{
  "id": "35c08a76-e63e-4b00-bb0d-0094596372fc",
  "title": "Material 3 Expressive Design: A New Era Part 2",
  "link": "https://proandroiddev.com/material-3-expressive-design-a-new-era-part-2-6a93483c98b0?source=rss----c72404660798---4",
  "description": "",
  "author": "Stefano Natali",
  "published": "Wed, 04 Jun 2025 15:01:13 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "material-3-expressive",
    "android-app-development",
    "jetpack-compose",
    "material3"
  ],
  "byline": "Stefano Natali",
  "length": 19882,
  "excerpt": "Material Design, continues to evolve, with its latest iteration, Material 3, introducing the concept of “Expressive Design”. As discussed in the first part of this series, expressive design aims to…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Material 3 Expressive Design: A New Era Part 2Transform Android UI with Toolbars, FlexibleBottomAppBar and FloatingActionButtonMenuGenerated by gemini.google.comMaterial Design, continues to evolve, with its latest iteration, Material 3, introducing the concept of “Expressive Design”. As discussed in the first part of this series, expressive design aims to infuse UIs with a more human touch, leveraging richer color palettes, diverse shapes, size variations, fluid animations, and strategic container usage to create intuitive and delightful user experiences.In the first article of this series, we explored how Material 3 enhances Android UI through new components like LoadingIndicator, SplitButtonLayout, and ButtonGroup. Now, in Part 2, we’ll dive into two more powerful elements that embody Expressive Design: Toolbars, FlexibleBottomAppBar and the FloatingActionButtonMenu. These components are crucial for navigation, contextual actions, and adding a layer of visual sophistication to your Android applications. All the examples discussed here are available in my GitHub repository.Getting Started with DependenciesTo ensure you can leverage these latest Material 3 features, verify that your project’s gradle file is updated with the necessary dependencies, similar to how we updated the material3 version in the previous article:[versions]material3 = \"1.4.0-alpha14\"[libraries]androidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\", version.ref = \"material3\"ToolbarsToolbars, in Material Design 3, are fundamental components of an Android application's UI. They serve as a consistent area for branding, navigation, and key actions. The new toolbars are no longer just functional, they are designed to be more expressive, adapting dynamically to content and user interaction.Material 3 introduces a range of toolbars composables, each offering distinct visual characteristics and behaviors that align with Expressive Design principles. We will see one by one the new possibilities.VerticalFloatingToolbar (Expandible)Material 3 introduces the concept of a VerticalFloatingToolbar. This component is a highly expressive and adaptable toolbar that can be positioned vertically, typically on the side of the screen. Its \"expandable\" nature allows it to dynamically show or hide content based on user interaction or scroll behavior, providing a clean UI when collapsed and rich functionality when expanded. This makes it ideal for contextual actions or secondary navigation that doesn't need to be persistently visible.@OptIn(ExperimentalMaterial3ExpressiveApi::class)@Preview@Composablefun ExpandableVerticalFloatingToolbarSample() { var expanded by rememberSaveable { mutableStateOf(true) } Scaffold( content = { innerPadding -\u003e Box(Modifier.padding(innerPadding)) { LazyColumn( modifier = Modifier.floatingToolbarVerticalNestedScroll( expanded = expanded, onExpand = { expanded = true }, onCollapse = { expanded = false }, ), state = rememberLazyListState(), contentPadding = innerPadding, verticalArrangement = Arrangement.spacedBy(8.dp) ) { val list = (0..75).map { it.toString() } items(count = list.size) { Text( text = list[it], style = MaterialTheme.typography.bodyLarge, modifier = Modifier .fillMaxWidth() .padding(horizontal = 16.dp) ) } } VerticalFloatingToolbar( modifier = Modifier .align(Alignment.CenterEnd) .offset(x = -ScreenOffset), expanded = expanded, leadingContent = { IconButton( onClick = {} ) { Icon( imageVector = Icons.Filled.MoreVert, contentDescription = null ) } }, trailingContent = { AppBarColumn( overflowIndicator = { menuState -\u003e IconButton( onClick = { if (menuState.isExpanded) { menuState.dismiss() } else { menuState.show() } } ) { Icon( imageVector = Icons.Filled.MoreVert, contentDescription = \"\" ) } } ) { clickableItem( onClick = {}, icon = { Icon( Icons.Filled.Download, contentDescription = \"\" ) }, label = \"Download\" ) clickableItem( onClick = {}, icon = { Icon( Icons.Filled.Settings, contentDescription = \"\" ) }, label = \"Settings\" ) } }, content = { FilledIconButton( modifier = Modifier.height(64.dp), onClick = { } ) { Icon(Icons.Filled.Add, contentDescription = null) } }, ) } } )}HorizontalFloatingToolbar (wih FAB)The HorizontalFloatingToolbar offers another expressive way to present actions, typically positioned at the bottom of the screen. The HorizontalFloatingToolbar float above content and often integrates seamlessly with a FloatingActionButton (FAB), providing a central primary action alongside a set of related secondary actions. This combination creates a visually appealing and highly functional component that responds to user interaction.@OptIn(ExperimentalMaterial3ExpressiveApi::class)@Preview@Composablefun OverflowingHorizontalFloatingToolbarSample() { Scaffold( content = { innerPadding -\u003e Box(Modifier.padding(innerPadding)) { LazyColumn( state = rememberLazyListState(), contentPadding = innerPadding, verticalArrangement = Arrangement.spacedBy(8.dp) ) { val list = (0..75).map { it.toString() } items(count = list.size) { Text( text = list[it], style = MaterialTheme.typography.bodyLarge, modifier = Modifier .fillMaxWidth() .padding(horizontal = 16.dp) ) } } HorizontalFloatingToolbar( modifier = Modifier .align(Alignment.BottomCenter) .offset(y = -ScreenOffset), expanded = true, floatingActionButton = { FloatingToolbarDefaults.VibrantFloatingActionButton( onClick = { /* */ }, ) { Icon(Icons.Filled.Add, contentDescription = null) } }, content = { FilledIconButton( modifier = Modifier.width(64.dp), onClick = { /* doSomething() */ } ) { Icon(Icons.Filled.Add, contentDescription = null) } IconButton( onClick = {} ) { Icon( imageVector = Icons.Filled.MoreVert, contentDescription = null ) } IconButton( onClick = {} ) { Icon( imageVector = Icons.Filled.Settings, contentDescription = null ) } } ) } } )}HorizontalFloatingToolbar (as Scaffold Fab)Another nice way to use the HorizontalFloatingToolbar is to integrate it directly as the floatingActionButton of a Scaffold. This approach allows the toolbar to leverage Scaffold’s built-in positioning and behavior for the FAB, making it a cohesive part of the overall screen layout. It's particularly useful when you want a set of actions that are always accessible at the bottom of the screen, potentially expanding and collapsing based on user interaction or scroll. Here’s an example demonstrating HorizontalFloatingToolbar used as a Scaffold FAB:@OptIn(ExperimentalMaterial3ExpressiveApi::class)@Preview@Composablefun HorizontalFloatingToolbarAsScaffoldFabSample() { var expanded by rememberSaveable { mutableStateOf(true) } val vibrantColors = FloatingToolbarDefaults.vibrantFloatingToolbarColors() Scaffold( floatingActionButton = { HorizontalFloatingToolbar( expanded = expanded, floatingActionButton = { FloatingToolbarDefaults.VibrantFloatingActionButton( onClick = { expanded = !expanded } ) { Icon(Icons.Filled.Add, null) } }, colors = vibrantColors, content = { IconButton(onClick = {}) { Icon(Icons.Filled.Person, contentDescription = null) } IconButton(onClick = {}) { Icon(Icons.Filled.Edit, contentDescription = null) } IconButton(onClick = {}) { Icon(Icons.Filled.Favorite, contentDescription = null) } IconButton(onClick = {}) { Icon(Icons.Filled.MoreVert, contentDescription = null) } }, ) }, floatingActionButtonPosition = FabPosition.End, ) { innerPadding -\u003e Box(Modifier.padding(innerPadding)) { Column( Modifier .fillMaxWidth() .padding(horizontal = 16.dp) .then( Modifier.floatingToolbarVerticalNestedScroll( expanded = expanded, onExpand = { expanded = true }, onCollapse = { expanded = false }, ) ) .verticalScroll(rememberScrollState()) ) { Text(text = remember { LoremIpsum().values.first() }) } } }}FlexibleBottomAppBarLet’s move to another type of component. The FlexibleBottomAppBar is a new Material 3 component that provides a highly adaptable bottom app bar. Unlike traditional fixed bottom app bars, the FlexibleBottomAppBar can dynamically adjust its layout and visibility based on scroll behavior, offering a more expressive and less intrusive navigation and action area. It's particularly useful for applications that require a dynamic bottom bar that can adapt to content scrolling, providing a fluid and engaging user experience. Here’s an example demonstrating a FlexibleBottomAppBar with exitAlwaysScrollBehavior:@OptIn(ExperimentalMaterial3ExpressiveApi::class, ExperimentalMaterial3Api::class)@Preview@Composablefun ExitAlwaysBottomAppBarFixedVibrant() { val scrollBehavior = BottomAppBarDefaults.exitAlwaysScrollBehavior() Scaffold( modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection), bottomBar = { FlexibleBottomAppBar( horizontalArrangement = BottomAppBarDefaults.FlexibleFixedHorizontalArrangement, scrollBehavior = scrollBehavior, containerColor = MaterialTheme.colorScheme.primaryContainer, content = { IconButton(onClick = { }) { Icon( Icons.AutoMirrored.Filled.ArrowBack, contentDescription = null ) } IconButton(onClick = { }) { Icon( Icons.AutoMirrored.Filled.ArrowForward, contentDescription = null ) } FilledIconButton( modifier = Modifier.width(56.dp), onClick = { } ) { Icon(Icons.Filled.Add, contentDescription = null) } IconButton(onClick = { }) { Icon(Icons.Filled.Check, contentDescription = null) } IconButton(onClick = { }) { Icon(Icons.Filled.Edit, contentDescription = null) } } ) }, content = { innerPadding -\u003e LazyColumn( contentPadding = innerPadding, verticalArrangement = Arrangement.spacedBy(8.dp) ) { val list = (0..75).map { it.toString() } items(count = list.size) { Text( text = list[it], style = MaterialTheme.typography.bodyLarge, modifier = Modifier .fillMaxWidth() .padding(horizontal = 16.dp) ) } } } )}FloatingActionButtonMenuLast, but not less important component for today, is the FloatingActionButtonMenu. It is a powerful Material 3 component that transforms a single FloatingActionButton (FAB) into an expandable menu, revealing a set of related, secondary actions. This pattern is particularly expressive as it provides contextual relevance and enhances user delight through subtle animations and organized actions. It's a more integrated and visually appealing solution compared to a simple expanding FAB, as it's designed specifically for this purpose within the Material 3 expressive design framework.Here’s an example demonstrating a FloatingActionButtonMenu:@OptIn(ExperimentalMaterial3ExpressiveApi::class)@Preview(showBackground = true)@Composablefun MyFloatingActionButtonMenu() { Box(Modifier.fillMaxSize()) { val items = listOf( Icons.AutoMirrored.Filled.Message to \"Reply\", Icons.Filled.People to \"Reply all\", Icons.Filled.Contacts to \"Forward\", Icons.Filled.Snooze to \"Snooze\", Icons.Filled.Archive to \"Archive\", Icons.AutoMirrored.Filled.Label to \"Label\", ) var fabMenuExpanded by rememberSaveable { mutableStateOf(false) } FloatingActionButtonMenu( modifier = Modifier.align(Alignment.BottomEnd), expanded = fabMenuExpanded, button = { ToggleFloatingActionButton( modifier = Modifier .semantics { traversalIndex = -1f stateDescription = if (fabMenuExpanded) \"Expanded\" else \"Collapsed\" contentDescription = \"Toggle menu\" } .animateFloatingActionButton( visible = true, alignment = Alignment.BottomEnd ), checked = fabMenuExpanded, onCheckedChange = { fabMenuExpanded = !fabMenuExpanded }) { val imageVector by remember { derivedStateOf { if (checkedProgress \u003e 0.5f) Icons.Filled.Close else Icons.Filled.Add } } Icon( painter = rememberVectorPainter(imageVector), contentDescription = null, modifier = Modifier.animateIcon({ checkedProgress }) ) } }) { items.forEachIndexed { i, item -\u003e FloatingActionButtonMenuItem( modifier = Modifier.semantics { isTraversalGroup = true if (i == items.size - 1) { customActions = listOf( CustomAccessibilityAction( label = \"Close menu\", action = { fabMenuExpanded = false true }) ) } }, onClick = { fabMenuExpanded = false }, icon = { Icon(item.first, contentDescription = null) }, text = { Text(text = item.second) }, ) } } }}ConclusionMaterial 3’s Expressive Design paradigm is fundamentally about creating Android UIs that are more intuitive, engaging, and reflective of a user’s personal style. By embracing dynamic colors, adaptive shapes, and fluid animations, Material 3 empowers developers to craft experiences that go beyond mere utility.The components explored in this article: the VerticalFloatingToolbar, HorizontalFloatingToolbar (both with and as a Scaffold FAB), FlexibleBottomAppBar, and the FloatingActionButtonMenu are prime examples of this evolution. They offer dynamic adaptability, visual prominence, and provide clean yet expressive ways to manage contextual actions. These, alongside the LoadingIndicator, SplitButtonLayout, and ButtonGroup discussed in Part 1, provide a robust toolkit for building enhanced user experiences.As developers, integrating these Material 3 features will enable us to design applications that are not only visually appealing but also more user-friendly and effective. The journey into Expressive Design is about crafting UIs that feel natural and responsive.If you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on Bluesky or LinkedIn for further discussions.Have a great day, and happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*8UqqyiP16Wl8SOY6lbUKjg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"b1da\" data-testid=\"storyTitle\"\u003eMaterial 3 Expressive Design: A New Era Part 2\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"aae9\"\u003eTransform Android UI with Toolbars, \u003cstrong\u003eFlexibleBottomAppBar\u003c/strong\u003e and \u003cem\u003eFloatingActionButtonMenu\u003c/em\u003e\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@stefanoq21?source=post_page---byline--6a93483c98b0---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Stefano Natali\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*nJT9nmRwE28kmJAEiRyHMw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated by gemini.google.com\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"de95\"\u003e\u003cstrong\u003eMaterial Design\u003c/strong\u003e, continues to evolve, with its latest iteration, \u003cstrong\u003eMaterial 3\u003c/strong\u003e, introducing the concept of “\u003cstrong\u003eExpressive Design\u003c/strong\u003e”. As discussed in the \u003ca href=\"https://medium.com/proandroiddev/material-3-expressive-design-a-new-era-9ea77959a262\" rel=\"noopener\"\u003e\u003cstrong\u003efirst part of this series\u003c/strong\u003e\u003c/a\u003e, expressive design aims to infuse UIs with a more human touch, leveraging richer color palettes, diverse shapes, size variations, fluid animations, and strategic container usage to create intuitive and delightful user experiences.\u003c/p\u003e\u003cp id=\"3c29\"\u003eIn the \u003ca href=\"https://medium.com/proandroiddev/material-3-expressive-design-a-new-era-9ea77959a262\" rel=\"noopener\"\u003efirst article\u003c/a\u003e of this series, we explored how Material 3 enhances Android UI through new components like \u003cstrong\u003eLoadingIndicator\u003c/strong\u003e, \u003cstrong\u003eSplitButtonLayout\u003c/strong\u003e, and \u003cstrong\u003eButtonGroup\u003c/strong\u003e. Now, in Part 2, we’ll dive into two more powerful elements that embody Expressive Design: \u003cstrong\u003eToolbars\u003c/strong\u003e, \u003cstrong\u003eFlexibleBottomAppBar \u003c/strong\u003eand the \u003cstrong\u003eFloatingActionButtonMenu\u003c/strong\u003e. These components are crucial for navigation, contextual actions, and adding a layer of visual sophistication to your Android applications. All the examples discussed here are available in my \u003ca href=\"https://github.com/stefanoq21/ComposePlayground\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGitHub repository\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"a38f\"\u003eGetting Started with Dependencies\u003c/h2\u003e\u003cp id=\"f1ed\"\u003eTo ensure you can leverage these latest Material 3 features, verify that your project’s \u003cstrong\u003egradle \u003c/strong\u003efile is updated with the necessary dependencies, similar to how we updated the \u003cstrong\u003ematerial3\u003c/strong\u003e version in the previous article:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cd2d\"\u003e[versions]\u003cbr/\u003ematerial3 = \u0026#34;1.4.0-alpha14\u0026#34;\u003cbr/\u003e[libraries]\u003cbr/\u003eandroidx-material3 = { group = \u0026#34;androidx.compose.material3\u0026#34;, name = \u0026#34;material3\u0026#34;, version.ref = \u0026#34;material3\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8b98\"\u003eToolbars\u003c/h2\u003e\u003cp id=\"0752\"\u003eToolbars, in Material Design 3, are fundamental components of an Android application\u0026#39;s UI. They serve as a consistent area for branding, navigation, and key actions. The new toolbars are no longer just functional, they are designed to be more expressive, adapting dynamically to content and user interaction.\u003c/p\u003e\u003cp id=\"5a29\"\u003eMaterial 3 introduces a range of toolbars composables, each offering distinct visual characteristics and behaviors that align with Expressive Design principles. We will see one by one the new possibilities.\u003c/p\u003e\u003ch2 id=\"24ca\"\u003eVerticalFloatingToolbar (Expandible)\u003c/h2\u003e\u003cp id=\"9e68\"\u003e\u003cstrong\u003eMaterial 3\u003c/strong\u003e introduces the concept of a \u003cstrong\u003eVerticalFloatingToolbar\u003c/strong\u003e. This component is a highly expressive and adaptable toolbar that can be positioned vertically, typically on the side of the screen. Its \u0026#34;\u003cstrong\u003eexpandable\u003c/strong\u003e\u0026#34; nature allows it to dynamically show or hide content based on user interaction or scroll behavior, providing a clean UI when collapsed and rich functionality when expanded. This makes it ideal for contextual actions or secondary navigation that doesn\u0026#39;t need to be persistently visible.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"68af\"\u003e\u003cbr/\u003e@OptIn(ExperimentalMaterial3ExpressiveApi::class)\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun ExpandableVerticalFloatingToolbarSample() {\u003cbr/\u003e    var expanded by rememberSaveable { mutableStateOf(true) }\u003cbr/\u003e    Scaffold(\u003cbr/\u003e        content = { innerPadding -\u0026gt;\u003cbr/\u003e            Box(Modifier.padding(innerPadding)) {\u003cbr/\u003e                LazyColumn(\u003cbr/\u003e                    modifier =\u003cbr/\u003e                        Modifier.floatingToolbarVerticalNestedScroll(\u003cbr/\u003e                            expanded = expanded,\u003cbr/\u003e                            onExpand = { expanded = true },\u003cbr/\u003e                            onCollapse = { expanded = false },\u003cbr/\u003e                        ),\u003cbr/\u003e                    state = rememberLazyListState(),\u003cbr/\u003e                    contentPadding = innerPadding,\u003cbr/\u003e                    verticalArrangement = Arrangement.spacedBy(8.dp)\u003cbr/\u003e                ) {\u003cbr/\u003e                    val list = (0..75).map { it.toString() }\u003cbr/\u003e                    items(count = list.size) {\u003cbr/\u003e                        Text(\u003cbr/\u003e                            text = list[it],\u003cbr/\u003e                            style = MaterialTheme.typography.bodyLarge,\u003cbr/\u003e                            modifier = Modifier\u003cbr/\u003e                                .fillMaxWidth()\u003cbr/\u003e                                .padding(horizontal = 16.dp)\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e                VerticalFloatingToolbar(\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .align(Alignment.CenterEnd)\u003cbr/\u003e                        .offset(x = -ScreenOffset),\u003cbr/\u003e                    expanded = expanded,\u003cbr/\u003e                    leadingContent = {\u003cbr/\u003e                        IconButton(\u003cbr/\u003e                            onClick = {}\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(\u003cbr/\u003e                                imageVector = Icons.Filled.MoreVert,\u003cbr/\u003e                                contentDescription = null\u003cbr/\u003e                            )\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                    trailingContent = {\u003cbr/\u003e                        AppBarColumn(\u003cbr/\u003e                            overflowIndicator = { menuState -\u0026gt;\u003cbr/\u003e                                IconButton(\u003cbr/\u003e                                    onClick = {\u003cbr/\u003e                                        if (menuState.isExpanded) {\u003cbr/\u003e                                            menuState.dismiss()\u003cbr/\u003e                                        } else {\u003cbr/\u003e                                            menuState.show()\u003cbr/\u003e                                        }\u003cbr/\u003e                                    }\u003cbr/\u003e                                ) {\u003cbr/\u003e                                    Icon(\u003cbr/\u003e                                        imageVector = Icons.Filled.MoreVert,\u003cbr/\u003e                                        contentDescription = \u0026#34;\u0026#34;\u003cbr/\u003e                                    )\u003cbr/\u003e                                }\u003cbr/\u003e                            }\u003cbr/\u003e                        ) {\u003cbr/\u003e                            clickableItem(\u003cbr/\u003e                                onClick = {},\u003cbr/\u003e                                icon = {\u003cbr/\u003e                                    Icon(\u003cbr/\u003e                                        Icons.Filled.Download,\u003cbr/\u003e                                        contentDescription = \u0026#34;\u0026#34;\u003cbr/\u003e                                    )\u003cbr/\u003e                                },\u003cbr/\u003e                                label = \u0026#34;Download\u0026#34;\u003cbr/\u003e                            )\u003cp\u003e                            clickableItem(\u003cbr/\u003e                                onClick = {},\u003cbr/\u003e                                icon = {\u003cbr/\u003e                                    Icon(\u003cbr/\u003e                                        Icons.Filled.Settings,\u003cbr/\u003e                                        contentDescription = \u0026#34;\u0026#34;\u003cbr/\u003e                                    )\u003cbr/\u003e                                },\u003cbr/\u003e                                label = \u0026#34;Settings\u0026#34;\u003cbr/\u003e                            )\u003c/p\u003e\u003cp\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                    content = {\u003cbr/\u003e                        FilledIconButton(\u003cbr/\u003e                            modifier = Modifier.height(64.dp),\u003cbr/\u003e                            onClick = { }\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(Icons.Filled.Add, contentDescription = null)\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"045b\"\u003eHorizontalFloatingToolbar (wih FAB)\u003c/h2\u003e\u003cp id=\"d5a0\"\u003eThe \u003cstrong\u003eHorizontalFloatingToolbar \u003c/strong\u003eoffers another expressive way to present actions, typically positioned at the bottom of the screen. The \u003cstrong\u003eHorizontalFloatingToolbar\u003c/strong\u003e float above content and often integrates seamlessly with a \u003cstrong\u003eFloatingActionButton (FAB)\u003c/strong\u003e, providing a central primary action alongside a set of related secondary actions. This combination creates a visually appealing and highly functional component that responds to user interaction.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb02\"\u003e@OptIn(ExperimentalMaterial3ExpressiveApi::class)\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun OverflowingHorizontalFloatingToolbarSample() {\u003cbr/\u003e    Scaffold(\u003cbr/\u003e        content = { innerPadding -\u0026gt;\u003cbr/\u003e            Box(Modifier.padding(innerPadding)) {\u003cbr/\u003e                LazyColumn(\u003cbr/\u003e                    state = rememberLazyListState(),\u003cbr/\u003e                    contentPadding = innerPadding,\u003cbr/\u003e                    verticalArrangement = Arrangement.spacedBy(8.dp)\u003cbr/\u003e                ) {\u003cbr/\u003e                    val list = (0..75).map { it.toString() }\u003cbr/\u003e                    items(count = list.size) {\u003cbr/\u003e                        Text(\u003cbr/\u003e                            text = list[it],\u003cbr/\u003e                            style = MaterialTheme.typography.bodyLarge,\u003cbr/\u003e                            modifier = Modifier\u003cbr/\u003e                                .fillMaxWidth()\u003cbr/\u003e                                .padding(horizontal = 16.dp)\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e                HorizontalFloatingToolbar(\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .align(Alignment.BottomCenter)\u003cbr/\u003e                        .offset(y = -ScreenOffset),\u003cbr/\u003e                    expanded = true,\u003cbr/\u003e                    floatingActionButton = {\u003cbr/\u003e                        FloatingToolbarDefaults.VibrantFloatingActionButton(\u003cbr/\u003e                            onClick = { /* */ },\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(Icons.Filled.Add, contentDescription = null)\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                    content = {\u003cbr/\u003e                        FilledIconButton(\u003cbr/\u003e                            modifier = Modifier.width(64.dp),\u003cbr/\u003e                            onClick = { /* doSomething() */ }\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(Icons.Filled.Add, contentDescription = null)\u003cbr/\u003e                        }\u003cbr/\u003e                        IconButton(\u003cbr/\u003e                            onClick = {}\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(\u003cbr/\u003e                                imageVector = Icons.Filled.MoreVert,\u003cbr/\u003e                                contentDescription = null\u003cbr/\u003e                            )\u003cbr/\u003e                        }\u003cbr/\u003e                        IconButton(\u003cbr/\u003e                            onClick = {}\u003cbr/\u003e                        ) {\u003cbr/\u003e                            Icon(\u003cbr/\u003e                                imageVector = Icons.Filled.Settings,\u003cbr/\u003e                                contentDescription = null\u003cbr/\u003e                            )\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2aab\"\u003eHorizontalFloatingToolbar (as Scaffold Fab)\u003c/h2\u003e\u003cp id=\"5025\"\u003eAnother nice way to use the \u003cstrong\u003eHorizontalFloatingToolbar\u003c/strong\u003e is to integrate it directly as the \u003cstrong\u003efloatingActionButton \u003c/strong\u003eof a \u003cstrong\u003eScaffold\u003c/strong\u003e. This approach allows the toolbar to leverage \u003cstrong\u003eScaffold’s \u003c/strong\u003ebuilt-in positioning and behavior for the FAB, making it a cohesive part of the overall screen layout. It\u0026#39;s particularly useful when you want a set of actions that are always accessible at the bottom of the screen, potentially expanding and collapsing based on user interaction or scroll. Here’s an example demonstrating \u003cstrong\u003eHorizontalFloatingToolbar \u003c/strong\u003eused as a \u003cstrong\u003eScaffold FAB\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8d8e\"\u003e@OptIn(ExperimentalMaterial3ExpressiveApi::class)\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun HorizontalFloatingToolbarAsScaffoldFabSample() {\u003cbr/\u003e    var expanded by rememberSaveable { mutableStateOf(true) }\u003cbr/\u003e    val vibrantColors = FloatingToolbarDefaults.vibrantFloatingToolbarColors()\u003cbr/\u003e    Scaffold(\u003cbr/\u003e        floatingActionButton = {\u003cbr/\u003e            HorizontalFloatingToolbar(\u003cbr/\u003e                expanded = expanded,\u003cbr/\u003e                floatingActionButton = {\u003cbr/\u003e                    FloatingToolbarDefaults.VibrantFloatingActionButton(\u003cbr/\u003e                        onClick = { expanded = !expanded }\u003cbr/\u003e                    ) {\u003cbr/\u003e                        Icon(Icons.Filled.Add, null)\u003cbr/\u003e                    }\u003cbr/\u003e                },\u003cbr/\u003e                colors = vibrantColors,\u003cbr/\u003e                content = {\u003cbr/\u003e                    IconButton(onClick = {}) {\u003cbr/\u003e                        Icon(Icons.Filled.Person, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = {}) {\u003cbr/\u003e                        Icon(Icons.Filled.Edit, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = {}) {\u003cbr/\u003e                        Icon(Icons.Filled.Favorite, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = {}) {\u003cbr/\u003e                        Icon(Icons.Filled.MoreVert, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                },\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        floatingActionButtonPosition = FabPosition.End,\u003cbr/\u003e    ) { innerPadding -\u0026gt;\u003cbr/\u003e        Box(Modifier.padding(innerPadding)) {\u003cbr/\u003e            Column(\u003cbr/\u003e                Modifier\u003cbr/\u003e                    .fillMaxWidth()\u003cbr/\u003e                    .padding(horizontal = 16.dp)\u003cbr/\u003e                    .then(\u003cbr/\u003e                        Modifier.floatingToolbarVerticalNestedScroll(\u003cbr/\u003e                            expanded = expanded,\u003cbr/\u003e                            onExpand = { expanded = true },\u003cbr/\u003e                            onCollapse = { expanded = false },\u003cbr/\u003e                        )\u003cbr/\u003e                    )\u003cbr/\u003e                    .verticalScroll(rememberScrollState())\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(text = remember { LoremIpsum().values.first() })\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"dc25\"\u003eFlexibleBottomAppBar\u003c/h2\u003e\u003cp id=\"b6ad\"\u003eLet’s move to another type of component. The \u003cstrong\u003eFlexibleBottomAppBar\u003c/strong\u003e is a new Material 3 component that provides a highly adaptable bottom app bar. Unlike traditional fixed bottom app bars, the \u003cstrong\u003eFlexibleBottomAppBar \u003c/strong\u003ecan dynamically adjust its layout and visibility based on scroll behavior, offering a more expressive and less intrusive navigation and action area. It\u0026#39;s particularly useful for applications that require a dynamic bottom bar that can adapt to content scrolling, providing a fluid and engaging user experience. Here’s an example demonstrating a \u003cstrong\u003eFlexibleBottomAppBar \u003c/strong\u003ewith \u003cstrong\u003eexitAlwaysScrollBehavior\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bc1b\"\u003e@OptIn(ExperimentalMaterial3ExpressiveApi::class, ExperimentalMaterial3Api::class)\u003cbr/\u003e@Preview\u003cbr/\u003e@Composable\u003cbr/\u003efun ExitAlwaysBottomAppBarFixedVibrant() {\u003cbr/\u003e    val scrollBehavior = BottomAppBarDefaults.exitAlwaysScrollBehavior()\u003cbr/\u003e    Scaffold(\u003cbr/\u003e        modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),\u003cbr/\u003e        bottomBar = {\u003cbr/\u003e            FlexibleBottomAppBar(\u003cbr/\u003e                horizontalArrangement = BottomAppBarDefaults.FlexibleFixedHorizontalArrangement,\u003cbr/\u003e                scrollBehavior = scrollBehavior,\u003cbr/\u003e                containerColor =\u003cbr/\u003e                    MaterialTheme.colorScheme.primaryContainer,\u003cbr/\u003e                content = {\u003cbr/\u003e                    IconButton(onClick = { }) {\u003cbr/\u003e                        Icon(\u003cbr/\u003e                            Icons.AutoMirrored.Filled.ArrowBack,\u003cbr/\u003e                            contentDescription = null\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = { }) {\u003cbr/\u003e                        Icon(\u003cbr/\u003e                            Icons.AutoMirrored.Filled.ArrowForward,\u003cbr/\u003e                            contentDescription = null\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                    FilledIconButton(\u003cbr/\u003e                        modifier = Modifier.width(56.dp),\u003cbr/\u003e                        onClick = { }\u003cbr/\u003e                    ) {\u003cbr/\u003e                        Icon(Icons.Filled.Add, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = { }) {\u003cbr/\u003e                        Icon(Icons.Filled.Check, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                    IconButton(onClick = { }) {\u003cbr/\u003e                        Icon(Icons.Filled.Edit, contentDescription = null)\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        content = { innerPadding -\u0026gt;\u003cbr/\u003e            LazyColumn(\u003cbr/\u003e                contentPadding = innerPadding,\u003cbr/\u003e                verticalArrangement = Arrangement.spacedBy(8.dp)\u003cbr/\u003e            ) {\u003cbr/\u003e                val list = (0..75).map { it.toString() }\u003cbr/\u003e                items(count = list.size) {\u003cbr/\u003e                    Text(\u003cbr/\u003e                        text = list[it],\u003cbr/\u003e                        style = MaterialTheme.typography.bodyLarge,\u003cbr/\u003e                        modifier = Modifier\u003cbr/\u003e                            .fillMaxWidth()\u003cbr/\u003e                            .padding(horizontal = 16.dp)\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"8089\"\u003eFloatingActionButtonMenu\u003c/h2\u003e\u003cp id=\"5bc9\"\u003eLast, but not less important component for today, is the \u003cstrong\u003eFloatingActionButtonMenu.\u003c/strong\u003e It\u003cstrong\u003e \u003c/strong\u003eis a powerful Material 3 component that transforms a single \u003cstrong\u003eFloatingActionButton \u003c/strong\u003e(FAB) into an expandable menu, revealing a set of related, secondary actions. This pattern is particularly expressive as it provides contextual relevance and enhances user delight through subtle animations and organized actions. It\u0026#39;s a more integrated and visually appealing solution compared to a simple expanding FAB, as it\u0026#39;s designed specifically for this purpose within the \u003cstrong\u003eMaterial 3 expressive design\u003c/strong\u003e framework.\u003c/p\u003e\u003cp id=\"00e1\"\u003eHere’s an example demonstrating a \u003cstrong\u003eFloatingActionButtonMenu\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9f5a\"\u003e@OptIn(ExperimentalMaterial3ExpressiveApi::class)\u003cbr/\u003e@Preview(showBackground = true)\u003cbr/\u003e@Composable\u003cbr/\u003efun MyFloatingActionButtonMenu() {\u003cbr/\u003e    Box(Modifier.fillMaxSize()) {\u003cp\u003e        val items = listOf(\u003cbr/\u003e            Icons.AutoMirrored.Filled.Message to \u0026#34;Reply\u0026#34;,\u003cbr/\u003e            Icons.Filled.People to \u0026#34;Reply all\u0026#34;,\u003cbr/\u003e            Icons.Filled.Contacts to \u0026#34;Forward\u0026#34;,\u003cbr/\u003e            Icons.Filled.Snooze to \u0026#34;Snooze\u0026#34;,\u003cbr/\u003e            Icons.Filled.Archive to \u0026#34;Archive\u0026#34;,\u003cbr/\u003e            Icons.AutoMirrored.Filled.Label to \u0026#34;Label\u0026#34;,\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        var fabMenuExpanded by rememberSaveable { mutableStateOf(false) }\u003c/p\u003e\u003cp\u003e        FloatingActionButtonMenu(\u003cbr/\u003e            modifier = Modifier.align(Alignment.BottomEnd), expanded = fabMenuExpanded, button = {\u003cbr/\u003e                ToggleFloatingActionButton(\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .semantics {\u003cbr/\u003e                            traversalIndex = -1f\u003cbr/\u003e                            stateDescription = if (fabMenuExpanded) \u0026#34;Expanded\u0026#34; else \u0026#34;Collapsed\u0026#34;\u003cbr/\u003e                            contentDescription = \u0026#34;Toggle menu\u0026#34;\u003cbr/\u003e                        }\u003cbr/\u003e                        .animateFloatingActionButton(\u003cbr/\u003e                            visible = true, alignment = Alignment.BottomEnd\u003cbr/\u003e                        ),\u003cbr/\u003e                    checked = fabMenuExpanded,\u003cbr/\u003e                    onCheckedChange = { fabMenuExpanded = !fabMenuExpanded }) {\u003cbr/\u003e                    val imageVector by remember {\u003cbr/\u003e                        derivedStateOf {\u003cbr/\u003e                            if (checkedProgress \u0026gt; 0.5f) Icons.Filled.Close else Icons.Filled.Add\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                    Icon(\u003cbr/\u003e                        painter = rememberVectorPainter(imageVector),\u003cbr/\u003e                        contentDescription = null,\u003cbr/\u003e                        modifier = Modifier.animateIcon({ checkedProgress })\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }) {\u003cbr/\u003e            items.forEachIndexed { i, item -\u0026gt;\u003cbr/\u003e                FloatingActionButtonMenuItem(\u003cbr/\u003e                    modifier = Modifier.semantics {\u003cbr/\u003e                        isTraversalGroup = true\u003cbr/\u003e                        if (i == items.size - 1) {\u003cbr/\u003e                            customActions = listOf(\u003cbr/\u003e                                CustomAccessibilityAction(\u003cbr/\u003e                                    label = \u0026#34;Close menu\u0026#34;, action = {\u003cbr/\u003e                                        fabMenuExpanded = false\u003cbr/\u003e                                        true\u003cbr/\u003e                                    })\u003cbr/\u003e                            )\u003cbr/\u003e                        }\u003cbr/\u003e                    },\u003cbr/\u003e                    onClick = { fabMenuExpanded = false },\u003cbr/\u003e                    icon = { Icon(item.first, contentDescription = null) },\u003cbr/\u003e                    text = { Text(text = item.second) },\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3a51\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"3290\"\u003e\u003cstrong\u003eMaterial 3’s Expressive Design\u003c/strong\u003e paradigm is fundamentally about creating Android UIs that are more intuitive, engaging, and reflective of a user’s personal style. By embracing dynamic colors, adaptive shapes, and fluid animations, Material 3 empowers developers to craft experiences that go beyond mere utility.\u003c/p\u003e\u003cp id=\"94b4\"\u003eThe components explored in this article: the \u003cstrong\u003eVerticalFloatingToolbar\u003c/strong\u003e, \u003cstrong\u003eHorizontalFloatingToolbar\u003c/strong\u003e (both with and as a Scaffold FAB), \u003cstrong\u003eFlexibleBottomAppBar\u003c/strong\u003e, and the \u003cstrong\u003eFloatingActionButtonMenu\u003c/strong\u003e are prime examples of this evolution. They offer dynamic adaptability, visual prominence, and provide clean yet expressive ways to manage contextual actions. These, alongside the \u003cstrong\u003eLoadingIndicator\u003c/strong\u003e, \u003cstrong\u003eSplitButtonLayout\u003c/strong\u003e, and \u003cstrong\u003eButtonGroup\u003c/strong\u003e discussed in \u003ca href=\"https://medium.com/proandroiddev/material-3-expressive-design-a-new-era-9ea77959a262\" rel=\"noopener\"\u003e\u003cstrong\u003ePart 1\u003c/strong\u003e\u003c/a\u003e, provide a robust toolkit for building enhanced user experiences.\u003c/p\u003e\u003cp id=\"0c67\"\u003eAs developers, integrating these Material 3 features will enable us to design applications that are not only visually appealing but also more user-friendly and effective. The journey into Expressive Design is about crafting UIs that feel natural and responsive.\u003c/p\u003e\u003cp id=\"47ca\"\u003eIf you found this article interesting, feel free to follow me for more insightful content on Android development and Jetpack Compose. I regularly publish new articles on these topics. Don’t hesitate to share your comments or reach out to me on \u003ca href=\"https://bsky.app/profile/stefanoq21.bsky.social\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eBluesky\u003c/strong\u003e\u003c/a\u003e or \u003ca href=\"http://www.linkedin.com/in/stefano-natali-q21\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eLinkedIn\u003c/strong\u003e\u003c/a\u003e for further discussions.\u003c/p\u003e\u003cp id=\"efb4\"\u003eHave a great day, and happy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": "2025-06-02T10:31:14.329Z",
  "modifiedTime": null
}
