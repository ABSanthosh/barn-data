{
  "id": "b2ffb9b9-a8da-407a-9ca7-8921131c1033",
  "title": "The conflation problem of testing StateFlows",
  "link": "https://zsmb.co/conflating-stateflows/",
  "description": "StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.",
  "author": "Márton Braun",
  "published": "Tue, 15 Aug 2023 14:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 10654,
  "excerpt": "StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "StateFlow has a bit of a wave–particle duality. On one hand, it’s a data holder which holds a current value. On the other hand, it’s also a Flow, emitting the values it holds over time to its collectors. Importantly, as the type’s documentation states: Updates to the value are always conflated. So a slow collector skips fast updates, but always collects the most recently emitted value. This conflation means that depending on how “fast” the code setting values in the StateFlow and the code collecting values from it are relative to each other, the collector may or may not receive intermediate values when the StateFlow's value is rapidly updated multiple times. In production code, this generally shouldn’t cause any issues. The collector should not be affected by conflation happening or not happening. The end result - for example, what’s displayed on the UI - should remain the same. Testing, however, is a different story. Testing StateFlows There are two approaches for testing a StateFlow: you can either make assertions on its value property, or collect it as a Flow and assert on the values collected. This article assumes that you’re familiar with coroutine testing using the kotlinx-coroutines-test library. Generally speaking, it’s simpler to treat StateFlow as a state holder and make assertions on its value after performing actions in the test, as described in the Android documentation about testing StateFlows. However, there might be cases where this is not feasible to do, and you need to collect from a StateFlow in a test. For example, a single action on a class under test may trigger multiple value writes on the StateFlow, and you may want to assert on all intermediate values written (instead of just asserting on value once, after the last write). A typical case of this is testing a ViewModel function that first triggers a loading state and then replaces that with actual data (oversimplified pseudocode!): class MyViewModel(private val repo: Repo) : ViewModel() { val state: MutableStateFlow\u003cMyState\u003e = MutableStateFlow(Initial) fun initialize() { state.value = Loading state.value = Content(repo.getData()) } } In this specific example, you might be able to write a test which only reads the value property of the StateFlow, by injecting a fake repository implementation that lets us control when getData returns, giving us a chance to read state.value while it’s still in the loading state. However, it’s often not possible or too cumbersome to control the object under test this way. Experiencing conflation If you choose to test a StateFlow by collecting it, you’ll need to take conflation into account. When writing a test asserting on values collected from a StateFlow, you have to decide whether you expect to see all values without conflation, or to experience conflation and only see the most recent value after rapid updates. Let’s see what happens if you start two coroutines in a test using runTest, one collecting from the StateFlow and another setting values in it. In this case, they’ll be equally “fast”, as they’ll both inherit the StandardTestDispatcher from runTest. We’ll call the first coroutine the collecting coroutine, and the second coroutine the producing coroutine. @Test fun useStandardTestDispatcherForCollection() = runTest { val stateFlow = MutableStateFlow(0) // Collecting coroutine launch { val values = stateFlow.take(2).toList() assertEquals(listOf(0, 3), values) // Conflation happened } // Producing coroutine launch { stateFlow.value = 1 stateFlow.value = 2 stateFlow.value = 3 } } As they are launched on a StandardTestDispatcher, both coroutines here will first be queued up on the test scheduler. When runTest reaches the end of the lambda passed to it, it will start executing the tasks queued up on the scheduler. This starts the collecting coroutine first, which begins collecting the StateFlow. The StateFlow immediately emits its initial value, which is collected into the list. The collecting coroutine then suspends as toList waits for new values. This lets the second coroutine start, which sets the value of the StateFlow several times. Setting the value property of StateFlow is a regular property assignment, which is not a suspending call, however its implementation does resume any collecting coroutines. Though the collector is resumed, it’s on a StandardTestDispatcher and still needs a chance to dispatch in order to run its code, which it doesn’t get until the test thread is yielded. That only happens on the completion of the producing coroutine, after all three value writes are done. With the completion of the producing coroutine, the collector gets to execute, and receives only the latest value, which it places in the list. Conflation happened. Avoiding conflation Let’s see what you can do if you want to avoid conflation in our tests. Note that conflation is not inherently bad. However, it’s often undesirable in testing scenarios that want to verify all the behaviour of an object. Yielding manually For a simple approach, if you let go of the test thread after each value assignment - for example, using a simple yield() call - the collecting coroutine gets a chance to dispatch, and receives all four values, eliminating conflation: @Test fun yieldingExample() = runTest { val stateFlow = MutableStateFlow(0) launch { val values = stateFlow.take(4).toList() assertEquals(listOf(0, 1, 2, 3), values) // No conflation } launch { stateFlow.value = 1 yield() stateFlow.value = 2 yield() stateFlow.value = 3 } } This doesn’t scale very well, as it requires explicitly yielding the thread every time a new value is set in the StateFlow. To make things worse, in a real test this likely happens somewhere in code that’s called from the test, and not within the test itself. Modifying the scheduling behaviour of production code to make testing more convenient isn’t great. Collecting faster Alternatively, you can change how “fast” the collecting coroutine is, so that it can better keep up with new values being produced. In the next example, the collecting coroutine is created using an eager UnconfinedTestDispatcher while the producing coroutine keeps using the lazier StandardTestDispatcher. For an explanation of the scheduling of these two dispatchers, see the Android docs on TestDispatchers. @Test fun useUnconfinedTestDispatcherForCollection() = runTest { val stateFlow = MutableStateFlow(0) launch(UnconfinedTestDispatcher(testScheduler)) { val values = stateFlow.take(4).toList() assertEquals(listOf(0, 1, 2, 3), values) // No conflation } launch { stateFlow.value = 1 stateFlow.value = 2 stateFlow.value = 3 } } In this test, collection happens immediately whenever the assignment of value resumes the collecting coroutine, thanks to UnconfinedTestDispatcher which doesn’t require a dispatch before resuming execution. Conflation is gone! Using UnconfinedTestDispatcher for the collecting coroutine also has the added benefit that the collecting coroutine is launched eagerly. This means that by the time the first launch call of the test returns the first coroutine has already started executing, collected the initial value of the StateFlow, and is suspended waiting for new values to be produced. Using the Turbine library instead of collecting from the Flow yourself behaves the exact same way, as Turbine’s test function also uses UnconfinedTestDispatcher under the hood if you’re using it with runTest. @Test fun useTurbineForCollection() = runTest { val stateFlow = MutableStateFlow(0) launch { stateFlow.test { // No conflation assertEquals(0, awaitItem()) assertEquals(1, awaitItem()) assertEquals(2, awaitItem()) assertEquals(3, awaitItem()) } } launch { stateFlow.value = 1 stateFlow.value = 2 stateFlow.value = 3 } } Note that your collecting coroutine can only go faster if the producing coroutine is on a “slow” StandardTestDispatcher. If the producing coroutine runs on an UnconfinedTestDispatcher and does not yield the thread at any point, conflation makes a comeback, and you have no chance of seeing those intermediate values. Here’s an example demonstrating just that: @Test fun useUnconfinedTestDispatcherForCollectionAndProduction() = runTest { val stateFlow = MutableStateFlow(0) launch(UnconfinedTestDispatcher(testScheduler)) { val values = stateFlow.take(2).toList() assertEquals(listOf(0, 3), values) // Conflation happened } launch(UnconfinedTestDispatcher(testScheduler)) { stateFlow.value = 1 stateFlow.value = 2 stateFlow.value = 3 } } Conclusion When testing a StateFlow, you have two options: reading its value at various points during the test or collecting it as a Flow. The former is the easier path if your circumstances allow it. Otherwise, you’ll have to keep in mind that collectors of a StateFlow are affected by conflation. It’s up to you to decide whether you want values to be conflated or not during a test, and set up assertions accordingly. You can control whether conflation can happen by choosing the dispatchers your code executes on during tests. Using injected dispatchers that you can replace with appropriate TestDispatcher instances during tests is crucial for this. Finally, the only way your collecting coroutine can be “faster” than the producing coroutine and avoid conflation is if the collector is on an UnconfinedTestDispatcher while the producer is on a StandardTestDispatcher. Other cases—where the coroutines are equally fast or the collector is slower—will result in conflation. Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one.Fragments have... Complicated lifecycles, to say the least. Let's take a look at these, and how they all fit into the world of Jetpack today, with LifecycleOwners, LiveData, and coroutines.Retrofit's coroutine support has been a long time coming, and it's finally coming to completion. Take a look at how you can use it to neatly integrate networking into an application built with coroutines.",
  "image": "https://zsmb.co/images/conflating-stateflows/meta.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/\"\u003e\u003ccode\u003eStateFlow\u003c/code\u003e\u003c/a\u003e has a bit of a \u003ca href=\"https://en.wikipedia.org/wiki/Wave%E2%80%93particle_duality\"\u003ewave–particle duality\u003c/a\u003e. On one hand, it’s a data holder which holds a current value. On the other hand, it’s also a \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/\"\u003e\u003ccode\u003eFlow\u003c/code\u003e\u003c/a\u003e, emitting the values it holds over time to its collectors. Importantly, as the type’s documentation states:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUpdates to the value are always \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html\"\u003econflated\u003c/a\u003e. So a slow collector skips fast updates, but always collects the most recently emitted value.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis conflation means that depending on how “fast” the code setting values in the \u003ccode\u003eStateFlow\u003c/code\u003e and the code collecting values from it are relative to each other, the collector may or may not receive intermediate values when the \u003ccode\u003eStateFlow\u003c/code\u003e\u0026#39;s value is rapidly updated multiple times.\u003c/p\u003e\n\u003cp\u003eIn production code, this generally shouldn’t cause any issues. The collector should not be affected by conflation happening or not happening. The end result - for example, what’s displayed on the UI - should remain the same. Testing, however, is a different story.\u003c/p\u003e\n\u003ch3 id=\"testing-stateflows\"\u003eTesting StateFlows\u003c/h3\u003e\n\u003cp\u003eThere are two approaches for testing a \u003ccode\u003eStateFlow\u003c/code\u003e: you can either make assertions on its \u003ccode\u003evalue\u003c/code\u003e property, or collect it as a \u003ccode\u003eFlow\u003c/code\u003e and assert on the values collected.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis article assumes that you’re familiar with \u003ca href=\"https://developer.android.com/kotlin/coroutines/test\"\u003ecoroutine testing\u003c/a\u003e using the \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-test\"\u003ekotlinx-coroutines-test\u003c/a\u003e library.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGenerally speaking, it’s simpler to treat \u003ccode\u003eStateFlow\u003c/code\u003e as a state holder and make assertions on its \u003ccode\u003evalue\u003c/code\u003e after performing actions in the test, as described in the Android documentation about \u003ca href=\"https://developer.android.com/kotlin/flow/test#stateflows\"\u003etesting StateFlows\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, there might be cases where this is not feasible to do, and you need to collect from a \u003ccode\u003eStateFlow\u003c/code\u003e in a test. For example, a single action on a class under test may trigger multiple value writes on the \u003ccode\u003eStateFlow\u003c/code\u003e, and you may want to assert on all intermediate values written (instead of just asserting on \u003ccode\u003evalue\u003c/code\u003e once, after the last write).\u003c/p\u003e\n\u003cp\u003eA typical case of this is testing a ViewModel function that first triggers a loading state and then replaces that with actual data (oversimplified pseudocode!):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass MyViewModel(private val repo: Repo) : ViewModel() {\n    val state: MutableStateFlow\u0026lt;MyState\u0026gt; = MutableStateFlow(Initial)\n    \n    fun initialize() {\n        state.value = Loading\n        state.value = Content(repo.getData())\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn this specific example, you might be able to write a test which only reads the \u003ccode\u003evalue\u003c/code\u003e property of the \u003ccode\u003eStateFlow\u003c/code\u003e, by injecting a fake repository implementation that lets us control when \u003ccode\u003egetData\u003c/code\u003e returns, giving us a chance to read \u003ccode\u003estate.value\u003c/code\u003e while it’s still in the loading state. However, it’s often not possible or too cumbersome to control the object under test this way.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"experiencing-conflation\"\u003eExperiencing conflation\u003c/h3\u003e\n\u003cp\u003eIf you choose to test a \u003ccode\u003eStateFlow\u003c/code\u003e by collecting it, you’ll need to take conflation into account. When writing a test asserting on values collected from a \u003ccode\u003eStateFlow\u003c/code\u003e, you have to decide whether you expect to see all values without conflation, or to experience conflation and only see the most recent value after rapid updates.\u003c/p\u003e\n\u003cp\u003eLet’s see what happens if you start two coroutines in a test using \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html\"\u003e\u003ccode\u003erunTest\u003c/code\u003e\u003c/a\u003e, one collecting from the \u003ccode\u003eStateFlow\u003c/code\u003e and another setting values in it. In this case, they’ll be equally “fast”, as they’ll both inherit the \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e from \u003ccode\u003erunTest\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe’ll call the first coroutine the \u003cem\u003ecollecting\u003c/em\u003e coroutine, and the second coroutine the \u003cem\u003eproducing\u003c/em\u003e coroutine.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Test\nfun useStandardTestDispatcherForCollection() = runTest {\n    val stateFlow = MutableStateFlow(0)\n            \n    // Collecting coroutine\n    launch {\n        val values = stateFlow.take(2).toList()\n        assertEquals(listOf(0, 3), values) // Conflation happened\n    }\n\n    // Producing coroutine\n    launch {\n        stateFlow.value = 1\n        stateFlow.value = 2\n        stateFlow.value = 3\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs they are launched on a \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e, both coroutines here will first be queued up on the test scheduler. When \u003ccode\u003erunTest\u003c/code\u003e reaches the end of the lambda passed to it, it will start executing the tasks queued up on the scheduler.\u003c/p\u003e\n\u003cp\u003eThis starts the collecting coroutine first, which begins collecting the \u003ccode\u003eStateFlow\u003c/code\u003e. The \u003ccode\u003eStateFlow\u003c/code\u003e immediately emits its initial value, which is collected into the list. The collecting coroutine then suspends as \u003ccode\u003etoList\u003c/code\u003e waits for new values.\u003c/p\u003e\n\u003cp\u003eThis lets the second coroutine start, which sets the value of the \u003ccode\u003eStateFlow\u003c/code\u003e several times. Setting the \u003ccode\u003evalue\u003c/code\u003e property of \u003ccode\u003eStateFlow\u003c/code\u003e is a regular property assignment, which is not a suspending call, however its implementation does \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/1ccc96890d38be52d1bdcd31af5befb54804aa05/kotlinx-coroutines-core/common/src/flow/StateFlow.kt#L349\"\u003eresume any collecting coroutines\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThough the collector is resumed, it’s on a \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e and still needs a chance to dispatch in order to run its code, which it doesn’t get until the test thread is yielded. That only happens on the completion of the producing coroutine, after all three value writes are done.\u003c/p\u003e\n\u003cp\u003eWith the completion of the producing coroutine, the collector gets to execute, and receives only the latest value, which it places in the list. Conflation happened.\u003c/p\u003e\n\u003ch3 id=\"avoiding-conflation\"\u003eAvoiding conflation\u003c/h3\u003e\n\u003cp\u003eLet’s see what you can do if you want to avoid conflation in our tests.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that conflation is not inherently bad. However, it’s often undesirable in testing scenarios that want to verify all the behaviour of an object.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch5 id=\"yielding-manually\"\u003eYielding manually\u003c/h5\u003e\n\u003cp\u003eFor a simple approach, if you let go of the test thread after each value assignment - for example, using a simple \u003ccode\u003eyield()\u003c/code\u003e call - the collecting coroutine gets a chance to dispatch, and receives all four values, eliminating conflation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Test\nfun yieldingExample() = runTest {\n    val stateFlow = MutableStateFlow(0)\n\n    launch {\n        val values = stateFlow.take(4).toList()\n        assertEquals(listOf(0, 1, 2, 3), values) // No conflation\n    }\n\n    launch {\n        stateFlow.value = 1\n        yield()\n        stateFlow.value = 2\n        yield()\n        stateFlow.value = 3\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis doesn’t scale very well, as it requires explicitly yielding the thread every time a new value is set in the \u003ccode\u003eStateFlow\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo make things worse, in a real test this likely happens somewhere in code that’s called from the test, and not within the test itself. Modifying the scheduling behaviour of production code to make testing more convenient isn’t great.\u003c/p\u003e\n\u003ch5 id=\"collecting-faster\"\u003eCollecting faster\u003c/h5\u003e\n\u003cp\u003eAlternatively, you can change how “fast” the collecting coroutine is, so that it can better keep up with new values being produced. In the next example, the collecting coroutine is created using an eager \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e while the producing coroutine keeps using the lazier \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor an explanation of the scheduling of these two dispatchers, see the Android docs on \u003ca href=\"https://developer.android.com/kotlin/coroutines/test#testdispatchers\"\u003e\u003ccode\u003eTestDispatchers\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode\u003e@Test\nfun useUnconfinedTestDispatcherForCollection() = runTest {\n    val stateFlow = MutableStateFlow(0)\n\n    launch(UnconfinedTestDispatcher(testScheduler)) {\n        val values = stateFlow.take(4).toList()\n        assertEquals(listOf(0, 1, 2, 3), values) // No conflation\n    }\n\n    launch {\n        stateFlow.value = 1\n        stateFlow.value = 2\n        stateFlow.value = 3\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this test, collection happens immediately whenever the assignment of \u003ccode\u003evalue\u003c/code\u003e resumes the collecting coroutine, thanks to \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e which doesn’t require a dispatch before resuming execution. Conflation is gone!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUsing \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e for the collecting coroutine also has the added benefit that the collecting coroutine is launched eagerly. This means that by the time the first \u003ccode\u003elaunch\u003c/code\u003e call of the test returns the first coroutine has already started executing, collected the initial value of the \u003ccode\u003eStateFlow\u003c/code\u003e, and is suspended waiting for new values to be produced.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eUsing the \u003ca href=\"https://github.com/cashapp/turbine\"\u003eTurbine\u003c/a\u003e library instead of collecting from the Flow yourself behaves the exact same way, as Turbine’s \u003ca href=\"https://cashapp.github.io/turbine/docs/1.x/-turbine/app.cash.turbine/test.html\"\u003e\u003ccode\u003etest\u003c/code\u003e\u003c/a\u003e function also uses \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e under the hood if you’re using it with \u003ccode\u003erunTest\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Test\nfun useTurbineForCollection() = runTest {\n    val stateFlow = MutableStateFlow(0)\n\n    launch {\n        stateFlow.test { // No conflation\n            assertEquals(0, awaitItem())\n            assertEquals(1, awaitItem())\n            assertEquals(2, awaitItem())\n            assertEquals(3, awaitItem())\n        }\n    }\n\n    launch {\n        stateFlow.value = 1\n        stateFlow.value = 2\n        stateFlow.value = 3\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that your collecting coroutine can only go faster if the producing coroutine is on a “slow” \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e. If the producing coroutine runs on an \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e and does not yield the thread at any point, conflation makes a comeback, and you have no chance of seeing those intermediate values.\u003c/p\u003e\n\u003cp\u003eHere’s an example demonstrating just that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Test\nfun useUnconfinedTestDispatcherForCollectionAndProduction() = runTest {\n    val stateFlow = MutableStateFlow(0)\n\n    launch(UnconfinedTestDispatcher(testScheduler)) {\n        val values = stateFlow.take(2).toList()\n        assertEquals(listOf(0, 3), values) // Conflation happened\n    }\n\n    launch(UnconfinedTestDispatcher(testScheduler)) {\n        stateFlow.value = 1\n        stateFlow.value = 2\n        stateFlow.value = 3\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eWhen testing a \u003ccode\u003eStateFlow\u003c/code\u003e, you have two options: reading its \u003ccode\u003evalue\u003c/code\u003e at various points during the test or collecting it as a \u003ccode\u003eFlow\u003c/code\u003e. The former is the easier path if your circumstances allow it. Otherwise, you’ll have to keep in mind that collectors of a \u003ccode\u003eStateFlow\u003c/code\u003e are affected by conflation.\u003c/p\u003e\n\u003cp\u003eIt’s up to you to decide whether you want values to be conflated or not during a test, and set up assertions accordingly. You can control whether conflation can happen by choosing the dispatchers your code executes on during tests. Using \u003ca href=\"https://developer.android.com/kotlin/coroutines/test#injecting-test-dispatchers\"\u003einjected dispatchers\u003c/a\u003e that you can replace with appropriate \u003ccode\u003eTestDispatcher\u003c/code\u003e instances during tests is crucial for this.\u003c/p\u003e\n\u003cp\u003eFinally, the only way your collecting coroutine can be “faster” than the producing coroutine and avoid conflation is if the collector is on an \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e while the producer is on a \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e. Other cases—where the coroutines are equally fast or the collector is slower—will result in conflation.\u003c/p\u003e\n\n\u003c/div\u003e\u003cp\u003eHave you ever encountered APIs that show warnings or errors when you use them, saying that they\u0026#39;re internal or experimental? In this guide, you\u0026#39;ll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.\u003c/p\u003e\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\u003cp\u003eFragments have... Complicated lifecycles, to say the least. Let\u0026#39;s take a look at these, and how they all fit into the world of Jetpack today, with LifecycleOwners, LiveData, and coroutines.\u003c/p\u003e\u003cp\u003eRetrofit\u0026#39;s coroutine support has been a long time coming, and it\u0026#39;s finally coming to completion. Take a look at how you can use it to neatly integrate networking into an application built with coroutines.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
