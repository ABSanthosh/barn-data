{
  "id": "292bf635-1189-451e-bdc5-18e5e625b06f",
  "title": "Build on latest Java, test through lowest Java",
  "link": "https://jakewharton.com/build-on-latest-java-test-through-lowest-java/",
  "description": "",
  "author": "",
  "published": "2022-05-17T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 3636,
  "excerpt": "17 May 2022",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Build on latest Java, test through lowest Java 17 May 2022 In the past, when a new version of Java was released, I would add that version to our open source project’s CI builds. strategy: matrix: java-version: - 8 - 9 ⋮ - 17 + - 18 This ensures that each project can be built and its tests pass on every major version. But this makes no sense! No user is building these projects on different versions. No user is building these projects at all. Consumers are using the pre-built .jar which we ship to Maven Central built on a single version. Testing on every version, however, is something extremely valuable. Thankfully, Gradle toolchains let us retain this while still only building once. First, CI only has to build on a single version. We choose the latest because Java has excellent cross-compilation capabilities, and we want to be using the latest tools. - uses: actions/setup-java@v2 with: distribution: 'zulu' - java-version: ${​{ matrix.java-version }} + java-version: 18 Second, unchanged from before, we still target whichever Java version is the lowest supported through either the --release flag or sourceCompatibility/targetCompatibility per the Gradle docs. And finally, we set up tests to run on every supported version. // Normal test task runs on compile JDK. (8..17).each { majorVersion -\u003e def jdkTest = tasks.register(\"testJdk$majorVersion\", Test) { javaLauncher = javaToolchains.launcherFor { languageVersion = JavaLanguageVersion.of(majorVersion) } description = \"Runs the test suite on JDK $majorVersion\" group = LifecycleBasePlugin.VERIFICATION_GROUP // Copy inputs from normal Test task. def testTask = tasks.getByName(\"test\") classpath = testTask.classpath testClassesDirs = testTask.testClassesDirs } tasks.named(\"check\").configure { dependsOn(jdkTest) } } This setup reduces CI burden since we only compile the main and test sources once but execute the tests on every supported version from latest to lowest. Verification tasks ------------------ check - Runs all checks. test - Runs the test suite. testJdk10 - Runs the test suite on JDK 10 testJdk11 - Runs the test suite on JDK 11 testJdk12 - Runs the test suite on JDK 12 testJdk13 - Runs the test suite on JDK 13 testJdk14 - Runs the test suite on JDK 14 testJdk15 - Runs the test suite on JDK 15 testJdk16 - Runs the test suite on JDK 16 testJdk17 - Runs the test suite on JDK 17 testJdk8 - Runs the test suite on JDK 8 testJdk9 - Runs the test suite on JDK 9 For projects using multi-release jars, this compilation and testing setup is essential since the source sets require compiling with newer versions but testing through a lower version bound. So if adding Java versions to a CI matrix is something you’ve been doing, consider switching to compile with a single Java version and instead varying your test execution instead. And if you only build and test on a single version today, adding this can ensure correctness on all versions that you support. Not every project needs to test on multiple versions. If your code is mostly algorithmic you won’t gain much from doing this. But if you vary behavior based on Java version, conditionally leverage APIs on newer versions, or interact with non-public APIs then this is a best practice. P.S. Are you an Android developer? You probably keep your compileSdk high, your minSdk low(-ish), and execute instrumentation tests on a few versions between those two. Great news, you’re already following this advice as it’s always been the norm! — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eBuild on latest Java, test through lowest Java\u003c/h2\u003e\n      \u003cp\u003e17 May 2022\u003c/p\u003e\n\n      \u003cp\u003eIn the past, when a new version of Java was released, I would add that version to our open source project’s CI builds.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e strategy:\n   matrix:\n     java-version:\n       - 8\n       - 9\n         ⋮\n       - 17\n\u003cspan\u003e+      - 18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis ensures that each project can be built and its tests pass on every major version.\u003c/p\u003e\n\n\u003cp\u003eBut this makes no sense! No user is building these projects on different versions. No user is building these projects at all. Consumers are using the pre-built \u003ccode\u003e.jar\u003c/code\u003e which we ship to Maven Central built on a single version.\u003c/p\u003e\n\n\u003cp\u003eTesting on every version, however, is something extremely valuable. Thankfully, \u003ca href=\"https://docs.gradle.org/current/userguide/toolchains.html\"\u003eGradle toolchains\u003c/a\u003e let us retain this while still only building once.\u003c/p\u003e\n\n\u003cp\u003eFirst, CI only has to build on a single version. We choose the latest because Java has excellent cross-compilation capabilities, and we want to be using the latest tools.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e - uses: actions/setup-java@v2\n   with:\n     distribution: \u0026#39;zulu\u0026#39;\n\u003cspan\u003e-    java-version: ${​{ matrix.java-version }}\n\u003c/span\u003e\u003cspan\u003e+    java-version: 18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSecond, unchanged from before, we still target whichever Java version is the lowest supported through either the \u003ccode\u003e--release\u003c/code\u003e flag or \u003ccode\u003esourceCompatibility\u003c/code\u003e/\u003ccode\u003etargetCompatibility\u003c/code\u003e \u003ca href=\"https://docs.gradle.org/7.4/userguide/building_java_projects.html#sec:java_cross_compilation\"\u003eper the Gradle docs\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAnd finally, we set up tests to run on every supported version.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Normal test task runs on compile JDK.\u003c/span\u003e\n\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e8\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e17\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003eeach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003emajorVersion\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n  \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ejdkTest\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eregister\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;testJdk$majorVersion\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTest\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ejavaLauncher\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejavaToolchains\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elauncherFor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003elanguageVersion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eJavaLanguageVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emajorVersion\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003edescription\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Runs the test suite on JDK $majorVersion\u0026#34;\u003c/span\u003e\n    \u003cspan\u003egroup\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLifecycleBasePlugin\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eVERIFICATION_GROUP\u003c/span\u003e\n\n    \u003cspan\u003e// Copy inputs from normal Test task.\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003etestTask\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetByName\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;test\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003eclasspath\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etestTask\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eclasspath\u003c/span\u003e\n    \u003cspan\u003etestClassesDirs\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etestTask\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etestClassesDirs\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enamed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;check\u0026#34;\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003econfigure\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003edependsOn\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ejdkTest\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis setup reduces CI burden since we only compile the main and test sources once but execute the tests on every supported version from latest to lowest.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eVerification tasks\n------------------\ncheck - Runs all checks.\ntest - Runs the test suite.\ntestJdk10 - Runs the test suite on JDK 10\ntestJdk11 - Runs the test suite on JDK 11\ntestJdk12 - Runs the test suite on JDK 12\ntestJdk13 - Runs the test suite on JDK 13\ntestJdk14 - Runs the test suite on JDK 14\ntestJdk15 - Runs the test suite on JDK 15\ntestJdk16 - Runs the test suite on JDK 16\ntestJdk17 - Runs the test suite on JDK 17\ntestJdk8 - Runs the test suite on JDK 8\ntestJdk9 - Runs the test suite on JDK 9\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFor projects using \u003ca href=\"https://openjdk.java.net/jeps/238\"\u003emulti-release jars\u003c/a\u003e, this compilation and testing setup is essential since the source sets require compiling with newer versions but testing through a lower version bound.\u003c/p\u003e\n\n\u003cp\u003eSo if adding Java versions to a CI matrix is something you’ve been doing, consider switching to compile with a single Java version and instead varying your test execution instead. And if you only build and test on a single version today, adding this can ensure correctness on all versions that you support.\u003c/p\u003e\n\n\u003cp\u003eNot every project needs to test on multiple versions. If your code is mostly algorithmic you won’t gain much from doing this. But if you vary behavior based on Java version, conditionally leverage APIs on newer versions, or interact with non-public APIs then this is a best practice.\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003eP.S. Are you an Android developer? You probably keep your \u003ccode\u003ecompileSdk\u003c/code\u003e high, your \u003ccode\u003eminSdk\u003c/code\u003e low(-ish), and execute instrumentation tests on a few versions between those two. Great news, you’re already following this advice as it’s always been the norm!\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2022-05-17T00:00:00Z",
  "modifiedTime": null
}
