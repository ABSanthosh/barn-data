{
  "id": "83e0b6a5-65a0-4b0e-b2a6-a0c7c9b88723",
  "title": "Handling Token Expiration in Retrofit: Automatic Token Refresh with OkHttp",
  "link": "https://proandroiddev.com/handling-token-expiration-in-retrofit-automatic-token-refresh-with-okhttp-d5673e4d4c41?source=rss----c72404660798---4",
  "description": "",
  "author": "Dobri Kostadinov",
  "published": "Wed, 19 Feb 2025 21:31:18 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-development",
    "androiddev",
    "mobile-app-development",
    "retrofit",
    "kotlin"
  ],
  "byline": "Dobri Kostadinov",
  "length": 6117,
  "excerpt": "When working with Retrofit in Android applications, handling token expiration is a crucial part of API security. If your app uses authentication tokens, those tokens may expire at any time, requiringâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "A Complete Guide to Seamlessly Managing Token Expiry and Refresh in Android AppsIntroductionWhen working with Retrofit in Android applications, handling token expiration is a crucial part of API security. If your app uses authentication tokens, those tokens may expire at any time, requiring a refresh before making further requests. In this article, we will explore how to seamlessly handle token expiration using OkHttpâ€™s Authenticator to ensure a smooth user experience.The Problem: Expiring TokensImagine you have an API service with multiple endpoints, such as:@GET(\"products\")suspend fun getProducts(): Response\u003cList\u003cProduct\u003e\u003eThis works well initially, but what happens when the access token expires? The backend responds with 401 Unauthorized, and the request fails. The expected behavior should be:Detect the 401 Unauthorized response.Automatically refresh the access token using a refresh_token.Retry the original request with the new access token.If the refresh fails (e.g., refresh token expired), log out the user.Manually handling this across multiple API calls can be tedious and error-prone. Instead, we can use OkHttp Interceptors and Authenticators to automate this process.Step 1: Create an Interceptor to Add Authorization HeaderWe first need an interceptor that appends the Authorization header to every API request.class AuthInterceptor(private val sharedPreferences: SharedPreferences) : Interceptor { override fun intercept(chain: Interceptor.Chain): Response { val accessToken = sharedPreferences.getString(\"access_token\", \"\") ?: \"\" val request = chain.request().newBuilder() .header(\"Authorization\", \"Bearer $accessToken\") .build() return chain.proceed(request) }}How it Works:Retrieves the access token from SharedPreferences.Appends it to the Authorization header.Proceeds with the modified request.Step 2: Create an Authenticator to Refresh the TokenThe Authenticator class is triggered when an API call fails with a 401 Unauthorized. It will:Call the token refresh API.Store the new access token.Retry the original request.Hereâ€™s how you implement it:class TokenAuthenticator( private val apiService: ApiService, private val sharedPreferences: SharedPreferences) : Authenticator { override fun authenticate(route: Route?, response: Response): Request? { synchronized(this) { // Prevent multiple refresh calls val refreshToken = sharedPreferences.getString(\"refresh_token\", null) ?: return null // Fetch new tokens synchronously val newTokensResponse = apiService.fetchNewTokens(refreshToken).execute() if (!newTokensResponse.isSuccessful) { return null // Refresh failed, trigger logout } val newTokens = newTokensResponse.body() ?: return null // Save new tokens sharedPreferences.edit() .putString(\"access_token\", newTokens.accessToken) .putString(\"refresh_token\", newTokens.refreshToken) .apply() // Retry the original request with new token return response.request.newBuilder() .header(\"Authorization\", \"Bearer ${newTokens.accessToken}\") .build() } }}How it Works:Gets the refresh token from SharedPreferences.Calls the refresh API synchronously to get new tokens.Saves new tokens in SharedPreferences.Retries the original request with the new access token.If the refresh fails, returns null, signaling that authentication is no longer valid.Step 3: Integrate with OkHttp ClientNow, we need to configure OkHttp to use both AuthInterceptor and TokenAuthenticator.fun provideOkHttpClient(apiService: ApiService, sharedPreferences: SharedPreferences): OkHttpClient { return OkHttpClient.Builder() .addInterceptor(AuthInterceptor(sharedPreferences)) .authenticator(TokenAuthenticator(apiService, sharedPreferences)) .build()}Explanation:AuthInterceptor ensures every request has an up-to-date token.TokenAuthenticator automatically refreshes tokens when a 401 is received.Retrofit will use this OkHttp client to handle expired tokens automatically.Step 4: Set Up RetrofitFinally, initialize Retrofit with the custom OkHttpClient:fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit { return Retrofit.Builder() .baseUrl(\"https://your.api.url\") .client(okHttpClient) .addConverterFactory(GsonConverterFactory.create()) .build()}Now, whenever you call:api.getProducts()If the token is expired, it will be refreshed automatically, and the API call will be retried without any manual intervention.Step 5: Handling Edge CasesWhile this setup works well, there are some important edge cases to handle:1. Refresh Token Expired?If the refresh token is also expired, you must log out the user:if (!newTokensResponse.isSuccessful) { logoutUser() return null}2. Multiple Requests Fail Simultaneously?If multiple API calls fail at the same time, the app should refresh the token only once. The synchronized(this) block ensures that only one refresh request happens at a time.3. Network Failure When Refreshing?If the network fails during token refresh, the original API call will also fail. Consider implementing a retry mechanism with exponential backoff.ConclusionBy using AuthInterceptor and TokenAuthenticator, we have achieved automatic token refresh in Retrofit. This approach ensures:âœ… Seamless token refresh without user intervention.âœ… Prevents multiple refresh calls by synchronizing the process.âœ… Automatically retries the failed request after refreshing the token.âœ… Handles refresh failures gracefully by logging out the user if needed.Final ThoughtThis method enhances the user experience by preventing disruptions due to expired tokens. With this in place, users never see token expiration issues, and your app remains functional at all times. ðŸš€Do you use another approach for token refreshing? Let me know in the comments below! ðŸ‘‡Dobri KostadinovAndroid Consultant | TrainerEmail me | Follow me on LinkedIn | Follow me on Medium | Buy me a coffee",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*YJ-yjnJS57CDjpeI4RSSlQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"d9b6\"\u003eA Complete Guide to Seamlessly Managing Token Expiry and Refresh in Android Apps\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dobri.kostadinov?source=post_page---byline--d5673e4d4c41---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dobri Kostadinov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*PDWUz7RmoqP9kmFnZzGPUg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--d5673e4d4c41---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c0a5\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"ee5e\"\u003eWhen working with Retrofit in Android applications, handling token expiration is a crucial part of API security. If your app uses authentication tokens, those tokens may expire at any time, requiring a refresh before making further requests. In this article, we will explore how to seamlessly handle token expiration using \u003cstrong\u003eOkHttpâ€™s Authenticator\u003c/strong\u003e to ensure a smooth user experience.\u003c/p\u003e\u003ch2 id=\"fca0\"\u003eThe Problem: Expiring Tokens\u003c/h2\u003e\u003cp id=\"8964\"\u003eImagine you have an API service with multiple endpoints, such as:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a3a4\"\u003e@GET(\u0026#34;products\u0026#34;)\u003cbr/\u003esuspend fun getProducts(): Response\u0026lt;List\u0026lt;Product\u0026gt;\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"58ba\"\u003eThis works well initially, but what happens when the access token expires? The backend responds with \u003ccode\u003e401 Unauthorized\u003c/code\u003e, and the request fails. The expected behavior should be:\u003c/p\u003e\u003col\u003e\u003cli id=\"0c42\"\u003eDetect the \u003ccode\u003e401 Unauthorized\u003c/code\u003e response.\u003c/li\u003e\u003cli id=\"016e\"\u003eAutomatically refresh the access token using a \u003ccode\u003erefresh_token\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"48e0\"\u003eRetry the original request with the new access token.\u003c/li\u003e\u003cli id=\"ca3b\"\u003eIf the refresh fails (e.g., refresh token expired), log out the user.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"4027\"\u003eManually handling this across multiple API calls can be tedious and error-prone. Instead, we can use \u003cstrong\u003eOkHttp Interceptors\u003c/strong\u003e and \u003cstrong\u003eAuthenticators\u003c/strong\u003e to automate this process.\u003c/p\u003e\u003ch2 id=\"fed2\"\u003eStep 1: Create an Interceptor to Add Authorization Header\u003c/h2\u003e\u003cp id=\"f789\"\u003eWe first need an interceptor that appends the \u003cstrong\u003eAuthorization\u003c/strong\u003e header to every API request.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a029\"\u003eclass AuthInterceptor(private val sharedPreferences: SharedPreferences) : Interceptor {\u003cbr/\u003e    override fun intercept(chain: Interceptor.Chain): Response {\u003cbr/\u003e        val accessToken = sharedPreferences.getString(\u0026#34;access_token\u0026#34;, \u0026#34;\u0026#34;) ?: \u0026#34;\u0026#34;\u003cbr/\u003e        val request = chain.request().newBuilder()\u003cbr/\u003e            .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $accessToken\u0026#34;)\u003cbr/\u003e            .build()\u003cbr/\u003e        return chain.proceed(request)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3cef\"\u003eHow it Works:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"06c7\"\u003eRetrieves the \u003cstrong\u003eaccess token\u003c/strong\u003e from \u003ccode\u003eSharedPreferences\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3361\"\u003eAppends it to the \u003cstrong\u003eAuthorization header\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"c90b\"\u003eProceeds with the modified request.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5bcb\"\u003eStep 2: Create an Authenticator to Refresh the Token\u003c/h2\u003e\u003cp id=\"c1f5\"\u003eThe \u003ccode\u003eAuthenticator\u003c/code\u003e class is triggered when an API call fails with a \u003ccode\u003e401 Unauthorized\u003c/code\u003e. It will:\u003c/p\u003e\u003cul\u003e\u003cli id=\"82b9\"\u003eCall the \u003cstrong\u003etoken refresh API\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"52b2\"\u003eStore the \u003cstrong\u003enew access token\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"3870\"\u003eRetry the \u003cstrong\u003eoriginal request\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2960\"\u003eHereâ€™s how you implement it:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"925d\"\u003eclass TokenAuthenticator(\u003cbr/\u003e    private val apiService: ApiService,\u003cbr/\u003e    private val sharedPreferences: SharedPreferences\u003cbr/\u003e) : Authenticator {\u003cp\u003e    override fun authenticate(route: Route?, response: Response): Request? {\u003cbr/\u003e        synchronized(this) { // Prevent multiple refresh calls\u003cbr/\u003e            val refreshToken = sharedPreferences.getString(\u0026#34;refresh_token\u0026#34;, null) ?: return null\u003c/p\u003e\u003cp\u003e            // Fetch new tokens synchronously\u003cbr/\u003e            val newTokensResponse = apiService.fetchNewTokens(refreshToken).execute()\u003cbr/\u003e            if (!newTokensResponse.isSuccessful) {\u003cbr/\u003e                return null // Refresh failed, trigger logout\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            val newTokens = newTokensResponse.body() ?: return null\u003c/p\u003e\u003cp\u003e            // Save new tokens\u003cbr/\u003e            sharedPreferences.edit()\u003cbr/\u003e                .putString(\u0026#34;access_token\u0026#34;, newTokens.accessToken)\u003cbr/\u003e                .putString(\u0026#34;refresh_token\u0026#34;, newTokens.refreshToken)\u003cbr/\u003e                .apply()\u003c/p\u003e\u003cp\u003e            // Retry the original request with new token\u003cbr/\u003e            return response.request.newBuilder()\u003cbr/\u003e                .header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer ${newTokens.accessToken}\u0026#34;)\u003cbr/\u003e                .build()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3315\"\u003eHow it Works:\u003c/h2\u003e\u003col\u003e\u003cli id=\"d7bd\"\u003e\u003cstrong\u003eGets the refresh token\u003c/strong\u003e from \u003ccode\u003eSharedPreferences\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"ff85\"\u003e\u003cstrong\u003eCalls the refresh API synchronously\u003c/strong\u003e to get new tokens.\u003c/li\u003e\u003cli id=\"5d74\"\u003e\u003cstrong\u003eSaves new tokens\u003c/strong\u003e in \u003ccode\u003eSharedPreferences\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"4fc0\"\u003e\u003cstrong\u003eRetries the original request\u003c/strong\u003e with the new access token.\u003c/li\u003e\u003cli id=\"3470\"\u003eIf the refresh \u003cstrong\u003efails\u003c/strong\u003e, returns \u003ccode\u003enull\u003c/code\u003e, signaling that authentication is no longer valid.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"14ce\"\u003eStep 3: Integrate with OkHttp Client\u003c/h2\u003e\u003cp id=\"c958\"\u003eNow, we need to configure \u003cstrong\u003eOkHttp\u003c/strong\u003e to use both \u003ccode\u003eAuthInterceptor\u003c/code\u003e and \u003ccode\u003eTokenAuthenticator\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7232\"\u003efun provideOkHttpClient(apiService: ApiService, sharedPreferences: SharedPreferences): OkHttpClient {\u003cbr/\u003e    return OkHttpClient.Builder()\u003cbr/\u003e        .addInterceptor(AuthInterceptor(sharedPreferences))\u003cbr/\u003e        .authenticator(TokenAuthenticator(apiService, sharedPreferences))\u003cbr/\u003e        .build()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8eb3\"\u003eExplanation:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"ce76\"\u003e\u003ccode\u003e\u003cstrong\u003eAuthInterceptor\u003c/strong\u003e\u003c/code\u003e ensures every request has an up-to-date token.\u003c/li\u003e\u003cli id=\"e898\"\u003e\u003ccode\u003e\u003cstrong\u003eTokenAuthenticator\u003c/strong\u003e\u003c/code\u003e automatically refreshes tokens when a \u003ccode\u003e401\u003c/code\u003e is received.\u003c/li\u003e\u003cli id=\"2c02\"\u003eRetrofit will use this OkHttp client to \u003cstrong\u003ehandle expired tokens automatically\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"efda\"\u003eStep 4: Set Up Retrofit\u003c/h2\u003e\u003cp id=\"f82a\"\u003eFinally, initialize Retrofit with the \u003cstrong\u003ecustom OkHttpClient\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d4b9\"\u003efun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {\u003cbr/\u003e    return Retrofit.Builder()\u003cbr/\u003e        .baseUrl(\u0026#34;https://your.api.url\u0026#34;)\u003cbr/\u003e        .client(okHttpClient)\u003cbr/\u003e        .addConverterFactory(GsonConverterFactory.create())\u003cbr/\u003e        .build()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"862e\"\u003eNow, whenever you call:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ff45\"\u003eapi.getProducts()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ba66\"\u003eIf the token is expired, it will be refreshed \u003cstrong\u003eautomatically\u003c/strong\u003e, and the API call will be retried \u003cstrong\u003ewithout any manual intervention\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"2b77\"\u003eStep 5: Handling Edge Cases\u003c/h2\u003e\u003cp id=\"1a0b\"\u003eWhile this setup works well, there are some \u003cstrong\u003eimportant edge cases\u003c/strong\u003e to handle:\u003c/p\u003e\u003ch2 id=\"7235\"\u003e1. Refresh Token Expired?\u003c/h2\u003e\u003cp id=\"792e\"\u003eIf the refresh token is also \u003cstrong\u003eexpired\u003c/strong\u003e, you must log out the user:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4c1d\"\u003eif (!newTokensResponse.isSuccessful) {\u003cbr/\u003e    logoutUser()\u003cbr/\u003e    return null\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bb33\"\u003e2. Multiple Requests Fail Simultaneously?\u003c/h2\u003e\u003cp id=\"bb73\"\u003eIf multiple API calls fail at the same time, the app should \u003cstrong\u003erefresh the token only once\u003c/strong\u003e. The \u003ccode\u003esynchronized(this)\u003c/code\u003e block ensures that only \u003cstrong\u003eone\u003c/strong\u003e refresh request happens at a time.\u003c/p\u003e\u003ch2 id=\"8651\"\u003e3. Network Failure When Refreshing?\u003c/h2\u003e\u003cp id=\"d7ce\"\u003eIf the network fails during token refresh, the \u003cstrong\u003eoriginal API call will also fail\u003c/strong\u003e. Consider implementing a retry mechanism with \u003cstrong\u003eexponential backoff\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"33d8\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"01cb\"\u003eBy using \u003ccode\u003eAuthInterceptor\u003c/code\u003e and \u003ccode\u003eTokenAuthenticator\u003c/code\u003e, we have achieved \u003cstrong\u003eautomatic token refresh\u003c/strong\u003e in Retrofit. This approach ensures:\u003c/p\u003e\u003cp id=\"1200\"\u003eâœ… \u003cstrong\u003eSeamless token refresh\u003c/strong\u003e without user intervention.\u003c/p\u003e\u003cp id=\"c9ae\"\u003eâœ… \u003cstrong\u003ePrevents multiple refresh calls\u003c/strong\u003e by synchronizing the process.\u003c/p\u003e\u003cp id=\"894e\"\u003eâœ… \u003cstrong\u003eAutomatically retries the failed request\u003c/strong\u003e after refreshing the token.\u003c/p\u003e\u003cp id=\"631e\"\u003eâœ… \u003cstrong\u003eHandles refresh failures gracefully\u003c/strong\u003e by logging out the user if needed.\u003c/p\u003e\u003ch2 id=\"e72e\"\u003eFinal Thought\u003c/h2\u003e\u003cp id=\"80c5\"\u003eThis method enhances the user experience by preventing disruptions due to expired tokens. With this in place, \u003cstrong\u003eusers never see token expiration issues\u003c/strong\u003e, and your app remains functional at all times. ðŸš€\u003c/p\u003e\u003cp id=\"625f\"\u003eDo you use another approach for token refreshing? Let me know in the comments below! ðŸ‘‡\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0957\"\u003e\u003cem\u003eDobri Kostadinov\u003c/em\u003e\u003cbr/\u003eAndroid Consultant | Trainer\u003cbr/\u003e\u003ca href=\"mailto:dobri.kostadinov@gmail.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEmail me\u003c/a\u003e | \u003ca href=\"https://www.linkedin.com/in/dobrikostadinov/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFollow me on LinkedIn\u003c/a\u003e | \u003ca href=\"https://medium.com/@dobri.kostadinov\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e | \u003ca href=\"https://www.buymeacoffee.com/dobri.kostadinov\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuy me a coffee\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-02-19T21:31:18.495Z",
  "modifiedTime": null
}
