{
  "id": "d1751388-755d-462c-bc72-2cdb29aef69c",
  "title": "Case-insensitive filesystems considered harmful (to me)",
  "link": "https://jakewharton.com/case-insensitive-filesystems-considered-harmful-to-me/",
  "description": "",
  "author": "",
  "published": "2021-06-04T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 8311,
  "excerpt": "04 June 2021",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Case-insensitive filesystems considered harmful (to me) 04 June 2021 Having been burned by case-insensitive filesystem bugs one too many times, I long ago switched my development folder to a case-sensitive filesystem partition on my otherwise case-insensitive Mac. Unfortunately this can actually work against me as I interact with the computers of coworkers and service providers which use the default. Well I was burned again, and this is the tale! I’ve been working on two projects based on Jetpack Compose1 which require me to recompile its sources. Despite building them unmodified, I still run its tests against my compiled version to ensure this core functionality of my project behaves as expected. However, both of my projects recently started experiencing test failures on CI, and it was the same, single test failing on both projects. The first project failed about a month ago when I added a MacOS worker in addition to the Linux worker to build a JNI library. Being so focused on the JNI compilation, I figured the Compose failure was a flake or something wrong with my setup. Its failure was: androidx.compose.runtime.CompositionTests[jvm] \u003e testInsertOnMultipleLevels[jvm] FAILED java.lang.NoClassDefFoundError: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$item$1 (wrong name: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$Item$1) at java.base/java.lang.ClassLoader.defineClass1(Native Method) ⋮ at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522) at androidx.compose.runtime.CompositionTests$testInsertOnMultipleLevels$1.invokeSuspend$Item(CompositionTests.kt:2055) Like I said I didn’t look too closely at this output and assumed it was my own fault. The second project (which is not open source yet) started failing yesterday when I added a Windows worker to publish new targets for its Kotlin multiplatform library. Notably, the project already had a MacOS worker, and the PR to add the Windows worker did see both workers succeed. The merge commit, however, failed with an exception on the Windows worker which looked awfully familiar: androidx.compose.runtime.CompositionTests[jvm] \u003e testInsertOnMultipleLevels[jvm] FAILED java.lang.NoClassDefFoundError: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$Item$1 (wrong name: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$item$1) at java.lang.ClassLoader.defineClass1(Native Method) ⋮ at java.lang.ClassLoader.loadClass(ClassLoader.java:351) at androidx.compose.runtime.CompositionTests$testInsertOnMultipleLevels$1.invokeSuspend$Item(CompositionTests.kt:2055) “It’s the same exception!”, my brain thought. But if you look closely it is the same but it’s also different. In this case we tried to load CompositionTests$testInsertOnMultipleLevels$1$Item$1 (note the uppercase “i” in Item) but found a class named CompositionTests$testInsertOnMultipleLevels$1$item$1 (note the lowercase “i” in item). This is in contrast to the first exception above where the “item” casing is reversed. Cracking open CompositionTests we can look at the testInsertOnMultipleLevels method and see the source of this class: fun testInsertOnMultipleLevels() = compositionTest { // …code… fun Item(number: Int, numbers: List\u003cInt\u003e) { Linear { // --\u003e This lambda is the source! \u003c-- // …code… } } // …code… } The anonymous lambda passed to compositionTest becomes $1, the nested Item function becomes $Item, and the lambda passed to Linear becomes another $1 producing the final class name of CompositionTests$testInsertOnMultipleLevels$1$Item$1. This all seems fine, though. So how could the name of the class for the function change casing from Item to item? Thankfully, with the investigative powers of Isaac Udy helping, we stumbled upon more code further down the function: fun testInsertOnMultipleLevels() = compositionTest { // …code… fun Item(number: Int, numbers: List\u003cInt\u003e) { Linear { // …code… } } // …code… fun MockViewValidator.item(number: Int, numbers: List\u003cInt\u003e) { Linear { // …code… } } // …code… } The class generation in this second nested function follow a similar formula to the first. The anonymous lambda passed to compositionTest once again becomes $1, the nested MockViewValidator.item function becomes $item, and the lambda passed to Linear becomes another $1 producing the final class name of CompositionTests$testInsertOnMultipleLevels$1$item$1. And there it is. The lambda inside first function produces a class named CompositionTests$testInsertOnMultipleLevels$1$Item$1 which is written to CompositionTests$testInsertOnMultipleLevels$1$Item$1.class on the filesystem. The lambda inside the second function produces a class named CompositionTests$testInsertOnMultipleLevels$1$item$1 which is written to CompositionTests$testInsertOnMultipleLevels$1$item$1.class on the filesystem. Except on a case-insensitive filesystem, those are the same file! To be clear, the problematic steps are this: The build system cleans the output directory giving us a blank slate on the filesystem. The Kotlin compiler generates the class CompositionTests$testInsertOnMultipleLevels$1$Item$1. The Kotlin compiler opens the CompositionTests$testInsertOnMultipleLevels$1$Item$1.class file (which does not exist and is created), writes the bytecode for CompositionTests$testInsertOnMultipleLevels$1$Item$1, and closes the file. The Kotlin compiler generates the class CompositionTests$testInsertOnMultipleLevels$1$item$1. The Kotlin compiler opens the CompositionTests$testInsertOnMultipleLevels$1$item$1.class file (but the filesystem sees CompositionTests$testInsertOnMultipleLevels$1$Item$1.class as an existing match and opens it as an existing file), writes the bytecode for CompositionTests$testInsertOnMultipleLevels$1$item$1, and closes the file. When the project builds on my machine the non-standard, case-sensitive filesystem sees those as separate files and the failure does not occur. On MacOS- and Windows-based CI workers with their filesystem defaults, however, they’re seen as the same and one overwrites the other. This is what leads to the class name of the second appearing in the file name of the first. The fix here is easy: rename one of the functions to produce different names. And in an ironic twist of timing, JetBrains made the exact fix to Compose just 12 hours ago. -fun MockViewValidator.item(number: Int, numbers: List\u003cInt\u003e) { +fun MockViewValidator.validateItem(number: Int, numbers: List\u003cInt\u003e) { Linear { // …code… } } A simple git submodule update and all my problems are now solved. Or are they? This is not the first time I have had this problem, and it likely won’t be the last. I would like to make the argument that this is a Kotlin compiler bug. Regardless of whether you are targeting a case-insensitive filesystem, the Kotlin compiler could avoid this entire class of problem by further mangling the name of this otherwise unnamed type to avoid case-insensitive collision. You can trivially reproduce this if you have a case-insensitive filesystem: $ kotlinc Hey.kt $ ls Hey* Hey.class Hey.kt And a minimal reproducer for the more cryptic cause in this post would be: fun complex() = run { fun Nested() { run { println(\"Nested\") } } fun String.nested() { run { println(\"String.nested\") } } } fun run(lambda: () -\u003e Unit) = lambda() $ kotlinc Complex.kt $ ls Complex* Complex.kt ComplexKt$complex$1$Nested$1.class ComplexKt$complex$1.class ComplexKt.class I have filed KT-47123 to advocate that the compiler should automatically prevent this from happening. Hey Java users you’re not totally immune either! class Hey {} class hey {} $ javac Hey.java $ ls Hey* Hey.class Hey.java I’m confident that this year will finally be the year of the Linux desktop to solve all these problems with its case-sensitive-by-default filesystems, right? But until then, having tools which are smarter about filesystem interaction in a world where both case-sensitive and case-insensitive variants exist would go a long way to reducing developer headaches like this. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eCase-insensitive filesystems considered harmful (to me)\u003c/h2\u003e\n      \u003cp\u003e04 June 2021\u003c/p\u003e\n\n      \u003cp\u003eHaving been burned by case-insensitive filesystem bugs one too many times, I long ago switched my development folder to a case-sensitive filesystem partition on my otherwise case-insensitive Mac. Unfortunately this can actually work against me as I interact with the computers of coworkers and service providers which use the default. Well I was burned again, and this is the tale!\u003c/p\u003e\n\n\u003cp\u003eI’ve been working on two projects based on \u003ca href=\"https://developer.android.com/jetpack/compose\"\u003eJetpack Compose\u003c/a\u003e\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\"\u003e1\u003c/a\u003e\u003c/sup\u003e which require me to recompile its sources. Despite building them unmodified, I still run its tests against my compiled version to ensure this core functionality of my project behaves as expected. However, both of my projects recently started experiencing test failures on CI, and it was the same, single test failing on both projects.\u003c/p\u003e\n\n\u003cp\u003eThe first project \u003ca href=\"https://github.com/JakeWharton/mosaic/runs/2547311635\"\u003efailed about a month ago\u003c/a\u003e when I added a MacOS worker in addition to the Linux worker to build a JNI library. Being so focused on the JNI compilation, I figured the Compose failure was a flake or something wrong with my setup. Its failure was:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eandroidx.compose.runtime.CompositionTests[jvm] \u0026gt; testInsertOnMultipleLevels[jvm] FAILED\n    java.lang.NoClassDefFoundError: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$item$1 (wrong name: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$Item$1)\n        at java.base/java.lang.ClassLoader.defineClass1(Native Method)\n         ⋮\n        at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:522)\n        at androidx.compose.runtime.CompositionTests$testInsertOnMultipleLevels$1.invokeSuspend$Item(CompositionTests.kt:2055)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLike I said I didn’t look too closely at this output and assumed it was my own fault.\u003c/p\u003e\n\n\u003cp\u003eThe second project (which is not open source yet) started failing yesterday when I added a Windows worker to publish new targets for its Kotlin multiplatform library. Notably, the project already had a MacOS worker, and the PR to add the Windows worker did see both workers succeed. The merge commit, however, failed with an exception on the Windows worker which looked awfully familiar:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eandroidx.compose.runtime.CompositionTests[jvm] \u0026gt; testInsertOnMultipleLevels[jvm] FAILED\n    java.lang.NoClassDefFoundError: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$Item$1 (wrong name: androidx/compose/runtime/CompositionTests$testInsertOnMultipleLevels$1$item$1)\n        at java.lang.ClassLoader.defineClass1(Native Method)\n         ⋮\n        at java.lang.ClassLoader.loadClass(ClassLoader.java:351)\n        at androidx.compose.runtime.CompositionTests$testInsertOnMultipleLevels$1.invokeSuspend$Item(CompositionTests.kt:2055)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e“It’s the same exception!”, my brain thought. But if you look closely it \u003cem\u003eis\u003c/em\u003e the same but it’s also different. In this case we tried to load \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1\u003c/code\u003e (note the uppercase “i” in \u003ccode\u003eItem\u003c/code\u003e) but found a class named \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1\u003c/code\u003e (note the lowercase “i” in \u003ccode\u003eitem\u003c/code\u003e). This is in contrast to the first exception above where the “item” casing is reversed.\u003c/p\u003e\n\n\u003cp\u003eCracking open \u003ccode\u003eCompositionTests\u003c/code\u003e we can look at the \u003ccode\u003etestInsertOnMultipleLevels\u003c/code\u003e method and see the source of this class:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003etestInsertOnMultipleLevels\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecompositionTest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// …code…\u003c/span\u003e\n\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eItem\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enumber\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003enumbers\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eLinear\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e// --\u0026gt; This lambda is the source! \u0026lt;--\u003c/span\u003e\n      \u003cspan\u003e// …code…\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003e// …code…\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe anonymous lambda passed to \u003ccode\u003ecompositionTest\u003c/code\u003e becomes \u003ccode\u003e$1\u003c/code\u003e, the nested \u003ccode\u003eItem\u003c/code\u003e function becomes \u003ccode\u003e$Item\u003c/code\u003e, and the lambda passed to \u003ccode\u003eLinear\u003c/code\u003e becomes another \u003ccode\u003e$1\u003c/code\u003e producing the final class name of \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis all seems fine, though. So how could the name of the class for the function change casing from \u003ccode\u003eItem\u003c/code\u003e to \u003ccode\u003eitem\u003c/code\u003e?\u003c/p\u003e\n\n\u003cp\u003eThankfully, with the investigative powers of \u003ca href=\"https://medium.com/@isaac.udy_90859\"\u003eIsaac Udy\u003c/a\u003e helping, we stumbled upon more code further down the function:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003etestInsertOnMultipleLevels\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ecompositionTest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// …code…\u003c/span\u003e\n\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eItem\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enumber\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003enumbers\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eLinear\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e// …code…\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003e// …code…\u003c/span\u003e\n\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eMockViewValidator\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enumber\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003enumbers\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eLinear\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e// …code…\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n \u003cspan\u003e// …code…\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe class generation in this second nested function follow a similar formula to the first. The anonymous lambda passed to \u003ccode\u003ecompositionTest\u003c/code\u003e once again becomes \u003ccode\u003e$1\u003c/code\u003e, the nested \u003ccode\u003eMockViewValidator.item\u003c/code\u003e function becomes \u003ccode\u003e$item\u003c/code\u003e, and the lambda passed to \u003ccode\u003eLinear\u003c/code\u003e becomes another \u003ccode\u003e$1\u003c/code\u003e producing the final class name of \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAnd there it is. The lambda inside first function produces a class named \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1\u003c/code\u003e which is written to \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1.class\u003c/code\u003e on the filesystem. The lambda inside the second function produces a class named \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1\u003c/code\u003e which is written to \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1.class\u003c/code\u003e on the filesystem. Except on a case-insensitive filesystem, \u003cem\u003ethose are the same file!\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eTo be clear, the problematic steps are this:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eThe build system cleans the output directory giving us a blank slate on the filesystem.\u003c/li\u003e\n  \u003cli\u003eThe Kotlin compiler generates the class \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1\u003c/code\u003e.\u003c/li\u003e\n  \u003cli\u003eThe Kotlin compiler opens the \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1.class\u003c/code\u003e file (which does not exist and is created), writes the bytecode for \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1\u003c/code\u003e, and closes the file.\u003c/li\u003e\n  \u003cli\u003eThe Kotlin compiler generates the class \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1\u003c/code\u003e.\u003c/li\u003e\n  \u003cli\u003eThe Kotlin compiler opens the \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1.class\u003c/code\u003e file (but the filesystem sees \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$Item$1.class\u003c/code\u003e as an existing match and opens it as an existing file), writes the bytecode for \u003ccode\u003eCompositionTests$testInsertOnMultipleLevels$1$item$1\u003c/code\u003e, and closes the file.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eWhen the project builds on my machine the non-standard, case-sensitive filesystem sees those as separate files and the failure does not occur. On MacOS- and Windows-based CI workers with their filesystem defaults, however, they’re seen as the same and one overwrites the other. This is what leads to the class name of the second appearing in the file name of the first.\u003c/p\u003e\n\n\u003cp\u003eThe fix here is easy: rename one of the functions to produce different names. And in an ironic twist of timing, JetBrains \u003ca href=\"https://android.googlesource.com/platform/frameworks/support/+/f705520d29e250a762c7c8ba354715e3def6fcde%5E!/\"\u003emade the exact fix\u003c/a\u003e to Compose just 12 hours ago.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-fun MockViewValidator.item(number: Int, numbers: List\u0026lt;Int\u0026gt;) {\n\u003c/span\u003e\u003cspan\u003e+fun MockViewValidator.validateItem(number: Int, numbers: List\u0026lt;Int\u0026gt;) {\n\u003c/span\u003e   Linear {\n     // …code…\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eA simple git submodule update and all my problems are now solved.\u003c/p\u003e\n\n\u003cp\u003eOr are they?\u003c/p\u003e\n\n\u003cp\u003eThis is not the first time I have had this problem, and it likely won’t be the last. I would like to make the argument that this is a Kotlin compiler bug. Regardless of whether you are targeting a case-insensitive filesystem, the Kotlin compiler could avoid this entire class of problem by further mangling the name of this otherwise unnamed type to avoid case-insensitive collision.\u003c/p\u003e\n\n\u003cp\u003eYou can trivially reproduce this if you have a case-insensitive filesystem:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ kotlinc Hey.kt\n$ ls Hey*\nHey.class\tHey.kt\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd a minimal reproducer for the more cryptic cause in this post would be:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecomplex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erun\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eNested\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003erun\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Nested\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enested\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003erun\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;String.nested\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elambda\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnit\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elambda\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ kotlinc Complex.kt\n$ ls Complex*\nComplex.kt\tComplexKt$complex$1$Nested$1.class\tComplexKt$complex$1.class\tComplexKt.class\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI have filed \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-47123\"\u003eKT-47123\u003c/a\u003e to advocate that the compiler should automatically prevent this from happening.\u003c/p\u003e\n\n\u003cp\u003eHey Java users you’re not totally immune either!\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eHey\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ehey\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ javac Hey.java\n$ ls Hey*\nHey.class\tHey.java\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI’m confident that \u003cem\u003ethis\u003c/em\u003e year will finally be the year of the Linux desktop to solve all these problems with its case-sensitive-by-default filesystems, right? But until then, having tools which are smarter about filesystem interaction in a world where both case-sensitive and case-insensitive variants exist would go a long way to reducing developer headaches like this.\u003c/p\u003e\n\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2021-06-04T00:00:00Z",
  "modifiedTime": null
}
