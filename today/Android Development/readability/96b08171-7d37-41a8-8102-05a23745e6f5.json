{
  "id": "96b08171-7d37-41a8-8102-05a23745e6f5",
  "title": "Jetpack Compose and Nested Scrolling Interoperability",
  "link": "https://joebirch.co/android/jetpack-compose-and-nested-scrolling-interoperability/",
  "description": "As we migrate our apps to Jetpack Compose, we need to ensure that all existing functionality remains intact. This means that not only the way our UI looks, but the way that it behaves when users interact with it. When recently migrating part of an app to Jetpack Compose, I experienced a broken coordinator layout... Continue reading â†’",
  "author": "hitherejoe",
  "published": "Fri, 07 Jun 2024 05:40:08 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Apps",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Material Design",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 7248,
  "excerpt": "As we migrate our apps to Jetpack Compose, we need to ensure that all existing functionality remains intact. This means that not only the way our UI looks, but the way that it behaves when users interact with it. When recently migrating part of an app to Jetpack Compose, I experienced a broken co",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "As we migrate our apps to Jetpack Compose, we need to ensure that all existing functionality remains intact. This means that not only the way our UI looks, but the way that it behaves when users interact with it. When recently migrating part of an app to Jetpack Compose, I experienced a broken coordinator layout behaviour â€“ the View System Toolbar was no longer collapsing when the nested compose list was being scrolled. This was due to the lack of a coordinator layout behaviour in place. After a little bit of searching, I learnt how to hook into the parent coordinator using a compose modifier. The solution is very simple and but in the blog post, I want to run through the scenario I encountered, in case it helps you in future! The TLDR of this approach is to apply the nestedScroll modifier to the parent composable, allowing the composable to hook into the nested scrolling hierarchy of your layout. If you want to read more into this approach, please read the rest of this blog post ðŸš€ LazyColumn( modifier = Modifier.nestedScroll( rememberNestedScrollInteropConnection() ) ) My new book,Â CI/CD for Android using GitHub ActionsÂ is now available ðŸš€ Existing View Components Before we get started, letâ€™s take a look at an example of what our existing app looks like. We can see here that we have two tabs with different content, showing the app bar and bottom bar collapsing/revealing as the content is scrolled. When it comes to this setup in our apps, it is a pretty traditional approach using the Android View System. We have a CoordinatorLayout that contains several children â€“ an AppBarLayout, fragment and BottomNavigationView, each of which we can see in the demo above. \u003candroidx.coordinatorlayout.widget.CoordinatorLayout\u003e \u003ccom.google.android.material.appbar.AppBarLayout/\u003e \u003cfragment android:id=\"@+id/fragment_content\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:defaultNavHost=\"true\" app:navGraph=\"@navigation/nav_graph\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /\u003e \u003ccom.google.android.material.bottomnavigation.BottomNavigationView\u003e \u003c/androidx.coordinatorlayout.widget.CoordinatorLayout\u003e For each of the tabs being shown for the BottomNavigationView, there is a fragment which contains a RecyclerView and corresponding adapter to show the list of content. This is pretty standard for what we would see in applications using the Android View System. class FirstFragment : Fragment() { private var _binding: FragmentFirstBinding? = null private val binding get() = _binding!! override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { _binding = FragmentFirstBinding.inflate(inflater, container, false) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) // setup recycler view data for adapter } } Moving to Compose I am starting to convert my application to compose, but I want to do this strategically and avoid massive rewrites. To achieve this, Iâ€™m utilising compose interoperability features so that I only need to migrate the content of the fragment, as opposed to the fragment itself and any of the parent content. To achieve this, the onCreateView of my fragment is going to return a ComposeView which composes the equivalent UI for the screen â€“ this moves away from the use of the XML layout for the fragment and any corresponding children (such as the RecyclerView). Note: For example sake, I am directly composing the content inside of the fragment, splitting this out into a separate composable file would help the readability of my project. class FirstFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { return ComposeView(requireContext()).apply { setContent { LazyColumn { ... } } } } } While we have greatly simplified the layout code of our fragment, we can see now that the behaviour of the coordinator children has broken â€“ the AppBarLayout and BottomNavigationView now longer collapse/reveal as the content is scrolled. The reason for this is that while the XML declaration for the fragment in our root layout states a layout_behaviour attribute (the BottomNavigationView has something similar), this does not work with Compose out of the box. Because we have migrated the content of the screen to Compose, and in turn removed the RecyclerView that previously hooked into this layout_behaviour, the scroll events are no longer being propagated up and out of our child fragments. \u003cfragment android:id=\"@+id/fragment_content\" android:name=\"androidx.navigation.fragment.NavHostFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:defaultNavHost=\"true\" app:navGraph=\"@navigation/nav_graph\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /\u003e Supporting Nested Scrolls As we can see this is a degraded experience from the existing implementation, but the fix is pretty simple. Luckily for us, we can utilise the nestedScroll modifier which tells our composable to participate in the nested scrolling hierarchy. When using this modifier, we provide a required reference to the NestedScrollConnection class â€“ this enables interoperability between the parent view and the nested composable, enabling the use of the layout_behaviour in the parent layout. This is our bridge between Compose and the View system when it comes to nested scrolling. class FirstFragment : Fragment() { override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { return ComposeView(requireContext()).apply { setContent { LazyColumn( modifier = Modifier.nestedScroll( rememberNestedScrollInteropConnection() ) ) { ... } } } } } With this modifier now in place, we can see that the scrolling behaviours now behave as expected for our Compose migration, meaning that now experience here has degraded. As we can see from this post, the solution to this problem has been a very effort fix â€“ the team behind compose has thought about many different use cases where these bridges are needed between Compose and Views. Good interoperability support is what allows us to take an incremental approach when adopting Jetpack Compose in our apps, as in this case, this would have been a blocker and required more engineering effort to fix using a custom solution. As I migrate more of my apps to compose, Iâ€™m looking forward to discovering more features such as this!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eAs we migrate our apps to Jetpack Compose, we need to ensure that all existing functionality remains intact. This means that not only the way our UI looks, but the way that it behaves when users interact with it.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen recently migrating part of an app to Jetpack Compose, I experienced a broken coordinator layout behaviour â€“ the View System Toolbar was no longer collapsing when the nested compose list was being scrolled. This was due to the lack of a coordinator layout behaviour in place. After a little bit of searching, I learnt how to hook into the parent coordinator using a compose modifier. The solution is very simple and but in the blog post, I want to run through the scenario I encountered, in case it helps you in future!\u003c/p\u003e\n\n\n\n\u003cp\u003eThe TLDR of this approach is to apply the \u003cstrong\u003enestedScroll\u003c/strong\u003e modifier to the parent composable, allowing the composable to hook into the nested scrolling hierarchy of your layout. If you want to read more into this approach, please read the rest of this blog post ðŸš€\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eLazyColumn(\n    modifier = Modifier.nestedScroll(\n        rememberNestedScrollInteropConnection()\n    )\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eMy new book,Â \u003ca href=\"https://androidactions.com/\"\u003eCI/CD for Android using GitHub Actions\u003c/a\u003eÂ is now available ðŸš€\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eExisting View Components\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore we get started, letâ€™s take a look at an example of what our existing app looks like. We can see here that we have two tabs with different content, showing the app bar and bottom bar collapsing/revealing as the content is scrolled.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo autoplay=\"\" loop=\"\" muted=\"\" src=\"https://joebirch.co/wp-content/uploads/2024/06/one.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen it comes to this setup in our apps, it is a pretty traditional approach using the Android View System. We have a \u003cstrong\u003eCoordinatorLayout\u003c/strong\u003e that contains several children â€“ an \u003cstrong\u003eAppBarLayout\u003c/strong\u003e, \u003cstrong\u003efragment\u003c/strong\u003e and \u003cstrong\u003eBottomNavigationView\u003c/strong\u003e, each of which we can see in the demo above.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"xml\"\u003e\u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt;\n\n    \u0026lt;com.google.android.material.appbar.AppBarLayout/\u0026gt;\n\n    \u0026lt;fragment\n        android:id=\u0026#34;@+id/fragment_content\u0026#34;\n        android:name=\u0026#34;androidx.navigation.fragment.NavHostFragment\u0026#34;\n        android:layout_width=\u0026#34;match_parent\u0026#34;\n        android:layout_height=\u0026#34;match_parent\u0026#34;\n        app:defaultNavHost=\u0026#34;true\u0026#34;\n        app:navGraph=\u0026#34;@navigation/nav_graph\u0026#34;\n        app:layout_behavior=\u0026#34;@string/appbar_scrolling_view_behavior\u0026#34; /\u0026gt;\n\n    \u0026lt;com.google.android.material.bottomnavigation.BottomNavigationView\u0026gt;\n\u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor each of the tabs being shown for the BottomNavigationView, there is a fragment which contains a RecyclerView and corresponding adapter to show the list of content. This is pretty standard for what we would see in applications using the Android View System.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass FirstFragment : Fragment() {\n\n    private var _binding: FragmentFirstBinding? = null\n    private val binding get() = _binding!!\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentFirstBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        // setup recycler view data for adapter\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eMoving to Compose\u003c/h2\u003e\n\n\n\n\u003cp\u003eI am starting to convert my application to compose, but I want to do this strategically and avoid massive rewrites. To achieve this, Iâ€™m utilising compose interoperability features so that I only need to migrate the content of the fragment, as opposed to the fragment itself and any of the parent content. To achieve this, the \u003cstrong\u003eonCreateView\u003c/strong\u003e of my fragment is going to return a \u003cstrong\u003eComposeView\u003c/strong\u003e which composes the equivalent UI for the screen â€“ this moves away from the use of the XML layout for the fragment and any corresponding children (such as the RecyclerView). \u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For example sake, I am directly composing the content inside of the fragment, splitting this out into a separate composable file would help the readability of my project.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass FirstFragment : Fragment() {\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n\n        return ComposeView(requireContext()).apply {\n            setContent {\n                LazyColumn  {\n                    ...\n                }\n            }\n        }\n\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhile we have greatly simplified the layout code of our fragment, we can see now that the behaviour of the coordinator children has broken â€“ the AppBarLayout and BottomNavigationView now longer collapse/reveal as the content is scrolled. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo autoplay=\"\" loop=\"\" muted=\"\" src=\"https://joebirch.co/wp-content/uploads/2024/06/two.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe reason for this is that while the XML declaration for the fragment in our root layout states a \u003cstrong\u003elayout_behaviour\u003c/strong\u003e attribute (the BottomNavigationView has something similar), this does not work with Compose out of the box. Because we have migrated the content of the screen to Compose, and in turn removed the RecyclerView that previously hooked into this layout_behaviour, the scroll events are no longer being propagated up and out of our child fragments.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"xml\"\u003e\u0026lt;fragment\n        android:id=\u0026#34;@+id/fragment_content\u0026#34;\n        android:name=\u0026#34;androidx.navigation.fragment.NavHostFragment\u0026#34;\n        android:layout_width=\u0026#34;match_parent\u0026#34;\n        android:layout_height=\u0026#34;match_parent\u0026#34;\n        app:defaultNavHost=\u0026#34;true\u0026#34;\n        app:navGraph=\u0026#34;@navigation/nav_graph\u0026#34;\n        app:layout_behavior=\u0026#34;@string/appbar_scrolling_view_behavior\u0026#34; /\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eSupporting Nested Scrolls\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs we can see this is a degraded experience from the existing implementation, but the fix is pretty simple. Luckily for us, we can utilise the \u003cstrong\u003enestedScroll\u003c/strong\u003e modifier which tells our composable to participate in the nested scrolling hierarchy. When using this modifier, we provide a required reference to the \u003cstrong\u003eNestedScrollConnection\u003c/strong\u003e class â€“ this enables interoperability between the parent view and the nested composable, enabling the use of the \u003cstrong\u003elayout_behaviour\u003c/strong\u003e in the parent layout. This is our bridge between Compose and the View system when it comes to nested scrolling.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass FirstFragment : Fragment() {\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        return ComposeView(requireContext()).apply {\n            setContent {\n                LazyColumn(\n                    modifier = Modifier.nestedScroll(\n                        rememberNestedScrollInteropConnection()\n                    )\n                ) {\n                    ...\n                }\n            }\n        }\n\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this modifier now in place, we can see that the scrolling behaviours now behave as expected for our Compose migration, meaning that now experience here has degraded.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo autoplay=\"\" loop=\"\" muted=\"\" src=\"https://joebirch.co/wp-content/uploads/2024/06/ezgif-3-0a994e1b5e-1.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eAs we can see from this post, the solution to this problem has been a very effort fix â€“ the team behind compose has thought about many different use cases where these bridges are needed between Compose and Views. Good interoperability support is what allows us to take an incremental approach when adopting Jetpack Compose in our apps, as in this case, this would have been a blocker and required more engineering effort to fix using a custom solution. As I migrate more of my apps to compose, Iâ€™m looking forward to discovering more features such as this!\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-06-07T05:40:08Z",
  "modifiedTime": "2024-06-07T05:44:01Z"
}
