{
  "id": "98d5aa55-c885-4717-b9a7-010c9acc07b1",
  "title": "Bundling Things Nice and Pretty üíù",
  "link": "https://zarah.dev/2023/08/21/bundle-parcel.html",
  "description": "Of all the projects that I have worked on over the years, one thing they all have in common is the need to pass things around. Whether passing stuff to an Activity as Intent extras, a Fragment as arguments or its onSaveInstanceState, or even a ViewModel‚Äôs SavedStateHandle, the most common way to do it is through a Bundle.",
  "author": "Zarah Dominguez",
  "published": "2023-08-21T00:00:00+00:00",
  "source": "https://zarah.dev/feed.xml",
  "categories": [
    "android",
    "parcelize"
  ],
  "byline": "",
  "length": 6654,
  "excerpt": "Of all the projects that I have worked on over the years, one thing they all have in common is the need to pass things around. Whether passing stuff to an Ac...",
  "siteName": "",
  "favicon": "https://zarah.dev/assets/images/apple-touch-icon.png",
  "text": "Of all the projects that I have worked on over the years, one thing they all have in common is the need to pass things around. Whether passing stuff to an Activity as Intent extras, a Fragment as arguments or its onSaveInstanceState, or even a ViewModel‚Äôs SavedStateHandle, the most common way to do it is through a Bundle. An Activity can accept different types of data through the various putExtra methods, such as the usual int, boolean, long, etc., array versions of these types, or even Parcelables. Let‚Äôs take this data class, for example: data class Person( val name: String, val rank: Int, // ...other fields omitted ) Say we have another Activity called DetailActivity that needs the Person‚Äôs name and the rank. We can pass these values individually via the relevant putExtra calls: val detailIntent = Intent(this, DetailActivity::class.java) detailIntent.putExtra(DetailActivity.EXTRA_KEY_NAME, person.name) detailIntent.putExtra(DetailActivity.EXTRA_KEY_RANK, person.rank) Note: In most circumstances, we would need to pass around minimal information such as an ID. However, there may be instances where we have to deal with more complex structures ‚Äì for example, when a user is applying filters to a list. For the purposes of this post, we will deal with multiple properties of a data class. Here, I opted to define the String values for the keys as const vals in a companion object in DetailActivity so I don‚Äôt have to type them over and over again: class DetailActivity : AppCompatActivity() { // ... companion object { const val EXTRA_KEY_NAME = \"dev.zarah.person.name\" const val EXTRA_KEY_RANK = \"dev.zarah.person.rank\" } } And retrieve them in DetailActivity: override fun onCreate(savedInstanceState: Bundle?) { val name = intent.getStringExtra(EXTRA_KEY_NAME) val rank = intent.getIntExtra(EXTRA_KEY_RANK, 0) } This works, but IMHO it‚Äôs not ideal. For one, we need to be extra careful that we are using the correct get***Extra call when retrieving the data. If we need to add another value to be passed, we need to change the code in a bunch of places: we need to add a new key in the companion object, add another putExtra call in the originating Activity, and add another get***Extra call in the receiving Activity. If for some reason we need to change the type of any one of the extras, we should not forget to change the get***Extra call. The IDE cannot help us here, and we need to rely on our tests to catch any mismatch. If we are working with Fragments, the idea is similar but we need wrap the values together in a Bundle before sending them through as arguments. An Activity can also accept a Bundle as an extra, so we can use the bundleOf convenience function to do the wrapping up: val bundle = bundleOf( DetailFragment.EXTRA_KEY_NAME to person.name, DetailFragment.EXTRA_KEY_RANK to person.rank, ) // Passing into a `Fragment` val fragment = DetailFragment() fragment.arguments = bundle // Passing into an `Activity`: val detailIntent = Intent(this, DetailActivity::class.java) detailIntent.putExtra(DetailActivity.EXTRA_KEY_AS_BUNDLE, bundle) I think the Bundle approach is slightly better for an Activity because it groups the information into one thing and if we want to refactor the Activity into a Fragment in the future, we already have a Bundle of stuff that we can use. However, we still need to remember to use the correct get*** methods when retrieving values from the Bundle: val bundleFromExtra = requireNotNull(intent.getBundleExtra(EXTRA_KEY_AS_BUNDLE)) val nameFromBundle = bundleFromExtra.getString(EXTRA_KEY_NAME) val rankFromBundle = bundleFromExtra.getInt(EXTRA_KEY_RANK) Parcel-ing it up üéÅ The good news is that we can improve our implementation even more by using a Parcelable, which both Activity and Fragment accept. I remember in my early days as an Android dev, I did not want to touch Parcels with a ten-foot pole. But those days are gone and we now have the Parcelable implementation generator that handles the boilerplate code required by Parcelable. Going back to our example above, we can make a data class that would encapsulate the data we need to pass, annotate it with @Parcelize, and have it implement the Parcelable interface: @Parcelize data class DetailsExtras( val name: String, val rank: Int, ) : Parcelable In some cases, there may not be a need to create a new data class just for extras or arguments. Annotating the Person class may work just as well if we need to pass everything that data class contains. For now, let us assume that there we do not want to pass through other information from Person, or perhaps we want to cobble together information from different models and thus need a new data class. We can make a new instance of this DetailsExtras data class so we can pass it to an Activity or Fragment: val detailExtras = DetailActivity.Companion.DetailsExtras( name = person.name, rank = person.rank, ) detailIntent.putExtra(DetailActivity.EXTRA_KEY_AS_PARCEL, detailExtras) startActivity(detailIntent) This is obviously personal preference, but when I need a data class for encapsulating extras I like putting in a companion object together with the key for the extra so that they live close together. Retrieving the values is the same as before, except we only need to remember to retrieve a Parcelable: // Pre-API33 val extras = requireNotNull(intent.getParcelableExtra\u003cDetailsExtras\u003e(EXTRA_KEY_AS_PARCEL)) // API33+ val extras = requireNotNull(intent.getParcelableExtra(EXTRA_KEY_AS_PARCEL, DetailsExtras::class.java)) val name = extras.name val rank = extras.rank With this approach, we do not have to worry about the types of name or rank because Kotlin is smart and can help us figure it out. Adding more stuff to our stuff üìù What I really like about this approach is that it makes the code really predictable. There is no guessing which values may or may not be there, no guessing what types each of the values are, and any default values can be incorporated into the data class itself. This also makes our implementation scalable and flexible ‚Äì we can even nest other data classes inside it if we so choose. But perhaps the biggest benefit of all in my opinion is making the IDE do a lot of the thinking for us. Since we are using a data class, adding or removing a property (or changing its type) causes the IDE to flag all the places we need to update. And if there‚Äôs one thing I know for sure, it‚Äôs that the earlier I let the IDE flag any errors before I need to rebuild my project, the better. üèÅ",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eOf all the projects that I have worked on over the years, one thing they all have in common is the need to pass things around. Whether passing stuff to an \u003ccode\u003eActivity\u003c/code\u003e as \u003ccode\u003eIntent\u003c/code\u003e extras, a \u003ccode\u003eFragment\u003c/code\u003e as arguments or its \u003ccode\u003eonSaveInstanceState\u003c/code\u003e, or even a \u003ccode\u003eViewModel\u003c/code\u003e‚Äôs \u003ccode\u003eSavedStateHandle\u003c/code\u003e, the most common way to do it is through a \u003ca href=\"https://developer.android.com/reference/android/os/Bundle\"\u003e\u003ccode\u003eBundle\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn \u003ccode\u003eActivity\u003c/code\u003e can accept different types of data through the various \u003ccode\u003eputExtra\u003c/code\u003e methods, such as the usual \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eboolean\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, etc., array versions of these types, or even \u003ccode\u003eParcelable\u003c/code\u003es.\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs take this data class, for example:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata class\u003c/span\u003e \u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003erank\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003e// ...other fields omitted\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSay we have another \u003ccode\u003eActivity\u003c/code\u003e called \u003ccode\u003eDetailActivity\u003c/code\u003e that needs the \u003ccode\u003ePerson\u003c/code\u003e‚Äôs  \u003ccode\u003ename\u003c/code\u003e and the \u003ccode\u003erank\u003c/code\u003e. We can pass these values individually via the relevant \u003ccode\u003eputExtra\u003c/code\u003e calls:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edetailIntent\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIntent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003edetailIntent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eputExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_NAME\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003edetailIntent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eputExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_RANK\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erank\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: In most circumstances, we would need to pass around minimal information such as an \u003ccode\u003eID\u003c/code\u003e. However, there may be instances where we have to deal with more complex structures ‚Äì for example, when a user is applying filters to a list. For the purposes of this post, we will deal with multiple properties of a \u003ccode\u003edata class\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere, I opted to define the \u003ccode\u003eString\u003c/code\u003e values for the keys as \u003ccode\u003econst val\u003c/code\u003es in a \u003ccode\u003ecompanion object\u003c/code\u003e in \u003ccode\u003eDetailActivity\u003c/code\u003e so I don‚Äôt have to type them over and over again:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eDetailActivity\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAppCompatActivity\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// ...\u003c/span\u003e\n\n    \u003cspan\u003ecompanion\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eEXTRA_KEY_NAME\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;dev.zarah.person.name\u0026#34;\u003c/span\u003e\n        \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eEXTRA_KEY_RANK\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;dev.zarah.person.rank\u0026#34;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd retrieve them in \u003ccode\u003eDetailActivity\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonCreate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esavedInstanceState\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBundle\u003c/span\u003e\u003cspan\u003e?)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eintent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetStringExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_NAME\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003erank\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eintent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetIntExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_RANK\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis works, but IMHO it‚Äôs not ideal. For one, we need to be extra careful that we are using the correct \u003ccode\u003eget***Extra\u003c/code\u003e call when retrieving the data. If we need to add another value to be passed, we need to change the code in a bunch of places: we  need to add a new key in the \u003ccode\u003ecompanion object\u003c/code\u003e, add another \u003ccode\u003eputExtra\u003c/code\u003e call in the originating \u003ccode\u003eActivity\u003c/code\u003e, and add another \u003ccode\u003eget***Extra\u003c/code\u003e call in the receiving \u003ccode\u003eActivity\u003c/code\u003e. If for some reason we need to change the type of any one of the extras, we should not forget to change the \u003ccode\u003eget***Extra\u003c/code\u003e call. The IDE cannot help us here, and we need to rely on our tests to catch any mismatch.\u003c/p\u003e\n\n\u003cp\u003eIf we are working with \u003ccode\u003eFragment\u003c/code\u003es, the idea is similar but we need wrap the values together in a \u003ccode\u003eBundle\u003c/code\u003e before sending them through as \u003ccode\u003earguments\u003c/code\u003e. An \u003ccode\u003eActivity\u003c/code\u003e can also accept a \u003ccode\u003eBundle\u003c/code\u003e as an extra, so we can use the \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/core/os/package-summary#bundleOf(kotlin.Array)\"\u003e\u003ccode\u003ebundleOf\u003c/code\u003e convenience function\u003c/a\u003e to do the wrapping up:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ebundle\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebundleOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003eDetailFragment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_NAME\u003c/span\u003e \u003cspan\u003eto\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003eDetailFragment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_RANK\u003c/span\u003e \u003cspan\u003eto\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erank\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// Passing into a `Fragment`\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003efragment\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDetailFragment\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003efragment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003earguments\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebundle\u003c/span\u003e\n\n\u003cspan\u003e// Passing into an `Activity`:\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edetailIntent\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eIntent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003edetailIntent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eputExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_AS_BUNDLE\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ebundle\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI think the \u003ccode\u003eBundle\u003c/code\u003e approach is \u003cem\u003eslightly\u003c/em\u003e better for an \u003ccode\u003eActivity\u003c/code\u003e because it groups the information into one thing and if we want to refactor the \u003ccode\u003eActivity\u003c/code\u003e into a \u003ccode\u003eFragment\u003c/code\u003e in the future, we already have a \u003ccode\u003eBundle\u003c/code\u003e of stuff that we can use. However, we still need to remember to use the correct \u003ccode\u003eget***\u003c/code\u003e methods when retrieving values from the \u003ccode\u003eBundle\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ebundleFromExtra\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erequireNotNull\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eintent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetBundleExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_AS_BUNDLE\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003enameFromBundle\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebundleFromExtra\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetString\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_NAME\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003erankFromBundle\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ebundleFromExtra\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetInt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_RANK\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"parcel-ing-it-up-\"\u003e\u003ccode\u003eParcel\u003c/code\u003e-ing it up üéÅ\u003c/h3\u003e\n\u003cp\u003eThe good news is that we can improve our implementation even more by using a \u003ca href=\"https://developer.android.com/reference/android/os/Parcelable\"\u003e\u003ccode\u003eParcelable\u003c/code\u003e\u003c/a\u003e, which both \u003ccode\u003eActivity\u003c/code\u003e and \u003ccode\u003eFragment\u003c/code\u003e accept. I remember in my early days as an Android dev, I did not want to touch \u003ccode\u003eParcel\u003c/code\u003es with a ten-foot pole. But those days are gone and we now have the \u003ca href=\"https://developer.android.com/kotlin/parcelize\"\u003e\u003ccode\u003eParcelable\u003c/code\u003e implementation generator\u003c/a\u003e that handles the boilerplate code required by \u003ccode\u003eParcelable\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eGoing back to our example above, we can make a data class that would encapsulate the data we need to pass, annotate it with \u003ccode\u003e@Parcelize\u003c/code\u003e, and have it implement the \u003ccode\u003eParcelable\u003c/code\u003e interface:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@Parcelize\u003c/span\u003e\n\u003cspan\u003edata class\u003c/span\u003e \u003cspan\u003eDetailsExtras\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003erank\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eParcelable\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn some cases, there may not be a need to create a new \u003ccode\u003edata class\u003c/code\u003e just for extras or arguments. Annotating the \u003ccode\u003ePerson\u003c/code\u003e class may work just as well if we need to pass everything that \u003ccode\u003edata class\u003c/code\u003e contains. For now, let us assume that there we do not want to pass through other information from \u003ccode\u003ePerson\u003c/code\u003e, or perhaps we want to cobble together information from different models and thus need a new \u003ccode\u003edata class\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWe can make a new instance of this \u003ccode\u003eDetailsExtras\u003c/code\u003e \u003ccode\u003edata class\u003c/code\u003e so we can pass it to an \u003ccode\u003eActivity\u003c/code\u003e or \u003ccode\u003eFragment\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edetailExtras\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eCompanion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eDetailsExtras\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003erank\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erank\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \n        \u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003edetailIntent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eputExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDetailActivity\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_AS_PARCEL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edetailExtras\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003estartActivity\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edetailIntent\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is obviously personal preference, but when I need a \u003ccode\u003edata class\u003c/code\u003e for encapsulating extras I like putting in a \u003ccode\u003ecompanion object\u003c/code\u003e together with the key for the extra so that they live close together.\u003c/p\u003e\n\n\u003cp\u003eRetrieving the values is the same as before, except we only need to remember to retrieve a \u003ccode\u003eParcelable\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Pre-API33\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eextras\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erequireNotNull\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eintent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetParcelableExtra\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eDetailsExtras\u003c/span\u003e\u003cspan\u003e\u0026gt;(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_AS_PARCEL\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\n\u003cspan\u003e// API33+\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eextras\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erequireNotNull\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eintent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetParcelableExtra\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eEXTRA_KEY_AS_PARCEL\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eDetailsExtras\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eextras\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003erank\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eextras\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erank\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWith this approach, we do not have to worry about the types of \u003ccode\u003ename\u003c/code\u003e or \u003ccode\u003erank\u003c/code\u003e because Kotlin is smart and can help us figure it out.\u003c/p\u003e\n\n\u003ch3 id=\"adding-more-stuff-to-our-stuff-\"\u003eAdding more stuff to our stuff üìù\u003c/h3\u003e\n\u003cp\u003eWhat I really like about this approach is that it makes the code really predictable. There is no guessing which values may or may not be there, no guessing what types each of the values are, and any default values can be incorporated into the data class itself.\u003c/p\u003e\n\n\u003cp\u003eThis also makes our implementation scalable and flexible ‚Äì we can even nest other \u003ccode\u003edata class\u003c/code\u003ees inside it if we so choose.\u003c/p\u003e\n\n\u003cp\u003eBut perhaps the biggest benefit of all in my opinion is making the IDE do a lot of the thinking for us. Since we are using a \u003ccode\u003edata class\u003c/code\u003e, adding or removing a property (or changing its type) causes the IDE to flag all the places we need to update.\u003c/p\u003e\n\n\u003cp\u003eAnd if there‚Äôs one thing I know for sure, it‚Äôs that the earlier I let the IDE flag any errors before I need to rebuild my project, the better. üèÅ\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
