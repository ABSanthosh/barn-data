{
  "id": "3a3e9233-6751-40fb-8898-3694af3ba0f1",
  "title": "Coroutines and Dispatchers",
  "link": "https://medium.com/mindorks/coroutines-and-dispatchers-b559094b828e?source=rss----f1a763fc7443--android",
  "description": "",
  "author": "Bigyan Thapa",
  "published": "Wed, 16 Oct 2024 06:48:00 GMT",
  "source": "https://medium.com/feed/mindorks/tagged/android",
  "categories": [
    "best-practices",
    "androiddev",
    "coroutine",
    "android",
    "kotlin"
  ],
  "byline": "Bigyan Thapa",
  "length": 3405,
  "excerpt": "In Android development, coroutines are commonly launched from ViewModel classes using viewModelScope. The typical usage looks like this: In Android development, coroutines are commonly launched from…",
  "siteName": "MindOrks",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Coroutines and DispatchersIn Android development, coroutines are commonly launched from ViewModel classes using viewModelScope. The typical usage looks like this:viewModelScope.launch { // ... implementation}In Android development, coroutines are commonly launched from ViewModel classes using viewModelScope. The typical usage looks like this:viewModelScope.launch { // … implementation}By default, if a dispatcher is not specified, any coroutine launched in viewModelScope will run on the main thread. However, in most use cases, we launch these coroutines to perform background tasks, such as — making API calls, or database operations. To ensure these tasks run in the background thread, it is essential to specify an appropriate dispatcher:I/O tasks should use Dispatchers.IOCPU-intensive tasks should use Dispatchers.DefaultUI updates should use Dispatchers.MainFor example, to run an I/O task, we can specify the dispatcher like this:viewModelScope.launch(Dispatchers.IO) { // ...implementation}Optimizing Coroutine LaunchingTo streamline coroutine launching, we can create extension functions on ViewModel that automatically use the specified dispatcher by default.Step 1: Create Extension FunctionsWe can define extension functions for different dispatchers:kotlinfun ViewModel.launchIO(block: suspend CoroutineScope.() -\u003e Unit) { viewModelScope.launch(Dispatchers.IO, block = block)}fun ViewModel.launchDefault(block: suspend CoroutineScope.() -\u003e Unit) { viewModelScope.launch(Dispatchers.Default, block = block)}fun ViewModel.launchMain(block: suspend CoroutineScope.() -\u003e Unit) { viewModelScope.launch(Dispatchers.Main, block = block)}Step 2: Use the Extension FunctionsYou can now use these extension functions in your ViewModel as follows:class MyViewModel : ViewModel() { fun fetchData() { launchIO { // … implementation } }}BenefitsConsistency: These extension functions maintain consistent coroutine usage for specific tasks.Readability: The function names clearly indicate their purpose, making the code easier to understand.Maintainability: Centralizing dispatcher management simplifies updates and modifications over time.Optional: Single Extension Function with OverloadingAs an alternative, you can create a single extension function that accepts a dispatcher as a parameter. By default, this function can run on the I/O dispatcher:fun ViewModel.launchOn(dispatcher: CoroutineDispatcher = Dispatchers.IO, block: suspend CoroutineScope.() -\u003e Unit) { viewModelScope.launch(dispatcher, block = block)}Example UsageWe can then use this overloaded function for different dispatchers:class MyViewModel : ViewModel() { fun someDatabaseOperation() { launchOn(Dispatchers.IO) { // … implementation } } fun someUiUpdates() { launchOn(Dispatchers.Main) { // … implementation } } fun someCPUIntensiveTask() { launchOn(Dispatchers.Default) { // … implementation } }}ConclusionImplementing a structured approach to launching coroutines in your ViewModel helps improve code quality, maintainability, and readability. By utilizing extension functions or a flexible overloaded function, you can ensure that your coroutines run on the appropriate dispatcher, aligning with best practices in Android development.Thank you for reading. Please share feedback!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*zwGCLQ2qqBwzHegoGYDgNg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"1b50\" data-testid=\"storyTitle\"\u003eCoroutines and Dispatchers\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@bigyan4424?source=post_page---byline--b559094b828e---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Bigyan Thapa\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*1HzYrs09Lw04NCHQw3G_eg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/mindorks?source=post_page---byline--b559094b828e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"MindOrks\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CWnVPd6NnwpcBIJdoUmkYg.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"72ab\"\u003eIn Android development, coroutines are commonly launched from \u003cem\u003eViewModel\u003c/em\u003e classes using \u003cem\u003eviewModelScope\u003c/em\u003e. The typical usage looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9946\"\u003eviewModelScope.launch {\u003cbr/\u003e    // ... implementation\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4d98\"\u003eIn Android development, coroutines are commonly launched from ViewModel classes using \u003cem\u003eviewModelScope\u003c/em\u003e. The typical usage looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1743\"\u003eviewModelScope.launch {\u003cbr/\u003e    // … implementation\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b451\"\u003eBy default, if a dispatcher is not specified, any coroutine launched in \u003cem\u003eviewModelScope\u003c/em\u003e will run on the \u003cstrong\u003emain\u003c/strong\u003e thread. However, in most use cases, we launch these coroutines to perform background tasks, such as — making API calls, or database operations. To ensure these tasks run in the background thread, it is essential to specify an appropriate dispatcher:\u003c/p\u003e\u003cul\u003e\u003cli id=\"dfae\"\u003e\u003cem\u003eI/O tasks\u003c/em\u003e should use \u003cstrong\u003eDispatchers.IO\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"9b06\"\u003e\u003cem\u003eCPU-intensive tasks\u003c/em\u003e should use \u003cstrong\u003eDispatchers.Default\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"961b\"\u003e\u003cem\u003eUI updates\u003c/em\u003e should use \u003cstrong\u003eDispatchers.Main\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9e35\"\u003eFor example, to run an I/O task, we can specify the dispatcher like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7b12\"\u003eviewModelScope.launch(Dispatchers.IO) {\u003cbr/\u003e    // ...implementation\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4dc9\"\u003eOptimizing Coroutine Launching\u003c/h2\u003e\u003cp id=\"fc51\"\u003eTo streamline coroutine launching, we can create extension functions on \u003cem\u003eViewModel\u003c/em\u003e that automatically use the specified dispatcher by default.\u003c/p\u003e\u003ch2 id=\"a1c5\"\u003eStep 1: Create Extension Functions\u003c/h2\u003e\u003cp id=\"8f69\"\u003eWe can define extension functions for different dispatchers:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"41e5\"\u003ekotlin\u003cbr/\u003efun ViewModel.launchIO(block: suspend CoroutineScope.() -\u0026gt; Unit) {\u003cbr/\u003e    viewModelScope.launch(Dispatchers.IO, block = block)\u003cbr/\u003e}\u003cp\u003efun ViewModel.launchDefault(block: suspend CoroutineScope.() -\u0026gt; Unit) {\u003cbr/\u003e    viewModelScope.launch(Dispatchers.Default, block = block)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun ViewModel.launchMain(block: suspend CoroutineScope.() -\u0026gt; Unit) {\u003cbr/\u003e    viewModelScope.launch(Dispatchers.Main, block = block)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"0626\"\u003eStep 2: Use the Extension Functions\u003c/h2\u003e\u003cp id=\"8b29\"\u003eYou can now use these extension functions in your ViewModel as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9afa\"\u003eclass MyViewModel : ViewModel() {\u003cbr/\u003e    fun fetchData() {\u003cbr/\u003e        launchIO {\u003cbr/\u003e            // … implementation\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cbr/\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5b8c\"\u003eBenefits\u003c/h2\u003e\u003cul\u003e\u003cli id=\"5fa5\"\u003e\u003cem\u003eConsistency\u003c/em\u003e: These extension functions maintain consistent coroutine usage for specific tasks.\u003c/li\u003e\u003cli id=\"faa6\"\u003e\u003cem\u003eReadability\u003c/em\u003e: The function names clearly indicate their purpose, making the code easier to understand.\u003c/li\u003e\u003cli id=\"d686\"\u003e\u003cem\u003eMaintainability\u003c/em\u003e: Centralizing dispatcher management simplifies updates and modifications over time.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4b09\"\u003eOptional: Single Extension Function with Overloading\u003c/h2\u003e\u003cp id=\"88a5\"\u003eAs an alternative, you can create a single extension function that accepts a dispatcher as a parameter. By default, this function can run on the I/O dispatcher:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2980\"\u003efun ViewModel.launchOn(dispatcher: CoroutineDispatcher = Dispatchers.IO, block: suspend CoroutineScope.() -\u0026gt; Unit) {\u003cbr/\u003e    viewModelScope.launch(dispatcher, block = block)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7b28\"\u003eExample Usage\u003c/h2\u003e\u003cp id=\"3ff0\"\u003eWe can then use this overloaded function for different dispatchers:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0fc6\"\u003eclass MyViewModel : ViewModel() {\u003cp\u003e    fun someDatabaseOperation() {\u003cbr/\u003e        launchOn(Dispatchers.IO) {\u003cbr/\u003e            // … implementation\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun someUiUpdates() {\u003cbr/\u003e        launchOn(Dispatchers.Main) {\u003cbr/\u003e            // … implementation\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun someCPUIntensiveTask() {\u003cbr/\u003e        launchOn(Dispatchers.Default) {\u003cbr/\u003e            // … implementation\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"23e3\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"fe7b\"\u003eImplementing a structured approach to launching coroutines in your ViewModel helps improve code quality, maintainability, and readability. By utilizing extension functions or a flexible overloaded function, you can ensure that your coroutines run on the appropriate dispatcher, aligning with best practices in Android development.\u003c/p\u003e\u003cp id=\"a64a\"\u003eThank you for reading. Please share feedback!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-10-14T15:19:10.973Z",
  "modifiedTime": null
}
