{
  "id": "15f79ba1-aa3b-4be3-8619-e7768eaf036f",
  "title": "Computed properties with property getters",
  "link": "https://okkotlin.com/computed-properties/",
  "description": "Custom getters and setters for fields in a class is not a new idea. We have been using them since our early days in programming. Kotlinâ€¦",
  "author": "",
  "published": "Sun, 15 Dec 2019 00:00:00 GMT",
  "source": "https://okkotlin.com/rss.xml",
  "categories": null,
  "byline": "",
  "length": 8678,
  "excerpt": "Ever wanted to create a derived property out of some existing ones? Let's see how we can create computed properties with Kotlin property getters.",
  "siteName": "",
  "favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABlmWCKAAAFGUlEQVR4Ae1Zb2wURRT/zc5eqxQM2BZIJQEKUk1D/BewBg0otIAiwcAXEb4ZP0hsAkbUiCQYY4wmajBGiZiYmPiBWEMNH6SUaIEoJhA0Go1FW62FRNuKkYtpe7szvtm73e7e7rW0t6Xc3Uyy2Tdv/r3fb9+8ebsL6KIZ0AxoBjQDmgHNgGZAM6AZ0AyUIgNsvKCH96+5Q1pyEw28T4LdxJiskRLTxzvPVPYv33Xcw21eqSHWm01bbNgvE/g6NUY6AyUIfEGXMQmQbzctTKXEx7a0GwoaaQ7jRyUgtb9xZcoSLfScK3OML3h1TgIUeGmLY+TiiYJHOQoAI6pNub20ZUuxg1fYIz1A7flidnv/Qw95gIr2BL4oA54fuCuHCFBHndtYCvcAASrJoQPeOedLAbzCGCBAZXilAtzFGQiC6fTWbZqCu0HmVNyYXjg1CAz+O+lGBAhQub2b5MaxMpt9M9jcW+laAja9GrK/C/LPTogLPwDJvtASrGoBEo+95+jtn9phf/5qqE/cigABmReb/NcorwB/oBn8ltXBuebf5dSlNQz71EGIc58G26egFowBMbzVscr5SGw/GAIvlUtnCjPLYK56EuYjr1AU4q56Su4BD8jbAmaAN+0Gm1HtTCX/uwT7i3cgfj8LDF0GZs0DX/oQjDu3gDEGY8FykjdDnDmU99ITnSDgAROdxB2ngBlz06eoTA4g9dETEJ1fpsGrTpd6YZ84ALvtdXcIeMN2YMZsrx4pELEoqxi5VD2mEt9MZBBfut4zy+54FyAPiCrixzaIP751mljiehhLVkZ1S+sIrLlhL8p2tDqXuf554JokgIBg5jzHaGmnIH45mRsUtYjODq+dVdV6crbAG5+GsfheRy1+OwPryD4abGV3m3A9Ng9g1Yucfa0skeTqEPaoRsm/e7x2VrXQk/0CX7UDvH6to1IeY322FyBy4yzxBUHLF+XLpo1to7/PUDLU36i9B4yOU1VE7/ewDu8h8MOhfvkqYvMAOdBD3weFYw+7YQ6QMT6Xgcpj3CL/Ou+K3t0FrxSy/1fAR7DXKQYhNgLU05H93Z5JfNmjnhwSKKLz2zZ6apUdRhWZ2Ub89k0wspOqqAET0MVHAC1uf/WhZ4Jz1i9a4dU9gYKlufYZsEzOL/q6IM6f8JpdQfR+B6tlNzwS1uxErljhjpnIPVYCZNfXED3nHDsYN5HYuA/8wRdg1K8DU0nP8q1IbDvgRXUFzskJIgKmvNwHSSTYpz5Iz5e4DubDdAKMsbXGS0J8QTCzsnXkJZjrnoVR2+BoeN39gLqyihxMwj7+FqL2v7+rOHsIoqaeSFsBNrOG5n4OVuuL/i55ybF6gGMJpbxW6x5YJ9+HTPaHjFNPXXR/Q1ni4+ksMdQjrLCOvgb5z0WnQZ0Oxt3bwp2uUMMAyslHCtVHytAbq+P/zzNtFticOnodroSk/S77KKJPwnE2gmIsiXWW72r3vnrFvgVCy1M6LLtPZ36lhVqvuoJBXvAvGv8W8M9+Dcrk4oEcveQIYCY77H8upUUAw89lze3pczrDQkkRwMHphSJYSoYABnba3Nn2SRB+jn+D2Z0KvU6f3wYSprE1CkfRewB9ekwxzjazp9pG3tR8TBQ1AerJM240JpqPdfgwB8SiJUDteXL7ZaOBV0xMfiYY4PsqVOioU9E+KuBFrV7QBND+TkrJLqr0VmV4KsnJPuejQGudZkAzoBnQDGgGNAOaAc2AZkAzoBn4H3WFe3QRC8LrAAAAAElFTkSuQmCC",
  "text": "Custom getters and setters for fields in a class is not a new idea. We have been using them since our early days in programming. Kotlin, however, takes that concept to a more elegant level by allowing us to define getters and setters at the declaration site of our properties. The primary advantage of this feature is the immediate connection we can make between a declared property and the logic that transforms the property. This week, we will be discussing how we can make our code more meaningful and easy to decipher using property getters and setters, a.k.a. computed properties. Computed properties make beautiful code Like type aliases, the best value in using computed properties is to have a slick and readable codebase. There's nothing extra that we can do with a computed property that we cannot do with a plain old method. We can define our own getter and setter methods to make fields return a computed value. The problem with having logic inside our getter methods is that if we mistakenly access the field value instead of its getter, we are skipping our business logic. This approach will result in miscalculations or a lousy output. Having logic inside Kotlin's property getters ensure that there is only one way to access a property, and it will return the correct value every time. Here's an example: var formattedSpeed: String get(): { return \"$field km/h\" } Now, every time we access formattedSpeed, we will get a formatted speed value indicating the unit. We don't have to do a string interpolation ourself every time we set a speed value. formattedSpeed = \"55\" println(\"Speed is $formattedSpeed\") // Output: Speed is 55 km/h This example above might seem like a lame one, but it's just a starting point to get creative. We can also create virtual properties Virtual properties aren't actual fields that you have in a class but are merely wrappers on top of some other property. The following example will clear things up: Suppose we have to build a content management system which lets our users manage multiple publications from a single dashboard. If we want to have a section where we show up all posts across publications, we need to run a loop like the following one everywhere we want the posts to show up: val allPosts = mutableListOf\u003cPost\u003e() publications.forEach { allPosts.addAll(it.posts) } To make this logic reusable, we can wrap it inside a function: fun getAllPosts(): List\u003cPost\u003e { val allPosts = mutableListOf\u003cPost\u003e() publications.forEach { allPosts.addAll(it.posts) } return allPosts } Now, here's a trick. For simple cases like the aggregation shown above, it's way better to declare a computed property like this: val allPosts: List\u003cPost\u003e get() { val aggregate = mutableListOf\u003cPost\u003e() publications.forEach { aggregate.addAll(it.posts) } return aggregate } This change makes accessing all posts from across publication a simple reference to our new virtual property called allPosts. allPosts.forEach { println(it.title) } // Output: Prints out all blog posts titles The reason I'm calling this a virtual property is because this property is not an actual field defined in the class. It's just a wrapper which returns a value calculated from other properties in the class. Also, if we look closely, there's nothing new that we did with a computed property that we couldn't have done with the function getAllPosts(). Defining the property just made our code much more elegant and predictable. Handle computed properties with care The allPosts computed property we just created, can be a hidden mess, if not treated carefully. From a 35,000 ft view all seems reasonable, but if we look closely, each property access is of the time complexity O(N2). A little knowledge of algorithms is enough to tell that this is bad. Sure, computing has evolved, and it's getting faster than ever. However, in some instances, this code can lag our super fast smartphone to an extent where it's noticeable. Take Android's RecyclerView as an example. When a RecyclerView populates a list of data on the screen, it repeatedly calls the bindViewHolder() method as the user scrolls through the list. A heavy operation such as accessing a computed property which takes O(N2) time inside bindViewHolder() can easily cause visible jank while scrolling through a list. This broken experience can go unnoticed when our data set is small, let's say our list contains only ten items. But, let's face it; real-world apps deal with way more data than that. One hidden bug can lead to painful debugging time. If we want or need to use a computed property in these cases, we can either: Make sure the computation logic is fast, or Compute once and pass the result during our class's initialisation In the previous case, instead of accessing the computed property on every bindViewHolder() call, we can pass a previously computed value to the adapter's constructor, like this: class PostsListAdapter(private val allPosts: List\u003cPost\u003e) The computation logic inside the allPosts is run only once when we initialise our PostsListAdapter, no matter how many times the bindViewHolder() method is called. Making them reactive Using computed properties in Vue.js, I was pretty accustomed to the fact that computed properties were de-facto reactive. Reactive means that if a computed property depends on some other property, when that property changes, the computed property gets recalculated. This behaviour usually triggers a view change with the updated result. In Kotlin, sadly, that's not the case. Recalculation will only be done once the property value is set or accessed depending on where we have written our calculation logic. We can achieve a reactive behaviour by using Kotlin's property observer delegate, though. It's a patch but let's see how it can be done. We need a backing property which we will keep updating and route the output through our computed property. Let's say we need to display a formatted speed value to the user whenever the speed gets updated. Here's how we can sprinkle in some reactivity: private var _formattedSpeed: String by Delegates.observable(\"0\") { _, _, _ -\u003e displaySpeed(formattedSpeed) } val formattedSpeed: String get() = \"$_formattedSpeed km/h\" Here, we are observing a private counterpart of our computed property, which we call the \"backing property\". Whenever our backing property changes, we display the change to the user. A little detail here is, on every change of the backing property value, we are querying the value of the computed property and passing it down to our displaySpeed() method. This approach ensures that the updated value goes through the computed property, and necessary transformations are applied before it reaches the user. You'll rarely need to rely on this technique. However, it could be handy to be aware of this possibility. Uh-oh! The stack is full Stacks are nice, but no one wants to overflow their stacks. Similar to recursion, it's pretty easy to get hit on the face with a StackOverflowException if we don't write our computation logic well. In Kotlin, any property we define is not a direct reference to a memory address. This means that every time we access value from a property, it comes through the get() method. A code like this is a sure-shot way to get a StackOverflowException: val formattedSpeed: String get() = \"$formattedSpeed km/h\" Every time we access formattedSpeed, we call it's get() method. Also, in the get() method we are trying to access formattedSpeed, which in turn calls the get() method again. This process continues until the device's stack can't hold any more method calls. Thus, the dreaded StackOverflowException. If we need to access the computed property's actual value, we need to access its backing field instead of the property. The above code becomes: var formattedSpeed: String = \"\" get() = \"$field km/h\" Here, field is the keyword used to access the actual value of a property. Think of it as a direct reference to the memory. It's essential to be aware of this common mistake to avoid losing time in debugging. Making the most out of it Just because computed properties exist, doesn't mean we should never write a simple property again. Language features such as this are most useful when there's a particular use case for them. Like the ones, we discussed above. Look at your code, be creative and think if using computed properties somewhere makes your code better. If not, well, stick to the plain old val goodByeMessage = \"Sayonara!\" . Here's a sketch note on the topic",
  "image": "https://okkotlin.com/images/computed-properties-featured.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eCustom getters and setters for fields in a class is not a new idea. We have been using them since our early days in programming.\u003c/p\u003e\n\u003cp\u003eKotlin, however, takes that concept to a more elegant level by allowing us to define getters and setters at the declaration site of our properties.\u003c/p\u003e\n\u003cp\u003eThe primary advantage of this feature is the immediate connection we can make between a declared property and the logic that transforms the property.\u003c/p\u003e\n\u003cp\u003eThis week, we will be discussing how we can make our code more meaningful and easy to decipher using property getters and setters, a.k.a. \u003cem\u003ecomputed properties\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"computed-properties-make-beautiful-code\"\u003eComputed properties make beautiful code\u003c/h2\u003e\n\u003cp\u003eLike \u003ca href=\"https://okkotlin.com/typealias/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003etype aliases\u003c/a\u003e, the best value in using computed properties is to have a slick and readable codebase.\u003c/p\u003e\n\u003cp\u003eThere\u0026#39;s nothing extra that we can do with a computed property that we cannot do with a plain old method. We can define our own getter and setter methods to make fields return a computed value.\u003c/p\u003e\n\u003cp\u003eThe problem with having logic inside our getter methods is that if we mistakenly access the field value instead of its getter, we are skipping our business logic. This approach will result in miscalculations or a lousy output.\u003c/p\u003e\n\u003cp\u003eHaving logic inside Kotlin\u0026#39;s property getters ensure that there is only one way to access a property, and it will return the correct value every time.\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s an example:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evar\u003c/span\u003e formattedSpeed\u003cspan\u003e:\u003c/span\u003e String\n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$field\u003c/span\u003e km/h\u0026#34;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow, every time we access \u003ccode\u003eformattedSpeed\u003c/code\u003e, we will get a formatted speed value indicating the unit. We don\u0026#39;t have to do a string interpolation ourself every time we set a speed value.\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003eformattedSpeed \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;55\u0026#34;\u003c/span\u003e\n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Speed is \u003cspan\u003e$formattedSpeed\u003c/span\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \n\u003cspan\u003e// Output: Speed is 55 km/h\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis example above might seem like a lame one, but it\u0026#39;s just a starting point to get creative.\u003c/p\u003e\n\u003ch2 id=\"we-can-also-create-virtual-properties\"\u003eWe can also create virtual properties\u003c/h2\u003e\n\u003cp\u003eVirtual properties aren\u0026#39;t actual fields that you have in a class but are merely wrappers on top of some other property.\u003c/p\u003e\n\u003cp\u003eThe following example will clear things up:\u003c/p\u003e\n\u003cp\u003eSuppose we have to build a content management system which lets our users manage multiple publications from a single dashboard. If we want to have a section where we show up all posts across publications, we need to run a loop like the following one everywhere we want the posts to show up:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e allPosts \u003cspan\u003e=\u003c/span\u003e mutableListOf\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \npublications\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    allPosts\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddAll\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eit\u003cspan\u003e.\u003c/span\u003eposts\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTo make this logic reusable, we can wrap it inside a function:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003egetAllPosts\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e allPosts \u003cspan\u003e=\u003c/span\u003e mutableListOf\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \n    publications\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        allPosts\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddAll\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eit\u003cspan\u003e.\u003c/span\u003eposts\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003ereturn\u003c/span\u003e allPosts\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow, here\u0026#39;s a trick. For simple cases like the aggregation shown above, it\u0026#39;s way better to declare a computed property like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e allPosts\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e aggregate \u003cspan\u003e=\u003c/span\u003e mutableListOf\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \n        publications\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            aggregate\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddAll\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eit\u003cspan\u003e.\u003c/span\u003eposts\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \n        \u003cspan\u003ereturn\u003c/span\u003e aggregate\n    \u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis change makes accessing all posts from across publication a simple reference to our new virtual property called \u003ccode\u003eallPosts\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003eallPosts\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eit\u003cspan\u003e.\u003c/span\u003etitle\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n    \n\u003cspan\u003e// Output: Prints out all blog posts titles\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe reason I\u0026#39;m calling this a virtual property is because this property is not an actual field defined in the class. It\u0026#39;s just a wrapper which returns a value calculated from other properties in the class.\u003c/p\u003e\n\u003cp\u003eAlso, if we look closely, there\u0026#39;s nothing new that we did with a computed property that we couldn\u0026#39;t have done with the function \u003ccode\u003egetAllPosts()\u003c/code\u003e. Defining the property just made our code much more elegant and predictable.\u003c/p\u003e\n\u003ch2 id=\"handle-computed-properties-with-care\"\u003eHandle computed properties with care\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eallPosts\u003c/code\u003e computed property we just created, can be a hidden mess, if not treated carefully. From a 35,000 ft view all seems reasonable, but if we look closely, each property access is of the time complexity O(N\u003csup\u003e2\u003c/sup\u003e).\u003c/p\u003e\n\u003cp\u003eA little knowledge of algorithms is enough to tell that this is bad. Sure, computing has evolved, and it\u0026#39;s getting faster than ever. However, in some instances, this code can lag our super fast smartphone to an extent where it\u0026#39;s noticeable.\u003c/p\u003e\n\u003cp\u003eTake Android\u0026#39;s \u003ccode\u003eRecyclerView\u003c/code\u003e as an example. When a \u003ccode\u003eRecyclerView\u003c/code\u003e populates a list of data on the screen, it repeatedly calls the \u003ccode\u003ebindViewHolder()\u003c/code\u003e method as the user scrolls through the list.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/f27b6/computed-properties-list.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"List of items\" title=\"List of items\" src=\"https://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/dbb61/computed-properties-list.png\" srcset=\"https://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/19bd1/computed-properties-list.png 163w,\nhttps://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/d3bcb/computed-properties-list.png 325w,\nhttps://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/dbb61/computed-properties-list.png 650w,\nhttps://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/6b691/computed-properties-list.png 975w,\nhttps://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/91670/computed-properties-list.png 1300w,\nhttps://okkotlin.com/static/6c4d1a72f0166e15a7c80f32aa7f8923/f27b6/computed-properties-list.png 2146w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eA heavy operation such as accessing a computed property which takes O(N\u003csup\u003e2\u003c/sup\u003e) time inside \u003ccode\u003ebindViewHolder()\u003c/code\u003e can easily cause visible jank while scrolling through a list.\u003c/p\u003e\n\u003cp\u003eThis broken experience can go unnoticed when our data set is small, let\u0026#39;s say our list contains only ten items. But, let\u0026#39;s face it; real-world apps deal with way more data than that. One hidden bug can lead to painful debugging time.\u003c/p\u003e\n\u003cp\u003eIf we want or need to use a computed property in these cases, we can either:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMake sure the computation logic is fast, or\u003c/li\u003e\n\u003cli\u003eCompute once and pass the result during our class\u0026#39;s initialisation\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the previous case, instead of accessing the computed property on every \u003ccode\u003ebindViewHolder()\u003c/code\u003e call, we can pass a previously computed value to the adapter\u0026#39;s constructor, like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePostsListAdapter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e allPosts\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003ePost\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe computation logic inside the \u003ccode\u003eallPosts\u003c/code\u003e is run only once when we initialise our \u003ccode\u003ePostsListAdapter\u003c/code\u003e, no matter how many times the \u003ccode\u003ebindViewHolder()\u003c/code\u003e method is called.\u003c/p\u003e\n\u003ch2 id=\"making-them-reactive\"\u003eMaking them reactive\u003c/h2\u003e\n\u003cp\u003eUsing computed properties in Vue.js, I was pretty accustomed to the fact that computed properties were de-facto reactive.\u003c/p\u003e\n\u003cp\u003eReactive means that if a computed property depends on some other property, when that property changes, the computed property gets recalculated. This behaviour usually triggers a view change with the updated result.\u003c/p\u003e\n\u003cp\u003eIn Kotlin, sadly, that\u0026#39;s not the case.\u003c/p\u003e\n\u003cp\u003eRecalculation will only be done once the property value is set or accessed depending on where we have written our calculation logic.\u003c/p\u003e\n\u003cp\u003eWe can achieve a reactive behaviour by using Kotlin\u0026#39;s property observer delegate, though. It\u0026#39;s a patch but let\u0026#39;s see how it can be done.\u003c/p\u003e\n\u003cp\u003eWe need a backing property which we will keep updating and route the output through our computed property.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s say we need to display a formatted speed value to the user whenever the speed gets updated. Here\u0026#39;s how we can sprinkle in some reactivity:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e _formattedSpeed\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003eby\u003c/span\u003e Delegates\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eobservable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e _\u003cspan\u003e,\u003c/span\u003e _\u003cspan\u003e,\u003c/span\u003e _ \u003cspan\u003e-\u0026gt;\u003c/span\u003e    \n    \u003cspan\u003edisplaySpeed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eformattedSpeed\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n    \n\u003cspan\u003eval\u003c/span\u003e formattedSpeed\u003cspan\u003e:\u003c/span\u003e String    \n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$_formattedSpeed\u003c/span\u003e km/h\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere, we are observing a private counterpart of our computed property, which we call the \u0026#34;backing property\u0026#34;. Whenever our backing property changes, we display the change to the user. \u003c/p\u003e\n\u003cp\u003eA little detail here is, on every change of the backing property value, we are querying the value of the computed property and passing it down to our \u003ccode\u003edisplaySpeed()\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eThis approach ensures that the updated value goes through the computed property, and necessary transformations are applied before it reaches the user.\u003c/p\u003e\n\u003cp\u003eYou\u0026#39;ll rarely need to rely on this technique. However, it could be handy to be aware of this possibility.\u003c/p\u003e\n\u003ch2 id=\"uh-oh-the-stack-is-full\"\u003eUh-oh! The stack is full\u003c/h2\u003e\n\u003cp\u003eStacks are nice, but no one wants to overflow their stacks.\u003c/p\u003e\n\u003cp\u003eSimilar to recursion, it\u0026#39;s pretty easy to get hit on the face with a \u003ccode\u003eStackOverflowException\u003c/code\u003e if we don\u0026#39;t write our computation logic well.\u003c/p\u003e\n\u003cp\u003eIn Kotlin, any property we define is not a direct reference to a memory address. This means that every time we access value from a property, it comes through the \u003ccode\u003eget()\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eA code like this is a sure-shot way to get a \u003ccode\u003eStackOverflowException\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e formattedSpeed\u003cspan\u003e:\u003c/span\u003e String    \n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$formattedSpeed\u003c/span\u003e km/h\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eEvery time we access \u003ccode\u003eformattedSpeed\u003c/code\u003e, we call it\u0026#39;s \u003ccode\u003eget()\u003c/code\u003e method. Also, in the \u003ccode\u003eget()\u003c/code\u003e method we are trying to access \u003ccode\u003eformattedSpeed\u003c/code\u003e, which in turn calls the \u003ccode\u003eget()\u003c/code\u003e method again. This process continues until the device\u0026#39;s stack can\u0026#39;t hold any more method calls.\u003c/p\u003e\n\u003cp\u003eThus, the dreaded \u003ccode\u003eStackOverflowException\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf we need to access the computed property\u0026#39;s actual value, we need to access its backing field instead of the property.\u003c/p\u003e\n\u003cp\u003eThe above code becomes:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evar\u003c/span\u003e formattedSpeed\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$field\u003c/span\u003e km/h\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere, \u003ccode\u003efield\u003c/code\u003e is the keyword used to access the actual value of a property. Think of it as a direct reference to the memory.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s essential to be aware of this common mistake to avoid losing time in debugging.\u003c/p\u003e\n\u003ch2 id=\"making-the-most-out-of-it\"\u003eMaking the most out of it\u003c/h2\u003e\n\u003cp\u003eJust because computed properties exist, doesn\u0026#39;t mean we should never write a simple property again. Language features such as this are most useful when there\u0026#39;s a particular use case for them. Like the ones, we discussed above.\u003c/p\u003e\n\u003cp\u003eLook at your code, be creative and think if using computed properties somewhere makes your code better. If not, well, stick to the plain old \u003ccode\u003eval goodByeMessage = \u0026#34;Sayonara!\u0026#34;\u003c/code\u003e .\u003c/p\u003e\n\u003ch2 id=\"heres-a-sketch-note-on-the-topic\"\u003eHere\u0026#39;s a sketch note on the topic\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/d40c8/computed-properties-sketch-note.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Computed properties sketch note\" title=\"Computed properties sketch note\" src=\"https://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/dbb61/computed-properties-sketch-note.png\" srcset=\"https://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/19bd1/computed-properties-sketch-note.png 163w,\nhttps://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/d3bcb/computed-properties-sketch-note.png 325w,\nhttps://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/dbb61/computed-properties-sketch-note.png 650w,\nhttps://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/6b691/computed-properties-sketch-note.png 975w,\nhttps://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/91670/computed-properties-sketch-note.png 1300w,\nhttps://okkotlin.com/static/eed535811df28ebbc25522dd5e2f57f2/d40c8/computed-properties-sketch-note.png 2000w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
