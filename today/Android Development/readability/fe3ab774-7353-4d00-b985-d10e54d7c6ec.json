{
  "id": "fe3ab774-7353-4d00-b985-d10e54d7c6ec",
  "title": "Kotlin companion object explained",
  "link": "https://proandroiddev.com/kotlin-companion-object-explained-a3cef8a9eeed?source=rss----c72404660798---4",
  "description": "",
  "author": "Michal Ankiersztajn",
  "published": "Mon, 16 Dec 2024 15:03:56 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "static",
    "kotlin-basic",
    "kotlin",
    "kotlin-companion-objec",
    "kotlindev"
  ],
  "byline": "Michal Ankiersztajn",
  "length": 2582,
  "excerpt": "Write more readable, performant, and maintainable code by using companion objects. Learn why, how, and what it is!",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Your true companionIn this article, you’re going to learn what companion object exactly is, how it behaves and what you can use it for in Kotlin!Why you should use it?The key to using companion object is that you treat it like a ‘companion’ of a given class/interface . From a technical perspective, it’s a special object associated directly with a class instead of its instances, meaning no matter how many instances you create, there’ll always be only 1 companion object. It allows you to write more readable, performant, and maintainable code. You can use it for:Holding constants associated with a classWriting utility functionsSharing resourcesCreating factory methodsHow does it work?ExampleLet’s work on an example so things are more straightforward. Here’s how you can define companion object :// It could be an interface as wellclass Example { companion object { const val TIMEOUT_MILLIS = 50 } }In the case above, we have a nameless companion object that’s associated with Example class . Inside it, you can write functions, define values and variables, etc., but remember that they’ll work like a Singleton.Usageclass Example { fun timeout() { Thread.sleep(TIMEOUT_MILLIS) } companion object { const val TIMEOUT_MILLIS = 50 } }fun main() { Thread.sleep(Example.TIMEOUT_MILLIS) // Used outside}So there’s an additional benefit: sometimes you’ll need a method that is associated with a given class but used outside of it as well and with companion object you can do it.What are the key characteristics?It’s public by default, but you can scope it to privateAssigned only to a class or interface , we cannot assign it to an object as it does not apply to standalone objects (it’s not a class).There can only be one companion object per class/interfaceUnder the hood companion object needs a name that’s Companion by default but can be easily changed, f.e companion object YourName {...}Additionally, it can access private members of a class — it sounds mysterious, but an example should clear things up:class Example { private var age: Int = 0 companion object { fun updateAgeRandomly(example: Example) { example.age = Random.nextInt() println(example.age) } } }Typically, you wouldn’t be able to access age variable as it’s private, but companion object can do so. However, in reality, it’s not as helpful because you can add a method to an Example class, it’s worth noting that it’s possible and Extension functions use the exact mechanism to access private fields of extended classes.",
  "image": "https://miro.medium.com/v2/resize:fit:1100/1*hB3lUJFE_UMKBQk2oD7YYQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003ch2 id=\"0ab1\"\u003eYour true companion\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@michalankiersztajn?source=post_page---byline--a3cef8a9eeed--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Michal Ankiersztajn\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*wqtk16v3lv_e1Cu_dPyT2w.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--a3cef8a9eeed--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"85ef\"\u003eIn this article, you’re going to learn what \u003ccode\u003ecompanion object\u003c/code\u003e exactly is, how it behaves and what you can use it for in Kotlin!\u003c/p\u003e\u003ch2 id=\"8d64\"\u003eWhy you should use it?\u003c/h2\u003e\u003cp id=\"fcdd\"\u003e\u003cstrong\u003eThe key to using \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecompanion object\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e is that you treat it like a ‘companion’ of a given \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eclass/interface\u003c/strong\u003e\u003c/code\u003e . From a technical perspective, \u003cstrong\u003eit’s a special object associated directly with a class instead of its instances,\u003c/strong\u003e meaning no matter how many instances you create, there’ll always be only 1 companion object. It allows you to write more readable, performant, and maintainable code. You can use it for:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1fb3\"\u003e\u003cstrong\u003eHolding constants associated with a class\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"3d84\"\u003e\u003cstrong\u003eWriting utility functions\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"e7f9\"\u003e\u003cstrong\u003eSharing resources\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"f6b1\"\u003e\u003cstrong\u003eCreating factory methods\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a014\"\u003eHow does it work?\u003c/h2\u003e\u003ch2 id=\"f01c\"\u003eExample\u003c/h2\u003e\u003cp id=\"33f0\"\u003eLet’s work on an example so things are more straightforward. Here’s how you can define \u003ccode\u003ecompanion object\u003c/code\u003e :\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5fec\"\u003e// It could be an interface as well\u003cbr/\u003eclass Example {\u003cbr/\u003e    companion object {\u003cbr/\u003e        const val TIMEOUT_MILLIS = 50\u003cbr/\u003e    } \u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4d62\"\u003eIn the case above, we have a nameless \u003ccode\u003ecompanion object\u003c/code\u003e that’s associated with \u003ccode\u003eExample\u003c/code\u003e \u003ccode\u003eclass\u003c/code\u003e . Inside it, you can write functions, define values and variables, etc., but remember that they’ll work like a Singleton.\u003c/p\u003e\u003ch2 id=\"797b\"\u003eUsage\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"e35f\"\u003eclass Example {\u003cbr/\u003e    fun timeout() {\u003cbr/\u003e        Thread.sleep(TIMEOUT_MILLIS)\u003cbr/\u003e    }\u003cbr/\u003e    companion object {\u003cbr/\u003e        const val TIMEOUT_MILLIS = 50\u003cbr/\u003e    } \u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    Thread.sleep(Example.TIMEOUT_MILLIS) // Used outside\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"14c4\"\u003eSo there’s an additional benefit: sometimes you’ll need a method that is associated with a given class but used outside of it as well and with \u003ccode\u003ecompanion object\u003c/code\u003e you can do it.\u003c/p\u003e\u003ch2 id=\"4da3\"\u003eWhat are the key characteristics?\u003c/h2\u003e\u003col\u003e\u003cli id=\"602c\"\u003eIt’s \u003cstrong\u003epublic by default\u003c/strong\u003e, but you can scope it to private\u003c/li\u003e\u003cli id=\"9898\"\u003e\u003cstrong\u003eAssigned only to a \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eclass\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e or \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einterface\u003c/strong\u003e\u003c/code\u003e , we cannot assign it to an \u003ccode\u003eobject\u003c/code\u003e as it does not apply to standalone objects (it’s not a class).\u003c/li\u003e\u003cli id=\"20a6\"\u003e\u003cstrong\u003eThere can only be one \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecompanion object\u003c/strong\u003e\u003c/code\u003e per \u003ccode\u003eclass/interface\u003c/code\u003e\u003c/li\u003e\u003cli id=\"f3c9\"\u003e\u003cstrong\u003eUnder the hood \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecompanion object\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e needs a name\u003c/strong\u003e that’s Companion by default but can be easily changed, f.e \u003ccode\u003ecompanion object YourName {...}\u003c/code\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"525d\"\u003eAdditionally, it can \u003cstrong\u003eaccess private members of a class\u003c/strong\u003e — it sounds mysterious, but an example should clear things up:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c787\"\u003eclass Example {\u003cbr/\u003e    private var age: Int = 0\u003cp\u003e    companion object {\u003cbr/\u003e        fun updateAgeRandomly(example: Example) {\u003cbr/\u003e            example.age = Random.nextInt()\u003cbr/\u003e            println(example.age)\u003cbr/\u003e        }\u003cbr/\u003e    } \u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8baa\"\u003eTypically, you wouldn’t be able to access \u003ccode\u003eage\u003c/code\u003e variable as it’s private, but \u003ccode\u003ecompanion object\u003c/code\u003e can do so. However, in reality, it’s not as helpful because you can add a method to an \u003ccode\u003eExample\u003c/code\u003e class, it’s worth noting that it’s possible and \u003ccode\u003eExtension functions\u003c/code\u003e use the exact mechanism to access private fields of extended classes.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-12-16T07:02:28.598Z",
  "modifiedTime": null
}
