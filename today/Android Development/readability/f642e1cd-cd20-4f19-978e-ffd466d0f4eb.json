{
  "id": "f642e1cd-cd20-4f19-978e-ffd466d0f4eb",
  "title": "JavaScript Nulls and Programming Minutiae",
  "link": "https://blog.danlew.net/2024/05/15/javascript-nulls-and-programming-minutiae/",
  "description": "Socrates once said “the unexamined life is not worth living.” He was immediately sentenced to death afterwards. I, too, often find myself examining the minutiae of programming languages. Thankfully, I have not been put to death for it (yet). After spending more than a decade honing my Android",
  "author": "Dan Lew",
  "published": "Wed, 15 May 2024 13:56:17 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "javascript"
  ],
  "byline": "Dan Lew",
  "length": 6711,
  "excerpt": "Socrates once said “the unexamined life is not worth living.” He was immediately sentenced to death afterwards. I, too, often find myself examining the minutiae of programming languages. Thankfully, I have not been put to death for it (yet). After spending more than a decade honing my Android development skills, I’ve recently switched back to my first foray into professional development, JavaScript[1]. It has a lot to examine, and much like Socrates, I have many, many questions. Today, let",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "“The Death of Socrates” by Jacques-Louis David Socrates once said “the unexamined life is not worth living.” He was immediately sentenced to death afterwards. I, too, often find myself examining the minutiae of programming languages. Thankfully, I have not been put to death for it (yet). After spending more than a decade honing my Android development skills, I’ve recently switched back to my first foray into professional development, JavaScript[1]. It has a lot to examine, and much like Socrates, I have many, many questions. Today, let’s look at a seemingly simple question: how do I represent absent data in function returns? Suppose I've got a function that queries the database for Foo: async function getFoo(id: string): Foo | ??? { const rows = await query(/* ...some SQL... */) if (rows.length \u003e 0) return rows[0] else return ??? } When Foo is not found, what do I return? For whatever reason, JavaScript provides two options here: null and undefined[2]. There are subtle distinctions between them, but fundamentally they both represent the absence of data. Which should I use? Let’s try to answer this question without drinking hemlock. So What? Before we begin, I’d like to answer a more fundamental question: who cares? On its face, this problem feels pretty dumb. null and undefined both mean approximately the same thing, just return whatever you feel like, right? It doesn't really matter, so you can leverage the vibes instead of your brain. These sorts of choices come up everywhere: in languages, frameworks, APIs, or even your own codebase. Situations where there’s more than one way to do something, but it’s not always clear which way is better because the options are so similar. Should I concatenate strings using + or string templating? Should I use a for-loop or a forEach() iterator? Should I use tabs or spaces? Here’s why I give a hoot: First, when you study a seemingly arbitrary choice, you sometimes come out with some real enlightenment. Perhaps the choice seemed arbitrary at first, but through careful study, you realize there are compelling reasons to use one method or another. For example, I investigated properties vs. functions in Kotlin and came out with a deeper understanding of val. My initial (naive) understanding equated val with “immutable” when it actually just means “read only”, and all my future work with class properties was more nuanced because of my research. Second, the more ambiguous a choice is, the longer people spend time on it, so it’s best to reduce the ambiguity. If it were obvious what the right answer was, everyone would do the right thing and not spend any further time thinking about it. But when there’s no obviously correct answer, you have to stop and think. And when discussing ambiguous choices, oftimes all you’ve got are personal opinions, and opinion-based arguments are pointless and infinite (see: the never-ending discussion of tabs vs. spaces[3]). If we can come up with a well-reasoned nudge in one direction, we can spend less time stressing about it going forward. Lastly, sometimes these questions just drill their way into my head and I can’t get them out until I have an answer. That’s a personal problem and applies directly to the null vs. undefined dilemma (which, believe it or not, I've been ruminating upon for years). Alright, Let’s Debate Let’s get back to the question at hand: coming to a conclusion on using null vs. undefined (hopefully without getting canceled on Hacker news for having imperfect thoughts). My first angle of inquiry: is it possible to write a codebase that only uses null or undefined? That would be awfully convenient (which is why almost every other programming language only has one null!). Unfortunately, a fellow sophist already dug into this idea and came up with the answer “no”, at least for most codebases. I’ll summarize the argument here: It’s easy to rule out a codebase that only uses null because it is impossible to get away from undefined. It is the value that properties start with before initialization, and it’s returned by many core JavaScript functions (e.g. Array.find()). It is possible to only use undefined but only in narrow circumstances. For example, TypeScript’s codebase has no nulls. However, if you use JSON or depend on 3rd party libraries you open yourself up to the possibility of using nulls (since both can give you nulls anytime). It’s worth pursuing an undefined-only codebase, but may be impossible for you. For my own use case, I will have to deal with nulls, so I must scratch this utopian idea. Can we answer this question by shifting our perspective to that of the consumer? How will they react to receiving a null vs. undefined? The annoying thing about being a consumer is you won’t always know if you’re getting back null or undefined, so you have to handle both cases[4]. How do we if-check “not null and not undefined”? Here's a bunch of ways, most with drawbacks: if (myVar !== undefined \u0026\u0026 myVar !== null) {} is too verbose. if (myVar) {} coerces extra values (“” and 0 are also false). if (myVar != null) {} breaks the guideline against using != if (!isNil(myVar)) {} (via lodash) works! Of all these options, if (!isNil(myVar)) works best. It’s succinct and type inference still works. And if you’re allergic to dependencies, you can write your own isNil(). Because consumers have to be defensive, it doesn’t matter whether I return null or undefined. That said, I find it revolting that typeof null === ‘object’, so my preference is to return undefined. Plus, that choice helps out anyone who might want to eventually try to go for an undefined-only codebase. tl;dr My personal conclusion: Represent absent data with undefined. Use isNil(xyz) for null checks. I don’t feel particularly warm and fuzzy about my conclusions, but I suppose that’s just how it goes when you’re working with JavaScript. Technically, TypeScript; but because TypeScript is built on top of the bog that is JavaScript, you are constantly having to sink to JavaScript’s level. ↩︎ TypeScript also includes other null-adjacent oddities: never, void, and unknown. I don’t consider these reasonable options for this situation, and they don’t actually exist in JavaScript, so I’m ignoring them. ↩︎ I know people present logical arguments for tabs vs. spaces, but the fact that this matter remains unsettled after decades of arguments seems like proof enough to me that there’s no one correct answer. ↩︎ If you enable TypeScript’s strictNullChecks, then you have to define whether a function returns null or undefined, which can help here; again, though, JSON/3rd party libraries may not be as helpful here. ↩︎",
  "image": "https://blog.danlew.net/content/images/size/w1200/2024/05/1644px-David_-_The_Death_of_Socrates.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n\n        \n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://blog.danlew.net/content/images/size/w300/2024/05/1644px-David_-_The_Death_of_Socrates.jpg 300w,\n                            https://blog.danlew.net/content/images/size/w600/2024/05/1644px-David_-_The_Death_of_Socrates.jpg 600w,\n                            https://blog.danlew.net/content/images/size/w1000/2024/05/1644px-David_-_The_Death_of_Socrates.jpg 1000w,\n                            https://blog.danlew.net/content/images/size/w2000/2024/05/1644px-David_-_The_Death_of_Socrates.jpg 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://blog.danlew.net/content/images/size/w2000/2024/05/1644px-David_-_The_Death_of_Socrates.jpg\" alt=\"Painting “The Death of Socrates” by Jacques-Louis David\"/\u003e\n                    \u003cfigcaption\u003e\u003cspan\u003e“The Death of Socrates” by Jacques-Louis David\u003c/span\u003e\u003c/figcaption\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eSocrates once said “the unexamined life is not worth living.” He was immediately sentenced to death afterwards.\u003c/p\u003e\n\u003cp\u003eI, too, often find myself examining the minutiae of programming languages. Thankfully, I have not been put to death for it (yet).\u003c/p\u003e\n\u003cp\u003eAfter spending more than a decade honing my Android development skills, I’ve recently switched back to my first foray into professional development, JavaScript\u003csup\u003e\u003ca href=\"#fn1\" id=\"fnref1\"\u003e[1]\u003c/a\u003e\u003c/sup\u003e. It has a lot to examine, and much like Socrates, I have many, many questions.\u003c/p\u003e\n\u003cp\u003eToday, let’s look at a seemingly simple question: \u003cstrong\u003ehow do I represent absent data in function returns\u003c/strong\u003e?\u003c/p\u003e\n\u003cp\u003eSuppose I\u0026#39;ve got a function that queries the database for \u003ccode\u003eFoo\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003easync function getFoo(id: string): Foo | ??? {\n  const rows = await query(/* ...some SQL... */)\n  if (rows.length \u0026gt; 0) return rows[0]\n  else return ???\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen \u003ccode\u003eFoo\u003c/code\u003e is not found, what do I return?\u003c/p\u003e\n\u003cp\u003eFor whatever reason, JavaScript provides two options here: \u003ccode\u003enull\u003c/code\u003e and \u003ccode\u003eundefined\u003c/code\u003e\u003csup\u003e\u003ca href=\"#fn2\" id=\"fnref2\"\u003e[2]\u003c/a\u003e\u003c/sup\u003e. There are subtle distinctions between them, but fundamentally they both represent the absence of data.\u003c/p\u003e\n\u003cp\u003eWhich should I use? Let’s try to answer this question without drinking hemlock.\u003c/p\u003e\n\u003ch2 id=\"so-what\"\u003eSo What?\u003c/h2\u003e\n\u003cp\u003eBefore we begin, I’d like to answer a more fundamental question: \u003cstrong\u003ewho cares?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOn its face, this problem feels pretty dumb. \u003ccode\u003enull\u003c/code\u003e and \u003ccode\u003eundefined\u003c/code\u003e both mean approximately the same thing, just return whatever you feel like, right? It doesn\u0026#39;t really matter, so you can leverage the vibes instead of your brain.\u003c/p\u003e\n\u003cp\u003eThese sorts of choices come up everywhere: in languages, frameworks, APIs, or even your own codebase. Situations where there’s more than one way to do something, but it’s not always clear which way is better because the options are so similar.\u003c/p\u003e\n\u003cp\u003eShould I concatenate strings using \u003ccode\u003e+\u003c/code\u003e or string templating? Should I use a for-loop or a \u003ccode\u003eforEach()\u003c/code\u003e iterator? Should I use tabs or spaces?\u003c/p\u003e\n\u003cp\u003eHere’s why I give a hoot:\u003c/p\u003e\n\u003cp\u003eFirst, \u003cstrong\u003ewhen you study a seemingly arbitrary choice, you sometimes come out with some real enlightenment\u003c/strong\u003e. Perhaps the choice \u003cem\u003eseemed\u003c/em\u003e arbitrary at first, but through careful study, you realize there are compelling reasons to use one method or another. For example, I investigated \u003ca href=\"https://blog.danlew.net/2017/05/30/mutable-vals-in-kotlin/\"\u003eproperties vs. functions in Kotlin\u003c/a\u003e and came out with a deeper understanding of \u003ccode\u003eval\u003c/code\u003e. My initial (naive) understanding equated \u003ccode\u003eval\u003c/code\u003e with “immutable” when it actually just means “read only”, and all my future work with class properties was more nuanced because of my research.\u003c/p\u003e\n\u003cp\u003eSecond, \u003cstrong\u003ethe more ambiguous a choice is, the longer people spend time on it, so it’s best to reduce the ambiguity\u003c/strong\u003e. If it were obvious what the right answer was, everyone would do the right thing and not spend any further time thinking about it. But when there’s no obviously correct answer, you have to stop and think. And when discussing ambiguous choices, oftimes all you’ve got are personal opinions, and opinion-based arguments are pointless and infinite (see: the never-ending discussion of tabs vs. spaces\u003csup\u003e\u003ca href=\"#fn3\" id=\"fnref3\"\u003e[3]\u003c/a\u003e\u003c/sup\u003e). If we can come up with a well-reasoned nudge in one direction, we can spend less time stressing about it going forward.\u003c/p\u003e\n\u003cp\u003eLastly, \u003cstrong\u003esometimes these questions just drill their way into my head and I can’t get them out until I have an answer\u003c/strong\u003e. That’s a personal problem and applies directly to the \u003ccode\u003enull\u003c/code\u003e vs. \u003ccode\u003eundefined\u003c/code\u003e dilemma (which, believe it or not, I\u0026#39;ve been ruminating upon for years).\u003c/p\u003e\n\u003ch2 id=\"alright-let%E2%80%99s-debate\"\u003eAlright, Let’s Debate\u003c/h2\u003e\n\u003cp\u003eLet’s get back to the question at hand: coming to a conclusion on using \u003ccode\u003enull\u003c/code\u003e vs. \u003ccode\u003eundefined\u003c/code\u003e (hopefully without getting canceled on Hacker news for having imperfect thoughts).\u003c/p\u003e\n\u003cp\u003eMy first angle of inquiry: \u003cstrong\u003eis it possible to write a codebase that only uses null or undefined?\u003c/strong\u003e That would be awfully convenient (which is why almost every other programming language only has one null!). Unfortunately, a fellow sophist \u003ca href=\"https://medium.com/@o_o_o/null-vs-undefined-can-i-use-only-one-a3b7db5468f2?ref=blog.danlew.net\"\u003ealready dug into this idea\u003c/a\u003e and came up with the answer “no”, at least for most codebases. I’ll summarize the argument here:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIt’s easy to rule out a codebase that only uses \u003ccode\u003enull\u003c/code\u003e because \u003cstrong\u003eit is impossible to get away from \u003ccode\u003eundefined\u003c/code\u003e\u003c/strong\u003e. It is the value that properties start with before initialization, and it’s returned by many core JavaScript functions (e.g. \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find?ref=blog.danlew.net\"\u003e\u003ccode\u003eArray.find()\u003c/code\u003e\u003c/a\u003e).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eIt is possible to only use \u003ccode\u003eundefined\u003c/code\u003e but only in narrow circumstances.\u003c/strong\u003e For example, \u003ca href=\"https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines?ref=blog.danlew.net#null-and-undefined\"\u003eTypeScript’s codebase has no nulls\u003c/a\u003e. However, if you use JSON or depend on 3rd party libraries you open yourself up to the possibility of using nulls (since both can give you nulls anytime).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt’s worth pursuing an \u003ccode\u003eundefined\u003c/code\u003e-only codebase, but may be impossible for you. For my own use case, I will have to deal with nulls, so I must scratch this utopian idea.\u003c/p\u003e\n\u003cp\u003eCan we answer this question by shifting our perspective to that of the consumer? How will they react to receiving a \u003ccode\u003enull\u003c/code\u003e vs. \u003ccode\u003eundefined\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eThe annoying thing about being a consumer is \u003cstrong\u003eyou won’t always know if you’re getting back \u003ccode\u003enull\u003c/code\u003e or \u003ccode\u003eundefined\u003c/code\u003e, so you have to handle both cases\u003c/strong\u003e\u003csup\u003e\u003ca href=\"#fn4\" id=\"fnref4\"\u003e[4]\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eHow do we if-check “not null and not undefined”? Here\u0026#39;s a bunch of ways, most with drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eif (myVar !== undefined \u0026amp;\u0026amp; myVar !== null) {}\u003c/code\u003e is too verbose.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eif (myVar) {}\u003c/code\u003e coerces extra values (\u003ccode\u003e“”\u003c/code\u003e and \u003ccode\u003e0\u003c/code\u003e are also false).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eif (myVar != null) {}\u003c/code\u003e breaks \u003ca href=\"https://eslint.org/docs/latest/rules/eqeqeq?ref=blog.danlew.net\"\u003ethe guideline\u003c/a\u003e against using \u003ccode\u003e!=\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eif (!isNil(myVar)) {}\u003c/code\u003e (\u003ca href=\"https://lodash.com/docs/4.17.15?ref=blog.danlew.net#isNil\"\u003evia lodash\u003c/a\u003e) works!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOf all these options, \u003cstrong\u003e\u003ccode\u003eif (!isNil(myVar))\u003c/code\u003e works best\u003c/strong\u003e. It’s succinct and type inference still works. And if you’re allergic to dependencies, you can write your own \u003ccode\u003eisNil()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause consumers have to be defensive, it doesn’t matter whether I return \u003ccode\u003enull\u003c/code\u003e or \u003ccode\u003eundefined\u003c/code\u003e. That said, I find it revolting that \u003ccode\u003etypeof null === ‘object’\u003c/code\u003e, so \u003cstrong\u003emy preference is to return \u003ccode\u003eundefined\u003c/code\u003e\u003c/strong\u003e. Plus, that choice helps out anyone who might want to eventually try to go for an \u003ccode\u003eundefined\u003c/code\u003e-only codebase.\u003c/p\u003e\n\u003ch2 id=\"tldr\"\u003etl;dr\u003c/h2\u003e\n\u003cp\u003eMy personal conclusion:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRepresent absent data with \u003ccode\u003eundefined\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003eisNil(xyz)\u003c/code\u003e for null checks.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI don’t feel particularly warm and fuzzy about my conclusions, but I suppose that’s just how it goes when you’re working with JavaScript.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://blog.danlew.net/content/images/2024/05/tz1c78larvd71.jpg\" alt=\"Screencap from the movie Chinatown, from the ending; a character is saying “Forget it, Jake. It’s JavaScript.”\" loading=\"lazy\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003csection\u003e\n\u003col\u003e\n\u003cli id=\"fn1\"\u003e\u003cp\u003eTechnically, TypeScript; but because TypeScript is built on top of the bog that is JavaScript, you are constantly having to sink to JavaScript’s level. \u003ca href=\"#fnref1\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn2\"\u003e\u003cp\u003eTypeScript also includes other null-adjacent oddities: \u003ccode\u003enever\u003c/code\u003e, \u003ccode\u003evoid\u003c/code\u003e, and \u003ccode\u003eunknown\u003c/code\u003e. I don’t consider these reasonable options for this situation, and they don’t actually exist in JavaScript, so I’m ignoring them. \u003ca href=\"#fnref2\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn3\"\u003e\u003cp\u003eI know people present logical arguments for tabs vs. spaces, but the fact that this matter remains unsettled after decades of arguments seems like proof enough to me that there’s no one correct answer. \u003ca href=\"#fnref3\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn4\"\u003e\u003cp\u003eIf you enable TypeScript’s \u003ca href=\"https://www.typescriptlang.org/tsconfig/?ref=blog.danlew.net#strictNullChecks\"\u003e\u003ccode\u003estrictNullChecks\u003c/code\u003e\u003c/a\u003e, then you have to define whether a function returns \u003ccode\u003enull\u003c/code\u003e or \u003ccode\u003eundefined\u003c/code\u003e, which can help here; again, though, JSON/3rd party libraries may not be as helpful here. \u003ca href=\"#fnref4\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\n    \u003c/section\u003e\n\n    \n    \n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-05-15T13:56:17Z",
  "modifiedTime": "2024-08-17T14:18:02Z"
}
