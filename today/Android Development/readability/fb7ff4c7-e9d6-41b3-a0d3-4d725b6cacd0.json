{
  "id": "fb7ff4c7-e9d6-41b3-a0d3-4d725b6cacd0",
  "title": "Type safe navigation for Compose",
  "link": "https://medium.com/androiddevelopers/type-safe-navigation-for-compose-105325a97657?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Don Turner",
  "published": "Thu, 05 Sep 2024 00:06:11 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "best-practices",
    "type-safety",
    "navigation",
    "compose-ui",
    "compose"
  ],
  "byline": "Don Turner",
  "length": 18853,
  "excerpt": "With the latest release of Jetpack Navigation 2.8.0, the type safe navigation APIs for building navigation graphs in Kotlin are stable üéâ. This means that you can define your destinations using‚Ä¶",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "With the latest release of Jetpack Navigation 2.8.0, the type safe navigation APIs for building navigation graphs in Kotlin are stable üéâ. This means that you can define your destinations using serializable types and benefit from compile-time safety.This is great news if you‚Äôre using Jetpack Compose for your UI because it‚Äôs simpler and safer to define your navigation destinations and arguments.The design philosophy behind these new APIs is covered in this blog post which accompanied the first release they appeared in ‚Äî 2.8.0-alpha08.Since then, we‚Äôve received and incorporated lots of feedback, fixed some bugs and made several improvements to the API. This article covers the stable API and points out changes since the first alpha release. It also looks at how to migrate existing code and provides some tips on testing navigation use cases.The basicsThe new type safe navigation APIs for Kotlin allow you to use Any serializable type to define navigation destinations. To use them, you‚Äôll need to add the Jetpack navigation library version 2.8.0 and the Kotlin serialization plugin to your project.Once done, you can use the @Serializableannotation to automatically create serializable types. These can then be used to create a navigation graph.The remainder of this article assumes you‚Äôre using Compose as your UI framework (by including navigation-compose in your dependencies), although the examples should work equally well with Fragments (with some slight differences). If you‚Äôre using both, we have some new interop APIs for that too.A good example of one of the new APIs is composable. It now accepts a generic type which can be used to define a destination.@Serializable data object HomeNavHost(navController, startDestination = Home) { composable\u003cHome\u003e { HomeScreen() }}Nomenclature is important here. In navigation terms, Home is a route which is used to create a destination. The destination has a route type and defines what will be displayed on screen at that destination, in this case HomeScreen.These new APIs can be summarized as: Any method that accepts a route now accepts a generic type for that route. The examples that follow use these new methods.Passing data between destinationsOne of the primary benefits of these new APIs is the compile-time safety provided by using types for navigation arguments. For basic types, it‚Äôs super simple to pass them to a destination.Let‚Äôs say we have an app which displays products on the Home screen. Clicking on any product displays the product details on a Product screen.Navigation graph with two destinations: Home and ProductWe can define the Product route using a data class which has a String id field which will contain the product ID.@Serializable data class Product(val id: String)By doing so, we‚Äôre establishing a couple of navigation rules:The Product route must always have an idThe type of id is always a StringYou can use any basic type as a navigation argument, including lists and arrays. For more complex types, see the ‚ÄúCustom types‚Äù section of this article.New since alpha: Nullable types are supported.New since alpha: Enums are supported (although you‚Äôll need to use @Keep on the enum declaration to ensure that the enum class is not removed during minified builds, tracking bug)Obtaining the route at the destinationWhen we use this route to define a destination in our navigation graph, we can obtain the route from the back stack entry using toRoute. This can then be passed to whatever is needed to render that destination on screen, in this case ProductScreen. Here‚Äôs how our destination is implemented:composable\u003cProduct\u003e { backStackEntry -\u003e val product : Product = backStackEntry.toRoute() ProductScreen(product)}New since alpha: If you‚Äôre using a ViewModel to provide state to your screen, you can also obtain the route from savedStateHandle using the toRoute extension function.ProductViewModel(private val savedStateHandle: SavedStateHandle, ‚Ä¶) : ViewModel { private val product : Product = savedStateHandle.toRoute() // Set up UI state using product}Note on testing: As of release 2.8.0, SavedStateHandle.toRoute is dependent on Android Bundle. This means your ViewModel tests will need to be instrumented (e.g. by using Robolectric or by running them on an emulator). We‚Äôre looking at ways we can remove this dependency in future releases (tracked here).Passing data when navigatingUsing the route to pass navigation arguments is simple ‚Äî just use navigate with an instance of the route class.navController.navigate(route = Product(id = \"ABC\"))Here‚Äôs a complete example:NavHost( navController = navController, startDestination = Home) { composable\u003cHome\u003e { HomeScreen( onProductClick = { id -\u003e navController.navigate(route = Product(id)) } ) } composable\u003cProduct\u003e { backStackEntry -\u003e val product : Product = backStackEntry.toRoute() ProductScreen(product) }}Now that you know how to pass data between screens inside your app, let‚Äôs look at how you can navigate and pass data into your app from outside.Straight to your destination with deep linksSometimes you want to take users directly to a specific screen within your app, rather than starting at the home screen. For example, if you‚Äôve just sent them a notification saying ‚Äúcheck out this new product‚Äù, it makes perfect sense to take them straight to that product screen when they tap on the notification. Deep links enable you to do this.Here‚Äôs how you add a deep link to the Product destination mentioned above:composable\u003cProduct\u003e( deepLinks = listOf( navDeepLink\u003cProduct\u003e( basePath = \"www.hellonavigation.example.com/product\" ) )) {‚Ä¶}navDeepLink is used to construct the deep link URL from both the class, in this case Product, and the supplied basePath. Any fields from the supplied class are automatically included in the URL as parameters. The generated deep link URL is:www.hellonavigation.example.com/product/{id}To test it, you could use the following adb command:adb shell am start -a android.intent.action.VIEW -d \"https://www.hellonavigation.example.com/product/ABC\" com.example.hellonavigationThis will launch the app directly on the Product destination with the Product.id set to ‚ÄúABC‚Äù.URL parameter typesWe‚Äôve just seen an example of the navigation library automatically generating a deep link URL containing a path parameter. Path parameters are generated for required route arguments. Looking at our Product again:@Serializable data class Product(val id: String)The id field is mandatory so the deep link URL format of /{id} is appended to the base path. Path parameters are always generated for route arguments, except when:1. the class field has a default value (the field is optional), or2. the class field represents a collection of primitive types, like a List\u003cString\u003e or Array\u003cInt\u003e (full list of supported types, add your own by extending CollectionNavType)In each of these cases, a query parameter is generated. Query parameters have a deep link URL format of ?name=value.Here‚Äôs a summary of the different types of URL parameter:Path and query parametersNew since alpha: Empty strings for path parameters are now supported. In the above example, if you use a deep link URL of www.hellonavigation.example.com/product// then the id field would be set to an empty string.Testing deep linksOnce you‚Äôve set up your app‚Äôs manifest to accept incoming links, an easy way to test your deep links is to use adb. Here‚Äôs an example (note that \u0026 is escaped):adb shell am start -a android.intent.action.VIEW -d ‚Äúhttps://hellonavigation.example.com/product/ABC?color=red\\\u0026variants=var1\\\u0026variants=var2\" com.example.hellonavigationüêûDebugging tip: If you ever want to check the generated deep link URL format, just print the NavBackStackEntry.destination.route from your destination and it‚Äôll appear in logcat when you navigate to that destination:composable\u003cProduct\u003e( ‚Ä¶ ) { backStackEntry -\u003e println(backStackEntry.destination.route)}Testing navigationWe‚Äôve already touched on how you can test deep links using adb but let‚Äôs dive a bit deeper into how you can test your navigation code. Navigation tests are usually instrumented tests which simulate the user navigating through your app.Here‚Äôs a simple test which verifies that when you tap on a product button, the product screen is displayed with the correct content.@RunWith(AndroidJUnit4::class)class NavigationTest { @get:Rule val composeTestRule = createAndroidComposeRule\u003cMainActivity\u003e() @Test fun onHomeScreen_whenProductIsTapped_thenProductScreenIsDisplayed() { composeTestRule.apply { onNodeWithText(\"View details about ABC\").performClick() onNodeWithText(\"Product details for ABC\").assertExists() } }}Essentially, you are not interacting with your navigation graph directly ‚Äî instead, you are simulating user input in order to assert that your navigation routes lead to the correct content.üêûDebugging tip: If you ever want to pause an instrumented test but still interact with the app, you can use composeTestRule.waitUntil(timeoutMillis = 3_600_000, condition = { false }). Paste this into a test right before a failure point, then poke around with the app to try to understand why the test fails (you have an hour ‚Äî hopefully long enough to figure it out!). The layout inspector even works at the same time. You can also just wrap this in a single test if you want to investigate the app‚Äôs state with only the test setup code. This is particularly useful when your instrumented app uses fake data which might cause differences in behavior from your production build.Migrating existing codeIf you‚Äôre already using Jetpack Navigation and defining your navigation graph using the Kotlin DSL, you will likely want to update your existing code. Let‚Äôs look at two popular migration use cases: string-based routes and top level navigation UI.From Strings to Any‚Ä¶thingIn previous releases of Navigation Compose, you needed to define your routes and navigation argument keys as strings. Here‚Äôs an example of a product route defined this way.const val PRODUCT_ID_KEY = \"id\"const val PRODUCT_BASE_ROUTE = \"product/\"const val PRODUCT_ROUTE = \"$PRODUCT_BASE_ROUTE{$PRODUCT_ID_KEY}\"// Inside NavHostcomposable( route = PRODUCT_ROUTE, arguments = listOf( navArgument(PRODUCT_ID_KEY) { type = NavType.StringType nullable = false } )) { entry -\u003e val id = entry.arguments?.getString(PRODUCT_ID_KEY) ProductScreen(id = id ?: \"Not found\")}// When navigating to Product destinationnavController.navigate(route = \"$PRODUCT_BASE_ROUTE$productId\")Note how the type of the id argument is defined in multiple places (NavType.StringType and getString). The new APIs allow us to remove this duplication.To migrate this code, create a serializable class for the route (or an object if it has no arguments).@Serializable data class Product(val id: String)Replace any instances of the string-based route used to create destinations with the new type, and remove any arguments:composable\u003cProduct\u003e { ‚Ä¶ }When obtaining arguments, use toRoute to obtain the route object or class.composable\u003cProduct\u003e { backStackEntry -\u003e val product : Product = backStackEntry.toRoute() ProductScreen(product.id)}Also replace any instances of the string-based route when calling navigate:navController.navigate(route = Product(id))OK, we‚Äôre done! We‚Äôve been able to remove the string constants and boilerplate code, and also introduced type safety for navigation arguments.Incremental migrationYou don‚Äôt have to migrate all your string-based routes in one go. You can use methods which accept a generic type for the route interchangeably with methods which accept a string-based route, as long as your string format matches that generated by the Navigation library from your route types.Put another way, the following code will still work as expected after the migration above:navController.navigate(route = ‚Äúproduct/ABC‚Äù)This lets you migrate your navigation code incrementally rather than being an ‚Äúall or nothing‚Äù procedure.Top level navigation UIMost apps will have some form of navigation UI which is always displayed, allowing users to navigate to different top level destinations.Material 3 Navigation RailA crucial responsibility for this navigation UI is to display which top level destination the user is currently on. This is usually done by iterating through the top-level destinations and checking whether its route is equal to any route in the current back stack.For the following example, we‚Äôll use NavigationSuiteScaffold which displays the correct navigation UI depending on the available window size.const val HOME_ROUTE = \"home\"const val SHOPPING_CART_ROUTE = \"shopping_cart\"const val ACCOUNT_ROUTE = \"account\"data class TopLevelRoute(val route: String, val icon: ImageVector)val TOP_LEVEL_ROUTES = listOf( TopLevelRoute(route = HOME_ROUTE, icon = Icons.Default.Home), TopLevelRoute(route = SHOPPING_CART_ROUTE, icon = Icons.Default.ShoppingCart), TopLevelRoute(route = ACCOUNT_ROUTE, icon = Icons.Default.AccountBox),)// Inside your main app layoutval navBackStackEntry by navController.currentBackStackEntryAsState()val currentDestination = navBackStackEntry?.destinationNavigationSuiteScaffold( navigationSuiteItems = { TOP_LEVEL_ROUTES.forEach { topLevelRoute -\u003e item( selected = currentDestination?.hierarchy?.any { it.route == topLevelRoute.route } == true, icon = { Icon( imageVector = topLevelRoute.icon, contentDescription = topLevelRoute.route ) }, onClick = { navController.navigate(route = topLevelRoute.route) } ) } }) {NavHost(‚Ä¶)}In the new type safe APIs, you don‚Äôt define your top level routes as strings, so you can‚Äôt use string comparison. Instead, use the new hasRoute extension function on NavDestination to check whether a destination has a specific route class.@Serializable data object Home@Serializable data object ShoppingCart@Serializable data object Accountdata class TopLevelRoute\u003cT : Any\u003e(val route: T, val icon: ImageVector)val TOP_LEVEL_ROUTES = listOf( TopLevelRoute(route = Home, icon = Icons.Default.Home), TopLevelRoute(route = ShoppingCart, icon = Icons.Default.ShoppingCart), TopLevelRoute(route = Account, icon = Icons.Default.AccountCircle))// Inside your main app layoutval navBackStackEntry by navController.currentBackStackEntryAsState()val currentDestination = navBackStackEntry?.destinationNavigationSuiteScaffold( navigationSuiteItems = { TOP_LEVEL_ROUTES.forEach { topLevelRoute -\u003e item( selected = currentDestination?.hierarchy?.any { it.hasRoute(route = topLevelRoute.route::class) } == true, icon = { Icon( imageVector = topLevelRoute.icon, contentDescription = topLevelRoute.route::class.simpleName ) }, onClick = { navController.navigate(route = topLevelRoute.route)} ) } }) {NavHost(‚Ä¶)}Things to watch out for‚Ä¶It‚Äôs easy to confuse classes and object destinationsCan you spot the problem with the following code?@Serializable data class Product(val id: String)NavHost( navController = navController, startDestination = Product) { ‚Ä¶ }It‚Äôs not immediately obvious but if you were to run it, you‚Äôd see the following error:kotlinx.serialization.SerializationException: Serializer for class ‚ÄòCompanion‚Äô is not found.This is because Product is not a valid destination, only an instance of Product is (e.g. Product(‚ÄúABC‚Äù)). The above error message is confusing until you realize that the serialization library is looking for the statically initialized Companion object of the Product class which isn‚Äôt defined as serializable (in fact, we didn‚Äôt define it at all, the Kotlin compiler added it for us), and hence doesn‚Äôt have a corresponding serializer.New since alpha: A lint check was added to spot places where an incorrect type is being used for the route. When you try to use the class name instead of the class instance, you‚Äôll receive a helpful error message: ‚ÄúThe route should be a destination class instance or destination object.‚Äù. A similar lint check when using popBackStack will be added in the 2.8.1 release.Don‚Äôt create duplicate destinationsUsing duplicate destinations used to result in undefined behavior. This has now been fixed, and (new since alpha) navigating to a duplicate destination will now navigate to the nearest destination in the navigation graph which matches, relative to your current destination.That said, it‚Äôs still not recommended to create duplicate destinations in your navigation graph due to the ambiguity it creates when navigating to one of those destinations. If the same content should appear in two destinations, create a separate destination class for each one and just use the same content composable.Be careful of ‚Äúnull‚Äù strings (for now)Currently, if you have a route with a String argument and its value is set to the string literal ‚Äúnull‚Äù, the app will crash when navigating to that destination. This issue will be fixed in 2.8.1, due in a couple of weeks.In the meantime, if you have unsanitized input to a String route argument, perform a check for ‚Äúnull‚Äù first to avoid the crash.TransactionTooLargeExceptionDon‚Äôt use large objects as routes as you may run into TransactionTooLargeException. When navigating, the route is saved to persist system-initiated process death and the saving mechanism is a binder transaction. Binder transactions have a 1MB buffer so large objects can easily fill this buffer.You can avoid using large objects for routes by storing data using a storage mechanism designed for large data, such as Room or DataStore. When inserting data, obtain a unique reference, such as an ID field. You can then use this, much smaller, unique reference in the route. Use the reference to obtain the data at the destination.SummaryThat‚Äôs about it for the new type safe navigation APIs. Here‚Äôs a quick summary of the most important functions.Define destinations using composable\u003cT\u003e (or navigation\u003cT\u003e for nested graphs)Navigate to a destination using navigate(route = T) for object routes or navigate(route = T(‚Ä¶)) for class instance routesObtain a route from a NavBackStackEntry or SavedStateHandle using toRoute\u003cT\u003eCheck whether a destination was created using a given route using hasRoute(route = T::class)You can check out a working implementation of these APIs in the Now in Android app. The migration from string-based routes happened in this pull request.We‚Äôd love to hear your thoughts on these APIs. Feel free to leave a comment, or if you have any issues please file a bug. You can read more about how to use Jetpack Navigation in the official documentation.The code snippets in this article have the following license:// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*jpVm3Kc_A-n-7LaCVbHrpQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@donturner?source=post_page-----105325a97657--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Don Turner\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*F2tQfS9RL-Br9vcm_ih_NQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page-----105325a97657--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"f383\"\u003eWith the latest release of \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/navigation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Navigation 2.8.0\u003c/a\u003e, the type safe navigation APIs for building navigation graphs in Kotlin are stable üéâ. This means that you can define your destinations using serializable types and benefit from compile-time safety.\u003c/p\u003e\u003cp id=\"251a\"\u003eThis is great news if you‚Äôre using \u003ca href=\"https://developer.android.com/compose\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose\u003c/a\u003e for your UI because it‚Äôs simpler and safer to define your navigation destinations and arguments.\u003c/p\u003e\u003cp id=\"f068\"\u003eThe design philosophy behind these new APIs is covered in \u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/navigation-compose-meet-type-safety-e081fb3cf2f8\"\u003ethis blog post\u003c/a\u003e which accompanied the first release they appeared in ‚Äî 2.8.0-alpha08.\u003c/p\u003e\u003cp id=\"31ba\"\u003eSince then, we‚Äôve received and incorporated lots of feedback, fixed some bugs and made several improvements to the API. This article covers the stable API and points out changes since the first alpha release. It also looks at how to migrate existing code and provides some tips on testing navigation use cases.\u003c/p\u003e\u003ch2 id=\"ad8b\"\u003eThe basics\u003c/h2\u003e\u003cp id=\"60b0\"\u003eThe new type safe navigation APIs for Kotlin allow you to use \u003ccode\u003eAny\u003c/code\u003e serializable type to define navigation destinations. To use them, you‚Äôll need to \u003ca href=\"https://developer.android.com/guide/navigation#set-up\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eadd the Jetpack navigation library version 2.8.0\u003c/a\u003e and the \u003ca href=\"https://kotlinlang.org/docs/serialization.html#example-json-serialization\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin serialization plugin\u003c/a\u003e to your project.\u003c/p\u003e\u003cp id=\"835a\"\u003eOnce done, you can use the \u003ccode\u003e@Serializable\u003c/code\u003eannotation to automatically create serializable types. These can then be used to create a navigation graph.\u003c/p\u003e\u003cp id=\"0f78\"\u003eThe remainder of this article assumes you‚Äôre using Compose as your UI framework (by including \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/navigation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enavigation-compose\u003c/a\u003e\u003c/code\u003e in your dependencies), although the examples should work equally well with Fragments (\u003ca href=\"https://developer.android.com/guide/navigation/design/kotlin-dsl#navgraphbuilder\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewith some slight differences\u003c/a\u003e). If you‚Äôre using both, we have some \u003ca href=\"https://youtu.be/DZJV-ZKQ634?si=8WmEQY-5VXMO4psl\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enew interop APIs for that too\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"bf8c\"\u003eA good example of one of the new APIs is \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder#(androidx.navigation.NavGraphBuilder).composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecomposable\u003c/a\u003e\u003c/code\u003e. It now accepts a generic type which can be used to define a destination.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a4a5\"\u003e@Serializable data object Home\u003cp\u003eNavHost(navController, startDestination = Home) {\u003cbr/\u003e  composable\u0026lt;Home\u0026gt; {\u003cbr/\u003e    HomeScreen()\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"606e\"\u003eNomenclature is important here. In navigation terms, \u003ccode\u003eHome\u003c/code\u003e is a \u003cstrong\u003eroute\u003c/strong\u003e which is used to create a \u003cstrong\u003edestination\u003c/strong\u003e. The destination has a route type and \u003cstrong\u003edefines what will be displayed on screen\u003c/strong\u003e at that destination, in this case \u003ccode\u003eHomeScreen\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"5b7b\"\u003eThese new APIs can be summarized as: \u003cstrong\u003eAny method that accepts a route now accepts a generic type for that route. \u003c/strong\u003eThe examples that follow use these new methods.\u003c/p\u003e\u003ch2 id=\"1e0c\"\u003ePassing data between destinations\u003c/h2\u003e\u003cp id=\"b361\"\u003eOne of the primary benefits of these new APIs is the compile-time safety provided by using types for navigation arguments. For \u003ca href=\"https://kotlinlang.org/docs/basic-types.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebasic types\u003c/a\u003e, it‚Äôs super simple to pass them to a destination.\u003c/p\u003e\u003cp id=\"88a0\"\u003eLet‚Äôs say we have an app which displays products on the Home screen. Clicking on any product displays the product details on a Product screen.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cem\u003eNavigation graph with two destinations: Home and Product\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c88b\"\u003eWe can define the Product route using a data class which has a String id field which will contain the product ID.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ef78\"\u003e@Serializable data class Product(val id: String)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ca1a\"\u003eBy doing so, we‚Äôre establishing a couple of navigation rules:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1356\"\u003eThe \u003ccode\u003eProduct\u003c/code\u003e route must always have an \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\u003cli id=\"0e68\"\u003eThe type of \u003ccode\u003eid\u003c/code\u003e is always a \u003ccode\u003eString\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"60e7\"\u003eYou can use any basic type as a navigation argument, including lists and arrays. For more complex types, see the ‚ÄúCustom types‚Äù section of \u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/navigation-compose-meet-type-safety-e081fb3cf2f8\"\u003ethis article\u003c/a\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c528\"\u003e\u003cstrong\u003eNew since alpha:\u003c/strong\u003e Nullable types are supported.\u003c/p\u003e\u003cp id=\"0535\"\u003e\u003cstrong\u003eNew since alpha\u003c/strong\u003e: Enums are supported (although you‚Äôll need to use \u003ccode\u003e@Keep\u003c/code\u003e on the enum declaration to ensure that the enum class is not removed during minified builds, \u003ca href=\"https://issuetracker.google.com/issues/358687142\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003etracking bug\u003c/a\u003e)\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"692f\"\u003eObtaining the route at the destination\u003c/h2\u003e\u003cp id=\"361c\"\u003eWhen we use this route to define a destination in our navigation graph, we can obtain the route from the back stack entry using \u003ccode\u003etoRoute\u003c/code\u003e. This can then be passed to whatever is needed to render that destination on screen, in this case \u003ccode\u003eProductScreen\u003c/code\u003e. Here‚Äôs how our destination is implemented:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5d04\"\u003ecomposable\u0026lt;Product\u0026gt; { backStackEntry -\u0026gt;\u003cbr/\u003e  val product : Product = backStackEntry.toRoute()\u003cbr/\u003e  ProductScreen(product)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"0ec5\"\u003e\u003cstrong\u003eNew since alpha:\u003c/strong\u003e If you‚Äôre using a ViewModel to provide state to your screen, you can also obtain the route from \u003ccode\u003esavedStateHandle\u003c/code\u003e using the \u003ccode\u003etoRoute\u003c/code\u003e extension function.\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"7730\"\u003eProductViewModel(private val savedStateHandle: SavedStateHandle, ‚Ä¶) : ViewModel {\u003cbr/\u003e  private val product : Product = savedStateHandle.toRoute()\u003cbr/\u003e  // Set up UI state using product\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"53ff\"\u003e\u003cstrong\u003eNote on testing:\u003c/strong\u003e As of release 2.8.0, \u003ccode\u003eSavedStateHandle.toRoute\u003c/code\u003e is dependent on Android \u003ccode\u003eBundle\u003c/code\u003e. This means your ViewModel tests will need to be instrumented (e.g. by using Robolectric or by running them on an emulator). We‚Äôre looking at ways we can remove this dependency in future releases (\u003ca href=\"https://issuetracker.google.com/349807172\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003etracked here\u003c/a\u003e).\u003c/p\u003e\u003ch2 id=\"a75a\"\u003ePassing data when navigating\u003c/h2\u003e\u003cp id=\"ff23\"\u003eUsing the route to pass navigation arguments is simple ‚Äî just use \u003ccode\u003enavigate\u003c/code\u003e with an instance of the route class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2880\"\u003enavController.navigate(route = Product(id = \u0026#34;ABC\u0026#34;))\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bd60\"\u003eHere‚Äôs a complete example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9c36\"\u003eNavHost(\u003cbr/\u003e    navController = navController,\u003cbr/\u003e    startDestination = Home\u003cbr/\u003e) {\u003cbr/\u003e    composable\u0026lt;Home\u0026gt; {\u003cbr/\u003e        HomeScreen(\u003cbr/\u003e            onProductClick = { id -\u0026gt;  \u003cbr/\u003e                navController.navigate(route = Product(id)) \u003cbr/\u003e            }\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e    composable\u0026lt;Product\u0026gt; { backStackEntry -\u0026gt;\u003cbr/\u003e        val product : Product = backStackEntry.toRoute()\u003cbr/\u003e        ProductScreen(product)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"11e4\"\u003eNow that you know how to pass data between screens inside your app, let‚Äôs look at how you can navigate and pass data into your app from outside.\u003c/p\u003e\u003ch2 id=\"97a9\"\u003eStraight to your destination with deep links\u003c/h2\u003e\u003cp id=\"2eb5\"\u003eSometimes you want to take users directly to a specific screen within your app, rather than starting at the home screen. For example, if you‚Äôve just sent them a notification saying ‚Äúcheck out this new product‚Äù, it makes perfect sense to take them straight to that product screen when they tap on the notification. \u003ca href=\"https://developer.android.com/guide/navigation/design/deep-link\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDeep links\u003c/a\u003e enable you to do this.\u003c/p\u003e\u003cp id=\"834c\"\u003eHere‚Äôs how you add a deep link to the \u003ccode\u003eProduct\u003c/code\u003e destination mentioned above:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"af91\"\u003ecomposable\u0026lt;Product\u0026gt;(\u003cbr/\u003e  deepLinks = listOf(\u003cbr/\u003e    navDeepLink\u0026lt;Product\u0026gt;(\u003cbr/\u003e      basePath = \u0026#34;www.hellonavigation.example.com/product\u0026#34;\u003cbr/\u003e    )\u003cbr/\u003e  )\u003cbr/\u003e) {\u003cbr/\u003e‚Ä¶\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ae4c\"\u003e\u003ccode\u003enavDeepLink\u003c/code\u003e is used to construct the deep link URL from both the class, in this case \u003ccode\u003eProduct\u003c/code\u003e, and the supplied \u003ccode\u003ebasePath\u003c/code\u003e. Any fields from the supplied class are automatically included in the URL as parameters. The generated deep link URL is:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2275\"\u003ewww.hellonavigation.example.com/product/{id}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"97be\"\u003eTo test it, you could use the following adb command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ee1f\"\u003eadb shell am start -a android.intent.action.VIEW -d \u0026#34;https://www.hellonavigation.example.com/product/ABC\u0026#34; com.example.hellonavigation\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0a9b\"\u003eThis will launch the app directly on the \u003ccode\u003eProduct\u003c/code\u003e destination with the \u003ccode\u003eProduct.id\u003c/code\u003e set to ‚ÄúABC‚Äù.\u003c/p\u003e\u003ch2 id=\"187d\"\u003eURL parameter types\u003c/h2\u003e\u003cp id=\"17a1\"\u003eWe‚Äôve just seen an example of the navigation library automatically generating a deep link URL containing a \u003cstrong\u003epath parameter\u003c/strong\u003e. Path parameters are generated for required route arguments. Looking at our \u003ccode\u003eProduct\u003c/code\u003e again:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b5b2\"\u003e@Serializable data class Product(val id: String)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2431\"\u003eThe \u003ccode\u003eid\u003c/code\u003e field is mandatory so the deep link URL format of \u003ccode\u003e/{id}\u003c/code\u003e is appended to the base path. Path parameters are always generated for route arguments, except when:\u003c/p\u003e\u003cp id=\"3879\"\u003e1. the class field has a default value (the field is optional), or\u003c/p\u003e\u003cp id=\"e099\"\u003e2. the class field represents a collection of primitive types, like a \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e or \u003ccode\u003eArray\u0026lt;Int\u0026gt;\u003c/code\u003e (\u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:navigation/navigation-common/src/main/java/androidx/navigation/NavType.kt;l=179\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efull list of supported types\u003c/a\u003e, add your own by extending \u003ccode\u003e\u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:navigation/navigation-common/src/main/java/androidx/navigation/CollectionNavType.kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCollectionNavType\u003c/a\u003e\u003c/code\u003e)\u003c/p\u003e\u003cp id=\"96c0\"\u003eIn each of these cases, a \u003cstrong\u003equery parameter\u003c/strong\u003e is generated. Query parameters have a deep link URL format of \u003ccode\u003e?name=value\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"84cb\"\u003eHere‚Äôs a summary of the different types of URL parameter:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003ePath and query parameters\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"250b\"\u003e\u003cstrong\u003eNew since alpha:\u003c/strong\u003e Empty strings for path parameters are now supported. In the above example, if you use a deep link URL of \u003ca href=\"http://www.hellonavigation.example.com/product//\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewww.hellonavigation.example.com/product//\u003c/a\u003e then the id field would be set to an empty string.\u003c/p\u003e\u003ch2 id=\"4b88\"\u003eTesting deep links\u003c/h2\u003e\u003cp id=\"3ef9\"\u003eOnce you‚Äôve \u003ca href=\"https://developer.android.com/training/app-links/deep-linking#adding-filters\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eset up your app‚Äôs manifest to accept incoming links\u003c/a\u003e, an easy way to test your deep links is to use \u003ccode\u003eadb\u003c/code\u003e. Here‚Äôs an example (note that \u003ccode\u003e\u0026amp;\u003c/code\u003e is escaped):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"08d6\"\u003eadb shell am start -a android.intent.action.VIEW -d ‚Äúhttps://hellonavigation.example.com/product/ABC?color=red\\\u0026amp;variants=var1\\\u0026amp;variants=var2\u0026#34; com.example.hellonavigation\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"26ac\"\u003eüêû\u003cstrong\u003eDebugging tip:\u003c/strong\u003e If you ever want to check the generated deep link URL format, just print the NavBackStackEntry.destination.route from your destination and it‚Äôll appear in logcat when you navigate to that destination:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ce15\"\u003ecomposable\u0026lt;Product\u0026gt;( ‚Ä¶ ) { backStackEntry -\u0026gt;\u003cbr/\u003e  println(backStackEntry.destination.route)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5066\"\u003eTesting navigation\u003c/h2\u003e\u003cp id=\"2fec\"\u003eWe‚Äôve already touched on how you can test deep links using adb but let‚Äôs dive a bit deeper into how you can test your navigation code. Navigation tests are usually instrumented tests which simulate the user navigating through your app.\u003c/p\u003e\u003cp id=\"69d9\"\u003eHere‚Äôs a simple test which verifies that when you tap on a product button, the product screen is displayed with the correct content.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e148\"\u003e@RunWith(AndroidJUnit4::class)\u003cbr/\u003eclass NavigationTest {\u003cbr/\u003e  @get:Rule\u003cbr/\u003e  val composeTestRule = createAndroidComposeRule\u0026lt;MainActivity\u0026gt;()\u003cp\u003e  @Test\u003cbr/\u003e  fun onHomeScreen_whenProductIsTapped_thenProductScreenIsDisplayed() {\u003cbr/\u003e    composeTestRule.apply {\u003cbr/\u003e      onNodeWithText(\u0026#34;View details about ABC\u0026#34;).performClick()\u003cbr/\u003e      onNodeWithText(\u0026#34;Product details for ABC\u0026#34;).assertExists()\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7e80\"\u003eEssentially, you are not interacting with your navigation graph directly ‚Äî instead, you are simulating user input in order to assert that your navigation routes lead to the correct content.\u003c/p\u003e\u003cp id=\"bdca\"\u003eüêû\u003cstrong\u003eDebugging tip: \u003c/strong\u003eIf you ever want to pause an instrumented test but still interact with the app, you can use \u003ccode\u003ecomposeTestRule.waitUntil(timeoutMillis = 3_600_000, condition = { false })\u003c/code\u003e. Paste this into a test right before a failure point, then poke around with the app to try to understand why the test fails (you have an hour ‚Äî hopefully long enough to figure it out!). The layout inspector even works at the same time. You can also just wrap this in a single test if you want to investigate the app‚Äôs state with only the test setup code. This is particularly useful when your instrumented app uses fake data which might cause differences in behavior from your production build.\u003c/p\u003e\u003ch2 id=\"ac14\"\u003eMigrating existing code\u003c/h2\u003e\u003cp id=\"f9b0\"\u003eIf you‚Äôre already using Jetpack Navigation and defining your navigation graph using the \u003ca href=\"https://developer.android.com/guide/navigation/design/kotlin-dsl\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin DSL\u003c/a\u003e, you will likely want to update your existing code. Let‚Äôs look at two popular migration use cases: string-based routes and top level navigation UI.\u003c/p\u003e\u003ch2 id=\"34c6\"\u003eFrom Strings to Any‚Ä¶thing\u003c/h2\u003e\u003cp id=\"01c6\"\u003eIn previous releases of Navigation Compose, you needed to define your routes and navigation argument keys as strings. Here‚Äôs an example of a product route defined this way.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"154c\"\u003econst val PRODUCT_ID_KEY = \u0026#34;id\u0026#34;\u003cbr/\u003econst val PRODUCT_BASE_ROUTE = \u0026#34;product/\u0026#34;\u003cbr/\u003econst val PRODUCT_ROUTE = \u0026#34;$PRODUCT_BASE_ROUTE{$PRODUCT_ID_KEY}\u0026#34;\u003cp\u003e// Inside NavHost\u003cbr/\u003ecomposable(\u003cbr/\u003e  route = PRODUCT_ROUTE,\u003cbr/\u003e  arguments = listOf(\u003cbr/\u003e    navArgument(PRODUCT_ID_KEY) {\u003cbr/\u003e      type = NavType.StringType\u003cbr/\u003e      nullable = false\u003cbr/\u003e    }\u003cbr/\u003e  )\u003cbr/\u003e) { entry -\u0026gt;\u003cbr/\u003e  val id = entry.arguments?.getString(PRODUCT_ID_KEY)\u003cbr/\u003e  ProductScreen(id = id ?: \u0026#34;Not found\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// When navigating to Product destination\u003cbr/\u003enavController.navigate(route = \u0026#34;$PRODUCT_BASE_ROUTE$productId\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9de4\"\u003eNote how the type of the \u003ccode\u003eid\u003c/code\u003e argument is defined in multiple places (\u003ccode\u003eNavType.StringType\u003c/code\u003e and \u003ccode\u003egetString\u003c/code\u003e). The new APIs allow us to remove this duplication.\u003c/p\u003e\u003cp id=\"2fed\"\u003eTo migrate this code, create a serializable class for the route (or an object if it has no arguments).\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0693\"\u003e@Serializable data class Product(val id: String)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4b3a\"\u003eReplace any instances of the string-based route used to create destinations with the new type, and remove any arguments:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98ac\"\u003ecomposable\u0026lt;Product\u0026gt; { ‚Ä¶ }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"37e5\"\u003eWhen obtaining arguments, use \u003ccode\u003etoRoute\u003c/code\u003e to obtain the route object or class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bbd0\"\u003ecomposable\u0026lt;Product\u0026gt; { backStackEntry -\u0026gt;\u003cbr/\u003e  val product : Product = backStackEntry.toRoute()\u003cbr/\u003e  ProductScreen(product.id)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc04\"\u003eAlso replace any instances of the string-based route when calling \u003ccode\u003enavigate\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7dc3\"\u003enavController.navigate(route = Product(id))\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1474\"\u003eOK, we‚Äôre done! We‚Äôve been able to remove the string constants and boilerplate code, and also introduced type safety for navigation arguments.\u003c/p\u003e\u003ch2 id=\"e3b6\"\u003eIncremental migration\u003c/h2\u003e\u003cp id=\"5cb6\"\u003eYou don‚Äôt have to migrate all your string-based routes in one go. You can use methods which accept a generic type for the route interchangeably with methods which accept a string-based route, as long as your string format matches that generated by the Navigation library from your route types.\u003c/p\u003e\u003cp id=\"7312\"\u003ePut another way, the following code will still work as expected after the migration above:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a7d\"\u003enavController.navigate(route = ‚Äúproduct/ABC‚Äù)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5f20\"\u003eThis lets you migrate your navigation code incrementally rather than being an ‚Äúall or nothing‚Äù procedure.\u003c/p\u003e\u003ch2 id=\"d699\"\u003eTop level navigation UI\u003c/h2\u003e\u003cp id=\"e103\"\u003eMost apps will have some form of navigation UI which is always displayed, allowing users to navigate to different top level destinations.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://m3.material.io/components/navigation-rail/overview\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eMaterial 3 Navigation Rail\u003c/em\u003e\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"93d1\"\u003eA crucial responsibility for this navigation UI is to display which top level destination the user is currently on. This is usually done by iterating through the top-level destinations and checking whether its route is equal to any route in the current back stack.\u003c/p\u003e\u003cp id=\"f00a\"\u003eFor the following example, we‚Äôll use \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive/build-adaptive-navigation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNavigationSuiteScaffold\u003c/a\u003e\u003c/code\u003e which displays the correct navigation UI depending on the available window size.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e0da\"\u003econst val HOME_ROUTE = \u0026#34;home\u0026#34;\u003cbr/\u003econst val SHOPPING_CART_ROUTE = \u0026#34;shopping_cart\u0026#34;\u003cbr/\u003econst val ACCOUNT_ROUTE = \u0026#34;account\u0026#34;\u003cp\u003edata class TopLevelRoute(val route: String, val icon: ImageVector)\u003c/p\u003e\u003cp\u003eval TOP_LEVEL_ROUTES = listOf(\u003cbr/\u003e  TopLevelRoute(route = HOME_ROUTE, icon = Icons.Default.Home),\u003cbr/\u003e  TopLevelRoute(route = SHOPPING_CART_ROUTE, icon = Icons.Default.ShoppingCart),\u003cbr/\u003e  TopLevelRoute(route = ACCOUNT_ROUTE, icon = Icons.Default.AccountBox),\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003e// Inside your main app layout\u003cbr/\u003eval navBackStackEntry by navController.currentBackStackEntryAsState()\u003cbr/\u003eval currentDestination = navBackStackEntry?.destination\u003c/p\u003e\u003cp\u003eNavigationSuiteScaffold(\u003cbr/\u003e  navigationSuiteItems = {\u003cbr/\u003e    TOP_LEVEL_ROUTES.forEach { topLevelRoute -\u0026gt;\u003cbr/\u003e      item(\u003cbr/\u003e        selected = currentDestination?.hierarchy?.any {\u003cbr/\u003e          it.route == topLevelRoute.route\u003cbr/\u003e        } == true,\u003cbr/\u003e        icon = {\u003cbr/\u003e          Icon(\u003cbr/\u003e            imageVector = topLevelRoute.icon,\u003cbr/\u003e            contentDescription = topLevelRoute.route\u003cbr/\u003e          )\u003cbr/\u003e        },\u003cbr/\u003e        onClick = { navController.navigate(route = topLevelRoute.route) }\u003cbr/\u003e      )\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e) {\u003cbr/\u003eNavHost(‚Ä¶)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e431\"\u003eIn the new type safe APIs, you don‚Äôt define your top level routes as strings, so you can‚Äôt use string comparison. Instead, use the new \u003ccode\u003ehasRoute\u003c/code\u003e extension function on \u003ccode\u003eNavDestination\u003c/code\u003e to check whether a destination has a specific route class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a59d\"\u003e@Serializable data object Home\u003cbr/\u003e@Serializable data object ShoppingCart\u003cbr/\u003e@Serializable data object Account\u003cp\u003edata class TopLevelRoute\u0026lt;T : Any\u0026gt;(val route: T, val icon: ImageVector)\u003c/p\u003e\u003cp\u003eval TOP_LEVEL_ROUTES = listOf(\u003cbr/\u003e  TopLevelRoute(route = Home, icon = Icons.Default.Home),\u003cbr/\u003e  TopLevelRoute(route = ShoppingCart, icon = Icons.Default.ShoppingCart),\u003cbr/\u003e  TopLevelRoute(route = Account, icon = Icons.Default.AccountCircle)\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003e// Inside your main app layout\u003cbr/\u003eval navBackStackEntry by navController.currentBackStackEntryAsState()\u003cbr/\u003eval currentDestination = navBackStackEntry?.destination\u003c/p\u003e\u003cp\u003eNavigationSuiteScaffold(\u003cbr/\u003e  navigationSuiteItems = {\u003cbr/\u003e    TOP_LEVEL_ROUTES.forEach { topLevelRoute -\u0026gt;\u003cbr/\u003e      item(\u003cbr/\u003e        selected = currentDestination?.hierarchy?.any {\u003cbr/\u003e          it.hasRoute(route = topLevelRoute.route::class)\u003cbr/\u003e        } == true,\u003cbr/\u003e        icon = {\u003cbr/\u003e          Icon(\u003cbr/\u003e            imageVector = topLevelRoute.icon,\u003cbr/\u003e            contentDescription = topLevelRoute.route::class.simpleName\u003cbr/\u003e          )\u003cbr/\u003e        },\u003cbr/\u003e        onClick = { navController.navigate(route = topLevelRoute.route)}\u003cbr/\u003e      )\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e) {\u003cbr/\u003eNavHost(‚Ä¶)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3e94\"\u003eThings to watch out for‚Ä¶\u003c/h2\u003e\u003ch2 id=\"7ddb\"\u003eIt‚Äôs easy to confuse classes and object destinations\u003c/h2\u003e\u003cp id=\"fe24\"\u003eCan you spot the problem with the following code?\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5f4e\"\u003e@Serializable \u003cbr/\u003edata class Product(val id: String)\u003cp\u003eNavHost(\u003cbr/\u003e  navController = navController,\u003cbr/\u003e  startDestination = Product\u003cbr/\u003e) { ‚Ä¶ }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"148e\"\u003eIt‚Äôs not immediately obvious but if you were to run it, you‚Äôd see the following error:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"05b1\"\u003ekotlinx.serialization.SerializationException: Serializer for class ‚ÄòCompanion‚Äô is not found.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9953\"\u003eThis is because \u003ccode\u003eProduct\u003c/code\u003e is not a valid destination, only \u003cem\u003ean instance of\u003c/em\u003e \u003ccode\u003eProduct\u003c/code\u003e is (e.g. \u003ccode\u003eProduct(‚ÄúABC‚Äù)\u003c/code\u003e). The above error message is confusing until you realize that the serialization library is looking for the statically initialized \u003ccode\u003eCompanion\u003c/code\u003e object of the \u003ccode\u003eProduct\u003c/code\u003e class which isn‚Äôt defined as serializable (in fact, we didn‚Äôt define it at all, the Kotlin compiler added it for us), and hence doesn‚Äôt have a corresponding serializer.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"bdfd\"\u003e\u003cstrong\u003eNew since alpha:\u003c/strong\u003e A \u003ca href=\"https://source.corp.google.com/h/android/platform/frameworks/support/+/81043eb1b25606c0242fabd80c0714b3f91b4d82\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elint check\u003c/a\u003e was added to spot places where an incorrect type is being used for the route. When you try to use the class name instead of the class instance, you‚Äôll receive a helpful error message: ‚ÄúThe route should be a destination class instance or destination object.‚Äù. A \u003ca href=\"https://b.corp.google.com/issues/358095343\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esimilar lint check\u003c/a\u003e when using \u003ccode\u003epopBackStack\u003c/code\u003e will be added in the 2.8.1 release.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"b922\"\u003eDon‚Äôt create duplicate destinations\u003c/h2\u003e\u003cp id=\"34f5\"\u003eUsing duplicate destinations used to result in undefined behavior. This has \u003ca href=\"https://issuetracker.google.com/issues/352006850\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enow been fixed\u003c/a\u003e, and (\u003cstrong\u003enew since alpha\u003c/strong\u003e)\u003cstrong\u003e \u003c/strong\u003enavigating to a duplicate destination will now navigate to the nearest destination in the navigation graph which matches, relative to your current destination.\u003c/p\u003e\u003cp id=\"6158\"\u003eThat said, it‚Äôs still not recommended to create duplicate destinations in your navigation graph due to the ambiguity it creates when navigating to one of those destinations. If the same content should appear in two destinations, create a separate destination class for each one and just use the same content composable.\u003c/p\u003e\u003ch2 id=\"158c\"\u003eBe careful of ‚Äúnull‚Äù strings (for now)\u003c/h2\u003e\u003cp id=\"31d1\"\u003eCurrently, if you have a route with a \u003ccode\u003eString\u003c/code\u003e argument and its value is set to the string literal \u003ccode\u003e‚Äúnull‚Äù\u003c/code\u003e, \u003ca href=\"https://issuetracker.google.com/360940641\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe app will crash when navigating to that destination\u003c/a\u003e. This issue will be fixed in 2.8.1, due in a couple of weeks.\u003c/p\u003e\u003cp id=\"7376\"\u003eIn the meantime, if you have unsanitized input to a \u003ccode\u003eString\u003c/code\u003e route argument, perform a check for ‚Äúnull‚Äù first to avoid the crash.\u003c/p\u003e\u003ch2 id=\"bc05\"\u003eTransactionTooLargeException\u003c/h2\u003e\u003cp id=\"475b\"\u003eDon‚Äôt use large objects as routes as you may run into \u003ca href=\"https://developer.android.com/reference/android/os/TransactionTooLargeException\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTransactionTooLargeException\u003c/a\u003e. When navigating, the route is saved to persist system-initiated process death and the saving mechanism is a binder transaction. Binder transactions have a 1MB buffer so large objects can easily fill this buffer.\u003c/p\u003e\u003cp id=\"be9f\"\u003eYou can avoid using large objects for routes by storing data using a storage mechanism designed for large data, such as \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/room\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRoom\u003c/a\u003e or \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/datastore\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDataStore\u003c/a\u003e. When inserting data, obtain a unique reference, such as an ID field. You can then use this, much smaller, unique reference in the route. Use the reference to obtain the data at the destination.\u003c/p\u003e\u003ch2 id=\"0cf1\"\u003eSummary\u003c/h2\u003e\u003cp id=\"04fc\"\u003eThat‚Äôs about it for the new type safe navigation APIs. Here‚Äôs a quick summary of the most important functions.\u003c/p\u003e\u003cul\u003e\u003cli id=\"9fb9\"\u003eDefine destinations using \u003ccode\u003ecomposable\u0026lt;T\u0026gt;\u003c/code\u003e (or \u003ccode\u003enavigation\u0026lt;T\u0026gt;\u003c/code\u003e for nested graphs)\u003c/li\u003e\u003cli id=\"0613\"\u003eNavigate to a destination using \u003ccode\u003enavigate(route = T)\u003c/code\u003e for object routes or \u003ccode\u003enavigate(route = T(‚Ä¶))\u003c/code\u003e for class instance routes\u003c/li\u003e\u003cli id=\"6530\"\u003eObtain a route from a \u003ccode\u003eNavBackStackEntry\u003c/code\u003e or \u003ccode\u003eSavedStateHandle\u003c/code\u003e using \u003ccode\u003etoRoute\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/li\u003e\u003cli id=\"cf2e\"\u003eCheck whether a destination was created using a given route using \u003ccode\u003ehasRoute(route = T::class)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"65d7\"\u003eYou can check out a \u003ca href=\"https://github.com/android/nowinandroid/blob/main/feature/topic/src/main/kotlin/com/google/samples/apps/nowinandroid/feature/topic/navigation/TopicNavigation.kt#L26\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eworking implementation of these APIs\u003c/a\u003e in the Now in Android app. The migration from string-based routes happened \u003ca href=\"https://github.com/android/nowinandroid/pull/1413\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ein this pull request\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"bd45\"\u003eWe‚Äôd love to hear your thoughts on these APIs. Feel free to leave a comment, or if you have any issues please \u003ca href=\"https://issuetracker.google.com/issues/new?component=409828\u0026amp;template=1093757\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efile a bug\u003c/a\u003e. You can read more about how to use Jetpack Navigation in the \u003ca href=\"https://developer.android.com/guide/navigation/design/type-safety\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial documentation\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"8d70\"\u003eThe code snippets in this article have the following license:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5710\"\u003e// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-09-05T00:06:11.383Z",
  "modifiedTime": null
}
