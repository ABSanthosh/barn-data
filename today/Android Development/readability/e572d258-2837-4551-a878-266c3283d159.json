{
  "id": "e572d258-2837-4551-a878-266c3283d159",
  "title": "I Dub Thee‚Ä¶ Marginally better at RegEx",
  "link": "https://zarah.dev/2024/07/21/regex-groups.html",
  "description": "Being a perpetual RegEx n00b, one thing I keep on forgetting is that it is easy to get tripped up when extracting information from an input.",
  "author": "Zarah Dominguez",
  "published": "2024-07-21T00:00:00+00:00",
  "source": "https://zarah.dev/feed.xml",
  "categories": [
    "kotlin",
    "regex"
  ],
  "byline": "",
  "length": 5129,
  "excerpt": "Being a perpetual RegEx n00b, one thing I keep on forgetting is that it is easy to get tripped up when extracting information from an input.",
  "siteName": "",
  "favicon": "https://zarah.dev/assets/images/apple-touch-icon.png",
  "text": "Being a perpetual RegEx n00b, one thing I keep on forgetting is that it is easy to get tripped up when extracting information from an input. I always forget that looking for a match does not really just give back just the matching values ‚Äì they are instead contained in Groups. Matches and Groups and all the things üíÖ For example, given the sentence ‚ÄúWelcome to zarah.dev!‚Äù, the value ‚Äúzarah.dev‚Äù can be extracted by enclosing a pattern within parentheses: val input = \"Welcome to zarah.dev!\" // Capture everything (. = any character, * = multiple times) // after the literal phrase \"Welcome to \" and before the literal exclamation mark val findPattern = \"\"\"Welcome to (.*)!\"\"\".toRegex() // Find matches in the input (!! to simplify examples) val results = findPattern.find(input)!! We know that in this instance there is only one value that we care for ‚Äì zarah.dev. But examining the contents of results, the returned value is actually the same as the input AND that there are two Groups contained within this MatchResult: println(\"Result of find: ${results.value}\") // Result of find: Welcome to zarah.dev! println(\"Groups in match: ${results.groups.count()}\") // Groups in match: 2 Looking into these further, we see that the Group: at index 0 is the full input at index 1 is the value captured within the parentheses results.groups.forEachIndexed { i, group -\u003e println(\"Group index $i, value is: ${group?.value}\") } // Group index 0, value is: Welcome to zarah.dev! // Group index 1, value is: zarah.dev I was super confused by this at first, until I realised that OF COURSE it makes sense! The whole input is present as the first element because it DOES match the RegEx pattern that we have. üôà In simple enough cases like in this example, dealing with the indices is not too bad, we just need to keep in mind that if we want to get value of anything after the ‚ÄúWelcome to ‚Äú phrase, we always need to look at the value of group[1]. However, once we want to capture more and more patterns, it can get very confusing very quickly. Gimme All The Groups üßÆ As a quick illustration, say the input is changed to something like: val input = \"Welcome to \u003csite\u003e! My name is \u003cowner\u003e and I talk about \u003ctopic\u003e.\" and we want to retrieve the values of site, owner, and topic. For simplicity, we will assume that input template always stays the same. val longInput = \"Welcome to zarah.dev! My name is Zarah and I talk about Android.\" val sitePattern = \"\"\"Welcome to (.*)! My name is (.*) and I talk about (.*)\\.\"\"\".toRegex() Applying this pattern to the longer input: results = sitePattern.find(longInput)!! results.groups.forEachIndexed { i, group -\u003e println(\"Group index $i, value is: ${group?.value}\") } // Group index 0, value is: Welcome to zarah.dev! My name is Zarah and I talk about Android. // Group index 1, value is: zarah.dev // Group index 2, value is: Zarah // Group index 3, value is: Android It is worth noting here that there is also a convenience method groupValues available on MatchResult which will basically give the same information but within a List: println(results.groupValues) // [Welcome to zarah.dev! My name is Zarah and I talk about Android., zarah.dev, Zarah, Android] This is NOT to be confused with another convenience method that omits the zeroth Group: println(results.destructured.toList()) // [zarah.dev, Zarah, Android] This is good enough if we only care about the values, but there are situations where we might want to also find the location of each value inside the source string; such as when writing a Lint rule, for example. Easier RegEx ü™™ Up to this point we have been dealing with indices, but what I found easiest is referring to each extracted value by name. And this is when MatchNamedGroupCollection comes in to save the day! From the documentation: Extends MatchGroupCollection by introducing a way to get matched groups by name, when regex supports it. To recap, calling find on a Regex returns a MatchResult, which contains a MatchGroupCollections. To use MatchNamedGroupCollection instead, we need to give our capturing statement a name, with the syntax being ?\u003cNAME\u003e. Applying this to our example: val namedSitePattern = \"\"\"Welcome to (?\u003csite\u003e.*)! My name is (?\u003cowner\u003e.*) and I talk about (?\u003ctopic\u003e.*)\\.\"\"\".toRegex() To make it even easier to use, we can define these names in vals for easy reuse: val KEY_SITE = \"site\" val KEY_OWNER = \"owner\" val KEY_TOPIC = \"topic\" val namedSitePattern = \"\"\"Welcome to (?\u003c$KEY_SITE\u003e.*)! My name is (?\u003c$KEY_OWNER\u003e.*) and I talk about (?\u003c$KEY_TOPIC\u003e.*)\\.\"\"\".toRegex() results = namedSitePattern.find(longInput)!! And then retrieve the individual Groups using their names: println(\"Site: ${results.groups[KEY_SITE]?.value}\") println(\"Owner: ${results.groups[KEY_OWNER]?.value}\") println(\"Topic: ${results.groups[KEY_TOPIC]?.value}\") // Site: zarah.dev // Owner: Zarah // Topic: Android I learned about this when I was looking at improving the TODO Lint rule and it definitely made all the String manipulations much easier. Keen to see how TODO Lint Rule v2 looks like? Stay tuned! üìª",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eBeing a perpetual RegEx n00b, one thing I keep on forgetting is that it is easy to get tripped up when \nextracting information from an input.\u003c/p\u003e\n\n\u003cp\u003eI always forget that looking for a match does \u003cem\u003enot\u003c/em\u003e really just give back just the matching values ‚Äì \nthey are instead contained in \u003ccode\u003eGroup\u003c/code\u003es.\u003c/p\u003e\n\n\u003ch3 id=\"matches-and-groups-and-all-the-things-\"\u003eMatches and Groups and all the things üíÖ\u003c/h3\u003e\n\n\u003cp\u003eFor example, given the sentence ‚ÄúWelcome to zarah.dev!‚Äù, the value ‚Äúzarah.dev‚Äù can be extracted by enclosing a \npattern within parentheses:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003einput\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Welcome to zarah.dev!\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003e// Capture everything (. = any character, * = multiple times) \u003c/span\u003e\n\u003cspan\u003e// after the literal phrase \u0026#34;Welcome to \u0026#34; and before the literal exclamation mark\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003efindPattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Welcome to (.*)!\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\n\u003cspan\u003e// Find matches in the input (!! to simplify examples)\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eresults\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efindPattern\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efind\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003einput\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe \u003cem\u003eknow\u003c/em\u003e that in this instance there is only one value that we care for ‚Äì \u003ccode\u003ezarah.dev\u003c/code\u003e. But examining the \ncontents of \u003ccode\u003eresults\u003c/code\u003e, the returned \u003ccode\u003evalue\u003c/code\u003e is actually the same as the input AND that there are two \u003ccode\u003eGroup\u003c/code\u003es\ncontained within this \u003ccode\u003eMatchResult\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Result of find: ${results.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// Result of find: Welcome to zarah.dev!\u003c/span\u003e\n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Groups in match: ${results.groups.count()}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// Groups in match: 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eLooking into these further, we see that the \u003ccode\u003eGroup\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eat index 0 is the full input\u003c/li\u003e\n  \u003cli\u003eat index 1 is the value captured within the parentheses\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egroups\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEachIndexed\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003egroup\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n    \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Group index $i, value is: ${group?.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// Group index 0, value is: Welcome to zarah.dev!\u003c/span\u003e\n\u003cspan\u003e// Group index 1, value is: zarah.dev\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI was super confused by this at first, until I realised that OF COURSE it makes sense! The whole input is \npresent as the first element because it \u003cstrong\u003e\u003cem\u003eDOES\u003c/em\u003e\u003c/strong\u003e match the RegEx pattern that we have. üôà\u003c/p\u003e\n\n\u003cp\u003eIn simple enough cases like in this example, dealing with the indices is not too bad, we just need to keep in\nmind that if we want to get value of anything after the ‚ÄúWelcome to ‚Äú phrase, we always need to look at the \nvalue of \u003ccode\u003egroup[1]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHowever, once we want to capture more and more patterns, it can get very confusing very quickly.\u003c/p\u003e\n\n\u003ch3 id=\"gimme-all-the-groups-\"\u003eGimme All The Groups üßÆ\u003c/h3\u003e\n\n\u003cp\u003eAs a quick illustration, say the input is changed to something like:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003einput\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Welcome to \u0026lt;site\u0026gt;! My name is \u0026lt;owner\u0026gt; and I talk about \u0026lt;topic\u0026gt;.\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eand we want to retrieve the values of \u003ccode\u003esite\u003c/code\u003e, \u003ccode\u003eowner\u003c/code\u003e, and \u003ccode\u003etopic\u003c/code\u003e. For simplicity, we will assume that input\ntemplate always stays the same.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003elongInput\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Welcome to zarah.dev! My name is Zarah and I talk about Android.\u0026#34;\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003esitePattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Welcome to (.*)! My name is (.*) and I talk about (.*)\\.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eApplying this pattern to the longer input:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eresults\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esitePattern\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efind\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elongInput\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\n\u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egroups\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEachIndexed\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003egroup\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n    \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Group index $i, value is: ${group?.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// Group index 0, value is: Welcome to zarah.dev! My name is Zarah and I talk about Android.\u003c/span\u003e\n\u003cspan\u003e// Group index 1, value is: zarah.dev\u003c/span\u003e\n\u003cspan\u003e// Group index 2, value is: Zarah\u003c/span\u003e\n\u003cspan\u003e// Group index 3, value is: Android\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt is worth noting here that there is also a convenience method \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-match-result/group-values.html\"\u003e\u003ccode\u003egroupValues\u003c/code\u003e\u003c/a\u003e\navailable on \u003ccode\u003eMatchResult\u003c/code\u003e which will basically give the same information but within a \u003ccode\u003eList\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egroupValues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// [Welcome to zarah.dev! My name is Zarah and I talk about Android., zarah.dev, Zarah, Android]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is NOT to be confused with \u003cem\u003eanother\u003c/em\u003e convenience method that omits the zeroth \u003ccode\u003eGroup\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresults\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edestructured\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoList\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\n\u003cspan\u003e// [zarah.dev, Zarah, Android]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is good enough if we only care about the values, but there are situations where we might want to also find\nthe location of each value inside the source string; such as when writing a Lint rule, for example.\u003c/p\u003e\n\n\u003ch3 id=\"easier-regex-\"\u003eEasier RegEx ü™™\u003c/h3\u003e\n\n\u003cp\u003eUp to this point we have been dealing with indices, but what I found easiest is referring to each extracted\nvalue by name. And this is when \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-match-named-group-collection/\"\u003e\u003ccode\u003eMatchNamedGroupCollection\u003c/code\u003e\u003c/a\u003e\ncomes in to save the day!\u003c/p\u003e\n\n\u003cp\u003eFrom the documentation:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eExtends \u003ccode\u003eMatchGroupCollection\u003c/code\u003e by introducing a way to get matched groups by name, when regex supports it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eTo recap, calling \u003ccode\u003efind\u003c/code\u003e on a \u003ccode\u003eRegex\u003c/code\u003e returns a \u003ccode\u003eMatchResult\u003c/code\u003e, which contains a \u003ccode\u003eMatchGroupCollection\u003c/code\u003es.\u003c/p\u003e\n\n\u003cp\u003eTo use \u003ccode\u003eMatchNamedGroupCollection\u003c/code\u003e instead, we need to give our capturing statement a name, with the syntax\nbeing \u003ccode\u003e?\u0026lt;NAME\u0026gt;\u003c/code\u003e. Applying this to our example:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003enamedSitePattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Welcome to (?\u0026lt;site\u0026gt;.*)! My name is (?\u0026lt;owner\u0026gt;.*) and I talk about (?\u0026lt;topic\u0026gt;.*)\\.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eTo make it even easier to use, we can define these names in \u003ccode\u003eval\u003c/code\u003es for easy reuse:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eKEY_SITE\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;site\u0026#34;\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eKEY_OWNER\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;owner\u0026#34;\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eKEY_TOPIC\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;topic\u0026#34;\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003enamedSitePattern\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Welcome to (?\u0026lt;$KEY_SITE\u0026gt;.*)! My name is (?\u0026lt;$KEY_OWNER\u0026gt;.*) and I talk about (?\u0026lt;$KEY_TOPIC\u0026gt;.*)\\.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoRegex\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003eresults\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enamedSitePattern\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efind\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elongInput\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e!!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd then retrieve the individual \u003ccode\u003eGroup\u003c/code\u003es using their names:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Site: ${results.groups[KEY_SITE]?.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Owner: ${results.groups[KEY_OWNER]?.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Topic: ${results.groups[KEY_TOPIC]?.value}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e// Site: zarah.dev\u003c/span\u003e\n\u003cspan\u003e// Owner: Zarah\u003c/span\u003e\n\u003cspan\u003e// Topic: Android\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI learned about this when I was looking at improving the \u003ca href=\"https://zarah.dev/2020/11/19/todo-detector.html\"\u003eTODO Lint rule\u003c/a\u003e\nand it definitely made all the \u003ccode\u003eString\u003c/code\u003e manipulations much easier. Keen to see how TODO Lint Rule v2 looks like? \nStay tuned! üìª\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
