{
  "id": "3942a17b-2368-4a8d-96de-9beb81b0aa9f",
  "title": "How to Answer Like a Kotlin Coroutine Expert: Kotlin Coroutine Suspension Under the Hood",
  "link": "https://proandroiddev.com/how-to-answer-like-a-kotlin-coroutine-expert-kotlin-coroutine-suspension-under-the-hood-fdfedfe88f44?source=rss----c72404660798---4",
  "description": "",
  "author": "Shbazhenov",
  "published": "Tue, 17 Jun 2025 13:48:33 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin-coroutines",
    "kotlin",
    "android",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Shbazhenov",
  "length": 7519,
  "excerpt": "Kotlin coroutines are often praised for their elegance in handling asynchronous code. But during interviews, surface-level understanding won’t get you far. To answer like a true Kotlin Coroutine…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin coroutines are often praised for their elegance in handling asynchronous code. But during interviews, surface-level understanding won’t get you far. To answer like a true Kotlin Coroutine expert, you need to understand what’s happening under the hood when a coroutine suspends.This article dives deep into the compiler-generated machinery of suspend functions: how they get compiled, what Continuation, invokeSuspend, and CoroutineImpl really are, and how suspension is actually implemented.What Happens When You Write a Suspend Function?Take this simple example:suspend fun functionA(param: Int): String { return \"hello $param\"}When compiled, the Kotlin compiler transforms it to something like:public static final Object functionA(int param, Continuation\u003c? super String\u003e $completion) { return \"hello \" + param;}What changed?An extra parameter of type Continuation was added.The return type changed from String to Object (or Any? in Kotlin), because:If the function completes synchronously, it returns the result (e.g., \"hello 5\")If it suspends, it returns a special marker: COROUTINE_SUSPENDEDThis transformation enables the compiler to treat the function as a suspendable computation, not just a regular method call.The Low-Level Suspending PrimitivesAny suspend function that truly suspends must eventually use one of the low-level suspension primitives. These primitives are the foundation of suspending functions like delay, withContext, and others. They are also the key to creating your own suspend functions or wrapping callback-based APIs.suspend fun something(): String = suspendCoroutine { continuation -\u003e println(\"Start async work\") someAsyncCallback { result -\u003e continuation.resume(result) // triggers coroutine to resume }}Types of primitives:suspendCoroutine { ... } — Basic suspension with manual continuation controlsuspendCancellableCoroutine { ... } — Same as above, but supports cancellation via JobsuspendCoroutineUninterceptedOrReturn { ... } — Even lower-level primitive, bypasses interceptors (used in libraries)These primitives are where the special marker COROUTINE_SUSPENDED is produced internally. When any of them returns, it signals to the caller that the coroutine should pause.The Coroutine Inheritance ChainEvery suspend function is backed by a compiler-generated class that extends from the following hierarchy:CoroutineImpl → ContinuationImpl → BaseContinuationImpl → Continuation\u003cT\u003eContinuation\u003cT\u003eThis is the core interface that represents what should happen next after a coroutine is suspended:interface Continuation\u003cin T\u003e { val context: CoroutineContext fun resumeWith(result: Result\u003cT\u003e)}context: Contains job, dispatcher, and other coroutine-related inforesumeWith: Called to resume the coroutine with a result or exceptionBaseContinuationImplThis abstract class implements Continuation. It introduces:abstract class BaseContinuationImpl( val completion: Continuation\u003cAny?\u003e?) : Continuation\u003cAny?\u003e { abstract fun invokeSuspend(result: Any?): Any? override fun resumeWith(result: Result\u003cAny?\u003e) { var current = this var param = result.getOrThrow() while (true) { val outcome = current.invokeSuspend(param) if (outcome == COROUTINE_SUSPENDED) return val parent = current.completion if (parent is BaseContinuationImpl) { current = parent param = outcome } else { parent?.resumeWith(Result.success(outcome)) return } } }}Why do we need invokeSuspend()?It contains the coroutine’s compiled state machine logic.It is overridden by compiler-generated classes like CoroutineImpl.It is invoked inside resumeWith(), which is the entry point for resuming suspended coroutines.What does resumeWith() do?It resumes the coroutine from where it was suspended.If the result is COROUTINE_SUSPENDED, the coroutine pauses and exits the loop.If the result is a real value, it is passed up the continuation chain to the parent coroutine.The loop continues until the top-level continuation (usually the one launched by the user) has no more work to resume.When COROUTINE_SUSPENDED is returned, it means the coroutine is paused and will be resumed later — typically via an external trigger like continuation.resume(...).ContinuationImplAdds debug info support:class ContinuationImpl(...) : BaseContinuationImpl(...) { override fun getStackTraceElement(): StackTraceElement? { ... }}It extends BaseContinuationImpl and implements CoroutineStackFrame to support debugging in IDEs like IntelliJ.CoroutineImplThis is the class generated by the compiler for a suspend function or lambda. It:Extends ContinuationImplOverrides invokeSuspend() using a when(label)-based state machineStores local variables across suspensions using internal fields (like L$0, L$1)What are L$0, L$1?These are internal variables created by the compiler to store the results of inner suspend functions. They help the coroutine remember intermediate values when it gets suspended and resumes later.What is label?label is an integer field used to track the current state of the coroutine. It is checked inside the when(label) statement to determine where to resume execution after suspension.Real Example: Suspend Lambda CompiledLet’s look at this suspend lambda (which under the hood is the compiler-generated CoroutineImpl class itself):val lambda = suspend { val a = computeA() val b = computeB(a) \"Result: $b\"}Under the hood, this becomes:class MySuspendLambda( completion: Continuation\u003cAny?\u003e) : ContinuationImpl(completion, EmptyCoroutineContext) { var label = 0 // current state var a: Any? = null // result of computeA() override fun invokeSuspend(result: Any?): Any? { when (label) { 0 -\u003e { label = 1 val resA = computeA(this) // suspension point #1 if (resA == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED a = resA } 1 -\u003e { val resB = computeB(a!!, this) // suspension point #2 if (resB == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED return \"Result: $resB\" } else -\u003e throw IllegalStateException(\"Invalid label $label\") } return COROUTINE_SUSPENDED }}Explanation:label = 0 is the initial state of the coroutine.When we call computeA(this), we pass the coroutine instance as a continuation.If the function suspends, it returns COROUTINE_SUSPENDED, and the coroutine pauses.Later, when resumed, invokeSuspend() is called again — this time with label = 1, so the execution continues from where it left off.Intermediate variables like a are stored in fields such as this.a to retain state across suspension.This pattern repeats for every suspension point in the coroutine logic.Summarysuspend — Marks a function that can suspend/resume executionContinuation — Represents what happens next after a suspension pointCOROUTINE_SUSPENDED — Special marker that tells the runtime to pause the coroutineinvokeSuspend — Holds compiled logic as a state machineBaseContinuationImpl — Calls invokeSuspend and resumes parent continuationsContinuationImpl — Adds debugging support, enables IDE stack tracesCoroutineImpl — Generated class that stores state and controls suspension via labelsCoroutines are not magic — they’re compiler-generated state machines backed by continuations.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*xEiBSFQo5_gue3CNYm2BvQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@shbazhenov?source=post_page---byline--fdfedfe88f44---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Shbazhenov\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*hiI_stOtJ4Av1nxkxrYAXg.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0d47\"\u003eKotlin coroutines are often praised for their elegance in handling asynchronous code. But during interviews, surface-level understanding won’t get you far. To answer like a \u003cstrong\u003etrue Kotlin Coroutine expert\u003c/strong\u003e, you need to understand what’s happening under the hood when a coroutine suspends.\u003c/p\u003e\u003cp id=\"6ad7\"\u003eThis article dives deep into the compiler-generated machinery of \u003ccode\u003esuspend\u003c/code\u003e functions: how they get compiled, what \u003ccode\u003eContinuation\u003c/code\u003e, \u003ccode\u003einvokeSuspend\u003c/code\u003e, and \u003ccode\u003eCoroutineImpl\u003c/code\u003e really are, and how suspension is actually implemented.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5b0c\"\u003eWhat Happens When You Write a Suspend Function?\u003c/h2\u003e\u003cp id=\"2529\"\u003eTake this simple example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bedc\"\u003esuspend fun functionA(param: Int): String {\u003cbr/\u003e    return \u0026#34;hello $param\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"16da\"\u003eWhen compiled, the Kotlin compiler transforms it to something like:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c404\"\u003epublic static final Object functionA(int param, Continuation\u0026lt;? super String\u0026gt; $completion) {\u003cbr/\u003e    return \u0026#34;hello \u0026#34; + param;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"35d2\"\u003eWhat changed?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0dc3\"\u003eAn \u003cstrong\u003eextra parameter\u003c/strong\u003e of type \u003ccode\u003eContinuation\u003c/code\u003e was added.\u003c/li\u003e\u003cli id=\"ae51\"\u003eThe \u003cstrong\u003ereturn type\u003c/strong\u003e changed from \u003ccode\u003eString\u003c/code\u003e to \u003ccode\u003eObject\u003c/code\u003e (or \u003ccode\u003eAny?\u003c/code\u003e in Kotlin), because:\u003c/li\u003e\u003cli id=\"8315\"\u003eIf the function completes synchronously, it returns the result (e.g., \u003ccode\u003e\u0026#34;hello 5\u0026#34;\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"9315\"\u003eIf it suspends, it returns a special marker: \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"99ec\"\u003eThis transformation enables the compiler to treat the function as a \u003cem\u003esuspendable computation\u003c/em\u003e, not just a regular method call.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1e93\"\u003eThe Low-Level Suspending Primitives\u003c/h2\u003e\u003cp id=\"adf4\"\u003eAny suspend function that truly suspends must eventually use one of the \u003cstrong\u003elow-level suspension primitives\u003c/strong\u003e. These primitives are the foundation of suspending functions like \u003ccode\u003edelay\u003c/code\u003e, \u003ccode\u003ewithContext\u003c/code\u003e, and others. They are also the key to \u003cstrong\u003ecreating your own suspend functions\u003c/strong\u003e or \u003cstrong\u003ewrapping callback-based APIs\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4633\"\u003esuspend fun something(): String = suspendCoroutine { continuation -\u0026gt;\u003cbr/\u003e    println(\u0026#34;Start async work\u0026#34;)\u003cbr/\u003e    someAsyncCallback { result -\u0026gt;\u003cbr/\u003e        continuation.resume(result) // triggers coroutine to resume\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"9816\"\u003eTypes of primitives:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"594e\"\u003e\u003ccode\u003esuspendCoroutine { ... }\u003c/code\u003e — Basic suspension with manual continuation control\u003c/li\u003e\u003cli id=\"4818\"\u003e\u003ccode\u003esuspendCancellableCoroutine { ... }\u003c/code\u003e — Same as above, but supports cancellation via \u003ccode\u003eJob\u003c/code\u003e\u003c/li\u003e\u003cli id=\"3f23\"\u003e\u003ccode\u003esuspendCoroutineUninterceptedOrReturn { ... }\u003c/code\u003e — Even lower-level primitive, bypasses interceptors (used in libraries)\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"f782\"\u003e\u003cem\u003eThese primitives are where the special marker \u003c/em\u003e\u003ccode\u003e\u003cem\u003eCOROUTINE_SUSPENDED\u003c/em\u003e\u003c/code\u003e\u003cem\u003e is produced internally. When any of them returns, it signals to the caller that the coroutine should pause.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"140d\"\u003eThe Coroutine Inheritance Chain\u003c/h2\u003e\u003cp id=\"c387\"\u003eEvery suspend function is backed by a compiler-generated class that extends from the following hierarchy:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8356\"\u003eCoroutineImpl → ContinuationImpl → BaseContinuationImpl → Continuation\u0026lt;T\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"94ee\"\u003e\u003ccode\u003eContinuation\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3039\"\u003eThis is the core interface that represents what should happen next after a coroutine is suspended:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"58f0\"\u003einterface Continuation\u0026lt;in T\u0026gt; {\u003cbr/\u003e    val context: CoroutineContext\u003cbr/\u003e    fun resumeWith(result: Result\u0026lt;T\u0026gt;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"3305\"\u003e\u003ccode\u003econtext\u003c/code\u003e: Contains job, dispatcher, and other coroutine-related info\u003c/li\u003e\u003cli id=\"0f71\"\u003e\u003ccode\u003eresumeWith\u003c/code\u003e: Called to resume the coroutine with a result or exception\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b72f\"\u003e\u003ccode\u003eBaseContinuationImpl\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"7cc7\"\u003eThis abstract class implements \u003ccode\u003eContinuation\u003c/code\u003e. It introduces:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2204\"\u003eabstract class BaseContinuationImpl(\u003cbr/\u003e    val completion: Continuation\u0026lt;Any?\u0026gt;?\u003cbr/\u003e) : Continuation\u0026lt;Any?\u0026gt; {\u003cp\u003e    abstract fun invokeSuspend(result: Any?): Any?\u003c/p\u003e\u003cp\u003e    override fun resumeWith(result: Result\u0026lt;Any?\u0026gt;) {\u003cbr/\u003e        var current = this\u003cbr/\u003e        var param = result.getOrThrow()\u003cbr/\u003e        while (true) {\u003cbr/\u003e            val outcome = current.invokeSuspend(param)\u003cbr/\u003e            if (outcome == COROUTINE_SUSPENDED) return\u003cbr/\u003e            val parent = current.completion\u003cbr/\u003e            if (parent is BaseContinuationImpl) {\u003cbr/\u003e                current = parent\u003cbr/\u003e                param = outcome\u003cbr/\u003e            } else {\u003cbr/\u003e                parent?.resumeWith(Result.success(outcome))\u003cbr/\u003e                return\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"efa9\"\u003eWhy do we need \u003ccode\u003einvokeSuspend()\u003c/code\u003e?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"bf09\"\u003eIt contains the coroutine’s \u003cstrong\u003ecompiled state machine logic\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"e2b1\"\u003eIt is \u003cstrong\u003eoverridden\u003c/strong\u003e by compiler-generated classes like \u003ccode\u003eCoroutineImpl\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"a994\"\u003eIt is \u003cstrong\u003einvoked inside\u003c/strong\u003e \u003ccode\u003eresumeWith()\u003c/code\u003e, which is the entry point for resuming suspended coroutines.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9afe\"\u003eWhat does \u003ccode\u003eresumeWith()\u003c/code\u003e do?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"fd6e\"\u003eIt \u003cstrong\u003eresumes the coroutine\u003c/strong\u003e from where it was suspended.\u003c/li\u003e\u003cli id=\"bbcf\"\u003eIf the result is \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, the coroutine pauses and exits the loop.\u003c/li\u003e\u003cli id=\"52b8\"\u003eIf the result is a real value, it is passed \u003cstrong\u003eup the continuation chain\u003c/strong\u003e to the parent coroutine.\u003c/li\u003e\u003cli id=\"e394\"\u003eThe loop continues \u003cstrong\u003euntil the top-level continuation\u003c/strong\u003e (usually the one launched by the user) has no more work to resume.\u003c/li\u003e\u003cli id=\"6cab\"\u003eWhen \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e is returned, it means the coroutine is paused and will be resumed later — typically via an external trigger like \u003ccode\u003econtinuation.resume(...)\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"54cd\"\u003e\u003ccode\u003eContinuationImpl\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"c0d5\"\u003eAdds debug info support:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fc44\"\u003eclass ContinuationImpl(...) : BaseContinuationImpl(...) {\u003cbr/\u003e    override fun getStackTraceElement(): StackTraceElement? { ... }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"09b4\"\u003eIt extends \u003ccode\u003eBaseContinuationImpl\u003c/code\u003e and implements \u003ccode\u003eCoroutineStackFrame\u003c/code\u003e to support debugging in IDEs like IntelliJ.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6b20\"\u003e\u003ccode\u003eCoroutineImpl\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3f77\"\u003eThis is the class generated by the compiler for a suspend function or lambda. It:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0a42\"\u003eExtends \u003ccode\u003eContinuationImpl\u003c/code\u003e\u003c/li\u003e\u003cli id=\"f55f\"\u003eOverrides \u003ccode\u003einvokeSuspend()\u003c/code\u003e using a \u003ccode\u003ewhen(label)\u003c/code\u003e-based state machine\u003c/li\u003e\u003cli id=\"15f2\"\u003eStores local variables across suspensions using internal fields (like \u003ccode\u003eL$0\u003c/code\u003e, \u003ccode\u003eL$1\u003c/code\u003e)\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"d1a1\"\u003eWhat are \u003ccode\u003eL$0\u003c/code\u003e, \u003ccode\u003eL$1\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"29fa\"\u003eThese are internal variables created by the compiler to \u003cstrong\u003estore the results of inner suspend functions\u003c/strong\u003e. They help the coroutine remember intermediate values when it gets suspended and resumes later.\u003c/p\u003e\u003ch2 id=\"0615\"\u003eWhat is \u003ccode\u003elabel\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"f69b\"\u003e\u003ccode\u003elabel\u003c/code\u003e is an integer field used to track the \u003cstrong\u003ecurrent state\u003c/strong\u003e of the coroutine. It is checked inside the \u003ccode\u003ewhen(label)\u003c/code\u003e statement to determine where to resume execution after suspension.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8790\"\u003eReal Example: Suspend Lambda Compiled\u003c/h2\u003e\u003cp id=\"3209\"\u003eLet’s look at this suspend lambda (which under the hood \u003cem\u003eis\u003c/em\u003e the compiler-generated \u003ccode\u003eCoroutineImpl\u003c/code\u003e class itself):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"403e\"\u003eval lambda = suspend {\u003cbr/\u003e    val a = computeA()\u003cbr/\u003e    val b = computeB(a)\u003cbr/\u003e    \u0026#34;Result: $b\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3682\"\u003eUnder the hood, this becomes:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2269\"\u003eclass MySuspendLambda(\u003cbr/\u003e    completion: Continuation\u0026lt;Any?\u0026gt;\u003cbr/\u003e) : ContinuationImpl(completion, EmptyCoroutineContext) {\u003cp\u003e    var label = 0                          // current state\u003cbr/\u003e    var a: Any? = null                     // result of computeA()\u003c/p\u003e\u003cp\u003e    override fun invokeSuspend(result: Any?): Any? {\u003cbr/\u003e        when (label) {\u003cbr/\u003e            0 -\u0026gt; {\u003cbr/\u003e                label = 1\u003cbr/\u003e                val resA = computeA(this)  // suspension point #1\u003cbr/\u003e                if (resA == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED\u003cbr/\u003e                a = resA\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            1 -\u0026gt; {\u003cbr/\u003e                val resB = computeB(a!!, this) // suspension point #2\u003cbr/\u003e                if (resB == COROUTINE_SUSPENDED) return COROUTINE_SUSPENDED\u003cbr/\u003e                return \u0026#34;Result: $resB\u0026#34;\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            else -\u0026gt; throw IllegalStateException(\u0026#34;Invalid label $label\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        return COROUTINE_SUSPENDED\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4c29\"\u003eExplanation:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0ce4\"\u003e\u003ccode\u003elabel = 0\u003c/code\u003e is the initial state of the coroutine.\u003c/li\u003e\u003cli id=\"c015\"\u003eWhen we call \u003ccode\u003ecomputeA(this)\u003c/code\u003e, we pass the coroutine instance as a continuation.\u003c/li\u003e\u003cli id=\"1d84\"\u003eIf the function suspends, it returns \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, and the coroutine pauses.\u003c/li\u003e\u003cli id=\"2940\"\u003eLater, when resumed, \u003ccode\u003einvokeSuspend()\u003c/code\u003e is called again — this time with \u003ccode\u003elabel = 1\u003c/code\u003e, so the execution continues from where it left off.\u003c/li\u003e\u003cli id=\"cafe\"\u003eIntermediate variables like \u003ccode\u003ea\u003c/code\u003e are stored in fields such as \u003ccode\u003ethis.a\u003c/code\u003e to retain state across suspension.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b4c5\"\u003eThis pattern repeats for every suspension point in the coroutine logic.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"dc01\"\u003eSummary\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6ed9\"\u003e\u003cstrong\u003esuspend\u003c/strong\u003e — Marks a function that can suspend/resume execution\u003c/li\u003e\u003cli id=\"233e\"\u003e\u003cstrong\u003eContinuation\u003c/strong\u003e — Represents what happens next after a suspension point\u003c/li\u003e\u003cli id=\"08ce\"\u003e\u003cstrong\u003eCOROUTINE_SUSPENDED\u003c/strong\u003e — Special marker that tells the runtime to pause the coroutine\u003c/li\u003e\u003cli id=\"eb2d\"\u003e\u003cstrong\u003einvokeSuspend\u003c/strong\u003e — Holds compiled logic as a state machine\u003c/li\u003e\u003cli id=\"f7ec\"\u003e\u003cstrong\u003eBaseContinuationImpl\u003c/strong\u003e — Calls \u003ccode\u003einvokeSuspend\u003c/code\u003e and resumes parent continuations\u003c/li\u003e\u003cli id=\"07aa\"\u003e\u003cstrong\u003eContinuationImpl\u003c/strong\u003e — Adds debugging support, enables IDE stack traces\u003c/li\u003e\u003cli id=\"6e6f\"\u003e\u003cstrong\u003eCoroutineImpl\u003c/strong\u003e — Generated class that stores state and controls suspension via labels\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cblockquote\u003e\u003cp id=\"b9ae\"\u003e\u003cstrong\u003e\u003cem\u003eCoroutines are not magic — they’re compiler-generated state machines backed by continuations.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-03-21T19:47:59.565Z",
  "modifiedTime": null
}
