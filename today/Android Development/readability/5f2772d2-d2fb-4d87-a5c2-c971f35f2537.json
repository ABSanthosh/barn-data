{
  "id": "5f2772d2-d2fb-4d87-a5c2-c971f35f2537",
  "title": "Null Safety",
  "link": "https://blog.kotlin-academy.com/null-safety-bb20b0cbf1a4?source=rss----e57b304801ef---4",
  "description": "",
  "author": "≈Åukasz Piƒôta",
  "published": "Tue, 06 Aug 2024 05:40:17 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "clean-code",
    "software-engineering",
    "kotlin",
    "null-safety",
    "java"
  ],
  "byline": "≈Åukasz Piƒôta",
  "length": 19065,
  "excerpt": "Kotlin's null safety sets it apart from Java. Compile-time guarantees enhance reliability and reduce errors, making it a top choice for modern programming.",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "The reason why Java will never catch up to KotlinThere are multiple reasons to choose Kotlin over Java as your programming language. Of course, as with many technical decisions, ‚Äúit depends‚Äù, doesn‚Äôt it? Moreover, everyone has their own opinion, and it wouldn‚Äôt be a surprise if you don‚Äôt share mine.However, if you asked me ‚Äî Kotlin is better than Java üòÅ. Even though the latest Java releases are truly promising, it still lags significantly behind Kotlin. Perhaps one of the most significant and challenging gaps to bridge is the structured null safety Kotlin guarantees at compile time. Is that really such a big deal? ‚Äî you might ask, let‚Äôs figure out!Null Safety Through the Eyes of AIWhat is ‚ÄúNull Safety‚Äù in general? Below, you can see an image generated by OpenAI‚Äôs DALL¬∑E model, which was asked to embody ‚ÄúKotlin null safety.‚Äù‚ÄúKotlin null safety‚Äù image created using OpenAI‚Äôs DALL¬∑E.In the center of the image, we can see a cosmic portal, which might be interpreted as a gateway of knowledge. The whole scenery looks very scientific and futuristic. Many mathematical symbols surround the portal, creating the impression of floating energy accumulating there. Beneath the portal, there is a circular platform with an amphitheater-like structure, encircled by towering pillar-like buildings that hint at an advanced civilization.Based on the above image, we can imagine what Kotlin null safety is. It can be thought of as a protective gateway that prevents NPEs (Null Pointer Exceptions). The well-organized structures surrounding the platform on which the portal is placed suggest the structured approach Kotlin uses to handle nullability in a systematic and safe manner.However, I don‚Äôt want to convince you to use Kotlin just because of an image generated by AI. That would be absurd! Assuming that Java is our reference point, let‚Äôs take a look at its approach to null safety (is there even such an approach in Java? Just kidding‚Ä¶ but am I? üòÇ). But to get there, let‚Äôs take a step back and answer the question: is ‚Äúnull‚Äù (to be precise: Null Reference) such a big problem at all?‚ÄúThe billion dollar mistake‚ÄùIt all started back in 1965, when Tony Hoare invented the null reference as part of the ALGOL W language. The problem he intended to solve with his invention was to indicate the absence of an object in a simple and memory-efficient fashion. There was no standardized way to do it yet, and any additional data structures or special cases for the absence of value were not optimal in terms of efficiency in the resource-constrained environments of early computing.And after over four decades he states:I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn‚Äôt resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.But wait, is really ‚Äúnull‚Äù such a big deal? Why does it cause so much pain and damage if we can simply perform a null check before we use a variable?if(sth != null) { ... }Some says it‚Äôs ugly, but it doesn‚Äôt bother me. The problem is not the code itself, but the concept in general. There are multiple issues caused by null pointers:Proliferation of null checks ‚Äî You can‚Äôt simply trust that what you operate on is a non-null value. Of course, you can work out with your team some architectural design which helps to keep all the null checks in one of the top layers, so you don‚Äôt need to bother in the inner layers about them. But it‚Äôs still hidden, not presented straight forward to the developer through the type system.Error-prone ‚Äî Forgetting a null check (especially when refactoring) can lead to NPEs, which are difficult to trace and often cause application crashes.Default and Unexpected States ‚Äî Using null to represent the absence of a value can be ambiguous. It‚Äôs not clear if it‚Äôs an uninitialized variable, an absent value, or an error condition.Encapsulation Violations ‚Äî Properly encapsulated objects should manage their own state, but it‚Äôs the client using the object who is responsible for performing null checks.Impact on Functional Programming ‚Äî In languages supporting functional programming paradigms, nulls can complicate the use of functions and higher-order functions. Handling nulls can break the chain of function calls and make composition difficult.How to minimize the risk of NPEs in Java?Assuming you don‚Äôt have a null safety feature in the language you use, how can you minimize the risk of NPEs? Here are several rules to follow that can help you do that:Consider using empty collection instead of nullIn many business cases, null is identical to an empty list or an array, so when it makes no difference from a business perspective, it can be simply replaced. However, keep in mind that it‚Äôs not always the same thing. For example, filtering by request parameters is fundamentally different when you don‚Äôt want to filter by a parameter versus when your filtering parameter is an empty list.Use null-safe object wrappersHandling an Object null-case scenario might be much harder than replacing null with an empty list when dealing with collections, especially if there is no nullable type in the type system of your programming language. However, there are some ways to minimize the risk of NPEs, even without built-in null safety in your programming language.Null Object Pattern: An approach where there is a ‚Äúnull implementation‚Äù of an object.// Example of Null Object Pattern Implementationpublic class Product { private int productId; private String productName; private double price; public String getProductName() { // ... } public void setProductName(String productName) { // ... } public double getPrice() { // ... } public void setPrice(double price) { // ... }}public class EmptyProduct extends Product { public int getProductId() { return -1; } public String getProductName() { return \"\"; } public double getPrice() { return 0.0; }}public Product getProductEntry() { Product result = db.getProduct(); if(result == null) { return new EmptyProduct(); } else { return result; }}Optional wrapper (Java implementation): Probably the most common approach, where we have a wrapper on a generic type with access to a rich API with many useful functions.// Example of Optional wrapper usagepublic Optional\u003cProduct\u003e getProductEntry() { return Optional.ofNullable(db.getProduct());}Optional\u003cProduct\u003e optionalProduct = getProductEntry();if (optionalProduct.isPresent()) { Product product = optionalProduct.get(); // Handle the product} else { // Handle the case when product is not found}And this is actually what people refer to as ‚Äúnull safety in Java‚Äù ‚Äî as you can see below, there is no such thing at all:// This will compileOptional\u003cProduct\u003e optionalProduct = null;// This will throw NPEoptionalProduct.isPresent();Don‚Äôt trust people who say there is null safety in Java! As you can see, there is not.Use @Nullable annotationHowever, there is one more tool that can help you avoid NPEs in Java: the @Nullable annotation. It can be used to mark a method parameter, return value, or field as potentially null. Although it doesn't guarantee null safety at compile time, it relies on external tools (like IDEs or static analysis tools) to catch potential nullability issues.To sum up, yes, you can minimize the risk of NPEs in Java, but your hands are tied, and there is no other way than maintaining strict discipline within the team and using workarounds such as Optional\u003cT\u003e and the null object pattern, which add complexity to your code. This still doesn‚Äôt guarantee that your system is safe enough, and there won‚Äôt be some NPEs propagated to the heart of your application, where you expect it to be the least likely to occur.‚ÄúJava‚Äôs lack of inherent null safety‚Äù image created using OpenAI‚Äôs DALL¬∑E.Java has many flaws, but the lack of null safety is, in my opinion, the biggest one and probably the hardest to address due to the need for backward compatibility in upcoming releases. That‚Äôs why Kotlin did it much better. Since it‚Äôs very young, it was able to learn from Java‚Äôs (and other languages‚Äô) mistakes, making it such a terrific programming language.Kotlin Null SafetyNullable TypesFirst of all, Kotlin‚Äôs type system consists of nullable and non-nullable types. Basically, a nullable type can be easily created from a non-nullable type by adding a question mark to the end of the type name, e.g., the nullable type of String is String?. When it comes to inheritance, a non-nullable type is always a subtype of a nullable one.var nonNullableString: String = \"Some value\"var nullableString: String? = \"Some other value\"nullableString = nonNullableString // it compilesnullableString = null // it compilesnonNullableString = nullableString // it doesn't compilenonNullableString = null // it doesn't compileAs seen above, we can‚Äôt assign a null value to a non-nullable type, because it results in a compilation error. This is, in my opinion, the biggest advantage of Kotlin‚Äôs approach to null safety ‚Äî compilation-time assurance of null-safe correctness.While Optional\u003cT\u003e gives a very rich API with plenty of methods, Kotlin‚Äôs null-safety is extremely simple and minimalistic. Therefore it‚Äôs much easier to use in day-to-day work, because it simply does not put any boilerplate code and does not disrupt understanding of the business logic in the actual code.Safe call operatorOne of the key tools that Kotlin implements for null safety is the safe call operator ?., which let us call a property or a method of nullable variable in a safe way. This means that the program will proceed to the right side of the safe call operator only if the left side is not null; otherwise, a null value will be propagated through the call without throwing any exception. This behavior is intentional, as it allows nullable types to handle cases with null values gracefully.data class Product( val productId: Int, val productName: String?, val price: Double)fun productNameToUpperCase(product: Product): String? { return product.productName?.toUpperCase() } Elvis OperatorAnother inherent element of Kotlin‚Äôs null safety is the Elvis operator ?:, which allows you to provide a default value if an expression evaluates to null.fun productNameToUpperCase(product: Product): String { return product.productName?.toUpperCase() ?: \"Name unknown\"}The Elvis operator can also be used if you want to throw an exception when a value is null.fun productNameToUpperCase(product: Product): String { return product.productName?.toUpperCase() ?: throw IllegalStateException()}Non-null assertionThe non-null assertion !! also seems very tempting, but it should be used very cautiously because if you apply it in a place where a null value occurs, a NPE will be thrown immediately. A better strategy is to use your own custom exceptions for easier troubleshooting and debugging.fun productNameToUpperCase(product: Product): String { return product.productName?.toUpperCase()!!}My personal advice is to avoid using the non-null assertion, as it reintroduces the risk of unexpected NPEs. The most suitable place for !! is probably in a test package, where there might be a need to force the compiler to ignore the nullability of some already initialized properties.Safe cast operatorOn the other hand, the safe cast operator as? can be very useful for soft casting and prevents unexpected exceptions from occurring when casting types.data class Product( val productId: Int, val productName: String?, val price: Double)data class DiscountedProduct( val productId: Int, val productName: String?, val price: Double, val discountPercentage: Double) : Product(productId, productName, price)fun processProduct(product: Product) { val discountedProduct = product as? DiscountedProduct discountedProduct?.let { // Handle discounted product } ?: run { // Handle regular product }}Late-Initialized PropertiesAnother cool feature in Kotlin, which might be useful when dealing with null safety, is the lateinit keyword for late-initialized properties. It can be used for properties that will be initialized after the object is created, but we don't want them to be nullable.class ProductManager { private lateinit var product: Product fun initializeProduct() { product = Product(1, \"Sample Product\", 19.99) } fun printProductName() { if (::product.isInitialized) { println(product.productName) } else { println(\"Product is not initialized\") } }}All these features are just tools, so they can be used either in a good or a wrong manner. You might not use them all at once, but feel free to mix them according to your needs. In the end, let me share some tips from my experience as a Kotlin Developer.As Nullable as Necessary, but No MoreHaving nullable and non-nullable types creates a very flexible environment to design either a perfect API or a poor one. In general, Kotlin developers can be divided into two groups: 1. those who insist on making nothing nullable at all (because no one should accept a nullable type in business logic!), and 2. those who make everything nullable by default (because it‚Äôs much easier when starting to write code). The bad news is that both approaches are fundamentally wrong. There is a very good reason for both types ‚Äî nullable and non-nullable ‚Äî to exist, and each should be used in different cases.Here are my rules of thumb:Make sure you don‚Äôt lose business value due to too many properties being nullable‚Äî maybe your aggregate should be divided into smaller ones if so many things can be empty (null) at the same time?Returning a null value from a function responsible for looking for some data is not a bad idea ‚Äî it‚Äôs much better to expect null value and handle it properly than to perform a try-catch on a method that is going to throw a NoSuchElementException.Don‚Äôt hinder yourself in debugging by creating nested nullable data types ‚Äî it‚Äôs sometimes very hard to figure out what actually was null in such a navigation chain: person?.account?.address?.city.Talk like a Kotlin nativeNotice the Kotlin naming conventions. Take a look at the following commonly used functions from the Kotlin standard library:package kotlin.collectionspublic interface List\u003cout E\u003e : Collection\u003cE\u003e { public operator fun get(index: Int): E //...}public fun \u003cT\u003e List\u003cT\u003e.getOrNull(index: Int): T?As you can see, it‚Äôs a good practice to name your function in such way which already suggests what type (nullable or not) should be expected. Even though we can check the return type, having it clarified in the function name makes the code more readable. However, while it appears to be for readability‚Äôs sake, it actually stems from a compiler limitation: we can‚Äôt have more than one function with the same signature.data class Person(private val id: String)fun findBy(id: String): Person { return Person(id)}fun findBy(id: String): Person? { return null}The code above causes following compilation error:Conflicting overloads: public fun findBy(id: String): Person defined in root package in file Foo.kt, public fun findBy(id: String): Person? defined in root package in file Foo.ktFinally, if you wonder what the Kotlin coding conventions are, either take inspiration from the Kotlin standard library or any other Kotlin library commonly used among Kotlin developers, or take a look at the official Kotlin documentation, where you can find the document with coding conventions.Never trust Java clients!One of the most frequently crashing parts of a Kotlin application, in my experience, is when you integrate with a Java client (e.g., Hibernate, which seems to frustrate many people, although it‚Äôs really not that bad ‚Äî check out my article about it).Consider the following Java code:// File: JavaClass.javapublic class JavaClass { public String getNullableString() { return null; }}When we try to invoke it in Kotlin, we will end up with the type String!, which should catch your attention, because the type is signalling that something might be wrong. Types of Java declarations are called platform types, and they are treated in a specific way in Kotlin.val foo: String? = JavaClass().nullableString // allowedprintln(foo?.length) // This works fineval bar: String = JavaClass().nullableString // allowedprintln(bar.length) // This throws NPEAs you can see, when integrating with a Java library, we need to consider null cases that might occur in Java code due to the lack of null safety. When it comes to handling platform types, you always have two options:Use a nullable type and handle the null case yourself.Use a non-nullable type and expect an assertion upon assignment, so an NPE will be thrown if the Java client returns a null value.Notice that if a Java client used @Nullable annotation compatible with your IDE , you would see String? instead of String!.import org.jetbrains.annotations.Nullable;// File: main.JavaClass.javapublic class JavaClass { @Nullable public String getNullableString() { return null; }}Still not convinced to switch from Java to Kotlin?Even if you were on the Java side in this conflict between Java and Kotlin at the beginning of my article, I hope you‚Äôve started thinking about Kotlin in a much more positive way. If null safety hasn‚Äôt convinced you enough and you‚Äôre curious about Kotlin‚Äôs capabilities, stay tuned, because I‚Äôm going to publish more Kotlin content in the near future.However, there is one more thing I‚Äôd like to mention regarding the choice between Java and Kotlin. Respected companies have proven through their experiences that, in general, switching from Java to Kotlin:Increases productivity: 70% of developers whose primary language is Kotlin say that Kotlin makes them more productive.Produces satisfaction among programmers who participated in the transition: 87% of Google server-side Kotlin developers are ‚Äúvery satisfied‚Äù with Kotlin.Makes your applications more stable: Google observed a 20% lower likelihood of Android applications crashing.Doesn‚Äôt result in any productivity degradation if some parts of the system are left in good old Java (Google observation).Link to the source of statistics: Google‚Äôs Journey from Java to Kotlin for Server Side Programming, Devoxx.Thanks for reading my article. I hope you enjoyed it! If you have any thoughts on it, please let me know; I‚Äôm happy to discuss it further.I‚Äôd like to thank Adrian Glapi≈Ñski and Pawe≈Ç Derezi≈Ñski for being very helpful in reviewing my article. I appreciate it a lot!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1024/0*wUMzn-K3NpRPRMK6",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"4cc0\"\u003eThe reason why Java will never catch up to Kotlin\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@pientaa?source=post_page-----bb20b0cbf1a4--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"≈Åukasz Piƒôta\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*IZ1xg2L-pCuPmxRQftzhCQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://blog.kotlin-academy.com/?source=post_page-----bb20b0cbf1a4--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Kt. Academy\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*2grDGjzH0tfX8XiaF4Izaw.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"998f\"\u003eThere are multiple reasons to choose Kotlin over Java as your programming language. Of course, as with many technical decisions, ‚Äúit depends‚Äù, doesn‚Äôt it? Moreover, everyone has their own opinion, and it wouldn‚Äôt be a surprise if you don‚Äôt share mine.\u003c/p\u003e\u003cp id=\"7626\"\u003eHowever, if you asked me ‚Äî Kotlin is better than Java üòÅ. Even though the latest Java releases are truly promising, it still lags significantly behind Kotlin. Perhaps one of the most significant and challenging gaps to bridge is the structured null safety Kotlin guarantees at compile time. Is that really such a big deal? ‚Äî you might ask, let‚Äôs figure out!\u003c/p\u003e\u003ch2 id=\"d4d2\"\u003eNull Safety Through the Eyes of AI\u003c/h2\u003e\u003cp id=\"408c\"\u003eWhat is ‚ÄúNull Safety‚Äù in general? Below, you can see an image generated by OpenAI‚Äôs DALL¬∑E model, which was asked to embody ‚ÄúKotlin null safety.‚Äù\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e‚ÄúKotlin null safety‚Äù image created using OpenAI‚Äôs DALL¬∑E.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a67d\"\u003eIn the center of the image, we can see a cosmic portal, which might be interpreted as a gateway of knowledge. The whole scenery looks very scientific and futuristic. Many mathematical symbols surround the portal, creating the impression of floating energy accumulating there. Beneath the portal, there is a circular platform with an amphitheater-like structure, encircled by towering pillar-like buildings that hint at an advanced civilization.\u003c/p\u003e\u003cp id=\"fe0e\"\u003eBased on the above image, we can imagine what Kotlin null safety is. It can be thought of as a protective gateway that prevents NPEs (Null Pointer Exceptions). The well-organized structures surrounding the platform on which the portal is placed suggest the structured approach Kotlin uses to handle nullability in a systematic and safe manner.\u003c/p\u003e\u003cp id=\"e487\"\u003eHowever, I don‚Äôt want to convince you to use Kotlin just because of an image generated by AI. That would be absurd! Assuming that Java is our reference point, let‚Äôs take a look at its approach to null safety (is there even such an approach in Java? Just kidding‚Ä¶ but am I? üòÇ). But to get there, let‚Äôs take a step back and answer the question: is ‚Äúnull‚Äù (to be precise: \u003ca href=\"https://en.wikipedia.org/wiki/Null_pointer\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNull Reference\u003c/a\u003e) such a big problem at all?\u003c/p\u003e\u003ch2 id=\"0954\"\u003e‚ÄúThe billion dollar mistake‚Äù\u003c/h2\u003e\u003cp id=\"9615\"\u003eIt all started back in 1965, when \u003ca href=\"https://en.wikipedia.org/wiki/Tony_Hoare\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTony Hoare\u003c/a\u003e invented the null reference as part of the \u003ca href=\"https://en.wikipedia.org/wiki/ALGOL_W\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eALGOL W\u003c/a\u003e language. The problem he intended to solve with his invention was to indicate the absence of an object in a simple and memory-efficient fashion. There was no standardized way to do it yet, and any additional data structures or special cases for the absence of value were not optimal in terms of efficiency in the resource-constrained environments of early computing.\u003c/p\u003e\u003cp id=\"88eb\"\u003eAnd after over four decades \u003ca href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehe states\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"a766\"\u003eI call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn‚Äôt resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8e90\"\u003eBut wait, is really ‚Äúnull‚Äù such a big deal? Why does it cause so much pain and damage if we can simply perform a null check before we use a variable?\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0a82\"\u003eif(sth != null) { ... }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c82d\"\u003eSome says it‚Äôs ugly, but it doesn‚Äôt bother me. The problem is not the code itself, but the concept in general. There are multiple issues caused by null pointers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"e980\"\u003e\u003cstrong\u003eProliferation of null checks \u003c/strong\u003e‚Äî You can‚Äôt simply trust that what you operate on is a non-null value. Of course, you can work out with your team some architectural design which helps to keep all the null checks in one of the top layers, so you don‚Äôt need to bother in the inner layers about them. But it‚Äôs still hidden, not presented straight forward to the developer through the type system.\u003c/li\u003e\u003cli id=\"5ead\"\u003e\u003cstrong\u003eError-prone \u003c/strong\u003e‚Äî Forgetting a null check (especially when refactoring) can lead to NPEs, which are difficult to trace and often cause application crashes.\u003c/li\u003e\u003cli id=\"276f\"\u003e\u003cstrong\u003eDefault and Unexpected States \u003c/strong\u003e‚Äî Using null to represent the absence of a value can be ambiguous. It‚Äôs not clear if it‚Äôs an uninitialized variable, an absent value, or an error condition.\u003c/li\u003e\u003cli id=\"f96f\"\u003e\u003cstrong\u003eEncapsulation Violations \u003c/strong\u003e‚Äî Properly encapsulated objects should manage their own state, but it‚Äôs the client using the object who is responsible for performing null checks.\u003c/li\u003e\u003cli id=\"dd81\"\u003e\u003cstrong\u003eImpact on Functional Programming \u003c/strong\u003e‚Äî In languages supporting functional programming paradigms, nulls can complicate the use of functions and higher-order functions. Handling nulls can break the chain of function calls and make composition difficult.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a940\"\u003eHow to minimize the risk of NPEs in Java?\u003c/h2\u003e\u003cp id=\"73a9\"\u003eAssuming you don‚Äôt have a null safety feature in the language you use, how can you minimize the risk of NPEs? Here are several rules to follow that can help you do that:\u003c/p\u003e\u003ch2 id=\"7039\"\u003e\u003cstrong\u003eConsider using empty collection instead of null\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"d620\"\u003eIn many business cases, null is identical to an empty list or an array, so when it makes no difference from a business perspective, it can be simply replaced. However, keep in mind that it‚Äôs not always the same thing. For example, filtering by request parameters is fundamentally different when you don‚Äôt want to filter by a parameter versus when your filtering parameter is an empty list.\u003c/p\u003e\u003ch2 id=\"5a58\"\u003eUse null-safe object wrappers\u003c/h2\u003e\u003cp id=\"73e5\"\u003eHandling an \u003ccode\u003eObject\u003c/code\u003e null-case scenario might be much harder than replacing null with an empty list when dealing with collections, especially if there is no nullable type in the type system of your programming language. However, there are some ways to minimize the risk of NPEs, even without built-in null safety in your programming language.\u003c/p\u003e\u003cul\u003e\u003cli id=\"078e\"\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Null_object_pattern\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNull Object Pattern\u003c/a\u003e: An approach where there is a ‚Äúnull implementation‚Äù of an object.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"d9b5\"\u003e// Example of Null Object Pattern Implementation\u003cbr/\u003epublic class Product {\u003cbr/\u003e    private int productId;\u003cbr/\u003e    private String productName;\u003cbr/\u003e    private double price;\u003cp\u003e    public String getProductName() {\u003cbr/\u003e       // ...\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        public void setProductName(String productName) {\u003cbr/\u003e       // ...\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        public double getPrice() {\u003cbr/\u003e       // ...\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        public void setPrice(double price) {\u003cbr/\u003e       // ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003epublic class EmptyProduct extends Product {\u003c/p\u003e\u003cp\u003e    public int getProductId() {\u003cbr/\u003e       return -1;\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    public String getProductName() {\u003cbr/\u003e       return \u0026#34;\u0026#34;;\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e        public double getPrice() {\u003cbr/\u003e       return 0.0;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003epublic Product getProductEntry() {\u003cbr/\u003e   Product result = db.getProduct();\u003cbr/\u003e   if(result == null) {\u003cbr/\u003e       return new EmptyProduct();\u003cbr/\u003e   } else {\u003cbr/\u003e       return result;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"c3ee\"\u003eOptional wrapper (\u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJava implementation\u003c/a\u003e): Probably the most common approach, where we have a wrapper on a generic type with access to a rich API with many useful functions.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"9641\"\u003e// Example of Optional wrapper usage\u003cbr/\u003epublic Optional\u0026lt;Product\u0026gt; getProductEntry() {\u003cbr/\u003e    return Optional.ofNullable(db.getProduct());\u003cbr/\u003e}\u003cp\u003eOptional\u0026lt;Product\u0026gt; optionalProduct = getProductEntry();\u003c/p\u003e\u003cp\u003eif (optionalProduct.isPresent()) {\u003cbr/\u003e    Product product = optionalProduct.get();\u003cbr/\u003e    // Handle the product\u003cbr/\u003e} else {\u003cbr/\u003e    // Handle the case when product is not found\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fbf5\"\u003eAnd this is actually what people refer to as ‚Äúnull safety in Java‚Äù ‚Äî as you can see below, there is no such thing at all:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4010\"\u003e// This will compile\u003cbr/\u003eOptional\u0026lt;Product\u0026gt; optionalProduct = null;\u003cp\u003e// This will throw NPE\u003cbr/\u003eoptionalProduct.isPresent();\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6411\"\u003eDon‚Äôt trust people who say there is null safety in Java! As you can see, there is not.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1744\"\u003eUse @Nullable annotation\u003c/h2\u003e\u003cp id=\"5499\"\u003eHowever, there is one more tool that can help you avoid NPEs in Java: the \u003ccode\u003e@Nullable\u003c/code\u003e annotation. It can be used to mark a method parameter, return value, or field as potentially null. Although it doesn\u0026#39;t guarantee null safety at compile time, it relies on external tools (like IDEs or static analysis tools) to catch potential nullability issues.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"3dd6\"\u003eTo sum up, yes, you can minimize the risk of NPEs in Java, but your hands are tied, and there is no other way than maintaining strict discipline within the team and using workarounds such as \u003ccode\u003eOptional\u0026lt;T\u0026gt;\u003c/code\u003e and the null object pattern, which add complexity to your code. This still doesn‚Äôt guarantee that your system is safe enough, and there won‚Äôt be some NPEs propagated to the heart of your application, where you expect it to be the least likely to occur.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e‚ÄúJava‚Äôs lack of inherent null safety‚Äù image created using OpenAI‚Äôs DALL¬∑E.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"bcfd\"\u003eJava has many flaws, but the lack of null safety is, in my opinion, the biggest one and probably the hardest to address due to the need for backward compatibility in upcoming releases. That‚Äôs why Kotlin did it much better. Since it‚Äôs very young, it was able to learn from Java‚Äôs (and other languages‚Äô) mistakes, making it such a terrific programming language.\u003c/p\u003e\u003ch2 id=\"bca8\"\u003eKotlin Null Safety\u003c/h2\u003e\u003ch2 id=\"2b4b\"\u003eNullable Types\u003c/h2\u003e\u003cp id=\"168f\"\u003eFirst of all, Kotlin‚Äôs type system consists of nullable and non-nullable types. Basically, a nullable type can be easily created from a non-nullable type by adding a question mark to the end of the type name, e.g., the nullable type of \u003ccode\u003eString\u003c/code\u003e is \u003ccode\u003eString?\u003c/code\u003e. When it comes to inheritance, a non-nullable type is always a subtype of a nullable one.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"00fd\"\u003evar nonNullableString: String = \u0026#34;Some value\u0026#34;\u003cbr/\u003evar nullableString: String? = \u0026#34;Some other value\u0026#34;\u003cp\u003enullableString = nonNullableString // it compiles\u003cbr/\u003enullableString = null // it compiles\u003c/p\u003e\u003cp\u003enonNullableString = nullableString // it doesn\u0026#39;t compile\u003cbr/\u003enonNullableString = null // it doesn\u0026#39;t compile\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5d0a\"\u003eAs seen above, we can‚Äôt assign a null value to a non-nullable type, because it results in a compilation error. This is, in my opinion, the biggest advantage of Kotlin‚Äôs approach to null safety ‚Äî compilation-time assurance of null-safe correctness.\u003c/p\u003e\u003cp id=\"de21\"\u003eWhile \u003ccode\u003eOptional\u0026lt;T\u0026gt;\u003c/code\u003e gives a very rich API with plenty of methods, Kotlin‚Äôs null-safety is extremely simple and minimalistic. Therefore it‚Äôs much easier to use in day-to-day work, because it simply does not put any boilerplate code and does not disrupt understanding of the business logic in the actual code.\u003c/p\u003e\u003ch2 id=\"d282\"\u003eSafe call operator\u003c/h2\u003e\u003cp id=\"86a2\"\u003eOne of the key tools that Kotlin implements for null safety is the safe call operator \u003ccode\u003e?.\u003c/code\u003e, which let us call a property or a method of nullable variable in a safe way. This means that the program will proceed to the right side of the safe call operator only if the left side is not null; otherwise, a null value will be propagated through the call without throwing any exception. This behavior is intentional, as it allows nullable types to handle cases with null values gracefully.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9b5c\"\u003edata class Product(\u003cbr/\u003e    val productId: Int,\u003cbr/\u003e    val productName: String?,\u003cbr/\u003e    val price: Double\u003cbr/\u003e)\u003cp\u003efun productNameToUpperCase(product: Product): String? {\u003cbr/\u003e    return product.productName?.toUpperCase() \u003cbr/\u003e} \u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"44bd\"\u003eElvis Operator\u003c/h2\u003e\u003cp id=\"7032\"\u003eAnother inherent element of Kotlin‚Äôs null safety is the Elvis operator \u003ccode\u003e?:\u003c/code\u003e, which allows you to provide a default value if an expression evaluates to null.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b41d\"\u003efun productNameToUpperCase(product: Product): String {\u003cbr/\u003e    return product.productName?.toUpperCase() ?: \u0026#34;Name unknown\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"083e\"\u003eThe Elvis operator can also be used if you want to throw an exception when a value is null.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a73\"\u003efun productNameToUpperCase(product: Product): String {\u003cbr/\u003e    return product.productName?.toUpperCase() ?: throw IllegalStateException()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d63f\"\u003eNon-null assertion\u003c/h2\u003e\u003cp id=\"55e6\"\u003eThe non-null assertion \u003ccode\u003e!!\u003c/code\u003e also seems very tempting, but it should be used very cautiously because if you apply it in a place where a null value occurs, a NPE will be thrown immediately. A better strategy is to use your own custom exceptions for easier troubleshooting and debugging.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4de0\"\u003efun productNameToUpperCase(product: Product): String {\u003cbr/\u003e    return product.productName?.toUpperCase()!!\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cac3\"\u003eMy personal advice is to avoid using the non-null assertion, as it reintroduces the risk of unexpected NPEs. The most suitable place for \u003ccode\u003e!!\u003c/code\u003e is probably in a test package, where there might be a need to force the compiler to ignore the nullability of some already initialized properties.\u003c/p\u003e\u003ch2 id=\"74d5\"\u003eSafe cast operator\u003c/h2\u003e\u003cp id=\"4625\"\u003eOn the other hand, the safe cast operator \u003ccode\u003eas?\u003c/code\u003e can be very useful for soft casting and prevents unexpected exceptions from occurring when casting types.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"908c\"\u003edata class Product(\u003cbr/\u003e    val productId: Int,\u003cbr/\u003e    val productName: String?,\u003cbr/\u003e    val price: Double\u003cbr/\u003e)\u003cp\u003edata class DiscountedProduct(\u003cbr/\u003e    val productId: Int,\u003cbr/\u003e    val productName: String?,\u003cbr/\u003e    val price: Double,\u003cbr/\u003e    val discountPercentage: Double\u003cbr/\u003e) : Product(productId, productName, price)\u003c/p\u003e\u003cp\u003efun processProduct(product: Product) {\u003cbr/\u003e    val discountedProduct = product as? DiscountedProduct\u003cbr/\u003e    discountedProduct?.let {\u003cbr/\u003e        // Handle discounted product\u003cbr/\u003e    } ?: run {\u003cbr/\u003e        // Handle regular product\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"59a5\"\u003eLate-Initialized Properties\u003c/h2\u003e\u003cp id=\"8542\"\u003eAnother cool feature in Kotlin, which might be useful when dealing with null safety, is the \u003ccode\u003elateinit\u003c/code\u003e keyword for late-initialized properties. It can be used for properties that will be initialized after the object is created, but we don\u0026#39;t want them to be nullable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d536\"\u003eclass ProductManager {\u003cbr/\u003e    private lateinit var product: Product\u003cp\u003e    fun initializeProduct() {\u003cbr/\u003e        product = Product(1, \u0026#34;Sample Product\u0026#34;, 19.99)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun printProductName() {\u003cbr/\u003e        if (::product.isInitialized) {\u003cbr/\u003e            println(product.productName)\u003cbr/\u003e        } else {\u003cbr/\u003e            println(\u0026#34;Product is not initialized\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"5d5e\"\u003eAll these features are just tools, so they can be used either in a good or a wrong manner. You might not use them all at once, but feel free to mix them according to your needs. In the end, let me share some tips from my experience as a Kotlin Developer.\u003c/p\u003e\u003ch2 id=\"938c\"\u003eAs Nullable as Necessary, but No More\u003c/h2\u003e\u003cp id=\"a7b0\"\u003eHaving nullable and non-nullable types creates a very flexible environment to design either a perfect API or a poor one. In general, Kotlin developers can be divided into two groups: 1. those who insist on making nothing nullable at all (because no one should accept a nullable type in business logic!), and 2. those who make everything nullable by default (because it‚Äôs much easier when starting to write code). The bad news is that both approaches are fundamentally wrong. There is a very good reason for both types ‚Äî nullable and non-nullable ‚Äî to exist, and each should be used in different cases.\u003c/p\u003e\u003cp id=\"e90c\"\u003eHere are my rules of thumb:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8bee\"\u003eMake sure you don‚Äôt lose business value due to too many properties being nullable‚Äî maybe your aggregate should be divided into smaller ones if so many things can be empty (null) at the same time?\u003c/li\u003e\u003cli id=\"ac4c\"\u003eReturning a null value from a function responsible for looking for some data is not a bad idea ‚Äî it‚Äôs much better to expect null value and handle it properly than to perform a try-catch on a method that is going to throw a \u003ccode\u003eNoSuchElementException\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"a734\"\u003eDon‚Äôt hinder yourself in debugging by creating nested nullable data types ‚Äî it‚Äôs sometimes very hard to figure out what actually was null in such a navigation chain: \u003ccode\u003eperson?.account?.address?.city\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a8c9\"\u003eTalk like a Kotlin native\u003c/h2\u003e\u003cp id=\"c76e\"\u003eNotice the Kotlin naming conventions. Take a look at the following commonly used functions from the Kotlin standard library:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ca91\"\u003epackage kotlin.collections\u003cp\u003epublic interface List\u0026lt;out E\u0026gt; : Collection\u0026lt;E\u0026gt; {\u003cbr/\u003e   public operator fun get(index: Int): E\u003cbr/\u003e   //...\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003epublic fun \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt;.getOrNull(index: Int): T?\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"41ba\"\u003eAs you can see, it‚Äôs a good practice to name your function in such way which already suggests what type (nullable or not) should be expected. Even though we can check the return type, having it clarified in the function name makes the code more readable. However, while it appears to be for readability‚Äôs sake, it actually stems from a compiler limitation: we can‚Äôt have more than one function with the same signature.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a9e5\"\u003edata class Person(private val id: String)\u003cp\u003efun findBy(id: String): Person {\u003cbr/\u003e    return Person(id)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun findBy(id: String): Person? {\u003cbr/\u003e    return null\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"77ef\"\u003eThe code above causes following compilation error:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"18cb\"\u003eConflicting overloads: public fun findBy(id: String): Person defined in root package in file Foo.kt, public fun findBy(id: String): Person? defined in root package in file Foo.kt\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d518\"\u003eFinally, if you wonder what the Kotlin coding conventions are, either take inspiration from the Kotlin standard library or any other Kotlin library commonly used among Kotlin developers, or take a look at the official Kotlin documentation, where you can find the \u003ca href=\"https://kotlinlang.org/docs/coding-conventions.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocument with coding conventions\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"cf2c\"\u003eNever trust Java clients!\u003c/h2\u003e\u003cp id=\"91bb\"\u003eOne of the most frequently crashing parts of a Kotlin application, in my experience, is when you integrate with a Java client (e.g., Hibernate, which seems to frustrate many people, although it‚Äôs really not that bad ‚Äî \u003ca href=\"https://medium.com/better-programming/hibernate-is-not-so-evil-84ca72b959c3\" rel=\"noopener\"\u003echeck out my article about it\u003c/a\u003e).\u003c/p\u003e\u003cp id=\"ce46\"\u003eConsider the following Java code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"371d\"\u003e// File: JavaClass.java\u003cbr/\u003epublic class JavaClass {\u003cbr/\u003e    public String getNullableString() {\u003cbr/\u003e        return null;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5945\"\u003eWhen we try to invoke it in Kotlin, we will end up with the type \u003ccode\u003eString!\u003c/code\u003e, which should catch your attention, because the type is signalling that something might be wrong. Types of Java declarations are called \u003ca href=\"https://kotlinlang.org/docs/java-interop.html#null-safety-and-platform-types\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eplatform types\u003c/a\u003e, and they are treated in a specific way in Kotlin.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1f5d\"\u003eval foo: String? = JavaClass().nullableString // allowed\u003cbr/\u003eprintln(foo?.length) // This works fine\u003cp\u003eval bar: String = JavaClass().nullableString // allowed\u003cbr/\u003eprintln(bar.length) // This throws NPE\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8fb7\"\u003eAs you can see, when integrating with a Java library, we need to consider null cases that might occur in Java code due to the lack of null safety. When it comes to handling platform types, you always have two options:\u003c/p\u003e\u003col\u003e\u003cli id=\"d1fa\"\u003eUse a nullable type and handle the null case yourself.\u003c/li\u003e\u003cli id=\"4583\"\u003eUse a non-nullable type and expect an assertion upon assignment, so an NPE will be thrown if the Java client returns a null value.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f386\"\u003eNotice that if a Java client used \u003ccode\u003e@Nullable\u003c/code\u003e annotation compatible with your IDE , you would see \u003ccode\u003eString?\u003c/code\u003e instead of \u003ccode\u003eString!\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f89e\"\u003eimport org.jetbrains.annotations.Nullable;\u003cp\u003e// File: main.JavaClass.java\u003cbr/\u003epublic class JavaClass {\u003cbr/\u003e    @Nullable\u003cbr/\u003e    public String getNullableString() {\u003cbr/\u003e        return null;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"093c\"\u003eStill not convinced to switch from Java to Kotlin?\u003c/h2\u003e\u003cp id=\"a348\"\u003eEven if you were on the Java side in this conflict between Java and Kotlin at the beginning of my article, I hope you‚Äôve started thinking about Kotlin in a much more positive way. If null safety hasn‚Äôt convinced you enough and you‚Äôre curious about Kotlin‚Äôs capabilities, stay tuned, because I‚Äôm going to publish more Kotlin content in the near future.\u003c/p\u003e\u003cp id=\"2f0f\"\u003eHowever, there is one more thing I‚Äôd like to mention regarding the choice between Java and Kotlin. Respected companies have proven through their experiences that, in general, switching from Java to Kotlin:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7003\"\u003eIncreases productivity: 70% of developers whose primary language is Kotlin say that Kotlin makes them more productive.\u003c/li\u003e\u003cli id=\"e773\"\u003eProduces satisfaction among programmers who participated in the transition: 87% of Google server-side Kotlin developers are ‚Äúvery satisfied‚Äù with Kotlin.\u003c/li\u003e\u003cli id=\"ea73\"\u003eMakes your applications more stable: Google observed a 20% lower likelihood of Android applications crashing.\u003c/li\u003e\u003cli id=\"d9c6\"\u003eDoesn‚Äôt result in any productivity degradation if some parts of the system are left in good old Java (Google observation).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2098\"\u003eLink to the source of statistics: \u003ca href=\"https://www.youtube.com/watch?v=o14wGByBRAQ\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGoogle‚Äôs Journey from Java to Kotlin for Server Side Programming, Devoxx\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"be77\"\u003eThanks for reading my article. I hope you enjoyed it! If you have any thoughts on it, please let me know; I‚Äôm happy to discuss it further.\u003c/p\u003e\u003cp id=\"0e27\"\u003eI‚Äôd like to thank \u003ca href=\"https://medium.com/u/52b77f020913\" rel=\"noopener\"\u003eAdrian Glapi≈Ñski\u003c/a\u003e and \u003ca href=\"https://medium.com/u/dddcafb2a42e\" rel=\"noopener\"\u003ePawe≈Ç Derezi≈Ñski\u003c/a\u003e for being very helpful in reviewing my article. I appreciate it a lot!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-08-03T15:09:15.425Z",
  "modifiedTime": null
}
