{
  "id": "d2689776-ea56-4416-8a4d-a55dd6df11e1",
  "title": "Correctly combining APIs with Business logic",
  "link": "https://proandroiddev.com/correctly-combining-apis-with-business-logic-d4a4eb6e36e8?source=rss----c72404660798---4",
  "description": "",
  "author": "Maxime Michel",
  "published": "Tue, 08 Oct 2024 15:27:39 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "api",
    "android"
  ],
  "byline": "Maxime Michel",
  "length": 12431,
  "excerpt": "I previously wrote an article on implementing MVI in Jetpack Compose so if you haven‚Äôt read it, be sure to do so as I‚Äôll be referring back to some elements from it in this article. As a preface, I‚Äôd‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "I previously wrote an article on implementing MVI in Jetpack Compose so if you haven‚Äôt read it, be sure to do so as I‚Äôll be referring back to some elements from it in this article.As a preface, I‚Äôd like to put point out that this article is library-agnostic! I won‚Äôt be talking about any specific implementations for integrating APIs or local databases and thus, everything described will be useable everywhere!Why ‚ÄúCorrectly‚Äù?Well firstly, because clickbait üòáSecondly, because I‚Äôve spent a long time testing different ways of integrating APIs (and other network-related operations) and have found positives and negatives to each approach. This article will combine all the positives I‚Äôve found into a single, correct, implementation.Integration with Clean ArchitectureI‚Äôm assuming you‚Äôre all well aware of the concept of Clean Architecture and the notion of Separation of Concern. You‚Äôre all hopefully familiar with which role each layer has, if not, check out the official Android guide.To implement Clean Architecture, you need a way to define what we want to do, usually with an Interface. Once we have this, we then define how we want to do it by implementing the interface.Following my article on implementing MVI, I will again take inspiration from the Now In Android project, specifically, the Topics feature.Repository interfaceThe repository interface lies within the Domain layer as it handles the business logic part of getting data from a given source.As stated previously, the interface defines what we want to do. Here we simply want to either get a list of topics or a single topic given an ID.Repository implementationNow that we have an interface defined, we need to implement this interface in the Data layer, where all our data-related operations are located.Focus on the Business-specific objectsIt is generally frowned upon to use repositories directly in the ViewModel in the Presentation layer. Why you ask? Honestly, I don‚Äôt know, and there are cases where I find it better to do it but in nearly all other cases, I agree.The specific cases where I don‚Äôt agree are, as stated, specific, and hence I won‚Äôt detail them. I‚Äôd rather let you leverage or build your own experience on the matter.My experience has been very positive when using what I call UseCases. A UseCase is, as the name suggests, a piece of code responsible for handling a specific use case. Some examples include:LoginUseCaseUpdateProfileUseCaseDoSomethingReallySpecificWithLotsOfBusinessLogicUseCaseAs you can see, they are usually named after what they do which has multiple advantages:You know exactly what the code doesYou implicitly avoid wanting to add unrelated code inside itYou expect it to contain all the related logic and business logicPoint 3 is what I‚Äôm the biggest fan of. It‚Äôs something I took quite some time to understand but once I did, everything clicked!Accurate visual representation of when I learnt how to correctly use UseCasesTo handle all possible scenarios when it comes to business logic, I implement two versions of a UseCase:FlowUseCaseA FlowUseCase is an abstract class intended to implement, as stated previously, the associated business logic. The use of Kotlin Flows here enables the emission of multiple values over a period of time. The strength of this version is its ability to combine multiple data-related calls from different repositories if needed.If you try to copy this Gist, your code will blow up‚Ä¶ Not entirely but the Result object will not be the correct one as this is a custom class I‚Äôll detail below.UseCaseA UseCase, contrary to its Flow counterpart, is intended to return a single value and, therefore, is more suited to unidirectional data flow scenarios. I often use them in cases where I interact with POST APIs or when updating stored application data. Cases where the return value is less significant than the potential business-related logic.No code blow up this time, just plain old application crash‚Ä¶ No seriously, just wait 2 minutes before blindly copying the code‚Ä¶ResultTo finally tie everything together, we need this specific Result class. The class is sealed (for reasons you‚Äôll see later on) and contains 4 internal components:A Success data class which contains the underlying data for a successful operation.An Error data class which contains non-business errors in the form of a sealed AppError class.A BusinessRuleError data class which contains the business errors.A Loading data object to represent the loading state where necessary.The AppError sealed class will not be described here. You can implement a version yourself if needed or (most likely) replace it with an existing class you may have in your codebase with a similar role. It can be used to detect JSON format errors for example without causing a crash.Business errors in a UseCaseFrom this point on, we have everything we need to integrate proper business rules and their associated errors into our very own UseCase.I‚Äôll start by defining the ‚Äúheader‚Äù of our UseCase and explaining what‚Äôs going on. I‚Äôll use our previously defined TopicsRepository here along with another one to demonstrate the behaviour of a UseCase, and create a UseCase intended to load the initial data for a screen from these two repositories.The @IoDispatcher annotation simply injects the underlying Dispatchers.IO dispatcher.What you‚Äôll notice here is the generic parameters of the FlowUseCase which respectively represent the: input, success output and business error output of the use case. They are defined as two distinct sealed classes, each containing the necessary classes to handle the appropriate behaviour for the use case.These are defined within the use case for clarity so that if other classes have the same names, the underlying import can help distinguish the appropriate one to use.With these in place, the actual execute function can be overridden and implemented in the UseCase in the following manner:I‚Äôll acknowledge that the code above may not be easily read by everyone and I‚Äôll explain what‚Äôs going on step by step:We return a cold flow with the flow function.We emit the Result.Loading value to the flow to indicate to the collector that no data has been received yet.We call the appropriate suspend functions in the repositories to get the data.For the received data lists, we check if the list is empty with the ifEmpty block and return null if so.We use the let function to extract the list if it is not null and emit the Result.Success value to the flow with the list in the appropriate GetForYouDataSuccess class.If the list was empty, we will run the right side of the elvis operator (?:) and emit the appropriate Result.BusinessRuleError value to the flow.Integration in a ViewModelThis is the last step to have an end-to-end solution, from getting data from a source to returning said data (or the appropriate business errors) to the user.As you can see, with the current implementation, we can easily handle all cases we need in terms of success, business errors and other errors!Business errors in the data layerIf we‚Äôre being honest, we could stop here and we‚Äôd have a very well structured system. We handle different cases with our two versions of a UseCase and we return business errors directly so they can be handled by the ViewModel.I‚Äôm not going to stop because there are still some parts of this flow that I‚Äôm not totally happy with and that have caused me issues in the past. I‚Äôm talking about HTTP status codes.Everyone knows that when you call an API, you want the holy grail of status codes as a response, the glorious 200 OK (Or any variant of it). However, we also know that more often than not, during development, you‚Äôre bound to get some other unpleasant response like 404, 422, 500, 503 and many more (the bane of my existence honestly).You‚Äôll hopefully have noticed now that we don‚Äôt handle these cases anywhere and rightly so, this is usually handled by our network client (OkHttp usually).To continue my examples, I‚Äôll assume you know about OkHttp3‚Äôs Interceptor interface which allows developers to access the requests and responses that transit through OkHttp. Namely, the code variable of the Response object which represents the HTTP status code.Long story short, what I do is create a custom IOException that takes this code as a parameter and intercept it in the UseCase implementations with the mapToAppError() function you‚Äôve seen above.I now have a way to convert an IOException into a class with a HTTP status code for me to handle how I want! Now we need a way to leverage this when calling APIs with a custom function.I know what you‚Äôre thinking and let me explain, it‚Äôs really not as complicated as it looks. Lets break it down:ParametersapiCall represents a lambda function that actually calls the API and returns the corresponding data.onError is a lambda that takes in a StatusCode and returns a nullable error.The StatusCode is an enum that represents all HTTP status codes.Return typeThe DataResult class is similar to the Result class we defined previously, it looks like this:Here, D represents the success data type and E the error data type.Function bodyWe execute the whole function with Dispatchers.IO for obvious reasons and inside this, we open a try-catch block which catches IOException errors.The try block executes the apiCall lambda and returns it as a DataResult.Success if no exceptions have been caught, which will behave exactly like the getTopics() function defined in our TopicsRepositoryImpl.The catch block is where things get interesting and is what I‚Äôm happy about. We convert the exception to our AppError class and based on the type, we either:Call the onError lambda with the provided status code.Throw the exception again to be handled as a general error by the UseCase classes.In the first case, what we want to do is check whether or not the provided status code represents an error we want to handle. If it does, the onError lambda return an instance of the E class, otherwise, it returns null and the exception is thrown again.What does it look like now?The change in the repository implementation is relatively minor but does highlight how effective this solution can be.What you‚Äôll notice here is that instead of directly returning the List\u003cTopic\u003e like we had previously, this is now wrapped in our new DataResult class along with a custom error type for this repository. The error is not defined in the implementation of the repository but in the interface as otherwise, it is not accessible in both the Data and Domain layers.This does also make the error accessible in the Presentation layer but you‚Äôll see further down how we avoid exposing it.You‚Äôll also notice that now that our function signature has changed, our current UseCase implementation will no longer work. But you‚Äôll be happy to know that the adaptations necessary are quite light and have no impact on the integration of our UseCase!As you can see, we check the repository business errors that originated from a given HTTP status code and emit the appropriate UseCase business error instead.You could argue that this conversion is unnecessary and we could directly use the repository error and you‚Äôd be somewhat correct. It is (at least for this example) a 1-to-1 mapping, but don‚Äôt forget that the repository errors are associated to a given repository whereas UseCases errors are associated to a given UseCase (which can use multiple repositories).The above example is very simple and does very little, but in a real world scenario with actual business rules and specifications to follow from Project Managers (or equivalent), the mapping will most likely be more complex and require additional verifications.Something to take into account is that although here the repository error is a simple data object, nothing stops you from using a data class and have additional data passed down to the UseCase along with the error. Data that you could potentially extract from the response in the Interceptor, alongside the associated HTTP status code.That‚Äôs all folks!There we have it, an end-to-end flow from a data source to a ViewModel that properly handles business errors at every possible stage!It‚Äôs taken me quite some time to write this article but I‚Äôm very happy with how it has turned out! I hope you enjoyed reading it as much as I did writing it and that you learnt something useful along the way!You can find the full implementation on GitHub:",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*DxajBup5BpHn2QXL",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@maxime.h.d.michel?source=post_page-----d4a4eb6e36e8--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Maxime Michel\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*5XdFo2879C-2MlDcOrC9qw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----d4a4eb6e36e8--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"86d4\"\u003eI previously wrote an article on implementing \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/a-robust-mvi-with-jetpack-compose-e08882d2c4ff\"\u003eMVI in Jetpack Compose\u003c/a\u003e so if you haven‚Äôt read it, be sure to do so as I‚Äôll be referring back to some elements from it in this article.\u003c/p\u003e\u003cp id=\"c3eb\"\u003eAs a preface, I‚Äôd like to put point out that this article is \u003cstrong\u003elibrary-agnostic\u003c/strong\u003e! I won‚Äôt be talking about any specific implementations for integrating APIs or local databases and thus, everything described will be \u003cstrong\u003euseable everywhere\u003c/strong\u003e!\u003c/p\u003e\u003ch2 id=\"fc02\"\u003eWhy ‚ÄúCorrectly‚Äù?\u003c/h2\u003e\u003cp id=\"fbb4\"\u003eWell firstly, because clickbait üòá\u003c/p\u003e\u003cp id=\"41b3\"\u003eSecondly, because I‚Äôve spent a long time testing different ways of integrating APIs (and other network-related operations) and have found positives and negatives to each approach. This article will combine all the positives I‚Äôve found into a single, \u003cstrong\u003ecorrect\u003c/strong\u003e, implementation.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"cdba\"\u003eIntegration with Clean Architecture\u003c/h2\u003e\u003cp id=\"9e5b\"\u003eI‚Äôm assuming you‚Äôre all well aware of the concept of \u003cstrong\u003eClean Architecture \u003c/strong\u003eand the notion of \u003cstrong\u003eSeparation of Concern\u003c/strong\u003e. You‚Äôre all hopefully familiar with which role each layer has, if not, check out the official \u003ca href=\"https://developer.android.com/topic/architecture\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid guide\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"c8cd\"\u003eTo implement \u003cstrong\u003eClean Architecture\u003c/strong\u003e, you need a way to define \u003cstrong\u003ewhat we want to do\u003c/strong\u003e, usually with an \u003cstrong\u003eInterface\u003c/strong\u003e. Once we have this, we then define \u003cstrong\u003ehow we want to do it\u003c/strong\u003e by implementing the interface.\u003c/p\u003e\u003cp id=\"0e1c\"\u003eFollowing my article on implementing MVI, I will again take inspiration from the \u003ca href=\"https://github.com/android/nowinandroid\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNow In Android\u003c/a\u003e project, specifically, the \u003cstrong\u003eTopics\u003c/strong\u003e feature.\u003c/p\u003e\u003ch2 id=\"d264\"\u003eRepository interface\u003c/h2\u003e\u003cp id=\"62f8\"\u003eThe repository interface lies within the \u003cstrong\u003eDomain \u003c/strong\u003elayer as it handles the business logic part of getting data from a given source.\u003c/p\u003e\u003cp id=\"dfc9\"\u003eAs stated previously, the interface defines \u003cstrong\u003ewhat we want to do\u003c/strong\u003e. Here we simply want to either get a list of topics or a single topic given an ID.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"1d32\"\u003eRepository implementation\u003c/h2\u003e\u003cp id=\"8973\"\u003eNow that we have an interface defined, we need to implement this interface in the \u003cstrong\u003eData \u003c/strong\u003elayer, where all our data-related operations are located.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5aaa\"\u003eFocus on the Business-specific objects\u003c/h2\u003e\u003cp id=\"3966\"\u003eIt is generally \u003cstrong\u003efrowned upon\u003c/strong\u003e to use repositories directly in the ViewModel in the Presentation layer. Why you ask? Honestly, I don‚Äôt know, and there are cases where I find it better to do it but in nearly all other cases, I agree.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"f3c6\"\u003eThe specific cases where I don‚Äôt agree are, as stated, \u003cstrong\u003especific\u003c/strong\u003e,\u003cstrong\u003e \u003c/strong\u003eand hence I won‚Äôt detail them. I‚Äôd rather let you leverage or build your own experience on the matter.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"abc1\"\u003eMy experience has been very positive when using what I call \u003cstrong\u003eUseCases\u003c/strong\u003e. A UseCase is, as the name suggests, a piece of code responsible for \u003cstrong\u003ehandling a specific use case\u003c/strong\u003e. Some examples include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bd98\"\u003eLoginUseCase\u003c/li\u003e\u003cli id=\"5163\"\u003eUpdateProfileUseCase\u003c/li\u003e\u003cli id=\"4b24\"\u003eDoSomethingReallySpecificWithLotsOfBusinessLogicUseCase\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0f29\"\u003eAs you can see, they are usually named after what they do which has \u003cstrong\u003emultiple advantages\u003c/strong\u003e:\u003c/p\u003e\u003col\u003e\u003cli id=\"e458\"\u003eYou know \u003cstrong\u003eexactly \u003c/strong\u003ewhat the code does\u003c/li\u003e\u003cli id=\"85d7\"\u003eYou \u003cstrong\u003eimplicitly avoid\u003c/strong\u003e wanting to add unrelated code inside it\u003c/li\u003e\u003cli id=\"85ea\"\u003eYou \u003cstrong\u003eexpect \u003c/strong\u003eit to contain all the related logic and business logic\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f6e3\"\u003ePoint 3 is what I‚Äôm the biggest fan of. It‚Äôs something I took quite some time to understand but once I did, \u003cstrong\u003eeverything clicked\u003c/strong\u003e!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAccurate visual representation of when I learnt how to correctly use UseCases\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"4c04\"\u003eTo handle all possible scenarios when it comes to business logic, I implement two versions of a UseCase:\u003c/p\u003e\u003ch2 id=\"346d\"\u003eFlowUseCase\u003c/h2\u003e\u003cp id=\"9662\"\u003eA FlowUseCase is an \u003cstrong\u003eabstract class\u003c/strong\u003e intended to implement, as stated previously, the associated business logic. The use of \u003cstrong\u003eKotlin Flows\u003c/strong\u003e here enables the emission of \u003cstrong\u003emultiple values\u003c/strong\u003e over a period of time. The strength of this version is its ability to \u003cstrong\u003ecombine \u003c/strong\u003emultiple data-related calls from \u003cstrong\u003edifferent \u003c/strong\u003erepositories if needed.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"5914\"\u003eIf you try to copy this Gist, your code will blow up‚Ä¶ Not entirely but the \u003ccode\u003eResult\u003c/code\u003e object will not be the correct one as this is a custom class I‚Äôll detail below.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"d87b\"\u003eUseCase\u003c/h2\u003e\u003cp id=\"1573\"\u003eA UseCase, contrary to its Flow counterpart, is intended to return a \u003cstrong\u003esingle value\u003c/strong\u003e and, therefore, is more suited to \u003cstrong\u003eunidirectional\u003c/strong\u003e data flow scenarios. I often use them in cases where I interact with \u003cstrong\u003ePOST \u003c/strong\u003eAPIs or when updating stored application data. Cases where the return value is \u003cstrong\u003eless significant\u003c/strong\u003e than the potential business-related logic.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"b181\"\u003eNo code blow up this time, just plain old application crash‚Ä¶ No seriously, just wait 2 minutes before blindly copying the code‚Ä¶\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"da66\"\u003eResult\u003c/h2\u003e\u003cp id=\"ba88\"\u003eTo finally tie everything together, we need this specific \u003ccode\u003e\u003cstrong\u003eResult\u003c/strong\u003e\u003c/code\u003e class. The class is \u003cstrong\u003esealed\u003c/strong\u003e (for reasons you‚Äôll see later on) and contains \u003cstrong\u003e4\u003c/strong\u003e internal components:\u003c/p\u003e\u003col\u003e\u003cli id=\"c58a\"\u003eA \u003ccode\u003eSuccess\u003c/code\u003e data class which contains the underlying data for a successful operation.\u003c/li\u003e\u003cli id=\"5481\"\u003eAn \u003ccode\u003eError\u003c/code\u003e data class which contains non-business errors in the form of a sealed \u003ccode\u003eAppError\u003c/code\u003e class.\u003c/li\u003e\u003cli id=\"822c\"\u003eA \u003ccode\u003eBusinessRuleError\u003c/code\u003e data class which contains the business errors.\u003c/li\u003e\u003cli id=\"d334\"\u003eA \u003ccode\u003eLoading\u003c/code\u003e data object to represent the loading state where necessary.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"d1c9\"\u003eThe \u003ccode\u003eAppError\u003c/code\u003e sealed class will not be described here. You can implement a version yourself if needed or (most likely) replace it with an existing class you may have in your codebase with a similar role. It can be used to detect JSON format errors for example without causing a crash.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1546\"\u003eBusiness errors in a UseCase\u003c/h2\u003e\u003cp id=\"d00d\"\u003eFrom this point on, we have \u003cstrong\u003eeverything \u003c/strong\u003ewe need to integrate \u003cstrong\u003eproper business rules\u003c/strong\u003e and their associated errors into our very own UseCase.\u003c/p\u003e\u003cp id=\"1209\"\u003eI‚Äôll start by defining the ‚Äú\u003cstrong\u003eheader\u003c/strong\u003e‚Äù of our UseCase and explaining what‚Äôs going on. I‚Äôll use our previously defined \u003ccode\u003eTopicsRepository\u003c/code\u003e here along with another one to demonstrate the behaviour of a UseCase, and create a UseCase intended to \u003cstrong\u003eload the initial data\u003c/strong\u003e for a screen from these two repositories.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"4dce\"\u003eThe \u003ccode\u003e@IoDispatcher\u003c/code\u003e annotation simply injects the underlying \u003ccode\u003eDispatchers.IO\u003c/code\u003e dispatcher.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"db6e\"\u003eWhat you‚Äôll notice here is the \u003cstrong\u003egeneric parameters \u003c/strong\u003eof the \u003ccode\u003eFlowUseCase\u003c/code\u003e which respectively represent the: \u003cstrong\u003einput\u003c/strong\u003e, \u003cstrong\u003esuccess \u003c/strong\u003eoutput and \u003cstrong\u003ebusiness error\u003c/strong\u003e output of the use case. They are defined as two \u003cstrong\u003edistinct \u003c/strong\u003esealed classes, each containing the necessary classes to handle the appropriate behaviour for the use case.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"5520\"\u003eThese are defined within the use case for \u003cstrong\u003eclarity\u003c/strong\u003e so that if other classes have the same names, the underlying import can help distinguish the appropriate one to use.\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1b5e\"\u003eWith these in place, the actual \u003ccode\u003eexecute\u003c/code\u003e function can be \u003cstrong\u003eoverridden and implemented\u003c/strong\u003e in the UseCase in the following manner:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f317\"\u003eI‚Äôll acknowledge that the code above may not be easily read by everyone and I‚Äôll explain what‚Äôs going on \u003cstrong\u003estep by step\u003c/strong\u003e:\u003c/p\u003e\u003col\u003e\u003cli id=\"b005\"\u003eWe return a \u003cem\u003ecold \u003c/em\u003eflow with the \u003ccode\u003eflow\u003c/code\u003e function.\u003c/li\u003e\u003cli id=\"cc44\"\u003eWe emit the \u003ccode\u003eResult.Loading\u003c/code\u003e value to the flow to \u003cstrong\u003eindicate\u003c/strong\u003e to the collector that no data has been received yet.\u003c/li\u003e\u003cli id=\"183b\"\u003eWe call the appropriate suspend functions in the repositories to get the data.\u003c/li\u003e\u003cli id=\"ece1\"\u003eFor the received data lists, we \u003cstrong\u003echeck \u003c/strong\u003eif the list is empty with the \u003ccode\u003eifEmpty \u003c/code\u003eblock and return \u003ccode\u003enull\u003c/code\u003e if so.\u003c/li\u003e\u003cli id=\"82e1\"\u003eWe use the \u003ccode\u003elet\u003c/code\u003e function to \u003cstrong\u003eextract \u003c/strong\u003ethe list if it is not null and emit the \u003ccode\u003eResult.Success\u003c/code\u003e value to the flow with the list in the appropriate \u003ccode\u003eGetForYouDataSuccess\u003c/code\u003e class.\u003c/li\u003e\u003cli id=\"10b9\"\u003eIf the list was empty, we will run the right side of the elvis operator (\u003ccode\u003e?:\u003c/code\u003e) and emit the appropriate \u003ccode\u003eResult.BusinessRuleError\u003c/code\u003e value to the flow.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"7b82\"\u003eIntegration in a ViewModel\u003c/h2\u003e\u003cp id=\"ed8f\"\u003eThis is the \u003cstrong\u003elast step\u003c/strong\u003e to have an end-to-end solution, from getting data from a source to returning said data (or the appropriate business errors) to the user.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b14c\"\u003eAs you can see, with the current implementation, we can \u003cstrong\u003eeasily \u003c/strong\u003ehandle all cases we need in terms of success, business errors and other errors!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4337\"\u003eBusiness errors in the data layer\u003c/h2\u003e\u003cp id=\"da94\"\u003eIf we‚Äôre being honest, we could stop here and we‚Äôd have a very well structured system. We handle \u003cstrong\u003edifferent \u003c/strong\u003ecases with our two versions of a UseCase and we \u003cstrong\u003ereturn business errors\u003c/strong\u003e directly so they can be handled by the ViewModel.\u003c/p\u003e\u003cp id=\"5103\"\u003eI‚Äôm not going to stop because there are still some parts of this flow that I‚Äôm not totally happy with and that have \u003cstrong\u003ecaused me issues\u003c/strong\u003e in the past. I‚Äôm talking about \u003cstrong\u003eHTTP\u003c/strong\u003e status codes.\u003c/p\u003e\u003cp id=\"143d\"\u003eEveryone knows that when you call an API, you want the\u003cstrong\u003e holy grail \u003c/strong\u003eof status codes as a response, the glorious \u003cstrong\u003e200 OK \u003c/strong\u003e(Or any variant of it). However, we also know that \u003cstrong\u003emore often than not\u003c/strong\u003e, during development, you‚Äôre bound to get some other \u003cstrong\u003eunpleasant \u003c/strong\u003eresponse like \u003cstrong\u003e404\u003c/strong\u003e, \u003cstrong\u003e422\u003c/strong\u003e, \u003cstrong\u003e500\u003c/strong\u003e, \u003cstrong\u003e503 \u003c/strong\u003eand many more (the bane of my existence honestly).\u003c/p\u003e\u003cp id=\"ba03\"\u003eYou‚Äôll hopefully have noticed now that we \u003cstrong\u003edon‚Äôt handle\u003c/strong\u003e these cases anywhere and \u003cstrong\u003erightly so\u003c/strong\u003e, this is usually handled by our \u003cstrong\u003enetwork client\u003c/strong\u003e (OkHttp usually).\u003c/p\u003e\u003cp id=\"74e3\"\u003eTo continue my examples, I‚Äôll assume you know about OkHttp3‚Äôs \u003ccode\u003e\u003cstrong\u003eInterceptor\u003c/strong\u003e\u003c/code\u003e interface which allows developers to \u003cstrong\u003eaccess \u003c/strong\u003ethe \u003cstrong\u003erequests \u003c/strong\u003eand \u003cstrong\u003eresponses \u003c/strong\u003ethat transit through OkHttp. Namely, the \u003ccode\u003ecode\u003c/code\u003e variable of the \u003ccode\u003eResponse\u003c/code\u003e object which represents the \u003cstrong\u003eHTTP\u003c/strong\u003e status code.\u003c/p\u003e\u003cp id=\"d0a2\"\u003eLong story short, what I do is create a custom \u003ccode\u003eIOException\u003c/code\u003e that takes this code as a parameter and \u003cstrong\u003eintercept \u003c/strong\u003eit in the UseCase implementations with the \u003ccode\u003emapToAppError()\u003c/code\u003e function you‚Äôve seen above.\u003c/p\u003e\u003cp id=\"e7d5\"\u003eI now have a way to \u003cstrong\u003econvert \u003c/strong\u003ean \u003ccode\u003eIOException\u003c/code\u003e into a class with a HTTP status code for me to handle how I want! Now we need a way to \u003cstrong\u003eleverage \u003c/strong\u003ethis when calling APIs with a \u003cstrong\u003ecustom function\u003c/strong\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3198\"\u003eI know what you‚Äôre thinking and let me \u003cstrong\u003eexplain\u003c/strong\u003e, it‚Äôs really not as complicated as it looks. Lets \u003cstrong\u003ebreak it down\u003c/strong\u003e:\u003c/p\u003e\u003ch2 id=\"287b\"\u003eParameters\u003c/h2\u003e\u003cp id=\"5f12\"\u003e\u003ccode\u003eapiCall\u003c/code\u003e represents a lambda function that\u003cstrong\u003e actually calls \u003c/strong\u003ethe API and \u003cstrong\u003ereturns \u003c/strong\u003ethe corresponding data.\u003c/p\u003e\u003cp id=\"95ff\"\u003e\u003ccode\u003eonError\u003c/code\u003e is a lambda that takes in a \u003ccode\u003eStatusCode\u003c/code\u003e and returns a \u003cstrong\u003enullable error\u003c/strong\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"48c4\"\u003eThe \u003ccode\u003eStatusCode\u003c/code\u003e is an enum that represents all HTTP status codes.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"98e5\"\u003eReturn type\u003c/h2\u003e\u003cp id=\"84f7\"\u003eThe \u003ccode\u003eDataResult\u003c/code\u003e class is similar to the \u003ccode\u003eResult\u003c/code\u003e class we defined previously, it looks like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"28b5\"\u003eHere, \u003ccode\u003eD\u003c/code\u003e represents the \u003cstrong\u003esuccess \u003c/strong\u003edata type and \u003ccode\u003eE\u003c/code\u003e the \u003cstrong\u003eerror \u003c/strong\u003edata type.\u003c/p\u003e\u003ch2 id=\"9755\"\u003eFunction body\u003c/h2\u003e\u003cp id=\"b3b5\"\u003eWe execute the whole function with \u003ccode\u003eDispatchers.IO\u003c/code\u003e for obvious reasons and inside this, we open a \u003cstrong\u003etry-catch\u003c/strong\u003e block which catches \u003ccode\u003eIOException\u003c/code\u003e errors.\u003c/p\u003e\u003cp id=\"2dc6\"\u003eThe \u003ccode\u003etry\u003c/code\u003e block \u003cstrong\u003eexecutes \u003c/strong\u003ethe \u003ccode\u003eapiCall\u003c/code\u003e lambda and \u003cstrong\u003ereturns \u003c/strong\u003eit as a \u003ccode\u003eDataResult.Success\u003c/code\u003e if \u003cstrong\u003eno exceptions\u003c/strong\u003e have been caught, which will behave exactly like the \u003ccode\u003egetTopics()\u003c/code\u003e function defined in our \u003ccode\u003eTopicsRepositoryImpl\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"b76c\"\u003eThe \u003ccode\u003ecatch\u003c/code\u003e block is where things get \u003cstrong\u003einteresting \u003c/strong\u003eand is what I‚Äôm happy about. We \u003cstrong\u003econvert \u003c/strong\u003ethe exception to our \u003ccode\u003eAppError\u003c/code\u003e class and based on the type, we either:\u003c/p\u003e\u003col\u003e\u003cli id=\"422a\"\u003eCall the \u003ccode\u003eonError\u003c/code\u003e lambda with the provided status code.\u003c/li\u003e\u003cli id=\"ee28\"\u003eThrow the exception again to be handled as a \u003cstrong\u003egeneral error\u003c/strong\u003e by the UseCase classes.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"1fa4\"\u003eIn the first case, what we want to do is check whether or not the provided status code \u003cstrong\u003erepresents \u003c/strong\u003ean error we want to handle. If it does, the \u003ccode\u003eonError\u003c/code\u003e lambda return an \u003cstrong\u003einstance \u003c/strong\u003eof the \u003ccode\u003eE\u003c/code\u003e class, otherwise, it returns \u003cstrong\u003enull \u003c/strong\u003eand the exception is thrown again.\u003c/p\u003e\u003ch2 id=\"8ee2\"\u003eWhat does it look like now?\u003c/h2\u003e\u003cp id=\"b35b\"\u003eThe change in the repository implementation is relatively minor but does \u003cstrong\u003ehighlight \u003c/strong\u003ehow effective this solution can be.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"dbee\"\u003eWhat you‚Äôll notice here is that instead of \u003cstrong\u003edirectly returning\u003c/strong\u003e the \u003ccode\u003eList\u0026lt;Topic\u0026gt;\u003c/code\u003e like we had previously, this is now wrapped in our new \u003ccode\u003eDataResult\u003c/code\u003e class along with a \u003cstrong\u003ecustom error type\u003c/strong\u003e for this repository. The error is not defined in the implementation of the repository but in the interface as otherwise, it is not accessible in both the \u003cstrong\u003eData \u003c/strong\u003eand \u003cstrong\u003eDomain \u003c/strong\u003elayers.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"8422\"\u003eThis does also make the error accessible in the Presentation layer but you‚Äôll see further down how we avoid exposing it.\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e3fc\"\u003eYou‚Äôll also notice that now that our \u003cstrong\u003efunction signature \u003c/strong\u003ehas changed, our current UseCase implementation will no longer work. But you‚Äôll be happy to know that the adaptations necessary are\u003cstrong\u003e quite light\u003c/strong\u003e and have \u003cstrong\u003eno impact\u003c/strong\u003e on the integration of our UseCase!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3841\"\u003eAs you can see, we check the \u003cstrong\u003erepository\u003c/strong\u003e business errors that originated from a given HTTP status code and emit the appropriate \u003cstrong\u003eUseCase \u003c/strong\u003ebusiness error instead.\u003c/p\u003e\u003cp id=\"fa1c\"\u003eYou could argue that this conversion is \u003cstrong\u003eunnecessary \u003c/strong\u003eand we could directly use the repository error and you‚Äôd be \u003cstrong\u003esomewhat correct\u003c/strong\u003e. It is (at least for this example) a 1-to-1 mapping, but don‚Äôt forget that the \u003cstrong\u003erepository errors\u003c/strong\u003e are associated to a given \u003cstrong\u003erepository \u003c/strong\u003ewhereas \u003cstrong\u003eUseCases errors\u003c/strong\u003e are associated to a given \u003cstrong\u003eUseCase \u003c/strong\u003e(which can use \u003cstrong\u003emultiple repositories\u003c/strong\u003e).\u003c/p\u003e\u003cp id=\"b7fc\"\u003eThe above example is \u003cstrong\u003every simple\u003c/strong\u003e and \u003cstrong\u003edoes very little\u003c/strong\u003e, but in a \u003cstrong\u003ereal world\u003c/strong\u003e scenario with actual business rules and \u003cstrong\u003especifications to follow\u003c/strong\u003e from Project Managers (or equivalent), the mapping will most likely be \u003cstrong\u003emore complex\u003c/strong\u003e and require \u003cstrong\u003eadditional verifications\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"071f\"\u003eSomething to take into account is that although here the repository error is a simple \u003ccode\u003edata object\u003c/code\u003e, \u003cstrong\u003enothing \u003c/strong\u003estops you from using a \u003ccode\u003edata class\u003c/code\u003e and have \u003cstrong\u003eadditional data\u003c/strong\u003e passed down to the UseCase along with the error. Data that you could \u003cstrong\u003epotentially \u003c/strong\u003eextract from the response in the \u003ccode\u003eInterceptor\u003c/code\u003e, \u003cstrong\u003ealongside \u003c/strong\u003ethe associated HTTP status code.\u003c/p\u003e\u003ch2 id=\"100b\"\u003eThat‚Äôs all folks!\u003c/h2\u003e\u003cp id=\"d663\"\u003eThere we have it, an end-to-end flow from a data source to a ViewModel that properly handles business errors at every possible stage!\u003c/p\u003e\u003cp id=\"d8e9\"\u003eIt‚Äôs taken me quite some time to write this article but I‚Äôm very happy with how it has turned out! I hope you enjoyed reading it as much as I did writing it and that you learnt something useful along the way!\u003c/p\u003e\u003cp id=\"3c64\"\u003eYou can find the full implementation on GitHub:\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-10-08T15:27:39.744Z",
  "modifiedTime": null
}
