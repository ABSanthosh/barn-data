{
  "id": "d2c98bcb-045e-4794-b5fe-96e94dc1d916",
  "title": "Hidden pitfalls of flatMapMerge",
  "link": "https://blog.kotlin-academy.com/hidden-pitfalls-of-flatmapmerge-f33f21ab9ca2?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Marcin Moskala",
  "published": "Tue, 10 Jun 2025 07:02:26 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "kotlin",
    "kotlin-coroutines"
  ],
  "byline": "Marcin Moskala",
  "length": 2658,
  "excerpt": "Today, we prepared an interesting topic for coroutines users. flatMapMerge is a popular function, but it has a bad habit of tricking its users. Let‚Äôs learn how to use it well. For those unfamiliar‚Ä¶",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "Quote‚ÄúWhen you write tests, do you want them to pass or do you want them to fail? Of course, you should want them to fail. Spending the whole day testing so as not to show any problems in your application is a waste of time. We all know our applications are not perfect, and tests should show that so we can improve them. If you want to build fake assurance that your app is ideal, you‚Äôd better talk to ChatGPT, but when writing tests, do your best to prove that there is something wrong with your application.‚Äù ‚Äî Marcin Moska≈ÇaFunction of the dayWhat if one coroutine calculates something that another coroutine needs? In such cases, we can use CompletableDeferred\u003cT\u003e. One or many coroutines can use its function await() to await value, while another coroutine can provide this value with complete(value). That can also be used to synchronize execution ‚Äî to make one coroutine await until another coroutine reaches some point. Only one value can be passed this way; if you need to pass more than one, use Channel or SharedFlow.Hidden pitfalls of flatMapMergeflatMapMerge is a popular function, but it has three important traps, that often lead to serious mistakes. Let me show you.First, flatMapMerge is used to start multiple asynchronous flows. That is useful when you need to fetch something for each value emitted from a flow. You can also limit concurrency.This is the flattenMerge implementation, it essentially explains most of the problems. You can challenge yourself to try to find them:The first problem is default concurrency. It is an amazing feature that we can limit concurrency, but the default value, that is 16, can surprise us in a very unpleasant way.The second problem is that only the result flow is executed asynchronously, but the transformation itself is synchronous. So if you suspend the transformation function (which is suspending), it will suspend the whole flow.The last problem is that flatMapMerge has inconsistent behavior for concurrency = 1. It starts no coroutines, where it should start one.To learn more about those issues, see my article:flatMapMerge is‚Ä¶ weirdWebinar‚ÄúUnderstanding Structured Concurrency in Kotlin Coroutines‚ÄùüìÜ Date: June 12, 2025üïí Time: 2 time zones to choose fromüëÄ Price: Completely free of chargeüßî Host: Marcin MoskalaLet‚Äôs explore structured concurrency! We will learn why it was introduced, how it helps with cancellation and synchronization, and why other languages introduced it after Kotlin popularized this revolutionary concept. Then we will understand how it is implemented in Kotlin, and learn about common patterns using it, and anti-patterns that break structured concurrency.Sign up now",
  "image": "https://miro.medium.com/v2/resize:fit:776/0*ewkeKfacqucENbDe.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"f4c7\"\u003eQuote\u003c/h2\u003e\u003cp id=\"63fe\"\u003e\u003cem\u003e‚ÄúWhen you write tests, do you want them to pass or do you want them to fail? Of course, you should want them to fail. Spending the whole day testing so as not to show any problems in your application is a waste of time. We all know our applications are not perfect, and tests should show that so we can improve them. If you want to build fake assurance that your app is ideal, you‚Äôd better talk to ChatGPT, but when writing tests, do your best to prove that there is something wrong with your application.‚Äù ‚Äî \u003c/em\u003eMarcin Moska≈Ça\u003c/p\u003e\u003ch2 id=\"8ad9\"\u003eFunction of the day\u003c/h2\u003e\u003cp id=\"1cf2\"\u003eWhat if one coroutine calculates something that another coroutine needs? In such cases, we can use CompletableDeferred\u0026lt;T\u0026gt;. One or many coroutines can use its function await() to await value, while another coroutine can provide this value with complete(value). That can also be used to synchronize execution ‚Äî to make one coroutine await until another coroutine reaches some point. Only one value can be passed this way; if you need to pass more than one, use Channel or SharedFlow.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a876\"\u003eHidden pitfalls of flatMapMerge\u003c/h2\u003e\u003cp id=\"9ac7\"\u003eflatMapMerge is a popular function, but it has three important traps, that often lead to serious mistakes. Let me show you.\u003c/p\u003e\u003cp id=\"782b\"\u003eFirst, flatMapMerge is used to start multiple asynchronous flows. That is useful when you need to fetch something for each value emitted from a flow. You can also limit concurrency.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a734\"\u003eThis is the flattenMerge implementation, it essentially explains most of the problems. You can challenge yourself to try to find them:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d59d\"\u003eThe first problem is default concurrency. It is an amazing feature that we can limit concurrency, but the default value, that is 16, can surprise us in a very unpleasant way.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f166\"\u003eThe second problem is that only the result flow is executed asynchronously, but the transformation itself is synchronous. So if you suspend the transformation function (which is suspending), it will suspend the whole flow.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"eab3\"\u003eThe last problem is that flatMapMerge has inconsistent behavior for concurrency = 1. It starts no coroutines, where it should start one.\u003c/p\u003e\u003cp id=\"79d7\"\u003eTo learn more about those issues, see my article:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1908\"\u003e\u003ca href=\"https://kt.academy/article/flat_map_merge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eflatMapMerge is‚Ä¶ weird\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a45d\"\u003eWebinar\u003c/h2\u003e\u003cp id=\"4468\"\u003e\u003cstrong\u003e‚ÄúUnderstanding Structured Concurrency in Kotlin Coroutines\u003c/strong\u003e‚Äù\u003c/p\u003e\u003cp id=\"865a\"\u003eüìÜ Date: \u003cstrong\u003eJune 12\u003c/strong\u003e, 2025\u003c/p\u003e\u003cp id=\"a76c\"\u003eüïí Time: \u003cstrong\u003e2 time zones\u003c/strong\u003e to choose from\u003c/p\u003e\u003cp id=\"4b2a\"\u003e\u003cstrong\u003eüëÄ \u003c/strong\u003ePrice: Completely\u003cstrong\u003e free\u003c/strong\u003e of charge\u003c/p\u003e\u003cp id=\"33fe\"\u003eüßî Host: \u003cstrong\u003eMarcin Moskala\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"b3c6\"\u003eLet‚Äôs explore structured concurrency! We will learn why it was introduced, how it helps with cancellation and synchronization, and why other languages introduced it after Kotlin popularized this revolutionary concept. Then we will understand how it is implemented in Kotlin, and learn about common patterns using it, and anti-patterns that break structured concurrency.\u003c/p\u003e\u003cp id=\"b206\"\u003e\u003ca href=\"https://webinar.kt.academy/structured-concurrency05\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eSign up now\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-06-10T07:02:25.68Z",
  "modifiedTime": null
}
