{
  "id": "e083d7fb-5287-4785-82fa-a35e13e848cc",
  "title": "How Android Notifications Work Internally",
  "link": "https://proandroiddev.com/how-android-notifications-work-internally-54510c18f1d0?source=rss----c72404660798---4",
  "description": "",
  "author": "Rahul Ray",
  "published": "Thu, 12 Jun 2025 20:15:45 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android",
    "kotlin",
    "notifications",
    "android-app-development"
  ],
  "byline": "Rahul Ray",
  "length": 7375,
  "excerpt": "Every Android app uses NotificationManager.notify() to surface messages, alerts, and updates. But what really happens behind the scenesâ€”from your app code to the little icon or heads-up banner inâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "How Android Notifications Work InternallyEvery Android app uses NotificationManager.notify() to surface messages, alerts, and updates. But what really happens behind the scenesâ€”from your app code to the little icon or heads-up banner in your status bar? In this blog, weâ€™ll follow the exact sections from our video and dive deep into each stage of the notification pipeline.ðŸ“º Watch the video explanation on youtube1. Intro: Why This Deep Dive?Youâ€™ve probably called notify() hundreds of timesâ€”but have you ever wondered what happens next? Understanding this flow helps you debug display issues, optimize performance, and respect battery \u0026 privacy boundaries.2. The Entry Point â€” notify()Your app constructs and posts a notification like this:val notification = NotificationCompat.Builder(context, \"chat_channel\") .setContentTitle(\"New Message\") .setContentText(\"You have a new DM.\") .setSmallIcon(R.drawable.ic_chat) .setAutoCancel(true) .build()val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManagermanager.notify(1001, notification)Facade API: NotificationManager.notify() lives in your appâ€™s process (NotificationManager.java).Binder Hand-Off: Under the hood, it calls INotificationManager.enqueueNotification() to cross into the system_server process.3. Core Data Structures \u0026 Binder4. Full Notification Flow ExplainedApp â†’ NotificationManager API (notify(tag, id, Notification)) Your application constructs a Notification (via NotificationCompat.Builder) and calls:NotificationManager.notify(tag, id, notification);This is a framework faÃ§ade â€” a thin client-side wrapper that packages up your payload and marshals it for IPC.NotificationManager API â†’ NotificationManagerService Under the hood, the API invokes the AIDL interface INotificationManager.enqueueNotification(...). This call crosses process boundaries (from your appâ€™s process into system_server) via Binder IPC.Inside NotificationManagerService, enqueueNotificationInternal() performs:Validation: Ensures the calling appâ€™s UID matches the package name.Channel \u0026 Importance Resolution (Android 8+).Wrapping: Converts the raw Notification into an internal NotificationRecord, adding metadata like postTime, userId, ongoing flags, etc.NMS â†’ Notification Storage NMS writes (or updates) the NotificationRecord in its on-disk SQLite table (notification_records), ensuring notifications survive reboots or service crashes.NMS â†’ StatusBarService/SystemUI After persistence, NMS calls StatusBarService.enqueueNotificationRecord(...). StatusBarService packages the record into a StatusBarNotification and invokes the registered callback in SystemUI (IStatusBar.onNotificationPosted(...)).SystemUI then decides whether to show a status-bar icon, a shade entry, or a heads-up banner.NMS â†’ NotificationListenerService (notifyListeners(NotificationRecord)) Optionally, NMS also broadcasts the new record to any NotificationListenerService implementations (e.g., Wear OS companion apps or accessibility services), enabling external reactions like wearable sync or auto-reply.SystemUI â†’ User (render icon, shade, heads-up)SystemUI inflates UI components:A small icon in the status barAn expandable row in the notification shade (with action buttons)A temporary heads-up banner for high-importance alertsNotificationListenerService â†’ External Service Each NotificationListenerService receives the same event and can forward data to external devices, log analytics, or trigger custom behaviors (e.g., automatically replying to messages).5. System Tray \u0026 SystemUI Integration ExplainedThe sequence diagram above illustrates how SystemUI â€” the Android system-chrome app â€” registers with and receives notifications from the framework services. Letâ€™s break down each phase:Initialization / BootSystemUI (App) starts in its own process (com.android.systemui).During device boot (or SystemUI restart), it calls StatusBarService.registerStatusBar(IStatusBar.Stub).This binder registration hands over a callback object (IStatusBar.Stub) so that StatusBarService can later notify SystemUI of new events.Notification PostedNotificationManagerService (NMS) in the system_server process enqueues a new notification record via StatusBarService.enqueueNotificationRecord().StatusBarService (SBS) then requests an icon slot from WindowManagerService (requestStatusBarIcon()) to reserve space in the status bar.Next, SBS invokes the registered callback IStatusBar.onNotificationPosted(...) in SystemUI (onNotificationPosted()), passing a StatusBarNotification object containing all necessary data.Permission \u0026 Channel ChecksAs part of its enqueueNotificationRecord() handling, StatusBarService enforces two critical checks before informing SystemUI:Notification Permission: On Android 13+ (API 33), it verifies the posting app still holds the POST_NOTIFICATIONS runtime permission.Channel Enabled: It confirms that the notificationâ€™s channel is still enabled and not blocked by the user in Settings.Rendering in SystemUIUpon receiving the callback, SystemUI takes over:It inflates the notification row in the NotificationShadeWindowView, handling layout, icons, text, action buttons, and grouping logic.It also triggers heads-up UI via HeadsUpManager, which decides whether to show a floating banner based on importance, timing, and current device state (e.g., ongoing calls or DND mode).Finally, the notification appears on the screen â€” either as a small icon, a shade entry, or a heads-up alert.6. Beyond the Basics: Edge CasesAndroidâ€™s power-saving and security features introduce a few wrinkles:Offline: Firebase Cloud Messaging (FCM) will hold onto high-priority messages and retry delivery when you come back online.Doze Mode: On API 23+, low-priority work gets delayed until your device wakes up, but urgent notifications still break through.Background Limits: Since API 26, long-running background work requires a foreground service (and its own notification), or the system will kill your process.App Data Cleared: If SystemUI loses its in-memory state, it rebuilds the notification shade by querying NMS for active notifications.7. Notification Channels \u0026 Permissions// Android 8.0+ NotificationChannelval channel = NotificationChannel( \"chat\", \"Chat Messages\", NotificationManager.IMPORTANCE_HIGH).apply { description = \"DM alerts\"}notificationManager.createNotificationChannel(channel)Channel Groups:val group = NotificationChannelGroup(\"social\", \"Social \u0026 Messaging\") notificationManager.createNotificationChannelGroup(group) channel.group = \"social\" notificationManager.createNotificationChannel(channel)Runtime Permission (Android 13+):if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.TIRAMISU) { requestPermissions( arrayOf( Manifest.permission.POST_NOTIFICATIONS ), REQUEST_CODE_NOTIFY )}Without POST_NOTIFICATIONS, your appâ€™s notifications are silently dropped.8. Summary \u0026 Best PracticesDefine meaningful channels with clear names \u0026 descriptions.Respect Doze \u0026 background limits; use high-priority sparingly.Group low-importance notifications to avoid shade clutter.Use FLAG_IMMUTABLE for PendingIntent (Android 12+).Test on real devices and across OEM SystemUI customizations.By mastering these internals, youâ€™ll create more reliable, battery-friendly, and user-respecting notifications. Happy coding!ðŸ”— Connect with me:LinkedIn Â· Twitter Â· Book a 1:1 session",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*J0V6cZMXq2Rjjs04Wx3KIQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"672b\" data-testid=\"storyTitle\"\u003eHow Android Notifications Work Internally\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://rahul9650ray.medium.com/?source=post_page---byline--54510c18f1d0---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Rahul Ray\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*UcWvM8PK5gRHTME0JM1dsQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"20f6\"\u003eEvery Android app uses \u003ccode\u003eNotificationManager.notify()\u003c/code\u003e to surface messages, alerts, and updates. But what really happens behind the scenesâ€”from your app code to the little icon or heads-up banner in your status bar? In this blog, weâ€™ll follow the exact sections from our video and dive deep into each stage of the notification pipeline.\u003c/p\u003e\u003cp id=\"903f\"\u003eðŸ“º \u003cstrong\u003eWatch the video explanation on youtube\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c1ff\"\u003e1. Intro: Why This Deep Dive?\u003c/h2\u003e\u003cp id=\"82c2\"\u003e\u003cstrong\u003eYouâ€™ve probably called \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003enotify()\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e hundreds of timesâ€”but have you ever wondered what happens next?\u003c/strong\u003e\u003cem\u003e\u003cbr/\u003e\u003c/em\u003e Understanding this flow helps you debug display issues, optimize performance, and respect battery \u0026amp; privacy boundaries.\u003c/p\u003e\u003ch2 id=\"6dd0\"\u003e2. The Entry Point â€” \u003ccode\u003enotify()\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"ea70\"\u003eYour app constructs and posts a notification like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"800d\"\u003eval notification = NotificationCompat.Builder(context, \u0026#34;chat_channel\u0026#34;)\u003cbr/\u003e    .setContentTitle(\u0026#34;New Message\u0026#34;)\u003cbr/\u003e    .setContentText(\u0026#34;You have a new DM.\u0026#34;)\u003cbr/\u003e    .setSmallIcon(R.drawable.ic_chat)\u003cbr/\u003e    .setAutoCancel(true)\u003cbr/\u003e    .build()\u003cp\u003eval manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager\u003cbr/\u003emanager.notify(1001, notification)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"390f\"\u003e\u003cstrong\u003eFacade API\u003c/strong\u003e: \u003ccode\u003eNotificationManager.notify()\u003c/code\u003e lives in your appâ€™s process (\u003ccode\u003eNotificationManager.java\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"3e07\"\u003e\u003cstrong\u003eBinder Hand-Off\u003c/strong\u003e: Under the hood, it calls \u003ccode\u003eINotificationManager.enqueueNotification()\u003c/code\u003e to cross into the \u003cstrong\u003esystem_server\u003c/strong\u003e process.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"af84\"\u003e3. Core Data Structures \u0026amp; Binder\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4d4b\"\u003e4. Full Notification Flow Explained\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0873\"\u003e\u003cstrong\u003eApp â†’ NotificationManager API (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003enotify(tag, id, Notification)\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003cbr/\u003e Your application constructs a \u003ccode\u003eNotification\u003c/code\u003e (via \u003ccode\u003eNotificationCompat.Builder\u003c/code\u003e) and calls:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a09d\"\u003eNotificationManager.notify(tag, id, notification);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0e34\"\u003eThis is a framework faÃ§ade â€” a thin client-side wrapper that packages up your payload and marshals it for IPC.\u003c/p\u003e\u003cp id=\"5d46\"\u003e\u003cstrong\u003eNotificationManager API â†’ NotificationManagerService \u003c/strong\u003e\u003cbr/\u003eUnder the hood, the API invokes the AIDL interface \u003ccode\u003eINotificationManager.enqueueNotification(...)\u003c/code\u003e.\u003cbr/\u003e This call crosses process boundaries (from your appâ€™s process into \u003cstrong\u003esystem_server\u003c/strong\u003e) via Binder IPC.\u003c/p\u003e\u003cp id=\"a019\"\u003eInside \u003cstrong\u003eNotificationManagerService\u003c/strong\u003e, \u003ccode\u003eenqueueNotificationInternal()\u003c/code\u003e performs:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4ee2\"\u003e\u003cstrong\u003eValidation\u003c/strong\u003e: Ensures the calling appâ€™s UID matches the package name.\u003c/li\u003e\u003cli id=\"0a7b\"\u003e\u003cstrong\u003eChannel \u0026amp; Importance Resolution\u003c/strong\u003e (Android 8+).\u003c/li\u003e\u003cli id=\"4362\"\u003e\u003cstrong\u003eWrapping\u003c/strong\u003e: Converts the raw \u003ccode\u003eNotification\u003c/code\u003e into an internal \u003ccode\u003eNotificationRecord\u003c/code\u003e, adding metadata like \u003ccode\u003epostTime\u003c/code\u003e, \u003ccode\u003euserId\u003c/code\u003e, ongoing flags, etc.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1758\"\u003e\u003cstrong\u003eNMS â†’ Notification Storage\u003c/strong\u003e\u003cbr/\u003e NMS writes (or updates) the \u003ccode\u003eNotificationRecord\u003c/code\u003e in its on-disk SQLite table (\u003ccode\u003enotification_records\u003c/code\u003e), ensuring notifications survive reboots or service crashes.\u003c/p\u003e\u003cp id=\"482a\"\u003e\u003cstrong\u003eNMS â†’ StatusBarService/SystemUI\u003c/strong\u003e\u003cbr/\u003e After persistence, NMS calls \u003ccode\u003eStatusBarService.enqueueNotificationRecord(...)\u003c/code\u003e.\u003cbr/\u003e StatusBarService packages the record into a \u003ccode\u003eStatusBarNotification\u003c/code\u003e and invokes the registered callback in \u003cstrong\u003eSystemUI \u003c/strong\u003e(\u003ccode\u003eIStatusBar.onNotificationPosted(...)\u003c/code\u003e).\u003cbr/\u003e\u003cstrong\u003eSystemUI\u003c/strong\u003e then decides whether to show a status-bar icon, a shade entry, or a heads-up banner.\u003c/p\u003e\u003cp id=\"7cd0\"\u003e\u003cstrong\u003eNMS â†’ NotificationListenerService (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003enotifyListeners(NotificationRecord)\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003cbr/\u003e Optionally, NMS also broadcasts the new record to any \u003ccode\u003eNotificationListenerService\u003c/code\u003e implementations (e.g., Wear OS companion apps or accessibility services), enabling external reactions like wearable sync or auto-reply.\u003c/p\u003e\u003cp id=\"e0b7\"\u003e\u003cstrong\u003eSystemUI â†’ User (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003erender icon, shade, heads-up\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003cbr/\u003eSystemUI inflates UI components:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2d22\"\u003eA small icon in the status bar\u003c/li\u003e\u003cli id=\"af0e\"\u003eAn expandable row in the notification shade (with action buttons)\u003c/li\u003e\u003cli id=\"bb8a\"\u003eA temporary heads-up banner for high-importance alerts\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b7b2\"\u003e\u003cstrong\u003eNotificationListenerService â†’ External Service\u003c/strong\u003e\u003cbr/\u003e Each \u003ccode\u003eNotificationListenerService\u003c/code\u003e receives the same event and can forward data to external devices, log analytics, or trigger custom behaviors (e.g., automatically replying to messages).\u003c/p\u003e\u003ch2 id=\"3453\"\u003e5. System Tray \u0026amp; SystemUI Integration Explained\u003c/h2\u003e\u003cp id=\"b875\"\u003eThe sequence diagram above illustrates how \u003cstrong\u003eSystemUI\u003c/strong\u003e â€” the Android system-chrome app â€” registers with and receives notifications from the framework services. Letâ€™s break down each phase:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4d91\"\u003e\u003cstrong\u003eInitialization / Boot\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0e69\"\u003e\u003cstrong\u003eSystemUI (App)\u003c/strong\u003e starts in its own process (\u003ccode\u003ecom.android.systemui\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"0dfd\"\u003eDuring device boot (or SystemUI restart), it calls \u003ccode\u003eStatusBarService.registerStatusBar(IStatusBar.Stub)\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"11ce\"\u003eThis binder registration hands over a callback object (\u003ccode\u003eIStatusBar.Stub\u003c/code\u003e) so that StatusBarService can later notify SystemUI of new events.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8b35\"\u003e\u003cstrong\u003eNotification Posted\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5063\"\u003e\u003cstrong\u003eNotificationManagerService (NMS)\u003c/strong\u003e in the \u003cstrong\u003esystem_server\u003c/strong\u003e process enqueues a new notification record via \u003ccode\u003eStatusBarService.enqueueNotificationRecord()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"d80a\"\u003e\u003cstrong\u003eStatusBarService (SBS)\u003c/strong\u003e then requests an icon slot from \u003cstrong\u003eWindowManagerService\u003c/strong\u003e (\u003ccode\u003erequestStatusBarIcon()\u003c/code\u003e) to reserve space in the status bar.\u003c/li\u003e\u003cli id=\"0202\"\u003eNext, SBS invokes the registered callback \u003ccode\u003eIStatusBar.onNotificationPosted(...)\u003c/code\u003e in SystemUI (\u003ccode\u003eonNotificationPosted()\u003c/code\u003e), passing a \u003ccode\u003eStatusBarNotification\u003c/code\u003e object containing all necessary data.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"11ff\"\u003e\u003cstrong\u003ePermission \u0026amp; Channel Checks\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"a4ba\"\u003eAs part of its \u003ccode\u003eenqueueNotificationRecord()\u003c/code\u003e handling, StatusBarService enforces two critical checks \u003cstrong\u003ebefore\u003c/strong\u003e informing SystemUI:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9907\"\u003e\u003cstrong\u003eNotification Permission:\u003c/strong\u003e On Android 13+ (API 33), it verifies the posting app still holds the \u003ccode\u003ePOST_NOTIFICATIONS\u003c/code\u003e runtime permission.\u003c/li\u003e\u003cli id=\"f31d\"\u003e\u003cstrong\u003eChannel Enabled:\u003c/strong\u003e It confirms that the notificationâ€™s channel is still enabled and not blocked by the user in Settings.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9927\"\u003e\u003cstrong\u003eRendering in SystemUI\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"8d58\"\u003eUpon receiving the callback, \u003cstrong\u003eSystemUI\u003c/strong\u003e takes over:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9c4f\"\u003eIt inflates the notification row in the \u003cstrong\u003eNotificationShadeWindowView\u003c/strong\u003e, handling layout, icons, text, action buttons, and grouping logic.\u003c/li\u003e\u003cli id=\"7d4c\"\u003eIt also triggers heads-up UI via \u003cstrong\u003eHeadsUpManager\u003c/strong\u003e, which decides whether to show a floating banner based on importance, timing, and current device state (e.g., ongoing calls or DND mode).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4a18\"\u003eFinally, the notification appears on the screen â€” either as a small icon, a shade entry, or a heads-up alert.\u003c/p\u003e\u003ch2 id=\"72de\"\u003e6. Beyond the Basics: Edge Cases\u003c/h2\u003e\u003cp id=\"ff57\"\u003eAndroidâ€™s power-saving and security features introduce a few wrinkles:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a374\"\u003e\u003cstrong\u003eOffline\u003c/strong\u003e: Firebase Cloud Messaging (FCM) will hold onto high-priority messages and retry delivery when you come back online.\u003c/li\u003e\u003cli id=\"4a01\"\u003e\u003cstrong\u003eDoze Mode\u003c/strong\u003e: On API 23+, low-priority work gets delayed until your device wakes up, but urgent notifications still break through.\u003c/li\u003e\u003cli id=\"c2f7\"\u003e\u003cstrong\u003eBackground Limits\u003c/strong\u003e: Since API 26, long-running background work requires a foreground service (and its own notification), or the system will kill your process.\u003c/li\u003e\u003cli id=\"f76a\"\u003e\u003cstrong\u003eApp Data Cleared\u003c/strong\u003e: If SystemUI loses its in-memory state, it rebuilds the notification shade by querying NMS for active notifications.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c7cc\"\u003e7. Notification Channels \u0026amp; Permissions\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"ae55\"\u003e// Android 8.0+ NotificationChannel\u003cbr/\u003eval channel = NotificationChannel(\u003cbr/\u003e  \u0026#34;chat\u0026#34;, \u0026#34;Chat Messages\u0026#34;, NotificationManager.IMPORTANCE_HIGH\u003cbr/\u003e).apply {\u003cbr/\u003e  description = \u0026#34;DM alerts\u0026#34;\u003cbr/\u003e}\u003cbr/\u003enotificationManager.createNotificationChannel(channel)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5a24\"\u003e\u003cstrong\u003eChannel Groups\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8c9\"\u003eval group = NotificationChannelGroup(\u0026#34;social\u0026#34;, \u0026#34;Social \u0026amp; Messaging\u0026#34;) \u003cbr/\u003enotificationManager.createNotificationChannelGroup(group) \u003cbr/\u003echannel.group = \u0026#34;social\u0026#34; \u003cbr/\u003enotificationManager.createNotificationChannel(channel)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"462e\"\u003e\u003cstrong\u003eRuntime Permission\u003c/strong\u003e (Android 13+):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"416d\"\u003eif (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.TIRAMISU) {   \u003cbr/\u003erequestPermissions(\u003cbr/\u003e    arrayOf(\u003cbr/\u003e      Manifest.permission.POST_NOTIFICATIONS\u003cbr/\u003e    ),\u003cbr/\u003e    REQUEST_CODE_NOTIFY\u003cbr/\u003e  )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ddf6\"\u003eWithout \u003ccode\u003ePOST_NOTIFICATIONS\u003c/code\u003e, your appâ€™s notifications are silently dropped.\u003c/p\u003e\u003ch2 id=\"ef06\"\u003e8. Summary \u0026amp; Best Practices\u003c/h2\u003e\u003cul\u003e\u003cli id=\"32ce\"\u003e\u003cstrong\u003eDefine meaningful channels\u003c/strong\u003e with clear names \u0026amp; descriptions.\u003c/li\u003e\u003cli id=\"8ca1\"\u003e\u003cstrong\u003eRespect Doze \u0026amp; background limits\u003c/strong\u003e; use high-priority sparingly.\u003c/li\u003e\u003cli id=\"3204\"\u003e\u003cstrong\u003eGroup low-importance notifications\u003c/strong\u003e to avoid shade clutter.\u003c/li\u003e\u003cli id=\"c071\"\u003eUse \u003ccode\u003eFLAG_IMMUTABLE\u003c/code\u003e for \u003ccode\u003ePendingIntent\u003c/code\u003e (Android 12+).\u003c/li\u003e\u003cli id=\"2c71\"\u003e\u003cstrong\u003eTest on real devices\u003c/strong\u003e and across OEM SystemUI customizations.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"04f1\"\u003eBy mastering these internals, youâ€™ll create more reliable, battery-friendly, and user-respecting notifications. Happy coding!\u003c/p\u003e\u003cp id=\"d63f\"\u003eðŸ”— \u003cstrong\u003eConnect with me:\u003cbr/\u003e\u003c/strong\u003e\u003ca href=\"https://www.linkedin.com/in/raystatic/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e Â· \u003ca href=\"https://x.com/raystatic_\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTwitter\u003c/a\u003e Â· \u003ca href=\"https://topmate.io/raystatic/465191\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBook a 1:1 session\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-06-12T12:28:42.424Z",
  "modifiedTime": null
}
