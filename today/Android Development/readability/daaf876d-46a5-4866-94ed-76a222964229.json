{
  "id": "daaf876d-46a5-4866-94ed-76a222964229",
  "title": "XML to Compose in Production: An Android Journey — Part 1",
  "link": "https://proandroiddev.com/xml-to-compose-in-production-an-android-journey-part-1-7f9a8369f868?source=rss----c72404660798---4",
  "description": "",
  "author": "Iago Fucolo",
  "published": "Tue, 15 Apr 2025 20:35:51 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "androiddev",
    "android-app-development",
    "android",
    "jetpack-compose"
  ],
  "byline": "Iago Fucolo",
  "length": 28833,
  "excerpt": "Back in 2017, I started my first Android app using Kotlin. At the time, it was just to explore the language, but later I ended up presenting it to my former colleagues to show how we could use Kotlin…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Back in 2017, I started my first Android app using Kotlin. At the time, it was just to explore the language, but later I ended up presenting it to my former colleagues to show how we could use Kotlin in our projects since they were all written in Java.GitHub commit screenshotThe idea of the app was straightforward, helping me on my prayer journey.Why did I decide to create an app like this?Well, I had no better idea, so I just picked the first thing that came to mind to start writing code quickly. What mattered to me back then was learning how to use Kotlin in Android projects.In the beginning, I was exploring what I could use to build a solid app ready for production, and I ended up using the following libraries:What is interest in on this build gradle file?I was already using dependency injection with Dagger 2, firebase real time data base as my backend and RxJava in order to do async operations, and a lot of other libraries that were very popular back then and some that are still used.In a month or so, I had an app ready to publish, and I did it, shipped out my first personal project to production on Google Play store.Google Play version historyIt was my first personal project in production, and it felt so good, because I finally could have my own app and use any libraries that I wanted.The reality is very simple, it is not easy to simply add new libraries to existing projects, or even change everything in a stable code base, because with client products we need to be very careful not to break everything. In order to bring a new library or approach to an application, we need to have a solid reason for it, but in the other hand for personal projects, we can do whatever we want, because we are the owners.I was working on large projects with millions of users, so I could not change everything at once, so I thought this would be the best way to keep myself in the loop for new technologies, and to show up that we could start upcoming projects using Kotlin and begin to migrate some of the ongoing projects.And it ended up very well. After 8 years, the project is still relevant for my learnings as a Android developer8 years ago, and now, what is happening in the Android world?Jetpack Compose is the hottest topic in the Android world, but how can I update a project that has 8 years to use the latest libraries? So, that is what I will try to summarise in the first post of probably a series of real case of migrating XML views to Jetpack Compose.First step, let’s check the app structure:I have implemented basically feature modules:Android studio screenshot — project structureSo, as you can see it is well divided in modules and this was made around 6 years ago (2 years after the first release):git commits from the first modules creationAnd inside of a feature module, the structure is the following:P.S: prayers feature module, will be the first one to be migrated from XML to Compose, that is why I’m showing it here.feature module structureNow as it is a bit more clear about the whole project structure, let’s dive into the UI folder of the prayer module, to understand how we can start the migration to Compose.But first, I want to show the first screen that will be migrated: CardPrayersFragment.gif recorded from the Sanctus AppThis is the CardPrayerFragment, which is one of the 4 main screens of the app, as it is part of the bottom tab navigation entry points. So let me explain how this screen was implemented, to understand how complex it will be to migrate to Compose.Structure of the ui package regarding the Prayers feature:Android studio screenshot — project structureCardsPrayerFragment:This the main class of the feature/screen, where the list of prayers and filters are implemented. Let’s take a look at the XML of this screen:\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/color_back_nav\"\u003e \u003cLinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" android:background=\"@android:color/white\"\u003e \u003cEditText android:id=\"@+id/edtSearch\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:drawableStart=\"@drawable/ic_search\" android:drawablePadding=\"@dimen/margin_view\" android:padding=\"@dimen/little_margin_view\" android:layout_marginTop=\"@dimen/little_margin_view\" android:layout_marginStart=\"@dimen/margin_view\" android:layout_marginEnd=\"@dimen/margin_view\" android:layout_marginBottom=\"@dimen/margin_view\" android:maxLines=\"1\" android:inputType=\"text\" android:imeOptions=\"actionGo\" android:background=\"@drawable/bg_rounded_black_transparent\"/\u003e \u003ccom.evangelhododiacatolico.prayers.ui.filter.FilterView android:id=\"@+id/filterView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"@dimen/margin_view\"/\u003e \u003c/LinearLayout\u003e \u003cView android:layout_width=\"match_parent\" android:layout_height=\"2dp\" android:background=\"@color/color_line\"/\u003e \u003candroidx.recyclerview.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:clipToPadding=\"false\" android:paddingTop=\"@dimen/margin_view\"/\u003e\u003c/LinearLayout\u003eedtSearch: is just the search box, to find prayers by typing.edtSearchFilterView: it is a custom component created to setup filters, by FilterType, which consist in a horizontal recyclerView that holds the filters options.FilterViewI have 3 filter types that are defined in the FilterType sealed class:sealed class FilterType { object TercoMain: FilterType() object NovenaMain: FilterType() sealed class PrayerMain: FilterType() { object Prayer: PrayerMain() object SubCategory: PrayerMain() }}And then, I custom FilterItem to hold the filter type, and some options to customize the UI:data class FilterItem( val tag: String, //text that shows in the UI val backgroundDrawable: Int, //backhground when isActive = true val backgroundDrawableDeactive: Int, //backhground when isActive = false var isActive: Boolean = true, // definition if the is On or Off val type: FilterType // the type of the filter)To start using the FilterView, the screen that is having it in the XML needs to call the setupFilter:class FilterView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : LinearLayout(context, attrs, defStyleAttr) { private val binding: ViewFilterBinding = ViewFilterBinding.inflate(LayoutInflater.from(context), this, true) private var filterAdapter: FilterAdapter? = null fun setupFilter( filters: List\u003cFilterItem\u003e, listener: (FilterItem) -\u003e Unit ) { filterAdapter = FilterAdapter( filters = filters, onClickListener = { val index = filters.indexOf(it) it.isActive = !it.isActive filterAdapter?.notifyItemChanged(index) onClickListener(it) } ) binding.filterList.layoutManager = LinearLayoutManager(context, RecyclerView.HORIZONTAL, false) binding.filterList.adapter = filterAdapter }}This is a custom view that sets up a horizontal filter list using a RecyclerView. First, it binds the view to access the XML components. Then, the setupFilter function initialises a FilterAdapter to populate the list with filter items. The adapter takes a high-order function to handle item clicks, toggling the isActive state and notifying the adapter to update the UI. Finally, the RecyclerView is set to a horizontal layout, and the adapter is attached.FilterAdapter: This defines how each filter item is displayed in the list. It binds the data to the UI, updating the tag text and background based on whether the filter is active or not. It also handles click events, passing the clicked item back through a high-order function.class FilterAdapter( val filters: List\u003cFilterItem\u003e, val onClickListener: (FilterItem) -\u003e Unit): RecyclerView.Adapter\u003cFilterAdapter.FilterViewHolder\u003e() { inner class FilterViewHolder( private val binding: ItemFilterBinding ) : RecyclerView.ViewHolder(binding.root){ fun bind(filter: FilterItem) = with(binding) { val context = binding.root.context txtTag.text = filter.tag when(filter.isActive) { true -\u003e txtTag.background = ContextCompat.getDrawable(context, filter.backgroundDrawable) else -\u003e txtTag.background = ContextCompat.getDrawable(context, filter.backgroundDrawableDeactive) } binding.root.setOnClickListener { onClickListener.invoke(filter) } } } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FilterViewHolder { val binding = ItemFilterBinding.inflate(LayoutInflater.from(parent.context), parent, false) return FilterViewHolder(binding) } override fun getItemCount(): Int = filters.size override fun onBindViewHolder(viewHolder: FilterViewHolder, position: Int) = viewHolder.bind(filters[position])}Filters are explained, now let’s check the list of prayers implementation.List of prayers from the Sanctus AppRecyclerView — List of prayersHere I need to explain a little deeper how lists in general are implemented in the whole app.You can skip it if you want, but I found it very important to understand how it was and how it will be with Compose, but feel free to move forward.My approach to handling lists was creating a GenericAdapter using the delegate adapters pattern. Each delegate has a specific type, and the GenericAdapter includes predefined types such as Load, NoResult, and ErrorRetry. These can be reused across different scenarios, making the solution more scalable and preventing the need to re-implement these cases for every list in the appclass GenericAdapter( lifecycleOwner: LifecycleOwner, private var items: ArrayList\u003cViewType\u003e, private var delegateAdapters : SparseArrayCompat\u003cViewTypeDelegateAdapter\u003e): RecyclerView.Adapter\u003cRecyclerView.ViewHolder\u003e() { private val _errorLiveData = MutableLiveData\u003cThrowable\u003e() val errorLiveData: LiveData\u003cThrowable\u003e = _errorLiveData init { val adapters = listOf( Load.TYPE to LoadDelegateAdapter(), NoResults.TYPE to NoResultsDelegateAdapter(), ErrorRetry.TYPE to ErrorDelegateAdapter().apply { errorLiveData.observe(lifecycleOwner) { updateList(listOf(Load())) _errorLiveData.postValue(it) } } ) adapters.forEach { (type, adapter) -\u003e delegateAdapters.put(type, adapter) } items = arrayListOf(Load()) } override fun getItemCount(): Int = items.size override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { val delegateAdapter = delegateAdapters.get(viewType) return delegateAdapter?.onCreateViewHolder(parent) ?: object : RecyclerView.ViewHolder(parent) {} } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { val delegateAdapter = delegateAdapters.get(getItemViewType(position)) delegateAdapter?.onBindViewHolder(position, holder, items[position]) } override fun getItemViewType(position: Int) = items[position].getViewType() fun updateList(newList: List\u003cViewType\u003e, query: String = \"\") { if (items.firstOrNull() is Load) { items.removeAt(0) notifyItemRemoved(0) } if (newList.isEmpty()) { items.add(NoResults(query = query)) notifyItemInserted(items.size - 1) } else { val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, newList)) items.clear() items.addAll(newList) diffResult.dispatchUpdatesTo(this) } } fun resetList( newList: List\u003cViewType\u003e, query: String = \"\" ) { if (newList.isEmpty()) { val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, listOf(NoResults(query)))) items.clear() items.add(NoResults(query)) diffResult.dispatchUpdatesTo(this) } else { val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, newList)) items.clear() items.addAll(newList) diffResult.dispatchUpdatesTo(this) } } fun showError(throwable: Throwable, color: Int = Color.BLACK) { resetList(listOf(ErrorRetry(throwable, color))) }}Init: I have setup as default 3 delegate types, as explained above, but want to add the ErrorRetry explanation: when it is present there is a liveData, which fires the retry event when the user clicks on retry button, so the view that is implementing the GenericAdapter can benefit of this error handling.getItemsCount, onCreateViewHolder, and onBindViewHolder, are just recycler view holder methods, and getItemViewType is the key of getting the correct delegate to show, so as you can see it is implemented for all types:Android studio screenshot — project structureSo the generic adapter rely on the ViewType, which is used for the whole app. Back 6 years ago, it was the way that I have found in order to have a more scalable list and components over the application.And updateList, resetList and showError are used to update the list with new data and show errors when it is necessary.It takes too long, but we are getting there. Now we can check the CardPrayerFragment, which uses all the above things that were explained.First, a diagram to show where the data is coming from, because the idea is not to explain the whole architecture of the app, but an overview is great:Sanctus App diagramSo basically, the data comes from 3 different places, Novena module which is responsable for Novenas , Terco module which is responsable for the Tercos data, and Prayers data source, is part of the prayers module, after fetching the data, which can be from the backend(firebase) or directly from the database, which for the UI does not matter, as the PrayerViewModel is asking it to PrayersUseCase.Let’s check how the CardPrayerFragment looks like:class CardPrayerFragment: BaseFragmentX(R.layout.fragment_prayer) { private val viewModel: PrayerViewModel by viewModel() private val crashLogs: CrashLogs by inject() private lateinit var genericAdapter: GenericAdapter private val unsubscribeOnDestroy = CompositeDisposable() private lateinit var binding: FragmentPrayerBinding companion object { fun newInstance(): CardPrayerFragment { return CardPrayerFragment() } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { binding = FragmentPrayerBinding.inflate(layoutInflater) return binding.root } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) setupViewModel() setupList() setupRecyclerView() setupSearch() } override fun onDestroy() { super.onDestroy() unsubscribeOnDestroy.clear() } private fun setupViewModel() { viewModel.init() viewModel.prayersLiveData.observe(viewLifecycleOwner, Observer { it?.getContentIfNotHandled()?.let { genericAdapter.updateList(it) } }) viewModel.updatePrayersLiveData.observe(viewLifecycleOwner, Observer { it?.getContentIfNotHandled()?.let { genericAdapter.resetList(it, binding.edtSearch.text.toString()) } }) viewModel.errorRetryLiveData.observe(viewLifecycleOwner, Observer { it?.getContentIfNotHandled()?.let { genericAdapter.showError(it) } }) viewModel.filtersLiveData.observe(viewLifecycleOwner, Observer { it?.getContentIfNotHandled()?.let { filters -\u003e binding.filterView.setupFilter(filters) { filter -\u003e viewModel.filter(filter) } } }) } private fun setupSearch() { binding.edtSearch.setOnEditorActionListener { _, actionId, _ -\u003e if (actionId == EditorInfo.IME_ACTION_GO) { binding.edtSearch.dismissKeyboard() } true } RxTextView.textChanges(binding.edtSearch) .skipInitialValue() .debounce(300, TimeUnit.MILLISECONDS) .subscribeBy( onNext = { viewModel.search(it.toString()) }, onError = { crashLogs.logException(it) } ) .addTo(unsubscribeOnDestroy) } private fun setupList() { val delegateAdapters = SparseArrayCompat\u003cViewTypeDelegateAdapter\u003e() val searchChapletDelegateAdapter = SearchChapletDelegateAdapter() searchChapletDelegateAdapter.tercoSearchLiveData.observe(viewLifecycleOwner, Observer { it.getContentIfNotHandled()?.let { startActivity(TercoFlowActivity.newIntent(requireContext(), it)) } }) val searchNovenaDelegateAdapter = SearchNovenaDelegateAdapter() searchNovenaDelegateAdapter.novenaSearchLiveData.observe(viewLifecycleOwner, Observer { it.getContentIfNotHandled()?.let { startActivity(NovenaFlowActivity.newIntent(requireContext(), it)) } }) val searchPrayerDelegateAdapter = SearchPrayerDelegateAdapter() searchPrayerDelegateAdapter.prayerSearchLiveData.observe(viewLifecycleOwner, Observer { it.getContentIfNotHandled()?.let { startActivity(PrayersDetailActivity.newIntent(requireContext(), it)) } }) delegateAdapters.put(PrayerSearch.TYPE, searchPrayerDelegateAdapter) delegateAdapters.put(NovenaSearch.TYPE, searchNovenaDelegateAdapter) delegateAdapters.put(ChapletSearch.TYPE, searchChapletDelegateAdapter) genericAdapter = GenericAdapter( this, arrayListOf(), delegateAdapters ) genericAdapter.errorLiveData.observe(viewLifecycleOwner, Observer { viewModel.init() }) setupRecyclerView() } private fun setupRecyclerView() = with(binding.recyclerView) { layoutManager = LinearLayoutManager(context) val decor = DividerItemDecoration(context, DividerItemDecoration.VERTICAL) decor.setDrawable(context.resources.getDrawable(R.drawable.divider2)) addItemDecoration(decor) adapter = genericAdapter }}Just want to mention that I’m using Koin as DI. I started with dagger but, later on I have decided to experiment Koin as a learning thing 7 years ago - 1 year after the first release.Let’s check the 4 methods that makes this screen works:setupViewModel: start to observe any changes regarding the liveDatas to show the data in the screen.setupList: here is where we add the delegate adapters for each card that we will show on the screen, and add then to the generic adapter constructor.The adapter will have 3 new types and will map it to the right delegate, resulting in the end of having: PrayerSearch.TYPE, NovenaSearch.TYPE and ChapletSearch.TYPE together with Load.TYPE, NoResults.TYPE and ErrorRetry.TYPE, that are added by default.setupSearch: input text field using RxTextView, to observe the changes when the user is typing and send it after 300 ms to the ViewModel to filter the list.setupRecyclerView: it is the setup of the recyclerView to use the generic adapter and add a divider to the list.Okay, finally we can start the fun part and really start the Compose implementation, as we have covered the most important part of the screen.2. Compose JourneyFrom here I’m going to start explaining my approach to starting the migration.As Prayers screen is the first to be migrated, I could say “I will create everything inside of prayer module”, but I don’t want to make this mistake, because later I want to update the whole app gradually, and for that I will need to breakdown the work and think in how I can scale the Compose implementation over the app.To start I have decided to create a new module called: sanctus-theme-Compose. It will hold everything related to the theme of the app. I can just add this module to the prayer dependencies and also to other modules to reuse it across the app.sanctus-theme-compose structure:Android studio screenshot — project structureSanctusAppColors: I have collected all colours over the app, and add it to this file, so it will be easy to reuse.val ColorPrimary = Color(0xFFFF5757)val ColorAccent = Color(0xFFF82222)val ColorPrimaryDark = Color(0xFFFAF7F2)val PrimaryTextColor = Color(0xFF000000)val WhiteTransparent = Color(0x52FFFFFF)val WhiteTransparent2 = Color(0x0D201E1E)val Yellow = Color(0xFFFF9800)val Gray = Color(0xFF464242)val Background = Color(0xFFF6F9FB)//there are more colors, but it is to big to show allSanctusColorScheme: this is the definition of the colours that will be used as the app theme, and here we can start to see how amazing Compose is, because it very easy to define light and dark theme colors, and support them directly in the app.val LightColorScheme = lightColorScheme( primary = ColorPrimary, secondary = ColorAccent, background = Background, surface = White, onPrimary = White, onSecondary = Black, onBackground = PrimaryTextColor, onSurface = PrimaryTextColor,)val DarkColorScheme = darkColorScheme( primary = ColorPrimary, secondary = ColorAccent, background = Gray, surface = Gray, onPrimary = White, onSecondary = White, onBackground = White, onSurface = White,)SanctusAppTypography: another amazing thing about Compose is that we can define a typography for the app and just use it on the app theme.val LatoFontFamily = FontFamily( Font(R.font.lato_light, FontWeight.Light), Font(R.font.lato_regular, FontWeight.Normal), Font(R.font.lato_black, FontWeight.Medium), Font(R.font.lato_bold, FontWeight.Bold), Font(R.font.lato_italic, FontWeight.Normal), Font(R.font.lato_bold_italic, FontWeight.Bold))val SanctusAppTypography = Typography( displayLarge = TextStyle( fontFamily = LatoFontFamily, fontWeight = FontWeight.Light, fontSize = 57.sp, lineHeight = 64.sp ), displayMedium = TextStyle( fontFamily = LatoFontFamily, fontWeight = FontWeight.Light, fontSize = 45.sp, lineHeight = 52.sp ),// there are more options, just hide it to not become way to bigSanctusAppShapes: defines three corner radii for UI elements: small (4dp), medium (8dp), and large (16dp), used for rounding corners in the app’s design.val SanctusAppShapes = Shapes( small = RoundedCornerShape(4.dp), medium = RoundedCornerShape(8.dp), large = RoundedCornerShape(16.dp))SanctusAppTheme: with all the foundation well defined, we can setup our AppTheme Compose to be used across the app, setting up the colours, typography and shapes, and taking in consideration dark mode from the device. It is so nice and easy to support dark mode from the start, without having to think about it any further.@Composablefun SanctusAppTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -\u003e Unit) { val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme MaterialTheme( colorScheme = colorScheme, typography = SanctusAppTypography, shapes = SanctusAppShapes, content = content )}Now let’s add this module to the prayer module and see how it will work.Before starting the project, I had to update several things to make the app work again. The last commit was 6 years ago, and the app was even removed from the Play Store last year(03/24). My first priority was to fix the issues and release a workable version again, which I’ve already done. I also took this opportunity to update the Gradle build system from Groovy to Kotlin DSL and began taking advantage of version catalogs.I have decided to add as api to use the Compose implementation from the the sanctus-theme-compose module:api(project(\":sanctus-theme-compose\"))Step 1: add a Compose view to the XML file for CardPrayerFragment to render the composable into the fragment, and remove the old components:\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/color_back_nav\"\u003e \u003candroidx.compose.ui.platform.ComposeView android:id=\"@+id/compose_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/\u003e\u003c/LinearLayout\u003eStep 2: access the Compose view using the view binding in the CardPrayerFragment. override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val composeView = binding.composeView composeView.setContent { SanctusAppTheme { PrayersScreen( onPrayerClicked = { prayer -\u003e startActivity(PrayersDetailActivity.newIntent(requireContext(), prayer.prayer)) }, onNovenaClicked = { novena -\u003e startActivity(NovenaFlowActivity.newIntent(requireContext(), novena.novena)) }, onChapletClicked = { chaplet -\u003e startActivity(TercoFlowActivity.newIntent(requireContext(), chaplet.terco)) } ) } } }Booomm, we have it, a brand new screen using Compose!!! But, wait, where is the implementation?gif recorded from the Sacntus AppVery simple, right? YEEESSS.It was easy to do that, because I have benefit of the koinViewModel.And I was able to take advantage of everything I was already using in the fragment, without any problems, making my migration even smoother.@Composablefun PrayersScreen( viewModel: PrayerViewModel = koinViewModel(), onPrayerClicked: (PrayerSearch) -\u003e Unit, onNovenaClicked: (NovenaSearch) -\u003e Unit, onChapletClicked: (ChapletSearch) -\u003e Unit) { val prayers by viewModel.prayersLiveData.observeAsState() prayers?.getContentIfNotHandled()?.let { list -\u003e LazyColumn { items(list) { prayer -\u003e when (prayer) { is PrayerSearch -\u003e PrayerItem(prayer, onClick = { onPrayerClicked(prayer) }) is NovenaSearch -\u003e NovenaItem(prayer, onClick = { onNovenaClicked(prayer) }) is ChapletSearch -\u003e ChapletItem(prayer, onClick = { onChapletClicked(prayer) }) } } } }}@Composablefun PrayerItem(prayer: PrayerSearch, onClick: () -\u003e Unit) { Card(onClick = onClick) { Text( text = prayer.prayer.name, style = MaterialTheme.typography.headlineLarge ) }}@Composablefun NovenaItem(prayer: NovenaSearch, onClick: () -\u003e Unit) { Card(onClick = onClick) { Text( text = prayer.novena.name, style = MaterialTheme.typography.headlineLarge ) }}@Composablefun ChapletItem(prayer: ChapletSearch, onClick: () -\u003e Unit) { Card(onClick = onClick) { Text( text = prayer.terco.name, style = MaterialTheme.typography.headlineLarge ) }}This is the first version of this screen, and I can already see some improvements. Of course there’s still a lot to refine, but having a solid architecture makes the transition to Compose much smoother. My next step is to dig deeper, rethink some parts of the app, and start creating reusable components inside the existing sanctus-components module. This way, I can add Compose components that will be used not only in this screen (prayers) but across the app, making future changes much easier.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*ODhnBGslax5QAVXTBFkuzw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@ifucolo?source=post_page---byline--7f9a8369f868---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Iago Fucolo\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*0AJPvJNIb6AVFELZgxB8-w.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--7f9a8369f868---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"6324\"\u003eBack in 2017, I started my first \u003cstrong\u003eAndroid\u003c/strong\u003e app using \u003cstrong\u003eKotlin\u003c/strong\u003e. At the time, it was just to explore the language, but later I ended up presenting it to my former colleagues to show how we could use \u003cstrong\u003eKotlin \u003c/strong\u003ein our projects since they were all written in \u003cstrong\u003eJava.\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGitHub commit screenshot\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"105d\"\u003eThe idea of the app was straightforward, helping me on my prayer journey.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"73fb\"\u003eWhy did I decide to create an app like this?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"1499\"\u003eWell, I had no better idea, so I just picked the first thing that came to mind to start writing code quickly. What mattered to me back then was learning how to use \u003cstrong\u003eKotlin\u003c/strong\u003e in Android projects.\u003c/p\u003e\u003cp id=\"9044\"\u003eIn the beginning, I was exploring what I could use to build a solid app ready for production, and I ended up using the following libraries:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"b1dc\"\u003eWhat is interest in on this build gradle file?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"4c3d\"\u003eI was already using dependency injection with \u003cstrong\u003eDagger\u003c/strong\u003e \u003cstrong\u003e2,\u003c/strong\u003e \u003cstrong\u003efirebase\u003c/strong\u003e \u003cstrong\u003ereal time data base\u003c/strong\u003e as my \u003cstrong\u003ebackend\u003c/strong\u003e and \u003cstrong\u003eRxJava\u003c/strong\u003e in order to do \u003cstrong\u003easync\u003c/strong\u003e operations, and a lot of other libraries that were very popular back then and some that are still used.\u003c/p\u003e\u003cp id=\"5cb4\"\u003eIn a month or so, I had an app ready to publish, and I did it, shipped out my first personal project to production on Google Play store.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGoogle Play version history\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2b58\"\u003eIt was my first \u003cstrong\u003epersonal\u003c/strong\u003e project in production, and it felt so good, because I finally could have my own app and use any libraries that I wanted.\u003c/p\u003e\u003cp id=\"2b54\"\u003eThe reality is very simple, it is not easy to simply add new libraries to existing projects, or even change everything in a stable code base, because with client products we need to be very careful not to break everything. In order to bring a new library or approach to an application, we need to have a solid reason for it, but in the other hand for personal projects, we can do whatever we want, because we are the owners.\u003c/p\u003e\u003cp id=\"6b08\"\u003eI was working on large projects with millions of users, so I could not change everything at once, so I thought this would be the best way to keep myself in the loop for new technologies, and to show up that we could start upcoming projects using \u003cstrong\u003eKotlin\u003c/strong\u003e and begin to migrate some of the ongoing projects.\u003c/p\u003e\u003cp id=\"44b8\"\u003eAnd it ended up very well. After 8 years, the project is still relevant for my learnings as a \u003cstrong\u003eAndroid developer\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cblockquote\u003e\u003cp id=\"5d39\"\u003e8 years ago, and now, what is happening in the Android world?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"528c\"\u003e\u003cstrong\u003eJetpack\u003c/strong\u003e \u003cstrong\u003eCompose\u003c/strong\u003e is the hottest topic in the \u003cstrong\u003eAndroid\u003c/strong\u003e world, but how can I update a project that has 8 years to use the latest libraries? So, that is what I will try to summarise in the first post of probably a series of real case of migrating \u003cstrong\u003eXML\u003c/strong\u003e views to \u003cstrong\u003eJetpack\u003c/strong\u003e \u003cstrong\u003eCompose\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"194c\"\u003eFirst step, let’s check the \u003cstrong\u003eapp\u003c/strong\u003e structure:\u003c/p\u003e\u003cp id=\"b5e1\"\u003eI have implemented basically feature \u003cstrong\u003emodules:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid studio screenshot — project structure\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"195e\"\u003eSo, as you can see it is well divided in modules and this was made around 6 years ago (2 years after the first release):\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003egit commits from the first modules creation\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"6f8b\"\u003eAnd inside of a \u003cstrong\u003efeature\u003c/strong\u003e \u003cstrong\u003emodule\u003c/strong\u003e, the structure is the following:\u003c/p\u003e\u003cp id=\"6df6\"\u003e\u003cstrong\u003e\u003cem\u003eP.S\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e: \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eprayers\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e \u003c/em\u003e\u003cstrong\u003e\u003cem\u003efeature module\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e, will be the first one to be migrated from \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eXML\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e to \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eCompose, \u003c/em\u003e\u003c/strong\u003e\u003cem\u003ethat is why I’m showing it here.\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003efeature module structure\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"02ed\"\u003eNow as it is a bit more clear about the whole project structure, let’s dive into the \u003cstrong\u003eUI\u003c/strong\u003e folder of the \u003cstrong\u003eprayer module\u003c/strong\u003e, to understand how we can start the migration to \u003cstrong\u003eCompose\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"d408\"\u003eBut first, I want to show the first screen that will be migrated: \u003cstrong\u003eCardPrayersFragment.\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003egif recorded from the Sanctus App\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"dac0\"\u003eThis is the \u003cstrong\u003eCardPrayerFragment\u003c/strong\u003e, which is one of the 4 main screens of the \u003cstrong\u003eapp\u003c/strong\u003e, as it is part of the \u003cstrong\u003ebottom\u003c/strong\u003e \u003cstrong\u003etab\u003c/strong\u003e \u003cstrong\u003enavigation\u003c/strong\u003e entry points. So let me explain how this screen was implemented, to understand how complex it will be to migrate to \u003cstrong\u003eCompose\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"eb4c\"\u003e\u003cstrong\u003eStructure of the ui package regarding the Prayers feature:\u003c/strong\u003e\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid studio screenshot — project structure\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"3246\"\u003eCardsPrayerFragment:\u003c/h2\u003e\u003cp id=\"f4f5\"\u003eThis the main class of the \u003cstrong\u003efeature/screen\u003c/strong\u003e, where the list of \u003cstrong\u003eprayers\u003c/strong\u003e and \u003cstrong\u003efilters\u003c/strong\u003e are implemented. Let’s take a look at the \u003cstrong\u003eXML\u003c/strong\u003e of this screen:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"93fa\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;LinearLayout\u003cbr/\u003e    xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u003cbr/\u003e    android:orientation=\u0026#34;vertical\u0026#34;\u003cbr/\u003e    android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:layout_height=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:background=\u0026#34;@color/color_back_nav\u0026#34;\u0026gt;\u003cp\u003e        \u0026lt;LinearLayout\u003cbr/\u003e        android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;wrap_content\u0026#34;\u003cbr/\u003e        android:orientation=\u0026#34;vertical\u0026#34;\u003cbr/\u003e        android:background=\u0026#34;@android:color/white\u0026#34;\u0026gt;\u003c/p\u003e\u003cp\u003e        \u0026lt;EditText\u003cbr/\u003e            android:id=\u0026#34;@+id/edtSearch\u0026#34;\u003cbr/\u003e            android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e            android:layout_height=\u0026#34;wrap_content\u0026#34;\u003cbr/\u003e            android:drawableStart=\u0026#34;@drawable/ic_search\u0026#34;\u003cbr/\u003e            android:drawablePadding=\u0026#34;@dimen/margin_view\u0026#34;\u003cbr/\u003e            android:padding=\u0026#34;@dimen/little_margin_view\u0026#34;\u003cbr/\u003e            android:layout_marginTop=\u0026#34;@dimen/little_margin_view\u0026#34;\u003cbr/\u003e            android:layout_marginStart=\u0026#34;@dimen/margin_view\u0026#34;\u003cbr/\u003e            android:layout_marginEnd=\u0026#34;@dimen/margin_view\u0026#34;\u003cbr/\u003e            android:layout_marginBottom=\u0026#34;@dimen/margin_view\u0026#34;\u003cbr/\u003e            android:maxLines=\u0026#34;1\u0026#34;\u003cbr/\u003e            android:inputType=\u0026#34;text\u0026#34;\u003cbr/\u003e            android:imeOptions=\u0026#34;actionGo\u0026#34;\u003cbr/\u003e            android:background=\u0026#34;@drawable/bg_rounded_black_transparent\u0026#34;/\u0026gt;\u003c/p\u003e\u003cp\u003e        \u0026lt;com.evangelhododiacatolico.prayers.ui.filter.FilterView\u003cbr/\u003e            android:id=\u0026#34;@+id/filterView\u0026#34;\u003cbr/\u003e            android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e            android:layout_height=\u0026#34;wrap_content\u0026#34;\u003cbr/\u003e            android:layout_marginBottom=\u0026#34;@dimen/margin_view\u0026#34;/\u0026gt;\u003c/p\u003e\u003cp\u003e    \u0026lt;/LinearLayout\u0026gt;\u003c/p\u003e\u003cp\u003e        \u0026lt;View\u003cbr/\u003e        android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;2dp\u0026#34;\u003cbr/\u003e        android:background=\u0026#34;@color/color_line\u0026#34;/\u0026gt;\u003c/p\u003e\u003cp\u003e    \u0026lt;androidx.recyclerview.widget.RecyclerView\u003cbr/\u003e        android:id=\u0026#34;@+id/recyclerView\u0026#34;\u003cbr/\u003e        android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e        android:clipToPadding=\u0026#34;false\u0026#34;\u003cbr/\u003e        android:paddingTop=\u0026#34;@dimen/margin_view\u0026#34;/\u0026gt;\u003c/p\u003e\u003cp\u003e\u0026lt;/LinearLayout\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2c06\"\u003e\u003cstrong\u003eedtSearch\u003c/strong\u003e: is just the search box, to find prayers by typing.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eedtSearch\u003c/strong\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"52b3\"\u003e\u003cstrong\u003eFilterView: \u003c/strong\u003eit is a custom component created to setup filters, by \u003cstrong\u003eFilterType,\u003c/strong\u003e which consist in a horizontal \u003cstrong\u003erecyclerView\u003c/strong\u003e that holds the filters options.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eFilterView\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2d18\"\u003eI have 3 filter types that are defined in the \u003cstrong\u003eFilterType\u003c/strong\u003e sealed class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"110a\"\u003esealed class FilterType {\u003cbr/\u003e    object TercoMain: FilterType()\u003cbr/\u003e    object NovenaMain: FilterType()\u003cbr/\u003e    sealed class PrayerMain: FilterType() {\u003cbr/\u003e        object Prayer: PrayerMain()\u003cbr/\u003e        object SubCategory: PrayerMain()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"935b\"\u003eAnd then, I custom \u003cstrong\u003eFilterItem\u003c/strong\u003e to hold the filter type, and some options to customize the \u003cstrong\u003eUI\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6de1\"\u003edata class FilterItem(\u003cbr/\u003e    val tag: String, //text that shows in the UI\u003cbr/\u003e    val backgroundDrawable: Int,  //backhground when isActive = true\u003cbr/\u003e    val backgroundDrawableDeactive: Int,  //backhground when isActive = false\u003cbr/\u003e    var isActive: Boolean = true,  // definition if the is On or Off\u003cbr/\u003e    val type: FilterType // the type of the filter\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f93d\"\u003eTo start using the \u003cstrong\u003eFilterView\u003c/strong\u003e, the screen that is having it in the XML needs to call the \u003cstrong\u003esetupFilter:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"627d\"\u003eclass FilterView @JvmOverloads constructor(\u003cbr/\u003e    context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0\u003cbr/\u003e) : LinearLayout(context, attrs, defStyleAttr) {\u003cp\u003e    private val binding: ViewFilterBinding =\u003cbr/\u003e        ViewFilterBinding.inflate(LayoutInflater.from(context), this, true)\u003c/p\u003e\u003cp\u003e    private var filterAdapter: FilterAdapter? = null\u003c/p\u003e\u003cp\u003e    fun setupFilter(\u003cbr/\u003e         filters: List\u0026lt;FilterItem\u0026gt;, \u003cbr/\u003e         listener: (FilterItem) -\u0026gt; Unit\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e                 filterAdapter = FilterAdapter(\u003cbr/\u003e            filters = filters,\u003cbr/\u003e            onClickListener = {\u003cbr/\u003e                val index = filters.indexOf(it)\u003cbr/\u003e                it.isActive = !it.isActive\u003c/p\u003e\u003cp\u003e                filterAdapter?.notifyItemChanged(index)\u003cbr/\u003e                onClickListener(it)\u003cbr/\u003e            }\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        binding.filterList.layoutManager = LinearLayoutManager(context, RecyclerView.HORIZONTAL, false)\u003cbr/\u003e        binding.filterList.adapter = filterAdapter\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7e4d\"\u003eThis is a custom view that sets up a horizontal filter list using a \u003cstrong\u003eRecyclerView\u003c/strong\u003e. First, it binds the view to access the \u003cstrong\u003eXML\u003c/strong\u003e components. Then, the \u003cstrong\u003esetupFilter\u003c/strong\u003e function initialises a \u003cstrong\u003eFilterAdapter\u003c/strong\u003e to populate the list with filter items. The adapter takes a \u003cstrong\u003ehigh-order function\u003c/strong\u003e to handle item clicks, toggling the \u003cstrong\u003eisActive\u003c/strong\u003e state and notifying the adapter to update the \u003cstrong\u003eUI\u003c/strong\u003e. Finally, the \u003cstrong\u003eRecyclerView\u003c/strong\u003e is set to a \u003cstrong\u003ehorizontal\u003c/strong\u003e layout, and the \u003cstrong\u003eadapter\u003c/strong\u003e is attached.\u003c/p\u003e\u003cp id=\"8ce9\"\u003e\u003cstrong\u003eFilterAdapter\u003c/strong\u003e: This defines how each filter item is displayed in the list. It binds the data to the UI, updating the \u003cstrong\u003etag text\u003c/strong\u003e and \u003cstrong\u003ebackground\u003c/strong\u003e based on whether the \u003cstrong\u003efilter\u003c/strong\u003e is active or not. It also handles click events, passing the clicked item back through a \u003cstrong\u003ehigh-order function\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3beb\"\u003eclass FilterAdapter(\u003cbr/\u003e    val filters: List\u0026lt;FilterItem\u0026gt;,\u003cbr/\u003e    val onClickListener: (FilterItem) -\u0026gt; Unit\u003cbr/\u003e): RecyclerView.Adapter\u0026lt;FilterAdapter.FilterViewHolder\u0026gt;() {\u003cp\u003e    inner class FilterViewHolder(\u003cbr/\u003e        private val binding: ItemFilterBinding\u003cbr/\u003e    ) : RecyclerView.ViewHolder(binding.root){\u003cbr/\u003e        fun bind(filter: FilterItem) = with(binding) {\u003cbr/\u003e            val context = binding.root.context\u003cbr/\u003e            txtTag.text = filter.tag\u003c/p\u003e\u003cp\u003e            when(filter.isActive) {\u003cbr/\u003e                true -\u0026gt;  txtTag.background = ContextCompat.getDrawable(context, filter.backgroundDrawable)\u003cbr/\u003e                else -\u0026gt;  txtTag.background = ContextCompat.getDrawable(context, filter.backgroundDrawableDeactive)\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            binding.root.setOnClickListener {\u003cbr/\u003e                onClickListener.invoke(filter)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): FilterViewHolder {\u003cbr/\u003e        val binding = ItemFilterBinding.inflate(LayoutInflater.from(parent.context), parent, false)\u003cbr/\u003e        return FilterViewHolder(binding)\u003cbr/\u003e    }\u003cbr/\u003e    override fun getItemCount(): Int = filters.size\u003cbr/\u003e    override fun onBindViewHolder(viewHolder: FilterViewHolder, position: Int) = viewHolder.bind(filters[position])\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1951\"\u003eFilters are explained, now let’s check the list of prayers implementation.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eList of prayers from the Sanctus App\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"368b\"\u003e\u003cstrong\u003eRecyclerView — List of prayers\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"8d60\"\u003eHere I need to explain a little deeper how lists in general are implemented in the whole app.\u003c/p\u003e\u003cp id=\"2cce\"\u003eYou can skip it if you want, but I found it very important to understand how it was and how it will be with Compose, but feel free to move forward.\u003c/p\u003e\u003cp id=\"a634\"\u003eMy approach to handling lists was creating a \u003cstrong\u003eGenericAdapter\u003c/strong\u003e using the delegate adapters pattern. Each delegate has a specific type, and the \u003cstrong\u003eGenericAdapter\u003c/strong\u003e includes predefined types such as \u003cstrong\u003eLoad, NoResult, \u003c/strong\u003eand \u003cstrong\u003eErrorRetry\u003c/strong\u003e. These can be reused across different scenarios, making the solution more scalable and preventing the need to re-implement these cases for every list in the app\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0074\"\u003eclass GenericAdapter(\u003cbr/\u003e    lifecycleOwner: LifecycleOwner,\u003cbr/\u003e    private var items: ArrayList\u0026lt;ViewType\u0026gt;,\u003cbr/\u003e    private var delegateAdapters : SparseArrayCompat\u0026lt;ViewTypeDelegateAdapter\u0026gt;\u003cbr/\u003e): RecyclerView.Adapter\u0026lt;RecyclerView.ViewHolder\u0026gt;() {\u003cp\u003e    private val _errorLiveData = MutableLiveData\u0026lt;Throwable\u0026gt;()\u003cbr/\u003e    val errorLiveData: LiveData\u0026lt;Throwable\u0026gt; = _errorLiveData\u003c/p\u003e\u003cp\u003e    init {\u003cbr/\u003e        val adapters = listOf(\u003cbr/\u003e            Load.TYPE to LoadDelegateAdapter(),\u003cbr/\u003e            NoResults.TYPE to NoResultsDelegateAdapter(),\u003cbr/\u003e            ErrorRetry.TYPE to ErrorDelegateAdapter().apply {\u003cbr/\u003e                errorLiveData.observe(lifecycleOwner) {\u003cbr/\u003e                    updateList(listOf(Load()))\u003cbr/\u003e                    _errorLiveData.postValue(it)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        adapters.forEach { (type, adapter) -\u0026gt;\u003cbr/\u003e            delegateAdapters.put(type, adapter)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        items = arrayListOf(Load())\u003cbr/\u003e    }\u003cbr/\u003e    override fun getItemCount(): Int = items.size\u003c/p\u003e\u003cp\u003e        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder {\u003cbr/\u003e        val delegateAdapter = delegateAdapters.get(viewType)\u003cbr/\u003e        return delegateAdapter?.onCreateViewHolder(parent)\u003cbr/\u003e            ?: object : RecyclerView.ViewHolder(parent) {}\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) {\u003cbr/\u003e        val delegateAdapter = delegateAdapters.get(getItemViewType(position))\u003cbr/\u003e        delegateAdapter?.onBindViewHolder(position, holder, items[position])\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun getItemViewType(position: Int) = items[position].getViewType()\u003c/p\u003e\u003cp\u003e    fun updateList(newList: List\u0026lt;ViewType\u0026gt;, query: String = \u0026#34;\u0026#34;) {\u003cbr/\u003e        if (items.firstOrNull() is Load) {\u003cbr/\u003e            items.removeAt(0)\u003cbr/\u003e            notifyItemRemoved(0)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        if (newList.isEmpty()) {\u003cbr/\u003e            items.add(NoResults(query = query))\u003cbr/\u003e            notifyItemInserted(items.size - 1)\u003cbr/\u003e        } else {\u003cbr/\u003e            val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, newList))\u003cbr/\u003e            items.clear()\u003cbr/\u003e            items.addAll(newList)\u003cbr/\u003e            diffResult.dispatchUpdatesTo(this)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun resetList(\u003cbr/\u003e        newList: List\u0026lt;ViewType\u0026gt;,\u003cbr/\u003e        query: String = \u0026#34;\u0026#34;\u003cbr/\u003e    ) {\u003cbr/\u003e        if (newList.isEmpty()) {\u003cbr/\u003e            val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, listOf(NoResults(query))))\u003cbr/\u003e            items.clear()\u003cbr/\u003e            items.add(NoResults(query))\u003cbr/\u003e            diffResult.dispatchUpdatesTo(this)\u003cbr/\u003e        } else {\u003cbr/\u003e            val diffResult = DiffUtil.calculateDiff(ViewTypeDiffCallback(items, newList))\u003cbr/\u003e            items.clear()\u003cbr/\u003e            items.addAll(newList)\u003cbr/\u003e            diffResult.dispatchUpdatesTo(this)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun showError(throwable: Throwable, color: Int = Color.BLACK) {\u003cbr/\u003e        resetList(listOf(ErrorRetry(throwable, color)))\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ad1b\"\u003e\u003cstrong\u003eInit\u003c/strong\u003e: I have setup as default \u003cstrong\u003e3 delegate types\u003c/strong\u003e, as explained above, but want to add the \u003cstrong\u003eErrorRetry\u003c/strong\u003e explanation: when it is present there is a \u003cstrong\u003eliveData\u003c/strong\u003e, which fires the retry event when the user clicks on retry button, so the view that is implementing the \u003cstrong\u003eGenericAdapter\u003c/strong\u003e can benefit of this error handling.\u003c/p\u003e\u003cp id=\"cb57\"\u003e\u003cstrong\u003egetItemsCount\u003c/strong\u003e, \u003cstrong\u003eonCreateViewHolder\u003c/strong\u003e, and \u003cstrong\u003eonBindViewHolder\u003c/strong\u003e, are just recycler view holder methods, and \u003cstrong\u003egetItemViewType \u003c/strong\u003eis the key of getting the correct delegate to show, so as you can see it is implemented for all types:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid studio screenshot — project structure\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f0c7\"\u003eSo the generic adapter rely on the \u003cstrong\u003eViewType,\u003c/strong\u003e which is used for the whole app. Back 6 years ago, it was the way that I have found in order to have a more scalable list and components over the application.\u003c/p\u003e\u003cp id=\"ec1b\"\u003eAnd \u003cstrong\u003eupdateList\u003c/strong\u003e, \u003cstrong\u003eresetList \u003c/strong\u003eand \u003cstrong\u003eshowError \u003c/strong\u003eare used to update the list with new data and show errors when it is necessary.\u003c/p\u003e\u003cp id=\"e0c1\"\u003eIt takes too long, but we are getting there. Now we can check the \u003cstrong\u003eCardPrayerFragment\u003c/strong\u003e, which uses all the above things that were explained.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"494e\"\u003eFirst, a diagram to show where the data is coming from, because the idea is not to explain the whole architecture of the app, but an overview is great:\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003cfigcaption\u003eSanctus App diagram\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"8b85\"\u003eSo basically, the data comes from 3 different places, \u003cstrong\u003eNovena\u003c/strong\u003e \u003cstrong\u003emodule\u003c/strong\u003e which is responsable for \u003cstrong\u003eNovenas\u003c/strong\u003e , \u003cstrong\u003eTerco\u003c/strong\u003e \u003cstrong\u003emodule\u003c/strong\u003e which is responsable for the \u003cstrong\u003eTercos\u003c/strong\u003e data, and \u003cstrong\u003ePrayers\u003c/strong\u003e data source, is part of the \u003cstrong\u003eprayers module\u003c/strong\u003e, after fetching the data, which can be from the \u003cstrong\u003ebackend(firebase)\u003c/strong\u003e or directly from the \u003cstrong\u003edatabase\u003c/strong\u003e, which for the \u003cstrong\u003eUI \u003c/strong\u003edoes not matter, as the \u003cstrong\u003ePrayerViewModel\u003c/strong\u003e is asking it to \u003cstrong\u003ePrayersUseCase\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"d388\"\u003eLet’s check how the \u003cstrong\u003eCardPrayerFragment\u003c/strong\u003e looks like:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3407\"\u003eclass CardPrayerFragment: BaseFragmentX(R.layout.fragment_prayer) {\u003cp\u003e    private val viewModel: PrayerViewModel by viewModel()\u003c/p\u003e\u003cp\u003e    private val crashLogs: CrashLogs by inject()\u003cbr/\u003e    private lateinit var genericAdapter: GenericAdapter\u003cbr/\u003e    private val unsubscribeOnDestroy = CompositeDisposable()\u003cbr/\u003e    private lateinit var binding: FragmentPrayerBinding\u003c/p\u003e\u003cp\u003e    companion object {\u003cbr/\u003e        fun newInstance(): CardPrayerFragment {\u003cbr/\u003e            return CardPrayerFragment()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onCreateView(\u003cbr/\u003e        inflater: LayoutInflater,\u003cbr/\u003e        container: ViewGroup?,\u003cbr/\u003e        savedInstanceState: Bundle?\u003cbr/\u003e    ): View {\u003cbr/\u003e        binding = FragmentPrayerBinding.inflate(layoutInflater)\u003cbr/\u003e        return binding.root\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onViewCreated(view, savedInstanceState)\u003c/p\u003e\u003cp\u003e        setupViewModel()\u003cbr/\u003e        setupList()\u003cbr/\u003e        setupRecyclerView()\u003cbr/\u003e        setupSearch()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun onDestroy() {\u003cbr/\u003e        super.onDestroy()\u003cbr/\u003e        unsubscribeOnDestroy.clear()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun setupViewModel() {\u003cbr/\u003e        viewModel.init()\u003c/p\u003e\u003cp\u003e        viewModel.prayersLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it?.getContentIfNotHandled()?.let {\u003cbr/\u003e                genericAdapter.updateList(it)\u003cbr/\u003e            }\u003cbr/\u003e        })\u003c/p\u003e\u003cp\u003e        viewModel.updatePrayersLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it?.getContentIfNotHandled()?.let {\u003cbr/\u003e                genericAdapter.resetList(it, binding.edtSearch.text.toString())\u003cbr/\u003e            }\u003cbr/\u003e        })\u003cbr/\u003e        viewModel.errorRetryLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it?.getContentIfNotHandled()?.let {\u003cbr/\u003e                genericAdapter.showError(it)\u003cbr/\u003e            }\u003cbr/\u003e        })\u003cbr/\u003e        viewModel.filtersLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it?.getContentIfNotHandled()?.let { filters -\u0026gt;\u003cbr/\u003e                binding.filterView.setupFilter(filters) { filter -\u0026gt;\u003cbr/\u003e                    viewModel.filter(filter)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        })\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun setupSearch() {\u003cbr/\u003e        binding.edtSearch.setOnEditorActionListener { _, actionId, _ -\u0026gt;\u003cbr/\u003e            if (actionId == EditorInfo.IME_ACTION_GO) {\u003cbr/\u003e                binding.edtSearch.dismissKeyboard()\u003cbr/\u003e            }\u003cbr/\u003e            true\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        RxTextView.textChanges(binding.edtSearch)\u003cbr/\u003e            .skipInitialValue()\u003cbr/\u003e            .debounce(300, TimeUnit.MILLISECONDS)\u003cbr/\u003e            .subscribeBy(\u003cbr/\u003e                onNext = {\u003cbr/\u003e                    viewModel.search(it.toString())\u003cbr/\u003e                },\u003cbr/\u003e                onError = {\u003cbr/\u003e                    crashLogs.logException(it)\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e            .addTo(unsubscribeOnDestroy)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun setupList() {\u003cbr/\u003e        val delegateAdapters = SparseArrayCompat\u0026lt;ViewTypeDelegateAdapter\u0026gt;()\u003c/p\u003e\u003cp\u003e        val searchChapletDelegateAdapter = SearchChapletDelegateAdapter()\u003cbr/\u003e        searchChapletDelegateAdapter.tercoSearchLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it.getContentIfNotHandled()?.let {\u003cbr/\u003e                startActivity(TercoFlowActivity.newIntent(requireContext(), it))\u003cbr/\u003e            }\u003cbr/\u003e        })\u003c/p\u003e\u003cp\u003e        val searchNovenaDelegateAdapter = SearchNovenaDelegateAdapter()\u003cbr/\u003e        searchNovenaDelegateAdapter.novenaSearchLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it.getContentIfNotHandled()?.let {\u003cbr/\u003e                startActivity(NovenaFlowActivity.newIntent(requireContext(), it))\u003cbr/\u003e            }\u003cbr/\u003e        })\u003c/p\u003e\u003cp\u003e        val searchPrayerDelegateAdapter = SearchPrayerDelegateAdapter()\u003cbr/\u003e        searchPrayerDelegateAdapter.prayerSearchLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            it.getContentIfNotHandled()?.let {\u003cbr/\u003e                startActivity(PrayersDetailActivity.newIntent(requireContext(), it))\u003cbr/\u003e            }\u003cbr/\u003e        })\u003c/p\u003e\u003cp\u003e        delegateAdapters.put(PrayerSearch.TYPE, searchPrayerDelegateAdapter)\u003cbr/\u003e        delegateAdapters.put(NovenaSearch.TYPE, searchNovenaDelegateAdapter)\u003cbr/\u003e        delegateAdapters.put(ChapletSearch.TYPE, searchChapletDelegateAdapter)\u003c/p\u003e\u003cp\u003e        genericAdapter = GenericAdapter(\u003cbr/\u003e            this,\u003cbr/\u003e            arrayListOf(),\u003cbr/\u003e            delegateAdapters\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        genericAdapter.errorLiveData.observe(viewLifecycleOwner, Observer {\u003cbr/\u003e            viewModel.init()\u003cbr/\u003e        })\u003c/p\u003e\u003cp\u003e        setupRecyclerView()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private fun setupRecyclerView() = with(binding.recyclerView) {\u003cbr/\u003e        layoutManager = LinearLayoutManager(context)\u003c/p\u003e\u003cp\u003e        val decor = DividerItemDecoration(context, DividerItemDecoration.VERTICAL)\u003cbr/\u003e        decor.setDrawable(context.resources.getDrawable(R.drawable.divider2))\u003cbr/\u003e        addItemDecoration(decor)\u003c/p\u003e\u003cp\u003e        adapter = genericAdapter\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"9ec7\"\u003eJust want to mention that I’m using \u003ca href=\"https://insert-koin.io\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKoin\u003c/strong\u003e\u003c/a\u003e as DI. I started with dagger but, later on I have decided to experiment K\u003cstrong\u003eoin\u003c/strong\u003e as a learning thing 7 years ago - 1 year after the first release.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"b2bd\"\u003eLet’s check the 4 \u003cstrong\u003emethods\u003c/strong\u003e that makes this screen works:\u003c/p\u003e\u003cp id=\"06fa\"\u003e\u003cstrong\u003esetupViewModel: \u003c/strong\u003estart to observe any changes regarding the \u003cstrong\u003eliveDatas\u003c/strong\u003e to show the data in the screen.\u003c/p\u003e\u003cp id=\"e14e\"\u003e\u003cstrong\u003esetupList: \u003c/strong\u003ehere is where we add the \u003cstrong\u003edelegate\u003c/strong\u003e adapters for each card that we will show on the screen, and add then to the generic adapter constructor.\u003c/p\u003e\u003cp id=\"7de6\"\u003eThe adapter will have 3 new types and will map it to the right delegate, resulting in the end of having: \u003cstrong\u003ePrayerSearch.TYPE\u003c/strong\u003e, \u003cstrong\u003eNovenaSearch.TYPE\u003c/strong\u003e and \u003cstrong\u003eChapletSearch.TYPE \u003c/strong\u003etogether with \u003cstrong\u003eLoad.TYPE\u003c/strong\u003e, \u003cstrong\u003eNoResults.TYPE\u003c/strong\u003e and \u003cstrong\u003eErrorRetry.TYPE, \u003c/strong\u003ethat are added by default.\u003c/p\u003e\u003cp id=\"36db\"\u003e\u003cstrong\u003esetupSearch: \u003c/strong\u003einput text field using \u003ca href=\"https://github.com/JakeWharton/RxBinding\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRxTextView\u003c/a\u003e, to observe the changes when the user is typing and send it after 300 ms to the \u003cstrong\u003eViewModel\u003c/strong\u003e to filter the list.\u003c/p\u003e\u003cp id=\"b18b\"\u003e\u003cstrong\u003esetupRecyclerView: \u003c/strong\u003eit is the setup of the \u003cstrong\u003erecyclerView\u003c/strong\u003e to use the generic adapter and add a divider to the list.\u003c/p\u003e\u003cp id=\"eac0\"\u003eOkay, finally we can start the fun part and really start the Compose implementation, as we have covered the most important part of the screen.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9be9\"\u003e2. Compose Journey\u003c/h2\u003e\u003cp id=\"abb8\"\u003eFrom here I’m going to start explaining my approach to starting the migration.\u003c/p\u003e\u003cp id=\"ef9f\"\u003eAs Prayers screen is the first to be migrated, I could say “\u003cem\u003eI will create everything inside of \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eprayer module”\u003c/em\u003e,\u003c/strong\u003e but I don’t want to make this mistake, because later I want to update the whole app gradually, and for that I will need to breakdown the work and think in how I can scale the Compose implementation over the app.\u003c/p\u003e\u003cp id=\"2ae0\"\u003eTo start I have decided to create a new module called: \u003cstrong\u003esanctus-theme-Compose. \u003c/strong\u003eIt will hold everything related to the theme of the app. I can just add this module to the prayer dependencies and also to other modules to reuse it across the app.\u003c/p\u003e\u003cp id=\"2497\"\u003e\u003cstrong\u003esanctus-theme-compose\u003c/strong\u003e structure:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAndroid studio screenshot — project structure\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"3179\"\u003e\u003cstrong\u003eSanctusAppColors: \u003c/strong\u003eI have collected all colours over the app, and add it to this file, so it will be easy to reuse.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ee15\"\u003eval ColorPrimary = Color(0xFFFF5757)\u003cbr/\u003eval ColorAccent = Color(0xFFF82222)\u003cbr/\u003eval ColorPrimaryDark = Color(0xFFFAF7F2)\u003cbr/\u003eval PrimaryTextColor = Color(0xFF000000)\u003cp\u003eval WhiteTransparent = Color(0x52FFFFFF)\u003cbr/\u003eval WhiteTransparent2 = Color(0x0D201E1E)\u003c/p\u003e\u003cp\u003eval Yellow = Color(0xFFFF9800)\u003c/p\u003e\u003cp\u003eval Gray = Color(0xFF464242)\u003cbr/\u003eval Background = Color(0xFFF6F9FB)\u003c/p\u003e\u003cp\u003e//there are more colors, but it is to big to show all\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7cc6\"\u003e\u003cstrong\u003eSanctusColorScheme: \u003c/strong\u003ethis is the definition of the colours that will be used as the \u003cstrong\u003eapp theme\u003c/strong\u003e, and here we can start to see how amazing Compose is, because it very easy to define \u003cstrong\u003elight\u003c/strong\u003e and \u003cstrong\u003edark\u003c/strong\u003e theme colors, and support them directly in the app.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ac1e\"\u003eval LightColorScheme = lightColorScheme(\u003cbr/\u003e    primary = ColorPrimary,\u003cbr/\u003e    secondary = ColorAccent,\u003cbr/\u003e    background = Background,\u003cbr/\u003e    surface = White,\u003cbr/\u003e    onPrimary = White,\u003cbr/\u003e    onSecondary = Black,\u003cbr/\u003e    onBackground = PrimaryTextColor,\u003cbr/\u003e    onSurface = PrimaryTextColor,\u003cbr/\u003e)\u003cp\u003eval DarkColorScheme = darkColorScheme(\u003cbr/\u003e    primary = ColorPrimary,\u003cbr/\u003e    secondary = ColorAccent,\u003cbr/\u003e    background = Gray,\u003cbr/\u003e    surface = Gray,\u003cbr/\u003e    onPrimary = White,\u003cbr/\u003e    onSecondary = White,\u003cbr/\u003e    onBackground = White,\u003cbr/\u003e    onSurface = White,\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"504e\"\u003e\u003cstrong\u003eSanctusAppTypography: \u003c/strong\u003eanother amazing thing about Compose is that we can define a typography for the app and just use it on the \u003cstrong\u003eapp theme\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cd45\"\u003eval LatoFontFamily = FontFamily(\u003cbr/\u003e    Font(R.font.lato_light, FontWeight.Light),\u003cbr/\u003e    Font(R.font.lato_regular, FontWeight.Normal),\u003cbr/\u003e    Font(R.font.lato_black, FontWeight.Medium),\u003cbr/\u003e    Font(R.font.lato_bold, FontWeight.Bold),\u003cbr/\u003e    Font(R.font.lato_italic, FontWeight.Normal),\u003cbr/\u003e    Font(R.font.lato_bold_italic, FontWeight.Bold)\u003cbr/\u003e)\u003cp\u003eval SanctusAppTypography = Typography(\u003cbr/\u003e    displayLarge = TextStyle(\u003cbr/\u003e        fontFamily = LatoFontFamily,\u003cbr/\u003e        fontWeight = FontWeight.Light,\u003cbr/\u003e        fontSize = 57.sp,\u003cbr/\u003e        lineHeight = 64.sp\u003cbr/\u003e    ),\u003cbr/\u003e    displayMedium = TextStyle(\u003cbr/\u003e        fontFamily = LatoFontFamily,\u003cbr/\u003e        fontWeight = FontWeight.Light,\u003cbr/\u003e        fontSize = 45.sp,\u003cbr/\u003e        lineHeight = 52.sp\u003cbr/\u003e    ),\u003cbr/\u003e// there are more options, just hide it to not become way to big\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6c8e\"\u003e\u003cstrong\u003eSanctusAppShapes: \u003c/strong\u003edefines three corner radii for UI elements: small (\u003cstrong\u003e4dp\u003c/strong\u003e), medium (\u003cstrong\u003e8dp\u003c/strong\u003e), and large (\u003cstrong\u003e16dp\u003c/strong\u003e), used for rounding corners in the app’s design.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6e60\"\u003eval SanctusAppShapes = Shapes(\u003cbr/\u003e    small = RoundedCornerShape(4.dp),\u003cbr/\u003e    medium = RoundedCornerShape(8.dp),\u003cbr/\u003e    large = RoundedCornerShape(16.dp)\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9567\"\u003e\u003cstrong\u003eSanctusAppTheme: \u003c/strong\u003ewith all the foundation well defined, we can setup our \u003cstrong\u003eAppTheme\u003c/strong\u003e Compose to be used across the app, setting up the \u003cstrong\u003ecolours\u003c/strong\u003e, \u003cstrong\u003etypography\u003c/strong\u003e and \u003cstrong\u003eshapes\u003c/strong\u003e, and taking in consideration \u003cstrong\u003edark\u003c/strong\u003e \u003cstrong\u003emode\u003c/strong\u003e from the device. It is so nice and easy to support dark mode from the start, without having to think about it any further.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bcc0\"\u003e@Composable\u003cbr/\u003efun SanctusAppTheme(\u003cbr/\u003e    darkTheme: Boolean = isSystemInDarkTheme(),\u003cbr/\u003e    content: @Composable () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme\u003cp\u003e    MaterialTheme(\u003cbr/\u003e        colorScheme = colorScheme,\u003cbr/\u003e        typography = SanctusAppTypography,\u003cbr/\u003e        shapes = SanctusAppShapes,\u003cbr/\u003e        content = content\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1ab2\"\u003eNow let’s add this module to the prayer module and see how it will work.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c85b\"\u003eBefore starting the project, I had to update several things to make the app work again. The last commit was 6 years ago, and the app was even removed from the Play Store last year(03/24). My first priority was to fix the issues and release a workable version again, which I’ve already done. I also took this opportunity to update the Gradle build system from Groovy to Kotlin DSL and began taking advantage of \u003ca href=\"https://developer.android.com/build/migrate-to-catalogs\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eversion catalogs\u003c/a\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"63d0\"\u003eI have decided to add as \u003cstrong\u003eapi\u003c/strong\u003e to use the Compose implementation from the the s\u003cstrong\u003eanctus-theme-compose\u003c/strong\u003e module:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fbc5\"\u003eapi(project(\u0026#34;:sanctus-theme-compose\u0026#34;))\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"146a\"\u003e\u003cstrong\u003eStep 1\u003c/strong\u003e: add a Compose view to the \u003cstrong\u003eXML\u003c/strong\u003e file for \u003cstrong\u003eCardPrayerFragment\u003c/strong\u003e to render the composable into the fragment, and remove the old components:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7a66\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt;\u003cbr/\u003e\u0026lt;LinearLayout\u003cbr/\u003e    xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u003cbr/\u003e    xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u003cbr/\u003e    android:orientation=\u0026#34;vertical\u0026#34;\u003cbr/\u003e    android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:layout_height=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e    android:background=\u0026#34;@color/color_back_nav\u0026#34;\u0026gt;\u003cp\u003e    \u0026lt;androidx.compose.ui.platform.ComposeView\u003cbr/\u003e        android:id=\u0026#34;@+id/compose_view\u0026#34;\u003cbr/\u003e        android:layout_width=\u0026#34;match_parent\u0026#34;\u003cbr/\u003e        android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt;\u003c/p\u003e\u003cp\u003e\u0026lt;/LinearLayout\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"03f9\"\u003e\u003cstrong\u003eStep 2: \u003c/strong\u003eaccess the Compose view using the view binding in the \u003cstrong\u003eCardPrayerFragment\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0741\"\u003e override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onViewCreated(view, savedInstanceState)\u003cp\u003e        val composeView = binding.composeView\u003cbr/\u003e        composeView.setContent {\u003cbr/\u003e            SanctusAppTheme {\u003cbr/\u003e                PrayersScreen(\u003cbr/\u003e                    onPrayerClicked = { prayer -\u0026gt;\u003cbr/\u003e                        startActivity(PrayersDetailActivity.newIntent(requireContext(), prayer.prayer))\u003cbr/\u003e                    },\u003cbr/\u003e                    onNovenaClicked = { novena -\u0026gt;\u003cbr/\u003e                        startActivity(NovenaFlowActivity.newIntent(requireContext(), novena.novena))\u003cbr/\u003e                    },\u003cbr/\u003e                    onChapletClicked = { chaplet -\u0026gt;\u003cbr/\u003e                        startActivity(TercoFlowActivity.newIntent(requireContext(), chaplet.terco))\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e          }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fba9\"\u003eBooomm, we have it, a brand new screen using \u003cstrong\u003eCompose\u003c/strong\u003e!!! But, wait, where is the implementation?\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003egif recorded from the Sacntus App\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a337\"\u003eVery simple, right? YEEESSS.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"40d3\"\u003eIt was easy to do that, because I have benefit of the \u003cstrong\u003ekoinViewModel\u003c/strong\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"ebf6\"\u003eAnd I was able to take advantage of everything I was already using in the fragment, without any problems, making my migration even smoother.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e4e\"\u003e@Composable\u003cbr/\u003efun PrayersScreen(\u003cbr/\u003e    viewModel: PrayerViewModel = koinViewModel(),\u003cbr/\u003e    onPrayerClicked: (PrayerSearch) -\u0026gt; Unit,\u003cbr/\u003e    onNovenaClicked: (NovenaSearch) -\u0026gt; Unit,\u003cbr/\u003e    onChapletClicked: (ChapletSearch) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val prayers by viewModel.prayersLiveData.observeAsState()\u003cp\u003e    prayers?.getContentIfNotHandled()?.let { list -\u0026gt;\u003cbr/\u003e        LazyColumn {\u003cbr/\u003e            items(list) { prayer -\u0026gt;\u003cbr/\u003e                when (prayer) {\u003cbr/\u003e                    is PrayerSearch -\u0026gt; PrayerItem(prayer, onClick = {\u003cbr/\u003e                        onPrayerClicked(prayer)\u003cbr/\u003e                    })\u003cbr/\u003e                    is NovenaSearch -\u0026gt; NovenaItem(prayer, onClick = {\u003cbr/\u003e                        onNovenaClicked(prayer)\u003cbr/\u003e                    })\u003cbr/\u003e                    is ChapletSearch -\u0026gt; ChapletItem(prayer, onClick = {\u003cbr/\u003e                        onChapletClicked(prayer)\u003cbr/\u003e                    })\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun PrayerItem(prayer: PrayerSearch, onClick: () -\u0026gt; Unit) {\u003cbr/\u003e    Card(onClick = onClick) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = prayer.prayer.name,\u003cbr/\u003e            style = MaterialTheme.typography.headlineLarge\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun NovenaItem(prayer: NovenaSearch, onClick: () -\u0026gt; Unit) {\u003cbr/\u003e    Card(onClick = onClick) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = prayer.novena.name,\u003cbr/\u003e            style = MaterialTheme.typography.headlineLarge\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun ChapletItem(prayer: ChapletSearch, onClick: () -\u0026gt; Unit) {\u003cbr/\u003e    Card(onClick = onClick) {\u003cbr/\u003e        Text(\u003cbr/\u003e            text = prayer.terco.name,\u003cbr/\u003e            style = MaterialTheme.typography.headlineLarge\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5d7b\"\u003eThis is the first version of this screen, and I can already see some improvements. Of course there’s still a lot to refine, but having a solid architecture makes the transition to Compose much smoother. My next step is to dig deeper, rethink some parts of the app, and start creating reusable components inside the existing\u003cstrong\u003e sanctus-components\u003c/strong\u003e module. This way, I can add Compose components that will be used not only in this screen (prayers) but across the app, making future changes much easier.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "31 min read",
  "publishedTime": "2025-04-14T19:45:18.755Z",
  "modifiedTime": null
}
