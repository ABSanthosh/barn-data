{
  "id": "1b39a648-f80d-4d9f-b016-504875cba9a1",
  "title": "Upgrading from AGP 7.4.1 to 8.5.2: A Developer’s Diary",
  "link": "https://proandroiddev.com/upgrading-from-agp-7-4-1-to-8-5-2-a-developers-diary-eace00a48a3b?source=rss----c72404660798---4",
  "description": "",
  "author": "Ivan Dimitrov",
  "published": "Thu, 03 Oct 2024 17:47:11 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "sdk",
    "gradle",
    "android",
    "obfuscation",
    "gradle-plugin"
  ],
  "byline": "Ivan Dimitrov",
  "length": 9581,
  "excerpt": "Upgrading essential tools in Android development often feels like navigating a complex maze, where each turn can either lead you to new efficiencies or unexpected challenges. Recently, I embarked on…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Daria Shatova on UnsplashUpgrading essential tools in Android development often feels like navigating a complex maze, where each turn can either lead you to new efficiencies or unexpected challenges. Recently, I embarked on such a journey: migrating from Android Gradle Plugin (AGP) 7.4.1 to AGP 8.5.2 to leverage the newest features of compileSdkVersion and targetSdkVersion 34 for our SDK deployed to Nexus.The Starting PointChoosing to upgrade to AGP 8.5.2 was based on careful research, noting that the incremental changes from AGP 8.0 to 8.5.2 wouldn’t adversely impact our project. With an optimistic outlook, I updated our SDK to comply with SDK 34 and embraced AGP 8.5.2, expecting a smooth transition. However, every update has its hurdles, and mine was just around the corner.The Initial SetbackAfter updating our SDK and integrating it into a test project, I faced an unexpected error — a NoMatchingGraphVariantsException. The artifact was right there in Nexus, visible yet unreachable by my sample app. It was frustrating, seeing the target but unable to reach it due to what initially seemed like an invisible barrier.Caused by: org.gradle.internal.component.NoMatchingGraphVariantsException: No matching variant of com.my.sdk:1.2.3-qa was found. The consumer was configured to find a library for use during runtime, preferably optimized for Android, as well as attribute 'com.android.build.api.attributes.AgpVersionAttr' with value '8.5.2', attribute 'com.android.build.api.attributes.BuildTypeAttr' with value 'debug', attribute 'org.jetbrains.kotlin.platform.type' with value 'androidJvm' but: - Variant 'qaApiElements-published' declares a library, as well as attribute 'org.jetbrains.kotlin.platform.type' with value 'androidJvm': - Incompatible because this component declares a component for use during compile-time, as well as attribute 'com.android.build.api.attributes.BuildTypeAttr' with value 'qa' and the consumer needed a component for use during runtime, as well as attribute 'com.android.build.api.attributes.BuildTypeAttr' with value 'debug' - Other compatible attributes: - Doesn't say anything about com.android.build.api.attributes.AgpVersionAttr (required '8.5.2') - Doesn't say anything about its target Java environment (preferred optimized for Android)The real issue stemmed from the nuanced way AGP 8.5.2 handles build variants. The sample app’s build system was strictly looking for matching SDK build variants — release with release, debug with debug. However, our SDK included a QA build not mirrored in the sample app, leading to a mismatch.Navigating the Build VariantsThe fix was straightforward yet crucial: instructing the build system to match the sample app’s debug build with the SDK’s QA build. This was achieved by setting matchingFallbacks in the test app’s build configuration:android { buildTypes { debug { matchingFallbacks = ['qa'] } }}This small tweak was like finding the right key for a previously locked door, allowing the app to correctly link to the intended SDK variant.Encountering the Subtle Beast: R8Just when I thought the path was clear, another issue surfaced. Although the app now built successfully with the SDK, it malfunctioned at runtime. The network layer, crucial for the app’s operation, was failing silently. This was a trickier problem, as there were no crashes to pinpoint the issue directly.The root cause was tied to updates in R8 obfuscation introduced with the new AGP version. These changes had subtly modified how R8 processed our network-related code. It was a challenging issue to diagnose because the symptoms were not straightforward.Implementing a Robust SolutionTo resolve this, I updated our obfuscation rules to align with the latest specifications for Gson, Retrofit, and OkHttp. These new rules were meticulously sourced from their respective official repositories, ensuring they were both accurate and effective. Here is what I’ve added to my proguard-rules.pro file:NOTE: You can look for the phrase “copied from:” in the ProGuard file to find the source of the rules.# From Gradle 8 Onward##---------------Begin: proguard configuration for Gson ----------# copied from: https://github.com/google/gson/blob/main/examples/android-proguard-example/proguard.cfg# Gson uses generic type information stored in a class file when working with fields. Proguard# removes such information by default, so configure it to keep all of it.-keepattributes Signature# For using GSON @Expose annotation-keepattributes *Annotation*# Gson specific classes-dontwarn sun.misc.**#-keep class com.google.gson.stream.** { *; }# Application classes that will be serialized/deserialized over Gson-keep class com.google.gson.examples.android.model.** { \u003cfields\u003e; }# Prevent proguard from stripping interface information from TypeAdapter, TypeAdapterFactory,# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)-keep class * extends com.google.gson.TypeAdapter-keep class * implements com.google.gson.TypeAdapterFactory-keep class * implements com.google.gson.JsonSerializer-keep class * implements com.google.gson.JsonDeserializer# Prevent R8 from leaving Data object members always null-keepclassmembers,allowobfuscation class * { @com.google.gson.annotations.SerializedName \u003cfields\u003e;}# Retain generic signatures of TypeToken and its subclasses with R8 version 3.0 and higher.-keep,allowobfuscation,allowshrinking class com.google.gson.reflect.TypeToken-keep,allowobfuscation,allowshrinking class * extends com.google.gson.reflect.TypeToken##---------------End: proguard configuration for Gson ----------##---------------Begin: proguard configuration for Retrofit ----------# copied from: https://github.com/square/retrofit/blob/trunk/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and# EnclosingMethod is required to use InnerClasses.-keepattributes Signature, InnerClasses, EnclosingMethod# Retrofit does reflection on method and parameter annotations.-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations# Keep annotation default values (e.g., retrofit2.http.Field.encoded).-keepattributes AnnotationDefault# Retain service method parameters when optimizing.-keepclassmembers,allowshrinking,allowobfuscation interface * { @retrofit2.http.* \u003cmethods\u003e;}# Ignore annotation used for build tooling.-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement# Ignore JSR 305 annotations for embedding nullability information.-dontwarn javax.annotation.**# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.-dontwarn kotlin.Unit# Top-level functions that can only be used by Kotlin.-dontwarn retrofit2.KotlinExtensions-dontwarn retrofit2.KotlinExtensions$*# With R8 full mode, it sees no subtypes of Retrofit interfaces since they are created with a Proxy# and replaces all potential values with null. Explicitly keeping the interfaces prevents this.-if interface * { @retrofit2.http.* \u003cmethods\u003e; }-keep,allowobfuscation interface \u003c1\u003e# Keep inherited services.-if interface * { @retrofit2.http.* \u003cmethods\u003e; }-keep,allowobfuscation interface * extends \u003c1\u003e# With R8 full mode generic signatures are stripped for classes that are not# kept. Suspend functions are wrapped in continuations where the type argument# is used.-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation# R8 full mode strips generic signatures from return types if not kept.-if interface * { @retrofit2.http.* public *** *(...); }-keep,allowoptimization,allowshrinking,allowobfuscation class \u003c3\u003e# With R8 full mode generic signatures are stripped for classes that are not kept.-keep,allowobfuscation,allowshrinking class retrofit2.Response##---------------End: proguard configuration for Retrofit ----------##---------------Begin: proguard configuration for Okhttp ----------# copied from: https://raw.githubusercontent.com/square/okhttp/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro# JSR 305 annotations are for embedding nullability information.-dontwarn javax.annotation.**# A resource is loaded with a relative path so the package of this class must be preserved.-adaptresourcefilenames okhttp3/internal/publicsuffix/PublicSuffixDatabase.gz# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.-dontwarn org.codehaus.mojo.animal_sniffer.*# OkHttp platform used only on JVM and when Conscrypt and other security providers are available.-dontwarn okhttp3.internal.platform.**-dontwarn org.conscrypt.**-dontwarn org.bouncycastle.**-dontwarn org.openjsse.**##---------------End: proguard configuration for Okhttp -----------keep class retrofit.** { *; }-keep class * implements java.io.Serializable { *; }-keep class kotlin.MetadataWith these updates, our network communications were not just restored; they were enhanced to be more robust than before.Lessons Learned and Looking ForwardThis journey taught me the importance of understanding every component of our development environment in-depth. The transition from AGP 7.4.1 to 8.5.2, while challenging, was a valuable learning experience that improved both our SDK and my skills as a developer.Embracing changes in our tools and adapting to their evolving landscapes is crucial for staying ahead. As I continue to develop and refine our SDK, the lessons learned from this upgrade will undoubtedly serve as a guide for future enhancements",
  "image": "https://miro.medium.com/v2/resize:fit:640/1*IEn64k7We7kAWoYDhzzWJA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@ivan.k.dimitrov21?source=post_page-----eace00a48a3b--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Ivan Dimitrov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*wkYj7Jwg2nfToAb3j-GaVw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----eace00a48a3b--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@dariasha911?utm_content=creditCopyText\u0026amp;utm_medium=referral\u0026amp;utm_source=unsplash\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDaria Shatova\u003c/a\u003e on \u003ca href=\"https://unsplash.com/photos/silver-tabby-cat-on-brown-wooden-fence-qBSIwo7H0qY?utm_content=creditCopyText\u0026amp;utm_medium=referral\u0026amp;utm_source=unsplash\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ec51\"\u003eUpgrading essential tools in Android development often feels like navigating a complex maze, where each turn can either lead you to new efficiencies or unexpected challenges. Recently, I embarked on such a journey: migrating from Android Gradle Plugin (AGP) 7.4.1 to AGP 8.5.2 to leverage the newest features of \u003ccode\u003ecompileSdkVersion\u003c/code\u003e and \u003ccode\u003etargetSdkVersion\u003c/code\u003e 34 for our SDK deployed to Nexus.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1acb\"\u003eThe Starting Point\u003c/h2\u003e\u003cp id=\"dfe4\"\u003eChoosing to upgrade to AGP 8.5.2 was based on careful research, noting that the incremental changes from AGP 8.0 to 8.5.2 wouldn’t adversely impact our project. With an optimistic outlook, I updated our SDK to comply with SDK 34 and embraced AGP 8.5.2, expecting a smooth transition. However, every update has its hurdles, and mine was just around the corner.\u003c/p\u003e\u003ch2 id=\"69a0\"\u003eThe Initial Setback\u003c/h2\u003e\u003cp id=\"eac7\"\u003eAfter updating our SDK and integrating it into a test project, I faced an unexpected error — a \u003ccode\u003eNoMatchingGraphVariantsException\u003c/code\u003e. The artifact was right there in Nexus, visible yet unreachable by my sample app. It was frustrating, seeing the target but unable to reach it due to what initially seemed like an invisible barrier.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0d44\"\u003eCaused by: org.gradle.internal.component.NoMatchingGraphVariantsException: No matching variant of com.my.sdk:1.2.3-qa was found. The consumer was configured to find a library for use during runtime, preferably optimized for Android, as well as attribute \u0026#39;com.android.build.api.attributes.AgpVersionAttr\u0026#39; with value \u0026#39;8.5.2\u0026#39;, attribute \u0026#39;com.android.build.api.attributes.BuildTypeAttr\u0026#39; with value \u0026#39;debug\u0026#39;, attribute \u0026#39;org.jetbrains.kotlin.platform.type\u0026#39; with value \u0026#39;androidJvm\u0026#39; but:\u003cbr/\u003e  - Variant \u0026#39;qaApiElements-published\u0026#39; declares a library, as well as attribute \u0026#39;org.jetbrains.kotlin.platform.type\u0026#39; with value \u0026#39;androidJvm\u0026#39;:\u003cbr/\u003e      - Incompatible because this component declares a component for use during compile-time, as well as attribute \u0026#39;com.android.build.api.attributes.BuildTypeAttr\u0026#39; with value \u0026#39;qa\u0026#39; and the consumer needed a component for use during runtime, as well as attribute \u0026#39;com.android.build.api.attributes.BuildTypeAttr\u0026#39; with value \u0026#39;debug\u0026#39;\u003cbr/\u003e      - Other compatible attributes:\u003cbr/\u003e          - Doesn\u0026#39;t say anything about com.android.build.api.attributes.AgpVersionAttr (required \u0026#39;8.5.2\u0026#39;)\u003cbr/\u003e          - Doesn\u0026#39;t say anything about its target Java environment (preferred optimized for Android)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e696\"\u003eThe real issue stemmed from the nuanced way AGP 8.5.2 handles build variants. The sample app’s build system was strictly looking for matching SDK build variants — release with release, debug with debug. However, our SDK included a QA build not mirrored in the sample app, leading to a mismatch.\u003c/p\u003e\u003ch2 id=\"882e\"\u003eNavigating the Build Variants\u003c/h2\u003e\u003cp id=\"634f\"\u003eThe fix was straightforward yet crucial: instructing the build system to match the sample app’s debug build with the SDK’s QA build. This was achieved by setting \u003ccode\u003ematchingFallbacks\u003c/code\u003e in the test app’s build configuration:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f07b\"\u003eandroid {\u003cbr/\u003e    buildTypes {\u003cbr/\u003e        debug {\u003cbr/\u003e            matchingFallbacks = [\u0026#39;qa\u0026#39;]\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"62be\"\u003eThis small tweak was like finding the right key for a previously locked door, allowing the app to correctly link to the intended SDK variant.\u003c/p\u003e\u003ch2 id=\"8fb0\"\u003eEncountering the Subtle Beast: R8\u003c/h2\u003e\u003cp id=\"1c29\"\u003eJust when I thought the path was clear, another issue surfaced. Although the app now built successfully with the SDK, it malfunctioned at runtime. The network layer, crucial for the app’s operation, was failing silently. This was a trickier problem, as there were no crashes to pinpoint the issue directly.\u003c/p\u003e\u003cp id=\"94a0\"\u003eThe root cause was tied to updates in R8 obfuscation introduced with the new AGP version. These changes had subtly modified how R8 processed our network-related code. It was a challenging issue to diagnose because the symptoms were not straightforward.\u003c/p\u003e\u003ch2 id=\"87f0\"\u003eImplementing a Robust Solution\u003c/h2\u003e\u003cp id=\"8b9a\"\u003eTo resolve this, I updated our obfuscation rules to align with the latest specifications for Gson, Retrofit, and OkHttp. These new rules were meticulously sourced from their respective official repositories, ensuring they were both accurate and effective. Here is what I’ve added to my \u003cstrong\u003eproguard-rules.pro\u003c/strong\u003e file:\u003c/p\u003e\u003cp id=\"4861\"\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: You can look for the phrase “copied from:” in the ProGuard file to find the source of the rules.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7234\"\u003e# From Gradle 8 Onward\u003cbr/\u003e##---------------Begin: proguard configuration for Gson  ----------\u003cbr/\u003e# copied from: https://github.com/google/gson/blob/main/examples/android-proguard-example/proguard.cfg\u003cp\u003e# Gson uses generic type information stored in a class file when working with fields. Proguard\u003cbr/\u003e# removes such information by default, so configure it to keep all of it.\u003cbr/\u003e-keepattributes Signature\u003c/p\u003e\u003cp\u003e# For using GSON @Expose annotation\u003cbr/\u003e-keepattributes *Annotation*\u003c/p\u003e\u003cp\u003e# Gson specific classes\u003cbr/\u003e-dontwarn sun.misc.**\u003cbr/\u003e#-keep class com.google.gson.stream.** { *; }\u003c/p\u003e\u003cp\u003e# Application classes that will be serialized/deserialized over Gson\u003cbr/\u003e-keep class com.google.gson.examples.android.model.** { \u0026lt;fields\u0026gt;; }\u003c/p\u003e\u003cp\u003e# Prevent proguard from stripping interface information from TypeAdapter, TypeAdapterFactory,\u003cbr/\u003e# JsonSerializer, JsonDeserializer instances (so they can be used in @JsonAdapter)\u003cbr/\u003e-keep class * extends com.google.gson.TypeAdapter\u003cbr/\u003e-keep class * implements com.google.gson.TypeAdapterFactory\u003cbr/\u003e-keep class * implements com.google.gson.JsonSerializer\u003cbr/\u003e-keep class * implements com.google.gson.JsonDeserializer\u003c/p\u003e\u003cp\u003e# Prevent R8 from leaving Data object members always null\u003cbr/\u003e-keepclassmembers,allowobfuscation class * {\u003cbr/\u003e  @com.google.gson.annotations.SerializedName \u0026lt;fields\u0026gt;;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e# Retain generic signatures of TypeToken and its subclasses with R8 version 3.0 and higher.\u003cbr/\u003e-keep,allowobfuscation,allowshrinking class com.google.gson.reflect.TypeToken\u003cbr/\u003e-keep,allowobfuscation,allowshrinking class * extends com.google.gson.reflect.TypeToken\u003c/p\u003e\u003cp\u003e##---------------End: proguard configuration for Gson  ----------\u003c/p\u003e\u003cp\u003e##---------------Begin: proguard configuration for Retrofit  ----------\u003cbr/\u003e# copied from: https://github.com/square/retrofit/blob/trunk/retrofit/src/main/resources/META-INF/proguard/retrofit2.pro\u003c/p\u003e\u003cp\u003e# Retrofit does reflection on generic parameters. InnerClasses is required to use Signature and\u003cbr/\u003e# EnclosingMethod is required to use InnerClasses.\u003cbr/\u003e-keepattributes Signature, InnerClasses, EnclosingMethod\u003c/p\u003e\u003cp\u003e# Retrofit does reflection on method and parameter annotations.\u003cbr/\u003e-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations\u003c/p\u003e\u003cp\u003e# Keep annotation default values (e.g., retrofit2.http.Field.encoded).\u003cbr/\u003e-keepattributes AnnotationDefault\u003c/p\u003e\u003cp\u003e# Retain service method parameters when optimizing.\u003cbr/\u003e-keepclassmembers,allowshrinking,allowobfuscation interface * {\u003cbr/\u003e    @retrofit2.http.* \u0026lt;methods\u0026gt;;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e# Ignore annotation used for build tooling.\u003cbr/\u003e-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement\u003c/p\u003e\u003cp\u003e# Ignore JSR 305 annotations for embedding nullability information.\u003cbr/\u003e-dontwarn javax.annotation.**\u003c/p\u003e\u003cp\u003e# Guarded by a NoClassDefFoundError try/catch and only used when on the classpath.\u003cbr/\u003e-dontwarn kotlin.Unit\u003c/p\u003e\u003cp\u003e# Top-level functions that can only be used by Kotlin.\u003cbr/\u003e-dontwarn retrofit2.KotlinExtensions\u003cbr/\u003e-dontwarn retrofit2.KotlinExtensions$*\u003c/p\u003e\u003cp\u003e# With R8 full mode, it sees no subtypes of Retrofit interfaces since they are created with a Proxy\u003cbr/\u003e# and replaces all potential values with null. Explicitly keeping the interfaces prevents this.\u003cbr/\u003e-if interface * { @retrofit2.http.* \u0026lt;methods\u0026gt;; }\u003cbr/\u003e-keep,allowobfuscation interface \u0026lt;1\u0026gt;\u003c/p\u003e\u003cp\u003e# Keep inherited services.\u003cbr/\u003e-if interface * { @retrofit2.http.* \u0026lt;methods\u0026gt;; }\u003cbr/\u003e-keep,allowobfuscation interface * extends \u0026lt;1\u0026gt;\u003c/p\u003e\u003cp\u003e# With R8 full mode generic signatures are stripped for classes that are not\u003cbr/\u003e# kept. Suspend functions are wrapped in continuations where the type argument\u003cbr/\u003e# is used.\u003cbr/\u003e-keep,allowobfuscation,allowshrinking class kotlin.coroutines.Continuation\u003c/p\u003e\u003cp\u003e# R8 full mode strips generic signatures from return types if not kept.\u003cbr/\u003e-if interface * { @retrofit2.http.* public *** *(...); }\u003cbr/\u003e-keep,allowoptimization,allowshrinking,allowobfuscation class \u0026lt;3\u0026gt;\u003c/p\u003e\u003cp\u003e# With R8 full mode generic signatures are stripped for classes that are not kept.\u003cbr/\u003e-keep,allowobfuscation,allowshrinking class retrofit2.Response\u003cbr/\u003e##---------------End: proguard configuration for Retrofit  ----------\u003c/p\u003e\u003cp\u003e##---------------Begin: proguard configuration for Okhttp  ----------\u003cbr/\u003e# copied from: https://raw.githubusercontent.com/square/okhttp/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro\u003c/p\u003e\u003cp\u003e# JSR 305 annotations are for embedding nullability information.\u003cbr/\u003e-dontwarn javax.annotation.**\u003c/p\u003e\u003cp\u003e# A resource is loaded with a relative path so the package of this class must be preserved.\u003cbr/\u003e-adaptresourcefilenames okhttp3/internal/publicsuffix/PublicSuffixDatabase.gz\u003c/p\u003e\u003cp\u003e# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.\u003cbr/\u003e-dontwarn org.codehaus.mojo.animal_sniffer.*\u003c/p\u003e\u003cp\u003e# OkHttp platform used only on JVM and when Conscrypt and other security providers are available.\u003cbr/\u003e-dontwarn okhttp3.internal.platform.**\u003cbr/\u003e-dontwarn org.conscrypt.**\u003cbr/\u003e-dontwarn org.bouncycastle.**\u003cbr/\u003e-dontwarn org.openjsse.**\u003cbr/\u003e##---------------End: proguard configuration for Okhttp  ----------\u003cbr/\u003e-keep class retrofit.** { *; }\u003cbr/\u003e-keep class * implements java.io.Serializable { *; }\u003cbr/\u003e-keep class kotlin.Metadata\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e8fc\"\u003eWith these updates, our network communications were not just restored; they were enhanced to be more robust than before.\u003c/p\u003e\u003ch2 id=\"c777\"\u003eLessons Learned and Looking Forward\u003c/h2\u003e\u003cp id=\"9537\"\u003eThis journey taught me the importance of understanding every component of our development environment in-depth. The transition from AGP 7.4.1 to 8.5.2, while challenging, was a valuable learning experience that improved both our SDK and my skills as a developer.\u003c/p\u003e\u003cp id=\"e2ab\"\u003eEmbracing changes in our tools and adapting to their evolving landscapes is crucial for staying ahead. As I continue to develop and refine our SDK, the lessons learned from this upgrade will undoubtedly serve as a guide for future enhancements\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-10-02T12:31:15.481Z",
  "modifiedTime": null
}
