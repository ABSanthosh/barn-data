{
  "id": "39b7cd55-e6d7-4b0c-b2ba-bc0f6579a319",
  "title": "Kotlin’s Builder Functions: A Better Way to Create Lists, Maps, Strings \u0026 Sets",
  "link": "https://proandroiddev.com/kotlins-builder-functions-a-better-way-to-create-lists-maps-strings-sets-77ddbe706303?source=rss----c72404660798---4",
  "description": "",
  "author": "Domen Lanišnik",
  "published": "Sat, 10 May 2025 05:43:58 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin-beginners",
    "kotlin-multiplatform",
    "kotlin",
    "androiddev"
  ],
  "byline": "Domen Lanišnik",
  "length": 5992,
  "excerpt": "Kotlin offers several convenience functions to create lists, maps, strings and more without the usual boilerplate code.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin’s Builder Functions: A Better Way to Create Lists, Maps, Strings \u0026 SetsKotlin offers several convenience functions to create lists, maps, strings, and more without the usual boilerplate code.In this short post, we’ll examine a few common functions in the Kotlin standard library that make constructing those objects easier.Building a ListThe usual approaches to creating and populating a dynamic list are, for example:val newList = mutableListOf\u003cInt\u003e()newList.add(1)if (conditionFullfilled) { newList.add(2)}// ORval newList = mutableListOf\u003cInt\u003e().apply { add(1) if (conditionFullfilled) { add(2) }}We can make that easier by using the buildList {} function that creates a mutable list under the hood, allows us to call functions on it, and then returns an immutable list.val newList = buildList { add(1) if (conditionFullfilled) { add(2) }}Looking at the implementation of the buildList() function, we can see that it works similarly to our initial code. It calls the buildListInternal() function that constructs a new mutable list and applies the actions to it. And since it’s an inline function, it also means that the overhead of the additional lambda is removed, since it will copy the code to the call site.@SinceKotlin(\"1.6\")@WasExperimental(ExperimentalStdlibApi::class)@kotlin.internal.InlineOnly@Suppress(\"LEAKED_IN_PLACE_LAMBDA\", \"WRONG_INVOCATION_KIND\")public inline fun \u003cE\u003e buildList(@BuilderInference builderAction: MutableList\u003cE\u003e.() -\u003e Unit): List\u003cE\u003e { contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) } return buildListInternal(builderAction)}buildList() can be used for any type, including primitives like Int, Float, Double, and Long. However, if we want to avoid auto-boxing when storing and retrieving the elements, we can use dedicated functions:buildIntList {}: constructs a MutableIntList and returns a IntList,buildLongList {}: constructs a MutableLongList and returns a LongList,buildFloatList {}: constructs a MutableFloatList and returns a FloatList,buildDoubleList {}: constructs a MutableDoubleList and returns a DoubleList.Building a StringA typical way of constructing a string that requires concatenation based on some condition is to create a StringBuilder object and then call the append functions on it and convert it to a string.val sb = StringBuilder()sb.append(\"Some\")if (conditionFullfilled) { sb.append(\" string\")}val newString = sb.toString()// ORval newString = StringBuilder().apply { append(\"Some\") if (conditionFullfilled) { append(\" string\") }}.toString()We can make that easier by using the buildString {} function that creates the StringBuilder object for us and returns the output string. We can call the usual append functions on it inside the code block.val newString = buildString { append(\"Some\") if (conditionFullfilled) { append(\" string\") }}Looking at the implementation of the buildString() function, we can see that it works the same as our initial code. And since it’s an inline function, it also means that the overhead of the additional lambda is removed, since it will copy the code to the call site.@kotlin.internal.InlineOnlypublic inline fun buildString(builderAction: StringBuilder.() -\u003e Unit): String { contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) } return StringBuilder().apply(builderAction).toString()}Building a SetSimilar to building a list and string, there is a helper function for building a set. It constructs a mutable set, allows us to call functions on it, and then returns an immutable version of the set that preserves the insertion order.val newSet = buildSet { add(1) if (conditionFullfilled) { addAll(someOtherSet) }}The buildSet() function can be used for any type. However, there are also other versions of the function for building type-specific sets:buildIntSet {}: constructs a MutableIntSet and returns a IntSet,buildFloatSet {}: constructs a MutableFloatSet and returns a FloatSet,buildLongSet {}: constructs a MutableLongSet and returns a LongSet.The three type-bound sets use a flat hash table underneath and don’t preserve insertion order.Building a MapWe can build a new map using the buildMap {} function. It constructs a new MutableMap underneath, allows us to call functions on it, and then returns an immutable Map.val newMap = buildMap { put(\"key\", \"value\") if (conditionFullfilled) { putAll(someOtherMap) }}If our keys or values are primitives like Int, Float, Double, or Long, we can use optimized variants of the function:buildIntIntMap {}: constructs a MutableIntIntMap and returns a IntIntMap, where the keys and values are Int primitives,buildLongLongMap {}: constructs a MutableLongLongMap and returns a LongLongMap, where the keys and values are Long primitives,buildFloatFloatMap {}: constructs a MutableFloatFloatMap and returns a FloatFloatMap, where the keys and values are Float primitives,buildObjectObjectMap {}: constructs a MutableObjectObjectMap and returns a ObjectObjectMap, where the keys and values are reference types.There are even more variants of this function for different combinations of key and value types: buildIntFloatMap {}, buildIntLongMap {}, buildObjectFloatMap {} and so on.Other buildersThe above functions are all part of the Kotlin standard library and should be available in most projects. There are other similar builder functions declared in other dependencies, for example: buildSpannedString {} and buildAnnotatedString {} that are part of Compose, and buildJsonObject {} that is part of the Kotlinx Serialization library.ConclusionThe Kotlin Standard Library offers several convenience functions for building common types like lists, sets, maps, and strings. They provide a standardized way of constructing those types and avoid common boilerplate.I hope you found this useful and learned something new. Let me know in the comments what other builder functions you’re using.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*XoAJ5gpuIAbpjEnZMcIr6Q.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"7bac\" data-testid=\"storyTitle\"\u003eKotlin’s Builder Functions: A Better Way to Create Lists, Maps, Strings \u0026amp; Sets\u003c/h2\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@domen.lanisnik?source=post_page---byline--77ddbe706303---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Domen Lanišnik\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*CHMrHH5mrrGDp0Vsm-UtKw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"f039\"\u003eKotlin offers several convenience functions to create lists, maps, strings, and more without the usual boilerplate code.\u003c/p\u003e\u003cp id=\"b275\"\u003eIn this short post, we’ll examine a few common functions in the Kotlin standard library that make constructing those objects easier.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"bf80\"\u003eBuilding a List\u003c/h2\u003e\u003cp id=\"c794\"\u003eThe usual approaches to creating and populating a dynamic list are, for example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e2af\"\u003eval newList = mutableListOf\u0026lt;Int\u0026gt;()\u003cbr/\u003enewList.add(1)\u003cbr/\u003eif (conditionFullfilled) {\u003cbr/\u003e    newList.add(2)\u003cbr/\u003e}\u003cp\u003e// OR\u003c/p\u003e\u003cp\u003eval newList = mutableListOf\u0026lt;Int\u0026gt;().apply { \u003cbr/\u003e    add(1)\u003c/p\u003e\u003cp\u003e    if (conditionFullfilled) {\u003cbr/\u003e        add(2)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"11cf\"\u003eWe can make that easier by using the \u003ccode\u003ebuildList {}\u003c/code\u003e function that creates a mutable list under the hood, allows us to call functions on it, and then returns an immutable list.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2747\"\u003eval newList = buildList { \u003cbr/\u003e    add(1)\u003cp\u003e    if (conditionFullfilled) {\u003cbr/\u003e        add(2)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5dd9\"\u003eLooking at the implementation of the \u003ccode\u003ebuildList()\u003c/code\u003e function, we can see that it works similarly to our initial code. It calls the \u003ccode\u003ebuildListInternal()\u003c/code\u003e function that constructs a new mutable list and applies the actions to it. And since it’s an \u003ccode\u003einline\u003c/code\u003e function, it also means that the overhead of the additional lambda is removed, since it will copy the code to the call site.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"25de\"\u003e@SinceKotlin(\u0026#34;1.6\u0026#34;)\u003cbr/\u003e@WasExperimental(ExperimentalStdlibApi::class)\u003cbr/\u003e@kotlin.internal.InlineOnly\u003cbr/\u003e@Suppress(\u0026#34;LEAKED_IN_PLACE_LAMBDA\u0026#34;, \u0026#34;WRONG_INVOCATION_KIND\u0026#34;)\u003cbr/\u003epublic inline fun \u0026lt;E\u0026gt; buildList(@BuilderInference builderAction: MutableList\u0026lt;E\u0026gt;.() -\u0026gt; Unit): List\u0026lt;E\u0026gt; {\u003cbr/\u003e    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\u003cbr/\u003e    return buildListInternal(builderAction)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9b80\"\u003e\u003ccode\u003ebuildList()\u003c/code\u003e can be used for any type, including primitives like \u003ccode\u003eInt\u003c/code\u003e, \u003ccode\u003eFloat\u003c/code\u003e, \u003ccode\u003eDouble\u003c/code\u003e, and \u003ccode\u003eLong\u003c/code\u003e. However, if we want to avoid auto-boxing when storing and retrieving the elements, we can use dedicated functions:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2d5c\"\u003e\u003ccode\u003ebuildIntList {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableIntList\u003c/code\u003e and returns a \u003ccode\u003eIntList\u003c/code\u003e,\u003c/li\u003e\u003cli id=\"db85\"\u003e\u003ccode\u003ebuildLongList {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableLongList\u003c/code\u003e and returns a \u003ccode\u003eLongList\u003c/code\u003e,\u003c/li\u003e\u003cli id=\"777a\"\u003e\u003ccode\u003ebuildFloatList {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableFloatList\u003c/code\u003e and returns a \u003ccode\u003eFloatList\u003c/code\u003e,\u003c/li\u003e\u003cli id=\"5465\"\u003e\u003ccode\u003ebuildDoubleList {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableDoubleList\u003c/code\u003e and returns a \u003ccode\u003eDoubleList\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1db7\"\u003eBuilding a String\u003c/h2\u003e\u003cp id=\"0b9d\"\u003eA typical way of constructing a string that requires concatenation based on some condition is to create a \u003ccode\u003eStringBuilder\u003c/code\u003e object and then call the \u003ccode\u003eappend\u003c/code\u003e functions on it and convert it to a string.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5213\"\u003eval sb = StringBuilder()\u003cbr/\u003esb.append(\u0026#34;Some\u0026#34;)\u003cbr/\u003eif (conditionFullfilled) {\u003cbr/\u003e    sb.append(\u0026#34; string\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eval newString = sb.toString()\u003cp\u003e// OR\u003c/p\u003e\u003cp\u003eval newString = StringBuilder().apply { \u003cbr/\u003e    append(\u0026#34;Some\u0026#34;)\u003c/p\u003e\u003cp\u003e    if (conditionFullfilled) {\u003cbr/\u003e        append(\u0026#34; string\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}.toString()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2212\"\u003eWe can make that easier by using the \u003ccode\u003ebuildString {}\u003c/code\u003e function that creates the \u003ccode\u003eStringBuilder\u003c/code\u003e object for us and returns the output string. We can call the usual \u003ccode\u003eappend\u003c/code\u003e functions on it inside the code block.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0c3c\"\u003eval newString = buildString {\u003cbr/\u003e    append(\u0026#34;Some\u0026#34;)\u003cp\u003e    if (conditionFullfilled) {\u003cbr/\u003e        append(\u0026#34; string\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e332\"\u003eLooking at the implementation of the \u003ccode\u003ebuildString()\u003c/code\u003e function, we can see that it works the same as our initial code. And since it’s an \u003ccode\u003einline\u003c/code\u003e function, it also means that the overhead of the additional lambda is removed, since it will copy the code to the call site.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4e98\"\u003e@kotlin.internal.InlineOnly\u003cbr/\u003epublic inline fun buildString(builderAction: StringBuilder.() -\u0026gt; Unit): String {\u003cbr/\u003e    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\u003cbr/\u003e    return StringBuilder().apply(builderAction).toString()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"21e7\"\u003eBuilding a Set\u003c/h2\u003e\u003cp id=\"2065\"\u003eSimilar to building a list and string, there is a helper function for building a set. It constructs a mutable set, allows us to call functions on it, and then returns an immutable version of the set that preserves the insertion order.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9d8a\"\u003eval newSet = buildSet {\u003cbr/\u003e    add(1)\u003cp\u003e    if (conditionFullfilled) {\u003cbr/\u003e        addAll(someOtherSet)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"41b1\"\u003eThe \u003ccode\u003ebuildSet()\u003c/code\u003e function can be used for any type. However, there are also other versions of the function for building type-specific sets:\u003c/p\u003e\u003cul\u003e\u003cli id=\"696b\"\u003e\u003ccode\u003ebuildIntSet {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableIntSet\u003c/code\u003e and returns a \u003ccode\u003eIntSet\u003c/code\u003e,\u003c/li\u003e\u003cli id=\"e411\"\u003e\u003ccode\u003ebuildFloatSet {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableFloatSet\u003c/code\u003e and returns a \u003ccode\u003eFloatSet\u003c/code\u003e,\u003c/li\u003e\u003cli id=\"4ae0\"\u003e\u003ccode\u003ebuildLongSet {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableLongSet\u003c/code\u003e and returns a \u003ccode\u003eLongSet\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0608\"\u003eThe three type-bound sets use a flat hash table underneath and don’t preserve insertion order.\u003c/p\u003e\u003ch2 id=\"14f5\"\u003eBuilding a Map\u003c/h2\u003e\u003cp id=\"14e2\"\u003eWe can build a new map using the \u003ccode\u003ebuildMap {}\u003c/code\u003e function. It constructs a new \u003ccode\u003eMutableMap\u003c/code\u003e underneath, allows us to call functions on it, and then returns an immutable \u003ccode\u003eMap\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"59b3\"\u003eval newMap = buildMap { \u003cbr/\u003e    put(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;)\u003cp\u003e        if (conditionFullfilled) {\u003cbr/\u003e        putAll(someOtherMap)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"525c\"\u003eIf our keys or values are primitives like \u003ccode\u003eInt\u003c/code\u003e, \u003ccode\u003eFloat\u003c/code\u003e, \u003ccode\u003eDouble\u003c/code\u003e, or \u003ccode\u003eLong\u003c/code\u003e, we can use optimized variants of the function:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c274\"\u003e\u003ccode\u003ebuildIntIntMap {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableIntIntMap\u003c/code\u003e and returns a \u003ccode\u003eIntIntMap\u003c/code\u003e, where the keys and values are \u003ccode\u003eInt\u003c/code\u003e primitives,\u003c/li\u003e\u003cli id=\"764a\"\u003e\u003ccode\u003ebuildLongLongMap {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableLongLongMap\u003c/code\u003e and returns a \u003ccode\u003eLongLongMap\u003c/code\u003e, where the keys and values are \u003ccode\u003eLong\u003c/code\u003e primitives,\u003c/li\u003e\u003cli id=\"687a\"\u003e\u003ccode\u003ebuildFloatFloatMap {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableFloatFloatMap\u003c/code\u003e and returns a \u003ccode\u003eFloatFloatMap\u003c/code\u003e, where the keys and values are \u003ccode\u003eFloat\u003c/code\u003e primitives,\u003c/li\u003e\u003cli id=\"bd4c\"\u003e\u003ccode\u003ebuildObjectObjectMap {}\u003c/code\u003e: constructs a \u003ccode\u003eMutableObjectObjectMap\u003c/code\u003e and returns a \u003ccode\u003eObjectObjectMap\u003c/code\u003e, where the keys and values are reference types.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fadb\"\u003eThere are even more variants of this function for different combinations of key and value types: \u003ccode\u003ebuildIntFloatMap {}\u003c/code\u003e, \u003ccode\u003ebuildIntLongMap {}\u003c/code\u003e, \u003ccode\u003ebuildObjectFloatMap {}\u003c/code\u003e and so on.\u003c/p\u003e\u003ch2 id=\"72ed\"\u003eOther builders\u003c/h2\u003e\u003cp id=\"78a9\"\u003eThe above functions are all part of the Kotlin standard library and should be available in most projects. There are other similar builder functions declared in other dependencies, for example: \u003ccode\u003ebuildSpannedString {}\u003c/code\u003e and \u003ccode\u003ebuildAnnotatedString {}\u003c/code\u003e that are part of Compose, and \u003ccode\u003ebuildJsonObject {}\u003c/code\u003e that is part of the Kotlinx Serialization library.\u003c/p\u003e\u003ch2 id=\"4ee1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"5682\"\u003eThe Kotlin Standard Library offers several convenience functions for building common types like lists, sets, maps, and strings. They provide a standardized way of constructing those types and avoid common boilerplate.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"1f58\"\u003eI hope you found this useful and learned something new. Let me know in the comments what other builder functions you’re using.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-05-09T19:23:10.042Z",
  "modifiedTime": null
}
