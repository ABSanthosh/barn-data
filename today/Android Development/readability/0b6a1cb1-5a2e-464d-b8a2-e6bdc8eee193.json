{
  "id": "0b6a1cb1-5a2e-464d-b8a2-e6bdc8eee193",
  "title": "Simplifying DiffUtil with RxJava",
  "link": "https://saket.me/simplifying-diffutil-rxjava/",
  "description": "One of my favorite parts of RxJava is that no matter how complex a state management usecase is, there’s always an operator for that™. During a recent code cleanup, I found a very cool usecase of RxJava’s scan() and compose() operators for simplifying the usually verbose DiffUtil implementation. I had been delaying writing this post […] The post Simplifying DiffUtil with RxJava appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Sun, 18 Feb 2018 07:45:54 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android",
    "recyclerview",
    "rxjava"
  ],
  "byline": "Saket Narayan",
  "length": 4703,
  "excerpt": "Leveraging RxJava's scan() and compose() operator for applying DiffUtil to any RecyclerView in one line.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "One of my favorite parts of RxJava is that no matter how complex a state management usecase is, there’s always an operator for that™. During a recent code cleanup, I found a very cool usecase of RxJava’s scan() and compose() operators for simplifying the usually verbose DiffUtil implementation. I had been delaying writing this post for a while, but Mark Allison’s new series of articles on adding item change animations to RecyclerView have finally pushed me to finish this. For those unaware, DiffUtil exists because maths is difficult. It’s a utility class for RecyclerView that calculates diffs between adapter data-set updates and accordingly plays item change animations by calling methods like notifyItemInserted(), notifyItemMoved(), etc. on the adapter. The usage of DiffUtil normally looks like like this: List\u003cT\u003e lastItems; database.streamItems()   .doAfterNext(nextItems -\u003e lastItems = nextItems)   .subscribe(nextItems -\u003e {     recyclerViewAdapter.updateItems(nextItems);     DiffResult result = DiffUtil.calculate(ItemDiffer.create(lastItems, nextItems));     result.dispatchUpdatesTo(recyclerViewAdapter);   }); For usecases where both the previous item and the current item in a stream are required for comparison, RxJava offers a handy operator called scan(): database.streamItems()   .scan(seedPair, (oldPair, nextItems) -\u003e {     DiffUtil.Callback callback = ItemDiffer.create(pair.items, nextItems);     DiffResult result = DiffUtil.calculate(callback, true);     return Pair.create(nextItems, result);   })   .skip(1)  // seedPair is fake news.   .subscribe(pair -\u003e {     recyclerViewAdapter.updateItems(pair.items);     pair.diffResult.dispatchUpdatesTo(recyclerViewAdapter);   }) scan() can look really overwhelming at first, especially because its documentation and marble diagram only start making sense after one has already understood what the operator does. Nevermind the diagram, let’s break-down its usage, scan(seedPair, (oldPair, nextItems) -\u003e {   // do comparison.   return pair; }) seedPair is the initial value to scan() because it needs atleast two values in the stream for doing a comparison. The dummy seed value is immediately ignored by calling skip(1). oldPair is the previous value produced by the scan() function. nextItems is the new value consumed by the function. You have probably already noticed that our Rx now chain looks way more verbose with scan() than before. This isn’t what you signed up for. We will simplify the chain in two steps: 1. Make the adapter responsible for consuming new items class RecyclerViewAdapter implements Consumer\u003cPair\u003cList\u003c\u003e, DiffResult\u003e {    void accept(Pair\u003cList\u003c\u003e, DiffResult\u003e pair) {     this.items = pair.items;     pair.diffResult.dispatchUpdatesTo(this);   } } This simplifies the subscribe call: database.streamItems()   .scan(seedPair, (oldPair, nextItems) -\u003e {     DiffUtil.Callback callback = ItemDiffer.create(pair.items, nextItems);     DiffUtil.DiffResult result = DiffUtil.calculate(callback, true);     return Pair.create(nextItems, result);   })   .skip(1)   .subscribe(recyclerViewAdapter) 2. Extract the diffing logic as a reusable function Considering that real world applications usually have multiple RecyclerViews that need item change animations, Observable#compose() can be leveraged to make the usage of DiffUtil reusable: public class RxDiffUtil {     public static \u003cT\u003e ObservableTransformer\u003cList\u003cT\u003e, Pair\u003cList\u003cT\u003e, DiffResult\u003e\u003e calculate(       BiFunction\u003cList\u003cT\u003e, List\u003cT\u003e, DiffUtil.Callback\u003e itemDiffer)   {     Pair\u003cList\u003cT\u003e, DiffUtil.DiffResult\u003e seedPair = Pair.create(Collections.emptyList(), null);     return upstream -\u003e upstream         .scan(seedPair, (oldPair, nextItems) -\u003e {           DiffUtil.Callback callback = itemDiffer.apply(oldPair.items, nextItems);           DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback, true);           return Pair.create(nextItems, result);         })         .skip(1);  // downstream shouldn't receive seedPair.   } } The method signature is probably unreadable because of generics and type information, but all we have done is wrap scan() and skip(1) with an ObservableTransformer so that they can be used elsewhere. DiffUtil can now be dropped anywhere with just one line: database.streamItems()   .compose(RxDiffUtil.calculate((oldItems, newItems) -\u003e ItemDiffer.create(oldItems, newItems)))   .subscribe(recyclerViewAdapter) We aren’t done yet. The compose line can be further simplified by using a method reference: database.streamItems()   .compose(RxDiffUtil.calculate(ItemDiffer::create)   .subscribe(recyclerViewAdapter) And that’s it. The source code for this article can be found here: https://github.com/Saketme/RxDiffUtil",
  "image": "https://saket.me/wp-content/uploads/2018/02/RxDiffUtil-featured-image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eOne of my favorite parts of RxJava is that no matter how complex a state management usecase is, \u003cem\u003e\u003cstrong\u003ethere’s always an operator for that\u003c/strong\u003e\u003cstrong\u003e\u003cspan\u003e™\u003c/span\u003e\u003c/strong\u003e\u003c/em\u003e. During a recent code cleanup, I found a very cool usecase of RxJava’s \u003ccode\u003escan()\u003c/code\u003e and \u003ccode\u003ecompose()\u003c/code\u003e operators for simplifying the usually verbose DiffUtil implementation.\u003c/p\u003e\n\u003cp\u003eI had been delaying writing this post for a while, but Mark Allison’s new \u003ca href=\"https://blog.stylingandroid.com/recyclerview-animations-add-remove-items/\"\u003eseries of articles\u003c/a\u003e on adding item change animations to RecyclerView have finally pushed me to finish this.\u003c/p\u003e\n\u003cp\u003eFor those unaware, \u003ca href=\"https://developer.android.com/reference/android/support/v7/util/DiffUtil.html\"\u003eDiffUtil\u003c/a\u003e exists because maths is difficult. It’s a utility class for \u003ccode\u003eRecyclerView\u003c/code\u003e that calculates diffs between adapter data-set updates and accordingly plays item change animations by calling methods like \u003ccode\u003enotifyItemInserted()\u003c/code\u003e, \u003ccode\u003enotifyItemMoved()\u003c/code\u003e, etc. on the adapter.\u003c/p\u003e\n\n\n\u003cp\u003eThe usage of DiffUtil normally looks like like this:\u003c/p\u003e\n\u003cpre data-line=\"8-9\"\u003e\u003ccode\u003eList\u0026lt;T\u0026gt; lastItems;\n\ndatabase.streamItems()\n  .doAfterNext(nextItems -\u0026gt; lastItems = nextItems)\n  .subscribe(nextItems -\u0026gt; {\n    recyclerViewAdapter.updateItems(nextItems);\n\n    DiffResult result = DiffUtil.calculate(ItemDiffer.create(lastItems, nextItems));\n    result.dispatchUpdatesTo(recyclerViewAdapter);\n  });\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor usecases where both the previous item and the current item in a stream are required for comparison, RxJava offers a handy operator called \u003ccode\u003escan()\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-line=\"2-7\"\u003e\u003ccode\u003edatabase.streamItems()\n  .scan(seedPair, (oldPair, nextItems) -\u0026gt; {\n    DiffUtil.Callback callback = ItemDiffer.create(pair.items, nextItems);\n    DiffResult result = DiffUtil.calculate(callback, true);\n    return Pair.create(nextItems, result);\n  })\n  .skip(1)  // seedPair is fake news.\n  .subscribe(pair -\u0026gt; {\n    recyclerViewAdapter.updateItems(pair.items);\n    pair.diffResult.dispatchUpdatesTo(recyclerViewAdapter);\n  })\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003escan()\u003c/code\u003e can look really overwhelming at first, especially because its documentation and marble diagram only start making sense \u003cstrong\u003eafter\u003c/strong\u003e one has already understood what the operator does.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-attachment-id=\"373\" data-permalink=\"https://saket.me/simplifying-diffutil-rxjava/rxjava-scan-documentatiuon-marble-diagram-2/\" data-orig-file=\"https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1.png\" data-orig-size=\"1406,988\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"rxjava scan documentatiuon marble diagram\" data-image-description=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-300x211.png\" data-large-file=\"https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-1024x720.png\" decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-768x540.png\" alt=\"\" width=\"768\" height=\"540\" srcset=\"https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-768x540.png 768w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-300x211.png 300w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-1024x720.png 1024w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-1200x843.png 1200w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-425x299.png 425w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-650x457.png 650w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1-1300x914.png 1300w, https://saket.me/wp-content/uploads/2018/02/rxjava-scan-documentatiuon-marble-diagram-1.png 1406w\" sizes=\"(max-width: 768px) 100vw, 768px\"/\u003e\u003c/p\u003e\n\u003cp\u003eNevermind the diagram, let’s break-down its usage,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escan(seedPair, (oldPair, nextItems) -\u0026gt; {\n  // do comparison.\n  return pair;\n})\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eseedPair is the initial value to \u003ccode\u003escan()\u003c/code\u003e because it needs atleast two values in the stream for doing a comparison. The dummy seed value is immediately ignored by calling \u003ccode\u003eskip(1)\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eoldPair\u003c/code\u003e is the previous value produced by the \u003ccode\u003escan()\u003c/code\u003e function.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enextItems\u003c/code\u003e is the new value consumed by the function.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou have probably already noticed that our Rx now chain looks way more verbose with \u003ccode\u003escan()\u003c/code\u003e than before. This isn’t what you signed up for. We will simplify the chain in two steps:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Make the adapter responsible for consuming new items\u003c/strong\u003e\u003c/p\u003e\n\u003cpre data-line=\"1\"\u003e\u003ccode\u003eclass RecyclerViewAdapter implements Consumer\u0026lt;Pair\u0026lt;List\u0026lt;\u0026gt;, DiffResult\u0026gt; {\n\n   void accept(Pair\u0026lt;List\u0026lt;\u0026gt;, DiffResult\u0026gt; pair) {\n    this.items = pair.items;\n    pair.diffResult.dispatchUpdatesTo(this);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis simplifies the subscribe call:\u003c/p\u003e\n\u003cpre data-line=\"8\"\u003e\u003ccode\u003edatabase.streamItems()\n  .scan(seedPair, (oldPair, nextItems) -\u0026gt; {\n    DiffUtil.Callback callback = ItemDiffer.create(pair.items, nextItems);\n    DiffUtil.DiffResult result = DiffUtil.calculate(callback, true);\n    return Pair.create(nextItems, result);\n  })\n  .skip(1)\n  .subscribe(recyclerViewAdapter)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Extract the diffing logic as a reusable function\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eConsidering that real world applications usually have multiple RecyclerViews that need item change animations, \u003ccode\u003eObservable#compose()\u003c/code\u003e can be leveraged to make the usage of \u003ccode\u003eDiffUtil\u003c/code\u003e reusable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic class RxDiffUtil {\n \n  public static \u0026lt;T\u0026gt; ObservableTransformer\u0026lt;List\u0026lt;T\u0026gt;, Pair\u0026lt;List\u0026lt;T\u0026gt;, DiffResult\u0026gt;\u0026gt; calculate(\n      BiFunction\u0026lt;List\u0026lt;T\u0026gt;, List\u0026lt;T\u0026gt;, DiffUtil.Callback\u0026gt; itemDiffer)\n  {\n    Pair\u0026lt;List\u0026lt;T\u0026gt;, DiffUtil.DiffResult\u0026gt; seedPair = Pair.create(Collections.emptyList(), null);\n    return upstream -\u0026gt; upstream\n        .scan(seedPair, (oldPair, nextItems) -\u0026gt; {\n          DiffUtil.Callback callback = itemDiffer.apply(oldPair.items, nextItems);\n          DiffUtil.DiffResult result = DiffUtil.calculateDiff(callback, true);\n          return Pair.create(nextItems, result);\n        })\n        .skip(1);  // downstream shouldn\u0026#39;t receive seedPair.\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe method signature is probably unreadable because of generics and type information, but all we have done is wrap \u003ccode\u003escan()\u003c/code\u003e and \u003ccode\u003eskip(1)\u003c/code\u003e with an \u003ccode\u003eObservableTransformer\u003c/code\u003e so that they can be used elsewhere.\u003c/p\u003e\n\u003cp\u003eDiffUtil can now be dropped anywhere with just one line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edatabase.streamItems()\n  .compose(RxDiffUtil.calculate((oldItems, newItems) -\u0026gt; ItemDiffer.create(oldItems, newItems)))\n  .subscribe(recyclerViewAdapter)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe aren’t done yet. The compose line can be further simplified by using a method reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edatabase.streamItems()\n  .compose(RxDiffUtil.calculate(ItemDiffer::create)\n  .subscribe(recyclerViewAdapter)\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd that’s it.\u003c/p\u003e\n\u003cp\u003eThe source code for this article can be found here: \u003ca href=\"https://github.com/Saketme/RxDiffUtil\"\u003ehttps://github.com/Saketme/RxDiffUtil\u003c/a\u003e\u003c/p\u003e\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2018-02-18T07:45:54Z",
  "modifiedTime": "2019-12-18T23:48:32Z"
}
