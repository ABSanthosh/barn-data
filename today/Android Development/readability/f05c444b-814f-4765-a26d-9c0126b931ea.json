{
  "id": "f05c444b-814f-4765-a26d-9c0126b931ea",
  "title": "Building a Cross-Platform Camera App with CameraK and Compose Multiplatform",
  "link": "https://proandroiddev.com/building-a-cross-platform-camera-app-with-camerak-and-compose-multiplatform-ec92cb944ec5?source=rss----c72404660798---4",
  "description": "",
  "author": "Kashif Mehmood",
  "published": "Tue, 08 Oct 2024 15:37:13 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "android",
    "kotlin-multiplatform",
    "android-app-development",
    "compose-multiplatform"
  ],
  "byline": "Kashif Mehmood",
  "length": 12954,
  "excerpt": "Over the past year, Compose Multiplatform has made impressive strides in bringing together different parts of Jetpack Compose, like lifecycle and ViewModel, into common part of KMP. But let’s be real…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Over the past year, Compose Multiplatform has made impressive strides in bringing together different parts of Jetpack Compose, like lifecycle and ViewModel, into common part of KMP. But let’s be real — features like ExoPlayer and Camera aren’t quite in the common code yet. And honestly, that’s not a bad thing. Sometimes, the best solution is to use platform-specific libraries tailored to the job rather than forcing everything into a one-size-fits-all approach.Now, if you’d rather skip the nitty-gritty of implementing camera features and just want to stick to writing common code, I’ve got you covered. I’ve built a library with a simple API that lets you create camera apps without the hassle. It seamlessly uses AVCamera for iOS and CameraX for Android behind the scenes, so you can stay focused on your code and let the library handle the platform specifics.Let's start using the library to build a simple camera app. Get the latest version from the repo.At the time of writing this article, the latest version is 0.0.7. Let's add it to the commonMain commonMain.dependencies { implementation(\"io.github.kashif-mehmood-km:camerak:0.0.5\") }once you add the library now sync the project.Showing Preview:After syncing is completed go to your composable where you want to create the camera preview.First, we will need to create a CameraController which will be null initially.val cameraController = remember { mutableStateOf\u003cCameraController?\u003e(null) }The camera controller is an expected class that controls different features of the camera library.CameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = { setCameraLens(CameraLens.BACK) setFlashMode(FlashMode.OFF) setImageFormat(ImageFormat.JPEG) setDirectory(Directory.PICTURES) addPlugin(/**Plugin here**/)}, onCameraControllerReady = { cameraController.value = it println(\"Camera Controller Ready ${cameraController.value}\") })cameraController.value?.let { controller -\u003e CameraScreen(cameraController = controller, imageSaverPlugin)}CameraKPreview is a Composable function which takes three parameters a modifier to modify size, width, height and other aspects of the camera preview, cameraConfiguration which will be used to create the camera controller and onCameraControllerReady callback returns the controller once it has been built with the configuration.CameraK has a plugin-based API which means you can enhance its capabilities with existing plugins or create your own by implementing the CameraPlugin interface. Currently, there are two plugins that we have one is for saving images locally and the other is for QR scanning, more on that later.Now, run the app….Your app won't work because we need to get permission from Android and IOS mainly Camera and External Storage permission on Android, NSCameraUsageDescription and NSPhotoLibraryUsageDescription for IOS.For Android add these to the manifest.\u003cuses-permission android:name=\"android.permission.CAMERA\" /\u003e\u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /\u003eFor IOS add these to Info.plist\u003ckey\u003eNSCameraUsageDescription\u003c/key\u003e\u003cstring\u003eCamera permission is required for the app to work.\u003c/string\u003e\u003ckey\u003eNSPhotoLibraryUsageDescription\u003c/key\u003e\u003cstring\u003ePhoto Library permission is required for the app to work.\u003c/string\u003eNow, getting back to the code the library contains the required code to check the permissions and ask for required permissions as well.// Initialize Camera Permission State based on current permission status val cameraPermissionState = remember { mutableStateOf( permissions.hasCameraPermission() )}// Initialize Storage Permission State val storagePermissionState = remember { mutableStateOf( permissions.hasStoragePermission() )}if (!cameraPermissionState.value) { permissions.RequestStoragePermission(onGranted = { cameraPermissionState.value = true }, onDenied = { println(\"Camera Permission Denied\") })}if (!storagePermissionState.value) { permissions.RequestStoragePermission(onGranted = { storagePermissionState.value = true }, onDenied = { println(\"Storage Permission Denied\") })}// Initialize CameraController only when permissions are granted if (cameraPermissionState.value \u0026\u0026 storagePermissionState.value) {CameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = { setCameraLens(CameraLens.BACK) setFlashMode(FlashMode.OFF) setImageFormat(ImageFormat.JPEG) setDirectory(Directory.PICTURES) addPlugin(/**Plugin here**/)}, onCameraControllerReady = { cameraController.value = it println(\"Camera Controller Ready ${cameraController.value}\") })cameraController.value?.let { controller -\u003e CameraScreen(cameraController = controller, imageSaverPlugin)}once done, run the app and you should see the permission pop up.Allow the permission and you should be able to see the previewTaking and Saving Pictures:To take pictures, let's add a a button val scope = rememberCoroutineScope()// Capture Button at the Bottom Center Button( onClick = { scope.launch { when (val result = cameraController.takePicture()) { is ImageCaptureResult.Success -\u003e { val imageBitmap = result.byteArray.decodeToImageBitmap() } is ImageCaptureResult.Error -\u003e { println(\"Image Capture Error: ${result.exception.message}\") } } } }, modifier = Modifier.size(70.dp).clip(CircleShape).align(Alignment.BottomCenter) ) { Text(text = \"Capture\") }we can take the image using takePicture function which takes one parameter ImageFormat which is an enum and has PNG and JPEG values for now. takePicture is a suspend function and should be called from a Coroutine, it then returns an object ImageCaptureResult.ImageCaptureResult is a sealed class that can be result in either success or error. coroutineScope.launch { val imageResult = controller.takePicture(ImageFormat.PNG) when (imageResult) { is ImageCaptureResult.Error -\u003e { } is ImageCaptureResult.Success -\u003e { } } }If the result is an error you can get the message from imageResult and if the result is success it will havedata class Success(val image: ByteArray, val path: String)and image which is a ByteArray and then the path where the image is saved.you can now use the image byteArray to convert it to ImageBitmap or ImageVector and display it using the Image composable. imageResult.image.decodeToImageBitmap() imageResult.image.decodeToImageVector()Why did i choose to return byteArray? The reason is if you uploading to a cloud storage such as Amazon S3 you can directly send the byte array and it will be able to handle it without an issue and you can easily convert it to image vector or image bitmap and use it inside your composables.If you want to save it to local storage. I have got you there as well either you can use any other library or your code to convert the byte array to a file and save that or you can use the built-in function.you need to add a CameraKplugin for thisimplementation(\"io.github.kashif-mehmood-km:image_saver_plugin:0.0.1\")Once you add the plugin sync the project, go back to you code and create a plugin object:val imageSaverPlugin = createImageSaverPlugin( config = ImageSaverConfig( isAutoSave = false, // Set to true to enable automatic saving prefix = \"MyApp\", // Prefix for image names when auto-saving directory = Directory.PICTURES, // Directory to save images customFolderName = \"CustomFolder\" // Custom folder name within the directory, only works on android for now ))Config can be customized according to the requirements.Next, you need to add the plugin to cameraController.CameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = { setCameraLens(CameraLens.BACK) setFlashMode(FlashMode.OFF) setImageFormat(ImageFormat.JPEG) setDirectory(Directory.PICTURES)//** add plugin here **// addPlugin(imageSaverPlugin)}, onCameraControllerReady = { cameraController.value = it println(\"Camera Controller Ready ${cameraController.value}\") })You can check the complete code here, along with the setup for QRScannerPlugin.Switching Camera:Let's add another button to switch our camera lenses. Button(onClick = {controller.toggleCameraLens() }) { Text(\"Toggle Camera Lens\") }Inside the onClick lambda we need to call a function using the controller.controller.toggleCameraLens()and it will look like this.Button(onClick = {controller.toggleCameraLens() }) { Text(\"Toggle Camera Lens\") }Switching Flash Mode:Just like flash Mode, we need to create another button/switch to toggle flash mode. We will be using a switch so we first need to create a state for flash mode trackingval flashMode = remember(controller.getFlashMode()) { controller.getFlashMode() == FlashMode.ON }Now let's add a switch so we can use it to turn on/off the camera flash.Switch( checked = flashMode, onCheckedChange = { controller.toggleFlashMode() })as simple as that.Complete Code for Camera Features:@OptIn(ExperimentalResourceApi::class, ExperimentalUuidApi::class)@Composablefun CameraScreen(cameraController: CameraController, imageSaverPlugin: ImageSaverPlugin) { val scope = rememberCoroutineScope() var imageBitmap by remember { mutableStateOf\u003cImageBitmap?\u003e(null) } var isFlashOn by remember { mutableStateOf(false) } Box( modifier = Modifier .fillMaxSize() ) { Row( modifier = Modifier .fillMaxWidth() .padding(16.dp) .align(Alignment.TopStart), horizontalArrangement = Arrangement.SpaceBetween ) { // Flash Mode Switch Row(verticalAlignment = Alignment.CenterVertically) { Text(text = \"Flash\") Spacer(modifier = Modifier.width(8.dp)) Switch( checked = isFlashOn, onCheckedChange = { isFlashOn = it cameraController.toggleFlashMode() } ) } // Camera Lens Toggle Button Button(onClick = { cameraController.toggleCameraLens() }) { Text(text = \"Toggle Lens\") } } // Capture Button at the Bottom Center Button( onClick = { scope.launch { when (val result = cameraController.takePicture()) { is ImageCaptureResult.Success -\u003e { imageBitmap = result.byteArray.decodeToImageBitmap() // If auto-save is disabled, manually save the image if (!imageSaverPlugin.config.isAutoSave) { // Generate a custom name or use default val customName = \"Manual_${Uuid.random().toHexString()}\" imageSaverPlugin.saveImage( byteArray = result.byteArray, imageName = customName ) } } is ImageCaptureResult.Error -\u003e { println(\"Image Capture Error: ${result.exception.message}\") } } } }, modifier = Modifier .size(70.dp) .clip(CircleShape) .align(Alignment.BottomCenter) ) { Text(text = \"Capture\") } // Display the captured image imageBitmap?.let { bitmap -\u003e Image( bitmap = bitmap, contentDescription = \"Captured Image\", modifier = Modifier .fillMaxSize() .padding(16.dp) ) LaunchedEffect(bitmap) { delay(3000) imageBitmap = null } } }}That’s a wrap for this article! I encourage you to give the library a try — it’s still in a very experimental phase, so your feedback is appreciated. Whether it’s issues, feature requests, or suggestions, I’d love to hear from you.If you do give it a go, let me know how it works for you. Your support, whether through claps or starring the repository, would mean the world to me and will motivate me to keep developing new features and improving what’s already there.You can connect with me on LinkedIn, X, Instagram.Happy coding! ❤️",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*6gkPU-GekSGiu6NIg49yPQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://kashif-mehmood-km.medium.com/?source=post_page-----ec92cb944ec5--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Kashif Mehmood\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*tGiKAPVbZaHZA14b-GIBEg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----ec92cb944ec5--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d331\"\u003eOver the past year, Compose Multiplatform has made impressive strides in bringing together different parts of Jetpack Compose, like lifecycle and ViewModel, into common part of KMP. But let’s be real — features like ExoPlayer and Camera aren’t quite in the common code yet. And honestly, that’s not a bad thing. Sometimes, the best solution is to use platform-specific libraries tailored to the job rather than forcing everything into a one-size-fits-all approach.\u003c/p\u003e\u003cp id=\"0998\"\u003eNow, if you’d rather skip the nitty-gritty of implementing camera features and just want to stick to writing common code, I’ve got you covered. I’ve built a library with a simple API that lets you create camera apps without the hassle. It seamlessly uses AVCamera for iOS and CameraX for Android behind the scenes, so you can stay focused on your code and let the library handle the platform specifics.\u003c/p\u003e\u003cp id=\"84b5\"\u003eLet\u0026#39;s start using the library to build a simple camera app. Get the latest version from the repo.\u003c/p\u003e\u003cp id=\"69a9\"\u003eAt the time of writing this article, the latest version is\u003cem\u003e 0.0.7. \u003c/em\u003eLet\u0026#39;s add it to the \u003ccode\u003ecommonMain\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f5ba\"\u003e    commonMain.dependencies {\u003cbr/\u003e            implementation(\u0026#34;io.github.kashif-mehmood-km:camerak:0.0.5\u0026#34;)\u003cbr/\u003e        }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f01a\"\u003eonce you add the library now sync the project.\u003c/p\u003e\u003ch2 id=\"e79a\"\u003eShowing Preview:\u003c/h2\u003e\u003cp id=\"814e\"\u003eAfter syncing is completed go to your composable where you want to create the camera preview.\u003c/p\u003e\u003cp id=\"b706\"\u003eFirst, we will need to create a \u003ccode\u003eCameraController\u003c/code\u003e which will be null initially.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8d7a\"\u003eval cameraController = remember { mutableStateOf\u0026lt;CameraController?\u0026gt;(null) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c688\"\u003eThe camera controller is an expected class that controls different features of the camera library.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"faad\"\u003eCameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = {\u003cbr/\u003e    setCameraLens(CameraLens.BACK)\u003cbr/\u003e    setFlashMode(FlashMode.OFF)\u003cbr/\u003e    setImageFormat(ImageFormat.JPEG)\u003cbr/\u003e    setDirectory(Directory.PICTURES)\u003cbr/\u003e    addPlugin(/**Plugin here**/)\u003cp\u003e}, onCameraControllerReady = {\u003cbr/\u003e    cameraController.value = it\u003cbr/\u003e    println(\u0026#34;Camera Controller Ready ${cameraController.value}\u0026#34;)\u003c/p\u003e\u003cp\u003e   })\u003c/p\u003e\u003cp\u003ecameraController.value?.let { controller -\u0026gt;\u003cbr/\u003e    CameraScreen(cameraController = controller, imageSaverPlugin)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"08ec\"\u003e\u003ccode\u003eCameraKPreview\u003c/code\u003e is a Composable function which takes three parameters a modifier to modify size, width, height and other aspects of the camera preview, \u003ccode\u003ecameraConfiguration\u003c/code\u003e which will be used to create the camera controller and \u003ccode\u003eonCameraControllerReady\u003c/code\u003e callback returns the controller once it has been built with the configuration.\u003ccode\u003eCameraK\u003c/code\u003e has a plugin-based API which means you can enhance its capabilities with existing plugins or create your own by implementing the \u003ccode\u003eCameraPlugin\u003c/code\u003e interface. Currently, there are two plugins that we have one is for saving images locally and the other is for QR scanning, more on that later.\u003c/p\u003e\u003cp id=\"7a5f\"\u003eNow, run the app….\u003c/p\u003e\u003cp id=\"4c2e\"\u003eYour app won\u0026#39;t work because we need to get permission from Android and IOS mainly \u003ccode\u003eCamera\u003c/code\u003e and \u003ccode\u003eExternal Storage\u003c/code\u003e permission on Android, \u003ccode\u003eNSCameraUsageDescription\u003c/code\u003e and \u003ccode\u003eNSPhotoLibraryUsageDescription\u003c/code\u003e for IOS.\u003c/p\u003e\u003cp id=\"9ea6\"\u003eFor Android add these to the manifest.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bbad\"\u003e\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt;\u003cbr/\u003e\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b2ea\"\u003eFor IOS add these to Info.plist\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f3da\"\u003e\u0026lt;key\u0026gt;NSCameraUsageDescription\u0026lt;/key\u0026gt;\u003cbr/\u003e\u0026lt;string\u0026gt;Camera permission is required for the app to work.\u0026lt;/string\u0026gt;\u003cbr/\u003e\u0026lt;key\u0026gt;NSPhotoLibraryUsageDescription\u0026lt;/key\u0026gt;\u003cbr/\u003e\u0026lt;string\u0026gt;Photo Library permission is required for the app to work.\u0026lt;/string\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6683\"\u003eNow, getting back to the code the library contains the required code to check the permissions and ask for required permissions as well.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"75ba\"\u003e// Initialize Camera Permission State based on current permission status  \u003cbr/\u003eval cameraPermissionState = remember {\u003cbr/\u003e    mutableStateOf(\u003cbr/\u003e        permissions.hasCameraPermission()\u003cbr/\u003e    )\u003cbr/\u003e}\u003cp\u003e// Initialize Storage Permission State  \u003cbr/\u003eval storagePermissionState = remember {\u003cbr/\u003e    mutableStateOf(\u003cbr/\u003e        permissions.hasStoragePermission()\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eif (!cameraPermissionState.value) {\u003cbr/\u003e    permissions.RequestStoragePermission(onGranted = { cameraPermissionState.value = true },\u003cbr/\u003e        onDenied = {\u003cbr/\u003e            println(\u0026#34;Camera Permission Denied\u0026#34;)\u003cbr/\u003e        })\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eif (!storagePermissionState.value) {\u003cbr/\u003e    permissions.RequestStoragePermission(onGranted = { storagePermissionState.value = true },\u003cbr/\u003e        onDenied = {\u003cbr/\u003e            println(\u0026#34;Storage Permission Denied\u0026#34;)\u003cbr/\u003e        })\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Initialize CameraController only when permissions are granted  \u003cbr/\u003eif (cameraPermissionState.value \u0026amp;\u0026amp; storagePermissionState.value) {\u003cbr/\u003eCameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = {\u003cbr/\u003e    setCameraLens(CameraLens.BACK)\u003cbr/\u003e    setFlashMode(FlashMode.OFF)\u003cbr/\u003e    setImageFormat(ImageFormat.JPEG)\u003cbr/\u003e    setDirectory(Directory.PICTURES)\u003cbr/\u003e    addPlugin(/**Plugin here**/)\u003c/p\u003e\u003cp\u003e}, onCameraControllerReady = {\u003cbr/\u003e    cameraController.value = it\u003cbr/\u003e    println(\u0026#34;Camera Controller Ready ${cameraController.value}\u0026#34;)\u003c/p\u003e\u003cp\u003e  })\u003cbr/\u003ecameraController.value?.let { controller -\u0026gt;\u003cbr/\u003e    CameraScreen(cameraController = controller, imageSaverPlugin)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7b32\"\u003eonce done, run the app and you should see the permission pop up.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8c2c\"\u003eAllow the permission and you should be able to see the preview\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"6ab2\"\u003eTaking and Saving Pictures:\u003c/h2\u003e\u003cp id=\"941b\"\u003eTo take pictures, let\u0026#39;s add a a button\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d039\"\u003e val scope = rememberCoroutineScope()\u003cbr/\u003e// Capture Button at the Bottom Center  \u003cbr/\u003e        Button(\u003cbr/\u003e            onClick = {\u003cbr/\u003e                scope.launch {\u003cbr/\u003e                    when (val result = cameraController.takePicture()) {\u003cbr/\u003e                        is ImageCaptureResult.Success -\u0026gt; {\u003cp\u003e                           val  imageBitmap = result.byteArray.decodeToImageBitmap()\u003c/p\u003e\u003cp\u003e                                                   }\u003c/p\u003e\u003cp\u003e                        is ImageCaptureResult.Error -\u0026gt; {\u003cbr/\u003e                            println(\u0026#34;Image Capture Error: ${result.exception.message}\u0026#34;)\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }, modifier = Modifier.size(70.dp).clip(CircleShape).align(Alignment.BottomCenter)\u003c/p\u003e\u003cp\u003e        ) {\u003cbr/\u003e            Text(text = \u0026#34;Capture\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"abcf\"\u003ewe can take the image using \u003ccode\u003etakePicture\u003c/code\u003e function which takes one parameter \u003ccode\u003eImageFormat\u003c/code\u003e which is an enum and has \u003ccode\u003ePNG\u003c/code\u003e and \u003ccode\u003eJPEG\u003c/code\u003e values for now. \u003ccode\u003etakePicture\u003c/code\u003e is a suspend function and should be called from a Coroutine, it then returns an object \u003ccode\u003eImageCaptureResult\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"3aec\"\u003e\u003ccode\u003eImageCaptureResult\u003c/code\u003e is a sealed class that can be result in either success or error.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6f92\"\u003e  coroutineScope.launch {\u003cbr/\u003e                    val imageResult = controller.takePicture(ImageFormat.PNG)\u003cp\u003e                    when (imageResult) {\u003cbr/\u003e                        is ImageCaptureResult.Error -\u0026gt; {\u003c/p\u003e\u003cp\u003e                        }\u003c/p\u003e\u003cp\u003e                        is ImageCaptureResult.Success -\u0026gt; {\u003c/p\u003e\u003cp\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"074d\"\u003eIf the result is an error you can get the message from \u003ccode\u003eimageResult\u003c/code\u003e and if the result is success it will have\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1c0d\"\u003edata class Success(val image: ByteArray, val path: String)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"816b\"\u003eand image which is a \u003ccode\u003eByteArray\u003c/code\u003e and then the \u003ccode\u003epath\u003c/code\u003e where the image is saved.\u003c/p\u003e\u003cp id=\"a9bc\"\u003eyou can now use the \u003ccode\u003eimage\u003c/code\u003e byteArray to convert it to \u003ccode\u003eImageBitmap\u003c/code\u003e or \u003ccode\u003eImageVector\u003c/code\u003e and display it using the \u003ccode\u003eImage\u003c/code\u003e composable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd0c\"\u003e   imageResult.image.decodeToImageBitmap()\u003cbr/\u003e   imageResult.image.decodeToImageVector()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0194\"\u003eWhy did i choose to return byteArray? The reason is if you uploading to a cloud storage such as Amazon S3 you can directly send the byte array and it will be able to handle it without an issue and you can easily convert it to image vector or image bitmap and use it inside your composables.\u003c/p\u003e\u003cp id=\"65da\"\u003eIf you want to save it to local storage. I have got you there as well either you can use any other library or your code to convert the byte array to a file and save that or you can use the built-in function.\u003c/p\u003e\u003cp id=\"aa1a\"\u003eyou need to add a \u003ccode\u003eCameraK\u003c/code\u003eplugin for this\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5fb2\"\u003eimplementation(\u0026#34;io.github.kashif-mehmood-km:image_saver_plugin:0.0.1\u0026#34;)\u003cbr/\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f9c6\"\u003eOnce you add the plugin sync the project, go back to you code and create a plugin object:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5bd8\"\u003eval imageSaverPlugin = createImageSaverPlugin(\u003cbr/\u003e    config = ImageSaverConfig(\u003cbr/\u003e        isAutoSave = false, // Set to true to enable automatic saving  \u003cbr/\u003e        prefix = \u0026#34;MyApp\u0026#34;, // Prefix for image names when auto-saving  \u003cbr/\u003e        directory = Directory.PICTURES, // Directory to save images  \u003cbr/\u003e        customFolderName = \u0026#34;CustomFolder\u0026#34; // Custom folder name within the directory, only works on android for now  \u003cbr/\u003e    )\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0cf1\"\u003eConfig can be customized according to the requirements.\u003c/p\u003e\u003cp id=\"3d09\"\u003eNext, you need to add the plugin to cameraController.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"13c0\"\u003eCameraPreview(modifier = Modifier.fillMaxSize(), cameraConfiguration = {\u003cbr/\u003e    setCameraLens(CameraLens.BACK)\u003cbr/\u003e    setFlashMode(FlashMode.OFF)\u003cbr/\u003e    setImageFormat(ImageFormat.JPEG)\u003cbr/\u003e    setDirectory(Directory.PICTURES)\u003cbr/\u003e//** add plugin here **//\u003cbr/\u003e    addPlugin(imageSaverPlugin)\u003cbr/\u003e}, onCameraControllerReady = {\u003cbr/\u003e    cameraController.value = it\u003cbr/\u003e    println(\u0026#34;Camera Controller Ready ${cameraController.value}\u0026#34;)\u003cp\u003e    })\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0808\"\u003eYou can check the complete code here, along with the setup for \u003ccode\u003eQRScannerPlugin\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"09d8\"\u003eSwitching Camera:\u003c/h2\u003e\u003cp id=\"e0f4\"\u003eLet\u0026#39;s add another button to switch our camera lenses.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"79d5\"\u003e Button(onClick = {controller.toggleCameraLens() }) {\u003cbr/\u003e   Text(\u0026#34;Toggle Camera Lens\u0026#34;)\u003cbr/\u003e }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"294a\"\u003eInside the \u003ccode\u003eonClick\u003c/code\u003e lambda we need to call a function using the controller.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bb30\"\u003econtroller.toggleCameraLens()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"37e5\"\u003eand it will look like this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"527c\"\u003eButton(onClick = {controller.toggleCameraLens() }) {\u003cbr/\u003e   Text(\u0026#34;Toggle Camera Lens\u0026#34;)\u003cbr/\u003e }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"b265\"\u003eSwitching Flash Mode:\u003c/h2\u003e\u003cp id=\"c4c0\"\u003eJust like flash Mode, we need to create another button/switch to toggle flash mode. We will be using a switch so we first need to create a state for flash mode tracking\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f63d\"\u003eval flashMode = remember(controller.getFlashMode()) {\u003cbr/\u003e        controller.getFlashMode() == FlashMode.ON\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2471\"\u003eNow let\u0026#39;s add a switch so we can use it to turn on/off the camera flash.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1e13\"\u003eSwitch(\u003cbr/\u003e       checked = flashMode,\u003cbr/\u003e       onCheckedChange = { controller.toggleFlashMode() }\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"52b8\"\u003eas simple as that.\u003c/p\u003e\u003ch2 id=\"47bd\"\u003eComplete Code for Camera Features:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"aab4\"\u003e@OptIn(ExperimentalResourceApi::class, ExperimentalUuidApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun CameraScreen(cameraController: CameraController, imageSaverPlugin: ImageSaverPlugin) {\u003cbr/\u003e    val scope = rememberCoroutineScope()\u003cbr/\u003e    var imageBitmap by remember { mutableStateOf\u0026lt;ImageBitmap?\u0026gt;(null) }\u003cbr/\u003e    var isFlashOn by remember { mutableStateOf(false) }\u003cp\u003e    Box(\u003cbr/\u003e        modifier = Modifier\u003cbr/\u003e            .fillMaxSize()\u003cbr/\u003e    ) {\u003c/p\u003e\u003cp\u003e        Row(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxWidth()\u003cbr/\u003e                .padding(16.dp)\u003cbr/\u003e                .align(Alignment.TopStart),\u003cbr/\u003e            horizontalArrangement = Arrangement.SpaceBetween\u003cbr/\u003e        ) {\u003cbr/\u003e            // Flash Mode Switch\u003cbr/\u003e            Row(verticalAlignment = Alignment.CenterVertically) {\u003cbr/\u003e                Text(text = \u0026#34;Flash\u0026#34;)\u003cbr/\u003e                Spacer(modifier = Modifier.width(8.dp))\u003cbr/\u003e                Switch(\u003cbr/\u003e                    checked = isFlashOn,\u003cbr/\u003e                    onCheckedChange = {\u003cbr/\u003e                        isFlashOn = it\u003cbr/\u003e                        cameraController.toggleFlashMode()\u003cbr/\u003e                    }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            // Camera Lens Toggle Button\u003cbr/\u003e            Button(onClick = { cameraController.toggleCameraLens() }) {\u003cbr/\u003e                Text(text = \u0026#34;Toggle Lens\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Capture Button at the Bottom Center\u003cbr/\u003e        Button(\u003cbr/\u003e            onClick = {\u003cbr/\u003e                scope.launch {\u003cbr/\u003e                    when (val result = cameraController.takePicture()) {\u003cbr/\u003e                        is ImageCaptureResult.Success -\u0026gt; {\u003c/p\u003e\u003cp\u003e                            imageBitmap = result.byteArray.decodeToImageBitmap()\u003cbr/\u003e                            // If auto-save is disabled, manually save the image\u003cbr/\u003e                            if (!imageSaverPlugin.config.isAutoSave) {\u003cbr/\u003e                                // Generate a custom name or use default\u003cbr/\u003e                                val customName = \u0026#34;Manual_${Uuid.random().toHexString()}\u0026#34;\u003c/p\u003e\u003cp\u003e                                imageSaverPlugin.saveImage(\u003cbr/\u003e                                    byteArray = result.byteArray,\u003cbr/\u003e                                    imageName = customName\u003cbr/\u003e                                )\u003cbr/\u003e                            }\u003cbr/\u003e                        }\u003c/p\u003e\u003cp\u003e                        is ImageCaptureResult.Error -\u0026gt; {\u003cbr/\u003e                            println(\u0026#34;Image Capture Error: ${result.exception.message}\u0026#34;)\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            },\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .size(70.dp)\u003cbr/\u003e                .clip(CircleShape)\u003cbr/\u003e                .align(Alignment.BottomCenter)\u003c/p\u003e\u003cp\u003e        ) {\u003cbr/\u003e            Text(text = \u0026#34;Capture\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // Display the captured image\u003cbr/\u003e        imageBitmap?.let { bitmap -\u0026gt;\u003cbr/\u003e            Image(\u003cbr/\u003e                bitmap = bitmap,\u003cbr/\u003e                contentDescription = \u0026#34;Captured Image\u0026#34;,\u003cbr/\u003e                modifier = Modifier\u003cbr/\u003e                    .fillMaxSize()\u003cbr/\u003e                    .padding(16.dp)\u003cbr/\u003e            )\u003c/p\u003e\u003cp\u003e            LaunchedEffect(bitmap) {\u003cbr/\u003e                delay(3000)\u003cbr/\u003e                imageBitmap = null\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6900\"\u003eThat’s a wrap for this article! I encourage you to give the library a try — it’s still in a very experimental phase, so your feedback is appreciated. Whether it’s issues, feature requests, or suggestions, I’d love to hear from you.\u003c/p\u003e\u003cp id=\"96ac\"\u003eIf you do give it a go, let me know how it works for you. Your support, whether through claps or starring the repository, would mean the world to me and will motivate me to keep developing new features and improving what’s already there.\u003c/p\u003e\u003cp id=\"f5b4\"\u003eYou can connect with me on \u003ca href=\"https://www.linkedin.com/in/kashif-mehmood-km/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e, \u003ca href=\"https://x.com/kashif_mehmood_\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eX\u003c/a\u003e, \u003ca href=\"https://instagram.com/kashif_mughal._\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInstagram\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"3222\"\u003eHappy coding! ❤️\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-10-08T15:37:13.571Z",
  "modifiedTime": null
}
