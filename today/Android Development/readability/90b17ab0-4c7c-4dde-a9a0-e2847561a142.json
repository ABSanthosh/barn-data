{
  "id": "90b17ab0-4c7c-4dde-a9a0-e2847561a142",
  "title": "Integrating Google ML Kit for Barcode Scanning in Jetpack Compose Android Apps",
  "link": "https://proandroiddev.com/integrating-google-ml-kit-for-barcode-scanning-in-jetpack-compose-android-apps-5deda28377c9?source=rss----c72404660798---4",
  "description": "",
  "author": "Anthony",
  "published": "Sat, 11 Jan 2025 22:45:04 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "ai",
    "jetpack-compose",
    "android",
    "qr-code",
    "cameras"
  ],
  "byline": "Anthony",
  "length": 9703,
  "excerpt": "QR codes and barcodes are everywhere, whether it’s scanning tickets at events, accessing product details in a supermarket, or enabling seamless payments. These compact codes have become essential…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Full Project:https://github.com/DUMA042/BarsandQQR codes and barcodes are everywhere, whether it’s scanning tickets at events, accessing product details in a supermarket, or enabling seamless payments. These compact codes have become essential tools for data sharing, authentication, and inventory management.As an Android developer, integrating barcode and QR code scanning into your app can unlock a wide range of possibilities for your users. In this blog, we’ll explore how to build a modern scanner using Kotlin, Jetpack Compose, and Google ML Kit. By the end of this guide, you’ll have a fully functional scanner that leverages the power of machine learning and the simplicity of declarative UI development.1 Setting up the project and adding dependenciesAndroidManifest.xmlNeeded for the Camera PermissionTo enable barcode and QR code scanning, your app needs access to the device’s camera. Start by adding the CAMERA permission to your AndroidManifest.xml file. This permission is required to use the camera for scanning:\u003cuses-permission android:name=\"android.permission.CAMERA\" /\u003eAdditionally, if your app relies on the camera as a core feature (and won’t function properly without it), you should declare this using the \u003cuses-feature\u003e tag. This ensures that your app is only installed on devices with a camera:\u003cuses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /\u003eIf the camera is optional for your app, you can set android:required=\"false\" instead. These steps ensure your app has the necessary permissions and hardware requirements to support barcode scanning. In the sample application android:required=\"true\" because the camera is needed for the scanning of the Bar-code and QR-code.libs.versions.tomlNeeded dependences for CameraX and MLkitGradle app build file:Gradle dependences2 Setting up camera permission:For the permission we are going to use the accompanist permissions library. The dependency has already been setup in the previous set, so we can move straight to the implementation.I will be making a composable for the HomeScreen. For simplicity of this article this composable will handle and host the permission state as well as the result from the Scanned QR code or Barcode.Code for the permission3 Setting up the Scanner3.1 Setting Up the Camera with CameraX:To implement the camera functionality (which will be needed for the scanning of the barcode) we are going to use CameraX, a modern Android library that simplifies camera operations and ensures compatibility across devices. The LifecycleCameraController is initialized and is used to simplify camera interactions by binding the camera’s lifecycle to a LifecycleOwner (ex: an Activity or Fragment). and bound to the lifecycleOwner (ex: an Activity ), ensuring the camera respects the app’s lifecycle (for ex: pausing when the app goes to the background). The AndroidView composable is used to integrate the PreviewView, which displays the live camera feed.Setting up the CameraIn this block:LifecycleCameraController manages the camera’s lifecycle and simplifies camera operations.AndroidView is used to embed the PreviewView (a traditional Android View) into a Jetpack Compose UI.The PreviewView displays the live camera feed, and the cameraController is bound to the lifecycleOwner to ensure proper lifecycle handling.3.2 Implementing Barcode Scanning with ML KitConfiguring Barcode Scanner Options:The first step in implementing barcode scanning is to configure the barcode formats that the scanner should detect. Google ML Kit supports a wide range of barcode formats, including QR codes, UPC codes, and more. We use the BarcodeScannerOptions.Builder() to specify the formats we want to support.Here’s the code:Barcode builderWhy this matters: By specifying the formats, you ensure the scanner only looks for relevant barcodes, improving efficiency and reducing false positives.Customization: You can add or remove formats based on your app’s requirements.Initializing the Barcode Scanner://inside your ScanCode.kts fileval barcodeScanner = BarcodeScanning.getClient(options)What this does: The barcodeScanner is the core component that analyzes camera frames and detects barcodes.Performance: ML Kit’s barcode scanner is optimized for real-time performance and works offline, making it ideal for mobile apps.3.3 Setting Up Image Analyzer with CameraX:To process camera frames, we use CameraX’s ImageAnalysis API. This API allows us to analyze each frame in real time and pass it to the barcode scanner. The MlKitAnalyzer is a utility provided by CameraX to integrate ML Kit with image analysis.Here’s the code:Setting up image AnalyzerKey Components:ContextCompat.getMainExecutor(ctx): Ensures the analysis runs on the main thread.ImageAnalysis.COORDINATE_SYSTEM_VIEW_REFERENCED: Aligns the barcode coordinates with the camera preview.MlKitAnalyzer: Bridges CameraX and ML Kit, simplifying the integration.3.4 Processing Barcode Results:When a barcode is detected, the MlKitAnalyzer returns a list of Barcode objects. Each Barcode contains information such as the raw value, format, and bounding box. We extract this information and update the UI state.Here’s the code:Processing Barcode ResultKey Components:barcodeResults.first().rawValue: Extracts the raw value of the detected barcode (e.g., a URL or text).boundingRect: Stores the bounding box of the barcode, which is used to draw a rectangle around it in the UI.qrCodeDetected: A boolean state that triggers further actions (e.g., invoking a callback).What we’ve covered so far:Configure Barcode Formats: Specify the types of barcodes the scanner should detect.Initialize the Scanner: Create a BarcodeScanning client with the configured options.Set Up Image Analysis: Use CameraX’s ImageAnalysis API to process camera frames.Process Results: Extract the barcode value and bounding box from the detected barcode.Update UI State: Store the barcode value and bounding box for further processing and display.Code Example for the Entire Barcode Scanning Logic:Mlkit full implementation3.5 Handling Detected BarcodesThe onQrCodeDetected parameter is a callback function that allows the parent composable to handle the detected barcode value. This is a common pattern in Jetpack Compose for passing data or events up the UI hierarchy. When a barcode is detected, the qrCodeDetected state is set to true, triggering a LaunchedEffect.LaunchedEffect Delay for DrawRectangle to complete composeIn this block:onQrCodeDetected is a lambda function that takes the detected barcode value as a parameter. This allows the parent composable to handle the result (e.g., navigating to a new screen or displaying the barcode data).LaunchedEffect is used to perform a side effect (invoking the callback) in a controlled manner. It ensures the callback is only triggered once when qrCodeDetected changes to true.A short delay is added to allow the UI to recompose before invoking the callback. This prevents potential race conditions and ensures a smooth user experience.3.6 Drawing the Barcode Bounding BoxTo provide visual feedback, a rectangle is drawn around the detected barcode using Jetpack Compose’s Canvas API. The DrawRectangle composable converts the Android Rect to a Compose Rect and draws it on the screen.Here’s the code:Draw Rectangle ComposeIn this block:The Rect object from ML Kit is converted to a Compose-compatible Rect.The Canvas composable is used to draw a red rectangle around the detected barcode, providing visual feedback to the user.LaunchedEffect is a key part of Jetpack Compose’s side-effect handling. It ensures that the callback (onQrCodeDetected) is only triggered once when the qrCodeDetected state changes. The delay ensures the UI has enough time to recompose before the callback is executed, preventing any visual glitches or inconsistencies. This approach aligns with Compose’s reactive programming model, where side effects are managed explicitly to maintain a predictable and efficient UI.Complete ScanCode Implementation:Complete ScanCode.kts file codeRunning the application and Scanning a Qrcode or Barcode:Run your code and you will have some this like this:Screen After permission has been GrantedWhen Button is clicked and Camera is placed on a QrcodeAfter the Scanned result has been GottenConclusionBuilding a barcode and QR code scanner in Android has never been easier, thanks to the powerful combination of Jetpack Compose, CameraX, and Google ML Kit. In this article, we’ve explored how to create a seamless scanning experience by integrating these modern tools. From setting up the camera and configuring ML Kit’s barcode detection to handling scanned results and drawing bounding boxes, we’ve covered all the essential steps to get you started.Key highlights of this implementation include:CameraX for reliable and lifecycle-aware camera operations.ML Kit for fast and accurate barcode and QR code detection, even offline.Jetpack Compose for building a dynamic and responsive UI with minimal boilerplate code.The use of onQrCodeDetected and LaunchedEffect to handle scanned results efficiently and ensure a smooth user experience.This implementation is highly customizable and can be adapted to various use cases, such as payment systems, inventory management, or event ticketing. By following this guide, you now have a solid foundation to build upon and enhance your app with advanced features like multi-scan support, custom UI overlays, or integration with cloud services.I hope this article has provided you with the knowledge and tools to implement barcode and QR code scanning in your Android app. Feel free to experiment, iterate, and take your app to the next level. Stay happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:520/1*BhQjF8UPhqvIl7oDn7u3XQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@Anthony042?source=post_page---byline--5deda28377c9--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anthony\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*hu489Sz9dSRQbYx2vCNxGw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--5deda28377c9--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cblockquote\u003e\u003cp id=\"b65a\"\u003e\u003cstrong\u003eFull Project:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c525\"\u003e\u003ca href=\"https://github.com/DUMA042/BarsandQ\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003ehttps://github.com/DUMA042/BarsandQ\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"a708\"\u003eQR codes and barcodes are everywhere, whether it’s scanning tickets at events, accessing product details in a supermarket, or enabling seamless payments. These compact codes have become essential tools for data sharing, authentication, and inventory management.\u003c/p\u003e\u003cp id=\"39be\"\u003eAs an Android developer, integrating barcode and QR code scanning into your app can unlock a wide range of possibilities for your users. In this blog, we’ll explore how to build a modern scanner using \u003cstrong\u003eKotlin\u003c/strong\u003e, \u003cstrong\u003eJetpack Compose\u003c/strong\u003e, and \u003cstrong\u003eGoogle ML Kit\u003c/strong\u003e. By the end of this guide, you’ll have a fully functional scanner that leverages the power of machine learning and the simplicity of declarative UI development.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e480\"\u003e\u003cstrong\u003e1 Setting up the project and adding dependencies\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"d4f6\"\u003eAndroidManifest.xml\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNeeded for the Camera Permission\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"b09e\"\u003eTo enable barcode and QR code scanning, your app needs access to the device’s camera. Start by adding the \u003ccode\u003eCAMERA\u003c/code\u003e permission to your \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e file. This permission is required to use the camera for scanning:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c513\"\u003e\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8958\"\u003eAdditionally, if your app relies on the camera as a core feature (and won’t function properly without it), you should declare this using the \u003ccode\u003e\u0026lt;uses-feature\u0026gt;\u003c/code\u003e tag. This ensures that your app is only installed on devices with a camera:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bc49\"\u003e\u0026lt;uses-feature android:name=\u0026#34;android.hardware.camera\u0026#34; android:required=\u0026#34;true\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"62a9\"\u003eIf the camera is optional for your app, you can set \u003ccode\u003eandroid:required=\u0026#34;false\u0026#34;\u003c/code\u003e instead. These steps ensure your app has the necessary permissions and hardware requirements to support barcode scanning. In the sample application \u003ccode\u003eandroid:required=\u0026#34;true\u0026#34;\u003c/code\u003e because the camera is needed for the scanning of the Bar-code and QR-code.\u003c/p\u003e\u003cp id=\"5a1f\"\u003e\u003cstrong\u003elibs.versions.toml\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNeeded dependences for CameraX and MLkit\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"aa48\"\u003e\u003cstrong\u003eGradle app build file:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eGradle dependences\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"baad\"\u003e\u003cstrong\u003e2 Setting up camera permission:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"69ca\"\u003eFor the permission we are going to use the accompanist permissions library. The dependency has already been setup in the previous set, so we can move straight to the implementation.\u003c/p\u003e\u003cp id=\"08fa\"\u003eI will be making a composable for the \u003cstrong\u003eHomeScreen\u003c/strong\u003e. For simplicity of this article this composable will handle and host the permission state as well as the result from the Scanned QR code or Barcode.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCode for the permission\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"f693\"\u003e\u003cstrong\u003e3 Setting up the Scanner\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3e00\"\u003e\u003cstrong\u003e3.1 Setting Up the Camera with CameraX:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"62bf\"\u003eTo implement the camera functionality (which will be needed for the scanning of the barcode) we are going to use \u003cstrong\u003eCameraX\u003c/strong\u003e, a modern Android library that simplifies camera operations and ensures compatibility across devices. The \u003ccode\u003eLifecycleCameraController\u003c/code\u003e is initialized and is used to simplify camera interactions by binding the camera’s lifecycle to a \u003cstrong\u003eLifecycleOwner\u003c/strong\u003e (ex: an Activity or Fragment). and bound to the \u003ccode\u003elifecycleOwner \u003c/code\u003e(ex: an Activity ), ensuring the camera respects the app’s lifecycle (for ex: pausing when the app goes to the background). The \u003ccode\u003eAndroidView\u003c/code\u003e composable is used to integrate the \u003ccode\u003ePreviewView\u003c/code\u003e, which displays the live camera feed.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSetting up the Camera\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"a45f\"\u003eIn this block:\u003c/p\u003e\u003cp id=\"3650\"\u003e\u003ccode\u003eLifecycleCameraController\u003c/code\u003e manages the camera’s lifecycle and simplifies camera operations.\u003c/p\u003e\u003cp id=\"f473\"\u003e\u003ccode\u003eAndroidView\u003c/code\u003e is used to embed the \u003ccode\u003ePreviewView\u003c/code\u003e (a traditional Android \u003ccode\u003eView\u003c/code\u003e) into a Jetpack Compose UI.\u003c/p\u003e\u003cp id=\"076b\"\u003eThe \u003ccode\u003ePreviewView\u003c/code\u003e displays the live camera feed, and the \u003ccode\u003ecameraController\u003c/code\u003e is bound to the \u003ccode\u003elifecycleOwner\u003c/code\u003e to ensure proper lifecycle handling.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e400\"\u003e\u003cstrong\u003e3.2 Implementing Barcode Scanning with ML Kit\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"763a\"\u003e\u003cstrong\u003eConfiguring Barcode Scanner Options:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"30e1\"\u003eThe first step in implementing barcode scanning is to configure the \u003cstrong\u003ebarcode formats\u003c/strong\u003e that the scanner should detect. Google ML Kit supports a wide range of barcode formats, including QR codes, UPC codes, and more. We use the \u003ccode\u003eBarcodeScannerOptions.Builder()\u003c/code\u003e to specify the formats we want to support.\u003c/p\u003e\u003cp id=\"e956\"\u003eHere’s the code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eBarcode builder\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"ce1f\"\u003e\u003cstrong\u003eWhy this matters\u003c/strong\u003e: By specifying the formats, you ensure the scanner only looks for relevant barcodes, improving efficiency and reducing false positives.\u003c/p\u003e\u003cp id=\"bc9f\"\u003e\u003cstrong\u003eCustomization\u003c/strong\u003e: You can add or remove formats based on your app’s requirements.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8061\"\u003e\u003cstrong\u003eInitializing the Barcode Scanner:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9994\"\u003e//inside your ScanCode.kts file\u003cbr/\u003eval barcodeScanner = BarcodeScanning.getClient(options)\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"18ac\"\u003e\u003cstrong\u003eWhat this does\u003c/strong\u003e: The \u003ccode\u003ebarcodeScanner\u003c/code\u003e is the core component that analyzes camera frames and detects barcodes.\u003c/p\u003e\u003cp id=\"2ee4\"\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e: ML Kit’s barcode scanner is optimized for real-time performance and works offline, making it ideal for mobile apps.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"5d50\"\u003e\u003cstrong\u003e3.3 Setting Up Image Analyzer with CameraX:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"ee61\"\u003eTo process camera frames, we use \u003cstrong\u003eCameraX’s \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eImageAnalysis\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e API\u003c/strong\u003e. This API allows us to analyze each frame in real time and pass it to the barcode scanner. The \u003ccode\u003eMlKitAnalyzer\u003c/code\u003e is a utility provided by CameraX to integrate ML Kit with image analysis.\u003c/p\u003e\u003cp id=\"8170\"\u003eHere’s the code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSetting up image Analyzer\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"7763\"\u003e\u003cstrong\u003eKey Components\u003c/strong\u003e:\u003c/p\u003e\u003cp id=\"5866\"\u003e\u003ccode\u003eContextCompat.getMainExecutor(ctx)\u003c/code\u003e: Ensures the analysis runs on the main thread.\u003c/p\u003e\u003cp id=\"6864\"\u003e\u003ccode\u003eImageAnalysis.COORDINATE_SYSTEM_VIEW_REFERENCED\u003c/code\u003e: Aligns the barcode coordinates with the camera preview.\u003c/p\u003e\u003cp id=\"96ce\"\u003e\u003ccode\u003eMlKitAnalyzer\u003c/code\u003e: Bridges CameraX and ML Kit, simplifying the integration.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"b719\"\u003e\u003cstrong\u003e3.4 Processing Barcode Results:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c80e\"\u003eWhen a barcode is detected, the \u003ccode\u003eMlKitAnalyzer\u003c/code\u003e returns a list of \u003ccode\u003eBarcode\u003c/code\u003e objects. Each \u003ccode\u003eBarcode\u003c/code\u003e contains information such as the raw value, format, and bounding box. We extract this information and update the UI state.\u003c/p\u003e\u003cp id=\"63c5\"\u003eHere’s the code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eProcessing Barcode Result\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"b606\"\u003e\u003cstrong\u003eKey Components\u003c/strong\u003e:\u003c/p\u003e\u003cp id=\"5ea7\"\u003e\u003ccode\u003ebarcodeResults.first().rawValue\u003c/code\u003e: Extracts the raw value of the detected barcode (e.g., a URL or text).\u003c/p\u003e\u003cp id=\"84ad\"\u003e\u003ccode\u003eboundingRect\u003c/code\u003e: Stores the bounding box of the barcode, which is used to draw a rectangle around it in the UI.\u003c/p\u003e\u003cp id=\"c383\"\u003e\u003ccode\u003eqrCodeDetected\u003c/code\u003e: A boolean state that triggers further actions (e.g., invoking a callback).\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"d716\"\u003e\u003cstrong\u003eWhat we’ve covered so far:\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"de00\"\u003e\u003cstrong\u003eConfigure Barcode Formats\u003c/strong\u003e: Specify the types of barcodes the scanner should detect.\u003c/li\u003e\u003cli id=\"af54\"\u003e\u003cstrong\u003eInitialize the Scanner\u003c/strong\u003e: Create a \u003ccode\u003eBarcodeScanning\u003c/code\u003e client with the configured options.\u003c/li\u003e\u003cli id=\"5e44\"\u003e\u003cstrong\u003eSet Up Image Analysis\u003c/strong\u003e: Use CameraX’s \u003ccode\u003eImageAnalysis\u003c/code\u003e API to process camera frames.\u003c/li\u003e\u003cli id=\"e639\"\u003e\u003cstrong\u003eProcess Results\u003c/strong\u003e: Extract the barcode value and bounding box from the detected barcode.\u003c/li\u003e\u003cli id=\"2034\"\u003e\u003cstrong\u003eUpdate UI State\u003c/strong\u003e: Store the barcode value and bounding box for further processing and display.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a05c\"\u003e\u003cstrong\u003eCode Example for the Entire Barcode Scanning Logic:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eMlkit full implementation\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ad7c\"\u003e\u003cstrong\u003e3.5 Handling Detected Barcodes\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"730a\"\u003eThe \u003ccode\u003eonQrCodeDetected\u003c/code\u003e parameter is a \u003cstrong\u003ecallback function\u003c/strong\u003e that allows the parent composable to handle the detected barcode value. This is a common pattern in Jetpack Compose for passing data or events up the UI hierarchy. When a barcode is detected, the \u003ccode\u003eqrCodeDetected\u003c/code\u003e state is set to \u003ccode\u003etrue\u003c/code\u003e, triggering a \u003ccode\u003eLaunchedEffect\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eLaunchedEffect Delay for DrawRectangle to complete compose\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"bc31\"\u003eIn this block:\u003c/p\u003e\u003cp id=\"6342\"\u003e\u003ccode\u003eonQrCodeDetected\u003c/code\u003e is a lambda function that takes the detected barcode value as a parameter. This allows the parent composable to handle the result (e.g., navigating to a new screen or displaying the barcode data).\u003c/p\u003e\u003cp id=\"5215\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e is used to perform a \u003cstrong\u003eside effect\u003c/strong\u003e (invoking the callback) in a controlled manner. It ensures the callback is only triggered once when \u003ccode\u003eqrCodeDetected\u003c/code\u003e changes to \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ebf6\"\u003eA short \u003ccode\u003edelay\u003c/code\u003e is added to allow the UI to recompose before invoking the callback. This prevents potential race conditions and ensures a smooth user experience.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"f442\"\u003e\u003cstrong\u003e3.6 Drawing the Barcode Bounding Box\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c096\"\u003eTo provide visual feedback, a rectangle is drawn around the detected barcode using Jetpack Compose’s \u003ccode\u003eCanvas\u003c/code\u003e API. The \u003ccode\u003eDrawRectangle\u003c/code\u003e composable converts the Android \u003ccode\u003eRect\u003c/code\u003e to a Compose \u003ccode\u003eRect\u003c/code\u003e and draws it on the screen.\u003c/p\u003e\u003cp id=\"72aa\"\u003eHere’s the code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDraw Rectangle Compose\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"9c39\"\u003eIn this block:\u003c/p\u003e\u003cp id=\"8965\"\u003eThe \u003ccode\u003eRect\u003c/code\u003e object from ML Kit is converted to a Compose-compatible \u003ccode\u003eRect\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"d6c7\"\u003eThe \u003ccode\u003eCanvas\u003c/code\u003e composable is used to draw a red rectangle around the detected barcode, providing visual feedback to the user.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"e6ae\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e is a key part of Jetpack Compose’s side-effect handling. It ensures that the callback (\u003ccode\u003eonQrCodeDetected\u003c/code\u003e) is only triggered once when the \u003ccode\u003eqrCodeDetected\u003c/code\u003e state changes. The \u003ccode\u003edelay\u003c/code\u003e ensures the UI has enough time to recompose before the callback is executed, preventing any visual glitches or inconsistencies. This approach aligns with Compose’s reactive programming model, where side effects are managed explicitly to maintain a predictable and efficient UI.\u003c/p\u003e\u003cp id=\"8c23\"\u003e\u003cstrong\u003eComplete ScanCode Implementation:\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eComplete ScanCode.kts file code\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"874b\"\u003e\u003cstrong\u003eRunning the application and Scanning a Qrcode or Barcode:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c730\"\u003eRun your code and you will have some this like this:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eScreen After permission has been Granted\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eWhen Button is clicked and Camera is placed on a Qrcode\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eAfter the Scanned result has been Gotten\u003c/figcaption\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"66a1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"484e\"\u003eBuilding a barcode and QR code scanner in Android has never been easier, thanks to the powerful combination of \u003cstrong\u003eJetpack Compose\u003c/strong\u003e, \u003cstrong\u003eCameraX\u003c/strong\u003e, and \u003cstrong\u003eGoogle ML Kit\u003c/strong\u003e. In this article, we’ve explored how to create a seamless scanning experience by integrating these modern tools. From setting up the camera and configuring ML Kit’s barcode detection to handling scanned results and drawing bounding boxes, we’ve covered all the essential steps to get you started.\u003c/p\u003e\u003cp id=\"297b\"\u003eKey highlights of this implementation include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d9a1\"\u003e\u003cstrong\u003eCameraX\u003c/strong\u003e for reliable and lifecycle-aware camera operations.\u003c/li\u003e\u003cli id=\"ba92\"\u003e\u003cstrong\u003eML Kit\u003c/strong\u003e for fast and accurate barcode and QR code detection, even offline.\u003c/li\u003e\u003cli id=\"a197\"\u003e\u003cstrong\u003eJetpack Compose\u003c/strong\u003e for building a dynamic and responsive UI with minimal boilerplate code.\u003c/li\u003e\u003cli id=\"f2e2\"\u003eThe use of \u003ccode\u003eonQrCodeDetected\u003c/code\u003e and \u003ccode\u003eLaunchedEffect\u003c/code\u003e to handle scanned results efficiently and ensure a smooth user experience.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"44d9\"\u003eThis implementation is highly customizable and can be adapted to various use cases, such as payment systems, inventory management, or event ticketing. By following this guide, you now have a solid foundation to build upon and enhance your app with advanced features like multi-scan support, custom UI overlays, or integration with cloud services.\u003c/p\u003e\u003cp id=\"640e\"\u003eI hope this article has provided you with the knowledge and tools to implement barcode and QR code scanning in your Android app. Feel free to experiment, iterate, and take your app to the next level. \u003cstrong\u003eStay happy coding!\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-01-11T22:45:04.284Z",
  "modifiedTime": null
}
