{
  "id": "8f7d4b6f-1825-45f5-a390-0c5c0027cc81",
  "title": "Sealed goodies coming in Kotlin 1.5",
  "link": "https://zsmb.co/sealed-goodies-coming-in-kotlin-1-5/",
  "description": "Kotlin 1.5 will bring exciting new features, among them improvements to sealed classes and an introduction of sealed interfaces. Let's take a look at what that will look like!",
  "author": "Márton Braun",
  "published": "Tue, 19 Jan 2021 14:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 9286,
  "excerpt": "Kotlin 1.5 will bring exciting new features, among them improvements to sealed classes and an introduction of sealed interfaces. Let's take a look at what that will look like!",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "Preview! Heads up: most things covered in this post are in a preview state of some sort. If you want the full technical details on this topic, you can jump to KEEP-226 and its design proposal instead of reading this article. JDK15 introduced a version of sealed classes and interfaces (see JEP 360) in a preview state. These let you restrict inheritance hierarchies, and perform checks on these types with pattern matching. (See this article for Java example code.) These features are expected to be stable in JDK17 at the earliest. In the meantime, Kotlin has had sealed classes since its release, but not sealed interfaces. Now that new JDK versions are adding support for these constructs, Kotlin needs to have an idea of them as well, so that it’ll be able to interoperate with new Java code. In this article, we’ll recap what sealed classes do, how they’ve evolved so far, and what new goodies you can expect to get when Kotlin 1.5 lands. Update: As of May 5, 2021, the features here are now available in stable Kotlin versions 1.5 and later, see here for the 1.5 changes. Sealed classes 101 Sealed classes are a really popular Kotlin feature: they allow you to restrict the type hierarchy, and prevent unknown subclasses of a base class. They’re kind of like enums with super powers: while enums define a fixed set of instances, sealed classes define a fixed set of types. Importantly, each “branch” of a sealed class is a full-fledged Kotlin class, and can have its own properties and methods. Originally, all subclasses had to be nested inside the sealed class: sealed class MenuItem { object Cake : MenuItem() class Hamburger(val toppings: List\u003cTopping\u003e) : MenuItem() class Soda(val size: Size) : MenuItem() } This made sure that after you compiled the sealed class, nobody else could come along and create their own class that extends it. Anyone adding a new item inside the class would also have to recompile the class itself, and any code that performs type checks against this class. You can still see this pattern of nesting in many usages of sealed classes today, as it’s still useful for scoping names (e.g. MenuItem.Soda is a nice descriptive name). One of the great things about sealed classes is that when can guarantee that you’ve exhaustively checked all possible cases (given that you’re using it as an expression, i.e. returning something from it): val rating = when (val item: MenuItem = getMenuItem()) { is Cake -\u003e 10 is Hamburger -\u003e if (Cheese in item.toppings) 9 else 7 is Soda -\u003e 2 } You also get convenient smart casts within branches to the specific subclass, which is how item.toppings can be referenced in the case of a burger above. Road to sealed classes freedom In Kotlin 1.1, the containment requirements were relaxed, requiring only that subclasses are in the same file as the sealed class, allowing you to get rid of the nesting: sealed class MenuItem object Cake : MenuItem() class Hamburger(val toppings: List\u003cTopping\u003e) : MenuItem() class Soda(val size: Size) : MenuItem() The preview features of Kotlin 1.5 relax this even further, allowing you to place your subclasses into different files as well. The remaining requirement is that the subclasses have to be in the same compilation module and same package as the sealed class. // MenuItem.kt sealed class MenuItem // Food.kt object Cake : MenuItem() class Hamburger(val toppings: List\u003cTopping\u003e) : MenuItem() // Drinks.kt object Water : MenuItem() class Soda(val size: Size) : MenuItem() This way, you’ll still know all possible types that might extend a sealed class at compile time, as the entire module is compiled together. However, you can freely organize your subclasses logically, and you can also split out long subclasses into separate files for readability. As always, if you get the rules wrong, you’ll get a really nice and descriptive error message from the IDE: e: Inheritance of sealed classes or interfaces from different module is prohibited e: Inheritor of sealed class or interface must be in package where base class is declared You can also now inherit from classes that are on the same level of nesting in the code, but on different levels of a sealed class hierarchy (KT-13495): sealed class MenuItem(val price: Double) { sealed class Hamburger : MenuItem(4.65) class CheeseBurger : Hamburger() } Sealed interfaces Sealed interfaces are… Just what they sound like. An interface with restricted implementations. The rules for this are the same as the new rules for sealed classes: same module, same package. Why is this useful? Because it allows you to expose interfaces from a module (or library, if you will) which its clients won’t be able to implement. These kinds of non-user-implementable interfaces are great: you can still use interfaces to hide concrete implementation classes in your module, but don’t run the risk of someone trying to reimplement your interface. I find that most of the time, this is what I want an interface to behave like in the first place. I don’t want multiple implementations of it, especially not by clients of my code, I just want to hide the concrete classes that implement it. Take this example, which defines a Restaurant interface, and some public API that lets you get an instance: public sealed interface Restaurant { val menu: List\u003cMenuItem\u003e fun purchase(item: MenuItem, quantity: Int) } public fun openRestaurant(): Restaurant { ... } By making this interface sealed, we prevent clients from creating their own implementations, while also being able to create multiple internal implementations ourselves, which the clients will never know about: internal class BurgerPlace : Restaurant { override val menu: List\u003cMenuItem\u003e = ... override fun purchase(item: MenuItem, quantity: Int) { ... } } As a bonus, sealed interfaces should also be able to have internal members, as they’re only implemented within the same module anyway. (For open, public interfaces, this wouldn’t make sense, as nobody outside the module could implement an internal member.) This isn’t available even as a preview yet, however, you could theoretically use this to add members to an interface that should not be public API, but you want to access them within your own module: public sealed interface Restaurant { public val menu: List\u003cMenuItem\u003e public fun purchase(item: MenuItem, quantity: Int) internal val totalIncome: Double } For more details on this, see KT-22286. Java interop considerations Kotlin always has some rough edges when it comes to interoperating with Java code, as Java is inherently less safe and less strict with its typing. For example, calling a Kotlin method with a null value it doesn’t expect is trivial to do from Java. It’s interesting to see that perfect Java interop is not an objective for Kotlin language design. You can see this both in the KEEP discussions and on the issue mentioned in the previous section, which notes: The fact that this restriction is would be non-enforceable for Java code is not a show-stopper. So how about sealed constructs and interop then? Sealed classes are still safe from Java code, as they’ve always been, as they have private constructors in the bytecode, preventing anyone from extending them. (Their inheriting subclasses in Kotlin use a secondary, synthetic constructor which is not available from Java). Sealed interfaces, on the other hand, get no protection from Java code. This means that Java clients can still freely extend these interfaces if they really want to do so, and the Java compiler will allow it. (This can change when running on JDK versions that support sealed types with a stable API, likely 17 or later.) In the meantime, if you’re using an IDE that understands Kotlin’s sealed types, such as IntelliJ IDEA, it will do its best to stop you from extending them from Java code by emitting inspection errors, such as: e: Java class cannot be a part of Kotlin sealed hierarchy Finally, it’s worth noting that mixing sealed hierarchies between the two languages will not be supported. Each sealed hierarchy will have to be made up of either Kotlin or Java classes. Conclusion Kotlin 1.5 can’t land quickly enough (edit: it’s now landed, go and try it!), it’s always nice to see the Kotlin type system become even more powerful, and allow even finer control over what clients are allowed to access and extend. For the full details and all the relevant issues around this topic, see KEEP-226 and its design proposal. Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.Introducing a new library to conveniently require values from common Android types.Not breaking client code is an essential duty of a library developer. Let's take a look at a couple rarely discussed issues you might face in this area.When designing a library, minimizing your API surface - the types, methods, properties, and functions you expose to the outside world - is a great idea. This doesn't apply to just libraries: it's a consideration you should make for every module in a multi-module project.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003ch3 id=\"preview\"\u003e\u003cdel\u003ePreview!\u003c/del\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cdel\u003eHeads up: most things covered in this post are in a preview state of some sort.\u003c/del\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you want the full technical details on this topic, you can jump to \u003ca href=\"https://github.com/Kotlin/KEEP/issues/226\"\u003eKEEP-226\u003c/a\u003e and \u003ca href=\"https://github.com/Kotlin/KEEP/blob/sealed-interface-freedom/proposals/sealed-interface-freedom.md\"\u003eits design proposal\u003c/a\u003e instead of reading this article.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eJDK15 introduced a version of sealed classes and interfaces (see \u003ca href=\"https://openjdk.java.net/jeps/360\"\u003eJEP 360\u003c/a\u003e) in a preview state. These let you restrict inheritance hierarchies, and perform checks on these types with pattern matching. (See \u003ca href=\"https://www.baeldung.com/java-sealed-classes-interfaces\"\u003ethis article\u003c/a\u003e for Java example code.) These features are expected to be stable in JDK17 at the earliest.\u003c/p\u003e\n\u003cp\u003eIn the meantime, Kotlin has had \u003cem\u003esealed classes\u003c/em\u003e since its release, but not \u003cem\u003esealed interfaces\u003c/em\u003e. Now that new JDK versions are adding support for these constructs, Kotlin needs to have an idea of them as well, so that it’ll be able to interoperate with new Java code.\u003c/p\u003e\n\u003cp\u003eIn this article, we’ll recap what sealed classes do, how they’ve evolved so far, and what new goodies you can expect to get when Kotlin 1.5 lands.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eUpdate:\u003c/strong\u003e As of May 5, 2021, the features here are now available in stable Kotlin versions 1.5 and later, \u003ca href=\"https://kotlinlang.org/docs/whatsnew15.html\"\u003esee here for the 1.5 changes\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"sealed-classes-101\"\u003eSealed classes 101\u003c/h3\u003e\n\u003cp\u003eSealed classes are a really popular Kotlin feature: they allow you to restrict the type hierarchy, and prevent unknown subclasses of a base class. They’re kind of like enums with super powers: while enums define a fixed set of instances, sealed classes define a fixed set of types. Importantly, each “branch” of a sealed class is a full-fledged Kotlin class, and can have its own properties and methods.\u003c/p\u003e\n\u003cp\u003eOriginally, all subclasses had to be nested inside the sealed class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esealed class MenuItem {\n    object Cake : MenuItem()\n    class Hamburger(val toppings: List\u0026lt;Topping\u0026gt;) : MenuItem()\n    class Soda(val size: Size) : MenuItem()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis made sure that after you compiled the sealed class, nobody else could come along and create their own class that extends it. Anyone adding a new item inside the class would also have to recompile the class itself, and any code that performs type checks against this class.\u003c/p\u003e\n\u003cp\u003eYou can still see this pattern of nesting in many usages of sealed classes today, as it’s still useful for scoping names (e.g. \u003ccode\u003eMenuItem.Soda\u003c/code\u003e is a nice descriptive name).\u003c/p\u003e\n\u003cp\u003eOne of the great things about sealed classes is that \u003ccode\u003ewhen\u003c/code\u003e can guarantee that you’ve exhaustively checked all possible cases (given that you’re using it as an expression, i.e. returning something from it):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval rating = when (val item: MenuItem = getMenuItem()) {\n    is Cake -\u0026gt; 10\n    is Hamburger -\u0026gt; if (Cheese in item.toppings) 9 else 7\n    is Soda -\u0026gt; 2\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou also get convenient smart casts within branches to the specific subclass, which is how \u003ccode\u003eitem.toppings\u003c/code\u003e can be referenced in the case of a burger above.\u003c/p\u003e\n\u003ch3 id=\"road-to-sealed-classes-freedom\"\u003eRoad to sealed classes freedom\u003c/h3\u003e\n\u003cp\u003eIn Kotlin 1.1, \u003ca href=\"https://kotlinlang.org/docs/whatsnew11.html#sealed-and-data-classes\"\u003ethe containment requirements were relaxed\u003c/a\u003e, requiring only that subclasses are in the same file as the sealed class, allowing you to get rid of the nesting:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esealed class MenuItem\n\nobject Cake : MenuItem()\nclass Hamburger(val toppings: List\u0026lt;Topping\u0026gt;) : MenuItem()\nclass Soda(val size: Size) : MenuItem()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe preview features of Kotlin 1.5 relax this even further, allowing you to place your subclasses into different files as well. The remaining requirement is that the subclasses have to be in the \u003cem\u003esame compilation module\u003c/em\u003e and \u003cem\u003esame package\u003c/em\u003e as the sealed class.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// MenuItem.kt\nsealed class MenuItem\n\n// Food.kt\nobject Cake : MenuItem()\nclass Hamburger(val toppings: List\u0026lt;Topping\u0026gt;) : MenuItem()\n\n// Drinks.kt\nobject Water : MenuItem()\nclass Soda(val size: Size) : MenuItem()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis way, you’ll still know all possible types that might extend a sealed class at compile time, as the entire module is compiled together. However, you can freely organize your subclasses logically, and you can also split out long subclasses into separate files for readability.\u003c/p\u003e\n\u003cp\u003eAs always, if you get the rules wrong, you’ll get a really nice and descriptive error message from the IDE:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ee: Inheritance of sealed classes or interfaces from different module is prohibited\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003ee: Inheritor of sealed class or interface must be in package where base class is declared\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYou can also now inherit from classes that are on the same level of nesting in the code, but on different levels of a sealed class hierarchy (\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-13495\"\u003eKT-13495\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esealed class MenuItem(val price: Double) {\n    sealed class Hamburger : MenuItem(4.65)\n    class CheeseBurger : Hamburger()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"sealed-interfaces\"\u003eSealed interfaces\u003c/h3\u003e\n\u003cp\u003eSealed interfaces are… Just what they sound like. An interface with restricted implementations. The rules for this are the same as the new rules for sealed classes: same module, same package.\u003c/p\u003e\n\u003cp\u003eWhy is this useful? Because it allows you to expose interfaces from a module (or library, if you will) which its clients won’t be able to implement. These kinds of \u003cem\u003enon-user-implementable\u003c/em\u003e interfaces are great: you can still use interfaces to hide concrete implementation classes in your module, but don’t run the risk of someone trying to reimplement your interface.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI find that most of the time, this is what I want an interface to behave like in the first place. I don’t want multiple implementations of it, especially not by clients of my code, I just want to hide the concrete classes that implement it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eTake this example, which defines a \u003ccode\u003eRestaurant\u003c/code\u003e interface, and some public API that lets you get an instance:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic sealed interface Restaurant {\n    val menu: List\u0026lt;MenuItem\u0026gt;\n    fun purchase(item: MenuItem, quantity: Int)\n}\n\npublic fun openRestaurant(): Restaurant { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy making this interface sealed, we prevent clients from creating their own implementations, while also being able to create multiple internal implementations ourselves, which the clients will never know about:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einternal class BurgerPlace : Restaurant {\n    override val menu: List\u0026lt;MenuItem\u0026gt; = ...\n    override fun purchase(item: MenuItem, quantity: Int) { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a bonus, sealed interfaces should also be able to have \u003ccode\u003einternal\u003c/code\u003e members, as they’re only implemented within the same module anyway. (For open, public interfaces, this wouldn’t make sense, as nobody outside the module could implement an \u003ccode\u003einternal\u003c/code\u003e member.)\u003c/p\u003e\n\u003cp\u003eThis isn’t available even as a preview yet, however, you could theoretically use this to add members to an interface that should not be public API, but you want to access them within your own module:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic sealed interface Restaurant {\n    public val menu: List\u0026lt;MenuItem\u0026gt;\n    public fun purchase(item: MenuItem, quantity: Int)\n    internal val totalIncome: Double\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor more details on this, see \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-22286\"\u003eKT-22286\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"java-interop-considerations\"\u003eJava interop considerations\u003c/h3\u003e\n\u003cp\u003eKotlin always has some rough edges when it comes to interoperating with Java code, as Java is inherently less safe and less strict with its typing. For example, calling a Kotlin method with a \u003ccode\u003enull\u003c/code\u003e value it doesn’t expect is trivial to do from Java.\u003c/p\u003e\n\u003cp\u003eIt’s interesting to see that perfect Java interop is not an objective for Kotlin language design. You can see this both in the KEEP discussions and on the issue mentioned in the previous section, which notes:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe fact that this restriction is would be non-enforceable for Java code is not a show-stopper.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSo how about sealed constructs and interop then?\u003c/p\u003e\n\u003cp\u003eSealed classes are still safe from Java code, as they’ve always been, as they have private constructors in the bytecode, preventing anyone from extending them. (Their inheriting subclasses in Kotlin use a secondary, synthetic constructor which is not available from Java).\u003c/p\u003e\n\u003cp\u003eSealed interfaces, on the other hand, get no protection from Java code. This means that Java clients can still freely extend these interfaces if they \u003cem\u003ereally\u003c/em\u003e want to do so, and the Java compiler will allow it. (This can change when running on JDK versions that support sealed types with a stable API, likely 17 or later.)\u003c/p\u003e\n\u003cp\u003eIn the meantime, if you’re using an IDE that understands Kotlin’s sealed types, such as IntelliJ IDEA, it will do its best to stop you from extending them from Java code by emitting inspection errors, such as:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003ee: Java class cannot be a part of Kotlin sealed hierarchy\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFinally, it’s worth noting that mixing sealed hierarchies between the two languages will not be supported. Each sealed hierarchy will have to be made up of either Kotlin or Java classes.\u003c/p\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eKotlin 1.5 can’t land quickly enough (edit: it’s now landed, go and try it!), it’s always nice to see the Kotlin type system become even more powerful, and allow even finer control over what clients are allowed to access and extend.\u003c/p\u003e\n\u003cp\u003eFor the full details and all the relevant issues around this topic, see \u003ca href=\"https://github.com/Kotlin/KEEP/issues/226\"\u003eKEEP-226\u003c/a\u003e and \u003ca href=\"https://github.com/Kotlin/KEEP/blob/sealed-interface-freedom/proposals/sealed-interface-freedom.md\"\u003eits design proposal\u003c/a\u003e.\u003c/p\u003e\n\n\u003c/div\u003e\u003cp\u003eHave you ever encountered APIs that show warnings or errors when you use them, saying that they\u0026#39;re internal or experimental? In this guide, you\u0026#39;ll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.\u003c/p\u003e\u003cp\u003eIntroducing a new library to conveniently require values from common Android types.\u003c/p\u003e\u003cp\u003eNot breaking client code is an essential duty of a library developer. Let\u0026#39;s take a look at a couple rarely discussed issues you might face in this area.\u003c/p\u003e\u003cp\u003eWhen designing a library, minimizing your API surface - the types, methods, properties, and functions you expose to the outside world - is a great idea. This doesn\u0026#39;t apply to just libraries: it\u0026#39;s a consideration you should make for every module in a multi-module project.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
