{
  "id": "85e36119-771a-4102-a6cb-570a3ed1d8d4",
  "title": "WebAssembly is like JSON for behaviour",
  "link": "https://publicobject.com/2024/01/11/wasm/",
  "description": "If you’re sending data from one computer to another, it’s probably JSON. But it hasn’t always been this way.How we Transmitted Data Before JSONBefore JSON got popular (2005ish) we had XML, CORBA, Java serialization, Python Pickle, and a bunch of other clever and complex encoding",
  "author": "Jesse Wilson",
  "published": "Thu, 11 Jan 2024 05:20:29 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 2419,
  "excerpt": "If you’re sending data from one computer to another, it’s probably JSON. But it hasn’t always been this way. How we Transmitted Data Before JSON Before JSON got popular (2005ish) we had XML, CORBA, Java serialization, Python Pickle, and a bunch of other clever and complex encoding schemes. One thing that Really Sucked about these schemes was getting different platforms to share data. Perhaps my writer program would make an XML file with schemas and namespaces and UTF-8. Perhaps your reader pro",
  "siteName": "Public Object",
  "favicon": "",
  "text": "If you’re sending data from one computer to another, it’s probably JSON. But it hasn’t always been this way.How we Transmitted Data Before JSONBefore JSON got popular (2005ish) we had XML, CORBA, Java serialization, Python Pickle, and a bunch of other clever and complex encoding schemes. One thing that Really Sucked about these schemes was getting different platforms to share data.Perhaps my writer program would make an XML file with schemas and namespaces and UTF-8. Perhaps your reader program would ignore all that ceremony and do the basics. And then our data would degrade in transit! Seeing ’ replaced with â€™ is still a very familiar failure mode.Or perhaps we’d use Java Serialization. That 100% Pure Java solution was easy to get started, awful to change, and impossible to secure. This was a standard industry practice in the bad old days!JSON is UniversalToday, JSON is everywhere.Because reading and writing JSON is simple, clients and servers need not agree on a tech stack! You can use a programming language that you like on your server; I’ll use what I like on the client; and it’ll just work.(If you really need a compact encoding you can use Protobuf, but even that specifies a JSON representation.)How we Build Software Before WebAssemblyBefore WebAssembly gets popular (2024ish), we have the JVM, NodeJS, Python, Rust, and a bunch of other clever and complex programming platforms. One thing that Really Sucks about these platforms is getting them to share behaviour.Perhaps I write a Kotlin library that implements my company’s authorization policies. Perhaps your Go program would like to call my library. Now we’re in hell! You can fork a process, or deploy my library as an HTTP service. Whatever we do, it’s going to be slow and clumsy.WebAssembly is UniversalWebAssembly is rolling out everywhere.I’m looking forward to packaging up business logic as a WebAssembly library and letting my users consume it everywhere: the JVM, NodeJS, Python, Rust, plus tons of niche programming platforms.Extism is running with this. They’re making abstractions so bridging into WebAssembly is easy.My team at Cash App is working on something similar with Zipline. But instead of using WebAssembly for polyglot, we’ll be using it for dynamic updates.WebAssembly in 2024I got really excited by reading Andy Wingo’s post:It is in this sense that WebAssembly is a new fundamental abstraction boundary.Yasss!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eIf you’re sending data from one computer to another, it’s probably JSON. But it hasn’t always been this way.\u003c/p\u003e\u003ch3 id=\"how-we-transmitted-data-before-json\"\u003eHow we Transmitted Data Before JSON\u003c/h3\u003e\u003cp\u003eBefore JSON got popular (2005ish) we had XML, CORBA, Java serialization, Python Pickle, and a bunch of other clever and complex encoding schemes. One thing that Really Sucked about these schemes was getting different platforms to share data.\u003c/p\u003e\u003cp\u003ePerhaps my writer program would make an XML file with schemas and namespaces and UTF-8. Perhaps your reader program would ignore all that ceremony and do the basics. And then our data would degrade in transit! Seeing \u003ccode\u003e’\u003c/code\u003e replaced with \u003ccode\u003e\u003ccode\u003eâ€™\u003c/code\u003e\u003c/code\u003e is still a very familiar failure mode.\u003c/p\u003e\u003cp\u003eOr perhaps we’d use Java Serialization. That \u003cem\u003e100% Pure Java\u003c/em\u003e solution was easy to get started, awful to change, and impossible to secure. This was a standard industry practice in the bad old days!\u003c/p\u003e\u003ch3 id=\"json-is-universal\"\u003eJSON is Universal\u003c/h3\u003e\u003cp\u003eToday, JSON is everywhere.\u003c/p\u003e\u003cp\u003eBecause reading and writing JSON is simple, clients and servers need not agree on a tech stack! You can use a programming language that you like on your server; I’ll use what I like on the client; and it’ll just work.\u003c/p\u003e\u003cp\u003e(If you really need a compact encoding you can use \u003ca href=\"https://protobuf.com/\"\u003eProtobuf,\u003c/a\u003e but even that specifies a JSON representation.)\u003c/p\u003e\u003ch3 id=\"how-we-build-software-before-webassembly\"\u003eHow we Build Software Before WebAssembly\u003c/h3\u003e\u003cp\u003eBefore WebAssembly gets popular (2024ish), we have the JVM, NodeJS, Python, Rust, and a bunch of other clever and complex programming platforms. One thing that Really Sucks about these platforms is getting them to share behaviour.\u003c/p\u003e\u003cp\u003ePerhaps I write a Kotlin library that implements my company’s authorization policies. Perhaps your Go program would like to call my library. Now we’re in hell! You can fork a process, or deploy my library as an HTTP service. Whatever we do, it’s going to be slow and clumsy.\u003c/p\u003e\u003ch3 id=\"webassembly-is-universal\"\u003eWebAssembly is Universal\u003c/h3\u003e\u003cp\u003eWebAssembly is rolling out everywhere.\u003c/p\u003e\u003cp\u003eI’m looking forward to packaging up business logic as a WebAssembly library and letting my users consume it everywhere: the JVM, NodeJS, Python, Rust, plus tons of niche programming platforms.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://dylibso.com/blog/announcing-extism-v1/\"\u003eExtism\u003c/a\u003e is running with this. They’re making abstractions so bridging into WebAssembly is easy.\u003c/p\u003e\u003cp\u003eMy team at Cash App is working on something similar with \u003ca href=\"https://github.com/cashapp/zipline/\"\u003eZipline\u003c/a\u003e. But instead of using WebAssembly for polyglot, we’ll be using it for dynamic updates.\u003c/p\u003e\u003ch3 id=\"webassembly-in-2024\"\u003eWebAssembly in 2024\u003c/h3\u003e\u003cp\u003eI got really excited by reading \u003ca href=\"https://wingolog.org/archives/2024/01/08/missing-the-point-of-webassembly\"\u003eAndy Wingo’s post\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003eIt is in this sense that WebAssembly is a new fundamental abstraction boundary.\u003c/blockquote\u003e\u003cp\u003eYasss!\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-01-11T05:20:29Z",
  "modifiedTime": "2024-01-13T19:43:19Z"
}
