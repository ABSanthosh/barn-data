{
  "id": "e3b23e4c-754d-444a-80bb-ed36089e837a",
  "title": "Pi Practice App in Compose",
  "link": "https://zsmb.co/pi-practice-app-in-compose/",
  "description": "In another detailed Jetpack Compose walkthrough, we'll look at implementing a simple app for practicing the digits of pi!",
  "author": "MÃ¡rton Braun",
  "published": "Sun, 18 Apr 2021 18:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "MÃ¡rton Braun",
  "length": 14402,
  "excerpt": "In another detailed Jetpack Compose walkthrough, we'll look at implementing a simple app for practicing the digits of pi!",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "This article was originally planned for ðŸ¥§ Pi Day, and it clearly ran more than a month late. However, itâ€™s finally complete! Concept This project is once again one of my older projects revived with Jetpack Compose. A couple years ago, I wrote an app that lets you practice and learn the digits of pi - always a fun thing to spend your commute on. Iâ€™m rather rusty now and down to knowing about ~60 digits. How high can you score in the app? Tweet at me @zsmb13! The app is still available in its original form on the Google Play Store for your pi practicing pleasure. Its sources are also available on GitHub. If you take a look at the repository, youâ€™ll find something rather interesting in its dependencies. It uses Anko Layouts to render some parts of its UI! This was an early, now deprecated and abandoned attempt by JetBrains to create declarative Android UI with Kotlin DSLs. In this article, weâ€™ll build the app in Compose, and also take a look at what some of the old Anko code looked like when we reach the relevant parts. The completed appâ€™s source code is available on GitHub, so you can browse it freely while reading the article. Project setup, navigation The app is rather simple, it consists of just two screens. The main screen contains the field displaying the current progress and the keypad to mash in the digits. The high scores screen displays the best runs you had at the digits of pi (a top 10 list of best attempts). Navigation setup is simple in MainActivity: setContent { PiPracticeComposeTheme { Surface(color = MaterialTheme.colors.background) { val navController = rememberNavController() NavHost(navController, startDestination = \"home\") { composable(\"home\") { Home(navController) } composable(\"highscores\") { HighScores(navController) } } } } } Main screen The first building block of the main screen will be a composable that displays a button, which can notify us when it was clicked. Weâ€™ll design this with a bottom-up approach. @Composable private fun NumberButton( number: Int, onClick: (Char) -\u003e Unit, modifier: Modifier = Modifier, ) { OutlinedButton( onClick = { @OptIn(ExperimentalStdlibApi::class) onClick(number.digitToChar()) }, modifier = modifier .aspectRatio(1f) .padding(4.dp), border = ButtonDefaults.outlinedBorder.copy( brush = SolidColor(MaterialTheme.colors.primary) ) ) { Text( text = number.toString(), fontSize = 30.sp, color = MaterialTheme.colors.primary, ) } } This NumberButton uses basic Compose concepts, and is based on a material OutlinedButton. It takes a modifier as an optional parameter, following the relevant section of the Jetpack Compose API Guidelines by Google (a must-read if youâ€™re writing Compose code). Keypad The next step up is assembling a grid of these on the screen, adding a progress indicator in the bottom row, and adding the current value of pi thatâ€™s been entered in a field on the top of the keypad: @Composable private fun KeyPad( input: String, scrollState: ScrollState, // 1 onClick: (digit: Char) -\u003e Unit, // 2 ) { val progress = input.length - 2 Column( modifier = Modifier .fillMaxSize() .padding(8.dp) ) { Text( text = input, fontSize = 32.sp, modifier = Modifier .verticalScroll(scrollState) // 1 .weight(1f) .padding(4.dp), ) Row(Modifier.fillMaxWidth()) { NumberButton(number = 1, onClick, Modifier.weight(1f)) NumberButton(number = 2, onClick, Modifier.weight(1f)) NumberButton(number = 3, onClick, Modifier.weight(1f)) } Row(Modifier.fillMaxWidth()) { NumberButton(number = 4, onClick, Modifier.weight(1f)) NumberButton(number = 5, onClick, Modifier.weight(1f)) NumberButton(number = 6, onClick, Modifier.weight(1f)) } Row(Modifier.fillMaxWidth()) { NumberButton(number = 7, onClick, Modifier.weight(1f)) NumberButton(number = 8, onClick, Modifier.weight(1f)) NumberButton(number = 9, onClick, Modifier.weight(1f)) } Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) { NumberButton(number = 0, onClick, Modifier.weight(1f)) Text( // 3 text = stringResource(id = R.string.current_progress, progress), modifier = Modifier.weight(2f), textAlign = TextAlign.Center, fontSize = 18.sp, ) } } } This code is a bit wordy, but it mostly just creates all the rows of buttons weâ€™ll need, and aligns them using weight modifiers. Letâ€™s review some of the other interesting bits: Weâ€™ll make the top Text that displays the current value of pi scrollable, as weâ€™d eventually run out of space while practicing. This is easily done by using the verticalScroll modifier. Note how the scroll state is hoisted to the containing function, which will let it control it externally. All number button clicks are passed to the same onClick event listener. We use the stringResource function to access Android string resources to make the few UI strings we have translatable. This is what we built so far: Game logic Now itâ€™s time to add the main game logic. @Composable private fun PiPad() { val pi = stringResource(R.string.pi) // 1 val scope = rememberCoroutineScope() // 2 var input by remember { mutableStateOf(\"3.\") } val scrollState = rememberScrollState() // 3 var showDialog by remember { mutableStateOf(false) } var lastInput by remember { mutableStateOf('-') } fun reset() { input = \"3.\" lastInput = '-' showDialog = false } KeyPad( input = input, scrollState = scrollState, onClick = { digit -\u003e // 4 val indexToTest = input.length val correctDigit = pi[indexToTest] lastInput = digit if (digit == correctDigit) { // 5 input += digit.toString() scope.launch { delay(100) scrollState.animateScrollTo(scrollState.maxValue) } } else { // 6 val decimalReached = input.length - 2 ScoreKeeper.logScore(decimalReached) showDialog = true } } ) if (showDialog) { val length = input.length EndOfGameDialog(onDismiss = { reset() }) { // 7 Column { Text(stringResource(R.string.dialog_decimal_reached, length - 2)) Text(stringResource(R.string.dialog_digit_info, lastInput, pi[length])) Text(stringResource(R.string.dialog_next_digits, pi.substring(length, length + 10))) } } } } This is quite a bit of code, but most of it is simple, and it handles all of the game logic for us! The true value of pi comes from string resources. The current value that the player has progressed to is always in the input variable. We also create the scroll state of the view that will display this value on the top of the screen here. When the game ends, weâ€™ll show a dialog. This requires us to remember the last input digit, and to keep track of whether we need to show the dialog or not. We instantiate a KeyPad, and in its onClick listener, we implement all of the game logic. If the player inputs the correct digit, weâ€™ll add it to the input, and make sure the view displaying it is scrolled to the bottom. If the player makes an error, we log the score they reached, and then display the end-of-game dialog. The dialogâ€™s content is passed in with the content lambda convention. ScoreKeeper is a relatively boring Kotlin object that reads/writes a file to keep track of the high scores. You can check out its implementation in the GitHub repository. Displaying a dialog The EndOfGameDialog function used above is a wrapper around AlertDialog, implemented like so: @Composable private fun EndOfGameDialog( onDismiss: () -\u003e Unit, content: @Composable () -\u003e Unit, ) { AlertDialog( onDismissRequest = onDismiss, title = { Text(stringResource(R.string.dialog_game_over_title)) }, text = content, confirmButton = { Button(onClick = onDismiss) { Text(stringResource(R.string.dialog_ok)) } }, ) } This dialog was one of the parts implemented with Anko in the original app, which looked like this - quite familiar and easy to read! alert { customView { verticalLayout { padding = dip(24) textView { text = getString(R.string.decimal_reached, indexReached) textSize = 16f } textView { text = getString(R.string.digit_info, digit, correctDigit) textSize = 16f } textView { val nextDigit = indexReached + 1 text = getString(R.string.next_digits, digitsToShow, pi.substring(nextDigit, nextDigit + digitsToShow)) textSize = 16f } } positiveButton(getString(R.string.OK)) { resetState() } onCancelled { resetState() } } }.show() As the final touch for the main screen, weâ€™ll add a toolbar on top to display the app name and provide navigation to the second screen. @Composable fun Home(navController: NavController) { Scaffold(topBar = { TopAppBar( title = { Text(\"Pi\") }, actions = { IconButton(onClick = { navController.navigate(\"highscores\") }) { Icon( Icons.Default.Star, stringResource(R.string.content_description_high_scores) ) } } ) }) { PiPad() } } This now shows up on the top of our screen: High scores The high scores screen is extremely simple, it will display just a toolbar and a list of values. Before we see the Compose implementation, hereâ€™s the original Anko code for this screen: verticalLayout { padding = dip(16) verticalGravity = Gravity.CENTER tableLayout { tableRow { horizontalGravity = Gravity.CENTER cell(\"# \") // 2 cell(getString(R.string.Score)) // 2 } ScoreKeeper.scores.forEachIndexed { index, score -\u003e // 1 tableRow { horizontalGravity = Gravity.CENTER cell(\"${index + 1}.\") // 2 cell(score.toString()) // 2 } } } } The rows of the table are created with a simple forEachIndexed loop - a huge advantage and convenience of writing declarative layouts in Kotlin, having all the language features and constructs like the collection APIs available. Each row here was assembled by calls to the cell function, an extension I added on the receiver scope of the Anko tableRow function - the oddly named _TableRow type. private fun _TableRow.cell(text: String) { textView(text) { padding = dip(4) textSize = 20f } } The Compose syntax for this screen will yet again be very similar to the Anko based approach. Weâ€™ll set up a toolbar much like on the main screen, and then add a header and some items underneath in a loop. @Composable fun HighScores(navController: NavController) { Scaffold( topBar = { TopAppBar( title = { Text(stringResource(R.string.high_scores_title)) }, navigationIcon = { IconButton(onClick = { navController.popBackStack() }) { Icon(Icons.Default.ArrowBack, null) } }, ) } ) { Column( modifier = Modifier .fillMaxSize() .padding(32.dp), horizontalAlignment = Alignment.CenterHorizontally, ) { Header(Modifier.width(120.dp)) ScoreKeeper.scores.forEachIndexed { index, score -\u003e ScoreItem(index + 1, score, Modifier.width(120.dp)) } } } } The Header and the ScoreItem composables are extremely similar, theyâ€™ll just use slightly different text styling. Hereâ€™s just the latter of them: @Composable private fun ScoreItem( index: Int, score: Int, modifier: Modifier = Modifier, ) { Row(modifier) { Text( text = \"${index}.\", textAlign = TextAlign.Start, modifier = Modifier.weight(1f), ) Text( text = score.toString(), textAlign = TextAlign.Center, modifier = Modifier.weight(2f), ) } } Ta-da, now we can display the high scores in the app: Wrap-up Thatâ€™s it for now! Thanks for following along with another Compose article. You can find the completed project on GitHub to play around with it and see the rest of the code that I omitted from the article. If you liked this project, youâ€™ll also like these other ones: Build an Android Chat app with Jetpack Compose Compose Oâ€™Clock Prime Table Generator in Jetpack Compose I've dusted off one of my oldest (and favourite) coding projects, and rewrote it in Jetpack Compose as a nice little practice exercise.StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one.Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cem\u003eThis article was originally planned for ðŸ¥§ \u003ca href=\"https://en.wikipedia.org/wiki/Pi_Day\"\u003ePi Day\u003c/a\u003e, and it clearly ran more than a month late. However, itâ€™s finally complete!\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"concept\"\u003eConcept\u003c/h2\u003e\n\u003cp\u003eThis project is once again one of my older projects revived with Jetpack Compose. A couple years ago, I wrote an app that lets you practice and learn the digits of pi - always a fun thing to spend your commute on.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIâ€™m rather rusty now and down to knowing about ~60 digits. How high can you score in the app? Tweet at me \u003ca href=\"https://twitter.com/zsmb13\"\u003e@zsmb13\u003c/a\u003e!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe app is still available in its original form \u003ca href=\"https://play.google.com/store/apps/details?id=co.zsmb.pi\"\u003eon the Google Play Store\u003c/a\u003e for your pi practicing pleasure. Its sources are also available \u003ca href=\"https://github.com/zsmb13/Pi\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/pi-app-play-store.png\" alt=\"The Pi app in the Play Store\"/\u003e\u003c/p\u003e\n\u003cp\u003eIf you take a look at the repository, youâ€™ll find something rather interesting in its dependencies. It uses \u003ca href=\"https://github.com/Kotlin/anko/wiki/Anko-Layouts\"\u003eAnko Layouts\u003c/a\u003e to render some parts of its UI! This was an early, now deprecated and abandoned attempt by JetBrains to create declarative Android UI with Kotlin DSLs.\u003c/p\u003e\n\u003cp\u003eIn this article, weâ€™ll build the app in Compose, and also take a look at what some of the old Anko code looked like when we reach the relevant parts.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe completed appâ€™s source code is available \u003ca href=\"https://github.com/zsmb13/PiCompose\"\u003eon GitHub\u003c/a\u003e, so you can browse it freely while reading the article.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"project-setup-navigation\"\u003eProject setup, navigation\u003c/h3\u003e\n\u003cp\u003eThe app is rather simple, it consists of just two screens. The main screen contains the field displaying the current progress and the keypad to mash in the digits. The high scores screen displays the best runs you had at the digits of pi (a top 10 list of best attempts).\u003c/p\u003e\n\u003cp\u003eNavigation setup is simple in \u003ccode\u003eMainActivity\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esetContent {\n    PiPracticeComposeTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            val navController = rememberNavController()\n            NavHost(navController, startDestination = \u0026#34;home\u0026#34;) {\n                composable(\u0026#34;home\u0026#34;) {\n                    Home(navController)\n                }\n                composable(\u0026#34;highscores\u0026#34;) {\n                    HighScores(navController)\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"main-screen\"\u003eMain screen\u003c/h3\u003e\n\u003cp\u003eThe first building block of the main screen will be a composable that displays a button, which can notify us when it was clicked. Weâ€™ll design this with a bottom-up approach.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nprivate fun NumberButton(\n    number: Int,\n    onClick: (Char) -\u0026gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    OutlinedButton(\n        onClick = {\n            @OptIn(ExperimentalStdlibApi::class)\n            onClick(number.digitToChar())\n        },\n        modifier = modifier\n            .aspectRatio(1f)\n            .padding(4.dp),\n        border = ButtonDefaults.outlinedBorder.copy(\n            brush = SolidColor(MaterialTheme.colors.primary)\n        )\n    ) {\n        Text(\n            text = number.toString(),\n            fontSize = 30.sp,\n            color = MaterialTheme.colors.primary,\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis \u003ccode\u003eNumberButton\u003c/code\u003e uses basic Compose concepts, and is based on a material \u003ccode\u003eOutlinedButton\u003c/code\u003e. It takes a \u003ccode\u003emodifier\u003c/code\u003e as an optional parameter, following the relevant section of the \u003ca href=\"https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#elements-accept-and-respect-a-modifier-parameter\"\u003eJetpack Compose API Guidelines\u003c/a\u003e by Google (a must-read if youâ€™re writing Compose code).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/number-button.png\" alt=\"A NumberButton\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"keypad\"\u003eKeypad\u003c/h3\u003e\n\u003cp\u003eThe next step up is assembling a grid of these on the screen, adding a progress indicator in the bottom row, and adding the current value of pi thatâ€™s been entered in a field on the top of the keypad:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nprivate fun KeyPad(\n    input: String,\n    scrollState: ScrollState, // 1\n    onClick: (digit: Char) -\u0026gt; Unit, // 2\n) {\n    val progress = input.length - 2\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(8.dp)\n    ) {\n        Text(\n            text = input,\n            fontSize = 32.sp,\n            modifier = Modifier\n                .verticalScroll(scrollState) // 1\n                .weight(1f)\n                .padding(4.dp),\n        )\n        Row(Modifier.fillMaxWidth()) {\n            NumberButton(number = 1, onClick, Modifier.weight(1f))\n            NumberButton(number = 2, onClick, Modifier.weight(1f))\n            NumberButton(number = 3, onClick, Modifier.weight(1f))\n        }\n        Row(Modifier.fillMaxWidth()) {\n            NumberButton(number = 4, onClick, Modifier.weight(1f))\n            NumberButton(number = 5, onClick, Modifier.weight(1f))\n            NumberButton(number = 6, onClick, Modifier.weight(1f))\n        }\n        Row(Modifier.fillMaxWidth()) {\n            NumberButton(number = 7, onClick, Modifier.weight(1f))\n            NumberButton(number = 8, onClick, Modifier.weight(1f))\n            NumberButton(number = 9, onClick, Modifier.weight(1f))\n        }\n        Row(Modifier.fillMaxWidth(), verticalAlignment = Alignment.CenterVertically) {\n            NumberButton(number = 0, onClick, Modifier.weight(1f))\n            Text( // 3\n                text = stringResource(id = R.string.current_progress, progress),\n                modifier = Modifier.weight(2f),\n                textAlign = TextAlign.Center,\n                fontSize = 18.sp,\n            )\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code is a bit wordy, but it mostly just creates all the rows of buttons weâ€™ll need, and aligns them using \u003ccode\u003eweight\u003c/code\u003e modifiers. Letâ€™s review some of the other interesting bits:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWeâ€™ll make the top \u003ccode\u003eText\u003c/code\u003e that displays the current value of pi scrollable, as weâ€™d eventually run out of space while practicing. This is easily done by using the \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#verticalscroll\"\u003e\u003ccode\u003everticalScroll\u003c/code\u003e modifier\u003c/a\u003e. Note how the scroll state is \u003ca href=\"https://developer.android.com/jetpack/compose/state#stateless-composables\"\u003ehoisted\u003c/a\u003e to the containing function, which will let it control it externally.\u003c/li\u003e\n\u003cli\u003eAll number button clicks are passed to the same \u003ccode\u003eonClick\u003c/code\u003e event listener.\u003c/li\u003e\n\u003cli\u003eWe use the \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/res/package-summary#stringresource\"\u003e\u003ccode\u003estringResource\u003c/code\u003e function\u003c/a\u003e to access Android string resources to make the few UI strings we have translatable.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis is what we built so far:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/keypad.png\" alt=\"The completed keypad\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"game-logic\"\u003eGame logic\u003c/h3\u003e\n\u003cp\u003eNow itâ€™s time to add the main game logic.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nprivate fun PiPad() {\n    val pi = stringResource(R.string.pi) // 1\n\n    val scope = rememberCoroutineScope()\n\n    // 2\n    var input by remember { mutableStateOf(\u0026#34;3.\u0026#34;) }\n    val scrollState = rememberScrollState()\n\n    // 3\n    var showDialog by remember { mutableStateOf(false) }\n    var lastInput by remember { mutableStateOf(\u0026#39;-\u0026#39;) }\n\n    fun reset() {\n        input = \u0026#34;3.\u0026#34;\n        lastInput = \u0026#39;-\u0026#39;\n        showDialog = false\n    }\n\n    KeyPad(\n        input = input,\n        scrollState = scrollState,\n        onClick = { digit -\u0026gt; // 4\n            val indexToTest = input.length\n            val correctDigit = pi[indexToTest]\n\n            lastInput = digit\n\n            if (digit == correctDigit) {\n                // 5\n                input += digit.toString()\n                scope.launch {\n                    delay(100)\n                    scrollState.animateScrollTo(scrollState.maxValue)\n                }\n            } else {\n                // 6\n                val decimalReached = input.length - 2\n                ScoreKeeper.logScore(decimalReached)\n\n                showDialog = true\n            }\n        }\n    )\n\n    if (showDialog) {\n        val length = input.length\n\n        EndOfGameDialog(onDismiss = { reset() }) {\n            // 7\n            Column {\n                Text(stringResource(R.string.dialog_decimal_reached, length - 2))\n                Text(stringResource(R.string.dialog_digit_info, lastInput, pi[length]))\n                Text(stringResource(R.string.dialog_next_digits, pi.substring(length, length + 10)))\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is quite a bit of code, but most of it is simple, and it handles all of the game logic for us!\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe true value of pi comes from string resources.\u003c/li\u003e\n\u003cli\u003eThe current value that the player has progressed to is always in the \u003ccode\u003einput\u003c/code\u003e variable. We also create the scroll state of the view that will display this value on the top of the screen here.\u003c/li\u003e\n\u003cli\u003eWhen the game ends, weâ€™ll show a dialog. This requires us to remember the last input digit, and to keep track of whether we need to show the dialog or not.\u003c/li\u003e\n\u003cli\u003eWe instantiate a \u003ccode\u003eKeyPad\u003c/code\u003e, and in its \u003ccode\u003eonClick\u003c/code\u003e listener, we implement all of the game logic.\u003c/li\u003e\n\u003cli\u003eIf the player inputs the correct digit, weâ€™ll add it to the \u003ccode\u003einput\u003c/code\u003e, and make sure the view displaying it is scrolled to the bottom.\u003c/li\u003e\n\u003cli\u003eIf the player makes an error, we log the score they reached, and then display the end-of-game dialog.\u003c/li\u003e\n\u003cli\u003eThe dialogâ€™s content is passed in with the \u003ca href=\"https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#compose-ui-layouts\"\u003e\u003ccode\u003econtent\u003c/code\u003e lambda convention\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eScoreKeeper\u003c/code\u003e is a relatively boring Kotlin object that reads/writes a file to keep track of the high scores. You can check out its implementation \u003ca href=\"https://github.com/zsmb13/PiCompose/blob/main/app/src/main/java/co/zsmb/picompose/data/ScoreKeeper.kt\"\u003ein the GitHub repository\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"displaying-a-dialog\"\u003eDisplaying a dialog\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eEndOfGameDialog\u003c/code\u003e function used above is a wrapper around \u003ccode\u003eAlertDialog\u003c/code\u003e, implemented like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nprivate fun EndOfGameDialog(\n    onDismiss: () -\u0026gt; Unit,\n    content: @Composable () -\u0026gt; Unit,\n) {\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        title = {\n            Text(stringResource(R.string.dialog_game_over_title))\n        },\n        text = content,\n        confirmButton = {\n            Button(onClick = onDismiss) {\n                Text(stringResource(R.string.dialog_ok))\n            }\n        },\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/end-of-game-dialog.png\" alt=\"The end-of-game dialog\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis dialog was one of the parts implemented with Anko in the original app, which looked \u003ca href=\"https://github.com/zsmb13/Pi/blob/94213675094a81dd1ec3cb96e86f7deb26d5bdb4/app/src/main/java/co/zsmb/pi/MainActivity.kt#L68\"\u003elike this\u003c/a\u003e - quite familiar and easy to read!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ealert {\n    customView {\n        verticalLayout {\n            padding = dip(24)\n\n            textView {\n                text = getString(R.string.decimal_reached, indexReached)\n                textSize = 16f\n            }\n            textView {\n                text = getString(R.string.digit_info, digit, correctDigit)\n                textSize = 16f\n            }\n            textView {\n                val nextDigit = indexReached + 1\n                text = getString(R.string.next_digits, digitsToShow,\n                        pi.substring(nextDigit, nextDigit + digitsToShow))\n                textSize = 16f\n            }\n        }\n\n        positiveButton(getString(R.string.OK)) { resetState() }\n        onCancelled { resetState() }\n    }\n}.show()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs the final touch for the main screen, weâ€™ll add a toolbar on top to display the app name and provide navigation to the second screen.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Home(navController: NavController) {\n    Scaffold(topBar = {\n        TopAppBar(\n            title = { Text(\u0026#34;Pi\u0026#34;) },\n            actions = {\n                IconButton(onClick = { navController.navigate(\u0026#34;highscores\u0026#34;) }) {\n                    Icon(\n                        Icons.Default.Star,\n                        stringResource(R.string.content_description_high_scores)\n                    )\n                }\n            }\n        )\n    }) {\n        PiPad()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis now shows up on the top of our screen:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/main-toolbar.png\" alt=\"The main toolbar\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"high-scores\"\u003eHigh scores\u003c/h3\u003e\n\u003cp\u003eThe high scores screen is extremely simple, it will display just a toolbar and a list of values. Before we see the Compose implementation, hereâ€™s the original Anko code for this screen:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003everticalLayout {\n    padding = dip(16)\n    verticalGravity = Gravity.CENTER\n\n    tableLayout {\n        tableRow {\n            horizontalGravity = Gravity.CENTER\n            cell(\u0026#34;# \u0026#34;) // 2\n            cell(getString(R.string.Score)) // 2\n        }\n\n        ScoreKeeper.scores.forEachIndexed { index, score -\u0026gt; // 1\n            tableRow {\n                horizontalGravity = Gravity.CENTER\n                cell(\u0026#34;${index + 1}.\u0026#34;) // 2\n                cell(score.toString()) // 2\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003eThe rows of the table are created with a simple \u003ccode\u003eforEachIndexed\u003c/code\u003e loop - a huge advantage and convenience of writing declarative layouts in Kotlin, having all the language features and constructs like the collection APIs available.\u003c/li\u003e\n\u003cli\u003eEach row here was assembled by calls to the \u003ccode\u003ecell\u003c/code\u003e function, an extension I added on the receiver scope of the Anko \u003ccode\u003etableRow\u003c/code\u003e function - the oddly named \u003ccode\u003e_TableRow\u003c/code\u003e type.\n\u003cpre\u003e\u003ccode\u003eprivate fun _TableRow.cell(text: String) {\n    textView(text) {\n        padding = dip(4)\n        textSize = 20f\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe Compose syntax for this screen will yet again be very similar to the Anko based approach. Weâ€™ll set up a toolbar much like on the main screen, and then add a header and some items underneath in a loop.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun HighScores(navController: NavController) {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(stringResource(R.string.high_scores_title)) },\n                navigationIcon = {\n                    IconButton(onClick = { navController.popBackStack() }) {\n                        Icon(Icons.Default.ArrowBack, null)\n                    }\n                },\n            )\n        }\n    ) {\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(32.dp),\n            horizontalAlignment = Alignment.CenterHorizontally,\n        ) {\n            Header(Modifier.width(120.dp))\n\n            ScoreKeeper.scores.forEachIndexed { index, score -\u0026gt;\n                ScoreItem(index + 1, score, Modifier.width(120.dp))\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eHeader\u003c/code\u003e and the \u003ccode\u003eScoreItem\u003c/code\u003e composables are extremely similar, theyâ€™ll just use slightly different text styling. Hereâ€™s just the latter of them:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nprivate fun ScoreItem(\n    index: Int,\n    score: Int,\n    modifier: Modifier = Modifier,\n) {\n    Row(modifier) {\n        Text(\n            text = \u0026#34;${index}.\u0026#34;,\n            textAlign = TextAlign.Start,\n            modifier = Modifier.weight(1f),\n        )\n        Text(\n            text = score.toString(),\n            textAlign = TextAlign.Center,\n            modifier = Modifier.weight(2f),\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTa-da, now we can display the high scores in the app:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/pi-practice-app-in-compose/high-scores.png\" alt=\"The High Scores screen\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"wrap-up\"\u003eWrap-up\u003c/h3\u003e\n\u003cp\u003eThatâ€™s it for now! Thanks for following along with another Compose article. You can find the completed project \u003ca href=\"\"\u003eon GitHub\u003c/a\u003e to play around with it and see the rest of the code that I omitted from the article.\u003c/p\u003e\n\u003cp\u003eIf you liked this project, youâ€™ll also like these other ones:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://proandroiddev.com/android-chat-app-jetpack-compose-dec472140ff1\"\u003eBuild an Android Chat app with Jetpack Compose\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zsmb.co/compose-o-clock/\"\u003eCompose Oâ€™Clock\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zsmb.co/prime-table-generator-jetpack-compose/\"\u003ePrime Table Generator in Jetpack Compose\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\u003cp\u003eI\u0026#39;ve dusted off one of my oldest (and favourite) coding projects, and rewrote it in Jetpack Compose as a nice little practice exercise.\u003c/p\u003e\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\u003cp\u003eHave you ever encountered APIs that show warnings or errors when you use them, saying that they\u0026#39;re internal or experimental? In this guide, you\u0026#39;ll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
