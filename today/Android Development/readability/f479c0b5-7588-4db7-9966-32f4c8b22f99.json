{
  "id": "f479c0b5-7588-4db7-9966-32f4c8b22f99",
  "title": "Farm or Grind",
  "link": "https://publicobject.com/2023/06/10/farm-or-grind/",
  "description": "Suppose your organization has a widely-used internal library for validating customer usernames:private val usernameRegex = Regex(\"[a-z]{2,40}\") fun isValidUsername(username: String): Boolean { return usernameRegex.matches(username) }The function becomes widely adopted:Some callers use it during customer sign-up. We don’t want customers putting slashes in their usernames!",
  "author": "Jesse Wilson",
  "published": "Sat, 10 Jun 2023 04:16:43 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 4714,
  "excerpt": "Suppose your organization has a widely-used internal library for validating customer usernames: private val usernameRegex = Regex(\"[a-z]{2,40}\") fun isValidUsername(username: String): Boolean { return usernameRegex.matches(username) } The function becomes widely adopted: * Some callers use it during customer sign-up. We don’t want customers putting slashes in their usernames! * Others use it to validate the strings they’re receiving are actually usernames. It would be bad to mix up",
  "siteName": "Public Object",
  "favicon": "",
  "text": "Suppose your organization has a widely-used internal library for validating customer usernames:private val usernameRegex = Regex(\"[a-z]{2,40}\") fun isValidUsername(username: String): Boolean { return usernameRegex.matches(username) }The function becomes widely adopted:Some callers use it during customer sign-up. We don’t want customers putting slashes in their usernames!Others use it to validate the strings they’re receiving are actually usernames. It would be bad to mix up a username with an email address!Years later, your product team changes the rules. So you implement version 2 of the username rules:private val usernameRegex = Regex(\"[a-z0-9-]{2,15}\") fun isValidUsername(username: String): Boolean { return usernameRegex.matches(username) }But this won’t work! It’ll crash validating long usernames issued before version 2. So you split callers by use-case:private val usernameRegex2015 = Regex(\"[a-z]{2,40}\") private val usernameRegex2023 = Regex(\"[a-z0-9-]{2,15}\") @Deprecated( message = \"If this is for sign-up, call isValidNewUsername(). \" + \"Otherwise call isValidExistingUsername()\" ) fun isValidUsername(username: String): Boolean { return isValidExistingUsername(username) } fun isValidExistingUsername(username: String): Boolean { return usernameRegex2015.matches(username) || usernameRegex2023.matches(username) } fun isValidNewUsername(username: String): Boolean { return usernameRegex2023.matches(username) }Who Fixes The Deprecation Warnings?Now that you’ve deprecated the old function, somebody needs to do is fix the 400 callers of the old function which spread across 20 product teams.Option 1: Farm it Out to the Owners of the Calling CodeYou merge \u0026 release the updated usernames library.The next day, some engineers who needed valid usernames a few years ago will see the deprecation warning and promptly fix their codebase.On other teams, the original authors have moved on. The new maintainers will see the deprecation warning and add a task to the next sprint to figure out what do to.On yet other teams, the team is responsible for some old code that does stuff with usernames. But the team is busy building a replacement service that’ll ship any day now. When that’s done this old code can all be deleted.In frustration with the laggards, you repeatedly broadcast Slack messages explaining the deprecation and encourage everyone to do their part.Option 2: You Grind And Fix It EverywhereYou merge \u0026 release the updated usernames library.Next you use a combination of GitHub search, ripgrep and zoekt to find the impacted codebases. You fix ’em all. Sometimes that’s using find \u0026 replace, and sometimes it’s just typing.You need to learn which of the two functions is appropriate for each callsite, but you pattern match and it’s not so bad. “If returning false triggers a customer-visible error message, it might be a sign-up.”The Case For GrindingIt’s so easy to deprecate and move on. You work in your codebase; other people work in theirs, and there’s no need to learn the style \u0026 process conventions for other teams. Deprecation-sensitive downstream teams can fix this quickly. Teams that don’t respond to deprecations are bad software engineers and that’s not your fault!But farming out work costs more for the organization as a whole.Developers will need to spend time learning the distinction between the two functions. They may also need to study their own code! But they won’t be working on this problem long enough to discover patterns.Teams may also spend time prioritizing and scheduling the work. They won’t find out if this is a 5-minute job or a 1-day one until they dig in.Personally driving a broad change like this to completion is how you can ensure you’ll reach 100%.Some made up numbers:Farm: 20 teams x 1 day of work per codebase = 20 daysGrind: 1 person x 20 codebases x 4 hours of work per codebase = 10 daysThe grind approach is also better suited to automation. Maybe you like structured search \u0026 replace, or perhaps OpenRewrite.A Real-World ExampleA couple years ago I migrated 300 repos from Gradle’s old Groovy-based syntax to the new Kotlin-based syntax. I had a ton of fun writing a (very crude) program to automate about ~95% of each migration.The process was fun – I love getting paid to write a parser! And I got to go pretty deep on Gradle.Now that it’s all .kts a few hundred people will never need to learn Groovy to build their Kotlin services. If instead I’d asked each team to do their own migrations, they’d need somebody to learn Groovy before they could even start.Fix Your CallersMost of the time I do deep changes within a single codebase. But sometimes it’s worth making a shallow change in many codebases.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eSuppose your organization has a widely-used internal library for validating customer usernames:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate val usernameRegex = Regex(\u0026#34;[a-z]{2,40}\u0026#34;)\n\nfun isValidUsername(username: String): Boolean {\n  return usernameRegex.matches(username)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe function becomes widely adopted:\u003c/p\u003e\u003cul\u003e\u003cli\u003eSome callers use it during customer sign-up. We don’t want customers putting slashes in their usernames!\u003c/li\u003e\u003cli\u003eOthers use it to validate the strings they’re receiving are actually usernames. It would be bad to mix up a username with an email address!\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYears later, your product team changes the rules. So you implement version 2 of the username rules:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate val usernameRegex = Regex(\u0026#34;[a-z0-9-]{2,15}\u0026#34;)\n\nfun isValidUsername(username: String): Boolean {\n  return usernameRegex.matches(username)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut this won’t work! It’ll crash validating long usernames issued before version 2. So you split callers by use-case:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate val usernameRegex2015 = Regex(\u0026#34;[a-z]{2,40}\u0026#34;)\nprivate val usernameRegex2023 = Regex(\u0026#34;[a-z0-9-]{2,15}\u0026#34;)\n\n@Deprecated(\n  message = \u0026#34;If this is for sign-up, call isValidNewUsername(). \u0026#34; +\n    \u0026#34;Otherwise call isValidExistingUsername()\u0026#34;\n)\nfun isValidUsername(username: String): Boolean {\n  return isValidExistingUsername(username)\n}\n\nfun isValidExistingUsername(username: String): Boolean {\n  return usernameRegex2015.matches(username)\n    || usernameRegex2023.matches(username)\n}\n\nfun isValidNewUsername(username: String): Boolean {\n  return usernameRegex2023.matches(username)\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"who-fixes-the-deprecation-warnings\"\u003eWho Fixes The Deprecation Warnings?\u003c/h2\u003e\u003cp\u003eNow that you’ve deprecated the old function, somebody needs to do is fix the 400 callers of the old function which spread across 20 product teams.\u003c/p\u003e\u003ch3 id=\"option-1-farm-it-out-to-the-owners-of-the-calling-code\"\u003eOption 1: Farm it Out to the Owners of the Calling Code\u003c/h3\u003e\u003cp\u003eYou merge \u0026amp; release the updated usernames library.\u003c/p\u003e\u003cp\u003eThe next day, some engineers who needed valid usernames a few years ago will see the deprecation warning and promptly fix their codebase.\u003c/p\u003e\u003cp\u003eOn other teams, the original authors have moved on. The new maintainers will see the deprecation warning and add a task to the next sprint to figure out what do to.\u003c/p\u003e\u003cp\u003eOn yet other teams, the team is responsible for some old code that does stuff with usernames. But the team is busy building a replacement service that’ll ship any day now. When that’s done this old code can all be deleted.\u003c/p\u003e\u003cp\u003eIn frustration with the laggards, you repeatedly broadcast Slack messages explaining the deprecation and encourage everyone to do their part.\u003c/p\u003e\u003ch3 id=\"option-2-you-grind-and-fix-it-everywhere\"\u003eOption 2: You Grind And Fix It Everywhere\u003c/h3\u003e\u003cp\u003eYou merge \u0026amp; release the updated usernames library.\u003c/p\u003e\u003cp\u003eNext you use a combination of GitHub search, \u003ca href=\"https://github.com/BurntSushi/ripgrep\"\u003eripgrep\u003c/a\u003e and \u003ca href=\"https://github.com/sourcegraph/zoekt\"\u003ezoekt\u003c/a\u003e to find the impacted codebases. You fix ’em all. Sometimes that’s using find \u0026amp; replace, and sometimes it’s just typing.\u003c/p\u003e\u003cp\u003eYou need to learn which of the two functions is appropriate for each callsite, but you pattern match and it’s not so bad. \u003cem\u003e“If returning false triggers a customer-visible error message, it might be a sign-up.”\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"the-case-for-grinding\"\u003eThe Case For Grinding\u003c/h2\u003e\u003cp\u003eIt’s so easy to deprecate and move on. You work in your codebase; other people work in theirs, and there’s no need to learn the style \u0026amp; process conventions for other teams. Deprecation-sensitive downstream teams can fix this quickly. Teams that don’t respond to deprecations are bad software engineers and that’s not your fault!\u003c/p\u003e\u003cp\u003eBut farming out work costs more for the organization as a whole.\u003c/p\u003e\u003cp\u003eDevelopers will need to spend time learning the distinction between the two functions. They may also need to study their own code! But they won’t be working on this problem long enough to discover patterns.\u003c/p\u003e\u003cp\u003eTeams may also spend time prioritizing and scheduling the work. They won’t find out if this is a 5-minute job or a 1-day one until they dig in.\u003c/p\u003e\u003cp\u003ePersonally driving a broad change like this to completion is how you can ensure you’ll reach 100%.\u003c/p\u003e\u003cp\u003eSome made up numbers:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eFarm:\u003c/strong\u003e 20 teams x 1 day of work per codebase = \u003cstrong\u003e20 days\u003c/strong\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eGrind:\u003c/strong\u003e 1 person x 20 codebases x 4 hours of work per codebase = \u003cstrong\u003e10 days\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe grind approach is also better suited to automation. Maybe you like structured search \u0026amp; replace, or perhaps \u003ca href=\"https://docs.openrewrite.org/\"\u003eOpenRewrite\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"a-real-world-example\"\u003eA Real-World Example\u003c/h2\u003e\u003cp\u003eA couple years ago I migrated 300 repos from Gradle’s old Groovy-based syntax to the new Kotlin-based syntax. I had a ton of fun writing a (very crude) program to automate about ~95% of each migration.\u003c/p\u003e\u003cp\u003eThe process was fun – I love getting paid to write a parser! And I got to go pretty deep on Gradle.\u003c/p\u003e\u003cp\u003eNow that it’s all \u003ccode\u003e.kts\u003c/code\u003e a few hundred people will never need to learn Groovy to build their Kotlin services. If instead I’d asked each team to do their own migrations, they’d need somebody to learn Groovy before they could even start.\u003c/p\u003e\u003ch2 id=\"fix-your-callers\"\u003eFix Your Callers\u003c/h2\u003e\u003cp\u003eMost of the time I do deep changes within a single codebase. But sometimes it’s worth making a shallow change in many codebases.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2023-06-10T04:16:43Z",
  "modifiedTime": "2023-06-12T11:29:57Z"
}
