{
  "id": "5b5b65c5-6dcc-4487-b471-b175539422f0",
  "title": "Make WebViews edge-to-edge",
  "link": "https://medium.com/androiddevelopers/make-webviews-edge-to-edge-a6ef319adfac?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Ash Nohe",
  "published": "Tue, 25 Mar 2025 19:43:00 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "android-app-development",
    "edge-to-edge",
    "webview",
    "android-16",
    "android-15"
  ],
  "byline": "Ash Nohe",
  "length": 12256,
  "excerpt": "Ensure your WebViews are compatible with Android 16, as Android 16 removes the ability to opt-out of drawing your app edge-to-edge. The way you handle insets for WebViews depends on whether or not…",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Make WebViews edge-to-edgeEnsure your WebViews are compatible with Android 16, as Android 16 removes the ability to opt-out of drawing your app edge-to-edge. The way you handle insets for WebViews depends on whether or not your app owns the web content.This post assumes basic knowledge of handling insets and is applicable if your WebViews are drawing underneath system bars or display cutouts. See the Compose and Views documentation, and the Inset handling tips blog for guidance on handling insets.If you’re looking for guidance on how to make your webpage edge-to-edge on Chrome, see the Chrome on Android edge-to-edge migration guide instead.This post covers the following topics:How to handle WebViews if your app doesn’t own the web contentHow to handle WebViews if your app owns the web contentHandling IME insets in WebViewsIf your app doesn’t own the web contentWebViews displaying external content cannot easily draw edge-to-edge and should instead be inset to avoid the system bars and display cutout. The implementation is different depending on if you’re using Compose or Views, but generally follows these steps:Wrap the WebView in a container and apply insets as padding on that container.Set the app’s background color in a best-effort attempt to match the webpage.Figure 1. Left to right. (a) The left image shows a full screen WebView in an app targeting SDK 35, at which point edge-to-edge is enforced. The top of the WebView collides with status bar icons. (b) The middle image shows the result of padding the WebView’s parent. The app’s background is set to red to make it apparent that the WebView is inset. (c) The right image is the desired result. The app’s background is set to white in a best-effort attempt to match the webpage.See the following code samples.Apply insets to a WebView in a Compose appTo ensure a WebView in Compose avoids overlapping with system bars, display cutout and keyboard, apply Modifier.windowInsetsPadding(WindowInsets.safeDrawing) to its wrapper (e.g. AndroidView). This provides the necessary padding to keep the WebView content within the safe area of the screen.@Composablefun WebViewInCompose() { AndroidView( modifier = Modifier.windowInsetsPadding(WindowInsets.safeDrawing), factory = { context -\u003e WebView(context).apply { // Configure WebView options here } } )}Then, update your app’s background so it matches the WebView’s background as much as possible.Apply insets to a WebView in a Views appTo ensure a WebView in Views avoids overlapping the system bars, display cutout and keyboard, wrap the WebView in a container like a FrameLayout and do one of the following:Set android:fitsSystemWindows=\"true\"Use ViewCompat.setOnApplyWindowInsetsListener() and apply systemBars, displayCutout, and ime insets on the container. See the Views documentation for a code sample using the listener.Finally, update android:windowBackground in your themes.xml so it matches the WebView’s background if possible.If your app owns the web contentIf your app owns the web content, either pad the WebView’s parent as described above; or, use JavaScript to inject padding into the web page to draw the page edge-to-edge as described below.To inject padding into the web page, first add \u003cmeta name=”viewport” content=”viewport-fit=cover”\u003e to your HTML.\u003cmeta name=\"viewport\" content=\"viewport-fit=cover, initial-scale=1\" /\u003eSecond, define CSS variables for top, right, bottom and left safe area insets, as the env(safe-area-inset-*) variables return 0px on Android at the time of writing this blog./* CSS */body { padding-top: var(--safe-area-inset-top); padding-right: var(--safe-area-inset-right); padding-bottom: var(--safe-area-inset-bottom); padding-left: var(--safe-area-inset-left);}Instead of applying insets on the WebView’s container, use JavaScript to pass the insets to your CSS variables to pad the webpage. The implementation is different depending on if you’re using Compose or Views, but it generally follows these steps:Retrieve the top, right, bottom and left system bar, display cutout and IME insets as raw pixel values.Convert the raw pixel values to density independent pixels.Inject the density independent pixels into the CSS variables as CSS pixels. When the website renders on the Android device, the WebView converts the CSS pixels back to density independent pixels. See Support different screens in web apps for more information.In Compose, recompose when the software keyboard expands or collapses if applicable.In Views, dispatch insets when the webpage first loads.Figure 2. Top to bottom. (a) The top image shows a full screen WebView in an app targeting SDK 35, at which point edge-to-edge is enforced. The WebView collides with system bars and display cutout. (b) The bottom image shows the result of using JavaScript to inject padding into the webpage, which is the edge-to-edge result we want.See the following code samples.Using Compose and JavaScript to inject insets into web pagesA code sample showing how to use JavaScript to inject insets into webpages in a Compose app.import android.webkit.WebViewimport android.webkit.WebViewClientimport androidx.compose.foundation.layout.WindowInsetsimport androidx.compose.foundation.layout.imeimport androidx.compose.foundation.layout.safeDrawingimport androidx.compose.ui.unit.Dp...@Composablefun MainScreen() { Box(modifier = Modifier.fillMaxSize()) { // Retrieve insets as raw pixels val insets = WindowInsets.safeDrawing WebViewInCompose( initialUrl = \"file:///android_asset/example.html\", insets = insets ) }}@SuppressLint(\"SetJavaScriptEnabled\")@Composablefun WebViewInCompose( initialUrl: String, insets: WindowInsets, density: Density = LocalDensity.current, layoutDirection: LayoutDirection = LocalLayoutDirection.current, myWebViewClient: CustomWebViewClient = remember { CustomWebViewClient( insets, density, layoutDirection ) }) { // Don't apply insets to the container AndroidView( factory = { context -\u003e WebView(context).apply { webViewClient = myWebViewClient settings.javaScriptEnabled = true loadUrl(initialUrl) } }, update = { view -\u003e // Updates webpage when software keyboard expands or collapses. // If your webpage doesn't have an input field that opens the // software keyboard, remove this line. applySafeAreaInsetsToWebView(insets, density, layoutDirection, view) } )}class CustomWebViewClient( private val insets: WindowInsets, private val density: Density, private val layoutDirection: LayoutDirection) : WebViewClient(){ override fun onPageFinished(view: WebView?, url: String?) { super.onPageFinished(view, url) // Inject insets into the webpage once the page has fully loaded applySafeAreaInsetsToWebView(insets, density, layoutDirection, view) }}private fun applySafeAreaInsetsToWebView( insets: WindowInsets, density: Density, layoutDirection: LayoutDirection, webView: WebView?){ // Convert raw pixels to density independent pixels val top = insets.getTop(density).toDp(density).value val right = insets.getRight(density, layoutDirection).toDp(density).value val bottom = insets.getBottom(density).toDp(density).value val left = insets.getLeft(density, layoutDirection).toDp(density).value val safeAreaJs = \"\"\" document.documentElement.style.setProperty('--safe-area-inset-top', '${top}px'); document.documentElement.style.setProperty('--safe-area-inset-right', '${right}px'); document.documentElement.style.setProperty('--safe-area-inset-bottom', '${bottom}px'); document.documentElement.style.setProperty('--safe-area-inset-left', '${left}px'); \"\"\" // Inject the density independent pixels into the CSS variables as CSS pixels webView?.evaluateJavascript(safeAreaJs, null)}private fun Int.toDp(density: Density): Dp = with(density) { this@toDp.toDp() }Using Views and JavaScript to inject insets into web pagesA code sample showing how to use JavaScript to inject insets into webpages in a Views app.import androidx.core.util.TypedValueCompat.pxToDpimport androidx.core.view.WindowInsetsCompat.Type.displayCutoutimport androidx.core.view.WindowInsetsCompat.Type.imeimport androidx.core.view.WindowInsetsCompat.Type.systemBars...override fun onCreate(savedInstanceState: Bundle?) { ... val myWebView: WebView = findViewById(R.id.webView) myWebView.settings.javaScriptEnabled = true myWebView.loadUrl(\"file:///android_asset/example.html\") ViewCompat.setOnApplyWindowInsetsListener(myWebView) { _, windowInsets -\u003e // Retrieve insets as raw pixels val safeDrawingInsets = windowInsets.getInsets( systemBars() or displayCutout() or ime() ) val displayMetrics = myWebView.context.resources.displayMetrics // Convert raw pixels to density independent pixels val top = pxToDp(safeDrawingInsets.top.toFloat(), displayMetrics) val right = pxToDp(safeDrawingInsets.right.toFloat(), displayMetrics) val bottom = pxToDp(safeDrawingInsets.bottom.toFloat(), displayMetrics) val left = pxToDp(safeDrawingInsets.left.toFloat(), displayMetrics) val safeAreaJs = \"\"\" document.documentElement.style.setProperty('--safe-area-inset-top', '${top}px'); document.documentElement.style.setProperty('--safe-area-inset-right', '${right}px'); document.documentElement.style.setProperty('--safe-area-inset-bottom', '${bottom}px'); document.documentElement.style.setProperty('--safe-area-inset-left', '${left}px'); \"\"\" // Inject the density independent pixels into the CSS variables as CSS pixels myWebView.evaluateJavascript(safeAreaJs, null) windowInsets } myWebView.webViewClient = object : WebViewClient() { override fun onPageFinished(view: WebView, url: String) { super.onPageFinished(myWebView, url) // dispatch insets because insets aren't applied when the webpage first loads. view.requestApplyInsets() } }}Note: If the injected insets look too large, it might be because your website’s Viewport initial-scale is more than 1. In this case, divide the top, right, bottom, and left variables by the scale.Handling IME insets in WebViewsTo ensure your web page correctly adjusts when the on-screen keyboard (IME) appears, you must also account for IME insets. The provided Compose and Views code example already includes this by retrieving WindowInsets.safeDrawing() in Compose or WindowInsetsCompat.Type.ime() in Views:// Getting IME insets from the above Compose code sample// safeDrawing includes ime, systemBars, and displayCutoutWindowInsets.safeDrawing// Getting IME insets from the above Views code sampleval safeDrawingInsets = windowInsets.getInsets( systemBars() or displayCutout() or ime())Omitting IME insets will lead to issues where the webpage content is obscured by the keyboard. For example, when the user taps an HTML text input and the IME expands, the webpage won’t resize, preventing the user from seeing content hidden behind the keyboard. By including IME insets, the webpage dynamically adjusts its layout when the IME is displayed, ensuring all content remains accessible to the user.Figure 3. Left (incorrect implementation) to right (correct implementation). (a) The left GIF shows a full-screen WebView where IME insets aren’t handled. When the IME appears, the user cannot scroll to view content behind it. (b) The right image shows the same WebView with correct IME inset handling. After the IME appears, the user can scroll to access the full webpage content.In summary, ensuring WebViews are compatible with an edge-to-edge display requires different approaches depending on whether the app owns the web content. For external content, wrap the WebView in a container and apply insets as padding. For owned content, either pad the container or inject JavaScript to handle insets within the webpage.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*vYYSHqniJAFO-mOIG45wYg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"1d60\" data-testid=\"storyTitle\"\u003eMake WebViews edge-to-edge\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@ashley.nohe?source=post_page---byline--a6ef319adfac---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ash Nohe\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*0dQdET0RLC8J6ZRVvRTr4Q.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page---byline--a6ef319adfac---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"0d45\"\u003eEnsure your WebViews are compatible with Android 16, as \u003ca href=\"https://developer.android.com/about/versions/16/behavior-changes-16#edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid 16 removes the ability to opt-out of drawing your app edge-to-edge\u003c/a\u003e. The way you handle insets for WebViews depends on whether or not your app owns the web content.\u003c/p\u003e\u003cp id=\"97a2\"\u003eThis post assumes basic knowledge of handling insets and is applicable if your WebViews are drawing underneath system bars or display cutouts. See the \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/insets\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCompose\u003c/a\u003e and \u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eViews\u003c/a\u003e documentation, and the \u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/insets-handling-tips-for-android-15s-edge-to-edge-enforcement-872774e8839b\"\u003eInset handling tips\u003c/a\u003e blog for guidance on handling insets.\u003c/p\u003e\u003cp id=\"0d37\"\u003eIf you’re looking for guidance on how to make your webpage edge-to-edge on Chrome, see the \u003ca href=\"https://developer.chrome.com/docs/css-ui/edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChrome on Android edge-to-edge migration guide\u003c/a\u003e instead.\u003c/p\u003e\u003cp id=\"bdfe\"\u003eThis post covers the following topics:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8056\"\u003eHow to handle WebViews if your app doesn’t own the web content\u003c/li\u003e\u003cli id=\"fec4\"\u003eHow to handle WebViews if your app owns the web content\u003c/li\u003e\u003cli id=\"c5c1\"\u003eHandling IME insets in WebViews\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"416a\"\u003eIf your app doesn’t own the web content\u003c/h2\u003e\u003cp id=\"9b6f\"\u003eWebViews displaying external content cannot easily draw edge-to-edge and should instead be inset to avoid the system bars and display cutout. The implementation is different depending on if you’re using Compose or Views, but generally follows these steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"f98c\"\u003eWrap the WebView in a container and apply insets as padding on that container.\u003c/li\u003e\u003cli id=\"51f7\"\u003eSet the app’s background color in a best-effort attempt to match the webpage.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 1.\u003c/strong\u003e Left to right. (a) The left image shows a full screen WebView in an app targeting SDK 35, at which point edge-to-edge is enforced. The top of the WebView collides with status bar icons. (b) The middle image shows the result of padding the WebView’s parent. The app’s background is set to red to make it apparent that the WebView is inset. (c) The right image is the desired result. The app’s background is set to white in a best-effort attempt to match the webpage.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1294\"\u003eSee the following code samples.\u003c/p\u003e\u003ch2 id=\"204a\"\u003eApply insets to a WebView in a Compose app\u003c/h2\u003e\u003cp id=\"2d41\"\u003eTo ensure a WebView in Compose avoids overlapping with system bars, display cutout and keyboard, apply \u003ccode\u003eModifier.windowInsetsPadding(WindowInsets.safeDrawing)\u003c/code\u003e to its wrapper (e.g. \u003ccode\u003eAndroidView\u003c/code\u003e). This provides the necessary padding to keep the WebView content within the safe area of the screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4833\"\u003e@Composable\u003cbr/\u003efun WebViewInCompose() {\u003cbr/\u003e    AndroidView(\u003cbr/\u003e        modifier = Modifier.windowInsetsPadding(WindowInsets.safeDrawing),\u003cbr/\u003e        factory = { context -\u0026gt;\u003cbr/\u003e            WebView(context).apply {\u003cbr/\u003e                // Configure WebView options here\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ea2d\"\u003eThen, update your app’s background so it matches the WebView’s background as much as possible.\u003c/p\u003e\u003ch2 id=\"9d18\"\u003eApply insets to a WebView in a Views app\u003c/h2\u003e\u003cp id=\"ad97\"\u003eTo ensure a WebView in Views avoids overlapping the system bars, display cutout and keyboard, wrap the WebView in a container like a \u003ccode\u003eFrameLayout\u003c/code\u003e and do one of the following:\u003c/p\u003e\u003cul\u003e\u003cli id=\"87df\"\u003eSet \u003ccode\u003eandroid:fitsSystemWindows=\u0026#34;true\u0026#34;\u003c/code\u003e\u003c/li\u003e\u003cli id=\"267a\"\u003eUse \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener()\u003c/code\u003e and apply \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat.Type#systemBars()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esystemBars\u003c/a\u003e, \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat.Type#displayCutout()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edisplayCutout\u003c/a\u003e, and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat.Type#ime()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eime\u003c/a\u003e insets on the container. See the \u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eViews\u003c/a\u003e documentation for a code sample using the listener.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b77d\"\u003eFinally, update \u003ccode\u003eandroid:windowBackground\u003c/code\u003e in your \u003ccode\u003ethemes.xml\u003c/code\u003e so it matches the WebView’s background if possible.\u003c/p\u003e\u003ch2 id=\"2932\"\u003eIf your app owns the web content\u003c/h2\u003e\u003cp id=\"6eb1\"\u003eIf your app owns the web content, either pad the WebView’s parent as described above; or, use JavaScript to inject padding into the web page to draw the page edge-to-edge as described below.\u003c/p\u003e\u003cp id=\"731d\"\u003eTo inject padding into the web page, first add \u003ccode\u003e\u0026lt;meta name=”viewport” content=”viewport-fit=cover”\u0026gt;\u003c/code\u003e to your HTML.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e15\"\u003e\u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;viewport-fit=cover, initial-scale=1\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9b97\"\u003eSecond, define CSS variables for top, right, bottom and left safe area insets, as the \u003ccode\u003eenv(safe-area-inset-*)\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/env\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003evariables\u003c/a\u003e return 0px on Android at the time of writing this blog.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c370\"\u003e/* CSS */\u003cbr/\u003ebody {\u003cbr/\u003e  padding-top: var(--safe-area-inset-top);\u003cbr/\u003e  padding-right: var(--safe-area-inset-right);\u003cbr/\u003e  padding-bottom: var(--safe-area-inset-bottom);\u003cbr/\u003e  padding-left: var(--safe-area-inset-left);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4c6c\"\u003eInstead of applying insets on the WebView’s container, use JavaScript to pass the insets to your CSS variables to pad the webpage. The implementation is different depending on if you’re using Compose or Views, but it generally follows these steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"17e6\"\u003eRetrieve the top, right, bottom and left system bar, display cutout and IME insets as raw pixel values.\u003c/li\u003e\u003cli id=\"523b\"\u003eConvert the raw pixel values to density independent pixels.\u003c/li\u003e\u003cli id=\"6762\"\u003eInject the density independent pixels into the CSS variables as CSS pixels. When the website renders on the Android device, the WebView converts the CSS pixels back to density independent pixels. See \u003ca href=\"https://developer.android.com/develop/ui/views/layout/webapps/targeting\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSupport different screens in web apps\u003c/a\u003e for more information.\u003c/li\u003e\u003cli id=\"0a01\"\u003eIn Compose, recompose when the software keyboard expands or collapses if applicable.\u003c/li\u003e\u003cli id=\"e2bf\"\u003eIn Views, dispatch insets when the webpage first loads.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 2.\u003c/strong\u003e Top to bottom. (a) The top image shows a full screen WebView in an app targeting SDK 35, at which point edge-to-edge is enforced. The WebView collides with system bars and display cutout. (b) The bottom image shows the result of using JavaScript to inject padding into the webpage, which is the edge-to-edge result we want.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e232\"\u003eSee the following code samples.\u003c/p\u003e\u003ch2 id=\"5cb2\"\u003eUsing Compose and JavaScript to inject insets into web pages\u003c/h2\u003e\u003cp id=\"b5e1\"\u003eA code sample showing how to use JavaScript to inject insets into webpages in a Compose app.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"30c6\"\u003eimport android.webkit.WebView\u003cbr/\u003eimport android.webkit.WebViewClient\u003cbr/\u003eimport androidx.compose.foundation.layout.WindowInsets\u003cbr/\u003eimport androidx.compose.foundation.layout.ime\u003cbr/\u003eimport androidx.compose.foundation.layout.safeDrawing\u003cbr/\u003eimport androidx.compose.ui.unit.Dp\u003cbr/\u003e...\u003cp\u003e@Composable\u003cbr/\u003efun MainScreen() {\u003cbr/\u003e    Box(modifier = Modifier.fillMaxSize()) {\u003c/p\u003e\u003cp\u003e                // Retrieve insets as raw pixels\u003cbr/\u003e        val insets = WindowInsets.safeDrawing\u003cbr/\u003e        WebViewInCompose(\u003cbr/\u003e            initialUrl = \u0026#34;file:///android_asset/example.html\u0026#34;,\u003cbr/\u003e            insets = insets\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@SuppressLint(\u0026#34;SetJavaScriptEnabled\u0026#34;)\u003cbr/\u003e@Composable\u003cbr/\u003efun WebViewInCompose(\u003cbr/\u003e    initialUrl: String,\u003cbr/\u003e    insets: WindowInsets,\u003cbr/\u003e    density: Density = LocalDensity.current,\u003cbr/\u003e    layoutDirection: LayoutDirection = LocalLayoutDirection.current,\u003cbr/\u003e    myWebViewClient: CustomWebViewClient = remember { CustomWebViewClient(\u003cbr/\u003e        insets, density, layoutDirection\u003cbr/\u003e    ) }\u003cbr/\u003e) {\u003c/p\u003e\u003cp\u003e        // Don\u0026#39;t apply insets to the container \u003cbr/\u003e    AndroidView(\u003cbr/\u003e        factory = { context -\u0026gt;\u003cbr/\u003e            WebView(context).apply {\u003cbr/\u003e                webViewClient = myWebViewClient\u003cbr/\u003e                settings.javaScriptEnabled = true\u003cbr/\u003e                loadUrl(initialUrl)\u003cbr/\u003e            }\u003cbr/\u003e        }, update = { view -\u0026gt;\u003c/p\u003e\u003cp\u003e                        // Updates webpage when software keyboard expands or collapses.\u003cbr/\u003e            // If your webpage doesn\u0026#39;t have an input field that opens the \u003cbr/\u003e            // software keyboard, remove this line.\u003cbr/\u003e            applySafeAreaInsetsToWebView(insets, density, layoutDirection, view)\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass CustomWebViewClient(\u003cbr/\u003e    private val insets: WindowInsets,\u003cbr/\u003e    private val density: Density,\u003cbr/\u003e    private val layoutDirection: LayoutDirection\u003cbr/\u003e) : WebViewClient(){\u003c/p\u003e\u003cp\u003e    override fun onPageFinished(view: WebView?, url: String?) {\u003cbr/\u003e        super.onPageFinished(view, url)\u003c/p\u003e\u003cp\u003e                // Inject insets into the webpage once the page has fully loaded\u003cbr/\u003e        applySafeAreaInsetsToWebView(insets, density, layoutDirection, view)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eprivate fun applySafeAreaInsetsToWebView(\u003cbr/\u003e    insets: WindowInsets,\u003cbr/\u003e    density: Density,\u003cbr/\u003e    layoutDirection: LayoutDirection,\u003cbr/\u003e    webView: WebView?){\u003c/p\u003e\u003cp\u003e    // Convert raw pixels to density independent pixels\u003cbr/\u003e    val top = insets.getTop(density).toDp(density).value\u003cbr/\u003e    val right = insets.getRight(density, layoutDirection).toDp(density).value\u003cbr/\u003e    val bottom = insets.getBottom(density).toDp(density).value\u003cbr/\u003e    val left = insets.getLeft(density, layoutDirection).toDp(density).value\u003c/p\u003e\u003cp\u003e    val safeAreaJs = \u0026#34;\u0026#34;\u0026#34;\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-top\u0026#39;, \u0026#39;${top}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-right\u0026#39;, \u0026#39;${right}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-bottom\u0026#39;, \u0026#39;${bottom}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-left\u0026#39;, \u0026#39;${left}px\u0026#39;);\u003cbr/\u003e            \u0026#34;\u0026#34;\u0026#34;\u003c/p\u003e\u003cp\u003e    // Inject the density independent pixels into the CSS variables as CSS pixels\u003cbr/\u003e    webView?.evaluateJavascript(safeAreaJs, null)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eprivate fun Int.toDp(density: Density): Dp = with(density) { this@toDp.toDp() }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"fcfc\"\u003eUsing Views and JavaScript to inject insets into web pages\u003c/h2\u003e\u003cp id=\"b764\"\u003eA code sample showing how to use JavaScript to inject insets into webpages in a Views app.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"043c\"\u003eimport androidx.core.util.TypedValueCompat.pxToDp\u003cbr/\u003eimport \u003cbr/\u003eandroidx.core.view.WindowInsetsCompat.Type.displayCutout\u003cbr/\u003eimport androidx.core.view.WindowInsetsCompat.Type.ime\u003cbr/\u003eimport androidx.core.view.WindowInsetsCompat.Type.systemBars\u003cbr/\u003e...\u003cp\u003eoverride fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e    ...\u003c/p\u003e\u003cp\u003e    val myWebView: WebView = findViewById(R.id.webView)\u003cbr/\u003e    myWebView.settings.javaScriptEnabled = true\u003cbr/\u003e    myWebView.loadUrl(\u0026#34;file:///android_asset/example.html\u0026#34;)\u003c/p\u003e\u003cp\u003e    ViewCompat.setOnApplyWindowInsetsListener(myWebView) { _, windowInsets -\u0026gt;\u003c/p\u003e\u003cp\u003e                // Retrieve insets as raw pixels\u003cbr/\u003e        val safeDrawingInsets = windowInsets.getInsets(\u003cbr/\u003e            systemBars() or displayCutout() or ime()\u003cbr/\u003e        )\u003cbr/\u003e        val displayMetrics = myWebView.context.resources.displayMetrics\u003c/p\u003e\u003cp\u003e        // Convert raw pixels to density independent pixels \u003cbr/\u003e        val top = pxToDp(safeDrawingInsets.top.toFloat(), displayMetrics)\u003cbr/\u003e        val right = pxToDp(safeDrawingInsets.right.toFloat(), displayMetrics)\u003cbr/\u003e        val bottom = pxToDp(safeDrawingInsets.bottom.toFloat(), displayMetrics)\u003cbr/\u003e        val left = pxToDp(safeDrawingInsets.left.toFloat(), displayMetrics)\u003c/p\u003e\u003cp\u003e        val safeAreaJs = \u0026#34;\u0026#34;\u0026#34;\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-top\u0026#39;, \u0026#39;${top}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-right\u0026#39;, \u0026#39;${right}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-bottom\u0026#39;, \u0026#39;${bottom}px\u0026#39;);\u003cbr/\u003e            document.documentElement.style.setProperty(\u0026#39;--safe-area-inset-left\u0026#39;, \u0026#39;${left}px\u0026#39;);\u003cbr/\u003e            \u0026#34;\u0026#34;\u0026#34;\u003c/p\u003e\u003cp\u003e        // Inject the density independent pixels into the CSS variables as CSS pixels\u003cbr/\u003e        myWebView.evaluateJavascript(safeAreaJs, null)\u003c/p\u003e\u003cp\u003e        windowInsets\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    myWebView.webViewClient = object : WebViewClient() {\u003cbr/\u003e        override fun onPageFinished(view: WebView, url: String) {\u003cbr/\u003e            super.onPageFinished(myWebView, url)\u003cbr/\u003e            // dispatch insets because insets aren\u0026#39;t applied when the webpage first loads.\u003cbr/\u003e            view.requestApplyInsets()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"42bf\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If the injected insets look too large, it might be because your website’s \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eViewport initial-scale\u003c/a\u003e is more than 1. In this case, divide the top, right, bottom, and left variables by the scale.\u003c/p\u003e\u003ch2 id=\"339d\"\u003eHandling IME insets in WebViews\u003c/h2\u003e\u003cp id=\"7535\"\u003eTo ensure your web page correctly adjusts when the on-screen keyboard (IME) appears, you must also account for IME insets. The provided Compose and Views code example already includes this by retrieving \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.foundation.layout.WindowInsets.Companion).safeDrawing()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsets.safeDrawing()\u003c/a\u003e in Compose or \u003ca href=\"https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.Type#ime()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsetsCompat.Type.ime()\u003c/a\u003e in Views:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dfb5\"\u003e// Getting IME insets from the above Compose code sample\u003cbr/\u003e// safeDrawing includes ime, systemBars, and displayCutout\u003cbr/\u003eWindowInsets.safeDrawing\u003cp\u003e// Getting IME insets from the above Views code sample\u003cbr/\u003eval safeDrawingInsets = windowInsets.getInsets(\u003cbr/\u003e    systemBars() or displayCutout() or ime()\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fdd1\"\u003eOmitting IME insets will lead to issues where the webpage content is obscured by the keyboard. For example, when the user taps an HTML text input and the IME expands, the webpage won’t resize, preventing the user from seeing content hidden behind the keyboard. By including IME insets, the webpage dynamically adjusts its layout when the IME is displayed, ensuring all content remains accessible to the user.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 3.\u003c/strong\u003e Left (incorrect implementation) to right (correct implementation). (a) The left GIF shows a full-screen WebView where IME insets \u003cem\u003earen’t\u003c/em\u003e handled. When the IME appears, the user cannot scroll to view content behind it. (b) The right image shows the same WebView with correct IME inset handling. After the IME appears, the user can scroll to access the full webpage content.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9ce3\"\u003eIn summary, ensuring WebViews are compatible with an edge-to-edge display requires different approaches depending on whether the app owns the web content. For external content, wrap the WebView in a container and apply insets as padding. For owned content, either pad the container or inject JavaScript to handle insets within the webpage.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-03-25T19:43:00.543Z",
  "modifiedTime": null
}
