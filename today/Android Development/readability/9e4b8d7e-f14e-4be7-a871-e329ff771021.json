{
  "id": "9e4b8d7e-f14e-4be7-a871-e329ff771021",
  "title": "Build an Android Chat app with Jetpack Compose",
  "link": "https://proandroiddev.com/android-chat-app-jetpack-compose-dec472140ff1",
  "description": "In this tutorial, you'll learn how to build a real, functional chat app using Jetpack Compose and the Stream Chat Android SDK.",
  "author": "Márton Braun",
  "published": "Fri, 19 Mar 2021 15:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Marton Braun",
  "length": 12155,
  "excerpt": "In this tutorial, you'll learn how to build a real, functional chat app using Jetpack Compose and the Stream Chat Android SDK.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Intro and contextIn our previous article about Jetpack Compose, we shared our initial impressions and recommended some learning resources. This time, we’ll take Compose out for a spin by building a basic chat UI implementation with it!Stream now provides a native Jetpack Compose Chat SDK instead of the approach you see in this article. Check out the Compose Chat Messaging Tutorial and give it a try today!Of course, you might be wondering why we’re building a Compose Chat app when there’s an official Google sample, Jetchat, which is also a chat app using Compose. That sample is a basic UI demo with a small bit of hardcoded data. Here, we’re building a real, functional chat app instead that’s hooked up to a real-time backend service.We already ship a UI Components library in our Chat SDK which contains ready-to-go, fully-featured Android Views to drop into your app, along with ViewModels that let you connect them to business logic in just a single line of code. You can check out how that works in our Android Chat Tutorial.This time, we’re going to reuse the ViewModels (and a View) from that implementation, and build our Compose-based UI on top of that. This won’t be an ideal scenario, as those ViewModels are designed to work with the Views that they ship with.Having dedicated support for Compose in the SDK would make this much nicer and simpler, and that’s something we’ll be working on in the future. However, as you’ll see, it’s already quite easy to integrate Stream Chat with Jetpack Compose, without any specific support for it!The project we’re building in this article is available on GitHub, feel free to clone the project and play around with it on your own! We recommend getting your own Stream API key for this, which you can do by signing up for a free trial. Stream is free for hobby projects and small companies even beyond the trial — just apply for a free Maker account.Project setupTo use Jetpack Compose, we’ll create our project in the latest Canary version of Android Studio. This contains a project template for Compose apps.After creating the project, our first step will be to add the Stream UI Components SDK as a dependency, as well as some Jetpack Compose dependencies we need. Some of our dependencies come from Jitpack, so make sure to add that repository in the settings.gradle file:Then, in the module’s build.gradle file, replace the dependencies block with the following:Check out the GitHub project if you get tangled up in the dependencies.Next, we’ll set up the Stream Chat SDK, providing an API key and user details to it. This is normally done in your custom Application class. To make things simple, we'll use the same environment and user as our tutorial.We’re initializing all three layers of our SDK here: the low-level client, the domain providing offline support, and the UI components. For more info about these, take a look at the documentation. Finally, we’re connecting our user, using a hardcoded, non-expiring example token from the tutorial.Since we created a custom Application class, we have to update our Manifest to use this ChatApplication when the app is launched. We'll also set windowSoftInputMode on the MainActivity so that we'll have better keyboard behaviour later on.Channel List ScreenFirst, we’ll create a screen that lists the channels available to our user. The UI Components library contains a ChannelListView component for this purpose, and we can reuse its ViewModel here.Let’s see what this code does step-by-step:We use the viewModel() method provided by Compose to get a ViewModel for our current context. This allows us to specify a factory that creates a ViewModel, which we need in the case of ChannelListViewModel to pass in some parameters to it. We'll stick to the default parameters of the SDK's ChannelListViewModelFactory for now, which will filter for channels that our current user is a member of.We observe the LiveData state in the ViewModel as a composable State, and we copy it to a local variable so that smart casts will work on it correctly. We also skip rendering anything if this State happens to be null.We’ll have the ChannelListScreen fill the entire screen, and center any content inside it.If the state is loading, we’ll display a basic progress indicator.Otherwise, we’ll display the list of channels in a LazyColumn. Each item will be a ChannelListItem responsible for showing info for a single channel. We're also adding a simple Divider after each item.Now, let’s see how we can render a single ChannelListItem in the list:We’re rendering each item as a Row.Inside that, we’re adding an Avatar representing the Channel at the start.Then we add a Column, laying out two pieces of Text vertically. These will contain the channel's title and a preview of the latest message. Note the LocalContext.current API being used to grab a Context in Compose, as well as the TextOverflow.Ellipsis option that will make long messages behave nicely in the preview.We have one last Composable to implement, the Avatar used above. Our UI components SDK ships an AvatarView with complex rendering logic inside it, which we don't want to reimplement for now. We can use Jetpack Compose's interop features to include our regular Android View inside Compose UI.This will be really simple, just a few lines of code to create a wrapper:The AndroidView function allows us to create... Well, an Android View, which we get a Context for. It also gives us a way to hook into Compose's state updates using its update parameter, which will be executed whenever composable state (in our case, the Channel object) changes. When that happens, we set the new Channel on our AvatarView.Finally, we can add the ChannelListScreen to MainActivity:Building and running this code gives us a working list of channels loaded from Stream’s backend, with performant scrolling thanks to LazyColumn. Not bad for a hundred lines of code for the entire thing!Setting up navigationContinuing with our chat app, let’s create a new screen, where we’ll display the list of messages in a channel. For this, we’ll need to set up click listeners and navigation. We’ll use the Navigation Component for Jetpack Compose here.Step one, we’ll make our ChannelListItem clickable, and add an onClick parameter that it will call when it was clicked:ChannelListScreen will take a NavController as its parameter, and use it to navigate to a new destination when an item was clicked, based on the cid of the channel.We’ll update MainActivity by moving our top-level Composable code to a ChatApp composable, and setting up navigation in there.We’re creating a NavController and a NavHost for our application.Our first and initial destination is a composable: ChannelListScreen. We pass the nav controller to it.Our second destination will be a new composable called MessageListScreen. Here, we pass in both the nav controller and the argument that was used to navigate to it. We can grab this from the NavBackStackEntry parameter.Message List ScreenOur message list will be a LazyColumn similar to the channel list we created before. For displaying messages, the UI Components library gives us a MessageListViewModelFactory which can create a few different ViewModel instances. This takes the cid of the channel we want to display.We’ll implement the MessageList like this:Let’s review:We get a MessageListViewModel from the factory, which will fetch messages for us, and expose it as LiveData.As before, we convert the LiveData state from the ViewModel into composable State.We have three states to handle, defined by a sealed class inside MessageListViewModel. The first state is a loading state, the second is a state that pushes us to the previous screen (using the nav controller), and the third is the result state, where we have a list of messages.In the result state, we’ll grab the list of messages received, filter for only MessageItems (excluding things such as date separators that we don't want to render for now). We also filter for messages that have non-blank text - for example, some messages might have only images attached to them, so we'll skip those for simplicity. Finally, we reverse the list, to match what we're doing in the next step.We use reverseLayout on LazyColumn to stack its items from the bottom. This is similar to using stackFromEnd on a RecyclerView.Each item will be rendered by a MessageCard composable.For a single message, we’ll use the following layout:This code is mostly straightforward, but let’s review some of its important bits:We take a MessageItem as a parameter.Depending on whether this is our current user’s message, or someone else’s, we align it to one of the sides of the screen. We also set colours based on this in a few places.We use a cardShapeFor helper method to create the shape of the Card that holds the message. This will create a shape with rounded corners, except for one of the bottom corners, giving us a chat bubble look.We display the username under each message, so that we can distinguish between messages sent by others.At this point, we can build and run again, and clicking a channel will navigate to the new screen, displaying the list of messages in it.Message InputFor our final piece of Jetpack Compose chat implementation, we’ll add an input view on the message list screen so that we can send new messages.First, we’ll modify MessageListScreen and place a new composable under MessageList:The weight modifier on MessageList will make it take up the maximum available space above the new MessageInput. We pass in the factory to MessageInput as well, so that it's able to access the currently open channel's data via ViewModels.This time, we’ll use a MessageInputViewModel, which normally belongs to the MessageInputView shipped in the UI components library, and handles input actions.We create a piece of composable state to hold the current input value.This local helper function calls into the ViewModel and sends the message to the server. Then, it clears the input field by resetting the state.We use a TextField to capture user input. This displays the current inputValue, and modifies it based on keyboard input. We also set up IME options so that our software keyboard displays a Send button, and we handle that being tapped by calling sendMessage.We’re also adding a Button that the user can tap to send a message. This is enabled/disabled dynamically based on the current input value.The button will show an icon from the default Material icon set. Not to skimp on accessibility, we also add a content description string for the send icon. We grab this from regular Android resources using stringResource, which allows us to localize it as usual. Make sure to create this resource in your project.Let’s build and run for the last time, and we have a working chat app now! We can browse channels, open them, read messages, and send new messages.ConclusionThis complete implementation, including UI, logic, and a connection to a real server is roughly 250 lines of code in total. Almost all of this is UI code with Jetpack Compose, the integration with Stream Chat’s ViewModels and Views is just a small fraction of it.Follow us on Twitter @getstream_io, and the author @zsmb13 for more content like this. If you liked this tutorial, tweet at us and let us know!As a reminder, you can check out the full project and play with it on GitHub. We recommend expanding this project to learn more about Compose — a good first goal could be to add a login screen, so that you can have different users on different devices.To jump into that, sign up for a free trial of Stream Chat. If you’re doing this for a side project or you’re a small business, you can use our SDK for with a free Maker account, even beyond the trial period!Here are some more useful links to continue exploring:- The Stream Chat Android SDK on GitHub, including the UI Components Sample app that showcases many features, and includes a login implementation you can take ideas from- Our regular, non-Compose Android Tutorial- The Stream Chat Android documentation- For more about Compose, some first impressions and recommended learning resources",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*uqfddDez-_gTmsXMS04A5w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@zsmb13?source=post_page-----dec472140ff1--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Marton Braun\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*suFfDiFgPFED3dXss3LJHA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----dec472140ff1--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4851\"\u003eIntro and context\u003c/h2\u003e\u003cp id=\"7d9a\"\u003eIn \u003ca href=\"https://blog.kotlin-academy.com/jetpack-compose-first-impressions-and-learning-resources-4101bff9f04\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eour previous article\u003c/a\u003e about Jetpack Compose, we shared our initial impressions and recommended some learning resources. This time, we’ll take Compose out for a spin by building a basic chat UI implementation with it!\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"0c74\"\u003e\u003cstrong\u003e\u003cem\u003eStream now provides a native \u003c/em\u003e\u003c/strong\u003e\u003ca href=\"https://getstream.io/chat/sdk/compose/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eJetpack Compose Chat SDK\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e\u003cem\u003e instead of the approach you see in this article. Check out the \u003c/em\u003e\u003c/strong\u003e\u003ca href=\"https://getstream.io/chat/compose/tutorial/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eCompose Chat Messaging Tutorial \u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e\u003cem\u003eand give it a try today!\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8c15\"\u003eOf course, you might be wondering why we’re building a Compose Chat app when there’s an official Google sample, \u003ca href=\"https://github.com/android/compose-samples/tree/main/Jetchat\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetchat\u003c/a\u003e, which is also a chat app using Compose. That sample is a basic UI demo with a small bit of hardcoded data. Here, we’re building a real, functional chat app instead that’s hooked up to a real-time backend service.\u003c/p\u003e\u003cp id=\"57c8\"\u003eWe already ship a \u003ca href=\"https://github.com/GetStream/stream-chat-android/tree/main/stream-chat-android-ui-components\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUI Components library\u003c/a\u003e in our Chat SDK which contains ready-to-go, fully-featured Android Views to drop into your app, along with ViewModels that let you connect them to business logic in just a single line of code. You can check out how that works in our \u003ca href=\"https://getstream.io/tutorials/android-chat/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Chat Tutorial\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3c2f\"\u003eThis time, we’re going to reuse the ViewModels (and a View) from that implementation, and build our Compose-based UI on top of that. This won’t be an ideal scenario, as those ViewModels are designed to work with the Views that they ship with.\u003c/p\u003e\u003cp id=\"9bd0\"\u003eHaving dedicated support for Compose in the SDK would make this much nicer and simpler, and that’s something we’ll be working on in the future. However, as you’ll see, it’s already quite easy to integrate Stream Chat with Jetpack Compose, without any specific support for it!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8258\"\u003eThe project we’re building in this article is \u003ca href=\"https://github.com/zsmb13/stream-chat-compose-experiment\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eavailable on GitHub\u003c/a\u003e, feel free to clone the project and play around with it on your own! We recommend getting your own Stream API key for this, which you can do by \u003ca href=\"https://getstream.io/try-for-free/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esigning up for a free trial\u003c/a\u003e. Stream is free for hobby projects and small companies even beyond the trial — just apply for a \u003ca href=\"https://getstream.io/maker-account/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efree Maker account\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"1bcb\"\u003eProject setup\u003c/h2\u003e\u003cp id=\"0794\"\u003eTo use Jetpack Compose, we’ll create our project in the \u003ca href=\"https://developer.android.com/studio/preview\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elatest Canary version of Android Studio\u003c/a\u003e. This contains a project template for Compose apps.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b6c2\"\u003eAfter creating the project, our first step will be to add the Stream UI Components SDK as a dependency, as well as some Jetpack Compose dependencies we need. Some of our dependencies come from Jitpack, so make sure to add that repository in the \u003ccode\u003esettings.gradle\u003c/code\u003e file:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"abf3\"\u003eThen, in the module’s \u003ccode\u003ebuild.gradle\u003c/code\u003e file, replace the \u003ccode\u003edependencies\u003c/code\u003e block with the following:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c42f\"\u003e\u003cem\u003eCheck out \u003c/em\u003e\u003ca href=\"https://github.com/zsmb13/stream-chat-compose-experiment\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ethe GitHub project\u003c/em\u003e\u003c/a\u003e\u003cem\u003e if you get tangled up in the dependencies.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"4c7a\"\u003eNext, we’ll set up the Stream Chat SDK, providing an API key and user details to it. This is normally done in your custom \u003ccode\u003eApplication\u003c/code\u003e class. To make things simple, we\u0026#39;ll use the same environment and user as \u003ca href=\"https://getstream.io/tutorials/android-chat/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eour tutorial\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"33d7\"\u003eWe’re initializing all three layers of our SDK here: the low-level client, the domain providing offline support, and the UI components. For more info about these, take a look at \u003ca href=\"https://getstream.io/chat/docs/android/?language=kotlin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe documentation\u003c/a\u003e. Finally, we’re connecting our user, using a hardcoded, non-expiring example token from the tutorial.\u003c/p\u003e\u003cp id=\"20ec\"\u003eSince we created a custom \u003ccode\u003eApplication\u003c/code\u003e class, we have to update our Manifest to use this \u003ccode\u003eChatApplication\u003c/code\u003e when the app is launched. We\u0026#39;ll also set \u003ccode\u003ewindowSoftInputMode\u003c/code\u003e on the \u003ccode\u003eMainActivity\u003c/code\u003e so that we\u0026#39;ll have better keyboard behaviour later on.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4d8f\"\u003eChannel List Screen\u003c/h2\u003e\u003cp id=\"143c\"\u003eFirst, we’ll create a screen that lists the channels available to our user. The UI Components library contains a \u003ca href=\"https://getstream.io/chat/docs/android/channel_list_view/?language=kotlin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eChannelListView component\u003c/a\u003e for this purpose, and we can reuse its ViewModel here.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4197\"\u003eLet’s see what this code does step-by-step:\u003c/p\u003e\u003col\u003e\u003cli id=\"da14\"\u003eWe use the \u003ccode\u003eviewModel()\u003c/code\u003e method provided by Compose to get a ViewModel for our current context. This allows us to specify a factory that creates a ViewModel, which we need in the case of \u003ccode\u003eChannelListViewModel\u003c/code\u003e to pass in some parameters to it. We\u0026#39;ll stick to the default parameters of the SDK\u0026#39;s \u003ccode\u003eChannelListViewModelFactory\u003c/code\u003e for now, which will filter for channels that our current user is a member of.\u003c/li\u003e\u003cli id=\"204c\"\u003eWe observe the \u003ccode\u003eLiveData\u003c/code\u003e state in the ViewModel as a composable \u003ccode\u003eState\u003c/code\u003e, and we copy it to a local variable so that smart casts will work on it correctly. We also skip rendering anything if this \u003ccode\u003eState\u003c/code\u003e happens to be \u003ccode\u003enull\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"dd3a\"\u003eWe’ll have the \u003ccode\u003eChannelListScreen\u003c/code\u003e fill the entire screen, and center any content inside it.\u003c/li\u003e\u003cli id=\"cf46\"\u003eIf the state is loading, we’ll display a basic progress indicator.\u003c/li\u003e\u003cli id=\"67a3\"\u003eOtherwise, we’ll display the list of channels in a \u003ccode\u003eLazyColumn\u003c/code\u003e. Each item will be a \u003ccode\u003eChannelListItem\u003c/code\u003e responsible for showing info for a single channel. We\u0026#39;re also adding a simple \u003ccode\u003eDivider\u003c/code\u003e after each item.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"84fa\"\u003eNow, let’s see how we can render a single \u003ccode\u003eChannelListItem\u003c/code\u003e in the list:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"c63a\"\u003eWe’re rendering each item as a \u003ccode\u003eRow\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"5bc8\"\u003eInside that, we’re adding an \u003ccode\u003eAvatar\u003c/code\u003e representing the \u003ccode\u003eChannel\u003c/code\u003e at the start.\u003c/li\u003e\u003cli id=\"42b4\"\u003eThen we add a \u003ccode\u003eColumn\u003c/code\u003e, laying out two pieces of \u003ccode\u003eText\u003c/code\u003e vertically. These will contain the channel\u0026#39;s title and a preview of the latest message. Note the \u003ccode\u003eLocalContext.current\u003c/code\u003e API being used to grab a \u003ccode\u003eContext\u003c/code\u003e in Compose, as well as the \u003ccode\u003eTextOverflow.Ellipsis\u003c/code\u003e option that will make long messages behave nicely in the preview.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"981b\"\u003eWe have one last Composable to implement, the \u003ccode\u003eAvatar\u003c/code\u003e used above. Our \u003ca href=\"https://github.com/GetStream/stream-chat-android/tree/main/stream-chat-android-ui-components\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUI components SDK\u003c/a\u003e ships an \u003ccode\u003eAvatarView\u003c/code\u003e with complex rendering logic inside it, which we don\u0026#39;t want to reimplement for now. We can use \u003ca href=\"https://developer.android.com/jetpack/compose/interop\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose\u0026#39;s interop features\u003c/a\u003e to include our regular Android \u003ccode\u003eView\u003c/code\u003e inside Compose UI.\u003c/p\u003e\u003cp id=\"19f3\"\u003eThis will be really simple, just a few lines of code to create a wrapper:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2367\"\u003eThe \u003ccode\u003eAndroidView\u003c/code\u003e function allows us to create... Well, an Android \u003ccode\u003eView\u003c/code\u003e, which we get a \u003ccode\u003eContext\u003c/code\u003e for. It also gives us a way to hook into Compose\u0026#39;s state updates using its \u003ccode\u003eupdate\u003c/code\u003e parameter, which will be executed whenever composable state (in our case, the \u003ccode\u003eChannel\u003c/code\u003e object) changes. When that happens, we set the new \u003ccode\u003eChannel\u003c/code\u003e on our \u003ccode\u003eAvatarView\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"0a6c\"\u003eFinally, we can add the \u003ccode\u003eChannelListScreen\u003c/code\u003e to \u003ccode\u003eMainActivity\u003c/code\u003e:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e4bf\"\u003eBuilding and running this code gives us a working list of channels loaded from Stream’s backend, with performant scrolling thanks to \u003ccode\u003eLazyColumn\u003c/code\u003e. Not bad for a hundred lines of code for the entire thing!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"e61d\"\u003eSetting up navigation\u003c/h2\u003e\u003cp id=\"8f89\"\u003eContinuing with our chat app, let’s create a new screen, where we’ll display the list of messages in a channel. For this, we’ll need to set up click listeners and navigation. We’ll use the \u003ca href=\"https://developer.android.com/jetpack/compose/navigation\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNavigation Component for Jetpack Compose\u003c/a\u003e here.\u003c/p\u003e\u003cp id=\"94eb\"\u003eStep one, we’ll make our \u003ccode\u003eChannelListItem\u003c/code\u003e clickable, and add an \u003ccode\u003eonClick\u003c/code\u003e parameter that it will call when it was clicked:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3ed5\"\u003e\u003ccode\u003eChannelListScreen\u003c/code\u003e will take a \u003ccode\u003eNavController\u003c/code\u003e as its parameter, and use it to navigate to a new destination when an item was clicked, based on the \u003ccode\u003ecid\u003c/code\u003e of the channel.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"228c\"\u003eWe’ll update \u003ccode\u003eMainActivity\u003c/code\u003e by moving our top-level Composable code to a \u003ccode\u003eChatApp\u003c/code\u003e composable, and setting up navigation in there.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"6e74\"\u003eWe’re creating a \u003ccode\u003eNavController\u003c/code\u003e and a \u003ccode\u003eNavHost\u003c/code\u003e for our application.\u003c/li\u003e\u003cli id=\"2f43\"\u003eOur first and initial destination is a composable: \u003ccode\u003eChannelListScreen\u003c/code\u003e. We pass the nav controller to it.\u003c/li\u003e\u003cli id=\"ed1b\"\u003eOur second destination will be a new composable called \u003ccode\u003eMessageListScreen\u003c/code\u003e. Here, we pass in both the nav controller and the argument that was used to navigate to it. We can grab this from the \u003ccode\u003eNavBackStackEntry\u003c/code\u003e parameter.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"3857\"\u003eMessage List Screen\u003c/h2\u003e\u003cp id=\"b71b\"\u003eOur message list will be a \u003ccode\u003eLazyColumn\u003c/code\u003e similar to the channel list we created before. For displaying messages, the UI Components library gives us a \u003ccode\u003eMessageListViewModelFactory\u003c/code\u003e which can create a few different ViewModel instances. This takes the \u003ccode\u003ecid\u003c/code\u003e of the channel we want to display.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5774\"\u003eWe’ll implement the \u003ccode\u003eMessageList\u003c/code\u003e like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9527\"\u003eLet’s review:\u003c/p\u003e\u003col\u003e\u003cli id=\"b7d0\"\u003eWe get a \u003ccode\u003eMessageListViewModel\u003c/code\u003e from the factory, which will fetch messages for us, and expose it as \u003ccode\u003eLiveData\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c9cc\"\u003eAs before, we convert the \u003ccode\u003eLiveData\u003c/code\u003e state from the ViewModel into composable \u003ccode\u003eState\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"2c75\"\u003eWe have three states to handle, defined by a sealed class inside \u003ccode\u003eMessageListViewModel\u003c/code\u003e. The first state is a loading state, the second is a state that pushes us to the previous screen (using the nav controller), and the third is the result state, where we have a list of messages.\u003c/li\u003e\u003cli id=\"aa85\"\u003eIn the result state, we’ll grab the list of messages received, filter for only \u003ccode\u003eMessageItem\u003c/code\u003es (excluding things such as date separators that we don\u0026#39;t want to render for now). We also filter for messages that have non-blank text - for example, some messages might have only images attached to them, so we\u0026#39;ll skip those for simplicity. Finally, we reverse the list, to match what we\u0026#39;re doing in the next step.\u003c/li\u003e\u003cli id=\"969d\"\u003eWe use \u003ccode\u003ereverseLayout\u003c/code\u003e on \u003ccode\u003eLazyColumn\u003c/code\u003e to stack its items from the bottom. This is similar to using \u003ccode\u003estackFromEnd\u003c/code\u003e on a \u003ccode\u003eRecyclerView\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e88b\"\u003eEach item will be rendered by a \u003ccode\u003eMessageCard\u003c/code\u003e composable.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"8c5a\"\u003eFor a single message, we’ll use the following layout:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"336c\"\u003eThis code is mostly straightforward, but let’s review some of its important bits:\u003c/p\u003e\u003col\u003e\u003cli id=\"0f48\"\u003eWe take a \u003ccode\u003eMessageItem\u003c/code\u003e as a parameter.\u003c/li\u003e\u003cli id=\"60f1\"\u003eDepending on whether this is our current user’s message, or someone else’s, we align it to one of the sides of the screen. We also set colours based on this in a few places.\u003c/li\u003e\u003cli id=\"0626\"\u003eWe use a \u003ccode\u003ecardShapeFor\u003c/code\u003e helper method to create the shape of the \u003ccode\u003eCard\u003c/code\u003e that holds the message. This will create a shape with rounded corners, except for one of the bottom corners, giving us a chat bubble look.\u003c/li\u003e\u003cli id=\"5275\"\u003eWe display the username under each message, so that we can distinguish between messages sent by others.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"c83a\"\u003eAt this point, we can build and run again, and clicking a channel will navigate to the new screen, displaying the list of messages in it.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"e97b\"\u003eMessage Input\u003c/h2\u003e\u003cp id=\"6edd\"\u003eFor our final piece of Jetpack Compose chat implementation, we’ll add an input view on the message list screen so that we can send new messages.\u003c/p\u003e\u003cp id=\"bc52\"\u003eFirst, we’ll modify \u003ccode\u003eMessageListScreen\u003c/code\u003e and place a new composable under \u003ccode\u003eMessageList\u003c/code\u003e:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f1d1\"\u003eThe \u003ccode\u003eweight\u003c/code\u003e modifier on \u003ccode\u003eMessageList\u003c/code\u003e will make it take up the maximum available space above the new \u003ccode\u003eMessageInput\u003c/code\u003e. We pass in the \u003ccode\u003efactory\u003c/code\u003e to \u003ccode\u003eMessageInput\u003c/code\u003e as well, so that it\u0026#39;s able to access the currently open channel\u0026#39;s data via ViewModels.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003col\u003e\u003cli id=\"6a8a\"\u003eThis time, we’ll use a \u003ccode\u003eMessageInputViewModel\u003c/code\u003e, which normally belongs to the \u003ca href=\"https://getstream.io/chat/docs/android/message_input_view/?language=kotlin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMessageInputView\u003c/a\u003e shipped in the UI components library, and handles input actions.\u003c/li\u003e\u003cli id=\"5a82\"\u003eWe create a piece of composable state to hold the current input value.\u003c/li\u003e\u003cli id=\"9258\"\u003eThis local helper function calls into the ViewModel and sends the message to the server. Then, it clears the input field by resetting the state.\u003c/li\u003e\u003cli id=\"7b2b\"\u003eWe use a \u003ccode\u003eTextField\u003c/code\u003e to capture user input. This displays the current \u003ccode\u003einputValue\u003c/code\u003e, and modifies it based on keyboard input. We also set up IME options so that our software keyboard displays a \u003cem\u003eSend\u003c/em\u003e button, and we handle that being tapped by calling \u003ccode\u003esendMessage\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"8340\"\u003eWe’re also adding a \u003ccode\u003eButton\u003c/code\u003e that the user can tap to send a message. This is enabled/disabled dynamically based on the current input value.\u003c/li\u003e\u003cli id=\"2c84\"\u003eThe button will show an icon from the default Material icon set. Not to skimp on accessibility, we also add a content description string for the send icon. We grab this from regular Android resources using \u003ccode\u003estringResource\u003c/code\u003e, which allows us to localize it as usual. \u003cem\u003eMake sure to create this resource in your project.\u003c/em\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"06ba\"\u003eLet’s build and run for the last time, and we have a working chat app now! We can browse channels, open them, read messages, and send new messages.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"e4b3\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"153a\"\u003eThis complete implementation, including UI, logic, and a connection to a real server is roughly 250 lines of code in total. Almost all of this is UI code with Jetpack Compose, the integration with Stream Chat’s ViewModels and Views is just a small fraction of it.\u003c/p\u003e\u003cp id=\"545d\"\u003e\u003cem\u003eFollow us on Twitter \u003c/em\u003e\u003ca href=\"https://twitter.com/getstream_io\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003e@getstream_io\u003c/em\u003e\u003c/a\u003e\u003cem\u003e, and the author \u003c/em\u003e\u003ca href=\"https://twitter.com/zsmb13\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003e@zsmb13\u003c/em\u003e\u003c/a\u003e\u003cem\u003e for more content like this. If you liked this tutorial, tweet at us and let us know!\u003c/em\u003e\u003c/p\u003e\u003cp id=\"b3ff\"\u003eAs a reminder, you can check out the full project and play with it \u003ca href=\"https://github.com/zsmb13/stream-chat-compose-experiment\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eon GitHub\u003c/a\u003e. We recommend expanding this project to learn more about Compose — a good first goal could be to add a login screen, so that you can have different users on different devices.\u003c/p\u003e\u003cp id=\"3604\"\u003eTo jump into that, sign up for a \u003ca href=\"https://getstream.io/try-for-free/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efree trial of Stream Chat\u003c/a\u003e. If you’re doing this for a side project or you’re a small business, you can use our SDK for with a \u003ca href=\"https://getstream.io/blog/maker-account/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efree Maker account\u003c/a\u003e, even beyond the trial period!\u003c/p\u003e\u003cp id=\"7d11\"\u003eHere are some more useful links to continue exploring:\u003c/p\u003e\u003cp id=\"b965\"\u003e- The \u003ca href=\"https://github.com/GetStream/stream-chat-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStream Chat Android SDK on GitHub\u003c/a\u003e, including the \u003ca href=\"https://github.com/GetStream/stream-chat-android/tree/main/stream-chat-android-ui-components-sample\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUI Components Sample app\u003c/a\u003e that showcases many features, and includes a login implementation you can take ideas from\u003cbr/\u003e- Our regular, non-Compose \u003ca href=\"https://getstream.io/tutorials/android-chat/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Tutorial\u003c/a\u003e\u003cbr/\u003e- The \u003ca href=\"https://getstream.io/chat/docs/android/?language=kotlin\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStream Chat Android documentation\u003c/a\u003e\u003cbr/\u003e- For more about Compose, some \u003ca href=\"https://blog.kotlin-academy.com/jetpack-compose-first-impressions-and-learning-resources-4101bff9f04\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efirst impressions and recommended learning resources\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2021-02-06T09:00:59Z",
  "modifiedTime": null
}
