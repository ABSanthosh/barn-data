{
  "id": "5557c429-e7eb-46d9-bcac-6f4300c0d4ae",
  "title": "Smoothly reacting to keyboard visibility changes in Android",
  "link": "https://saket.me/smoothly-reacting-to-keyboard/",
  "description": "When people use Dank, one of the terms they use to describe it is fluid. The app makes a good use of motion to indicate changes on the screen, but I think one of my favorite reasons why the app feels fluid is because it handles keyboard changes smoothly. When the soft keyboard is shown, […] The post Smoothly reacting to keyboard visibility changes in Android appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Fri, 05 Oct 2018 19:05:52 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android",
    "animation",
    "keyboard"
  ],
  "byline": "Saket Narayan",
  "length": 2700,
  "excerpt": "Android's soft-keyboard by default forces the content to resize immediately. This looks jarring, but can be improved by using a simple animation.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "When people use Dank, one of the terms they use to describe it is fluid. The app makes a good use of motion to indicate changes on the screen, but I think one of my favorite reasons why the app feels fluid is because it handles keyboard changes smoothly. When the soft keyboard is shown, Android forces the content to resize immediately (unless the windowSoftInputMode is set otherwise). This results in a jarring change in the layout. Unfortunately, neither the platform nor the vast majority of apps handle this, so it looks normal to the user. Here’s a video from Google Keep: In comparison, here’s how Dank reacts to keyboard by smoothly resizing the content upwards. If you’re curious, you can watch the same screen in Dank but with the resize animation turned off here. To achieve this, I learned a small trick. I learned that, when the keyboard is shown, the Activity’s entire window does not get resized. The root layout in the Activity’s View hierarchy, also referred to as the DecorView, stays unaffected. The layout that actually gets resized, is the content layout with the ID, android.R.id.content. What this means, is that the space in DecorView occupied by the keyboard can be reclaimed. The Activity View tree usually looks like this, DecorView - LinearLayout -- FrameLayout \u003c- gets resized --- LinearLayout ---- Activity content I wrote a utility class that takes advantage of this. It observes changes to the content layout’s size. When a resize is detected, it immediately snaps the content back to full height and then manually resizes it, this time with an animator. val decorView = activity.window.decorView decorView.viewTreeObserver.addOnPreDrawListener { val contentHeight = contentViewFrame.height val sizeChanged = contentHeight != previousHeight if (sizeChanged) { animateSizeChange(from = previousHeight, to = contentHeight) } previousHeight = contentHeight } fun animateSizeChange(from: Int, to: Int) { // Immediately snap back to the original size. contentView.setHeight(from) ObjectAnimator.ofInt(from, to) .addUpdateListener { val h = it.animatedValue as Int contentView.setHeight(h) } .start() } // Transitions API would be much more efficient than // using ObjectAnimator, but for some reason it skips // the first animation and I cannot figure out why. You can find the full source here: https://github.com/saket/FluidKeyboardResize Writing this was one of the many things that required low effort, but made a big impact to the motion of the app. I understand that this is not a perfect solution and is more of a workaround, but I’ve been using it for many months now and I haven’t noticed any issues.",
  "image": "https://i1.wp.com/saket.me/wp-content/uploads/2018/10/material_design_motion_wide.jpg?w=1640",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eWhen people use \u003ca href=\"https://saket.me/dank/\"\u003eDank\u003c/a\u003e, one of the terms they use to describe it is \u003cem\u003efluid\u003c/em\u003e. The app makes a good use of motion to indicate changes on the screen, but I think one of my favorite reasons why the app feels fluid is because it handles keyboard changes \u003cem\u003esmoothly\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhen the soft keyboard is shown, Android forces the content to resize immediately (unless the \u003ccode\u003ewindowSoftInputMode\u003c/code\u003e is set otherwise). This results in a jarring change in the layout. Unfortunately, neither the platform nor the vast majority of apps handle this, so it looks normal to the user. Here’s a video from Google Keep:\u003c/p\u003e\n\n\u003cp\u003eIn comparison, here’s how \u003ca href=\"https://saket.me/dank/\"\u003eDank\u003c/a\u003e reacts to keyboard by smoothly resizing the content upwards.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eIf you’re curious, you can watch the same screen in Dank but with the resize animation turned off \u003ca href=\"https://saket.me/wp-content/uploads/2018/10/dank_keyboard_without_animation_1166p.mp4\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehere\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eTo achieve this, I learned a small trick. I learned that, when the keyboard is shown, the Activity’s entire window does not get resized. The root layout in the Activity’s View hierarchy, also referred to as the \u003ccode\u003eDecorView\u003c/code\u003e, stays unaffected. The layout that actually gets resized, is the content layout with the ID, \u003ccode\u003eandroid.R.id.content\u003c/code\u003e. What this means, is that the space in \u003ccode\u003eDecorView\u003c/code\u003e occupied by the keyboard can be reclaimed.\u003c/p\u003e\n\u003cp\u003eThe Activity View tree \u003cem\u003eusually\u003c/em\u003e looks like this,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eDecorView\n- LinearLayout\n-- FrameLayout \u0026lt;- gets resized\n--- LinearLayout\n---- Activity content\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI wrote a utility class that takes advantage of this. It observes changes to the content layout’s size. When a resize is detected, it immediately snaps the content back to full height and then manually resizes it, this time with an animator.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval decorView = activity.window.decorView\n\ndecorView.viewTreeObserver.addOnPreDrawListener { \n  val contentHeight = contentViewFrame.height\n  val sizeChanged = contentHeight != previousHeight\n\n  if (sizeChanged) {\n    animateSizeChange(from = previousHeight, to = contentHeight)\n  }\n\n  previousHeight = contentHeight\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre\u003e\u003ccode\u003efun animateSizeChange(from: Int, to: Int) {\n  // Immediately snap back to the original size.\n  contentView.setHeight(from)\n  \n  ObjectAnimator.ofInt(from, to)\n    .addUpdateListener { \n      val h = it.animatedValue as Int\n      contentView.setHeight(h) \n    }\n    .start()\n}\n\n// Transitions API would be much more efficient than \n// using ObjectAnimator, but for some reason it skips \n// the first animation and I cannot figure out why.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can find the full source here: \u003ca href=\"https://github.com/saket/FluidKeyboardResize\" rel=\"nofollow\"\u003ehttps://github.com/saket/FluidKeyboardResize\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWriting this was one of the many things that required low effort, but made a big impact to the motion of the app. I understand that this is not a perfect solution and is more of a workaround, but I’ve been using it for many months now and I haven’t noticed any issues.\u003c/p\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2018-10-05T19:05:52Z",
  "modifiedTime": "2023-07-17T01:05:09Z"
}
