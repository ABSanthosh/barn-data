{
  "id": "32b772ac-e41d-4bef-acff-39158d7df07a",
  "title": "How Does Mocking Work Internally? A Deep Dive into MockK Internals",
  "link": "https://proandroiddev.com/how-does-mocking-work-internally-a-deep-dive-into-mockk-internals-defecd66b815?source=rss----c72404660798---4",
  "description": "",
  "author": "Sagar Malhotra",
  "published": "Fri, 23 May 2025 07:22:03 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "testing",
    "mockk",
    "android",
    "kotlin"
  ],
  "byline": "Sagar Malhotra",
  "length": 6923,
  "excerpt": "If you’ve ever written unit tests in Kotlin, you’ve probably used MockK. This famous, powerful, expressive mocking library is designed specifically for Kotlin. It feels like magic: you define every {…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "If you’ve ever written unit tests in Kotlin, you’ve probably used MockK. This famous, powerful, expressive mocking library is designed specifically for Kotlin. It feels like magic: you define every { someFunction() } returns value, and suddenly that function doesn’t behave the way it was originally defined. Instead, they will obey your test scenarios and react as you want. But have you ever wondered how it works behind the scenes?In this article, we’ll break down what happens inside MockK, how it hooks into your code, stores return values, and uses bytecode manipulation to do its job. By the end, you’ll understand the secret sauce that powers mocking libraries like MockK.What Is Mocking?In unit testing, mocking means replacing real objects with “fake” ones that simulate the behavior of the real ones. These mocks can:Return controlled data (using returns)Throw exceptions (using throws)Track which methods were called (using verify)This lets you isolate the unit of your code and simulate various edge cases.Example:val userService = mockk\u003cUserService\u003e()every { userService.getUserName() } returns \"Alice\"This “every” line tells MockK: “Whenever someone calls getUserName() On this mocked userService object, just return \"Alice\".”But how does it know to do that?Note: The function call should be on a mocked object, like here userService was a mocked object created using mockk(). If you use this directly on a non-mocked object, or a Static function of a class, or an Object class function, this means the function is not called from a mocked object, and that might cause your tests to fail. You will soon understand why.MockK Internals:1. Creating the Mock:When you write mockk\u003cUserService\u003e()MockK doesn’t just return a regular object using the constructor of the class. It uses powerful libraries behind the scenes to create a \"mocked\" version of your class:ByteBuddy: Generates or manipulates classes at runtime by manipulating bytecode.Objenesis: Instantiates objects without calling their constructors.Understanding the working of these libraries are out of scope for today.This gives MockK full control over what happens when any method on the mock object is called.These mechanisms (like ByteBuddy and Objenesis) are JVM-specific. On non-JVM targets like Kotlin/Native or Kotlin/JS, mocking is usually done through code generation or manual test doubles, since runtime bytecode manipulation is not possible.2. Recording every { ... } :When you write:every { userService.getUserName() } returns \"Alice\"MockK enters recording mode using `CallRecorder.startStubbing` and then:It intercepts the method call (getUserName()).Even though we called the method, it doesn’t run. Instead, it is recorded inside CallRecorder.This ever {} returns us an answerOpportunity , which is a simple interface using which we can provide what Answer type we want from the invocation. You might use it returns(\"expected value\") to make the function return a specific value or throws(Exception()) to simulate an error. You can even use theanswers {... } block to define a whole block of code that should run.3. Storing the Behavior:MockK stores all this info in a chain of internal classes:CallRecorder→ Holds the current list of recorded calls.Matchers → Helps match actual calls to recorded calls. (Multiple matchers are there to serve their unique purposes.)Answer→ Holds the response to return when a match is found.These are used when we get an actual call to the functions. But, how do we know this is called, and how do we override the originally defined behavior?4. Intercepting Calls at RuntimeHere’s where things get wild.When you call this in your test scenario:val name = userService.getUserName()This method doesn’t behave like a normal function call. The call is intercepted at the bytecode level by MockK.MockK has already replaced the method body with a custom handler using ByteBuddy.Instead of running the real code, this handleInvocation function passes the method call details to gatewayAccess.callrecorder().call(invocation).The checks the call against the CallRecorder.If it finds a match, it returns the corresponding answer.When you create a mock object, ByteBuddy dynamically generates a special version of that class. Then, when you define behavior using every {}, ByteBuddy modifies the code of this generated mock object. It essentially tells the methods in the mock object to not execute their original logic (they don't have any in a pure mock anyway) but instead to hand over control to MockK's internal mechanisms. This behind-the-scenes code manipulation is what allows MockK to intercept calls to your mock objects.Invoking the Mocked Function:When your code under test calls a function on your mock object, it looks like a normal function call. However, because of ByteBuddy’s magic, this call is intercepted within the mock object. The execution is redirected to MockK’s internal handler, which is connected to the CallRecorder object of that specific mock, and it directly responds only with the answer you provided.5. Verifying CallsMockK also lets you verify that certain calls were made:verify { userService.getUserName() }When this line runs:MockK switches into verification mode.It checks the list of all method calls that were made on the mocked object (which it records automatically during the test).It then matches them against what you asked to verify.If the call happened, verification passes. Otherwise, it throws an error of `NoSuchInvocationFound`.Overall, it can be imagined as:Some special types:Static methods: They can be mocked directly by using SomeClass.someStatic() as this SomeClass is not a mock class and ByteBuddy doesn’t know how to manipulate this. So, we need to first tell it that!- Use mockkStatic(SomeJavaClass::class) to intercept static methods.Top-level functions: Kotlin top-level functions are compiled into static methods in a hidden class named after the file (e.g., MyFileKt), so the same stuff applies here.- UsemockkStatic(\"com.example.MyFileKt\") to intercept and replace these static methods at runtime.Object class functions: Similar stuff here, but these objects are singletons, so a slight change to respect behavior. - UsemockkObject(MyObject) to intercept method calls.We specifically mocked these classes, so make sure to unmock them after you are done using them to avoid unexpected test case failures in other tests.Conclusion:These APIs can change in the future, but the core idea of mocking will remain the same and is similar to other mocking libraries like Mockito, which also uses ByteBuddy and Objenesis for under-the-hood stuff. Understanding these internal mechanisms can give you a deeper appreciation for how mocking libraries work and help you write more effective and reliable tests. So, the next time you use MockK, remember this article(and me), and the powerful libraries working behind the scenes to make your testcases pass!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*wSI6DlGr7oaKRU2rDb5hrg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://sagar0-0.medium.com/?source=post_page---byline--defecd66b815---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Sagar Malhotra\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*PCJVPFHPX_oQ4eILPEDSag.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"25bb\"\u003eIf you’ve ever written unit tests in Kotlin, you’ve probably used \u003ca href=\"https://github.com/mockk/mockk\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMockK\u003c/a\u003e. This famous, powerful, expressive mocking library is designed specifically for Kotlin. It feels like magic: you define \u003ccode\u003eevery { someFunction() } returns value\u003c/code\u003e, and suddenly that function doesn’t behave the way it was originally defined. Instead, they will obey your test scenarios and react as you want. But have you ever wondered how it works behind the scenes?\u003c/p\u003e\u003cp id=\"fd3c\"\u003eIn this article, we’ll break down what happens inside MockK, how it hooks into your code, stores return values, and uses bytecode manipulation to do its job. By the end, you’ll understand the secret sauce that powers mocking libraries like MockK.\u003c/p\u003e\u003ch2 id=\"3f7e\"\u003eWhat Is Mocking?\u003c/h2\u003e\u003cp id=\"6ad6\"\u003eIn unit testing, \u003cem\u003emocking\u003c/em\u003e means replacing real objects with “fake” ones that simulate the behavior of the real ones. These mocks can:\u003c/p\u003e\u003col\u003e\u003cli id=\"8cb2\"\u003eReturn controlled data (using \u003ccode\u003ereturns\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"86ea\"\u003eThrow exceptions (using \u003ccode\u003ethrows\u003c/code\u003e)\u003c/li\u003e\u003cli id=\"a897\"\u003eTrack which methods were called (using \u003ccode\u003everify\u003c/code\u003e)\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"139f\"\u003eThis lets you isolate the unit of your code and simulate various edge cases.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"207f\"\u003eExample:\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"41cd\"\u003eval userService = mockk\u0026lt;UserService\u0026gt;()\u003cbr/\u003eevery { userService.getUserName() } returns \u0026#34;Alice\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"db11\"\u003eThis “every” line tells MockK: “Whenever someone calls \u003ccode\u003egetUserName()\u003c/code\u003e On \u003cstrong\u003ethis mocked userService object\u003c/strong\u003e, just return \u003ccode\u003e\u0026#34;Alice\u0026#34;\u003c/code\u003e.”\u003c/p\u003e\u003cp id=\"9b41\"\u003eBut how does it \u003cem\u003eknow\u003c/em\u003e to do that?\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"87a5\"\u003eNote: The function call should be on a mocked object, like here userService was a mocked object created using mockk(). If you use this directly on a non-mocked object, or a Static function of a class, or an Object class function, this means the function is not called from a mocked object, and that might cause your tests to fail. You will soon understand why.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"5ede\"\u003eMockK Internals:\u003c/h2\u003e\u003ch2 id=\"3553\"\u003e1. Creating the Mock:\u003c/h2\u003e\u003cp id=\"2f8d\"\u003eWhen you write \u003ccode\u003emockk\u0026lt;UserService\u0026gt;()\u003c/code\u003eMockK doesn’t just return a regular object using the constructor of the class. It uses powerful libraries behind the scenes to create a \u0026#34;mocked\u0026#34; version of your class:\u003c/p\u003e\u003cul\u003e\u003cli id=\"68d6\"\u003e\u003cstrong\u003eByteBuddy\u003c/strong\u003e: Generates or manipulates classes at runtime by manipulating bytecode.\u003c/li\u003e\u003cli id=\"9851\"\u003e\u003cstrong\u003eObjenesis\u003c/strong\u003e: Instantiates objects \u003cem\u003ewithout calling their constructors\u003c/em\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"74cd\"\u003eUnderstanding the working of these libraries are out of scope for today.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"ea3c\"\u003eThis gives MockK full control over what happens when any method on the mock object is called.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d537\"\u003eThese mechanisms (like ByteBuddy and Objenesis) are JVM-specific. On non-JVM targets like Kotlin/Native or Kotlin/JS, mocking is usually done through code generation or manual test doubles, since runtime bytecode manipulation is not possible.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"7fe4\"\u003e\u003cstrong\u003e2. Recording \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eevery { ... } :\u003c/strong\u003e\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"8b78\"\u003eWhen you write:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aa70\"\u003eevery { userService.getUserName() } returns \u0026#34;Alice\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d350\"\u003eMockK enters \u003cem\u003erecording mode using `CallRecorder.\u003c/em\u003estartStubbing` and then:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1dba\"\u003eIt intercepts the method call (\u003ccode\u003egetUserName()\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"8da3\"\u003eEven though we called the method, it doesn’t run. Instead, it is \u003cem\u003erecorded\u003c/em\u003e inside \u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/GatewayAPI.kt#L174\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCallRecorder\u003c/a\u003e\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9934\"\u003eThis ever {} returns us an \u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/GatewayAPI.kt#L167\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eanswerOpportunity\u003c/a\u003e\u003c/code\u003e , which is a simple interface using which we can provide what \u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/API.kt#L3873\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnswer\u003c/a\u003e\u003c/code\u003e type we want from the invocation. You might use it \u003ccode\u003ereturns(\u0026#34;expected value\u0026#34;)\u003c/code\u003e to make the function return a specific value or \u003ccode\u003ethrows(Exception())\u003c/code\u003e to simulate an error. You can even use the\u003ccode\u003eanswers {... }\u003c/code\u003e block to define a whole block of code that should run.\u003c/p\u003e\u003ch2 id=\"88d0\"\u003e3. Storing the Behavior:\u003c/h2\u003e\u003cp id=\"01ae\"\u003eMockK stores all this info in a chain of internal classes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"12b2\"\u003e\u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/GatewayAPI.kt#L174\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCallRecorder\u003c/a\u003e\u003c/code\u003e→ Holds the current list of recorded calls.\u003c/li\u003e\u003cli id=\"033f\"\u003e\u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/API.kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMatchers\u003c/a\u003e\u003c/code\u003e → Helps match actual calls to recorded calls. (Multiple matchers are there to serve their unique purposes.)\u003c/li\u003e\u003cli id=\"7c05\"\u003e\u003ccode\u003e\u003ca href=\"https://github.com/mockk/mockk/blob/4bf4ec761ced65adf7bbd1f49c9017c520fe1880/modules/mockk-dsl/src/commonMain/kotlin/io/mockk/API.kt#L3873\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnswer\u003c/a\u003e\u003c/code\u003e→ Holds the response to return when a match is found.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"dae7\"\u003eThese are used when we get an actual call to the functions. But, how do we know this is called, and how do we override the originally defined behavior?\u003c/p\u003e\u003ch2 id=\"b870\"\u003e4. Intercepting Calls at Runtime\u003c/h2\u003e\u003cp id=\"dd6d\"\u003eHere’s where things get wild.\u003c/p\u003e\u003cp id=\"c729\"\u003eWhen you call this in your test scenario:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"98d3\"\u003eval name = userService.getUserName()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6ee0\"\u003eThis method doesn’t behave like a normal function call. The call is intercepted at the bytecode level by MockK.\u003c/p\u003e\u003cul\u003e\u003cli id=\"8e66\"\u003eMockK has already replaced the method body with a custom handler using \u003cstrong\u003eByteBuddy\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"2e92\"\u003eInstead of running the real code, this \u003ccode\u003ehandleInvocation\u003c/code\u003e function passes the method call details to \u003ccode\u003egatewayAccess.callrecorder().call(invocation)\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"4ac4\"\u003eThe checks the call against the \u003ccode\u003eCallRecorder\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"0de6\"\u003eIf it finds a match, it returns the corresponding answer.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"9001\"\u003eWhen you create a mock object, ByteBuddy dynamically generates a special version of that class. Then, when you define behavior using \u003ccode\u003eevery {}\u003c/code\u003e, ByteBuddy modifies the code of this generated mock object. It essentially tells the methods in the mock object to not execute their original logic (they don\u0026#39;t have any in a pure mock anyway) but instead to hand over control to MockK\u0026#39;s internal mechanisms. This behind-the-scenes code manipulation is what allows MockK to intercept calls to your mock objects.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"6ad0\"\u003eInvoking the Mocked Function:\u003c/h2\u003e\u003cp id=\"c3cc\"\u003eWhen your code under test calls a function on your mock object, it looks like a normal function call. However, because of ByteBuddy’s magic, this call is intercepted within the mock object. The execution is redirected to MockK’s internal handler, which is connected to the \u003ccode\u003eCallRecorder\u003c/code\u003e object of that specific mock, and it directly responds only with the answer you provided.\u003c/p\u003e\u003ch2 id=\"932b\"\u003e5. Verifying Calls\u003c/h2\u003e\u003cp id=\"12cf\"\u003eMockK also lets you verify that certain calls were made:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4032\"\u003everify { userService.getUserName() }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"abd7\"\u003eWhen this line runs:\u003c/p\u003e\u003cul\u003e\u003cli id=\"adc9\"\u003eMockK switches into \u003cem\u003everification mode\u003c/em\u003e.\u003c/li\u003e\u003cli id=\"b6e2\"\u003eIt checks the list of all method calls that were made on the mocked object (which it records automatically during the test).\u003c/li\u003e\u003cli id=\"db13\"\u003eIt then matches them against what you asked to verify.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7538\"\u003eIf the call happened, verification passes. Otherwise, it throws an error of `NoSuchInvocationFound`.\u003c/p\u003e\u003cp id=\"f27a\"\u003eOverall, it can be imagined as:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"9f00\"\u003eSome special types:\u003c/h2\u003e\u003col\u003e\u003cli id=\"1fed\"\u003eStatic methods: They can be mocked directly by using \u003ccode\u003eSomeClass.someStatic()\u003c/code\u003e as this SomeClass is not a mock class and ByteBuddy doesn’t know how to manipulate this. So, we need to first tell it that!\u003cbr/\u003e- Use \u003ccode\u003emockkStatic(SomeJavaClass::class)\u003c/code\u003e to intercept static methods.\u003c/li\u003e\u003cli id=\"7bff\"\u003eTop-level functions: Kotlin top-level functions are compiled into static methods in a hidden class named after the file (e.g., \u003ccode\u003eMyFileKt\u003c/code\u003e), so the same stuff applies here.\u003cbr/\u003e- Use\u003ccode\u003emockkStatic(\u0026#34;com.example.MyFileKt\u0026#34;)\u003c/code\u003e to intercept and replace these static methods at runtime.\u003c/li\u003e\u003cli id=\"4f3f\"\u003eObject class functions: Similar stuff here, but these objects are singletons, so a slight change to respect behavior. \u003cbr/\u003e- Use\u003ccode\u003emockkObject(MyObject)\u003c/code\u003e to intercept method calls.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f72c\"\u003eWe specifically mocked these classes, so make sure to unmock them after you are done using them to avoid unexpected test case failures in other tests.\u003c/p\u003e\u003ch2 id=\"e0fa\"\u003eConclusion:\u003c/h2\u003e\u003cp id=\"f45d\"\u003eThese APIs can change in the future, but the core idea of mocking will remain the same and is similar to other mocking libraries like Mockito, which also uses ByteBuddy and Objenesis for under-the-hood stuff. Understanding these internal mechanisms can give you a deeper appreciation for how mocking libraries work and help you write more effective and reliable tests. So, the next time you use MockK, remember this article(and me), and the powerful libraries working behind the scenes to make your testcases pass!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-05-18T20:27:13.165Z",
  "modifiedTime": null
}
