{
  "id": "1cdae629-fe04-40be-b088-ea05366a507b",
  "title": "Build your components the right way with Jetpack Compose",
  "link": "https://proandroiddev.com/build-your-components-the-right-way-with-jetpack-compose-f3a2c96b7616?source=rss----c72404660798---4",
  "description": "",
  "author": "Rasul Aghakishiyev",
  "published": "Fri, 08 Nov 2024 17:48:50 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android-app-development",
    "jetpack-compose",
    "android",
    "kotlin"
  ],
  "byline": "Rasul Aghakishiyev",
  "length": 3890,
  "excerpt": "Jetpack Compose is Google’s modern toolkit for building native Android UI. Designed to simplify and accelerate UI development, it uses a declarative approach, allowing developers to directly define…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Jetpack Compose is Google’s modern toolkit for building native Android UI. Designed to simplify and accelerate UI development, it uses a declarative approach, allowing developers to directly define how the UI should look and respond to data changes. Unlike traditional XML-based layouts, Jetpack Compose lets you write UI code in Kotlin, which leads to more concise, readable, and maintainable code.One of the standout features of Jetpack Compose is its composable functions, reusable components that manage their own state, handle UI logic, and can be combined to create complex layouts.When building components, think about where and how they might be reused. Create generic composables (like buttons, cards, and text fields) that aren’t tied to specific screen logic. Make them adaptable by allowing customizable parameters, such as colors, shapes, or actions, so they can serve multiple purposes across your app.Here are some examples of bad composables.data class Person( val id: String, val name: String, val surname: String, val age: Int, val createdAt: Long, val email: String, val phone: String, val photo: String, val likesCount: Int)@Composablefun PersonLikeCountCell(person: Person) { Row { Text(text = person.name) Icon(imageVector = Icons.Default.Star, contentDescription = null) Text(text = \"${person.likesCount} likes\") }}Why is this composable function bad? Because we are passing the Person object here, while we need name and likesCountof Person. This makes our composables less reusable. So if we will have another model and we want to use this function, we will not be able to do that. Let’s rewrite our function to make it more reusable@Composablefun PersonLikeCountCell(name: String, likesCount: Int) { Row { Text(text = name) Icon(imageVector = Icons.Default.Star, contentDescription = null) Text(text = \"$likesCount likes\") }}Now our function takes two parameters: name and likesCount. This means that we can reuse it anywhere just passing these two parameters. Our function became independent,You should remember that your composables shouldn’t rely on data models everywhere where this possible. This will also prevent component from unnecessary recompositions.Another thing that many engineers do wrong, is putting state in wrong place. Here is an example@Composablefun UserDetailsPage() { var bgColor by remember { mutableStateOf(Color.Red) } Column( modifier = Modifier.background(bgColor) ) { Button(onClick = { bgColor = Color.Blue }) { Text(text = \"Change color\") } }}What is wrong with this composable?The main issue here is that when we change the color system will start the composition and layout phases for our Column . So if you want only change the color of component instead of backround modifier we should use drawBehind modifier.@Composablefun UserDetailsPage() { var bgColor by remember { mutableStateOf(Color.Red) } Column( modifier = Modifier.drawBehind { drawRect(bgColor) } ) { Button(onClick = { bgColor = if (bgColor == Color.Red) Color.Blue else Color.Red }) { Text(text = \"Change color\") } }}Now our system will skip the composition and layout phases, and will go straight to the draw phase.ConclusionIn summary, following best practices in Jetpack Compose helps create efficient, responsive, and maintainable Android apps. By managing state wisely, structuring composables effectively, and optimizing performance, developers can deliver a seamless user experience.Feel free to follow me on Twitter and don’t hesitate to ask questions related to Jetpack Compose.Twitter: https://twitter.com/a_rasul98Also check out my other posts related to Jetpack Compose:Thanks for reading and see you later!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*ZcecKxtthrK1OdFOCWgyVw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://agarasul.medium.com/?source=post_page---byline--f3a2c96b7616--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Rasul Aghakishiyev\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*H1bReYgOd3-fhGeXfkfWSw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--f3a2c96b7616--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"2c14\"\u003eJetpack Compose is Google’s modern toolkit for building native Android UI. Designed to simplify and accelerate UI development, it uses a declarative approach, allowing developers to directly define how the UI should look and respond to data changes. Unlike traditional XML-based layouts, Jetpack Compose lets you write UI code in Kotlin, which leads to more concise, readable, and maintainable code.\u003c/p\u003e\u003cp id=\"97d2\"\u003eOne of the standout features of Jetpack Compose is its composable functions, reusable components that manage their own state, handle UI logic, and can be combined to create complex layouts.\u003c/p\u003e\u003cp id=\"8dc8\"\u003eWhen building components, think about where and how they might be reused. Create generic composables (like buttons, cards, and text fields) that aren’t tied to specific screen logic. Make them adaptable by allowing customizable parameters, such as colors, shapes, or actions, so they can serve multiple purposes across your app.\u003c/p\u003e\u003cp id=\"9545\"\u003eHere are some examples of \u003cstrong\u003ebad\u003c/strong\u003e composables.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8c31\"\u003edata class Person(\u003cbr/\u003e    val id: String,\u003cbr/\u003e    val name: String,\u003cbr/\u003e    val surname: String,\u003cbr/\u003e    val age: Int,\u003cbr/\u003e    val createdAt: Long,\u003cbr/\u003e    val email: String,\u003cbr/\u003e    val phone: String,\u003cbr/\u003e    val photo: String,\u003cbr/\u003e    val likesCount: Int\u003cbr/\u003e)\u003cp\u003e@Composable\u003cbr/\u003efun PersonLikeCountCell(person: Person) {\u003cbr/\u003e    Row {\u003cbr/\u003e        Text(text = person.name)\u003cbr/\u003e        Icon(imageVector = Icons.Default.Star, contentDescription = null)\u003cbr/\u003e        Text(text = \u0026#34;${person.likesCount} likes\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d2d\"\u003eWhy is this composable function bad? Because we are passing the \u003ccode\u003ePerson\u003c/code\u003e object here, while we need \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003elikesCount\u003c/code\u003eof Person. This makes our composables less reusable. So if we will have another model and we want to use this function, we will not be able to do that. Let’s rewrite our function to make it more reusable\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dace\"\u003e@Composable\u003cbr/\u003efun PersonLikeCountCell(name: String, likesCount: Int) {\u003cbr/\u003e    Row {\u003cbr/\u003e        Text(text = name)\u003cbr/\u003e        Icon(imageVector = Icons.Default.Star, contentDescription = null)\u003cbr/\u003e        Text(text = \u0026#34;$likesCount likes\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"065a\"\u003eNow our function takes two parameters: \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003elikesCount\u003c/code\u003e. This means that we can reuse it anywhere just passing these two parameters. Our function became independent,\u003c/p\u003e\u003cp id=\"cada\"\u003eYou should remember that your composables shouldn’t rely on data models everywhere where this possible. This will also prevent component from unnecessary recompositions.\u003c/p\u003e\u003cp id=\"00e4\"\u003eAnother thing that many engineers do wrong, is putting state in wrong place. Here is an example\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8a0d\"\u003e@Composable\u003cbr/\u003efun UserDetailsPage() {\u003cbr/\u003e    var bgColor by remember {\u003cbr/\u003e        mutableStateOf(Color.Red)\u003cbr/\u003e    }\u003cbr/\u003e    Column(\u003cbr/\u003e        modifier = Modifier.background(bgColor)\u003cbr/\u003e    ) {\u003cbr/\u003e        Button(onClick = {\u003cbr/\u003e            bgColor = Color.Blue\u003cbr/\u003e        }) {\u003cbr/\u003e            Text(text = \u0026#34;Change color\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5231\"\u003eWhat is wrong with this composable?\u003c/p\u003e\u003cp id=\"cb50\"\u003eThe main issue here is that when we change the color system will start the composition and layout phases for our \u003ccode\u003eColumn\u003c/code\u003e . So if you want only change the color of component instead of backround modifier we should use \u003ccode\u003edrawBehind\u003c/code\u003e modifier.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"12e9\"\u003e@Composable\u003cbr/\u003efun UserDetailsPage() {\u003cbr/\u003e    var bgColor by remember {\u003cbr/\u003e        mutableStateOf(Color.Red)\u003cbr/\u003e    }\u003cbr/\u003e    Column(\u003cbr/\u003e        modifier = Modifier.drawBehind { \u003cbr/\u003e            drawRect(bgColor)\u003cbr/\u003e        }\u003cbr/\u003e    ) {\u003cbr/\u003e        Button(onClick = {\u003cbr/\u003e            bgColor = if (bgColor == Color.Red) Color.Blue else Color.Red\u003cbr/\u003e        }) {\u003cbr/\u003e            Text(text = \u0026#34;Change color\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6a9d\"\u003eNow our system will skip the composition and layout phases, and will go straight to the draw phase.\u003c/p\u003e\u003ch2 id=\"abda\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"36c4\"\u003eIn summary, following best practices in Jetpack Compose helps create efficient, responsive, and maintainable Android apps. By managing state wisely, structuring composables effectively, and optimizing performance, developers can deliver a seamless user experience.\u003c/p\u003e\u003cp id=\"934a\"\u003eFeel free to follow me on Twitter and don’t hesitate to ask questions related to Jetpack Compose.\u003c/p\u003e\u003cp id=\"3a26\"\u003eTwitter: \u003ca href=\"https://twitter.com/a_rasul98\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://twitter.com/a_rasul98\u003c/a\u003e\u003c/p\u003e\u003cp id=\"90ed\"\u003eAlso check out my other posts related to Jetpack Compose:\u003c/p\u003e\u003cp id=\"7217\"\u003eThanks for reading and see you later!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-11-08T17:48:50.128Z",
  "modifiedTime": null
}
