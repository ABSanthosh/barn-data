{
  "id": "88384e3d-6173-443f-a9f8-34aee011f2ee",
  "title": "Floating in Space — Animations with Compose and Canvas",
  "link": "https://proandroiddev.com/floating-in-space-animations-with-compose-and-canvas-7e2978629cd7?source=rss----c72404660798---4",
  "description": "",
  "author": "Eevis Panula",
  "published": "Tue, 08 Oct 2024 15:41:58 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "canvas",
    "space",
    "android",
    "android-app-development",
    "jetpack-compose"
  ],
  "byline": "Eevis Panula",
  "length": 6008,
  "excerpt": "In my previous blog post, Paint the Stars — Drawing with Compose and Canvas, I shared how I wanted to be better with Canvas and Compose and created an illustration with planets and stars. This blog…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In my previous blog post, Paint the Stars — Drawing with Compose and Canvas, I shared how I wanted to be better with Canvas and Compose and created an illustration with planets and stars. This blog post shares how to animate those elements. In the end, the result will look like this:Full code is available in this snippet.AnimationsStarsLet’s start with the stars. In the previous blog post, we defined the Star data class like this:data class Star( val size: Float, val topLeft: Offset, val color: Color,)From these values, we want to animate the size of the stars. We’ll do it by defining a multiplier that we will use with the star sizes to create the effect of the stars twinkling. We do this with infiniteTransition and animateFloat:val infiniteTransition = rememberInfiniteTransition(label = \"infinite\")val starSizeMultiplierOne by infiniteTransition .animateFloat( initialValue = 1f, targetValue = 1.5f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 3000, easing = animationEasing, ), repeatMode = RepeatMode.Reverse, ), label = \"starSizeMultiplierOne\", )For the starSizeMultiplierOne, we give the initial value of 1, meaning that as it will act as a multiplier, the size would be 1 * size. The target value is 1.5, and as the repeat mode is Reverse, the float will animate between the size multiplied by 1 and 1.5. This transition creates a growing and shrinking effect.As we want the stars to look realistic and not animate at the same speed, we need to define two animated multipliers. Let’s define another one:val starSizeMultiplierTwo by infiniteTransition .animateFloat( initialValue = 0.7f, targetValue = 1.7f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 2300, easing = animationEasing, ), repeatMode = RepeatMode.Reverse, ), label = \"starSizeMultiplierTwo\", )This one has a bit shorter animation duration, and the initial and target values are different, so the twinkling happens at a different rate from the first multiplier.Now we’ll just need to pass these multipliers to stars:val stars = starsList.mapIndexed { index, star -\u003e val multiplier = if (index % 2 == 0) starSizeMultiplierOne else starSizeMultiplierTwo star.copy( size = star.size * multiplier, ) }We map through the list of stars defined previously, return copies of the star with the multiplier attached, and store them in a new list. Later, when drawing the stars, we use this new list.In the case of the code snippet, this mapping through the list might feel redundant — why just not put the multipliers in when defining the stars? Well, in this case, it would work. But if we defined the stars outside the component, animated values can be hard to attach, so this would be the strategy.PlanetThe next thing we want to animate is the planet — or the moon orbiting around it, to be exact.In the previous post, we defined how to draw the planet and the moon, and the source code showed an extension function called drawMoon. Let's extend it and pass in a parameter called degrees:fun DrawScope.drawMoon( center: Offset, outlineStyle: Stroke, degrees: Float,) {...}Then we wrap the contents of drawMoon with a rotate, which uses the degrees for rotation and center for pivot so that the rotation happens around the center of the planet:rotate(degrees = degrees, pivot = center) {...}In the top-level component, we define the degrees, which is an animated float value:val degrees by infiniteTransition .animateFloat( initialValue = 360f, targetValue = 0f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 3000 * 6, easing = LinearEasing, ), ), label = \"degrees\", )For the initial value, we use 360f, and as the target value, 0f. These values create the effect that the moon orbits counter-clockwise around the planet.SaturnThe last item we animate is Saturn. Its movement is subtle — slightly moving up and down to create a floating effect.In the previous blog post, we defined an extension function, drawSaturn, that takes in top-left coordinates and outline style. We can use the top-left coordinates for the effect.First, let’s define center offset, an animated float value we’re going to use:val centerOffset by infiniteTransition .animateFloat( initialValue = 0f, targetValue = 2f, animationSpec = infiniteRepeatable( animation = tween( durationMillis = 3000, easing = EaseIn, ), repeatMode = RepeatMode.Reverse, ), label = \"centerOffset\", )As you can see, the initial value is 0f, and the target value is 2f. We can then use this and change the parameters we pass to drawSaturn by adding the centerOffset to the top-left coordinates:drawSaturn( center = Offset( size.width * 0.25f + centerOffset, size.height * 0.25f + centerOffset ), outlineStyle = outlineStyle,)This way, the x and y coordinates have an extra amount of animating from 0f to 2f, creating the floating effect.Wrapping UpIn this blog post, we’ve covered animating drawings on Canvas. All the animations used animated floats in different ways. And as we can see, small changes add a lot of movement to the Canvas.I hope you’ve enjoyed this blog post and learned something!Links in the Blog PostPaint the Stars — Drawing with Compose and CanvasFull code is available in this snippet",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Fu-haBheuLWMsukdcTc6Iw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@eevajonna?source=post_page-----7e2978629cd7--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Eevis Panula\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*NhMD_9eOS1kF9_b3VomDEQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----7e2978629cd7--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b819\"\u003eIn my previous blog post, \u003ca href=\"https://medium.com/proandroiddev/paint-the-stars-drawing-with-compose-and-canvas-6a4e719efe20\" rel=\"noopener\"\u003ePaint the Stars — Drawing with Compose and Canvas\u003c/a\u003e, I shared how I wanted to be better with Canvas and Compose and created an illustration with planets and stars. This blog post shares how to animate those elements. In the end, the result will look like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"77f3\"\u003e\u003ca href=\"https://gist.github.com/eevajonnapanula/5e75e960605de7504fb5ed9f5b96b3b9\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFull code is available in this snippet\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"4208\"\u003eAnimations\u003c/h2\u003e\u003ch2 id=\"eab3\"\u003eStars\u003c/h2\u003e\u003cp id=\"bbab\"\u003eLet’s start with the stars. In the previous blog post, we defined the \u003ccode\u003eStar\u003c/code\u003e data class like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"21bc\"\u003edata class Star(\u003cbr/\u003e    val size: Float,\u003cbr/\u003e    val topLeft: Offset,\u003cbr/\u003e    val color: Color,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6a8a\"\u003eFrom these values, we want to animate the size of the stars. We’ll do it by defining a multiplier that we will use with the star sizes to create the effect of the stars twinkling. We do this with \u003ccode\u003einfiniteTransition\u003c/code\u003e and \u003ccode\u003eanimateFloat\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3747\"\u003eval infiniteTransition = \u003cbr/\u003e    rememberInfiniteTransition(label = \u0026#34;infinite\u0026#34;)\u003cp\u003eval starSizeMultiplierOne by infiniteTransition\u003cbr/\u003e    .animateFloat(\u003cbr/\u003e        initialValue = 1f,\u003cbr/\u003e        targetValue = 1.5f,\u003cbr/\u003e        animationSpec =\u003cbr/\u003e            infiniteRepeatable(\u003cbr/\u003e                animation =\u003cbr/\u003e                    tween(\u003cbr/\u003e                        durationMillis = 3000,\u003cbr/\u003e                        easing = animationEasing,\u003cbr/\u003e                    ),\u003cbr/\u003e                repeatMode = RepeatMode.Reverse,\u003cbr/\u003e            ),\u003cbr/\u003e        label = \u0026#34;starSizeMultiplierOne\u0026#34;,\u003cbr/\u003e    )\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2ff9\"\u003eFor the \u003ccode\u003estarSizeMultiplierOne\u003c/code\u003e, we give the initial value of 1, meaning that as it will act as a multiplier, the size would be 1 * size. The target value is 1.5, and as the repeat mode is \u003ccode\u003eReverse\u003c/code\u003e, the float will animate between the size multiplied by 1 and 1.5. This transition creates a growing and shrinking effect.\u003c/p\u003e\u003cp id=\"a3b9\"\u003eAs we want the stars to look realistic and not animate at the same speed, we need to define two animated multipliers. Let’s define another one:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c5aa\"\u003eval starSizeMultiplierTwo by infiniteTransition\u003cbr/\u003e    .animateFloat(\u003cbr/\u003e        initialValue = 0.7f,\u003cbr/\u003e        targetValue = 1.7f,\u003cbr/\u003e        animationSpec =\u003cbr/\u003e            infiniteRepeatable(\u003cbr/\u003e                animation =\u003cbr/\u003e                    tween(\u003cbr/\u003e                        durationMillis = 2300,\u003cbr/\u003e                        easing = animationEasing,\u003cbr/\u003e                    ),\u003cbr/\u003e                repeatMode = RepeatMode.Reverse,\u003cbr/\u003e            ),\u003cbr/\u003e        label = \u0026#34;starSizeMultiplierTwo\u0026#34;,\u003cbr/\u003e    )\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7274\"\u003eThis one has a bit shorter animation duration, and the initial and target values are different, so the twinkling happens at a different rate from the first multiplier.\u003c/p\u003e\u003cp id=\"3a04\"\u003eNow we’ll just need to pass these multipliers to stars:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5fd8\"\u003eval stars =\u003cbr/\u003e    starsList.mapIndexed { index, star -\u0026gt;\u003cbr/\u003e        val multiplier = if (index % 2 == 0) \u003cbr/\u003e            starSizeMultiplierOne \u003cbr/\u003e        else \u003cbr/\u003e            starSizeMultiplierTwo\u003cp\u003e        star.copy(\u003cbr/\u003e            size = star.size * multiplier,\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"18bf\"\u003eWe map through the list of stars defined previously, return copies of the star with the multiplier attached, and store them in a new list. Later, when drawing the stars, we use this new list.\u003c/p\u003e\u003cp id=\"f0ec\"\u003eIn the case of the code snippet, this mapping through the list might feel redundant — why just not put the multipliers in when defining the stars? Well, in this case, it would work. But if we defined the stars outside the component, animated values can be hard to attach, so this would be the strategy.\u003c/p\u003e\u003ch2 id=\"3946\"\u003ePlanet\u003c/h2\u003e\u003cp id=\"edbb\"\u003eThe next thing we want to animate is the planet — or the moon orbiting around it, to be exact.\u003c/p\u003e\u003cp id=\"4ccc\"\u003eIn the previous post, we defined how to draw the planet and the moon, and the source code showed an extension function called \u003ccode\u003edrawMoon\u003c/code\u003e. Let\u0026#39;s extend it and pass in a parameter called \u003ccode\u003edegrees\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d3c7\"\u003efun DrawScope.drawMoon(\u003cbr/\u003e    center: Offset,\u003cbr/\u003e    outlineStyle: Stroke,\u003cbr/\u003e    degrees: Float,\u003cbr/\u003e) {\u003cbr/\u003e...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1580\"\u003eThen we wrap the contents of \u003ccode\u003edrawMoon\u003c/code\u003e with a \u003ccode\u003erotate\u003c/code\u003e, which uses the \u003ccode\u003edegrees\u003c/code\u003e for rotation and \u003ccode\u003ecenter\u003c/code\u003e for pivot so that the rotation happens around the center of the planet:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb95\"\u003erotate(degrees = degrees, pivot = center) {\u003cbr/\u003e...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"45ff\"\u003eIn the top-level component, we define the degrees, which is an animated float value:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ce8c\"\u003eval degrees by infiniteTransition\u003cbr/\u003e    .animateFloat(\u003cbr/\u003e        initialValue = 360f,\u003cbr/\u003e        targetValue = 0f,\u003cbr/\u003e        animationSpec =\u003cbr/\u003e            infiniteRepeatable(\u003cbr/\u003e                animation =\u003cbr/\u003e                    tween(\u003cbr/\u003e                        durationMillis = 3000 * 6,\u003cbr/\u003e                        easing = LinearEasing,\u003cbr/\u003e                    ),\u003cbr/\u003e            ),\u003cbr/\u003e        label = \u0026#34;degrees\u0026#34;,\u003cbr/\u003e    )\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cfa4\"\u003eFor the initial value, we use 360f, and as the target value, 0f. These values create the effect that the moon orbits counter-clockwise around the planet.\u003c/p\u003e\u003ch2 id=\"cf77\"\u003eSaturn\u003c/h2\u003e\u003cp id=\"d4d6\"\u003eThe last item we animate is Saturn. Its movement is subtle — slightly moving up and down to create a floating effect.\u003c/p\u003e\u003cp id=\"c5de\"\u003eIn the previous blog post, we defined an extension function, \u003ccode\u003edrawSaturn\u003c/code\u003e, that takes in top-left coordinates and outline style. We can use the top-left coordinates for the effect.\u003c/p\u003e\u003cp id=\"5aef\"\u003eFirst, let’s define center offset, an animated float value we’re going to use:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2395\"\u003eval centerOffset by infiniteTransition\u003cbr/\u003e    .animateFloat(\u003cbr/\u003e        initialValue = 0f,\u003cbr/\u003e        targetValue = 2f,\u003cbr/\u003e        animationSpec =\u003cbr/\u003e            infiniteRepeatable(\u003cbr/\u003e                animation =\u003cbr/\u003e                    tween(\u003cbr/\u003e                        durationMillis = 3000,\u003cbr/\u003e                        easing = EaseIn,\u003cbr/\u003e                    ),\u003cbr/\u003e                repeatMode = RepeatMode.Reverse,\u003cbr/\u003e            ),\u003cbr/\u003e        label = \u0026#34;centerOffset\u0026#34;,\u003cbr/\u003e    )\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8b48\"\u003eAs you can see, the initial value is 0f, and the target value is 2f. We can then use this and change the parameters we pass to \u003ccode\u003edrawSaturn\u003c/code\u003e by adding the \u003ccode\u003ecenterOffset\u003c/code\u003e to the top-left coordinates:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9e0f\"\u003edrawSaturn(\u003cbr/\u003e    center =\u003cbr/\u003e        Offset(\u003cbr/\u003e            size.width * 0.25f + centerOffset,\u003cbr/\u003e            size.height * 0.25f + centerOffset\u003cbr/\u003e        ),\u003cbr/\u003e    outlineStyle = outlineStyle,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ddf\"\u003eThis way, the x and y coordinates have an extra amount of animating from 0f to 2f, creating the floating effect.\u003c/p\u003e\u003ch2 id=\"f377\"\u003eWrapping Up\u003c/h2\u003e\u003cp id=\"efaf\"\u003eIn this blog post, we’ve covered animating drawings on Canvas. All the animations used animated floats in different ways. And as we can see, small changes add a lot of movement to the Canvas.\u003c/p\u003e\u003cp id=\"c9d8\"\u003eI hope you’ve enjoyed this blog post and learned something!\u003c/p\u003e\u003ch2 id=\"3c37\"\u003eLinks in the Blog Post\u003c/h2\u003e\u003cul\u003e\u003cli id=\"2166\"\u003e\u003ca href=\"https://medium.com/proandroiddev/paint-the-stars-drawing-with-compose-and-canvas-6a4e719efe20\" rel=\"noopener\"\u003ePaint the Stars — Drawing with Compose and Canvas\u003c/a\u003e\u003c/li\u003e\u003cli id=\"18b6\"\u003e\u003ca href=\"https://gist.github.com/eevajonnapanula/5e75e960605de7504fb5ed9f5b96b3b9\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFull code is available in this snippet\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-10-06T11:11:49.005Z",
  "modifiedTime": null
}
