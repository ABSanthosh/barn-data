{
  "id": "4e33342e-6456-4deb-b7c1-d1f9a3b841fd",
  "title": "Frankencode: Bringing an old Android library back to life with Kotlin",
  "link": "https://chrynan.codes/converting-an-old-java-library-to-kotlin/",
  "description": "Converting a Java Android library to Kotlin.",
  "author": "Christopher Keenan",
  "published": "Sun, 19 Jan 2020 20:02:32 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "android",
    "kotlin",
    "kotlin-library",
    "library",
    "view",
    "widget",
    "ui",
    "guitar",
    "chords",
    "chord",
    "chart",
    "diagram"
  ],
  "byline": "Christopher Keenan",
  "length": 8645,
  "excerpt": "Converting a Java Android library to Kotlin.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Converting a Java Android library to Kotlin. Jan 19, 2020 • 5 min read Look! It's moving. It's alive. It's alive... It's alive, it's moving,  it's alive, it's alive, it's alive, it's alive, IT'S ALIVE!A few years ago, I created an Android library, written in Java, to display Guitar Chord Diagrams natively. Recently, I revisited the library and converted it to Kotlin, fixing some lingering issues and updating the API in the process. The end result is chords, an easily customizable and simple to use native Android View for displaying fretted stringed instrument chord diagrams. In this article, I provide some insights into the Java to Kotlin conversion process for the library.TL;DRKotlin provided conciseness and flexibility to an old Java Android library. Checkout the code here.The processUpdating the library ended up requiring a significant overhaul in the code structure and API. There were some lingering issues in the old code and separation of concerns wasn't followed. On top of that, there was too much of an attempt to be \"smart\" and handle incorrect input values by coercing them to work. All of these things contributed to making the code hard to read and follow. These issues had to be fixed in the new implementation.The first thing that needed to be done was to setup the build files correctly. It seems when I first created this library, I didn't upload the all the Gradle files. Adding these was simple enough. I also knew that I would create a Kotlin multi-platform module that would handle the common code so that this library could be implemented for different environments, other than Android.Next, was to convert all the Java classes to Kotlin. IntelliJ has a helpful tool for this: In the top menu of IntelliJ, choose code \u003e Convert Java File to Kotlin File. The code will now be in Kotlin, but sometimes you still have to go through and make some corrections and better structure the code for readability.Then, removing the unnecessary code. The original library attempted to handle work that seemingly ventured out of the scope of the project. Also, there was redundancy in the API. For instance, the GuitarChordView had constants that just delegated to other constants for convenience. So, any redundant or out of scope code was removed.After that came updating the API. This is where Kotlin played an important role. For instance, the model for this library is fairly complex. There's a model for the chart, a view model for how the chart is displayed, and a model for the chord. The chord model can contain any number of unique markers. These markers, however, were each different and didn't share much in common with the other markers. But there was a finite set of marker options. This was a perfect use case for Kotlin's sealed classes.Finally, the view implementation had to be updated. The original library had some lingering issues that had to be addressed. And there was performance problems that had to be optimized as well. For instance, the original library performed a lot of the layout calculations from within the onDraw function. These calculations were moved into the onMeasure function and only drawing was performed in the onDraw function.The resultThe new API for the library is simple to use and easy to understand. It still maintains the customizability of the original and even adds some extra options. Overall, I'm satisfied with the end result. The following are the highlights of updating the library to use Kotlin:The library is more concise. For example, after converting the GuitarChordView from Java to Kotlin and removing some of the unnecessary code, the line count dropped from 1,812 to 422. Some lines were added to this class, now called ChordWidget, but it still only has 547 lines, far fewer than the original.Converted GuitarChordView to Kotlin and Refactored the class · chRyNaN/chords@d33526bAn Android view library for displaying stringed instrument chord diagrams - chRyNaN/chordsGitHubchRyNaNThe library is more flexible. There's a core module which is a Kotlin multi-platform module that contains all the models, views, and parsing code. This means that other environments, such as, client-side Javascript or iOS, could be supported in the future.Use of Kotlin's sealed classes. As stated before, the Chord class contains markers that represent the different components of a chord to be displayed. These markers are defined by the ChordMarker sealed class. This allows for a definite set of types which can be handled conditionally in an exhaustive manner. Which in turn, provides a better API to the user of the library, exposing only what is needed.Use of Kotlin's inline classes. Some of the ChordMarker classes contain multiple properties of the same type. To prevent any accidental errors from messing up the constructor parameter order, inline classes are used.// Instead of this data class Note( override val fret: Int, override val string: Int, ... ) // Inline classes are used to prevent mistakes data class Note( override val fret: FretNumber, override val string: StringNumber, ... ) Use of Kotlin's suspend functions. The ChordParser interface takes in an input and outputs a ChordParseResult containing a Chord. Different implementations of this interface can be created to handle different formats. Most of the time these parsing actions will take some time to perform and should be handled off the UI Thread. Leveraging Kotlin's support for Coroutines, the parse function is a suspending function. This will assert that it is called appropriately, from within another suspending function or within a Coroutine. There's no dependency on the Kotlin Coroutine library, since the suspend modifier is built-in to the language.Use of Kotlin extension functions. Extension functions play an important role in providing convenience utilities on existing Android component objects, and adding properties and functions to models without polluting the model class itself. Examples of these can be seen in the ChordUtils in the core module and the ParcelableUtils in the library module.Using the libraryThe README file contains a more detailed description on using the library. The basic idea is to define the ChordWidget in your XML layout. And then assign a Chord to the ChordWidget.Defining ChordWidget in an XML layout:\u003c!-- Specify an exact size (MATCH_PARENT, MATCH_CONSTRAINTS, DP value). --\u003e \u003ccom.chrynan.chords.widget.ChordWidget android:id=\"@+id/chordWidget\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /\u003e Assigning a Chord to the ChordWidget:chordWidget?.chord = chord(\"G\") { +ChordMarker.Note( fret = FretNumber(3), finger = Finger.MIDDLE, string = StringNumber(6) ) +ChordMarker.Note( fret = FretNumber(2), finger = Finger.INDEX, string = StringNumber(5) ) +ChordMarker.Open(string = StringNumber(4)) +ChordMarker.Open(string = StringNumber(3)) +ChordMarker.Note( fret = FretNumber(3), finger = Finger.RING, string = StringNumber(2) ) +ChordMarker.Note( fret = FretNumber(3), finger = Finger.PINKY, string = StringNumber(1) ) } Sample using the libraryThere is a sample module in the library which contains a simple Android application showcasing the use of the library. The following is a screenshot of the sample app:Sample app using the chords libraryConclusionWith the help of the Kotlin programming language, I was able to instill life into an old Java Android library. It was an interesting experience and was enlightening to see how much I have progressed in my development capability in just a few short years. Overall, I am satisfied with the result. If I find more time to work on the project, it may be worth while to see if I can get an implementation working for iOS, making the library truly multi-platform. Another option would be to create an implementation using Jetpack Compose, since that may be the future of UI development on Android.",
  "image": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/alive.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eConverting a Java Android library to Kotlin.\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \u003cdiv\u003e\n                \n                \u003cp\u003e\u003ctime datetime=\"2020-01-19\"\u003eJan 19, 2020\u003c/time\u003e\n                        \u003cspan\u003e\u003cspan\u003e•\u003c/span\u003e 5 min read\u003c/span\u003e\n                \u003c/p\u003e\n            \u003c/div\u003e\n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w300/2023/02/alive.jpeg 300w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w600/2023/02/alive.jpeg 600w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w1000/2023/02/alive.jpeg 1000w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/alive.jpeg 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/alive.jpeg\" alt=\"Frankencode: Bringing an old Android library back to life with Kotlin\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cblockquote\u003eLook! It\u0026#39;s moving. It\u0026#39;s alive. It\u0026#39;s alive... It\u0026#39;s alive, it\u0026#39;s moving,  it\u0026#39;s alive, it\u0026#39;s alive, it\u0026#39;s alive, it\u0026#39;s alive, IT\u0026#39;S ALIVE!\u003c/blockquote\u003e\u003cp\u003eA few years ago, I created an Android library, written in Java, to display \u003ca href=\"https://en.wikipedia.org/wiki/Guitar_chord?ref=chrynan.codes\"\u003eGuitar Chord\u003c/a\u003e Diagrams natively. Recently, I revisited the library and converted it to Kotlin, fixing some lingering issues and updating the API in the process. The end result is \u003ca href=\"https://github.com/chRyNaN/chords?ref=chrynan.codes\"\u003echords\u003c/a\u003e, an easily customizable and simple to use native Android View for displaying fretted stringed instrument chord diagrams. In this article, I provide some insights into the Java to Kotlin conversion process for the library.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eKotlin provided conciseness and flexibility to an old Java Android library. Checkout the code \u003ca href=\"https://github.com/chRyNaN/chords?ref=chrynan.codes\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"the-process\"\u003eThe process\u003c/h3\u003e\u003cp\u003eUpdating the library ended up requiring a significant overhaul in the code structure and API. There were some lingering issues in the old code and separation of concerns wasn\u0026#39;t followed. On top of that, there was too much of an attempt to be \u0026#34;smart\u0026#34; and handle incorrect input values by coercing them to work. All of these things contributed to making the code hard to read and follow. These issues had to be fixed in the new implementation.\u003c/p\u003e\u003cp\u003eThe first thing that needed to be done was to setup the build files correctly. It seems when I first created this library, I didn\u0026#39;t upload the all the Gradle files. Adding these was simple enough. I also knew that I would create a Kotlin multi-platform module that would handle the common code so that this library could be implemented for different environments, other than Android.\u003c/p\u003e\u003cp\u003eNext, was to convert all the Java classes to Kotlin. IntelliJ has a helpful tool for this: In the top menu of IntelliJ, choose \u003ccode\u003ecode \u0026gt; Convert Java File to Kotlin File\u003c/code\u003e. The code will now be in Kotlin, but sometimes you still have to go through and make some corrections and better structure the code for readability.\u003c/p\u003e\u003cp\u003eThen, removing the unnecessary code. The original library attempted to handle work that seemingly ventured out of the scope of the project. Also, there was redundancy in the API. For instance, the \u003ccode\u003eGuitarChordView\u003c/code\u003e had constants that just delegated to other constants for convenience. So, any redundant or out of scope code was removed.\u003c/p\u003e\u003cp\u003eAfter that came updating the API. This is where Kotlin played an important role. For instance, the model for this library is fairly complex. There\u0026#39;s a model for the chart, a view model for how the chart is displayed, and a model for the chord. The chord model can contain any number of unique markers. These markers, however, were each different and didn\u0026#39;t share much in common with the other markers. But there was a finite set of marker options. This was a perfect use case for Kotlin\u0026#39;s sealed classes.\u003c/p\u003e\u003cp\u003eFinally, the view implementation had to be updated. The original library had some lingering issues that had to be addressed. And there was performance problems that had to be optimized as well. For instance, the original library performed a lot of the layout calculations from within the \u003ccode\u003eonDraw\u003c/code\u003e function. These calculations were moved into the \u003ccode\u003eonMeasure\u003c/code\u003e function and only drawing was performed in the \u003ccode\u003eonDraw\u003c/code\u003e function.\u003c/p\u003e\u003ch3 id=\"the-result\"\u003eThe result\u003c/h3\u003e\u003cp\u003eThe new API for the library is simple to use and easy to understand. It still maintains the customizability of the original and even adds some extra options. Overall, I\u0026#39;m satisfied with the end result. The following are the highlights of updating the library to use Kotlin:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe library is more concise. For example, after converting the \u003ccode\u003eGuitarChordView\u003c/code\u003e from Java to Kotlin and removing some of the unnecessary code, the line count dropped from \u003cstrong\u003e1,812\u003c/strong\u003e to \u003cstrong\u003e422\u003c/strong\u003e. Some lines were added to this class, now called \u003ccode\u003eChordWidget\u003c/code\u003e, but it still only has \u003cstrong\u003e547\u003c/strong\u003e lines, far fewer than the original.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003ca href=\"https://github.com/chRyNaN/chords/commit/d33526b0c1f154d42584be29e0087de804b6193f?ref=chrynan.codes\"\u003e\u003cdiv\u003e\u003cp\u003eConverted GuitarChordView to Kotlin and Refactored the class · chRyNaN/chords@d33526b\u003c/p\u003e\u003cp\u003eAn Android view library for displaying stringed instrument chord diagrams - chRyNaN/chords\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://github.githubassets.com/favicon.ico\" alt=\"\"/\u003e\u003cspan\u003eGitHub\u003c/span\u003e\u003cspan\u003echRyNaN\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://avatars2.githubusercontent.com/u/10093880?s=200\u0026amp;v=4\" alt=\"\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cul\u003e\u003cli\u003eThe library is more flexible. There\u0026#39;s a \u003ccode\u003ecore\u003c/code\u003e module which is a Kotlin multi-platform module that contains all the models, views, and parsing code. This means that other environments, such as, client-side Javascript or iOS, could be supported in the future.\u003c/li\u003e\u003cli\u003eUse of Kotlin\u0026#39;s \u003ca href=\"https://kotlinlang.org/docs/reference/sealed-classes.html?ref=chrynan.codes\"\u003esealed classes\u003c/a\u003e. As stated before, the \u003ccode\u003eChord\u003c/code\u003e class contains markers that represent the different components of a chord to be displayed. These markers are defined by the \u003ccode\u003eChordMarker\u003c/code\u003e sealed class. This allows for a definite set of types which can be handled conditionally in an exhaustive manner. Which in turn, provides a better API to the user of the library, exposing only what is needed.\u003c/li\u003e\u003cli\u003eUse of Kotlin\u0026#39;s \u003ca href=\"https://kotlinlang.org/docs/reference/inline-classes.html?ref=chrynan.codes\"\u003einline classes\u003c/a\u003e. Some of the \u003ccode\u003eChordMarker\u003c/code\u003e classes contain multiple properties of the same type. To prevent any accidental errors from messing up the constructor parameter order, inline classes are used.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// Instead of this\ndata class Note(\n            override val fret: Int,\n            override val string: Int,\n            ...\n)\n\n// Inline classes are used to prevent mistakes\ndata class Note(\n            override val fret: FretNumber,\n            override val string: StringNumber,\n            ...\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eUse of Kotlin\u0026#39;s \u003ca href=\"https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html?ref=chrynan.codes\"\u003esuspend functions\u003c/a\u003e. The \u003ccode\u003eChordParser\u003c/code\u003e interface takes in an input and outputs a \u003ccode\u003eChordParseResult\u003c/code\u003e containing a \u003ccode\u003eChord\u003c/code\u003e. Different implementations of this interface can be created to handle different formats. Most of the time these parsing actions will take some time to perform and should be handled off the UI Thread. Leveraging Kotlin\u0026#39;s support for Coroutines, the \u003ccode\u003eparse\u003c/code\u003e function is a suspending function. This will assert that it is called appropriately, from within another suspending function or within a Coroutine. There\u0026#39;s no dependency on the Kotlin Coroutine library, since the \u003ccode\u003esuspend\u003c/code\u003e modifier is built-in to the language.\u003c/li\u003e\u003cli\u003eUse of Kotlin extension functions. Extension functions play an important role in providing convenience utilities on existing Android component objects, and adding properties and functions to models without polluting the model class itself. Examples of these can be seen in the \u003ccode\u003eChordUtils\u003c/code\u003e in the \u003ccode\u003ecore\u003c/code\u003e module and the \u003ccode\u003eParcelableUtils\u003c/code\u003e in the \u003ccode\u003elibrary\u003c/code\u003e module.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"using-the-library\"\u003eUsing the library\u003c/h3\u003e\u003cp\u003eThe \u003ca href=\"https://github.com/chRyNaN/chords/blob/master/README.md?ref=chrynan.codes\"\u003eREADME file\u003c/a\u003e contains a more detailed description on using the library. The basic idea is to define the \u003ccode\u003eChordWidget\u003c/code\u003e in your XML layout. And then assign a \u003ccode\u003eChord\u003c/code\u003e to the \u003ccode\u003eChordWidget\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eDefining \u003ccode\u003eChordWidget\u003c/code\u003e in an XML layout:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;!-- Specify an exact size (MATCH_PARENT, MATCH_CONSTRAINTS, DP value). --\u0026gt;\n\u0026lt;com.chrynan.chords.widget.ChordWidget\n    android:id=\u0026#34;@+id/chordWidget\u0026#34;\n    android:layout_width=\u0026#34;match_parent\u0026#34;\n    android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAssigning a \u003ccode\u003eChord\u003c/code\u003e to the \u003ccode\u003eChordWidget\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003echordWidget?.chord = chord(\u0026#34;G\u0026#34;) {\n            +ChordMarker.Note(\n                    fret = FretNumber(3),\n                    finger = Finger.MIDDLE,\n                    string = StringNumber(6)\n            )\n            +ChordMarker.Note(\n                    fret = FretNumber(2),\n                    finger = Finger.INDEX,\n                    string = StringNumber(5)\n            )\n            +ChordMarker.Open(string = StringNumber(4))\n            +ChordMarker.Open(string = StringNumber(3))\n            +ChordMarker.Note(\n                    fret = FretNumber(3),\n                    finger = Finger.RING,\n                    string = StringNumber(2)\n            )\n            +ChordMarker.Note(\n                    fret = FretNumber(3),\n                    finger = Finger.PINKY,\n                    string = StringNumber(1)\n            )\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"sample-using-the-library\"\u003eSample using the library\u003c/h3\u003e\u003cp\u003eThere is a \u003ccode\u003esample\u003c/code\u003e module in the \u003ca href=\"https://github.com/chRyNaN/chords?ref=chrynan.codes\"\u003elibrary\u003c/a\u003e which contains a simple Android application showcasing the use of the library. The following is a screenshot of the sample app:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://chrynan.codes/content/images/2020/01/device-2020-01-18-180759-2.png\" alt=\"\" loading=\"lazy\"/\u003e\u003cfigcaption\u003eSample app using the \u003ca href=\"https://github.com/chRyNaN/chords?ref=chrynan.codes\"\u003echords\u003c/a\u003e library\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\u003cp\u003eWith the help of the Kotlin programming language, I was able to instill life into an old Java Android library. It was an interesting experience and was enlightening to see how much I have progressed in my development capability in just a few short years. Overall, I am satisfied with the \u003ca href=\"https://github.com/chRyNaN/chords?ref=chrynan.codes\"\u003eresult\u003c/a\u003e. If I find more time to work on the project, it may be worth while to see if I can get an implementation working for iOS, making the library truly multi-platform. Another option would be to create an implementation using \u003ca href=\"https://developer.android.com/jetpack/compose?ref=chrynan.codes\"\u003eJetpack Compose\u003c/a\u003e, since that may be the future of UI development on Android. \u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2020-01-19T20:02:32Z",
  "modifiedTime": "2023-02-07T15:13:18Z"
}
