{
  "id": "001346d4-3167-41db-99ea-bb61d73471a0",
  "title": "Friendly Captcha 2.0 in Jetpack Compose with Hilt: A Ready-to-Use Solution",
  "link": "https://proandroiddev.com/friendly-captcha-2-0-in-jetpack-compose-with-hilt-a-ready-to-use-solution-92c93f10b91a?source=rss----c72404660798---4",
  "description": "",
  "author": "Anatolii Frolov",
  "published": "Mon, 14 Apr 2025 14:15:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "captcha",
    "jetpack-compose",
    "androiddev",
    "android"
  ],
  "byline": "Anatolii Frolov",
  "length": 11094,
  "excerpt": "In the previous article, we implemented the first version of Friendly Captcha in a Jetpack Compose-based Android app. In this post, we’re diving into Friendly Captcha 2.0 — showing how to set it up…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In the previous article, we implemented the first version of Friendly Captcha in a Jetpack Compose-based Android app.In this post, we’re diving into Friendly Captcha 2.0 — showing how to set it up with a clean, production-ready architecture using Jetpack Compose and Hilt.What’s New in Friendly Captcha 2.0?Before we dive into the implementation, here’s a quick overview of how Friendly Captcha 2.0 improves compared to the earlier version:Integration Flow:Version 1 required a more manual setup.Version 2.0 offers smoother SDK initialization, making integration easier.Widget Experience:In Version 1, the widget sometimes introduced a slight delay.Version 2.0 renders faster and offers a more seamless user experience.API Endpoint Support:Version 1 had a fixed endpoint.Version 2.0 supports customizable endpoints like \"global\" for better flexibility.Privacy \u0026 Security:Version 1 already had a strong privacy focus.Version 2.0 improves on this with a smarter puzzle engine and the same zero-tracking approach.TL;DR: Version 2.0 is faster, more flexible, and even more secure — while staying privacy-first and developer-friendly.Step 1: Add the Friendly Captcha SDKTo get started, you need to add the Friendly Captcha 2.0 SDK to your project.If you’re using version catalogs (libs.versions.toml), you can define the dependency like this:# libs.versions.tomlfriendlyCaptchaAndroid = \"1.0.2\"friendly-captcha-android = { module = \"com.friendlycaptcha.android:friendly-captcha-android\", version.ref = \"friendlyCaptchaAndroid\"}Then include it in your app-level build.gradle.kts:implementation(libs.friendly.captcha.android)Note: Version 1.0.2 of the SDK is the current stable release that reflects the 2.0 features - naming-wise, it’s a bit confusing, but this is the right one.Step 2: Create a Captcha Provider with HiltTo avoid initializing the SDK directly in your UI or ViewModel, let’s create a simple provider class that encapsulates setup and exposes the captcha widget.@Singletonclass FriendlyCaptchaProvider @Inject constructor( @ApplicationContext private val context: Context) { private val sdk by lazy { FriendlyCaptchaSDK( context = context, apiEndpoint = \"global\" // or use \"eu\" / custom region if needed ) } internal val widget by lazy { sdk.createWidget( sitekey = context.getString(R.string.friendly_captcha_api_key) ) }}What’s happening here:@Singleton ensures only one instance exists app-wide.We’re using @Inject constructor so Hilt can provide this class automatically.sdk.createWidget() creates an instance of FriendlyCaptchaWidgetHandle, which you’ll pass to your UI.Note: Make sure your API key is stored in strings.xml:\u003cstring name=\"friendly_captcha_api_key\"\u003eYOUR_SITE_KEY_HERE\u003c/string\u003eStep 3: Inject the Captcha Widget into Your ViewModelWe’ll inject the FriendlyCaptchaProvider using Hilt, then expose the widget via a val so it can be passed into your composable screen.@HiltViewModelclass RegistrationViewModel @Inject constructor( private val authService: AuthService, private val friendlyCaptchaProvider: FriendlyCaptchaProvider) : ViewModel() { var state by mutableStateOf(RegistrationState()) private set private val _effect = Channel\u003cRegistrationEffect\u003e() val effect = _effect.receiveAsFlow() // Expose the captcha widget val friendlyCaptchaWidget by lazy { friendlyCaptchaProvider.widget } fun onAction(action: RegistrationAction) { when (action) { is RegistrationAction.NextClick -\u003e { // Extract captcha response val captchaResponse = action.data.captchaSolution // Optional: validate or show loading state state = state.copy(isLoading = true) // Simulate call to backend or your authService viewModelScope.launch { val result = authService.registerWithCaptcha(captchaResponse) state = state.copy( isLoading = false, authResult = result ) } } // Handle other actions if needed (e.g., field input, back press) else -\u003e Unit } }}Why this matters:The widget is now part of your UI state, not tightly coupled to your composable.It’s initialized lazily, so it only gets created when needed.Keeping it inside the ViewModel avoids unnecessary recompositions or view-specific issues.If you’re following an MVI or MVVM pattern, this keeps your architecture clean and testable.Step 4: Pass the Widget to Your Composable ScreenNow that your ViewModel exposes the FriendlyCaptchaWidgetHandle, you can pass it to your screen-level composable:RegistrationScreen( state = viewModel.state, onAction = viewModel::onAction, captchaWidget = viewModel.friendlyCaptchaWidget)Then update your screen function to accept the captchaWidget as a parameter:@Composablefun RegistrationScreen( state: RegistrationState, onAction: (RegistrationAction) -\u003e Unit, captchaWidget: FriendlyCaptchaWidgetHandle) { when (state.currentStep) { RegistrationStep.CAPTCHA -\u003e { CaptchaComponent( widget = captchaWidget, modifier = Modifier.padding(bottom = 40.dp), state = state, nextClickTrigger = nextClickTrigger.value, onNextButtonEnabled = { enabled -\u003e nextButtonEnabled.value = enabled }, onAction = onAction, onResetNextTrigger = { nextClickTrigger.value = false } ) } // other steps... }}What’s happening here:The widget is now fully integrated with your screen.You can control how it’s shown, when it resets, and how it feeds back to the form.The CaptchaComponent will handle the actual rendering and logic.Step 5: Create the CaptchaComponent ComposableThis component is responsible for rendering the captcha widget inside your screen, handling its events, and triggering actions like form submission when the captcha is completed.@Composablefun CaptchaComponent( widget: FriendlyCaptchaWidgetHandle, modifier: Modifier = Modifier, state: RegistrationState, nextClickTrigger: Boolean?, onResetNextTrigger: () -\u003e Unit, onNextButtonEnabled: (enabled: Boolean) -\u003e Unit, onAction: (RegistrationAction) -\u003e Unit) { val captchaResponse = remember { mutableStateOf(state.registrationData.captchaSolution) } var buttonEnabled by remember { mutableStateOf(!captchaResponse.value.isNullOrEmpty()) } // React to external \"Next\" clicks LaunchedEffect(nextClickTrigger) { if (nextClickTrigger == true) { onAction( RegistrationAction.NextClick( RegistrationDataTransfer.CaptchaDataTransfer( captchaSolution = captchaResponse.value.orEmpty() ) ) ) onResetNextTrigger() widget.reset() } } // Enable or disable the Next button based on captcha state LaunchedEffect(buttonEnabled) { onNextButtonEnabled(buttonEnabled) } Captcha( modifier = modifier, widget = widget, onWidgetClick = { eventState, eventResponse -\u003e when (eventState) { CaptchaEventState.COMPLETED.type -\u003e { captchaResponse.value = eventResponse buttonEnabled = true } CaptchaEventState.EXPIRED.type, CaptchaEventState.ERROR.type, CaptchaEventState.RESET.type -\u003e { captchaResponse.value = eventResponse buttonEnabled = false } } } ) // Optional: show error message below the widget if (state.authResult.authStatus == AuthStatus.Error) { Text( modifier = Modifier .padding(20.dp) .fillMaxWidth(), text = state.authResult.errorMessage ?: stringResource(R.string.error), textAlign = TextAlign.Center, style = MaterialTheme.typography.titleSmall.copy( color = MaterialTheme.colorScheme.error ) ) }}What’s happening here:Captcha state is tracked locally inside the composable using remember.Events from the widget update the button state and captcha response.It listens for an external trigger (nextClickTrigger) to submit the captcha.After submission, the widget is reset and ready to use again.This makes the component reusable, testable, and reactive to both internal and external events.Step 6: Create the Captcha() Composable Using AndroidViewJetpack Compose doesn’t support direct rendering of native views, so we use AndroidView to embed the Captcha SDK's view inside our Compose layout.@Composableprivate fun Captcha( modifier: Modifier, widget: FriendlyCaptchaWidgetHandle, onWidgetClick: (eventState: String, eventResponse: String) -\u003e Unit) { // Set the listener for captcha events widget.setOnStateChangeListener { event -\u003e onWidgetClick(event.state, event.response) } // Render the widget using AndroidView AndroidView( factory = { widget.view }, modifier = modifier .fillMaxWidth() .height(72.dp) )}Why this is needed:The SDK exposes the Captcha as a traditional Android View.AndroidView is a bridge that allows you to embed classic Views inside Compose.The setOnStateChangeListener lets you react to events like \"completed\", \"error\", or \"expired\" — all of which are passed back to your CaptchaComponent.Bonus: Define Captcha Event States for ClarityFor clean and readable logic, define the event states like this:private enum class CaptchaEventState(val type: String) { COMPLETED(\"completed\"), EXPIRED(\"expired\"), ERROR(\"error\"), RESET(\"reset\")}ConclusionIn this article, we walked through how to integrate Friendly Captcha 2.0 into a Jetpack Compose-based Android app using Hilt and ViewModel-based state management.Compared to the older version, 2.0 brings:Faster widget renderingSmarter, adaptive puzzle logicCleaner SDK initializationStrong privacy and zero trackingBy combining Compose, Hilt, and a well-structured UI flow, we’ve created a seamless and secure captcha experience that’s ready for production.If you haven’t already, you can check out Implementing Friendly Captcha in Jetpack Compose: A Ready-to-Use Solution, where we implemented the first version of Friendly Captcha and established the foundation for this setup.Found this helpful?If this article helped you get up and running with Friendly Captcha 2.0 — or saved you a few hours of trial and error — drop a few claps 👏 to help others discover it too!Have questions, feedback, or your own approach to integrating captcha in Jetpack Compose?💬 Leave a comment — I’d love to hear your thoughts.If you’re into Android development, Jetpack Compose, or Kotlin tips, follow me here on Medium — I regularly share practical content based on real projects, not just docs.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*dYQkXKgnLcJr749s",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp id=\"23a2\"\u003eIn the \u003ca href=\"https://medium.com/proandroiddev/implementing-friendly-captcha-in-jetpack-compose-a-ready-to-use-solution-d9300252ba8e\" rel=\"noopener\"\u003eprevious article\u003c/a\u003e, we implemented the first version of Friendly Captcha in a Jetpack Compose-based Android app.\u003c/p\u003e\u003cp id=\"5eca\"\u003eIn this post, we’re diving into \u003cstrong\u003eFriendly Captcha 2.0\u003c/strong\u003e — showing how to set it up with a clean, production-ready architecture using Jetpack Compose and Hilt.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0281\"\u003eWhat’s New in Friendly Captcha 2.0?\u003c/h2\u003e\u003cp id=\"35b2\"\u003eBefore we dive into the implementation, here’s a quick overview of how Friendly Captcha 2.0 improves compared to the earlier version:\u003c/p\u003e\u003cul\u003e\u003cli id=\"fa3f\"\u003e\u003cstrong\u003eIntegration Flow:\u003c/strong\u003e\u003cbr/\u003eVersion 1 required a more manual setup.\u003cbr/\u003eVersion 2.0 offers smoother SDK initialization, making integration easier.\u003c/li\u003e\u003cli id=\"eb8d\"\u003e\u003cstrong\u003eWidget Experience:\u003c/strong\u003e\u003cbr/\u003eIn Version 1, the widget sometimes introduced a slight delay.\u003cbr/\u003eVersion 2.0 renders faster and offers a more seamless user experience.\u003c/li\u003e\u003cli id=\"e382\"\u003e\u003cstrong\u003eAPI Endpoint Support:\u003c/strong\u003e\u003cbr/\u003eVersion 1 had a fixed endpoint.\u003cbr/\u003eVersion 2.0 supports customizable endpoints like \u003ccode\u003e\u0026#34;global\u0026#34;\u003c/code\u003e for better flexibility.\u003c/li\u003e\u003cli id=\"dd2d\"\u003e\u003cstrong\u003ePrivacy \u0026amp; Security:\u003c/strong\u003e\u003cbr/\u003eVersion 1 already had a strong privacy focus.\u003cbr/\u003eVersion 2.0 improves on this with a smarter puzzle engine and the same zero-tracking approach.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"f48b\"\u003e\u003cstrong\u003e\u003cem\u003eTL;DR:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e Version 2.0 is faster, more flexible, and even more secure — while staying privacy-first and developer-friendly.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"656f\"\u003eStep 1: Add the Friendly Captcha SDK\u003c/h2\u003e\u003cp id=\"676a\"\u003eTo get started, you need to add the Friendly Captcha 2.0 SDK to your project.\u003c/p\u003e\u003cp id=\"cde4\"\u003eIf you’re using version catalogs (\u003ccode\u003elibs.versions.toml\u003c/code\u003e), you can define the dependency like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1362\"\u003e# libs.versions.toml\u003cbr/\u003efriendlyCaptchaAndroid = \u0026#34;1.0.2\u0026#34;\u003cp\u003efriendly-captcha-android = {\u003cbr/\u003e  module = \u0026#34;com.friendlycaptcha.android:friendly-captcha-android\u0026#34;,\u003cbr/\u003e  version.ref = \u0026#34;friendlyCaptchaAndroid\u0026#34;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8faf\"\u003eThen include it in your app-level \u003ccode\u003ebuild.gradle.kts\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"90f1\"\u003eimplementation(libs.friendly.captcha.android)\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"3521\"\u003e\u003cstrong\u003e\u003cem\u003eNote:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e Version \u003c/em\u003e\u003ccode\u003e\u003cem\u003e1.0.2\u003c/em\u003e\u003c/code\u003e\u003cem\u003e of the SDK is the current stable release that reflects the 2.0 features\u003c/em\u003e\u003cstrong\u003e\u003cem\u003e -\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e naming-wise, it’s a bit confusing, but this is the right one.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"bf72\"\u003eStep 2: Create a Captcha Provider with Hilt\u003c/h2\u003e\u003cp id=\"ac5a\"\u003eTo avoid initializing the SDK directly in your UI or ViewModel, let’s create a simple provider class that encapsulates setup and exposes the captcha widget.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8042\"\u003e@Singleton\u003cbr/\u003eclass FriendlyCaptchaProvider @Inject constructor(\u003cbr/\u003e    @ApplicationContext private val context: Context\u003cbr/\u003e) {\u003cbr/\u003e    private val sdk by lazy {\u003cbr/\u003e        FriendlyCaptchaSDK(\u003cbr/\u003e            context = context,\u003cbr/\u003e            apiEndpoint = \u0026#34;global\u0026#34; // or use \u0026#34;eu\u0026#34; / custom region if needed\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cp\u003e    internal val widget by lazy {\u003cbr/\u003e        sdk.createWidget(\u003cbr/\u003e            sitekey = context.getString(R.string.friendly_captcha_api_key)\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9375\"\u003e\u003cstrong\u003eWhat’s happening here:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4dc4\"\u003e\u003ccode\u003e@Singleton\u003c/code\u003e ensures only one instance exists app-wide.\u003c/li\u003e\u003cli id=\"fce8\"\u003eWe’re using \u003ccode\u003e@Inject constructor\u003c/code\u003e so Hilt can provide this class automatically.\u003c/li\u003e\u003cli id=\"3e98\"\u003e\u003ccode\u003esdk.createWidget()\u003c/code\u003e creates an instance of \u003ccode\u003eFriendlyCaptchaWidgetHandle\u003c/code\u003e, which you’ll pass to your UI.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"56ec\"\u003e\u003cstrong\u003e\u003cem\u003eNote:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e Make sure your API key is stored in \u003c/em\u003e\u003ccode\u003e\u003cem\u003estrings.xml\u003c/em\u003e\u003c/code\u003e\u003cem\u003e:\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003cspan id=\"b1f0\"\u003e\u0026lt;string name=\u0026#34;friendly_captcha_api_key\u0026#34;\u0026gt;YOUR_SITE_KEY_HERE\u0026lt;/string\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9037\"\u003eStep 3: Inject the Captcha Widget into Your ViewModel\u003c/h2\u003e\u003cp id=\"7af2\"\u003eWe’ll inject the \u003ccode\u003eFriendlyCaptchaProvider\u003c/code\u003e using Hilt, then expose the widget via a \u003ccode\u003eval\u003c/code\u003e so it can be passed into your composable screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c5aa\"\u003e@HiltViewModel\u003cbr/\u003eclass RegistrationViewModel @Inject constructor(\u003cbr/\u003e    private val authService: AuthService,\u003cbr/\u003e    private val friendlyCaptchaProvider: FriendlyCaptchaProvider\u003cbr/\u003e) : ViewModel() {\u003cp\u003e    var state by mutableStateOf(RegistrationState())\u003cbr/\u003e        private set\u003c/p\u003e\u003cp\u003e    private val _effect = Channel\u0026lt;RegistrationEffect\u0026gt;()\u003cbr/\u003e    val effect = _effect.receiveAsFlow()\u003c/p\u003e\u003cp\u003e    // Expose the captcha widget\u003cbr/\u003e    val friendlyCaptchaWidget by lazy { friendlyCaptchaProvider.widget }\u003c/p\u003e\u003cp\u003e    fun onAction(action: RegistrationAction) {\u003cbr/\u003e        when (action) {\u003cbr/\u003e            is RegistrationAction.NextClick -\u0026gt; {\u003cbr/\u003e                // Extract captcha response\u003cbr/\u003e                val captchaResponse = action.data.captchaSolution\u003c/p\u003e\u003cp\u003e                // Optional: validate or show loading state\u003cbr/\u003e                state = state.copy(isLoading = true)\u003c/p\u003e\u003cp\u003e                // Simulate call to backend or your authService\u003cbr/\u003e                viewModelScope.launch {\u003cbr/\u003e                    val result = authService.registerWithCaptcha(captchaResponse)\u003c/p\u003e\u003cp\u003e                    state = state.copy(\u003cbr/\u003e                        isLoading = false,\u003cbr/\u003e                        authResult = result\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            // Handle other actions if needed (e.g., field input, back press)\u003cbr/\u003e            else -\u0026gt; Unit\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"16e2\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6d47\"\u003eThe widget is now part of your UI state, not tightly coupled to your composable.\u003c/li\u003e\u003cli id=\"e0c4\"\u003eIt’s initialized lazily, so it only gets created when needed.\u003c/li\u003e\u003cli id=\"b907\"\u003eKeeping it inside the ViewModel avoids unnecessary recompositions or view-specific issues.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"0086\"\u003e\u003cem\u003eIf you’re following an MVI or MVVM pattern, this keeps your architecture clean and testable.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"bc7c\"\u003eStep 4: Pass the Widget to Your Composable Screen\u003c/h2\u003e\u003cp id=\"ec02\"\u003eNow that your \u003ccode\u003eViewModel\u003c/code\u003e exposes the \u003ccode\u003eFriendlyCaptchaWidgetHandle\u003c/code\u003e, you can pass it to your screen-level composable:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a1db\"\u003eRegistrationScreen(\u003cbr/\u003e    state = viewModel.state,\u003cbr/\u003e    onAction = viewModel::onAction,\u003cbr/\u003e    captchaWidget = viewModel.friendlyCaptchaWidget\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"15be\"\u003eThen update your screen function to accept the \u003ccode\u003ecaptchaWidget\u003c/code\u003e as a parameter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d180\"\u003e@Composable\u003cbr/\u003efun RegistrationScreen(\u003cbr/\u003e    state: RegistrationState,\u003cbr/\u003e    onAction: (RegistrationAction) -\u0026gt; Unit,\u003cbr/\u003e    captchaWidget: FriendlyCaptchaWidgetHandle\u003cbr/\u003e) {\u003cbr/\u003e    when (state.currentStep) {\u003cbr/\u003e        RegistrationStep.CAPTCHA -\u0026gt; {\u003cbr/\u003e            CaptchaComponent(\u003cbr/\u003e                widget = captchaWidget,\u003cbr/\u003e                modifier = Modifier.padding(bottom = 40.dp),\u003cbr/\u003e                state = state,\u003cbr/\u003e                nextClickTrigger = nextClickTrigger.value,\u003cbr/\u003e                onNextButtonEnabled = { enabled -\u0026gt;\u003cbr/\u003e                    nextButtonEnabled.value = enabled\u003cbr/\u003e                },\u003cbr/\u003e                onAction = onAction,\u003cbr/\u003e                onResetNextTrigger = { nextClickTrigger.value = false }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e        // other steps...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3717\"\u003e\u003cstrong\u003eWhat’s happening here:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"febe\"\u003eThe widget is now fully integrated with your screen.\u003c/li\u003e\u003cli id=\"b928\"\u003eYou can control how it’s shown, when it resets, and how it feeds back to the form.\u003c/li\u003e\u003cli id=\"2e1c\"\u003eThe \u003ccode\u003eCaptchaComponent\u003c/code\u003e will handle the actual rendering and logic.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b372\"\u003eStep 5: Create the \u003ccode\u003eCaptchaComponent\u003c/code\u003e Composable\u003c/h2\u003e\u003cp id=\"de18\"\u003eThis component is responsible for rendering the captcha widget inside your screen, handling its events, and triggering actions like form submission when the captcha is completed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1325\"\u003e@Composable\u003cbr/\u003efun CaptchaComponent(\u003cbr/\u003e    widget: FriendlyCaptchaWidgetHandle,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    state: RegistrationState,\u003cbr/\u003e    nextClickTrigger: Boolean?,\u003cbr/\u003e    onResetNextTrigger: () -\u0026gt; Unit,\u003cbr/\u003e    onNextButtonEnabled: (enabled: Boolean) -\u0026gt; Unit,\u003cbr/\u003e    onAction: (RegistrationAction) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val captchaResponse = remember { mutableStateOf(state.registrationData.captchaSolution) }\u003cbr/\u003e    var buttonEnabled by remember { mutableStateOf(!captchaResponse.value.isNullOrEmpty()) }\u003cp\u003e    // React to external \u0026#34;Next\u0026#34; clicks\u003cbr/\u003e    LaunchedEffect(nextClickTrigger) {\u003cbr/\u003e        if (nextClickTrigger == true) {\u003cbr/\u003e            onAction(\u003cbr/\u003e                RegistrationAction.NextClick(\u003cbr/\u003e                    RegistrationDataTransfer.CaptchaDataTransfer(\u003cbr/\u003e                        captchaSolution = captchaResponse.value.orEmpty()\u003cbr/\u003e                    )\u003cbr/\u003e                )\u003cbr/\u003e            )\u003cbr/\u003e            onResetNextTrigger()\u003cbr/\u003e            widget.reset()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Enable or disable the Next button based on captcha state\u003cbr/\u003e    LaunchedEffect(buttonEnabled) {\u003cbr/\u003e        onNextButtonEnabled(buttonEnabled)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Captcha(\u003cbr/\u003e        modifier = modifier,\u003cbr/\u003e        widget = widget,\u003cbr/\u003e        onWidgetClick = { eventState, eventResponse -\u0026gt;\u003cbr/\u003e            when (eventState) {\u003cbr/\u003e                CaptchaEventState.COMPLETED.type -\u0026gt; {\u003cbr/\u003e                    captchaResponse.value = eventResponse\u003cbr/\u003e                    buttonEnabled = true\u003cbr/\u003e                }\u003cbr/\u003e                CaptchaEventState.EXPIRED.type,\u003cbr/\u003e                CaptchaEventState.ERROR.type,\u003cbr/\u003e                CaptchaEventState.RESET.type -\u0026gt; {\u003cbr/\u003e                    captchaResponse.value = eventResponse\u003cbr/\u003e                    buttonEnabled = false\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    // Optional: show error message below the widget\u003cbr/\u003e    if (state.authResult.authStatus == AuthStatus.Error) {\u003cbr/\u003e        Text(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .padding(20.dp)\u003cbr/\u003e                .fillMaxWidth(),\u003cbr/\u003e            text = state.authResult.errorMessage ?: stringResource(R.string.error),\u003cbr/\u003e            textAlign = TextAlign.Center,\u003cbr/\u003e            style = MaterialTheme.typography.titleSmall.copy(\u003cbr/\u003e                color = MaterialTheme.colorScheme.error\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7f4d\"\u003e\u003cstrong\u003eWhat’s happening here:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7b91\"\u003eCaptcha state is tracked locally inside the composable using \u003ccode\u003eremember\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3006\"\u003eEvents from the widget update the button state and captcha response.\u003c/li\u003e\u003cli id=\"1e7c\"\u003eIt listens for an external trigger (\u003ccode\u003enextClickTrigger\u003c/code\u003e) to submit the captcha.\u003c/li\u003e\u003cli id=\"bc96\"\u003eAfter submission, the widget is reset and ready to use again.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"b274\"\u003e\u003cem\u003eThis makes the component reusable, testable, and reactive to both internal and external events.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"4e09\"\u003eStep 6: Create the \u003ccode\u003eCaptcha()\u003c/code\u003e Composable Using \u003ccode\u003eAndroidView\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"17f5\"\u003eJetpack Compose doesn’t support direct rendering of native views, so we use \u003ccode\u003eAndroidView\u003c/code\u003e to embed the Captcha SDK\u0026#39;s view inside our Compose layout.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ba30\"\u003e@Composable\u003cbr/\u003eprivate fun Captcha(\u003cbr/\u003e    modifier: Modifier,\u003cbr/\u003e    widget: FriendlyCaptchaWidgetHandle,\u003cbr/\u003e    onWidgetClick: (eventState: String, eventResponse: String) -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    // Set the listener for captcha events\u003cbr/\u003e    widget.setOnStateChangeListener { event -\u0026gt;\u003cbr/\u003e        onWidgetClick(event.state, event.response)\u003cbr/\u003e    }\u003cp\u003e    // Render the widget using AndroidView\u003cbr/\u003e    AndroidView(\u003cbr/\u003e        factory = { widget.view },\u003cbr/\u003e        modifier = modifier\u003cbr/\u003e            .fillMaxWidth()\u003cbr/\u003e            .height(72.dp)\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d3aa\"\u003e\u003cstrong\u003eWhy this is needed:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bc99\"\u003eThe SDK exposes the Captcha as a traditional Android View.\u003c/li\u003e\u003cli id=\"3f7c\"\u003e\u003ccode\u003eAndroidView\u003c/code\u003e is a bridge that allows you to embed classic Views inside Compose.\u003c/li\u003e\u003cli id=\"f7c0\"\u003eThe \u003ccode\u003esetOnStateChangeListener\u003c/code\u003e lets you react to events like \u003ccode\u003e\u0026#34;completed\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;error\u0026#34;\u003c/code\u003e, or \u003ccode\u003e\u0026#34;expired\u0026#34;\u003c/code\u003e — all of which are passed back to your \u003ccode\u003eCaptchaComponent\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"92a9\"\u003e\u003cstrong\u003eBonus: Define Captcha Event States for Clarity\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"aa77\"\u003eFor clean and readable logic, define the event states like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d32c\"\u003eprivate enum class CaptchaEventState(val type: String) {\u003cbr/\u003e    COMPLETED(\u0026#34;completed\u0026#34;),\u003cbr/\u003e    EXPIRED(\u0026#34;expired\u0026#34;),\u003cbr/\u003e    ERROR(\u0026#34;error\u0026#34;),\u003cbr/\u003e    RESET(\u0026#34;reset\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bba3\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"b0a9\"\u003eIn this article, we walked through how to integrate Friendly Captcha 2.0 into a Jetpack Compose-based Android app using Hilt and ViewModel-based state management.\u003c/p\u003e\u003cp id=\"78cc\"\u003eCompared to the older version, 2.0 brings:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b53f\"\u003eFaster widget rendering\u003c/li\u003e\u003cli id=\"7c51\"\u003eSmarter, adaptive puzzle logic\u003c/li\u003e\u003cli id=\"7627\"\u003eCleaner SDK initialization\u003c/li\u003e\u003cli id=\"303d\"\u003eStrong privacy and zero tracking\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4052\"\u003eBy combining Compose, Hilt, and a well-structured UI flow, we’ve created a seamless and secure captcha experience that’s ready for production.\u003c/p\u003e\u003cp id=\"3d88\"\u003eIf you haven’t already, you can check out \u003ca href=\"https://medium.com/proandroiddev/implementing-friendly-captcha-in-jetpack-compose-a-ready-to-use-solution-d9300252ba8e\" rel=\"noopener\"\u003e\u003cstrong\u003eImplementing Friendly Captcha in Jetpack Compose: A Ready-to-Use Solution\u003c/strong\u003e\u003c/a\u003e, where we implemented the first version of Friendly Captcha and established the foundation for this setup.\u003c/p\u003e\u003ch2 id=\"b6a4\"\u003eFound this helpful?\u003c/h2\u003e\u003cp id=\"9fed\"\u003eIf this article helped you get up and running with Friendly Captcha 2.0 — or saved you a few hours of trial and error — drop a few claps 👏 to help others discover it too!\u003c/p\u003e\u003cp id=\"0536\"\u003eHave questions, feedback, or your own approach to integrating captcha in Jetpack Compose?\u003cbr/\u003e💬 Leave a comment — I’d love to hear your thoughts.\u003c/p\u003e\u003cp id=\"ab28\"\u003eIf you’re into Android development, Jetpack Compose, or Kotlin tips, follow me here on Medium — I regularly share practical content based on real projects, not just docs.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-04-14T14:15:10.8Z",
  "modifiedTime": null
}
