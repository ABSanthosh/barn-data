{
  "id": "aad15ee0-07ca-47e2-96b2-2db820cf0903",
  "title": "Coroutines under the hood.",
  "link": "https://proandroiddev.com/coroutines-under-the-hood-36561949497d?source=rss----c72404660798---4",
  "description": "",
  "author": "Sahil Thakar",
  "published": "Mon, 30 Sep 2024 18:06:58 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "programming",
    "kotlin",
    "java",
    "software-development",
    "android"
  ],
  "byline": "Sahil Thakar",
  "length": 8816,
  "excerpt": "What exactly happens under the hood when you create a suspension function? Let’s dig deep and uncover the inner workings of this essential coroutine concept. Let’s look at the suspended functions and…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hey folks!Today, we’re exploring suspension functions — those magical building blocks of Kotlin Coroutines.What exactly happens under the hood when you create a suspension function? Let’s dig deep and uncover the inner workings of this essential coroutine concept.Ready to dive in?Let’s talk briefly about how the suspend function works:-Kotlin coroutines leverage a state machine architecture to implement suspending functions, facilitating asynchronous programming.When a suspending function is compiled, it is transformed into a state machine with distinct states representing various execution stages.A continuation object is used to track the current state, manage resumption points, and maintain context between suspensions.The state machine structure allows coroutines to suspend and resume, transitioning through different states, and providing non-blocking concurrency.This approach preserves the readability of synchronous code while offering a robust and efficient framework for managing asynchronous operations in Kotlin.Continuation-passing style:-There are a few ways with suspending function could have been implemented but Kotlin choose to go with CPS.Kotlin coroutines use continuation-passing style (CPS) to support asynchronous programming, allowing functions to “suspend” and “resume,” thus enabling non-blocking concurrency. This design choice provides a simple and intuitive way to write asynchronous code that resembles synchronous code, improving readability and reducing callback complexity.By convention, a continuation takes the last parameter position.If we look behind the code Continuation:-Let’s look at the suspended functions and their decompiled version of code. But note here we are not going to real decompiled code because it is really complex to understand. So we are going to learn it in Kotlin way so it makes it easier to understand.suspend fun getUser(): User?suspend fun setUser(user: User)suspend fun checkAvailability(flight: Flight): Boolean// under the hood isfun getUser(continuation: Continuation\u003c*\u003e): Any?fun setUser(user: User, continuation: Continuation\u003c*\u003e): Anyfun checkAvailability( flight: Flight, continuation: Continuation\u003c*\u003e): AnySo, here as you will see, every suspended function under the hood has continuation as arguments.the result type under the hood is different from the originally declared one. It has changed to Any or Any?.Why so? The reason is that a suspending function might be suspended, and so it might not return a declared type.In such a case, it returns a special COROUTINE_SUSPENDED marker, which we will later see in practice.For now, just noticed that since getUser might return User? or COROUTINE_SUSPENDED (which is of type Any), its result type must be the closest supertype of User? and Any, so it is Any?.Perhaps one day Kotlin will introduce union types, in which case we will have User? | COROUTINE_SUSPENDED instead.A very simple functionTo dive deeper, let’s start with a very simple function that prints something before and after a delay.suspend fun myFunction() { println(\"Before\") delay(1000) // suspending println(\"After\")}Let’s look at the underhood:The function could be started from two places: either from the beginning (in the case of a first call) or from the point after suspension (in the case of resuming from continuation). To identify the current state, we use a field called label. At the start, it is 0, therefore the function will start from the beginning. However, it is set to the next state before each suspension point so that we start from just after the suspension point after a resume.// A simplified picture of how myFunction looks under the hoodfun myFunction(continuation: Continuation\u003cUnit\u003e): Any { val continuation = continuation as? MyFunctionContinuation ?: MyFunctionContinuation(continuation) if (continuation.label == 0) { println(\"Before\") continuation.label = 1 if (delay(1000, continuation) == COROUTINE_SUSPENDED){ return COROUTINE_SUSPENDED } } if (continuation.label == 1) { println(\"After\") return Unit } error(\"Impossible\")}The next thing is that this function needs its own continuation in order to remember its state. so we name it MyFunctionContinuation (the actual continuation is an object expression and has no name, but it will be easier to explain this way). At the beginning of its body, myFunction will wrap the continuation (the parameter) with its own continuation (MyFunctionContinuation).Explanation:-In Kotlin coroutines, a continuation represents a point in the coroutine’s execution that can be resumed later. If a coroutine is suspended, it returns COROUTINE_SUSPENDED, indicating that control should be returned to the caller without completing the operation.The delay function is used to simulate non-blocking delays, allowing other tasks to run on the same thread while the coroutine is suspended. If delay returns COROUTINE_SUSPENDED, it signifies that the coroutine will be resumed later. If it returns Unit, it indicates that the coroutine did not suspend.When a coroutine suspends, it releases the thread for other tasks to run. If delay returns COROUTINE_SUSPENDED, the function suspends and returns control, but if it doesn't, it continues execution immediately. This impacts how other tasks can share the thread, with suspension providing better concurrency.The code snippet uses a state-tracking mechanism (with a label) to handle suspension and resumption. Initially, with label == 0, the function executes code and then suspends with delay. If delay returns COROUTINE_SUSPENDED, the function suspends, awaiting resumption. Otherwise, it moves to the next state (label == 1), indicating continuation without suspension.Potential Issues with delay Returning Unit Instead of COROUTINE_SUSPENDED: If delay were to return Unit instead of suspending, it would lead to immediate continuation without releasing the thread. This behavior is problematic because it would prevent other tasks from running during the supposed \"delay,\" potentially causing performance issues due to lack of concurrency. It underscores the importance of proper suspension in coroutine-based applications to maintain efficient execution flow.Call Stack in Traditional Programming:In traditional programming, the call stack stores crucial information such as function states, local variables, and return addresses. This structure allows functions to call and return without losing context.The challenge in Coroutine-Based Programming:In coroutines, suspension releases the thread and clears the call stack. This behavior is key for non-blocking concurrency, allowing other tasks to use the same thread while a coroutine is suspended. However, it necessitates an alternative to maintain the coroutine’s context upon resumption.Continuations as Call Stack Alternatives:Continuations are used to maintain context for suspended coroutines. When a coroutine suspends, a continuation object is created to store its state, including:State Label: Indicates where the coroutine was suspended, guiding where it should resume.Local Variables and Parameters: Preserved within the continuation, retaining context during suspension.Reference to the Caller: Holds a link to the continuation of the calling function, forming a chain of continuations.Continuations Forming a “Stack”: Each continuation references the one that called it, creating a chain that resembles a call stack. When resuming, this chain allows the coroutine to trace back through the context and continue from where it left off.suspend fun a() { val user = readUser() b() b() b() println(user)}suspend fun b() { for (i in 1..10) { c(i) }}suspend fun c(i: Int) { delay(i * 100L) println(\"Tick\")}Try to decompile this code by yourself and understand what’s going on. open the function in IntelliJ IDEA, use Tools \u003e Kotlin \u003e Show Kotlin bytecode, and click the “Decompile” button.The actual code that continuations and suspending functions are compiled to is more complicated as it includes optimizations and some additional mechanisms, like:constructing a better exceptions stack trace;adding coroutine suspension interceptionoptimizations on different levels (like removing unused variables or tail-call optimization).if we look more under the hood concept of BaseContinuationImpl :-As you can see, it uses a loop instead of recursion. This change allows the actual code to make some optimizations and simplifications.Yeah, Now that’s it for this class.Did you guys enjoy it ??Try it out, and put a question in the comments if you guys have any.Follow me here on Medium for an interesting topicFollow me on — Linkedin as well to increase our developer’s network.Will see you guys soon with some new amazing topics.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:800/0*DK2NOaqvM1jH9rb7.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@sahilthakar10?source=post_page-----36561949497d--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Sahil Thakar\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*KdqqwZdYVTnxCt2BVb2eqQ.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----36561949497d--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"0067\"\u003eHey folks!\u003c/p\u003e\u003cp id=\"81f9\"\u003eToday, we’re exploring suspension functions — those magical building blocks of Kotlin Coroutines.\u003c/p\u003e\u003cp id=\"355a\"\u003eWhat exactly happens under the hood when you create a suspension function? Let’s dig deep and uncover the inner workings of this essential coroutine concept.\u003c/p\u003e\u003cp id=\"815d\"\u003e\u003cstrong\u003eReady to dive in?\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"51ae\"\u003e\u003cstrong\u003eLet’s talk briefly about how the suspend function works:-\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1dac\"\u003eKotlin coroutines leverage a state machine architecture to implement suspending functions, facilitating asynchronous programming.\u003c/li\u003e\u003cli id=\"275f\"\u003eWhen a suspending function is compiled, it is transformed into a state machine with distinct states representing various execution stages.\u003c/li\u003e\u003cli id=\"35f1\"\u003eA continuation object is used to track the current state, manage resumption points, and maintain context between suspensions.\u003c/li\u003e\u003cli id=\"9c2f\"\u003eThe state machine structure allows coroutines to suspend and resume, transitioning through different states, and providing non-blocking concurrency.\u003c/li\u003e\u003cli id=\"d66b\"\u003eThis approach preserves the readability of synchronous code while offering a robust and efficient framework for managing asynchronous operations in Kotlin.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"18f4\"\u003e\u003cstrong\u003eContinuation-passing style:-\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"23ff\"\u003eThere are a few ways with suspending function could have been implemented but Kotlin choose to go with CPS.\u003c/li\u003e\u003cli id=\"cdcb\"\u003eKotlin coroutines use continuation-passing style (CPS) to support asynchronous programming, allowing functions to “suspend” and “resume,” thus enabling non-blocking concurrency. This design choice provides a simple and intuitive way to write asynchronous code that resembles synchronous code, improving readability and reducing callback complexity.\u003c/li\u003e\u003cli id=\"6e10\"\u003eBy convention, a continuation takes the last parameter position.\u003c/li\u003e\u003cli id=\"8636\"\u003eIf we look behind the code Continuation:-\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"82cf\"\u003eLet’s look at the suspended functions and their decompiled version of code. But note here we are not going to real decompiled code because it is really complex to understand. So we are going to learn it in Kotlin way so it makes it easier to understand.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d734\"\u003esuspend fun getUser(): User?\u003cbr/\u003esuspend fun setUser(user: User)\u003cbr/\u003esuspend fun checkAvailability(flight: Flight): Boolean\u003cp\u003e// under the hood is\u003cbr/\u003efun getUser(continuation: Continuation\u0026lt;*\u0026gt;): Any?\u003cbr/\u003efun setUser(user: User, continuation: Continuation\u0026lt;*\u0026gt;): Any\u003cbr/\u003efun checkAvailability(\u003cbr/\u003e  flight: Flight,\u003cbr/\u003e  continuation: Continuation\u0026lt;*\u0026gt;\u003cbr/\u003e): Any\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"a87d\"\u003eSo, here as you will see, every suspended function under the hood has continuation as arguments.\u003c/li\u003e\u003cli id=\"8a3a\"\u003ethe result type under the hood is different from the originally declared one. It has changed to \u003ccode\u003eAny\u003c/code\u003e or \u003ccode\u003eAny?\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"de26\"\u003eWhy so? The reason is that a suspending function might be suspended, and so it might not return a declared type.\u003c/li\u003e\u003cli id=\"e803\"\u003eIn such a case, it returns a special \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e marker, which we will later see in practice.\u003c/li\u003e\u003cli id=\"8ee3\"\u003eFor now, just noticed that since \u003ccode\u003egetUser\u003c/code\u003e might return \u003ccode\u003eUser?\u003c/code\u003e or \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e (which is of type \u003ccode\u003eAny\u003c/code\u003e), its result type must be the closest supertype of \u003ccode\u003eUser?\u003c/code\u003e and \u003ccode\u003eAny\u003c/code\u003e, so it is \u003ccode\u003eAny?\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3bf3\"\u003ePerhaps one day Kotlin will introduce union types, in which case we will have \u003ccode\u003eUser? | COROUTINE_SUSPENDED\u003c/code\u003e instead.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3d6d\"\u003e\u003cstrong\u003eA very simple function\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c98b\"\u003eTo dive deeper, let’s start with a very simple function that prints something before and after a delay.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"2877\"\u003esuspend fun myFunction() {\u003cbr/\u003e  println(\u0026#34;Before\u0026#34;)\u003cbr/\u003e  delay(1000) // suspending\u003cbr/\u003e  println(\u0026#34;After\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ba4e\"\u003e\u003cstrong\u003eLet’s look at the underhood:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"0ae4\"\u003eThe function could be started from two places: either from the beginning (in the case of a first call) or from the point after suspension (in the case of resuming from continuation). To identify the current state, we use a field called \u003ccode\u003elabel\u003c/code\u003e. At the start, it is \u003ccode\u003e0\u003c/code\u003e, therefore the function will start from the beginning. However, it is set to the next state before each suspension point so that we start from just after the suspension point after a resume.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a904\"\u003e// A simplified picture of how myFunction looks under the hood\u003cbr/\u003efun myFunction(continuation: Continuation\u0026lt;Unit\u0026gt;): Any {\u003cbr/\u003e    val continuation = continuation as? MyFunctionContinuation\u003cbr/\u003e        ?: MyFunctionContinuation(continuation)\u003cp\u003e    if (continuation.label == 0) {\u003cbr/\u003e        println(\u0026#34;Before\u0026#34;)\u003cbr/\u003e        continuation.label = 1\u003cbr/\u003e        if (delay(1000, continuation) == COROUTINE_SUSPENDED){\u003cbr/\u003e            return COROUTINE_SUSPENDED\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    if (continuation.label == 1) {\u003cbr/\u003e        println(\u0026#34;After\u0026#34;)\u003cbr/\u003e        return Unit\u003cbr/\u003e    }\u003cbr/\u003e    error(\u0026#34;Impossible\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ae86\"\u003eThe next thing is that this function needs its own continuation in order to remember its state. so we name it \u003ccode\u003eMyFunctionContinuation\u003c/code\u003e (the actual continuation is an object expression and has no name, but it will be easier to explain this way). At the beginning of its body, \u003ccode\u003emyFunction\u003c/code\u003e will wrap the \u003ccode\u003econtinuation\u003c/code\u003e (the parameter) with its own continuation (\u003ccode\u003eMyFunctionContinuation\u003c/code\u003e).\u003c/p\u003e\u003cp id=\"5700\"\u003e\u003cstrong\u003eExplanation:-\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1567\"\u003eIn Kotlin coroutines, a continuation represents a point in the coroutine’s execution that can be resumed later. If a coroutine is suspended, it returns \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, indicating that control should be returned to the caller without completing the operation.\u003c/li\u003e\u003cli id=\"29de\"\u003eThe \u003ccode\u003edelay\u003c/code\u003e function is used to simulate non-blocking delays, allowing other tasks to run on the same thread while the coroutine is suspended. If \u003ccode\u003edelay\u003c/code\u003e returns \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, it signifies that the coroutine will be resumed later. If it returns \u003ccode\u003eUnit\u003c/code\u003e, it indicates that the coroutine did not suspend.\u003c/li\u003e\u003cli id=\"0c6c\"\u003eWhen a coroutine suspends, it releases the thread for other tasks to run. If \u003ccode\u003edelay\u003c/code\u003e returns \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, the function suspends and returns control, but if it doesn\u0026#39;t, it continues execution immediately. This impacts how other tasks can share the thread, with suspension providing better concurrency.\u003c/li\u003e\u003cli id=\"1d55\"\u003eThe code snippet uses a state-tracking mechanism (with a \u003ccode\u003elabel\u003c/code\u003e) to handle suspension and resumption. Initially, with \u003ccode\u003elabel == 0\u003c/code\u003e, the function executes code and then suspends with \u003ccode\u003edelay\u003c/code\u003e. If \u003ccode\u003edelay\u003c/code\u003e returns \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e, the function suspends, awaiting resumption. Otherwise, it moves to the next state (\u003ccode\u003elabel == 1\u003c/code\u003e), indicating continuation without suspension.\u003c/li\u003e\u003cli id=\"27c3\"\u003ePotential Issues with \u003ccode\u003edelay\u003c/code\u003e Returning \u003ccode\u003eUnit\u003c/code\u003e Instead of \u003ccode\u003eCOROUTINE_SUSPENDED\u003c/code\u003e: If \u003ccode\u003edelay\u003c/code\u003e were to return \u003ccode\u003eUnit\u003c/code\u003e instead of suspending, it would lead to immediate continuation without releasing the thread. This behavior is problematic because it would prevent other tasks from running during the supposed \u0026#34;delay,\u0026#34; potentially causing performance issues due to lack of concurrency. It underscores the importance of proper suspension in coroutine-based applications to maintain efficient execution flow.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"8f5d\"\u003e\u003cstrong\u003eCall Stack in Traditional Programming:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b225\"\u003eIn traditional programming, the call stack stores crucial information such as function states, local variables, and return addresses. This structure allows functions to call and return without losing context.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5047\"\u003e\u003cstrong\u003eThe challenge in Coroutine-Based Programming:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c4dc\"\u003eIn coroutines, suspension releases the thread and clears the call stack. This behavior is key for non-blocking concurrency, allowing other tasks to use the same thread while a coroutine is suspended. However, it necessitates an alternative to maintain the coroutine’s context upon resumption.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8c97\"\u003e\u003cstrong\u003eContinuations as Call Stack Alternatives:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"055e\"\u003eContinuations are used to maintain context for suspended coroutines. When a coroutine suspends, a continuation object is created to store its state, including:\u003c/li\u003e\u003cli id=\"c6f5\"\u003e\u003cstrong\u003eState Label:\u003c/strong\u003e Indicates where the coroutine was suspended, guiding where it should resume.\u003c/li\u003e\u003cli id=\"d395\"\u003e\u003cstrong\u003eLocal Variables and Parameters:\u003c/strong\u003e Preserved within the continuation, retaining context during suspension.\u003c/li\u003e\u003cli id=\"6da9\"\u003e\u003cstrong\u003eReference to the Caller: \u003c/strong\u003eHolds a link to the continuation of the calling function, forming a chain of continuations.\u003c/li\u003e\u003cli id=\"d716\"\u003e\u003cstrong\u003eContinuations Forming a “Stack”: \u003c/strong\u003eEach continuation references the one that called it, creating a chain that resembles a call stack. When resuming, this chain allows the coroutine to trace back through the context and continue from where it left off.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre\u003e\u003cspan id=\"912e\"\u003esuspend fun a() {\u003cbr/\u003e    val user = readUser()\u003cbr/\u003e    b()\u003cbr/\u003e    b()\u003cbr/\u003e    b()\u003cbr/\u003e    println(user)\u003cbr/\u003e}\u003cp\u003esuspend fun b() {\u003cbr/\u003e    for (i in 1..10) {\u003cbr/\u003e        c(i)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003esuspend fun c(i: Int) {\u003cbr/\u003e    delay(i * 100L)\u003cbr/\u003e    println(\u0026#34;Tick\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cb51\"\u003eTry to decompile this code by yourself and understand what’s going on. open the function in IntelliJ IDEA, use Tools \u0026gt; Kotlin \u0026gt; Show Kotlin bytecode, and click the “Decompile” button.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"9b3f\"\u003eThe actual code that continuations and suspending functions are compiled to is more complicated as it includes optimizations and some additional mechanisms, like:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a1a1\"\u003econstructing a better exceptions stack trace;\u003c/li\u003e\u003cli id=\"34e8\"\u003eadding coroutine suspension interception\u003c/li\u003e\u003cli id=\"8168\"\u003eoptimizations on different levels (like removing unused variables or tail-call optimization).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f0b0\"\u003eif we look more under the hood concept of \u003ccode\u003eBaseContinuationImpl\u003c/code\u003e :-\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0037\"\u003eAs you can see, it uses a loop instead of recursion. This change allows the actual code to make some optimizations and simplifications.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"a91b\"\u003eYeah, Now that’s it for this class.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d67e\"\u003eDid you guys enjoy it ??\u003c/p\u003e\u003cp id=\"3736\"\u003eTry it out, and put a question in the comments if you guys have any.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"a7e3\"\u003e\u003cem\u003eFollow me here on \u003c/em\u003e\u003ca href=\"https://medium.com/@sahilthakar10\" rel=\"noopener\"\u003e\u003cem\u003eMedium\u003c/em\u003e\u003c/a\u003e\u003cem\u003e for an interesting topic\u003c/em\u003e\u003c/p\u003e\u003cp id=\"e562\"\u003e\u003cem\u003eFollow me on — \u003c/em\u003e\u003ca href=\"https://www.linkedin.com/in/sahil-hm/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eLinkedin\u003c/em\u003e\u003c/a\u003e\u003cem\u003e as well to increase our developer’s network.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"8e51\"\u003eWill see you guys soon with some new amazing topics.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-05-01T16:23:44.23Z",
  "modifiedTime": null
}
