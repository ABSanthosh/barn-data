{
  "id": "f248e22e-052b-4ee0-8f9d-baaa0e62e870",
  "title": "Adaptive Camera: Smooth Tabletop Mode with Animations",
  "link": "https://medium.com/androiddevelopers/adaptive-camera-smooth-tabletop-mode-with-animations-f57d77696e0f?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Jolanda Verhoef",
  "published": "Tue, 08 Apr 2025 16:03:14 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "featured",
    "camerax",
    "adaptive",
    "media",
    "compose"
  ],
  "byline": "Jolanda Verhoef",
  "length": 13976,
  "excerpt": "Welcome back to the final part of our blog post series about harnessing the power of CameraX and Compose. In the previous posts, weâ€™ve created a camera preview screen with tap-to-focus and spotlightâ€¦",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Part 4 of Unlocking the Power of CameraX in Jetpack ComposeWelcome back to the final part of our blog post series about harnessing the power of CameraX and Compose. In the previous posts, weâ€™ve created a camera preview screen with tap-to-focus and spotlight effect. Now, we will take our viewfinder and expand it to the larger screen!ðŸ§± Part 1: Building a basic camera preview using the new camera-compose artifact. We covered permission handling and basic integration.ðŸ‘† Part 2: Using the Compose gesture system, graphics, and coroutines to implement a visual tap-to-focus.ðŸ”¦ Part 3: Exploring how to overlay Compose UI elements on top of your camera preview for a richer user experience.ðŸ“‚ Part 4 (this post): Using adaptive APIs and the Compose animation framework to smoothly animate to and from tabletop mode on foldable phones.This post shows how to create a UI that elegantly transitions between a full-screen and a split-screen layout when a foldable device enters tabletop mode. We can use Composeâ€™s animation APIs to smoothly animate this transition.Hereâ€™s the final result:Building upon the concepts and code from the previous posts, weâ€™ll accomplish this in five logical steps:Update our dependencies to use the latest animation and adaptive APIs.Retrieve and share the hinge coordinates of our foldable device.Position the camera viewfinder above the fold when the device is in tabletop mode.Animate the transition between full-screen and top-half only viewfinder.Create supporting content to display in the bottom half of the screen when in tabletop mode.Note; you can follow along step by step, continuing with the code from the third blog post, or check out the final code snippet here.Add and update dependenciesThis post takes advantage of some newer APIs, so we need to make sure to update our dependencies to their latest versions. We will use the brand new animateBounds API, introduced in Compose 1.8.Weâ€™ll also add a dependency on material3-adaptive, the artifact that helps us deal with foldable concepts such as tabletop mode and physical device hinges:#libs.versions.toml[versions]kotlin = \"2.1.20\"composeBom = \"2025.03.01\"camerax = \"1.5.0-alpha06\"accompanist = \"0.37.2\"..[libraries]androidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom-beta\", version.ref = \"composeBom\" }androidx-material3-adaptive = { group = \"androidx.compose.material3.adaptive\", name = \"adaptive\" }..#build.gradle.kts..dependencies { .. implementation(libs.androidx.material3.adaptive)}Provide foldable hinge information with rulersWeâ€™re aiming to align our UI components based on the position of the foldableâ€™s hinge. Because foldables come in many shapes and forms, we should align our UI to the actual position of the top and bottom of the hinge, instead of simply breaking up the screen into two parts.Note: Most foldables have a single display that runs across the hinge. In that case the hinge is simply a horizontal line, so its top and bottom coordinate would be equal. However, some foldables have two separate displays with some small space between them. That space still takes up layouting space, and you can still draw things in that non-existent space.Basically, we want to know the top and the bottom y-coordinate of the first horizontal hinge:Also, we likely want to use the same pattern in more screens in our app, so any screen can use this information when needed.To provide the hinge position for the whole composable sub-tree, we can use rulers, a new UI concept introduced in Compose 1.7.0. By defining a horizontal ruler and providing it from the root of our UI hierarchy, any UI component can then use that ruler to align itself or its children to.Since hinges can have a non-zero thickness, letâ€™s provide two horizontal rulers, one for the top and one for the bottom y-coordinate of the first horizontal hinge. Weâ€™ll retrieve the actual coordinates by using the currentWindowAdaptiveInfo method in material3-adaptive.val HorizontalHingeTopRuler = HorizontalRuler()val HorizontalHingeBottomRuler = HorizontalRuler()class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { MyApplicationTheme { val viewModel = remember { CameraPreviewViewModel() } val horizontalHinge = currentWindowAdaptiveInfo().windowPosture .allHorizontalHingeBounds.firstOrNull() Box( Modifier.layout { measurable, constraints -\u003e val placeable = measurable.measure(constraints) layout( width = constraints.maxWidth, height = constraints.maxHeight, rulers = { if (horizontalHinge != null) { val bounds = coordinates.windowToLocal(horizontalHinge) HorizontalHingeTopRuler provides bounds.top HorizontalHingeBottomRuler provides bounds.bottom } } ) { placeable.place(0, 0) } } ) { CameraPreviewScreen(viewModel) } } } }}private fun LayoutCoordinates.windowToLocal(rect: Rect): Rect = Rect( topLeft = windowToLocal(rect.topLeft), bottomRight = windowToLocal(rect.bottomRight), )Adapt camera viewfinder to tabletop postureIf you remember, in our last post, we simply showed a full screen camera viewfinder. That doesnâ€™t look great while our foldable device is in tabletop mode:So, letâ€™s wrap our viewfinder inside a container, and make sure that that container shows only at the top half of the screen when the device is in tabletop mode:As part of this, weâ€™ll extract all code from the previous blog post into its own ViewfinderContent composable.@Composablefun CameraPreviewContent( viewModel: CameraPreviewViewModel, modifier: Modifier = Modifier, lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current) { val surfaceRequest by viewModel.surfaceRequest.collectAsStateWithLifecycle() val sensorFaceRects by viewModel.sensorFaceRects.collectAsStateWithLifecycle() val context = LocalContext.current LaunchedEffect(lifecycleOwner) { viewModel.bindToCamera(context.applicationContext, lifecycleOwner) } val shouldHighlightFaces by remember { derivedStateOf { sensorFaceRects.isNotEmpty() } } val spotlightColor = Color(0xFFE60991) val windowPosture = currentWindowAdaptiveInfo().windowPosture val isTabletop: Boolean = windowPosture.isTabletop Box(modifier.safeDrawingPadding()) { ViewfinderContent( surfaceRequest, { sensorFaceRects }, shouldHighlightFaces: Boolean, viewModel::tapToFocus, Modifier .fillMaxSize() .then(if (isTabletop) Modifier.alignAboveHinge() else Modifier) .padding(16.dp) .clip(RoundedCornerShape(24.dp)) .border(8.dp, spotlightColor, RoundedCornerShape(24.dp)) ) }}// Place the composable above the horizontal hinge, if a hinge is present.// Ruler values are only available during the placement phase, so this modifier// *measures* with max constraints, and then *places* the content above the hinge.private fun Modifier.alignAboveHinge(): Modifier = this then Modifier.layout { measurable, constraints -\u003e layout(constraints.maxWidth, constraints.maxHeight) { // Get current hinge top, or NaN if not available val hingeTop = HorizontalHingeTopRuler.current(defaultValue = Float.NaN) // Constrain the height of the composable to the hinge top (if available) val childConstraints = if (hingeTop.isNaN()) constraints else Constraints(maxHeight = hingeTop.roundToInt()).constrain(constraints) // Place the composable above the hinge val placeable = measurable.measure(childConstraints) placeable.place(0, 0) } }One thing to note is that weâ€™ll only have access to the rulers once in the placement phase. So, in this case, we make the ViewfinderContent composable measure with full constraints, but then place itself only above the hinge.Animate transitionsWe can improve this code by adding a smooth transition between the tabletop and flat modes of the device. Right now, when the user moves between these two states, the UI jumps from one version to the other, creating a jarring experience:Luckily, we have the new animation APIs to add automatic transitions between the two states. With Modifier.animateBounds() (new in Compose 1.8), that is available for use within a LookaheadScope , you can automatically animate the bounds of a composable. Note that weâ€™ll need to add the LookaheadScope at the top level so the rulers take it into account, and then pass it on through the UI hierarchy using a composition local (as per documentation):val LocalLookaheadScope = compositionLocalOf\u003cLookaheadScope?\u003e { null }class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { .. setContent { MyApplicationTheme { .. LookaheadScope { CompositionLocalProvider(LocalLookaheadScope provides this) { Box( Modifier.layout { measurable, constraints -\u003e .. } ) { CameraPreviewScreen(viewModel) } } } } } }}@OptIn(ExperimentalSharedTransitionApi::class)@Composablefun CameraPreviewContent( viewModel: CameraPreviewViewModel, modifier: Modifier = Modifier, lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current) { .. val isTabletop: Boolean = windowPosture.isTabletop val lookaheadScope = LocalLookaheadScope.current ?: throw IllegalStateException(\"No LookaheadScope found\") Box(modifier.safeDrawingPadding()) { ViewfinderContent( .. modifier = Modifier .fillMaxSize() .then(if (isTabletop) Modifier.alignAboveHinge() else Modifier) .animateBounds(this@LookaheadScope) .padding(16.dp) .clip(RoundedCornerShape(24.dp)) .border(8.dp, spotlightColor, RoundedCornerShape(24.dp)) ) }}Add a control panelNow that we have some extra space in our layout, we can add a control panel that shows or hides based on the tabletop mode. Here, we can use the AnimatedVisibility API to show or hide the panel, in combination with the same rulers as above to position the panel below the hinge:@OptIn(ExperimentalSharedTransitionApi::class)@Composablefun CameraPreviewContent( ..) { .. val colors = listOf(Color(0xFF09D8E6), Color(0xFFE6C709), Color(0xFFE60991)) var pickedColorIndex by rememberSaveable { mutableIntStateOf(0) } val onColorIndexChanged = { index: Int -\u003e pickedColorIndex = index } val spotlightColor by animateColorAsState(colors[pickedColorIndex]) Box(modifier.safeDrawingPadding()) { ViewfinderContent( .. ) AnimatedVisibility( isTabletop, enter = fadeIn() + slideInVertically { it / 2 }, exit = fadeOut() + slideOutVertically { it / 2 }, modifier = Modifier.alignBelowHinge() ) { MyControlPanel( colors = colors, pickedColorIndex = pickedColorIndex, onColorPicked = onColorIndexChanged, ) } }}// Place the composable below the horizontal hinge, if a hinge is present.// Ruler values are only available during the placement phase, so this modifier// *measures* with max constraints, and then *places* the content below the hinge.private fun Modifier.alignBelowHinge(): Modifier = this then Modifier.layout { measurable, constraints -\u003e layout(constraints.maxWidth, constraints.maxHeight) { // Get current hinge bottom, or default to 0 if not available val hingeBottom = HorizontalHingeBottomRuler.current(defaultValue = 0f).roundToInt() // Constrain the height of the composable to the hinge bottom (if available) val childConstraints = Constraints(maxHeight = constraints.maxHeight - hingeBottom) .constrain(constraints) // Place the composable below the hinge val placeable = measurable.measure(childConstraints) placeable.place(0, hingeBottom) } }And with that, weâ€™ll have a beautiful animated adaptive experience!Note: Generally, providing functionality only when in tabletop mode would be considered a bad practice, so youâ€™d have to make sure the control panel is available in non-tabletop mode as well. Iâ€™ll leave that for you to implement ðŸ™‚ConclusionBy combining the adaptive and animation APIs, we can build powerful adaptive applications that add foldable support with delightful transitions.The principle demonstrated in this blog post can of course be generalized into a separate composable component, so it can be reused across screens.You can find the full code snippet here. And with that, weâ€™ve concluded our journey of exploring the power of CameraX and Compose! Weâ€™ve built a basic camera preview, added tap-to-focus functionality, overlaid a dynamic spotlight effect, and finally, made our app adaptive and beautiful on foldable devices.We hope you enjoyed this blog series, and that it inspires you to create amazing camera experiences with Jetpack Compose. Remember to check the docs for the latest updates!Happy coding, and thanks for joining us!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Ay6Qn6hYSX4FzqZFWv2Nkw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"a500\"\u003ePart 4 of Unlocking the Power of CameraX in Jetpack Compose\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@lojanda?source=post_page---byline--f57d77696e0f---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Jolanda Verhoef\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*XXxKnGkW5RkuVemStEYjdw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page---byline--f57d77696e0f---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"2475\"\u003eWelcome back to the final part of our blog post series about harnessing the power of CameraX and Compose. In the previous posts, weâ€™ve created a camera preview screen with tap-to-focus and spotlight effect. Now, we will take our viewfinder and expand it to the larger screen!\u003c/p\u003e\u003cul\u003e\u003cli id=\"806c\"\u003e\u003cstrong\u003eðŸ§± \u003c/strong\u003e\u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/getting-started-with-camerax-in-jetpack-compose-781c722ca0c4\"\u003e\u003cstrong\u003ePart 1\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e:\u003c/strong\u003e Building a basic camera preview using the new camera-compose artifact. We covered permission handling and basic integration.\u003c/li\u003e\u003cli id=\"5285\"\u003e\u003cstrong\u003eðŸ‘† \u003c/strong\u003e\u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/tap-to-focus-mastering-camerax-transformations-in-jetpack-compose-440853280a6e\"\u003e\u003cstrong\u003ePart 2\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e:\u003c/strong\u003e Using the Compose gesture system, graphics, and coroutines to implement a visual tap-to-focus.\u003c/li\u003e\u003cli id=\"a38d\"\u003e\u003cstrong\u003eðŸ”¦ \u003c/strong\u003e\u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/create-a-spotlight-effect-with-camerax-and-jetpack-compose-8a7fa5b76641\"\u003e\u003cstrong\u003ePart 3\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e: \u003c/strong\u003eExploring how to overlay Compose UI elements on top of your camera preview for a richer user experience.\u003c/li\u003e\u003cli id=\"d336\"\u003e\u003cstrong\u003eðŸ“‚ Part 4 (this post): \u003c/strong\u003eUsing adaptive APIs and the Compose animation framework to smoothly animate to and from tabletop mode on foldable phones.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"69ca\"\u003eThis post shows how to create a UI that elegantly transitions between a full-screen and a split-screen layout when a foldable device enters tabletop mode. We can use Composeâ€™s animation APIs to smoothly animate this transition.\u003c/p\u003e\u003cp id=\"64f3\"\u003eHereâ€™s the final result:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5684\"\u003eBuilding upon the concepts and code from the previous posts, weâ€™ll accomplish this in five logical steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"1fff\"\u003eUpdate our dependencies to use the latest animation and adaptive APIs.\u003c/li\u003e\u003cli id=\"5450\"\u003eRetrieve and share the hinge coordinates of our foldable device.\u003c/li\u003e\u003cli id=\"f5ef\"\u003ePosition the camera viewfinder above the fold when the device is in tabletop mode.\u003c/li\u003e\u003cli id=\"f68f\"\u003eAnimate the transition between full-screen and top-half only viewfinder.\u003c/li\u003e\u003cli id=\"8728\"\u003eCreate supporting content to display in the bottom half of the screen when in tabletop mode.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"b91e\"\u003e\u003cem\u003eNote; you can follow along step by step, continuing with the code from the \u003c/em\u003e\u003ca href=\"https://gist.github.com/JolandaVerhoef/74d4696b804736c698450bd34b5c9ff8#file-3_spotlight_effect-kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ethird blog post\u003c/em\u003e\u003c/a\u003e\u003cem\u003e, or check out the final code snippet \u003c/em\u003e\u003ca href=\"https://gist.github.com/JolandaVerhoef/74d4696b804736c698450bd34b5c9ff8#file-4_tabletop_mode-kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehere\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"7bc0\"\u003eAdd and update dependencies\u003c/h2\u003e\u003cp id=\"5d9a\"\u003eThis post takes advantage of some newer APIs, so we need to make sure to update our dependencies to their latest versions. We will use the brand new \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.ui.Modifier).animateBounds(androidx.compose.ui.layout.LookaheadScope,androidx.compose.ui.Modifier,androidx.compose.animation.BoundsTransform,kotlin.Boolean)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eanimateBounds\u003c/a\u003e\u003c/code\u003e API, introduced in Compose 1.8.\u003c/p\u003e\u003cp id=\"9e8d\"\u003eWeâ€™ll also add a dependency on \u003ccode\u003ematerial3-adaptive\u003c/code\u003e, the artifact that helps us deal with foldable concepts such as tabletop mode and physical device hinges:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9ada\"\u003e#libs.versions.toml\u003cp\u003e[versions]\u003cbr/\u003ekotlin = \u0026#34;2.1.20\u0026#34;\u003cbr/\u003ecomposeBom = \u0026#34;2025.03.01\u0026#34;\u003cbr/\u003ecamerax = \u0026#34;1.5.0-alpha06\u0026#34;\u003cbr/\u003eaccompanist = \u0026#34;0.37.2\u0026#34;\u003cbr/\u003e..\u003c/p\u003e\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-compose-bom = { group = \u0026#34;androidx.compose\u0026#34;, name = \u0026#34;compose-bom-beta\u0026#34;, version.ref = \u0026#34;composeBom\u0026#34; }\u003cbr/\u003eandroidx-material3-adaptive = { group = \u0026#34;androidx.compose.material3.adaptive\u0026#34;, name = \u0026#34;adaptive\u0026#34; }\u003cbr/\u003e..\u003c/p\u003e\u003cp\u003e#build.gradle.kts\u003cbr/\u003e..\u003cbr/\u003edependencies {\u003cbr/\u003e  ..\u003cbr/\u003e  implementation(libs.androidx.material3.adaptive)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"19c3\"\u003eProvide foldable hinge information with rulers\u003c/h2\u003e\u003cp id=\"271c\"\u003eWeâ€™re aiming to align our UI components based on the position of the foldableâ€™s hinge. Because foldables come in many shapes and forms, we should align our UI to the actual position of the top and bottom of the hinge, instead of simply breaking up the screen into two parts.\u003c/p\u003e\u003cp id=\"ac85\"\u003e\u003cem\u003eNote: Most foldables have a single display that runs across the hinge. In that case the hinge is simply a horizontal line, so its top and bottom coordinate would be equal. However, some foldables have two separate displays with some small space between them. That space still takes up layouting space, and you can still draw things in that non-existent space.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"2237\"\u003eBasically, we want to know the top and the bottom y-coordinate of the first horizontal hinge:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1472\"\u003eAlso, we likely want to use the same pattern in more screens in our app, so any screen can use this information when needed.\u003c/p\u003e\u003cp id=\"1059\"\u003eTo provide the hinge position for the whole composable sub-tree, we can use \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/Ruler\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003erulers\u003c/em\u003e\u003c/a\u003e, a new UI concept introduced in Compose 1.7.0. By defining a horizontal ruler and providing it from the root of our UI hierarchy, any UI component can then use that ruler to align itself or its children to.\u003c/p\u003e\u003cp id=\"0875\"\u003eSince hinges can have a non-zero thickness, letâ€™s provide two horizontal rulers, one for the top and one for the bottom y-coordinate of the first horizontal hinge. Weâ€™ll retrieve the actual coordinates by using the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/adaptive/package-summary#currentWindowAdaptiveInfo()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecurrentWindowAdaptiveInfo\u003c/a\u003e\u003c/code\u003e method in \u003ccode\u003ematerial3-adaptive\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"748e\"\u003eval HorizontalHingeTopRuler = HorizontalRuler()\u003cbr/\u003eval HorizontalHingeBottomRuler = HorizontalRuler()\u003cp\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        enableEdgeToEdge()\u003cbr/\u003e        setContent {\u003cbr/\u003e            MyApplicationTheme {\u003cbr/\u003e                val viewModel = remember { CameraPreviewViewModel() }\u003cbr/\u003e                val horizontalHinge = currentWindowAdaptiveInfo().windowPosture\u003cbr/\u003e                    .allHorizontalHingeBounds.firstOrNull()\u003cbr/\u003e                Box(\u003cbr/\u003e                    Modifier.layout { measurable, constraints -\u0026gt;\u003cbr/\u003e                        val placeable = measurable.measure(constraints)\u003cbr/\u003e                        layout(\u003cbr/\u003e                            width = constraints.maxWidth,\u003cbr/\u003e                            height = constraints.maxHeight,\u003cbr/\u003e                            rulers = {\u003cbr/\u003e                                if (horizontalHinge != null) {\u003cbr/\u003e                                    val bounds = coordinates.windowToLocal(horizontalHinge)\u003cbr/\u003e                                    HorizontalHingeTopRuler provides bounds.top\u003cbr/\u003e                                    HorizontalHingeBottomRuler provides bounds.bottom\u003cbr/\u003e                                }\u003cbr/\u003e                            }\u003cbr/\u003e                        ) { placeable.place(0, 0) }\u003cbr/\u003e                    }\u003cbr/\u003e                ) {\u003cbr/\u003e                    CameraPreviewScreen(viewModel)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eprivate fun LayoutCoordinates.windowToLocal(rect: Rect): Rect =\u003cbr/\u003e    Rect(\u003cbr/\u003e        topLeft = windowToLocal(rect.topLeft),\u003cbr/\u003e        bottomRight = windowToLocal(rect.bottomRight),\u003cbr/\u003e    )\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a687\"\u003eAdapt camera viewfinder to tabletop posture\u003c/h2\u003e\u003cp id=\"d949\"\u003eIf you remember, in our last post, we simply showed a full screen camera viewfinder. That doesnâ€™t look great while our foldable device is in tabletop mode:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2275\"\u003eSo, letâ€™s wrap our viewfinder inside a container, and make sure that that container shows only at the top half of the screen when the device is in tabletop mode:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b131\"\u003eAs part of this, weâ€™ll extract all code from the previous blog post into its own \u003ccode\u003eViewfinderContent\u003c/code\u003e composable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"72e3\"\u003e@Composable\u003cbr/\u003efun CameraPreviewContent(\u003cbr/\u003e    viewModel: CameraPreviewViewModel,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current\u003cbr/\u003e) {\u003cbr/\u003e    val surfaceRequest by viewModel.surfaceRequest.collectAsStateWithLifecycle()\u003cbr/\u003e    val sensorFaceRects by viewModel.sensorFaceRects.collectAsStateWithLifecycle()\u003cbr/\u003e    val context = LocalContext.current\u003cbr/\u003e    LaunchedEffect(lifecycleOwner) {\u003cbr/\u003e        viewModel.bindToCamera(context.applicationContext, lifecycleOwner)\u003cbr/\u003e    }\u003cbr/\u003e    val shouldHighlightFaces by remember {\u003cbr/\u003e        derivedStateOf { sensorFaceRects.isNotEmpty() }\u003cbr/\u003e    }\u003cp\u003e    val spotlightColor = Color(0xFFE60991)\u003c/p\u003e\u003cp\u003e    val windowPosture = currentWindowAdaptiveInfo().windowPosture\u003cbr/\u003e    val isTabletop: Boolean = windowPosture.isTabletop\u003c/p\u003e\u003cp\u003e    Box(modifier.safeDrawingPadding()) {\u003cbr/\u003e        ViewfinderContent(\u003cbr/\u003e            surfaceRequest,\u003cbr/\u003e            { sensorFaceRects },\u003cbr/\u003e            shouldHighlightFaces: Boolean,\u003cbr/\u003e            viewModel::tapToFocus,\u003cbr/\u003e            Modifier\u003cbr/\u003e                .fillMaxSize()\u003cbr/\u003e                .then(if (isTabletop) Modifier.alignAboveHinge() else Modifier)\u003cbr/\u003e                .padding(16.dp)\u003cbr/\u003e                .clip(RoundedCornerShape(24.dp))\u003cbr/\u003e                .border(8.dp, spotlightColor, RoundedCornerShape(24.dp))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Place the composable above the horizontal hinge, if a hinge is present.\u003cbr/\u003e// Ruler values are only available during the placement phase, so this modifier\u003cbr/\u003e// *measures* with max constraints, and then *places* the content above the hinge.\u003cbr/\u003eprivate fun Modifier.alignAboveHinge(): Modifier = this then\u003cbr/\u003e    Modifier.layout { measurable, constraints -\u0026gt;\u003cbr/\u003e        layout(constraints.maxWidth, constraints.maxHeight) {\u003cbr/\u003e            // Get current hinge top, or NaN if not available\u003cbr/\u003e            val hingeTop = HorizontalHingeTopRuler.current(defaultValue = Float.NaN)\u003c/p\u003e\u003cp\u003e            // Constrain the height of the composable to the hinge top (if available)\u003cbr/\u003e            val childConstraints = if (hingeTop.isNaN()) constraints else\u003cbr/\u003e                Constraints(maxHeight = hingeTop.roundToInt()).constrain(constraints)\u003c/p\u003e\u003cp\u003e            // Place the composable above the hinge\u003cbr/\u003e            val placeable = measurable.measure(childConstraints)\u003cbr/\u003e            placeable.place(0, 0)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"09b4\"\u003eOne thing to note is that weâ€™ll only have access to the rulers once in the placement phase. So, in this case, we make the \u003ccode\u003eViewfinderContent\u003c/code\u003e composable measure with full constraints, but then place itself only above the hinge.\u003c/p\u003e\u003ch2 id=\"bee1\"\u003eAnimate transitions\u003c/h2\u003e\u003cp id=\"0dbf\"\u003eWe can improve this code by adding a smooth transition between the tabletop and flat modes of the device. Right now, when the user moves between these two states, the UI jumps from one version to the other, creating a jarring experience:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"8faf\"\u003eLuckily, we have the new animation APIs to add automatic transitions between the two states. With \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#%28androidx.compose.ui.Modifier%29.animateBounds%28androidx.compose.ui.layout.LookaheadScope,androidx.compose.ui.Modifier,androidx.compose.animation.BoundsTransform,kotlin.Boolean%29\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eModifier.animateBounds()\u003c/a\u003e\u003c/code\u003e (new in Compose 1.8), that is available for use within a \u003ccode\u003eLookaheadScope\u003c/code\u003e , you can automatically animate the bounds of a composable. Note that weâ€™ll need to add the \u003ccode\u003eLookaheadScope\u003c/code\u003e at the top level so the rulers take it into account, and then pass it on through the UI hierarchy using a composition local (as per \u003ca href=\"https://developer.android.com/develop/ui/compose/animation/shared-elements#understand-scopes\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"80a8\"\u003eval LocalLookaheadScope = compositionLocalOf\u0026lt;LookaheadScope?\u0026gt; { null }\u003cp\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e   override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        ..\u003cbr/\u003e        setContent {\u003cbr/\u003e            MyApplicationTheme {\u003cbr/\u003e                ..\u003cbr/\u003e                LookaheadScope {\u003cbr/\u003e                    CompositionLocalProvider(LocalLookaheadScope provides this) {\u003cbr/\u003e                        Box(\u003cbr/\u003e                            Modifier.layout { measurable, constraints -\u0026gt;\u003cbr/\u003e                                ..\u003cbr/\u003e                            }\u003cbr/\u003e                        ) {\u003cbr/\u003e                            CameraPreviewScreen(viewModel)\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@OptIn(ExperimentalSharedTransitionApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun CameraPreviewContent(\u003cbr/\u003e    viewModel: CameraPreviewViewModel,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current\u003cbr/\u003e) {\u003cbr/\u003e    ..\u003cbr/\u003e    val isTabletop: Boolean = windowPosture.isTabletop\u003c/p\u003e\u003cp\u003e    val lookaheadScope = LocalLookaheadScope.current\u003cbr/\u003e        ?: throw IllegalStateException(\u0026#34;No LookaheadScope found\u0026#34;)\u003c/p\u003e\u003cp\u003e    Box(modifier.safeDrawingPadding()) {\u003cbr/\u003e        ViewfinderContent(\u003cbr/\u003e            ..\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxSize()\u003cbr/\u003e                .then(if (isTabletop) Modifier.alignAboveHinge() else Modifier)\u003cbr/\u003e                .animateBounds(this@LookaheadScope)\u003cbr/\u003e                .padding(16.dp)\u003cbr/\u003e                .clip(RoundedCornerShape(24.dp))\u003cbr/\u003e                .border(8.dp, spotlightColor, RoundedCornerShape(24.dp))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"9dcf\"\u003eAdd a control panel\u003c/h2\u003e\u003cp id=\"071c\"\u003eNow that we have some extra space in our layout, we can add a control panel that shows or hides based on the tabletop mode. Here, we can use the \u003ccode\u003eAnimatedVisibility\u003c/code\u003e API to show or hide the panel, in combination with the same rulers as above to position the panel below the hinge:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6cd1\"\u003e@OptIn(ExperimentalSharedTransitionApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun CameraPreviewContent(\u003cbr/\u003e    ..\u003cbr/\u003e) {\u003cbr/\u003e    ..\u003cp\u003e   val colors = listOf(Color(0xFF09D8E6), Color(0xFFE6C709), Color(0xFFE60991))\u003cbr/\u003e   var pickedColorIndex by rememberSaveable { mutableIntStateOf(0) }\u003cbr/\u003e   val onColorIndexChanged = { index: Int -\u0026gt; pickedColorIndex = index }\u003cbr/\u003e   val spotlightColor by animateColorAsState(colors[pickedColorIndex])\u003c/p\u003e\u003cp\u003e   Box(modifier.safeDrawingPadding()) {\u003cbr/\u003e        ViewfinderContent(\u003cbr/\u003e            ..\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e        AnimatedVisibility(\u003cbr/\u003e            isTabletop,\u003cbr/\u003e            enter = fadeIn() + slideInVertically { it / 2 },\u003cbr/\u003e            exit = fadeOut() + slideOutVertically { it / 2 },\u003cbr/\u003e            modifier = Modifier.alignBelowHinge()\u003cbr/\u003e        ) {\u003cbr/\u003e            MyControlPanel(\u003cbr/\u003e                colors = colors,\u003cbr/\u003e                pickedColorIndex = pickedColorIndex,\u003cbr/\u003e                onColorPicked = onColorIndexChanged,\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Place the composable below the horizontal hinge, if a hinge is present.\u003cbr/\u003e// Ruler values are only available during the placement phase, so this modifier\u003cbr/\u003e// *measures* with max constraints, and then *places* the content below the hinge.\u003cbr/\u003eprivate fun Modifier.alignBelowHinge(): Modifier = this then\u003cbr/\u003e    Modifier.layout { measurable, constraints -\u0026gt;\u003cbr/\u003e        layout(constraints.maxWidth, constraints.maxHeight) {\u003cbr/\u003e            // Get current hinge bottom, or default to 0 if not available\u003cbr/\u003e            val hingeBottom = HorizontalHingeBottomRuler.current(defaultValue = 0f).roundToInt()\u003c/p\u003e\u003cp\u003e            // Constrain the height of the composable to the hinge bottom (if available)\u003cbr/\u003e            val childConstraints = Constraints(maxHeight = constraints.maxHeight - hingeBottom)\u003cbr/\u003e                    .constrain(constraints)\u003c/p\u003e\u003cp\u003e            // Place the composable below the hinge\u003cbr/\u003e            val placeable = measurable.measure(childConstraints)\u003cbr/\u003e            placeable.place(0, hingeBottom)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"14e4\"\u003eAnd with that, weâ€™ll have a beautiful animated adaptive experience!\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"6256\"\u003e\u003cstrong\u003e\u003cem\u003eNote:\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e \u003c/em\u003eGenerally, providing functionality only when in tabletop mode would be considered a bad practice, so youâ€™d have to make sure the control panel is available in non-tabletop mode as well. Iâ€™ll leave that for you to implement ðŸ™‚\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"93fa\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"f32e\"\u003eBy combining the adaptive and animation APIs, we can build powerful adaptive applications that add foldable support with delightful transitions.\u003c/p\u003e\u003cp id=\"1404\"\u003eThe principle demonstrated in this blog post can of course be generalized into a separate composable component, so it can be reused across screens.\u003c/p\u003e\u003cp id=\"74e4\"\u003eYou can find the full code snippet \u003ca href=\"https://gist.github.com/JolandaVerhoef/74d4696b804736c698450bd34b5c9ff8#file-4_tabletop_mode-kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e. And with that, weâ€™ve concluded our journey of exploring the power of CameraX and Compose! Weâ€™ve built a basic camera preview, added tap-to-focus functionality, overlaid a dynamic spotlight effect, and finally, made our app adaptive and beautiful on foldable devices.\u003c/p\u003e\u003cp id=\"1e52\"\u003eWe hope you enjoyed this blog series, and that it inspires you to create amazing camera experiences with Jetpack Compose. Remember to check the docs for the latest updates!\u003c/p\u003e\u003cp id=\"650e\"\u003eHappy coding, and thanks for joining us!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-04-08T16:03:14.387Z",
  "modifiedTime": null
}
