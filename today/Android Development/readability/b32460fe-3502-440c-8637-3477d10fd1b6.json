{
  "id": "b32460fe-3502-440c-8637-3477d10fd1b6",
  "title": "It's about time",
  "link": "https://chrynan.codes/its-about-time/",
  "description": "Taking a look through time, a new Kotlin multi-platform library",
  "author": "Christopher Keenan",
  "published": "Wed, 12 Feb 2020 22:01:00 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "time",
    "kotlin",
    "kotlin-library",
    "kotlin-multiplatform",
    "kotlin multiplatform",
    "kotlin multi-platform",
    "time library",
    "time-lib",
    "time-library",
    "java time",
    "java.time",
    "moment",
    "duration"
  ],
  "byline": "Christopher Keenan",
  "length": 6551,
  "excerpt": "Taking a look through time, a new Kotlin multi-platform library",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Taking a look through time, a new Kotlin multi-platform library Feb 12, 2020 • 4 min read People like us, who believe in physics, know that the distinction between past, present, and future is only a stubbornly persistent illusion.-- Albert EinsteinTime representation is a necessity for nearly all applications. The ability to display, reference, track, and manipulate moments of time plays an important role in the development of applications. But when developing a Kotlin multi-platform application, this becomes a difficult task, as there is no notion of a moment of time in the standard library. Waiting for one to be added would be a waste of time, so I decided to create one. This article takes an early look at this new library that is still in development.TL;DRIntroducing a new Kotlin multi-platform time library.The libraryKotlin does provide a new experimental duration class which serves as a period of time, but no notion of a moment, or instant, of time. There is already a promising Kotlin multi-platform library called Klock, but this doesn't make use of the new experimental Duration class. So I created a library that expands on the Duration class by provided a Moment interface. These Moments are obtained by a TimeProvider. Getting this correct was pretty difficult and took some time, but, while the library is still in the early stages of development, I am pretty satisfied with the API and it's ease of use. Let's have a look.TimeProvider The TimeProvider interface is the entry point to doing anything time related, such as, obtaining a specific Moment in time. val now = timeProvider.now() val later = now + 20.minutes val tomorrow = timeProvider.tomorrow() val diffDuration = later to tomorrow Any Moment in time can be obtained by using the TimeProvider.moment() function and providing the Duration since the epoch as a parameter. Moments in time for a specific Time Zone can be retrieved by passing in a TimeZoneRegionId. Without passing in a TimeZoneRegionId, the default is used, by accessing the TimeZoneOffsetProvider.defaultTimeZoneRegionId property that is available to the TimeProvider. val moment = timeProvider.moment( durationSinceEpoch = 20_000.hours, regionId = TimeZoneRegionId(\"America/New_York\")) Each platform target is responsible for providing their own implementation of the TimeProvider interface. For instance, the jvmMain source set provides a JavaTimeProvider implementation. This implementation delegates to the java.time classes. Then each platform can provide their own platform specific implementations and the Kotlin common code can just reference the interfaces, such as, TimeProvider.@Provides fun provideTimeProvider(): TimeProvider = JavaTimeProvider(locale = Locale.getDefault()) MomentThe Moment interface represents an instant of time, as a duration since the epoch, with a TimeOffset from UTC for a specified TimeZoneRegionId and it's corresponding rules (daylight savings time, etc). A Moment can also represent UTC/GMT time which has an offset equal to zero, and which can be retrieved for any Moment using the Moment.toUtc() function. Kotlin Durations can be added or subtracted from a Moment, and a Duration between two Moments can be retrieved using the to infix function. Also, CalendarDate and TimeOfDay objects can be retrieved from the Moment instance.val yesterday = timeProvider.yesterday() val later = timeProvider.now() + 3.hours val duration = yesterday to later val date = later.calendarDate val time = later.timeOfDay CalendarDateThe CalendarDate class represents the date of a Moment in a calendar year with no information about the time within the day.val date = moment.calendarDate date.year date.month date.dayInYear date.dayInMonth date.dayOfWeek TimeOfDayThe TimeOfDay class is similar to CalendarDate but instead of providing information about the date within a calendar year, it provides information about the time within a calendar date.val time = moment.timeOfDay time.elapsedDurationInDay time.minuteInHour time.secondInMinute time.millisecondInSecond time.hourInDay(ClockConvention.TWENTY_FOUR_HOUR_CLOCK) Parsing and FormattingThe library comes with two interfaces, MomentFormatter and MomentParser, which provide a way to transform a Moment into a String for a particular pattern and vice-versa. These can be obtained from the TimeProvider interface.val formatter = timeProvider.formatter(MomentFormatPattern(\"MM/dd/yyyy\")) val string = formatter.format(timeProvider.now()) val parser = timeProvider.parser(MomentFormatPattern(\"MM/dd/yyyy\")) val moment = parser.parse(\"2/12/2020\") JSONOne idea of the library is to have JSON serializers, for popular JSON parsing libaries, that handle common time formats. This way it is simple to pass Moments between components. These aren't implemented yet, as of writing this article, but I imagine that they would reside in their own modules per library supported. Why not mimic java.time?There are some similarities between the two libraries and java.time has provided some inspiration in the development of this library. But there seems to be a common source of confusion for the components within the java.time library, such as, OffsetDateTime, ZonedDateTime, LocalDateTime, and Instant. I wanted to avoid this confusion for a casual user of the library and wanted to provide a more Kotlin-esque API. For this reason, the Moment interface was created, which acts similar to a combination of the OffsetDateTime, ZonedDateTime, and Instant classes. The CalendarDateAndTime class corresponds to Java Time's LocalDateTime class. And a new interface was created, TimeProvider, that acts as a single source for everything time related.RecapitulateThis new library, still in the early stages of development, provides a promising vision of working with time within Kotlin multi-platform code. Still, implementations need to be finalized, tests need to be written, and other platforms need to be targeted. And since the library uses the experimental Duration class, the library is experimental as well. The implementation of time related code isn't as trivial as one might expect, but, overall, the future of this Kotlin time library looks bright, however, only time will tell.",
  "image": "https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eTaking a look through time, a new Kotlin multi-platform library\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \u003cdiv\u003e\n                \n                \u003cp\u003e\u003ctime datetime=\"2020-02-12\"\u003eFeb 12, 2020\u003c/time\u003e\n                        \u003cspan\u003e\u003cspan\u003e•\u003c/span\u003e 4 min read\u003c/span\u003e\n                \u003c/p\u003e\n            \u003c/div\u003e\n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=300 300w,\n                            https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=600 600w,\n                            https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=1000 1000w,\n                            https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000\" alt=\"It\u0026#39;s about time\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cblockquote\u003ePeople like us, who believe in physics, know that the distinction between past, present, and future is only a stubbornly persistent illusion.\u003c/blockquote\u003e\u003cp\u003e-- \u003ca href=\"https://en.wikiquote.org/wiki/Albert_Einstein?ref=chrynan.codes\"\u003eAlbert Einstein\u003c/a\u003e\u003c/p\u003e\u003cp\u003eTime representation is a necessity for nearly all applications. The ability to display, reference, track, and manipulate moments of time plays an important role in the development of applications. But when developing a Kotlin multi-platform application, this becomes a difficult task, as there is no notion of a moment of time in the standard library. Waiting for one to be added would be a waste of time, so I decided to create one. This article takes an early look at this new library that is still in development.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eIntroducing a new Kotlin multi-platform \u003ca href=\"https://github.com/chRyNaN/time?ref=chrynan.codes\"\u003etime library\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"the-library\"\u003eThe library\u003c/h3\u003e\u003cp\u003eKotlin does provide a new experimental \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html?ref=chrynan.codes\"\u003eduration class\u003c/a\u003e which serves as a period of time, but no notion of a moment, or instant, of time. There is already a promising Kotlin multi-platform library called \u003ca href=\"https://github.com/korlibs/klock?ref=chrynan.codes\"\u003eKlock\u003c/a\u003e, but this doesn\u0026#39;t make use of the new experimental Duration class. So I created a library that expands on the Duration class by provided a \u003ccode\u003eMoment\u003c/code\u003e interface. These \u003ccode\u003eMoments\u003c/code\u003e are obtained by a \u003ccode\u003eTimeProvider\u003c/code\u003e. Getting this correct was pretty difficult and took some time, but, while the library is still in the early stages of development, I am pretty satisfied with the API and it\u0026#39;s ease of use. Let\u0026#39;s have a look.\u003c/p\u003e\u003ch3 id=\"timeprovider\"\u003eTimeProvider \u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eTimeProvider\u003c/code\u003e interface is the entry point to doing anything time related, such as, obtaining a specific \u003ccode\u003eMoment\u003c/code\u003e in time. \u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval now = timeProvider.now()\n\nval later = now + 20.minutes\n\nval tomorrow = timeProvider.tomorrow()\n\nval diffDuration = later to tomorrow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny \u003ccode\u003eMoment\u003c/code\u003e in time can be obtained by using the \u003ccode\u003eTimeProvider.moment()\u003c/code\u003e function and providing the \u003ccode\u003eDuration\u003c/code\u003e since the epoch as a parameter. Moments in time for a specific Time Zone can be retrieved by passing in a \u003ccode\u003eTimeZoneRegionId\u003c/code\u003e. Without passing in a \u003ccode\u003eTimeZoneRegionId\u003c/code\u003e, the default is used, by accessing the \u003ccode\u003eTimeZoneOffsetProvider.defaultTimeZoneRegionId\u003c/code\u003e property that is available to the \u003ccode\u003eTimeProvider\u003c/code\u003e. \u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval moment = timeProvider.moment(\n        durationSinceEpoch = 20_000.hours,\n        regionId = TimeZoneRegionId(\u0026#34;America/New_York\u0026#34;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach platform target is responsible for providing their own implementation of the \u003ccode\u003eTimeProvider\u003c/code\u003e interface. For instance, the \u003ccode\u003ejvmMain\u003c/code\u003e source set provides a \u003ccode\u003eJavaTimeProvider\u003c/code\u003e implementation. This implementation delegates to the \u003ccode\u003ejava.time\u003c/code\u003e classes. Then each platform can provide their own platform specific implementations and the Kotlin common code can just reference the interfaces, such as, \u003ccode\u003eTimeProvider\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Provides\nfun provideTimeProvider(): TimeProvider = JavaTimeProvider(locale = Locale.getDefault())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"moment\"\u003eMoment\u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eMoment\u003c/code\u003e interface represents an instant of time, as a duration since the epoch, with a \u003ccode\u003eTimeOffset\u003c/code\u003e from \u003ca href=\"https://en.wikipedia.org/wiki/Coordinated_Universal_Time?ref=chrynan.codes\"\u003eUTC\u003c/a\u003e for a specified \u003ccode\u003eTimeZoneRegionId\u003c/code\u003e and it\u0026#39;s corresponding rules (daylight savings time, etc). A \u003ccode\u003eMoment\u003c/code\u003e can also represent UTC/GMT time which has an offset equal to zero, and which can be retrieved for any \u003ccode\u003eMoment\u003c/code\u003e using the \u003ccode\u003eMoment.toUtc()\u003c/code\u003e function. \u003c/p\u003e\u003cp\u003eKotlin \u003ccode\u003eDurations\u003c/code\u003e can be added or subtracted from a \u003ccode\u003eMoment\u003c/code\u003e, and a \u003ccode\u003eDuration\u003c/code\u003e between two \u003ccode\u003eMoments\u003c/code\u003e can be retrieved using the \u003ccode\u003eto\u003c/code\u003e infix function. Also, \u003ccode\u003eCalendarDate\u003c/code\u003e and \u003ccode\u003eTimeOfDay\u003c/code\u003e objects can be retrieved from the \u003ccode\u003eMoment\u003c/code\u003e instance.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval yesterday = timeProvider.yesterday()\n\nval later = timeProvider.now() + 3.hours\n\nval duration = yesterday to later\n\nval date = later.calendarDate\nval time = later.timeOfDay\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"calendardate\"\u003eCalendarDate\u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eCalendarDate\u003c/code\u003e class represents the date of a \u003ccode\u003eMoment\u003c/code\u003e in a calendar year with no information about the time within the day.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval date = moment.calendarDate\n\ndate.year\ndate.month\ndate.dayInYear\ndate.dayInMonth\ndate.dayOfWeek\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"timeofday\"\u003eTimeOfDay\u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eTimeOfDay\u003c/code\u003e class is similar to \u003ccode\u003eCalendarDate\u003c/code\u003e but instead of providing information about the date within a calendar year, it provides information about the time within a calendar date.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval time = moment.timeOfDay\n\ntime.elapsedDurationInDay\ntime.minuteInHour\ntime.secondInMinute\ntime.millisecondInSecond\ntime.hourInDay(ClockConvention.TWENTY_FOUR_HOUR_CLOCK)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"parsing-and-formatting\"\u003eParsing and Formatting\u003c/h3\u003e\u003cp\u003eThe library comes with two interfaces, \u003ccode\u003eMomentFormatter\u003c/code\u003e and \u003ccode\u003eMomentParser\u003c/code\u003e, which provide a way to transform a \u003ccode\u003eMoment\u003c/code\u003e into a \u003ccode\u003eString\u003c/code\u003e for a particular pattern and vice-versa. These can be obtained from the \u003ccode\u003eTimeProvider\u003c/code\u003e interface.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval formatter = timeProvider.formatter(MomentFormatPattern(\u0026#34;MM/dd/yyyy\u0026#34;))\n\nval string = formatter.format(timeProvider.now())\n\nval parser = timeProvider.parser(MomentFormatPattern(\u0026#34;MM/dd/yyyy\u0026#34;))\n\nval moment = parser.parse(\u0026#34;2/12/2020\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"json\"\u003eJSON\u003c/h3\u003e\u003cp\u003eOne idea of the library is to have JSON serializers, for popular JSON parsing libaries, that handle common time formats. This way it is simple to pass \u003ccode\u003eMoments\u003c/code\u003e between components. These aren\u0026#39;t implemented yet, as of writing this article, but I imagine that they would reside in their own modules per library supported. \u003c/p\u003e\u003ch3 id=\"why-not-mimic-java-time\"\u003eWhy not mimic java.time?\u003c/h3\u003e\u003cp\u003eThere are some similarities between the two libraries and \u003ccode\u003ejava.time\u003c/code\u003e has provided some inspiration in the development of this library. But there seems to be a common source of confusion for the components within the \u003ccode\u003ejava.time\u003c/code\u003e library, such as, \u003ccode\u003eOffsetDateTime\u003c/code\u003e, \u003ccode\u003eZonedDateTime\u003c/code\u003e, \u003ccode\u003eLocalDateTime\u003c/code\u003e, and \u003ccode\u003eInstant\u003c/code\u003e. I wanted to avoid this confusion for a casual user of the library and wanted to provide a more Kotlin-esque API. For this reason, the \u003ccode\u003eMoment\u003c/code\u003e interface was created, which acts similar to a combination of the \u003ccode\u003eOffsetDateTime\u003c/code\u003e, \u003ccode\u003eZonedDateTime\u003c/code\u003e, and \u003ccode\u003eInstant\u003c/code\u003e classes. The \u003ccode\u003eCalendarDateAndTime\u003c/code\u003e class corresponds to Java Time\u0026#39;s \u003ccode\u003eLocalDateTime\u003c/code\u003e class. And a new interface was created, \u003ccode\u003eTimeProvider\u003c/code\u003e, that acts as a single source for everything time related.\u003c/p\u003e\u003ch3 id=\"recapitulate\"\u003eRecapitulate\u003c/h3\u003e\u003cp\u003eThis new \u003ca href=\"https://github.com/chRyNaN/time?ref=chrynan.codes\"\u003elibrary\u003c/a\u003e, still in the early stages of development, provides a promising vision of working with time within Kotlin multi-platform code. Still, implementations need to be finalized, tests need to be written, and other platforms need to be targeted. And since the library uses the experimental \u003ccode\u003eDuration\u003c/code\u003e class, the library is experimental as well. The implementation of time related code isn\u0026#39;t as trivial as one might expect, but, overall, the future of this Kotlin time library looks bright, however, only time will tell.\u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2020-02-12T22:01:00Z",
  "modifiedTime": "2020-02-12T22:01:00Z"
}
