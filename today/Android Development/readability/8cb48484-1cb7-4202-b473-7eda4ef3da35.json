{
  "id": "8cb48484-1cb7-4202-b473-7eda4ef3da35",
  "title": "Adding Compose to Existing Espresso Tests with createEmptyComposeRule()",
  "link": "https://handstandsam.com/2023/04/12/adding-compose-to-existing-espresso-tests-with-createemptycomposerule/",
  "description": "As the documentation says, you can combine both Espresso and Compose in an Android instrumentation test. In order to interact with Compose in an instrumentation test you need a ComposeTestRule. Problem Typically you would create a ComposeTestRule with createComposeRule() in a part of your app that is compose only, but that will create a blank [â€¦]",
  "author": "Sam Edwards",
  "published": "Wed, 12 Apr 2023 13:46:30 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Updates"
  ],
  "byline": "Sam Edwards Published April 12, 2023",
  "length": 1373,
  "excerpt": "As the documentation says, you can combine both Espresso and Compose in an Android instrumentation test. In order to interact with Compose in an instrumentation test you need a ComposeTestRule.",
  "siteName": "",
  "favicon": "",
  "text": "As the documentation says, you can combine both Espresso and Compose in an Android instrumentation test. In order to interact with Compose in an instrumentation test you need a ComposeTestRule. Problem Typically you would create a ComposeTestRule with createComposeRule() in a part of your app that is compose only, but that will create a blank ComponentActivity and launch it showing a blank screen. @get:Rule val composeTestRule = createComposeRule() This is great if you are looking to just use composeTestRule.setContent { Text(\"Hi\")} in your test, but if you are integrating with an existing Espresso test, this will not be the case. You could use the createAndroidComposeRule\u003cMyActivity\u003e(), however that will also use an ActivityTestRule underneath the hood and launch the Activity, which will change the behavior of your existing test. ðŸ¤” @get:Rule val composeTestRule = createAndroidComposeRule\u003cMyActivity\u003e() Solution If all you want to do is keep the Espresso test the same way it is, but also interact with some compose elements, use createEmptyComposeRule() and it will all work! ðŸŽ‰ @get:Rule val composeTestRule = createEmptyComposeRule() Conclusion Now you can interact with compose elements along with view elements, exactly like the documentation says. ðŸ˜ƒ composeTestRule.onNodeWithText(\"Something\").assertIsDisplayed()",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1985\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eAs the \u003ca href=\"https://developer.android.com/jetpack/compose/testing#espresso-interop\"\u003edocumentation says, you can combine both Espresso and Compose in an Android instrumentation test\u003c/a\u003e. In order to interact with \u003ca href=\"https://developer.android.com/jetpack/compose\"\u003eCompose\u003c/a\u003e in an instrumentation test you need a \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/ComposeTestRule\"\u003eComposeTestRule\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eProblem\u003c/h2\u003e\n\n\n\n\u003cp\u003eTypically you would create a \u003ccode\u003eComposeTestRule\u003c/code\u003e with \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/package-summary#createComposeRule()\"\u003ecreateComposeRule()\u003c/a\u003e\u003c/code\u003e in a part of your app that is compose only, but that will create a blank \u003ccode\u003eComponentActivity\u003c/code\u003e and launch it showing a blank screen.  \u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@get:Rule\nval composeTestRule = createComposeRule()\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is great if you are looking to just use \u003ccode\u003ecomposeTestRule.setContent { Text(\u0026#34;Hi\u0026#34;)}\u003c/code\u003e in your test, but if you are integrating with an existing Espresso test, this will not be the case.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou could use the \u003ccode\u003ecreateAndroidComposeRule\u0026lt;MyActivity\u0026gt;()\u003c/code\u003e, however that will also use an \u003ccode\u003eActivityTestRule\u003c/code\u003e underneath the hood and launch the Activity, which will change the behavior of your existing test. ðŸ¤”\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@get:Rule\nval composeTestRule = \u003cspan\u003ecreateAndroidComposeRule\u0026lt;MyActivity\u0026gt;()\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch2\u003eSolution\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf all you want to do is keep the Espresso test the same way it is, but also interact with some compose elements, use \u003ccode\u003ecreateEmptyComposeRule()\u003c/code\u003e and it will all work! ðŸŽ‰\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@get:Rule\nval composeTestRule = createEmptyComposeRule()\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow you can interact with compose elements along with view elements, exactly like \u003ca href=\"https://developer.android.com/jetpack/compose/testing\"\u003ethe documentation\u003c/a\u003e says. ðŸ˜ƒ\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003ecomposeTestRule.onNodeWithText(\u0026#34;Something\u0026#34;).assertIsDisplayed()\u003c/code\u003e\u003c/pre\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "2 min read",
  "publishedTime": null,
  "modifiedTime": null
}
