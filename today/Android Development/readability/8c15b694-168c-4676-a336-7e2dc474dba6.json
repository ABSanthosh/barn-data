{
  "id": "8c15b694-168c-4676-a336-7e2dc474dba6",
  "title": "Seamless Screenshot Testing for Compose with Screenshotbot",
  "link": "https://joebirch.co/android/seamless-screenshot-testing-for-compose-with-screenshotbot/",
  "description": "In a recent blog post I took a look at the new Compose Preview Screenshot Testing Tool, provided by Google as a way to enable developers to easily write screenshot tests for their composable UI. When it comes to screenshot testing, writing these tests only represents one part of the process – we also need... Continue reading →",
  "author": "hitherejoe",
  "published": "Thu, 20 Jun 2024 06:24:58 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Testing",
    "Android App Development",
    "Android Apps",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 16157,
  "excerpt": "In a recent blog post I took a look at the new Compose Preview Screenshot Testing Tool, provided by Google as a way to enable developers to easily write screenshot tests for their composable UI. When it comes to screenshot testing, writing these tests only represents one part of the process - we als",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "In a recent blog post I took a look at the new Compose Preview Screenshot Testing Tool, provided by Google as a way to enable developers to easily write screenshot tests for their composable UI. When it comes to screenshot testing, writing these tests only represents one part of the process – we also need to think about how we will slot this into our CI process, along with the management of our composable snapshots. In this post, we will be exploring Screenshotbot, which can help to alleviate some of the friction experienced when trying to integrate screenshot tests into your workflow. This is a commissioned blog post based on my experience using Screenshotbot Why Screenshotbot? So you may be thinking, why do I need another tool for my screenshot testing process? Well, as mentioned above, there are a couple of pain points which come with integrating screenshot testing into your development workflow. For the code on your main branch, you’re going to want to have snapshots that represent the expected state of your UI – this is so that we can compare the changes of our proposed work with that on main. The friction here is that we would need to manage this ourselves – we’d have to manually update the screenshots and commit them to our repository, while also only ensuring that this happens when there are expected changes to those parts of the UI. Alongside this management, we need to run the verification process and then communicate this on the PR for reviewers. To make it easy for reviewers to assess changes, we’d want to show a diff of the before/after state and ensure that we are doing this for each UI change within the PR. Depending on the screenshot testing framework being used, this would be both tricky and tedious to configure via manual scripting within your CI flow. Screenshotbot solves both of these issues by offering a plug-and-play tool that will capture, store and diff UI changes in your project. You do not need to write custom scripts to capture and update snapshots, or write scripts to surface diffs within pull requests, Screenshotbot will handle all of this for us. We simply need to add a plugin and optional GitHub app, and we’ll be able to access screenshot checks directly within our pull requests. Screenshotbot is also platform \u0026 framework agnostic, meaning that it only needs screenshots to operate. This means you can use one of the supported frameworks of the plugin (Compose Preview Screenshot Tests, Paparazzi, Roborazzi, Shot, screenshot-tests-for-android, Dropshots) or simply provide screenshots via your own screenshot testing tool, as long as Screenshotbot has access to screenshots then it will be able to perform diffs on your UI changes. With a generous free plan, it’s easy to get started and see if the tool is something that will work for you or your team. With that said, let’s take it for a spin and integrate it into a sample workflow. Setting up Screenshot Tests For this blog post, we’re going to be using Composable Preview Tests via the Compose Preview Testing Tool. We’re going to focus on the management of screenshot tests through Screenshotbot as opposed to creating tests. If you haven’t yet set up screenshot tests or are looking to learn more about the Compose Preview Testing Tool, please checkout a recent blog post of mine. In our sample project we have 2 simple composables – a Contact composable that displays the name of the contact, followed by a composable that displays a list of these contacts. @Composable fun MainScreen() { Scaffold( topBar = { TopAppBar(title = { Text(text = \"Contacts\") }) } ) { padding -\u003e LazyColumn( contentPadding = padding ) { items(ContactFactory.makeContacts()) { Contact(modifier = Modifier.fillMaxWidth(), contact = it) } } } } @Composable fun Contact(modifier: Modifier = Modifier, contact: Contact) { Surface { Row(modifier = modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) { Box( modifier = Modifier .background(contact.color, CircleShape) .size(48.dp), contentAlignment = Alignment.Center ) { Text( text = contact.name.first().uppercase(), color = Color.White, lineHeight = 0.sp ) } Spacer(modifier = Modifier.width(16.dp)) Text(text = contact.name) } } } We’ll also use composable previews to write two preview tests, allowing snapshots to be generated for our composable. @Preview(showBackground = true) @Composable fun ScreenPreview() { MaterialTheme { MainScreen() } } @Preview(showBackground = true) @Composable fun ContactPreview() { MaterialTheme { Contact(contact = Contact(\"Joe\", Color.Red)) } } With this in place, we now have some composables along with corresponding preview tests to take Screenshotbot for a spin. Setting Up Screenshot Bot Configuring the Android Project When it comes to integrating Screenshotbot into our project, there isn’t a lot that we need to do. First up, we need to add a plugin declaration to the root build.gradle file in our project – this will enable the use of Screenshotbot functionality. plugins { … id(\"io.screenshotbot.plugin\") version \"1.14\" } Next, we’ll need to add the plugin to the build.gradle file for every sub-module that contains screenshot tests. If every module contains screenshot tests then you can apply this globally from your root build.grade file, but I would recommend doing this at individual level. plugins { … id(\"io.screenshotbot.plugin\") } Once your project has synced and can built successfully, we will have everything in place to run Screenshotbot. Installing the GitHub App Because we’re going to be integrating Screenshotbot with our Pull Request flow, we’re going to want to install the Screenshotbot GitHub App – this will allow the tool to hook into the GitHub Checks API, which means we can show success/failed states for screenshot verification directly within our pull requests. Setting up the app is very straightforward and during project setup within Screenshotbot, you’ll be prompted to do so via the Install App on GitHub button. You’ll need to follow the on-screen instructions and then grant Screenshotbot access to your repository. Once complete, you will see verification that the setup was successful. Running Verification Checks When it comes to verifying our screenshots, we no longer need to use any existing commands from the testing framework we are using. Instead, we just need to run a single corresponding command from Screenshotbot. Because I am using the Compose Preview Testing Tool, I need to use the following command. ./gradlew recordAndVerifyDebugAndroidScreenshotbotCI When running this command, Screenshotbot will record the screenshots for the current branch and upload them to its server, which is where they will be compared with the existing snapshots. Once this flow has completed, we will be returned with a result that states a success or failure state.  While we can run this locally, we’re going to want to slot this into our CI process. I am going to be using GitHub Actions for my project, so I’ll go ahead and create a new Pull Request workflow. This workflow will run on any pull requests that are opened, as well as when any changes are pushed to the corresponding branch (while the PR is open). name: Pull Request on: pull_request: push: branches: - 'main' jobs: screenshots: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: fetch-depth: 0 - name: Set up JDK uses: actions/setup-java@v3 with: distribution: 'temurin' java-version: '17' cache: 'gradle' - name: Setup Android SDK uses: android-actions/setup-android@v2 We won’t go too deep into this workflow, but we’re simply checking out the branch of our repository and configuring the required frameworks (Java and Android), as this is required for any checks depending on these. Whenever this workflow is run, we’ll want to run the verification for our screenshots. name: Pull Request … jobs: screenshots: runs-on: ubuntu-latest steps: … - name: Run checks run: | ./gradlew recordAndVerifyDebugScreenshotTest However, this command alone is not enough.So that our script can communicate with our Screenshotbot account, we’re going to need to provide both an API key and secret that will allow API calls to be made on behalf of our account. We’ll need to start here by heading back on over to our Screenshotbot account, selecting API Keys from the sidebar, and then using the New API Key button to navigate to the key creation form. After creating our API key and secret, we’ll want to store these within GitHub Actions as action secrets. We’ll create two new secrets, SCREENSHOTBOT_API_KEY and SCREENSHOTBOT_API_SECRET, copying over the values generated in the previous step. We’ve these in place, we can now provide them as environment variables for our command. We’ll do this using the env property for our workflow step, passing the corresponding values for the key and secret value. name: Pull Request ... jobs: screenshots: runs-on: ubuntu-latest steps: ... - name: Run checks run: | ./gradlew recordAndVerifyDebugScreenshotTest env: SCREENSHOTBOT_API_KEY: ${{ secrets.SCREENSHOTBOT_API_KEY }} SCREENSHOTBOT_API_SECRET: ${{ secrets.SCREENSHOTBOT_API_SECRET }} Opening a Pull Request Now that Screenshotbot has been configured, we’re going to go and test the functionality in our repository. We’re going to purposefully create a failed state here, so we’ll start by changing the background colour of our Box composable to use Color.Red instead of the color property from the provided Contact reference. This will cause our screenshot tests to break, due to there now being a change in the styling of the Contact component. @Composable fun Contact(modifier: Modifier = Modifier, contact: Contact) { Surface { Row( … ) { Box( modifier = Modifier .background(Color.Red, CircleShape) .size(48.dp), contentAlignment = Alignment.Center ) { … } … } } } After this change has been committed and a pull request open, we’ll be able to see two checks running – the screenshots job that we created in our GitHub Action, along with the Screenshotbot app that is verifying our changes. The changes that we’ve made have purposefully broken the styling of our Contact component, and we can see that the Screenshotbot check has failed because of this. We’re going to want to inspect why these checks have failed, so we’ll click the Details link for Screenshotbot in our pull request checks. At this point, we’ll want to click Resolve – this will take us directly to the diff report for this commit within Screenshotbot.  Analysing changes Once we’ve clicked through to Screenshotbot from GitHub, we will be able to see the stored snapshots of our composable, along with the generated screenshot from our pull request.  Comparing Screenshots On the main screen of the commit, we’ll be able to see the before/after for our changes – hovering over the before state will also allow you to quickly flick between these states for comparison. If we want to inspect our changes in more detail, we can click the Compare link to open up a window that allows us to view scaled in diff, before and after versions of our changes. This is incredibly useful for being able to focus in on changes, especially where the overall diff image is a larger screenshot where it may be harder to work out change details. Once we’ve analysed the changes on this screen we’ll want to review them, meaning that we will either want to Accept or Reject them. If we reject these changes, the check will remain as failed until we push some more changes and the checks are run again. Otherwise, accepting the changes will mark the check as passed in our Pull Request, allowing the changes to be merged. Adding Notes In scenarios where the changes need some feedback, we can utilise the notes functionality in Screenshotbot which can be accessed through the More menu on the changes dashboard. After leaving a note, it will appear at the top of the changes dashboard which is incredibly visible to any viewers. If multiple comments are added, then these will appear stacked in the latest order. Notes are global for the changes in question. So if there are multiple comments, this will rely on the author making it clear what the comment applies to. Ideally, developers will create small PRs with focused changes, but this is going to be dependent on the workflows of the corresponding team. One nice addition here could be the ability to leave comments on specific parts of a change, as opposed to the comment being general to the overall change. Masking Screenshots In some cases, there may be parts of a screenshot that we want to ignore when verification is taking place. This is supported within Screenshotbot as Masks and allows us to highlight specific parts of screenshots that should not be counted towards comparisons. This could be useful in cases such as: Dynamic Content – such as timestamps, usernames or any kind of user-generated content. We can’t rely on this data always being the same between runs, so created masks help us to avoid flakey comparisons Animations – it’s likely that the state of any animations will differ between runs, meaning that comparisons will not be equal. In these cases, we can mask parts of our UI that are animated to avoid flakey results from animated content To add masks we can use the Edit Masks link on the comparisons dashboard for your commit, which will take us to the masks management screen. Here we can draw rectangle areas on our screenshot to represent the areas that should be ignored during comparison. Once we are satisfied with our masks, we can hit Save Masks and these will be applied for any future comparisons. Creating Jira Issues When there are issues during verification, this work is going to need to be accounted for in planning and completed by developers. To make it easier for reviewers to create these tasks, Jira tickets can be created from Screenshotbot. We can select the Create Issue link on the comparisons dashboard for your commit, which will take us to the issue creation screen. Here we can again use rectangles to select areas of the image, but this time the selection will be used to highlight within the created issue. This content will then be referenced when creating the ticket, allowing developers to have clarity on the issue and reduce friction when performing the fix.  Summary Prior to my use of screenshot testing, I wasn’t aware of the friction that I would experience with the storing of screenshots and surfacing issues to reviewers within pull requests. However, tools such as Screenshotbot remove this friction and make me confident that more teams will be able to easily adopt screenshot testing into their workflows. The management aspect alone of Screenshotbot is enough to pull me into using the tool, with the extended functionality such as masking, issue creation and diffing functionality taking its offerings to the next level. I would highly recommend Screenshotbot when evaluating the tooling for your testing infrastructure, and if you haven’t started screenshot testing yet for your product, at this point you’ll find it even easier to get started.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eIn a \u003ca href=\"https://joebirch.co/android/exploring-screenshot-testing-for-jetpack-compose/\"\u003erecent blog post\u003c/a\u003e I took a look at the new Compose Preview Screenshot Testing Tool, provided by Google as a way to enable developers to easily write screenshot tests for their composable UI. When it comes to screenshot testing, writing these tests only represents one part of the process – we also need to think about how we will slot this into our CI process, along with the management of our composable snapshots. In this post, we will be exploring \u003ca href=\"https://screenshotbot.io/joe\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eScreenshotbot\u003c/a\u003e, which can help to alleviate some of the friction experienced when trying to integrate screenshot tests into your workflow.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eThis is a \u003ca href=\"https://joebirch.co/services/content-writing/\"\u003ecommissioned blog post\u003c/a\u003e based on my experience using Screenshotbot\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eWhy Screenshotbot?\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo you may be thinking, why do I need another tool for my screenshot testing process? Well, as mentioned above, there are a couple of pain points which come with integrating screenshot testing into your development workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the code on your main branch, you’re going to want to have snapshots that represent the expected state of your UI – this is so that we can compare the changes of our proposed work with that on main. The friction here is that we would need to manage this ourselves – we’d have to manually update the screenshots and commit them to our repository, while also only ensuring that this happens when there are expected changes to those parts of the UI.\u003c/p\u003e\n\n\n\n\u003cp\u003eAlongside this management, we need to run the verification process and then communicate this on the PR for reviewers. To make it easy for reviewers to assess changes, we’d want to show a diff of the before/after state and ensure that we are doing this for each UI change within the PR. Depending on the screenshot testing framework being used, this would be both tricky and tedious to configure via manual scripting within your CI flow.\u003c/p\u003e\n\n\n\n\u003cp\u003eScreenshotbot solves both of these issues by offering a plug-and-play tool that will capture, store and diff UI changes in your project. You do not need to write custom scripts to capture and update snapshots, or write scripts to surface diffs within pull requests, Screenshotbot will handle all of this for us. We simply need to add a plugin and optional GitHub app, and we’ll be able to access screenshot checks directly within our pull requests.\u003c/p\u003e\n\n\n\n\u003cp\u003eScreenshotbot is also platform \u0026amp; framework agnostic, meaning that it only needs screenshots to operate. This means you can use one of the supported frameworks of the plugin (\u003ca href=\"https://developer.android.com/studio/preview/compose-screenshot-testing\"\u003eCompose Preview Screenshot Tests\u003c/a\u003e, \u003ca href=\"https://github.com/cashapp/paparazzi\"\u003ePaparazzi\u003c/a\u003e, \u003ca href=\"https://github.com/takahirom/roborazzi\"\u003eRoborazzi\u003c/a\u003e, \u003ca href=\"https://github.com/pedrovgs/Shot\"\u003eShot\u003c/a\u003e, \u003ca href=\"https://github.com/facebook/screenshot-tests-for-android\"\u003escreenshot-tests-for-android\u003c/a\u003e, \u003ca href=\"https://github.com/dropbox/dropshots\"\u003eDropshots\u003c/a\u003e) or simply provide screenshots via your own screenshot testing tool, as long as Screenshotbot has access to screenshots then it will be able to perform diffs on your UI changes.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith a generous free plan, it’s easy to get started and see if the tool is something that will work for you or your team. With that said, let’s take it for a spin and integrate it into a sample workflow.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eSetting up Screenshot Tests\u003c/h2\u003e\n\n\n\n\u003cp\u003eFor this blog post, we’re going to be using Composable Preview Tests via the Compose Preview Testing Tool. We’re going to focus on the management of screenshot tests through Screenshotbot as opposed to creating tests. If you haven’t yet set up screenshot tests or are looking to learn more about the Compose Preview Testing Tool, please checkout a \u003ca href=\"https://joebirch.co/android/exploring-screenshot-testing-for-jetpack-compose/\"\u003erecent blog post of mine\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our sample project we have 2 simple composables – a Contact composable that displays the name of the contact, followed by a composable that displays a list of these contacts.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun MainScreen() {\n    Scaffold(\n        topBar = {\n            TopAppBar(title = {\n                Text(text = \u0026#34;Contacts\u0026#34;)\n            })\n        }\n    ) { padding -\u0026gt;\n        LazyColumn(\n            contentPadding = padding\n        ) {\n            items(ContactFactory.makeContacts()) {\n                Contact(modifier = Modifier.fillMaxWidth(), contact = it)\n            }\n        }\n    }\n}\n\n@Composable\nfun Contact(modifier: Modifier = Modifier, contact: Contact) {\n    Surface {\n        Row(modifier = modifier.padding(16.dp), verticalAlignment = Alignment.CenterVertically) {\n            Box(\n                modifier = Modifier\n                    .background(contact.color, CircleShape)\n                    .size(48.dp),\n                contentAlignment = Alignment.Center\n            ) {\n                Text(\n                    text = contact.name.first().uppercase(),\n                    color = Color.White,\n                    lineHeight = 0.sp\n                )\n            }\n            Spacer(modifier = Modifier.width(16.dp))\n            Text(text = contact.name)\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe’ll also use composable previews to write two preview tests, allowing snapshots to be generated for our composable.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Preview(showBackground = true)\n@Composable\nfun ScreenPreview() {\n    MaterialTheme {\n        MainScreen()\n    }\n}\n\n@Preview(showBackground = true)\n@Composable\nfun ContactPreview() {\n    MaterialTheme {\n        Contact(contact = Contact(\u0026#34;Joe\u0026#34;, Color.Red))\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this in place, we now have some composables along with corresponding preview tests to take Screenshotbot for a spin.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eSetting Up Screenshot Bot\u003c/h2\u003e\n\n\n\n\u003ch2\u003eConfiguring the Android Project\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen it comes to integrating Screenshotbot into our project, there isn’t a lot that we need to do. First up, we need to add a plugin declaration to the root \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file in our project – this will enable the use of Screenshotbot functionality.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003eplugins {\n   …\n   id(\u0026#34;io.screenshotbot.plugin\u0026#34;) version \u0026#34;1.14\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, we’ll need to add the plugin to the \u003cstrong\u003ebuild.gradle\u003c/strong\u003e file for every sub-module that contains screenshot tests. If every module contains screenshot tests then you can apply this globally from your root build.grade file, but I would recommend doing this at individual level.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003eplugins {\n   …\n   id(\u0026#34;io.screenshotbot.plugin\u0026#34;)\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOnce your project has synced and can built successfully, we will have everything in place to run Screenshotbot.\u003c/p\u003e\n\n\n\n\u003ch2\u003eInstalling the GitHub App\u003c/h2\u003e\n\n\n\n\u003cp\u003eBecause we’re going to be integrating Screenshotbot with our Pull Request flow, we’re going to want to install the Screenshotbot GitHub App – this will allow the tool to hook into the GitHub Checks API, which means we can show success/failed states for screenshot verification directly within our pull requests.\u003c/p\u003e\n\n\n\n\u003cp\u003eSetting up the app is very straightforward and during project setup within Screenshotbot, you’ll be prompted to do so via the \u003cstrong\u003eInstall App on GitHub\u003c/strong\u003e button.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXc_koH9OEwMKXpYVS8eqtdiPG_qQjMY-gMBwMxt3AbfgNZRIOgkLTHOH4Y5GB661LIV-8_HDltJZIMvDlX5xBCQFfMJUm0mzxdxEzGvfhFuaj8cFyQLb78ETJK5KMPPuxlL23j3oGqq9AtGPzxaZqxg0RXD?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eYou’ll need to follow the on-screen instructions and then grant Screenshotbot access to your repository. Once complete, you will see verification that the setup was successful.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eRunning Verification Checks\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen it comes to verifying our screenshots, we no longer need to use any existing commands from the testing framework we are using. Instead, we just need to run a single \u003ca href=\"https://screenshotbot.io/documentation/platforms/android-apps#integrating-with-the-screenshotbot-gradle-plugin\"\u003ecorresponding command\u003c/a\u003e from Screenshotbot. Because I am using the Compose Preview Testing Tool, I need to use the following command.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003e./gradlew recordAndVerifyDebugAndroidScreenshotbotCI\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen running this command, Screenshotbot will record the screenshots for the current branch and upload them to its server, which is where they will be compared with the existing snapshots. Once this flow has completed, we will be returned with a result that states a success or failure state. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we can run this locally, we’re going to want to slot this into our CI process. I am going to be using GitHub Actions for my project, so I’ll go ahead and create a new Pull Request workflow. This workflow will run on any pull requests that are opened, as well as when any changes are pushed to the corresponding branch (while the PR is open).\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003ename: Pull Request\n\non:\n  pull_request:\n  push:\n    branches:\n      - \u0026#39;main\u0026#39;\n\njobs:\n screenshots:\n   runs-on: ubuntu-latest\n   steps:\n     - uses: actions/checkout@v3\n       with:\n         fetch-depth: 0\n     - name: Set up JDK\n       uses: actions/setup-java@v3\n       with:\n         distribution: \u0026#39;temurin\u0026#39;\n         java-version: \u0026#39;17\u0026#39;\n         cache: \u0026#39;gradle\u0026#39;\n     - name: Setup Android SDK\n       uses: android-actions/setup-android@v2\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe won’t go too deep into this workflow, but we’re simply checking out the branch of our repository and configuring the required frameworks (Java and Android), as this is required for any checks depending on these.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhenever this workflow is run, we’ll want to run the verification for our screenshots.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003ename: Pull Request\n\n…\n\njobs:\n screenshots:\n   runs-on: ubuntu-latest\n   steps:\n     …\n     - name: Run checks\n       run: |\n         ./gradlew recordAndVerifyDebugScreenshotTest\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eHowever, this command alone is not enough.So that our script can communicate with our Screenshotbot account, we’re going to need to provide both an API key and secret that will allow API calls to be made on behalf of our account. We’ll need to start here by heading back on over to our Screenshotbot account, selecting \u003cstrong\u003eAPI Keys\u003c/strong\u003e from the sidebar, and then using the \u003cstrong\u003eNew API Key\u003c/strong\u003e button to navigate to the key creation form.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXe72KkOQSmwRqBq4-6BLoT2JJ8CoIjucxj8dUzSXFiPntHfctjil2n-UAb3qZcZBa9uYHBpSga6E8UiFCaUVsuRkFvUHMRiA98XEjWAnMnY-VqZNxU8GZ333uVMOJxa9xABPSChAxj9KjIIBcjPYvFpSsan?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAfter creating our API key and secret, we’ll want to store these within GitHub Actions as action secrets. We’ll create two new secrets, \u003cstrong\u003eSCREENSHOTBOT_API_KEY\u003c/strong\u003e and \u003cstrong\u003eSCREENSHOTBOT_API_SECRET\u003c/strong\u003e, copying over the values generated in the previous step.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXclQfZenA9SexPAFltfAnJpAK4Idf1e9u6VkIIesKBux9Xfyk2k38vYsb2c0XnlRtm0QUJm_mghlgoUBvt4T4U9YQ-Q5LzNRHsgjsfo9kMyLbYaRdPAI2h1FaHBDnnNWJuzSMpeCZY_1PGEe3LKRFu1DKk?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWe’ve these in place, we can now provide them as environment variables for our command. We’ll do this using the env property for our workflow step, passing the corresponding values for the key and secret value.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"bash\"\u003ename: Pull Request\n\n...\n\njobs:\n screenshots:\n   runs-on: ubuntu-latest\n   steps:\n     ...\n     - name: Run checks\n       run: |\n         ./gradlew recordAndVerifyDebugScreenshotTest\n       env:\n         SCREENSHOTBOT_API_KEY: ${{ secrets.SCREENSHOTBOT_API_KEY }}\n         SCREENSHOTBOT_API_SECRET: ${{ secrets.SCREENSHOTBOT_API_SECRET }}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eOpening a Pull Request\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that Screenshotbot has been configured, we’re going to go and test the functionality in our repository. We’re going to purposefully create a failed state here, so we’ll start by changing the background colour of our \u003cstrong\u003eBox\u003c/strong\u003e composable to use \u003cstrong\u003eColor.Red\u003c/strong\u003e instead of the \u003cstrong\u003ecolor\u003c/strong\u003e property from the provided \u003cstrong\u003eContact\u003c/strong\u003e reference. This will cause our screenshot tests to break, due to there now being a change in the styling of the Contact component.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun Contact(modifier: Modifier = Modifier, contact: Contact) {\n    Surface {\n        Row(\n            …\n        ) {\n            Box(\n                modifier = Modifier\n                    .background(Color.Red, CircleShape)\n                    .size(48.dp),\n                contentAlignment = Alignment.Center\n            ) {\n                …\n            }\n            …\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAfter this change has been committed and a pull request open, we’ll be able to see two checks running – the screenshots job that we created in our GitHub Action, along with the \u003cstrong\u003eScreenshotbot\u003c/strong\u003e app that is verifying our changes. The changes that we’ve made have purposefully broken the styling of our \u003cstrong\u003eContact\u003c/strong\u003e component, and we can see that the Screenshotbot check has failed because of this.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXdx3qf8cA4K9T8bhQNKxUh1aYd0Bo8C08BYhJcWxPLT8-gEQcGESZztoTR4uTn1pq8uW2MNpoKoz86Xgp0Gs8AabmHLbxIG-N-gt8IKNPNvl6srtgq0enSK-9PCsmLH3_bKuFe-Hnqlqt63AABTe9izDQY?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWe’re going to want to inspect why these checks have failed, so we’ll click the \u003cstrong\u003eDetails\u003c/strong\u003e link for Screenshotbot in our pull request checks.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXdXy0PPV5a-uYO20J-LRz6C35DbDaiVB6fYPgzuH7hNVmimNTXkksGLXgpK4JSogaJV2XklLemMd5Ci5cnJqs2JCDyc86OslGy51V-HaDyvax-btI-vCB4WYFVgnLMMGXpJSuik4DIHENh24_2NqPNNigbH?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAt this point, we’ll want to click \u003cstrong\u003eResolve\u003c/strong\u003e – this will take us directly to the diff report for this commit within Screenshotbot. \u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eAnalysing changes\u003c/h2\u003e\n\n\n\n\u003cp\u003eOnce we’ve clicked through to Screenshotbot from GitHub, we will be able to see the stored snapshots of our composable, along with the generated screenshot from our pull request. \u003c/p\u003e\n\n\n\n\u003ch2\u003eComparing Screenshots\u003c/h2\u003e\n\n\n\n\u003cp\u003eOn the main screen of the commit, we’ll be able to see the before/after for our changes – hovering over the before state will also allow you to quickly flick between these states for comparison.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo autoplay=\"\" loop=\"\" muted=\"\" src=\"https://joebirch.co/wp-content/uploads/2024/06/1-changes-15-June-2024-2-1.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIf we want to inspect our changes in more detail, we can click the \u003cstrong\u003eCompare\u003c/strong\u003e link to open up a window that allows us to view scaled in diff, before and after versions of our changes. This is incredibly useful for being able to focus in on changes, especially where the overall diff image is a larger screenshot where it may be harder to work out change details.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo autoplay=\"\" loop=\"\" muted=\"\" src=\"https://joebirch.co/wp-content/uploads/2024/06/1-changes-15-June-2024-3.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce we’ve analysed the changes on this screen we’ll want to review them, meaning that we will either want to \u003cstrong\u003eAccept\u003c/strong\u003e or \u003cstrong\u003eReject\u003c/strong\u003e them.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXd0iwRJUUCwp9XxgHKAKag8T3SJpZsd6kkIFSQiferF4SMVDqmzlIZ9qfgSvAcByZvTAqE-0E7zSTWIRtz8UUXLE7rk6hKkf9kxMYeFOnMZKRgM9OdweZhmMqqVsuo5DJc-TdjvzbKaFyFVfgnVKdMulfbt?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIf we reject these changes, the check will remain as failed until we push some more changes and the checks are run again. Otherwise, accepting the changes will mark the check as passed in our Pull Request, allowing the changes to be merged.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXeBx0kgQMDDGgmACS1wq6c5JPC3SRMznXw8yeHF-Yg95qrK8NoAk7xFfs9OcHTO8h2yF2qieZ5bvmk2sNiT37k2EzPiau5PQ1ID-M0SGZrnbOme3fKDJ1NwBTqSYPIvpT4ElIFW6gkuDkIcOiGcjW5SoJQv?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eAdding Notes\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn scenarios where the changes need some feedback\u003cstrong\u003e,\u003c/strong\u003e we can utilise the notes functionality in Screenshotbot which can be accessed through the \u003cstrong\u003eMore\u003c/strong\u003e menu on the changes dashboard.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXdTlhkTOu1aP-phApaoqdT1l6iDBRnx1UbzICS5c2GxZxqAvkQHjqzzaM9gSKoLM1imw1AoSLvUVuCRL2m16WI2ejfiacGhdIaXsYSEXJKCLVerKi0gYr8tmnfNUTAgWZ0JF3phycKlxgt6epQGIw7cz8E9?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAfter leaving a note, it will appear at the top of the changes dashboard which is incredibly visible to any viewers. If multiple comments are added, then these will appear stacked in the latest order.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXfVNPZYGAVAoEdBqnpJxAIQMSvWw1CdyiZXtjjglEI1o0vXF9B8ImdvK8XmIIA5rbrbVQJvaLD-3wiYqygbmxlz_uo_WlHaMq61yZw2obNzguDfW2Z1zpOF3c5Zte6MY2NgnE7QxYe_EMytXDnKkNzupyT_?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNotes are global for the changes in question. So if there are multiple comments, this will rely on the author making it clear what the comment applies to. Ideally, developers will create small PRs with focused changes, but this is going to be dependent on the workflows of the corresponding team. One nice addition here could be the ability to leave comments on specific parts of a change, as opposed to the comment being general to the overall change.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMasking Screenshots\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn some cases, there may be parts of a screenshot that we want to ignore when verification is taking place. This is supported within Screenshotbot as \u003cstrong\u003eMasks\u003c/strong\u003e and allows us to highlight specific parts of screenshots that should not be counted towards comparisons. This could be useful in cases such as:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDynamic Content\u003c/strong\u003e – such as timestamps, usernames or any kind of user-generated content. We can’t rely on this data always being the same between runs, so created masks help us to avoid flakey comparisons\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAnimations\u003c/strong\u003e – it’s likely that the state of any animations will differ between runs, meaning that comparisons will not be equal. In these cases, we can mask parts of our UI that are animated to avoid flakey results from animated content\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eTo add masks we can use the \u003cstrong\u003eEdit Masks\u003c/strong\u003e link on the comparisons dashboard for your commit, which will take us to the masks management screen. Here we can draw rectangle areas on our screenshot to represent the areas that should be ignored during comparison. Once we are satisfied with our masks, we can hit \u003cstrong\u003eSave Masks\u003c/strong\u003e and these will be applied for any future comparisons.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXfyAEDuRkpV5-CGGfizzfocqbs3T6oJfPfFLZqWepZrLbbaWu_rsExHM2GMV7BTzFDO1NqvxR1QivvmHnUmrkV5Obo_aGZPptQQn379t9fVcQSj7VFyqEFSHJ57CuNi16HQBACqAldPThMv6sIFl9cW_u01?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eCreating Jira Issues\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen there are issues during verification, this work is going to need to be accounted for in planning and completed by developers. To make it easier for reviewers to create these tasks, Jira tickets can be created from Screenshotbot. We can select the \u003cstrong\u003eCreate Issue\u003c/strong\u003e link on the comparisons dashboard for your commit, which will take us to the issue creation screen.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-us.googleusercontent.com/docsz/AD_4nXdU_bjVrQfg47H6IaG-6cHkRnEwoVTukSiVYrEbssXK_n_iVbC5VGDtCoXkgp-niJZjQM1Qa8WCXItEjjrFoOmqOE0ggP3q9XmmFtxdSi4mZETtWjUf-krhBL_XDsMuQ2xUqrRAHEJOJS3lIajmfwwX7sQ?key=zQs8KO98zXt8viLJYn9D9Q\" alt=\"\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eHere we can again use rectangles to select areas of the image, but this time the selection will be used to highlight within the created issue. This content will then be referenced when creating the ticket, allowing developers to have clarity on the issue and reduce friction when performing the fix. \u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003ePrior to my use of screenshot testing, I wasn’t aware of the friction that I would experience with the storing of screenshots and surfacing issues to reviewers within pull requests. However, tools such as \u003ca href=\"https://screenshotbot.io/joe\"\u003eScreenshotbot\u003c/a\u003e remove this friction and make me confident that more teams will be able to easily adopt screenshot testing into their workflows. The management aspect alone of Screenshotbot is enough to pull me into using the tool, with the extended functionality such as masking, issue creation and diffing functionality taking its offerings to the next level.\u003c/p\u003e\n\n\n\n\u003cp\u003eI would highly recommend \u003ca href=\"https://screenshotbot.io/joe\"\u003eScreenshotbot\u003c/a\u003e when evaluating the tooling for your testing infrastructure, and if you haven’t started screenshot testing yet for your product, at this point you’ll find it even easier to get started.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-06-20T06:24:58Z",
  "modifiedTime": "2024-06-20T15:18:06Z"
}
