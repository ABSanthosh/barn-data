{
  "id": "1c86df00-45b7-4cec-ab7f-20ed66a00c68",
  "title": "A non-scientific survey of ZIP Metadata",
  "link": "https://publicobject.com/2024/02/26/zip-metadata/",
  "description": "Okio's has an openZip() function that views a .zip file as a FileSystem. To expose file metadata in the file system API, Okio must extract it from the .zip file.There’s at least four ways to encode timestamps in a .zip file. I wanted to find out which of",
  "author": "Jesse Wilson",
  "published": "Mon, 26 Feb 2024 14:48:58 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 4309,
  "excerpt": "Okio's has an openZip() function that views a .zip file as a FileSystem. To expose file metadata in the file system API, Okio must extract it from the .zip file. There’s at least four ways to encode timestamps in a .zip file. I wanted to find out which of these formats are used in practice, so I can support them in Okio. I was also curious about what other metadata is used. I used my Mac’s disk as a source of sample .zip files. I scanned 6.2 million files on my Mac, of which 50,861 successfull",
  "siteName": "Public Object",
  "favicon": "",
  "text": "Okio's has an openZip() function that views a .zip file as a FileSystem. To expose file metadata in the file system API, Okio must extract it from the .zip file.There’s at least four ways to encode timestamps in a .zip file. I wanted to find out which of these formats are used in practice, so I can support them in Okio. I was also curious about what other metadata is used.I used my Mac’s disk as a source of sample .zip files. I scanned 6.2 million files on my Mac, of which 50,861 successfully decoded as .zip files. My program attempted to decode every single file as a ZIP, regardless of its extension! I do lots of Android, JVM, and Kotlin work on this Mac so my sample is biased towards the ZIPs used in these ecosystems, including .jar, .apk, and .klib files.Here's what I found...Timestamps32-bit DOS timestamps (Built-in)Every ZIP files include a bit-packed last modified time. It spends 16 bits on the date another 16 bits on the time:7-bit year4-bit month5-bit day5-bit hour6-bit minute5-bit secondSpending only 7 bits on the year means that this format can't express dates before 1980 or after 2107. Our industry is great at hiding time bombs in things!Spending only 5 bits on the second means that this format rounds (or truncates?!) seconds to an even number: your file could be last modified at 11:45:30 or 11:45:32, but not at 11:45:31.No bits are spent on the time zone and the convention is to encode the local-computer's time zone when writing a file. When a person in Sydney sends GraysAlmanac.zip to a friend in San Francisco, the contents’ last-modified timestamps could be in the future!Extended Timestamp (0x5455, 4,826 files)This optional field holds seconds-since-epoch for last modified, last accessed, and created at timestamps. Each of these fields are optional.They're stored as signed 32-bit integers and can store dates between 1901-12-13 and 2038-01-19. Library authors must act now to defuse this time bomb!NTFS Timestamp (0x000a, 5 files)I found just 3 distinct files (plus 2 duplicates) with this metadata:A file named github-vector-logo.zip that I downloaded from seeklogo.com in 2022.Android Studio’s bundled ffmpeg and javacpp libraries.A sample file for testing NTFS timestamp handling in rubyzip. (Today I learned that when I use a Ruby Gem, that library's test suite could be saved to my computer?!)The NTFS timestamp format doesn’t have any time bombs in it.UNIX Timestamp (0x000d, 0 files)This is similar to the extended timestamp metadata. This format also suffers from the 2038 problem.Everything ElseZip64 (0x0001, 2,031 files)This metadata is present for .zips with more than 65,535 entries and also for .zips with any entry larger than 4 GiB.Executable .jar Metadata (0xcafe, 3,196 files)When creating a .zip with JarOutputStream, this metadata is added. Apparently it’s a hack from 1999 to support executable JAR files on Solaris. Info-ZIP UNIX MetadataI found three revisions of this field for storing UNIX metadata like the file’s owning username and group:0x5855: 41 files0x7855: 12 files0x7875: 244 filesUTF-8 Path Name (0x7075, 16 files)This is necessary for .zip entries whose file names are non-ASCII. Okio doesn't support these.None of the .zips that used this field did so usefully! That is, they encoded a UTF-8 that equaled the ASCII-name. (I’d probably get different results if I spoke more languages.)It’s unclear to me whether this field specifies a full path or just a file name. I saw both approaches in the .zip files on my Mac. Yuck.I assume that abusing UTF-8 paths in .zip files is a great way to find bugs and vulnerabilities!Microsoft Open Packaging (0xa220, 7 files)This metadata is used include gaps after .zip entries so they can be updated in-place. I only saw this used in Microsoft Office .xlsx and .docx files.Zipalign (0xd935, 9 files)This is used by Android’s zipalign tool to word-align the start of entries.Next StepsI’m surprised that I only found 10 distinct metadata tags!I think it’s prudent to support NTFS timestamps in ZIP libraries like Okio, to defend against the 2038 and 2107 time bombs. (I hope that Internet research confirms this is already the general consensus?!)I’m going to skip UTF-8 support for now, as it breaks my files-are-implementation-details hypothesis. I’m open to having my mind changed on this!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eOkio\u0026#39;s has an \u003ccode\u003eopenZip()\u003c/code\u003e function that views a .zip file as a \u003ccode\u003eFileSystem\u003c/code\u003e. To expose file metadata in the file system API, Okio must extract it from the .zip file.\u003c/p\u003e\u003cp\u003eThere’s at least four ways to encode timestamps in a .zip file. I wanted to find out which of these formats are used in practice, so I can support them in Okio. I was also curious about what other metadata is used.\u003c/p\u003e\u003cp\u003eI used my Mac’s disk as a source of sample .zip files. I scanned 6.2 million files on my Mac, of which 50,861 successfully decoded as .zip files. My program attempted to decode every single file as a ZIP, regardless of its extension! I do lots of Android, JVM, and Kotlin work on this Mac so my sample is biased towards the ZIPs used in these ecosystems, including \u003ccode\u003e.jar\u003c/code\u003e, \u003ccode\u003e.apk\u003c/code\u003e, and \u003ccode\u003e.klib\u003c/code\u003e files.\u003c/p\u003e\u003cp\u003eHere\u0026#39;s what I found...\u003c/p\u003e\u003ch2 id=\"timestamps\"\u003eTimestamps\u003c/h2\u003e\u003ch3 id=\"32-bit-dos-timestamps-built-in-\"\u003e32-bit DOS timestamps (Built-in)\u003c/h3\u003e\u003cp\u003eEvery ZIP files include a bit-packed last modified time. It spends 16 bits on the date another 16 bits on the time:\u003c/p\u003e\u003cul\u003e\u003cli\u003e7-bit year\u003c/li\u003e\u003cli\u003e4-bit month\u003c/li\u003e\u003cli\u003e5-bit day\u003c/li\u003e\u003cli\u003e5-bit hour\u003c/li\u003e\u003cli\u003e6-bit minute\u003c/li\u003e\u003cli\u003e5-bit second\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSpending only 7 bits on the year means that this format can\u0026#39;t express dates before 1980 or after 2107. Our industry is great at hiding time bombs in things!\u003c/p\u003e\u003cp\u003eSpending only 5 bits on the second means that this format rounds (or truncates?!) seconds to an even number: your file could be last modified at \u003ccode\u003e11:45:30\u003c/code\u003e or \u003ccode\u003e11:45:32\u003c/code\u003e, but not at \u003ccode\u003e11:45:31\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNo bits are spent on the time zone and the convention is to encode the local-computer\u0026#39;s time zone when writing a file. When a person in Sydney sends \u003ccode\u003eGraysAlmanac.zip\u003c/code\u003e to a friend in San Francisco, the contents’ last-modified timestamps could be in the future!\u003c/p\u003e\u003ch3 id=\"extended-timestamp-0x5455-4-826-files-\"\u003eExtended Timestamp (0x5455, 4,826 files)\u003c/h3\u003e\u003cp\u003eThis optional field holds seconds-since-epoch for last modified, last accessed, and created at timestamps. Each of these fields are optional.\u003c/p\u003e\u003cp\u003eThey\u0026#39;re stored as signed 32-bit integers and can store dates between 1901-12-13 and 2038-01-19. Library authors must act now to defuse this time bomb!\u003c/p\u003e\u003ch3 id=\"ntfs-timestamp-0x000a-5-files-\"\u003eNTFS Timestamp (0x000a, 5 files)\u003c/h3\u003e\u003cp\u003eI found just 3 distinct files (plus 2 duplicates) with this metadata:\u003c/p\u003e\u003cul\u003e\u003cli\u003eA file named \u003ccode\u003egithub-vector-logo.zip\u003c/code\u003e that I downloaded from \u003ccode\u003eseeklogo.com\u003c/code\u003e in 2022.\u003c/li\u003e\u003cli\u003eAndroid Studio’s bundled \u003ccode\u003effmpeg\u003c/code\u003e and \u003ccode\u003ejavacpp\u003c/code\u003e libraries.\u003c/li\u003e\u003cli\u003eA sample file for testing NTFS timestamp handling in \u003ca href=\"https://github.com/rubyzip/rubyzip\"\u003erubyzip\u003c/a\u003e. (Today I learned that when I use a Ruby Gem, that library\u0026#39;s test suite could be saved to my computer?!)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe NTFS timestamp format doesn’t have any time bombs in it.\u003c/p\u003e\u003ch3 id=\"unix-timestamp-0x000d-0-files-\"\u003eUNIX Timestamp (0x000d, 0 files)\u003c/h3\u003e\u003cp\u003eThis is similar to the extended timestamp metadata. This format also suffers from the 2038 problem.\u003c/p\u003e\u003ch2 id=\"everything-else\"\u003eEverything Else\u003c/h2\u003e\u003ch3 id=\"zip64-0x0001-2-031-files-\"\u003eZip64 (0x0001, 2,031 files)\u003c/h3\u003e\u003cp\u003eThis metadata is present for .zips with more than 65,535 entries and also for .zips with any entry larger than 4 GiB.\u003c/p\u003e\u003ch3 id=\"executable-jar-metadata-0xcafe-3-196-files-\"\u003eExecutable .jar Metadata (0xcafe, 3,196 files)\u003c/h3\u003e\u003cp\u003eWhen creating a .zip with \u003ccode\u003eJarOutputStream\u003c/code\u003e, this metadata is added. Apparently it’s \u003ca href=\"https://bugs.openjdk.org/browse/JDK-4138619\"\u003ea hack from 1999 to support executable JAR files on Solaris\u003c/a\u003e. \u003c/p\u003e\u003ch3 id=\"info-zip-unix-metadata\"\u003eInfo-ZIP UNIX Metadata\u003c/h3\u003e\u003cp\u003eI found three revisions of \u003ca href=\"https://fossies.org/linux/misc/unzip60.tar.gz/unzip60/proginfo/extrafld.txt\"\u003ethis field\u003c/a\u003e for storing UNIX metadata like the file’s owning username and group:\u003c/p\u003e\u003cul\u003e\u003cli\u003e0x5855: 41 files\u003c/li\u003e\u003cli\u003e0x7855: 12 files\u003c/li\u003e\u003cli\u003e0x7875: 244 files\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"utf-8-path-name-0x7075-16-files-\"\u003eUTF-8 Path Name (0x7075, 16 files)\u003c/h3\u003e\u003cp\u003eThis is necessary for .zip entries whose file names are non-ASCII. Okio doesn\u0026#39;t support these.\u003c/p\u003e\u003cp\u003eNone of the .zips that used this field did so usefully! That is, they encoded a UTF-8 that equaled the ASCII-name. (I’d probably get different results if I spoke more languages.)\u003c/p\u003e\u003cp\u003eIt’s unclear to me whether this field specifies a full path or just a file name. I saw both approaches in the .zip files on my Mac. Yuck.\u003c/p\u003e\u003cp\u003eI assume that abusing UTF-8 paths in .zip files is a great way to find bugs and vulnerabilities!\u003c/p\u003e\u003ch3 id=\"microsoft-open-packaging-0xa220-7-files-\"\u003eMicrosoft Open Packaging (0xa220, 7 files)\u003c/h3\u003e\u003cp\u003eThis metadata is used include gaps after .zip entries so they can be updated in-place. I only saw this used in Microsoft Office \u003ccode\u003e.xlsx\u003c/code\u003e and \u003ccode\u003e.docx\u003c/code\u003e files.\u003c/p\u003e\u003ch3 id=\"zipalign-0xd935-9-files-\"\u003eZipalign (0xd935, 9 files)\u003c/h3\u003e\u003cp\u003eThis is used by \u003ca href=\"https://developer.android.com/tools/zipalign\"\u003eAndroid’s zipalign tool\u003c/a\u003e to word-align the start of entries.\u003c/p\u003e\u003ch2 id=\"next-steps\"\u003eNext Steps\u003c/h2\u003e\u003cp\u003eI’m surprised that I only found 10 distinct metadata tags!\u003c/p\u003e\u003cp\u003eI think it’s prudent to support NTFS timestamps in ZIP libraries like Okio, to defend against the 2038 and 2107 time bombs. (I hope that Internet research confirms this is already the general consensus?!)\u003c/p\u003e\u003cp\u003eI’m going to skip UTF-8 support for now, as it breaks my \u003ca href=\"https://publicobject.com/2020/10/06/files/\"\u003efiles-are-implementation-details hypothesis\u003c/a\u003e. I’m open to having my mind changed on this!\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-02-26T14:48:58Z",
  "modifiedTime": "2024-02-26T23:16:33Z"
}
