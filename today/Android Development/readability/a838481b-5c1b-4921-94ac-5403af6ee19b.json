{
  "id": "a838481b-5c1b-4921-94ac-5403af6ee19b",
  "title": "Perils of duplicate finding",
  "link": "https://jakewharton.com/perils-of-duplicate-finding/",
  "description": "",
  "author": "",
  "published": "2024-02-14T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 5767,
  "excerpt": "14 February 2024",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Perils of duplicate finding 14 February 2024 Given an array of integers ([1, 2, 3, 1, 3, 1]), find the elements which are duplicated. No, we’re not interviewing. I’m trying to prevent a user from specifying a reserved value twice. Elsewhere in the file I already have duplicate detection for object tags. val dupes: Map\u003cInt, List\u003cWidget\u003e\u003e = widgets.groupBy(Widget::tag) .filterValues { it.size \u003e 1 } I can do the same technique for the integer array with an identity function and grabbing the resulting keys. val dupes: Set\u003cInt\u003e = ints.groupBy { it } .filterValues { it.size \u003e 1 } .keys This prints [1, 3]. So… done? Yes! But no, using the map seems wasteful, right? Attempt 1 My first attempt to avoid the map was to remove the set of integers from a list of them. This should result in a list of any duplicated elements. val dupes: List\u003cInt\u003e = ints.toList() - ints.toSet() No matter the content of ints, this will always print []. Why? The minus operator says that it “returns a list containing all elements of the original collection except the elements contained in the given elements collection”. So it removes all occurrences of each element in the set from the list. This is some surprising behavior to hide behind an operator whose signature operates on an Iterable receiver and Collection argument. Attempt 2 Second attempt switches to MutableList.removeAll which takes a collection of elements. The MutableList.remove function only removes the first occurrence of an element, so this should remove the first occurrence of each element in the set. val dupes: List\u003cInt\u003e = ints.toMutableList() .apply { removeAll(ints.toSet()) } This once again prints []. But why? Kotlin made me a liar. MutableList.remove does indeed only remove the first occurrence of the element. MutableList.removeAll, however, removes all occurrences of each element in the supplied collection. That’s quite the subtle asymmetry. There is no function for removing all occurrences of a single element. Nor a function to remove only the first occurrences of each element of a supplied collection. You needn’t be mad at Kotlin, though. It inherited this behavior from Java. Attempt 3 Third attempt now with MutableList.remove. val dupes: List\u003cInt\u003e = ints.toMutableList() .apply { ints.toSet().forEach(::remove) } This (finally) prints [1, 3, 1]. If we want just the set of duplicates to match the map-based approach above we can tag on a toSet(). val dupes: Set\u003cInt\u003e = ints.toMutableList() .apply { ints.toSet().forEach(::remove) } .toSet() Visually this is not the greatest. It’s also not really that efficient (not that we’ve been worrying about that yet). We got here because I started with a clever-but-incorrect approach (toList() - toSet()) that I then had to refactor until it was correct. Attempt 4 Fourth attempt is a chance to reset our approach. I thought that we could partition the elements based on whether we’ve seen the value before. A set tracks the values, and its MutableSet.add returns a boolean indicating whether the collection was mutated (i.e., has been seen before). val dupes: Set\u003cInt\u003e = HashSet\u003cInt\u003e() .run { ints.partition(::add) } .second .toSet() This prints [1, 3] correctly. Visually the code is just dreadful. It’s hard to quickly discern what value is flowing from line to line. Using partition was just my first intuition. But a partition that throws away half the result has another name: a filter! Attempt 5 Fifth attempt at this now using a filter. val dupes: Set\u003cInt\u003e = ints.filterNot(HashSet\u003cInt\u003e()::add) .toSet() This continues to print [1, 3] correctly. We use filterNot because we want to keep elements where MutableSet.add returns false. Visually this is pretty decent. The use of HashSet\u003cInt\u003e()::add is what’s known as a bound reference. We are specifying a function reference of MutableSet::add as our filterNot lambda, but bound to an instance of HashSet which we are creating on-the-fly. This is an equivalent version of the above code. val seen = HashSet\u003cInt\u003e() val dupes: Set\u003cInt\u003e = ints.filterNot(seen::add) .toSet() The advantage of inlining the HashSet instantiation is that we don’t need to name it.1 Attempt 5.1 Finally, almost all of Kotlin’s collection extensions have To-suffixed variants which allow supplying a destination collection. This can save you from having to add a toSomething() after an operation by instead just using that Something in the operation directly. val dupes: Set\u003cInt\u003e = ints.filterNotTo(HashSet(), HashSet\u003cInt\u003e()::add) Pretty, pretty, pretty good. Benchmarks Performance is not really a concern in my usage, but let’s look anyway. Benchmark Score Error Units ---------------------------------------------- --------- ------ ----- IntDupes.map 94.015 ± 0.469 ns/op IntDupes.map:·gc.alloc.rate.norm 776.000 ± 0.001 B/op IntDupes.mutableListRemove 155.744 ± 17.829 ns/op IntDupes.mutableListRemove:·gc.alloc.rate.norm 560.000 ± 0.001 B/op IntDupes.partition 135.693 ± 18.976 ns/op IntDupes.partition:·gc.alloc.rate.norm 544.000 ± 0.001 B/op IntDupes.filterNot 97.748 ± 1.055 ns/op IntDupes.filterNot:·gc.alloc.rate.norm 504.000 ± 0.001 B/op IntDupes.filterNotTo 39.904 ± 0.331 ns/op IntDupes.filterNotTo:·gc.alloc.rate.norm 432.000 ± 0.001 B/op So the filterNotTo winds up being the fastest and allocates the fewest bytes. Double win! — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003ePerils of duplicate finding\u003c/h2\u003e\n      \u003cp\u003e14 February 2024\u003c/p\u003e\n\n      \u003cp\u003eGiven an array of integers (\u003ccode\u003e[1, 2, 3, 1, 3, 1]\u003c/code\u003e), find the elements which are duplicated.\nNo, we’re not interviewing.\nI’m trying to prevent a user from specifying a reserved value twice.\u003c/p\u003e\n\n\u003cp\u003eElsewhere in the file I already have duplicate detection for object tags.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eMap\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eWidget\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003ewidgets\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egroupBy\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eWidget\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilterValues\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI can do the same technique for the integer array with an identity function and grabbing the resulting keys.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egroupBy\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilterValues\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ekeys\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis prints \u003ccode\u003e[1, 3]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSo… done? Yes!\nBut no, using the map seems wasteful, right?\u003c/p\u003e\n\n\u003ch3 id=\"attempt-1\"\u003eAttempt 1\u003c/h3\u003e\n\n\u003cp\u003eMy first attempt to avoid the map was to remove the set of integers from a list of them.\nThis should result in a list of any duplicated elements.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoList\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNo matter the content of \u003ccode\u003eints\u003c/code\u003e, this will always print \u003ccode\u003e[]\u003c/code\u003e.\nWhy?\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/minus.html\"\u003e\u003ccode\u003eminus\u003c/code\u003e operator\u003c/a\u003e says that it “returns a list containing all elements of the original collection except the elements contained in the given \u003ccode\u003eelements\u003c/code\u003e collection”.\nSo it removes \u003cem\u003eall\u003c/em\u003e occurrences of each element in the set from the list.\u003c/p\u003e\n\n\u003cp\u003eThis is some surprising behavior to hide behind an operator whose signature operates on an \u003ccode\u003eIterable\u003c/code\u003e receiver and \u003ccode\u003eCollection\u003c/code\u003e argument.\u003c/p\u003e\n\n\u003ch3 id=\"attempt-2\"\u003eAttempt 2\u003c/h3\u003e\n\n\u003cp\u003eSecond attempt switches to \u003ccode\u003eMutableList.removeAll\u003c/code\u003e which takes a collection of elements.\nThe \u003ccode\u003eMutableList.remove\u003c/code\u003e function only removes the first occurrence of an element, so this should remove the first occurrence of each element in the set.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoMutableList\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eapply\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eremoveAll\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis once again prints \u003ccode\u003e[]\u003c/code\u003e.\nBut why?\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://jakewharton.com/static/post-image/kotlin-remove-removeAll.png\"\u003e\u003cimg src=\"https://jakewharton.com/static/post-image/kotlin-remove-removeAll.png\" alt=\"\nScreenshot of Kotlin documentation showing two functions:\nremove: Removes a single instance of the specified element from this collection, if it is present.\nremoveAll: Removes all of this collection\u0026#39;s elements that are also contained in the specified collection.\n\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eKotlin made me a liar.\n\u003ccode\u003eMutableList.remove\u003c/code\u003e does indeed only remove the first occurrence of the element.\n\u003ccode\u003eMutableList.removeAll\u003c/code\u003e, however, removes \u003cem\u003eall\u003c/em\u003e occurrences of each element in the supplied collection.\nThat’s quite the subtle asymmetry.\u003c/p\u003e\n\n\u003cp\u003eThere is no function for removing all occurrences of a single element.\nNor a function to remove only the first occurrences of each element of a supplied collection.\u003c/p\u003e\n\n\u003cp\u003eYou needn’t be mad at Kotlin, though.\nIt \u003ca href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Collection.html#removeAll(java.util.Collection)\"\u003einherited this behavior\u003c/a\u003e from Java.\u003c/p\u003e\n\n\u003ch3 id=\"attempt-3\"\u003eAttempt 3\u003c/h3\u003e\n\n\u003cp\u003eThird attempt now with \u003ccode\u003eMutableList.remove\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoMutableList\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eapply\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis (finally) prints \u003ccode\u003e[1, 3, 1]\u003c/code\u003e.\nIf we want just the set of duplicates to match the map-based approach above we can tag on a \u003ccode\u003etoSet()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoMutableList\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eapply\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eremove\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eVisually this is not the greatest.\nIt’s also not really that efficient (not that we’ve been worrying about that yet).\nWe got here because I started with a clever-but-incorrect approach (\u003ccode\u003etoList() - toSet()\u003c/code\u003e) that I then had to refactor until it was correct.\u003c/p\u003e\n\n\u003ch3 id=\"attempt-4\"\u003eAttempt 4\u003c/h3\u003e\n\n\u003cp\u003eFourth attempt is a chance to reset our approach.\nI thought that we could partition the elements based on whether we’ve seen the value before.\nA set tracks the values, and its \u003ccode\u003eMutableSet.add\u003c/code\u003e returns a boolean indicating whether the collection was mutated (i.e., has been seen before).\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eHashSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epartition\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esecond\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis prints \u003ccode\u003e[1, 3]\u003c/code\u003e correctly.\nVisually the code is just dreadful.\nIt’s hard to quickly discern what value is flowing from line to line.\u003c/p\u003e\n\n\u003cp\u003eUsing \u003ccode\u003epartition\u003c/code\u003e was just my first intuition.\nBut a \u003ccode\u003epartition\u003c/code\u003e that throws away half the result has another name: a \u003ccode\u003efilter\u003c/code\u003e!\u003c/p\u003e\n\n\u003ch3 id=\"attempt-5\"\u003eAttempt 5\u003c/h3\u003e\n\n\u003cp\u003eFifth attempt at this now using a filter.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilterNot\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eHashSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;()\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis continues to print \u003ccode\u003e[1, 3]\u003c/code\u003e correctly.\nWe use \u003ccode\u003efilterNot\u003c/code\u003e because we want to keep elements where \u003ccode\u003eMutableSet.add\u003c/code\u003e returns \u003cem\u003efalse\u003c/em\u003e.\nVisually this is pretty decent.\u003c/p\u003e\n\n\u003cp\u003eThe use of \u003ccode\u003eHashSet\u0026lt;Int\u0026gt;()::add\u003c/code\u003e is what’s known as a \u003cem\u003ebound\u003c/em\u003e reference.\nWe are specifying a function reference of \u003ccode\u003eMutableSet::add\u003c/code\u003e as our \u003ccode\u003efilterNot\u003c/code\u003e lambda, but bound to an instance of \u003ccode\u003eHashSet\u003c/code\u003e which we are creating on-the-fly.\nThis is an equivalent version of the above code.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eseen\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eHashSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;()\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilterNot\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eseen\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoSet\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe advantage of inlining the \u003ccode\u003eHashSet\u003c/code\u003e instantiation is that we don’t need to name it.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\n\u003ch3 id=\"attempt-51\"\u003eAttempt 5.1\u003c/h3\u003e\n\n\u003cp\u003eFinally, almost all of Kotlin’s collection extensions have \u003ccode\u003eTo\u003c/code\u003e-suffixed variants which allow supplying a destination collection.\nThis can save you from having to add a \u003ccode\u003etoSomething()\u003c/code\u003e after an operation by instead just using that \u003ccode\u003eSomething\u003c/code\u003e in the operation directly.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edupes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e\n    \u003cspan\u003eints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efilterNotTo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eHashSet\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e \u003cspan\u003eHashSet\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;()\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003ePretty, pretty, pretty good.\u003c/p\u003e\n\n\u003ch3 id=\"benchmarks\"\u003eBenchmarks\u003c/h3\u003e\n\n\u003cp\u003ePerformance is not really a concern in my usage, but let’s look anyway.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eBenchmark                                       Score      Error   Units\n----------------------------------------------  ---------  ------  -----\nIntDupes.map                                     94.015 ±   0.469  ns/op\nIntDupes.map:·gc.alloc.rate.norm                776.000 ±   0.001   B/op\n\nIntDupes.mutableListRemove                      155.744 ±  17.829  ns/op\nIntDupes.mutableListRemove:·gc.alloc.rate.norm  560.000 ±   0.001   B/op\n\nIntDupes.partition                              135.693 ±  18.976  ns/op\nIntDupes.partition:·gc.alloc.rate.norm          544.000 ±   0.001   B/op\n\nIntDupes.filterNot                               97.748 ±   1.055  ns/op\nIntDupes.filterNot:·gc.alloc.rate.norm          504.000 ±   0.001   B/op\n\nIntDupes.filterNotTo                             39.904 ±   0.331  ns/op\nIntDupes.filterNotTo:·gc.alloc.rate.norm        432.000 ±   0.001   B/op\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSo the \u003ccode\u003efilterNotTo\u003c/code\u003e winds up being the fastest and allocates the fewest bytes.\nDouble win!\u003c/p\u003e\n\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-02-14T00:00:00Z",
  "modifiedTime": null
}
