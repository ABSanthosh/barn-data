{
  "id": "6e759ff4-b35c-4f83-b088-8f9a7e1588d0",
  "title": "Using the `kotlin-dsl` Gradle Plugin forces Kotlin 1.4 Compatibility üò±",
  "link": "https://handstandsam.com/2022/04/13/using-the-kotlin-dsl-gradle-plugin-forces-kotlin-1-4-compatibility/",
  "description": "I previously wrote an article ‚ÄúSharing Gradle Configuration in Multi-Module Android Projects‚Äù about re-using Gradle configuration using the ‚Äúapply‚Äù feature to reduce boilerplate and provide consistency. It‚Äôs super helpful and handy, but there is now a better way to do the same kind of thing using Gradle Convention Plugins. Gradle Convention Plugins There is a [‚Ä¶]",
  "author": "Sam Edwards",
  "published": "Wed, 13 Apr 2022 18:09:51 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Gradle",
    "Kotlin"
  ],
  "byline": "Sam Edwards",
  "length": 4679,
  "excerpt": "I previously wrote an article ‚ÄúSharing Gradle Configuration in Multi-Module Android Projects‚Äù about re-using Gradle configuration using the ‚Äúapply‚Äù feature to reduce boilerplate and provide consistency. It‚Äôs super helpful and handy, but there is now a better way to do the same kind of thing using Gradle Convention Plugins.",
  "siteName": "",
  "favicon": "",
  "text": "I previously wrote an article ‚ÄúSharing Gradle Configuration in Multi-Module Android Projects‚Äù about re-using Gradle configuration using the ‚Äúapply‚Äù feature to reduce boilerplate and provide consistency. It‚Äôs super helpful and handy, but there is now a better way to do the same kind of thing using Gradle Convention Plugins. Gradle Convention Plugins There is a great post by Tony Robalik that goes into the benefits of Gradle Convention Plugins. I say it is ‚Äúbetter‚Äù because it can be pre-compiled, written in Kotlin and tested in Kotlin. These convention plugins are most easily added in buildSrc, so I figured I‚Äôd start there when adding it to my existing project. My journey writing a Gradle Convention Plugin and how I ran into Kotlin 1.4 So, in a large Android project I added the ‚Äúkotlin-dsl‚Äù plugin to the buildSrc module and things blew up. I‚Äôm using the latest version of Gradle 7.4.2, yet it is telling me: Language version 1.4 is deprecated and its support will be removed in a future version of Kotlin I had specified Kotlin 1.6.10 everywhere! What was I doing wrong? Nothing. It‚Äôs intentional. Gradle even calls out why on their site: Gradle plugins written in Kotlin target Kotlin 1.4 for compatibility with Gradle and Kotlin DSL build scripts, even though the embedded Kotlin runtime is Kotlin 1.5.https://docs.gradle.org/current/userguide/compatibility.html#kotlin Even though it is intentional, it wasn‚Äôt immediately clear to me, and to others, but I understand the thinking behind it now, and in this post show you how you can get around it if you need to. Martin Bonnin has a great post talking about how you could get around this by doing some crazy things like creating shadow jars, but his answer of ‚ÄúShould I use this in production?‚Äù was ‚Äúit depends‚Äù, and where possible, I try to not use complex workarounds (even though this post is a less complex workaround üòÇ). Gradle 7.4.2 still targets Kotlin 1.4 with the kotlin-dsl plugin, even though 1.5.31 is embedded now in Gradle 7.4.2. Gradle plugin compatibility is very important when distributing plugins publicly, but if you are just going to use them in your team or organization, you may not want to support old version of Kotlin going back to 1.4. In order to use the version of Kotlin available in the version of Gradle you have, you need to specify the version yourself to override the default. import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { `kotlin-dsl` } afterEvaluate { tasks.withType\u003cKotlinCompile\u003e().configureEach { kotlinOptions { apiVersion = \"1.5\" languageVersion = \"1.5\" } } } This will allow you to use Kotlin 1.5 syntax now when using the ‚Äúkotlin-dsl‚Äù plugin! One thing that is weird about this is the need for afterEvaulate. I‚Äôm not 100% sure why it was needed, but it‚Äôs how they specify it in Gradle source code, and it doesn‚Äôt work without adding afterEvaluate. But‚Ä¶ what about Kotlin 1.6? If you really want to use Kotlin 1.6 though, fear not! Kotlin 1.6.10 is going to be available with Gradle 7.5 when it comes out. When it does, you should be able to use this configuration to use 1.6 compatibility: import org.jetbrains.kotlin.gradle.tasks.KotlinCompile plugins { `kotlin-dsl` } afterEvaluate { tasks.withType\u003cKotlinCompile\u003e().configureEach { kotlinOptions { apiVersion = \"1.6\" languageVersion = \"1.6\" } } } Kotlin/Gradle Version Table when using kotlin-dsl Gradle VersionEmbedded Kotlin VersionDefault Api Version7.5 (Unreleased as of April 14, 2022)1.6.101.47.3+1.5.311.47.0+1.4.301.4 What do you recommend? If you are only going to use this plugin internally, and everyone is using the same version of Kotlin everywhere, this seems pretty safe. If you are looking to open source something for public use, you may need to call out a minimum Gradle version required use your Plugin. Should I put my Gradle Convention Plugin in buildSrc? This is the first place you should try it out. You will have the same issue with any code you put in buildSrc though, where if any code changes, all code and tests in buildSrc have to be re-run which increases build times. If you plan to use this a lot going forward, use an includeBuild to add in your Convention Plugins going forward so that you only re-compile when that code changes, and so you could publish a binary to avoid any compilation at all. Reviewers Thanks Martin Bonnin and Tony Robalik for reviewing the article. Also special thanks to Martin for helping me dig into the Gradle source to figure this out!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1870\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eI previously wrote an article ‚Äú\u003ca href=\"https://handstandsam.com/2019/03/12/sharing-gradle-configuration-in-multi-module-android-projects/\"\u003eSharing Gradle Configuration in Multi-Module Android Projects\u003c/a\u003e‚Äù about re-using Gradle configuration using the ‚Äúapply‚Äù feature to reduce boilerplate and provide consistency.  It‚Äôs super helpful and handy, \u003cstrong\u003ebut there is now a better way\u003c/strong\u003e to do the same kind of thing using \u003ca href=\"https://docs.gradle.org/current/samples/sample_convention_plugins.html#organizing_build_logic\"\u003eGradle Convention Plugins\u003c/a\u003e.  \u003c/p\u003e\n\n\n\n\u003ch2\u003eGradle Convention Plugins\u003c/h2\u003e\n\n\n\n\u003cp\u003eThere is \u003ca href=\"https://developer.squareup.com/blog/herding-elephants/\"\u003ea great post by Tony Robalik\u003c/a\u003e that goes into the benefits of \u003ca href=\"https://docs.gradle.org/current/samples/sample_convention_plugins.html#organizing_build_logic\" data-type=\"URL\" data-id=\"https://docs.gradle.org/current/samples/sample_convention_plugins.html#organizing_build_logic\"\u003eGradle Convention Plugins\u003c/a\u003e. I say it is ‚Äúbetter‚Äù because it can be pre-compiled, written in Kotlin and tested in Kotlin. These convention plugins are most easily added in buildSrc, so I figured I‚Äôd start there when adding it to my existing project.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMy journey writing a Gradle Convention Plugin and how I ran into Kotlin 1.4\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo, in a large Android project I added the ‚Äú\u003ca href=\"https://docs.gradle.org/current/userguide/kotlin_dsl.html\"\u003ekotlin-dsl\u003c/a\u003e‚Äù plugin to the buildSrc module and things blew up.  I‚Äôm using the latest version of \u003ca href=\"https://docs.gradle.org/7.4.2/release-notes.html\"\u003eGradle 7.4.2\u003c/a\u003e, yet it is telling me:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eLanguage version 1.4 is deprecated and its support will be removed in a future version of Kotlin\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eI had specified Kotlin 1.6.10 everywhere!  What was I doing wrong?\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eNothing.  It‚Äôs intentional.  Gradle even calls out why \u003ca href=\"https://docs.gradle.org/current/userguide/compatibility.html#kotlin\"\u003eon their site\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\u003cp\u003eGradle plugins written in Kotlin target Kotlin 1.4 for compatibility with Gradle and Kotlin DSL build scripts, even though the embedded Kotlin runtime is Kotlin 1.5.\u003c/p\u003e\u003ccite\u003e\u003ca href=\"https://docs.gradle.org/current/userguide/compatibility.html#kotlin\"\u003ehttps://docs.gradle.org/current/userguide/compatibility.html#kotlin\u003c/a\u003e\u003c/cite\u003e\u003c/blockquote\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://docs.gradle.org/7.2/userguide/kotlin_dsl.html#sec:kotlin\"\u003eEven though it is intentional\u003c/a\u003e, it wasn‚Äôt immediately clear to me, \u003ca href=\"https://github.com/gradle/gradle/issues/16345\"\u003eand to others\u003c/a\u003e, but I understand the thinking behind it now, and in this post show you how you can get around it if you need to.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://blog.mbonnin.net/use-kotlin-15-in-your-gradle-plugins\"\u003eMartin Bonnin has a great post\u003c/a\u003e talking about how you could get around this by doing some crazy things like creating shadow jars, but his answer of ‚ÄúShould I use this in production?‚Äù was ‚Äúit depends‚Äù, and where possible, I try to not use complex workarounds (even though this post is a less complex workaround üòÇ).\u003c/p\u003e\n\n\n\n\u003cp\u003eGradle 7.4.2 \u003ca href=\"https://github.com/gradle/gradle/blob/7a69f2f3d791044b946040cd43097ce57f430ca8/subprojects/kotlin-dsl-plugins/src/main/kotlin/org/gradle/kotlin/dsl/plugins/dsl/KotlinDslCompilerPlugins.kt#L48-L49\"\u003estill targets Kotlin 1.4 with the kotlin-dsl plugin\u003c/a\u003e, even though \u003ca href=\"https://github.com/gradle/gradle/commit/15e7bfaedaa8b853bb113086bce60d9f55658c70\" data-type=\"URL\" data-id=\"https://github.com/gradle/gradle/commit/15e7bfaedaa8b853bb113086bce60d9f55658c70\"\u003e1.5.31 is embedded now in Gradle 7.4.2\u003c/a\u003e.  Gradle plugin compatibility is very important when distributing plugins publicly, but if you are just going to use them in your team or organization, you may not want to support old version of Kotlin going back to 1.4.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn order to use the version of Kotlin available in the version of Gradle you have, you need to specify the version yourself to override the default.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    `kotlin-dsl`\n}\n\nafterEvaluate {\n    tasks.withType\u0026lt;KotlinCompile\u0026gt;().configureEach {\n        kotlinOptions {\n            apiVersion = \u0026#34;1.5\u0026#34;\n            languageVersion = \u0026#34;1.5\u0026#34;\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eT\u003cstrong\u003ehis will allow you to use Kotlin 1.5 syntax now when using the ‚Äúkotlin-dsl‚Äù plugin!\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eOne thing that is weird about this is the need for \u003ccode\u003eafterEvaulate\u003c/code\u003e.  I‚Äôm not 100% sure why it was needed, but \u003ca href=\"https://github.com/gradle/gradle/blob/7a69f2f3d791044b946040cd43097ce57f430ca8/subprojects/kotlin-dsl-plugins/src/main/kotlin/org/gradle/kotlin/dsl/plugins/dsl/KotlinDslCompilerPlugins.kt#L43-L56\"\u003eit‚Äôs how they specify it in Gradle source code\u003c/a\u003e, and it doesn‚Äôt work without adding \u003ccode\u003eafterEvaluate\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBut‚Ä¶ what about Kotlin 1.6?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you really want to use Kotlin 1.6 though, fear not!  Kotlin 1.6.10 is \u003ca href=\"https://github.com/gradle/gradle/pull/19539\"\u003egoing to be available with Gradle 7.5 when it comes out\u003c/a\u003e.  When it does, you should be able to use this configuration to use 1.6 compatibility:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\n\nplugins {\n    `kotlin-dsl`\n}\n\nafterEvaluate {\n    tasks.withType\u0026lt;KotlinCompile\u0026gt;().configureEach {\n        kotlinOptions {\n            apiVersion = \u0026#34;1.6\u0026#34;\n            languageVersion = \u0026#34;1.6\u0026#34;\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch2\u003eKotlin/Gradle Version Table when using \u003ccode\u003ekotlin-dsl\u003c/code\u003e\u003c/h2\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eGradle Version\u003c/td\u003e\u003ctd\u003eEmbedded Kotlin Version\u003c/td\u003e\u003ctd\u003eDefault Api Version\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"https://github.com/gradle/gradle/pull/19539\"\u003e7.5 (Unreleased as of April 14, 2022)\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e1.6.10\u003c/td\u003e\u003ctd\u003e1.4\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"https://github.com/gradle/gradle/pull/18148\"\u003e7.3+\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e1.5.31\u003c/td\u003e\u003ctd\u003e1.4\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ca href=\"https://github.com/gradle/gradle/pull/16352\"\u003e7.0+\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e1.4.30\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://github.com/gradle/gradle/commit/0724acf72648d14c03b6fcf0019cebfb7f4bf178\"\u003e1.4\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eWhat do you recommend?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you are only going to use this plugin internally, and everyone is using the same version of Kotlin everywhere, this seems pretty safe.  If you are looking to open source something for public use, you may need to call out a minimum Gradle version required use your Plugin.\u003c/p\u003e\n\n\n\n\u003ch2\u003eShould I put my Gradle Convention Plugin in buildSrc?\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis is the first place you should try it out.  You will have the same issue with any code you put in buildSrc though, where if any code changes, all code and tests in buildSrc have to be re-run which increases build times.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you plan to use this a lot going forward, use an \u003ca href=\"https://docs.gradle.org/current/samples/sample_composite_builds_basics.html\"\u003eincludeBuild\u003c/a\u003e to add in your Convention Plugins going forward so that you only re-compile when that code changes, and so you could publish a binary to avoid any compilation at all.\u003c/p\u003e\n\n\n\n\u003ch2\u003eReviewers\u003c/h2\u003e\n\n\n\n\u003cp\u003eThanks \u003ca href=\"https://twitter.com/martinbonnin\"\u003eMartin Bonnin\u003c/a\u003e and \u003ca href=\"https://twitter.com/AutonomousApps\" data-type=\"URL\" data-id=\"https://twitter.com/AutonomousApps\"\u003eTony Robalik\u003c/a\u003e for reviewing the article.  Also special thanks to \u003ca href=\"https://twitter.com/martinbonnin\"\u003eMartin\u003c/a\u003e for helping me dig into the Gradle source to figure this out!\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
