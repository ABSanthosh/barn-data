{
  "id": "b9844005-e838-4103-8efd-8722868bcda7",
  "title": "Saving the UI State in a Compose Multiplatform App",
  "link": "https://proandroiddev.com/saving-the-ui-state-in-a-compose-multiplatform-app-8e1c57500986?source=rss----c72404660798---4",
  "description": "",
  "author": "Ruben Quadros",
  "published": "Mon, 26 May 2025 08:31:39 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "savedstatehandle",
    "kmm",
    "viewmodel",
    "compose-multiplatform",
    "ui-state"
  ],
  "byline": "Ruben Quadros",
  "length": 8020,
  "excerpt": "Learn how to use SavedStateHandle in the ViewModel within a Compose Multiplatform app to preserve UI state across process death.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Saving the UI State in a Compose Multiplatform AppLearn how you can save your UI state in the SavedStateHandleIntroductionWhat is process death? When the user puts your app in the background and starts interacting with other apps, the system does its best to keep your app process in memory. However, the system might decide to destroy your app process due to several reasons (battery optimization, performance optimization, resource management). In such a scenario the activity instance is destroyed. When the user now comes back to your app, the activity is recreated. Since the whole activity is recreated, any data that was previously saved in the ViewModel is also lost. Only the data which was saved on the disk or network (server) survives.What can we do to prevent this? Well, there are a few strategies which can be used to save important data. In this article, we’ll look at how we can save our UI state in the SavedStateHandle which can be directly accessed in the ViewModel.Before we proceed, I would also encourage you to read more about saving UI states and other potential solutions to this problem — here.SavedStateHandle in Compose MultiplatformIt is important to note that Multiplatform support was added to SavedStateHandle starting from the version 2.9.0-alpha07. This version uses KotlinX Serialization to save and restore items. You can read more about the Multiplatform support for SavedStateHandle — here.For the sake of demonstration, we will create a simple counter app in which the user can increment and decrement the counter and also see the value of the counter.If you want to see the source code of the sample app and also a real app where I have used a similar implementation you can skip to the end!Sample appDependencies and gradle setupMake sure you have the following dependencies in your libs.versions.toml file.[versions]androidx-lifecycle = \"2.9.0-beta01\"kotlinxSerialization = \"2.1.21\"[libraries]//Saved state module for ViewModelandroidx-lifecycle-savedstate = { module = \"org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-savedstate\", version.ref = \"androidx-lifecycle\" }[plugins]kotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlinxSerialization\" }Include the KotlinX Serialization plugin in the root build.gradle.kts file.plugins { // this is necessary to avoid the plugins to be loaded multiple times // in each subproject's classloader // ..other plugins alias(libs.plugins.kotlinxSerialization) apply false}Now, also include the dependency and plugin in the build.gradle.kts file of your composeApp module.plugins { // ..other plugins alias(libs.plugins.kotlinxSerialization)}kotlin { sourceSets { commonMain.dependencies { // ..other dependen implementation(libs.androidx.lifecycle.savedstate) } }}Now that our dependencies are setup, let’s look at how we can use SavedStateHandle in our ViewModel!ViewModel and SavedStateHandle in actionLet’s first setup our UI code. It’s a simple composable with 2 buttons to increment and decrement the counter and a text component to show the count.//Screen@Composablefun MainScreen( viewModel: MainViewModel = viewModel(factory = MainViewModel.FACTORY)) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() Column( modifier = Modifier.fillMaxSize(), horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.spacedBy(16.dp) ) { Text(\"Count: ${uiState.counter}\") Row( horizontalArrangement = Arrangement.spacedBy(16.dp) ){ Button( enabled = uiState.counter \u003e 0, onClick = viewModel::decrement ) { Text(\"-\") } Button( onClick = viewModel::increment ) { Text(\"+\") } } }}Now let’s setup our UI state and the ViewModel which is our main star.@Serializable //#2data class UiState( val counter: Int = 0)class MainViewModel(savedStateHandle: SavedStateHandle) : ViewModel() { //#1 private var _savedState: UiState by savedStateHandle.saved( key = \"SAVED_STATE\", init = { UiState() } ) //#3 private val _uiState: MutableStateFlow\u003cUiState\u003e = MutableStateFlow(_savedState) val uiState: StateFlow\u003cUiState\u003e = _uiState.asStateFlow() fun increment() { _uiState.update { state -\u003e val counter = state.counter _savedState = state.copy(counter = counter+1) //#4 _savedState } } fun decrement() { _uiState.update { state -\u003e val counter = state.counter _savedState = state.copy(counter = counter-1) //#5 _savedState } } companion object { val FACTORY = object : ViewModelProvider.Factory { override fun \u003cT : ViewModel\u003e create(modelClass: KClass\u003cT\u003e, extras: CreationExtras): T { return MainViewModel( savedStateHandle = extras.createSavedStateHandle() ) as T } } }}This is it! Whenever the state is updated it always saves the latest state into the SavedStateHandle.If you are also curious how this actually works under the hood, stick around — we’ll go through the above code step by step and understand how each part works!1. How can we use SavedStateHandle to save and restore the state?Looking at the code, we do not use the old Android SavedStateHandle methods to save and retrieve the values i.e. the set and get methods. Instead, we make use of the newly introduced saved extension method.Now, what is this saved extension and how does it work?Quoting from the source code, it returns a property delegate which uses SavedStateHandle to save and restore the value of type T using the default serializer. In our case the type is UiState.There is also another saved method which let’s you pass your serializer. This is particularly helpful if UiState is a sealed class or a sealed interface.2. Why do we have to add the Serializable annotation to our UI state?Let’s refresh our memory and also dive a bit deeper into why this is required. As stated previously, SavedStateHandle makes use of KotlinX Serialization to store and restore the state across process death.If you look at the delegate source code, you’ll see that when the setValue method is called, it internally invokes encodeToSavedState. This basically serializes our UiState. Similarly, when the getValue method is called, it internally invokes decodeFromSavedState and this basically deserializes our UiState.3. Restoring the state from SavedStateHandleLet’s take a look at the following code again.private var _savedState: UiState by savedStateHandle.saved( key = \"SAVED_STATE\", init = { UiState() })private val _uiState: MutableStateFlow\u003cUiState\u003e = MutableStateFlow(_savedState)Reading _savedState calls the delegate getValue method. This basically tries to get any previously saved value with key SAVED_STATE and if it does not find any value, it assigns the the value provided in the init param.4\u00265. Saving the latest state into SavedStateHandleSetting _savedState calls the delegate setValue method. This basically sets a value with key SAVED_STATE into the SavedStateHandle. Any previous value will be overwritten with the new value.Verifying the solutionBefore we move on to verifying the solution, if you are verifying it on an Android device, there is one important point from the docs I want you to understand:Saved instance state APIs only save data written to it when the Activity is stopped. Writing into it in between this lifecycle state defers the save operation till the next stopped lifecycle event.To verify the solution, we will simply put our app in the background (by clicking the home button) and then kill the app process via the Logcat.And there we go! We can see that our counter state with value 6 is successfully restored when the user returns to the app.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*2vDpSazA7m7mImbWZC58qQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"a301\" data-testid=\"storyTitle\"\u003eSaving the UI State in a Compose Multiplatform App\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"d000\"\u003eLearn how you can save your UI state in the SavedStateHandle\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://ruben-quadros.medium.com/?source=post_page---byline--8e1c57500986---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ruben Quadros\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*u-hTZ-0pZE-mD76DRommHA.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8566\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"2803\"\u003eWhat is \u003cstrong\u003e\u003cem\u003eprocess death\u003c/em\u003e\u003c/strong\u003e? When the user puts your app in the background and starts interacting with other apps, the system does its best to keep your app process in memory. However, the system might decide to destroy your app process due to several reasons (battery optimization, performance optimization, resource management). In such a scenario the activity instance is destroyed. When the user now comes back to your app, the activity is recreated. Since the whole activity is recreated, any data that was previously saved in the \u003ccode\u003eViewModel\u003c/code\u003e is also lost. Only the data which was saved on the disk or network (server) survives.\u003c/p\u003e\u003cp id=\"ea45\"\u003eWhat can we do to \u003cstrong\u003e\u003cem\u003eprevent this\u003c/em\u003e\u003c/strong\u003e? Well, there are a few strategies which can be used to save important data. In this article, we’ll look at how we can save our UI state in the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eSavedStateHandle\u003c/em\u003e\u003c/a\u003e\u003c/code\u003e which can be directly accessed in the \u003ccode\u003eViewModel\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"6e72\"\u003eBefore we proceed, I would also encourage you to read more about saving UI states and other potential solutions to this problem — \u003ca href=\"https://developer.android.com/topic/libraries/architecture/saving-states\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003ehere\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"c5a5\"\u003eSavedStateHandle in Compose Multiplatform\u003c/h2\u003e\u003cp id=\"60ed\"\u003eIt is important to note that \u003cem\u003eMultiplatform\u003c/em\u003e support was added to \u003cem\u003eSavedStateHandle\u003c/em\u003e starting from the version \u003cstrong\u003e\u003cem\u003e2.9.0-alpha07\u003c/em\u003e\u003c/strong\u003e. This version uses \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eKotlinX Serialization\u003c/em\u003e\u003c/a\u003e to save and restore items. You can read more about the \u003cem\u003eMultiplatform\u003c/em\u003e support for \u003cem\u003eSavedStateHandle —\u003c/em\u003e \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/lifecycle#2.9.0-alpha07\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003ehere\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"7bf1\"\u003eFor the sake of demonstration, we will create a simple counter app in which the user can increment and decrement the counter and also see the value of the counter.\u003c/p\u003e\u003cp id=\"172e\"\u003eIf you want to see the source code of the sample app and also a real app where I have used a similar implementation you can skip to the end!\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSample app\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"0e4b\"\u003eDependencies and gradle setup\u003c/h2\u003e\u003cp id=\"c86a\"\u003eMake sure you have the following dependencies in your \u003cstrong\u003e\u003cem\u003elibs.versions.toml\u003c/em\u003e\u003c/strong\u003e file.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"92c2\"\u003e[versions]\u003cbr/\u003eandroidx-lifecycle = \u0026#34;2.9.0-beta01\u0026#34;\u003cbr/\u003ekotlinxSerialization = \u0026#34;2.1.21\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003e//Saved state module for ViewModel\u003cbr/\u003eandroidx-lifecycle-savedstate = { module = \u0026#34;org.jetbrains.androidx.lifecycle:lifecycle-viewmodel-savedstate\u0026#34;, version.ref = \u0026#34;androidx-lifecycle\u0026#34; }\u003c/p\u003e\u003cp\u003e[plugins]\u003cbr/\u003ekotlinxSerialization = { id = \u0026#34;org.jetbrains.kotlin.plugin.serialization\u0026#34;, version.ref = \u0026#34;kotlinxSerialization\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b428\"\u003eInclude the \u003cem\u003eKotlinX Serialization\u003c/em\u003e plugin in the root \u003cstrong\u003e\u003cem\u003ebuild.gradle.kts\u003c/em\u003e\u003c/strong\u003e file.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"11d8\"\u003eplugins {\u003cbr/\u003e    // this is necessary to avoid the plugins to be loaded multiple times\u003cbr/\u003e    // in each subproject\u0026#39;s classloader\u003cp\u003e    // ..other plugins\u003c/p\u003e\u003cp\u003e    alias(libs.plugins.kotlinxSerialization) apply false\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"db6e\"\u003eNow, also include the dependency and plugin in the \u003cstrong\u003e\u003cem\u003ebuild.gradle.kts\u003c/em\u003e\u003c/strong\u003e file of your \u003cstrong\u003e\u003cem\u003ecomposeApp\u003c/em\u003e\u003c/strong\u003e module.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6152\"\u003eplugins {\u003cbr/\u003e    // ..other plugins\u003cbr/\u003e    alias(libs.plugins.kotlinxSerialization)\u003cbr/\u003e}\u003cp\u003ekotlin {\u003cbr/\u003e    sourceSets {\u003cbr/\u003e        commonMain.dependencies {\u003cbr/\u003e            // ..other dependen\u003cbr/\u003e            implementation(libs.androidx.lifecycle.savedstate)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0912\"\u003eNow that our dependencies are setup, let’s look at how we can use \u003ccode\u003eSavedStateHandle\u003c/code\u003e in our \u003ccode\u003eViewModel\u003c/code\u003e!\u003c/p\u003e\u003ch2 id=\"7afa\"\u003eViewModel and SavedStateHandle in action\u003c/h2\u003e\u003cp id=\"66a6\"\u003eLet’s first setup our UI code. It’s a simple composable with 2 buttons to increment and decrement the counter and a text component to show the count.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4302\"\u003e//Screen\u003cbr/\u003e@Composable\u003cbr/\u003efun MainScreen(\u003cbr/\u003e    viewModel: MainViewModel = viewModel(factory = MainViewModel.FACTORY)\u003cbr/\u003e) {\u003cbr/\u003e    val uiState by viewModel.uiState.collectAsStateWithLifecycle()\u003cp\u003e    Column(\u003cbr/\u003e        modifier = Modifier.fillMaxSize(),\u003cbr/\u003e        horizontalAlignment = Alignment.CenterHorizontally,\u003cbr/\u003e        verticalArrangement = Arrangement.spacedBy(16.dp)\u003cbr/\u003e    ) {\u003cbr/\u003e        Text(\u0026#34;Count: ${uiState.counter}\u0026#34;)\u003c/p\u003e\u003cp\u003e        Row(\u003cbr/\u003e            horizontalArrangement = Arrangement.spacedBy(16.dp)\u003cbr/\u003e        ){\u003cbr/\u003e           Button(\u003cbr/\u003e               enabled = uiState.counter \u0026gt; 0,\u003cbr/\u003e               onClick = viewModel::decrement\u003cbr/\u003e           ) {\u003cbr/\u003e               Text(\u0026#34;-\u0026#34;)\u003cbr/\u003e           }\u003c/p\u003e\u003cp\u003e            Button(\u003cbr/\u003e                onClick = viewModel::increment\u003cbr/\u003e            ) {\u003cbr/\u003e                Text(\u0026#34;+\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3e99\"\u003eNow let’s setup our UI state and the \u003ccode\u003e\u003cstrong\u003e\u003cem\u003eViewModel\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e which is our main star.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8f68\"\u003e@Serializable //#2\u003cbr/\u003edata class UiState(\u003cbr/\u003e    val counter: Int = 0\u003cbr/\u003e)\u003cp\u003eclass MainViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {\u003c/p\u003e\u003cp\u003e    //#1\u003cbr/\u003e    private var _savedState: UiState by savedStateHandle.saved(\u003cbr/\u003e        key = \u0026#34;SAVED_STATE\u0026#34;,\u003cbr/\u003e        init = { UiState() }\u003cbr/\u003e    )\u003c/p\u003e\u003cp\u003e    //#3 \u003cbr/\u003e    private val _uiState: MutableStateFlow\u0026lt;UiState\u0026gt; = MutableStateFlow(_savedState)\u003cbr/\u003e    val uiState: StateFlow\u0026lt;UiState\u0026gt; = _uiState.asStateFlow()\u003c/p\u003e\u003cp\u003e    fun increment() {\u003cbr/\u003e        _uiState.update { state -\u0026gt;\u003cbr/\u003e            val counter = state.counter\u003cbr/\u003e            _savedState = state.copy(counter = counter+1) //#4\u003cbr/\u003e            _savedState\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun decrement() {\u003cbr/\u003e        _uiState.update { state -\u0026gt;\u003cbr/\u003e            val counter = state.counter\u003cbr/\u003e            _savedState = state.copy(counter = counter-1) //#5\u003cbr/\u003e            _savedState\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    companion object {\u003cbr/\u003e        val FACTORY = object : ViewModelProvider.Factory {\u003cbr/\u003e            override fun \u0026lt;T : ViewModel\u0026gt; create(modelClass: KClass\u0026lt;T\u0026gt;, extras: CreationExtras): T {\u003cbr/\u003e                return MainViewModel(\u003cbr/\u003e                    savedStateHandle = extras.createSavedStateHandle()\u003cbr/\u003e                ) as T\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"439d\"\u003eThis is it! Whenever the state is updated it always saves the latest state into the \u003cem\u003eSavedStateHandle\u003c/em\u003e.\u003c/p\u003e\u003cp id=\"a122\"\u003eIf you are also curious how this actually works under the hood, stick around — we’ll go through the above code step by step and understand how each part works!\u003c/p\u003e\u003ch2 id=\"e625\"\u003e1. How can we use \u003cstrong\u003e\u003cem\u003eSavedStateHandle\u003c/em\u003e\u003c/strong\u003e to save and restore the state?\u003c/h2\u003e\u003cp id=\"7e25\"\u003eLooking at the code, we do not use the old Android \u003ccode\u003e\u003cem\u003eSavedStateHandle\u003c/em\u003e\u003c/code\u003e methods to save and retrieve the values i.e. the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle#set(kotlin.String,kotlin.Any)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eset\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle#get(kotlin.String)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eget\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e \u003c/em\u003e\u003c/strong\u003emethods. Instead, we make use of the newly introduced \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle#(androidx.lifecycle.SavedStateHandle).saved(kotlin.String,androidx.savedstate.serialization.SavedStateConfiguration,kotlin.Function0)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003esaved\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/code\u003e extension method.\u003c/p\u003e\u003cp id=\"4a42\"\u003eNow, what is this \u003ccode\u003e\u003cem\u003esaved\u003c/em\u003e\u003c/code\u003e extension and how does it work?\u003c/p\u003e\u003cp id=\"69ad\"\u003eQuoting from the \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-viewmodel-savedstate/src/commonMain/kotlin/androidx/lifecycle/serialization/SavedStateHandleDelegate.kt?q=file%3Aandroidx%2Flifecycle%2Fserialization%2FSavedStateHandleDelegate.kt+function%3Asaved\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esource code\u003c/a\u003e, it returns a property delegate which uses \u003ccode\u003e\u003cem\u003eSavedStateHandle\u003c/em\u003e\u003c/code\u003e to save and restore the value of type T using the default serializer. In our case the type is \u003ccode\u003e\u003cstrong\u003e\u003cem\u003eUiState\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"676f\"\u003eThere is also another \u003ccode\u003e\u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-viewmodel-savedstate/src/commonMain/kotlin/androidx/lifecycle/serialization/SavedStateHandleDelegate.kt;l=41\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003esaved\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/code\u003e method which let’s you pass your serializer. This is particularly helpful if \u003ccode\u003eUiState\u003c/code\u003e is a \u003cstrong\u003e\u003cem\u003esealed class\u003c/em\u003e\u003c/strong\u003e or a \u003cstrong\u003e\u003cem\u003esealed interface\u003c/em\u003e\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"497b\"\u003e2. Why do we have to add the \u003cstrong\u003e\u003cem\u003eSerializable\u003c/em\u003e\u003c/strong\u003e annotation to our UI state?\u003c/h2\u003e\u003cp id=\"f2f6\"\u003eLet’s refresh our memory and also dive a bit deeper into why this is required. As stated previously, \u003cem\u003eSavedStateHandle\u003c/em\u003e makes use of \u003cem\u003eKotlinX Serialization\u003c/em\u003e to store and restore the state across process death.\u003c/p\u003e\u003cp id=\"4e12\"\u003eIf you look at the \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-viewmodel-savedstate/src/commonMain/kotlin/androidx/lifecycle/serialization/SavedStateHandleDelegate.kt;l=67\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edelegate source code\u003c/a\u003e, you’ll see that when the \u003ccode\u003e\u003cem\u003esetValue\u003c/em\u003e\u003c/code\u003e method is called, it internally invokes \u003ccode\u003e\u003cem\u003eencodeToSavedState\u003c/em\u003e\u003c/code\u003e\u003cem\u003e. \u003c/em\u003eThis basically serializes our \u003ccode\u003eUiState\u003c/code\u003e. Similarly, when the \u003ccode\u003e\u003cem\u003egetValue\u003c/em\u003e\u003c/code\u003e method is called, it internally invokes \u003ccode\u003e\u003cem\u003edecodeFromSavedState\u003c/em\u003e\u003c/code\u003e\u003cem\u003e \u003c/em\u003eand this basically deserializes our \u003ccode\u003eUiState\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"f2ac\"\u003e3. Restoring the state from SavedStateHandle\u003c/h2\u003e\u003cp id=\"ea24\"\u003eLet’s take a look at the following code again.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2053\"\u003eprivate var _savedState: UiState by savedStateHandle.saved(\u003cbr/\u003e        key = \u0026#34;SAVED_STATE\u0026#34;,\u003cbr/\u003e        init = { UiState() }\u003cbr/\u003e)\u003cp\u003eprivate val _uiState: MutableStateFlow\u0026lt;UiState\u0026gt; = MutableStateFlow(_savedState)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c2d6\"\u003eReading \u003ccode\u003e_savedState\u003c/code\u003e calls the delegate \u003ccode\u003egetValue\u003c/code\u003e method. This basically tries to get any previously saved value with key \u003cstrong\u003e\u003cem\u003eSAVED_STATE \u003c/em\u003e\u003c/strong\u003eand if it does not find any value, it assigns the the value provided in the \u003ccode\u003einit\u003c/code\u003e param.\u003c/p\u003e\u003ch2 id=\"af9f\"\u003e4\u0026amp;5. Saving the latest state into SavedStateHandle\u003c/h2\u003e\u003cp id=\"f763\"\u003eSetting \u003ccode\u003e_savedState\u003c/code\u003e calls the delegate \u003ccode\u003esetValue\u003c/code\u003e method. This basically sets a value with key \u003cstrong\u003e\u003cem\u003eSAVED_STATE\u003c/em\u003e\u003c/strong\u003e into the \u003cem\u003eSavedStateHandle. \u003c/em\u003eAny previous value will be overwritten with the new value.\u003c/p\u003e\u003ch2 id=\"b2e3\"\u003eVerifying the solution\u003c/h2\u003e\u003cp id=\"8d2f\"\u003eBefore we move on to verifying the solution, if you are verifying it on an Android device, there is one important point from the \u003ca href=\"https://developer.android.com/topic/libraries/architecture/saving-states#:~:text=Key%20Point%3A%20Saved%20instance%20state%20APIs%20only%20save%20data%20written%20to%20it%20when%20the%20Activity%20is%20stopped.%20Writing%20into%20it%20in%20between%20this%20lifecycle%20state%20defers%20the%20save%20operation%20till%20the%20next%20stopped%20lifecycle%20event.\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocs\u003c/a\u003e I want you to understand:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e52b\"\u003eSaved instance state APIs only save data written to it when the \u003ccode\u003e\u003cstrong\u003eActivity\u003c/strong\u003e\u003c/code\u003e is stopped. Writing into it in between this lifecycle state defers the save operation till the next stopped lifecycle event.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"b4f0\"\u003eTo verify the solution, we will simply put our app in the background (by clicking the home button) and then kill the app process via the \u003cstrong\u003e\u003cem\u003eLogcat\u003c/em\u003e\u003c/strong\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"fc9c\"\u003eAnd there we go! We can see that our counter state with value 6 is successfully restored when the user returns to the app.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-05-26T08:31:39.762Z",
  "modifiedTime": null
}
