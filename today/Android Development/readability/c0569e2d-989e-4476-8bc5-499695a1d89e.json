{
  "id": "c0569e2d-989e-4476-8bc5-499695a1d89e",
  "title": "Understanding the platform differences to better define the business logic for Kotlin Multiplatform",
  "link": "https://blog.kotlin-academy.com/understanding-the-platform-differences-to-better-define-the-business-logic-for-kotlin-multiplatform-5e29d15d7846?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Scalable Mobile Apps",
  "published": "Mon, 02 Sep 2024 09:43:23 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "ios-development",
    "architecture",
    "android-app-development",
    "kotlin-multiplatform",
    "swiftui"
  ],
  "byline": "Scalable Mobile Apps",
  "length": 7655,
  "excerpt": "Business logic in KMM for Android and iOS. Understanding iOS and Android platform differences. Architecture for Kotlin Multiplatform Mobile.",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "Understanding the platform differences to better define the business logic for Kotlin Multiplatform Mobile (KMM)Photo by Clark Tibbs on UnsplashBusiness logic has a much bigger connotation than what is perceived. Generally, people limit themselves to a single screen. Developers choose one of the MV(x) design patterns, believing that this selection ensures the successful implementation of KMM. However, this assumption does not hold because of the platforms' framework design differences.Differences across platformsAlthough mobile development seems similar for Android and iOS, they differ fundamentally in multiple aspects. The article aims to provide relevant information about these aspects, that would guide the team to make tactical decisions and incorporate essential changes while adopting KMM.Passing data across screensExample: As the user login, the user object is passed to the Home screen.In iOS, passing data like DTO(Data Transfer Objects) is by framework design, and user can be easily passed to a HomeView.struct SplashView: View { @ObservedObject var viewmodel: SplashViewModel = SplashViewModel() var body: some View { VStack { switch viewmodel.userState { case .Loggedout: LoggedOutView(listener: viewmodel) case .Loggedin(let user): HomeView(user: user) // Focus here } } } }However, in Android, passing data is through bundles and is not type-safe. The Bundle is a map of key-value pairs. You can only pass serializables.fun launchHomeFragment() { val bundle = Bundle().apply { putString(\"username\", \"John\") // Focus here putString(\"secondName\", \"Doe\") // Focus here putInt(\"age\", 42) // Focus here } val fragment = HomeFragment().apply { arguments = bundle } // Start the fragment}2. Relation between screensIn the programming world, Interfaces/Protocols are the means of establishing communications between components.In the example below, CommunicationHandle interface is used to communicate from the EventProducer to EventReceiver. Observe how the interface’s implementation is passed to receive the event from the producerinterface CommunicationHandle { fun onEvent()}class EventProducer(private val handle: CommmunicationHandle) { fun onAParticularEvent() { handle.onEvent() }}class EventReceiver { init { val eventProducer = EventProducer(CommunicationHandleEventsReceiver()) } inner class CommunicationHandleEventsReceiver: CommunicationHandle { override fun onEvent() { // Process the event } }}Back to our platforms. Consider a Profile from where an AddressList screen is opened and can be edited. Once the updation is completed, the address list screen will inform the Profile screen through callbacks. Let’s look at the implementation in the platforms.In the iOS code below, Listener is implemented by ProfileViewModel. This establishes a relation with the EditAddresses screen and can receive events from it.protocol EditAddressListener { func onAddressUpdated(address: Address)}class ProfileViewModel: EditAddressListener { func onAddressUpdated(address: Address) { // Logic when address is updated }}Notice how the listener can be passed to the next screen.struct ProfileView: View { @ObservedObject var viewmodel: ProfileViewModel = ProfileViewModel() NavigationLink() .navigationDestination(for: ...) { ... in EditAddressesView(listener: viewmodel) // Focus here }}In Android, you cannot pass interfaces. The only data that can be passed is a key-value pair of strings. Thus there is no scope to establish a relationship between screens. All screens are independent by themselves.From ProfileFragment, it’s just a fire \u0026 forget and no communication is possible between them.class ProfileFragment() { fun launchEditAddressFragment() { val fragment = EditAddressFragment() // Start the fragment }}3. Navigation logicpath.append(.MovieDetailScreen(movie: movie))In iOS SwiftUI, navigation is reactively driven through a state using the Navigation path. It follows 2-way binding for navigation — updating the navigation path variable performs navigation.This is in sync with how the UI layout is rendered reactively in Jetpack compose and SwiftUI.In Android, for navigation, we just bundle the information in an Intent and pass it to the Android framework which eventually starts your next screen. This works in an imperative, fire \u0026 forget way.4. Handling Deeplink / Notifications:Consider an example of an IMDB app that contains the deep link for a specific movie. If already logged in, directly open the Movie detail screen. Additionally, if the user is not logged in, the login/registration flow is invoked. And post that, the Movie detail is opened.Because the platforms differ in the first 3 points, the uniform handling of these Deeplinks/Notifications like the one mentioned above poses a challenge. As the app grows, the number of Deeplinks and Notifications typically increases, forming a significant part of the business logic that cannot be overlooked.5. Managing dependencies: A very crucial oneNote that, I’m not talking about any library. The general problem I have seen people mentioning is the incorporation of libraries like Koin etc in KMM. Here lies the problem.In Android, managing dependencies is a much bigger problem than in iOS. This is mainly because of how the Framework is designed by principle. The Activities, Fragments, and ViewModels are system-instantiated and are not created by the developer (Constructor injection of dependencies is not possible). Thus passing dependencies while constructing these classes is not possible.In iOS, the screens are developer created and dependencies are passed as constructor dependencies.Dependency Injection is a must for reusable, maintainable clean code. But this can be achieved manually. There is no need to forcefully use a particular library to achieve that in a KMM module.Although the above points seem to undermine the Android framework, the purpose is to only highlight the differences.The major roadblock that I observe is Android lacks compile-time safety \u0026 type safety. This limitation prevents us from fully realizing the potential of Kotlin Multiplatform Mobile (KMM). Adopting KMM from an Android perspective can eliminate the benefits offered by the iOS platform.Note: Improper adoption of a good technology can lead to increased complexity and reduce its potential benefits.SolutionIn this section, we cover what can be done to overcome these differences and achieve the full potential of KMM.Uniform framework for both Android and iOSTo have the shared business logic (defined above) across both platforms, we should have to choose a framework that functions uniformly for both of them. Uber’s RIBs and Square’s Workflow are a couple of them. Note that both of them are not designed to support KMM.What both of them have solved is establishing a relation between screens in a compile-safe way. This is achieved by using views as screens instead of Fragments or Activities.I will write a separate detailed post to cover this.Closing pointsKMM provides an opportunity to reduce the code by sharing. To begin with, we can share the data(API \u0026 Local database) \u0026 domain layer (like entities).Reducing this even further requires a thorough understanding of the nuances of these platforms involved.I hope this article has provided valuable insights into the platforms involved, enabling you to make well-informed, holistic decisions when adopting KMM. Further, I will be writing an article on adopting a uniform framework to leverage the full potential of KMM",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*Nmb6FjxQiAXM_jC9",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"ffc1\" data-testid=\"storyTitle\"\u003eUnderstanding the platform differences to better define the business logic for Kotlin Multiplatform Mobile (KMM)\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@ammanavaranup?source=post_page-----5e29d15d7846--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Scalable Mobile Apps\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*gXjM-K1qeztqsFwNp9WlBw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://blog.kotlin-academy.com/?source=post_page-----5e29d15d7846--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Kt. Academy\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*2grDGjzH0tfX8XiaF4Izaw.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@clarktibbs?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eClark Tibbs\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2117\"\u003eBusiness logic has a much bigger connotation than what is perceived. Generally, people limit themselves to a single screen. Developers choose one of the MV(x) design patterns, believing that this selection ensures the successful implementation of KMM. However, this assumption does not hold because of the platforms\u0026#39; framework design differences.\u003c/p\u003e\u003ch2 id=\"99d2\"\u003eDifferences across platforms\u003c/h2\u003e\u003cp id=\"0068\"\u003eAlthough mobile development seems similar for Android and iOS, they differ fundamentally in multiple aspects. The article aims to provide relevant information about these aspects, that would guide the team to make tactical decisions and incorporate essential changes while adopting KMM.\u003c/p\u003e\u003col\u003e\u003cli id=\"a104\"\u003e\u003cstrong\u003ePassing data across screens\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"5a73\"\u003eExample: As the user login, the \u003ccode\u003euser\u003c/code\u003e object is passed to the \u003cem\u003eHome\u003c/em\u003e screen.\u003c/p\u003e\u003cul\u003e\u003cli id=\"8c16\"\u003eIn iOS, passing data like \u003cstrong\u003e\u003cem\u003eDTO(\u003c/em\u003e\u003c/strong\u003e\u003cem\u003eData Transfer Objects\u003c/em\u003e\u003cstrong\u003e\u003cem\u003e)\u003c/em\u003e\u003c/strong\u003e is by framework design, and \u003ccode\u003euser\u003c/code\u003e can be easily passed to a HomeView.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"74a5\"\u003estruct SplashView: View {\u003cp\u003e        @ObservedObject var viewmodel: SplashViewModel = SplashViewModel()\u003c/p\u003e\u003cp\u003e        var body: some View {\u003cbr/\u003e        VStack {\u003cbr/\u003e            switch viewmodel.userState {\u003cbr/\u003e            case .Loggedout: LoggedOutView(listener: viewmodel)\u003cbr/\u003e            case .Loggedin(let user): HomeView(user: user) // Focus here\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"4aa8\"\u003eHowever, in Android, passing data is through bundles and is not type-safe. The Bundle is a map of key-value pairs. You can only pass serializables.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"e52b\"\u003e\u003cbr/\u003efun launchHomeFragment() {\u003cbr/\u003e    val bundle = Bundle().apply {\u003cbr/\u003e        putString(\u0026#34;username\u0026#34;, \u0026#34;John\u0026#34;) // Focus here\u003cbr/\u003e        putString(\u0026#34;secondName\u0026#34;, \u0026#34;Doe\u0026#34;) // Focus here\u003cbr/\u003e        putInt(\u0026#34;age\u0026#34;, 42) // Focus here\u003cbr/\u003e    }\u003cp\u003e    val fragment = HomeFragment().apply { arguments = bundle }\u003cbr/\u003e    // Start the fragment\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8c34\"\u003e\u003cstrong\u003e2. Relation between screens\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9de2\"\u003eIn the programming world, Interfaces/Protocols are the means of establishing communications between components.\u003c/p\u003e\u003cp id=\"4fc7\"\u003eIn the example below, \u003ccode\u003eCommunicationHandle\u003c/code\u003e interface is used to communicate from the \u003ccode\u003eEventProducer\u003c/code\u003e to \u003ccode\u003eEventReceiver\u003c/code\u003e. Observe how the interface’s implementation is passed to receive the event from the producer\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"520e\"\u003einterface CommunicationHandle {\u003cbr/\u003e  fun onEvent()\u003cbr/\u003e}\u003cp\u003eclass EventProducer(private val handle: CommmunicationHandle) {\u003cbr/\u003e  fun onAParticularEvent() {\u003cbr/\u003e    handle.onEvent()\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"085c\"\u003eclass EventReceiver {\u003cbr/\u003e  init {\u003cbr/\u003e      val eventProducer = EventProducer(CommunicationHandleEventsReceiver())\u003cbr/\u003e  } \u003cp\u003e  inner class CommunicationHandleEventsReceiver: CommunicationHandle {\u003cbr/\u003e    override fun onEvent() {\u003cbr/\u003e      // Process the event\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1c77\"\u003eBack to our platforms. Consider a \u003ccode\u003eProfile\u003c/code\u003e from where an \u003ccode\u003eAddressList\u003c/code\u003e screen is opened and can be edited. Once the updation is completed, the address list screen will inform the Profile screen through callbacks. Let’s look at the implementation in the platforms.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4f25\"\u003eIn the iOS code below, Listener is implemented by \u003ccode\u003eProfileViewModel\u003c/code\u003e. This establishes a relation with the EditAddresses screen and can receive events from it.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"9558\"\u003eprotocol EditAddressListener {\u003cbr/\u003e  func onAddressUpdated(address: Address)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"37d6\"\u003eclass ProfileViewModel: EditAddressListener {\u003cbr/\u003e  func onAddressUpdated(address: Address) {\u003cbr/\u003e    // Logic when address is updated\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"155f\"\u003eNotice how the listener can be passed to the next screen.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0b91\"\u003estruct ProfileView: View {\u003cbr/\u003e  @ObservedObject var viewmodel: ProfileViewModel = ProfileViewModel()\u003cbr/\u003e  NavigationLink()\u003cbr/\u003e    .navigationDestination(for: ...) { ... in\u003cbr/\u003e      EditAddressesView(listener: viewmodel) // Focus here\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"eb39\"\u003eIn Android, you cannot pass interfaces. The only data that can be passed is a key-value pair of strings. Thus there is no scope to establish a relationship between screens. All screens are independent by themselves.\u003c/li\u003e\u003cli id=\"ded3\"\u003eFrom ProfileFragment, it’s just a fire \u0026amp; forget and no communication is possible between them.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"2e4d\"\u003eclass ProfileFragment() {\u003cp\u003e           fun launchEditAddressFragment() {\u003cbr/\u003e      val fragment = EditAddressFragment()\u003cbr/\u003e      // Start the fragment\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7fea\"\u003e\u003cstrong\u003e3. Navigation logic\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6dba\"\u003epath.append(.MovieDetailScreen(movie: movie))\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"6740\"\u003eIn iOS SwiftUI, navigation is \u003cstrong\u003ereactively\u003c/strong\u003e driven through a state using the \u003cstrong\u003eNavigation path\u003c/strong\u003e. It follows \u003cstrong\u003e2-way binding\u003c/strong\u003e for navigation — updating the navigation path variable performs navigation.\u003c/li\u003e\u003cli id=\"7dc4\"\u003eThis is in sync with how the UI layout is rendered reactively in Jetpack compose and SwiftUI.\u003c/li\u003e\u003cli id=\"2f70\"\u003eIn Android, for navigation, we just bundle the information in an Intent and pass it to the Android framework which eventually starts your next screen. \u003cstrong\u003eThis works in an \u003cem\u003eimperative,\u003c/em\u003e \u003cem\u003efire \u0026amp; forget\u003c/em\u003e way.\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ced9\"\u003e\u003cstrong\u003e4. Handling Deeplink / Notifications\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1b10\"\u003eConsider an example of an IMDB app that contains the deep link for a specific movie. If already logged in, directly open the Movie detail screen. Additionally, if the user is not logged in, the login/registration flow is invoked. And post that, the Movie detail is opened.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"ea84\"\u003eBecause the platforms differ in the first 3 points, the uniform handling of these Deeplinks/Notifications like the one mentioned above poses a challenge. As the app grows, the number of Deeplinks and Notifications typically increases, forming a significant part of the business logic that cannot be overlooked.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2621\"\u003e\u003cstrong\u003e5. Managing dependencies\u003c/strong\u003e: A very crucial one\u003c/p\u003e\u003cul\u003e\u003cli id=\"1f40\"\u003eNote that, I’m not talking about any library. The general problem I have seen people mentioning is the incorporation of libraries like Koin etc in KMM. \u003cem\u003eHere lies the problem.\u003c/em\u003e\u003c/li\u003e\u003cli id=\"0086\"\u003eIn Android, managing dependencies is a much bigger problem than in iOS. This is mainly because of how the Framework is designed by principle. The Activities, Fragments, and ViewModels are system-instantiated and are not created by the developer (Constructor injection of dependencies is not possible). Thus passing dependencies while constructing these classes is not possible.\u003c/li\u003e\u003cli id=\"3f75\"\u003eIn iOS, the screens are developer created and dependencies are passed as constructor dependencies.\u003c/li\u003e\u003cli id=\"6aa9\"\u003eDependency Injection is a must for reusable, maintainable clean code. But this can be achieved manually. There is no need to forcefully use a particular library to achieve that in a KMM module.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"bcd2\"\u003eAlthough the above points seem to undermine the Android framework, the purpose is to only highlight the differences.\u003c/p\u003e\u003cp id=\"747f\"\u003eThe major roadblock that I observe is \u003cstrong\u003e\u003cem\u003eAndroid lacks compile-time safety \u0026amp; type safety\u003c/em\u003e\u003c/strong\u003e. This limitation prevents us from fully realizing the potential of Kotlin Multiplatform Mobile (KMM). Adopting KMM from an Android perspective can eliminate the benefits offered by the iOS platform.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d67c\"\u003e\u003cem\u003eNote: Improper adoption of a good technology can lead to increased complexity and reduce its potential benefits.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"7b84\"\u003eSolution\u003c/h2\u003e\u003cp id=\"9a4c\"\u003eIn this section, we cover what can be done to overcome these differences and achieve the full potential of KMM.\u003c/p\u003e\u003cp id=\"fcc9\"\u003e\u003cstrong\u003eUniform framework for both Android and iOS\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"18e9\"\u003eTo have the shared business logic (defined above) across both platforms, we should have to choose a framework that functions uniformly for both of them. \u003ca href=\"https://github.com/uber/RIBs\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUber’s RIBs\u003c/a\u003e and \u003ca href=\"https://square.github.io/workflow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSquare’s Workflow\u003c/a\u003e are a couple of them. Note that both of them are not designed to support KMM.\u003c/li\u003e\u003cli id=\"629f\"\u003eWhat both of them have solved is establishing a relation between screens in a compile-safe way. This is achieved by using \u003cstrong\u003eviews\u003c/strong\u003e as screens instead of Fragments or Activities.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e182\"\u003e\u003cem\u003eI will write a separate detailed post to cover this.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"2682\"\u003eClosing points\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b12e\"\u003eKMM provides an opportunity to reduce the code by sharing. To begin with, we can share the data(API \u0026amp; Local database) \u0026amp; domain layer (like entities).\u003c/li\u003e\u003cli id=\"ed3e\"\u003eReducing this even further requires a thorough understanding of the nuances of these platforms involved.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d22f\"\u003eI hope this article has provided valuable insights into the platforms involved, enabling you to make well-informed, holistic decisions when adopting KMM. Further, I will be writing an article on adopting a \u003cstrong\u003euniform framework to leverage the full potential of KMM\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-09-02T09:43:23.136Z",
  "modifiedTime": null
}
