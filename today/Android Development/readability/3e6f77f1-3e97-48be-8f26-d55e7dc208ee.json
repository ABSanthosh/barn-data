{
  "id": "3e6f77f1-3e97-48be-8f26-d55e7dc208ee",
  "title": "Deprecating idling resource libraries",
  "link": "https://jakewharton.com/deprecating-idling-resource-libraries/",
  "description": "",
  "author": "",
  "published": "2025-02-19T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 2683,
  "excerpt": "19 February 2025",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Deprecating idling resource libraries 19 February 2025 When Espresso was made public a decade ago, one of its banner features was the “idling resource” concept. This monitored the main thread and any background thread pools to prevent your test from progressing until the app became idle. Waiting until idle generally increased the stability of tests since at that point the UI should be stable. We released RxIdler and okhttp-idling-resource for monitoring RxJava schedulers and OkHttp’s dispatcher, respectively. Today I am deprecating both libraries. In the years since their release, I have become disillusioned with the idling resource mechanism–and I’m not alone. Like using R.id to target views, idling resources expose the internals of your application to the testing framework in a way that no real user can match. The point of building tests in the robot pattern was to describe interaction at a high-level. If you can’t read a UI test to someone over the phone interacting with the real app then it probably encodes implementation detail. “Okay dad, now wait for OkHttp’s Dispatcher to report itself as idle before clicking ‘continue’.” Yeah… no. What do we do as real users? We wait until some UI condition is met which signals our ability to progress. “Okay dad, now wait for the ‘continue’ button to turn green before clicking it.” Much better. We don’t care how the application is performing the work nor the means by which it signals the UI that it is complete. Moreover, test failures that occur based on condition waits are failures which can occur in the wild. I’ve been sitting on these deprecations and this blog post for a few years now. Telling you to switch to a new technique without actually demonstrating it is not great. Turns out that around the same time Google was also changing their tune on idling resources. That guidance has since been promoted to the official documentation as well. These links demonstrate how to wait on conditions using new built-in Compose testing APIs. For View-based layouts, you can write a custom ViewAction that loops on yielding to the main thread, checking the condition, and then either breaking or looping. Yes I know I’m still not really demonstrating how to do this for views. Sorry! Both of these idling resource libraries are stable and reliable. They haven’t needed any commits or releases in years. If you are relying on them today then absolutely nothing is changing for you. Deprecation is a signal to new users that this is not the recommended approach. And it’s a nudge to existing users that they can migrate at their own pace to a superior solution. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eDeprecating idling resource libraries\u003c/h2\u003e\n      \u003cp\u003e19 February 2025\u003c/p\u003e\n\n      \u003cp\u003eWhen \u003ca href=\"https://developer.android.com/training/testing/espresso\"\u003eEspresso\u003c/a\u003e was made public a decade ago, one of its banner features was the “idling resource” concept.\nThis monitored the main thread and any background thread pools to prevent your test from progressing until the app became idle.\nWaiting until idle generally increased the stability of tests since at that point the UI should be stable.\u003c/p\u003e\n\n\u003cp\u003eWe released \u003ca href=\"https://github.com/square/RxIdler\"\u003eRxIdler\u003c/a\u003e and \u003ca href=\"https://github.com/JakeWharton/okhttp-idling-resource/\"\u003eokhttp-idling-resource\u003c/a\u003e for monitoring RxJava schedulers and OkHttp’s dispatcher, respectively.\nToday I am deprecating both libraries.\nIn the years since their release, I have become disillusioned with the idling resource mechanism–and I’m not alone.\u003c/p\u003e\n\n\u003cp\u003eLike using \u003ccode\u003eR.id\u003c/code\u003e to target views, idling resources expose the internals of your application to the testing framework in a way that no real user can match.\nThe point of building tests in \u003ca href=\"https://jakewharton.com/testing-robots/\"\u003ethe robot pattern\u003c/a\u003e was to describe interaction at a high-level.\nIf you can’t read a UI test to someone over the phone interacting with the real app then it probably encodes implementation detail.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e“Okay dad, now wait for OkHttp’s \u003ccode\u003eDispatcher\u003c/code\u003e to report itself as idle before clicking ‘continue’.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eYeah… no.\u003c/p\u003e\n\n\u003cp\u003eWhat do we do as real users?\nWe wait until some UI condition is met which signals our ability to progress.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e“Okay dad, now wait for the ‘continue’ button to turn green before clicking it.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eMuch better.\u003c/p\u003e\n\n\u003cp\u003eWe don’t care \u003cem\u003ehow\u003c/em\u003e the application is performing the work nor the means by which it signals the UI that it is complete.\nMoreover, test failures that occur based on condition waits are failures which can occur in the wild.\u003c/p\u003e\n\n\u003cp\u003eI’ve been sitting on these deprecations and this blog post for a few years now.\nTelling you to switch to a new technique without actually demonstrating it is not great.\nTurns out that around the same time \u003ca href=\"https://medium.com/androiddevelopers/alternatives-to-idling-resources-in-compose-tests-8ae71f9fc473\"\u003eGoogle was also changing their tune\u003c/a\u003e on idling resources.\nThat guidance has since been promoted to \u003ca href=\"https://developer.android.com/training/testing/instrumented-tests/stability#prevent-synchronization\"\u003ethe official documentation\u003c/a\u003e as well.\nThese links demonstrate how to wait on conditions using new built-in Compose testing APIs.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://jakewharton.com/static/post-image/condition-wait.png\" alt=\"Flow chart showing \u0026#39;click on button\u0026#39; pointing to \u0026#39;is the condition met\u0026#39;. Its \u0026#39;no\u0026#39; branch recurses onto itself. The \u0026#39;yes\u0026#39; branch points to \u0026#39;Assert text is displayed\u0026#39;. (Image courtesy developer.android.com)\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eFor View-based layouts, you can write a custom \u003ccode\u003eViewAction\u003c/code\u003e that loops on yielding to the main thread, checking the condition, and then either breaking or looping.\nYes I know I’m still not \u003cem\u003ereally\u003c/em\u003e demonstrating how to do this for views.\nSorry!\u003c/p\u003e\n\n\u003cp\u003eBoth of these idling resource libraries are stable and reliable.\nThey haven’t needed any commits or releases in years.\nIf you are relying on them today then absolutely nothing is changing for you.\nDeprecation is a signal to new users that this is not the recommended approach.\nAnd it’s a nudge to existing users that they can migrate at their own pace to a superior solution.\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-02-19T00:00:00Z",
  "modifiedTime": null
}
