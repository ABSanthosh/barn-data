{
  "id": "7b7a4980-2c6b-413f-8821-048b6e63fb6d",
  "title": "Kotlin Tips and Tricks You May Not Know: #1 — Kotlin Logging",
  "link": "https://proandroiddev.com/kotlin-tips-and-tricks-you-may-not-know-1-kotlin-logging-91b7675b6276?source=rss----c72404660798---4",
  "description": "",
  "author": "Elena van Engelen - Maslova",
  "published": "Mon, 28 Oct 2024 18:34:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "structured-logging",
    "idiomatic-kotlin",
    "kotlin-beginners",
    "mdc",
    "kotlin"
  ],
  "byline": "Elena van Engelen - Maslova",
  "length": 11065,
  "excerpt": "Enhance and streamline logging in Kotlin with Kotlin-Logging. Get seamless SLF4J integration, structured logging, MDC support, and improved performance for efficient logging.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin Tips and Tricks You May Not Know: #1 — Kotlin LoggingKotlin-Logging simplifies logging with idiomatic Kotlin syntaxIntroductionLogging is a crucial part of every application, but traditional Java-based logging can be verbose and inefficient in Kotlin. Kotlin-Logging simplifies logging with cleaner, more expressive syntax and improves performance through lazy message evaluation, seamlessly integrating with popular logging backends like SLF4J and Logback.In this article, you will learn how Kotlin-Logging makes logging easier and more efficient, from lazy and eager message evaluation to handling exceptions more idiomatically. We will also show how Kotlin-Logging supports advanced features like structured logging and MDC for richer, more traceable logs.What is Kotlin-Logging?Kotlin-Logging is a simple wrapper around popular Java logging libraries like SLF4J or Logback. Its main advantage is that it allows you to write logging statements that are cleaner and more Kotlin-like.Seamless integration: If you are already using SLF4J or Logback in your projects, adding Kotlin-Logging is straightforward. You can keep using the same logging backend while enjoying Kotlin’s more expressive syntax.You can add Kotlin-Logging and Logback to your Kotlin project as follows:dependencies { implementation(\"io.github.oshai:kotlin-logging-jvm:7.0.0\") implementation(\"org.slf4j:slf4j-api:2.0.16\") implementation(\"ch.qos.logback:logback-classic:1.5.11\")}Chapter 3 of Kotlin Crash Course helps you set up a simple development environment to try out logging.Kotlin-Logging makes logging much cleaner and more idiomatic by allowing lazy message evaluation. You can write logs like this:import io.github.oshai.kotlinlogging.KotlinLoggingprivate val logger = KotlinLogging.logger {}fun main() { val compliment = \"Great job\" logger.debug { \"Generating compliment: $compliment\" } // Lazy evaluation, only executed if the log level is enabled logger.info { \"Compliment generated: $compliment\" } // Lazy evaluation, only executed if the log level is enabled}Lazy evaluation means that the message inside {} is only evaluated when the log level is actually enabled, reducing the performance cost of logging in production.Handling Exceptions in Kotlin-LoggingKotlin-Logging also provides a clean way to log exceptions. You can log errors in an expressive and idiomatic way by passing the exception into the log statement. It also allows you to combine exceptions with lazy log messages:try { // Some risky code} catch (e: Exception) { logger.error(e) { \"An error occurred during execution\" } // Logs both the exception and a message}This approach ensures that you not only capture the stack trace of the exception but also log a meaningful message. In Java, this would typically look like:logger.error(\"An error occurred during execution\", e);With Kotlin-Logging, the syntax is cleaner and better suited to Kotlin’s style.Adding MetadataKotlin-Logging allows you to enhance log entries with additional metadata, which is useful for tracking context across requests and operations. By attaching key-value pairs, such as customer IDs or order numbers, you can provide more meaningful logs that are easier to trace.Structured LoggingStructured logging lets you embed metadata directly into log messages, making it ideal for scenarios where specific context is crucial. Structured logging becomes especially valuable in distributed systems or microservices, where logs with rich metadata can help pinpoint issues across different services or components.For example, when processing an order, you can log customer and order IDs for better traceability:import io.github.oshai.kotlinlogging.KotlinLoggingprivate val logger = KotlinLogging.logger {}fun processOrder(order: Order) { // process order // something failed logException(order, Exception(\"Order processing exception\"))}fun logException(order: Order, t: Throwable) { logger.atError { message = \"Order processing failed\" cause = t payload = buildMap(capacity = 2) { put(\"customerId\", order.customerId) put(\"orderId\", order.orderId) } }}fun main() { processOrder(Order(\"C123\", \"O98765\"))}data class Order(val customerId: String, val orderId: String)By using structured logging, we avoid constructing complex log messages manually. Instead, we pass relevant metadata, such as customerId and orderId, as key-value pairs in the log, which makes the logs easier to parse and trace.The output will look like this:10:04:48.685 [main] ERROR LoggingExample -customerId=\"C123\" orderId=\"O98765\"- Order processing failedjava.lang.Exception: Order processing exception at LoggingExampleKt.processOrder(LoggingExample.kt:12) at LoggingExampleKt.main(LoggingExample.kt:27) at LoggingExampleKt.main(LoggingExample.kt)Mapped Diagnostic Context (MDC)While structured logging works well for adding metadata to specific log entries, in situations where you need to consistently log the same metadata across multiple log statements — such as in long-running processes or within the same thread — MDC (Mapped Diagnostic Context) becomes a more powerful tool. Instead of manually attaching metadata to each log entry, MDC automatically adds shared context data to all log messages within a given execution flow. More details about MDC can be found in the SLF4J manual.MDC allows you to add implicit context data, such as customerId or orderId, to all log messages in a thread or execution block. This is particularly useful when tracking context across multiple log statements within the same flow or request, as it simplifies the logging process and ensures consistency across related logs.In Kotlin-Logging, MDC properties can be set using the withLoggingContext function. This allows you to capture and propagate important metadata, without needing to pass it explicitly in every log statement.Let us update our previous example to use MDC:import io.github.oshai.kotlinlogging.KotlinLoggingimport io.github.oshai.kotlinlogging.withLoggingContextprivate val logger = KotlinLogging.logger {}fun processOrder(order: Order) = withLoggingContext(\"customerId\" to order.customerId, \"orderId\" to order.orderId) { // process order // something failed logException(Exception(\"Order processing exception\")) }// no need to repeat order details for every log linefun logException(t: Throwable) { logger.error (t) { \"Order processing failed\" }}fun main() { processOrder(Order(\"C123\", \"O98765\"))}data class Order(val customerId: String, val orderId: String)To display the MDC properties in your logs, you need to configure your logger. For example, if you are using Logback, you will need to add configuration similar to the following in your logback.xml file:\u003cconfiguration\u003e \u003c!-- Console appender for logging to the console --\u003e \u003cappender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003cencoder\u003e \u003c!-- Use %X to include all MDC key-value pairs --\u003e \u003cpattern\u003e%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %X - %msg%n\u003c/pattern\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!-- Root logger configuration --\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"STDOUT\" /\u003e \u003c/root\u003e\u003c/configuration\u003eIn this example, MDC automatically adds customerId and orderId to all log entries within the withLoggingContext block, avoiding the need to repeat the metadata for every log statement. The output will include the following information:10:08:37.070 [main] ERROR LoggingExampleMDC - customerId=C123, orderId=O98765 - Order processing failedjava.lang.Exception: Order processing exception at LoggingExampleMDCKt.processOrder(LoggingExampleMDC.kt:12) at LoggingExampleMDCKt.main(LoggingExampleMDC.kt:21) at LoggingExampleMDCKt.main(LoggingExampleMDC.kt)This way, any logs within the context block will include these additional MDC properties, making it easier to track related logs across different services or requests.MDC and CoroutinesMDC uses ThreadLocal to store context information, therefore when using coroutines, the context must be explicitly propagated between threads.Kotlin coroutines provide built-in support for MDC via the MDCContext function, which ensures that the MDC data is transported between coroutine contexts. For example:import io.github.oshai.kotlinlogging.KotlinLoggingimport io.github.oshai.kotlinlogging.withLoggingContextimport kotlinx.coroutines.runBlockingimport kotlinx.coroutines.launchimport kotlinx.coroutines.slf4j.MDCContextprivate val logger = KotlinLogging.logger {}fun main() = runBlocking { withLoggingContext(\"customerId\" to \"C123\", \"orderId\" to \"O98765\") { launch(MDCContext()) { logger.info { \"Starting coroutine for order processing\" } // Simulate order processing logger.info { \"Order processed with status: Shipped\" } } }}In this case, the MDCContext() ensures that the customerId and orderId MDC properties are carried into the coroutine, allowing you to maintain the same context across concurrent operations.To use MDC with coroutines, you need to add the following dependency to your project:dependencies { implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-slf4j:\u003cversion\u003e\")}This ensures that your application can propagate MDC data correctly between coroutines.Additional InformationOlder versions of Kotlin-Logging: Version 5 brought package structure changes and no longer bundles SLF4J, see change log for more information. It is not backward compatible, but you can run older and newer versions side by side.Emerging alternative — Klogging: A new Kotlin logging library offering a seamless structured logging with coroutine support. Still in development, Klogging shows promise for future projects but may not yet be stable for production use.ConclusionKotlin-Logging is a powerful yet simple tool for adding structured, efficient logging to your Kotlin applications. By integrating with popular backends like SLF4J and Logback, Kotlin-Logging retains all the capabilities you are used to but with cleaner, more idiomatic syntax. Whether you are building a simple application or managing complex, distributed systems, Kotlin-Logging can simplify your logging practices. Its seamless integration with existing logging frameworks like SLF4J and Logback, combined with structured logging and MDC, ensures that your logs are not only cleaner and more efficient but also more informative and easy to trace.Tip recap:Use Kotlin-Logging to simplify logging with clean syntax and improve performance with lazy message evaluation.Use structured logging when you need to add specific metadata (like customer ID or order number) to individual log entries for better traceability.Use MDC when you want to attach the same metadata across multiple log messages in the same workflow, ensuring consistent context without repeating data.Try Kotlin-Logging in your next Kotlin project to enhance your logging experience!For more Kotlin tips and tricks, visit my Medium blog homepage.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*eepMS5gifLIX-6ZXBvB2tA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"3387\" data-testid=\"storyTitle\"\u003eKotlin Tips and Tricks You May Not Know: #1 — Kotlin Logging\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"92eb\"\u003eKotlin-Logging simplifies logging with idiomatic Kotlin syntax\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@elenavanengelen?source=post_page---byline--91b7675b6276--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Elena van Engelen - Maslova\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*N-t_FroIxVl5WDVcCO45jw@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--91b7675b6276--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b968\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"6544\"\u003eLogging is a crucial part of every application, but traditional Java-based logging can be verbose and inefficient in Kotlin. \u003cstrong\u003eKotlin-Logging\u003c/strong\u003e simplifies logging with cleaner, more expressive syntax and improves performance through \u003cstrong\u003elazy message evaluation\u003c/strong\u003e, seamlessly integrating with popular logging backends like \u003cstrong\u003eSLF4J\u003c/strong\u003e and \u003cstrong\u003eLogback\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"1c73\"\u003eIn this article, you will learn how Kotlin-Logging makes logging easier and more efficient, from lazy and eager message evaluation to handling exceptions more idiomatically. We will also show how Kotlin-Logging supports advanced features like structured logging and MDC for richer, more traceable logs.\u003c/p\u003e\u003ch2 id=\"4f34\"\u003eWhat is Kotlin-Logging?\u003c/h2\u003e\u003cp id=\"69dd\"\u003eKotlin-Logging is a simple wrapper around popular Java logging libraries like SLF4J or Logback. Its main advantage is that it allows you to write logging statements that are cleaner and more Kotlin-like.\u003c/p\u003e\u003cp id=\"5a97\"\u003e\u003cstrong\u003eSeamless integration\u003c/strong\u003e: If you are already using SLF4J or Logback in your projects, adding Kotlin-Logging is straightforward. You can keep using the same logging backend while enjoying Kotlin’s more expressive syntax.\u003c/p\u003e\u003cp id=\"eaa3\"\u003eYou can add Kotlin-Logging and Logback to your Kotlin project as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"04f3\"\u003edependencies {\u003cbr/\u003e    implementation(\u0026#34;io.github.oshai:kotlin-logging-jvm:7.0.0\u0026#34;)\u003cbr/\u003e    implementation(\u0026#34;org.slf4j:slf4j-api:2.0.16\u0026#34;)\u003cbr/\u003e    implementation(\u0026#34;ch.qos.logback:logback-classic:1.5.11\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e4d8\"\u003e\u003ca href=\"https://www.amazon.com/dp/9355516304\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003eChapter 3 of Kotlin Crash Course\u003c/em\u003e\u003c/a\u003e\u003cem\u003e helps you set up a simple development environment to try out logging.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"46db\"\u003eKotlin-Logging makes logging much cleaner and more idiomatic by allowing \u003cstrong\u003elazy message evaluation\u003c/strong\u003e. You can write logs like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"70d5\"\u003eimport io.github.oshai.kotlinlogging.KotlinLogging\u003cp\u003eprivate val logger = KotlinLogging.logger {}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    val compliment = \u0026#34;Great job\u0026#34;\u003cbr/\u003e    logger.debug { \u0026#34;Generating compliment: $compliment\u0026#34; } // Lazy evaluation, only executed if the log level is enabled\u003cbr/\u003e    logger.info { \u0026#34;Compliment generated: $compliment\u0026#34; }  // Lazy evaluation, only executed if the log level is enabled\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"82bb\"\u003e\u003cstrong\u003eLazy evaluation\u003c/strong\u003e means that the message inside \u003ccode\u003e{}\u003c/code\u003e is only evaluated when the log level is actually enabled, reducing the performance cost of logging in production.\u003c/p\u003e\u003ch2 id=\"d5a7\"\u003eHandling Exceptions in Kotlin-Logging\u003c/h2\u003e\u003cp id=\"8744\"\u003eKotlin-Logging also provides a clean way to log exceptions. You can log errors in an expressive and idiomatic way by passing the exception into the log statement. It also allows you to combine exceptions with lazy log messages:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"48c5\"\u003etry {\u003cbr/\u003e    // Some risky code\u003cbr/\u003e} catch (e: Exception) {\u003cbr/\u003e    logger.error(e) { \u0026#34;An error occurred during execution\u0026#34; }  // Logs both the exception and a message\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2543\"\u003eThis approach ensures that you not only capture the stack trace of the exception but also log a meaningful message. In Java, this would typically look like:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"35c2\"\u003elogger.error(\u0026#34;An error occurred during execution\u0026#34;, e);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"206e\"\u003eWith Kotlin-Logging, the syntax is cleaner and better suited to Kotlin’s style.\u003c/p\u003e\u003ch2 id=\"8183\"\u003eAdding Metadata\u003c/h2\u003e\u003cp id=\"df8a\"\u003eKotlin-Logging allows you to enhance log entries with additional metadata, which is useful for tracking context across requests and operations. By attaching key-value pairs, such as customer IDs or order numbers, you can provide more meaningful logs that are easier to trace.\u003c/p\u003e\u003ch2 id=\"0538\"\u003eStructured Logging\u003c/h2\u003e\u003cp id=\"20c4\"\u003eStructured logging lets you embed metadata directly into log messages, making it ideal for scenarios where specific context is crucial. Structured logging becomes especially valuable in distributed systems or microservices, where logs with rich metadata can help pinpoint issues across different services or components.\u003c/p\u003e\u003cp id=\"be67\"\u003eFor example, when processing an order, you can log customer and order IDs for better traceability:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7794\"\u003eimport io.github.oshai.kotlinlogging.KotlinLogging\u003cp\u003eprivate val logger = KotlinLogging.logger {}\u003c/p\u003e\u003cp\u003efun processOrder(order: Order) {\u003cbr/\u003e    // process order\u003cbr/\u003e    // something failed\u003cbr/\u003e    logException(order, Exception(\u0026#34;Order processing exception\u0026#34;))\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun logException(order: Order, t: Throwable) {\u003cbr/\u003e    logger.atError {\u003cbr/\u003e        message = \u0026#34;Order processing failed\u0026#34;\u003cbr/\u003e        cause = t\u003cbr/\u003e        payload = buildMap(capacity = 2) {\u003cbr/\u003e            put(\u0026#34;customerId\u0026#34;, order.customerId)\u003cbr/\u003e            put(\u0026#34;orderId\u0026#34;, order.orderId)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    processOrder(Order(\u0026#34;C123\u0026#34;, \u0026#34;O98765\u0026#34;))\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003edata class Order(val customerId: String, val orderId: String)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"421c\"\u003eBy using structured logging, we avoid constructing complex log messages manually. Instead, we pass relevant metadata, such as \u003ccode\u003ecustomerId\u003c/code\u003e and \u003ccode\u003eorderId\u003c/code\u003e, as key-value pairs in the log, which makes the logs easier to parse and trace.\u003c/p\u003e\u003cp id=\"561d\"\u003eThe output will look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5684\"\u003e10:04:48.685 [main] ERROR LoggingExample -customerId=\u0026#34;C123\u0026#34; orderId=\u0026#34;O98765\u0026#34;- Order processing failed\u003cbr/\u003ejava.lang.Exception: Order processing exception\u003cbr/\u003e    at LoggingExampleKt.processOrder(LoggingExample.kt:12)\u003cbr/\u003e    at LoggingExampleKt.main(LoggingExample.kt:27)\u003cbr/\u003e    at LoggingExampleKt.main(LoggingExample.kt)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"65c3\"\u003eMapped Diagnostic Context (MDC)\u003c/h2\u003e\u003cp id=\"6082\"\u003eWhile structured logging works well for adding metadata to specific log entries, in situations where you need to consistently log the same metadata across multiple log statements — such as in long-running processes or within the same thread — \u003cstrong\u003eMDC\u003c/strong\u003e (Mapped Diagnostic Context) becomes a more powerful tool. Instead of manually attaching metadata to each log entry, MDC automatically adds shared context data to all log messages within a given execution flow. More details about MDC can be found in the \u003ca href=\"https://www.slf4j.org/manual.html#mdc\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSLF4J manual\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"df18\"\u003eMDC allows you to add implicit context data, such as \u003ccode\u003ecustomerId\u003c/code\u003e or \u003ccode\u003eorderId\u003c/code\u003e, to all log messages in a thread or execution block. This is particularly useful when tracking context across multiple log statements within the same flow or request, as it simplifies the logging process and ensures consistency across related logs.\u003c/p\u003e\u003cp id=\"6984\"\u003eIn Kotlin-Logging, MDC properties can be set using the \u003ccode\u003ewithLoggingContext\u003c/code\u003e function. This allows you to capture and propagate important metadata, without needing to pass it explicitly in every log statement.\u003c/p\u003e\u003cp id=\"7871\"\u003eLet us update our previous example to use MDC:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5636\"\u003eimport io.github.oshai.kotlinlogging.KotlinLogging\u003cbr/\u003eimport io.github.oshai.kotlinlogging.withLoggingContext\u003cp\u003eprivate val logger = KotlinLogging.logger {}\u003c/p\u003e\u003cp\u003efun processOrder(order: Order) =\u003cbr/\u003e    withLoggingContext(\u0026#34;customerId\u0026#34; to order.customerId, \u0026#34;orderId\u0026#34; to order.orderId) {\u003cbr/\u003e        // process order\u003cbr/\u003e        // something failed\u003cbr/\u003e        logException(Exception(\u0026#34;Order processing exception\u0026#34;))\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e// no need to repeat order details for every log line\u003cbr/\u003efun logException(t: Throwable) {\u003cbr/\u003e    logger.error (t) { \u0026#34;Order processing failed\u0026#34; }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    processOrder(Order(\u0026#34;C123\u0026#34;, \u0026#34;O98765\u0026#34;))\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003edata class Order(val customerId: String, val orderId: String)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9bdd\"\u003eTo display the MDC properties in your logs, you need to configure your logger. For example, if you are using Logback, you will need to add configuration similar to the following in your \u003ccode\u003elogback.xml\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e0f3\"\u003e\u0026lt;configuration\u0026gt;\u003cp\u003e    \u0026lt;!-- Console appender for logging to the console --\u0026gt;\u003cbr/\u003e    \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;encoder\u0026gt;\u003cbr/\u003e            \u0026lt;!-- Use %X to include all MDC key-value pairs --\u0026gt;\u003cbr/\u003e            \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %X - %msg%n\u0026lt;/pattern\u0026gt;\u003cbr/\u003e        \u0026lt;/encoder\u0026gt;\u003cbr/\u003e    \u0026lt;/appender\u0026gt;\u003c/p\u003e\u003cp\u003e    \u0026lt;!-- Root logger configuration --\u0026gt;\u003cbr/\u003e    \u0026lt;root level=\u0026#34;info\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt;\u003cbr/\u003e    \u0026lt;/root\u0026gt;\u003c/p\u003e\u003cp\u003e\u0026lt;/configuration\u0026gt;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e577\"\u003eIn this example, MDC automatically adds \u003ccode\u003ecustomerId\u003c/code\u003e and \u003ccode\u003eorderId\u003c/code\u003e to all log entries within the \u003ccode\u003ewithLoggingContext\u003c/code\u003e block, avoiding the need to repeat the metadata for every log statement. The output will include the following information:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4bc0\"\u003e10:08:37.070 [main] ERROR LoggingExampleMDC - customerId=C123, orderId=O98765 - Order processing failed\u003cbr/\u003ejava.lang.Exception: Order processing exception\u003cbr/\u003e    at LoggingExampleMDCKt.processOrder(LoggingExampleMDC.kt:12)\u003cbr/\u003e    at LoggingExampleMDCKt.main(LoggingExampleMDC.kt:21)\u003cbr/\u003e    at LoggingExampleMDCKt.main(LoggingExampleMDC.kt)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5140\"\u003eThis way, any logs within the context block will include these additional MDC properties, making it easier to track related logs across different services or requests.\u003c/p\u003e\u003ch2 id=\"385d\"\u003eMDC and Coroutines\u003c/h2\u003e\u003cp id=\"b62d\"\u003eMDC uses \u003ccode\u003eThreadLocal\u003c/code\u003e to store context information, therefore when using coroutines, the context must be explicitly propagated between threads.\u003c/p\u003e\u003cp id=\"69c8\"\u003eKotlin coroutines provide built-in support for MDC via the \u003ccode\u003eMDCContext\u003c/code\u003e function, which ensures that the MDC data is transported between coroutine contexts. For example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4ddf\"\u003eimport io.github.oshai.kotlinlogging.KotlinLogging\u003cbr/\u003eimport io.github.oshai.kotlinlogging.withLoggingContext\u003cbr/\u003eimport kotlinx.coroutines.runBlocking\u003cbr/\u003eimport kotlinx.coroutines.launch\u003cbr/\u003eimport kotlinx.coroutines.slf4j.MDCContext\u003cp\u003eprivate val logger = KotlinLogging.logger {}\u003cbr/\u003efun main() = runBlocking {\u003cbr/\u003e    withLoggingContext(\u0026#34;customerId\u0026#34; to \u0026#34;C123\u0026#34;, \u0026#34;orderId\u0026#34; to \u0026#34;O98765\u0026#34;) {\u003cbr/\u003e        launch(MDCContext()) {\u003cbr/\u003e            logger.info { \u0026#34;Starting coroutine for order processing\u0026#34; }\u003cbr/\u003e            // Simulate order processing\u003cbr/\u003e            logger.info { \u0026#34;Order processed with status: Shipped\u0026#34; }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eff3\"\u003eIn this case, the \u003ccode\u003eMDCContext()\u003c/code\u003e ensures that the \u003ccode\u003ecustomerId\u003c/code\u003e and \u003ccode\u003eorderId\u003c/code\u003e MDC properties are carried into the coroutine, allowing you to maintain the same context across concurrent operations.\u003c/p\u003e\u003cp id=\"fa2b\"\u003eTo use MDC with coroutines, you need to add the following dependency to your project:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6bc6\"\u003edependencies {\u003cbr/\u003e    implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-slf4j:\u0026lt;version\u0026gt;\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2039\"\u003eThis ensures that your application can propagate MDC data correctly between coroutines.\u003c/p\u003e\u003ch2 id=\"fb77\"\u003eAdditional Information\u003c/h2\u003e\u003cul\u003e\u003cli id=\"879c\"\u003e\u003cstrong\u003eOlder versions of Kotlin-Logging:\u003c/strong\u003e Version 5 brought package structure changes and no longer bundles SLF4J, see \u003ca href=\"https://github.com/oshai/kotlin-logging/blob/master/ChangeLog.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003echange log\u003c/a\u003e for more information. It is not backward compatible, but you can run older and newer versions side by side.\u003c/li\u003e\u003cli id=\"11cd\"\u003e\u003cstrong\u003eEmerging alternative — Klogging:\u003c/strong\u003e A new Kotlin logging library offering a seamless structured logging with coroutine support. Still in development, \u003ca href=\"https://klogging.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKlogging\u003c/strong\u003e\u003c/a\u003e shows promise for future projects but may not yet be stable for production use.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1b1a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"af01\"\u003eKotlin-Logging is a powerful yet simple tool for adding structured, efficient logging to your Kotlin applications. By integrating with popular backends like SLF4J and Logback, Kotlin-Logging retains all the capabilities you are used to but with cleaner, more idiomatic syntax. Whether you are building a simple application or managing complex, distributed systems, Kotlin-Logging can simplify your logging practices. Its seamless integration with existing logging frameworks like SLF4J and Logback, combined with structured logging and MDC, ensures that your logs are not only cleaner and more efficient but also more informative and easy to trace.\u003c/p\u003e\u003cp id=\"ca13\"\u003e\u003cstrong\u003eTip recap\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4268\"\u003eUse \u003cstrong\u003eKotlin-Logging\u003c/strong\u003e to simplify logging with clean syntax and improve performance with lazy message evaluation.\u003c/li\u003e\u003cli id=\"77c8\"\u003e\u003cstrong\u003eUse structured logging when\u003c/strong\u003e you need to add specific metadata (like customer ID or order number) to individual log entries for better traceability.\u003c/li\u003e\u003cli id=\"e948\"\u003e\u003cstrong\u003eUse MDC when\u003c/strong\u003e you want to attach the same metadata across multiple log messages in the same workflow, ensuring consistent context without repeating data.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ff8a\"\u003eTry Kotlin-Logging in your next Kotlin project to enhance your logging experience!\u003c/p\u003e\u003cp id=\"374f\"\u003eFor more Kotlin tips and tricks, visit my \u003ca href=\"https://medium.com/@elenavanengelen\" rel=\"noopener\"\u003eMedium blog homepage\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-09-10T14:42:26.614Z",
  "modifiedTime": null
}
