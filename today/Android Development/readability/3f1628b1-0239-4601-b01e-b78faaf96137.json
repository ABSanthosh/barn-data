{
  "id": "3f1628b1-0239-4601-b01e-b78faaf96137",
  "title": "Compose O'Clock",
  "link": "https://zsmb.co/compose-o-clock/",
  "description": "I started learning Jetpack Compose this week. Two days into that adventure, here's a quick look at how a neat clock design can be built up in Compose, step-by-step.",
  "author": "Márton Braun",
  "published": "Tue, 02 Mar 2021 16:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 12766,
  "excerpt": "I started learning Jetpack Compose this week. Two days into that adventure, here's a quick look at how a neat clock design can be built up in Compose, step-by-step.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "I’ve seen this fancy clock on Reddit a few days ago. Seeing how I took this week to get started with Jetpack Compose, I figured it would be fun to attempt re-implementing that clock with our new Android UI toolkit. A couple hours ago, I’ve seen that Aurimas Liutikas already created a Compose implementation of the same design, but I intentionally did not look at the source, as I really wanted to figure out how to do this myself. Here’s what I came up with, just two days into learning Jetpack Compose, in about an hour’s worth of trial and error. Let’s see how this can be built, step-by-step. If you’re looking for the full code for this sample, it’s all available on GitHub. A single digit First, we’ll create a Number composable, which contains a Text with a fixed size. This takes a single parameter, the numerical value it should display. @Composable fun Number(value: Int) { Text( text = value.toString(), fontSize = 20.sp, modifier = Modifier.size(40.dp) ) } Creating a @Preview with a Number in it lets us quickly check how this looks: @Composable @Preview fun NumberPreview() { Number(3) } This renders the number in the upper left corner, but we wanted to center this Text within its 40dp by 40dp area. Setting textAlign on it would solve this horizontally, but I didn’t find anything similar for vertical alignment. Therefore, let’s just wrap it in a Box to achieve the alignment. @Composable fun Number(value: Int) { Box( contentAlignment = Alignment.Center, modifier = Modifier.size(40.dp), ) { Text( text = value.toString(), fontSize = 20.sp, ) } } Continuing on, time to add some colour! The Box will provide a dark background colour, and the text will be white: @Composable fun Number(value: Int) { Box( contentAlignment = Alignment.Center, modifier = Modifier .size(40.dp) .background(MaterialTheme.colors.primary), ) { Text( text = value.toString(), fontSize = 20.sp, color = Color.White, ) } } The currently selected number should have a different background colour within its column. This requires a new Boolean parameter in the composable, and then a simple if statement can decide which colour to use. @Composable fun Number(value: Int, active: Boolean) { val backgroundColor = if (active) { MaterialTheme.colors.primary } else { MaterialTheme.colors.primaryVariant } Box( contentAlignment = Alignment.Center, modifier = Modifier .size(40.dp) .background(backgroundColor), ) { Text( text = value.toString(), fontSize = 20.sp, color = Color.White, ) } } Let’s also update the preview so that it shows one of each style of Number: @Composable @Preview fun NumberPreview() { Column { Number(value = 3, active = true) Number(value = 7, active = false) } } A column of digits That’s it for a single number! Now, to render a column of these, with a new NumberColumn composable. This takes a range of valid values, and the currently selected value as its parameters. A clip modifier gives us neat rounded corners, and creating each Number is as simple as iterating through the provided range. @Composable fun NumberColumn( range: IntRange, current: Int, ) { Column( Modifier.clip(RoundedCornerShape(percent = 25)) ) { range.forEach { num -\u003e Number(num, num == current) } } } Again, let’s see a quick preview: @Composable @Preview fun NumberColumnPreview() { NumberColumn(range = 0..9, current = 5) } Looking good so far! Creating a clock Time to make this look and work like a clock. This requires six of these NumberColumns, each receiving a digit of the current time as its parameter. The time will be provided by a Time data class. The columns are arranged in a Row, which takes up the entire screen, and centers everything inside it both horizontally and vertically. data class Time(val hours: Int, val minutes: Int, val seconds: Int) @Composable fun Clock(time: Time) { Row( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically, ) { NumberColumn(0..2, time.hours / 10) NumberColumn(0..9, time.hours % 10) NumberColumn(0..5, time.minutes / 10) NumberColumn(0..9, time.minutes % 10) NumberColumn(0..5, time.seconds / 10) NumberColumn(0..9, time.seconds % 10) } } For now, we can display a static time in the preview: @Composable @Preview fun ClockPreview() { Clock(Time(14, 15, 59)) } This displays the given time correctly, but we’re missing alignment of the active digits. We want to offset each column vertically, based on how far the current digit is from the middle of the column. If the current digit is in the middle, it requires no offsetting. If it’s at the end, we want to offset it by half the height of the column. The math for this works out to be the distance of the current digit from the midpoint, times the height of each individual digit. The offset modifier gives us a very simple solution from here: @Composable fun NumberColumn( range: IntRange, current: Int, ) { val mid = (range.last - range.first) / 2f val offset = 40.dp * (mid - current) Column( Modifier .offset(y = offset) .clip(RoundedCornerShape(percent = 25)) ) { range.forEach { num -\u003e Number(num, num == current) } } } Now that we have the correct look, time to input the current time, and keep it updated. @Composable @Preview fun ClockPreview() { fun currentTime(): Time { // 1 val cal = Calendar.getInstance() return Time( hours = cal.get(Calendar.HOUR_OF_DAY), minutes = cal.get(Calendar.MINUTE), seconds = cal.get(Calendar.SECOND), ) } var time by remember { mutableStateOf(currentTime()) } // 2 LaunchedEffect(0) { // 3 while (true) { time = currentTime() delay(1000) } } Clock(time) } Let’s see how this is done, step-by-step: The currentTime function grabs a Calendar to get the current time, and creates one of our Time objects, which Clock can work with. This line creates a piece of mutable state that Compose understands and can recompose when its value changes. This is initialized to the current time. LaunchedEffect runs the suspending lambda passed to it, which will update time every second. LaunchedEffect will only recompose if its key parameter changes: the hardcoded dummy 0 value here ensures that it only starts this loop once. When the Composable that contains it leaves the composition, the coroutine will be cancelled. This gets us a working clock, which pops between the different states like so: Animations We still have a bit of work to do to animate this, but it’ll be quite easy. To animate the colour changes of each Number, we can use animateColorAsState. Wrapping our colour into this helper function will create a smooth default animation between the colours, instead of an instant change. @Composable fun Number(value: Int, active: Boolean) { val backgroundColor by animateColorAsState( if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant, ) Box( contentAlignment = Alignment.Center, modifier = Modifier .size(40.dp) .background(backgroundColor), ) { ... } } The story is very similar for animating the movement of the columns. We simply wrap their offset value using the animateDpAsState function: @Composable fun NumberColumn( range: IntRange, current: Int, ) { val mid = (range.last - range.first) / 2f val offset by animateDpAsState(targetValue = 40.dp * (mid - current)) Column( Modifier .offset(y = offset) .clip(RoundedCornerShape(percent = 25)) ) { ... } } This looks great! Animation added by changing just a couple lines of code. Cleanup and tweaks Let’s tweak the UI a bit to make it look even nicer. First, we’ll add a modifier parameter to Number, allowing its users to customize it. For example, previously our Number has a fixed 40dp size - this is something that would be better to control externally. We’ll use this parameter on the Box at the root of the Number composable, adding our own modifiers on top of it. @Composable fun Number(value: Int, active: Boolean, modifier: Modifier = Modifier) { val backgroundColor by animateColorAsState( if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant, ) Box( modifier = modifier.background(backgroundColor), contentAlignment = Alignment.Center, ) { ... } } In NumberColumn, we’ll create a size value, which we’ll use in our offset calculations, and pass in to each Number. This way, resizing our UI can be done here, in just one place in our code. NumberColumn will also have its own modifier parameter to allow for some customization. @Composable fun NumberColumn( range: IntRange, current: Int, modifier: Modifier = Modifier, ) { val size = 40.dp val mid = (range.last - range.first) / 2f val offset by animateDpAsState(size * (mid - current)) Column( modifier .offset(y = offset) .clip(RoundedCornerShape(percent = 25)) ) { range.forEach { num -\u003e Number(num, num == current, Modifier.size(size)) } } } We’ll use that modifier parameter to add some padding on each column, and we can also add some Spacers between the pairs of columns: @Composable fun Clock(time: Time) { Row( modifier = Modifier.fillMaxSize(), horizontalArrangement = Arrangement.Center, verticalAlignment = Alignment.CenterVertically, ) { val padding = Modifier.padding(horizontal = 4.dp) NumberColumn(0..2, time.hours / 10, padding) NumberColumn(0..9, time.hours % 10, padding) Spacer(Modifier.size(16.dp)) NumberColumn(0..5, time.minutes / 10, padding) NumberColumn(0..9, time.minutes % 10, padding) Spacer(Modifier.size(16.dp)) NumberColumn(0..5, time.seconds / 10, padding) NumberColumn(0..9, time.seconds % 10, padding) } } As a final tweak, let’s add a special animation for when the columns reset - go from the highest value to the lowest - as this case looks a bit too jumpy with the previous default offset animation. Within the animateDpAsState call, we can specify an AnimationSpec, which controls how the values transition from one targetValue to the next. The different types of animations are listed in the official documentation. We’ll use a spring() for the reset animation (with a bit of a bounce to it), and a simple tween() for the rest of the offset changes. val reset = current == range.first val offset by animateDpAsState( targetValue = size * (mid - current), animationSpec = if (reset) { spring( dampingRatio = Spring.DampingRatioLowBouncy, stiffness = Spring.StiffnessLow, ) } else { tween( durationMillis = 300, easing = LinearOutSlowInEasing, ) } ) Conclusion That’s it! This was a quick demo of building UI with Jetpack Compose. The full code for this example is available on GitHub. Compose is the clear future path for Android UI development, and it’s really exciting to build UI with it. The speed of putting together this example with very basic knowledge of the framework makes me very hopeful for the future of Compose. Stay tuned for more Compose content! StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.For the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn't look quite right. Here's how I finally ended up remembering how the ordering works.Fragments have... Complicated lifecycles, to say the least. Let's take a look at these, and how they all fit into the world of Jetpack today, with LifecycleOwners, LiveData, and coroutines.In what may be the start of a new series, I code review a project that was posted on reddit recently and got very popular very quickly. Let's see what we can learn from it?",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003eI’ve seen \u003ca href=\"https://www.reddit.com/r/oddlysatisfying/comments/lsa654/this_clock_hitting_midnight_is_oddly_satisfying/\"\u003ethis fancy clock\u003c/a\u003e on Reddit a few days ago. Seeing how I took this week to get started with Jetpack Compose, I figured it would be fun to attempt re-implementing that clock with our new Android UI toolkit.\u003c/p\u003e\n\u003cp\u003eA couple hours ago, I’ve seen that Aurimas Liutikas \u003ca href=\"https://twitter.com/_aurimas/status/1366557927067185157\"\u003ealready created a Compose implementation\u003c/a\u003e of the same design, but I intentionally did not look at the source, as I really wanted to figure out how to do this myself.\u003c/p\u003e\n\u003cp\u003eHere’s what I came up with, just two days into learning Jetpack Compose, in about an hour’s worth of trial and error.\u003c/p\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" playsinline=\"\" width=\"400\"\u003e\n    \u003csource src=\"https://zsmb.co/images/compose-o-clock/dark_animation.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eLet’s see how this can be built, step-by-step.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you’re looking for the full code for this sample, it’s all available \u003ca href=\"https://github.com/zsmb13/ComposeClock/blob/main/app/src/main/java/co/zsmb/composeclock/MainActivity.kt\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"a-single-digit\"\u003eA single digit\u003c/h3\u003e\n\u003cp\u003eFirst, we’ll create a \u003ccode\u003eNumber\u003c/code\u003e composable, which contains a \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary.html#text\"\u003e\u003ccode\u003eText\u003c/code\u003e\u003c/a\u003e with a fixed size. This takes a single parameter, the numerical value it should display.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int) {\n    Text(\n        text = value.toString(),\n        fontSize = 20.sp,\n        modifier = Modifier.size(40.dp)\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCreating a \u003ccode\u003e@Preview\u003c/code\u003e with a \u003ccode\u003eNumber\u003c/code\u003e in it lets us quickly check how this looks:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\n@Preview\nfun NumberPreview() {\n    Number(3)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/text.png\" alt=\"A single digit on the screen\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis renders the number in the upper left corner, but we wanted to center this \u003ccode\u003eText\u003c/code\u003e within its \u003ccode\u003e40dp\u003c/code\u003e by \u003ccode\u003e40dp\u003c/code\u003e area. Setting \u003ccode\u003etextAlign\u003c/code\u003e on it would solve this horizontally, but I didn’t find anything similar for vertical alignment. Therefore, let’s just wrap it in a \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#box\"\u003e\u003ccode\u003eBox\u003c/code\u003e\u003c/a\u003e to achieve the alignment.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int) {\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier.size(40.dp),\n    ) {\n        Text(\n            text = value.toString(),\n            fontSize = 20.sp,\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/text_boxed.png\" alt=\"A single digit, now with correct positioning\"/\u003e\u003c/p\u003e\n\u003cp\u003eContinuing on, time to add some colour! The \u003ccode\u003eBox\u003c/code\u003e will provide a dark background colour, and the text will be white:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int) {\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier\n            .size(40.dp)\n            .background(MaterialTheme.colors.primary),\n    ) {\n        Text(\n            text = value.toString(),\n            fontSize = 20.sp,\n            color = Color.White,\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/text_boxed_coloured.png\" alt=\"A digit with a background colour and white text\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe currently selected number should have a different background colour within its column. This requires a new \u003ccode\u003eBoolean\u003c/code\u003e parameter in the composable, and then a simple \u003ccode\u003eif\u003c/code\u003e statement can decide which colour to use.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int, active: Boolean) {\n    val backgroundColor = if (active) {\n        MaterialTheme.colors.primary\n    } else {\n        MaterialTheme.colors.primaryVariant\n    }\n\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier\n            .size(40.dp)\n            .background(backgroundColor),\n    ) {\n        Text(\n            text = value.toString(),\n            fontSize = 20.sp,\n            color = Color.White,\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s also update the preview so that it shows one of each style of \u003ccode\u003eNumber\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\n@Preview\nfun NumberPreview() {\n    Column {\n        Number(value = 3, active = true)\n        Number(value = 7, active = false)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/text_boxed_multiple_colours.png\" alt=\"Two different digits with different background colour\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"a-column-of-digits\"\u003eA column of digits\u003c/h3\u003e\n\u003cp\u003eThat’s it for a single number! Now, to render a column of these, with a new \u003ccode\u003eNumberColumn\u003c/code\u003e composable. This takes a range of valid values, and the currently selected value as its parameters. A \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier).clip(androidx.compose.ui.graphics.Shape)\"\u003e\u003ccode\u003eclip\u003c/code\u003e\u003c/a\u003e modifier gives us neat rounded corners, and creating each \u003ccode\u003eNumber\u003c/code\u003e is as simple as iterating through the provided \u003ccode\u003erange\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun NumberColumn(\n    range: IntRange,\n    current: Int,\n) {\n    Column(\n        Modifier.clip(RoundedCornerShape(percent = 25))\n    ) {\n        range.forEach { num -\u0026gt;\n            Number(num, num == current)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, let’s see a quick preview:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\n@Preview\nfun NumberColumnPreview() {\n    NumberColumn(range = 0..9, current = 5)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/column.png\" alt=\"A column of digits, with one selected\"/\u003e\u003c/p\u003e\n\u003cp\u003eLooking good so far!\u003c/p\u003e\n\u003ch3 id=\"creating-a-clock\"\u003eCreating a clock\u003c/h3\u003e\n\u003cp\u003eTime to make this look and work like a clock. This requires six of these \u003ccode\u003eNumberColumn\u003c/code\u003es, each receiving a digit of the current time as its parameter. The time will be provided by a \u003ccode\u003eTime\u003c/code\u003e data class. The columns are arranged in a \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#row\"\u003e\u003ccode\u003eRow\u003c/code\u003e\u003c/a\u003e, which takes up the entire screen, and centers everything inside it both horizontally and vertically.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edata class Time(val hours: Int, val minutes: Int, val seconds: Int)\n\n@Composable\nfun Clock(time: Time) {\n    Row(\n        modifier = Modifier.fillMaxSize(),\n        horizontalArrangement = Arrangement.Center,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        NumberColumn(0..2, time.hours / 10)\n        NumberColumn(0..9, time.hours % 10)\n        NumberColumn(0..5, time.minutes / 10)\n        NumberColumn(0..9, time.minutes % 10)\n        NumberColumn(0..5, time.seconds / 10)\n        NumberColumn(0..9, time.seconds % 10)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor now, we can display a static time in the preview:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\n@Preview\nfun ClockPreview() {\n    Clock(Time(14, 15, 59))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/columns.png\" alt=\"Multiple columns of digits, showing the current time\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis displays the given time correctly, but we’re missing alignment of the active digits. We want to offset each column vertically, based on how far the current digit is from the middle of the column. If the current digit is in the middle, it requires no offsetting. If it’s at the end, we want to offset it by half the height of the column.\u003c/p\u003e\n\u003cp\u003eThe math for this works out to be the distance of the current digit from the midpoint, times the height of each individual digit. The \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary.html#(androidx.compose.ui.Modifier).offset(androidx.compose.ui.unit.Dp,%20androidx.compose.ui.unit.Dp)\"\u003e\u003ccode\u003eoffset\u003c/code\u003e\u003c/a\u003e modifier gives us a very simple solution from here:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun NumberColumn(\n    range: IntRange,\n    current: Int,\n) {\n    val mid = (range.last - range.first) / 2f\n    val offset = 40.dp * (mid - current)\n\n    Column(\n        Modifier\n            .offset(y = offset)\n            .clip(RoundedCornerShape(percent = 25))\n    ) {\n        range.forEach { num -\u0026gt;\n            Number(num, num == current)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/compose-o-clock/aligned_columns.png\" alt=\"Multiple columns of digits, now aligned at their currently selected item\"/\u003e\u003c/p\u003e\n\u003cp\u003eNow that we have the correct look, time to input the current time, and keep it updated.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\n@Preview\nfun ClockPreview() {\n    fun currentTime(): Time { // 1\n        val cal = Calendar.getInstance()\n        return Time(\n            hours = cal.get(Calendar.HOUR_OF_DAY),\n            minutes = cal.get(Calendar.MINUTE),\n            seconds = cal.get(Calendar.SECOND),\n        )\n    }\n\n    var time by remember { mutableStateOf(currentTime()) } // 2\n    LaunchedEffect(0) { // 3\n        while (true) {\n            time = currentTime()\n            delay(1000)\n        }\n    }\n\n    Clock(time)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s see how this is done, step-by-step:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003ecurrentTime\u003c/code\u003e function grabs a \u003ccode\u003eCalendar\u003c/code\u003e to get the current time, and creates one of our \u003ccode\u003eTime\u003c/code\u003e objects, which \u003ccode\u003eClock\u003c/code\u003e can work with.\u003c/li\u003e\n\u003cli\u003eThis line creates a piece of mutable state that Compose understands and can recompose when its value changes. This is initialized to the current time.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#launchedeffect_1\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e\u003c/a\u003e runs the suspending lambda passed to it, which will update \u003ccode\u003etime\u003c/code\u003e every second. \u003ccode\u003eLaunchedEffect\u003c/code\u003e will only recompose if its \u003ccode\u003ekey\u003c/code\u003e parameter changes: the hardcoded dummy 0 value here ensures that it only starts this loop once. When the \u003ccode\u003eComposable\u003c/code\u003e that contains it leaves the composition, the coroutine will be cancelled.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis gets us a working clock, which pops between the different states like so:\u003c/p\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" playsinline=\"\" width=\"400\"\u003e\n    \u003csource src=\"https://zsmb.co/images/compose-o-clock/no_animation.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003ch3 id=\"animations\"\u003eAnimations\u003c/h3\u003e\n\u003cp\u003eWe still have a bit of work to do to animate this, but it’ll be quite easy. To animate the colour changes of each \u003ccode\u003eNumber\u003c/code\u003e, we can use \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#animatecolorasstate\"\u003e\u003ccode\u003eanimateColorAsState\u003c/code\u003e\u003c/a\u003e. Wrapping our colour into this helper function will create a smooth default animation between the colours, instead of an instant change.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int, active: Boolean) {\n    val backgroundColor by animateColorAsState(\n        if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant,\n    )\n\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier\n            .size(40.dp)\n            .background(backgroundColor),\n    ) { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe story is very similar for animating the movement of the columns. We simply wrap their offset value using the \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animatedpasstate\"\u003e\u003ccode\u003eanimateDpAsState\u003c/code\u003e\u003c/a\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun NumberColumn(\n    range: IntRange,\n    current: Int,\n) {\n    val mid = (range.last - range.first) / 2f\n    val offset by animateDpAsState(targetValue = 40.dp * (mid - current))\n\n    Column(\n        Modifier\n            .offset(y = offset)\n            .clip(RoundedCornerShape(percent = 25))\n    ) { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" playsinline=\"\" width=\"400\"\u003e\n    \u003csource src=\"https://zsmb.co/images/compose-o-clock/default_animation.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eThis looks great! Animation added by changing just a couple lines of code.\u003c/p\u003e\n\u003ch3 id=\"cleanup-and-tweaks\"\u003eCleanup and tweaks\u003c/h3\u003e\n\u003cp\u003eLet’s tweak the UI a bit to make it look even nicer. First, we’ll add a \u003ccode\u003emodifier\u003c/code\u003e parameter to \u003ccode\u003eNumber\u003c/code\u003e, allowing its users to customize it. For example, previously our \u003ccode\u003eNumber\u003c/code\u003e has a fixed \u003ccode\u003e40dp\u003c/code\u003e size - this is something that would be better to control externally.\u003c/p\u003e\n\u003cp\u003eWe’ll use this parameter on the \u003ccode\u003eBox\u003c/code\u003e at the root of the \u003ccode\u003eNumber\u003c/code\u003e composable, adding our own modifiers on top of it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Number(value: Int, active: Boolean, modifier: Modifier = Modifier) {\n    val backgroundColor by animateColorAsState(\n        if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant,\n    )\n\n    Box(\n        modifier = modifier.background(backgroundColor),\n        contentAlignment = Alignment.Center,\n    ) { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn \u003ccode\u003eNumberColumn\u003c/code\u003e, we’ll create a \u003ccode\u003esize\u003c/code\u003e value, which we’ll use in our offset calculations, and pass in to each \u003ccode\u003eNumber\u003c/code\u003e. This way, resizing our UI can be done here, in just one place in our code.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNumberColumn\u003c/code\u003e will also have its own \u003ccode\u003emodifier\u003c/code\u003e parameter to allow for some customization.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun NumberColumn(\n    range: IntRange,\n    current: Int,\n    modifier: Modifier = Modifier,\n) {\n    val size = 40.dp\n    val mid = (range.last - range.first) / 2f\n    val offset by animateDpAsState(size * (mid - current))\n\n    Column(\n        modifier\n            .offset(y = offset)\n            .clip(RoundedCornerShape(percent = 25))\n    ) {\n        range.forEach { num -\u0026gt;\n            Number(num, num == current, Modifier.size(size))\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ll use that \u003ccode\u003emodifier\u003c/code\u003e parameter to add some padding on each column, and we can also add some \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#spacer\"\u003e\u003ccode\u003eSpacer\u003c/code\u003e\u003c/a\u003es between the pairs of columns:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun Clock(time: Time) {\n    Row(\n        modifier = Modifier.fillMaxSize(),\n        horizontalArrangement = Arrangement.Center,\n        verticalAlignment = Alignment.CenterVertically,\n    ) {\n        val padding = Modifier.padding(horizontal = 4.dp)\n\n        NumberColumn(0..2, time.hours / 10, padding)\n        NumberColumn(0..9, time.hours % 10, padding)\n        Spacer(Modifier.size(16.dp))\n        NumberColumn(0..5, time.minutes / 10, padding)\n        NumberColumn(0..9, time.minutes % 10, padding)\n        Spacer(Modifier.size(16.dp))\n        NumberColumn(0..5, time.seconds / 10, padding)\n        NumberColumn(0..9, time.seconds % 10, padding)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" playsinline=\"\" width=\"400\"\u003e\n    \u003csource src=\"https://zsmb.co/images/compose-o-clock/spaced_animation.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003cp\u003eAs a final tweak, let’s add a special animation for when the columns reset - go from the highest value to the lowest - as this case looks a bit too jumpy with the previous default offset animation.\u003c/p\u003e\n\u003cp\u003eWithin the \u003ccode\u003eanimateDpAsState\u003c/code\u003e call, we can specify an \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec\"\u003e\u003ccode\u003eAnimationSpec\u003c/code\u003e\u003c/a\u003e, which controls how the values transition from one \u003ccode\u003etargetValue\u003c/code\u003e to the next. The different types of animations are listed in the \u003ca href=\"https://developer.android.com/jetpack/compose/animation#animationspec\"\u003eofficial documentation\u003c/a\u003e. We’ll use a \u003ccode\u003espring()\u003c/code\u003e for the reset animation (with a bit of a bounce to it), and a simple \u003ccode\u003etween()\u003c/code\u003e for the rest of the offset changes.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval reset = current == range.first\nval offset by animateDpAsState(\n    targetValue = size * (mid - current),\n    animationSpec = if (reset) {\n        spring(\n            dampingRatio = Spring.DampingRatioLowBouncy,\n            stiffness = Spring.StiffnessLow,\n        )\n    } else {\n        tween(\n            durationMillis = 300,\n            easing = LinearOutSlowInEasing,\n        )\n    }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" playsinline=\"\" width=\"400\"\u003e\n    \u003csource src=\"https://zsmb.co/images/compose-o-clock/tweaked_animation.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eThat’s it! This was a quick demo of building UI with Jetpack Compose. The full code for this example is available \u003ca href=\"https://github.com/zsmb13/ComposeClock/blob/main/app/src/main/java/co/zsmb/composeclock/MainActivity.kt\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCompose is the clear future path for Android UI development, and it’s really exciting to build UI with it. The speed of putting together this example with very basic knowledge of the framework makes me very hopeful for the future of Compose.\u003c/p\u003e\n\u003cp\u003eStay tuned for more Compose content!\u003c/p\u003e\n\n\u003c/div\u003e\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\u003cp\u003eFor the longest time, I proudly had no idea of how Modifier ordering works, and would just guess and then guess again when something didn\u0026#39;t look quite right. Here\u0026#39;s how I finally ended up remembering how the ordering works.\u003c/p\u003e\u003cp\u003eFragments have... Complicated lifecycles, to say the least. Let\u0026#39;s take a look at these, and how they all fit into the world of Jetpack today, with LifecycleOwners, LiveData, and coroutines.\u003c/p\u003e\u003cp\u003eIn what may be the start of a new series, I code review a project that was posted on reddit recently and got very popular very quickly. Let\u0026#39;s see what we can learn from it?\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
