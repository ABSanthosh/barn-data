{
  "id": "7bfbe545-bef2-4583-8bcf-185d7483dd0e",
  "title": "Top 3 Android Use Cases for Every SOLID Principle (with Code)",
  "link": "https://proandroiddev.com/top-3-android-use-cases-for-every-solid-principle-with-code-960eedcdbc3f?source=rss----c72404660798---4",
  "description": "",
  "author": "Dobri Kostadinov",
  "published": "Sun, 06 Apr 2025 18:02:13 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "mobile-app-development",
    "androiddev",
    "android-app-development"
  ],
  "byline": "Dobri Kostadinov",
  "length": 10046,
  "excerpt": "As Android developers, we often hear about the SOLID principles, but letâ€™s be real â€” itâ€™s not always clear how to apply them specifically in our projects. SOLID is a set of five design principlesâ€¦",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Learn how to apply each SOLID principle in Android apps with 15 focused use cases and Kotlin code examples.source: istockphoto.comIntroductionAs Android developers, we often hear about the SOLID principles, but letâ€™s be real â€” itâ€™s not always clear how to apply them specifically in our projects. SOLID is a set of five design principles that help make software more maintainable, flexible, and scalable. Originally coined by Uncle Bob (Robert C. Martin), these principles are especially powerful in Android when youâ€™re working on large codebases or want better testability and separation of concerns.In this article, weâ€™ll explore three real-world Android use cases for each of the SOLID principles â€” complete with Kotlin code snippets and detailed explanations. Whether youâ€™re building Jetpack Compose UIs, integrating with APIs, or setting up your ViewModels and UseCases, youâ€™ll walk away with practical knowledge you can apply today.ðŸŸ  1. Single Responsibility Principle (SRP)A class should have one reason to change.In Android development, classes tend to become bloated quickly â€” think of Activity, Fragment, or ViewModel handling UI, navigation, API calls, error handling, and more. SRP encourages us to split responsibilities so each class does one thing well.âœ… Use Case 1: Split ViewModel UI and Business Logicclass LoginUseCase(private val repository: LoginRepository) { suspend fun login(username: String, password: String): Result\u003cUser\u003e { if (username.isEmpty()) return Result.failure(Exception(\"Username empty\")) return repository.login(username, password) }}class LoginViewModel(private val useCase: LoginUseCase) : ViewModel() { val uiState = MutableStateFlow\u003cUiState\u003e(UiState.Idle) fun login(username: String, password: String) { viewModelScope.launch { uiState.value = UiState.Loading val result = useCase.login(username, password) uiState.value = if (result.isSuccess) UiState.Success else UiState.Error } }}Why this matters: Moving business logic out of the ViewModel and into a UseCase separates concerns and improves testability. The ViewModel focuses only on UI state management, while the UseCase is reusable and testable on its own.âœ… Use Case 2: Extract API Calls from Repositoryinterface RemoteDataSource { suspend fun login(username: String, password: String): Result\u003cUser\u003e}class LoginRepository(private val remote: RemoteDataSource) { suspend fun login(username: String, password: String) = remote.login(username, password)}Why this matters: You delegate responsibility for API calls to RemoteDataSource, keeping your repository focused on data coordination. This makes it easier to replace or mock the remote logic during testing.âœ… Use Case 3: Split Responsibilities in Fragmentclass ProfileFragment : Fragment() {private val viewModel: ProfileViewModel by viewModels()override fun onViewCreated(view: View, savedInstanceState: Bundle?) { setupUi() observeViewModel() } private fun setupUi() { /* setup views, listeners */ } private fun observeViewModel() { /* collect flows */ }}Why this matters: Instead of crowding everything into onViewCreated, you give each method a specific job. This improves readability and ensures your Fragment follows SRPâ€”one task per method, one reason to change.ðŸŸ¡ 2. Open/Closed Principle (OCP)Software entities should be open for extension, but closed for modification.You should be able to add new features without modifying existing code. This reduces the risk of bugs and makes your codebase future-proof.âœ… Use Case 1: Extend Sealed Classes for UI Statessealed class UiState { object Loading : UiState() data class Success(val data: String) : UiState() data class Error(val message: String) : UiState()}data class Empty(val reason: String) : UiState()Why this matters: You can introduce new screen states like Empty without altering existing logic. Using sealed classes lets your code evolve safely with clear intent.âœ… Use Case 2: Custom ViewModel Factory with DIclass MyViewModelFactory @Inject constructor( private val useCase: SomeUseCase) : ViewModelProvider.Factory { override fun \u003cT : ViewModel\u003e create(modelClass: Class\u003cT\u003e): T { return MyViewModel(useCase) as T }}Why this matters: You can inject different use cases into your ViewModel without rewriting or modifying the ViewModel itself â€” just extend the factory behavior.âœ… Use Case 3: Compose Modifier Extensionsfun Modifier.errorBorder(): Modifier = this .border(2.dp, Color.Red)TextField( value = username, onValueChange = { username = it }, modifier = Modifier .fillMaxWidth() .then(if (hasError) Modifier.errorBorder() else Modifier))Why this matters: Modifiers in Jetpack Compose allow you to extend UI behavior without modifying the UI component. This keeps your UI flexible and reusable.ðŸŸ¢ 3. Liskov Substitution Principle (LSP)Subtypes must be substitutable for their base types.Any subclass or implementation should be usable wherever the base type is expected â€” without introducing errors.âœ… Use Case 1: Base Fragment with Template Methodsabstract class BaseFragment : Fragment() { abstract fun setupObservers() abstract fun setupUI()override fun onViewCreated(view: View, savedInstanceState: Bundle?) { setupUI() setupObservers() }}class LoginFragment : BaseFragment() { override fun setupUI() { /* Login UI */ } override fun setupObservers() { /* ViewModel observers */ }}Why this matters: You can create multiple screens that plug into the same base fragment structure without rewriting lifecycle code. Each screen extends the base behavior safely.âœ… Use Case 2: Multi-Type RecyclerViewabstract class BaseViewHolder(view: View) : RecyclerView.ViewHolder(view) { abstract fun bind(item: ListItem)}class TextViewHolder(view: View) : BaseViewHolder(view) { override fun bind(item: ListItem) { /* Bind text */ }}class ImageViewHolder(view: View) : BaseViewHolder(view) { override fun bind(item: ListItem) { /* Bind image */ }}Why this matters: Each ViewHolder type can be used wherever BaseViewHolder is expected. Your adapter logic stays generic, but the behavior is customized.âœ… Use Case 3: Replace Dispatchers for Testingopen class CoroutineDispatcherProvider { open val io = Dispatchers.IO open val main = Dispatchers.Main}class TestDispatcherProvider : CoroutineDispatcherProvider() { override val io = UnconfinedTestDispatcher() override val main = UnconfinedTestDispatcher()}Why this matters: In tests, you can inject a subclass without changing the production logic. Your classes work with any subclass of the base dispatcher provider.ðŸ”µ 4. Interface Segregation Principle (ISP)Clients should not be forced to depend on interfaces they donâ€™t use.In Android, this means keeping interfaces clean and focused â€” no bloated method contracts.âœ… Use Case 1: Split Repository Contractsinterface AuthRepository { suspend fun login(username: String, password: String): Result\u003cUser\u003e}interface ProfileRepository { suspend fun getProfile(): Result\u003cUserProfile\u003e}Why this matters: The LoginViewModel shouldnâ€™t care about getProfile()â€”so it doesnâ€™t. Smaller interfaces reduce coupling and simplify testing.âœ… Use Case 2: RecyclerView Click Listenersinterface OnImageClickListener { fun onImageClick(url: String)}interface OnTextClickListener { fun onTextClick(text: String)}Why this matters: Let each adapter implement only what it needs. This keeps components lightweight and avoids confusing method stubs.âœ… Use Case 3: Feature-Specific View Contractsinterface LoginContract { fun showLoginForm() fun showLoginSuccess()}interface SignupContract { fun showSignupForm() fun showSignupSuccess()}Why this matters: Avoid forcing unrelated screens (e.g., Login vs Signup) to implement shared methods they donâ€™t need. Focused interfaces = cleaner code.ðŸŸ£ 5. Dependency Inversion Principle (DIP)Depend on abstractions, not on concretions.This is the foundation of scalable Android apps using Clean Architecture or MVVM with DI.âœ… Use Case 1: Inject UseCase into ViewModelclass LoginViewModel(private val loginUseCase: LoginUseCase) : ViewModel() { fun login() = viewModelScope.launch { loginUseCase.login() }}Why this matters: You can mock LoginUseCase in tests. The ViewModel doesnâ€™t know or care about the implementationâ€”it just calls the abstraction.âœ… Use Case 2: Abstract Data Sourcesinterface UserDataSource { suspend fun fetchUser(): User}class RemoteUserDataSource : UserDataSource { override suspend fun fetchUser() = api.getUser()}class LocalUserDataSource : UserDataSource { override suspend fun fetchUser() = db.getUser()}Why this matters: You can switch between sources at runtime â€” e.g., use remote when online, local when offline â€” without changing the rest of your code.âœ… Use Case 3: Abstract Auth Storageinterface AuthStorage { suspend fun saveToken(token: String) suspend fun getToken(): String?}class DataStoreAuthStorage(...) : AuthStorage { override suspend fun saveToken(token: String) { /* Save to DataStore */ } override suspend fun getToken(): String? { /* Load from DataStore */ }}Why this matters: Whether you use DataStore, EncryptedSharedPrefs, or something else, your app logic stays the same. The rest of your app talks only to the interface.âœ… ConclusionThe SOLID principles arenâ€™t just abstract theory â€” theyâ€™re real tools you can use to improve your Android codebase today.To recap:SRP separates responsibilities, keeping classes focused.OCP lets you add new features without changing old code.LSP ensures safe inheritance and polymorphism.ISP helps break down bloated interfaces.DIP decouples logic, improving testability and flexibility.Start small. Refactor one ViewModel. Break one big interface into two. Inject one abstraction. These small changes now will lead to a solid architecture later (pun absolutely intended ðŸ˜‰).Dobri KostadinovAndroid Consultant | TrainerEmail me | Follow me on LinkedIn | Follow me on Medium | Buy me a coffee",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*gieIEBhQJOwmYvIogd5a3g.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"83e0\"\u003e\u003cem\u003eLearn how to apply each SOLID principle in Android apps with 15 focused use cases and Kotlin code examples.\u003c/em\u003e\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dobri.kostadinov?source=post_page---byline--960eedcdbc3f---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dobri Kostadinov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*PDWUz7RmoqP9kmFnZzGPUg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--960eedcdbc3f---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003esource: istockphoto.com\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"70d4\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"e104\"\u003eAs Android developers, we often hear about the SOLID principles, but letâ€™s be real â€” itâ€™s not always clear how to apply them \u003cem\u003especifically\u003c/em\u003e in our projects. SOLID is a set of five design principles that help make software more maintainable, flexible, and scalable. Originally coined by Uncle Bob (Robert C. Martin), these principles are especially powerful in Android when youâ€™re working on large codebases or want better testability and separation of concerns.\u003c/p\u003e\u003cp id=\"8b4d\"\u003eIn this article, weâ€™ll explore \u003cstrong\u003ethree real-world Android use cases\u003c/strong\u003e for each of the SOLID principles â€” complete with Kotlin code snippets \u003cstrong\u003eand detailed explanations\u003c/strong\u003e. Whether youâ€™re building Jetpack Compose UIs, integrating with APIs, or setting up your ViewModels and UseCases, youâ€™ll walk away with practical knowledge you can apply today.\u003c/p\u003e\u003ch2 id=\"4cfd\"\u003eðŸŸ  1. Single Responsibility Principle (SRP)\u003c/h2\u003e\u003cp id=\"58ba\"\u003e\u003cem\u003eA class should have one reason to change.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"5567\"\u003eIn Android development, classes tend to become bloated quickly â€” think of \u003ccode\u003eActivity\u003c/code\u003e, \u003ccode\u003eFragment\u003c/code\u003e, or \u003ccode\u003eViewModel\u003c/code\u003e handling UI, navigation, API calls, error handling, and more. SRP encourages us to split responsibilities so each class does \u003cem\u003eone thing well\u003c/em\u003e.\u003c/p\u003e\u003ch2 id=\"ca9b\"\u003eâœ… Use Case 1: Split ViewModel UI and Business Logic\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"eb39\"\u003eclass LoginUseCase(private val repository: LoginRepository) {\u003cbr/\u003e    suspend fun login(username: String, password: String): Result\u0026lt;User\u0026gt; {\u003cbr/\u003e        if (username.isEmpty()) return Result.failure(Exception(\u0026#34;Username empty\u0026#34;))\u003cbr/\u003e        return repository.login(username, password)\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003eclass LoginViewModel(private val useCase: LoginUseCase) : ViewModel() {\u003cbr/\u003e    val uiState = MutableStateFlow\u0026lt;UiState\u0026gt;(UiState.Idle)\u003cbr/\u003e    fun login(username: String, password: String) {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            uiState.value = UiState.Loading\u003cbr/\u003e            val result = useCase.login(username, password)\u003cbr/\u003e            uiState.value = if (result.isSuccess) UiState.Success else UiState.Error\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5507\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Moving business logic out of the \u003ccode\u003eViewModel\u003c/code\u003e and into a \u003ccode\u003eUseCase\u003c/code\u003e separates concerns and improves testability. The \u003ccode\u003eViewModel\u003c/code\u003e focuses only on UI state management, while the \u003ccode\u003eUseCase\u003c/code\u003e is reusable and testable on its own.\u003c/p\u003e\u003ch2 id=\"7035\"\u003eâœ… Use Case 2: Extract API Calls from Repository\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"3fc2\"\u003einterface RemoteDataSource {\u003cbr/\u003e    suspend fun login(username: String, password: String): Result\u0026lt;User\u0026gt;\u003cbr/\u003e}\u003cp\u003eclass LoginRepository(private val remote: RemoteDataSource) {\u003cbr/\u003e    suspend fun login(username: String, password: String) = remote.login(username, password)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"52e1\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You delegate responsibility for API calls to \u003ccode\u003eRemoteDataSource\u003c/code\u003e, keeping your repository focused on data coordination. This makes it easier to replace or mock the remote logic during testing.\u003c/p\u003e\u003ch2 id=\"2993\"\u003eâœ… Use Case 3: Split Responsibilities in Fragment\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0f47\"\u003eclass ProfileFragment : Fragment() {\u003cp\u003eprivate val viewModel: ProfileViewModel by viewModels()\u003c/p\u003e\u003cp\u003eoverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\u003cbr/\u003e        setupUi()\u003cbr/\u003e        observeViewModel()\u003cbr/\u003e    }\u003cbr/\u003e    private fun setupUi() { /* setup views, listeners */ }\u003cbr/\u003e    private fun observeViewModel() { /* collect flows */ }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3722\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Instead of crowding everything into \u003ccode\u003eonViewCreated\u003c/code\u003e, you give each method a specific job. This improves readability and ensures your Fragment follows SRPâ€”one task per method, one reason to change.\u003c/p\u003e\u003ch2 id=\"f3b4\"\u003eðŸŸ¡ 2. Open/Closed Principle (OCP)\u003c/h2\u003e\u003cp id=\"801a\"\u003e\u003cem\u003eSoftware entities should be open for extension, but closed for modification.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"16db\"\u003eYou should be able to add new features without modifying existing code. This reduces the risk of bugs and makes your codebase future-proof.\u003c/p\u003e\u003ch2 id=\"265a\"\u003eâœ… Use Case 1: Extend Sealed Classes for UI States\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"5fda\"\u003esealed class UiState {\u003cbr/\u003e    object Loading : UiState()\u003cbr/\u003e    data class Success(val data: String) : UiState()\u003cbr/\u003e    data class Error(val message: String) : UiState()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"4601\"\u003edata class Empty(val reason: String) : UiState()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"34d9\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You can introduce new screen states like \u003ccode\u003eEmpty\u003c/code\u003e without altering existing logic. Using sealed classes lets your code evolve safely with clear intent.\u003c/p\u003e\u003ch2 id=\"bdc9\"\u003eâœ… Use Case 2: Custom ViewModel Factory with DI\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"efb0\"\u003eclass MyViewModelFactory @Inject constructor(\u003cbr/\u003e    private val useCase: SomeUseCase\u003cbr/\u003e) : ViewModelProvider.Factory {\u003cbr/\u003e    override fun \u0026lt;T : ViewModel\u0026gt; create(modelClass: Class\u0026lt;T\u0026gt;): T {\u003cbr/\u003e        return MyViewModel(useCase) as T\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"546e\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You can inject different use cases into your ViewModel without rewriting or modifying the ViewModel itself â€” just extend the factory behavior.\u003c/p\u003e\u003ch2 id=\"acdf\"\u003eâœ… Use Case 3: Compose Modifier Extensions\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4b61\"\u003efun Modifier.errorBorder(): Modifier = this\u003cbr/\u003e    .border(2.dp, Color.Red)\u003cp\u003eTextField(\u003cbr/\u003e    value = username,\u003cbr/\u003e    onValueChange = { username = it },\u003cbr/\u003e    modifier = Modifier\u003cbr/\u003e        .fillMaxWidth()\u003cbr/\u003e        .then(if (hasError) Modifier.errorBorder() else Modifier)\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d20\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Modifiers in Jetpack Compose allow you to extend UI behavior without modifying the UI component. This keeps your UI flexible and reusable.\u003c/p\u003e\u003ch2 id=\"dfc6\"\u003eðŸŸ¢ 3. Liskov Substitution Principle (LSP)\u003c/h2\u003e\u003cp id=\"3fa4\"\u003e\u003cem\u003eSubtypes must be substitutable for their base types.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"e7e4\"\u003eAny subclass or implementation should be usable wherever the base type is expected â€” without introducing errors.\u003c/p\u003e\u003ch2 id=\"2db3\"\u003eâœ… Use Case 1: Base Fragment with Template Methods\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"f11b\"\u003eabstract class BaseFragment : Fragment() {\u003cbr/\u003e    abstract fun setupObservers()\u003cbr/\u003e    abstract fun setupUI()\u003cp\u003eoverride fun onViewCreated(view: View, savedInstanceState: Bundle?) {\u003cbr/\u003e        setupUI()\u003cbr/\u003e        setupObservers()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eclass LoginFragment : BaseFragment() {\u003cbr/\u003e    override fun setupUI() { /* Login UI */ }\u003cbr/\u003e    override fun setupObservers() { /* ViewModel observers */ }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ba01\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You can create multiple screens that plug into the same base fragment structure without rewriting lifecycle code. Each screen extends the base behavior safely.\u003c/p\u003e\u003ch2 id=\"86d6\"\u003eâœ… Use Case 2: Multi-Type RecyclerView\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0103\"\u003eabstract class BaseViewHolder(view: View) : RecyclerView.ViewHolder(view) {\u003cbr/\u003e    abstract fun bind(item: ListItem)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"5389\"\u003eclass TextViewHolder(view: View) : BaseViewHolder(view) {\u003cbr/\u003e    override fun bind(item: ListItem) { /* Bind text */ }\u003cbr/\u003e}\u003cp\u003eclass ImageViewHolder(view: View) : BaseViewHolder(view) {\u003cbr/\u003e    override fun bind(item: ListItem) { /* Bind image */ }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1887\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Each \u003ccode\u003eViewHolder\u003c/code\u003e type can be used wherever \u003ccode\u003eBaseViewHolder\u003c/code\u003e is expected. Your adapter logic stays generic, but the behavior is customized.\u003c/p\u003e\u003ch2 id=\"5754\"\u003eâœ… Use Case 3: Replace Dispatchers for Testing\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"c21f\"\u003eopen class CoroutineDispatcherProvider {\u003cbr/\u003e    open val io = Dispatchers.IO\u003cbr/\u003e    open val main = Dispatchers.Main\u003cbr/\u003e}\u003cp\u003eclass TestDispatcherProvider : CoroutineDispatcherProvider() {\u003cbr/\u003e    override val io = UnconfinedTestDispatcher()\u003cbr/\u003e    override val main = UnconfinedTestDispatcher()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5600\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e In tests, you can inject a subclass without changing the production logic. Your classes work with any subclass of the base dispatcher provider.\u003c/p\u003e\u003ch2 id=\"6aa3\"\u003eðŸ”µ 4. Interface Segregation Principle (ISP)\u003c/h2\u003e\u003cp id=\"a9fe\"\u003e\u003cem\u003eClients should not be forced to depend on interfaces they donâ€™t use.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"8b0c\"\u003eIn Android, this means keeping interfaces clean and focused â€” no bloated method contracts.\u003c/p\u003e\u003ch2 id=\"e1e4\"\u003eâœ… Use Case 1: Split Repository Contracts\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"6963\"\u003einterface AuthRepository {\u003cbr/\u003e    suspend fun login(username: String, password: String): Result\u0026lt;User\u0026gt;\u003cbr/\u003e}\u003cp\u003einterface ProfileRepository {\u003cbr/\u003e    suspend fun getProfile(): Result\u0026lt;UserProfile\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1f40\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e The \u003ccode\u003eLoginViewModel\u003c/code\u003e shouldnâ€™t care about \u003ccode\u003egetProfile()\u003c/code\u003eâ€”so it doesnâ€™t. Smaller interfaces reduce coupling and simplify testing.\u003c/p\u003e\u003ch2 id=\"b05b\"\u003eâœ… Use Case 2: RecyclerView Click Listeners\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"e7f9\"\u003einterface OnImageClickListener {\u003cbr/\u003e    fun onImageClick(url: String)\u003cbr/\u003e}\u003cp\u003einterface OnTextClickListener {\u003cbr/\u003e    fun onTextClick(text: String)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7788\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Let each adapter implement only what it needs. This keeps components lightweight and avoids confusing method stubs.\u003c/p\u003e\u003ch2 id=\"6506\"\u003eâœ… Use Case 3: Feature-Specific View Contracts\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"8c64\"\u003einterface LoginContract {\u003cbr/\u003e    fun showLoginForm()\u003cbr/\u003e    fun showLoginSuccess()\u003cbr/\u003e}\u003cp\u003einterface SignupContract {\u003cbr/\u003e    fun showSignupForm()\u003cbr/\u003e    fun showSignupSuccess()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ce98\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Avoid forcing unrelated screens (e.g., Login vs Signup) to implement shared methods they donâ€™t need. Focused interfaces = cleaner code.\u003c/p\u003e\u003ch2 id=\"c6c9\"\u003eðŸŸ£ 5. Dependency Inversion Principle (DIP)\u003c/h2\u003e\u003cp id=\"31d6\"\u003e\u003cem\u003eDepend on abstractions, not on concretions.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"c6d9\"\u003eThis is the foundation of scalable Android apps using Clean Architecture or MVVM with DI.\u003c/p\u003e\u003ch2 id=\"bd3b\"\u003eâœ… Use Case 1: Inject UseCase into ViewModel\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"abef\"\u003eclass LoginViewModel(private val loginUseCase: LoginUseCase) : ViewModel() {\u003cbr/\u003e    fun login() = viewModelScope.launch {\u003cbr/\u003e        loginUseCase.login()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ebb4\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You can mock \u003ccode\u003eLoginUseCase\u003c/code\u003e in tests. The ViewModel doesnâ€™t know or care about the implementationâ€”it just calls the abstraction.\u003c/p\u003e\u003ch2 id=\"d47c\"\u003eâœ… Use Case 2: Abstract Data Sources\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"e07b\"\u003einterface UserDataSource {\u003cbr/\u003e    suspend fun fetchUser(): User\u003cbr/\u003e}\u003cp\u003eclass RemoteUserDataSource : UserDataSource {\u003cbr/\u003e    override suspend fun fetchUser() = api.getUser()\u003cbr/\u003e}\u003cbr/\u003eclass LocalUserDataSource : UserDataSource {\u003cbr/\u003e    override suspend fun fetchUser() = db.getUser()\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"908d\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e You can switch between sources at runtime â€” e.g., use remote when online, local when offline â€” without changing the rest of your code.\u003c/p\u003e\u003ch2 id=\"2c15\"\u003eâœ… Use Case 3: Abstract Auth Storage\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"84fc\"\u003einterface AuthStorage {\u003cbr/\u003e    suspend fun saveToken(token: String)\u003cbr/\u003e    suspend fun getToken(): String?\u003cbr/\u003e}\u003cp\u003eclass DataStoreAuthStorage(...) : AuthStorage {\u003cbr/\u003e    override suspend fun saveToken(token: String) { /* Save to DataStore */ }\u003cbr/\u003e    override suspend fun getToken(): String? { /* Load from DataStore */ }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e6c8\"\u003e\u003cstrong\u003eWhy this matters:\u003c/strong\u003e\u003cbr/\u003e Whether you use DataStore, EncryptedSharedPrefs, or something else, your app logic stays the same. The rest of your app talks only to the interface.\u003c/p\u003e\u003ch2 id=\"68bd\"\u003eâœ… Conclusion\u003c/h2\u003e\u003cp id=\"b0b7\"\u003eThe SOLID principles arenâ€™t just abstract theory â€” theyâ€™re real tools you can use to improve your Android codebase today.\u003c/p\u003e\u003cp id=\"ec20\"\u003eTo recap:\u003c/p\u003e\u003cul\u003e\u003cli id=\"eab4\"\u003e\u003cstrong\u003eSRP\u003c/strong\u003e separates responsibilities, keeping classes focused.\u003c/li\u003e\u003cli id=\"c012\"\u003e\u003cstrong\u003eOCP\u003c/strong\u003e lets you add new features without changing old code.\u003c/li\u003e\u003cli id=\"2f78\"\u003e\u003cstrong\u003eLSP\u003c/strong\u003e ensures safe inheritance and polymorphism.\u003c/li\u003e\u003cli id=\"e8c9\"\u003e\u003cstrong\u003eISP\u003c/strong\u003e helps break down bloated interfaces.\u003c/li\u003e\u003cli id=\"570d\"\u003e\u003cstrong\u003eDIP\u003c/strong\u003e decouples logic, improving testability and flexibility.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"bacf\"\u003eStart small. Refactor one ViewModel. Break one big interface into two. Inject one abstraction. These small changes now will lead to a \u003cstrong\u003esolid\u003c/strong\u003e architecture later (pun absolutely intended ðŸ˜‰).\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fec6\"\u003e\u003cem\u003eDobri Kostadinov\u003c/em\u003e\u003cbr/\u003eAndroid Consultant | Trainer\u003cbr/\u003e\u003ca href=\"mailto:dobri.kostadinov@gmail.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEmail me\u003c/a\u003e | \u003ca href=\"https://www.linkedin.com/in/dobrikostadinov/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFollow me on LinkedIn\u003c/a\u003e | \u003ca href=\"https://medium.com/@dobri.kostadinov\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e | \u003ca href=\"https://www.buymeacoffee.com/dobri.kostadinov\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuy me a coffee\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-04-06T18:02:13.298Z",
  "modifiedTime": null
}
