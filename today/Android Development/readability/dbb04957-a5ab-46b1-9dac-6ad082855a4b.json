{
  "id": "dbb04957-a5ab-46b1-9dac-6ad082855a4b",
  "title": "Preparing for Network Failures this Holiday Season",
  "link": "https://publicobject.com/2023/11/20/idempotent-apis/",
  "description": "Suppose I’m connecting my home Christmas lights to the Internet. Perhaps I’ll make a mobile app that calls my home control server via an HTTP API:POST /lights/toggle HTTP/1.1 { \"subjects\": [\"maple_tree\", \"roof\"] }HTTP/1.1 200 OK { \"toggled\": true }It works. I can finally",
  "author": "Jesse Wilson",
  "published": "Mon, 20 Nov 2023 02:32:08 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 3589,
  "excerpt": "Suppose I’m connecting my home Christmas lights to the Internet. Perhaps I’ll make a mobile app that calls my home control server via an HTTP API: POST /lights/toggle HTTP/1.1 { \"subjects\": [\"maple_tree\", \"roof\"] } HTTP/1.1 200 OK { \"toggled\": true } It works. I can finally live the dad dream of flashing the lights on and off when my sports team scores. But this API? It sucks. If the network call fails, I won’t know what state the lights end up in. I might inadvertently leave the light",
  "siteName": "Public Object",
  "favicon": "",
  "text": "Suppose I’m connecting my home Christmas lights to the Internet. Perhaps I’ll make a mobile app that calls my home control server via an HTTP API:POST /lights/toggle HTTP/1.1 { \"subjects\": [\"maple_tree\", \"roof\"] }HTTP/1.1 200 OK { \"toggled\": true }It works. I can finally live the dad dream of flashing the lights on and off when my sports team scores.But this API? It sucks. If the network call fails, I won’t know what state the lights end up in. I might inadvertently leave the lights off and deprive my neighbours of holiday cheer.Mitigation 1: Check The Network FirstOne tempting mitigation is to check my phone’s connectivity before calling the toggle API. Perhaps I’ll use Android’s ConnectivityManager to only toggle the lights once I’ve confirmed that the device is connected to the Internet.But what does it mean to be connected to the Internet ? Not very much! On Android phones it probably means that a recent request to https://google.com/ resulted in a successful response.It doesn’t mean that a new request to https://google.com/ will succeed. I could have since stepped into a radio-blocking elevator and failed the request at the client.It doesn’t mean that a new request will reach the server. Each network call involves a sequence of fallible ISPs, DNS servers, gateways, and routers. If any of these are offline or overloaded the call fails on the network.It doesn’t mean that the server will successfully toggle the lights. My server code might have a bug that toggles the smart locks instead! Or perhaps it’s busy transcoding Bluey and will time out before anything is returned.Even a live TCP connection to a server is precarious: the client, network, and server can all fail without warning. Any strategy that checks connectivity first is fragile.Mitigation 2: Idempotence TokenFrom our vantage point on the client, we can’t differentiate between:The toggle request didn’t reach the serverThe server’s response didn’t reach the clientBut if the server can discard duplicate calls, the client can retry until it receives a positive response.POST /lights/toggle HTTP/1.1 { \"request_id\": \"a7240db9800efaa68251f797094a208d\", \"subjects\": [\"maple_tree\", \"roof\"] }This strategy is excellent and I recommend it everywhere. Here’s the recipe I follow:The client generates a universally-unique ID, such as UUID.randomUUID().The client includes that ID in every attempt. (If the request is stored in an on-device queue, the generated ID should be stored with it!)The server maintains a unique index of request IDs. Keeping these forever is easy and good enough for most applications.The server only performs the operation the first time it sees its request ID.The server returns the original response if a repeated request ID is received.Mitigation 3: Idempotent EndpointWe don’t need an idempotence token if we can make an idempotent API. ‘Turn on the lights’ is idempotent: doing it 5 times is the same as doing it once.We can make our API idempotent:POST /lights/set HTTP/1.1 { \"on\": true, \"subjects\": [\"maple_tree\", \"roof\"] }Version numbers offer another way to make other APIs idempotent:POST /lights/toggle HTTP/1.1 { \"require_version\": 99, \"subjects\": [\"maple_tree\", \"roof\"] }HTTP/1.1 200 OK { \"toggled\": true, \"result_version\": 100 }OkHttp Does RetriesThis topic is dear to me 'cause OkHttp automatically retries when a pooled TCP connection cannot be reused. This is scary behaviour! I don’t want anybody to accidentally buy two Christmas trees ’cause an HTTP request was repeated.Be idempotentSkip connectivity checksJust one Christmas Tree",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eSuppose I’m connecting my home Christmas lights to the Internet. Perhaps I’ll make a mobile app that calls my home control server via an HTTP API:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ePOST /lights/toggle HTTP/1.1\n\n{\n  \u0026#34;subjects\u0026#34;: [\u0026#34;maple_tree\u0026#34;, \u0026#34;roof\u0026#34;]\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eHTTP/1.1 200 OK\n\n{\n  \u0026#34;toggled\u0026#34;: true\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt works. I can finally live the dad dream of flashing the lights on and off when my sports team scores.\u003c/p\u003e\u003cp\u003eBut this API? It sucks. If the network call fails, I won’t know what state the lights end up in. I might inadvertently leave the lights off and deprive my neighbours of holiday cheer.\u003c/p\u003e\u003ch3 id=\"mitigation-1-check-the-network-first\"\u003eMitigation 1: Check The Network First\u003c/h3\u003e\u003cp\u003eOne tempting mitigation is to check my phone’s connectivity before calling the toggle API. Perhaps I’ll use Android’s \u003ca href=\"https://developer.android.com/reference/android/net/ConnectivityManager\"\u003e\u003ccode\u003eConnectivityManager\u003c/code\u003e\u003c/a\u003e to only toggle the lights once I’ve confirmed that the device is connected to the Internet.\u003c/p\u003e\u003cp\u003eBut what does it mean to be \u003cem\u003econnected to the Internet\u003c/em\u003e ? Not very much! On Android phones it probably means that a recent request to \u003ccode\u003ehttps://google.com/\u003c/code\u003e resulted in a successful response.\u003c/p\u003e\u003cul\u003e\u003cli\u003eIt doesn’t mean that a new request to \u003ccode\u003ehttps://google.com/\u003c/code\u003e will succeed. I could have since stepped into a radio-blocking elevator and failed the request at the client.\u003c/li\u003e\u003cli\u003eIt doesn’t mean that a new request will reach the server. Each network call involves a sequence of fallible ISPs, DNS servers, gateways, and routers. If any of these are offline or overloaded the call fails on the network.\u003c/li\u003e\u003cli\u003eIt doesn’t mean that the server will successfully toggle the lights. My server code might have a bug that toggles the smart locks instead! Or perhaps it’s busy transcoding \u003ca href=\"https://www.bluey.tv/\"\u003eBluey\u003c/a\u003e and will time out before anything is returned.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eEven a live TCP connection to a server is precarious: the client, network, and server can all fail without warning. Any strategy that checks connectivity first is fragile.\u003c/p\u003e\u003ch3 id=\"mitigation-2-idempotence-token\"\u003eMitigation 2: Idempotence Token\u003c/h3\u003e\u003cp\u003eFrom our vantage point on the client, we can’t differentiate between:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe toggle request didn’t reach the server\u003c/li\u003e\u003cli\u003eThe server’s response didn’t reach the client\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBut if the server can discard duplicate calls, the client can retry until it receives a positive response.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ePOST /lights/toggle HTTP/1.1\n\n{\n  \u0026#34;request_id\u0026#34;: \u0026#34;a7240db9800efaa68251f797094a208d\u0026#34;,\n  \u0026#34;subjects\u0026#34;: [\u0026#34;maple_tree\u0026#34;, \u0026#34;roof\u0026#34;]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis strategy is excellent and I recommend it everywhere. Here’s the recipe I follow:\u003c/p\u003e\u003col\u003e\u003cli\u003eThe client generates a universally-unique ID, such as \u003ccode\u003eUUID.randomUUID()\u003c/code\u003e.\u003c/li\u003e\u003cli\u003eThe client includes that ID in every attempt. (If the request is stored in an on-device queue, the generated ID should be stored with it!)\u003c/li\u003e\u003cli\u003eThe server maintains a unique index of request IDs. Keeping these forever is easy and good enough for most applications.\u003c/li\u003e\u003cli\u003eThe server only performs the operation the first time it sees its request ID.\u003c/li\u003e\u003cli\u003eThe server returns the original response if a repeated request ID is received.\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"mitigation-3-idempotent-endpoint\"\u003eMitigation 3: Idempotent Endpoint\u003c/h3\u003e\u003cp\u003eWe don’t need an idempotence \u003cem\u003etoken\u003c/em\u003e if we can make an idempotent API. \u003cem\u003e‘Turn on the lights’\u003c/em\u003e is idempotent: doing it 5 times is the same as doing it once.\u003c/p\u003e\u003cp\u003eWe can make our API idempotent:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ePOST /lights/set HTTP/1.1\n\n{\n  \u0026#34;on\u0026#34;: true,\n  \u0026#34;subjects\u0026#34;: [\u0026#34;maple_tree\u0026#34;, \u0026#34;roof\u0026#34;]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVersion numbers offer another way to make other APIs idempotent:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ePOST /lights/toggle HTTP/1.1\n\n{\n  \u0026#34;require_version\u0026#34;: 99,\n  \u0026#34;subjects\u0026#34;: [\u0026#34;maple_tree\u0026#34;, \u0026#34;roof\u0026#34;]\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eHTTP/1.1 200 OK\n\n{\n  \u0026#34;toggled\u0026#34;: true,\n  \u0026#34;result_version\u0026#34;: 100\n}\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"okhttp-does-retries\"\u003eOkHttp Does Retries\u003c/h3\u003e\u003cp\u003eThis topic is dear to me \u0026#39;cause OkHttp automatically retries when a pooled TCP connection cannot be reused. This is scary behaviour! I don’t want anybody to accidentally buy two Christmas trees ’cause an HTTP request was repeated.\u003c/p\u003e\u003cp\u003eBe idempotent\u003cbr/\u003eSkip connectivity checks\u003cbr/\u003eJust one Christmas Tree\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2023-11-20T02:32:08Z",
  "modifiedTime": "2023-11-20T02:43:00Z"
}
