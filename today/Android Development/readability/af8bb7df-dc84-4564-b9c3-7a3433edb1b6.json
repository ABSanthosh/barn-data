{
  "id": "af8bb7df-dc84-4564-b9c3-7a3433edb1b6",
  "title": "Android Parcelable: There's a better way",
  "link": "https://chrynan.codes/android-parcelable-theres-a-better-way/",
  "description": "Introducing a new library that uses Kotlinx Serialization to parcellize objects on Android.",
  "author": "Christopher Keenan",
  "published": "Mon, 18 Jan 2021 07:08:17 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "parcelable",
    "android",
    "kotlin",
    "kotlin-library",
    "android-library",
    "kotlinx-serialization",
    "serialization",
    "parcel",
    "parceling",
    "parceler",
    "library"
  ],
  "byline": "Christopher Keenan",
  "length": 7944,
  "excerpt": "Introducing a new library that uses Kotlinx Serialization to parcellize objects on Android.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "TL;DRIntroducing the new parcelable library which enables using kotlinx.serialization to serialize data into Android Parcels to be passed between different Android Components.Android ParcelableAndroid's Parcelable is an object whose values can be written and read from a Parcel. An Android Parcel is a container of values that can be sent between different Android components, such as Activities and Fragments. So implementing the Parcelable interface allows an object to be passed between the different Android components. The process of implementing the Parcelable interface has always been tedious, verbose, and error prone. It requires implementing the interface functions describeContents and writeToParcel, as well as, creating a static field called CREATOR that implements the Parcelable.Creator interface. This Parcelable.Creator interface has two functions that need to be implemented: createFromParcel and newArray. And to make everything more complex, the order of operations matter; the contents of the class must be read in the same order they were written. Here's an example taken from the Parcelable documentation and converted to Kotlin:class MyDataClass : Parcelable { private val mData: Int constructor(mData: Int) { this.mData = mData } private constructor(parcel: Parcel) { this.mData = parcel.readInt() } override fun describeContents(): Int = 0 override fun writeToParcel(out: Parcel, flags: Int) { out.writeInt(mData) } companion object { val CREATOR: Parcelable.Creator\u003cMyParcelable\u003e = object : Parcelable.Creator\u003cMyParcelable\u003e { override fun createFromParcel(parcel: Parcel): MyParcelable = MyParcelable(parcel) override fun newArray(size: Int): Array\u003cMyParcelable?\u003e = arrayOfNulls(size) } } } As you can see this requires a lot of code just to be able to pass a single object to a different Activity or component. There must be an easier way to \"parcel\" or \"serialize\" our objects...Java SerializableThe Java Serializable interface is available on Android and provides a different means of serializing an object so that it can be passed between different components. This approach is much simpler than implementing Parcelable because all that is necessary is to implement the Serializable interface:class MyDataClass(val mData: Int): Serializable It's obvious this is much simpler than the Parcelable approach, but it comes at a cost. As detailed in this StackOverflow answer, the Serializable uses reflection to handle the serializing of the object and thus is much slower. On Android, where we are generally constrained on processing ability compared to computers, performance is of the upmost importance. So sacrificing performance for readability in this case may not be the best approach. Then let's take a look at another way to parcel objects on Android.Kotlin Android ExtensionsThe Kotlin Android Extensions Gradle Plugin provides a way to parcel objects on Android using a @Parcelize annotation. This Plugin (which has since been moved to it's own Plugin: kotlin-parcelize), greatly reduces the amount of code needed to be written in order to parcel an object by generating the parceling code for you. Simply annotate your model class with the @Parcelize annotation and implement the Parcelable interface, and you're all set!@Parcelize class MyDataClass(val mData: Int): Parcelable This is an extremely simply approach and still uses the Parcelable interface so it is much more performant at runtime than the Java Serializable approach. The @Parcelize annotation works for most usecases but what if we have a more complex object that requires specific serialization? In those scenarios, there is the Parceler interface that allows you to manually serialize your object in an easier way than completely implementing the Parcelable interface:object MyDataClassParceler : Parceler\u003cMyDataClass\u003e { override fun create(parcel: Parcel) = MyDataClass(parcel.readInt()) override fun MyDataClass.write(parcel: Parcel, flags: Int) { parcel.writeInt(mData) } } This approach allows us to simply parcel our objects and has the flexibility to handle more complex use cases. However, with the rise of popularity of Kotlin Multi-platform, model classes are typically created in common code, separating them from Android specific components, such as the @Parcelize annotation. This would require us to create Parcelers in the Android module for every class we wish to parcel from the common module, defeating the purpose of using the plugin in the first place.moko-parcelizeThere's a library by IceRock Development called moko-parcelize that brings the @Parcelize functionality to Kotlin Multi-platform. So now we can parcel our model classes in a common module just as we did before with the Android class:@Parcelize class MyDataClass(val mData: Int): Parcelable The lingering issue with the @Parcelize approach is that for complex classes we still have to manually write Parcelers, which serialize our models to a Parcel. This helps serialize the models for use with Android components but it doesn't help serialize our models for other scenarios, such as formatting the model to JSON.kotlinx.serializationThe kotlinx.serialization library provides a way to serialize/deserialize between Kotlin models and other formats. The library supports JSON, Protobuf, CBOR, Hocon, and Properties. And there are third party libraries that add extra formats, like the xmlutil library that adds XML support to Kotlinx Serialization.Typically in a project, you would use kotlinx.serialization to handle serializing your Kotlin models to and from JSON for HTTP requests. For complex models you can create a custom KSerializer. The problem here is that for complex models, we would have to create a custom KSerializer and a custom Parceler just to be able to serialize our models throughout the application. This redundancy is verbose, tedious, and error prone. So this lead me to an idea: what if there were custom Encoders and Decoders for the kotlinx.serialization library that handled parceling our models? This would remove the redundancy of multiple custom serializers.chRyNaN/parcelableI created the parcelable library as a companion to the kotlinx.serialization library. It provides custom Encoders and Decoders that handle writing and reading from an Android Parcel. This means that @Serialiable classes just work with Android components and any custom KSerializers work as well. Using the library is very straightforward:Create your @Serializable model (and any necessary KSerializers) using the kotlinx.serialization library:@Serializable data class MyDataClass( mData: Int ) Create a Parcelable object or use the default:val parcelable = Parcelable { serializersModule = mySerializersModule } // Or val parcelable = Parcelable.Default Then pass your model through Intents and Bundles just as you normally would but provide the parcelable instance as an extra parameter:// Put intent.putExtra(key, myModel, parcelable) bundle.putParcelable(key, myModel, parcelable) // Get val myModel = intent.getParcelableExtra(key, parcelable) val myModel = bundle.getParcelable(key, parcelable) And that's all there is to it! If you need custom serialization, you would create a custom KSerializer for the kotlinx.serialization library, and as long as you don't use a specific encoder/decoder, it should work with Android's Parcel. No duplicating serializing logic, no Android specific components, and no extra annotation processors.ConclusionThere are numerous approaches to parceling data to pass between different Android Components. The simplest of these approaches is to use the kotlinx.serialization library alongside the new parcelable companion library. Together these libraries enable your models to be serialized from JSON HTTP Responses, to Parcels between Android Components.",
  "image": "https://images.unsplash.com/photo-1505128761803-50d3fc78a565?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=MXwxMTc3M3wwfDF8c2VhcmNofDl8fHBhcmNlbHxlbnwwfHx8\u0026ixlib=rb-1.2.1\u0026q=80\u0026w=2000",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eIntroducing the new \u003ca href=\"https://github.com/chRyNaN/parcelable?ref=chrynan.codes\"\u003eparcelable library\u003c/a\u003e which enables using \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization?ref=chrynan.codes\"\u003ekotlinx.serialization\u003c/a\u003e to serialize data into Android \u003ccode\u003eParcels\u003c/code\u003e to be passed between different Android Components.\u003c/p\u003e\u003ch3 id=\"android-parcelable\"\u003eAndroid Parcelable\u003c/h3\u003e\u003cp\u003eAndroid\u0026#39;s \u003ca href=\"https://developer.android.com/reference/android/os/Parcelable?ref=chrynan.codes\"\u003eParcelable\u003c/a\u003e is an object whose values can be written and read from a \u003ca href=\"https://developer.android.com/reference/android/os/Parcel?ref=chrynan.codes\"\u003eParcel\u003c/a\u003e. An Android \u003ca href=\"https://developer.android.com/reference/android/os/Parcel?ref=chrynan.codes\"\u003eParcel\u003c/a\u003e is a container of values that can be sent between different Android components, such as Activities and Fragments. So implementing the Parcelable interface allows an object to be passed between the different Android components. \u003c/p\u003e\u003cp\u003eThe process of implementing the Parcelable interface has always been tedious, verbose, and error prone. It requires implementing the interface functions \u003ccode\u003edescribeContents\u003c/code\u003e and \u003ccode\u003ewriteToParcel\u003c/code\u003e, as well as, creating a static field called \u003ccode\u003eCREATOR\u003c/code\u003e that implements the \u003ccode\u003eParcelable.Creator\u003c/code\u003e interface. This \u003ccode\u003eParcelable.Creator\u003c/code\u003e interface has two functions that need to be implemented: \u003ccode\u003ecreateFromParcel\u003c/code\u003e and \u003ccode\u003enewArray\u003c/code\u003e. And to make everything more complex, the order of operations matter; the contents of the class must be read in the same order they were written. Here\u0026#39;s an example taken from the \u003ca href=\"https://developer.android.com/reference/android/os/Parcelable?ref=chrynan.codes\"\u003eParcelable\u003c/a\u003e documentation and converted to Kotlin:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MyDataClass : Parcelable {\n\n    private val mData: Int\n\n    constructor(mData: Int) {\n        this.mData = mData\n    }\n\n    private constructor(parcel: Parcel) {\n        this.mData = parcel.readInt()\n    }\n\n    override fun describeContents(): Int = 0\n\n    override fun writeToParcel(out: Parcel, flags: Int) {\n        out.writeInt(mData)\n    }\n\n    companion object {\n\n        val CREATOR: Parcelable.Creator\u0026lt;MyParcelable\u0026gt; = object : Parcelable.Creator\u0026lt;MyParcelable\u0026gt; {\n\n            override fun createFromParcel(parcel: Parcel): MyParcelable = MyParcelable(parcel)\n\n            override fun newArray(size: Int): Array\u0026lt;MyParcelable?\u0026gt; = arrayOfNulls(size)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see this requires a lot of code just to be able to pass a single object to a different Activity or component. There must be an easier way to \u0026#34;parcel\u0026#34; or \u0026#34;serialize\u0026#34; our objects...\u003c/p\u003e\u003ch3 id=\"java-serializable\"\u003eJava Serializable\u003c/h3\u003e\u003cp\u003eThe Java \u003ca href=\"https://developer.android.com/reference/java/io/Serializable?ref=chrynan.codes\"\u003eSerializable\u003c/a\u003e interface is available on Android and provides a different means of serializing an object so that it can be passed between different components. This approach is much simpler than implementing \u003ccode\u003eParcelable\u003c/code\u003e because all that is necessary is to implement the \u003ccode\u003eSerializable\u003c/code\u003e interface:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MyDataClass(val mData: Int): Serializable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt\u0026#39;s obvious this is much simpler than the \u003ccode\u003eParcelable\u003c/code\u003e approach, but it comes at a cost. As detailed in \u003ca href=\"https://stackoverflow.com/a/23647471/1478764?ref=chrynan.codes\"\u003ethis StackOverflow answer\u003c/a\u003e, the \u003ccode\u003eSerializable\u003c/code\u003e uses reflection to handle the serializing of the object and thus is much slower. On Android, where we are generally constrained on processing ability compared to computers, performance is of the upmost importance. So sacrificing performance for readability in this case may not be the best approach. Then let\u0026#39;s take a look at another way to parcel objects on Android.\u003c/p\u003e\u003ch3 id=\"kotlin-android-extensions\"\u003eKotlin Android Extensions\u003c/h3\u003e\u003cp\u003eThe \u003ca href=\"https://plugins.gradle.org/plugin/org.jetbrains.kotlin.android.extensions?ref=chrynan.codes\"\u003eKotlin Android Extensions Gradle Plugin\u003c/a\u003e provides a way to parcel objects on Android using a \u003ccode\u003e@Parcelize\u003c/code\u003e annotation. This Plugin (which has since been moved to it\u0026#39;s own Plugin: \u003ca href=\"https://developer.android.com/kotlin/parcelize?ref=chrynan.codes\"\u003ekotlin-parcelize\u003c/a\u003e), greatly reduces the amount of code needed to be written in order to parcel an object by generating the parceling code for you. Simply annotate your model class with the \u003ccode\u003e@Parcelize\u003c/code\u003e annotation and implement the \u003ccode\u003eParcelable\u003c/code\u003e interface, and you\u0026#39;re all set!\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Parcelize\nclass MyDataClass(val mData: Int): Parcelable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is an extremely simply approach and still uses the \u003ccode\u003eParcelable\u003c/code\u003e interface so it is much more performant at runtime than the Java \u003ccode\u003eSerializable\u003c/code\u003e approach. The \u003ccode\u003e@Parcelize\u003c/code\u003e annotation works for most usecases but what if we have a more complex object that requires specific serialization? In those scenarios, there is the \u003ca href=\"https://developer.android.com/kotlin/parcelize?ref=chrynan.codes#custom_parcelers\"\u003e\u003ccode\u003eParceler\u003c/code\u003e interface\u003c/a\u003e that allows you to manually serialize your object in an easier way than completely implementing the \u003ccode\u003eParcelable\u003c/code\u003e interface:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eobject MyDataClassParceler : Parceler\u0026lt;MyDataClass\u0026gt; {\n\n    override fun create(parcel: Parcel) = MyDataClass(parcel.readInt())\n\n    override fun MyDataClass.write(parcel: Parcel, flags: Int) {\n        parcel.writeInt(mData)\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis approach allows us to simply parcel our objects and has the flexibility to handle more complex use cases. However, with the rise of popularity of Kotlin Multi-platform, model classes are typically created in common code, separating them from Android specific components, such as the \u003ccode\u003e@Parcelize\u003c/code\u003e annotation. This would require us to create \u003ccode\u003eParcelers\u003c/code\u003e in the Android module for every class we wish to parcel from the common module, defeating the purpose of using the plugin in the first place.\u003c/p\u003e\u003ch3 id=\"moko-parcelize\"\u003emoko-parcelize\u003c/h3\u003e\u003cp\u003eThere\u0026#39;s a library by \u003ca href=\"https://github.com/icerockdev?ref=chrynan.codes\"\u003eIceRock Development\u003c/a\u003e called \u003ca href=\"https://github.com/icerockdev/moko-parcelize?ref=chrynan.codes\"\u003emoko-parcelize\u003c/a\u003e that brings the \u003ccode\u003e@Parcelize\u003c/code\u003e functionality to Kotlin Multi-platform. So now we can parcel our model classes in a common module just as we did before with the Android class:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Parcelize\nclass MyDataClass(val mData: Int): Parcelable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe lingering issue with the \u003ccode\u003e@Parcelize\u003c/code\u003e approach is that for complex classes we still have to manually write \u003ccode\u003eParcelers\u003c/code\u003e, which serialize our models to a \u003ccode\u003eParcel\u003c/code\u003e. This helps serialize the models for use with Android components but it doesn\u0026#39;t help serialize our models for other scenarios, such as formatting the model to JSON.\u003c/p\u003e\u003ch3 id=\"kotlinx-serialization\"\u003ekotlinx.serialization\u003c/h3\u003e\u003cp\u003eThe \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization?ref=chrynan.codes\"\u003ekotlinx.serialization\u003c/a\u003e library provides a way to serialize/deserialize between Kotlin models and other formats. The library supports JSON, Protobuf, CBOR, Hocon, and Properties. And there are third party libraries that add extra formats, like the \u003ca href=\"https://github.com/pdvrieze/xmlutil?ref=chrynan.codes\"\u003exmlutil\u003c/a\u003e library that adds XML support to Kotlinx Serialization.\u003c/p\u003e\u003cp\u003eTypically in a project, you would use kotlinx.serialization to handle serializing your Kotlin models to and from JSON for HTTP requests. For complex models you can create a custom \u003ccode\u003eKSerializer\u003c/code\u003e. The problem here is that for complex models, we would have to create a custom \u003ccode\u003eKSerializer\u003c/code\u003e and a custom \u003ccode\u003eParceler\u003c/code\u003e just to be able to serialize our models throughout the application. This redundancy is verbose, tedious, and error prone. So this lead me to an idea: what if there were custom Encoders and Decoders for the kotlinx.serialization library that handled parceling our models? This would remove the redundancy of multiple custom serializers.\u003c/p\u003e\u003ch3 id=\"chrynan-parcelable\"\u003echRyNaN/parcelable\u003c/h3\u003e\u003cp\u003eI created the \u003ca href=\"https://github.com/chRyNaN/parcelable?ref=chrynan.codes\"\u003eparcelable\u003c/a\u003e library as a companion to the kotlinx.serialization library. It provides custom \u003ccode\u003eEncoders\u003c/code\u003e and \u003ccode\u003eDecoders\u003c/code\u003e that handle writing and reading from an Android \u003ccode\u003eParcel\u003c/code\u003e. This means that \u003ccode\u003e@Serialiable\u003c/code\u003e classes just work with Android components and any custom \u003ccode\u003eKSerializers\u003c/code\u003e work as well. \u003c/p\u003e\u003cp\u003eUsing the library is very straightforward:\u003c/p\u003e\u003cul\u003e\u003cli\u003eCreate your \u003ccode\u003e@Serializable\u003c/code\u003e model (and any necessary \u003ccode\u003eKSerializers\u003c/code\u003e) using the kotlinx.serialization library:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e@Serializable\ndata class MyDataClass(\n    mData: Int\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eCreate a \u003ccode\u003eParcelable\u003c/code\u003e object or use the default:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eval parcelable = Parcelable {\n    serializersModule = mySerializersModule\n}\n\n// Or\n\nval parcelable = Parcelable.Default\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eThen pass your model through \u003ccode\u003eIntents\u003c/code\u003e and \u003ccode\u003eBundles\u003c/code\u003e just as you normally would but provide the \u003ccode\u003eparcelable\u003c/code\u003e instance as an extra parameter:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// Put\nintent.putExtra(key, myModel, parcelable)\nbundle.putParcelable(key, myModel, parcelable)\n\n// Get\nval myModel = intent.getParcelableExtra(key, parcelable)\nval myModel = bundle.getParcelable(key, parcelable)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd that\u0026#39;s all there is to it! If you need custom serialization, you would create a custom \u003ccode\u003eKSerializer\u003c/code\u003e for the kotlinx.serialization library, and as long as you don\u0026#39;t use a specific encoder/decoder, it should work with Android\u0026#39;s \u003ccode\u003eParcel\u003c/code\u003e. No duplicating serializing logic, no Android specific components, and no extra annotation processors.\u003c/p\u003e\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\u003cp\u003eThere are numerous approaches to parceling data to pass between different Android Components. The simplest of these approaches is to use the kotlinx.serialization library alongside the new \u003ca href=\"https://github.com/chRyNaN/parcelable?ref=chrynan.codes\"\u003eparcelable\u003c/a\u003e companion library. Together these libraries enable your models to be serialized from JSON HTTP Responses, to Parcels between Android Components.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2021-01-18T07:08:17Z",
  "modifiedTime": "2021-01-18T07:19:45Z"
}
