{
  "id": "a401ed33-e6d1-430b-913c-9541ed54a867",
  "title": "Insets handling tips for Android 15’s edge-to-edge enforcement",
  "link": "https://medium.com/androiddevelopers/insets-handling-tips-for-android-15s-edge-to-edge-enforcement-872774e8839b?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Ash Nohe",
  "published": "Tue, 03 Sep 2024 18:12:32 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "android-15",
    "display-cutouts",
    "edge-to-edge",
    "windowinsets",
    "system-bars"
  ],
  "byline": "Ash Nohe",
  "length": 23382,
  "excerpt": "This blog post is part of our series: Spotlight Week on Android 15, where we provide resources — blog posts, videos, sample code, and more — all designed to help you prepare your apps and take…",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Users prefer edge-to-edge over non edge-to-edge screens for both gesture navigation and three button navigation, according to an internal Google user study.Android 15 enforces edge-to-edgeBefore target SDK 35 (Android 15), your app does not draw edge-to-edge without explicit code changes to intentionally go edge-to-edge. After setting targetSdk=35 or higher, the system will draw your app edge-to-edge by default on Android 15 and later devices. While this change can make it easier for many apps to go edge-to-edge, critical UI elements may also be inaccessible to users. Your app must handle insets to ensure critical UI elements remain accessible.Figure 2. App targeting SDK 34 on an Android 15 device. The app is not edge-to-edge.Figure 3. App targeting SDK 35 on an Android 15 device. The app is edge-to-edge but insets are not handled. The status bar, navigation bar, and the display cutout obscure UI.Figure 4. App targeting SDK 35 on an Android 15 device. The app is edge-to-edge and insets are handled so that critical UI isn’t obscured.If your app is already edge-to-edge or in immersive mode, you’re unaffected. However, it’s still worth testing your app for breakages.Insets handling tipsThere are various APIs and attributes you can use to handle insets to avoid the System UI and display cutout.This article explains the following tips that are applicable to Compose and Views:Use material components to make handling insets easierDraw backgrounds edge-to-edge, and inset critical UIHandle display cutout and caption bar insetsDon’t forget the last list itemDon’t forget IMEsFor backwards compatibility, use enableEdgeToEdge instead of setDecorFitsSystemWindowsBackground protect system bars only when necessaryIt also provides these tips that are specific to Compose:8. Use Scaffold’s PaddingValues9. Use high level WindowInset APIsFinally, it includes these tips specific to Views:10. Prefer ViewCompat.setOnApplyWindowInsetsListener over fitsSystemWindows=true11. Apply insets based on app bar height on bar layout1. Use material components to make handling insets easierMany material components automatically handle insets, meaning the component’s background draws inside the system bar region and pads critical UI (see tip #2). Some material components do not automatically handle insets, but instead provide methods to make handling insets easier.Material 3 Components (androidx.compose.material3) that automatically handle insets:BottomAppBarCenterAlignedTopAppBarDismissibleDrawerSheetLargeTopAppBarMediumTopAppBarModalBottomSheetModalDrawerSheetNavigationBarNavigationRailNavigationSuiteScaffoldPermanentDrawerSheetTopAppBarSmallTopAppBarMaterial 2 Components (androidx.compose.material) don’t automatically handle insets themselves by default, unlike Material 3 components. Consider updating to Material 3 Components. Otherwise, many Material 2 components support specifying the window insets to apply with the windowInsets parameter, like the BottomAppBar, TopAppBar, BottomNavigation, and NavigationRail. Likewise, use the contentWindowInsets parameter for Scaffold. Otherwise, apply the insets as padding.Material View Components (com.google.android.material) that automatically handle insets:BottomAppBarBottomNavigationViewNavigationRailViewNavigationView2. Draw backgrounds edge-to-edge, and inset critical UI.Oftentimes, apps will set the system bars to the same color as the app bars to appear edge-to-edge, which is an anti-pattern.Figure 5. App targeting SDK 34 on an Android 15 device. The app has set the status bar and navigation bar colors, which is no longer supported after targeting SDK 35. The status and navigation bar color are intentionally set to a slightly different shade so you can distinguish the system bars from the app bars, but usually apps will use the same colors for the system and app bars to appear edge-to-edge.Apps using this anti-pattern do not appear edge-to-edge all the time, especially on large screen devices.To improve this app’s UX after edge-to-edge is enforced, extend the background of the app bars so they draw underneath the transparent system bars, then inset the text and buttons to avoid the system bars. Material 3 components TopAppBars and BottomAppBars do this automatically. For Material 2 components, use the windowInsets parameter. For Views, some Material components handle this automatically. Otherwise, you’ll use fitsSystemWindows or ViewCompat.setOnApplyWindowInsetsListener.Figure 6. Edge-to-edge enforced. Left: Insets not handled. Right: Insets handled. App bars draw under transparent system bars and text and icons avoid the system bars.3. Handle display cutout and caption bar insetsWhile handling insets, account for the display cutouts and caption bars in addition to the status and navigation bars.Display cutoutsA display cutout often contains the camera. After targeting SDK 35, your app might have important UI under the display cutout, especially when the cutout is on the left or right edges of the device.For example, prior to targeting SDK 35, your app might have a large white box to account for a camera cutout in landscape.Figure 7. App targeting SDK 34 on an Android 15 device.After targeting SDK 35, the white box disappears and all content moves to the left. Some content draws underneath the camera cutout.Figure 8. App targeting SDK 35 on an Android 15 device. The camera hides Sheep’s photo.Handling display cutouts in ComposeIn Compose, easily handle display cutouts using WindowInsets.safeContent, WindowInsets.safeDrawing, or WindowInsets.safeGestures. Or, use WindowInsets.displayCutout for fine-grained control. Unfortunately, at the time of writing this blog, Scaffold’s PaddingValues does not yet account for the display cutout.// Shows using WindowInsets.displayCutout for fine-grained control.// But, it's often sufficient and easier to instead use// WindowInsets.safeContent, WindowInsets.safeDrawing, or WindowInsets.safeGestures@Composablefun ChatRow(...) { val layoutDirection = LocalLayoutDirection.current val displayCutout = WindowInsets.displayCutout.asPaddingValues() val startPadding = displayCutout.calculateStartPadding(layoutDirection) val endPadding = displayCutout.calculateEndPadding(layoutDirection) Row( modifier = modifier.padding( PaddingValues( top = 16.dp, bottom = 16.dp, // Ensure content is not hidden by display cutouts // when rotating the device. start = startPadding.coerceAtLeast(16.dp), end = endPadding.coerceAtLeast(16.dp) ) ), ... ) { ... }After handling display cutouts, the app looks like this:Figure 9. App targeting SDK 35 on an Android 15 device. Display cutout insets handled. Note: ideally “Chats” should also be padded to the right.You can test various display cutout configurations on the Developer options screen under Display cutout.Learn more about this example in the codelab, Handle edge-to-edge enforcements in Android 15.Handling display cutouts in ViewsIn Views, handle display cutouts using WindowInsetsCompat.Type.displayCutout. See the documentation for a code sample.Note: If your app has a non-floating window (for example, an Activity) that is using LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT, LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER or LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES, Android will interpret these cutout modes to be LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS starting in Android 15, causing your window to draw into the display cutout region. Ensure to test your screens that use DEFAULT, NEVER, or SHORT_EDGES.Caption barsWhen your app appears in a desktop emulator or in a free form window, it has a caption bar instead of a status bar.Figure 10. The caption bar in a desktop emulator.While handling insets in Compose, use either Scaffold’s PaddingValues, WindowInsets.safeContent, WindowInsets.safeDrawing, or WindowInsets.systemBars, which all include the caption bar. Don’t use WindowInsets.statusBars.In your app’s View-based layouts, use WindowInsetsCompat.Type.systemBars. Don’t use WindowInsetsCompat.Type.statusBars.4. Don’t forget the last list itemAfter targeting SDK 35, the last item of your lists might be inaccessible, especially if it’s behind three-button navigation or the taskbar.Handling the last list item in ComposeTo handle the last list item in Compose, use LazyColumn’s contentPadding to add a space to the last item unless you are using TextField:Scaffold { innerPadding -\u003e LazyColumn( contentPadding = innerPadding ) { // Content that does not contain TextField }}For TextField, use a Spacer to draw the last TextField in a LazyColumn. For an in-depth overview of handling insets with lists, see Inset consumption.LazyColumn( Modifier.imePadding()) { // Content with TextField item { Spacer( Modifier.windowInsetsBottomHeight( WindowInsets.systemBars ) ) }}Handling the last list item in ViewsAdding clipToPadding=”false” can ensure the last list item appears above the navigation bar for RecyclerView or NestedScrollView. Take this app for example. After targeting SDK 35, the app’s list UI shows the last list item underneath the navigation bar.We can use the window inset listener so that all list items, including the last list item, are padded above the navigation bar.Figure 12. App has handled insets, but feels less immersive because content does not scroll behind system bars.// Figure 12ViewCompat.setOnApplyWindowInsetsListener( findViewById(R.id.recycler_view)) { v, insets -\u003e val innerPadding = insets.getInsets( // Notice we're using systemBars, not statusBar WindowInsetsCompat.Type.systemBars() // Notice we're also accounting for the display cutouts or WindowInsetsCompat.Type.displayCutout() // If using EditText, also add // \"or WindowInsetsCompat.Type.ime()\" // to maintain focus when opening the IME ) v.setPadding( innerPadding.left, innerPadding.top, innerPadding.right, innerPadding.bottom) insets}However, now the app looks less immersive. To get the result we want, add clipToPadding=false to ensure the last list item sits above the navigation bar and the list is visible while scrolling behind the navigation bar (and status bar).Figure 13. App displays edge-to-edge and the last list item is fully visible. This is the result we want.\u003c!-- Figure 13 --\u003e\u003cRecyclerView ... android:clipToPadding=\"false\" /\u003e5. Don’t forget IMEsSet android:windowSoftInputMode=”adjustResize” in your Activity’s AndroidManifest.xml entry to make room for the IME (or soft keyboard) on screen.Handling IMEs insets in ComposeAccount for the IME using Modifier.imePadding(). For example, this can help maintain focus on a TextField in a LazyColumn when the IME opens. See the Inset consumption section for a code example and explanation.Handling IMEs insets in ViewsBefore targeting SDK 35, using android:windowSoftInputMode=”adjustResize” was all you needed to maintain focus on — for example — an EditText in a RecyclerView when opening an IME. With “adjustResize”, the framework treated the IME as the system window, and the window’s root views were padded so content avoids the system window.After targeting SDK 35, you must also account for the IME using ViewCompat.setOnApplyWindowInsetsListener and WindowInsetsCompat.Type.ime() because the framework will not pad the window’s root views. See Figure 12's code example.6. For backward compatibility, use enableEdgeToEdge instead of setDecorFitsSystemWindowsAfter your app has handled insets, make your app edge-to-edge on previous Android versions. For this, use enableEdgeToEdge instead of setDecorFitsSystemWindows. The enableEdgeToEdge method encapsulates the about 100 lines of code you need to be truly backward compatible.7. Background protect system bars only when necessaryIn many cases, keep the new Android 15 defaults. The status bar and gesture navigation bar should be transparent, and three button navigation translucent after targeting SDK 35 (see Figure 1).However, there are some cases where you wish to preserve the background color of the system bars, but the APIs to set the status and navigation bar colors are deprecated. We are planning to release an AndroidX library to support this use case. In the meantime, if your app must offer custom background protection to 3-button navigation or the status bar, you can place a composable or view behind the system bar using WindowInsets.Type#tappableElement() to get the 3-button navigation bar height or WindowInsets.Type#statusBars.For example, to show the color of the element behind the 3-button navigation in Compose, set the window.isNavigationBarContrastEnforced property to false. Setting this property to false makes 3-button navigation fully transparent (note: this property does not affect gesture navigation).Then, use WindowInsets.tappableElement to align UI behind insets for tappable system UI. If non-0, the user is using tappable bars, like three button navigation. In this case, draw an opaque view or box behind the tappable bars.class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContent { window.isNavigationBarContrastEnforced = false MyTheme { Surface(...) { MyContent(...) ProtectNavigationBar() } } } }}// Use only if required.@Composablefun ProtectNavigationBar(modifier: Modifier = Modifier) { val density = LocalDensity.current val tappableElement = WindowInsets.tappableElement val bottomPixels = tappableElement.getBottom(density) val usingTappableBars = remember(bottomPixels) { bottomPixels != 0 } val barHeight = remember(bottomPixels) { tappableElement.asPaddingValues(density).calculateBottomPadding() } Column( modifier = modifier.fillMaxSize(), verticalArrangement = Arrangement.Bottom ) { if (usingTappableBars) { Box( modifier = Modifier .background(MaterialTheme.colorScheme.background) .fillMaxWidth() .height(barHeight) ) } }}Inset handling tips for UIs that use ComposeThe following tips apply only for apps that use Jetpack Compose. See additional Compose-related tips in this video: Edge-to-edge and insets | Compose Tips.8. Use Scaffold’s PaddingValuesFor Compose, use Scaffold instead of Surface to organize your app’s UI with TopAppBar, BottomAppBar, NavigationBar, and NavigationRail. Use Scaffold’s PaddingValues parameter to inset your critical UI. In most cases, that’s all you need to do.However, there are cases where applying Scaffold’s PaddingValues will cause unexpected results. Scaffold’s PaddingValues includes insets for the top, bottom, start and end edges of the screen. You may need values for only certain edges. One approach is to make a copy of the parameter and manually adjust top, bottom, start and end insets so as to not apply too much padding.Figure 14. Left: The input field at the bottom is obscured by the system’s navigation bar after targeting SDK 35. Middle: Scaffold’s PaddingValues applied to the input field. The system uses the size of the status bar and the top app bar to calculate the top padding value, which creates excess padding above the input field. Right: Scaffold’s PaddingValues applied but with top padding manually removed.Here’s the incorrect code, causing the excess padding seen in the middle image of Figure 14.// Causes excess padding, seen in the middle image of Figure 14.Scaffold { innerPadding -\u003e // innerPadding is Scaffold's PaddingValues InputBar( ... contentPadding = innerPadding ) {...}}Here’s the corrected code that generates proper padding, as seen in the right-side image of Figure 14.// Function to make a copy of PaddingValues, using existing defaults unless an// alternative value is specified​​private fun PaddingValues.copy( layoutDirection: LayoutDirection, start: Dp? = null, top: Dp? = null, end: Dp? = null, bottom: Dp? = null,) = PaddingValues( start = start ?: calculateStartPadding(layoutDirection), top = top ?: calculateTopPadding(), end = end ?: calculateEndPadding(layoutDirection), bottom = bottom ?: calculateBottomPadding(),)// Produces correct padding, seen in the right-side image of Figure 14.Scaffold { innerPadding -\u003e // innerPadding is Scaffold's PaddingValues val layoutDirection = LocalLayoutDirection.current InputBar( ... contentPadding = innerPadding.copy(layoutDirection, top = 0.dp) ) {...}}9. Use high level WindowInsets APIsSimilar to Scaffold’s PaddingValues, you can also use the high-level WindowInset APIs to easily and safely draw critical UI elements. These are:WindowInsets.safeDrawingWindowInsets.safeGesturesWindowInsets.safeContentSee Inset fundamentals to learn more.Inset handling tips for UIs that use ViewsThe following apply only for Views-based apps.10. Prefer ViewCompat.setOnApplyWindowInsetsListener over fitsSystemWindows=trueYou could use fitsSystemWindows=true to inset your app’s content. It’s an easy 1-line code change. However, don’t use fitsSystemWindows on a View that contains your entire layout (including the background). This will make your app look not edge-to-edge because fitsSystemWindows handles insets on all edges.Figure 15. Edge-to-edge enforced. Left: fitsSystemWindows=false (the default). Right: fitsSystemWindows=true. This is not the result we want because the app does not look edge-to-edge.Figure 16. Edge-to-edge enforced, fitsSystemWindows=true. The gap on the left edge is due to a display cutout, which is not visible here. This is not the result we want because the app doesn’t look edge-to-edge.fitsSystemWindows can create an edge-to-edge experience if using CoordinatorLayouts or AppBarLayouts.Add fitsSystemWindows to the CoordinatorLayout and the AppBarLayout, and the AppBarLayout draws edge-to-edge, which is what we want.Figure 17. Edge-to-edge enforced. Left: AppBarLayout does not automatically handle insets. Right: Add fitsSystemWindows to AppBarLayout and CoordinatorLayout to draw edge-to-edge.\u003c!-- Figure 17 --\u003e\u003cCoordinatorLayout android:fitsSystemWindows=\"true\" ...\u003e \u003cAppBarLayout android:fitsSystemWindows=\"true\" ...\u003e \u003cTextView android:text=\"App Bar Layout\" .../\u003e \u003c/AppBarLayout\u003e\u003c/CoordinatorLayout\u003eIn this case, AppBarLayout used fitsSystemWindows to draw underneath the status bar rather than avoiding it, which is the opposite of what we might expect. Furthermore, AppBarLayout with fitsSystemWindows=true only applies padding for the top and not the bottom, start, or end edges.The CoordinatorLayout and AppBarLayout objects have the following behavior when overriding fitsSystemWindows:CoordinatorLayout: backgrounds of child views draw underneath the system bars if those views also set fitsSystemWindows=true. Padding is automatically applied to the content of those Views (e.g. text, icons, images) to account for system bars and display cutouts.AppBarLayout: draws underneath the system bars if fitsSystemWindows=true and automatically applies top padding to content.In most cases, handle insets with ViewCompat.setOnApplyWindowInsetsListener because it allows you to define which edges should handle insets and has consistent behavior. See tips #4 and #11 for a code example.11. Apply insets based on app bar height during the layout phaseIf you find that your app’s content is hiding underneath an app bar, you might need to apply insets after the app bar is laid out, taking the app bar height into account.For example, if you have scrolling content underneath an AppBarLayout in a FrameLayout, you could use code like this to ensure the scrolling content appears after the AppBarLayout. Notice padding is applied within doOnLayout.val myScrollView = findViewById\u003cNestedScrollView\u003e(R.id.my_scroll_view)val myAppBar = findViewById\u003cAppBarLayout\u003e(R.id.my_app_bar_layout)ViewCompat.setOnApplyWindowInsetsListener(myScrollView) { scrollView, windowInsets -\u003e val insets = windowInsets.getInsets( WindowInsetsCompat.Type.systemBars() or WindowInsetsCompat.Type.displayCutout() ) myAppBar.doOnLayout { appBar -\u003e scrollView.updatePadding( left = insets.left, right = insets.right, top = appBar.height, bottom = insets.bottom ) } WindowInsetsCompat.CONSUMED}Likewise, if you have scrolling content that should sit above a BottomNavigationView, you’ll want to account for the BottomNavigationView’s height once it is laid out.Need more time to migrate?It might take significant work to properly support an edge-to-edge experience. Before you target SDK 35, consider how long you need to make the necessary changes in your app.If you need more time to handle insets to be compatible with the system’s default edge-to-edge behavior, you can temporarily opt-out using R.attr#windowOptOutEdgeToEdgeEnforcement. But do not plan to use this flag indefinitely as it will be non-functional in the near future.The flag might be particularly helpful for apps that have tens to hundreds of Activities. You might opt-out each Activity, then — make your app edge-to-edge one Activity at a time.Here’s one approach to using this flag. Assuming your minSDK is less than 35, this attribute must be in values-v35.xml.\u003c!-- In values-v35.xml --\u003e\u003cresources\u003e \u003c!-- TODO: Remove once activities handle insets. --\u003e \u003cstyle name=\"OptOutEdgeToEdgeEnforcement\"\u003e \u003citem name=\"android:windowOptOutEdgeToEdgeEnforcement\"\u003etrue\u003c/item\u003e \u003c/style\u003e\u003c/resources\u003eCreate an empty style for past versions in values.xml:\u003c!-- In values.xml --\u003e\u003cresources\u003e \u003c!-- TODO: Remove once activities handle insets. --\u003e \u003cstyle name=\"OptOutEdgeToEdgeEnforcement\"\u003e \u003c!-- android:windowOptOutEdgeToEdgeEnforcement isn't supported before SDK 35. This empty style enables programmatically opting-out. --\u003e \u003c/style\u003e\u003c/resources\u003eCall the style before accessing the decor view in setContentView:class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { // Call before the DecorView is accessed in setContentView theme.applyStyle(R.style.OptOutEdgeToEdgeEnforcement, /* force */ false) super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... }}ResourcesAndroid 15 AOSP released today. Our team has created blogs, videos, and codelabs to help get your app ready to handle the Android 15 edge-to-edge enforcement. What follows is a list of old and new resources for further learning.DocumentationBehavior changes for apps targeting Android 15: Edge-to-edge enforcementWindow insets in ComposeCutouts in ComposeDisplay content edge-to-edge in your app (Views)Support display cutouts (Views)VideosEdge to Edge \u0026 Insets (Compose)Insets: Compose edition3 things to improve the user experience of your Android app: Handle edge-to-edge enforcements in Android 15 walkthrough (Compose)CodelabsHandle edge-to-edge enforcements in Android 15 (Compose)",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*cbWmzhcQsly95rHdfYZA1g.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"e261\"\u003eUsers prefer edge-to-edge over non edge-to-edge screens for both gesture navigation and three button navigation, according to an internal Google user study.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b56f\"\u003eAndroid 15 enforces edge-to-edge\u003c/h2\u003e\u003cp id=\"d550\"\u003eBefore target SDK 35 (Android 15), your app does \u003cem\u003enot\u003c/em\u003e draw edge-to-edge without explicit code changes to intentionally go edge-to-edge. After setting \u003ccode\u003etargetSdk=35\u003c/code\u003e or higher, the system will draw \u003ca href=\"https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eyour app edge-to-edge\u003c/a\u003e by default on Android 15 and later devices. While this change can make it easier for many apps to go edge-to-edge, critical UI elements may also be inaccessible to users. Your app must handle insets to ensure critical UI elements remain accessible.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 2. \u003c/strong\u003eApp targeting SDK 34 on an Android 15 device. The app is not edge-to-edge.\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 3. \u003c/strong\u003eApp targeting SDK 35 on an Android 15 device. The app is edge-to-edge but insets are \u003cem\u003enot\u003c/em\u003e handled. The status bar, navigation bar, and the display cutout obscure UI.\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 4. \u003c/strong\u003eApp targeting SDK 35 on an Android 15 device. The app is edge-to-edge and insets are handled so that critical UI isn’t obscured.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9195\"\u003eIf your app is already edge-to-edge or in immersive mode, you’re unaffected. However, it’s still worth testing your app for breakages.\u003c/p\u003e\u003ch2 id=\"f255\"\u003eInsets handling tips\u003c/h2\u003e\u003cp id=\"a7ee\"\u003eThere are various APIs and attributes you can use to handle insets to avoid the System UI and display cutout.\u003c/p\u003e\u003cp id=\"fab9\"\u003eThis article explains the following tips that are applicable to Compose and Views:\u003c/p\u003e\u003col\u003e\u003cli id=\"162a\"\u003eUse material components to make handling insets easier\u003c/li\u003e\u003cli id=\"4f92\"\u003eDraw backgrounds edge-to-edge, and inset critical UI\u003c/li\u003e\u003cli id=\"4b71\"\u003eHandle display cutout and caption bar insets\u003c/li\u003e\u003cli id=\"14c8\"\u003eDon’t forget the last list item\u003c/li\u003e\u003cli id=\"bbed\"\u003eDon’t forget IMEs\u003c/li\u003e\u003cli id=\"9c52\"\u003eFor backwards compatibility, use \u003ccode\u003eenableEdgeToEdge\u003c/code\u003e instead of \u003ccode\u003esetDecorFitsSystemWindows\u003c/code\u003e\u003c/li\u003e\u003cli id=\"21ba\"\u003eBackground protect system bars only when necessary\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"922b\"\u003eIt also provides these tips that are specific to Compose:\u003c/p\u003e\u003cp id=\"b322\"\u003e8. Use Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e\u003c/p\u003e\u003cp id=\"5649\"\u003e9. Use high level \u003ccode\u003eWindowInset\u003c/code\u003e APIs\u003c/p\u003e\u003cp id=\"ca0c\"\u003eFinally, it includes these tips specific to Views:\u003c/p\u003e\u003cp id=\"d3ff\"\u003e10. Prefer \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener\u003c/code\u003e over \u003ccode\u003efitsSystemWindows=true\u003c/code\u003e\u003c/p\u003e\u003cp id=\"879f\"\u003e11. Apply insets based on app bar height on bar layout\u003c/p\u003e\u003ch2 id=\"e72c\"\u003e1. Use material components to make handling insets easier\u003c/h2\u003e\u003cp id=\"f67d\"\u003eMany material components automatically handle insets, meaning the component’s background draws inside the system bar region and pads critical UI (see tip #2). Some material components do \u003cem\u003enot\u003c/em\u003e automatically handle insets, but instead provide methods to make handling insets easier.\u003c/p\u003e\u003cp id=\"126d\"\u003eMaterial 3 Components (\u003ccode\u003eandroidx.compose.material3\u003c/code\u003e) that automatically handle insets:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7060\"\u003e\u003ccode\u003eBottomAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"b036\"\u003e\u003ccode\u003eCenterAlignedTopAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"8192\"\u003e\u003ccode\u003eDismissibleDrawerSheet\u003c/code\u003e\u003c/li\u003e\u003cli id=\"e9a3\"\u003e\u003ccode\u003eLargeTopAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"e02a\"\u003e\u003ccode\u003eMediumTopAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"2b22\"\u003e\u003ccode\u003eModalBottomSheet\u003c/code\u003e\u003c/li\u003e\u003cli id=\"1030\"\u003e\u003ccode\u003eModalDrawerSheet\u003c/code\u003e\u003c/li\u003e\u003cli id=\"9f7f\"\u003e\u003ccode\u003eNavigationBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"cc82\"\u003e\u003ccode\u003eNavigationRail\u003c/code\u003e\u003c/li\u003e\u003cli id=\"07b7\"\u003e\u003ccode\u003eNavigationSuiteScaffold\u003c/code\u003e\u003c/li\u003e\u003cli id=\"ae74\"\u003e\u003ccode\u003ePermanentDrawerSheet\u003c/code\u003e\u003c/li\u003e\u003cli id=\"683e\"\u003e\u003ccode\u003eTopAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"12ae\"\u003e\u003ccode\u003eSmallTopAppBar\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fc93\"\u003eMaterial 2 Components (\u003ccode\u003eandroidx.compose.material\u003c/code\u003e) don’t automatically handle insets themselves by default, unlike Material 3 components. Consider updating to \u003ca href=\"https://m3.material.io/blog/migrating-material-3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMaterial 3 Components\u003c/a\u003e. Otherwise, many Material 2 components support specifying the window insets to apply with the windowInsets parameter, like the \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#BottomAppBar(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBottomAppBar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TopAppBar(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTopAppBar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#BottomNavigation(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBottomNavigation\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#NavigationRail(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.unit.Dp,kotlin.Function1,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNavigationRail\u003c/a\u003e\u003c/code\u003e. Likewise, use the \u003ccode\u003econtentWindowInsets\u003c/code\u003e parameter for \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#Scaffold(androidx.compose.foundation.layout.WindowInsets,androidx.compose.ui.Modifier,androidx.compose.material.ScaffoldState,kotlin.Function0,kotlin.Function0,kotlin.Function1,kotlin.Function0,androidx.compose.material.FabPosition,kotlin.Boolean,kotlin.Function1,kotlin.Boolean,androidx.compose.ui.graphics.Shape,androidx.compose.ui.unit.Dp,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,kotlin.Function1)\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eScaffold\u003c/a\u003e\u003c/code\u003e. Otherwise, apply the insets as padding.\u003c/p\u003e\u003cp id=\"61df\"\u003eMaterial View Components (\u003ccode\u003ecom.google.android.material\u003c/code\u003e) that automatically handle insets:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f432\"\u003e\u003ccode\u003eBottomAppBar\u003c/code\u003e\u003c/li\u003e\u003cli id=\"44f4\"\u003e\u003ccode\u003eBottomNavigationView\u003c/code\u003e\u003c/li\u003e\u003cli id=\"d349\"\u003e\u003ccode\u003eNavigationRailView\u003c/code\u003e\u003c/li\u003e\u003cli id=\"9407\"\u003e\u003ccode\u003eNavigationView\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5941\"\u003e2. Draw backgrounds edge-to-edge, and inset critical UI.\u003c/h2\u003e\u003cp id=\"77e7\"\u003eOftentimes, apps will set the system bars to the same color as the app bars to appear edge-to-edge, which is an anti-pattern.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 5. \u003c/strong\u003eApp targeting SDK 34 on an Android 15 device. The app has set the status bar and navigation bar colors, which is no longer supported after targeting SDK 35. The status and navigation bar color are intentionally set to a slightly different shade so you can distinguish the system bars from the app bars, but usually apps will use the same colors for the system and app bars to appear edge-to-edge.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"526e\"\u003eApps using this anti-pattern do \u003cem\u003enot\u003c/em\u003e appear edge-to-edge all the time, especially on large screen devices.\u003c/p\u003e\u003cp id=\"50f3\"\u003eTo improve this app’s UX after edge-to-edge is enforced, extend the background of the app bars so they draw underneath the transparent system bars, then inset the text and buttons to avoid the system bars. Material 3 components \u003ccode\u003eTopAppBars\u003c/code\u003e and \u003ccode\u003eBottomAppBars\u003c/code\u003e do this automatically. For Material 2 components, use the \u003ccode\u003ewindowInsets\u003c/code\u003e parameter. For Views, some Material components handle this automatically. Otherwise, you’ll use \u003ccode\u003efitsSystemWindows\u003c/code\u003e or \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 6.\u003c/strong\u003e Edge-to-edge enforced. \u003cstrong\u003eLeft:\u003c/strong\u003e Insets not handled. \u003cstrong\u003eRight:\u003c/strong\u003e Insets handled. App bars draw under transparent system bars and text and icons avoid the system bars.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9f64\"\u003e3. Handle display cutout and caption bar insets\u003c/h2\u003e\u003cp id=\"e713\"\u003eWhile handling insets, account for the display cutouts and caption bars in addition to the status and navigation bars.\u003c/p\u003e\u003cp id=\"fb61\"\u003e\u003cstrong\u003eDisplay cutouts\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d0e3\"\u003eA display cutout often contains the camera. After targeting SDK 35, your app might have important UI under the display cutout, especially when the cutout is on the left or right edges of the device.\u003c/p\u003e\u003cp id=\"cf7f\"\u003eFor example, prior to targeting SDK 35, your app might have a large white box to account for a camera cutout in landscape.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 7. \u003c/strong\u003eApp targeting SDK 34 on an Android 15 device.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"1d1f\"\u003eAfter targeting SDK 35, the white box disappears and all content moves to the left. Some content draws underneath the camera cutout.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 8. \u003c/strong\u003eApp targeting SDK 35 on an Android 15 device. The camera hides Sheep’s photo.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"405e\"\u003e\u003cstrong\u003eHandling display cutouts in Compose\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"e531\"\u003eIn Compose, easily handle display cutouts using \u003ccode\u003eWindowInsets.safeContent\u003c/code\u003e, \u003ccode\u003eWindowInsets.safeDrawing\u003c/code\u003e, or \u003ccode\u003eWindowInsets.safeGestures\u003c/code\u003e. Or, use \u003ccode\u003eWindowInsets.displayCutout\u003c/code\u003e for fine-grained control. Unfortunately, at the time of writing this blog, Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e does \u003cem\u003enot\u003c/em\u003e yet account for the display cutout.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dd79\"\u003e// Shows using WindowInsets.displayCutout for fine-grained control.\u003cbr/\u003e// But, it\u0026#39;s often sufficient and easier to instead use\u003cbr/\u003e// WindowInsets.safeContent, WindowInsets.safeDrawing, or WindowInsets.safeGestures\u003cbr/\u003e@Composable\u003cbr/\u003efun ChatRow(...) {\u003cbr/\u003e   val layoutDirection = LocalLayoutDirection.current\u003cbr/\u003e   val displayCutout = WindowInsets.displayCutout.asPaddingValues()\u003cbr/\u003e   val startPadding = displayCutout.calculateStartPadding(layoutDirection)\u003cbr/\u003e   val endPadding = displayCutout.calculateEndPadding(layoutDirection)\u003cbr/\u003e   Row(\u003cbr/\u003e       modifier = modifier.padding(\u003cbr/\u003e               PaddingValues(\u003cbr/\u003e                   top = 16.dp,\u003cbr/\u003e                   bottom = 16.dp,\u003cbr/\u003e                   // Ensure content is not hidden by display cutouts\u003cbr/\u003e                   // when rotating the device.\u003cbr/\u003e                   start = startPadding.coerceAtLeast(16.dp),\u003cbr/\u003e                   end = endPadding.coerceAtLeast(16.dp)\u003cbr/\u003e               )\u003cbr/\u003e           ),\u003cbr/\u003e       ...\u003cbr/\u003e   ) { ... }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"330a\"\u003eAfter handling display cutouts, the app looks like this:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 9. \u003c/strong\u003eApp targeting SDK 35 on an Android 15 device. Display cutout insets handled. Note: ideally “Chats” should also be padded to the right.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"93cb\"\u003eYou can test various display cutout configurations on the \u003ca href=\"https://developer.android.com/studio/debug/dev-options\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDeveloper options\u003c/a\u003e screen under Display cutout.\u003c/p\u003e\u003cp id=\"90a3\"\u003eLearn more about this example in the codelab, \u003ca href=\"https://developer.android.com/codelabs/edge-to-edge#4\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHandle edge-to-edge enforcements in Android 15\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"7d08\"\u003e\u003cstrong\u003eHandling display cutouts in Views\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"0c42\"\u003eIn Views, handle display cutouts using \u003ccode\u003eWindowInsetsCompat.Type.displayCutout\u003c/code\u003e. See the \u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge#cutout-insets\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e for a code sample.\u003c/p\u003e\u003cp id=\"1af7\"\u003eNote: If your app has a non-floating window (for example, an Activity) that is using \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES\u003c/a\u003e\u003c/code\u003e, Android will interpret these cutout modes to be \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/android/view/WindowManager.LayoutParams#LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS\u003c/a\u003e\u003c/code\u003e starting in Android 15, causing your window to draw into the display cutout region. Ensure to test your screens that use \u003ccode\u003eDEFAULT\u003c/code\u003e, \u003ccode\u003eNEVER\u003c/code\u003e, or \u003ccode\u003eSHORT_EDGES\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"c781\"\u003e\u003cstrong\u003eCaption bars\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"b7da\"\u003eWhen your app appears in a desktop emulator or in a free form window, it has a caption bar instead of a status bar.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 10. \u003c/strong\u003eThe caption bar in a desktop emulator.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9071\"\u003eWhile handling insets in Compose, use either Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e, \u003ccode\u003eWindowInsets.safeContent\u003c/code\u003e, \u003ccode\u003eWindowInsets.safeDrawing\u003c/code\u003e, or \u003ccode\u003eWindowInsets.systemBars\u003c/code\u003e, which all include the caption bar. Don’t use \u003ccode\u003eWindowInsets.statusBars\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"abe0\"\u003eIn your app’s View-based layouts, use \u003ccode\u003eWindowInsetsCompat.Type.systemBars\u003c/code\u003e. Don’t use \u003ccode\u003eWindowInsetsCompat.Type.statusBars\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"045d\"\u003e4. Don’t forget the last list item\u003c/h2\u003e\u003cp id=\"4848\"\u003eAfter targeting SDK 35, the last item of your lists might be inaccessible, especially if it’s behind three-button navigation or the taskbar.\u003c/p\u003e\u003cp id=\"e708\"\u003e\u003cstrong\u003eHandling the last list item in Compose\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"5e64\"\u003eTo handle the last list item in Compose, use LazyColumn’s \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/lists#content-padding\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003econtentPadding\u003c/a\u003e\u003c/code\u003e to add a space to the last item unless you are using \u003ccode\u003eTextField\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"02c9\"\u003eScaffold { innerPadding -\u0026gt;\u003cbr/\u003e    LazyColumn(\u003cbr/\u003e        contentPadding = innerPadding\u003cbr/\u003e    ) {\u003cbr/\u003e        // Content that does not contain TextField\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bcaa\"\u003eFor \u003ccode\u003eTextField\u003c/code\u003e, use a \u003ccode\u003eSpacer\u003c/code\u003e to draw the last \u003ccode\u003eTextField\u003c/code\u003e in a \u003ccode\u003eLazyColumn\u003c/code\u003e. For an in-depth overview of handling insets with lists, see \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/insets#inset-consumption\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInset consumption\u003c/a\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"32e0\"\u003eLazyColumn(\u003cbr/\u003e    Modifier.imePadding()\u003cbr/\u003e) {\u003cbr/\u003e    // Content with TextField\u003cbr/\u003e    item {\u003cbr/\u003e        Spacer(\u003cbr/\u003e            Modifier.windowInsetsBottomHeight(\u003cbr/\u003e                WindowInsets.systemBars\u003cbr/\u003e            )\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6390\"\u003e\u003cstrong\u003eHandling the last list item in Views\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c1f3\"\u003eAdding \u003ccode\u003eclipToPadding=”false”\u003c/code\u003e can ensure the last list item appears above the navigation bar for \u003ccode\u003eRecyclerView\u003c/code\u003e or \u003ccode\u003eNestedScrollView\u003c/code\u003e. Take this app for example. After targeting SDK 35, the app’s list UI shows the last list item underneath the navigation bar.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"7996\"\u003eWe can use the window inset listener so that all list items, including the last list item, are padded above the navigation bar.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 12. \u003c/strong\u003eApp has handled insets, but feels less immersive because content does not scroll behind system bars.\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"417b\"\u003e// Figure 12\u003cbr/\u003eViewCompat.setOnApplyWindowInsetsListener(\u003cbr/\u003e    findViewById(R.id.recycler_view)\u003cbr/\u003e) { v, insets -\u0026gt;\u003cbr/\u003e    val innerPadding = insets.getInsets(\u003cbr/\u003e        // Notice we\u0026#39;re using systemBars, not statusBar\u003cbr/\u003e        WindowInsetsCompat.Type.systemBars()\u003cbr/\u003e        // Notice we\u0026#39;re also accounting for the display cutouts\u003cbr/\u003e        or WindowInsetsCompat.Type.displayCutout()\u003cbr/\u003e        // If using EditText, also add \u003cbr/\u003e        // \u0026#34;or WindowInsetsCompat.Type.ime()\u0026#34;\u003cbr/\u003e        // to maintain focus when opening the IME\u003cbr/\u003e    )\u003cbr/\u003e    v.setPadding(\u003cbr/\u003e        innerPadding.left,\u003cbr/\u003e        innerPadding.top,\u003cbr/\u003e        innerPadding.right,\u003cbr/\u003e        innerPadding.bottom)\u003cbr/\u003e    insets\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8c5d\"\u003eHowever, now the app looks less immersive. To get the result we want, add \u003ccode\u003eclipToPadding=false\u003c/code\u003e to ensure the last list item sits above the navigation bar and the list is visible while scrolling behind the navigation bar (and status bar).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 13. \u003c/strong\u003eApp displays edge-to-edge and the last list item is fully visible. This is the result we want.\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"f394\"\u003e\u0026lt;!-- Figure 13 --\u0026gt;\u003cbr/\u003e\u0026lt;RecyclerView\u003cbr/\u003e    ...\u003cbr/\u003e    android:clipToPadding=\u0026#34;false\u0026#34; /\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1b6d\"\u003e5. Don’t forget IMEs\u003c/h2\u003e\u003cp id=\"4244\"\u003eSet \u003ccode\u003e\u003ca href=\"https://developer.android.com/guide/topics/manifest/activity-element#wsoft\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eandroid:windowSoftInputMode=”adjustResize”\u003c/a\u003e\u003c/code\u003e in your Activity’s AndroidManifest.xml entry to make room for the IME (or soft keyboard) on screen.\u003c/p\u003e\u003cp id=\"5e9b\"\u003e\u003cstrong\u003eHandling IMEs insets in Compose\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"2993\"\u003eAccount for the IME using \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).imePadding()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eModifier.imePadding()\u003c/a\u003e\u003c/code\u003e. For example, this can help maintain focus on a \u003ccode\u003eTextField\u003c/code\u003e in a \u003ccode\u003eLazyColumn\u003c/code\u003e when the IME opens. See the \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).imePadding()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInset consumption\u003c/a\u003e section for a code example and explanation.\u003c/p\u003e\u003cp id=\"d485\"\u003e\u003cstrong\u003eHandling IMEs insets in Views\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7a68\"\u003eBefore targeting SDK 35, using \u003ccode\u003eandroid:windowSoftInputMode=”adjustResize”\u003c/code\u003e was all you needed to maintain focus on — for example — an \u003ccode\u003eEditText\u003c/code\u003e in a \u003ccode\u003eRecyclerView\u003c/code\u003e when opening an IME. With \u003ccode\u003e“adjustResize”\u003c/code\u003e, the framework treated the IME as the system window, and the window’s root views were padded so content avoids the system window.\u003c/p\u003e\u003cp id=\"eaf4\"\u003eAfter targeting SDK 35, you must also account for the IME using \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener\u003c/code\u003e and \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.Type#ime()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsetsCompat.Type.ime()\u003c/a\u003e\u003c/code\u003e because the framework will \u003cem\u003enot\u003c/em\u003e pad the window’s root views. See Figure 12\u0026#39;s code example.\u003c/p\u003e\u003ch2 id=\"2459\"\u003e6. For backward compatibility, use \u003ccode\u003eenableEdgeToEdge\u003c/code\u003e instead of setDecorFitsSystemWindows\u003c/h2\u003e\u003cp id=\"d168\"\u003eAfter your app has handled insets, make your app edge-to-edge on previous Android versions. For this, use \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge#enable-edge-to-edge-display\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eenableEdgeToEdge\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge-manually\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esetDecorFitsSystemWindows\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003eenableEdgeToEdge\u003c/code\u003e method encapsulates the about \u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/is-your-app-providing-a-backward-compatible-edge-to-edge-experience-2479267073a0\"\u003e100 lines of code\u003c/a\u003e you need to be truly backward compatible.\u003c/p\u003e\u003ch2 id=\"695d\"\u003e7. Background protect system bars only when necessary\u003c/h2\u003e\u003cp id=\"8b2c\"\u003eIn many cases, keep the new Android 15 defaults. The status bar and gesture navigation bar should be transparent, and three button navigation translucent after targeting SDK 35 (see Figure 1).\u003c/p\u003e\u003cp id=\"705d\"\u003eHowever, there are some cases where you wish to preserve the background color of the system bars, but the APIs to set the status and navigation bar colors are \u003ca href=\"https://developer.android.com/about/versions/15/behavior-changes-15#deprecated-apis\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edeprecated\u003c/a\u003e. We are planning to release an AndroidX library to support this use case. In the meantime, if your app must offer custom background protection to 3-button navigation or the status bar, you can place a composable or view behind the system bar using \u003ccode\u003eWindowInsets.Type#tappableElement()\u003c/code\u003e to get the 3-button navigation bar height or \u003ccode\u003eWindowInsets.Type#statusBars\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"134a\"\u003eFor example, to show the color of the element behind the 3-button navigation in Compose, set the \u003ccode\u003ewindow.isNavigationBarContrastEnforced\u003c/code\u003e property to false. Setting this property to false makes 3-button navigation fully transparent (note: this property does \u003cem\u003enot\u003c/em\u003e affect gesture navigation).\u003c/p\u003e\u003cp id=\"4023\"\u003eThen, use \u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/WindowInsets.Companion#(androidx.compose.foundation.layout.WindowInsets.Companion).tappableElement()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsets.tappableElement\u003c/a\u003e\u003c/code\u003e to align UI behind insets for tappable system UI. If non-0, the user is using tappable bars, like three button navigation. In this case, draw an opaque view or box behind the tappable bars.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dda6\"\u003eclass MainActivity : ComponentActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContent {\u003cbr/\u003e            window.isNavigationBarContrastEnforced = false\u003cbr/\u003e            MyTheme {\u003cbr/\u003e                Surface(...) {\u003cbr/\u003e                    MyContent(...)\u003cbr/\u003e                    ProtectNavigationBar()\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// Use only if required.\u003cbr/\u003e@Composable\u003cbr/\u003efun ProtectNavigationBar(modifier: Modifier = Modifier) {\u003cbr/\u003e   val density = LocalDensity.current\u003cbr/\u003e   val tappableElement = WindowInsets.tappableElement\u003cbr/\u003e   val bottomPixels = tappableElement.getBottom(density)\u003cbr/\u003e   val usingTappableBars = remember(bottomPixels) {\u003cbr/\u003e       bottomPixels != 0\u003cbr/\u003e   }\u003cbr/\u003e   val barHeight = remember(bottomPixels) {\u003cbr/\u003e       tappableElement.asPaddingValues(density).calculateBottomPadding()\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   Column(\u003cbr/\u003e       modifier = modifier.fillMaxSize(),\u003cbr/\u003e       verticalArrangement = Arrangement.Bottom\u003cbr/\u003e   ) {\u003cbr/\u003e       if (usingTappableBars) {\u003cbr/\u003e           Box(\u003cbr/\u003e               modifier = Modifier\u003cbr/\u003e                   .background(MaterialTheme.colorScheme.background)\u003cbr/\u003e                   .fillMaxWidth()\u003cbr/\u003e                   .height(barHeight)\u003cbr/\u003e           )\u003cbr/\u003e       }\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4c0a\"\u003eInset handling tips for UIs that use Compose\u003c/h2\u003e\u003cp id=\"6aa3\"\u003eThe following tips apply only for apps that use \u003ca href=\"https://developer.android.com/jetpack/compose\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetpack Compose\u003c/a\u003e. See additional Compose-related tips in this video: \u003ca href=\"https://www.youtube.com/watch?v=QRzepC9gHj4\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEdge-to-edge and insets | Compose Tips\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"6723\"\u003e8. Use Scaffold’s PaddingValues\u003c/h2\u003e\u003cp id=\"8fa4\"\u003eFor Compose, use \u003ccode\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/insets#scaffold\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eScaffold\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003eSurface\u003c/code\u003e to organize your app’s UI with \u003ccode\u003eTopAppBar\u003c/code\u003e, \u003ccode\u003eBottomAppBar\u003c/code\u003e, \u003ccode\u003eNavigationBar\u003c/code\u003e, and \u003ccode\u003eNavigationRail\u003c/code\u003e. Use Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e parameter to inset your critical UI. In most cases, that’s all you need to do.\u003c/p\u003e\u003cp id=\"f0c1\"\u003eHowever, there are cases where applying Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e will cause unexpected results. Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e includes insets for the top, bottom, start and end edges of the screen. You may need values for only certain edges. One approach is to make a copy of the parameter and manually adjust top, bottom, start and end insets so as to not apply too much padding.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 14. Left:\u003c/strong\u003e The input field at the bottom is obscured by the system’s navigation bar after targeting SDK 35. \u003cstrong\u003eMiddle\u003c/strong\u003e: Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e applied to the input field. The system uses the size of the status bar and the top app bar to calculate the top padding value, which creates excess padding above the input field. \u003cstrong\u003eRight\u003c/strong\u003e: Scaffold’s PaddingValues applied but with top padding manually removed.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d1b0\"\u003eHere’s the incorrect code, causing the excess padding seen in the middle image of Figure 14.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"db15\"\u003e// Causes excess padding, seen in the middle image of Figure 14.\u003cbr/\u003eScaffold { innerPadding -\u0026gt; // innerPadding is Scaffold\u0026#39;s PaddingValues\u003cbr/\u003e    InputBar(\u003cbr/\u003e        ...\u003cbr/\u003e        contentPadding = innerPadding\u003cbr/\u003e     ) {...}\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d30\"\u003eHere’s the corrected code that generates proper padding, as seen in the right-side image of Figure 14.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"17d7\"\u003e// Function to make a copy of PaddingValues, using existing defaults unless an\u003cbr/\u003e// alternative value is specified\u003cbr/\u003e​​private fun PaddingValues.copy(\u003cbr/\u003e    layoutDirection: LayoutDirection,\u003cbr/\u003e    start: Dp? = null,\u003cbr/\u003e    top: Dp? = null,\u003cbr/\u003e    end: Dp? = null,\u003cbr/\u003e    bottom: Dp? = null,\u003cbr/\u003e) = PaddingValues(\u003cbr/\u003e    start = start ?: calculateStartPadding(layoutDirection),\u003cbr/\u003e    top = top ?: calculateTopPadding(),\u003cbr/\u003e    end = end ?: calculateEndPadding(layoutDirection),\u003cbr/\u003e    bottom = bottom ?: calculateBottomPadding(),\u003cbr/\u003e)\u003cp\u003e// Produces correct padding, seen in the right-side image of Figure 14.\u003cbr/\u003eScaffold { innerPadding -\u0026gt; // innerPadding is Scaffold\u0026#39;s PaddingValues\u003cbr/\u003e    val layoutDirection = LocalLayoutDirection.current\u003cbr/\u003e    InputBar(\u003cbr/\u003e        ...\u003cbr/\u003e        contentPadding = innerPadding.copy(layoutDirection, top = 0.dp)\u003cbr/\u003e    ) {...}\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"abf2\"\u003e9. Use high level WindowInsets APIs\u003c/h2\u003e\u003cp id=\"08a9\"\u003eSimilar to Scaffold’s \u003ccode\u003ePaddingValues\u003c/code\u003e, you can also use the high-level \u003ccode\u003eWindowInset\u003c/code\u003e APIs to easily and safely draw critical UI elements. These are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6a74\"\u003e\u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.foundation.layout.WindowInsets.Companion).safeDrawing()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsets.safeDrawing\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"266a\"\u003e\u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.foundation.layout.WindowInsets.Companion).safeGestures()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsets.safeGestures\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"b083\"\u003e\u003ccode\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.foundation.layout.WindowInsets.Companion).safeContent()\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindowInsets.safeContent\u003c/a\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"170c\"\u003eSee \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/insets\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInset fundamentals\u003c/a\u003e to learn more.\u003c/p\u003e\u003ch2 id=\"bb00\"\u003eInset handling tips for UIs that use Views\u003c/h2\u003e\u003cp id=\"b1c0\"\u003eThe following apply only for Views-based apps.\u003c/p\u003e\u003ch2 id=\"d0f6\"\u003e10. Prefer \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener\u003c/code\u003e over fitsSystemWindows=true\u003c/h2\u003e\u003cp id=\"fd61\"\u003eYou \u003cem\u003ecould\u003c/em\u003e use \u003ccode\u003efitsSystemWindows=true\u003c/code\u003e to inset your app’s content. It’s an easy 1-line code change. However, don’t use \u003ccode\u003efitsSystemWindows\u003c/code\u003e on a View that contains your entire layout (including the background). This will make your app look \u003cem\u003enot\u003c/em\u003e edge-to-edge because \u003ccode\u003efitsSystemWindows\u003c/code\u003e handles insets on all edges.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 15.\u003c/strong\u003e Edge-to-edge enforced. \u003cstrong\u003eLeft\u003c/strong\u003e: fitsSystemWindows=false (the default). \u003cstrong\u003eRight\u003c/strong\u003e: fitsSystemWindows=true. This is not the result we want because the app does not look edge-to-edge.\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 16. \u003c/strong\u003eEdge-to-edge enforced, fitsSystemWindows=true. The gap on the left edge is due to a display cutout, which is not visible here. This is not the result we want because the app doesn’t look edge-to-edge.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"309e\"\u003e\u003ccode\u003efitsSystemWindows\u003c/code\u003e can create an edge-to-edge experience if using \u003ccode\u003eCoordinatorLayouts\u003c/code\u003e or \u003ccode\u003eAppBarLayouts.\u003c/code\u003eAdd \u003ccode\u003efitsSystemWindows\u003c/code\u003e to the \u003ccode\u003eCoordinatorLayout\u003c/code\u003e and the \u003ccode\u003eAppBarLayout\u003c/code\u003e, and the \u003ccode\u003eAppBarLayout\u003c/code\u003e draws edge-to-edge, which is what we want.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003eFigure 17.\u003c/strong\u003e Edge-to-edge enforced. \u003cstrong\u003eLeft:\u003c/strong\u003e AppBarLayout does not automatically handle insets. \u003cstrong\u003eRight:\u003c/strong\u003e Add fitsSystemWindows to AppBarLayout and CoordinatorLayout to draw edge-to-edge.\u003c/figcaption\u003e\u003c/figure\u003e\u003cpre\u003e\u003cspan id=\"1511\"\u003e\u0026lt;!-- Figure 17 --\u0026gt;\u003cbr/\u003e\u0026lt;CoordinatorLayout\u003cbr/\u003e    android:fitsSystemWindows=\u0026#34;true\u0026#34;\u003cbr/\u003e    ...\u0026gt;\u003cbr/\u003e    \u0026lt;AppBarLayout\u003cbr/\u003e        android:fitsSystemWindows=\u0026#34;true\u0026#34;\u003cbr/\u003e        ...\u0026gt;\u003cbr/\u003e        \u0026lt;TextView\u003cbr/\u003e            android:text=\u0026#34;App Bar Layout\u0026#34;\u003cbr/\u003e            .../\u0026gt;\u003cbr/\u003e    \u0026lt;/AppBarLayout\u0026gt;\u003cbr/\u003e\u0026lt;/CoordinatorLayout\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3cd\"\u003eIn this case, \u003ccode\u003eAppBarLayout\u003c/code\u003e used \u003ccode\u003efitsSystemWindows\u003c/code\u003e to draw underneath the status bar rather than avoiding it, which is the opposite of what we might expect. Furthermore, \u003ccode\u003eAppBarLayout\u003c/code\u003e with \u003ccode\u003efitsSystemWindows=true\u003c/code\u003e only applies padding for the top and not the bottom, start, or end edges.\u003c/p\u003e\u003cp id=\"735e\"\u003eThe \u003ccode\u003eCoordinatorLayout\u003c/code\u003e and \u003ccode\u003eAppBarLayout\u003c/code\u003e objects have the following behavior when overriding \u003ccode\u003efitsSystemWindows\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"db48\"\u003e\u003ccode\u003eCoordinatorLayout\u003c/code\u003e: backgrounds of child views draw underneath the system bars if those views also set \u003ccode\u003efitsSystemWindows=true\u003c/code\u003e. Padding is automatically applied to the content of those Views (e.g. text, icons, images) to account for system bars and display cutouts.\u003c/li\u003e\u003cli id=\"7853\"\u003e\u003ccode\u003eAppBarLayout\u003c/code\u003e: draws underneath the system bars if \u003ccode\u003efitsSystemWindows=true\u003c/code\u003e and automatically applies top padding to content.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"dbc6\"\u003eIn most cases, handle insets with \u003ccode\u003eViewCompat.setOnApplyWindowInsetsListener\u003c/code\u003e because it allows you to define which edges should handle insets and has consistent behavior. See tips #4 and #11 for a code example.\u003c/p\u003e\u003ch2 id=\"2746\"\u003e11. Apply insets based on app bar height during the layout phase\u003c/h2\u003e\u003cp id=\"bdad\"\u003eIf you find that your app’s content is hiding underneath an app bar, you might need to apply insets after the app bar is laid out, taking the app bar height into account.\u003c/p\u003e\u003cp id=\"16b1\"\u003eFor example, if you have scrolling content underneath an \u003ccode\u003eAppBarLayout\u003c/code\u003e in a \u003ccode\u003eFrameLayout\u003c/code\u003e, you could use code like this to ensure the scrolling content appears after the \u003ccode\u003eAppBarLayout\u003c/code\u003e. Notice padding is applied within \u003ccode\u003edoOnLayout\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"15e4\"\u003eval myScrollView = findViewById\u0026lt;NestedScrollView\u0026gt;(R.id.my_scroll_view)\u003cbr/\u003eval myAppBar = findViewById\u0026lt;AppBarLayout\u0026gt;(R.id.my_app_bar_layout)\u003cp\u003eViewCompat.setOnApplyWindowInsetsListener(myScrollView) { scrollView, windowInsets -\u0026gt;\u003cbr/\u003e   val insets = windowInsets.getInsets(\u003cbr/\u003e       WindowInsetsCompat.Type.systemBars() or WindowInsetsCompat.Type.displayCutout()\u003cbr/\u003e   )\u003cbr/\u003e   myAppBar.doOnLayout { appBar -\u0026gt;\u003cbr/\u003e       scrollView.updatePadding(\u003cbr/\u003e           left = insets.left,\u003cbr/\u003e           right = insets.right,\u003cbr/\u003e           top = appBar.height,\u003cbr/\u003e           bottom = insets.bottom\u003cbr/\u003e       )\u003cbr/\u003e   }\u003cbr/\u003e   WindowInsetsCompat.CONSUMED\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3466\"\u003eLikewise, if you have scrolling content that should sit above a \u003ccode\u003eBottomNavigationView\u003c/code\u003e, you’ll want to account for the BottomNavigationView’s height once it is laid out.\u003c/p\u003e\u003ch2 id=\"fd6d\"\u003eNeed more time to migrate?\u003c/h2\u003e\u003cp id=\"989b\"\u003eIt might take significant work to properly support an edge-to-edge experience. Before you target SDK 35, consider how long you need to make the necessary changes in your app.\u003c/p\u003e\u003cp id=\"9854\"\u003eIf you need more time to handle insets to be compatible with the system’s default edge-to-edge behavior, you can temporarily opt-out using \u003ccode\u003eR.attr#windowOptOutEdgeToEdgeEnforcement\u003c/code\u003e. But do \u003cem\u003enot\u003c/em\u003e plan to use this flag indefinitely as it will be non-functional in the near future.\u003c/p\u003e\u003cp id=\"75ed\"\u003eThe flag might be particularly helpful for apps that have tens to hundreds of Activities. You might opt-out each Activity, then — make your app edge-to-edge one Activity at a time.\u003c/p\u003e\u003cp id=\"a0a0\"\u003eHere’s one approach to using this flag. Assuming your minSDK is less than 35, this attribute must be in \u003ccode\u003evalues-v35.xml\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6340\"\u003e\u0026lt;!-- In values-v35.xml --\u0026gt;\u003cbr/\u003e\u0026lt;resources\u0026gt;\u003cbr/\u003e    \u0026lt;!-- TODO: Remove once activities handle insets. --\u0026gt;\u003cbr/\u003e    \u0026lt;style name=\u0026#34;OptOutEdgeToEdgeEnforcement\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;item name=\u0026#34;android:windowOptOutEdgeToEdgeEnforcement\u0026#34;\u0026gt;true\u0026lt;/item\u0026gt;\u003cbr/\u003e    \u0026lt;/style\u0026gt;\u003cbr/\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a05d\"\u003eCreate an empty style for past versions in \u003ccode\u003evalues.xml\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3439\"\u003e\u0026lt;!-- In values.xml --\u0026gt;\u003cbr/\u003e\u0026lt;resources\u0026gt;\u003cbr/\u003e    \u0026lt;!-- TODO: Remove once activities handle insets. --\u0026gt;\u003cbr/\u003e    \u0026lt;style name=\u0026#34;OptOutEdgeToEdgeEnforcement\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;!-- android:windowOptOutEdgeToEdgeEnforcement\u003cbr/\u003e             isn\u0026#39;t supported before SDK 35. This empty\u003cbr/\u003e             style enables programmatically opting-out. --\u0026gt;\u003cbr/\u003e    \u0026lt;/style\u0026gt;\u003cbr/\u003e\u0026lt;/resources\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1a8c\"\u003eCall the style before accessing the decor view in \u003ccode\u003esetContentView\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9d16\"\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cp\u003e        // Call before the DecorView is accessed in setContentView\u003cbr/\u003e        theme.applyStyle(R.style.OptOutEdgeToEdgeEnforcement, /* force */ false)\u003c/p\u003e\u003cp\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003cbr/\u003e        ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"388c\"\u003eResources\u003c/h2\u003e\u003cp id=\"492e\"\u003eAndroid 15 AOSP released today. Our team has created blogs, videos, and codelabs to help get your app ready to handle the \u003ca href=\"https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid 15 edge-to-edge enforcement\u003c/a\u003e. What follows is a list of old and new resources for further learning.\u003c/p\u003e\u003ch2 id=\"bd68\"\u003eDocumentation\u003c/h2\u003e\u003cul\u003e\u003cli id=\"2b31\"\u003e\u003ca href=\"https://developer.android.com/about/versions/15/behavior-changes-15#edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBehavior changes for apps targeting Android 15: Edge-to-edge enforcement\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6b79\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/insets\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWindow insets in Compose\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5d3f\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/compose/system/cutouts\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCutouts in Compose\u003c/a\u003e\u003c/li\u003e\u003cli id=\"870e\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/views/layout/edge-to-edge\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDisplay content edge-to-edge in your app\u003c/a\u003e (Views)\u003c/li\u003e\u003cli id=\"7a1c\"\u003e\u003ca href=\"https://developer.android.com/develop/ui/views/layout/display-cutout\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSupport display cutouts\u003c/a\u003e (Views)\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c338\"\u003eVideos\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a63c\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=QRzepC9gHj4\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEdge to Edge \u0026amp; Insets\u003c/a\u003e (Compose)\u003c/li\u003e\u003cli id=\"e5ef\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=mlL6H-s0nF0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eInsets: Compose edition\u003c/a\u003e\u003c/li\u003e\u003cli id=\"4f64\"\u003e\u003ca href=\"https://m.youtube.com/watch?v=RimGfoOU67s\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e3 things to improve the user experience of your Android app: Handle edge-to-edge enforcements in Android 15\u003c/a\u003e walkthrough (Compose)\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"55cf\"\u003eCodelabs\u003c/h2\u003e\u003cp id=\"449d\"\u003e\u003ca href=\"https://developer.android.com/codelabs/edge-to-edge#0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHandle edge-to-edge enforcements in Android 15\u003c/a\u003e (Compose)\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "25 min read",
  "publishedTime": "2024-09-03T18:12:32.484Z",
  "modifiedTime": null
}
