{
  "id": "092316fb-e4a7-4908-93f0-1fb432d436e9",
  "title": "Airbnb’s Page Performance Score on Android",
  "link": "https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-android-f9fd5e733e?source=rss----53c7c27702d5--android",
  "description": "",
  "author": "Luping Lin",
  "published": "Fri, 17 Dec 2021 21:06:55 GMT",
  "source": "https://medium.com/feed/airbnb-engineering/tagged/android",
  "categories": [
    "mobile-performance",
    "android-performance",
    "mobile-app-development",
    "android",
    "mobile"
  ],
  "byline": "Luping Lin",
  "length": 8768,
  "excerpt": "Airbnb’s home grown Page Performance Score (PPS) is designed to capture the rich, complex realities of performance by collecting a multitude of user-centric performance metrics and formulating them…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Part 4 of our series on Airbnb’s Page Performance Score.Luping LinAirbnb’s home grown Page Performance Score (PPS) is designed to capture the rich, complex realities of performance by collecting a multitude of user-centric performance metrics and formulating them into one single 0-100 score. In this post we will deep dive into how we define and implement these metrics on Android. Make sure you read the overview blog post first to familiarize yourself with our PPS metrics and formula.InstrumentationUniversal Page Tracking SystemThe entire customer journey on Airbnb is divided into different pages, each of which has its own measured PPS. In order to support this page-based performance tracking system, we built a standardized infrastructure that enables engineers to configure pages representing their features.On Android a page is associated with a Fragment. Each fragment must provide a LoggingConfig object specifying a page name, which can later be retrieved whenever the page name needs to be referenced. We collect performance data throughout the fragment’s lifecycle, and only emit the logging event when the fragment is paused.A universal PageName enum is used to uniquely identify each page, and is referenced across all platforms to consistently represent each page in our user journey.Capturing Wait Time Perceived by UsersA key differentiator of our new Page Performance Score (PPS) is that it measures wait time that users can see. While our early measurement effort (mentioned in our overview blog post), which was based on the commonly known Time To Interactive (TTI) metric, measures code execution time and length of asynchronous calls. For example, PPS measures how long a user sees the loading indicators on screen, while TTI measures how long it takes for a network request to return results and how long it takes to build the view models. We believe PPS more closely reflects performance experienced by our users.In order to capture visually perceived wait time, we needed all views with a loading state to implement an API that reports their loading state changes. We created a simple interface called LoadableView.We provide primitives such as a base ViewGroup, a base TextView, and a base ImageView, all of which implement the LoadableView interface. Our developers simply need to inherit from these primitives for their views to be automatically instrumented.One challenge was that we needed to keep track of a view’s visibility because if a view is not at least 10% visible on the screen we don’t want to include its loading time in our measurement. The computation of the percentage of visibility of every view is both frequent and recursive. Furthermore, most of our views are in a RecyclerView and we must ensure their visibility is updated correctly on each scroll event, while keeping the RecyclerView performant. We devised algorithms to reduce the frequency and complexity of these calculations, including caching the visibility states within the RecyclerView.Metric ImplementationTime to First Layout (TTFL)TTFL measures how long a user has to wait before seeing any content on the screen. TTFL starts at fragment initialization and ends at the first onGlobalLayout event after the fragment is laid out, at which point the system has finished inflating, measuring, and laying out the fragment’s view hierarchy.A slow TTFL often indicates that the fragment’s view hierarchy is overly complicated, or the UI thread is preoccupied with unnecessary tasks during fragment initialization.Time to Initial Load (TTIL)TTIL measures how long a user sees loading indicators (excluding media loading which is measured separately) before meaningful content is displayed on screen. TTIL starts at fragment initialization like TTFL, and ends when no more views on screen are in a loading state. If a screen (Fragment) is static or cached we don’t show a loading indicator. In that scenario TTIL would be the same as TTFL.A slow TTIL often reveals opportunities in improving network latency or client rendering time. For network latency we look for slow backend services, large payloads, unutilized cache, or a less optimized data parser. For rendering time we try to follow best practices in using the RecyclerView, avoid doing heavy or recursive computation when building view models, and reduce over drawing, etc.As mentioned above, views with a loading state can inherit from base primitives with built-in LoadableView implementations. The API automatically reports the view’s loading state changes to our logging framework. We use a simple counter that increments when a view enters loading state and decrements when the data is loaded. When the counter is 0, we know that there are no more loading views on screen.This GIF demonstrates TTFL (marked when the gray background with the Airbnb logo is shown) and TTIL (marked when the loading dots are replaced by meaningful content).Main Thread Hangs (MTH)Users experience screen freezes, lags, and stutters when ui frames take too long to render. Each android device has a target frame refresh rate based on the device’s capacity. However when the main thread is too busy, the device renders slower than the frame rate it’s capable of. We define a MTH as whenever any frame takes more than twice the system’s frame refresh rate to render.Frequent MTHs indicate that the main thread might be overloaded. Heavy operations or computations should be moved off the UI thread or delayed until contents are rendered.MTH is calculated using FrameMetrics reported by the Android system. We obtain the frame refresh rate from the system and use it to calculate the threshold for the thread hangs. We then listen for system callbacks to receive FrameMetrics, if the frame duration is above our threshold, we record the delta (frameDuration - hangThreshold) as a hang.Additional Load Time (ALT)ALT measures any wait time that occurs after the initial load, such as waiting for list paginations or for content to be updated after a Save button is pressed. ALT starts whenever a view enters the loading state after TTIL has already been marked, and ends when no more loading views are shown. ALT can start and end multiple times, each time is recorded as a separate ALT.Opportunities to improve ALT often lie in predicting and prefetching additional content. The overall PPS can also be improved by balancing how much content to load in initial load vs additional loads.This GIF demonstrates ALT (marked when the loading indicator at the bottom is replaced by paginated content loaded from the network).Rich Content Load Time (RCLT)RCLT measures how long a user sees a placeholder or a loading indicator until an image, a video, or some rich media content is fully displayed. ImageView and other rich media containers implement the same LoadableView API to report loading state changes to the PPS logger.To improve RCLT, we look to reduce image size, improve image caching, optimize image formats and serving, strategically schedule loading rich content that is not yet on screen, and select performant streaming libraries, etc.This GIF demonstrates RCLT (marked when the place holders are replaced with actual images loaded from the network).ConclusionWe successfully built an instrumentation framework on Android to capture much richer and user-centric performance metrics, guided by the same design principles in Airbnb’s Page Performance Score across web and native platforms. On top of this framework and the data collected, we built out dashboards to monitor performance across the entire app, set up automatic alerts targeting page owners, streamlined performance goal setting at team and org levels, and systematically tracked and mitigated performance regressions.In 2022, we plan to improve the granularity and accuracy of our instrumentations such as measuring tap responsiveness, better differentiating performance during scrolling, and providing primitives with built-in performance optimizations. We will also devote resources to build tooling to improve debuggability, and enable early regression detection and prevention via synthetic testing.PPS gives our engineers and data scientists better insights and more ways to improve our products. It also strengthens our Commitment to Craft culture. We hope that you apply these learnings in your organization as well.AppreciationsThank you to everyone who has helped build PPS on Android: Eli Hart, Charles Xue, Nick Miller, Andrew Scheuermann, Antonio Niñirola, Josh Nelson, Aditya Punjani, Josh Polsky, Jean-Nicolas Vollmer, Wensheng Mao and everyone else who helped along the way.Interested in working at Airbnb? Check out these roles:Staff Android EngineerSenior Android Engineer Senior Android EngineerAndroid Engineer, Special Projects",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*jv0-M5bsGxi2bcXb",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@lupinglin?source=post_page-----f9fd5e733e--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Luping Lin\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*oI_OkIEpE7Ob0IBd.jpg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/airbnb-engineering?source=post_page-----f9fd5e733e--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"The Airbnb Tech Blog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*MlNQKg-sieBGW5prWoe9HQ.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"461d\"\u003e\u003cem\u003ePart 4 of our series on \u003c/em\u003e\u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936\"\u003e\u003cem\u003eAirbnb’s Page Performance Score\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"6b55\"\u003e\u003ca href=\"https://www.linkedin.com/in/lupinglin/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLuping Lin\u003c/a\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"aa3f\"\u003eAirbnb’s home grown \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936\"\u003ePage Performance Score\u003c/a\u003e (PPS) is designed to capture the rich, complex realities of performance by collecting a multitude of user-centric performance metrics and formulating them into one single 0-100 score. In this post we will deep dive into how we define and implement these metrics on Android. Make sure you read the \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936\"\u003eoverview blog post\u003c/a\u003e first to familiarize yourself with our PPS metrics and formula.\u003c/p\u003e\u003ch2 id=\"2f91\"\u003eInstrumentation\u003c/h2\u003e\u003ch2 id=\"55ff\"\u003eUniversal Page Tracking System\u003c/h2\u003e\u003cp id=\"d50c\"\u003eThe entire customer journey on Airbnb is divided into different pages, each of which has its own measured PPS. In order to support this page-based performance tracking system, we built a standardized infrastructure that enables engineers to configure pages representing their features.\u003c/p\u003e\u003cp id=\"2468\"\u003eOn Android a page is associated with a \u003cem\u003eFragment\u003c/em\u003e. Each fragment must provide a \u003cem\u003eLoggingConfig\u003c/em\u003e object specifying a page name, which can later be retrieved whenever the page name needs to be referenced. We collect performance data throughout the fragment’s lifecycle, and only emit the logging event when the fragment is paused.\u003c/p\u003e\u003cp id=\"f5fd\"\u003eA universal \u003cem\u003ePageName\u003c/em\u003e enum is used to uniquely identify each page, and is referenced across all platforms to consistently represent each page in our user journey.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"298d\"\u003eCapturing Wait Time Perceived by Users\u003c/h2\u003e\u003cp id=\"54e4\"\u003eA key differentiator of our new Page Performance Score (PPS) is that it measures wait time that users can see. While our early measurement effort (mentioned in our \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936\"\u003eoverview blog post\u003c/a\u003e), which was based on the commonly known \u003ca href=\"https://web.dev/interactive/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTime To Interactive\u003c/a\u003e (TTI) metric, measures code execution time and length of asynchronous calls. For example, PPS measures how long a user sees the loading indicators on screen, while TTI measures how long it takes for a network request to return results and how long it takes to build the view models. We believe PPS more closely reflects performance experienced by our users.\u003c/p\u003e\u003cp id=\"8cef\"\u003eIn order to capture visually perceived wait time, we needed all views with a loading state to implement an API that reports their loading state changes. We created a simple interface called \u003cem\u003eLoadableView\u003c/em\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f873\"\u003eWe provide primitives such as a base \u003cem\u003eViewGroup\u003c/em\u003e, a base \u003cem\u003eTextView\u003c/em\u003e, and a base \u003cem\u003eImageView,\u003c/em\u003e all of which implement the \u003cem\u003eLoadableView\u003c/em\u003e interface. Our developers simply need to inherit from these primitives for their views to be automatically instrumented.\u003c/p\u003e\u003cp id=\"a4b1\"\u003eOne challenge was that we needed to keep track of a view’s visibility because if a view is not at least 10% visible on the screen we don’t want to include its loading time in our measurement. The computation of the percentage of visibility of every view is both frequent and recursive. Furthermore, most of our views are in a \u003cem\u003eRecyclerView\u003c/em\u003e and we must ensure their visibility is updated correctly on each scroll event, while keeping the \u003cem\u003eRecyclerView\u003c/em\u003e performant. We devised algorithms to reduce the frequency and complexity of these calculations, including caching the visibility states within the \u003cem\u003eRecyclerView\u003c/em\u003e.\u003c/p\u003e\u003ch2 id=\"602b\"\u003eMetric Implementation\u003c/h2\u003e\u003ch2 id=\"e640\"\u003eTime to First Layout (TTFL)\u003c/h2\u003e\u003cp id=\"bfe8\"\u003eTTFL measures how long a user has to wait before seeing \u003cem\u003eany\u003c/em\u003e content on the screen. TTFL starts at fragment initialization and ends at the first \u003cem\u003eonGlobalLayout \u003c/em\u003eevent after the fragment is laid out, at which point the system has finished inflating, measuring, and laying out the fragment’s view hierarchy.\u003c/p\u003e\u003cp id=\"aa1c\"\u003eA slow TTFL often indicates that the fragment’s view hierarchy is overly complicated, or the UI thread is preoccupied with unnecessary tasks during fragment initialization.\u003c/p\u003e\u003ch2 id=\"f0f6\"\u003eTime to Initial Load (TTIL)\u003c/h2\u003e\u003cp id=\"2754\"\u003eTTIL measures how long a user sees loading indicators (excluding media loading which is measured separately) before meaningful content is displayed on screen. TTIL starts at fragment initialization like TTFL, and ends when no more views on screen are in a loading state. If a screen (Fragment) is static or cached we don’t show a loading indicator. In that scenario TTIL would be the same as TTFL.\u003c/p\u003e\u003cp id=\"f148\"\u003eA slow TTIL often reveals opportunities in improving network latency or client rendering time. For network latency we look for slow backend services, large payloads, unutilized cache, or a less optimized data parser. For rendering time we try to follow best practices in using the RecyclerView, avoid doing heavy or recursive computation when building view models, and reduce over drawing, etc.\u003c/p\u003e\u003cp id=\"5e59\"\u003eAs mentioned above, views with a loading state can inherit from base primitives with built-in \u003cem\u003eLoadableView\u003c/em\u003e implementations. The API automatically reports the view’s loading state changes to our logging framework. We use a simple counter that increments when a view enters loading state and decrements when the data is loaded. When the counter is 0, we know that there are no more loading views on screen.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"388e\"\u003e\u003cem\u003eThis GIF demonstrates TTFL (marked when the gray background with the Airbnb logo is shown) and TTIL (marked when the loading dots are replaced by meaningful content).\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3d65\"\u003eMain Thread Hangs (MTH)\u003c/h2\u003e\u003cp id=\"9540\"\u003eUsers experience screen freezes, lags, and stutters when ui frames take too long to render. Each android device has a target frame refresh rate based on the device’s capacity. However when the main thread is too busy, the device renders slower than the frame rate it’s capable of. We define a MTH as whenever any frame takes more than twice the system’s frame refresh rate to render.\u003c/p\u003e\u003cp id=\"e705\"\u003eFrequent MTHs indicate that the main thread might be overloaded. Heavy operations or computations should be moved off the UI thread or delayed until contents are rendered.\u003c/p\u003e\u003cp id=\"fd35\"\u003eMTH is calculated using \u003ca href=\"https://developer.android.com/reference/android/view/FrameMetrics\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFrameMetrics\u003c/a\u003e reported by the Android system. We obtain the frame refresh rate from the system and use it to calculate the threshold for the thread hangs. We then listen for system callbacks to receive \u003ca href=\"https://developer.android.com/reference/android/view/FrameMetrics\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFrameMetrics\u003c/a\u003e, if the frame duration is above our threshold, we record the delta \u003cem\u003e(frameDuration - hangThreshold)\u003c/em\u003e as a hang.\u003c/p\u003e\u003ch2 id=\"51b7\"\u003eAdditional Load Time (ALT)\u003c/h2\u003e\u003cp id=\"8b56\"\u003eALT measures any wait time that occurs after the initial load, such as waiting for list paginations or for content to be updated after a Save button is pressed. ALT starts whenever a view enters the loading state \u003cem\u003eafter\u003c/em\u003e TTIL has already been marked, and ends when no more loading views are shown. ALT can start and end multiple times, each time is recorded as a separate ALT.\u003c/p\u003e\u003cp id=\"0f45\"\u003eOpportunities to improve ALT often lie in predicting and prefetching additional content. The overall PPS can also be improved by balancing how much content to load in initial load vs additional loads.\u003c/p\u003e\u003cp id=\"40ba\"\u003e\u003cem\u003eThis GIF demonstrates ALT (marked when the loading indicator at the bottom is replaced by paginated content loaded from the network).\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c63d\"\u003eRich Content Load Time (RCLT)\u003c/h2\u003e\u003cp id=\"df6c\"\u003eRCLT measures how long a user sees a placeholder or a loading indicator until an image, a video, or some rich media content is fully displayed. \u003cem\u003eImageView\u003c/em\u003e and other rich media containers implement the same \u003cem\u003eLoadableView\u003c/em\u003e API to report loading state changes to the PPS logger.\u003c/p\u003e\u003cp id=\"0ae5\"\u003eTo improve RCLT, we look to reduce image size, improve image caching, optimize image formats and serving, strategically schedule loading rich content that is not yet on screen, and select performant streaming libraries, etc.\u003c/p\u003e\u003cp id=\"b042\"\u003e\u003cem\u003eThis GIF demonstrates RCLT (marked when the place holders are replaced with actual images loaded from the network).\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"540d\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"22b0\"\u003eWe successfully built an instrumentation framework on Android to capture much richer and user-centric performance metrics, guided by the same design principles in \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936\"\u003e\u003cem\u003eAirbnb’s Page Performance Score\u003c/em\u003e\u003c/a\u003e across web and native platforms. On top of this framework and the data collected, we built out dashboards to monitor performance across the entire app, set up automatic alerts targeting page owners, streamlined performance goal setting at team and org levels, and systematically tracked and mitigated performance regressions.\u003c/p\u003e\u003cp id=\"635b\"\u003eIn 2022, we plan to improve the granularity and accuracy of our instrumentations such as measuring tap responsiveness, better differentiating performance during scrolling, and providing primitives with built-in performance optimizations. We will also devote resources to build tooling to improve debuggability, and enable early regression detection and prevention via synthetic testing.\u003c/p\u003e\u003cp id=\"7552\"\u003ePPS gives our engineers and data scientists better insights and more ways to improve our products. It also strengthens our \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/commitment-to-craft-e36d5a8efe2a\"\u003eCommitment to Craft\u003c/a\u003e culture. We hope that you apply these learnings in your organization as well.\u003c/p\u003e\u003ch2 id=\"96cc\"\u003eAppreciations\u003c/h2\u003e\u003cp id=\"d851\"\u003eThank you to everyone who has helped build PPS on Android: \u003ca href=\"https://www.linkedin.com/in/eli-hart-54a4b975/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEli Hart\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/charlesx2013/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCharles Xue\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/nickbryanmiller/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNick Miller\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/scheuermann/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndrew Scheuermann\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/hdezninirola/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAntonio Niñirola\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/search/results/all/?keywords=joshua+nelson+%E2%9C%A8\u0026amp;origin=RICH_QUERY_SUGGESTION\u0026amp;position=0\u0026amp;searchId=959d4aca-c80e-448a-b415-4a732ba7a84d\u0026amp;sid=Rr6\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJosh Nelson\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/adityapunjani/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAditya Punjani\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/joshpolsky/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJosh Polsky\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/jnvollmer/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJean-Nicolas Vollmer\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/wensheng-mao-76ab7142/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWensheng Mao\u003c/a\u003e and everyone else who helped along the way.\u003c/p\u003e\u003cp id=\"8971\"\u003eInterested in working at Airbnb? Check out these roles:\u003cbr/\u003e\u003ca href=\"https://grnh.se/6c9839421us\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStaff Android Engineer\u003c/a\u003e\u003cbr/\u003e\u003ca href=\"https://grnh.se/1e5c9bf51us\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSenior Android Engineer\u003c/a\u003e \u003cbr/\u003e\u003ca href=\"https://grnh.se/aa366a2e1us\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSenior Android Engineer\u003c/a\u003e\u003cbr/\u003e\u003ca href=\"https://grnh.se/20c296251us\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAndroid Engineer, Special Projects\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2021-12-17T21:06:55.251Z",
  "modifiedTime": null
}
