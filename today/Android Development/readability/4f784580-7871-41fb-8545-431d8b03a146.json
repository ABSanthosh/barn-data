{
  "id": "4f784580-7871-41fb-8545-431d8b03a146",
  "title": "Constructing Kotlin Friendly Code",
  "link": "https://chrynan.codes/constructing-kotlin-friendly-apis/",
  "description": "Using the right tools for the job results in a nicer API",
  "author": "Christopher Keenan",
  "published": "Tue, 25 Feb 2020 01:01:48 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "kotlin",
    "api",
    "design",
    "design patterns",
    "design-patterns",
    "dsl",
    "extension functions",
    "infix functions",
    "kotlin-library",
    "library",
    "operator",
    "operator overloading",
    "package level",
    "object"
  ],
  "byline": "Christopher Keenan",
  "length": 11520,
  "excerpt": "Using the right tools for the job results in a nicer API",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Kotlin is often lauded for it's conciseness and eloquent syntax, but often suffers from being confined to more limited Java coding conventions. This may be welcoming to Java developers looking to adopt Kotlin in their projects, but could be off-putting for others working in different environments, as well as, somewhat limiting Kotlin's full linguistic potential. In this article, we'll look at different ways to leverage the Kotlin programming language's features and compare them with their more \"Java-esque\" counterparts.TL;DRMake use of Kotlin's full feature set, such as, extension, operator, and infix functions, when building public facing API's.BuildersThe Builder Pattern is a common Design Pattern for constructing objects often with complex data. It's an approach to separating the data from the way in which the object is constructed. This allows the developer to provide the data they need to build an instance of an object, typically where defaults are used, internally in the builder, for the values that aren't provided. Consider the following naive and hypothetical model for representing a Kotlin function's source code:Modelclass Function\u003cR : Any\u003e( val name: String, val parameters: List\u003cParameter\u003c*\u003e\u003e = emptyList(), val returnType: KClass\u003cR\u003e, val codeBlock: String ) Java-esque BuilderThe invocation of a Java styled builder pattern in Kotlin might look something like this:Function.builder(\"sum\") .addParameter(\"a\", Int::class) .addParameter(\"b\", Int::class) .addStatement(\"return a + b\") .build() As you can see, it's a fluent API that is fairly easy to read and understand. However, some issues arise when the model becomes more complex, such as, when there are nested complex objects which also have builders. Then the API becomes difficult to visually parse and delays understanding. For instance, their could be a model to represent the source code of a Kotlin class, which can have multiple functions. This would result in nested builders in a flow, effectively convoluting the code.Klass.builder(\"Math\") .addFunction(Function.builder(\"sum\") .addParameter(\"a\", Int::class) .addParameter(\"b\", Int::class) .addStatement(\"return a + b\") .build()) .addFunction(Function.builder(\"divide\") .addParameter(\"a\", Int::class) .addParameter(\"b\", Int::class) .addStatement(\"return a / b\") .build()) The more complex the data, the more illegible the code becomes. If we were to create a model representing a Kotlin source file, which takes in Klass and Function builders, then it would quickly decrease the legibility even more. Kotlin BuilderA more Kotlin styled approach to the Builder Pattern would be to create DSLs. In Kotlin, DSLs, or Domain Specific Languages, are type-safe builders. They make use of Kotlin's Higher-order Functions (functions that take functions as parameters) and trailing lambdas to create a nicer syntactic builder. Using this approach, the Kotlin class source code builder might look like this:klass(\"Math\") { function(\"sum\") { +Parameter(\"a\", Int::class) +Parameter(\"b\", Int::class) +\"return a + b\" } function(\"divide\") { +Parameter(\"a\", Int::class) +Parameter(\"b\", Int::class) +\"return a / b\" } } This creates a much more visually appealing API by grouping related and nested objects (and removing the trailing and accruing end parentheses on a single line). It creates a cleaner and familiar look, and at first glance is easier to ascertain.Operator FunctionsKotlin provides the ability for Operator Overloading, which is to change the functioning of operators ( +, -, etc.) on different types. This feature was used in the above example with the Kotlin DSL Builder. In that example, the unary plus operator ( +item ) was overloaded to provide an alternative implementation in the context of the builder.By providing the ability to have custom classes be interacted with using language operators, Kotlin's operator overloading can be useful in many scenarios. For instance, consider Kotlin's experimental Duration class. In the source code for the Duration class, they have an overloaded operator function to provide a convenient means of adding and subtracting multiple Durations:public operator fun plus(other: Duration): Duration = Duration(value + other.value) This allows the Kotlin Duration classes to be used in the following way:val duration = 2.minutes + 30.seconds Without this feature, getting at the same result would require either wrapping an existing plus operator, or creating a new function.Java-esque Operator// Explicit constructor invocation around built-in operator support val duration = Duration(2.minutes.value + 30.seconds.value) // Custom function val otherDuration = 2.minutes.plus(30.seconds) Clearly Operator Overloading provides better semantics than the above \"Java-esque\" approach.Infix FunctionsAnother interesting feature that Kotlin supports is an Infix Function. These functions are capable of being invoked without explicitly using a period ( . ) or parentheses ( ( or )). Let's take a look at the to infix function in the Kotlin standard library that creates a Pair out of two objects.public infix fun \u003cA, B\u003e A.to(that: B): Pair\u003cA, B\u003e = Pair(this, that) The above infix function is particularly useful when constructing Maps:mapOf(\"itemOne\" to \"valueOne\", \"itemTwo\" to \"valueTwo\", \"itemThree\" to \"valueThree\", \"itemFour\" to \"valueFour\") The invocation of infix functions reads more naturally by removing obvious glyphs and appearing more native to traditional spoken and written languages. Creative use of infix functions allows for elegant APIs. For instance, in my time library, I created an infix function called to on the Moment class that retrieves the Duration difference from the first Moment to another.val duration = now to tomorrow Perhaps, the function could have even been called until, so that the function could read like so:val duration = now until tomorrow The possibilities are vast. However, one obvious caveat with the above infix function called to is that it conflicts with the Kotlin standard library to function mentioned earlier. So, you would have to be conscious of this and make sure to import the appropriate one (the compiler should alert you if you are expecting one type but get another).Java-esque Infix FunctionJava has no direct equivalent to Kotlin's infix functions, to my knowledge. So, a function would have to be written traditionally, which in some cases is not as elegant.val duration = now.to(tomorrow) // Or val otherDuration = now.until(tomorrow) Extension FunctionsKotlin provides the concept of extension functions and properties. This gives the ability to add functions and properties, scoped to an object, that are not existing in the original object's code. Consider the Kotlin Coroutines Flow interface, which represents a stream of data. This interface already has an extension function called map which transforms the data in the stream from one type to another. However, it often is the case that we would have a Flow\u003cCollection\u003cT\u003e\u003e and we need to map each value in the collection emitted by the Flow to another value and emit the entire collection of results. Since this function isn't already provided in the library, we would have to manually create it. Using extension functions, it might look something like this:fun \u003cT, R\u003e Flow\u003cCollection\u003cT\u003e\u003e.mapEach(block: suspend (T) -\u003e R): Flow\u003cList\u003cR\u003e\u003e = map { collection -\u003e collection.map { item -\u003e block(item) } } Which can be invoked like so:flowOf(listOf(1, 2, 3)) .mapEach { start + it } That looks much cleaner and is much easier than having to handle the nested map redundantly in every call site:// Not as elegant flowOf(listOf(1, 2, 3)) .map { numbers -\u003e numbers.map { start + it } } Java-esque Extension FunctionsOnce again, Java has no direct equivalent to this Kotlin feature, as far as I know, so you would have to create a function in some other class to perform the same logic. This is typically done as a \"static\" function (\"static\" is in quotes because in Java it would be a static function but in Kotlin it would be a function on a companion object).object FlowUtils { // Kotlin Anti-pattern fun \u003cT, R\u003e mapEach(upstream: Flow\u003cCollection\u003cT\u003e\u003e, block: suspend (T) -\u003e R): Flow\u003cList\u003cR\u003e\u003e = // Note that the \"map\" function is also an extension function so if // this wasn't provided on the class and we couldn't use extension // functions then we would have to have a workaround for that as well upstream.map { collection -\u003e collection.map { block(it) } } } Which could be called like the following:val flow = flowOf(listOf(1, 2, 3)) FlowUtils.mapEach(flow, { start + it }) It should be obvious that the Kotlin extension function approach is much nicer.Package Level and Object ValuesThis one is more nuanced because the usage depends on the particular scenario, and there are subjective proponents of both methods, but just the mere fact that Kotlin provides the ability for both approachs gives it the upper hand.Functions and properties can be on a singleton Kotlin object or at the package level (meaning that it can be used without a static modifier or class instance). These are useful for utility functions and values. Though the more \"Java-esque\" approach is to use a singleton Kotlin object which is reminiscent of Java static fields and methods.Object Approachobject TimeUtils { const val MILLISECONDS_IN_SECONDS = 1_000 const val SECONDS_IN_MINUTE = 60 const val MINUTES_IN_HOUR = 60 const val HOURS_IN_DAY = 24 // Wherever possible, I would advocate against having functions like these. // In particular because it makes the ability to test and provide different // implementations much more difficult. fun durationFromMilliseconds(millis: Long) = millis.milliseconds } Where the invocations would look like:val milliseconds = seconds * TimeUtils.MILLISECONDS_IN_SECONDS val duration = TimeUtils.durationFromMilliseconds(1000) Package Level Approachconst val MILLISECONDS_IN_SECONDS = 1_000 const val SECONDS_IN_MINUTE = 60 const val MINUTES_IN_HOUR = 60 const val HOURS_IN_DAY = 24 fun durationFromMilliseconds(millis: Long) = millis.milliseconds Where the invocations would look like:val milliseconds = seconds * MILLISECONDS_IN_SECONDS val duration = durationFromMilliseconds(1000) The second approach (package level) looks more elegant in the call site but opponents would argue that it pollutes the global namespace. The first approach (object) looks more verbose but groups related information together. And it should be noted that the object approach can be used similar to the package level approach depending on how it is imported, but it does add some redundancy.import com.chrynan.example.TimeUtils.MILLISECONDS_IN_SECONDS So which approach to go with is more nuanced and depends on the particular use case and some subjectivity. RecapitulateWe have gone through different Kotlin features which make code more concise and readable, and have illustrated their alternatives in a more antiquated \"Java-esque\" style to show the contrast between the different approaches. When designing public facing APIs and libraries, take into consideration Kotlin features that may provide a better design. This will bolster the API and provide a more eloquent syntax.",
  "image": "https://images.unsplash.com/reserve/oIpwxeeSPy1cnwYpqJ1w_Dufer%20Collateral%20test.jpg?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eKotlin is often lauded for it\u0026#39;s conciseness and eloquent syntax, but often suffers from being confined to more limited Java coding conventions. This may be welcoming to Java developers looking to adopt Kotlin in their projects, but could be off-putting for others working in different environments, as well as, somewhat limiting Kotlin\u0026#39;s full linguistic potential. In this article, we\u0026#39;ll look at different ways to leverage the Kotlin programming language\u0026#39;s features and compare them with their more \u0026#34;Java-esque\u0026#34; counterparts.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eMake use of Kotlin\u0026#39;s full feature set, such as, extension, operator, and infix functions, when building public facing API\u0026#39;s.\u003c/p\u003e\u003ch3 id=\"builders\"\u003eBuilders\u003c/h3\u003e\u003cp\u003eThe \u003ca href=\"https://en.wikipedia.org/wiki/Builder_pattern?ref=chrynan.codes\"\u003eBuilder Pattern\u003c/a\u003e is a common Design Pattern for constructing objects often with complex data. It\u0026#39;s an approach to separating the data from the way in which the object is constructed. This allows the developer to provide the data they need to build an instance of an object, typically where defaults are used, internally in the builder, for the values that aren\u0026#39;t provided. Consider the following naive and hypothetical model for representing a Kotlin function\u0026#39;s source code:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eModel\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass Function\u0026lt;R : Any\u0026gt;(\n        val name: String,\n        val parameters: List\u0026lt;Parameter\u0026lt;*\u0026gt;\u0026gt; = emptyList(),\n        val returnType: KClass\u0026lt;R\u0026gt;,\n        val codeBlock: String\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eJava-esque Builder\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eThe invocation of a Java styled builder pattern in Kotlin might look something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eFunction.builder(\u0026#34;sum\u0026#34;)\n    .addParameter(\u0026#34;a\u0026#34;, Int::class)\n    .addParameter(\u0026#34;b\u0026#34;, Int::class)\n    .addStatement(\u0026#34;return a + b\u0026#34;)\n    .build()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, it\u0026#39;s a fluent API that is fairly easy to read and understand. However, some issues arise when the model becomes more complex, such as, when there are nested complex objects which also have builders. Then the API becomes difficult to visually parse and delays understanding. For instance, their could be a model to represent the source code of a Kotlin class, which can have multiple functions. This would result in nested builders in a flow, effectively convoluting the code.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eKlass.builder(\u0026#34;Math\u0026#34;)\n    .addFunction(Function.builder(\u0026#34;sum\u0026#34;)\n        .addParameter(\u0026#34;a\u0026#34;, Int::class)\n        .addParameter(\u0026#34;b\u0026#34;, Int::class)\n        .addStatement(\u0026#34;return a + b\u0026#34;)\n        .build())\n    .addFunction(Function.builder(\u0026#34;divide\u0026#34;)\n        .addParameter(\u0026#34;a\u0026#34;, Int::class)\n        .addParameter(\u0026#34;b\u0026#34;, Int::class)\n        .addStatement(\u0026#34;return a / b\u0026#34;)\n        .build())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe more complex the data, the more illegible the code becomes. If we were to create a model representing a Kotlin source file, which takes in Klass and Function builders, then it would quickly decrease the legibility even more. \u003c/p\u003e\u003cp\u003e\u003cstrong\u003eKotlin Builder\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eA more Kotlin styled approach to the Builder Pattern would be to create \u003ca href=\"https://kotlinlang.org/docs/reference/type-safe-builders.html?ref=chrynan.codes\"\u003eDSLs\u003c/a\u003e. In Kotlin, DSLs, or \u003ca href=\"https://en.wikipedia.org/wiki/Domain-specific_language?ref=chrynan.codes\"\u003eDomain Specific Languages\u003c/a\u003e, are type-safe builders. They make use of Kotlin\u0026#39;s \u003ca href=\"https://kotlinlang.org/docs/reference/lambdas.html?ref=chrynan.codes\"\u003eHigher-order Functions\u003c/a\u003e (functions that take functions as parameters) and trailing lambdas to create a nicer syntactic builder. Using this approach, the Kotlin class source code builder might look like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eklass(\u0026#34;Math\u0026#34;) {\n    function(\u0026#34;sum\u0026#34;) {\n        +Parameter(\u0026#34;a\u0026#34;, Int::class)\n        +Parameter(\u0026#34;b\u0026#34;, Int::class)\n        +\u0026#34;return a + b\u0026#34;\n    }\n    function(\u0026#34;divide\u0026#34;) {\n        +Parameter(\u0026#34;a\u0026#34;, Int::class)\n        +Parameter(\u0026#34;b\u0026#34;, Int::class)\n        +\u0026#34;return a / b\u0026#34;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis creates a much more visually appealing API by grouping related and nested objects (and removing the trailing and accruing end parentheses on a single line). It creates a cleaner and familiar look, and at first glance is easier to ascertain.\u003c/p\u003e\u003ch3 id=\"operator-functions\"\u003eOperator Functions\u003c/h3\u003e\u003cp\u003eKotlin provides the ability for \u003ca href=\"https://kotlinlang.org/docs/reference/operator-overloading.html?ref=chrynan.codes\"\u003eOperator Overloading\u003c/a\u003e, which is to change the functioning of operators ( \u003ccode\u003e+\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, etc.) on different types. This feature was used in the above example with the Kotlin DSL Builder. In that example, the unary plus operator ( \u003ccode\u003e+item\u003c/code\u003e ) was overloaded to provide an alternative implementation in the context of the builder.\u003c/p\u003e\u003cp\u003eBy providing the ability to have custom classes be interacted with using language operators, Kotlin\u0026#39;s operator overloading can be useful in many scenarios. For instance, consider Kotlin\u0026#39;s experimental \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.time/-duration/index.html?ref=chrynan.codes\"\u003eDuration\u003c/a\u003e class. In the source code for the \u003ccode\u003eDuration\u003c/code\u003e class, they have an overloaded operator function to provide a convenient means of adding and subtracting multiple \u003ccode\u003eDurations\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic operator fun plus(other: Duration): Duration = Duration(value + other.value)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis allows the Kotlin Duration classes to be used in the following way:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval duration = 2.minutes + 30.seconds\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout this feature, getting at the same result would require either wrapping an existing plus operator, or creating a new function.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eJava-esque Operator\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Explicit constructor invocation around built-in operator support\nval duration = Duration(2.minutes.value + 30.seconds.value)\n\n// Custom function\nval otherDuration = 2.minutes.plus(30.seconds)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eClearly Operator Overloading provides better semantics than the above \u0026#34;Java-esque\u0026#34; approach.\u003c/p\u003e\u003ch3 id=\"infix-functions\"\u003eInfix Functions\u003c/h3\u003e\u003cp\u003eAnother interesting feature that Kotlin supports is an \u003ca href=\"https://kotlinlang.org/docs/reference/functions.html?ref=chrynan.codes\"\u003eInfix Function\u003c/a\u003e. These functions are capable of being invoked without explicitly using a period ( \u003ccode\u003e.\u003c/code\u003e ) or parentheses ( \u003ccode\u003e(\u003c/code\u003e or \u003ccode\u003e)\u003c/code\u003e). Let\u0026#39;s take a look at the \u003ccode\u003eto\u003c/code\u003e infix function in the Kotlin standard library that creates a \u003ccode\u003ePair\u003c/code\u003e out of two objects.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic infix fun \u0026lt;A, B\u0026gt; A.to(that: B): Pair\u0026lt;A, B\u0026gt; = Pair(this, that)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above infix function is particularly useful when constructing \u003ccode\u003eMaps\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003emapOf(\u0026#34;itemOne\u0026#34; to \u0026#34;valueOne\u0026#34;,\n      \u0026#34;itemTwo\u0026#34; to \u0026#34;valueTwo\u0026#34;,\n      \u0026#34;itemThree\u0026#34; to \u0026#34;valueThree\u0026#34;,\n      \u0026#34;itemFour\u0026#34; to \u0026#34;valueFour\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe invocation of infix functions reads more naturally by removing obvious glyphs and appearing more native to traditional spoken and written languages. Creative use of infix functions allows for elegant APIs. For instance, in my \u003ca href=\"https://github.com/chRyNaN/time?ref=chrynan.codes\"\u003etime\u003c/a\u003e library, I created an infix function called \u003ccode\u003eto\u003c/code\u003e on the \u003ccode\u003eMoment\u003c/code\u003e class that retrieves the \u003ccode\u003eDuration\u003c/code\u003e difference from the first \u003ccode\u003eMoment\u003c/code\u003e to another.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval duration = now to tomorrow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePerhaps, the function could have even been called \u003ccode\u003euntil\u003c/code\u003e, so that the function could read like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval duration = now until tomorrow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe possibilities are vast. However, one obvious caveat with the above infix function called \u003ccode\u003eto\u003c/code\u003e is that it conflicts with the Kotlin standard library \u003ccode\u003eto\u003c/code\u003e function mentioned earlier. So, you would have to be conscious of this and make sure to import the appropriate one (the compiler should alert you if you are expecting one type but get another).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eJava-esque Infix Function\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eJava has no direct equivalent to Kotlin\u0026#39;s infix functions, to my knowledge. So, a function would have to be written traditionally, which in some cases is not as elegant.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval duration = now.to(tomorrow)\n\n// Or\nval otherDuration = now.until(tomorrow)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"extension-functions\"\u003eExtension Functions\u003c/h3\u003e\u003cp\u003eKotlin provides the concept of \u003ca href=\"https://kotlinlang.org/docs/reference/extensions.html?ref=chrynan.codes\"\u003eextension\u003c/a\u003e functions and properties. This gives the ability to add functions and properties, scoped to an object, that are not existing in the original object\u0026#39;s code. Consider the Kotlin Coroutines \u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/?ref=chrynan.codes\"\u003eFlow\u003c/a\u003e interface, which represents a stream of data. This interface already has an extension function called \u003ccode\u003emap\u003c/code\u003e which transforms the data in the stream from one type to another. However, it often is the case that we would have a \u003ccode\u003eFlow\u0026lt;Collection\u0026lt;T\u0026gt;\u0026gt;\u003c/code\u003e and we need to map each value in the collection emitted by the \u003ccode\u003eFlow\u003c/code\u003e to another value and emit the entire collection of results. Since this function isn\u0026#39;t already provided in the library, we would have to manually create it. Using extension functions, it might look something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun \u0026lt;T, R\u0026gt; Flow\u0026lt;Collection\u0026lt;T\u0026gt;\u0026gt;.mapEach(block: suspend (T) -\u0026gt; R): Flow\u0026lt;List\u0026lt;R\u0026gt;\u0026gt; =\n    map { collection -\u0026gt; collection.map { item -\u0026gt; block(item) } }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich can be invoked like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eflowOf(listOf(1, 2, 3))\n    .mapEach { start + it }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat looks much cleaner and is much easier than having to handle the nested map redundantly in every call site:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Not as elegant\nflowOf(listOf(1, 2, 3))\n    .map { numbers -\u0026gt;\n        numbers.map { start + it }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eJava-esque Extension Functions\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eOnce again, Java has no direct equivalent to this Kotlin feature, as far as I know, so you would have to create a function in some other class to perform the same logic. This is typically done as a \u0026#34;static\u0026#34; function (\u0026#34;static\u0026#34; is in quotes because in Java it would be a static function but in Kotlin it would be a function on a companion object).\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eobject FlowUtils {\n\n    // Kotlin Anti-pattern\n    fun \u0026lt;T, R\u0026gt; mapEach(upstream: Flow\u0026lt;Collection\u0026lt;T\u0026gt;\u0026gt;, block: suspend (T) -\u0026gt; R): Flow\u0026lt;List\u0026lt;R\u0026gt;\u0026gt; =\n        // Note that the \u0026#34;map\u0026#34; function is also an extension function so if\n        // this wasn\u0026#39;t provided on the class and we couldn\u0026#39;t use extension\n        // functions then we would have to have a workaround for that as well\n        upstream.map { collection -\u0026gt;\n            collection.map { block(it) }\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich could be called like the following:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval flow = flowOf(listOf(1, 2, 3))\n\nFlowUtils.mapEach(flow, { start + it })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt should be obvious that the Kotlin extension function approach is much nicer.\u003c/p\u003e\u003ch3 id=\"package-level-and-object-values\"\u003ePackage Level and Object Values\u003c/h3\u003e\u003cp\u003eThis one is more nuanced because the usage depends on the particular scenario, and there are subjective proponents of both methods, but just the mere fact that Kotlin provides the ability for both approachs gives it the upper hand.\u003c/p\u003e\u003cp\u003eFunctions and properties can be on a singleton Kotlin \u003ccode\u003eobject\u003c/code\u003e or at the package level (meaning that it can be used without a static modifier or class instance). These are useful for utility functions and values. Though the more \u0026#34;Java-esque\u0026#34; approach is to use a singleton Kotlin \u003ccode\u003eobject\u003c/code\u003e which is reminiscent of Java static fields and methods.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eObject Approach\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eobject TimeUtils {\n\n    const val MILLISECONDS_IN_SECONDS = 1_000\n    const val SECONDS_IN_MINUTE = 60\n    const val MINUTES_IN_HOUR = 60\n    const val HOURS_IN_DAY = 24\n    \n    // Wherever possible, I would advocate against having functions like these.\n    // In particular because it makes the ability to test and provide different\n    // implementations much more difficult.\n    fun durationFromMilliseconds(millis: Long) = millis.milliseconds\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the invocations would look like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval milliseconds = seconds * TimeUtils.MILLISECONDS_IN_SECONDS\n\nval duration = TimeUtils.durationFromMilliseconds(1000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePackage Level Approach\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst val MILLISECONDS_IN_SECONDS = 1_000\nconst val SECONDS_IN_MINUTE = 60\nconst val MINUTES_IN_HOUR = 60\nconst val HOURS_IN_DAY = 24\n\nfun durationFromMilliseconds(millis: Long) = millis.milliseconds\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhere the invocations would look like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval milliseconds = seconds * MILLISECONDS_IN_SECONDS\n\nval duration = durationFromMilliseconds(1000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe second approach (package level) looks more elegant in the call site but opponents would argue that it pollutes the global namespace. The first approach (object) looks more verbose but groups related information together. And it should be noted that the object approach can be used similar to the package level approach depending on how it is imported, but it does add some redundancy.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport com.chrynan.example.TimeUtils.MILLISECONDS_IN_SECONDS\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo which approach to go with is more nuanced and depends on the particular use case and some subjectivity. \u003c/p\u003e\u003ch3 id=\"recapitulate\"\u003eRecapitulate\u003c/h3\u003e\u003cp\u003eWe have gone through different Kotlin features which make code more concise and readable, and have illustrated their alternatives in a more antiquated \u0026#34;Java-esque\u0026#34; style to show the contrast between the different approaches. When designing public facing APIs and libraries, take into consideration Kotlin features that may provide a better design. This will bolster the API and provide a more eloquent syntax.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2020-02-25T01:01:48Z",
  "modifiedTime": "2020-02-25T01:35:33Z"
}
