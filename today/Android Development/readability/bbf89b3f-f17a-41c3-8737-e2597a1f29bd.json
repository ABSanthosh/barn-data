{
  "id": "bbf89b3f-f17a-41c3-8737-e2597a1f29bd",
  "title": "Kotlin Inject",
  "link": "https://chrynan.codes/kotlin-inject/",
  "description": "A new Kotlin multi-platform library for annotating common code that will be dependency injected.",
  "author": "Christopher Keenan",
  "published": "Thu, 09 Jan 2020 02:01:22 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "inject",
    "kotlin",
    "kotlin-library",
    "kotlin-multiplatform",
    "kotlin multiplatform",
    "dependency injection",
    "dependency-injection",
    "di",
    "annotations",
    "javax.inject"
  ],
  "byline": "Christopher Keenan",
  "length": 4051,
  "excerpt": "A new Kotlin multi-platform library for annotating common code that will be dependency injected.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "A new Kotlin multi-platform library for annotating common code that will be dependency injected. TL;DRInject is a new Kotlin multi-platform library that is a wrapper around the javax.inject annotations so that they can be used in Kotlin common code.I recently created a new Kotlin Multi-platform library called inject which is a simple wrapper around the javax.inject annotations. The reason for creating this library was to allow Kotlin common code to be dependency injected using dagger on the JVM.Dagger is a popular dependency injection library, used on Android and the JVM, which processes the javax.inject annotations to create a dependency graph during compile time. Though the library is often criticised for it's complexity and verbosity, it is one of the most performant solutions. And for this reason, is the most popular, especially on mobile environments. However, the downside is that this library is not available for Kotlin multi-platform code. There are other Kotlin dependency injection and service locator libraries, such as, Koin, locator (which I created), and Kodein. The latter of which is a Kotlin multi-platform solution. Though I like the syntax of those libraries, I still tend to favor dagger because of it's performance and my familiarity with it.Also, after pondering about it for awhile, I've come to the conclusion that dependency injection should be a platform specific concept. Each platform would be responsible for it's own dependency injection even when sharing common code.For instance, there may be an interface in the common code with a corresponding implementation in each of the platform modules. Therefore the dependency creation couldn't occur in the common module due to it not knowing about each of the platform's implementations. This could possibly be solved using Kotlin's expect and actual keywords, but there's only so far an abstraction can be made as each implementation may require different platform specific code. For example, Android relies heavily on the Context framework class. This class is used for everything from retrieving resources to switching screens. This class is needed for many different reasons on Android but doesn't have a direct counterpart on iOS. So, to avoid polluting the shared business logic in the common module with framework specific code, each platform module will handle their own dependency injection. Then why this library?Dependency injection using the dagger library requires constructors to be annotated with the javax.inject.Inject annotation. Though this is framework or platform specific code, the library needs annotations on the components it will inject so that the annotation processor can register the components and create the dependency graph (the Provides annotation could also be used but Inject is the more elegant and recommended approach). And since these annotations don't actually perform the dependency injection and just are metadata, I think it's fine to have them on Kotlin common code.Using the libraryThe library is provided through Github Packages. Provide the repository in your build.gradle file:repositories { maven { url = uri(\"https://maven.pkg.github.com/chrynan/inject\") } } Then provide the dependencies in your build.gradle file:dependencies { implementation(\"com.chrynan.inject:inject:VERSION\") } Refer to the releases page for the most recent version.Then you can use any of the available annotations. For example:class MyPresenter @Inject constructor() : Presenter { ... } The available annotations and interfaces are:InjectNamedQualifierScopeSingletonProviderConclusionThe new library I created, inject, allows you to annotate your Kotlin multi-platform common code with javax.inject annotations so that they can be processed in JVM platform modules to create a dependency graph.",
  "image": "https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n        \n\n        \n\n            \u003cp\u003eA new Kotlin multi-platform library for annotating common code that will be dependency injected.\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=300 300w,\n                            https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=600 600w,\n                            https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=1000 1000w,\n                            https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://images.unsplash.com/photo-1538333702852-c1b7a2a93001?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000\" alt=\"Kotlin Inject\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/div\u003e\u003csection\u003e\n        \u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003e\u003ca href=\"https://github.com/chRyNaN/inject?ref=chrynan.codes\"\u003eInject\u003c/a\u003e is a new Kotlin multi-platform library that is a wrapper around the \u003ccode\u003ejavax.inject\u003c/code\u003e annotations so that they can be used in Kotlin common code.\u003c/p\u003e\u003cp\u003eI recently created a new Kotlin Multi-platform library called \u003ca href=\"https://github.com/chRyNaN/inject?ref=chrynan.codes\"\u003einject\u003c/a\u003e which is a simple wrapper around the \u003ca href=\"https://search.maven.org/artifact/javax.inject/javax.inject/1/jar?ref=chrynan.codes\"\u003ejavax.inject\u003c/a\u003e annotations. The reason for creating this library was to allow Kotlin common code to be dependency injected using \u003ca href=\"https://github.com/google/dagger?ref=chrynan.codes\"\u003edagger\u003c/a\u003e on the JVM.\u003c/p\u003e\u003cp\u003eDagger is a popular dependency injection library, used on Android and the JVM, which processes the javax.inject annotations to create a dependency graph during compile time. Though the library is often criticised for it\u0026#39;s complexity and verbosity, it is one of the most performant solutions. And for this reason, is the most popular, especially on mobile environments. However, the downside is that this library is not available for Kotlin multi-platform code. \u003c/p\u003e\u003cp\u003eThere are other Kotlin dependency injection and service locator libraries, such as, \u003ca href=\"https://github.com/InsertKoinIO/koin?ref=chrynan.codes\"\u003eKoin\u003c/a\u003e, \u003ca href=\"https://github.com/chRyNaN/locator?ref=chrynan.codes\"\u003elocator\u003c/a\u003e (which I created), and \u003ca href=\"https://github.com/Kodein-Framework/Kodein-DI/?ref=chrynan.codes\"\u003eKodein\u003c/a\u003e. The latter of which is a Kotlin multi-platform solution. Though I like the syntax of those libraries, I still tend to favor dagger because of it\u0026#39;s performance and my familiarity with it.\u003c/p\u003e\u003cp\u003eAlso, after pondering about it for awhile, I\u0026#39;ve come to the conclusion that dependency injection should be a platform specific concept. Each platform would be responsible for it\u0026#39;s own dependency injection even when sharing common code.\u003c/p\u003e\u003cp\u003eFor instance, there may be an interface in the common code with a corresponding implementation in each of the platform modules. Therefore the dependency creation couldn\u0026#39;t occur in the common module due to it not knowing about each of the platform\u0026#39;s implementations. This could possibly be solved using Kotlin\u0026#39;s \u003ccode\u003eexpect\u003c/code\u003e and \u003ccode\u003eactual\u003c/code\u003e keywords, but there\u0026#39;s only so far an abstraction can be made as each implementation may require different platform specific code. For example, Android relies heavily on the \u003ccode\u003eContext\u003c/code\u003e framework class. This class is used for everything from retrieving resources to switching screens. This class is needed for many different reasons on Android but doesn\u0026#39;t have a direct counterpart on iOS. \u003c/p\u003e\u003cp\u003eSo, to avoid polluting the shared business logic in the common module with framework specific code, each platform module will handle their own dependency injection. \u003c/p\u003e\u003ch3 id=\"then-why-this-library\"\u003eThen why this library?\u003c/h3\u003e\u003cp\u003eDependency injection using the dagger library requires constructors to be annotated with the \u003ccode\u003ejavax.inject.Inject\u003c/code\u003e annotation. Though this is framework or platform specific code, the library needs annotations on the components it will inject so that the annotation processor can register the components and create the dependency graph (the \u003ccode\u003eProvides\u003c/code\u003e annotation could also be used but \u003ccode\u003eInject\u003c/code\u003e is the more elegant and recommended approach). And since these annotations don\u0026#39;t actually perform the dependency injection and just are metadata, I think it\u0026#39;s fine to have them on Kotlin common code.\u003c/p\u003e\u003ch3 id=\"using-the-library\"\u003eUsing the library\u003c/h3\u003e\u003cp\u003eThe library is provided through \u003ca href=\"https://github.com/chRyNaN/inject/packages?ref=chrynan.codes\"\u003eGithub Packages\u003c/a\u003e. Provide the repository in your \u003ccode\u003ebuild.gradle\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003erepositories {\n    maven {\n        url = uri(\u0026#34;https://maven.pkg.github.com/chrynan/inject\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen provide the dependencies in your \u003ccode\u003ebuild.gradle\u003c/code\u003e file:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edependencies {\n    implementation(\u0026#34;com.chrynan.inject:inject:VERSION\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRefer to the \u003ca href=\"https://github.com/chRyNaN/inject/releases?ref=chrynan.codes\"\u003ereleases page\u003c/a\u003e for the most recent version.\u003c/p\u003e\u003cp\u003eThen you can use any of the available annotations. For example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MyPresenter @Inject constructor() : Presenter { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe available annotations and interfaces are:\u003c/p\u003e\u003cul\u003e\u003cli\u003eInject\u003c/li\u003e\u003cli\u003eNamed\u003c/li\u003e\u003cli\u003eQualifier\u003c/li\u003e\u003cli\u003eScope\u003c/li\u003e\u003cli\u003eSingleton\u003c/li\u003e\u003cli\u003eProvider\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\u003cp\u003eThe new library I created, \u003ca href=\"https://github.com/chRyNaN/inject?ref=chrynan.codes\"\u003einject\u003c/a\u003e, allows you to annotate your Kotlin multi-platform common code with \u003ccode\u003ejavax.inject\u003c/code\u003e annotations so that they can be processed in JVM platform modules to create a dependency graph.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2020-01-09T02:01:22Z",
  "modifiedTime": "2020-01-09T02:12:35Z"
}
