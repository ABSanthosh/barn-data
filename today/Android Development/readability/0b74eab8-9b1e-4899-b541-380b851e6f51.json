{
  "id": "0b74eab8-9b1e-4899-b541-380b851e6f51",
  "title": "Using jlink to cross-compile minimal JREs",
  "link": "https://jakewharton.com/using-jlink-to-cross-compile-minimal-jres/",
  "description": "",
  "author": "",
  "published": "2023-01-16T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 3917,
  "excerpt": "16 January 2023",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Using jlink to cross-compile minimal JREs 16 January 2023 jlink is a JDK tool to create bespoke, minimal JREs for your applications. Let’s try it with a “Hello, world!” program: class Main { public static void main(String... args) { System.out.println(\"Hello, world!\"); } } My laptop is an M1 Mac and I have downloaded the Azul Zulu JDK 19 build for it. With the JDK I can both compile Java and then run the resulting program. $ mkdir out $ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/javac -d out in/Main.java $ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/java -cp out Main Hello, world! Azul Zulu also provides a JRE that I can use to run compiled programs. $ zulu19.30.11-ca-jre19.0.1-macosx_aarch64/bin/java -cp out Main Hello, world! Note the slight change in folder name (“jdk” → “jre”). If we were shipping this to end-users it would be an easy win for binary size. $ du -hs zulu* 329M zulu19.30.11-ca-jdk19.0.1-macosx_aarch64 136M zulu19.30.11-ca-jre19.0.1-macosx_aarch64 But 136MiB just for “Hello, world”? Don’t tell Reddit or Hacker News! Thankfully, jlink is here to help us build a minimal JRE with only what we need. Given our program, a sibling tool, jdeps, lists the Java modules which are required. $ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jdeps \\ --print-module-deps \\ out/Main.class java.base Our program is so simple that it only needs the “base” module. Now with jlink we can produce a minimal JRE. $ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \\ --compress 2 \\ --strip-debug \\ --no-header-files \\ --no-man-pages \\ --output zulu-hello-jre \\ --add-modules java.base $ du -hs zulu* 28M zulu-hello-jre 329M zulu19.30.11-ca-jdk19.0.1-macosx_aarch64 136M zulu19.30.11-ca-jre19.0.1-macosx_aarch64 28MiB won’t win any language wars, but it’s a massive 80% savings over the full JRE. $ zulu-hello-jre/bin/java -cp out Main Hello, world! We can ship it to our client and call it a day, right? $ tar -czf hello.tgz zulu-hello-jre out $ scp hello.tgz jw@server: hello.tgz 100% 14MB 2.0MB/s 00:07 $ ssh jw@server \"tar xzf hello.tgz \u0026\u0026 zulu-hello-jre/bin/java -cp out Main\" bash: zulu-hello-jre/bin/java: cannot execute binary file: Exec format error Nope! While the Java bytecode we compiled is platform independent, the JRE is specific to each platform and my server runs Linux x64. Thankfully, jlink can operate on JDKs for different platforms. Let’s download the Linux x64 JDK and point jlink at its Java modules using --module-path. $ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \\ --compress 2 \\ --strip-debug \\ --no-header-files \\ --no-man-pages \\ --output zulu-hello-jre-linux-x64 \\ --module-path zulu19.30.11-ca-jdk19.0.1-linux_x64/jmods --add-modules java.base $ du -hs zulu* 28M zulu-hello-jre 36M zulu-hello-jre-linux-x64 338M zulu19.30.11-ca-jdk19.0.1-linux_x64 329M zulu19.30.11-ca-jdk19.0.1-macosx_aarch64 136M zulu19.30.11-ca-jre19.0.1-macosx_aarch64 The Linux x64 JRE is a little larger than the one for my ARM Mac, but it’s still small compared to the full-size JRE. Does it work on the client? $ tar -czf hello-linux.tgz zulu-hello-jre-linux-x64 out $ scp hello-linux.tgz jw@server: hello.tgz 100% 16MB 2.1MB/s 00:08 $ ssh jw@server \"tar xzf hello-linux.tgz \u0026\u0026 zulu-hello-jre-linux-x64/bin/java -cp out Main\" Hello, world! It works! Now we can grab JDKs for any architecture for any platform and use our host jlink to effectively cross-compile minimal JREs for each target. This is a great solution for multi-architecture Docker containers, desktop clients like JetBrains Compose UI, shipping to devices where you can’t fit a full JDK, and more. Be sure to explore all the options on jdeps and jlink for ways to keep your runtimes small. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eUsing jlink to cross-compile minimal JREs\u003c/h2\u003e\n      \u003cp\u003e16 January 2023\u003c/p\u003e\n\n      \u003cp\u003e\u003ccode\u003ejlink\u003c/code\u003e is a JDK tool to create bespoke, minimal JREs for your applications.\nLet’s try it with a “Hello, world!” program:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMain\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e \u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eSystem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eMy laptop is an M1 Mac and I have downloaded the Azul Zulu JDK 19 build for it.\nWith the JDK I can both compile Java and then run the resulting program.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ mkdir out\n$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/javac -d out in/Main.java\n$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/java -cp out Main\nHello, world!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAzul Zulu also provides a JRE that I can use to run compiled programs.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ zulu19.30.11-ca-jre19.0.1-macosx_aarch64/bin/java -cp out Main\nHello, world!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNote the slight change in folder name (“jdk” → “jre”).\u003c/p\u003e\n\n\u003cp\u003eIf we were shipping this to end-users it would be an easy win for binary size.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ du -hs zulu*\n329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64\n136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBut 136MiB just for “Hello, world”? Don’t tell Reddit or Hacker News!\u003c/p\u003e\n\n\u003cp\u003eThankfully, \u003ccode\u003ejlink\u003c/code\u003e is here to help us build a minimal JRE with only what we need.\nGiven our program, a sibling tool, \u003ccode\u003ejdeps\u003c/code\u003e, lists the Java modules which are required.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jdeps \\\n      --print-module-deps \\\n      out/Main.class\njava.base\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eOur program is so simple that it only needs the “base” module.\nNow with \u003ccode\u003ejlink\u003c/code\u003e we can produce a minimal JRE.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \\\n      --compress 2 \\\n      --strip-debug \\\n      --no-header-files \\\n      --no-man-pages \\\n      --output zulu-hello-jre \\\n      --add-modules java.base\n\n$ du -hs zulu*\n 28M    zulu-hello-jre\n329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64\n136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e28MiB won’t win any language wars, but it’s a massive 80% savings over the full JRE.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ zulu-hello-jre/bin/java -cp out Main\nHello, world!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe can ship it to our client and call it a day, right?\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ tar -czf hello.tgz zulu-hello-jre out\n\n$ scp hello.tgz jw@server:\nhello.tgz            100%   14MB   2.0MB/s   00:07\n\n$ ssh jw@server \u0026#34;tar xzf hello.tgz \u0026amp;\u0026amp; zulu-hello-jre/bin/java -cp out Main\u0026#34;\nbash: zulu-hello-jre/bin/java: cannot execute binary file: Exec format error\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNope!\nWhile the Java bytecode we compiled is platform independent, the JRE is specific to each platform and my server runs Linux x64.\u003c/p\u003e\n\n\u003cp\u003eThankfully, \u003ccode\u003ejlink\u003c/code\u003e can operate on JDKs for different platforms.\nLet’s download the Linux x64 JDK and point \u003ccode\u003ejlink\u003c/code\u003e at its Java modules using \u003ccode\u003e--module-path\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ zulu19.30.11-ca-jdk19.0.1-macosx_aarch64/bin/jlink \\\n      --compress 2 \\\n      --strip-debug \\\n      --no-header-files \\\n      --no-man-pages \\\n      --output zulu-hello-jre-linux-x64 \\\n      --module-path zulu19.30.11-ca-jdk19.0.1-linux_x64/jmods\n      --add-modules java.base\n\n$ du -hs zulu*\n 28M    zulu-hello-jre\n 36M    zulu-hello-jre-linux-x64\n338M    zulu19.30.11-ca-jdk19.0.1-linux_x64\n329M    zulu19.30.11-ca-jdk19.0.1-macosx_aarch64\n136M    zulu19.30.11-ca-jre19.0.1-macosx_aarch64\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe Linux x64 JRE is a little larger than the one for my ARM Mac, but it’s still small compared to the full-size JRE.\nDoes it work on the client?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ tar -czf hello-linux.tgz zulu-hello-jre-linux-x64 out\n\n$ scp hello-linux.tgz jw@server:\nhello.tgz            100%   16MB   2.1MB/s   00:08\n\n$ ssh jw@server \u0026#34;tar xzf hello-linux.tgz \u0026amp;\u0026amp; zulu-hello-jre-linux-x64/bin/java -cp out Main\u0026#34;\nHello, world!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt works! Now we can grab JDKs for any architecture for any platform and use our host \u003ccode\u003ejlink\u003c/code\u003e to effectively cross-compile minimal JREs for each target.\u003c/p\u003e\n\n\u003cp\u003eThis is a great solution for multi-architecture Docker containers, desktop clients like JetBrains Compose UI, shipping to devices where you can’t fit a full JDK, and more.\nBe sure to explore all the options on \u003ccode\u003ejdeps\u003c/code\u003e and \u003ccode\u003ejlink\u003c/code\u003e for ways to keep your runtimes small.\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2023-01-16T00:00:00Z",
  "modifiedTime": null
}
