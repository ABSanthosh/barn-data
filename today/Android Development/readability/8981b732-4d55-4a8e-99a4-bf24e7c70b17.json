{
  "id": "8981b732-4d55-4a8e-99a4-bf24e7c70b17",
  "title": "What's new in CameraX 1.4.0 and a sneak peek of Jetpack Compose support",
  "link": "http://android-developers.googleblog.com/2024/12/whats-new-in-camerax-140-and-jetpack-compose-support.html",
  "description": "",
  "author": "Android Developers",
  "published": "2024-12-17T12:00:00.001-08:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "Android Camera",
    "Camera Extensions",
    "CameraX",
    "CameraX Effect",
    "CameraX Extensions",
    "HDR",
    "Jetpack Compose",
    "Media3 Effect",
    "Mirror Mode",
    "Night Mode",
    "OverlayEffect",
    "postview",
    "Preview Stabilization",
    "Screen Flash",
    "Ultra HDR"
  ],
  "byline": "",
  "length": 15099,
  "excerpt": "CameraX 1.4.0 is now available, with features like expanded HDR capabilities, preview stabilization, and a versatile effect framework.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Scott Nien – Software Engineer (scottnien@) Get ready to level up your Android camera apps! CameraX 1.4.0 just dropped with a load of awesome new features and improvements. We're talking expanded HDR capabilities, preview stabilization and the versatile effect framework, and a whole lot of cool stuff to explore. We will also explore how to seamlessly integrate CameraX with Jetpack Compose! Let's dive in and see how these enhancements can take your camera app to the next level. HDR preview and Ultra HDR High Dynamic Range (HDR) is a game-changer for photography, capturing a wider range of light and detail to create stunningly realistic images. With CameraX 1.3.0, we brought you HDR video recording capabilities, and now in 1.4.0, we're taking it even further! Get ready for HDR Preview and Ultra HDR. These exciting additions empower you to deliver an even richer visual experience to your users. HDR Preview This new feature allows you to enable HDR on Preview without needing to bind a VideoCapture use case. This is especially useful for apps that use a single preview stream for both showing preview on display and video recording with an OpenGL pipeline. To fully enable the HDR, you need to ensure your OpenGL pipeline is capable of processing the specific dynamic range format and then check the camera capability. See following code snippet as an example to enable HLG10 which is the baseline HDR standard that device makers must support on cameras with 10-bit output. // Declare your OpenGL pipeline supported dynamic range format. val openGLPipelineSupportedDynamicRange = setOf( DynamicRange.SDR, DynamicRange.HLG_10_BIT ) // Check camera dynamic range capabilities. val isHlg10Supported = cameraProvider.getCameraInfo(cameraSelector) .querySupportedDynamicRanges(openGLPipelineSupportedDynamicRange) .contains(DynamicRange.HLG_10_BIT) val preview = Preview.Builder().apply { if (isHlg10Supported) { setDynamicRange(DynamicRange.HLG_10_BIT) } } Ultra HDR Introducing Ultra HDR, a new format in Android 14 that lets users capture stunningly realistic photos with incredible dynamic range. And the best part? CameraX 1.4.0 makes it incredibly easy to add Ultra HDR capture to your app with just a few lines of code: val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA val cameraInfo = cameraProvider.getCameraInfo(cameraSelector) val isUltraHdrSupported = ImageCapture.getImageCaptureCapabilities(cameraInfo) .supportedOutputFormats .contains(ImageCapture.OUTPUT_FORMAT_JPEG_ULTRA_HDR) val imageCapture = ImageCapture.Builder().apply { if (isUltraHdrSupported) { setOutputFormat(ImageCapture.OUTPUT_FORMAT_JPEG_ULTRA_HDR) } }.build() Jetpack Compose support While this post focuses on 1.4.0, we're excited to announce the Jetpack Compose support in CameraX 1.5.0 alpha. We’re adding support for a Composable Viewfinder built on top of AndroidExternalSurface and AndroidEmbeddedExternalSurface. The CameraXViewfinder Composable hooks up a display surface to a CameraX Preview use case, handling the complexities of rotation, scaling and Surface lifecycle so you don’t need to. // in build.gradle implementation (\"androidx.camera:camera-compose:1.5.0-alpha03\") class PreviewViewModel : ViewModel() { private val _surfaceRequests = MutableStateFlow\u003cSurfaceRequest?\u003e(null) val surfaceRequests: StateFlow\u003cSurfaceRequest?\u003e get() = _surfaceRequests.asStateFlow() private fun produceSurfaceRequests(previewUseCase: Preview) { // Always publish new SurfaceRequests from Preview previewUseCase.setSurfaceProvider { newSurfaceRequest -\u003e _surfaceRequests.value = newSurfaceRequest } } // ... } @Composable fun MyCameraViewfinder( viewModel: PreviewViewModel, modifier: Modifier = Modifier ) { val currentSurfaceRequest: SurfaceRequest? by viewModel.surfaceRequests.collectAsState() currentSurfaceRequest?.let { surfaceRequest -\u003e CameraXViewfinder( surfaceRequest = surfaceRequest, implementationMode = ImplementationMode.EXTERNAL, // Or EMBEDDED modifier = modifier ) } } Kotlin-friendly APIs CameraX is getting even more Kotlin-friendly! In 1.4.0, we've introduced two new suspend functions to streamline camera initialization and image capture. // CameraX initialization val cameraProvider = ProcessCameraProvider.awaitInstance() val imageProxy = imageCapture.takePicture() // Processing imageProxy imageProxy.close() Preview Stabilization and Mirror mode Preview Stabilization Preview stabilization mode was added in Android 13 to enable the stabilization on all non-RAW streams, including previews and MediaCodec input surfaces. Compared to the previous video stabilization mode, which may have inconsistent FoV (Field of View) between the preview and recorded video, this new preview stabilization mode ensures consistency and thus provides a better user experience. For apps that record the preview directly for video recording, this mode is also the only way to enable stabilization. Follow the code below to enable preview stabilization. Please note that once preview stabilization is turned on, it is not only applied to the Preview but also to the VideoCapture if it is bound as well. val isPreviewStabilizationSupported = Preview.getPreviewCapabilities(cameraProvider.getCameraInfo(cameraSelector)) .isStabilizationSupported val preview = Preview.Builder().apply { if (isPreviewStabilizationSupported) { setPreviewStabilizationEnabled(true) } }.build() MirrorMode While CameraX 1.3.0 introduced mirror mode for VideoCapture, we've now brought this handy feature to Preview in 1.4.0. This is especially useful for devices with outer displays, allowing you to create a more natural selfie experience when using the rear camera. To enable the mirror mode, simply call Preview.Builder.setMirrorMode APIs. This feature is supported for Android 13 and above. Real-time Effect CameraX 1.3.0 introduced the CameraEffect framework, giving you the power to customize your camera output with OpenGL. Now, in 1.4.0, we're taking it a step further. In addition to applying your own custom effects, you can now leverage a set of pre-built effects provided by CameraX and Media3, making it easier than ever to enhance your app's camera features. Overlay Effect The new camera-effects artifact aims to provide ready-to-use effect implementations, starting with the OverlayEffect. This effect lets you draw overlays on top of camera frames using the familiar Canvas API. The following sample code shows how to detect the QR code and draw the shape of the QR code once it is detected. By default, drawing is performed in surface frame coordinates. But what if you need to use camera sensor coordinates? No problem! OverlayEffect provides the Frame#getSensorToBufferTransform function, allowing you to apply the necessary transformation matrix to your overlayCanvas. In this example, we use CameraX's MLKit Vision APIs (MlKitAnalyzer) and specify COORDINATE_SYSTEM_SENSOR to obtain QR code corner points in sensor coordinates. This ensures accurate overlay placement regardless of device orientation or screen aspect ratio. // in build.gradle implementation (\"androidx.camera:camera-effects:1.4.1}\") implementation (\"androidx.camera:camera-mlkit-vision:1.4.1\") var qrcodePoints: Array\u003cPoint\u003e? = null val qrcodeBoxEffect = OverlayEffect( PREVIEW /* applied on the preview only */, 0, /* queueDepth */, Handler(Looper.getMainLooper()), {} ) fun initCamera() { qrcodeBoxEffect.setOnDrawListener { frame -\u003e frame.overlayCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR) qrcodePoints?.let { // Using sensor coordinates to draw. frame.overlayCanvas.setMatrix(frame.sensorToBufferTransform) val path = android.graphics.Path().apply { it.forEachIndexed { index, point -\u003e if (index == 0) { moveTo(point.x.toFloat(), point.y.toFloat()) } else { lineTo(point.x.toFloat(), point.y.toFloat()) } } lineTo(it[0].x.toFloat(), it[0].y.toFloat()) } frame.overlayCanvas.drawPath(path, paint) } true } val imageAnalysis = ImageAnalysis.Builder() .build() .apply { setAnalyzer(executor, MlKitAnalyzer( listOf(barcodeScanner!!), COORDINATE_SYSTEM_SENSOR, executor ) { result -\u003e val barcodes = result.getValue(barcodeScanner!!) qrcodePoints = barcodes?.takeIf { it.size \u003e 0}?.get(0)?.cornerPoints } ) } val useCaseGroup = UseCaseGroup.Builder() .addUseCase(preview) .addUseCase(imageAnalysis) .addEffect(qrcodeBoxEffect) .build() cameraProvider.bindToLifecycle( lifecycleOwner, cameraSelector, usecaseGroup) } Media3 Effect Want to add stunning camera effects to your CameraX app? Now you can tap into the power of Media3's rich effects framework! This exciting integration allows you to apply Media3 effects to your CameraX output, including Preview, VideoCapture, and ImageCapture. This means you can easily enhance your app with a wide range of professional-grade effects, from blurs and color filters to transitions and more. To get started, simply use the new androidx.camera:media3:media3-effect artifact. Here's a quick example of how to apply a Gaussian blur to your camera output: // in build.gradle implementation (\"androidx.camera.media3:media3-effect:1.0.0-alpha01\") implementation (\"androidx.media3:media3-effect:1.5.0\") import androidx.camera.media3.effect.Media3Effect val media3Effect = Media3Effect( requireContext(), PREVIEW or VIDEO_CAPTURE or IMAGE_CAPTURE, mainThreadExecutor(), {} ) // use grayscale effect media3Effect.setEffects(listOf(RgbFilter.createGrayscaleFilter()) cameraController.setEffects(setOf(media3Effect)) // or using UseCaseGroup API Here is what the effect looks like: Screen Flash Taking selfies in low light just got easier with CameraX 1.4.0! This release introduces a powerful new feature: screen flash. Instead of relying on a traditional LED flash which most selfie cameras don’t have, screen flash cleverly utilizes your phone's display. By momentarily turning the screen bright white, it provides a burst of illumination that helps capture clear and vibrant selfies even in challenging lighting conditions. Integrating screen flash into your CameraX app is flexible and straightforward. You have two main options: 1. Implement the ScreenFlash interface: This gives you full control over the screen flash behavior. You can customize the color, intensity, duration, and any other aspect of the flash. This is ideal if you need a highly tailored solution. 2. Use the built-in implementation: For a quick and easy solution, leverage the pre-built screen flash functionality in ScreenFlashView or PreviewView. This implementation handles all the heavy lifting for you. If you're already using PreviewView in your app, enabling screen flash is incredibly simple. Just enable it directly on the PreviewView instance. If you need more control or aren't using PreviewView, you can use ScreenFlashView directly. Here's a code example demonstrating how to enable screen flash: // case 1: PreviewView + CameraX core API. previewView.setScreenFlashWindow(activity.getWindow()); imageCapture.screenFlash = previewView.screenFlash imageCapture.setFlashMode(ImageCapture.FLASH_MODE_SCREEN) // case 2: PreviewView + CameraController previewView.setScreenFlashWindow(activity.getWindow()); cameraController.setImageCaptureFlashMode(ImageCapture.FLASH_MODE_SCREEN); // case 3 : use ScreenFlashView screenFlashView.setScreenFlashWindow(activity.getWindow()); imageCapture.setScreenFlash(screenFlashView.getScreenFlash()); imageCapture.setFlashMode(ImageCapture.FLASH_MODE_SCREEN); Camera Extensions new features Camera Extensions APIs aim to help apps to access the cutting-edge capabilities previously available only on built-in camera apps. And the ecosystem is growing rapidly! In 2024, we've seen major players like Pixel, Samsung, Xiaomi, Oppo, OnePlus, Vivo, and Honor all embrace Camera Extensions, particularly for Night Mode and Bokeh Mode. CameraX 1.4.0 takes this even further by adding support for brand-new Android 15 Camera Extensions features, including: Postview: Provides a preview of the captured image almost instantly before the long-exposure shots are completed Capture Process Progress: Displays a progress indicator so users know how long capturing and processing will take, improving the experience for features like Night Mode Extensions Strength: Allows users to fine-tune the intensity of the applied effect Below is an example of the improved UX that uses postview and capture process progress features on Samsung S24 Ultra. Interested to know how this can be implemented? See the sample code below: val extensionsCameraSelector = extensionsManager .getExtensionEnabledCameraSelector(DEFAULT_BACK_CAMERA, extensionMode) val isPostviewSupported = ImageCapture.getImageCaptureCapabilities(     cameraProvider.getCameraInfo(extensionsCameraSelector) ).isPostviewSupported val imageCapture = ImageCapture.Builder().apply { setPostviewEnabled(isPostviewSupported) }.build() imageCapture.takePicture(outputfileOptions, executor, object : OnImageSavedCallback { override fun onImageSaved(outputFileResults: OutputFileResults) { // final image saved. } override fun onPostviewBitmapAvailable(bitmap: Bitmap) { // Postview bitmap is available. } override fun onCaptureProcessProgressed(progress: Int) { // capture process progress update } } Important: If your app ran into the CameraX Extensions issue on Pixel 9 series devices, please use CameraX 1.4.1 instead. This release fixes a critical issue that prevented Night Mode from working correctly with takePicture. What's Next We hope you enjoy this new release. Our mission is to make camera development a joy, removing the friction and pain points so you can focus on innovation. With CameraX, you can easily harness the power of Android's camera capabilities and build truly amazing app experiences. Have questions or want to connect with the CameraX team? Join the CameraX developer discussion group or file a bug report: CameraX developers discussion group File a bug We can’t wait to see what you create!",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEigeusOF9AySkwGgQw_ZPwUQnNXgh4lXVZsvahkJj_ulJBfDyjHuJh0KI80fR1rxY04IywD5rELnxOSsjWmA42uSd_IWUa79QPaK79PQF1C_kHRgqbBRV6Mk-4zxi6mino6coR6QaHL3kT27NiwUt1lbDvzzogHwp-V3MixukVhrQ21v5_nJW1UzNzYC_s/w1200-h630-p-k-no-nu/AndroidSpotlight_Adaptive_CameraX_Metadata_02.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEigeusOF9AySkwGgQw_ZPwUQnNXgh4lXVZsvahkJj_ulJBfDyjHuJh0KI80fR1rxY04IywD5rELnxOSsjWmA42uSd_IWUa79QPaK79PQF1C_kHRgqbBRV6Mk-4zxi6mino6coR6QaHL3kT27NiwUt1lbDvzzogHwp-V3MixukVhrQ21v5_nJW1UzNzYC_s/s1600/AndroidSpotlight_Adaptive_CameraX_Metadata_02.png\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by Scott Nien – Software Engineer (scottnien@)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eGet ready to level up your Android camera apps! CameraX 1.4.0 just dropped with a load of awesome new features and improvements. We\u0026#39;re talking expanded HDR capabilities, preview stabilization and the versatile effect framework, and a whole lot of cool stuff to explore. We will also explore how to seamlessly  integrate CameraX with Jetpack Compose! Let\u0026#39;s dive in and see how these enhancements can take your camera app to the next level.\u003c/p\u003e\n\n\n\u003ch2\u003e\u003cspan\u003eHDR preview and Ultra HDR\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003cimg alt=\"A split-screen image compares Standard Dynamic Range (SDR) and High Dynamic Range (HDR) image quality side-by-side using a singular image of a detailed landscape. The HDR side is more vivid and vibrant.\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgLNYJXd1Kk97dTXZe5M09aMs6gXCEr0DxDIazLXDJOIAvh2JbYnmklTDFFrFVkpqzjyxox8yL7EeYCNnXSxKFJHwbvtCCgEDwo8U1cg2KTJdNe34sldODOzK9JKixr7Dt4XHkoGYFCF6TBxVWGZO6oKM0WHktPHxVGXzlp6G0LhTWKS-5JMvb3m-JIeio/s1600/image3.png\" width=\"640\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eHigh Dynamic Range (HDR) is a game-changer for photography, capturing a wider range of light and detail to create stunningly realistic images.  With CameraX 1.3.0, we brought you HDR video recording capabilities, and now in 1.4.0, we\u0026#39;re taking it even further! Get ready for \u003cb\u003eHDR Preview\u003c/b\u003e and \u003cb\u003eUltra HDR\u003c/b\u003e. These exciting additions empower you to deliver an even richer visual experience to your users.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003eHDR Preview\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eThis new feature allows you to enable HDR on Preview without needing to bind a VideoCapture use case. This is especially useful for apps that use a single preview stream for both showing preview on display and video recording with an OpenGL pipeline.\u003c/p\u003e\n\n\u003cp\u003eTo fully enable the HDR,  you need to ensure your OpenGL pipeline is capable of processing the specific dynamic range format and then check the camera capability.\u003c/p\u003e\n\n\u003cp\u003eSee following code snippet as an example to enable HLG10 which is the baseline HDR standard that device makers must support on cameras with 10-bit output.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// Declare your OpenGL pipeline supported dynamic range format. \u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e openGLPipelineSupportedDynamicRange = setOf(\n     DynamicRange.SDR, \n     DynamicRange.HLG_10_BIT\n)\n\u003cspan\u003e// Check camera dynamic range capabilities. \u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e isHlg10Supported =  \n     cameraProvider.getCameraInfo(cameraSelector)\n           .querySupportedDynamicRanges(openGLPipelineSupportedDynamicRange)\n           .contains(DynamicRange.HLG_10_BIT)\n\n\u003cspan\u003eval\u003c/span\u003e preview = Preview.Builder().apply {\n     \u003cspan\u003eif\u003c/span\u003e (isHlg10Supported) {\n        setDynamicRange(DynamicRange.HLG_10_BIT)\n     }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003e\u003cspan\u003eUltra HDR\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eIntroducing Ultra HDR, a new format in Android 14 that lets users capture stunningly realistic photos with incredible dynamic range. And the best part? CameraX 1.4.0 makes it incredibly easy to add Ultra HDR capture to your app with just a few lines of code:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA\n\u003cspan\u003eval\u003c/span\u003e cameraInfo = cameraProvider.getCameraInfo(cameraSelector)\n\u003cspan\u003eval\u003c/span\u003e isUltraHdrSupported = \n      ImageCapture.getImageCaptureCapabilities(cameraInfo)\n                  .supportedOutputFormats\n                  .contains(ImageCapture.OUTPUT_FORMAT_JPEG_ULTRA_HDR)\n\n\u003cspan\u003eval\u003c/span\u003e imageCapture = ImageCapture.Builder().apply {\n    \u003cspan\u003eif\u003c/span\u003e (isUltraHdrSupported) {\n        setOutputFormat(ImageCapture.OUTPUT_FORMAT_JPEG_ULTRA_HDR)\n    }\n}.build()\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003e\u003cspan\u003eJetpack Compose support\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eWhile this post focuses on 1.4.0, we\u0026#39;re excited to announce the Jetpack Compose support in CameraX 1.5.0 alpha. We’re adding support for a Composable Viewfinder built on top of \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#AndroidExternalSurface%28androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.unit.IntSize,androidx.compose.foundation.AndroidExternalSurfaceZOrder,kotlin.Boolean,kotlin.Function1%29\" target=\"_blank\"\u003eAndroidExternalSurface\u003c/a\u003e\u003c/span\u003e and \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#AndroidEmbeddedExternalSurface%28androidx.compose.ui.Modifier,kotlin.Boolean,androidx.compose.ui.unit.IntSize,androidx.compose.ui.graphics.Matrix,kotlin.Function1%29\" target=\"_blank\"\u003eAndroidEmbeddedExternalSurface\u003c/a\u003e\u003c/span\u003e. The \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/camera/compose/package-summary#CameraXViewfinder%28androidx.camera.core.SurfaceRequest,androidx.compose.ui.Modifier,androidx.camera.viewfinder.surface.ImplementationMode,androidx.camera.viewfinder.compose.MutableCoordinateTransformer%29\" target=\"_blank\"\u003eCameraXViewfinder\u003c/a\u003e\u003c/span\u003e Composable hooks up a display surface to a CameraX Preview use case, handling the complexities of rotation, scaling and Surface lifecycle so you don’t need to.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// in build.gradle \u003c/span\u003e\nimplementation (\u003cspan\u003e\u0026#34;androidx.camera:camera-compose:1.5.0-alpha03\u0026#34;\u003c/span\u003e)\n\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePreviewViewModel\u003c/span\u003e : ViewModel() {\n    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e _surfaceRequests = MutableStateFlow\u0026lt;SurfaceRequest?\u0026gt;(\u003cspan\u003enull\u003c/span\u003e)\n\n    \u003cspan\u003eval\u003c/span\u003e surfaceRequests: StateFlow\u0026lt;SurfaceRequest?\u0026gt;\n        \u003cspan\u003eget\u003c/span\u003e() = _surfaceRequests.asStateFlow()\n\n    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eproduceSurfaceRequests\u003c/span\u003e(previewUseCase: Preview) {\n        \u003cspan\u003e// Always publish new SurfaceRequests from Preview\u003c/span\u003e\n        previewUseCase.setSurfaceProvider { newSurfaceRequest -\u0026gt;\n            _surfaceRequests.value = newSurfaceRequest\n        }\n    }\n\n    \u003cspan\u003e// ...\u003c/span\u003e\n}\n\n@Composable\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eMyCameraViewfinder\u003c/span\u003e(\n    viewModel: PreviewViewModel,\n    modifier: Modifier = Modifier\n) {\n    \u003cspan\u003eval\u003c/span\u003e currentSurfaceRequest: SurfaceRequest? by\n        viewModel.surfaceRequests.collectAsState()\n\n    currentSurfaceRequest?.let { surfaceRequest -\u0026gt;\n        CameraXViewfinder(\n            surfaceRequest = surfaceRequest,\n            implementationMode = ImplementationMode.EXTERNAL, \u003cspan\u003e// Or EMBEDDED\u003c/span\u003e\n            modifier = modifier        \n        )\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\n\u003ch3\u003e\u003cspan\u003eKotlin-friendly APIs\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eCameraX is getting even more Kotlin-friendly! In 1.4.0, we\u0026#39;ve introduced two new suspend functions to streamline camera initialization and image capture.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// CameraX initialization \u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e cameraProvider = ProcessCameraProvider.awaitInstance()\n\n\u003cspan\u003eval\u003c/span\u003e imageProxy = imageCapture.takePicture() \n\u003cspan\u003e// Processing imageProxy\u003c/span\u003e\nimageProxy.close()\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2\u003e\u003cspan\u003ePreview Stabilization and Mirror mode\u003c/span\u003e\u003c/h2\u003e \n\n\u003ch3\u003e\u003cspan\u003ePreview Stabilization\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://source.android.com/docs/core/camera/camera-preview-stabilization\" target=\"_blank\"\u003ePreview stabilization mode\u003c/a\u003e was added in Android 13 to enable the stabilization on all non-RAW streams, including previews and MediaCodec input surfaces. Compared to the previous \u003ca href=\"https://developer.android.com/reference/android/hardware/camera2/CameraMetadata#CONTROL_VIDEO_STABILIZATION_MODE_ON\" target=\"_blank\"\u003evideo stabilization mode\u003c/a\u003e, which may have inconsistent FoV (Field of View) between the preview and recorded video, this new preview stabilization mode ensures consistency and thus provides a better user experience.  For apps that record the preview directly for video recording, this mode is also the only way to enable stabilization.\u003c/p\u003e\n\n\u003cp\u003eFollow the code below to enable preview stabilization. Please note that once preview stabilization is turned on, it is not only applied to the Preview but also to the VideoCapture if it is bound as well.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e isPreviewStabilizationSupported =  \n    Preview.getPreviewCapabilities(cameraProvider.getCameraInfo(cameraSelector))\n        .isStabilizationSupported\n\u003cspan\u003eval\u003c/span\u003e preview = Preview.Builder().apply {\n    \u003cspan\u003eif\u003c/span\u003e (isPreviewStabilizationSupported) {\n      setPreviewStabilizationEnabled(\u003cspan\u003etrue\u003c/span\u003e)\n    }\n}.build()\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003e\u003cspan\u003eMirrorMode\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eWhile CameraX 1.3.0 introduced mirror mode for VideoCapture,  we\u0026#39;ve now brought this handy feature to Preview in 1.4.0. This is especially useful for devices with outer displays, allowing you to create a more natural selfie experience when using the rear camera.\u003c/p\u003e\n\n\u003cp\u003eTo enable the mirror mode, simply call \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/camera/core/Preview.Builder#setMirrorMode%28int%29\" target=\"_blank\"\u003ePreview.Builder.setMirrorMode\u003c/a\u003e\u003c/span\u003e APIs. This feature is supported for Android 13 and above.\u003c/p\u003e\n\n\u003ch2\u003e\u003cspan\u003eReal-time Effect\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eCameraX 1.3.0 introduced the CameraEffect framework, giving you the power to customize your camera output with OpenGL. Now, in 1.4.0, we\u0026#39;re taking it a step further.  In addition to applying your own custom effects, you can now leverage a set of pre-built effects provided by CameraX and Media3, making it easier than ever to enhance your app\u0026#39;s camera features.\u003c/p\u003e\n\n\u003ch3\u003e\u003cspan\u003eOverlay Effect\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eThe new camera-effects artifact aims to provide ready-to-use effect implementations, starting with the OverlayEffect. This effect lets you draw overlays on top of camera frames using the familiar \u003ca href=\"https://developer.android.com/reference/android/graphics/Canvas\" target=\"_blank\"\u003eCanvas API\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe following sample code shows how to detect the QR code and draw the shape of the QR code once it is detected.\u003c/p\u003e\n\n\u003cp\u003eBy default, drawing is performed in surface frame coordinates. But what if you need to use camera sensor coordinates? No problem! \u003cspan\u003eOverlayEffect\u003c/span\u003e provides the \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/camera/effects/Frame#getSensorToBufferTransform%28%29\" target=\"_blank\"\u003eFrame#getSensorToBufferTransform\u003c/a\u003e\u003c/span\u003e function, allowing you to apply the necessary transformation matrix to your overlayCanvas.\u003c/p\u003e\n\n\u003cp\u003eIn this example, we use CameraX\u0026#39;s MLKit Vision APIs (\u003cspan\u003eMlKitAnalyzer\u003c/span\u003e) and specify \u003cspan\u003eCOORDINATE_SYSTEM_SENSOR\u003c/span\u003e to obtain QR code corner points in sensor coordinates. This ensures accurate overlay placement regardless of device orientation or screen aspect ratio.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// in build.gradle \u003c/span\u003e\nimplementation (\u003cspan\u003e\u0026#34;androidx.camera:camera-effects:1.4.1}\u0026#34;\u003c/span\u003e)      \nimplementation (\u003cspan\u003e\u0026#34;androidx.camera:camera-mlkit-vision:1.4.1\u0026#34;\u003c/span\u003e)\n\n\u003cspan\u003evar\u003c/span\u003e qrcodePoints: Array\u0026lt;Point\u0026gt;? = \u003cspan\u003enull\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e qrcodeBoxEffect \n    = OverlayEffect(\n        PREVIEW \u003cspan\u003e/* applied on the preview only */\u003c/span\u003e,\n        \u003cspan\u003e0\u003c/span\u003e, \u003cspan\u003e/* queueDepth */\u003c/span\u003e, \n        Handler(Looper.getMainLooper()), {}\n      )\n\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003einitCamera\u003c/span\u003e() {\n    qrcodeBoxEffect.setOnDrawListener { frame -\u0026gt;\n        frame.overlayCanvas.drawColor(Color.TRANSPARENT, PorterDuff.Mode.CLEAR)\n        qrcodePoints?.let {\n            \u003cspan\u003e// Using sensor coordinates to draw.\u003c/span\u003e\n            frame.overlayCanvas.setMatrix(frame.sensorToBufferTransform)\n            \u003cspan\u003eval\u003c/span\u003e path = android.graphics.Path().apply {\n                it.forEachIndexed { index, point -\u0026gt;\n                    \u003cspan\u003eif\u003c/span\u003e (index == \u003cspan\u003e0\u003c/span\u003e) {\n                        moveTo(point.x.toFloat(), point.y.toFloat())\n                    } \u003cspan\u003eelse\u003c/span\u003e {\n                        lineTo(point.x.toFloat(), point.y.toFloat())\n                    }\n                 }\n                 lineTo(it[\u003cspan\u003e0\u003c/span\u003e].x.toFloat(), it[\u003cspan\u003e0\u003c/span\u003e].y.toFloat())\n            }\n            frame.overlayCanvas.drawPath(path, paint)\n        }\n        \u003cspan\u003etrue\u003c/span\u003e\n    }\n\n    \u003cspan\u003eval\u003c/span\u003e imageAnalysis = ImageAnalysis.Builder()\n        .build()\n        .apply {\n            setAnalyzer(executor,\n                MlKitAnalyzer(\n                    listOf(barcodeScanner!!),\n                    COORDINATE_SYSTEM_SENSOR,\n                    executor\n                ) { result -\u0026gt;\n                    \u003cspan\u003eval\u003c/span\u003e barcodes = result.getValue(barcodeScanner!!)\n                    qrcodePoints = \n                        barcodes?.takeIf { it.size \u0026gt; \u003cspan\u003e0\u003c/span\u003e}?.\u003cspan\u003eget\u003c/span\u003e(\u003cspan\u003e0\u003c/span\u003e)?.cornerPoints\n                }\n            )\n        }\n\n    \u003cspan\u003eval\u003c/span\u003e useCaseGroup = UseCaseGroup.Builder()\n          .addUseCase(preview)\n          .addUseCase(imageAnalysis)\n          .addEffect(qrcodeBoxEffect)\n          .build()\n\n    cameraProvider.bindToLifecycle(\n        lifecycleOwner, cameraSelector, usecaseGroup)\n  }\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003eMedia3 Effect\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eWant to add stunning camera effects to your CameraX app? Now you can tap into the power of Media3\u0026#39;s rich effects framework!  This exciting integration allows you to apply Media3 effects to your CameraX output, including Preview, VideoCapture, and ImageCapture.\u003c/p\u003e\n\n\u003cp\u003eThis means you can easily enhance your app with a wide range of professional-grade effects, from blurs and color filters to transitions and more.  To get started, simply use the new androidx.camera:media3:media3-effect artifact.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a quick example of how to apply a Gaussian blur to your camera output:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// in build.gradle \u003c/span\u003e\nimplementation (\u003cspan\u003e\u0026#34;androidx.camera.media3:media3-effect:1.0.0-alpha01\u0026#34;\u003c/span\u003e)\nimplementation (\u003cspan\u003e\u0026#34;androidx.media3:media3-effect:1.5.0\u0026#34;\u003c/span\u003e)\n\nimport androidx.camera.media3.effect.Media3Effect\n\u003cspan\u003eval\u003c/span\u003e media3Effect =\n            Media3Effect(\n                requireContext(),  PREVIEW or VIDEO_CAPTURE or IMAGE_CAPTURE,\n                mainThreadExecutor(), {}\n            )\n\u003cspan\u003e// use grayscale effect\u003c/span\u003e\nmedia3Effect.setEffects(listOf(RgbFilter.createGrayscaleFilter()) \ncameraController.setEffects(setOf(media3Effect)) \u003cspan\u003e// or using UseCaseGroup API\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\n\u003cp\u003eHere is what the effect looks like:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"A black and white view from inside a coffee shop looking out at a city street.  The bottom of the photo shows the edge of a table with a laptop and two buttons labeled \u0026#39;BACK\u0026#39; and \u0026#39;RECORD\u0026#39;\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgiBJ6m4-p4Wmh3sI2mhexJqVnSdHDiJ0ifoetK7ccdWWHdmWZgnjPx_IWd95TUx1NTMkokZnN9oZK1fd_rEk-M8KaEZ-LXzSkiQ5P2VtNUYrBRos-nA-dw0yQ0uMlbZVSKtHf9FdlkmvoDSK6Dpt4qIdP2oOtsYceiFrC8lWf0ZOU2BN4nxojG3wCbu5s/s1600/image1.png\" width=\"45%\"/\u003e\u003c/p\u003e\u003cbr/\u003e\n\n\n\n\u003ch2\u003e\u003cspan\u003eScreen Flash\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eTaking selfies in low light just got easier with CameraX 1.4.0! This release introduces a powerful new feature: screen flash.  Instead of relying on a traditional LED flash which most selfie cameras don’t have, screen flash cleverly utilizes your phone\u0026#39;s display. By momentarily turning the screen bright white, it provides a burst of illumination that helps capture clear and vibrant selfies even in challenging lighting conditions.\u003c/p\u003e\n\n\u003cp\u003eIntegrating screen flash into your CameraX app is flexible and straightforward. You have two main options:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n  \u003cp\u003e1. Implement the \u003cspan\u003eScreenFlash\u003c/span\u003e interface: This gives you full control over the screen flash behavior. You can customize the color, intensity, duration, and any other aspect of the flash. This is ideal if you need a highly tailored solution.\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e2. Use the built-in implementation: For a quick and easy solution, leverage the pre-built screen flash functionality in \u003cspan\u003eScreenFlashView\u003c/span\u003e or \u003cspan\u003ePreviewView\u003c/span\u003e. This implementation handles all the heavy lifting for you.\u003c/p\u003e\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eIf you\u0026#39;re already using \u003cspan\u003ePreviewView\u003c/span\u003e in your app, enabling screen flash is incredibly simple. Just enable it directly on the \u003cspan\u003ePreviewView\u003c/span\u003e instance. If you need more control or aren\u0026#39;t using \u003cspan\u003ePreviewView\u003c/span\u003e, you can use \u003cspan\u003eScreenFlashView\u003c/span\u003e directly.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a code example demonstrating how to enable screen flash:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// case 1: PreviewView + CameraX core API.\u003c/span\u003e\npreviewView.setScreenFlashWindow(activity.getWindow());\nimageCapture.screenFlash = previewView.screenFlash\nimageCapture.setFlashMode(ImageCapture.FLASH_MODE_SCREEN)\n\n\u003cspan\u003e// case 2: PreviewView + CameraController\u003c/span\u003e\npreviewView.setScreenFlashWindow(activity.getWindow());\ncameraController.setImageCaptureFlashMode(ImageCapture.FLASH_MODE_SCREEN);\n\n\u003cspan\u003e// case 3 : use ScreenFlashView \u003c/span\u003e\nscreenFlashView.setScreenFlashWindow(activity.getWindow());\nimageCapture.setScreenFlash(screenFlashView.getScreenFlash());\nimageCapture.setFlashMode(ImageCapture.FLASH_MODE_SCREEN);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch2\u003e\u003cspan\u003eCamera Extensions new features\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eCamera Extensions APIs aim to help apps to access the cutting-edge capabilities previously available only on built-in camera apps. And the ecosystem is growing rapidly! In 2024, we\u0026#39;ve seen major players like Pixel, Samsung, Xiaomi, Oppo, OnePlus, Vivo, and Honor all embrace Camera Extensions, particularly for Night Mode and Bokeh Mode. CameraX 1.4.0 takes this even further by adding support for brand-new Android 15 Camera Extensions features, including:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003ePostview:\u003c/b\u003e Provides a preview of the captured image almost instantly before the long-exposure shots are completed\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003eCapture Process Progress:\u003c/b\u003e Displays a progress indicator so users know how long capturing and processing will take, improving the experience for features like Night Mode\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cb\u003eExtensions Strength:\u003c/b\u003e Allows users to fine-tune the intensity of the applied effect\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eBelow is an example of the improved UX that uses postview and capture process progress features on Samsung S24 Ultra.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"moving image capturing process progress features on Samsung S24 Ultra\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQQbOgL1fhJBA4nL-eO4dhqbA1POcGQImYsAGg6N1F3iFNLD3F2yQyBKaWUxS0yOv5ycc46h4bndnMmwX10KP1ZMk3L6PS_WWTDK_EPRAOQub4G_ssZarclyqvXbllKS5htzF2QEv4uQtdNyvXsbgma7_ZkezDKTk98-rE6Jz0HHiuBM-trnlsLqp0gV8/s1600/image2.gif\" width=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eInterested to know how this can be implemented? See the sample code below:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e extensionsCameraSelector =  \n    extensionsManager\n        .getExtensionEnabledCameraSelector(DEFAULT_BACK_CAMERA, extensionMode)\n\u003cspan\u003eval\u003c/span\u003e isPostviewSupported = ImageCapture.getImageCaptureCapabilities(                   \n\u003cspan\u003e    \u003c/span\u003ecameraProvider.getCameraInfo(extensionsCameraSelector)\n).isPostviewSupported\n\u003cspan\u003eval\u003c/span\u003e imageCapture = ImageCapture.Builder().apply {\n    setPostviewEnabled(isPostviewSupported)\n}.build()\n\nimageCapture.takePicture(outputfileOptions, executor,  \n    object : OnImageSavedCallback {\n        \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonImageSaved\u003c/span\u003e(outputFileResults: OutputFileResults) {\n            \u003cspan\u003e// final image saved. \u003c/span\u003e\n        }\n        \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonPostviewBitmapAvailable\u003c/span\u003e(bitmap: Bitmap) {\n            \u003cspan\u003e// Postview bitmap is available.\u003c/span\u003e\n        }\n        \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonCaptureProcessProgressed\u003c/span\u003e(progress: Int) {\n            \u003cspan\u003e// capture process progress update \u003c/span\u003e\n        }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cblockquote\u003e\u003cb\u003eImportant:\u003c/b\u003e If your app ran into the CameraX Extensions issue on Pixel 9 series devices, please use CameraX 1.4.1 instead. This release fixes a critical issue that prevented Night Mode from working correctly with \u003cspan\u003etakePicture\u003c/span\u003e.\u003c/blockquote\u003e\n\n\u003ch3\u003eWhat\u0026#39;s Next\u003c/h3\u003e\n\n\u003cp\u003eWe hope you enjoy this new release. Our mission is to make camera development a joy, removing the friction and pain points so you can focus on innovation. With CameraX, you can easily harness the power of Android\u0026#39;s camera capabilities and build truly amazing app experiences.\u003c/p\u003e\n\n\u003cp\u003eHave questions or want to connect with the CameraX team? Join the CameraX developer discussion group or file a bug report:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://groups.google.com/a/android.com/g/camerax-developers\" target=\"_blank\"\u003eCameraX developers discussion group\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://issuetracker.google.com/issues/new?component=618491\u0026amp;template=1257717\u0026amp;hl=zh-tw\" target=\"_blank\"\u003eFile a bug\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eWe can’t wait to see what you create!\u003c/p\u003e\n\n\n\n\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
