{
  "id": "35ed67eb-dbee-4b22-9cc7-8005709e2228",
  "title": "Faking Network Responses with MockK (Featuring Ktor)",
  "link": "https://proandroiddev.com/faking-network-responses-with-mockk-featuring-ktor-5e5dc11dc95f?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Tue, 21 Jan 2025 07:09:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "androiddev",
    "android-app-development",
    "mobile-app-development",
    "mockk"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 15643,
  "excerpt": "A practical guide to mocking network responses in Kotlin. Make your tests faster and more reliable using MockK, with real-world examples",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "IntroductionWhen you’re building an Android app — or even a cross-platform Kotlin Multiplatform (KMM) project — that relies on network calls, things can get slow and unreliable if you’re always calling a real server — especially during testing.By combining MockK, Koin, and Ktor, you can “fake” your network responses, so your tests and development stay smooth and reliable — even when offline.Note: Although we use Ktor in this article (because it’s Kotlin-friendly and perfect for KMM), the MockK + Koin approach easily applies to any networking library — such as OkHttp, Retrofit, or others. As long as you wrap your network calls in an interface (like ApiService), you can swap in a mock or a real implementation as needed.Enter MockKMockK is a Kotlin-first mocking library that offers:Native Kotlin support: Ideal for projects using coroutines or advanced Kotlin features.Clear syntax: every { ... } returns ... to define how mocks respond, and verify/coVerify to confirm calls.Flexible options: Like “relaxed” mocks to reduce boilerplate, and coVerify for suspend functions.Because MockK is pure Kotlin, it often feels more natural than Java-oriented libraries — especially on modern Android and KMM projects.Why Ktor?Ktor is a Kotlin-native framework for building and consuming HTTP APIs. It works on the JVM, Android, iOS (via Kotlin/Native), and more. In Android apps, you might use it as your HTTP client, but in KMM projects, you can share this network logic across multiple platforms:Pure Kotlin: Suits KMM perfectly — no platform-specific bridging for networking.Lightweight \u0026 Composable: Configure pipeline features like logging, JSON parsing, and timeouts.Multiplatform: Same code for Android, iOS, desktop, or server-based projects.When using MockK to fake Ktor responses, you effectively short-circuit real network requests, returning data as if Ktor had made the call — without hitting an actual server. This synergy is what makes your tests fast, reliable, and easy to maintain in both Android and KMM environments.Mockito vs MockKHistorically, Mockito has been the go-to solution for Java-based mocking, and it can work in Kotlin with some additional steps (like enabling inline mocking or adding Kotlin extensions). However, MockK:Natively supports Kotlin: Suspending functions, extension methods, etc.Offers “relaxed” mocks to cut down on boilerplate.Tends to require fewer workarounds, making it particularly appealing for Kotlin Multiplatform code, where Java-specific assumptions might break.Use Case: Faking Ktor ResponsesImagine your app (or KMM module) fetches user profiles, weather data, or anything else from a remote API via Ktor. If you rely on a real server in your tests or staging environment, you might face:Slower tests (network latency).Flaky results (server downtime or changing data).Difficult offline testing (losing network disrupts your tests).Instead, you can:Use the real Ktor service in production.Switch to a mock for tests (or “stage” environment) returning predictable data, no internet required.This is where MockK (for mocking), Koin (for easy dependency injection), and Ktor (for flexible HTTP clients) align perfectly. A simple toggle, like useMocks = true, decides whether to rely on real or fake Ktor calls.Implementation Steps1. Environment \u0026 Mock SettingsFirst, create a small data class to hold environment info:data class EnvironmentConfig( val environmentName: String, // e.g. \"production\", \"stage\" val useMocks: Boolean)You can define these values in many ways — via BuildConfig, code constants, or even your CI pipeline. Below are two approaches to wire them up in Koin:(A) Defining Environment Info in a Koin Moduleval envModule = module { single { EnvironmentConfig( environmentName = \"stage\", useMocks = true ) }}Here, you simply declare the environment name (\"stage\") and set useMocks = true so any module that depends on EnvironmentConfig can get it from Koin.(B) Using BuildConfig to Define Environment Info// In your app-level build.gradleandroid { defaultConfig { // Example build config fields for environment + mock usage buildConfigField \"String\", \"ENVIRONMENT\", \"\\\"stage\\\"\" buildConfigField \"boolean\", \"USE_MOCKS\", \"true\" }}Then in Kotlin code:// You can still define a data class, or just read from BuildConfig directly:val environmentName = BuildConfig.ENVIRONMENTval useMocks = BuildConfig.USE_MOCKSThis approach is handy if you want to automatically tie environment flags to different build variants (e.g., debug, release, or custom “staging” variants).2. Real API Service (Ktor)Then you’ll need an interface plus a real implementation using Ktor:// Important to use interfaceinterface ApiService { suspend fun fetchData(): String}// This implementation utilizes the interface to return real dataclass RealApiService : ApiService { private val client = io.ktor.client.HttpClient() { // e.g. logging, timeouts, JSON config } override suspend fun fetchData(): String { // Calls a real endpoint return client.get(\"https://example.com/data\") }}If useMocks = false, you’d provide RealApiService in your code or DI setup. For KMM, this same code could be shared across Android and iOS modules—Ktor works on both.3. Creating a Mock with MockKFaking the Ktor calls in MockK is straightforward:import io.mockk.everyimport io.mockk.mockkval mockService = mockk\u003cApiService\u003e()every { mockService.fetchData() } returns \"Fake response data from MockK!\"mockk() creates a mock object.every { ... } returns ... tells it to return a certain value whenever fetchData() is called.You can also use answers which gives you a lambda, thus a place to add extra code (rather than just returning a value) if you want something dynamic, like a timestamp.every { mockService.fetchData() } answers { \"Response with timestamp: ${System.currentTimeMillis()}\"}If you don’t specify how a method behaves, MockK returns defaults (null, 0, false, etc.) for that method.4. Injecting Dependencies with KoinUse Koin to switch between mock and real services, depending on your environment.Below is an example that uses the Koin module approach for environment info. If you prefer BuildConfig, just replace the lines where we retrieve EnvironmentConfig with direct calls to BuildConfig.ENVIRONMENT and BuildConfig.USE_MOCKS.val networkModule = module { single\u003cApiService\u003e { val config: EnvironmentConfig = get() // from envModule if using approach (A) // If you prefer BuildConfig approach, do something like: // val environmentName = BuildConfig.ENVIRONMENT // val useMocks = BuildConfig.USE_MOCKS if (config.environmentName == \"stage\" \u0026\u0026 config.useMocks) { // Provide a mock val mockService = mockk\u003cApiService\u003e() every { mockService.fetchData() } returns \"Fake response data from MockK!\" mockService } else { RealApiService() } }}// Also you can have a module to hold environment info if not in BuildConfig// In approach (A) we saw this environment moduleval envModule = module { single { EnvironmentConfig( environmentName = \"stage\", useMocks = true ) }}If environmentName = \"stage\" and useMocks = true, you inject the mock ApiService.Otherwise, you get RealApiService.Why Koin?Lightweight DI framework, well-suited for Kotlin (and KMM if you share modules).Simplifies the “if-else” logic for providing mocks vs. real objects.Makes it easy to override modules in tests, staging, or production builds.Overriding Modules in TestsIf you prefer different modules for production vs. testing, you can override them in your test setup using loadKoinModules() or the override = true flag.Testing with runTestModern Android apps often rely on coroutines. Add the coroutines test library to your build.gradle:testImplementation \"org.jetbrains.kotlinx:kotlinx-coroutines-test:YOUR_VERSION_HERE\"Then wrap your test logic in runTest:@Testfun testFetchDataWithMockK() = runTest { startKoin { modules(listOf(envModule, networkModule)) } // Because environment = \"stage\" + useMocks = true, you get a mock val service: ApiService = get() val data = service.fetchData() assertEquals(\"Fake response data from MockK!\", data)}This ensures no real network calls happen and that your tests are fast and consistent.Testing the ViewModelBelow is a quick sample of how to test a ViewModel that depends on ApiService:// The ViewModelclass MyViewModel(private val apiService: ApiService) : ViewModel() { val data = MutableLiveData\u003cString\u003e() fun loadData() { viewModelScope.launch { data.value = apiService.fetchData() } }}// Our Test classclass MyViewModelTest { @Before fun setupKoin() { // Start Koin once per test class (or per test if you prefer) startKoin { modules(listOf(envModule, networkModule)) } } @After fun tearDownKoin() { // Stop Koin to avoid polluting other tests stopKoin() } @Test fun `ViewModel uses mocked service with verify`() = runTest { // The mock or real service is injected based on environment settings val viewModel = MyViewModel(get()) viewModel.loadData() // Our mock returns \"Fake response data from MockK!\" assertEquals(\"Fake response data from MockK!\", viewModel.data.value) // Check that fetchData() was indeed called once using verify val service: ApiService = get() io.mockk.verify(exactly = 1) { service.fetchData() } }}Notes:@Before and @After allow you to set up and tear down Koin cleanly.You can replicate this logic in a base test class or a JUnit test rule/extension if you have many test classes.verify vs. coVerify in MockKIn MockK, both verify and coVerify can work with suspending functions, but:1. coVerifycoVerify is explicitly designed for suspending (coroutine) calls.It ensures the verification is aligned with coroutine context handling, which can help avoid subtle concurrency or timing issues.It tells readers of your test, “I’m verifying a coroutine call,” improving clarity and maintainability.2. verifyverify can pass most of the time if you’re testing suspending code inside runTest, but in complex or asynchronous flows (e.g., parallel coroutines, multiple suspending calls, time manipulation with advanceTimeBy), coVerify might handle completion states more reliably.When to use coVerifyWhenever you’re verifying multiple or complex suspending calls: If your test triggers concurrency or sequential calls that can’t be guaranteed to finish instantly, coVerify reduces the risk of timing issues.When clarity is key: Marking a verification as coVerify signals you’re intentionally dealing with coroutine-based calls, which helps other developers.If you run into race conditions using verify in a more complex coroutine scenario, switching to coVerify often resolves them.If your scenario is super simple — one call, straightforward flow, all in runTest—verify and coVerify will likely behave identically. In that case, verify is perfectly fine. But coVerify gives you a safer, more explicit guarantee in real-world coroutine usage.coVerify Example: Multiple Suspending CallsImagine a scenario where your ViewModel calls two suspending methods on the same service, possibly in parallel. With verify, the test might pass or fail depending on timing, especially if the second call hasn’t completed when verify runs. With coVerify, MockK tries to ensure the coroutine calls have completed before verifying.Service With Two Suspensionsinterface ApiService { suspend fun fetchUsers(): List\u003cString\u003e suspend fun fetchPosts(): List\u003cString\u003e}class RealApiService : ApiService { override suspend fun fetchUsers(): List\u003cString\u003e { // Some real network call } override suspend fun fetchPosts(): List\u003cString\u003e { // Another real network call }}ViewModel Triggering Bothclass MyViewModel(private val apiService: ApiService) : ViewModel() { val users = MutableLiveData\u003cList\u003cString\u003e\u003e() val posts = MutableLiveData\u003cList\u003cString\u003e\u003e() fun loadAllData() { viewModelScope.launch { // In real life, you might do these in parallel or with concurrency structures users.value = apiService.fetchUsers() posts.value = apiService.fetchPosts() } }}Test Using coVerifyclass MyViewModelTest { @Test fun `test loadAllData with coVerify`() = runTest { // Suppose we inject a mockk\u003cApiService\u003e via Koin or manual injection val mockService = mockk\u003cApiService\u003e() every { mockService.fetchUsers() } returns listOf(\"Alice\", \"Bob\") every { mockService.fetchPosts() } returns listOf(\"Post1\", \"Post2\") val viewModel = MyViewModel(mockService) viewModel.loadAllData() // calls both suspending methods // Check results assertEquals(listOf(\"Alice\", \"Bob\"), viewModel.users.value) assertEquals(listOf(\"Post1\", \"Post2\"), viewModel.posts.value) // coVerify ensures all coroutines completed for these calls before verifying coVerify(exactly = 1) { mockService.fetchUsers() } coVerify(exactly = 1) { mockService.fetchPosts() } }}In some advanced tests (e.g., if you used runTest { ... } but had parallel coroutines plus time-shifting with advanceTimeBy or advanceUntilIdle), verify might incorrectly run before the second call finishes. coVerify is better at ensuring it waits for suspend calls to complete (or at least that it knows they’re coroutines) before checking if they were called.KMM ConsiderationsBecause Ktor, Koin, and MockK are all pure Kotlin, you can use them in Kotlin Multiplatform Mobile (KMM) projects as well:Ktor client code can be shared across Android and iOS.MockK can test your shared (common) Kotlin code that includes business logic and network layers.Koin can be used to inject these dependencies in a KMM environment (though you might handle DI differently on iOS if you want a more native approach).Regardless, the same principles apply: mock your ApiService so you’re not hitting a real server on each test run, saving time and complexity across both platforms.Extra Use Cases for MockKBesides faking HTTP requests, MockK can also simplify other use cases. Here are just a few ideas:1. Database TestingQuickly test your repository logic without a real DB.val mockDao = mockk\u003cUserDao\u003e()every { mockDao.getUsers() } returns listOf(User(\"Alice\"))2. Analytics \u0026 LoggingConfirm logs are called correctly — no real analytics server needed.val mockAnalytics = mockk\u003cAnalyticsService\u003e()// ...io.mockk.verify { mockAnalytics.trackEvent(\"ScreenViewed\") }3. Push NotificationsThe inverse = true parameter (or verify(exactly = 0)) ensures sendNotification wasn’t called.val mockPushManager = mockk\u003cPushManager\u003e()io.mockk.verify(inverse = true) { mockPushManager.sendNotification(any()) }Wrapping UpBy mixing MockK with Ktor and Koin, you can:Short-circuit real network calls in your tests, boosting speed and reliability.Toggle between a mock or real service using either a Koin module or BuildConfig flags.Test coroutines seamlessly, thanks to MockK’s Kotlin-native design.Mockito is still a solid library, but MockK usually feels more natural for modern Kotlin — especially if you heavily use suspending functions or advanced Kotlin features. Whichever approach you pick, mocking your network layer (and other dependencies) is a surefire way to keep your tests stable, your code modular, and your development process friction-free. Enjoy your streamlined testing workflow!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*tTFt4p_bc707o7a6cwKtmg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--5e5dc11dc95f--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*CPyc3y-sp02vMh239V_suQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--5e5dc11dc95f--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"927c\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"a1d7\"\u003eWhen you’re building an Android app — or even a cross-platform Kotlin Multiplatform (KMM) project — that relies on network calls, things can get slow and unreliable if you’re always calling a \u003cstrong\u003ereal server\u003c/strong\u003e — especially during testing.\u003c/p\u003e\u003cp id=\"bbdc\"\u003eBy combining \u003cstrong\u003eMockK\u003c/strong\u003e, \u003cstrong\u003eKoin\u003c/strong\u003e, and \u003cstrong\u003eKtor\u003c/strong\u003e, you can “fake” your network responses, so your tests and development stay smooth and reliable — even when offline.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"84b4\"\u003e\u003cstrong\u003e\u003cem\u003eNote\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e: Although we use \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eKtor\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e in this article (because it’s Kotlin-friendly and perfect for KMM), the \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eMockK + Koin\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e approach easily applies to \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eany\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e networking library — such as \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eOkHttp\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e, \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eRetrofit\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e, or others. As long as you wrap your network calls in an interface (like \u003c/em\u003e\u003ccode\u003e\u003cem\u003eApiService\u003c/em\u003e\u003c/code\u003e\u003cem\u003e), you can swap in a mock or a real implementation as needed.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"95d3\"\u003eEnter MockK\u003c/h2\u003e\u003cp id=\"62b0\"\u003e\u003cstrong\u003eMockK\u003c/strong\u003e is a \u003cstrong\u003eKotlin-first\u003c/strong\u003e mocking library that offers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c817\"\u003e\u003cstrong\u003eNative Kotlin support\u003c/strong\u003e: Ideal for projects using coroutines or advanced Kotlin features.\u003c/li\u003e\u003cli id=\"c784\"\u003e\u003cstrong\u003eClear syntax\u003c/strong\u003e: \u003ccode\u003eevery { ... } returns ...\u003c/code\u003e to define how mocks respond, and \u003ccode\u003everify\u003c/code\u003e/\u003ccode\u003ecoVerify\u003c/code\u003e to confirm calls.\u003c/li\u003e\u003cli id=\"806e\"\u003e\u003cstrong\u003eFlexible options\u003c/strong\u003e: Like “relaxed” mocks to reduce boilerplate, and \u003ccode\u003ecoVerify\u003c/code\u003e for suspend functions.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d814\"\u003eBecause MockK is \u003cstrong\u003epure Kotlin\u003c/strong\u003e, it often feels more natural than Java-oriented libraries — especially on \u003cstrong\u003emodern Android\u003c/strong\u003e and \u003cstrong\u003eKMM\u003c/strong\u003e projects.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"533c\"\u003eWhy Ktor?\u003c/h2\u003e\u003cp id=\"fbec\"\u003e\u003ca href=\"https://ktor.io/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKtor\u003c/strong\u003e\u003c/a\u003e is a \u003cstrong\u003eKotlin-native\u003c/strong\u003e framework for building and consuming HTTP APIs. It works on the JVM, Android, iOS (via Kotlin/Native), and more. In Android apps, you might use it as your HTTP client, but in \u003cstrong\u003eKMM\u003c/strong\u003e projects, you can share this network logic across multiple platforms:\u003c/p\u003e\u003col\u003e\u003cli id=\"09b2\"\u003e\u003cstrong\u003ePure Kotlin\u003c/strong\u003e: Suits KMM perfectly — no platform-specific bridging for networking.\u003c/li\u003e\u003cli id=\"2ee6\"\u003e\u003cstrong\u003eLightweight \u0026amp; Composable\u003c/strong\u003e: Configure pipeline features like logging, JSON parsing, and timeouts.\u003c/li\u003e\u003cli id=\"d8de\"\u003e\u003cstrong\u003eMultiplatform\u003c/strong\u003e: Same code for Android, iOS, desktop, or server-based projects.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"08be\"\u003eWhen using \u003cstrong\u003eMockK\u003c/strong\u003e to fake Ktor responses, you effectively \u003cstrong\u003eshort-circuit\u003c/strong\u003e real network requests, returning data as if Ktor had made the call — without hitting an actual server. This synergy is what makes your tests fast, reliable, and easy to maintain in both Android and \u003cstrong\u003eKMM\u003c/strong\u003e environments.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4b02\"\u003eMockito vs MockK\u003c/h2\u003e\u003cp id=\"18f1\"\u003eHistorically, \u003cstrong\u003eMockito\u003c/strong\u003e has been the go-to solution for Java-based mocking, and it can work in Kotlin with some additional steps (like enabling inline mocking or adding Kotlin extensions). However, \u003cstrong\u003eMockK\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2bdc\"\u003e\u003cstrong\u003eNatively\u003c/strong\u003e supports \u003cstrong\u003eKotlin\u003c/strong\u003e: Suspending functions, extension methods, etc.\u003c/li\u003e\u003cli id=\"83b6\"\u003eOffers \u003cstrong\u003e“relaxed” mocks\u003c/strong\u003e to cut down on boilerplate.\u003c/li\u003e\u003cli id=\"c005\"\u003eTends to require fewer workarounds, making it particularly appealing for \u003cstrong\u003eKotlin Multiplatform\u003c/strong\u003e code, where Java-specific assumptions might break.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7d4c\"\u003eUse Case: Faking Ktor Responses\u003c/h2\u003e\u003cp id=\"0b3a\"\u003eImagine your app (or KMM module) fetches user profiles, weather data, or anything else from a remote API via Ktor. If you rely on a real server in your tests or staging environment, you might face:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b0a5\"\u003e\u003cstrong\u003eSlower tests\u003c/strong\u003e (network latency).\u003c/li\u003e\u003cli id=\"baf7\"\u003e\u003cstrong\u003eFlaky results\u003c/strong\u003e (server downtime or changing data).\u003c/li\u003e\u003cli id=\"e1a2\"\u003e\u003cstrong\u003eDifficult offline testing\u003c/strong\u003e (losing network disrupts your tests).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"aa6a\"\u003eInstead, you can:\u003c/p\u003e\u003col\u003e\u003cli id=\"75c7\"\u003eUse the \u003cstrong\u003ereal\u003c/strong\u003e Ktor service in \u003cstrong\u003eproduction\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"031a\"\u003eSwitch to a \u003cstrong\u003emock\u003c/strong\u003e for tests (or “stage” environment) returning predictable data, no internet required.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"e095\"\u003eThis is where \u003cstrong\u003eMockK\u003c/strong\u003e (for mocking), \u003cstrong\u003eKoin\u003c/strong\u003e (for easy dependency injection), and \u003cstrong\u003eKtor\u003c/strong\u003e (for flexible HTTP clients) align perfectly. A simple toggle, like \u003ccode\u003euseMocks = true\u003c/code\u003e, decides whether to rely on \u003cstrong\u003ereal\u003c/strong\u003e or \u003cstrong\u003efake\u003c/strong\u003e Ktor calls.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a73c\"\u003eImplementation Steps\u003c/h2\u003e\u003ch2 id=\"4150\"\u003e1. Environment \u0026amp; Mock Settings\u003c/h2\u003e\u003cp id=\"3046\"\u003eFirst, create a small data class to hold environment info:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f158\"\u003edata class EnvironmentConfig(\u003cbr/\u003e    val environmentName: String,  // e.g. \u0026#34;production\u0026#34;, \u0026#34;stage\u0026#34;\u003cbr/\u003e    val useMocks: Boolean\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e5b7\"\u003eYou can define these values in \u003cstrong\u003emany ways\u003c/strong\u003e — via \u003ccode\u003eBuildConfig\u003c/code\u003e, code constants, or even your CI pipeline. Below are \u003cstrong\u003etwo approaches\u003c/strong\u003e to wire them up in Koin:\u003c/p\u003e\u003ch2 id=\"a9c9\"\u003e(A) Defining Environment Info in a Koin Module\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"2bd2\"\u003eval envModule = module {\u003cbr/\u003e    single {\u003cbr/\u003e        EnvironmentConfig(\u003cbr/\u003e            environmentName = \u0026#34;stage\u0026#34;,\u003cbr/\u003e            useMocks = true\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4e37\"\u003eHere, you simply declare the environment name (\u003ccode\u003e\u0026#34;stage\u0026#34;\u003c/code\u003e) and set \u003ccode\u003euseMocks = true\u003c/code\u003e so any module that depends on \u003ccode\u003eEnvironmentConfig\u003c/code\u003e can get it from Koin.\u003c/p\u003e\u003ch2 id=\"d784\"\u003e(B) Using BuildConfig to Define Environment Info\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"0679\"\u003e// In your app-level build.gradle\u003cbr/\u003eandroid {\u003cbr/\u003e    defaultConfig {\u003cbr/\u003e        // Example build config fields for environment + mock usage\u003cbr/\u003e        buildConfigField \u0026#34;String\u0026#34;, \u0026#34;ENVIRONMENT\u0026#34;, \u0026#34;\\\u0026#34;stage\\\u0026#34;\u0026#34;\u003cbr/\u003e        buildConfigField \u0026#34;boolean\u0026#34;, \u0026#34;USE_MOCKS\u0026#34;, \u0026#34;true\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8ec0\"\u003eThen in Kotlin code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"be11\"\u003e// You can still define a data class, or just read from BuildConfig directly:\u003cbr/\u003eval environmentName = BuildConfig.ENVIRONMENT\u003cbr/\u003eval useMocks = BuildConfig.USE_MOCKS\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c680\"\u003eThis approach is handy if you want to automatically tie environment flags to different \u003cstrong\u003ebuild variants\u003c/strong\u003e (e.g., \u003ccode\u003edebug\u003c/code\u003e, \u003ccode\u003erelease\u003c/code\u003e, or custom “staging” variants).\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d940\"\u003e2. Real API Service (Ktor)\u003c/h2\u003e\u003cp id=\"e34e\"\u003eThen you’ll need an interface plus a real implementation using \u003cstrong\u003eKtor\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"19f4\"\u003e// Important to use interface\u003cbr/\u003einterface ApiService {\u003cbr/\u003e    suspend fun fetchData(): String\u003cbr/\u003e}\u003cp\u003e// This implementation utilizes the interface to return real data\u003cbr/\u003eclass RealApiService : ApiService {\u003cbr/\u003e    private val client = io.ktor.client.HttpClient() {\u003cbr/\u003e        // e.g. logging, timeouts, JSON config\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override suspend fun fetchData(): String {\u003cbr/\u003e        // Calls a real endpoint\u003cbr/\u003e        return client.get(\u0026#34;https://example.com/data\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b7f2\"\u003eIf \u003ccode\u003euseMocks = false\u003c/code\u003e, you’d provide \u003ccode\u003eRealApiService\u003c/code\u003e in your code or DI setup. For KMM, this same code could be shared across Android and iOS modules—\u003cstrong\u003eKtor\u003c/strong\u003e works on both.\u003c/p\u003e\u003ch2 id=\"b628\"\u003e3. Creating a Mock with MockK\u003c/h2\u003e\u003cp id=\"15e9\"\u003eFaking the Ktor calls in MockK is straightforward:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1664\"\u003eimport io.mockk.every\u003cbr/\u003eimport io.mockk.mockk\u003cp\u003eval mockService = mockk\u0026lt;ApiService\u0026gt;()\u003c/p\u003e\u003cp\u003eevery { mockService.fetchData() } returns \u0026#34;Fake response data from MockK!\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"2279\"\u003e\u003ccode\u003e\u003cstrong\u003emockk()\u003c/strong\u003e\u003c/code\u003e creates a mock object.\u003c/li\u003e\u003cli id=\"5dc1\"\u003e\u003ccode\u003e\u003cstrong\u003eevery { ... } returns ...\u003c/strong\u003e\u003c/code\u003e tells it to return a certain value whenever \u003ccode\u003efetchData()\u003c/code\u003e is called.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8141\"\u003eYou can also use \u003ccode\u003e\u003cstrong\u003eanswers\u003c/strong\u003e\u003c/code\u003e which gives you a lambda, thus a place to add extra code (rather than just returning a value) if you want something dynamic, like a timestamp.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a3d\"\u003eevery { mockService.fetchData() } answers {\u003cbr/\u003e    \u0026#34;Response with timestamp: ${System.currentTimeMillis()}\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0217\"\u003eIf you don’t specify how a method behaves, \u003cstrong\u003eMockK\u003c/strong\u003e returns defaults (null, 0, false, etc.) for that method.\u003c/p\u003e\u003ch2 id=\"7155\"\u003e4. Injecting Dependencies with Koin\u003c/h2\u003e\u003cp id=\"05c5\"\u003eUse \u003cstrong\u003eKoin\u003c/strong\u003e to switch between mock and real services, depending on your environment.\u003c/p\u003e\u003cp id=\"6272\"\u003eBelow is an example that uses the \u003cstrong\u003eKoin module\u003c/strong\u003e approach for environment info. If you prefer \u003ccode\u003eBuildConfig\u003c/code\u003e, just replace the lines where we retrieve \u003ccode\u003eEnvironmentConfig\u003c/code\u003e with direct calls to \u003ccode\u003eBuildConfig.ENVIRONMENT\u003c/code\u003e and \u003ccode\u003eBuildConfig.USE_MOCKS\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d31d\"\u003eval networkModule = module {\u003cbr/\u003e    single\u0026lt;ApiService\u0026gt; {\u003cbr/\u003e        val config: EnvironmentConfig = get()  // from envModule if using approach (A)\u003cp\u003e        // If you prefer BuildConfig approach, do something like:\u003cbr/\u003e        // val environmentName = BuildConfig.ENVIRONMENT\u003cbr/\u003e        // val useMocks = BuildConfig.USE_MOCKS\u003c/p\u003e\u003cp\u003e        if (config.environmentName == \u0026#34;stage\u0026#34; \u0026amp;\u0026amp; config.useMocks) {\u003cbr/\u003e            // Provide a mock\u003cbr/\u003e            val mockService = mockk\u0026lt;ApiService\u0026gt;()\u003cbr/\u003e            every { mockService.fetchData() } returns \u0026#34;Fake response data from MockK!\u0026#34;\u003cbr/\u003e            mockService\u003cbr/\u003e        } else {\u003cbr/\u003e            RealApiService()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Also you can have a module to hold environment info if not in BuildConfig\u003cbr/\u003e// In approach (A) we saw this environment module\u003cbr/\u003eval envModule = module {\u003cbr/\u003e    single {\u003cbr/\u003e        EnvironmentConfig(\u003cbr/\u003e            environmentName = \u0026#34;stage\u0026#34;,\u003cbr/\u003e            useMocks = true\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"96c5\"\u003eIf \u003ccode\u003eenvironmentName = \u0026#34;stage\u0026#34;\u003c/code\u003e \u003cstrong\u003eand\u003c/strong\u003e \u003ccode\u003euseMocks = true\u003c/code\u003e, you inject the mock \u003ccode\u003eApiService\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"2e90\"\u003eOtherwise, you get \u003ccode\u003eRealApiService\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c33c\"\u003eWhy Koin?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"6df5\"\u003e\u003cstrong\u003eLightweight\u003c/strong\u003e DI framework, well-suited for Kotlin (and KMM if you share modules).\u003c/li\u003e\u003cli id=\"11e7\"\u003eSimplifies the “if-else” logic for providing mocks vs. real objects.\u003c/li\u003e\u003cli id=\"5503\"\u003eMakes it easy to override modules in tests, staging, or production builds.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"53c5\"\u003eOverriding Modules in Tests\u003c/h2\u003e\u003cp id=\"f3fe\"\u003eIf you prefer different modules for production vs. testing, you can \u003cstrong\u003eoverride\u003c/strong\u003e them in your test setup using \u003ccode\u003eloadKoinModules()\u003c/code\u003e or the \u003ccode\u003eoverride = true\u003c/code\u003e flag.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a8b2\"\u003eTesting with runTest\u003c/h2\u003e\u003cp id=\"997e\"\u003eModern Android apps often rely on coroutines. Add the coroutines test library to your \u003ccode\u003ebuild.gradle\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f69e\"\u003etestImplementation \u0026#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:YOUR_VERSION_HERE\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7c37\"\u003eThen wrap your test logic in \u003ccode\u003e\u003cstrong\u003erunTest\u003c/strong\u003e\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5233\"\u003e@Test\u003cbr/\u003efun testFetchDataWithMockK() = runTest {\u003cbr/\u003e    startKoin { modules(listOf(envModule, networkModule)) }\u003cp\u003e    // Because environment = \u0026#34;stage\u0026#34; + useMocks = true, you get a mock\u003cbr/\u003e    val service: ApiService = get()\u003c/p\u003e\u003cp\u003e    val data = service.fetchData()\u003cbr/\u003e    assertEquals(\u0026#34;Fake response data from MockK!\u0026#34;, data)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"504d\"\u003eThis ensures no \u003cstrong\u003ereal network\u003c/strong\u003e calls happen and that your tests are \u003cstrong\u003efast\u003c/strong\u003e and \u003cstrong\u003econsistent\u003c/strong\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0386\"\u003eTesting the ViewModel\u003c/h2\u003e\u003cp id=\"97ae\"\u003eBelow is a quick sample of how to test a \u003ccode\u003eViewModel\u003c/code\u003e that depends on \u003ccode\u003eApiService\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7e87\"\u003e// The ViewModel\u003cbr/\u003eclass MyViewModel(private val apiService: ApiService) : ViewModel() {\u003cbr/\u003e    val data = MutableLiveData\u0026lt;String\u0026gt;()\u003cp\u003e    fun loadData() {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            data.value = apiService.fetchData()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Our Test class\u003cbr/\u003eclass MyViewModelTest {\u003c/p\u003e\u003cp\u003e    @Before\u003cbr/\u003e    fun setupKoin() {\u003cbr/\u003e        // Start Koin once per test class (or per test if you prefer)\u003cbr/\u003e        startKoin {\u003cbr/\u003e            modules(listOf(envModule, networkModule))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @After\u003cbr/\u003e    fun tearDownKoin() {\u003cbr/\u003e        // Stop Koin to avoid polluting other tests\u003cbr/\u003e        stopKoin()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @Test\u003cbr/\u003e    fun `ViewModel uses mocked service with verify`() = runTest {\u003cbr/\u003e        // The mock or real service is injected based on environment settings\u003cbr/\u003e        val viewModel = MyViewModel(get())\u003c/p\u003e\u003cp\u003e        viewModel.loadData()\u003c/p\u003e\u003cp\u003e        // Our mock returns \u0026#34;Fake response data from MockK!\u0026#34;\u003cbr/\u003e        assertEquals(\u0026#34;Fake response data from MockK!\u0026#34;, viewModel.data.value)\u003c/p\u003e\u003cp\u003e        // Check that fetchData() was indeed called once using verify\u003cbr/\u003e        val service: ApiService = get()\u003cbr/\u003e        io.mockk.verify(exactly = 1) { service.fetchData() }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2d9d\"\u003eNotes:\u003c/h2\u003e\u003col\u003e\u003cli id=\"b9cf\"\u003e\u003ccode\u003e\u003cstrong\u003e@Before\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e@After\u003c/strong\u003e\u003c/code\u003e allow you to set up and tear down Koin cleanly.\u003c/li\u003e\u003cli id=\"9ef0\"\u003eYou can replicate this logic in a base test class or a JUnit test rule/extension if you have many test classes.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c78c\"\u003e\u003ccode\u003everify\u003c/code\u003e vs. \u003ccode\u003ecoVerify\u003c/code\u003e in MockK\u003c/h2\u003e\u003cp id=\"8757\"\u003eIn \u003cstrong\u003eMockK\u003c/strong\u003e, both \u003ccode\u003everify\u003c/code\u003e and \u003ccode\u003ecoVerify\u003c/code\u003e can work with suspending functions, \u003cstrong\u003ebut\u003c/strong\u003e:\u003c/p\u003e\u003cp id=\"b4b4\"\u003e\u003cstrong\u003e1. \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp id=\"51f3\"\u003e\u003ccode\u003e\u003cstrong\u003ecoVerify\u003c/strong\u003e\u003c/code\u003e is explicitly designed for \u003cstrong\u003esuspending\u003c/strong\u003e (coroutine) calls.\u003c/p\u003e\u003cul\u003e\u003cli id=\"52b1\"\u003eIt ensures the verification is \u003cstrong\u003ealigned with coroutine context\u003c/strong\u003e handling, which can help avoid subtle concurrency or timing issues.\u003c/li\u003e\u003cli id=\"d62f\"\u003eIt tells readers of your test, “I’m verifying a \u003cstrong\u003ecoroutine\u003c/strong\u003e call,” improving clarity and maintainability.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ac7c\"\u003e\u003cstrong\u003e2. \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003everify\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp id=\"8c12\"\u003e\u003ccode\u003e\u003cstrong\u003everify\u003c/strong\u003e\u003c/code\u003e can pass most of the time if you’re testing suspending code inside \u003ccode\u003erunTest\u003c/code\u003e, but in \u003cstrong\u003ecomplex\u003c/strong\u003e or asynchronous flows (e.g., parallel coroutines, multiple suspending calls, time manipulation with \u003ccode\u003eadvanceTimeBy\u003c/code\u003e), \u003ccode\u003ecoVerify\u003c/code\u003e might handle completion states more reliably.\u003c/p\u003e\u003ch2 id=\"43bc\"\u003eWhen to use coVerify\u003c/h2\u003e\u003cul\u003e\u003cli id=\"3108\"\u003e\u003cstrong\u003eWhenever you’re verifying multiple or complex suspending calls\u003c/strong\u003e: If your test triggers concurrency or sequential calls that can’t be guaranteed to finish instantly, \u003ccode\u003ecoVerify\u003c/code\u003e reduces the risk of timing issues.\u003c/li\u003e\u003cli id=\"064c\"\u003e\u003cstrong\u003eWhen clarity is key\u003c/strong\u003e: Marking a verification as \u003ccode\u003ecoVerify\u003c/code\u003e signals you’re intentionally dealing with coroutine-based calls, which helps other developers.\u003c/li\u003e\u003cli id=\"cf27\"\u003e\u003cstrong\u003eIf you run into race conditions\u003c/strong\u003e using \u003ccode\u003everify\u003c/code\u003e in a more complex coroutine scenario, switching to \u003ccode\u003ecoVerify\u003c/code\u003e often resolves them.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1c2e\"\u003e\u003cstrong\u003eIf your scenario is super simple\u003c/strong\u003e — one call, straightforward flow, all in \u003ccode\u003erunTest\u003c/code\u003e—\u003ccode\u003everify\u003c/code\u003e and \u003ccode\u003ecoVerify\u003c/code\u003e will likely behave identically. In that case, \u003ccode\u003everify\u003c/code\u003e is perfectly fine. But \u003ccode\u003ecoVerify\u003c/code\u003e gives you a safer, more explicit guarantee in real-world coroutine usage.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0115\"\u003ecoVerify Example: Multiple Suspending Calls\u003c/h2\u003e\u003cp id=\"2f87\"\u003eImagine a scenario where your ViewModel calls \u003cstrong\u003etwo\u003c/strong\u003e suspending methods on the same service, possibly in parallel. With \u003ccode\u003everify\u003c/code\u003e, the test might pass or fail depending on timing, especially if the second call hasn’t completed when \u003ccode\u003everify\u003c/code\u003e runs. With \u003ccode\u003ecoVerify\u003c/code\u003e, MockK tries to ensure the coroutine calls have completed before verifying.\u003c/p\u003e\u003ch2 id=\"00cf\"\u003eService With Two Suspensions\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"085c\"\u003einterface ApiService {\u003cbr/\u003e    suspend fun fetchUsers(): List\u0026lt;String\u0026gt;\u003cbr/\u003e    suspend fun fetchPosts(): List\u0026lt;String\u0026gt;\u003cbr/\u003e}\u003cp\u003eclass RealApiService : ApiService {\u003cbr/\u003e    override suspend fun fetchUsers(): List\u0026lt;String\u0026gt; {\u003cbr/\u003e        // Some real network call\u003cbr/\u003e    }\u003cbr/\u003e    override suspend fun fetchPosts(): List\u0026lt;String\u0026gt; {\u003cbr/\u003e        // Another real network call\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"67dd\"\u003eViewModel Triggering Both\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"2d07\"\u003eclass MyViewModel(private val apiService: ApiService) : ViewModel() {\u003cbr/\u003e    val users = MutableLiveData\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;()\u003cbr/\u003e    val posts = MutableLiveData\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;()\u003cp\u003e    fun loadAllData() {\u003cbr/\u003e        viewModelScope.launch {\u003cbr/\u003e            // In real life, you might do these in parallel or with concurrency structures\u003cbr/\u003e            users.value = apiService.fetchUsers()\u003cbr/\u003e            posts.value = apiService.fetchPosts()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"68ea\"\u003eTest Using \u003ccode\u003ecoVerify\u003c/code\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"d819\"\u003eclass MyViewModelTest {\u003cp\u003e    @Test\u003cbr/\u003e    fun `test loadAllData with coVerify`() = runTest {\u003cbr/\u003e        // Suppose we inject a mockk\u0026lt;ApiService\u0026gt; via Koin or manual injection\u003cbr/\u003e        val mockService = mockk\u0026lt;ApiService\u0026gt;()\u003cbr/\u003e        every { mockService.fetchUsers() } returns listOf(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;)\u003cbr/\u003e        every { mockService.fetchPosts() } returns listOf(\u0026#34;Post1\u0026#34;, \u0026#34;Post2\u0026#34;)\u003c/p\u003e\u003cp\u003e        val viewModel = MyViewModel(mockService)\u003cbr/\u003e        viewModel.loadAllData()  // calls both suspending methods\u003c/p\u003e\u003cp\u003e        // Check results\u003cbr/\u003e        assertEquals(listOf(\u0026#34;Alice\u0026#34;, \u0026#34;Bob\u0026#34;), viewModel.users.value)\u003cbr/\u003e        assertEquals(listOf(\u0026#34;Post1\u0026#34;, \u0026#34;Post2\u0026#34;), viewModel.posts.value)\u003c/p\u003e\u003cp\u003e        // coVerify ensures all coroutines completed for these calls before verifying\u003cbr/\u003e        coVerify(exactly = 1) { mockService.fetchUsers() }\u003cbr/\u003e        coVerify(exactly = 1) { mockService.fetchPosts() }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ba4d\"\u003eIn some advanced tests (e.g., if you used \u003ccode\u003erunTest { ... }\u003c/code\u003e but had parallel coroutines plus time-shifting with \u003ccode\u003eadvanceTimeBy\u003c/code\u003e or \u003ccode\u003eadvanceUntilIdle\u003c/code\u003e), \u003ccode\u003everify\u003c/code\u003e might incorrectly run before the second call finishes. \u003ccode\u003e\u003cstrong\u003ecoVerify\u003c/strong\u003e\u003c/code\u003e is better at ensuring it waits for suspend calls to complete (or at least that it knows they’re coroutines) before checking if they were called.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5952\"\u003eKMM Considerations\u003c/h2\u003e\u003cp id=\"b9f2\"\u003eBecause \u003cstrong\u003eKtor\u003c/strong\u003e, \u003cstrong\u003eKoin\u003c/strong\u003e, and \u003cstrong\u003eMockK\u003c/strong\u003e are all \u003cstrong\u003epure Kotlin\u003c/strong\u003e, you can use them in \u003cstrong\u003eKotlin Multiplatform Mobile\u003c/strong\u003e (KMM) projects as well:\u003c/p\u003e\u003cul\u003e\u003cli id=\"60e1\"\u003e\u003cstrong\u003eKtor\u003c/strong\u003e client code can be shared across Android and iOS.\u003c/li\u003e\u003cli id=\"a067\"\u003e\u003cstrong\u003eMockK\u003c/strong\u003e can test your shared (common) Kotlin code that includes business logic and network layers.\u003c/li\u003e\u003cli id=\"131d\"\u003e\u003cstrong\u003eKoin\u003c/strong\u003e can be used to inject these dependencies in a KMM environment (though you might handle DI differently on iOS if you want a more native approach).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"400c\"\u003eRegardless, the same principles apply: mock your \u003ccode\u003eApiService\u003c/code\u003e so you’re not hitting a real server on each test run, saving time and complexity across both \u003cstrong\u003eplatforms\u003c/strong\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8711\"\u003eExtra Use Cases for MockK\u003c/h2\u003e\u003cp id=\"e2a3\"\u003eBesides faking HTTP requests, \u003cstrong\u003eMockK\u003c/strong\u003e can also simplify other use cases. Here are just a few ideas:\u003c/p\u003e\u003ch2 id=\"92b9\"\u003e\u003cstrong\u003e1. Database Testing\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"1845\"\u003eQuickly test your repository logic without a real DB.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8182\"\u003eval mockDao = mockk\u0026lt;UserDao\u0026gt;()\u003cbr/\u003eevery { mockDao.getUsers() } returns listOf(User(\u0026#34;Alice\u0026#34;))\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"15d4\"\u003e2. Analytics \u0026amp; Logging\u003c/h2\u003e\u003cp id=\"5b23\"\u003eConfirm logs are called correctly — no real analytics server needed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7551\"\u003eval mockAnalytics = mockk\u0026lt;AnalyticsService\u0026gt;()\u003cbr/\u003e// ...\u003cbr/\u003eio.mockk.verify { mockAnalytics.trackEvent(\u0026#34;ScreenViewed\u0026#34;) }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"64ba\"\u003e3. Push Notifications\u003c/h2\u003e\u003cp id=\"aac0\"\u003eThe \u003ccode\u003einverse = true\u003c/code\u003e parameter (or \u003ccode\u003everify(exactly = 0)\u003c/code\u003e) ensures \u003ccode\u003esendNotification\u003c/code\u003e wasn’t called.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"72fd\"\u003eval mockPushManager = mockk\u0026lt;PushManager\u0026gt;()\u003cbr/\u003eio.mockk.verify(inverse = true) { mockPushManager.sendNotification(any()) }\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a619\"\u003eWrapping Up\u003c/h2\u003e\u003cp id=\"6af4\"\u003eBy mixing \u003cstrong\u003eMockK\u003c/strong\u003e with \u003cstrong\u003eKtor\u003c/strong\u003e and \u003cstrong\u003eKoin\u003c/strong\u003e, you can:\u003c/p\u003e\u003cul\u003e\u003cli id=\"76cf\"\u003e\u003cstrong\u003eShort-circuit real network calls\u003c/strong\u003e in your tests, boosting speed and reliability.\u003c/li\u003e\u003cli id=\"4565\"\u003e\u003cstrong\u003eToggle\u003c/strong\u003e between a mock or real service using either a Koin module or \u003ccode\u003eBuildConfig\u003c/code\u003e flags.\u003c/li\u003e\u003cli id=\"0f77\"\u003e\u003cstrong\u003eTest coroutines\u003c/strong\u003e seamlessly, thanks to MockK’s Kotlin-native design.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a197\"\u003e\u003cstrong\u003eMockito\u003c/strong\u003e is still a solid library, but \u003cstrong\u003eMockK\u003c/strong\u003e usually feels \u003cstrong\u003emore natural\u003c/strong\u003e for modern Kotlin — especially if you heavily use suspending functions or advanced Kotlin features. Whichever approach you pick, mocking your network layer (and other dependencies) is a surefire way to keep your tests stable, your code modular, and your development process friction-free. Enjoy your streamlined testing workflow!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-01-21T07:09:10.542Z",
  "modifiedTime": null
}
