{
  "id": "daefd868-2842-4008-bf14-3e71a9a59a2e",
  "title": "Domain-Specific Models",
  "link": "https://blog.danlew.net/2022/08/15/domain-specific-models/",
  "description": "For a long time at Trello Android, we used the same class for parsing API calls (via Gson), making DB transactions (via OrmLite), and displaying data in the UI.Here’s a pseudo-code-y example of a board:@DatabaseTable(tableName = \"boards\") data class Board( @DatabaseField(columnName = “name\u0026",
  "author": "Dan Lew",
  "published": "Mon, 15 Aug 2022 13:00:40 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "android"
  ],
  "byline": "Dan Lew",
  "length": 5332,
  "excerpt": "For a long time at Trello Android, we used the same class for parsing API calls (via Gson), making DB transactions (via OrmLite), and displaying data in the UI. Here’s a pseudo-code-y example of a board: @DatabaseTable(tableName = \"boards\") data class Board( @DatabaseField(columnName = “name”) @SerializedName(\"BoardName\") private var boardName: String?, private var cards: List\u003cCard\u003e?, private var lastViewedTime: Long? ) While it was allocation efficient and somewhat convenient t",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "For a long time at Trello Android, we used the same class for parsing API calls (via Gson), making DB transactions (via OrmLite), and displaying data in the UI.Here’s a pseudo-code-y example of a board:@DatabaseTable(tableName = \"boards\") data class Board( @DatabaseField(columnName = “name”) @SerializedName(\"BoardName\") private var boardName: String?, private var cards: List\u003cCard\u003e?, private var lastViewedTime: Long? ) While it was allocation efficient and somewhat convenient to have all this data in one place, more often it was just a pain in the ass:Availability sadness - Any given field might only be available some of the time. For example, Board.cards is returned by the API, but a DB query would not return that field (since it was stored in a separate table). Conversely, we might store some local state in the DB (e.g., when the board was last viewed in the client via Board.lastViewedTime) and that data wouldn’t be present in API responses.In both cases, it made figuring out what data was actually available in any given place a minefield. Sure, you could do a null-check, but what if you really needed the data? How can you guarantee it’s available? It was hard to reason about the code.On top of that, it was a constant source of bugs while making Trello Android work offline. Whenever we switched from API calls to DB queries, it would change which fields would be populated, causing issues.Mutability sadness - These models were highly mutable because of OrmLite - even if we didn’t mutate them, OrmLite might when reusing objects via caching. A piece of the UI might query the DB for a Board, use it once, then later use that exact same Board instance again only to find that the Board’s data changed in secret.Nullability sadness - Trello’s API lets you choose which fields to return for any given query. As a result, we typically needed all fields to be nullable. When we switched to using Kotlin, we were constantly having to use !! or null-checks when we knew data was present but couldn’t prove it to the compiler.Naming sadness - A given field could have up to three different names - one for how it looks in the API, one for the column name in the DB, and one for the actual property in the model. This caused confusion, especially when writing generic logic based on the names of API or DB fields.Bloat sadness - Perhaps some part of the UI only needs the board’s name - too bad! You’re getting a dozen other fields with it. A relatively minor problem compared to the others, but it always felt problematic to provide so much information to the UI that it wasn’t using. For one thing, it made testing more complex, since how could you guarantee that this random field wasn’t being used when it was part of the input?There’s one root cause of all these problems: overloading the data model. Whenever we gave a field multiple roles at once, it caused sadness. Each layer - the API, the DB, and the UI - all had different needs, and there was no one-size-fits-all solution.A Better SolutionWhat do you do if you’ve got one class with too many roles? You split it up!Rather than one single OmniModel, we’d instead create (at least) three: an ApiModel, a DbModel, and a UiModel. Each would be tailored to its domain, which is why I call them domain-specific models*.Let’s go through each in turn:ApiModels match the API schema. They are immutable (because they’re just used for one-time communication) and nullable (since we might request a subset of fields).DbModels match the DB schema. They are mutable (because of OrmLite) but provide more non-null property guarantees. (In an ideal, non-ORM world, they would be immutable as well.)UiModels match whatever the UI needs. They are immutable and their properties are generally non-null.Between each of these models are converters. We send a network request to the server and get back an ApiModel; that’s converted into a DbModel for insertion into the database. Then the UI queries the database, which converts the DbModel into whatever UiModels the UI requires.If this all seems like a lot more work… that’s because it is! However, I’ve found that the high down payment is well worth the long-term low interest rate. While there’s a lot more code (especially converting from one model to another), it’s overall much simpler to grok and use.Also, it solves all of the problems outlined above: all data is available in each model, immutability can be achieved where it really counts, we can make more non-null guarantees, there’s only one name per property per model, and the UiModels can be limited to only the data needed and nothing more.There is one key trade-off you’re making here: domain-specific models are not as efficient as all-in-one models. They allocate more objects and add work when converting between the types. In practice I did not find this to be an issue, but of course your situation may be different, so make sure to measure and verify that this solution doesn’t bog down your application.In short: if you’re ever in a situation where a data model seems to be doing too much at once, try splitting it up into its separate domains. You’d be surprised how much of a win it can be.* It’s possible there’s a more formal name for this concept that already exists, let me know!Many thanks to Zac Sweers for reviewing this post!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eFor a long time at Trello Android, we used the same class for parsing API calls (via \u003ca href=\"https://github.com/google/gson?ref=blog.danlew.net\"\u003eGson\u003c/a\u003e), making DB transactions (via \u003ca href=\"https://ormlite.com/?ref=blog.danlew.net\"\u003eOrmLite\u003c/a\u003e), and displaying data in the UI.\u003c/p\u003e\u003cp\u003eHere’s a pseudo-code-y example of a board:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@DatabaseTable(tableName = \u0026#34;boards\u0026#34;)\ndata class Board(\n  @DatabaseField(columnName = “name”)\n  @SerializedName(\u0026#34;BoardName\u0026#34;)\n  private var boardName: String?,\n\n  private var cards: List\u0026lt;Card\u0026gt;?,\n\n  private var lastViewedTime: Long?\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile it was allocation efficient and somewhat convenient to have all this data in one place, more often it was just a pain in the ass:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eAvailability sadness \u003c/strong\u003e- Any given field might only be available some of the time. For example, \u003ccode\u003eBoard.cards\u003c/code\u003e is returned by the API, but a DB query would not return that field (since it was stored in a separate table). Conversely, we might store some local state in the DB (e.g., when the board was last viewed in the client via \u003ccode\u003eBoard.lastViewedTime\u003c/code\u003e) and that data wouldn’t be present in API responses.\u003c/p\u003e\u003cp\u003eIn both cases, it made figuring out what data was \u003cem\u003eactually\u003c/em\u003e available in any given place a minefield. Sure, you could do a null-check, but what if you \u003cem\u003ereally\u003c/em\u003e needed the data? How can you guarantee it’s available? It was hard to reason about the code.\u003c/p\u003e\u003cp\u003eOn top of that, it was a constant source of bugs while \u003ca href=\"https://blog.danlew.net/2017/02/14/airplane-mode-enabling-trello-mobile-offline/\"\u003emaking Trello Android work offline\u003c/a\u003e. Whenever we switched from API calls to DB queries, it would change which fields would be populated, causing issues.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMutability sadness \u003c/strong\u003e- These models were highly mutable because of OrmLite - even if we didn’t mutate them, OrmLite might when reusing objects via caching. A piece of the UI might query the DB for a \u003ccode\u003eBoard\u003c/code\u003e, use it once, then later use that exact same \u003ccode\u003eBoard\u003c/code\u003e instance again only to find that the \u003ccode\u003eBoard\u003c/code\u003e’s data changed in secret.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNullability sadness \u003c/strong\u003e- Trello’s API lets you choose which fields to return for any given query. As a result, we typically needed all fields to be nullable. When we switched to using Kotlin, we were constantly having to use \u003ccode\u003e!!\u003c/code\u003e or null-checks when we knew data was present but couldn’t prove it to the compiler.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNaming sadness\u003c/strong\u003e - A given field could have up to three different names - one for how it looks in the API, one for the column name in the DB, and one for the actual property in the model. This caused confusion, especially when writing generic logic based on the names of API or DB fields.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBloat sadness\u003c/strong\u003e - Perhaps some part of the UI only needs the board’s name - too bad! You’re getting a dozen other fields with it. A relatively minor problem compared to the others, but it always felt problematic to provide so much information to the UI that it wasn’t using. For one thing, it made testing more complex, since how could you guarantee that this random field \u003cem\u003ewasn’t\u003c/em\u003e being used when it was part of the input?\u003c/p\u003e\u003chr/\u003e\u003cp\u003eThere’s one root cause of all these problems: overloading the data model. Whenever we gave a field multiple roles at once, it caused sadness. Each layer - the API, the DB, and the UI - all had different needs, and there was no one-size-fits-all solution.\u003c/p\u003e\u003ch2 id=\"a-better-solution\"\u003eA Better Solution\u003c/h2\u003e\u003cp\u003eWhat do you do if you’ve got one class with too many roles? You split it up!\u003c/p\u003e\u003cp\u003eRather than one single OmniModel, we’d instead create (at least) three: an ApiModel, a DbModel, and a UiModel. Each would be tailored to its domain, which is why I call them domain-specific models*.\u003c/p\u003e\u003cp\u003eLet’s go through each in turn:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eApiModels\u003c/strong\u003e match the API schema. They are immutable (because they’re just used for one-time communication) and nullable (since we might request a subset of fields).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eDbModels\u003c/strong\u003e match the DB schema. They are mutable (because of OrmLite) but provide more non-null property guarantees. (In an ideal, non-ORM world, they would be immutable as well.)\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eUiModels\u003c/strong\u003e match whatever the UI needs. They are immutable and their properties are generally non-null.\u003c/p\u003e\u003cp\u003eBetween each of these models are converters. We send a network request to the server and get back an ApiModel; that’s converted into a DbModel for insertion into the database. Then the UI queries the database, which converts the DbModel into whatever UiModels the UI requires.\u003c/p\u003e\u003cp\u003eIf this all seems like a lot more work… that’s because it is! However, I’ve found that the high down payment is well worth the long-term low interest rate. While there’s a lot more code (especially converting from one model to another), it’s overall much simpler to grok and use.\u003c/p\u003e\u003cp\u003eAlso, it solves all of the problems outlined above: all data is available in each model, immutability can be achieved where it really counts, we can make more non-null guarantees, there’s only one name per property per model, and the UiModels can be limited to \u003cem\u003eonly\u003c/em\u003e the data needed and nothing more.\u003c/p\u003e\u003cp\u003eThere is one key trade-off you’re making here: domain-specific models are not as efficient as all-in-one models. They allocate more objects and add work when converting between the types. In practice I did not find this to be an issue, but of course your situation may be different, so make sure to measure and verify that this solution doesn’t bog down your application.\u003c/p\u003e\u003cp\u003eIn short: if you’re ever in a situation where a data model seems to be doing too much at once, try splitting it up into its separate domains. You’d be surprised how much of a win it can be.\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003e* It’s possible there’s a more formal name for this concept that already exists, let me know!\u003c/em\u003e\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003eMany thanks to \u003c/em\u003e\u003ca href=\"https://twitter.com/ZacSweers?ref=blog.danlew.net\"\u003e\u003cem\u003eZac Sweers\u003c/em\u003e\u003c/a\u003e\u003cem\u003e for reviewing this post!\u003c/em\u003e\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2022-08-15T13:00:40Z",
  "modifiedTime": "2022-08-15T13:00:40Z"
}
