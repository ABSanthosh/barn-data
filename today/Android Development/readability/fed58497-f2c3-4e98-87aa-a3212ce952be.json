{
  "id": "fed58497-f2c3-4e98-87aa-a3212ce952be",
  "title": "Concerning Jetpack Compose",
  "link": "https://chrynan.codes/concerns-with-the-jetpack-compose-library/",
  "description": "Jetpack Compose is an intriguing library but is not without concerns.",
  "author": "Christopher Keenan",
  "published": "Thu, 21 Nov 2019 19:03:08 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "android",
    "jetpack compose",
    "compose",
    "composable",
    "jetpack",
    "library",
    "declarative ui",
    "ui",
    "design",
    "design patterns",
    "layout",
    "view",
    "presentation",
    "kotlin",
    "dsl",
    "declarative"
  ],
  "byline": "Christopher Keenan",
  "length": 5736,
  "excerpt": "Jetpack Compose is an intriguing library but is not without concerns.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Jetpack Compose is an intriguing library but is not without concerns. Nov 21, 2019 • 3 min read The Jetpack Compose library provides the ability to create declarative and reactive UIs written in Kotlin for Android. It's another attempt to avoid XML layout files by allowing the creation of layouts in a DSL-esque manner. The library borrows heavily from cross-platform application frameworks like React Native and Flutter, but unlike those frameworks, it is meant solely for the Android platform and is written in Kotlin (similar to the Android View DSL library, Anko). While this library will surely continue to grow in prominence, there are some concerns I have about it.TL;DRJetpack Compose is a very intriguing library, but it's coupling of layouts and logic, along with it's inflexibility to adapt to a desired design pattern, are concerning.CodeThe following is a Jetpack Compose example taken from the official tutorial.@Composable fun NewsStory() { val image = +imageResource(R.drawable.header) MaterialTheme { Column( crossAxisSize = LayoutSize.Expand, modifier=Spacing(16.dp) ) { Container(expanded = true, height = 180.dp) { Clip(shape = RoundedCornerShape(8.dp)) { DrawImage(image) } } HeightSpacer(16.dp) Text(\"A day wandering through the sandhills in Shark \" + \"Fin Cove, and a few of the sights I saw\", maxLines = 2, overflow = TextOverflow.Ellipsis, style = (+themeTextStyle { h6 }).withOpacity(0.87f)) Text(\"Davenport, California\", style = (+themeTextStyle { body2 }).withOpacity(0.87f)) Text(\"December 2018\", style = (+themeTextStyle { body2 }).withOpacity(0.6f)) } } } ConcernsTightly coupled state management and layout logic.Inflexibility to adapt to different design patterns.No support for existing Views, such as, ConstraintLayout and RecyclerView.ElaborateTightly coupled state management and layout logic.The Layout now handles managing it's own state which is different than most currently used approaches where the Layout/View reacts to commands from the Presenter/ViewModel or User input. Instead, this new approach will couple the state management and the layout itself. Some of this maintenance is alleviated by the framework ( `+state { ... }` ), but for more complex state, custom State models will have to be created that conform to the framework using the appropriate annotations. This especially gets troublesome for Kotlin Multi-platform projects where part of the presentation code may be reusable and does not have access to an Android specific framework.Inflexibility to adapt to different design patterns.This issue is similar to the issue mentioned above with more of a focus on accessing the defined Layouts and Views. The Jetpack Compose library doesn't give you access to the underlying View object created. For instance, Text(\"\") will not return the \"TextView\" object. This makes it difficult to adapt to different design patterns other than the one the framework enforces. For example, in a Kotlin Multi-platform project, using Model-View-Presenter, the Models, View interfaces, and Presenters may be within a multi-platform presentation module. While the View implementations would be platform specific. Not having access to the underlying view and layout components makes implementing a View interface much more difficult.No support for existing Views, such as, ConstraintLayout and RecyclerViewMost of the examples given from blogs and even the official tutorial are very simple. They showcase an ideal \"Hello World\" like scenario but they don't showcase a real-world application with all the intracacies that come along with it.Common and popular layouts for Android that help with some of the complexities involved with layouts in applications are ConstraintLayout and RecyclerView. Since the Jetpack Compose library doesn't use the existing Android View components, it would have to recreate these. That's certainly not a trivial task. But these are two very important components for a proper layout library, and unfortunately, I haven't seen any alternative from Jetpack Compose.BonusWith Jetpack Compose, layouts are broken down into @Composable annotated functions. This is a nice approach to separating the complexity and making reusable components. An issue that this presents though, is access to other classes and resources within these functions. Ideally, you would have a Layout class that has constructor injected dependencies which can be accessible from the composable layout functions. But I'm not sure this is the case or if the library would allow this. If it doesn't than this is certainly a concern. Here's an example of what I'm visualizing:class MyLayout @Inject constructor(private val stringResources: StringResources) : Layout { override fun createLayout() = MyComposableFunction() @Composable fun MyComposableFunction() { Text(stringResources.helloWorld) } } EndThe Jetpack Compose library is a highly anticipated layout library/framework, especially as the Android Developer Community seeks to move further away from XML based layouts. But this library presents some valid concerns that should not be overlooked when considering the move.",
  "image": "https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eJetpack Compose is an intriguing library but is not without concerns.\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \u003cdiv\u003e\n                \n                \u003cp\u003e\u003ctime datetime=\"2019-11-21\"\u003eNov 21, 2019\u003c/time\u003e\n                        \u003cspan\u003e\u003cspan\u003e•\u003c/span\u003e 3 min read\u003c/span\u003e\n                \u003c/p\u003e\n            \u003c/div\u003e\n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=300 300w,\n                            https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=600 600w,\n                            https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=1000 1000w,\n                            https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://images.unsplash.com/photo-1453906971074-ce568cccbc63?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000\" alt=\"Concerning Jetpack Compose\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eThe \u003ca href=\"https://developer.android.com/jetpack/compose?ref=chrynan.codes\"\u003eJetpack Compose\u003c/a\u003e library provides the ability to create declarative and reactive UIs written in Kotlin for Android. It\u0026#39;s another attempt to avoid XML layout files by allowing the creation of layouts in a DSL-esque manner. The library borrows heavily from cross-platform application frameworks like \u003ca href=\"https://facebook.github.io/react-native/?ref=chrynan.codes\"\u003eReact Native\u003c/a\u003e and \u003ca href=\"https://flutter.dev/?ref=chrynan.codes\"\u003eFlutter\u003c/a\u003e, but unlike those frameworks, it is meant solely for the Android platform and is written in \u003ca href=\"https://kotlinlang.org/?ref=chrynan.codes\"\u003eKotlin\u003c/a\u003e (similar to the Android View DSL library, \u003ca href=\"https://github.com/Kotlin/anko?ref=chrynan.codes\"\u003eAnko\u003c/a\u003e). While this library will surely continue to grow in prominence, there are some concerns I have about it.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eJetpack Compose is a very intriguing library, but it\u0026#39;s coupling of layouts and logic, along with it\u0026#39;s inflexibility to adapt to a desired design pattern, are concerning.\u003c/p\u003e\u003ch3 id=\"code\"\u003eCode\u003c/h3\u003e\u003cp\u003eThe following is a Jetpack Compose example taken from the \u003ca href=\"https://developer.android.com/jetpack/compose/tutorial?ref=chrynan.codes\"\u003eofficial tutorial\u003c/a\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Composable\nfun NewsStory() {\n    val image = +imageResource(R.drawable.header)\n\n    MaterialTheme {\n        Column(\n            crossAxisSize = LayoutSize.Expand,\n            modifier=Spacing(16.dp)\n        ) {\n            Container(expanded = true, height = 180.dp) {\n                Clip(shape = RoundedCornerShape(8.dp)) {\n                    DrawImage(image)\n                }\n            }\n\n            HeightSpacer(16.dp)\n\n            Text(\u0026#34;A day wandering through the sandhills in Shark \u0026#34; +\n                \u0026#34;Fin Cove, and a few of the sights I saw\u0026#34;,\n                maxLines = 2, overflow = TextOverflow.Ellipsis,\n                style = (+themeTextStyle { h6 }).withOpacity(0.87f))\n            Text(\u0026#34;Davenport, California\u0026#34;,\n                style = (+themeTextStyle { body2 }).withOpacity(0.87f))\n            Text(\u0026#34;December 2018\u0026#34;,\n                style = (+themeTextStyle { body2 }).withOpacity(0.6f))\n        }\n    }\n}\n        \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"concerns\"\u003eConcerns\u003c/h3\u003e\u003cul\u003e\u003cli\u003eTightly coupled state management and layout logic.\u003c/li\u003e\u003cli\u003eInflexibility to adapt to different design patterns.\u003c/li\u003e\u003cli\u003eNo support for existing Views, such as, ConstraintLayout and RecyclerView.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"elaborate\"\u003eElaborate\u003c/h3\u003e\u003cul\u003e\u003cli\u003eTightly coupled state management and layout logic.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe Layout now handles managing it\u0026#39;s own state which is different than most currently used approaches where the Layout/View reacts to commands from the Presenter/ViewModel or User input. Instead, this new approach will couple the state management and the layout itself. Some of this maintenance is alleviated by the framework ( `+state { ... }` ), but for more complex state, custom State models will have to be created that conform to the framework using the appropriate annotations. This especially gets troublesome for Kotlin Multi-platform projects where part of the presentation code may be reusable and does not have access to an Android specific framework.\u003c/p\u003e\u003cul\u003e\u003cli\u003eInflexibility to adapt to different design patterns.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis issue is similar to the issue mentioned above with more of a focus on accessing the defined Layouts and Views. The Jetpack Compose library doesn\u0026#39;t give you access to the underlying View object created. For instance, \u003ccode\u003eText(\u0026#34;\u0026#34;)\u003c/code\u003e will not return the \u0026#34;TextView\u0026#34; object. This makes it difficult to adapt to different design patterns other than the one the framework enforces. For example, in a Kotlin Multi-platform project, using Model-View-Presenter, the Models, View interfaces, and Presenters may be within a multi-platform presentation module. While the View implementations would be platform specific. Not having access to the underlying view and layout components makes implementing a View interface much more difficult.\u003c/p\u003e\u003cul\u003e\u003cli\u003eNo support for existing Views, such as, ConstraintLayout and RecyclerView\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eMost of the examples given from blogs and even the official tutorial are very simple. They showcase an ideal \u0026#34;Hello World\u0026#34; like scenario but they don\u0026#39;t showcase a real-world application with all the intracacies that come along with it.\u003c/p\u003e\u003cp\u003eCommon and popular layouts for Android that help with some of the complexities involved with layouts in applications are \u003ccode\u003eConstraintLayout\u003c/code\u003e and \u003ccode\u003eRecyclerView\u003c/code\u003e. Since the Jetpack Compose library doesn\u0026#39;t use the existing Android View components, it would have to recreate these. That\u0026#39;s certainly not a trivial task. But these are two very important components for a proper layout library, and unfortunately, I haven\u0026#39;t seen any alternative from Jetpack Compose.\u003c/p\u003e\u003ch3 id=\"bonus\"\u003eBonus\u003c/h3\u003e\u003cp\u003eWith Jetpack Compose, layouts are broken down into \u003ccode\u003e@Composable\u003c/code\u003e annotated functions. This is a nice approach to separating the complexity and making reusable components. An issue that this presents though, is access to other classes and resources within these functions. Ideally, you would have a Layout class that has constructor injected dependencies which can be accessible from the composable layout functions. But I\u0026#39;m not sure this is the case or if the library would allow this. If it doesn\u0026#39;t than this is certainly a concern. Here\u0026#39;s an example of what I\u0026#39;m visualizing:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MyLayout @Inject constructor(private val stringResources: StringResources) : Layout {\n\n    override fun createLayout() = MyComposableFunction()\n    \n    @Composable\n    fun MyComposableFunction() {\n        Text(stringResources.helloWorld)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"end\"\u003eEnd\u003c/h3\u003e\u003cp\u003eThe Jetpack Compose library is a highly anticipated layout library/framework, especially as the Android Developer Community seeks to move further away from XML based layouts. But this library presents some valid concerns that should not be overlooked when considering the move.\u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2019-11-21T19:03:08Z",
  "modifiedTime": "2019-11-21T19:11:17Z"
}
