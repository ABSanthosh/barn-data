{
  "id": "6be231ff-d8af-4d24-9ddd-0dbe0d35d371",
  "title": "UseCases: Injectable Functions",
  "link": "https://chrynan.codes/usecases-injectable-functions/",
  "description": "This post demystifies use cases: they’re just functions with dependency injection. Single-purpose classes that simplify complex logic by letting DI handle dependencies, making code cleaner and testable.",
  "author": "Chris Keenan",
  "published": "Wed, 19 Mar 2025 22:59:19 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "kotlin",
    "usecase",
    "dependency injection",
    "dependency-injection",
    "abstraction",
    "soc",
    "dry",
    "clean-architecture",
    "architecture",
    "design-patterns"
  ],
  "byline": "Chris Keenan",
  "length": 6534,
  "excerpt": "This post demystifies use cases: they’re just functions with dependency injection. Single-purpose classes that simplify complex logic by letting DI handle dependencies, making code cleaner and testable.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "This post demystifies use cases: they’re just functions with dependency injection. Single-purpose classes that simplify complex logic by letting DI handle dependencies, making code cleaner and testable. If you’ve spent any time in modern Android development—or really any ecosystem that leans on clean architecture—you’ve probably bumped into the concept of \"use cases.\" Maybe you’ve seen them praised as a cornerstone of separation of concerns (SoC), or maybe you’ve rolled your eyes at yet another layer of abstraction. There’s a lot of confusion and even some resentment around use cases, so let’s cut through the noise: a use case is just an injectable function. That’s it. It’s a single-purposecomponent that behaves like a function but gets its dependencies handed to it via your dependency injection framework of choice. Let me explain.TLDRUse cases are single-purpose classes that act like functions but use dependency injection to handle their inputs—think reusable, testable functions without the parameter mess.What's a UseCase?A use case is a class that performs one specific piece of business logic. Consider the following example:public class ConnectToServerUseCase @Inject public constructor( private val serverRepository: ServerRepository, private val connectionManager: VPNConnectionManager, private val serverConnectionRecordRepository: ServerConnectionRecordRepository, private val clock: Clock ) { public suspend operator fun invoke(location: LocationCode): Boolean { val server = serverRepository.get(at = location) .firstOrNull() ?: return false val connected = connectionManager.connect(server) if (connected) { serverConnectionRecordRepository.record(server, timestamp = clock.now()) } return connected } }The above class ConnectToServerUseCase performs a simple business logic task for a VPN application: connects to a VPN server in the provided location. When performing this task, it might have some related logic it needs to perform every time, such as recording information about the connection and time, and returning a result of whether the connection was successful. Perhaps this function is invoked on multiple screens within an application, so isolating it into its own reusable component keeps things DRY and testable. The component can easily be injected into your ViewModel, and since we used Kotlin's `invoke` operator function, the component can be invoked as if it were a function within the ViewModel itself.public class ServerListViewModel @Inject constructor( private val connectToServer: ConnectToServerUseCase ... ) { ... public fun selectLocation(location: LocationCode) { coroutineScope.launch { val isConnected = connectToServer(location) emitUpdatedState { current -\u003e current.copy(isConnected) } } } }Now, the ConnectToServerUseCase can easily be tested by mocking its dependencies. The ViewModel can focus on performing application logic and updating the state appropriately. And the UseCase can be reused in other parts of the application. Clearly, this is a simple example created for this blog post, but it illustrates the point: a UseCase is just an \"injectable\" function. We could have just injected all those components into the ViewModel and used them in the selectLocation function, but that wouldn't be reusable throughout theapplication, it would be more difficult to test (as a whole ViewModel with multiple functions would have to be tested now), and that is not scalable for real world applications (as the functionality grows it becomes difficult to maintain). Likewise, we could have created a function, which takes all those components as parameters instead of injecting them in, but that would add pointless complexity to the call-site. So, instead we rely on our dependency injection framework to handle providing dependencies and we let our UseCases rely on performing business logic.Let's take a deeper look.Why Not Just a Function?Simple stuff like fun add(a: Int, b: Int) doesn’t need DI. But logic with dependencies—like connecting to a server—gets messy:suspend fun connectToServer( location: LocationCode, repo: ServerRepository, manager: VPNConnectionManager, recordRepo: ServerConnectionRecordRepository, clock: Clock ) { ... } val success = connectToServer(\"US-EAST\", repo, manager, recordRepo, clock)This violates DRY (Don't Repeat Yourself)—every call site repeats the wiring. A use case hands that to DI, keeping calls clean.The PayoffDI Magic: No manual dependency passing.Separation: One task, one component.Testing: Inject mocks easily.Consistency: Uniform structure.Reuse: Consistent reuse of code throughout the application.Are Use Cases Meant for Everything?No. They’re one tool in your toolbox, not the whole shed. Use cases shine when you’ve got a distinct piece of business logic that needs dependencies and reuse—like fetching user data and deriving data from it. But they don’t fit every scenario. Need a simple utility function like formatDate(date: Date)? No DI needed, no class required—just keep it a plain function. Throwing a use case at every line of code is overkill and misses the point. They’re a piece of the puzzle, but they don't fit everywhere. Know your problem, pick your tool.Why Do Use Cases Get So Much Pushback?Use cases can feel like overkill for small apps—more files, more boilerplate. Fair point. But they shine as complexity grows, keeping code modular and easier to scale. Not everything needs a UseCase, for instance if a UseCase is just acting as a intermediary simply delegating to a repository then it is definitely overkill. Or, if you find yourself trying to fit something into a UseCase, it might be a bit too much.I don't think UseCases are meant for everything, you'll still use your utility functions, \"manager\" components, repository abstractions, or simple functions, but they work great at separating complex business logic into digestible portions, reducing redundancy, and simplifying scalability.Embrace the InjectionUse cases turn functions into lean, DI-powered machines—simple to call, easy to test, built to scale. They’re not meant to overcomplicate; they’re meant to simplify where it counts. A good UseCase is simply a function that performs one task, injects its dependencies, and can be invoked just like a traditional function.",
  "image": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-4.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eThis post demystifies use cases: they’re just functions with dependency injection. Single-purpose classes that simplify complex logic by letting DI handle dependencies, making code cleaner and\ntestable.\u003c/p\u003e\n\n        \n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w300/2025/03/img-4.png 300w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w600/2025/03/img-4.png 600w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w1000/2025/03/img-4.png 1000w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-4.png 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2025/03/img-4.png\" alt=\"UseCases: Injectable Functions\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003cp\u003eIf you’ve spent any time in modern Android development—or really any ecosystem that leans on clean architecture—you’ve probably bumped into the concept of \u0026#34;use cases.\u0026#34; Maybe you’ve seen them praised as a cornerstone of separation of concerns (SoC), or maybe you’ve rolled your eyes at yet another layer of abstraction. There’s a lot of confusion and even some resentment around use cases, so let’s cut through the noise: a use case is just an injectable function. That’s it. It’s a single-purpose\u003cbr/\u003ecomponent that behaves like a function but gets its dependencies handed to it via your dependency injection framework of choice. Let me explain.\u003c/p\u003e\u003ch2 id=\"tldr\"\u003eTLDR\u003c/h2\u003e\u003cp\u003eUse cases are single-purpose classes that act like functions but use dependency injection to handle their inputs—think reusable, testable functions without the parameter mess.\u003c/p\u003e\u003ch3 id=\"whats-a-usecase\"\u003eWhat\u0026#39;s a UseCase?\u003c/h3\u003e\u003cp\u003eA use case is a class that performs one specific piece of business logic. Consider the following example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class ConnectToServerUseCase @Inject public constructor(\n    private val serverRepository: ServerRepository,\n    private val connectionManager: VPNConnectionManager,\n    private val serverConnectionRecordRepository: ServerConnectionRecordRepository,\n    private val clock: Clock\n) {\n\n    public suspend operator fun invoke(location: LocationCode): Boolean {\n        val server = serverRepository.get(at = location)\n            .firstOrNull()\n            ?: return false\n\n        val connected = connectionManager.connect(server)\n\n        if (connected) {\n            serverConnectionRecordRepository.record(server, timestamp = clock.now())\n        }\n\n        return connected\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe above class ConnectToServerUseCase performs a simple business logic task for a VPN application: connects to a VPN server in the provided location. When performing this task, it might have some related logic it needs to perform every time, such as recording information about the connection and time, and returning a result of whether the connection was successful. Perhaps this function is invoked on multiple screens within an application, so isolating it into its own reusable component keeps things \u003cstrong\u003eDRY\u003c/strong\u003e and \u003cstrong\u003etestable\u003c/strong\u003e. The component can easily be injected into your ViewModel, and since we used Kotlin\u0026#39;s `invoke` operator function, the component can be invoked as if it were a function within the ViewModel itself.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class ServerListViewModel @Inject constructor(\n    private val connectToServer: ConnectToServerUseCase\n    ...\n) {\n    ...\n\n    public fun selectLocation(location: LocationCode) {\n        coroutineScope.launch {\n            val isConnected = connectToServer(location)\n            emitUpdatedState { current -\u0026gt; current.copy(isConnected) }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, the \u003ccode\u003eConnectToServerUseCase\u003c/code\u003e can easily be tested by mocking its dependencies. The ViewModel can focus on performing application logic and updating the state appropriately. And the UseCase can be reused in other parts of the application. Clearly, this is a simple example created for this blog post, but it illustrates the point: a UseCase is just an \u0026#34;injectable\u0026#34; function. \u003c/p\u003e\u003cp\u003eWe could have just injected all those components into the ViewModel and used them in the selectLocation function, but that wouldn\u0026#39;t be reusable throughout the\u003cbr/\u003eapplication, it would be more difficult to test (as a whole ViewModel with multiple functions would have to be tested now), and that is not scalable for real world applications (as the functionality grows it becomes difficult to maintain). Likewise, we could have created a function, which takes all those components as parameters instead of injecting them in, but that would add pointless complexity to the call-site. So, instead we rely on our dependency injection framework to handle providing dependencies and we let our UseCases rely on performing business logic.\u003cbr/\u003e\u003c/p\u003e\u003cp\u003eLet\u0026#39;s take a deeper look.\u003c/p\u003e\u003ch3 id=\"why-not-just-a-function\"\u003eWhy Not Just a Function?\u003c/h3\u003e\u003cp\u003eSimple stuff like fun add(a: Int, b: Int) doesn’t need DI. But logic with dependencies—like connecting to a server—gets messy:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003esuspend fun connectToServer(\n    location: LocationCode,\n    repo: ServerRepository,\n    manager: VPNConnectionManager,\n    recordRepo: ServerConnectionRecordRepository,\n    clock: Clock\n) {\n    ...\n}\nval success = connectToServer(\u0026#34;US-EAST\u0026#34;, repo, manager, recordRepo, clock)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis violates \u003cstrong\u003eDRY (Don\u0026#39;t Repeat Yourself)\u003c/strong\u003e—every call site repeats the wiring. A use case hands that to DI, keeping calls clean.\u003c/p\u003e\u003ch3 id=\"the-payoff\"\u003eThe Payoff\u003c/h3\u003e\u003cul\u003e\u003cli\u003eDI Magic: No manual dependency passing.\u003c/li\u003e\u003cli\u003eSeparation: One task, one component.\u003c/li\u003e\u003cli\u003eTesting: Inject mocks easily.\u003c/li\u003e\u003cli\u003eConsistency: Uniform structure.\u003c/li\u003e\u003cli\u003eReuse: Consistent reuse of code throughout the application.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"are-use-cases-meant-for-everything\"\u003eAre Use Cases Meant for Everything?\u003c/h3\u003e\u003cp\u003eNo. They’re one tool in your toolbox, not the whole shed. Use cases shine when you’ve got a distinct piece of business logic that needs dependencies and reuse—like fetching user data and deriving data from it. But they don’t fit every scenario. Need a simple utility function like \u003ccode\u003eformatDate(date: Date)\u003c/code\u003e? No DI needed, no class required—just keep it a plain function. Throwing a use case at every line of code is overkill and misses the point. They’re a piece of the puzzle, but they don\u0026#39;t fit everywhere. Know your problem, pick your tool.\u003c/p\u003e\u003ch3 id=\"why-do-use-cases-get-so-much-pushback\"\u003eWhy Do Use Cases Get So Much Pushback?\u003c/h3\u003e\u003cp\u003eUse cases can feel like overkill for small apps—more files, more boilerplate. Fair point. But they shine as complexity grows, keeping code modular and easier to scale. Not everything needs a UseCase, for instance if a UseCase is just acting as a intermediary simply delegating to a repository then it is definitely overkill. Or, if you find yourself trying to fit something into a UseCase, it might be a bit too much.\u003c/p\u003e\u003cp\u003eI don\u0026#39;t think UseCases are meant for everything, you\u0026#39;ll still use your utility functions, \u0026#34;manager\u0026#34; components, repository abstractions, or simple functions, but they work great at separating complex business logic into digestible portions, reducing redundancy, and simplifying scalability.\u003c/p\u003e\u003ch3 id=\"embrace-the-injection\"\u003eEmbrace the Injection\u003c/h3\u003e\u003cp\u003eUse cases turn functions into lean, DI-powered machines—simple to call, easy to test, built to scale. They’re not meant to overcomplicate; they’re meant to simplify where it counts. A good UseCase is simply a function that performs one task, injects its dependencies, and can be invoked just like a traditional function.\u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-03-19T22:59:19Z",
  "modifiedTime": "2025-03-19T22:59:19Z"
}
