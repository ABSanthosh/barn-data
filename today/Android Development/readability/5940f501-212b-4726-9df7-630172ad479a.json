{
  "id": "5940f501-212b-4726-9df7-630172ad479a",
  "title": "From GraphQL to Kotlin",
  "link": "https://chrynan.codes/generate-graphql-schema-json-from-sdl-files/",
  "description": "Converting GraphQL SDL files to Kotlin Code",
  "author": "Christopher Keenan",
  "published": "Sat, 18 Jul 2020 23:39:28 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "graphql",
    "sdl",
    "kotlin",
    "kotlin-multiplatform",
    "graphkl",
    "apollo",
    "api",
    "convert",
    "generate",
    "code generation",
    "client"
  ],
  "byline": "Christopher Keenan",
  "length": 10409,
  "excerpt": "Converting GraphQL SDL files to Kotlin Code",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "That's one small step for [a] man, one giant leap for mankind. -- Neil ArmstrongGraphQL has redefined the way of writing APIs by providing an elegant way to declare and query data. Structuring models and their relationships, and querying those models for specific data can be done using a simple Schema Definition Language (SDL). GraphQL provides client applications with the flexibility to retreive data that they are interested in and reduces the need for multiple web requests.Using the appropriate tools, GraphQL Schemas and Queries can be used to generate Kotlin code for the client. This greatly expedites application development with GraphQL APIs. However, these tools typically require a functioning GraphQL API Server which could be introspected. This might be fine in most cases but I recently found myself in a scenario where I was simultaneously developing the API and the Client. So I had to devise an approach to generating Kotlin code from GraphQL SDL files instead of an endpoint that can be introspected. This article discusses the solution I decided on. TL;DRCreating a simple Gradle Task that loads the GraphQL SDL files and generates a schema.json file allowed me to use the apollo-android client to generate Kotlin code for interacting with the GraphQL API.The BackgroundFor awhile I had been working on different approaches to interacting with GraphQL APIs with Kotlin. My desire was to have a Kotlin Multi-platform GraphQL Library. I created a Kotlin Multi-platform GraphQL query builder library but there were some issues with this approach and I wasn't quite satisfied with it. So I began developing graphkl which was intended to be a complete Kotlin Multi-platform GraphQL Library. It had modules for parsing GraphQL SDLs, writing typesafe queries, and generating Kotlin code. Unfortunately, I was sidetracked and other projects garnered my attention. I always had the intent to go back to the graphkl project and finish developing it, but it seems that it might not be necessary anymore.There are now multiple Kotlin libraries that generate Kotlin code from GraphQL. Two of the more popular ones are graphql-kotlin and apollo-android. Despite it's name, apollo-android recently added experimental support for generating Kotlin Multi-platform code, which is the reason why I decided to go with this library.The ProblemThe apollo-android library provides both a runtime library and a Gradle Plugin that performs the code generation. The Gradle Plugin requires a schema.json file which defines your GraphQL API Schema. The Gradle Plugin provides a way to obtain this file by introspecting a specified endpoint to the server implementing the GraphQL API. But I didn't have a server running for my API, instead I had the GraphQL SDL files defining my Schema. Unfortunately, the apollo-android Gradle Plugin doesn't have a way to create the schema.json file from those SDL files.The SolutionSince the Kotlin code generation from apollo-android is done from a Gradle Plugin, I can create my own Gradle Task that creates the schema.json file and have it run before the code generation. While previously working on setting up the server, I used the graphql-java library. From my experience with the graphql-java library, I knew it was possible to create a Schema object from SDL files. I just had to figure out how to create the schema.json file from this object.That's when I stumbled across this new project on Github called gradle-plugin-graphql-schema-tools. It seems the developer was attempting to acheive a similar goal. With the help of these two projects, I was able to acheive my desired goal. The solution was to create a mocked RuntimeWiring object, combine that with the SDL files to create a Schema object, run an introspection query on that Schema, and output the result of executionResult.toSpecification() to a schema.json file.The CodeAs of the time of writing this post, the code can be found here which is located in the buildSrc directory of my Video repository. The most relevant class is the CreateSchemaJsonTask which can be found here.First, a mocked RuntimeWiring object is needed to perform the introspection query. This mock doesn't return any actual data but just echos the name and type that is being queried.private class MockedWiringFactory : EchoingWiringFactory() { override fun providesScalar(environment: ScalarWiringEnvironment): Boolean = !ScalarInfo.isGraphqlSpecifiedScalar(environment.scalarTypeDefinition.name) override fun getScalar(environment: ScalarWiringEnvironment): GraphQLScalarType = GraphQLScalarType.newScalar() .name(environment.scalarTypeDefinition.name) .coercing(object : Coercing\u003cAny, Any\u003e { override fun parseValue(input: Any): Any = throw UnsupportedOperationException(\"parseValue() function is not implemented.\") override fun parseLiteral(input: Any): Any = throw UnsupportedOperationException(\"parseLiteral() function is not implemented.\") override fun serialize(dataFetcherResult: Any): Any = throw UnsupportedOperationException(\"serialize() function is not implemented.\") }) .build() } An instance of this class can be obtained like so:val mockRuntimeWiring = RuntimeWiring.newRuntimeWiring().wiringFactory(MockedWiringFactory()).build() Then a TypeDefinitionRegistry needs to be created using the GraphQL SDL files.val parser = SchemaParser() val typeRegistry = TypeDefinitionRegistry() (graphQLDirectory.listFiles()?.toList() ?: emptyList()) .filter { it.isFile \u0026\u0026 (it.path.endsWith(\".graphql\") || it.path.endsWith(\".graphqls\") || it.path.endsWith(\".gql\")) } .forEach { typeRegistry.merge(parser.parse(it)) } Then the Schema needs to be generated and an instropection query needs to be run on it.val schema = SchemaGenerator().makeExecutableSchema(typeRegistry, mockRuntimeWiring) val graphQL = GraphQL.newGraphQL(schema).build() val executionResult = graphQL.execute(IntrospectionQuery.INTROSPECTION_QUERY) Finally the schema.json file can be created with the introspection result.val output = JSONObject(executionResult.toSpecification()) val outputFile = File(schemaDirectory, \"schema.json\") outputFile.writeText(output.toString()) Then all that is needed is to have the generateApolloSources task depend on this newly created Task. Now, everytime the GraphQL SDL files are updated and the project is built, the schema.json file will be generated, followed by the Kotlin code using that schema.json file.The ExampleNow that the Gradle schema.json Task is created, let's have a look at an example of using the apollo-android library. The API used in this example is available here. The API GraphQL SDL files directory location is provided to the CreateSchemaJsonTask in the build.gradle file. Then the output schema.json file is placed in the src/commonMain/graphql directory, along with the GraphQL Queries on the API, which the apollo-android Gradle Plugin will use to generate the Kotlin Code to execute the queries. Â The following are the relevant parts of the GraphQL Schema for this example:schema { query: Query mutation: Mutation } type Query @access(type: OPEN) { apiVersion: String! @access(type: OPEN) login: LoginInfo! @access(type: OPEN) provider: ProviderInfo! @access(type: OPEN) viewer: Viewer! @access(type: LOGIN_STRATEGY) search(query: String!, take: Int!, after: Cursor): SearchResultConnection! @access(type: LOGIN_STRATEGY) feed(take: Int!, after: Cursor): FeedConnection! @access(type: LOGIN_STRATEGY) } type ProviderInfo implements TimeDetail @access(type: OPEN) { created: DateTime! lastUpdated: DateTime! uri: UriString! name: String! description: String about: String website: String contactEmail: String images: ProviderImageInfo! } type ProviderImageInfo @access(type: OPEN) { thumbnail: UriString banner: UriString } Then we can create any GraphQL Queries in .graphql files in the src/commonMain/graphql directory. The following is an example of a query:query ProviderInfoQuery { apiVersion provider { created lastUpdated uri name images { banner thumbnail } } } After building the project, the Kotlin Code for the above query should be generated. Performing the query is then relatively simple:val result: Flow\u003cResponse\u003cProviderInfoQuery.Data\u003e\u003e = apolloClient.query(ProviderInfoQuery()).execute() The EndGraphQL is a modern approach to developing APIs that provides flexibility to the client applications. The apollo-android library makes GraphQL accessible to Kotlin Multi-platform projects. With the guidance of this post, it is my hope that developing GraphQL APIs, from a Kotlin perspective, will become efficient, trivial, and enjoyable. I began this post with a quote from the Apollo 11 astronaut Neil Armstrong and an image of an Apollo Lunar Landing Module. These were deliberately chosen as a reference to the apollo-android library. Apollo was an ancient Greek and Roman Olympian Deity which was perhaps the inspiration for the Apollo Program. It seems as though the naming of the Apollo GraphQL organization was inspired by the Apollo Program due to their constant use of space like imagery. Due to this, I found it fitting to reference the Apollo Program in this post, and as such, ending in the same manner. I feel we need to remind the world about the Apollo missions and that we can still do impossible things. -- Buzz AldrinThe UpdateIt looks as though the apollo-android library added support for an SDL schema file called schema.sdl which may provide similar functionality to what this post describes. However, it seems that they only currently support a single .sdl file for the Schema, so in my particular case, the approach described in this article is still much better, as it allows me to have multiple .graphql files representing my Schema and from those it generates a single schema.json file to be used by the library. The PR adding the schema.sdl support can be found here: https://github.com/apollographql/apollo-android/pull/2417/files",
  "image": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/image-from-rawpixel-id-418656-jpeg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cblockquote\u003e\n\u003cp\u003eThat\u0026#39;s one small step for [a] man, one giant leap for mankind.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e-- \u003ca href=\"https://en.wikiquote.org/wiki/Neil_Armstrong?ref=chrynan.codes\"\u003eNeil Armstrong\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://graphql.org/?ref=chrynan.codes\"\u003eGraphQL\u003c/a\u003e has redefined the way of writing APIs by providing an elegant way to declare and query data. Structuring models and their relationships, and querying those models for specific data can be done using a simple Schema Definition Language (SDL). GraphQL provides client applications with the flexibility to retreive data that they are interested in and reduces the need for multiple web requests.\u003c/p\u003e\u003cp\u003eUsing the appropriate tools, GraphQL Schemas and Queries can be used to generate Kotlin code for the client. This greatly expedites application development with GraphQL APIs. However, these tools typically require a functioning GraphQL API Server which could be introspected. This might be fine in most cases but I recently found myself in a scenario where I was simultaneously developing the API and the Client. So I had to devise an approach to generating Kotlin code from GraphQL SDL files instead of an endpoint that can be introspected. This article discusses the solution I decided on. \u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eCreating a simple Gradle Task that loads the GraphQL SDL files and generates a \u003ccode\u003eschema.json\u003c/code\u003e file allowed me to use the \u003ccode\u003eapollo-android\u003c/code\u003e client to generate Kotlin code for interacting with the GraphQL API.\u003c/p\u003e\u003ch3 id=\"the-background\"\u003eThe Background\u003c/h3\u003e\u003cp\u003eFor awhile I had been working on different approaches to interacting with GraphQL APIs with Kotlin. My desire was to have a Kotlin Multi-platform GraphQL Library. I created a Kotlin Multi-platform GraphQL \u003ca href=\"https://github.com/chRyNaN/graphql-query-builder?ref=chrynan.codes\"\u003equery builder library\u003c/a\u003e but there were some issues with this approach and I wasn\u0026#39;t quite satisfied with it. So I began developing \u003ca href=\"https://github.com/chRyNaN/graphkl?ref=chrynan.codes\"\u003egraphkl\u003c/a\u003e which was intended to be a complete Kotlin Multi-platform GraphQL Library. It had modules for parsing GraphQL SDLs, writing typesafe queries, and generating Kotlin code. Unfortunately, I was sidetracked and other projects garnered my attention. I always had the intent to go back to the \u003ccode\u003egraphkl\u003c/code\u003e project and finish developing it, but it seems that it might not be necessary anymore.\u003c/p\u003e\u003cp\u003eThere are now multiple Kotlin libraries that generate Kotlin code from GraphQL. Two of the more popular ones are \u003ca href=\"https://github.com/ExpediaGroup/graphql-kotlin?ref=chrynan.codes\"\u003egraphql-kotlin\u003c/a\u003e and \u003ca href=\"https://github.com/apollographql/apollo-android?ref=chrynan.codes\"\u003eapollo-android\u003c/a\u003e. Despite it\u0026#39;s name, \u003ccode\u003eapollo-android\u003c/code\u003e recently added experimental support for generating Kotlin Multi-platform code, which is the reason why I decided to go with this library.\u003c/p\u003e\u003ch3 id=\"the-problem\"\u003eThe Problem\u003c/h3\u003e\u003cp\u003eThe \u003ccode\u003eapollo-android\u003c/code\u003e library provides both a runtime library and a Gradle Plugin that performs the code generation. The Gradle Plugin requires a \u003ccode\u003eschema.json\u003c/code\u003e file which defines your GraphQL API Schema. The Gradle Plugin provides a way to obtain this file by introspecting a specified endpoint to the server implementing the GraphQL API. But I didn\u0026#39;t have a server running for my API, instead I had the GraphQL SDL files defining my Schema. Unfortunately, the \u003ccode\u003eapollo-android\u003c/code\u003e Gradle Plugin doesn\u0026#39;t have a way to create the \u003ccode\u003eschema.json\u003c/code\u003e file from those SDL files.\u003c/p\u003e\u003ch3 id=\"the-solution\"\u003eThe Solution\u003c/h3\u003e\u003cp\u003eSince the Kotlin code generation from \u003ccode\u003eapollo-android\u003c/code\u003e is done from a Gradle Plugin, I can create my own Gradle Task that creates the \u003ccode\u003eschema.json\u003c/code\u003e file and have it run before the code generation. While previously working on setting up the server, I used the \u003ca href=\"https://github.com/graphql-java/graphql-java?ref=chrynan.codes\"\u003egraphql-java\u003c/a\u003e library. From my experience with the \u003ccode\u003egraphql-java\u003c/code\u003e library, I knew it was possible to create a Schema object from SDL files. I just had to figure out how to create the \u003ccode\u003eschema.json\u003c/code\u003e file from this object.\u003c/p\u003e\u003cp\u003eThat\u0026#39;s when I stumbled across this new project on Github called \u003ca href=\"https://github.com/symbaloo/gradle-plugin-graphql-schema-tools?ref=chrynan.codes\"\u003egradle-plugin-graphql-schema-tools\u003c/a\u003e. It seems the developer was attempting to acheive a similar goal. With the help of these two projects, I was able to acheive my desired goal. The solution was to create a mocked \u003ccode\u003eRuntimeWiring\u003c/code\u003e object, combine that with the SDL files to create a \u003ccode\u003eSchema\u003c/code\u003e object, run an introspection query on that Schema, and output the result of \u003ccode\u003eexecutionResult.toSpecification()\u003c/code\u003e to a \u003ccode\u003eschema.json\u003c/code\u003e file.\u003c/p\u003e\u003ch3 id=\"the-code\"\u003eThe Code\u003c/h3\u003e\u003cp\u003eAs of the time of writing this post, the code can be found \u003ca href=\"https://github.com/chRyNaN/Video/tree/master/buildSrc/src/main/kotlin/com/chrynan/video/plugins/schema?ref=chrynan.codes\"\u003ehere\u003c/a\u003e which is located in the \u003ccode\u003ebuildSrc\u003c/code\u003e directory of my \u003ca href=\"https://github.com/chRyNaN/Video?ref=chrynan.codes\"\u003eVideo\u003c/a\u003e repository. The most relevant class is the \u003ccode\u003eCreateSchemaJsonTask\u003c/code\u003e which can be found \u003ca href=\"https://github.com/chRyNaN/Video/blob/master/buildSrc/src/main/kotlin/com/chrynan/video/plugins/schema/CreateSchemaJsonTask.kt?ref=chrynan.codes\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cul\u003e\u003cli\u003eFirst, a mocked \u003ccode\u003eRuntimeWiring\u003c/code\u003e object is needed to perform the introspection query. This mock doesn\u0026#39;t return any actual data but just echos the name and type that is being queried.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eprivate class MockedWiringFactory : EchoingWiringFactory() {\n\n        override fun providesScalar(environment: ScalarWiringEnvironment): Boolean =\n            !ScalarInfo.isGraphqlSpecifiedScalar(environment.scalarTypeDefinition.name)\n\n        override fun getScalar(environment: ScalarWiringEnvironment): GraphQLScalarType =\n            GraphQLScalarType.newScalar()\n                .name(environment.scalarTypeDefinition.name)\n                .coercing(object : Coercing\u0026lt;Any, Any\u0026gt; {\n\n                    override fun parseValue(input: Any): Any =\n                        throw UnsupportedOperationException(\u0026#34;parseValue() function is not implemented.\u0026#34;)\n\n                    override fun parseLiteral(input: Any): Any =\n                        throw UnsupportedOperationException(\u0026#34;parseLiteral() function is not implemented.\u0026#34;)\n\n                    override fun serialize(dataFetcherResult: Any): Any =\n                        throw UnsupportedOperationException(\u0026#34;serialize() function is not implemented.\u0026#34;)\n                })\n                .build()\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn instance of this class can be obtained like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval mockRuntimeWiring =      RuntimeWiring.newRuntimeWiring().wiringFactory(MockedWiringFactory()).build()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eThen a \u003ccode\u003eTypeDefinitionRegistry\u003c/code\u003e needs to be created using the GraphQL SDL files.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eval parser = SchemaParser()\nval typeRegistry = TypeDefinitionRegistry()\n\n(graphQLDirectory.listFiles()?.toList() ?: emptyList())\n            .filter {\n                it.isFile \u0026amp;\u0026amp; (it.path.endsWith(\u0026#34;.graphql\u0026#34;) ||\n                        it.path.endsWith(\u0026#34;.graphqls\u0026#34;) ||\n                        it.path.endsWith(\u0026#34;.gql\u0026#34;))\n            }\n            .forEach { typeRegistry.merge(parser.parse(it)) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eThen the \u003ccode\u003eSchema\u003c/code\u003e needs to be generated and an instropection query needs to be run on it.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eval schema = SchemaGenerator().makeExecutableSchema(typeRegistry, mockRuntimeWiring)\n\nval graphQL = GraphQL.newGraphQL(schema).build()\n\nval executionResult = graphQL.execute(IntrospectionQuery.INTROSPECTION_QUERY)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\u003cli\u003eFinally the \u003ccode\u003eschema.json\u003c/code\u003e file can be created with the introspection result.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eval output = JSONObject(executionResult.toSpecification())\n\nval outputFile = File(schemaDirectory, \u0026#34;schema.json\u0026#34;)\n\noutputFile.writeText(output.toString())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen all that is needed is to have the \u003ccode\u003egenerateApolloSources\u003c/code\u003e task depend on this newly created Task. Now, everytime the GraphQL SDL files are updated and the project is built, the \u003ccode\u003eschema.json\u003c/code\u003e file will be generated, followed by the Kotlin code using that \u003ccode\u003eschema.json\u003c/code\u003e file.\u003c/p\u003e\u003ch3 id=\"the-example\"\u003eThe Example\u003c/h3\u003e\u003cp\u003eNow that the Gradle \u003ccode\u003eschema.json\u003c/code\u003e Task is created, let\u0026#39;s have a look at an example of using the \u003ccode\u003eapollo-android\u003c/code\u003e library. The API used in this example is available \u003ca href=\"https://github.com/chRyNaN/Video/tree/master/api/graphql?ref=chrynan.codes\"\u003ehere\u003c/a\u003e. The API GraphQL SDL files directory location is provided to the \u003ccode\u003eCreateSchemaJsonTask\u003c/code\u003e in the \u003ccode\u003ebuild.gradle\u003c/code\u003e file. Then the output \u003ccode\u003eschema.json\u003c/code\u003e file is placed in the \u003ccode\u003esrc/commonMain/graphql\u003c/code\u003e directory, along with the GraphQL Queries on the API, which the \u003ccode\u003eapollo-android\u003c/code\u003e Gradle Plugin will use to generate the Kotlin Code to execute the queries. Â The following are the relevant parts of the GraphQL Schema for this example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eschema {\n    query: Query\n    mutation: Mutation\n}\n\ntype Query @access(type: OPEN) {\n    apiVersion: String! @access(type: OPEN)\n    login: LoginInfo! @access(type: OPEN)\n    provider: ProviderInfo! @access(type: OPEN)\n    viewer: Viewer! @access(type: LOGIN_STRATEGY)\n    search(query: String!, take: Int!, after: Cursor): SearchResultConnection! @access(type: LOGIN_STRATEGY)\n    feed(take: Int!, after: Cursor): FeedConnection! @access(type: LOGIN_STRATEGY)\n}\n\ntype ProviderInfo implements TimeDetail @access(type: OPEN) {\n    created: DateTime!\n    lastUpdated: DateTime!\n    uri: UriString!\n    name: String!\n    description: String\n    about: String\n    website: String\n    contactEmail: String\n    images: ProviderImageInfo!\n}\n\ntype ProviderImageInfo @access(type: OPEN) {\n    thumbnail: UriString\n    banner: UriString\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen we can create any GraphQL Queries in \u003ccode\u003e.graphql\u003c/code\u003e files in the \u003ccode\u003esrc/commonMain/graphql\u003c/code\u003e directory. The following is an example of a query:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003equery ProviderInfoQuery {\n    apiVersion\n    provider {\n        created\n        lastUpdated\n        uri\n        name\n        images {\n            banner\n            thumbnail\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter building the project, the Kotlin Code for the above query should be generated. Performing the query is then relatively simple:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval result: Flow\u0026lt;Response\u0026lt;ProviderInfoQuery.Data\u0026gt;\u0026gt; = apolloClient.query(ProviderInfoQuery()).execute()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"the-end\"\u003eThe End\u003c/h3\u003e\u003cp\u003eGraphQL is a modern approach to developing APIs that provides flexibility to the client applications. The \u003ccode\u003eapollo-android\u003c/code\u003e library makes GraphQL accessible to Kotlin Multi-platform projects. With the guidance of this post, it is my hope that developing GraphQL APIs, from a Kotlin perspective, will become efficient, trivial, and enjoyable. \u003c/p\u003e\u003cp\u003eI began this post with a quote from the Apollo 11 astronaut Neil Armstrong and an image of an Apollo Lunar Landing Module. These were deliberately chosen as a reference to the \u003cstrong\u003eapollo\u003c/strong\u003e-android library. \u003ca href=\"https://en.wikipedia.org/wiki/Apollo?ref=chrynan.codes\"\u003eApollo\u003c/a\u003e was an ancient Greek and Roman Olympian Deity which was perhaps the inspiration for the \u003ca href=\"https://en.wikipedia.org/wiki/Apollo_program?ref=chrynan.codes\"\u003eApollo Program\u003c/a\u003e. It seems as though the naming of the \u003ca href=\"https://www.apollographql.com/?ref=chrynan.codes\"\u003eApollo GraphQL\u003c/a\u003e organization was inspired by the \u003ca href=\"https://en.wikipedia.org/wiki/Apollo_program?ref=chrynan.codes\"\u003eApollo Program\u003c/a\u003e due to their constant use of space like imagery. Due to this, I found it fitting to reference the Apollo Program in this post, and as such, ending in the same manner.\u003c/p\u003e\u003cblockquote\u003e\n\u003cp\u003eI feel we need to remind the world about the Apollo missions and that we can still do impossible things.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e-- \u003ca href=\"https://www.brainyquote.com/quotes/buzz_aldrin_679902?ref=chrynan.codes\"\u003eBuzz Aldrin\u003c/a\u003e\u003c/p\u003e\u003ch3 id=\"the-update\"\u003eThe Update\u003c/h3\u003e\u003cp\u003eIt looks as though the \u003ccode\u003eapollo-android\u003c/code\u003e library added support for an SDL schema file called \u003ccode\u003eschema.sdl\u003c/code\u003e which may provide similar functionality to what this post describes. However, it seems that they only currently support a single \u003ccode\u003e.sdl\u003c/code\u003e file for the Schema, so in my particular case, the approach described in this article is still much better, as it allows me to have multiple \u003ccode\u003e.graphql\u003c/code\u003e files representing my Schema and from those it generates a single \u003ccode\u003eschema.json\u003c/code\u003e file to be used by the library. The PR adding the \u003ccode\u003eschema.sdl\u003c/code\u003e support can be found here: \u003ca href=\"https://github.com/apollographql/apollo-android/pull/2417/files?ref=chrynan.codes\"\u003ehttps://github.com/apollographql/apollo-android/pull/2417/files\u003c/a\u003e\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2020-07-18T23:39:28Z",
  "modifiedTime": "2023-02-07T15:12:26Z"
}
