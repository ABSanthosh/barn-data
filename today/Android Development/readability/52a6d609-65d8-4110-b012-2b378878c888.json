{
  "id": "52a6d609-65d8-4110-b012-2b378878c888",
  "title": "Future Of Android: Why Navigation 3 is a Game-Changer!",
  "link": "https://proandroiddev.com/future-of-android-why-navigation-3-is-a-game-changer-f835f841c17f?source=rss----c72404660798---4",
  "description": "",
  "author": "ashiqfury",
  "published": "Sat, 21 Jun 2025 16:17:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "compose",
    "jetpack-compose",
    "jetpack-navigation"
  ],
  "byline": "ashiqfury",
  "length": 8426,
  "excerpt": "Hello android developers, lets be honest, how many times have you pulled your hair out trying to manage navigation? Its been a nightmare, right? We have all been writing custom code make it suits our…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Hello android developers, lets be honest, how many times have you pulled your hair out trying to manage navigation? Its been a nightmare, right? We have all been writing custom code make it suits our use case.From now, we have a new relief called Navigation 3. A new navigation compose navigation library that fits all our use cases at ease. It uses a backstack which is handled by the developers, that means, we have a full control over our navigation backstack.Lets Clear a Big MisconceptionBefore going further, we need to understand one golden rule: Navigation is NOT your UI.Think of it like this. You go to a restaurant. The menu is your navigation. It tells you what dishes are available (screens) and helps you which dish you want to order (screen to show). The actual food on your plate is the UI. The menu does not care if your biryani is spicy or your lemon mint is salty. It just guides you to it.Similarly, your navigation logics should only care about which screen to show and when it should happen. It should not be tightly coupled with your UI components, like directly passing the backstack into the screen and drilling it to components also. It limits the component reusability and difficulty in testing screens.The Real-World Tension: The Old Way vs. The Compose WayWe all know, Jetpack Compose is all about states. You describe your UI based on the current state, and when the state changes, the UI will automatically updates. Simple, right? Then why not the old navigation system works the same way?The reason why because the old Navigation Compose library was more like event-based. Here is where the actual problem arise.Imagine you’re navigating from your `Home` screen to your `Profile` screen.1. The Click: The user taps the “Profile” button.2. The Split-Second Confusion: Your app’s main state (viewmodel) instantly changes to say, “Okay, we are on the Profile screen now.” But it sends an event to the Navigation library.3. The Lag: For a moment, your app state thinks it’s on “Profile,” but the navigation library’s internal state is still on “Home.” They are out of sync!4. The Catch-Up: The navigation library finally processes the event, updates its own state, and then the UI changes.This little sync mismatch results unpredictable behaviour and a lot of debugging tension. In Navigation 3, instead of working with events, we have more control on backstack state. We can create our own backstack and manage it in our app.val backstack = remember { mutableStateListOf\u003cAny\u003e() }NavDisplay( // Similar to NavHost in old Nav library. backStack = backstack, ...)By having this, we can add or remove entries from the backstack (at any index, just like List). This Navigation 3 throws away event-based model and brings state-based just like Compose. There is no events here, directly updating the navigation state, which prevents the issues which I mentioned above and also it gives more flexibility on handling navigation states on real world use cases.So, how does the same flow work with Navigation 3?1. The Click: User taps the “Profile” button.2. One State to Rule Them All: You update your app’s state to “Profile.”3. That’s It! Navigation 3 is constantly watching your app state. The moment it sees the state change to “Profile,” it automatically shows the Profile screen.There is no separate navigation state. Your app state is the single source of truth, and everything else just follows its lead. So simple and so powerful!Lets get into the implementation:Implementing Navigation 3 is pretty straightforward, but with more flexibility in defining navigation flows, supporting dynamic UI patterns like bottom sheets, and handling backstack behavior seamlessly in Jetpack Compose.Navigation 3 DependenciesIn libs.version.toml[versions]nav3 = \"1.0.0-alpha01\"viewmodel = \"1.0.0-alpha01\"[libraries]# Core Navigation 3 librariesandroidx-navigation3-runtime = { module = \"androidx.navigation3:navigation3-runtime\", version.ref = \"nav3\" }androidx-navigation3-ui = { module = \"androidx.navigation3:navigation3-ui\", version.ref = \"nav3\" }# Optional add-on librariesandroidx-lifecycle-viewmodel-navigation3 = { module = \"androidx.lifecycle:lifecycle-viewmodel-navigation3\", version.ref = \"viewmodel\" }[plugins]jetbrains-kotlin-serialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlinSerialization\"}In build.gradle (app)plugins { ... alias(libs.plugins.jetbrains.kotlin.serialization)}dependencies { ... implementation(libs.androidx.navigation3.ui) implementation(libs.androidx.navigation3.runtime) implementation(libs.androidx.lifecycle.viewmodel.navigation3)}Also, update your compile SDK to 36.NavDisplay SetupWhen creating a new nav key, we should extend the NavKey from Nav3. Additionally, make sure your entry is Serializable. Lets create two new nav entries.import androidx.navigation3.runtime.NavKey@Serializabledata object NotesList: NavKey@Serializabledata class NoteDetail(val noteId: String): NavKeyWe can create our app’s navigation state by two ways:mutableStateListOf(…)rememberNavBackStack(…)Using rememberNavBackStack() will automatically remembers the hierarchy across configuration change and process death.To associate the screens to the key, it should be done through entryProvider parameter in NavDisplay. It gives navKey as a parameter, and expect a NavEntry. We can use the navKey to associate the screen using when statement.In this example, we are returning NavEntry to the entryProvider. NavEntry accepts three parameters:key: The navKey of the screen, which we get from entryProvider itself.metadata (optional): This accepts a map to provide additional information about the behaviour of the screen to display.content: The Composable screen content which we need to display.Before we going further, lets complete our NotesListScreen and NoteDetailScreen .NotesListScreen.ktIn this screen, we are displaying a list of Text showing Note Id. Passing the navigation callback into the screen will helps in separation of UI and Navigation logics.NoteDetailScreen.ktIn this screen, we are displaying a simple Text showing the received Note Id from the parameter.If we run the app, we can see something like this:Navigation Demo on Compose Navigation 3 LibraryFacing IllegalStateException on App Boot:java.lang.IllegalStateException: No NavigationEventDispatcher was provided via LocalNavigationEventDispatcherOwnerIf you are getting this error when running, change your activity-compose version into 1.12.0-alpha01Now, Lets explore some other parameters of NavDisplay briefly:SceneStrategy:NavDisplay( sceneStrategy = SinglePaneSceneStrategy(),)Scene Strategy determines how the screens are visually displayed in your app.It controls whether the navigation stack should show single screen at a time or multiple screens together.By default, it uses SinglePaneSceneStrategy , only top most screen is visible.We can customise this behaviour to create custom adaptive layouts.OnBack:NavDisplay( ... onBack = { entries: Int -\u003e if (backstack.isNotEmpty()) { backstack.removeLastOrNull() } })Called when system back press is called. It gives entries count, represents the number of scenes to be removed, typically used on custom SceneStrategy.Entry Decorators:It accepts list of NavEntryDecorators , which adds behaviour like saved state or viewModel retention to screens.There are some decorators:- rememberSceneSetupNavEntryDecorator() — Lifecycle setup.- rememberSavedStateNavEntryDecorator() — Saves state.- rememberViewModelStoreNavEntryDecorator() — Retains viewModel.Size Transform: — Animates size changes during transition. By default, no transition size animation should be occured.Transition Spec \u0026 Pop Transition Spec: —NavDisplay( ... transitionSpec = { ContentTransform( fadeIn(tween(300)), fadeOut(tween(300)) ) })Defines enter and exit animations for forward or backward navigation.Predictive Pop Transition Spec: — Advanced animation for predictive back gesture.SummaryNavigation 3 is not just an upgrade, its a fundamental shift toward more maintainable, scaleable and user-friendly navigation in compose apps. Nav3 represents a leap forward in clarity and control. By providing declarative navigation graphs, type-safe routes and custom scene strategies, developers can now build more intrutive and adaptive navigaion flows with ease.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*3D5rG5u0pH0fGSn2",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"2f4c\"\u003e\u003cspan\u003eH\u003c/span\u003eello android developers, lets be honest, how many times have you pulled your hair out trying to manage navigation? Its been a nightmare, right? We have all been writing custom code make it suits our use case.\u003c/p\u003e\u003cp id=\"c2bf\"\u003eFrom now, we have a new relief called \u003cstrong\u003eNavigation 3\u003c/strong\u003e. A new navigation compose navigation library that fits all our use cases at ease. It uses a backstack which is handled by the developers, that means, we have a full control over our navigation backstack.\u003c/p\u003e\u003ch2 id=\"4f33\"\u003eLets Clear a Big Misconception\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"2c84\"\u003eBefore going further, we need to understand one golden rule: \u003cstrong\u003eNavigation is NOT your UI.\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3462\"\u003eThink of it like this. You go to a restaurant. The menu is your \u003cstrong\u003enavigation\u003c/strong\u003e. It tells you what dishes are available (screens) and helps you which dish you want to order (screen to show). The actual food on your plate is the \u003cstrong\u003eUI\u003c/strong\u003e. The menu does not care if your biryani is spicy or your lemon mint is salty. It just guides you to it.\u003c/p\u003e\u003cp id=\"c3e8\"\u003eSimilarly, your navigation logics should only care about \u003cstrong\u003ewhich\u003c/strong\u003e screen to show and \u003cstrong\u003ewhen\u003c/strong\u003e it should happen. It should not be tightly coupled with your UI components, like directly passing the backstack into the screen and drilling it to components also. It limits the component reusability and difficulty in testing screens.\u003c/p\u003e\u003ch2 id=\"c062\"\u003eThe Real-World Tension: The Old Way vs. The Compose Way\u003c/h2\u003e\u003cp id=\"2b77\"\u003eWe all know, Jetpack Compose is all about \u003cstrong\u003estates\u003c/strong\u003e. You describe your UI based on the current state, and when the state changes, the UI will automatically updates. Simple, right? Then why not the old navigation system works the same way?\u003c/p\u003e\u003cp id=\"1c8a\"\u003eThe reason why because the old Navigation Compose library was more like \u003cstrong\u003eevent-based\u003c/strong\u003e. Here is where the actual problem arise.\u003c/p\u003e\u003cp id=\"0504\"\u003eImagine you’re navigating from your `Home` screen to your `Profile` screen.\u003c/p\u003e\u003cp id=\"5814\"\u003e1. \u003cstrong\u003eThe Click:\u003c/strong\u003e The user taps the “Profile” button.\u003cbr/\u003e2. \u003cstrong\u003eThe Split-Second Confusion:\u003c/strong\u003e Your app’s main state (viewmodel) instantly changes to say, “Okay, we are on the Profile screen now.” But it sends an \u003cstrong\u003eevent\u003c/strong\u003e to the Navigation library.\u003cbr/\u003e3. \u003cstrong\u003eThe Lag:\u003c/strong\u003e For a moment, your app state thinks it’s on “Profile,” but the navigation library’s internal state is still on “Home.” They are out of sync!\u003cbr/\u003e4. \u003cstrong\u003eThe Catch-Up:\u003c/strong\u003e The navigation library finally processes the event, updates its own state, and then the UI changes.\u003c/p\u003e\u003cp id=\"5399\"\u003eThis little sync mismatch results unpredictable behaviour and a lot of debugging tension. In Navigation 3, instead of working with \u003cstrong\u003eevents, \u003c/strong\u003ewe have more control on backstack state. We can create our own backstack and manage it in our app.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1a04\"\u003eval backstack = remember { mutableStateListOf\u0026lt;Any\u0026gt;() }\u003cp\u003eNavDisplay( // Similar to NavHost in old Nav library.\u003cbr/\u003e  backStack = backstack, \u003cbr/\u003e  ...\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9779\"\u003eBy having this, we can add or remove entries from the backstack (at any index, just like List). This Navigation 3 throws away event-based model and brings \u003cstrong\u003estate-based\u003c/strong\u003e just like Compose. There is no events here, directly updating the navigation state, which prevents the issues which I mentioned above and also it gives more flexibility on handling navigation states on real world use cases.\u003c/p\u003e\u003cp id=\"98e6\"\u003eSo, how does the same flow work with Navigation 3?\u003c/p\u003e\u003cp id=\"fc07\"\u003e1. \u003cstrong\u003eThe Click:\u003c/strong\u003e User taps the “Profile” button.\u003cbr/\u003e2. \u003cstrong\u003eOne State to Rule Them All:\u003c/strong\u003e You update your app’s state to “Profile.”\u003cbr/\u003e3. \u003cstrong\u003eThat’s It!\u003c/strong\u003e Navigation 3 is constantly watching your app state. The moment it sees the state change to “Profile,” it automatically shows the Profile screen.\u003c/p\u003e\u003cp id=\"7042\"\u003eThere is no separate navigation state. Your app state is the \u003cstrong\u003esingle source of truth\u003c/strong\u003e, and everything else just follows its lead. So simple and so powerful!\u003c/p\u003e\u003ch2 id=\"f9b3\"\u003eLets get into the implementation:\u003c/h2\u003e\u003cp id=\"8c76\"\u003eImplementing Navigation 3 is pretty straightforward, but with more flexibility in defining navigation flows, supporting dynamic UI patterns like bottom sheets, and handling backstack behavior seamlessly in Jetpack Compose.\u003c/p\u003e\u003ch2 id=\"c043\"\u003eNavigation 3 Dependencies\u003c/h2\u003e\u003cp id=\"2ad8\"\u003e\u003cem\u003eIn libs.version.toml\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6ec9\"\u003e[versions]\u003cbr/\u003enav3 = \u0026#34;1.0.0-alpha01\u0026#34;\u003cbr/\u003eviewmodel = \u0026#34;1.0.0-alpha01\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003e# Core Navigation 3 libraries\u003cbr/\u003eandroidx-navigation3-runtime = { module = \u0026#34;androidx.navigation3:navigation3-runtime\u0026#34;, version.ref = \u0026#34;nav3\u0026#34; }\u003cbr/\u003eandroidx-navigation3-ui = { module = \u0026#34;androidx.navigation3:navigation3-ui\u0026#34;, version.ref = \u0026#34;nav3\u0026#34; }\u003c/p\u003e\u003cp\u003e# Optional add-on libraries\u003cbr/\u003eandroidx-lifecycle-viewmodel-navigation3 = { module = \u0026#34;androidx.lifecycle:lifecycle-viewmodel-navigation3\u0026#34;, version.ref = \u0026#34;viewmodel\u0026#34; }\u003c/p\u003e\u003cp\u003e[plugins]\u003cbr/\u003ejetbrains-kotlin-serialization = { id = \u0026#34;org.jetbrains.kotlin.plugin.serialization\u0026#34;, version.ref = \u0026#34;kotlinSerialization\u0026#34;}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e842\"\u003e\u003cem\u003eIn build.gradle (app)\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"30d4\"\u003eplugins {\u003cbr/\u003e    ...\u003cbr/\u003e    alias(libs.plugins.jetbrains.kotlin.serialization)\u003cbr/\u003e}\u003cp\u003edependencies {\u003cbr/\u003e    ...\u003cbr/\u003e    implementation(libs.androidx.navigation3.ui)\u003cbr/\u003e    implementation(libs.androidx.navigation3.runtime)\u003cbr/\u003e    implementation(libs.androidx.lifecycle.viewmodel.navigation3)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2c1f\"\u003eAlso, update your \u003cstrong\u003ecompile SDK\u003c/strong\u003e to \u003cstrong\u003e36.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"6e36\"\u003eNavDisplay Setup\u003c/h2\u003e\u003cp id=\"9e36\"\u003eWhen creating a new nav key, we should extend the \u003ccode\u003eNavKey\u003c/code\u003e from Nav3. Additionally, make sure your entry is \u003cstrong\u003eSerializable\u003c/strong\u003e. Lets create two new nav entries.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f0bc\"\u003eimport androidx.navigation3.runtime.NavKey\u003cp\u003e@Serializable\u003cbr/\u003edata object NotesList: NavKey\u003c/p\u003e\u003cp\u003e@Serializable\u003cbr/\u003edata class NoteDetail(val noteId: String): NavKey\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"693a\"\u003eWe can create our app’s navigation state by two ways:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a614\"\u003emutableStateListOf(…)\u003c/li\u003e\u003cli id=\"8fb2\"\u003erememberNavBackStack(…)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"599a\"\u003eUsing \u003ccode\u003erememberNavBackStack()\u003c/code\u003e will automatically remembers the hierarchy across configuration change and process death.\u003c/p\u003e\u003cp id=\"35ae\"\u003eTo associate the screens to the key, it should be done through \u003ccode\u003eentryProvider\u003c/code\u003e parameter in \u003ccode\u003eNavDisplay\u003c/code\u003e. It gives \u003ccode\u003enavKey\u003c/code\u003e as a parameter, and expect a \u003ccode\u003eNavEntry\u003c/code\u003e. We can use the \u003ccode\u003enavKey\u003c/code\u003e to associate the screen using \u003ccode\u003ewhen\u003c/code\u003e statement.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"529d\"\u003eIn this example, we are returning \u003ccode\u003eNavEntry\u003c/code\u003e to the \u003ccode\u003eentryProvider\u003c/code\u003e. \u003ccode\u003eNavEntry\u003c/code\u003e accepts three parameters:\u003c/p\u003e\u003cul\u003e\u003cli id=\"df2e\"\u003e\u003cstrong\u003ekey:\u003c/strong\u003e The \u003ccode\u003enavKey\u003c/code\u003e of the screen, which we get from \u003ccode\u003eentryProvider\u003c/code\u003e itself.\u003c/li\u003e\u003cli id=\"e0da\"\u003e\u003cstrong\u003emetadata (optional):\u003c/strong\u003e This accepts a map to provide additional information about the behaviour of the screen to display.\u003c/li\u003e\u003cli id=\"97cc\"\u003e\u003cstrong\u003econtent: \u003c/strong\u003eThe Composable screen content which we need to display.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"db23\"\u003eBefore we going further, lets complete our \u003ccode\u003eNotesListScreen\u003c/code\u003e and \u003ccode\u003eNoteDetailScreen\u003c/code\u003e .\u003c/p\u003e\u003cp id=\"afb4\"\u003e\u003cstrong\u003e\u003cem\u003eNotesListScreen.kt\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a5a8\"\u003eIn this screen, we are displaying a list of Text showing Note Id. Passing the navigation callback into the screen will helps in separation of UI and Navigation logics.\u003c/p\u003e\u003cp id=\"2d99\"\u003e\u003cstrong\u003e\u003cem\u003eNoteDetailScreen.kt\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e895\"\u003eIn this screen, we are displaying a simple Text showing the received Note Id from the parameter.\u003c/p\u003e\u003cp id=\"e178\"\u003eIf we run the app, we can see something like this:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eNavigation Demo on Compose Navigation 3 Library\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c134\"\u003e\u003cstrong\u003e\u003cem\u003eFacing IllegalStateException on App Boot:\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d756\"\u003e\u003cem\u003ejava.lang.IllegalStateException: No NavigationEventDispatcher was provided via LocalNavigationEventDispatcherOwner\u003c/em\u003e\u003c/p\u003e\u003cp id=\"1e55\"\u003eIf you are getting this error when running, change your \u003ccode\u003eactivity-compose\u003c/code\u003e version into \u003ccode\u003e1.12.0-alpha01\u003c/code\u003e\u003c/p\u003e\u003ch2 id=\"53d9\"\u003eNow, Lets explore some other parameters of NavDisplay briefly:\u003c/h2\u003e\u003cp id=\"18d7\"\u003e\u003cstrong\u003eSceneStrategy:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4da7\"\u003eNavDisplay(\u003cbr/\u003e    sceneStrategy = SinglePaneSceneStrategy(),\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"c973\"\u003eScene Strategy determines how the screens are visually displayed in your app.\u003c/li\u003e\u003cli id=\"ee72\"\u003eIt controls whether the navigation stack should show single screen at a time or multiple screens together.\u003c/li\u003e\u003cli id=\"e81f\"\u003eBy default, it uses \u003ccode\u003eSinglePaneSceneStrategy\u003c/code\u003e , only top most screen is visible.\u003c/li\u003e\u003cli id=\"1ccf\"\u003eWe can customise this behaviour to create custom adaptive layouts.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1b98\"\u003e\u003cstrong\u003eOnBack:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"54d7\"\u003eNavDisplay(\u003cbr/\u003e    ...\u003cbr/\u003e    onBack = { entries: Int -\u0026gt;\u003cbr/\u003e        if (backstack.isNotEmpty()) {\u003cbr/\u003e            backstack.removeLastOrNull()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"1c41\"\u003eCalled when system back press is called. It gives entries count, represents the number of scenes to be removed, typically used on custom \u003ccode\u003eSceneStrategy\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c52b\"\u003e\u003cstrong\u003eEntry Decorators:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2fad\"\u003eIt accepts list of \u003ccode\u003eNavEntryDecorators\u003c/code\u003e , which adds behaviour like saved state or viewModel retention to screens.\u003c/li\u003e\u003cli id=\"0d12\"\u003eThere are some decorators:\u003cbr/\u003e- \u003ccode\u003erememberSceneSetupNavEntryDecorator()\u003c/code\u003e — Lifecycle setup.\u003cbr/\u003e- \u003ccode\u003erememberSavedStateNavEntryDecorator()\u003c/code\u003e — Saves state.\u003cbr/\u003e- \u003ccode\u003erememberViewModelStoreNavEntryDecorator()\u003c/code\u003e — Retains viewModel.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d12b\"\u003e\u003cstrong\u003eSize Transform: — \u003c/strong\u003eAnimates size changes during transition. By default, no transition size animation should be occured.\u003c/p\u003e\u003cp id=\"bfcf\"\u003e\u003cstrong\u003eTransition Spec \u0026amp; Pop Transition Spec: —\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2ee9\"\u003eNavDisplay(\u003cbr/\u003e    ...\u003cbr/\u003e    transitionSpec = {\u003cbr/\u003e        ContentTransform(\u003cbr/\u003e            fadeIn(tween(300)),\u003cbr/\u003e            fadeOut(tween(300))\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e7a7\"\u003eDefines enter and exit animations for forward or backward navigation.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3fd5\"\u003e\u003cstrong\u003ePredictive Pop Transition Spec: — \u003c/strong\u003eAdvanced animation for predictive back gesture.\u003c/p\u003e\u003ch2 id=\"a7ca\"\u003eSummary\u003c/h2\u003e\u003cp id=\"55a7\"\u003eNavigation 3 is not just an upgrade, its a fundamental shift toward more maintainable, scaleable and user-friendly navigation in compose apps. Nav3 represents a leap forward in clarity and control. By providing declarative navigation graphs, type-safe routes and custom scene strategies, developers can now build more intrutive and adaptive navigaion flows with ease.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-06-20T11:14:36.925Z",
  "modifiedTime": null
}
