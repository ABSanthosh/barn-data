{
  "id": "4cca9f75-f726-4878-8742-447babda0f2a",
  "title": "Android Interview Series 2024 — Part 8 (Android architecture)",
  "link": "https://proandroiddev.com/android-interview-series-2024-part-8-android-architecture-07ca74eee000?source=rss----c72404660798---4",
  "description": "",
  "author": "Anitaa Murthy",
  "published": "Sun, 17 Nov 2024 19:16:57 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android-app-development",
    "android",
    "android-architecture",
    "kotlin",
    "androiddev"
  ],
  "byline": "Anitaa Murthy",
  "length": 12765,
  "excerpt": "This is Part 8 of the android interview question series. This part will focus on Android architecture. MVVM (Model-View-View Model) architecture: MVVM leverages ViewModel, a lifecycle-aware component…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "https://hdwallsbox.com/3d-android-logo-background-wallpaper-43891/This is Part 8 of the android interview question series. This part will focus on Android architecture.Part 1 — Android basicsPart 2 — Android expertsPart 3 — Java basicsPart 4 — Kotlin basicsPart 5 — Kotlin coroutinesPart 6 — Kotlin FlowsPart 7 — Jetpack ComposePart 8 — Android architecture \u0026 framework -\u003e You are here1. Can you explain the MVC and MVP patterns? What are the main differences and why are they not used in Android development?MVC is the Model-View-Controller architecture where model refers to the data model classes. The view refers to the xml files and the controller handles the business logic. The issue with this architecture is unit testing. The model can be easily tested since it is not tied to anything. The controller is tightly coupled with the android apis making it difficult to unit test. Modularity \u0026 flexibility is a problem since the view and the controller are tightly coupled. If we change the view, the controller logic should also be changed. Maintenance is also an issue.MVP architecture: Model-View-Presenter architecture. MVP separates concerns by using a Presenter to handle business logic, the View (often an Activity or Fragment) to display UI, and the Model to manage data. In this setup, the Presenter is responsible for updating the View based on the Model’s data and handling user actions, making it testable and reducing the burden on the Android lifecycle-aware View. This separation improves testability since the Presenter can be tested independently of the Android framework. But the Presenter does not inherently respond to lifecycle events like configuration changes (e.g., screen rotations), which means that extra handling is often required to manage these situations.2. What is MVVM architecture in android?MVVM (Model-View-View Model) architecture: MVVM leverages ViewModel, a lifecycle-aware component that holds and processes data for the UI, separating it from the View (Activity/Fragment). The Model represents the data layer and interacts with the ViewModel, which then updates the View using LiveData, DataBinding, or StateFlow. The ViewModel handles data and business logic, while the View observes changes and updates UI reactively, which is lifecycle-aware and thus avoids memory leaks and configuration issues.3. What are the main advantages and disadvantages of using MVVM in Android development?Advantages include:MVVM encourages a clear separation between the UI (View), business logic (ViewModel), and data (Model). This makes the codebase more modular, organized, and easier to maintain.The ViewModel is lifecycle-aware, meaning it retains its data across configuration changes like screen rotations. This lifecycle management reduces memory leaks and simplifies handling UI-related data.The ViewModel contains the business logic and is decoupled from the Android UI framework, making it easier to test independently. The Model and ViewModel can be unit-tested, which improves code quality and reliability.MVVM enables a reactive approach where the View observes data changes in the ViewModel, allowing for automatic UI updates without manual intervention. Using LiveData, Flow, or StateFlow, the View automatically reacts to data changes, which can result in a more responsive and dynamic UI.Some disadvantages might include:MVVM, along with components like LiveData, DataBinding, and Flow, requires a deeper understanding of reactive programming and lifecycle management, which can be challenging for developers new to these concepts.Using DataBinding in MVVM can reduce some code but also add boilerplate, especially if implemented extensively. Additionally, debugging can be more complex with DataBinding, as errors may not always be immediately apparent.4. How do you manage the “fat ViewModel” problem in MVVM?In MVVM, the ViewModel can easily become “fat” if too much logic is placed there, especially as the app grows. Handling multiple ViewModel responsibilities can lead to complex, hard-to-maintain code if not carefully managed. This is called the “fat ViewModel” problem. In order to avoid that,Use the Repository Pattern: The Repository acts as a single source of truth for data, abstracting data access layers (local databases, network, cache) from the ViewModel. By offloading data-fetching and manipulation responsibilities to the Repository, the ViewModel only needs to manage UI data, reducing its workload.Delegate Business Logic to Use Cases or Interactors: Use Cases are components that encapsulate a specific piece of business logic. By moving business logic out of the ViewModel into Use Cases, each Use Case is responsible for a single action, keeping the ViewModel focused on UI state and interactions. This approach makes it easier to test logic independently and enhances reusability.Utilize Separate State Management Classes: State management classes manage UI states and UI events, helping organize complex UI-related data. If your ViewModel has many UI states, creating a specific state management class can centralize the handling of UI states, reducing clutter in the ViewModel.Use Event Wrappers for One-Time Events: Event wrappers (e.g., SingleLiveEvent, Event classes) handle events that should only be consumed once, like navigation triggers or toast messages. By using event wrappers, the ViewModel doesn’t need complex logic to manage one-time events, simplifying its responsibilities and making UI event handling more predictable.5. What is MVI architecture and what are it’s core concepts?MVI (Model-View-Intent) is an architecture pattern that is inspired by functional and reactive programming principles.The Model in MVI represents the application’s state and data. It holds all the information needed to render the UI at any given time.The View in MVI is responsible for rendering the UI based on the Model’s state. The View receives the state updates from the Model and re-renders itself accordingly, which means the View is entirely reactive and doesn’t hold any logic.Intents represent user actions or events, such as button clicks, text input, or system events. Intents are like requests to change the state of the application. They are dispatched from the View to the Model, which processes the intent and updates the state accordingly.Key principles of MVIMVI promotes a unidirectional data flow: Intents are sent from the View to the Model, which processes them and returns a new state back to the View. This clear flow helps to prevent unpredictable state changes and race conditions.The state in MVI is usually managed in one central location (often a single state object), ensuring there is a single source of truth for the UI. This single state object holds all relevant data for rendering the UI, which allows for easy testing, debugging, and state persistence, especially in cases where configuration changes or complex UI flows are involved.MVI encourages immutable states, meaning each change creates a new state rather than modifying the existing one. This immutability helps prevent unintended side effects and makes the state transitions easy to trace.6. What are some scenarios where MVI might be a better fit than MVVM?Jetpack Compose aligns well with MVI principles. The declarative nature of Compose reduces the complexity of handling user interactions and ensures that the UI stays in sync with the application state.In MVI, the UI state is managed by the ViewModel, often using StateFlow or LiveData. This state remains immutable, ensuring UI updates are predictable. Composables observe the state and recompose automatically when the state changes.Event/Intent: User interactions, like button clicks, are captured as events (Intents) and sent to the ViewModel for handling. Intents guide the ViewModel on how to respond to user actions, such as fetching data or adding a user, and the ViewModel adjusts the state based on these actions. This structured flow ensures smooth transitions in state and UI updates.Effects handle one-time actions like showing a snackbar or navigation. MVI manages effects using channels, allowing the ViewModel to dispatch them without affecting the app’s overall state.7. Can you describe Clean Architecture? What layers would you typically create in a Clean Architecture setup, and what’s the purpose of each?In Android development, clean architecture design approach provides a structured way to organize code into layers, each with its own responsibilities and dependencies, making the application more maintainable, flexible, and testable. Typically, Clean Architecture consists of four layers:Presentation Layer: Responsible for the UI and the communication between the user and the app. This is where you handle user input, present data to the user, and manage UI state. Eg: activities, fragments, composables etc.Domain Layer: Contains the business logic and use cases (or interactors) of the application. Executes business rules and logic without directly interacting with data sources or the UI. This layer is agnostic to platform or framework, making it suitable for pure unit testing. Eg: repository, entity, use cases etc.Data Layer: Responsible for managing data sources and implementing the Repository pattern. It provides data to the Domain Layer by implementing the Repository interfaces defined in the Domain. Eg: Retrofit, Room db, Paging source etc.Framework and UI Layer: Houses platform-specific elements and external frameworks that your application depends on, such as Android SDK components, dependency injection frameworks (like Dagger or Hilt), and navigation components.8. How do you handle communication between different layers in a Clean Architecture setup?Communication from Presentation Layer to Domain Layer: can happen using Use Cases. Use Cases are often suspend functions (or return Flow or LiveData) to support asynchronous operations. The Presentation Layer then collects the data or subscribes to updates and updates the UI accordingly.Communication from Domain Layer to Data Layer: The Domain Layer interacts with data through the Repository pattern. The Repository interface is defined in the Domain Layer, while the actual implementation resides in the Data Layer. The Domain Layer doesn’t know where the data is coming from (e.g., network, database). It simply calls the UserRepository interface, which the Data Layer implements.Communication within the Data Layer: The Repository in the Data Layer manages communication between various data sources (e.g., remote API, local database, cache).Data Sources: The Data Layer might have separate Data Sources for handling network requests, local database interactions, and cache. These data sources are abstracted within the Repository, so the Repository decides the source and manages caching logic if necessary.Data Flow from Data Layer Back to Domain and Presentation Layers: The Data Layer can expose data as Flows, LiveData, or suspend functions that the Domain Layer or Presentation Layer can observe or collect.9. Can you explain the Repository pattern and how it helps with code organization and separation of concerns?The Repository Pattern is a design pattern used to abstract and centralize data access logic, which helps with code organization and separation of concerns. It serves as a bridge between the Domain Layer (business logic) and the Data Layer (data sources such as local databases, remote APIs, and cache). This allows the application’s core logic to remain independent of specific data source implementations, making the codebase easier to maintain, test, and scale.The Repository Pattern abstracts data access, hiding the details of data sources from the rest of the app.Separates concerns by isolating data handling logic, keeping the UI and Domain layers focused on their specific roles.Improves testability by allowing you to mock the Repository for unit tests.Centralizes data management and caching, making it easier to implement and maintain complex data operations.10. How would you design a Repository to interact with a local database and a remote API in an Android application?In this example:The ProductRepository interface is defined in the Domain Layer, which is agnostic to where the data comes from.The ProductRepositoryImpl in the Data Layer fetches data from an API and caches it locally. If the API call fails, it retrieves data from the local database.This pattern allows the rest of the app to call getProducts() without knowing or managing data retrieval or caching strategies.Thanks for reading!Hope you find this useful. This is just a list of questions I personally found useful in interviews. This list is by no means exhaustive. Let me know your thoughts in the responses. Happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/0*ovGMYgU7aA9In-oV.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990?source=post_page---byline--07ca74eee000--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Anitaa Murthy\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*062ZoiVn_WJIT9PYUS4yww.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--07ca74eee000--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp\u003e\u003cfigure\u003e\u003cpicture\u003e\u003csource srcset=\"https://miro.medium.com/v2/resize:fit:640/format:webp/0*ovGMYgU7aA9In-oV.jpeg 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*ovGMYgU7aA9In-oV.jpeg 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*ovGMYgU7aA9In-oV.jpeg 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*ovGMYgU7aA9In-oV.jpeg 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*ovGMYgU7aA9In-oV.jpeg 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*ovGMYgU7aA9In-oV.jpeg 1100w, https://miro.medium.com/v2/resize:fit:3840/format:webp/0*ovGMYgU7aA9In-oV.jpeg 3840w\" sizes=\"(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 1920px\" type=\"image/webp\"/\u003e\u003csource data-testid=\"og\" srcset=\"https://miro.medium.com/v2/resize:fit:640/0*ovGMYgU7aA9In-oV.jpeg 640w, https://miro.medium.com/v2/resize:fit:720/0*ovGMYgU7aA9In-oV.jpeg 720w, https://miro.medium.com/v2/resize:fit:750/0*ovGMYgU7aA9In-oV.jpeg 750w, https://miro.medium.com/v2/resize:fit:786/0*ovGMYgU7aA9In-oV.jpeg 786w, https://miro.medium.com/v2/resize:fit:828/0*ovGMYgU7aA9In-oV.jpeg 828w, https://miro.medium.com/v2/resize:fit:1100/0*ovGMYgU7aA9In-oV.jpeg 1100w, https://miro.medium.com/v2/resize:fit:3840/0*ovGMYgU7aA9In-oV.jpeg 3840w\" sizes=\"(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 1920px\"/\u003e\u003c/picture\u003e\u003cfigcaption\u003e\u003ca href=\"https://hdwallsbox.com/3d-android-logo-background-wallpaper-43891/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://hdwallsbox.com/3d-android-logo-background-wallpaper-43891/\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003c/p\u003e\u003cdiv\u003e\u003cp id=\"77d7\"\u003eThis is Part 8 of the android interview question series. This part will focus on Android architecture.\u003c/p\u003e\u003cul\u003e\u003cli id=\"0e53\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-1-android-basics-23a713f4a648\" rel=\"noopener\"\u003ePart 1 — Android basics\u003c/a\u003e\u003c/li\u003e\u003cli id=\"c452\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-2-android-intermediate-472e0e787725\" rel=\"noopener\"\u003ePart 2 — Android experts\u003c/a\u003e\u003c/li\u003e\u003cli id=\"1611\"\u003e\u003ca href=\"https://medium.com/android-news/android-interview-questions-cheat-sheet-part-ii-bea0633f0da7\" rel=\"noopener\"\u003ePart 3 — Java basics\u003c/a\u003e\u003c/li\u003e\u003cli id=\"4d2d\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-4-kotlin-basics-16531ee54e8a\" rel=\"noopener\"\u003ePart 4 — Kotlin basics\u003c/a\u003e\u003c/li\u003e\u003cli id=\"33b2\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-5-kotlin-coroutines-3dd1ae81c721\" rel=\"noopener\"\u003ePart 5 — Kotlin coroutines\u003c/a\u003e\u003c/li\u003e\u003cli id=\"8465\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-6-kotlin-flows-730f6bf877df\" rel=\"noopener\"\u003ePart 6 — Kotlin Flows\u003c/a\u003e\u003c/li\u003e\u003cli id=\"213d\"\u003e\u003ca href=\"https://medium.com/@anitaa_1990/android-interview-series-2024-part-7-jetpack-compose-ff7d2ecd9018\" rel=\"noopener\"\u003ePart 7 — Jetpack Compose\u003c/a\u003e\u003c/li\u003e\u003cli id=\"2616\"\u003ePart 8 — Android architecture \u0026amp; framework -\u0026gt; \u003cstrong\u003eYou are here\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"53f1\"\u003e1. Can you explain the MVC and MVP patterns? What are the main differences and why are they not used in Android development?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"42ea\"\u003e\u003cstrong\u003eMVC\u003c/strong\u003e is the \u003cstrong\u003eModel-View-Controller\u003c/strong\u003e architecture where model refers to the data model classes. The view refers to the xml files and the controller handles the business logic. The issue with this architecture is unit testing. The model can be easily tested since it is not tied to anything. The controller is tightly coupled with the android apis making it difficult to unit test. Modularity \u0026amp; flexibility is a problem since the view and the controller are tightly coupled. If we change the view, the controller logic should also be changed. Maintenance is also an issue.\u003c/li\u003e\u003cli id=\"8e34\"\u003e\u003cstrong\u003eMVP architecture:\u003c/strong\u003e \u003cstrong\u003eModel-View-Presenter architecture\u003c/strong\u003e. MVP separates concerns by using a \u003cstrong\u003ePresenter\u003c/strong\u003e to handle business logic, the \u003cstrong\u003eView\u003c/strong\u003e (often an Activity or Fragment) to display UI, and the \u003cstrong\u003eModel\u003c/strong\u003e to manage data. In this setup, the Presenter is responsible for updating the View based on the Model’s data and handling user actions, making it testable and reducing the burden on the Android lifecycle-aware View. This separation improves testability since the Presenter can be tested independently of the Android framework. But the \u003cstrong\u003ePresenter\u003c/strong\u003e does not inherently respond to lifecycle events like configuration changes (e.g., screen rotations), which means that extra handling is often required to manage these situations.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"042b\"\u003e2. What is MVVM architecture in android?\u003c/h2\u003e\u003cp id=\"02b0\"\u003e\u003cstrong\u003eMVVM (Model-View-View Model) architecture:\u003c/strong\u003e MVVM leverages \u003cstrong\u003eViewModel\u003c/strong\u003e, a lifecycle-aware component that holds and processes data for the UI, separating it from the \u003cstrong\u003eView\u003c/strong\u003e (Activity/Fragment). The \u003cstrong\u003eModel\u003c/strong\u003e represents the data layer and interacts with the ViewModel, which then updates the View using LiveData, DataBinding, or StateFlow. The ViewModel handles data and business logic, while the View observes changes and updates UI reactively, which is lifecycle-aware and thus avoids memory leaks and configuration issues.\u003c/p\u003e\u003ch2 id=\"af21\"\u003e3. What are the main advantages and disadvantages of using MVVM in Android development?\u003c/h2\u003e\u003cp id=\"d77e\"\u003e\u003cstrong\u003eAdvantages include:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"f30d\"\u003eMVVM encourages a clear separation between the UI (View), business logic (ViewModel), and data (Model). This makes the codebase more modular, organized, and easier to maintain.\u003c/li\u003e\u003cli id=\"3a85\"\u003eThe ViewModel is lifecycle-aware, meaning it retains its data across configuration changes like screen rotations. This lifecycle management reduces memory leaks and simplifies handling UI-related data.\u003c/li\u003e\u003cli id=\"f010\"\u003eThe ViewModel contains the business logic and is decoupled from the Android UI framework, making it easier to test independently. The Model and ViewModel can be unit-tested, which improves code quality and reliability.\u003c/li\u003e\u003cli id=\"b7de\"\u003eMVVM enables a reactive approach where the View observes data changes in the ViewModel, allowing for automatic UI updates without manual intervention. Using LiveData, Flow, or StateFlow, the View automatically reacts to data changes, which can result in a more responsive and dynamic UI.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4fec\"\u003eSome disadvantages might include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6f7c\"\u003eMVVM, along with components like LiveData, DataBinding, and Flow, requires a deeper understanding of reactive programming and lifecycle management, which can be challenging for developers new to these concepts.\u003c/li\u003e\u003cli id=\"667c\"\u003eUsing DataBinding in MVVM can reduce some code but also add boilerplate, especially if implemented extensively. Additionally, debugging can be more complex with DataBinding, as errors may not always be immediately apparent.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"d3b2\"\u003e4. How do you manage the “fat ViewModel” problem in MVVM?\u003c/h2\u003e\u003cp id=\"43fd\"\u003eIn MVVM, the ViewModel can easily become “fat” if too much logic is placed there, especially as the app grows. Handling multiple ViewModel responsibilities can lead to complex, hard-to-maintain code if not carefully managed. This is called the “fat ViewModel” problem. In order to avoid that,\u003c/p\u003e\u003cul\u003e\u003cli id=\"98ad\"\u003e\u003cstrong\u003eUse the Repository Pattern\u003c/strong\u003e: The Repository acts as a single source of truth for data, abstracting data access layers (local databases, network, cache) from the ViewModel. By offloading data-fetching and manipulation responsibilities to the Repository, the ViewModel only needs to manage UI data, reducing its workload.\u003c/li\u003e\u003cli id=\"251f\"\u003e\u003cstrong\u003eDelegate Business Logic to Use Cases or Interactors\u003c/strong\u003e: Use Cases are components that encapsulate a specific piece of business logic. By moving business logic out of the ViewModel into Use Cases, each Use Case is responsible for a single action, keeping the ViewModel focused on UI state and interactions. This approach makes it easier to test logic independently and enhances reusability.\u003c/li\u003e\u003cli id=\"ccdd\"\u003e\u003cstrong\u003eUtilize Separate State Management Classes\u003c/strong\u003e: State management classes manage UI states and UI events, helping organize complex UI-related data. If your ViewModel has many UI states, creating a specific state management class can centralize the handling of UI states, reducing clutter in the ViewModel.\u003c/li\u003e\u003cli id=\"4d53\"\u003e\u003cstrong\u003eUse Event Wrappers for One-Time Events\u003c/strong\u003e: Event wrappers (e.g., SingleLiveEvent, Event classes) handle events that should only be consumed once, like navigation triggers or toast messages. By using event wrappers, the ViewModel doesn’t need complex logic to manage one-time events, simplifying its responsibilities and making UI event handling more predictable.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6372\"\u003e5. What is MVI architecture and what are it’s core concepts?\u003c/h2\u003e\u003cp id=\"a4d0\"\u003e\u003cstrong\u003eMVI (Model-View-Intent)\u003c/strong\u003e is an architecture pattern that is inspired by functional and reactive programming principles.\u003c/p\u003e\u003cul\u003e\u003cli id=\"7578\"\u003eThe \u003cstrong\u003eModel\u003c/strong\u003e in MVI represents the application’s state and data. It holds all the information needed to render the UI at any given time.\u003c/li\u003e\u003cli id=\"92fb\"\u003eThe \u003cstrong\u003eView\u003c/strong\u003e in MVI is responsible for rendering the UI based on the Model’s state. The View receives the state updates from the Model and re-renders itself accordingly, which means the View is entirely reactive and doesn’t hold any logic.\u003c/li\u003e\u003cli id=\"9782\"\u003e\u003cstrong\u003eIntents\u003c/strong\u003e represent user actions or events, such as button clicks, text input, or system events. Intents are like requests to change the state of the application. They are dispatched from the View to the Model, which processes the intent and updates the state accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"68e3\"\u003e\u003cstrong\u003eKey principles of MVI\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2687\"\u003eMVI promotes a unidirectional data flow: Intents are sent from the View to the Model, which processes them and returns a new state back to the View. This clear flow helps to prevent unpredictable state changes and race conditions.\u003c/li\u003e\u003cli id=\"9139\"\u003eThe state in MVI is usually managed in one central location (often a single state object), ensuring there is a single source of truth for the UI. This single state object holds all relevant data for rendering the UI, which allows for easy testing, debugging, and state persistence, especially in cases where configuration changes or complex UI flows are involved.\u003c/li\u003e\u003cli id=\"5398\"\u003eMVI encourages immutable states, meaning each change creates a new state rather than modifying the existing one. This immutability helps prevent unintended side effects and makes the state transitions easy to trace.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3a4d\"\u003e6. What are some scenarios where MVI might be a better fit than MVVM?\u003c/h2\u003e\u003cp id=\"93be\"\u003eJetpack Compose aligns well with MVI principles. The declarative nature of Compose reduces the complexity of handling user interactions and ensures that the UI stays in sync with the application state.\u003c/p\u003e\u003cul\u003e\u003cli id=\"098e\"\u003eIn MVI, the UI state is managed by the ViewModel, often using \u003ccode\u003eStateFlow\u003c/code\u003e or \u003ccode\u003eLiveData\u003c/code\u003e. This state remains immutable, ensuring UI updates are predictable. Composables observe the state and recompose automatically when the state changes.\u003c/li\u003e\u003cli id=\"c0e6\"\u003e\u003cstrong\u003eEvent/Intent\u003c/strong\u003e: User interactions, like button clicks, are captured as events (Intents) and sent to the ViewModel for handling. Intents guide the ViewModel on how to respond to user actions, such as fetching data or adding a user, and the ViewModel adjusts the state based on these actions. This structured flow ensures smooth transitions in state and UI updates.\u003c/li\u003e\u003cli id=\"1d84\"\u003eEffects handle one-time actions like showing a snackbar or navigation. MVI manages effects using channels, allowing the ViewModel to dispatch them without affecting the app’s overall state.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a247\"\u003e7. Can you describe Clean Architecture? What layers would you typically create in a Clean Architecture setup, and what’s the purpose of each?\u003c/h2\u003e\u003cp id=\"6107\"\u003eIn Android development, \u003cstrong\u003eclean architecture\u003c/strong\u003e design approach provides a structured way to organize code into layers, each with its own responsibilities and dependencies, making the application more maintainable, flexible, and testable. Typically, Clean Architecture consists of four layers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b0f4\"\u003e\u003cstrong\u003ePresentation Layer\u003c/strong\u003e: Responsible for the UI and the communication between the user and the app. This is where you handle user input, present data to the user, and manage UI state. Eg: activities, fragments, composables etc.\u003c/li\u003e\u003cli id=\"fd48\"\u003e\u003cstrong\u003eDomain Layer\u003c/strong\u003e: Contains the \u003cstrong\u003ebusiness logic\u003c/strong\u003e and \u003cstrong\u003euse cases\u003c/strong\u003e (or interactors) of the application. Executes business rules and logic without directly interacting with data sources or the UI. This layer is agnostic to platform or framework, making it suitable for pure unit testing. Eg: repository, entity, use cases etc.\u003c/li\u003e\u003cli id=\"50d2\"\u003e\u003cstrong\u003eData Layer\u003c/strong\u003e: Responsible for managing data sources and implementing the \u003cstrong\u003eRepository pattern\u003c/strong\u003e. It provides data to the Domain Layer by implementing the Repository interfaces defined in the Domain. Eg: Retrofit, Room db, Paging source etc.\u003c/li\u003e\u003cli id=\"2842\"\u003e\u003cstrong\u003eFramework and UI Layer\u003c/strong\u003e: Houses platform-specific elements and external frameworks that your application depends on, such as Android SDK components, dependency injection frameworks (like Dagger or Hilt), and navigation components.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2365\"\u003e8. How do you handle communication between different layers in a Clean Architecture setup?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"7f78\"\u003eCommunication from Presentation Layer to Domain Layer: can happen using \u003cstrong\u003eUse Cases\u003c/strong\u003e. Use Cases are often \u003ccode\u003esuspend\u003c/code\u003e functions (or return \u003cstrong\u003eFlow\u003c/strong\u003e or \u003cstrong\u003eLiveData\u003c/strong\u003e) to support asynchronous operations. The Presentation Layer then collects the data or subscribes to updates and updates the UI accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"3621\"\u003e\u003cstrong\u003eCommunication from Domain Layer to Data Layer\u003c/strong\u003e: The Domain Layer interacts with data through the \u003cstrong\u003eRepository pattern\u003c/strong\u003e. The Repository interface is defined in the Domain Layer, while the actual implementation resides in the Data Layer. The Domain Layer doesn’t know where the data is coming from (e.g., network, database). It simply calls the \u003ccode\u003eUserRepository\u003c/code\u003e interface, which the Data Layer implements.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"65f9\"\u003e\u003cstrong\u003eCommunication within the Data Layer:\u003c/strong\u003e The Repository in the Data Layer manages communication between various data sources (e.g., remote API, local database, cache).\u003cstrong\u003eData Sources\u003c/strong\u003e: The Data Layer might have separate \u003cstrong\u003eData Sources\u003c/strong\u003e for handling network requests, local database interactions, and cache. These data sources are abstracted within the Repository, so the Repository decides the source and manages caching logic if necessary.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"0b49\"\u003e\u003cstrong\u003eData Flow from Data Layer Back to Domain and Presentation Layers:\u003c/strong\u003e The Data Layer can expose data as \u003cstrong\u003eFlows\u003c/strong\u003e, \u003cstrong\u003eLiveData\u003c/strong\u003e, or \u003cstrong\u003esuspend functions\u003c/strong\u003e that the Domain Layer or Presentation Layer can observe or collect.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"361f\"\u003e9. Can you explain the Repository pattern and how it helps with code organization and separation of concerns?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"683b\"\u003eThe \u003cstrong\u003eRepository Pattern\u003c/strong\u003e is a design pattern used to abstract and centralize data access logic, which helps with \u003cstrong\u003ecode organization\u003c/strong\u003e and \u003cstrong\u003eseparation of concerns\u003c/strong\u003e. It serves as a bridge between the \u003cstrong\u003eDomain Layer\u003c/strong\u003e (business logic) and the \u003cstrong\u003eData Layer\u003c/strong\u003e (data sources such as local databases, remote APIs, and cache). This allows the application’s core logic to remain independent of specific data source implementations, making the codebase easier to maintain, test, and scale.\u003c/li\u003e\u003cli id=\"0249\"\u003eThe Repository Pattern \u003cstrong\u003eabstracts\u003c/strong\u003e data access, hiding the details of data sources from the rest of the app.\u003c/li\u003e\u003cli id=\"3205\"\u003e\u003cstrong\u003eSeparates concerns\u003c/strong\u003e by isolating data handling logic, keeping the UI and Domain layers focused on their specific roles.\u003c/li\u003e\u003cli id=\"8ff5\"\u003e\u003cstrong\u003eImproves testability\u003c/strong\u003e by allowing you to mock the Repository for unit tests.\u003c/li\u003e\u003cli id=\"1364\"\u003e\u003cstrong\u003eCentralizes data management\u003c/strong\u003e and caching, making it easier to implement and maintain complex data operations.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"499b\"\u003e10. How would you design a Repository to interact with a local database and a remote API in an Android application?\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ff00\"\u003eIn this example:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4797\"\u003eThe \u003ccode\u003e\u003cstrong\u003eProductRepository\u003c/strong\u003e\u003c/code\u003e interface is defined in the Domain Layer, which is agnostic to where the data comes from.\u003c/li\u003e\u003cli id=\"3533\"\u003eThe \u003ccode\u003e\u003cstrong\u003eProductRepositoryImpl\u003c/strong\u003e\u003c/code\u003e in the Data Layer fetches data from an API and caches it locally. If the API call fails, it retrieves data from the local database.\u003c/li\u003e\u003cli id=\"c828\"\u003eThis pattern allows the rest of the app to call \u003ccode\u003egetProducts()\u003c/code\u003e without knowing or managing data retrieval or caching strategies.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9e29\"\u003eThanks for reading!\u003c/h2\u003e\u003cp id=\"4e24\"\u003eHope you find this useful. This is just a list of questions I personally found useful in interviews. This list is by no means exhaustive. Let me know your thoughts in the responses. Happy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-11-12T16:01:45.001Z",
  "modifiedTime": null
}
