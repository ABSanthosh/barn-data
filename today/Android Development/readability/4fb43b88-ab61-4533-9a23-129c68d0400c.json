{
  "id": "4fb43b88-ab61-4533-9a23-129c68d0400c",
  "title": "Place Scope Handling on Auto-Pilot with Koin \u0026 Compose Navigation",
  "link": "https://proandroiddev.com/place-scope-handling-on-auto-pilot-with-koin-compose-navigation-d40023b1ba6f?source=rss----c72404660798---4",
  "description": "",
  "author": "Mihai Batista",
  "published": "Fri, 04 Oct 2024 18:20:00 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "dependency-injection",
    "compose",
    "android-app-development",
    "koin"
  ],
  "byline": "Mihai Batista",
  "length": 5341,
  "excerpt": "Koin has straightforward APIs to manage custom scopes and Compose Navigation can easily express app flows as nested navigation graphs, but how can we connect these two worlds to automatically connect‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Scope \u0026 Navigation DefinitionFor the solution described in this article we will make use of one convention in order to make a logical bridge between app flows and scopes and that is: the route of a nested nav graph is used as scope identifier.We start by describing our nested nav graph and here please pay attention to the declared route, we will use it again in the next step when declaring the scope tied to this flow.const val ROUTE_GRAPH_FLOW: NavGraphRoute = \"route_graph_flow\"/** * Navigation graph of the custom flow. */fun NavGraphBuilder.flowNavGraph( navController: NavController,) { navigation( startDestination = routeScreen1.getRouteWithPlaceholders(), route = ROUTE_GRAPH_FLOW, ) { screen1( onNextClick = { navController.navigateToScreen2() } ) screen2( onFinishFlowClick = { navController.navigateToStart() } ) }}As you can see below, the definition of the scoped dependencies comes with no surprises. The important aspect to be noticed here is that the name of the scope qualifier is the route we have declared above, to fulfil our convention.val scopeModule = module { /** * Dependencies of [ROUTE_GRAPH_FLOW] scope. */ scope(named(ROUTE_GRAPH_FLOW)) { viewModel { Screen1ViewModel( flowRepository = get(), ) } // add other viewModels scoped\u003cFlowRepository\u003e { FlowRepositoryImpl( authRepository = get() ) } // add other repositories, use cases, DAOs }}‚ö° Quick Refresher: A dependency coming from a narrow scope can rely on a dependency coming from a larger one, but vice-versa is not possible. If we want to inject a scoped repository, the viewModel that makes use of it has to be also scoped. That‚Äôs why in the definition above the viewModel is declared alongside the repository and is not placed in the root scope.The solutionWe‚Äôre moving to the final part of writing the composable that is taking care of the scope management, we will call it AutoConnectKoinScope. Now let‚Äôs look at the details.navController.addOnDestinationChangedListener() is the key of the solution, as it gives us the current destination (screen) and implicitly the nested nav graph (flow) that the destination is part of. Adding our convention in the equation enables us to know which scope should be used to resolve the dependencies of a particular screen.üîì Key API: addOnDestinationChangedListener gives us the current destination (screen) and implicitly the nested nav graph (flow) that the destination is part of.For clarity I‚Äôve broke the solution into three parts:1st ‚Äî For each visited screen the appropriate scope is resolved and passed implicitly through CompositionLocal mechanism.if (currentNavGraphRoute != null) { val scopeForCurrentNavGraphRoute = koinInstance.getOrCreateScope( scopeId = currentNavGraphRoute, qualifier = named(currentNavGraphRoute) ) scopeToInject = scopeForCurrentNavGraphRoute} else { scopeToInject = rootScope} ..... CompositionLocalProvider( LocalKoinScope provides scopeToInject, content = content )üí° Good to Know: We don‚Äôt need to link a custom scope to the root scope, by default dependencies coming from the root scope can be resolved in a custom scope.2nd ‚Äî The previous scope is closed when we detect that the user has moved to a new flow.val currentNavGraphRoute = destination.parent?.routeval previousNavGraphRoute = lastKnownNavGraphRouteif (previousNavGraphRoute != null \u0026\u0026 currentNavGraphRoute != previousNavGraphRoute) { val lastScope = koinInstance.getOrCreateScope( scopeId = previousNavGraphRoute, qualifier = named(previousNavGraphRoute) ) lastScope.close()} 3rd ‚Äî The correct scope is restored in case the parent activity is being recreated, for this purpose we store the last known nav graph route in a global variable (in order to be kept around while the process lives) and use it to initialise the mutable state that holds the scope to be injected.var scopeToInject by remember { val lastKnownNavGraphRoute = lastKnownNavGraphRoute mutableStateOf( value = if (lastKnownNavGraphRoute != null) { koinInstance.getOrCreateScope( scopeId = lastKnownNavGraphRoute, qualifier = named(lastKnownNavGraphRoute) ) } else { rootScope } ) }To keep things clean \u0026 tidy we make use of DisposableEffect to unregister the OnDestinationChangedListener when AutoConnectKoinScope composable leaves the composition.üç¨ Koin for Compose Goodies: To get a hold of the current Koin instance, Koin provides us with the getKoin() composable, and to get the current scope with LocalKoinScope.current .To have visibility over the entire navigation and be able to manage the scope for any screen of the app, we need to place the AutoConnectKoinScope composable at the top of our Compose hierarchy, somewhere above the app's NavHost.And that‚Äôs it folks üéâ, with this last piece we‚Äôve placed the scope management on auto-pilot and we can move our focus on other aspects of the app craftsmanship.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*SJ1T1qEVuB0yXzIs",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"1f4d\"\u003e\u003cstrong\u003eScope \u0026amp; Navigation Definition\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"63aa\"\u003eFor the solution described in this article we will make use of one convention in order to make a logical bridge between app flows and scopes and that is: \u003cstrong\u003e\u003cem\u003ethe route of a nested nav graph is used as scope identifier.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d22a\"\u003eWe start by describing our nested nav graph and here please pay attention to the declared route, we will use it again in the next step when declaring the scope tied to this flow.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df22\"\u003econst val ROUTE_GRAPH_FLOW: NavGraphRoute = \u0026#34;route_graph_flow\u0026#34;\u003cp\u003e/**\u003cbr/\u003e * Navigation graph of the custom flow.\u003cbr/\u003e */\u003cbr/\u003efun NavGraphBuilder.flowNavGraph(\u003cbr/\u003e    navController: NavController,\u003cbr/\u003e) {\u003cbr/\u003e    navigation(\u003cbr/\u003e        startDestination = routeScreen1.getRouteWithPlaceholders(),\u003cbr/\u003e        route = ROUTE_GRAPH_FLOW,\u003cbr/\u003e    ) {\u003cbr/\u003e        screen1(\u003cbr/\u003e            onNextClick = {\u003cbr/\u003e                navController.navigateToScreen2()\u003cbr/\u003e            }\u003cbr/\u003e        )\u003cbr/\u003e        screen2(\u003cbr/\u003e            onFinishFlowClick = {\u003cbr/\u003e                navController.navigateToStart()\u003cbr/\u003e            }\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f810\"\u003eAs you can see below, the definition of the scoped dependencies comes with no surprises. The important aspect to be noticed here is that the name of the scope qualifier is the route we have declared above, to fulfil our convention.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"189b\"\u003eval scopeModule = module {\u003cp\u003e    /**\u003cbr/\u003e     * Dependencies of [ROUTE_GRAPH_FLOW] scope.\u003cbr/\u003e     */\u003cbr/\u003e    scope(named(ROUTE_GRAPH_FLOW)) {\u003c/p\u003e\u003cp\u003e        viewModel {\u003cbr/\u003e            Screen1ViewModel(\u003cbr/\u003e                flowRepository = get(),\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        // add other viewModels\u003c/p\u003e\u003cp\u003e        scoped\u0026lt;FlowRepository\u0026gt; {\u003cbr/\u003e            FlowRepositoryImpl(\u003cbr/\u003e                authRepository = get()\u003cbr/\u003e            )\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e                // add other repositories, use cases, DAOs        \u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"2eab\"\u003e‚ö° \u003cstrong\u003eQuick Refresher:\u003c/strong\u003e A dependency coming from a narrow scope can rely on a dependency coming from a larger one, but vice-versa is not possible. If we want to inject a scoped repository, the viewModel that makes use of it has to be also scoped. That‚Äôs why in the definition above the viewModel is declared alongside the repository and is not placed in the root scope.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0212\"\u003eThe solution\u003c/h2\u003e\u003cp id=\"03b3\"\u003eWe‚Äôre moving to the final part of writing the composable that is taking care of the scope management, we will call it \u003ccode\u003eAutoConnectKoinScope\u003c/code\u003e. Now let‚Äôs look at the details.\u003c/p\u003e\u003cp id=\"3267\"\u003e\u003ccode\u003enavController.addOnDestinationChangedListener()\u003c/code\u003e is the key of the solution, as it gives us the current destination (screen) and implicitly the nested nav graph (flow) that the destination is part of. Adding our convention in the equation enables us to know which scope should be used to resolve the dependencies of a particular screen.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"023e\"\u003eüîì Key API: \u003ccode\u003eaddOnDestinationChangedListener\u003c/code\u003e gives us the current destination (screen) and implicitly the nested nav graph (flow) that the destination is part of.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3e12\"\u003eFor clarity I‚Äôve broke the solution into three parts:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bc8b\"\u003e\u003cstrong\u003e1st ‚Äî\u003c/strong\u003e For each visited screen the appropriate scope is resolved and passed implicitly through \u003ca href=\"https://developer.android.com/develop/ui/compose/compositionlocal\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCompositionLocal\u003c/a\u003e mechanism.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"d57f\"\u003eif (currentNavGraphRoute != null) {\u003cbr/\u003e       val scopeForCurrentNavGraphRoute = koinInstance.getOrCreateScope(\u003cbr/\u003e            scopeId = currentNavGraphRoute,\u003cbr/\u003e            qualifier = named(currentNavGraphRoute)\u003cbr/\u003e       )\u003cbr/\u003e       scopeToInject = scopeForCurrentNavGraphRoute\u003cbr/\u003e} else {\u003cbr/\u003e       scopeToInject = rootScope\u003cbr/\u003e}\u003cp\u003e             .....\u003c/p\u003e\u003cp\u003e  CompositionLocalProvider(\u003cbr/\u003e      LocalKoinScope provides scopeToInject,\u003cbr/\u003e      content = content\u003cbr/\u003e )\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"6c38\"\u003e\u003cstrong\u003eüí° Good to Know:\u003c/strong\u003e We don‚Äôt need to link a custom scope to the root scope, by default dependencies coming from the root scope can be resolved in a custom scope.\u003c/p\u003e\u003c/blockquote\u003e\u003cul\u003e\u003cli id=\"3fc6\"\u003e\u003cstrong\u003e2nd ‚Äî\u003c/strong\u003e The previous scope is closed when we detect that the user has moved to a new flow.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"6856\"\u003eval currentNavGraphRoute = destination.parent?.route\u003cbr/\u003eval previousNavGraphRoute = lastKnownNavGraphRoute\u003cp\u003eif (previousNavGraphRoute != null \u0026amp;\u0026amp; currentNavGraphRoute != previousNavGraphRoute) {\u003cbr/\u003e      val lastScope = koinInstance.getOrCreateScope(\u003cbr/\u003e            scopeId = previousNavGraphRoute,\u003cbr/\u003e            qualifier = named(previousNavGraphRoute)\u003cbr/\u003e      )\u003cbr/\u003e      lastScope.close()\u003cbr/\u003e}      \u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"0738\"\u003e\u003cstrong\u003e3rd ‚Äî\u003c/strong\u003e The correct scope is restored in case the parent activity is being recreated, for this purpose we store the last known nav graph route in a global variable (in order to be kept around while the process lives) and use it to initialise the mutable state that holds the scope to be injected.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"63d0\"\u003evar scopeToInject by remember {\u003cbr/\u003e        val lastKnownNavGraphRoute = lastKnownNavGraphRoute\u003cbr/\u003e        mutableStateOf(\u003cbr/\u003e            value = if (lastKnownNavGraphRoute != null) {\u003cbr/\u003e                koinInstance.getOrCreateScope(\u003cbr/\u003e                    scopeId = lastKnownNavGraphRoute,\u003cbr/\u003e                    qualifier = named(lastKnownNavGraphRoute)\u003cbr/\u003e                )\u003cbr/\u003e            } else {\u003cbr/\u003e                rootScope\u003cbr/\u003e            }\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9e0f\"\u003eTo keep things clean \u0026amp; tidy we make use of \u003ccode\u003eDisposableEffect\u003c/code\u003e to unregister the \u003ccode\u003eOnDestinationChangedListener\u003c/code\u003e when \u003ccode\u003eAutoConnectKoinScope\u003c/code\u003e composable leaves the composition.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"e003\"\u003eüç¨ \u003cstrong\u003eKoin for\u003c/strong\u003e \u003cstrong\u003eCompose Goodies: \u003c/strong\u003eTo get a hold of the current Koin instance, Koin provides us with the \u003ccode\u003egetKoin()\u003c/code\u003e composable, and to get the current scope with \u003ccode\u003eLocalKoinScope.current\u003c/code\u003e .\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"f749\"\u003eTo have visibility over the entire navigation and be able to manage the scope for any screen of the app, we need to place the \u003ccode\u003eAutoConnectKoinScope\u003c/code\u003e composable at the top of our Compose hierarchy, somewhere above the app\u0026#39;s \u003ccode\u003eNavHost\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"5167\"\u003eAnd that‚Äôs it folks üéâ, with this last piece we‚Äôve placed the scope management on auto-pilot and we can move our focus on other aspects of the app craftsmanship.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-10-04T18:20:00.13Z",
  "modifiedTime": null
}
