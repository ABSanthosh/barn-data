{
  "id": "cbfea931-e152-4dd1-8ccd-ab63e987c4fa",
  "title": "Native UI and multiplatform Compose with Redwood",
  "link": "https://code.cash.app/native-ui-and-multiplatform-compose-with-redwood",
  "description": "",
  "author": "",
  "published": "2023-07-05T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "Jake Wharton",
  "length": 3762,
  "excerpt": "Redwood is Cash App’s take on multiplatform mobile client UI with slightly different values.",
  "siteName": "Cash App Code Blog",
  "favicon": "https://code.cash.app/assets/icon-196.png",
  "text": "Posted by Jake Wharton on July 5, 2023 Redwood is Cash App’s take on multiplatform mobile client UI. Unlike many of the existing solutions to this problem, our values are slightly different: Render using the native UI toolkit on each platform. Native UI is the best UI, and we want to ensure our engineers can continue to use all their skills when building UI components. Retain the ability to reuse components from the rest of the application. The existing styles and custom controls used by the rest of the app are available without redefinition keeping a single source of truth. Use a mobile language with great tooling. We want to tap into the existing skills of our engineers to build within this new system and not have to learn a new ecosystem. Allow for incremental adoption in an existing app. This shouldn’t be an all-or-nothing framework but a library that you can use only where it’s needed. We chose the Kotlin programming language because it can compile to Java bytecode, native (via LLVM), and Javascript. This supports use on Android, iOS, and the web using intrinsic execution on each platform. On top of Kotlin we leverage Compose for creating UI nodes and managing state. Compose UI started as an Android-specific UI toolkit which was later ported to Kotlin multiplatform by JetBrains to run on Desktop and iOS. Compose, the underlying technology, can be used to manage state alongside any tree-like structure. Redwood’s Compose uses a custom tree which talks to the native UI toolkit on each platform. In order to create a multiplatform set of composables that can interface with each platform’s native UI toolkit we need a common definition of UI widgets. data class TextInput( val state: TextFieldState, val hint: String = \"\", val onChange: ((TextFieldState) -\u003e Unit)? = null, ) These definitions are called the schema. If your app has a formal design system this will be a programmatic representation of its contents. From the schema Redwood generates a composable and an interface. @Composable fun TextInput( state: TextFieldState, hint: String = \"\", onChange: ((TextFieldState) -\u003e Unit)? = null, modifier: Modifier = Modifier, ) { … } interface TextInput\u003cW : Any\u003e : Widget\u003cW\u003e { fun state(state: TextFieldState) fun hint(hint: String) fun onChange(onChange: ((TextFieldState) -\u003e Unit)?) } Each platform binds an implementation of the interface to an associate native UI component. To drive the UI we write regular Compose code, only with these generated composables instead of Compose UI. Redwood takes care of plumbing both halves together. The Redwood repo is also home to Treehouse, a module which uses Zipline to dynamically update the composable logic at runtime. This improves the development experience, but also allows updating our app logic in the wild between app upgrades. Today we are releasing Redwood 0.5 which we’re calling “beta”. Breaking changes are still allowed, but all changes will be compatible with previous versions when running across the updatable Treehouse bridge. This means using a future Redwood 0.6 we can still target older apps only running Redwood 0.5. Redwood, Zipline, and Treehouse are a big effort–much too large for one or two blog posts. If you want more information consider watching some of our recent conference talks: “Playing in the Treehouse with Redwood and Zipline” @ KotlinConf 2023 “Dynamic code with Zipline” @ Droidcon NYC 2022 “Native UI with multiplatform Compose” @ Droidcon NYC 2022 Our usage of Redwood to date has been very limited. With today’s beta we are excited to start rolling out experiences to all customers soon. This post is part of Cash App’s Summer of Kotlin Multiplatform series.",
  "image": "https://code.cash.app/assets/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n\n  \u003cdiv\u003e\u003cp\u003e\n    Posted by\n    \u003ca href=\"https://jakewharton.com/\"\u003eJake Wharton\u003c/a\u003e\n    \n      \u003cspan\u003eon \u003c/span\u003e\u003ctime datetime=\"2023-07-05 00:00:00 +0000\"\u003eJuly  5, 2023\u003c/time\u003e\n    \n  \u003c/p\u003e\u003c/div\u003e\n\n  \u003cp\u003e\u003ca href=\"https://github.com/cashapp/redwood\"\u003eRedwood\u003c/a\u003e is Cash App’s take on multiplatform mobile client UI. Unlike many of the existing solutions to this problem, our values are slightly different:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eRender using the native UI toolkit on each platform. Native UI is the best UI, and we want to ensure our engineers can continue to use all their skills when building UI components.\u003c/li\u003e\n  \u003cli\u003eRetain the ability to reuse components from the rest of the application. The existing styles and custom controls used by the rest of the app are available without redefinition keeping a single source of truth.\u003c/li\u003e\n  \u003cli\u003eUse a mobile language with great tooling. We want to tap into the existing skills of our engineers to build within this new system and not have to learn a new ecosystem.\u003c/li\u003e\n  \u003cli\u003eAllow for incremental adoption in an existing app. This shouldn’t be an all-or-nothing framework but a library that you can use only where it’s needed.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eWe chose the \u003ca href=\"https://kotlinlang.org/\"\u003eKotlin programming language\u003c/a\u003e because it can compile to Java bytecode, native (via LLVM), and Javascript. This supports use on Android, iOS, and the web using intrinsic execution on each platform.\u003c/p\u003e\n\n\u003cp\u003eOn top of Kotlin we leverage Compose for creating UI nodes and managing state. Compose UI started as an Android-specific UI toolkit which was later ported to Kotlin multiplatform by JetBrains to run on Desktop and iOS. Compose, the underlying technology, can be used to manage state alongside any tree-like structure. Redwood’s Compose uses a custom tree which talks to the native UI toolkit on each platform.\u003c/p\u003e\n\n\u003cp\u003eIn order to create a multiplatform set of composables that can interface with each platform’s native UI toolkit we need a common definition of UI widgets.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata class\u003c/span\u003e \u003cspan\u003eTextInput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n  \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ehint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eonChange\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnit\u003c/span\u003e\u003cspan\u003e)?\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThese definitions are called the schema. If your app has a formal design system this will be a programmatic representation of its contents.\u003c/p\u003e\n\n\u003cp\u003eFrom the schema Redwood generates a composable and an interface.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@Composable\u003c/span\u003e\n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eTextInput\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n  \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003ehint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003eonChange\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnit\u003c/span\u003e\u003cspan\u003e)?\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n  \u003cspan\u003emodifier\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eModifier\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eModifier\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e…\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003einterface\u003c/span\u003e \u003cspan\u003eTextInput\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eW\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eWidget\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eW\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ehint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ehint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonChange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eonChange\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eTextFieldState\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnit\u003c/span\u003e\u003cspan\u003e)?)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eEach platform binds an implementation of the interface to an associate native UI component. To drive the UI we write regular Compose code, only with these generated composables instead of Compose UI. Redwood takes care of plumbing both halves together.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://code.cash.app/assets/2023-07/redwood-1.png\" alt=\"Screenshot showing the iOS simulator, a web browser, and the Android emulator each running a version of the same app which is an input box containing the word \u0026#34;tree\u0026#34; and below it a list of five emoji images and their names which all contain the word \u0026#34;tree\u0026#34;\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe Redwood repo is also home to Treehouse, a module which uses \u003ca href=\"https://code.cash.app/zipline\"\u003eZipline\u003c/a\u003e to dynamically update the composable logic at runtime. This improves the development experience, but also allows updating our app logic in the wild between app upgrades.\u003c/p\u003e\n\n\u003cp\u003eToday we are releasing Redwood 0.5 which we’re calling “beta”. Breaking changes are still allowed, but all changes will be compatible with previous versions when running across the updatable Treehouse bridge. This means using a future Redwood 0.6 we can still target older apps only running Redwood 0.5.\u003c/p\u003e\n\n\u003cp\u003eRedwood, Zipline, and Treehouse are a big effort–much too large for one or two blog posts. If you want more information consider watching some of our recent conference talks:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=G4LK_euTadU\"\u003e“Playing in the Treehouse with Redwood and Zipline”\u003c/a\u003e @ KotlinConf 2023\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.droidcon.com/2022/09/29/dynamic-code-with-zipline/\"\u003e“Dynamic code with Zipline”\u003c/a\u003e @ Droidcon NYC 2022\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.droidcon.com/2022/09/29/native-ui-with-multiplatform-compose/\"\u003e“Native UI with multiplatform Compose”\u003c/a\u003e @ Droidcon NYC 2022\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOur usage of Redwood to date has been very limited. With today’s beta we are excited to start rolling out experiences to all customers soon.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://code.cash.app/assets/2023-07/redwood-2.png\" alt=\"Screenshot of Cash App running on iOS and Android showing the same \u0026#34;Money\u0026#34; screen with items like a cash balance and tiles for savings, taxes, and investing\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eThis post is part of Cash App’s \u003ca href=\"https://code.cash.app/kotlin-multiplatform-summer\"\u003eSummer of Kotlin Multiplatform\u003c/a\u003e series.\u003c/em\u003e\u003c/p\u003e\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2023-07-05T00:00:00Z",
  "modifiedTime": null
}
