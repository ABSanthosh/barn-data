{
  "id": "67c31402-3532-44c5-bb50-ba716aa98e80",
  "title": "Mastering Playback State with EXO Player",
  "link": "https://proandroiddev.com/mastering-playback-state-with-exo-player-977016aa5003?source=rss----c72404660798---4",
  "description": "",
  "author": "Siva Ganesh Kantamani",
  "published": "Sat, 26 Jul 2025 13:37:30 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "media-player",
    "jetpack-compose",
    "androiddev",
    "exoplayer2",
    "android-app-development"
  ],
  "byline": "Siva Ganesh Kantamani",
  "length": 11362,
  "excerpt": "This is the second part of the series that delves into the EXO player in Android. In the first part, we explored the origins of the player, its basic functionalities, integration with the Jetpack…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Mastering Playback State with EXO PlayerListeners — Buffering and Analytics, Timeline UI, and Cache MechanismZoom image will be displayedPhoto by Kelly Sikkema on UnsplashOverviewThis is the second part of the series that delves into the EXO player in Android. In the first part, we explored the origins of the player, its basic functionalities, integration with the Jetpack Compose, custom video controllers, playlist implementation, and some real-time use-case handling.I recommend reading the first part before proceeding further to gain a comprehensive understanding.In this part of the series, we’ll deep dive into player listeners to implement loading views during buffering and analytics. Then, we’ll implement a timeline view similar to the YouTube player, featuring a seekbar and a timer at the bottom. To conclude the article, we’ll introduce a caching mechanism to enhance playback speed.Settle into your comfortable office space with a cup of coffee; this will be an interesting article.Implementing Buffering IndicatorsLet’s begin with a simple real-time use case for the player listener, which is nothing but showing the circular loading while the player is yet to be ready to start the playback or while buffering the video.To achieve this functionality, we’ll subscribe to Player.Listener and override onPlaybackStateChanged, which provides us with access to playbackState. This allows us to determine the current playback state. As this is UI related, we’ll subscribe to this listener in our VideoControls compose function. Have a look at the listener subscription:DisposableEffect(player) { val listener = object : Player.Listener { override fun onPlaybackStateChanged(playbackState: Int) { super.onPlaybackStateChanged(playbackState) duration = player.duration.coerceAtLeast(0L) if(playbackState == Player.STATE_BUFFERING) { // show loading } } } player.addListener(listener) onDispose { player.removeListener(listener) } }Now, we need to create a state within the VideoControls Compose that will be updated whenever a callback occurs in the listener. Based on this state, we’ll display either the play/pause icons or a circular loading view. The state we’re going to add in the VideoControls looks as follows:var isBuffering by remember { mutableStateOf(player.isLoading) }Before proceeding with the implementation, we’ll separate the concerns of the VideoControls function since it’s becoming too complex. We’ll create a separate compose function called ShowButtonControllers, which will contain all buttons related to the UI. Additionally, we’ll pass all the necessary states as parameters to this function.After segregation, this is how VideoControls and ShowButtonControllers looks:That’s all we need to do. Whenever there’s buffering or the player isn’t ready to start playback, we are displaying a nice loading view to inform the user about the situation.Playback AnalyticsAnalytics is one of the most common real-time use cases where we heavily depend on EXO Player listeners. Fortunately, we already have an AnalyticsListener out of the box from the Media3 EXO player library for this purpose.To achieve scalable implementation, we can create a custom analytics class and extend it with the AnalyticsListener from EXO Player. Then we can override the functions as per our specific requirements and log them across various analytics platforms.class LearningsPlayerAnalytics(): AnalyticsListener {}A few of the commonly used functions are onPlaybackStateChanged, onPlayerError, onMediaItemTransition, etc. I’ve also decided to pass the EXO player instance to this via the constructor, to get the video ID from the player and log the events along with that ID. To keep things simple, just print the events in the logcat, have a look at the implementation:A few commonly used functions include onPlaybackStateChanged, onPlayerError, and onMediaItemTransition. I’ve also decided to pass the EXO player instance via the constructor to retrieve the video ID from the player media item and log the events along with that ID. To keep things simple, I’ll simply print the events in the logcat. For a more detailed look at the implementation, refer to the code below:Here is the code to set the video ID as a tag to the media item of the EXO player:MediaItem.Builder().setUri(Video_1).setMediaId(\"Video_1\").setTag(\"Video_1\").build(),There are many more things that can be logged, such as the duration of playback, buffer, and audio-related information, among others. However, you’ll get the general idea of how to do it from the above simple implementation, so I’ll leave it for now.Building a Custom Timeline ViewThe custom timeline view is nothing but a seekbar that allows you to jump between the video timeline and a view that displays the current and total duration, similar to how it works in the YouTube player.Let’s begin by creating the Composable function to design the view. We’ll include the current player position, the total video duration, and the formatted time as parameters. Additionally, we’ll have a couple of lambda functions, one that returns a boolean variable to represent the seeking status and another that communicates the seekbar position after a seek action. Have a look:@Composablefun TimelineControllers( modifier: Modifier = Modifier, playerPosition: Long, duration: Long, seeking: (Boolean) -\u003e Unit, formatedTime: String, seekPlayerToPosition:(Long) -\u003e Unit,)Now, let’s begin with the Compose code. We’ll use Slider and Text Composable wrapped inside a Row. To customize the appearance of the Slider, we’ll utilize the track. Then, we need to calculate the fraction of the video that is watched to highlight it and dim down the rest of the slider. Take a look at the implementation:Now we need to integrate this function inside VideoControls, and supply all the states needed by updating them from the player parameter in VideoControls. Let’s start with the states to be added in the function:Now, we need to integrate this function into VideoControls and provide all the necessary states that need to be updated from the player parameter in VideoControls. Let’s begin by listing the states that need to be added to the function:var duration by remember { mutableStateOf(0L) }var position by remember { mutableStateOf(0L) }var isSeeking by remember { mutableStateOf(false) }var formatedTime by remember { mutableStateOf(\"\") }Let’s begin with duration. We’ll utilize the onPlaybackStateChanged event, which we’ve already observed in the function to retrieve the duration state from the player. Take a look:DisposableEffect(player) { val listener = object : Player.Listener { override fun onIsPlayingChanged(isPlayingNow: Boolean) { } override fun onPlaybackStateChanged(playbackState: Int) { super.onPlaybackStateChanged(playbackState) // Updating the duration, if not fallback to 0 duration = player.duration.coerceAtLeast(0L) } } player.addListener(listener) onDispose { player.removeListener(listener) }}To update the position and formattedTime, we’ll use the LaunchedEffect with the keys as player and isSeeking. Whenever any of them changes, we’ll recalculate both position and formattedTime. To ensure the UI is in sync with the playback, we need to update them every 500 milliseconds. However, we need to be cautious and avoid recalculating them while the player is seeking. Here’s the implementation:LaunchedEffect(player, isSeeking) { while (isActive) { if (player.isPlaying \u0026\u0026 isSeeking.not()) { position = player.currentPosition if (player.duration != duration) { duration = player.duration } } formatedTime = \"${formatTime(position)} : ${formatTime(duration)}\" delay(500) }}Finally, isSeeking is to be updated on the callback of the lambda function we’re sending to TimelineControllers. Have a look at the complete implementation:To complete the timeline view, we need to handle the manual seek action to play the content from the desired position. To do this, we need to add SEEK as part of ActionType and handle it in the view model.enum class ActionType { PLAY, PAUSE, REWIND, FORWARD, PREVIOUS, NEXT, SEEK,}Now in the view model, we’ll create a separate EXO Player extension function and seek the player to the given position. Have a look:private fun ExoPlayer.seekWithValidation(position: Long?) { logEvent(\"seeking\") position?.let { seekTo(position) }}That’s all, we’re done with the timeline view implementation with YouTube style.Building a Cache MechanismTo implement a cache mechanism, we’ll use SimpleCache from the Media3 EXO player library. Additionally, we’ll use Okhttp as the data source (this is optional, but I prefer Okhttp for HTTP clients).To add okhttp as a data source, for which we need to add media3-datasource-okhttp. Add the following to the toml filemedia3-datasource-okhttp = { module = \"androidx.media3:media3-datasource-okhttp\", version.ref = \"media3ExoplayerDash\" }Then integrate it in the application via app-level gradle file:implementation(libs.media3.datasource.okhttp)Now that we’ve completed the integration part, let’s begin by creating a class to encapsulate the logic related to cache location, maximum cache size, and so on. Finally, we’ll create an instance of the SimpleCache class from the EXO player. Take a look:Now, we need to construct the CacheDataSource by setting OkHttpDataSource as the upstream data source factory and using the SimpleCache instance we created earlier. Have a look:As a final step, we need to add the above-created data source to the EXO player while creating the instance of the player. Have a look:ExoPlayer.Builder(context) .setMediaSourceFactory( DefaultMediaSourceFactory( buildOkHttoDataSourceFactory(context) ) ) .build().apply { setMediaItems(mediaItems) prepare() playWhenReady = true }That’s all. If you run the application now, you will notice less buffering while navigating through the playlist.Media Transition Handling — Real Time Playlist ProblemIn the previous part of the series, we introduced a playlist feature. This feature allows us to track the current positions of each video, enabling us to resume playback of each video based on its progress.It worked well, but the issue arises when the video reaches its end, and the playback transitions to the next video. In such a case, the current saved position and the total duration remain the same. Consequently, when the user returns to the previous video, it will automatically move to the next one, as the playback is completed.We can handle this scenario by setting the current position to the beginning of the media item when the player listener callback onMediaItemTransition is triggered. This will happen if the media item reaches the end while the player is transitioning to the previous or next item. Have a look:End Note:Following is a link to the sample project, if you need it. Make sure to check out feature/timeline-listeners For this article related code :That is all for now. I hope you learned something useful. Thanks for reading!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*1Px65AlaG_NtvXhQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"e864\" data-testid=\"storyTitle\"\u003eMastering Playback State with EXO Player\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"7c6a\"\u003eListeners — Buffering and Analytics, Timeline UI, and Cache Mechanism\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\" role=\"tooltip\"\u003e\u003ca href=\"https://sgkantamani.medium.com/?source=post_page---byline--977016aa5003---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Siva Ganesh Kantamani\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*bVSRBKr1Pb75KQuhsPXO7g.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cdiv role=\"button\" tabindex=\"0\"\u003e\u003cp\u003e\u003cspan\u003eZoom image will be displayed\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@kellysikkema?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKelly Sikkema\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"832b\"\u003eOverview\u003c/h2\u003e\u003cp id=\"3c5b\"\u003eThis is the second part of the series that delves into the EXO player in Android. In the first part, we explored the origins of the player, its basic functionalities, integration with the Jetpack Compose, custom video controllers, playlist implementation, and some real-time use-case handling.\u003c/p\u003e\u003cp id=\"5c31\"\u003eI recommend reading the first part before proceeding further to gain a comprehensive understanding.\u003c/p\u003e\u003cp id=\"6dd6\"\u003eIn this part of the series, we’ll deep dive into player listeners to implement loading views during buffering and analytics. Then, we’ll implement a timeline view similar to the YouTube player, featuring a seekbar and a timer at the bottom. To conclude the article, we’ll introduce a caching mechanism to enhance playback speed.\u003c/p\u003e\u003cp id=\"c5c1\"\u003eSettle into your comfortable office space with a cup of coffee; this will be an interesting article.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"104e\"\u003eImplementing Buffering Indicators\u003c/h2\u003e\u003cp id=\"5f10\"\u003eLet’s begin with a simple real-time use case for the player listener, which is nothing but showing the circular loading while the player is yet to be ready to start the playback or while buffering the video.\u003c/p\u003e\u003cp id=\"dc5a\"\u003eTo achieve this functionality, we’ll subscribe to \u003ccode\u003ePlayer.Listener\u003c/code\u003e and override \u003ccode\u003eonPlaybackStateChanged\u003c/code\u003e, which provides us with access to \u003ccode\u003eplaybackState\u003c/code\u003e. This allows us to determine the current playback state. As this is UI related, we’ll subscribe to this listener in our \u003ccode\u003eVideoControls\u003c/code\u003e compose function. Have a look at the listener subscription:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fcff\"\u003eDisposableEffect(player) {\u003cbr/\u003e        val listener = object : Player.Listener {\u003cbr/\u003e            override fun onPlaybackStateChanged(playbackState: Int) {\u003cbr/\u003e                super.onPlaybackStateChanged(playbackState)\u003cbr/\u003e                duration = player.duration.coerceAtLeast(0L)\u003cbr/\u003e                if(playbackState == Player.STATE_BUFFERING) {\u003cbr/\u003e                    // show loading\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        player.addListener(listener)\u003cp\u003e        onDispose {\u003cbr/\u003e            player.removeListener(listener)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b38d\"\u003eNow, we need to create a state within the \u003ccode\u003eVideoControls\u003c/code\u003e Compose that will be updated whenever a callback occurs in the listener. Based on this state, we’ll display either the play/pause icons or a circular loading view. The state we’re going to add in the \u003ccode\u003eVideoControls\u003c/code\u003e looks as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0b65\"\u003evar isBuffering by remember { mutableStateOf(player.isLoading) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"56d0\"\u003eBefore proceeding with the implementation, we’ll separate the concerns of the VideoControls function since it’s becoming too complex. We’ll create a separate compose function called ShowButtonControllers, which will contain all buttons related to the UI. Additionally, we’ll pass all the necessary states as parameters to this function.\u003c/p\u003e\u003cp id=\"9cab\"\u003eAfter segregation, this is how \u003ccode\u003eVideoControls\u003c/code\u003e and \u003ccode\u003eShowButtonControllers\u003c/code\u003e looks:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0f9b\"\u003eThat’s all we need to do. Whenever there’s buffering or the player isn’t ready to start playback, we are displaying a nice loading view to inform the user about the situation.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"873f\"\u003ePlayback Analytics\u003c/h2\u003e\u003cp id=\"afff\"\u003eAnalytics is one of the most common real-time use cases where we heavily depend on EXO Player listeners. Fortunately, we already have an \u003ccode\u003eAnalyticsListener\u003c/code\u003e out of the box from the Media3 EXO player library for this purpose.\u003c/p\u003e\u003cp id=\"ee67\"\u003eTo achieve scalable implementation, we can create a custom analytics class and extend it with the \u003ccode\u003eAnalyticsListener\u003c/code\u003e from EXO Player. Then we can override the functions as per our specific requirements and log them across various analytics platforms.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"882b\"\u003eclass LearningsPlayerAnalytics(): AnalyticsListener {\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3ac6\"\u003eA few of the commonly used functions are onPlaybackStateChanged, onPlayerError, onMediaItemTransition, etc. I’ve also decided to pass the EXO player instance to this via the constructor, to get the video ID from the player and log the events along with that ID. To keep things simple, just print the events in the logcat, have a look at the implementation:\u003c/p\u003e\u003cp id=\"e9fb\"\u003eA few commonly used functions include onPlaybackStateChanged, onPlayerError, and onMediaItemTransition. I’ve also decided to pass the EXO player instance via the constructor to retrieve the video ID from the player media item and log the events along with that ID. To keep things simple, I’ll simply print the events in the logcat. For a more detailed look at the implementation, refer to the code below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"64c0\"\u003eHere is the code to set the video ID as a tag to the media item of the EXO player:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6d16\"\u003eMediaItem.Builder().setUri(Video_1).setMediaId(\u0026#34;Video_1\u0026#34;).setTag(\u0026#34;Video_1\u0026#34;).build(),\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2ced\"\u003eThere are many more things that can be logged, such as the duration of playback, buffer, and audio-related information, among others. However, you’ll get the general idea of how to do it from the above simple implementation, so I’ll leave it for now.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c622\"\u003eBuilding a Custom Timeline View\u003c/h2\u003e\u003cp id=\"c15a\"\u003eThe custom timeline view is nothing but a seekbar that allows you to jump between the video timeline and a view that displays the current and total duration, similar to how it works in the YouTube player.\u003c/p\u003e\u003cp id=\"8c74\"\u003eLet’s begin by creating the Composable function to design the view. We’ll include the current player position, the total video duration, and the formatted time as parameters. Additionally, we’ll have a couple of lambda functions, one that returns a boolean variable to represent the seeking status and another that communicates the seekbar position after a seek action. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7a07\"\u003e@Composable\u003cbr/\u003efun TimelineControllers(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    playerPosition: Long,\u003cbr/\u003e    duration: Long,\u003cbr/\u003e    seeking: (Boolean) -\u0026gt; Unit,\u003cbr/\u003e    formatedTime: String,\u003cbr/\u003e    seekPlayerToPosition:(Long) -\u0026gt; Unit,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"14b3\"\u003eNow, let’s begin with the Compose code. We’ll use Slider and Text Composable wrapped inside a Row. To customize the appearance of the Slider, we’ll utilize the track. Then, we need to calculate the fraction of the video that is watched to highlight it and dim down the rest of the slider. Take a look at the implementation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4de3\"\u003eNow we need to integrate this function inside VideoControls, and supply all the states needed by updating them from the player parameter in VideoControls. Let’s start with the states to be added in the function:\u003c/p\u003e\u003cp id=\"4ec4\"\u003eNow, we need to integrate this function into \u003ccode\u003eVideoControls\u003c/code\u003e and provide all the necessary states that need to be updated from the player parameter in \u003ccode\u003eVideoControls\u003c/code\u003e. Let’s begin by listing the states that need to be added to the function:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b0a9\"\u003evar duration by remember { mutableStateOf(0L) }\u003cbr/\u003evar position by remember { mutableStateOf(0L) }\u003cbr/\u003evar isSeeking by remember { mutableStateOf(false) }\u003cbr/\u003evar formatedTime by remember { mutableStateOf(\u0026#34;\u0026#34;) }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f350\"\u003eLet’s begin with duration. We’ll utilize the onPlaybackStateChanged event, which we’ve already observed in the function to retrieve the duration state from the player. Take a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5a4f\"\u003eDisposableEffect(player) {\u003cbr/\u003e    val listener = object : Player.Listener {\u003cbr/\u003e        override fun onIsPlayingChanged(isPlayingNow: Boolean) {\u003cbr/\u003e        }\u003cp\u003e        override fun onPlaybackStateChanged(playbackState: Int) {\u003cbr/\u003e            super.onPlaybackStateChanged(playbackState)\u003cbr/\u003e            // Updating the duration, if not fallback to 0\u003cbr/\u003e            duration = player.duration.coerceAtLeast(0L)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    player.addListener(listener)\u003c/p\u003e\u003cp\u003e    onDispose {\u003cbr/\u003e        player.removeListener(listener)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7626\"\u003eTo update the \u003ccode\u003eposition\u003c/code\u003e and \u003ccode\u003eformattedTime\u003c/code\u003e, we’ll use the \u003ccode\u003eLaunchedEffect\u003c/code\u003e with the keys as \u003ccode\u003eplayer\u003c/code\u003e and \u003ccode\u003eisSeeking\u003c/code\u003e. Whenever any of them changes, we’ll recalculate both position and formattedTime. To ensure the UI is in sync with the playback, we need to update them every 500 milliseconds. However, we need to be cautious and avoid recalculating them while the player is seeking. Here’s the implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"230e\"\u003eLaunchedEffect(player, isSeeking) {\u003cbr/\u003e    while (isActive) {\u003cbr/\u003e        if (player.isPlaying \u0026amp;\u0026amp; isSeeking.not()) {\u003cbr/\u003e            position = player.currentPosition\u003cbr/\u003e            if (player.duration != duration) {\u003cbr/\u003e                duration = player.duration\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        formatedTime = \u0026#34;${formatTime(position)} : ${formatTime(duration)}\u0026#34;\u003cbr/\u003e        delay(500)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3571\"\u003eFinally, \u003ccode\u003eisSeeking\u003c/code\u003e is to be updated on the callback of the lambda function we’re sending to \u003ccode\u003eTimelineControllers\u003c/code\u003e. Have a look at the complete implementation:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c3f7\"\u003eTo complete the timeline view, we need to handle the manual seek action to play the content from the desired position. To do this, we need to add \u003ccode\u003eSEEK\u003c/code\u003e as part of \u003ccode\u003eActionType\u003c/code\u003e and handle it in the view model.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"49ef\"\u003eenum class ActionType {\u003cbr/\u003e    PLAY, PAUSE, REWIND, FORWARD, PREVIOUS, NEXT, SEEK,\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"518e\"\u003eNow in the view model, we’ll create a separate EXO Player extension function and seek the player to the given position. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4279\"\u003eprivate fun ExoPlayer.seekWithValidation(position: Long?) {\u003cbr/\u003e    logEvent(\u0026#34;seeking\u0026#34;)\u003cbr/\u003e    position?.let {\u003cbr/\u003e        seekTo(position)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a476\"\u003eThat’s all, we’re done with the timeline view implementation with YouTube style.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"76fd\"\u003eBuilding a Cache Mechanism\u003c/h2\u003e\u003cp id=\"baa8\"\u003eTo implement a cache mechanism, we’ll use SimpleCache from the Media3 EXO player library. Additionally, we’ll use Okhttp as the data source (this is optional, but I prefer Okhttp for HTTP clients).\u003c/p\u003e\u003cp id=\"0227\"\u003eTo add okhttp as a data source, for which we need to add \u003ccode\u003emedia3-datasource-okhttp\u003c/code\u003e. Add the following to the toml file\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"08e2\"\u003emedia3-datasource-okhttp = { module = \u0026#34;androidx.media3:media3-datasource-okhttp\u0026#34;, version.ref = \u0026#34;media3ExoplayerDash\u0026#34; }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"65d8\"\u003eThen integrate it in the application via app-level gradle file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"876d\"\u003eimplementation(libs.media3.datasource.okhttp)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5eea\"\u003eNow that we’ve completed the integration part, let’s begin by creating a class to encapsulate the logic related to cache location, maximum cache size, and so on. Finally, we’ll create an instance of the SimpleCache class from the EXO player. Take a look:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a8d0\"\u003eNow, we need to construct the \u003ccode\u003eCacheDataSource\u003c/code\u003e by setting \u003ccode\u003eOkHttpDataSource\u003c/code\u003e as the upstream data source factory and using the \u003ccode\u003eSimpleCache\u003c/code\u003e instance we created earlier. Have a look:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7a5c\"\u003eAs a final step, we need to add the above-created data source to the EXO player while creating the instance of the player. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e160\"\u003eExoPlayer.Builder(context)\u003cbr/\u003e    .setMediaSourceFactory(\u003cbr/\u003e        DefaultMediaSourceFactory(\u003cbr/\u003e              buildOkHttoDataSourceFactory(context)\u003cbr/\u003e        )\u003cbr/\u003e    )\u003cbr/\u003e    .build().apply {\u003cbr/\u003e        setMediaItems(mediaItems)\u003cbr/\u003e        prepare()\u003cbr/\u003e        playWhenReady = true\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"27b9\"\u003eThat’s all. If you run the application now, you will notice less buffering while navigating through the playlist.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"fcee\"\u003eMedia Transition Handling — Real Time Playlist Problem\u003c/h2\u003e\u003cp id=\"2df7\"\u003eIn the previous part of the series, we introduced a playlist feature. This feature allows us to track the current positions of each video, enabling us to resume playback of each video based on its progress.\u003c/p\u003e\u003cp id=\"6ae7\"\u003eIt worked well, but the issue arises when the video reaches its end, and the playback transitions to the next video. In such a case, the current saved position and the total duration remain the same. Consequently, when the user returns to the previous video, it will automatically move to the next one, as the playback is completed.\u003c/p\u003e\u003cp id=\"7ae0\"\u003eWe can handle this scenario by setting the current position to the beginning of the media item when the player listener callback \u003ccode\u003eonMediaItemTransition\u003c/code\u003e is triggered. This will happen if the media item reaches the end while the player is transitioning to the previous or next item. Have a look:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"241d\"\u003eEnd Note:\u003c/h2\u003e\u003cp id=\"20a1\"\u003eFollowing is a link to the sample project, if you need it. Make sure to check out \u003ccode\u003efeature/timeline-listeners\u003c/code\u003e For this article related code :\u003c/p\u003e\u003cp id=\"866e\"\u003eThat is all for now. I hope you learned something useful. Thanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-07-26T13:37:30.177Z",
  "modifiedTime": null
}
