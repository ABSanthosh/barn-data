{
  "id": "72358e5b-e1b4-4eec-a927-83094ecd8faa",
  "title": "Jetpack Compose APIs for building adaptive layouts using Material guidance now stable",
  "link": "http://android-developers.googleblog.com/2024/09/jetpack-compose-apis-for-building-adaptive-layouts-material-guidance-now-stable.html",
  "description": "",
  "author": "Android Developers",
  "published": "2024-09-09T10:01:00.000-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "adaptive API",
    "adaptive layouts",
    "adaptive UI",
    "Compose",
    "Compose Material 3",
    "library"
  ],
  "byline": "",
  "length": 8737,
  "excerpt": "Build adaptive layouts for optimized user experience on any window size with flexible, customizable components and tools for creating responsive UIs.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Alex Vanyo – Developer Relations Engineer The 1.0 stable version of the Compose adaptive APIs with Material guidance is out, ready to be used in production. The library helps you build adaptive layouts that provide an optimized user experience on any window size. The team at SAP Mobile Start were early adopters of the Compose adaptive APIs. It took their developers only five minutes to integrate the NavigationSuiteScaffold from the new Compose Material 3 adaptive library, rapidly adapting the app’s navigation UI to different window sizes. Each of the new components in the library, NavigationSuiteScaffold, ListDetailPaneScaffold and SupportingPaneScaffold are adaptive: based on the window size and posture, different components are displayed to the user based on which one is most appropriate in the current context. This helps build UI that adapts to a wide variety of window sizes instead of just stretching layouts. For an overview of the components, check out the dedicated I/O session and our new documentation pages to get started. In this post, we’re going to take a more detailed look at the layering of the new library so you have a better understanding of how customisable it is, to fit a wide variety of use cases you might have. Similar to Compose itself, the adaptive libraries are layered into multiple dependencies, so that you can choose the appropriate level of abstraction for your application.There are four new artifacts as part of the adaptive libraries: For the core building blocks for building adaptive UI, including computing the window size class and the current posture, add androidx.compose.material3.adaptive:adaptive:1.0.0 For implementing multi-pane layouts, add androidx.compose.material3.adaptive:adaptive-layout:1.0.0 Contains the multi-pane scaffold layouts ListDetailPaneScaffold and SupportingPaneScaffold For standalone navigators for the multi-pane scaffold layouts, add androidx.compose.material3.adaptive:adaptive-navigation:1.0.0 For implementing adaptive navigation UI, add androidx.compose.material3:material3-adaptive-navigation-suite:1.3.0 The libraries have the following dependencies: New library dependency graph To explore this layering more, let’s start with the highest level example with the most built-in functionality using a NavigableListDetailPaneScaffold from androidx.compose.material3.adaptive:adaptive-navigation: val navigator = rememberListDetailPaneScaffoldNavigator\u003cAny\u003e() NavigableListDetailPaneScaffold( navigator = navigator, listPane = { // List pane }, detailPane = { // Detail pane }, ) This snippet of code gives you all of our recommended adaptive behavior out of the box for a list-detail layout: determining how many panes to show based on the current window size, hiding and showing the correct pane when the window size changes depending on the previous state of the UI, and having the back button conditionally bring the user back to the list, depending on the window size and the current state. This encapsulates a lot of behavior – and this might be all you need, and you don’t need to go any deeper! However, there may be reasons why you may want to tweak this behavior, or more directly manage the state by hoisting parts of it in a different way. Remember, each layer builds upon the last. This snippet is at the outermost layer, and we can start unwrapping the layers to customize it where we need. Let’s go one level deeper with NavigableListDetailPaneScaffold and drop down one layer. Behavior won’t change at all with these direct inlinings, since we are just inlining the default behavior at each step: (Fun fact: You can follow along with this directly in Android Studio and for any other component you desire. If you choose Refactor \u003e Inline function, you can directly replace a component with its implementation. You can’t delete the original function in the library of course.) val navigator = rememberListDetailPaneScaffoldNavigator\u003cAny\u003e() BackHandler( enabled = navigator.canNavigateBack(BackNavigationBehavior.PopUntilContentChange) ) { navigator.navigateBack(BackNavigationBehavior.PopUntilContentChange) } ListDetailPaneScaffold( directive = navigator.scaffoldDirective, value = navigator.scaffoldValue, listPane = { // List pane }, detailPane = { // Detail pane }, ) With the first inlining, we see the BackHandler that NavigableListDetailPaneScaffold includes by default. If using ListDetailPaneScaffold directly, back handling is left up to the developer to include and hoist to the appropriate place. This also reveals how the navigator provides two pieces of state to control the ListDetailPaneScaffold: directive —- how the panes should be arranged in the ListDetailPaneScaffold, and value —- the current state of the panes, as calculated from the directive and the current navigation state. These are both controlled by the navigator, and the next unpeeling shows us the default arguments to the navigator for directive and the adapt strategy, which is used to calculate value: val navigator = rememberListDetailPaneScaffoldNavigator\u003cAny\u003e( scaffoldDirective = calculatePaneScaffoldDirective(currentWindowAdaptiveInfo()), adaptStrategies = ListDetailPaneScaffoldDefaults.adaptStrategies(), ) BackHandler( enabled = navigator.canNavigateBack(BackNavigationBehavior.PopUntilContentChange) ) { navigator.navigateBack(BackNavigationBehavior.PopUntilContentChange) } ListDetailPaneScaffold( directive = navigator.scaffoldDirective, value = navigator.scaffoldValue, listPane = { // List pane }, detailPane = { // Detail pane }, ) The directive controls the behavior for how many panes to show and the pane spacing, based on currentWindowAdaptiveInfo, which contains the size and posture of the window. This can be customized with a different directive, to show two panes side-by-side at a smaller medium width: val navigator = rememberListDetailPaneScaffoldNavigator\u003cAny\u003e( scaffoldDirective = calculatePaneScaffoldDirectiveWithTwoPanesOnMediumWidth(currentWindowAdaptiveInfo()), adaptStrategies = ListDetailPaneScaffoldDefaults.adaptStrategies(), ) By default, showing two panes at a medium width can result in UI that is too narrow, especially for complex content. However, this can be a good option to use the window space more optimally by showing two panes for less complex content. The AdaptStrategy controls what happens to panes when there isn’t enough space to show all of them. Right now, this always hides panes for which there isn’t enough space. This directive is used by the navigator to drive its logic and, combined with the adapt strategy to determine the scaffold value, the resulting target state for each of the panes. The scaffold directive and the scaffold value are then passed to the ListDetailPaneScaffold, driving the behavior of the scaffold. This layering allows hoisting the scaffold state away from the display of the scaffold itself. This layering also allows custom implementations for controlling how the scaffold works and for hoisting related state. For example, if you are using a custom navigation solution instead of the navigator, you could drive the ListDetailPaneScaffold directly with state derived from your custom navigation solution. The layering is enforced in the library with the different artifacts: androidx.compose.material3.adaptive:adaptive contains the underlying methods to calculate the current window adaptive info androidx.compose.material3.adaptive:adaptive-layout contains the layouts ListDetailPaneScaffold and SupportingPaneScaffold androidx.compose.material3.adaptive:adaptive-navigation contains the navigator APIs (like rememberListDetailPaneScaffoldNavigator) Therefore, if you aren’t going to use the navigator and instead use a custom navigation solution, you can skip using androidx.compose.material3.adaptive:adaptive-navigation and depend on androidx.compose.material3.adaptive:adaptive-layout directly. When adding the Compose Adaptive library to your app, start with the most fully featured layer, and then unwrap if needed to tweak behavior. As we continue to work on the library and add new features, we’ll keep adding them to the appropriate layer. Using the higher-level layers will mean that you will be able to get these new features most easily. If you need to, you can use lower layers to get more fine-grained control, but that also means that more responsibility for behavior is transferred to your app, just like the layering in Compose itself. Try out the new components today, and send us your feedback for bugs and feature requests.",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjQjeNUPPsxNcdHmOSd54uH6MSoMiJysuH_kAdzzhyMmhxWpeepDnS6GP0dhoPP7U9RLHENlmaOOQNpKcTR1MA21TinJdXfc73BJFrGqg3SdhceL_bjIhW99PSgvZFZzPqR_kDCCnjVakUiKn_KMZCvOlD4FWqbCTAy5vbNMh6qjyJ1qKouAzjef3DFfQ/w1200-h630-p-k-no-nu/Android-Large-Screen-Form-Factors-Social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhjQjeNUPPsxNcdHmOSd54uH6MSoMiJysuH_kAdzzhyMmhxWpeepDnS6GP0dhoPP7U9RLHENlmaOOQNpKcTR1MA21TinJdXfc73BJFrGqg3SdhceL_bjIhW99PSgvZFZzPqR_kDCCnjVakUiKn_KMZCvOlD4FWqbCTAy5vbNMh6qjyJ1qKouAzjef3DFfQ/s1600/Android-Large-Screen-Form-Factors-Social.png\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by \u003cauthor\u003eAlex Vanyo – Developer Relations Engineer\u003c/author\u003e\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe 1.0 stable version of \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/compose-material3-adaptive\" target=\"_blank\"\u003ethe Compose adaptive APIs with Material guidance\u003c/a\u003e is out, ready to be used in production. The library helps you build \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive\" target=\"_blank\"\u003eadaptive layouts\u003c/a\u003e that provide an optimized user experience on any window size.\u003c/p\u003e\n\n\u003ciframe allowfullscreen=\"\" height=\"398\" src=\"https://www.youtube.com/embed/Nwnj01s-gOo\" width=\"100%\" youtube-src-id=\"Nwnj01s-gOo\"\u003e\u003c/iframe\u003e\n\n\u003cp\u003eThe team at SAP Mobile Start were early adopters of the Compose adaptive APIs. It took their developers \u003ca href=\"https://android-developers.googleblog.com/2024/09/sap-integrates-compose-adaptive-api-for-responsive-navigation-ui.html\" target=\"_blank\"\u003eonly five minutes to integrate the \u003cspan\u003eNavigationSuiteScaffold\u003c/span\u003e\u003c/a\u003e from the new Compose Material 3 adaptive library, rapidly adapting the app’s navigation UI to different window sizes.\u003c/p\u003e\n\n\u003cp\u003eEach of the new components in the library, \u003cspan\u003eNavigationSuiteScaffold\u003c/span\u003e, \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e and \u003cspan\u003eSupportingPaneScaffold\u003c/span\u003e are \u003ci\u003eadaptive\u003c/i\u003e: based on the window size and posture, different components are displayed to the user based on which one is most appropriate in the current context. This helps build UI that adapts to a wide variety of window sizes instead of just stretching layouts.\u003c/p\u003e\n\n\u003cp\u003eFor an overview of the components, check out the dedicated \u003ca href=\"https://www.youtube.com/watch?v=xPUZENis4gc\" target=\"_blank\"\u003eI/O session\u003c/a\u003e and our \u003ca href=\"https://developer.android.com/develop/ui/compose/layouts/adaptive\" target=\"_blank\"\u003enew documentation\u003c/a\u003e pages to get started.\u003c/p\u003e\n\n\u003cp\u003eIn this post, we’re going to take a more detailed look at the layering of the new library so you have a better understanding of how customisable it is, to fit a wide variety of use cases you might have.\u003c/p\u003e \n\n\u003cp\u003eSimilar to \u003ca href=\"https://developer.android.com/develop/ui/compose/layering\" target=\"_blank\"\u003eCompose itself\u003c/a\u003e, the adaptive libraries are layered into multiple dependencies, so that you can choose the appropriate level of abstraction for your application.There are four new artifacts as part of the adaptive libraries:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eFor the core building blocks for building adaptive UI, including computing the window size class and the current posture, add \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive:1.0.0\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eFor implementing multi-pane layouts, add \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-layout:1.0.0\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cul\u003e\u003cul\u003e\u003cli\u003eContains the multi-pane scaffold layouts \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/adaptive/layout/package-summary#ListDetailPaneScaffold%28androidx.compose.material3.adaptive.layout.PaneScaffoldDirective,androidx.compose.material3.adaptive.layout.ThreePaneScaffoldValue,kotlin.Function1,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1%29\" target=\"_blank\"\u003eListDetailPaneScaffold\u003c/a\u003e\u003c/span\u003e and \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/adaptive/layout/package-summary#SupportingPaneScaffold%28androidx.compose.material3.adaptive.layout.PaneScaffoldDirective,androidx.compose.material3.adaptive.layout.ThreePaneScaffoldValue,kotlin.Function1,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1%29\" target=\"_blank\"\u003eSupportingPaneScaffold\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eFor standalone navigators for the multi-pane scaffold layouts, add \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-navigation:1.0.0\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eFor implementing adaptive navigation UI, add \u003cspan\u003eandroidx.compose.material3:material3-adaptive-navigation-suite:1.3.0\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eThe libraries have the following dependencies:\u003c/p\u003e\n\n\n\u003cp\u003e\u003cimg alt=\"Flow diagram showing dependencies between material3-adaptive 1.0.0 and material 1.3.0 libraries\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEijyMpfuQveO7_inLD_hYQiSP4RHLx9NJX7dF_J3_EYDhzPmCLIPUw_4dhxBgdz8u-OAoH7SBm-_SwNsutG23cxPDsBCR_lJNJjbt_j4UZ4nGYmakHQw3OSZ6Q2qf2UOj2K5gQ0GlR-LYECwhFSBjUK7zaKlZ0nG7nkKU28qC66_vo_BjhPgTZmX_f-L3w/s1600/image2.png\" width=\"100%\"/\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eNew library dependency graph\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eTo explore this layering more, let’s start with the highest level example with the most built-in functionality using a \u003cspan\u003eNavigableListDetailPaneScaffold\u003c/span\u003e from \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-navigation\u003c/span\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval navigator \u003cspan\u003e=\u003c/span\u003e rememberListDetailPaneScaffoldNavigator\u003cspan\u003e\u0026lt;\u003c/span\u003eAny\u003cspan\u003e\u0026gt;()\u003c/span\u003e\n\nNavigableListDetailPaneScaffold\u003cspan\u003e(\u003c/span\u003e\n    navigator \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e,\u003c/span\u003e\n    listPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// List pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n    detailPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// Detail pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis snippet of code gives you all of our recommended adaptive behavior out of the box for a list-detail layout: determining how many panes to show based on the current window size, hiding and showing the correct pane when the window size changes depending on the previous state of the UI, and having the back button conditionally bring the user back to the list, depending on the window size and the current state.\u003c/p\u003e\n\n\n\u003cp\u003e\u003cimg alt=\"A list layout adapting to and from a list detail layout depending on the window size\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjfcVgJvk0K6ANCGUEBcCP7XnCjkVRYNynUiNGWz_pmukdMi_tFqXzaZTnGbYnlNSouFaNBC7KP0HpVaXXkoPtCDZ0uWPkBgbKgsucj5H6k44SSmZypBPM3eZvzwNZZdAEf5U8SrMvgL3xmWdBsraS1fu_wgViyUPW1YpPoqBDONSf6WIklmM9vJxaTGsE/s1600/image1.gif\" width=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThis encapsulates a lot of behavior – and this might be all you need, and you don’t need to go any deeper!\u003c/p\u003e\n\n\u003cp\u003eHowever, there may be reasons why you may want to tweak this behavior, or more directly manage the state by hoisting parts of it in a different way.\u003c/p\u003e\n\n\n\u003cp\u003eRemember, each layer builds upon the last. This snippet is at the outermost layer, and we can start unwrapping the layers to customize it where we need.\u003c/p\u003e\n\n\u003cp\u003eLet’s go one level deeper with \u003cspan\u003eNavigableListDetailPaneScaffold\u003c/span\u003e and drop down one layer. Behavior won’t change at all with these direct inlinings, since we are just inlining the default behavior at each step:\u003c/p\u003e\n\n\u003cp\u003e(Fun fact: You can follow along with this directly in Android Studio and for any other component you desire. If you choose \u003cb\u003eRefactor \u0026gt; Inline\u003c/b\u003e function, you can directly replace a component with its implementation. You can’t delete the original function in the library of course.)\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval navigator \u003cspan\u003e=\u003c/span\u003e rememberListDetailPaneScaffoldNavigator\u003cspan\u003e\u0026lt;\u003c/span\u003eAny\u003cspan\u003e\u0026gt;()\u003c/span\u003e\n\nBackHandler\u003cspan\u003e(\u003c/span\u003e\n    enabled \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecanNavigateBack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eBackNavigationBehavior\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePopUntilContentChange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enavigateBack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eBackNavigationBehavior\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePopUntilContentChange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\nListDetailPaneScaffold\u003cspan\u003e(\u003c/span\u003e\n    directive \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaffoldDirective\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    value \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaffoldValue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    listPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// List pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n    detailPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// Detail pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith the first inlining, we see the \u003cspan\u003eBackHandler\u003c/span\u003e that \u003cspan\u003eNavigableListDetailPaneScaffold\u003c/span\u003e includes by default. If using \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e directly, back handling is left up to the developer to include and hoist to the appropriate place.\u003c/p\u003e\n\n\u003cp\u003eThis also reveals how the navigator provides two pieces of state to control the \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cspan\u003edirective\u003c/span\u003e —- how the panes should be arranged in the \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e, and \u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cspan\u003evalue\u003c/span\u003e —- the current state of the panes, as calculated from the directive and the current navigation state.\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eThese are both controlled by the navigator, and the next unpeeling shows us the default arguments to the navigator for \u003cspan\u003edirective\u003c/span\u003e and the adapt strategy, which is used to calculate \u003cspan\u003evalue\u003c/span\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval navigator \u003cspan\u003e=\u003c/span\u003e rememberListDetailPaneScaffoldNavigator\u003cspan\u003e\u0026lt;\u003c/span\u003eAny\u003cspan\u003e\u0026gt;(\u003c/span\u003e\n    scaffoldDirective \u003cspan\u003e=\u003c/span\u003e calculatePaneScaffoldDirective\u003cspan\u003e(\u003c/span\u003ecurrentWindowAdaptiveInfo\u003cspan\u003e()),\u003c/span\u003e\n    adaptStrategies \u003cspan\u003e=\u003c/span\u003e ListDetailPaneScaffoldDefaults\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadaptStrategies\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\nBackHandler\u003cspan\u003e(\u003c/span\u003e\n    enabled \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecanNavigateBack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eBackNavigationBehavior\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePopUntilContentChange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enavigateBack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eBackNavigationBehavior\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePopUntilContentChange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\nListDetailPaneScaffold\u003cspan\u003e(\u003c/span\u003e\n    directive \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaffoldDirective\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    value \u003cspan\u003e=\u003c/span\u003e navigator\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaffoldValue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    listPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// List pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n    detailPane \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// Detail pane\u003c/span\u003e\n    \u003cspan\u003e},\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe directive controls the behavior for how many panes to show and the pane spacing, based on \u003cspan\u003ecurrentWindowAdaptiveInfo\u003c/span\u003e, which contains the size and posture of the window.\u003c/p\u003e\n\n\u003cp\u003eThis can be customized with a different directive, to show two panes side-by-side at a smaller medium width:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval navigator \u003cspan\u003e=\u003c/span\u003e rememberListDetailPaneScaffoldNavigator\u003cspan\u003e\u0026lt;\u003c/span\u003eAny\u003cspan\u003e\u0026gt;(\u003c/span\u003e\n    scaffoldDirective \u003cspan\u003e=\u003c/span\u003e calculatePaneScaffoldDirectiveWithTwoPanesOnMediumWidth\u003cspan\u003e(\u003c/span\u003ecurrentWindowAdaptiveInfo\u003cspan\u003e()),\u003c/span\u003e\n    adaptStrategies \u003cspan\u003e=\u003c/span\u003e ListDetailPaneScaffoldDefaults\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadaptStrategies\u003c/span\u003e\u003cspan\u003e(),\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eBy default, showing two panes at a medium width can result in UI that is too narrow, especially for complex content. However, this can be a good option to use the window space more optimally by showing two panes for less complex content.\u003c/p\u003e\n\n\u003cp\u003eThe \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/adaptive/layout/AdaptStrategy\" target=\"_blank\"\u003eAdaptStrategy\u003c/a\u003e\u003c/span\u003e controls what happens to panes when there isn’t enough space to show all of them. Right now, this always hides panes for which there isn’t enough space.\u003c/p\u003e\n\n\u003cp\u003eThis directive is used by the navigator to drive its logic and, combined with the adapt strategy to determine the scaffold value, the resulting target state for each of the panes.\u003c/p\u003e\n\n\u003cp\u003eThe scaffold directive and the scaffold value are then passed to the \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e, driving the behavior of the scaffold.\u003c/p\u003e\n\n\u003cp\u003eThis layering allows hoisting the scaffold state away from the display of the scaffold itself. This layering also allows custom implementations for controlling how the scaffold works and for hoisting related state. For example, if you are using a custom navigation solution instead of the navigator, you could drive the \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e directly with state derived from your custom navigation solution.\u003c/p\u003e\n\n\u003cp\u003eThe layering is enforced in the library with the different artifacts:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eandroidx.compose.material3.adaptive:adaptive\u003c/span\u003e contains the underlying methods to calculate the current window adaptive info\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-layout\u003c/span\u003e contains the layouts \u003cspan\u003eListDetailPaneScaffold\u003c/span\u003e and \u003cspan\u003eSupportingPaneScaffold\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003e\u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-navigation\u003c/span\u003e contains the navigator APIs (like \u003cspan\u003erememberListDetailPaneScaffoldNavigator\u003c/span\u003e)\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eTherefore, if you aren’t going to use the navigator and instead use a custom navigation solution, you can skip using \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-navigation\u003c/span\u003e and depend on \u003cspan\u003eandroidx.compose.material3.adaptive:adaptive-layout\u003c/span\u003e directly.\u003c/p\u003e\n\n\u003cp\u003eWhen adding the \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/compose-material3-adaptive\" target=\"_blank\"\u003eCompose Adaptive library\u003c/a\u003e to your app, start with the most fully featured layer, and then unwrap if needed to tweak behavior. As we continue to work on the library and add new features, we’ll keep adding them to the appropriate layer. Using the higher-level layers will mean that you will be able to get these new features most easily. If you need to, you can use lower layers to get more fine-grained control, but that also means that more responsibility for behavior is transferred to your app, just like the layering in Compose itself.\u003c/p\u003e\n\n\u003cp\u003eTry out the new components today, and send us your \u003ca href=\"https://issuetracker.google.com/issues/new?component=742043\" target=\"_blank\"\u003efeedback\u003c/a\u003e for bugs and feature requests.\u003c/p\u003e\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
