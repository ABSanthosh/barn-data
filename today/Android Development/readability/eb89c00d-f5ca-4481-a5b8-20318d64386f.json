{
  "id": "eb89c00d-f5ca-4481-a5b8-20318d64386f",
  "title": "Graduating from View IDs",
  "link": "https://saket.me/graduating-from-view-ids/",
  "description": "I found an old screen in Cash App today that wasn’t retaining its scroll position across configuration changes. A peek into git history revealed that the author forgot to assign an ID to its scrollable layout for enabling state restoration. And would you even blame them? Sure, View IDs are necessary, but maintaining them manually […] The post Graduating from View IDs appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Thu, 02 Dec 2021 08:55:21 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android",
    "jetpack compose"
  ],
  "byline": "Saket Narayan",
  "length": 1409,
  "excerpt": "Remembering to assign View IDs for state restoration is a chore, and I'm excited that Compose UI is getting rid of them!",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "I found an old screen in Cash App today that wasn’t retaining its scroll position across configuration changes. A peek into git history revealed that the author forgot to assign an ID to its scrollable layout for enabling state restoration. And would you even blame them? Sure, View IDs are necessary, but maintaining them manually is such a chore. It’s even easier to forget about them when layouts are built in Kotlin using contour, where findViewById is no longer needed. This is one of the many reasons why I’m so excited about Compose UI — it makes View IDs practically obsolete for state restoration. When rememberSaveable is used for saving values across Activity recreations, assigning a unique key (analogous to View IDs) is no longer needed. The Compose runtime is able to automatically generate unique keys for every exact location in your code! @Composable fun NewMessageField() { var text by rememberSaveable { mutableStateOf(\"block.xyz\") } TextField( value = text, onValueChange = { text = it } ) } What’s even better is that composables such as LazyColumn automatically use rememberSaveable under the hood so state restoration works out of the box with zero effort (in most cases). @Composable fun MessageList(messages: List) { LazyColumn { items(messages) { message -\u003e MessageRow(message) } } } Here’s to making better apps with less effort using Compose UI!",
  "image": "https://saket.me/wp-content/uploads/2021/12/vintage_tech.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eI found an old screen in \u003ca href=\"https://cash.app\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCash App\u003c/a\u003e today that wasn’t retaining its scroll position across configuration changes. A peek into git history revealed that the author forgot to assign an ID to its scrollable layout for enabling state restoration. And would you even blame them? Sure, View IDs are necessary, but maintaining them manually is such a chore. It’s even easier to forget about them when layouts are built in Kotlin using \u003ca href=\"https://github.com/cashapp/contour\" target=\"_blank\" rel=\"noopener noreferrer\"\u003econtour\u003c/a\u003e, where \u003ccode\u003efindViewById\u003c/code\u003e is no longer needed.\u003c/p\u003e\n\u003cp\u003eThis is one of the many reasons why I’m so excited about \u003ca href=\"https://developer.android.com/jetpack/compose\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCompose UI\u003c/a\u003e — it makes View IDs \u003cem\u003epractically\u003c/em\u003e obsolete for state restoration. When \u003ccode\u003erememberSaveable\u003c/code\u003e is used for saving values across Activity recreations, assigning a unique key (analogous to View IDs) is no longer needed. The Compose runtime is able to automatically generate unique keys for every exact location in your code!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun NewMessageField() {\n  var text by rememberSaveable { mutableStateOf(\u0026#34;block.xyz\u0026#34;) }\n\n  TextField(\n    value = text,\n    onValueChange = { text = it }\n  )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat’s even better is that composables such as \u003ccode\u003eLazyColumn\u003c/code\u003e automatically use \u003ccode\u003erememberSaveable\u003c/code\u003e \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/LazyDsl.kt;l=242;drc=139388e7452f762578a6c3caa758c97d23d1e8df\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eunder the hood\u003c/a\u003e so state restoration works out of the box with zero effort (in most cases).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun MessageList(messages: List) {\n  LazyColumn {\n    items(messages) { message -\u0026gt;\n      MessageRow(message)\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s to making better apps with less effort using Compose UI!\u003c/p\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "2 min read",
  "publishedTime": "2021-12-02T08:55:21Z",
  "modifiedTime": "2021-12-03T20:06:37Z"
}
