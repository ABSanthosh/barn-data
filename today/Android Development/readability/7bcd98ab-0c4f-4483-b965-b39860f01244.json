{
  "id": "7bcd98ab-0c4f-4483-b965-b39860f01244",
  "title": "Low-overhead wrappers using inline classes",
  "link": "https://okkotlin.com/inline-classes/",
  "description": "Previously, we discussed how Kotlin's type aliases could make our code more readable. However, if you remember, since type aliases don't…",
  "author": "",
  "published": "Sun, 08 Dec 2019 00:00:00 GMT",
  "source": "https://okkotlin.com/rss.xml",
  "categories": null,
  "byline": "",
  "length": 7232,
  "excerpt": "Wrappers shouldn't slow down our programs. Let's have a look at how we can use inline classes to create type-safe lightweight wrappers.",
  "siteName": "",
  "favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABlmWCKAAAFGUlEQVR4Ae1Zb2wURRT/zc5eqxQM2BZIJQEKUk1D/BewBg0otIAiwcAXEb4ZP0hsAkbUiCQYY4wmajBGiZiYmPiBWEMNH6SUaIEoJhA0Go1FW62FRNuKkYtpe7szvtm73e7e7rW0t6Xc3Uyy2Tdv/r3fb9+8ebsL6KIZ0AxoBjQDmgHNgGZAM6AZ0AyUIgNsvKCH96+5Q1pyEw28T4LdxJiskRLTxzvPVPYv33Xcw21eqSHWm01bbNgvE/g6NUY6AyUIfEGXMQmQbzctTKXEx7a0GwoaaQ7jRyUgtb9xZcoSLfScK3OML3h1TgIUeGmLY+TiiYJHOQoAI6pNub20ZUuxg1fYIz1A7flidnv/Qw95gIr2BL4oA54fuCuHCFBHndtYCvcAASrJoQPeOedLAbzCGCBAZXilAtzFGQiC6fTWbZqCu0HmVNyYXjg1CAz+O+lGBAhQub2b5MaxMpt9M9jcW+laAja9GrK/C/LPTogLPwDJvtASrGoBEo+95+jtn9phf/5qqE/cigABmReb/NcorwB/oBn8ltXBuebf5dSlNQz71EGIc58G26egFowBMbzVscr5SGw/GAIvlUtnCjPLYK56EuYjr1AU4q56Su4BD8jbAmaAN+0Gm1HtTCX/uwT7i3cgfj8LDF0GZs0DX/oQjDu3gDEGY8FykjdDnDmU99ITnSDgAROdxB2ngBlz06eoTA4g9dETEJ1fpsGrTpd6YZ84ALvtdXcIeMN2YMZsrx4pELEoqxi5VD2mEt9MZBBfut4zy+54FyAPiCrixzaIP751mljiehhLVkZ1S+sIrLlhL8p2tDqXuf554JokgIBg5jzHaGmnIH45mRsUtYjODq+dVdV6crbAG5+GsfheRy1+OwPryD4abGV3m3A9Ng9g1Yucfa0skeTqEPaoRsm/e7x2VrXQk/0CX7UDvH6to1IeY322FyBy4yzxBUHLF+XLpo1to7/PUDLU36i9B4yOU1VE7/ewDu8h8MOhfvkqYvMAOdBD3weFYw+7YQ6QMT6Xgcpj3CL/Ou+K3t0FrxSy/1fAR7DXKQYhNgLU05H93Z5JfNmjnhwSKKLz2zZ6apUdRhWZ2Ub89k0wspOqqAET0MVHAC1uf/WhZ4Jz1i9a4dU9gYKlufYZsEzOL/q6IM6f8JpdQfR+B6tlNzwS1uxErljhjpnIPVYCZNfXED3nHDsYN5HYuA/8wRdg1K8DU0nP8q1IbDvgRXUFzskJIgKmvNwHSSTYpz5Iz5e4DubDdAKMsbXGS0J8QTCzsnXkJZjrnoVR2+BoeN39gLqyihxMwj7+FqL2v7+rOHsIoqaeSFsBNrOG5n4OVuuL/i55ybF6gGMJpbxW6x5YJ9+HTPaHjFNPXXR/Q1ni4+ksMdQjrLCOvgb5z0WnQZ0Oxt3bwp2uUMMAyslHCtVHytAbq+P/zzNtFticOnodroSk/S77KKJPwnE2gmIsiXWW72r3vnrFvgVCy1M6LLtPZ36lhVqvuoJBXvAvGv8W8M9+Dcrk4oEcveQIYCY77H8upUUAw89lze3pczrDQkkRwMHphSJYSoYABnba3Nn2SRB+jn+D2Z0KvU6f3wYSprE1CkfRewB9ekwxzjazp9pG3tR8TBQ1AerJM240JpqPdfgwB8SiJUDteXL7ZaOBV0xMfiYY4PsqVOioU9E+KuBFrV7QBND+TkrJLqr0VmV4KsnJPuejQGudZkAzoBnQDGgGNAOaAc2AZkAzoBn4H3WFe3QRC8LrAAAAAElFTkSuQmCC",
  "text": "Previously, we discussed how Kotlin's type aliases could make our code more readable. However, if you remember, since type aliases don't introduce new types, they don't provide any type-safety. This week we will be exploring Kotlin's experimental inline classes which have benefits that type aliases provide but go further than that. A little about inline classes Kotlin introduced inline classes in their 1.3 release, advertised as light-weight wrapper classes. What separates inline classes from traditional wrappers is that inline classes don't add any overhead due to no additional heap allocations. Now that's a mouthful. Let's see what that means. Consider this function: fun renderLocation(latitude: Double, longitude: Double) { map.render(latitude, longitude) } Since both latitude and longitude are Double values, it's easy to pass them in the wrong order making our program render an incorrect map. We can prevent this error by introducing two wrapper classes called Latitude and Longitude like this, thereby, making our function type-safe: class Latitude(val value: Double) class Longitude(val value: Double) fun renderLocation(latitude: Latitude, longitude: Longitude) { map.render(latitude, longitude) } Although we made our function type-safe, we added a little overhead here. Every time we pass new values to our renderLocation function here, we need to initialise two new objects. This approach, as you might have guessed, results in additional expensive heap allocations. The previous version of our function didn't have this problem because primitive values are optimised by the compiler. All hope's not lost, yet: We can convert our plain old wrapper classes into inline classes to prevent any extra initialisation. How? Well, the Kotlin compiler treats inline classes as a drop-in replacement for their underlying value. Therefore, if we do this: inline class Latitude(val value: Double) inline class Longitude(val value: Double) fun renderLocation(latitude: Latitude, longitude: Longitude) { map.render(latitude, longitude) } When we run our program, Kotlin will try to replace every usage of Latitude or Longitude with a Double value. In cases where the type has to be retained, like for a type check using the as keyword, Kotlin will box the Double value into the appropriate wrapper class. Keep in mind that type erasure happens only during runtime or when your Kotlin code gets compiled to byte code. In our source code, we get full type support that we don't get while using a type alias. A decompiled Java version of our renderLocation will be this: public static final void renderLocation_vKZqJUM/* $FF was: renderLocation-vKZqJUM*/(double latitude, double longitude) { map.render-vKZqJUM(latitude, longitude); } Notice how the function parameters are plain old primitive double values. What happened to our function name? We named our function as renderLocation, but our Java code shows a weird name renderLocation-vKZqJUM, what's the deal here? It turns out, inline classes only work when we are writing Kotlin code. The hot-swapping of an inline class to its underlying type doesn't happen in Java. As a result, if we have multiple functions like this: fun renderLocation(latitude: Double, longitude: Double) {} fun renderLocation(latitude: Latitude, longitude: Longitude) { map.render(latitude, longitude) } A straightforward conversion to Java code would look like: public static final void renderLocation(double latitude, double longitude) {} public static final void renderLocation(double latitude, double longitude) { map.render(latitude, longitude); } The above code is not valid because we can't have two methods with the same signature. To deal with this collision problem, Kotlin adds a \"-hash code\" to all methods which have an inline class parameter in their Kotlin counterpart. This technique is called mangling. Although this trick solves the collision issue, it creates another problem. We can't refer to any of our Kotlin functions which accepts an inline class parameter from our Java code. Why? Because, in Java, \"-\" is considered an illegal symbol. Therefore, it is impossible to call methods which has a \"-\" in their names. This is where Kotlin-Java interoperability breaks for us. Don't let this be a blocker though Casting aside the interoperability problem, Kotlin's inline classes are quite handy in a variety of cases. As we saw in our renderLocation function, using inline classes makes our program bug free by enforcing compile-time type-safety. We can't wrongly pass a Latitude value as Longitude to our function here. The compiler won't allow this misplacement. Jake Wharton pointed out another extensive use case for inline classes in one of his blog post – type-safe database IDs. Similar to our example here, database IDs are easy to misplace due to being of the same type. We can slip a payment ID as a customer ID and not notice until we get an incorrect result during runtime. Inline classes prevent these errors during compilation. Comparing with type aliases Type aliases don't introduce a new type. They mask an existing type to a different name. Inline classes, however, introduce new types which are available for us to harness while writing our programs. That doesn't mean type aliases are useless; they are useful for a different reason as we discussed in an earlier article. A few caveats to keep in mind Owing to the nature of their design, inline classes, right now: cannot have init blocks in them can neither inherit from another class nor can be open for extension cannot have any property with a backing field They can, however, have simple computed properties like this: inline class Longitude(val value: Double) { val formattedValue: String get() = \"$value°\" } Enforcing contracts with interfaces Inline classes can implement interfaces. This feature gives us the ability to enforce some contracts for our wrappers. Take out Latitude and Longitude wrappers as an example. We can define a contract for all geolocation values to have a formatting method, like this: interface GeoUnit { val formattedValue: String } Modifying our inline classes to implement this interface will ensure all implement classes have at least a formattedValue property which returns a String value. Here, we can make use of this property to pretty print our location value: inline class Latitude(val value: Double) : GeoUnit { override val formattedValue: String get() = \"$value°\" } We can now have consistent functionalities across wrappers of similar type. Refactoring already? Inline classes can be tempting to use. However, if you have an existing codebase, it's better to take a step back and think whether using inline classes would be suitable or not. Firstly, as of Kotlin 1.3.6, inline classes are still at an experimental stage. Refactoring a large project with experimental API can be detrimental. Also, if your codebase is mostly in legacy Java code, using inline classes means losing access to a bunch of methods from your Java classes. Before plunging into a full refactor mode, weigh in pros and cons and then make a decision. Here's a sketch note on the topic",
  "image": "https://okkotlin.com/images/inline-classes-featured.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003ePreviously, we discussed how \u003ca href=\"https://okkotlin.com/typealias/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eKotlin\u0026#39;s type aliases\u003c/a\u003e could make our code more readable. However, if you remember, since type aliases don\u0026#39;t introduce new types, they don\u0026#39;t provide any type-safety.\u003c/p\u003e\n\u003cp\u003eThis week we will be exploring Kotlin\u0026#39;s experimental inline classes which have benefits that type aliases provide but go further than that.\u003c/p\u003e\n\u003ch2 id=\"a-little-about-inline-classes\"\u003eA little about inline classes\u003c/h2\u003e\n\u003cp\u003eKotlin introduced \u003ca href=\"https://kotlinlang.org/docs/reference/inline-classes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003einline classes\u003c/a\u003e in their 1.3 release, advertised as light-weight wrapper classes. What separates inline classes from traditional wrappers is that inline classes don\u0026#39;t add any overhead due to no additional heap allocations.\u003c/p\u003e\n\u003cp\u003eNow that\u0026#39;s a mouthful. Let\u0026#39;s see what that means. Consider this function:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSince both latitude and longitude are \u003ccode\u003eDouble\u003c/code\u003e values, it\u0026#39;s easy to pass them in the wrong order making our program render an incorrect map.\u003c/p\u003e\n\u003cp\u003eWe can prevent this error by introducing two wrapper classes called \u003ccode\u003eLatitude\u003c/code\u003e and \u003ccode\u003eLongitude\u003c/code\u003e like this, thereby, making our function type-safe:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLatitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLongitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\n    \n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Latitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAlthough we made our function type-safe, we added a little overhead here. Every time we pass new values to our \u003ccode\u003erenderLocation\u003c/code\u003e function here, we need to initialise two new objects. This approach, as you might have guessed, results in additional expensive heap allocations.\u003c/p\u003e\n\u003cp\u003eThe previous version of our function didn\u0026#39;t have this problem because primitive values are optimised by the compiler.\u003c/p\u003e\n\u003cp\u003eAll hope\u0026#39;s not lost, yet:\u003c/p\u003e\n\u003cp\u003eWe can convert our plain old wrapper classes into inline classes to prevent any extra initialisation.\u003c/p\u003e\n\u003cp\u003eHow?\u003c/p\u003e\n\u003cp\u003eWell, the Kotlin compiler treats inline classes as a drop-in replacement for their underlying value. Therefore, if we do this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLatitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLongitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\n    \n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Latitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhen we run our program, Kotlin will try to replace every usage of \u003ccode\u003eLatitude\u003c/code\u003e or \u003ccode\u003eLongitude\u003c/code\u003e with a \u003ccode\u003eDouble\u003c/code\u003e value. \u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/cc285/inline-classes-type-replacement.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Replacing Latitudes with Doubles\" title=\"Replacing Latitudes with Doubles\" src=\"https://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/dbb61/inline-classes-type-replacement.png\" srcset=\"https://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/19bd1/inline-classes-type-replacement.png 163w,\nhttps://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/d3bcb/inline-classes-type-replacement.png 325w,\nhttps://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/dbb61/inline-classes-type-replacement.png 650w,\nhttps://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/6b691/inline-classes-type-replacement.png 975w,\nhttps://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/91670/inline-classes-type-replacement.png 1300w,\nhttps://okkotlin.com/static/5d870d9e23c4e7528c02769906ec3dfa/cc285/inline-classes-type-replacement.png 1708w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eIn cases where the type has to be retained, like for a type check using the \u003ccode\u003eas\u003c/code\u003e keyword, Kotlin will box the \u003ccode\u003eDouble\u003c/code\u003e value into the appropriate wrapper class.\u003c/p\u003e\n\u003cp\u003eKeep in mind that type erasure happens only during runtime or when your Kotlin code gets compiled to byte code. In our source code, we get full type support that we don\u0026#39;t get while using a type alias. \u003c/p\u003e\n\u003cp\u003eA decompiled Java version of our \u003ccode\u003erenderLocation\u003c/code\u003e will be this:\u003c/p\u003e\n\u003cdiv data-language=\"java\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e renderLocation_vKZqJUM\u003cspan\u003e/* $FF was: renderLocation-vKZqJUM*/\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edouble\u003c/span\u003e latitude\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edouble\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003erender\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003evKZqJUM\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNotice how the function parameters are plain old primitive \u003ccode\u003edouble\u003c/code\u003e values.\u003c/p\u003e\n\u003ch2 id=\"what-happened-to-our-function-name\"\u003eWhat happened to our function name?\u003c/h2\u003e\n\u003cp\u003eWe named our function as \u003ccode\u003erenderLocation\u003c/code\u003e, but our Java code shows a weird name \u003ccode\u003erenderLocation-vKZqJUM\u003c/code\u003e, what\u0026#39;s the deal here?\u003c/p\u003e\n\u003cp\u003eIt turns out, inline classes only work when we are writing Kotlin code. The hot-swapping of an inline class to its underlying type doesn\u0026#39;t happen in Java.\u003c/p\u003e\n\u003cp\u003eAs a result, if we have multiple functions like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n    \n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Latitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eA straightforward conversion to Java code would look like:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e static \u003cspan\u003efinal\u003c/span\u003e void \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003edouble latitude\u003cspan\u003e,\u003c/span\u003e double longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n    \n\u003cspan\u003epublic\u003c/span\u003e static \u003cspan\u003efinal\u003c/span\u003e void \u003cspan\u003erenderLocation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003edouble latitude\u003cspan\u003e,\u003c/span\u003e double longitude\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    map\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erender\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe above code is not valid because we can\u0026#39;t have two methods with the same signature.\u003c/p\u003e\n\u003cp\u003eTo deal with this collision problem, Kotlin adds a \u0026#34;-hash code\u0026#34; to all methods which have an inline class parameter in their Kotlin counterpart. This technique is called \u003cstrong\u003emangling\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAlthough this trick solves the collision issue, it creates another problem. We can\u0026#39;t refer to any of our Kotlin functions which accepts an inline class parameter from our Java code.\u003c/p\u003e\n\u003cp\u003eWhy?\u003c/p\u003e\n\u003cp\u003eBecause, in Java, \u0026#34;-\u0026#34; is considered an illegal symbol. Therefore, it is impossible to call methods which has a \u0026#34;-\u0026#34; in their names.\u003c/p\u003e\n\u003cp\u003eThis is where Kotlin-Java interoperability breaks for us.\u003c/p\u003e\n\u003ch2 id=\"dont-let-this-be-a-blocker-though\"\u003eDon\u0026#39;t let this be a blocker though\u003c/h2\u003e\n\u003cp\u003eCasting aside the interoperability problem, Kotlin\u0026#39;s inline classes are quite handy in a variety of cases.\u003c/p\u003e\n\u003cp\u003eAs we saw in our \u003ccode\u003erenderLocation\u003c/code\u003e function, using inline classes makes our program bug free by enforcing compile-time type-safety. We can\u0026#39;t wrongly pass a \u003ccode\u003eLatitude\u003c/code\u003e value as \u003ccode\u003eLongitude\u003c/code\u003e  to our function here. The compiler won\u0026#39;t allow this misplacement.\u003c/p\u003e\n\u003cp\u003eJake Wharton pointed out another extensive use case for inline classes in one of his blog post – \u003ca href=\"https://jakewharton.com/inline-classes-make-great-database-ids/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003etype-safe database IDs\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSimilar to our example here, database IDs are easy to misplace due to being of the same type. We can slip a payment ID as a customer ID and not notice until we get an incorrect result during runtime. Inline classes prevent these errors during compilation.\u003c/p\u003e\n\u003ch2 id=\"comparing-with-type-aliases\"\u003eComparing with type aliases\u003c/h2\u003e\n\u003cp\u003eType aliases don\u0026#39;t introduce a new type. They mask an existing type to a different name.\u003c/p\u003e\n\u003cp\u003eInline classes, however, introduce new types which are available for us to harness while writing our programs.\u003c/p\u003e\n\u003cp\u003eThat doesn\u0026#39;t mean type aliases are useless; they are useful for a different reason as we discussed in an \u003ca href=\"https://okkotlin.com/typealias/#common-places-where-we-can-type-alias\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eearlier article\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"a-few-caveats-to-keep-in-mind\"\u003eA few caveats to keep in mind\u003c/h2\u003e\n\u003cp\u003eOwing to the nature of their design, inline classes, right now:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecannot have \u003ccode\u003einit\u003c/code\u003e blocks in them\u003c/li\u003e\n\u003cli\u003ecan neither inherit from another class nor can be open for extension\u003c/li\u003e\n\u003cli\u003ecannot have any property with a backing field\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThey can, however, have simple computed properties like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLongitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e formattedValue\u003cspan\u003e:\u003c/span\u003e String\n        \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$value\u003c/span\u003e°\u0026#34;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"enforcing-contracts-with-interfaces\"\u003eEnforcing contracts with interfaces\u003c/h2\u003e\n\u003cp\u003eInline classes can implement interfaces. This feature gives us the ability to enforce some contracts for our wrappers.\u003c/p\u003e\n\u003cp\u003eTake out \u003ccode\u003eLatitude\u003c/code\u003e and \u003ccode\u003eLongitude\u003c/code\u003e wrappers as an example. We can define a contract for all geolocation values to have a formatting method, like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003einterface\u003c/span\u003e GeoUnit \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e formattedValue\u003cspan\u003e:\u003c/span\u003e String\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eModifying our inline classes to implement this interface will ensure all implement classes have at least a \u003ccode\u003eformattedValue\u003c/code\u003e property which returns a \u003ccode\u003eString\u003c/code\u003e value. Here, we can make use of this property to pretty print our location value:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003einline\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLatitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e value\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e GeoUnit \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e formattedValue\u003cspan\u003e:\u003c/span\u003e String\n        \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$value\u003c/span\u003e°\u0026#34;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe can now have consistent functionalities across wrappers of similar type.\u003c/p\u003e\n\u003ch2 id=\"refactoring-already\"\u003eRefactoring already?\u003c/h2\u003e\n\u003cp\u003eInline classes can be tempting to use. However, if you have an existing codebase, it\u0026#39;s better to take a step back and think whether using inline classes would be suitable or not.\u003c/p\u003e\n\u003cp\u003eFirstly, as of Kotlin 1.3.6, inline classes are still at an experimental stage. Refactoring a large project with experimental API can be detrimental.\u003c/p\u003e\n\u003cp\u003eAlso, if your codebase is mostly in legacy Java code, using inline classes means losing access to a bunch of methods from your Java classes.\u003c/p\u003e\n\u003cp\u003eBefore plunging into a full refactor mode, weigh in pros and cons and then make a decision.\u003c/p\u003e\n\u003ch2 id=\"heres-a-sketch-note-on-the-topic\"\u003eHere\u0026#39;s a sketch note on the topic\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/d40c8/inline-classes-sketch-note.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Inline classes sketch note\" title=\"Inline classes sketch note\" src=\"https://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/dbb61/inline-classes-sketch-note.png\" srcset=\"https://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/19bd1/inline-classes-sketch-note.png 163w,\nhttps://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/d3bcb/inline-classes-sketch-note.png 325w,\nhttps://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/dbb61/inline-classes-sketch-note.png 650w,\nhttps://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/6b691/inline-classes-sketch-note.png 975w,\nhttps://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/91670/inline-classes-sketch-note.png 1300w,\nhttps://okkotlin.com/static/156fb58f4932f6a01e5f673ce8dcbbea/d40c8/inline-classes-sketch-note.png 2000w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
