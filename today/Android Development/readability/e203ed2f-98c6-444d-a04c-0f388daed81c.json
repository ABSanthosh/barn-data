{
  "id": "e203ed2f-98c6-444d-a04c-0f388daed81c",
  "title": "Kotlin \"Server-less\" Functions",
  "link": "https://chrynan.codes/kotlin-serverless-functions/",
  "description": "A concept about single focus server functions written in Kotlin.",
  "author": "Christopher Keenan",
  "published": "Tue, 12 Nov 2019 20:11:59 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "concept",
    "idea",
    "kotlin",
    "serverless",
    "lambda",
    "functions",
    "function",
    "kotlin-server",
    "server-side",
    "development",
    "chrynan codes",
    "programming",
    "kotlin-multiplatform",
    "kotlin multiplatform",
    "kotlin multi-platform",
    "http",
    "server"
  ],
  "byline": "Christopher Keenan",
  "length": 5381,
  "excerpt": "A concept about single focus server functions written in Kotlin.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "A concept about single focus server functions written in Kotlin. Nov 12, 2019 â€¢ 3 min read Recently I found the need to create a Server-less Function for a project and was disappointed in both the lack of Kotlin options and the tightly-coupled, framework-specific code necessary to implement one. This lead me to ponder about how a Server-less Function could be implemented in Kotlin. These musings are what I discuss in this article. Note, this is just a rough idea and not a fully worked out solution.TL;DRThis article posits a Kotlin Server-less Function library using annotation processing as a means to automatically coordinate the functions appropriately.What is a \"Server-less\" Function?This may not be the appropriate terminology, but essentially, a Server-less Function is a hosted function in the cloud that performs a single focus action. These functions can be triggered by an HTTP endpoint, another Server-less Function, or some other service.Why is \"Server-less\" in quotes?ðŸ˜‚ These functions do actually run in a Server. But all the noise about setting up and configuring a Server is abstracted out. This lets the developer just focus on the implementation logic for the action the function performs.Achieving this in KotlinThere are a few popular Kotlin server-side frameworks, including:KtorFuelhttp4kHowever, these are full Kotlin server solutions not merely a Server-less Function framework/library. The closest one resembling a Server-less Function framework is http4k. From their introduction on their website they state:http4k is a lightweight but fully-featured HTTP toolkit written in pure Kotlin that enables the serving and consuming of HTTP services in a functional and consistent way. http4k applications are just Kotlin functions which can be mounted into a running backend.The library seems well put together. I have used it before in some personal projects and it is a pretty solid option for a Kotlin backend. It also almost provides exactly what I am looking for with respect to functions:fun main() { val app: HttpHandler = { request: Request -\u003e Response(OK).body(request.body) } val server = app.asServer(SunHttp(8000)).start() } The HttpHandler is essentially a \"Server-less\" Function. It's just a Kotlin function that takes in an HTTP Request object and returns an HTTP Response object. Unfortunately, however, you will still need to explicitly start the Server and state which Server implementation you are using (this is done in the main() function above). On a larger application with numerous functions, this could become a bit more cumbersome. Also, the library works only on the JVM, so it's not Kotlin Multi-platform which would nice.My \"Server-less\" Function library visionKotlin Multi-platformFramework and platform agnosticSimple, yet flexible, APIBoilerplate and setup code handled for youMultiple function supportThe way I envisioned this was to have an annotation, say @ServerFunction, that would be provided on a Kotlin function simply like:@ServerFunction fun performAction(request: HttpRequest): HttpResponse { ... } The parameter provided to the function would be the HttpRequest object and the function would be expected to return an HttpResponse. It may be perferrable, for testability reasons for one, to annotate a class rather than a top-level function. So, perhaps there would be an interface that the annotated class must implement:@ServerFunction class MyServerlessFunction : ServerlessFunction { override fun invoke(request: HttpRequest): HttpResponse { ... } } The annotation processor's responsibility would be to gather all the functions and set them up along with the actual server (or server abstraction). So this means you will no longer have an entry point function, such as main, to coordinate the functions and launch the server. The code generated by the annotation processor could even use the http4k library underneath and just handle the coordination and setup of the server. It's a simple idea, but if done correctly, the library could be both framework and platform agnostic (giving it the most flexibility - imagine being able to choose between KotlinJs/NodeJs and KotlinJVM and use the same code), and simple enough to hack something together real quick. This library would require:A Kotlin Multi-platform annotation processor (like this one) or a Gradle or Kotlin Compiler pluginA Kotlin Multi-platform representation of an HTTP Request and ResponseOne module for the Annotations and InterfacesOne module for the Annotation ProcessorSome form of server abstractionCoordination between the different functionsEndpoint managementEndA Kotlin Server-less Function library with a simple API would be beneficial for developers to quickly launch a function without the overhead of learning an entire framework. They could use any existing Kotlin libraries, tools, and build systems they need. And will have ultimate flexibility in launching the functions to whatever server they desire. While not fully worked through, this concept may provide the groundwork to building such a library.",
  "image": "https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n        \n\n        \n\n            \u003cp\u003eA concept about single focus server functions written in Kotlin.\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \u003cdiv\u003e\n                \n                \u003cp\u003e\u003ctime datetime=\"2019-11-12\"\u003eNov 12, 2019\u003c/time\u003e\n                        \u003cspan\u003e\u003cspan\u003eâ€¢\u003c/span\u003e 3 min read\u003c/span\u003e\n                \u003c/p\u003e\n            \u003c/div\u003e\n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=300 300w,\n                            https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=600 600w,\n                            https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=1000 1000w,\n                            https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://images.unsplash.com/photo-1516414447565-b14be0adf13e?ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;fm=jpg\u0026amp;crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;ixid=eyJhcHBfaWQiOjExNzczfQ\u0026amp;w=2000\" alt=\"Kotlin \u0026#34;Server-less\u0026#34; Functions\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/div\u003e\u003csection\u003e\n        \u003cp\u003eRecently I found the need to create a Server-less Function for a project and was disappointed in both the lack of Kotlin options and the tightly-coupled, framework-specific code necessary to implement one. This lead me to ponder about how a Server-less Function could be implemented in Kotlin. These musings are what I discuss in this article. Note, this is just a rough idea and not a fully worked out solution.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eThis article posits a Kotlin Server-less Function library using annotation processing as a means to automatically coordinate the functions appropriately.\u003c/p\u003e\u003ch3 id=\"what-is-a-server-less-function\"\u003eWhat is a \u0026#34;Server-less\u0026#34; Function?\u003c/h3\u003e\u003cp\u003eThis may not be the appropriate terminology, but essentially, a Server-less Function is a hosted function in the cloud that performs a single focus action. These functions can be triggered by an HTTP endpoint, another Server-less Function, or some other service.\u003c/p\u003e\u003ch3 id=\"why-is-server-less-in-quotes\"\u003eWhy is \u0026#34;Server-less\u0026#34; in quotes?\u003c/h3\u003e\u003cp\u003eðŸ˜‚ These functions do actually run in a Server. But all the noise about setting up and configuring a Server is abstracted out. This lets the developer just focus on the implementation logic for the action the function performs.\u003c/p\u003e\u003ch3 id=\"achieving-this-in-kotlin\"\u003eAchieving this in Kotlin\u003c/h3\u003e\u003cp\u003eThere are a few popular Kotlin server-side frameworks, including:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://ktor.io/?ref=chrynan.codes\"\u003eKtor\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/kittinunf/Fuel?ref=chrynan.codes\"\u003eFuel\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.http4k.org/?ref=chrynan.codes\"\u003ehttp4k\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eHowever, these are full Kotlin server solutions not merely a Server-less Function framework/library. The closest one resembling a Server-less Function framework is \u003cstrong\u003ehttp4k\u003c/strong\u003e. From their \u003ca href=\"https://www.http4k.org/?ref=chrynan.codes\"\u003eintroduction\u003c/a\u003e on their website they state:\u003c/p\u003e\u003cblockquote\u003e\u003ca href=\"https://http4k.org/?ref=chrynan.codes\"\u003ehttp4k\u003c/a\u003e is a lightweight but fully-featured HTTP toolkit written in pure \u003ca href=\"https://kotlinlang.org/?ref=chrynan.codes\"\u003eKotlin\u003c/a\u003e that enables the serving and consuming of HTTP services in a functional and consistent way. \u003ca href=\"https://http4k.org/?ref=chrynan.codes\"\u003ehttp4k\u003c/a\u003e applications are \u003cem\u003ejust\u003c/em\u003e Kotlin functions which can be mounted into a running backend.\u003c/blockquote\u003e\u003cp\u003eThe library seems well put together. I have used it before in some personal projects and it is a pretty solid option for a Kotlin backend. It also almost provides exactly what I am looking for with respect to functions:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun main() {\n    val app: HttpHandler = { request: Request -\u0026gt; Response(OK).body(request.body) }\n    val server = app.asServer(SunHttp(8000)).start()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eHttpHandler\u003c/code\u003e is essentially a \u0026#34;Server-less\u0026#34; Function. It\u0026#39;s just a Kotlin function that takes in an HTTP \u003ccode\u003eRequest\u003c/code\u003e object and returns an HTTP \u003ccode\u003eResponse\u003c/code\u003e object. Unfortunately, however, you will still need to explicitly start the Server and state which Server implementation you are using (this is done in the \u003ccode\u003emain()\u003c/code\u003e function above). On a larger application with numerous functions, this could become a bit more cumbersome. Also, the library works only on the JVM, so it\u0026#39;s not Kotlin Multi-platform which would nice.\u003c/p\u003e\u003ch3 id=\"my-server-less-function-library-vision\"\u003eMy \u0026#34;Server-less\u0026#34; Function library vision\u003c/h3\u003e\u003cul\u003e\u003cli\u003eKotlin Multi-platform\u003c/li\u003e\u003cli\u003eFramework and platform agnostic\u003c/li\u003e\u003cli\u003eSimple, yet flexible, API\u003c/li\u003e\u003cli\u003eBoilerplate and setup code handled for you\u003c/li\u003e\u003cli\u003eMultiple function support\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe way I envisioned this was to have an annotation, say \u003ccode\u003e@ServerFunction\u003c/code\u003e, that would be provided on a Kotlin function simply like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@ServerFunction\nfun performAction(request: HttpRequest): HttpResponse { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe parameter provided to the function would be the \u003ccode\u003eHttpRequest\u003c/code\u003e object and the function would be expected to return an \u003ccode\u003eHttpResponse\u003c/code\u003e. It may be perferrable, for testability reasons for one, to annotate a class rather than a top-level function. So, perhaps there would be an interface that the annotated class must implement:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@ServerFunction\nclass MyServerlessFunction : ServerlessFunction {\n\n    override fun invoke(request: HttpRequest): HttpResponse { ... }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe annotation processor\u0026#39;s responsibility would be to gather all the functions and set them up along with the actual server (or server abstraction). So this means you will no longer have an entry point function, such as \u003ccode\u003emain\u003c/code\u003e, to coordinate the functions and launch the server. \u003c/p\u003e\u003cp\u003eThe code generated by the annotation processor could even use the \u003ccode\u003ehttp4k\u003c/code\u003e library underneath and just handle the coordination and setup of the server. It\u0026#39;s a simple idea, but if done correctly, the library could be both framework and platform agnostic (giving it the most flexibility - imagine being able to choose between KotlinJs/NodeJs and KotlinJVM and use the same code), and simple enough to hack something together real quick. This library would require:\u003c/p\u003e\u003cul\u003e\u003cli\u003eA Kotlin Multi-platform annotation processor (like \u003ca href=\"https://github.com/Foso/MpApt?ref=chrynan.codes\"\u003ethis one\u003c/a\u003e) or a Gradle or Kotlin Compiler plugin\u003c/li\u003e\u003cli\u003eA Kotlin Multi-platform representation of an HTTP Request and Response\u003c/li\u003e\u003cli\u003eOne module for the Annotations and Interfaces\u003c/li\u003e\u003cli\u003eOne module for the Annotation Processor\u003c/li\u003e\u003cli\u003eSome form of server abstraction\u003c/li\u003e\u003cli\u003eCoordination between the different functions\u003c/li\u003e\u003cli\u003eEndpoint management\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"end\"\u003eEnd\u003c/h3\u003e\u003cp\u003eA Kotlin Server-less Function library with a simple API would be beneficial for developers to quickly launch a function without the overhead of learning an entire framework. They could use any existing Kotlin libraries, tools, and build systems they need. And will have ultimate flexibility in launching the functions to whatever server they desire. While not fully worked through, this concept may provide the groundwork to building such a library.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2019-11-12T20:11:59Z",
  "modifiedTime": "2019-11-12T20:19:33Z"
}
