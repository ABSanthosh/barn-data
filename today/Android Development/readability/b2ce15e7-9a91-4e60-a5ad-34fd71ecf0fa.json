{
  "id": "b2ce15e7-9a91-4e60-a5ad-34fd71ecf0fa",
  "title": "[Experiment] Espresso Closed-Box Testing",
  "link": "https://handstandsam.com/2022/12/14/experiment-espresso-closed-box-testing/",
  "description": "I wanted to write some Android Espresso tests for a large application, but iterate on the tests as fast as possible. Typically someone would run :app:connectedDebugAndroidTest to run their instrumentation tests, but under the hood that is just compiling and installing both the app and androidTest apks, and using the instrumentation runner over adb. When […]",
  "author": "Sam Edwards",
  "published": "Wed, 14 Dec 2022 15:24:25 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Android",
    "Kotlin",
    "Testing"
  ],
  "byline": "Sam Edwards Published December 14, 2022",
  "length": 4453,
  "excerpt": "I wanted to write some Android Espresso tests for a large application, but iterate on the tests as fast as possible.",
  "siteName": "",
  "favicon": "",
  "text": "I wanted to write some Android Espresso tests for a large application, but iterate on the tests as fast as possible. Typically someone would run :app:connectedDebugAndroidTest to run their instrumentation tests, but under the hood that is just compiling and installing both the app and androidTest apks, and using the instrumentation runner over adb. When executing Android Instrumentation Tests, you just need an app.apk and an androidTest.apk, and then to invoke the test instrumentation runner via adb. Because of the configuration, the androidTest APK gets everything that is on the app‘s classpath so it can reference resources, classes and activities in the app. I wanted to see if I could build an androidTest.apk without having any ties to the original :app. I tried a few methods, but found that creating a new blank application with the exact same package name, and then writing tests under the androidTest folder allowed me to compile quickly. Problems: No access to the classpath \u0026 resource identifiers Classpaths can’t clash (must use same versions of dependencies as the original app). Workarounds: You could import just a few modules that have resource identifiers or code that you want to reference in your tests. (easier and typesafe, but a little slower) OR you could just access everything by fully qualified package names, and look up resource identifiers by ID. (no compile time safety, but faster) I tried workaround #2, because I wanted to have this be the fastest iteration time possible, and I finally got it to work! Here’s my receipt for how I made it happen. How I Got it Working 1) Install my app (com.example.app) as usual :app:installDebug. This will be the app I want to test. 2) Create the :cloneapp project In this :cloneapp project, keep an empty main source folder, but add an androidTest directory. 3) In :cloneapp set the package name to the the exact same package name com.example.app. android { defaultConfig { applicationId \"com.example.app\" } } 4) In :cloneapp update the src/androidTest/AndroidManfest.xml \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003cinstrumentation android:name=\"androidx.test.runner.AndroidJUnitRunner\" android:targetPackage=\"com.example.app\" android:targetProcesses=\"com.example.app\" /\u003e \u003c/manifest\u003e 5) Add in a test! package com.example.app.tests import android.app.Activity import android.content.Context import android.os.SystemClock import android.util.Log import androidx.test.core.app.ApplicationProvider import androidx.test.espresso.Espresso import androidx.test.espresso.ViewInteraction import androidx.test.espresso.action.ViewActions import androidx.test.espresso.assertion.ViewAssertions import androidx.test.espresso.matcher.ViewMatchers import androidx.compose.ui.test.junit4.createComposeRule import org.junit.Before import org.junit.Rule import org.junit.Test fun findResourceIntByIdStr(id: String): Int { ApplicationProvider.getApplicationContext().resources.getIdentifier(id, \"id\", applicationContext.packageName) Espresso.onView(ViewMatchers.withId(findResourceIntByIdStr(idStr))) } fun findViewByIdStr(idStr: String): ViewInteraction { Log.d(TAG, \"Find View By ID Str $idStr\") return } class ExampleTest { /** Use this to interact with Compose surfaces */ @get:Rule val composeTestRule = createComposeRule() @Test fun testLoginFlow() { } } 6) Install the test clone APK Run :cloneapp:installDebugAndroidTest to install the test apk. 7) Run the tests using adb! adb shell am instrument -w -r com.example.app.test/androidx.test.runner.AndroidJUnitRunner Note: You can be more explicit with command line instrumentation arguments about what test or test class you want to execute. 8) Test Development Iteration Loop I ended up clearing the app data between runs with adb shell pm clear com.example.app as well so I had consistent behavior and didn’t have to install the package. Conclusion As mentioned, this was an experiment. It made the iteration time blazing fast, but lacked compile time safety. Anyways, it’s possible, and hopefully you learned something. If you end up using this technique, I’m curious to hear more. Feel free to message me on Kotlin Lang Slack or Mastodon.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1918\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eI wanted to write some Android Espresso tests for a large application, but iterate on the tests as fast as possible. \u003c/p\u003e\n\n\n\n\u003cp\u003eTypically someone would run \u003ccode\u003e:app:connectedDebugAndroidTest\u003c/code\u003e to run their instrumentation tests, but under the hood that is just compiling and installing both the app and androidTest apks, and using the instrumentation runner over \u003ccode\u003eadb\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen executing Android Instrumentation Tests, you just need an \u003ccode\u003eapp.apk\u003c/code\u003e and an \u003ccode\u003eandroidTest.apk\u003c/code\u003e, and then to \u003ca href=\"https://developer.android.com/studio/test/command-line\"\u003einvoke the test instrumentation runner via \u003ccode\u003eadb\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBecause of the configuration, the \u003ccode\u003eandroidTest\u003c/code\u003e APK gets everything that is on the \u003ccode\u003eapp\u003c/code\u003e‘s classpath so it can reference resources, classes and activities in the \u003ccode\u003eapp\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eI wanted to see if I could build an \u003ccode\u003eandroidTest.apk\u003c/code\u003e without having any ties to the original \u003ccode\u003e:app\u003c/code\u003e.  I tried a few methods, but found that creating a new blank application with the exact same package name, and then writing tests under the \u003ccode\u003eandroidTest\u003c/code\u003e folder allowed me to compile quickly.\u003c/p\u003e\n\n\n\n\u003ch3\u003eProblems:\u003c/h3\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eNo access to the classpath \u0026amp; resource identifiers\u003c/li\u003e\n\n\n\n\u003cli\u003eClasspaths can’t clash (must use same versions of dependencies as the original app).\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003ch3\u003eWorkarounds:\u003c/h3\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eYou could import just a few modules that have resource identifiers or code that you want to reference in your tests. (easier and typesafe, but a little slower)\u003c/li\u003e\n\n\n\n\u003cli\u003eOR you could just access everything by fully qualified package names, and look up resource identifiers by ID. (no compile time safety, but faster)\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eI tried workaround #2, because I wanted to have this be the fastest iteration time possible, and I finally got it to work!  Here’s my receipt for how I made it happen.\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow I Got it Working\u003c/h2\u003e\n\n\n\n\u003ch4\u003e1) Install my app (com.example.app) as usual \u003ccode\u003e:app:installDebug\u003c/code\u003e.  \u003c/h4\u003e\n\n\n\n\u003cp\u003eThis will be the app I want to test.\u003c/p\u003e\n\n\n\n\u003ch4\u003e2) Create the \u003ccode\u003e:cloneapp\u003c/code\u003e project\u003c/h4\u003e\n\n\n\n\u003cp\u003eIn this \u003ccode\u003e:cloneapp\u003c/code\u003e project, keep an empty \u003ccode\u003emain\u003c/code\u003e source folder, but add an \u003ccode\u003eandroidTest\u003c/code\u003e directory.\u003c/p\u003e\n\n\n\n\u003ch4\u003e3) In \u003ccode\u003e:cloneapp\u003c/code\u003e set the package name to the the exact same package name \u003ccode\u003ecom.example.app\u003c/code\u003e.\u003c/h4\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eandroid {\n    defaultConfig {\n        applicationId \u0026#34;com.example.app\u0026#34;\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch4\u003e4) In \u003ccode\u003e:cloneapp\u003c/code\u003e update the \u003ccode\u003esrc/androidTest/AndroidManfest.xml\u003c/code\u003e\u003c/h4\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"xml\"\u003e\u0026lt;manifest xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\n      xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34;\u0026gt;\n    \u0026lt;instrumentation\n        android:name=\u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34;\n        android:targetPackage=\u0026#34;com.example.app\u0026#34;\n        android:targetProcesses=\u0026#34;com.example.app\u0026#34; /\u0026gt;\n\u0026lt;/manifest\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch4\u003e5) Add in a test!\u003c/h4\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epackage com.example.app.tests\n\nimport android.app.Activity\nimport android.content.Context\nimport android.os.SystemClock\nimport android.util.Log\nimport androidx.test.core.app.ApplicationProvider\nimport androidx.test.espresso.Espresso\nimport androidx.test.espresso.ViewInteraction\nimport androidx.test.espresso.action.ViewActions\nimport androidx.test.espresso.assertion.ViewAssertions\nimport androidx.test.espresso.matcher.ViewMatchers\nimport androidx.compose.ui.test.junit4.createComposeRule\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\n\nfun findResourceIntByIdStr(id: String): Int {\n    ApplicationProvider.getApplicationContext().resources.getIdentifier(id, \u0026#34;id\u0026#34;, applicationContext.packageName)\n    Espresso.onView(ViewMatchers.withId(findResourceIntByIdStr(idStr)))\n}\n\nfun findViewByIdStr(idStr: String): ViewInteraction {\n    Log.d(TAG, \u0026#34;Find View By ID Str $idStr\u0026#34;)\n    return \n}\n\nclass ExampleTest {\n\n    /** Use this to interact with Compose surfaces */\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun testLoginFlow() {\n        \n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003ch4\u003e6) Install the test clone APK\u003c/h4\u003e\n\n\n\n\u003cp\u003eRun \u003ccode\u003e:cloneapp:installDebugAndroidTest\u003c/code\u003e to install the test apk.\u003c/p\u003e\n\n\n\n\u003ch4\u003e7) Run the tests using adb!\u003c/h4\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u003ccode\u003eadb shell am instrument -w -r com.example.app.test/androidx.test.runner.AndroidJUnitRunner\u003c/code\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote: You can be more explicit with \u003ca href=\"https://developer.android.com/studio/test/command-line\"\u003ecommand line instrumentation arguments\u003c/a\u003e about what test or test class you want to execute.\u003c/p\u003e\n\n\n\n\u003ch4\u003e8) Test Development Iteration Loop\u003c/h4\u003e\n\n\n\n\u003cp\u003eI ended up clearing the app data between runs with \u003ccode\u003eadb shell pm clear com.example.app\u003c/code\u003e as well so I had consistent behavior and didn’t have to install the package.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs mentioned, this was an experiment.  It made the iteration time blazing fast, but lacked compile time safety.  Anyways, it’s possible, and hopefully you learned something.  If you end up using this technique, I’m curious to hear more.  Feel free to message me on \u003ca href=\"https://slack-chats.kotlinlang.org/\"\u003eKotlin Lang Slack\u003c/a\u003e or \u003ca href=\"https://mastodon.social/@handstandsam\" data-type=\"URL\" data-id=\"https://mastodon.social/@handstandsam\"\u003eMastodon\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
