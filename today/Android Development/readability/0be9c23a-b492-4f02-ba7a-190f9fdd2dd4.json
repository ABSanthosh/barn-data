{
  "id": "0be9c23a-b492-4f02-ba7a-190f9fdd2dd4",
  "title": "6 steps to make a “Slide to unlock” button in Jetpack Compose",
  "link": "https://proandroiddev.com/6-steps-to-make-a-slide-to-unlock-button-in-jetpack-compose-ee9398cecf5f?source=rss----c72404660798---4",
  "description": "",
  "author": "Anitaa Murthy",
  "published": "Wed, 09 Apr 2025 13:41:49 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "kotlin",
    "jetpack-compose",
    "animation-studio"
  ],
  "byline": "Anitaa Murthy",
  "length": 7269,
  "excerpt": "I recently had the opportunity to work on a custom “Slide to Book” button for one of my projects and since this was my first time implementing a swipe-to-action animation in Jetpack Compose, I…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "I recently had the opportunity to work on a custom “Slide to Book” button for one of my projects and since this was my first time implementing a swipe-to-action animation in Jetpack Compose, I thought I’d share the learnings and breakdown the implementation.This button allows the user to drag a slider thumb horizontally to confirm a booking. Once dragged past a threshold, the button triggers a ride booking action, plays a subtle animation, and displays a loading indicator.If you would like to skip this article and just want to see a gif of the end result and go straight for the final code, here’s the link.Let’s get’s started!Step 1: Create the ComposableWe start by defining the top-level composable for the button. This composable is responsible for the layout and structure of the entire slider: the outer button that holds the text and slider, and the inner slider thumb that the user can drag. Let’s name it SlideToBookButton.https://gist.github.com/anitaa1990/f0120934810287665e18d097f4557e5fThis composable includes:btnText: The label displayed on the outer track (e.g., “Book Ride ₹199”).btnTextStyle : The typography style for the btnText — allows font weight, size, etc.outerBtnBackgroundColor : The background color for the entire button track.sliderBtnBackgroundColor : The background color for the draggable slider/thumb element.sliderBtnIcon : The icon displayed inside the slider button.onBtnSwipe : The callback invoked when the user successfully completes the swipe.Step 2: Define the button UIWith our parameters in place, the next step is to define the visual structure of the SlideToBookButton. The layout has two primary components:The outer button— a full-width container that holds the background and the center aligned button text.The slider button.thumb — a smaller draggable button layered above the track that users can slide horizontally.https://gist.github.com/anitaa1990/b969b9273b8594b649f2070d3ba330c5Step 3: Add Drag gesture and slide animationNow that we’ve built the UI for our “Slide to Book” button, let’s start with the animation. We want users to drag the slider thumb from left to right, and once they’ve swiped far enough, we’ll consider it a successful “slide to book” action.To animate and track the thumb’s position during drag, we’ll need to:Figure out how wide the button is: We use something called Modifier.onSizeChanged to get the actual width of the outer button once it’s displayed. This tells us how far the slider thumb is allowed to move — from the left edge to just before the right edge.Track how far the thumb moves: We use remember { mutableStateOf(… ) } to store the current X-position of the slider thumb in pixels. This allows us to update the thumb’s position reactively as the user drags.Listen for drag gestures: We use Modifier.draggable with rememberDraggableState { delta -\u003e … } to listen for drag gestures in a specified direction (in our case, horizontally). The delta parameter gives us the amount the user’s finger moved since the last update — in pixels, not dp. This means that, every time the user drags their finger left or right, delta tells us how far they moved. We take that delta and add it to our current thumb position, so the thumb follows the finger. If they swipe right, the thumb moves right. If they try to go left again, it moves left — just like dragging a real slider. We also make sure the thumb doesn’t go past the edges. This gives us full control over the drag behavior — not just how far the user can swipe, but when the swipe is “complete”, and even what happens if we want to animate it back later.Finally, we move the thumb visually on the screen: We use Modifier.offset to move a composable by a certain distance on the X (horizontal) or Y (vertical) axis — like nudging it left, right, up, or down. As the user drags their finger, we’re tracking how far they’ve moved using sliderPositionPx (in pixels). We then pass that value to offset — after converting it to dp, since offset expects dp values. This is what makes the slider thumb visually shift across the button, matching the user’s drag. Without offset, even though we’re tracking the finger movement, the thumb would just sit still.Now let’s update our code:https://gist.github.com/anitaa1990/92e80882d23ed8c47ca52a29544de50cThis is what we’re achieved so far:Step 4: Add text alpha animationNow that we’ve wired up the drag gesture for the slider button, it’s time to move on to fading out the button text as the slider is dragged. As the user starts sliding: The button label (e.g., “Book Ride ₹199”) gradually fades out. When the slider reaches the end, the text should be completely invisible.To fade out the text label, we’ll need to:measure how far the slider button has been dragged. That gives us a number from 0.0 (not moved at all) to 1.0 (moved all the way to the end). This value is what we call dragProgress.Next, we define and calculate the textAlpha, which controls how transparent the text is. When dragProgress is 0.0 (user hasn’t moved), textAlpha is 1.0 → the text is fully visible. As the user drags and dragProgress increases (like 0.3, 0.5, 0.7…), we decrease the textAlpha to make the text less visible. When dragProgress reaches 1.0 (fully dragged), textAlpha becomes 0.0 → the text is fully invisible. We apply this textAlpha to our Text composable using Modifier.alpha() — so the text fades smoothly while dragging.https://gist.github.com/anitaa1990/b687344c083275c78ae9f022cc2c2341This is what we have so farStep 5: Add track scale \u0026 thumb alpha animationOnce the user slides the button almost to the end, we want two things to happen:The outer track (button background) should shrink and disappear.The slider button should fade out completely.This tells the user that the slide is complete, and the action (like booking the ride) is being processed.What we need to do:We use a boolean flag sliderComplete that tells us when slide progress has passed a threshold. When dragProgress reaches 80% or more, we set sliderComplete = true.We use animateFloatAsState() and Modifier.graphicsLayer() to smoothly animate the scale and alpha changes.https://gist.github.com/anitaa1990/bd3d257337317cb71fdfd8ca73188bfbAnd this is what we’ec achieved!Note: The order of modifiers matters here. We have to ensure that we add the .graphicsLayer above the .background here to ensure that the scaling takes place correctly. If we change the order, i.e. if we add the .background after we add the .graphicsayer, the background is already drawn at full size so the scaling doesn’t affect what’s already been rendered. But if you shrink before, everything is drawn inside the new size — and that’s what you want here!Step 6: Add the loading indicator animationNow that we have all the moving parts in place, we simply need to show a loading indicator when the animation is complete. For that, we need to:Define a boolean flag showLoading that tells us when we need to show this loading indicator.We need to update our LaunchedEffect(dragProgress) method to set showLoading = true when sliding is completed.We need to display a CircularProgressIndicator() when showLoading = true.And this is our full code:https://gist.github.com/anitaa1990/c2f17982d19d2b5835493596f7755860And that’s pretty much it!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*91h8Dqna9xpJcA0mAd4Ybg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"769f\"\u003eI recently had the opportunity to work on a custom “Slide to Book” button for one of my projects and since this was my first time implementing a swipe-to-action animation in Jetpack Compose, I thought I’d share the learnings and breakdown the implementation.\u003c/p\u003e\u003cp id=\"7dc4\"\u003eThis button allows the user to drag a slider thumb horizontally to confirm a booking. Once dragged past a threshold, the button triggers a ride booking action, plays a subtle animation, and displays a loading indicator.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"ef80\"\u003eIf you would like to skip this article and just want to see a gif of the end result and go straight for the final code, here’s the \u003ca href=\"https://gist.github.com/anitaa1990/c2f17982d19d2b5835493596f7755860\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elink\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"e800\"\u003eLet’s get’s started!\u003c/p\u003e\u003ch2 id=\"b4f5\"\u003eStep 1: Create the Composable\u003c/h2\u003e\u003cp id=\"c567\"\u003eWe start by defining the \u003cstrong\u003etop-level composable\u003c/strong\u003e for the button. This composable is responsible for the layout and structure of the entire slider: the \u003cstrong\u003eouter button\u003c/strong\u003e that holds the text and slider, and the \u003cstrong\u003einner slider thumb\u003c/strong\u003e that the user can drag. Let’s name it \u003ccode\u003e\u003cstrong\u003eSlideToBookButton\u003c/strong\u003e\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/f0120934810287665e18d097f4557e5f\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/f0120934810287665e18d097f4557e5f\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"8c20\"\u003eThis composable includes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b90c\"\u003e\u003ccode\u003e\u003cstrong\u003ebtnText\u003c/strong\u003e\u003c/code\u003e: The label displayed on the outer track (e.g., “Book Ride ₹199”).\u003c/li\u003e\u003cli id=\"1542\"\u003e\u003ccode\u003e\u003cstrong\u003ebtnTextStyle\u003c/strong\u003e\u003c/code\u003e : The typography style for the btnText — allows font weight, size, etc.\u003c/li\u003e\u003cli id=\"0bde\"\u003e\u003ccode\u003e\u003cstrong\u003eouterBtnBackgroundColor\u003c/strong\u003e\u003c/code\u003e : The background color for the entire button track.\u003c/li\u003e\u003cli id=\"bd59\"\u003e\u003ccode\u003e\u003cstrong\u003esliderBtnBackgroundColor\u003c/strong\u003e\u003c/code\u003e : The background color for the draggable slider/thumb element.\u003c/li\u003e\u003cli id=\"a93a\"\u003e\u003ccode\u003e\u003cstrong\u003esliderBtnIcon\u003c/strong\u003e\u003c/code\u003e : The icon displayed inside the slider button.\u003c/li\u003e\u003cli id=\"f0ab\"\u003e\u003ccode\u003e\u003cstrong\u003eonBtnSwipe\u003c/strong\u003e\u003c/code\u003e : The callback invoked when the user successfully completes the swipe.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"92e6\"\u003eStep 2: Define the button UI\u003c/h2\u003e\u003cp id=\"c9e1\"\u003eWith our parameters in place, the next step is to define the visual structure of the \u003ccode\u003e\u003cstrong\u003eSlideToBookButton\u003c/strong\u003e\u003c/code\u003e. The layout has two primary components:\u003c/p\u003e\u003col\u003e\u003cli id=\"1b2d\"\u003e\u003cstrong\u003eThe outer button\u003c/strong\u003e— a full-width container that holds the background and the center aligned button text.\u003c/li\u003e\u003cli id=\"47f7\"\u003e\u003cstrong\u003eThe slider button.thumb\u003c/strong\u003e — a smaller draggable button layered above the track that users can slide horizontally.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/b969b9273b8594b649f2070d3ba330c5\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/b969b9273b8594b649f2070d3ba330c5\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"e36a\"\u003eStep 3: Add Drag gesture and slide animation\u003c/h2\u003e\u003cp id=\"0283\"\u003eNow that we’ve built the UI for our “\u003cstrong\u003eSlide to Book”\u003c/strong\u003e button, let’s start with the animation. We want users to \u003cstrong\u003edrag the slider thumb from left to right\u003c/strong\u003e, and once they’ve swiped far enough, we’ll consider it a successful “slide to book” action.\u003c/p\u003e\u003cp id=\"44f9\"\u003eTo animate and track the thumb’s position during drag, we’ll need to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"94c4\"\u003e\u003cstrong\u003eFigure out how wide the button is:\u003c/strong\u003e We use something called \u003ccode\u003eModifier.onSizeChanged\u003c/code\u003e to get the \u003cstrong\u003eactual width\u003c/strong\u003e of the outer button once it’s displayed. This tells us how far the slider thumb is \u003cstrong\u003eallowed to move\u003c/strong\u003e — from the left edge to just before the right edge.\u003c/li\u003e\u003cli id=\"a353\"\u003e\u003cstrong\u003eTrack how far the thumb moves: \u003c/strong\u003eWe use \u003ccode\u003eremember { mutableStateOf(… ) }\u003c/code\u003e to store the \u003cstrong\u003ecurrent X-position\u003c/strong\u003e of the slider thumb in \u003cstrong\u003epixels\u003c/strong\u003e. This allows us to update the thumb’s position reactively as the user drags.\u003c/li\u003e\u003cli id=\"d84a\"\u003e\u003cstrong\u003eListen for drag gestures\u003c/strong\u003e: We use \u003ccode\u003eModifier.draggable\u003c/code\u003e with \u003ccode\u003erememberDraggableState { delta -\u0026gt; … }\u003c/code\u003e to listen for drag gestures in a specified direction (in our case, horizontally). The \u003ccode\u003edelta\u003c/code\u003e parameter gives us the \u003cstrong\u003eamount the user’s finger moved\u003c/strong\u003e since the last update — in \u003cstrong\u003epixels\u003c/strong\u003e, not dp. This means that, every time the user drags their finger left or right, delta tells us how far they moved. We take that \u003ccode\u003edelta\u003c/code\u003e and \u003cstrong\u003eadd it to our current thumb position\u003c/strong\u003e, so the thumb follows the finger. If they swipe right, the thumb moves right. If they try to go left again, it moves left — \u003cstrong\u003ejust like dragging a real slider\u003c/strong\u003e. We also make sure the thumb doesn’t go past the edges. This gives us \u003cstrong\u003efull control\u003c/strong\u003e over the drag behavior — not just how far the user can swipe, but when the swipe is “complete”, and even what happens if we want to animate it back later.\u003c/li\u003e\u003cli id=\"6d0b\"\u003eFinally, \u003cstrong\u003ewe move the thumb visually on the screen\u003c/strong\u003e: We use \u003cstrong\u003eModifier.offset \u003c/strong\u003eto \u003cstrong\u003emove a composable by a certain distance\u003c/strong\u003e on the X (horizontal) or Y (vertical) axis — like nudging it left, right, up, or down. As the user drags their finger, we’re tracking how far they’ve moved using sliderPositionPx (in pixels). We then pass that value to \u003ccode\u003eoffset\u003c/code\u003e — after converting it to \u003cstrong\u003edp\u003c/strong\u003e, since \u003ccode\u003eoffset\u003c/code\u003e expects dp values. This is what makes the slider thumb \u003cstrong\u003evisually shift\u003c/strong\u003e across the button, matching the user’s drag. Without offset, even though we’re tracking the finger movement, the thumb would just sit still.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ead7\"\u003eNow let’s update our code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/92e80882d23ed8c47ca52a29544de50c\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/92e80882d23ed8c47ca52a29544de50c\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"0ac9\"\u003eThis is what we’re achieved so far:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3d11\"\u003eStep 4: Add text alpha animation\u003c/h2\u003e\u003cp id=\"9663\"\u003eNow that we’ve wired up the drag gesture for the \u003cstrong\u003eslider button\u003c/strong\u003e, it’s time to move on to \u003cstrong\u003efading out the button text\u003c/strong\u003e as the slider is dragged. As the user starts sliding: The button label (e.g., “Book Ride ₹199”)\u003cstrong\u003e \u003c/strong\u003egradually fades out. When the slider reaches the end, the text should be completely invisible.\u003c/p\u003e\u003cp id=\"f95d\"\u003eTo fade out the text label, we’ll need to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0bed\"\u003e\u003cstrong\u003emeasure how far\u003c/strong\u003e the slider button has been dragged. That gives us a number from 0.0 (not moved at all) to 1.0 (moved all the way to the end). This value is what we call \u003ccode\u003edragProgress\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"2b3c\"\u003eNext, we define and calculate the \u003ccode\u003etextAlpha\u003c/code\u003e, which controls how \u003cstrong\u003etransparent\u003c/strong\u003e the text is. When dragProgress is 0.0 (user hasn’t moved), textAlpha is 1.0 → the text is \u003cstrong\u003efully visible\u003c/strong\u003e. As the user drags and dragProgress increases (like 0.3, 0.5, 0.7…), we decrease the textAlpha to make the text \u003cstrong\u003eless visible\u003c/strong\u003e. When dragProgress reaches 1.0 (fully dragged), textAlpha becomes 0.0 → the text is \u003cstrong\u003efully invisible\u003c/strong\u003e. We apply this textAlpha to our \u003ccode\u003eText\u003c/code\u003e composable using \u003ccode\u003eModifier.alpha()\u003c/code\u003e — so the text fades smoothly while dragging.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/b687344c083275c78ae9f022cc2c2341\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/b687344c083275c78ae9f022cc2c2341\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eThis is what we have so far\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"679b\"\u003eStep 5: Add track scale \u0026amp; thumb alpha animation\u003c/h2\u003e\u003cp id=\"7a0a\"\u003eOnce the user \u003cstrong\u003eslides the button almost to the end\u003c/strong\u003e, we want two things to happen:\u003c/p\u003e\u003col\u003e\u003cli id=\"0ca6\"\u003eThe \u003cstrong\u003eouter track\u003c/strong\u003e (button background) should \u003cstrong\u003eshrink and disappear\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"9b98\"\u003eThe \u003cstrong\u003eslider button\u003c/strong\u003e should \u003cstrong\u003efade out\u003c/strong\u003e completely.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"89a6\"\u003eThis tells the user that the slide is \u003cstrong\u003ecomplete\u003c/strong\u003e, and the action (like booking the ride) is being processed.\u003c/p\u003e\u003cp id=\"afc0\"\u003eWhat we need to do:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2660\"\u003eWe use a boolean flag \u003ccode\u003esliderComplete\u003c/code\u003e that tells us when slide progress has passed a threshold. When \u003ccode\u003edragProgress\u003c/code\u003e reaches \u003cstrong\u003e80% or more\u003c/strong\u003e, we \u003cstrong\u003eset \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003esliderComplete = true\u003c/strong\u003e\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"5fc1\"\u003eWe use \u003ccode\u003eanimateFloatAsState()\u003c/code\u003e and \u003ccode\u003eModifier.graphicsLayer()\u003c/code\u003e to smoothly animate the scale and alpha changes.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/bd3d257337317cb71fdfd8ca73188bfb\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/bd3d257337317cb71fdfd8ca73188bfb\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cfigcaption\u003eAnd this is what we’ec achieved!\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"4c4b\"\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The order of \u003cstrong\u003emodifiers\u003c/strong\u003e matters here. We have to ensure that we add the \u003ccode\u003e\u003cstrong\u003e.graphicsLayer\u003c/strong\u003e\u003c/code\u003e above the \u003ccode\u003e\u003cstrong\u003e.background\u003c/strong\u003e\u003c/code\u003e here to ensure that the scaling takes place correctly. If we change the order, i.e. if we add the \u003ccode\u003e\u003cstrong\u003e.background\u003c/strong\u003e\u003c/code\u003e after we add the \u003ccode\u003e\u003cstrong\u003e.graphicsayer\u003c/strong\u003e\u003c/code\u003e, the background is already drawn at full size so the scaling doesn’t affect what’s already been rendered. But if you shrink before, everything is drawn inside the new size — and that’s what you want here!\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"df3b\"\u003eStep 6: Add the loading indicator animation\u003c/h2\u003e\u003cp id=\"5934\"\u003eNow that we have all the moving parts in place, we simply need to show a loading indicator when the animation is complete. For that, we need to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ab5b\"\u003eDefine a boolean flag \u003ccode\u003e\u003cstrong\u003eshowLoading\u003c/strong\u003e\u003c/code\u003e that tells us when we need to show this loading indicator.\u003c/li\u003e\u003cli id=\"3fcb\"\u003eWe need to update our \u003ccode\u003e\u003cstrong\u003eLaunchedEffect(dragProgress)\u003c/strong\u003e\u003c/code\u003e method to set \u003ccode\u003e\u003cstrong\u003eshowLoading = true\u003c/strong\u003e\u003c/code\u003e when sliding is completed.\u003c/li\u003e\u003cli id=\"92f9\"\u003eWe need to display a \u003ccode\u003e\u003cstrong\u003eCircularProgressIndicator()\u003c/strong\u003e\u003c/code\u003e when \u003ccode\u003e\u003cstrong\u003eshowLoading = true\u003c/strong\u003e\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"220a\"\u003eAnd this is our full code:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/anitaa1990/c2f17982d19d2b5835493596f7755860\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/anitaa1990/c2f17982d19d2b5835493596f7755860\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e2e4\"\u003eAnd that’s pretty much it!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-08T10:13:37.226Z",
  "modifiedTime": null
}
