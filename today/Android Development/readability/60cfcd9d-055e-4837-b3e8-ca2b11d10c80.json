{
  "id": "60cfcd9d-055e-4837-b3e8-ca2b11d10c80",
  "title": "AssistedInject is dead, long live AssistedInject!",
  "link": "https://code.cash.app/assisted-inject-is-dead-long-live-assisted-inject",
  "description": "",
  "author": "",
  "published": "2021-03-31T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "Jake Wharton",
  "length": 6864,
  "excerpt": "After ~5 years of existing and ~4 years as an open source project, our AssistedInject library has been deleted. Mourn not, however, for the same functionality is now available directly in Dagger and InflationInject got its own repo.",
  "siteName": "Cash App Code Blog",
  "favicon": "https://code.cash.app/assets/icon-196.png",
  "text": "Posted by Jake Wharton on March 31, 2021 After ~5 years of existing and ~4 years as an open source project, our AssistedInject library has been deleted. Mourn not, however, for the same functionality is now available directly in Dagger and InflationInject got its own repo. (Psst. Know Dagger but don’t know what assisted or inflation injection is? That’s okay. Check out this introductory talk. Otherwise, this post won’t make much sense!) This post will cover the steps required for migrating from Square AssistedInject to Dagger AssistedInject, minor differences between the two, and the status of InflationInject. Migration and differences Our migration to Dagger’s AssistedInject was done in a few discrete steps after failing to migrate in a single change. It is possible to migrate in a single change, but multiple changes help ensure the differences are handled correctly. These steps assume you are using AssistedInject 0.6.0 which was the latest stable version for the past six months. Step 1: Upgrade to 0.7 Version 0.7.0 contains changes from the last 6 months which will make future changes simpler. Most notably, this version will require specifying qualifier annotations for assisted parameters of the same type. class Example @AssistedInject constructor( graphValue: GraphValue, - @Assisted assistedValue1: String, + @Assisted @Named(\"one\") assistedValue1: String, - @Assisted assistedValue2: String, + @Assisted @Named(\"two\") assistedValue2: String, ) { // ... @AssistedInject.Factory interface Factory { fun create( - assistedValue1: String, + @Named(\"one\") assistedValue1: String, - assistedValue2: String, + @Named(\"two\") assistedValue2: String, ): Example } } While this seems like boilerplate, the previous behavior of relying on parameter names was not safe as they are not always available (Dagger will also require this). This version also includes a bug fix that allows using Dagger’s @AssistedInject-annotated types inside a Square @AssistedInject or @InflationInject-annotated type. If you are migrating incrementally rather than all modules at once this fix is essential for interoperability between the two libraries. Step 2: Upgrade to 0.8 If you are using inflation injection, version 0.8.1 changes the annotation used in the constructor from @Assisted to @Inflated. -import com.squareup.inject.assisted.Assisted +import com.squareup.inject.inflation.Inflated import com.squareup.inject.inflation.InflationInject class ExampleView @InjectionInject constructor( - @Assisted context: Context, + @Inflated context: Context, - @Assisted attrs: AttributeSet, + @Inflated attrs: AttributeSet, picasso: Picasso, ) : View { // ... } Since Dagger validates that all usages of its @Assisted are inside constructors annotated with its @AssistedInject, this change is required before migrating. Additionally, since the layout inflater provides the values instead of the user, the new name is also more accurate. Step 3: Switch to Dagger At this point we can start migrating to Dagger’s version. While it has been released for a few versions, the latest (at time of writing) is 2.33 which has some important bug fixes. Aside from simple import changes, Dagger uses @AssistedFactory instead of @AssistedInject.Factory and disambiguation for assisted parameters of the same type goes directly on the @Assisted annotation rather than through a qualifier annotation. -import com.squareup.inject.assisted.Assisted +import dagger.assisted.Assisted +import dagger.assisted.AssistedFactory -import com.squareup.inject.asissted.AssistedInject +import dagger.assisted.AssistedInject -import javax.inject.Named class Example @AssistedInject constructor( graphValue: GraphValue, - @Assisted @Named(\"one\") assistedValue1: String, + @Assisted(\"one\") assistedValue1: String, - @Assisted @Named(\"two\") assistedValue2: String, + @Assisted(\"two\") assistedValue2: String, ) { // ... - @AssistedInject.Factory + @AssistedFactory interface Factory { fun create( - @Named(\"one\") assistedValue1: String, + @Assisted(\"one\") assistedValue1: String, - @Named(\"two\") assistedValue2: String, + @Assisted(\"two\") assistedValue2: String, ): Example } } With assisted injection built-in to Dagger there is no need to have something like @AssistedModule. Delete it! -@AssistedModule -@Module(includes = AssistedInject_ExampleModule.class) +@Module class ExampleModule { // ... } There is one pattern to watch out for in this migration. Dagger’s assisted injection requires that the factory return type matches the type which is being created. If one of your factories was returning a supertype of the enclosing class, you will have to pull out a second factory interface and use @Binds to support it. class TestPresenter @AssistedInject constructor( // ... ) : ObservableTransformer\u003cEvent, Model\u003e { // ... + @AssistedFactory + interface DaggerFactory : Factory { + override fun create(/*..*/): TestPresenter + } - @AssistedInject.Factory interface Factory { fun create(/*..*/): ObservableTransformer\u003cEvent, Model\u003e } } // In a module somewhere… +@Binds +abstract fun daggerFactoryTestPresenter( + factory: TestPresenter.DaggerFactory, +): TestPresenter.Factory Step 4: Remove dependencies or upgrade to 0.9 At this point you can remove the Square AssistedInject dependencies. And if you’re not using inflation injection then you’re done! If you are using inflation injection, upgrade to version 0.9.1 which completely removes the assisted injection parts. You’re almost done… InflationInject 1.0! With assisted injection now excised from the project, the GitHub repo was renamed to InflationInject, moved into the ‘cashapp’ organization, and given a quick makeover for its 1.0.0 release. The Maven coordinates now use the groupId of ‘app.cash.inject’. -implementation 'com.squareup.inject:inflation-inject:0.9.1' +implementation 'app.cash.inject:inflation-inject:1.0.0' -annotationProcessor 'com.squareup.inject:inflation-inject-processor:0.9.1' +annotationProcessor 'app.cash.inject:inflation-inject-processor:1.0.0' Imports were changed to also use app.cash.inject as the base package. -import com.squareup.inject.inflation.Inflated +import app.cash.inject.inflation.Inflated -import com.squareup.inject.inflation.InflationInject +import app.cash.inject.inflation.InflationInject class ExampleView @InjectionInject constructor( // ... ) : View { // ... } Inflation injection serves a niche need, and with Jetpack Compose UI becoming viable the project is unlikely to see much more development. With the primary goal of landing assisted injection upstream into Dagger fulfilled, it’s still nice to have the rest of the project reach 1.0.",
  "image": "https://code.cash.app/assets/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n\n  \u003cdiv\u003e\u003cp\u003e\n    Posted by\n    \u003ca href=\"https://mastodon.jakewharton.com/@jw\"\u003eJake Wharton\u003c/a\u003e\n    \n      \u003cspan\u003eon \u003c/span\u003e\u003ctime datetime=\"2021-03-31 00:00:00 +0000\"\u003eMarch 31, 2021\u003c/time\u003e\n    \n  \u003c/p\u003e\u003c/div\u003e\n\n  \u003cp\u003eAfter ~5 years of existing and ~4 years as an open source project, our AssistedInject library has been deleted. Mourn not, however, for the same functionality is \u003ca href=\"https://dagger.dev/dev-guide/assisted-injection.html\"\u003enow available\u003c/a\u003e directly in Dagger and InflationInject \u003ca href=\"https://github.com/cashapp/InflationInject\"\u003egot its own repo\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e(Psst. Know Dagger but don’t know what assisted or inflation injection is? That’s okay. Check out \u003ca href=\"https://jakewharton.com/helping-dagger-help-you/\"\u003ethis introductory talk\u003c/a\u003e. Otherwise, this post won’t make much sense!)\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThis post will cover the steps required for migrating from Square AssistedInject to Dagger AssistedInject, minor differences between the two, and the status of InflationInject.\u003c/p\u003e\n\n\u003ch2 id=\"migration-and-differences\"\u003eMigration and differences\u003c/h2\u003e\n\n\u003cp\u003eOur migration to Dagger’s AssistedInject was done in a few discrete steps after failing to migrate in a single change. It is possible to migrate in a single change, but multiple changes help ensure the differences are handled correctly.\u003c/p\u003e\n\n\u003cp\u003eThese steps assume you are using AssistedInject 0.6.0 which was the latest stable version for the past six months.\u003c/p\u003e\n\n\u003ch3 id=\"step-1-upgrade-to-07\"\u003eStep 1: Upgrade to 0.7\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/cashapp/InflationInject/blob/trunk/CHANGELOG.md#070---2021-03-21\"\u003eVersion 0.7.0\u003c/a\u003e contains changes from the last 6 months which will make future changes simpler.\u003c/p\u003e\n\n\u003cp\u003eMost notably, this version will require specifying qualifier annotations for assisted parameters of the same type.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e class Example @AssistedInject constructor(\n   graphValue: GraphValue,\n\u003cspan\u003e-  @Assisted assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e+  @Assisted @Named(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e-  @Assisted assistedValue2: String,\n\u003c/span\u003e\u003cspan\u003e+  @Assisted @Named(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e ) {\n   // ...\n   \n   @AssistedInject.Factory\n   interface Factory {\n     fun create(\n\u003cspan\u003e-      assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e+      @Named(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e-      assistedValue2: String,\n\u003c/span\u003e\u003cspan\u003e+      @Named(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e     ): Example\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhile this seems like boilerplate, the previous behavior of relying on parameter names was not safe as they are not always available (Dagger will also require this).\u003c/p\u003e\n\n\u003cp\u003eThis version also includes a bug fix that allows using Dagger’s \u003ccode\u003e@AssistedInject\u003c/code\u003e-annotated types\ninside a Square \u003ccode\u003e@AssistedInject\u003c/code\u003e or \u003ccode\u003e@InflationInject\u003c/code\u003e-annotated type. If you are migrating incrementally rather than all modules at once this fix is essential for interoperability between the two libraries.\u003c/p\u003e\n\n\u003ch3 id=\"step-2-upgrade-to-08\"\u003eStep 2: Upgrade to 0.8\u003c/h3\u003e\n\n\u003cp\u003eIf you are using inflation injection, \u003ca href=\"https://github.com/cashapp/InflationInject/blob/trunk/CHANGELOG.md#081---2021-03-22\"\u003eversion 0.8.1\u003c/a\u003e changes the annotation used in the constructor from \u003ccode\u003e@Assisted\u003c/code\u003e to \u003ccode\u003e@Inflated\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-import com.squareup.inject.assisted.Assisted\n\u003c/span\u003e\u003cspan\u003e+import com.squareup.inject.inflation.Inflated\n\u003c/span\u003e import com.squareup.inject.inflation.InflationInject\n\n class ExampleView @InjectionInject constructor(\n\u003cspan\u003e-  @Assisted context: Context,\n\u003c/span\u003e\u003cspan\u003e+  @Inflated context: Context,\n\u003c/span\u003e\u003cspan\u003e-  @Assisted attrs: AttributeSet,\n\u003c/span\u003e\u003cspan\u003e+  @Inflated attrs: AttributeSet,\n\u003c/span\u003e   picasso: Picasso,\n ) : View {\n   // ...\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSince Dagger validates that all usages of its \u003ccode\u003e@Assisted\u003c/code\u003e are inside constructors annotated with its \u003ccode\u003e@AssistedInject\u003c/code\u003e, this change is required before migrating. Additionally, since the layout inflater provides the values instead of the user, the new name is also more accurate.\u003c/p\u003e\n\n\u003ch3 id=\"step-3-switch-to-dagger\"\u003eStep 3: Switch to Dagger\u003c/h3\u003e\n\n\u003cp\u003eAt this point we can start migrating to Dagger’s version. While it has been released for a few versions, the latest (at time of writing) is 2.33 which has some important bug fixes.\u003c/p\u003e\n\n\u003cp\u003eAside from simple import changes, Dagger uses \u003ccode\u003e@AssistedFactory\u003c/code\u003e instead of \u003ccode\u003e@AssistedInject.Factory\u003c/code\u003e and disambiguation for assisted parameters of the same type goes directly on the \u003ccode\u003e@Assisted\u003c/code\u003e annotation rather than through a qualifier annotation.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-import com.squareup.inject.assisted.Assisted\n\u003c/span\u003e\u003cspan\u003e+import dagger.assisted.Assisted\n+import dagger.assisted.AssistedFactory\n\u003c/span\u003e\u003cspan\u003e-import com.squareup.inject.asissted.AssistedInject\n\u003c/span\u003e\u003cspan\u003e+import dagger.assisted.AssistedInject\n\u003c/span\u003e\u003cspan\u003e-import javax.inject.Named\n\u003c/span\u003e\n class Example @AssistedInject constructor(\n   graphValue: GraphValue,\n\u003cspan\u003e-  @Assisted @Named(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e+  @Assisted(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e-  @Assisted @Named(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e\u003cspan\u003e+  @Assisted(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e ) {\n   // ...\n   \n\u003cspan\u003e-  @AssistedInject.Factory\n\u003c/span\u003e\u003cspan\u003e+  @AssistedFactory\n\u003c/span\u003e   interface Factory {\n     fun create(\n\u003cspan\u003e-      @Named(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e+      @Assisted(\u0026#34;one\u0026#34;) assistedValue1: String,\n\u003c/span\u003e\u003cspan\u003e-      @Named(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e\u003cspan\u003e+      @Assisted(\u0026#34;two\u0026#34;) assistedValue2: String,\n\u003c/span\u003e     ): Example\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith assisted injection built-in to Dagger there is no need to have something like \u003ccode\u003e@AssistedModule\u003c/code\u003e. Delete it!\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-@AssistedModule\n-@Module(includes = AssistedInject_ExampleModule.class)\n\u003c/span\u003e\u003cspan\u003e+@Module\n\u003c/span\u003e class ExampleModule {\n   // ...\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThere is one pattern to watch out for in this migration. Dagger’s assisted injection requires that the factory return type matches the type which is being created. If one of your factories was returning a supertype of the enclosing class, you will have to pull out a second factory interface and use \u003ccode\u003e@Binds\u003c/code\u003e to support it.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e class TestPresenter @AssistedInject constructor(\n   // ...\n ) : ObservableTransformer\u0026lt;Event, Model\u0026gt; {\n   // ...\n  \n\u003cspan\u003e+  @AssistedFactory\n+  interface DaggerFactory : Factory {\n+    override fun create(/*..*/): TestPresenter\n+  }\n\u003c/span\u003e\u003cspan\u003e-  @AssistedInject.Factory\n\u003c/span\u003e   interface Factory {\n     fun create(/*..*/): ObservableTransformer\u0026lt;Event, Model\u0026gt;\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e // In a module somewhere…\n\u003cspan\u003e+@Binds\n+abstract fun daggerFactoryTestPresenter(\n+  factory: TestPresenter.DaggerFactory,\n+): TestPresenter.Factory\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3 id=\"step-4-remove-dependencies-or-upgrade-to-09\"\u003eStep 4: Remove dependencies or upgrade to 0.9\u003c/h3\u003e\n\n\u003cp\u003eAt this point you can remove the Square AssistedInject dependencies. And if you’re not using inflation injection then you’re done!\u003c/p\u003e\n\n\u003cp\u003eIf you are using inflation injection, upgrade to \u003ca href=\"https://github.com/cashapp/InflationInject/blob/trunk/CHANGELOG.md#091---2021-03-26\"\u003eversion 0.9.1\u003c/a\u003e which completely removes the assisted injection parts. You’re \u003cem\u003ealmost\u003c/em\u003e done…\u003c/p\u003e\n\n\u003ch2 id=\"inflationinject-10\"\u003eInflationInject 1.0!\u003c/h2\u003e\n\n\u003cp\u003eWith assisted injection now excised from the project, \u003ca href=\"https://github.com/cashapp/InflationInject\"\u003ethe GitHub repo\u003c/a\u003e was renamed to InflationInject, moved into the ‘cashapp’ organization, and given a quick makeover for its 1.0.0 release.\u003c/p\u003e\n\n\u003cp\u003eThe Maven coordinates now use the groupId of ‘app.cash.inject’.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-implementation \u0026#39;com.squareup.inject:inflation-inject:0.9.1\u0026#39;\n\u003c/span\u003e\u003cspan\u003e+implementation \u0026#39;app.cash.inject:inflation-inject:1.0.0\u0026#39;\n\u003c/span\u003e\u003cspan\u003e-annotationProcessor \u0026#39;com.squareup.inject:inflation-inject-processor:0.9.1\u0026#39;\n\u003c/span\u003e\u003cspan\u003e+annotationProcessor \u0026#39;app.cash.inject:inflation-inject-processor:1.0.0\u0026#39;\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eImports were changed to also use \u003ccode\u003eapp.cash.inject\u003c/code\u003e as the base package.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-import com.squareup.inject.inflation.Inflated\n\u003c/span\u003e\u003cspan\u003e+import app.cash.inject.inflation.Inflated\n\u003c/span\u003e\u003cspan\u003e-import com.squareup.inject.inflation.InflationInject\n\u003c/span\u003e\u003cspan\u003e+import app.cash.inject.inflation.InflationInject\n\u003c/span\u003e\n class ExampleView @InjectionInject constructor(\n   // ...\n ) : View {\n   // ...\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eInflation injection serves a niche need, and with Jetpack Compose UI becoming viable the project is unlikely to see much more development. With the primary goal of landing assisted injection upstream into Dagger fulfilled, it’s still nice to have the rest of the project reach 1.0.\u003c/p\u003e\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2021-03-31T00:00:00Z",
  "modifiedTime": null
}
