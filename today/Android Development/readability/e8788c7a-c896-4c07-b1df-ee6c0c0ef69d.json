{
  "id": "e8788c7a-c896-4c07-b1df-ee6c0c0ef69d",
  "title": "Mastering Android ViewModels: Essential Dos and Don’ts Part 5 ️5️⃣",
  "link": "https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-5-%EF%B8%8F5%EF%B8%8F%E2%83%A3-14d04ec2426a?source=rss----c72404660798---4",
  "description": "",
  "author": "Reza",
  "published": "Sat, 26 Oct 2024 20:33:01 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "viewmodel",
    "viewmodel-testing",
    "android",
    "kotlin",
    "performance"
  ],
  "byline": "Reza",
  "length": 4139,
  "excerpt": "This will be the fifth installment in our series “Mastering Android ViewModels” where we dive deep into the essential dos and don’ts that can elevate your Android development skills. We’ve already…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "keep these in mind for better code quality when doing ViewModels!This will be the fifth installment in our series “Mastering Android ViewModels” where we dive deep into the essential dos and don’ts that can elevate your Android development skills. We’ve already covered several tips to improve performance and code quality in ViewModels, which have become an integral part of modern Android applications.We’ve Covered So Far 🔄🔄🔄Avoid initializing the state in the init {} block. ✅ Read hereAvoid exposing mutable states. ✅ Read hereUse update{} when using MutableStateFlows. ✅ Read hereTry not to import Android dependencies in the ViewModels. ✅ Read hereLazily inject dependencies in the constructor. ✅ Read hereEmbrace more reactive and less imperative coding. ✅ Read hereAvoid initializing the ViewModel from the outside world. ✅ Read hereIn this article we’ll cover:8. 👉Avoid hardcoding Coroutine Dispatchers.9. 👉Unit test your ViewModels.10. 👉Avoid exposing suspended functions.#8 — Avoid Hardcoding Coroutine DispatchersWhen dealing with coroutines in your ViewModel, hardcoding dispatchers like Dispatchers.IO or Dispatchers.Default might seem convenient, but it can lead to tightly coupled and less testable code.The Problem with Hardcoding DispatchersHardcoding dispatchers directly in your ViewModel can make testing difficult and reduce flexibility. For instance, during testing, you may want to control the threading behavior, which becomes challenging with hardcoded dispatchers.Recommended ApproachInject your dispatchers via the constructor or use a dependency injection framework like Hilt or Dagger. This not only makes your ViewModel more flexible but also simplifies testing:class MyViewModel( private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO) : ViewModel() { private fun loadData() { viewModelScope.launch(ioDispatcher) { // Your coroutine code here } }}By using dependency injection, you can swap out the dispatcher during testing, ensuring your ViewModel behaves correctly in different environments.for an example look at:#9 — Unit Test Your ViewModelsUnit testing is essential to ensure your ViewModels behave as expected. Without proper tests, you risk introducing bugs that could have been caught early.Testing ChallengesViewModels often interact with complex state and other components, making them tricky to test. However, by following the right practices, specially what we discuss in this series, you can thoroughly test your ViewModel’s logic.Best Practices for Testing ViewModelsUse a TestCoroutineDispatcher to control coroutine execution and test asynchronous code synchronously.Favor testing ViewModels as a non-Android test (use test folder instead of androidTest)Avoid using runBlocking{} for testing suspended functions, instead use runTest{} from coroutines-testAvoid manually peeking values from StateFlows, Use Turbine insteadFor testing flows, use TurbineFavor fakes over mocks#10 — Avoid Exposing Suspended FunctionsWhile suspend functions make asynchronous programming in Kotlin easier, exposing them directly from your ViewModel can lead to misuse and increased complexity.Why It’s ProblematicExposing suspend functions can result in mismanagement of threading or lifecycle events, leading to bugs or crashes.The Better WayKeep suspension internal to the ViewModel, and expose results through Flow or other observable patterns.Conclusion:Mastering ViewModels in Android development is crucial for creating robust, efficient, and maintainable applications. Throughout this series, we’ve discussed a comprehensive set of best practices to improve your code quality and application performance.🌟 Congratulations if you’ve made it this far in the article! 🎉 Don’t forget to:👏 smash the clap button as many times! So I can continue with the follow-up articles!Follow my YouTube channel for video tutorials and tips on Android development✨✨ If you need help with your Android ViewModels, Project, or your career development, Book a 1:1 or a Pair-Programming session with me, Book a time now 🧑‍💻🧑‍💻🧑‍💻check out the previous articles in this series with the links below:",
  "image": "https://miro.medium.com/v2/resize:fit:1080/1*XDoCaRPSQa-h0DqkT5ckmA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"d05b\"\u003ekeep these in mind for better code quality when doing ViewModels!\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://mrnajafi.medium.com/?source=post_page-----14d04ec2426a--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Reza\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*T95Zeqgg_vm1yNzTq7I3Jg.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page-----14d04ec2426a--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c347\"\u003eThis will be the fifth installment in our series \u003cstrong\u003e“Mastering Android ViewModels”\u003c/strong\u003e where we dive deep into the essential dos and don’ts that can elevate your Android development skills. We’ve already covered several tips to improve performance and code quality in ViewModels, which have become an integral part of modern Android applications.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7e01\"\u003eWe’ve Covered So Far 🔄🔄🔄\u003c/h2\u003e\u003col\u003e\u003cli id=\"9539\"\u003e\u003cstrong\u003eAvoid initializing the state in the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einit {}\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e block.\u003c/strong\u003e ✅\u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-1-%EF%B8%8F-bdf05287bca9\"\u003e Read here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"6ce1\"\u003e\u003cstrong\u003eAvoid exposing mutable states.\u003c/strong\u003e ✅ \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-2-%EF%B8%8F-2b49281f0029\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"93c0\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eupdate{}\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e when using \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMutableStateFlows\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e.\u003c/strong\u003e ✅ \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-2-%EF%B8%8F-2b49281f0029\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"2c09\"\u003e\u003cstrong\u003eTry not to import Android dependencies in the ViewModels.\u003c/strong\u003e ✅ \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-3-%EF%B8%8F3%EF%B8%8F%E2%83%A3-1833ce3ddd2b\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"b702\"\u003e\u003cstrong\u003eLazily inject dependencies in the constructor.\u003c/strong\u003e ✅ \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-3-%EF%B8%8F3%EF%B8%8F%E2%83%A3-1833ce3ddd2b\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"466c\"\u003e\u003cstrong\u003eEmbrace more reactive and less imperative coding. ✅ \u003c/strong\u003e\u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-4-%EF%B8%8F-a0bad53cebd2\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003cli id=\"8d7d\"\u003e\u003cstrong\u003eAvoid initializing the ViewModel from the outside world. ✅ \u003c/strong\u003e\u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://proandroiddev.com/mastering-android-viewmodels-essential-dos-and-donts-part-4-%EF%B8%8F-a0bad53cebd2\"\u003eRead here\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0d58\"\u003eIn this article we’ll cover:\u003c/h2\u003e\u003cp id=\"31f2\"\u003e8. \u003cstrong\u003e👉Avoid hardcoding Coroutine Dispatchers.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"848e\"\u003e9. \u003cstrong\u003e👉Unit test your ViewModels.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"523b\"\u003e10. \u003cstrong\u003e👉Avoid exposing suspended functions.\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"ee95\"\u003e#8 — Avoid Hardcoding Coroutine Dispatchers\u003c/h2\u003e\u003cp id=\"9aa6\"\u003eWhen dealing with coroutines in your ViewModel, hardcoding dispatchers like \u003ccode\u003eDispatchers.IO\u003c/code\u003e or \u003ccode\u003eDispatchers.Default\u003c/code\u003e might seem convenient, but it can lead to tightly coupled and less testable code.\u003c/p\u003e\u003ch2 id=\"5ebd\"\u003eThe Problem with Hardcoding Dispatchers\u003c/h2\u003e\u003cp id=\"060c\"\u003eHardcoding dispatchers directly in your ViewModel can make testing difficult and reduce flexibility. For instance, during testing, you may want to control the threading behavior, which becomes challenging with hardcoded dispatchers.\u003c/p\u003e\u003ch2 id=\"57e2\"\u003eRecommended Approach\u003c/h2\u003e\u003cp id=\"476e\"\u003eInject your dispatchers via the constructor or use a dependency injection framework like Hilt or Dagger. This not only makes your ViewModel more flexible but also simplifies testing:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0daf\"\u003eclass MyViewModel(\u003cbr/\u003e    private val ioDispatcher: CoroutineDispatcher = Dispatchers.IO\u003cbr/\u003e) : ViewModel() {\u003cp\u003e  private fun loadData() {\u003cbr/\u003e     viewModelScope.launch(ioDispatcher) {\u003cbr/\u003e       // Your coroutine code here\u003cbr/\u003e     }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"28f0\"\u003eBy using dependency injection, you can swap out the dispatcher during testing, ensuring your ViewModel behaves correctly in different environments.\u003c/p\u003e\u003cp id=\"1243\"\u003efor an example look at:\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"42ee\"\u003e#9 — Unit Test Your ViewModels\u003c/h2\u003e\u003cp id=\"fffd\"\u003eUnit testing is essential to ensure your ViewModels behave as expected. Without proper tests, you risk introducing bugs that could have been caught early.\u003c/p\u003e\u003ch2 id=\"6211\"\u003eTesting Challenges\u003c/h2\u003e\u003cp id=\"8362\"\u003eViewModels often interact with complex state and other components, making them tricky to test. However, by following the right practices, specially what we discuss in this series, you can thoroughly test your ViewModel’s logic.\u003c/p\u003e\u003ch2 id=\"2f94\"\u003eBest Practices for Testing ViewModels\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1d36\"\u003e\u003cstrong\u003eUse a \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eTestCoroutineDispatcher\u003c/strong\u003e\u003c/code\u003e to control coroutine execution and test asynchronous code synchronously.\u003c/li\u003e\u003cli id=\"cc39\"\u003eFavor testing ViewModels as a non-Android test (use test folder instead of androidTest)\u003c/li\u003e\u003cli id=\"9f13\"\u003eAvoid using \u003ccode\u003erunBlocking{}\u003c/code\u003e for testing \u003ccode\u003esuspended\u003c/code\u003e functions, instead use \u003ccode\u003erunTest{}\u003c/code\u003e from \u003ccode\u003ecoroutines-test\u003c/code\u003e\u003c/li\u003e\u003cli id=\"5608\"\u003eAvoid manually peeking values from \u003ccode\u003eStateFlows\u003c/code\u003e, Use \u003ca href=\"https://github.com/cashapp/turbine\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTurbine\u003c/a\u003e instead\u003c/li\u003e\u003cli id=\"1723\"\u003eFor testing \u003ccode\u003eflows\u003c/code\u003e, use \u003ca href=\"https://github.com/cashapp/turbine\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTurbine\u003c/a\u003e\u003c/li\u003e\u003cli id=\"ed62\"\u003eFavor fakes over mocks\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f7db\"\u003e#10 — Avoid Exposing Suspended Functions\u003c/h2\u003e\u003cp id=\"c1c5\"\u003eWhile \u003ccode\u003esuspend\u003c/code\u003e functions make asynchronous programming in Kotlin easier, exposing them directly from your ViewModel can lead to misuse and increased complexity.\u003c/p\u003e\u003ch2 id=\"3a79\"\u003eWhy It’s Problematic\u003c/h2\u003e\u003cp id=\"0a93\"\u003eExposing \u003ccode\u003esuspend\u003c/code\u003e functions can result in mismanagement of threading or lifecycle events, leading to bugs or crashes.\u003c/p\u003e\u003ch2 id=\"eec7\"\u003eThe Better Way\u003c/h2\u003e\u003cp id=\"f3a7\"\u003eKeep suspension internal to the ViewModel, and expose results through \u003ccode\u003eFlow\u003c/code\u003e or other observable patterns.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f331\"\u003eConclusion:\u003c/h2\u003e\u003cp id=\"8297\"\u003eMastering ViewModels in Android development is crucial for creating robust, efficient, and maintainable applications. Throughout this series, we’ve discussed a comprehensive set of best practices to improve your code quality and application performance.\u003c/p\u003e\u003cp id=\"f3d4\"\u003e🌟 \u003cstrong\u003eCongratulations\u003c/strong\u003e if you’ve made it this far in the article! 🎉 \u003cstrong\u003eDon’t forget to\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5850\"\u003e👏 smash the clap button as many times! So I can continue with the follow-up articles!\u003c/li\u003e\u003cli id=\"699a\"\u003eFollow \u003ca href=\"https://www.youtube.com/@DroidFly\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emy YouTube channel\u003c/a\u003e for video tutorials and tips on Android development\u003c/li\u003e\u003cli id=\"8991\"\u003e✨✨ \u003cstrong\u003eIf you need help with your Android ViewModels, Project, or your career development, Book a 1:1 or a Pair-Programming session with me, \u003c/strong\u003e\u003ca href=\"https://mentorcruise.com/mentor/rezanajafi/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eBook a time now\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003e🧑‍💻🧑‍💻🧑‍💻\u003c/li\u003e\u003cli id=\"9f78\"\u003echeck out the previous articles in this series with the links below:\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-10-26T20:33:01.088Z",
  "modifiedTime": null
}
