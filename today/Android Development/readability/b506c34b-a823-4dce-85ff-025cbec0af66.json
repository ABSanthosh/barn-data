{
  "id": "b506c34b-a823-4dce-85ff-025cbec0af66",
  "title": "Exploring the Android Photo Picker",
  "link": "https://joebirch.co/android/exploring-the-android-photo-picker/",
  "description": "The Photo Picker allow us to reduce friction when working with Media selection on Android, along with creating a simpler + consistent experience for users. In this blog post, we’re going to take a quick look at how we can use it in our own apps – both in Composable UI and within activities/fragments. Looking... Continue reading →",
  "author": "hitherejoe",
  "published": "Fri, 05 Apr 2024 00:01:21 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Apps",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 5622,
  "excerpt": "The Photo Picker allow us to reduce friction when working with Media selection on Android, along with creating a simpler + consistent experience for users. In this blog post, we're going to take a quick look at how we can use it in our own apps - both in Composable UI and within activities/fragments",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "The Photo Picker allow us to reduce friction when working with Media selection on Android, along with creating a simpler + consistent experience for users. In this blog post, we’re going to take a quick look at how we can use it in our own apps – both in Composable UI and within activities/fragments. Looking to learn Jetpack Compose? Check out my course, Practical Jetpack Compose Why use the Photo Picker? Whether you already have media pickers implemented in your app, or are looking at adding support, the Photo Picker gives us some advantages out of the box. Media Permissions are handled for us, regardless of Android Version. For example, Android 14 saw the introduction of partial media access. The Photo Picker handles these permissions for us, so we don’t need to invest in additional effort for implementing and maintaining complex permission flows Picker availability is managed by the API. If the Photo Picker is available then this will be used, otherwise, the API will use one of the PICK_IMAGES or GET_DOCUMENTS system alternatives as a fallback The Photo Picker gives our users a consistent experience across the android ecosystem, while also modernising and simplifying the media selection process. The Photo Picker hides a lot of the noise that comes with the standard system pickers, allowing our users to focus on the desired media selection These are only some of the main advantages for using the photo picker, and i’m sure there are more that others have experience from their migration of traditional approaches. Implementation in Activities/Fragments When it comes to utilising the photo picker inside of activities or fragments, we need to do two things: Register the result request using a contract that will be used to receive the result Create the activity request and use the contract to launch it We’ll start here by registering our activity/fragment using the registerForActivityResult function. When doing this, we need to provide both the contract and callback. private val picker = registerForActivityResult(//contract) { // callback } For the contract, we will be using PickMultipleVisualMedia, this is a system intent that will launch the Photo Picker – if the Photo Picker is not available, alternative system pickers will be used instead. ActivityResultContracts.PickMultipleVisualMedia() When using the PickMultipleVisualMedia contract, we can also provide a value for the maximum number of media that can be selected. If not provided, the default value supported by the picker will be used. PickMultipleVisualMedia(10) Alternatively, the PickVisualMedia contract can be used to allow the selection of a single media item. ActivityResultContracts.PickVisualMedia() Regardless of the contract being used, we next need to slot this into our registerForActivityResult request. Along with the callback that will handle our request – we won’t be implementing the body of this callback in this example, but the callback will simplify provide us with the list of Uris from the multiple media request. If only supporting a single media item via PickVisualMedia, this will be a Uri instead of a list. private val picker = registerForActivityResult(ActivityResultContracts.PickMultipleVisualMedia()) { uris -\u003e // handle uris } With our request defined, we can now trigger a media picker request using the launch function on our picker reference. When calling this function, we need to pass a PickVisualMediaRequest reference containing the supported media type. This takes the form of a VisualMediaType reference that can be either ImageAndVideo, ImageOnly, VideoOnly or SingleMimeType to provide the mimetype that you want the picker to filter by. picker.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)) When triggering this launch function, the photo picker will be displayed to the user using the specified constraints. Once the media selection has been confirmed, the result will be delivered to the callback provided to the registerForActivityResult function. Implementation in Compose When it comes to using the photo picker in compose, the developer experience is consistent to using it within an activity/fragment, things only differ slightly for the adaption within the compose world. We must start by defining our result receiver using the rememberLaunchForActivityResult function. Similar to what we saw in the previous example, this will create a result receiver using the provided contract and callback. The difference here is that this remember function is specifically for compose and will be remembered across compositions. val photoPickerLauncher = rememberLauncherForActivityResult(ActivityResultContracts.PickMultipleVisualMedia(10)) { uris -\u003e // Handle URIs } With this receiver in place we can now use this within our composables to trigger the Photo Picker within our composable UI. Similar to before, we use the launch function along with the request that we wish to be used. The same availability applies as above, allowing us to restrict the types of media that is displayed within the Photo Picker. photoPickerLauncher.launch( PickVisualMediaRequest( ActivityResultContracts.PickVisualMedia.ImageAndVideo ) ) In the above examples, we’ve learnt how we can adopt the Photo Picker in both our Compose and Android View UI. These examples aren’t extensive and there’s much more you can do with the Photo Picker, so I’d love to hear how you are/plan on using it in your own apps!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eThe \u003ca href=\"https://developer.android.com/training/data-storage/shared/photopicker\"\u003ePhoto Picker\u003c/a\u003e allow us to reduce friction when working with Media selection on Android, along with creating a simpler + consistent experience for users. In this blog post, we’re going to take a quick look at how we can use it in our own apps – both in Composable UI and within activities/fragments.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eLooking to learn Jetpack Compose? Check out my course, \u003ca href=\"https://practicaljetpackcompose.com/\"\u003ePractical Jetpack Compose\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eWhy use the Photo Picker?\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhether you already have media pickers implemented in your app, or are looking at adding support, the Photo Picker gives us some advantages out of the box. \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eMedia Permissions are handled for us, regardless of Android Version. For example, Android 14 saw the introduction of \u003ca href=\"https://developer.android.com/about/versions/14/changes/partial-photo-video-access\"\u003epartial media access\u003c/a\u003e. The Photo Picker handles these permissions for us, so we don’t need to invest in additional effort for implementing and maintaining complex permission flows\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003ePicker availability is managed by the API. If the Photo Picker is available then this will be used, otherwise, the API will use one of the PICK_IMAGES or GET_DOCUMENTS system alternatives as a fallback\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe Photo Picker gives our users a consistent experience across the android ecosystem, while also modernising and simplifying the media selection process. The Photo Picker hides a lot of the noise that comes with the standard system pickers, allowing our users to focus on the desired media selection\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThese are only some of the main advantages for using the photo picker, and i’m sure there are more that others have experience from their migration of traditional approaches.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eImplementation in Activities/Fragments\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen it comes to utilising the photo picker inside of activities or fragments, we need to do two things:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eRegister the result request using a contract that will be used to receive the result\u003c/li\u003e\n\n\n\n\u003cli\u003eCreate the activity request and use the contract to launch it\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe’ll start here by registering our activity/fragment using the \u003cstrong\u003eregisterForActivityResult\u003c/strong\u003e function. When doing this, we need to provide both the contract and callback.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eprivate val picker = registerForActivityResult(//contract) {\n    // callback\n }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor the contract, we will be using \u003cstrong\u003ePickMultipleVisualMedia\u003c/strong\u003e, this is a system intent that will launch the Photo Picker – if the Photo Picker is not available, alternative system pickers will be used instead.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eActivityResultContracts.PickMultipleVisualMedia()\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen using the PickMultipleVisualMedia contract, we can also provide a value for the maximum number of media that can be selected. If not provided, the default value supported by the picker will be used.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003ePickMultipleVisualMedia(10)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlternatively, the \u003cstrong\u003ePickVisualMedia\u003c/strong\u003e contract can be used to allow the selection of a single media item.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eActivityResultContracts.PickVisualMedia()\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eRegardless of the contract being used, we next need to slot this into our \u003cstrong\u003eregisterForActivityResult\u003c/strong\u003e request. Along with the callback that will handle our request – we won’t be implementing the body of this callback in this example, but the callback will simplify provide us with the list of Uris from the multiple media request. If only supporting a single media item via \u003cstrong\u003ePickVisualMedia\u003c/strong\u003e, this will be a Uri instead of a list.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eprivate val picker = registerForActivityResult(ActivityResultContracts.PickMultipleVisualMedia()) { uris -\u0026gt;\n    // handle uris\n }\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith our request defined, we can now trigger a media picker request using the \u003cstrong\u003elaunch\u003c/strong\u003e function on our picker reference. When calling this function, we need to pass a \u003cstrong\u003ePickVisualMediaRequest\u003c/strong\u003e reference containing the supported media type. This takes the form of a VisualMediaType reference that can be either ImageAndVideo, ImageOnly, VideoOnly or SingleMimeType to provide the mimetype that you want the picker to filter by.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epicker.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo))\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhen triggering this launch function, the photo picker will be displayed to the user using the specified constraints. Once the media selection has been confirmed, the result will be delivered to the callback provided to the \u003cstrong\u003eregisterForActivityResult\u003c/strong\u003e function.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eImplementation in Compose\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen it comes to using the photo picker in compose, the developer experience is consistent to using it within an activity/fragment, things only differ slightly for the adaption within the compose world.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe must start by defining our result receiver using the \u003cstrong\u003erememberLaunchForActivityResult\u003c/strong\u003e function. Similar to what we saw in the previous example, this will create a result receiver using the provided contract and callback. The difference here is that this \u003cstrong\u003eremember\u003c/strong\u003e function is specifically for compose and will be remembered across compositions.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e val photoPickerLauncher = rememberLauncherForActivityResult(ActivityResultContracts.PickMultipleVisualMedia(10)) { uris -\u0026gt;\n    // Handle URIs\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this receiver in place we can now use this within our composables to trigger the Photo Picker within our composable UI. Similar to before, we use the \u003cstrong\u003elaunch\u003c/strong\u003e function along with the request that we wish to be used. The same availability applies as above, allowing us to restrict the types of media that is displayed within the Photo Picker.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003ephotoPickerLauncher.launch(\n    PickVisualMediaRequest(\n        ActivityResultContracts.PickVisualMedia.ImageAndVideo\n    )\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eIn the above examples, we’ve learnt how we can adopt the Photo Picker in both our Compose and Android View UI. These examples aren’t extensive and there’s much more you can do with the Photo Picker, so I’d love to hear how you are/plan on using it in your own apps!\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-04-05T00:01:21Z",
  "modifiedTime": "2024-04-05T00:01:22Z"
}
