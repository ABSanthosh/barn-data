{
  "id": "48cab411-1f7b-46a5-aaee-47ec5a5ec2d7",
  "title": "Announcing requireKTX",
  "link": "https://zsmb.co/announcing-requirektx/",
  "description": "Introducing a new library to conveniently require values from common Android types.",
  "author": "Márton Braun",
  "published": "Thu, 17 Jun 2021 18:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 2438,
  "excerpt": "Introducing a new library to conveniently require values from common Android types.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "2021-06-17 • Márton Braun So, I got tired of writing code like this. requireArguments().getString(\"user_id\")!! And seeing others have to write code like this: val channelType: String = inputData.getString(DATA_CHANNEL_TYPE)!! val channelId: String = inputData.getString(DATA_CHANNEL_ID)!! val messageId: String = inputData.getString(DATA_MESSAGE_ID)!! So I created requireKTX. What does it do? It adds extensions so that the code above becomes this: requireArguments().requireString(\"user_id\") And this: val channelType: String = inputData.requireString(DATA_CHANNEL_TYPE) val channelId: String = inputData.requireString(DATA_CHANNEL_ID) val messageId: String = inputData.requireString(DATA_MESSAGE_ID) These extensions exist on various types (Bundle, Intent, WorkManager Data), and for various types of data you’d want to fetch (String, Int, and dozens more). Instead of giving you nullable types or default values, they’ll throw meaningful exceptions (IllegalStateException or IllegalArgumentException) with nicely worded error messages describing why the value couldn’t be fetched. Bonus You also get nicer getOrNull style methods for all these base types and all types you’d want to fetch, so that the possible nullability is explicit: val userId: String? = requireArguments().getStringOrNull(\"user_id\") That’s all! Check out the library on GitHub, give it a star ⭐, add it to your project, send feedback my way! You might also like... A Bit of Gradle Housekeeping While cleaning is traditionally a spring activity, let me invite you to do it at the end of summer this time around. In this article, we'll take a look at some Gradle configuration that you can probably clean up in your Android project. Wrap-up 2021 Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one. The conflation problem of testing StateFlows StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests. All About Opt-In Annotations Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main-content\"\u003e\n\n\n\u003cp\u003e2021-06-17\n•\n\u003ca href=\"https://zsmb.co/authors/zsmb13/\"\u003eMárton Braun\u003c/a\u003e\n\n\n\u003c/p\u003e\n\u003cdiv\u003e\n  \u003cp\u003eSo, I got tired of writing code like this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erequireArguments().getString(\u0026#34;user_id\u0026#34;)!!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd seeing others have to write code like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval channelType: String = inputData.getString(DATA_CHANNEL_TYPE)!!\nval channelId: String = inputData.getString(DATA_CHANNEL_ID)!!\nval messageId: String = inputData.getString(DATA_MESSAGE_ID)!!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo I created \u003ca href=\"https://github.com/zsmb13/requireKTX\"\u003erequireKTX\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"what-does-it-do\"\u003eWhat does it do?\u003c/h3\u003e\n\u003cp\u003eIt adds extensions so that the code above becomes this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erequireArguments().requireString(\u0026#34;user_id\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval channelType: String = inputData.requireString(DATA_CHANNEL_TYPE)\nval channelId: String = inputData.requireString(DATA_CHANNEL_ID)\nval messageId: String = inputData.requireString(DATA_MESSAGE_ID)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese extensions exist on various types (\u003ccode\u003eBundle\u003c/code\u003e, \u003ccode\u003eIntent\u003c/code\u003e, WorkManager \u003ccode\u003eData\u003c/code\u003e), and for various types of data you’d want to fetch (\u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e, and dozens more).\u003c/p\u003e\n\u003cp\u003eInstead of giving you nullable types or default values, they’ll throw meaningful exceptions (\u003ccode\u003eIllegalStateException\u003c/code\u003e or \u003ccode\u003eIllegalArgumentException\u003c/code\u003e) with nicely worded error messages describing why the value couldn’t be fetched.\u003c/p\u003e\n\u003ch3 id=\"bonus\"\u003eBonus\u003c/h3\u003e\n\u003cp\u003eYou also get nicer \u003ccode\u003egetOrNull\u003c/code\u003e style methods for all these base types and all types you’d want to fetch, so that the possible nullability is explicit:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eval userId: String? = requireArguments().getStringOrNull(\u0026#34;user_id\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"thats-all\"\u003eThat’s all!\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/zsmb13/requireKTX\"\u003eCheck out the library on GitHub\u003c/a\u003e, give it a star ⭐, add it to your project, send feedback my way!\u003c/p\u003e\n\n\u003c/div\u003e\n\n\u003chr/\u003e\n\t\t\t\t\t\t   \n\n\n\n\n\n\u003chr/\u003e    \n\u003ch3\u003eYou might also like...\u003c/h3\u003e\n\t\n\t\t\u003ch5\u003e\u003ca href=\"https://zsmb.co/a-bit-of-gradle-housekeeping/\"\u003eA Bit of Gradle Housekeeping\u003c/a\u003e\u003c/h5\u003e\n\t\t\u003cp\u003eWhile cleaning is traditionally a spring activity, let me invite you to do it at the end of summer this time around. In this article, we\u0026#39;ll take a look at some Gradle configuration that you can probably clean up in your Android project.\u003c/p\u003e\n\t\n\t\t\u003ch5\u003e\u003ca href=\"https://zsmb.co/wrap-up-2021/\"\u003eWrap-up 2021\u003c/a\u003e\u003c/h5\u003e\n\t\t\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\n\t\n\t\t\u003ch5\u003e\u003ca href=\"https://zsmb.co/conflating-stateflows/\"\u003eThe conflation problem of testing StateFlows\u003c/a\u003e\u003c/h5\u003e\n\t\t\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\n\t\n\t\t\u003ch5\u003e\u003ca href=\"https://zsmb.co/opt-in-annotations/\"\u003eAll About Opt-In Annotations\u003c/a\u003e\u003c/h5\u003e\n\t\t\u003cp\u003eHave you ever encountered APIs that show warnings or errors when you use them, saying that they\u0026#39;re internal or experimental? In this guide, you\u0026#39;ll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.\u003c/p\u003e\n\t\n\n\n\n\n      \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": null,
  "modifiedTime": null
}
