{
  "id": "18aae45a-9cc8-47b7-903d-dababa3dda45",
  "title": "Composable lambda list during recomposition in Android",
  "link": "https://proandroiddev.com/composable-lambda-list-during-recomposition-in-android-bf798f236ba7?source=rss----c72404660798---4",
  "description": "",
  "author": "Manuel Mato",
  "published": "Sat, 02 Nov 2024 14:36:18 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "androiddev",
    "jetpack-compose",
    "android-app-development",
    "kotlin"
  ],
  "byline": "Manuel Mato",
  "length": 4005,
  "excerpt": "This post is to see how to render a composable list, more at an educational level than a practical one, since in most cases we can use lazy lists. I once had to deal with a screen that painted…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "This post is to see how to render a composable list, more at an educational level than a practical one, since in most cases we can use lazy lists.I once had to deal with a screen that painted several nested lists dynamically, using generic types, quite complex due to the way it was built and also using the hybrid XML + Jetpack Compose system, so in the end I ended up using a composable list, or at least that was the solution I found by reusing the pieces I had available.But again, in most cases this approach will be the exception or you will probably come up with other solutions.Composables listIn this example, the UI will receive three values ​​that will be emitted every second:private val viewTypeState: MutableState\u003cViewType?\u003e = mutableStateOf(null)init { emitViewTypes()}private fun emitViewTypes() { lifecycleScope.launch { delay(1_000) viewTypeState.value = ViewType.Header delay(1_000) viewTypeState.value = ViewType.Body delay(1_000) viewTypeState.value = ViewType.Footer }}The list will be dynamically created in the UI and displayed like this:@Composableprivate fun RenderViews() { val views: MutableList\u003c@Composable () -\u003e Unit\u003e = remember { mutableListOf() } viewTypeState.value?.let { viewType -\u003e val view = getView(text = viewType.title) views.add(view) Column( verticalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.padding(16.dp), ) { views.forEach { view -\u003e view() } } }}@Composableprivate fun getView(text: String): @Composable () -\u003e Unit { return { Text(text = text) }}That is, the getView() method returns a composable lambda that, when invoked, will display a text view.And the RenderViews() method goes through the list of views, invoking them item by item, to display the views on the screen.When running the above code, it looks like the result will be this:Compose list expectedBut it actually shows:Compose list realSo what’s going on?Reference in memory of lambdasWhat happens is that every time the lambda is invoked, the same reference is obtained in memory, so:The Header is emitted, the view with the header is added to the list, and the Header view is displayed.The Body is emitted, the view with the body is added to the list, and the Body view is displayed twice, since the first item that had the value of Header now has the value of Body.The Footer is emitted, the view with the Footer is added to the list, and the Footer view is displayed three times, since the first item and the second item that had the value of Body now have the value of Footer.And so on, the last value emitted is added to the list and affects the previous elements, since the list lambdas have the same reference, so they will always render the same view (Text) with a different value (title):This could be due to how Kotlin handles different lambda instances depending on the context, in this case the let block, even though the content is different.Different contexts to have different lambda referencesTherefore, a solution could have different contexts to generate different instances. In this case, using the when block:@Composableprivate fun RenderViews() { val views: MutableList\u003c@Composable () -\u003e Unit\u003e = remember { mutableListOf() } when (val viewType = viewTypeState.value) { ViewType.Body -\u003e { val view = getView(text = viewType.title) views.add(view) } ViewType.Footer -\u003e { val view = getView(text = viewType.title) views.add(view) } ViewType.Header -\u003e { val view = getView(text = viewType.title) views.add(view) } null -\u003e Unit } Column( verticalArrangement = Arrangement.spacedBy(16.dp), modifier = Modifier.padding(16.dp), ) { views.forEach { view -\u003e view() } }}Thus, calling the getView() method generates different instances:",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*8nScfAbqJD24zynwz7TivQ.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@manuelmato?source=post_page---byline--bf798f236ba7--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Manuel Mato\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*o7sbHHldNjmD6Yl0.\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--bf798f236ba7--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"2460\"\u003eThis post is to see how to render a composable list, more at an educational level than a practical one, since in most cases we can use lazy lists.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e452\"\u003eI once had to deal with a screen that painted several nested lists dynamically, using generic types, quite complex due to the way it was built and also using the \u003cstrong\u003ehybrid XML + Jetpack Compose system\u003c/strong\u003e, so in the end I ended up using a composable list, or at least that was the solution I found by reusing the pieces I had available.\u003c/p\u003e\u003cp id=\"d3f8\"\u003eBut again, in most cases this approach will be the exception or you will probably come up with other solutions.\u003c/p\u003e\u003ch2 id=\"a735\"\u003eComposables list\u003c/h2\u003e\u003cp id=\"cba7\"\u003eIn this example, the UI will receive three values ​​that will be emitted every second:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d176\"\u003eprivate val viewTypeState: MutableState\u0026lt;ViewType?\u0026gt; = mutableStateOf(null)\u003cp\u003einit {\u003cbr/\u003e  emitViewTypes()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eprivate fun emitViewTypes() {\u003cbr/\u003e  lifecycleScope.launch {\u003cbr/\u003e    delay(1_000)\u003cbr/\u003e    viewTypeState.value = ViewType.Header\u003cbr/\u003e    delay(1_000)\u003cbr/\u003e    viewTypeState.value = ViewType.Body\u003cbr/\u003e    delay(1_000)\u003cbr/\u003e    viewTypeState.value = ViewType.Footer\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"beb7\"\u003eThe list will be dynamically created in the UI and displayed like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a3ea\"\u003e@Composable\u003cbr/\u003eprivate fun RenderViews() {\u003cbr/\u003e    val views: MutableList\u0026lt;@Composable () -\u0026gt; Unit\u0026gt; = remember {\u003cbr/\u003e        mutableListOf()\u003cbr/\u003e    }\u003cp\u003e    viewTypeState.value?.let { viewType -\u0026gt;\u003cbr/\u003e        val view = getView(text = viewType.title)\u003cbr/\u003e        views.add(view)\u003c/p\u003e\u003cp\u003e        Column(\u003cbr/\u003e            verticalArrangement = Arrangement.spacedBy(16.dp),\u003cbr/\u003e            modifier = Modifier.padding(16.dp),\u003cbr/\u003e        ) {\u003cbr/\u003e            views.forEach { view -\u0026gt;\u003cbr/\u003e                view()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003eprivate fun getView(text: String): @Composable () -\u0026gt; Unit {\u003cbr/\u003e    return {\u003cbr/\u003e        Text(text = text)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e710\"\u003eThat is, the \u003cem\u003egetView()\u003c/em\u003e method returns a composable lambda that, when invoked, will display a text view.\u003c/p\u003e\u003cp id=\"2ac1\"\u003eAnd the \u003cem\u003eRenderViews()\u003c/em\u003e method goes through the list of views, invoking them item by item, to display the views on the screen.\u003c/p\u003e\u003cp id=\"1343\"\u003eWhen running the above code, it looks like the result will be this:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCompose list expected\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f950\"\u003eBut it actually shows:\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCompose list real\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"04cd\"\u003eSo what’s going on?\u003c/p\u003e\u003ch2 id=\"0d3c\"\u003eReference in memory of lambdas\u003c/h2\u003e\u003cp id=\"e47f\"\u003eWhat happens is that every time the lambda is invoked, \u003cstrong\u003ethe same reference is obtained in memory\u003c/strong\u003e, so:\u003c/p\u003e\u003col\u003e\u003cli id=\"f329\"\u003eThe Header is emitted, the view with the header is added to the list, and the Header view is displayed.\u003c/li\u003e\u003cli id=\"df73\"\u003eThe Body is emitted, the view with the body is added to the list, and the Body view is displayed twice, since the first item that had the value of Header now has the value of Body.\u003c/li\u003e\u003cli id=\"e1ed\"\u003eThe Footer is emitted, the view with the Footer is added to the list, and the Footer view is displayed three times, since the first item and the second item that had the value of Body now have the value of Footer.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"386e\"\u003eAnd so on, the last value emitted is added to the list and affects the previous elements, since\u003cstrong\u003e the list lambdas have the same reference\u003c/strong\u003e, so they will always \u003cstrong\u003erender the same view\u003c/strong\u003e (Text) \u003cstrong\u003ewith a different value\u003c/strong\u003e (title):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4b0d\"\u003e\u003cstrong\u003eThis could be due to how Kotlin handles different lambda instances depending on the context, in this case the \u003cem\u003elet\u003c/em\u003e block, even though the content is different.\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a2a9\"\u003eDifferent contexts to have different lambda references\u003c/h2\u003e\u003cp id=\"58c5\"\u003eTherefore, a solution could have different contexts to generate different instances. In this case, using the when block:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9199\"\u003e@Composable\u003cbr/\u003eprivate fun RenderViews() {\u003cbr/\u003e    val views: MutableList\u0026lt;@Composable () -\u0026gt; Unit\u0026gt; = remember {\u003cbr/\u003e        mutableListOf()\u003cbr/\u003e    }\u003cp\u003e    when (val viewType = viewTypeState.value) {\u003cbr/\u003e        ViewType.Body -\u0026gt; {\u003cbr/\u003e            val view = getView(text = viewType.title)\u003cbr/\u003e            views.add(view)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        ViewType.Footer -\u0026gt; {\u003cbr/\u003e            val view = getView(text = viewType.title)\u003cbr/\u003e            views.add(view)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        ViewType.Header -\u0026gt; {\u003cbr/\u003e            val view = getView(text = viewType.title)\u003cbr/\u003e            views.add(view)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        null -\u0026gt; Unit\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    Column(\u003cbr/\u003e        verticalArrangement = Arrangement.spacedBy(16.dp),\u003cbr/\u003e        modifier = Modifier.padding(16.dp),\u003cbr/\u003e    ) {\u003cbr/\u003e        views.forEach { view -\u0026gt;\u003cbr/\u003e            view()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"84f0\"\u003eThus, calling the \u003cem\u003egetView()\u003c/em\u003e method generates different instances:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-11-01T16:39:48.857Z",
  "modifiedTime": null
}
