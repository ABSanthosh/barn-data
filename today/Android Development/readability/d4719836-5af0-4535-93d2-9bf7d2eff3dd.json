{
  "id": "d4719836-5af0-4535-93d2-9bf7d2eff3dd",
  "title": "How Trello Android converted from Gson to Moshi",
  "link": "https://blog.danlew.net/2021/11/01/how-trello-android-converted-from-gson-to-moshi/",
  "description": "Trello Android recently converted from using Gson to Moshi for handling JSON. It was a bit tricky so I wanted to document the process.(For context, Trello Android primarily parses JSON. We rarely serialize JSON, and thus most of the focus here is on deserializing.)Why Refactor?There were three",
  "author": "Dan Lew",
  "published": "Mon, 01 Nov 2021 14:00:00 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "json",
    "kotlin",
    "android"
  ],
  "byline": "Dan Lew",
  "length": 5992,
  "excerpt": "Trello Android recently converted from using Gson [https://github.com/google/gson] to Moshi [https://github.com/square/moshi] for handling JSON. It was a bit tricky so I wanted to document the process. (For context, Trello Android primarily parses JSON. We rarely serialize JSON, and thus most of the focus here is on deserializing.) Why Refactor? There were three main reasons for the switch from Gson to Moshi: safety, speed, and bad life choices. Safety - Gson does not understand Kotlin’s null",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "Trello Android recently converted from using Gson to Moshi for handling JSON. It was a bit tricky so I wanted to document the process.(For context, Trello Android primarily parses JSON. We rarely serialize JSON, and thus most of the focus here is on deserializing.)Why Refactor?There were three main reasons for the switch from Gson to Moshi: safety, speed, and bad life choices.Safety - Gson does not understand Kotlin’s null safety and will happily place null values into non-null properties. Also, default values only sometimes work (depending on the constructor setup).Speed - Plenty of benchmarks (1, 2, 3) have demonstrated that Moshi is usually faster than Gson. After we converted, we set up some benchmarks to see how real-world parsing compared in our app, and we saw a 2x-3.5x speedup:Bad life choices - Instead of using Gson to parse JSON into simple models, we would write elaborate, confusing, brittle custom deserializers that had entirely too much logic in them. Refactoring gave us an opportunity to correct this architectural snafu.As for why we picked Moshi over competitors (e.g. Kotlin serialization), we generally trust Square's libraries, we've used Moshi in the past for projects (both at work and at home) and felt it worked well. We did not do an in-depth study of alternatives.Step 1 - Feature FlagsThe first step was to ensure that we could use feature flags to switch between using our old Gson implementation and the new Moshi one. I wrote a JsonInterop class which, based on the flag, would either parse all JSON responses using Gson or Moshi.(I opted to avoid using tools like moshi-gson-interop because I wanted to test whether Moshi parsing worked in its entirety. If you’d rather have a mix of Gson and Moshi at the same time, that library would be useful.)Step 2 - Safety ChecksGson gives you opportunities to override the default naming of a key using @SerializedName. Moshi lets you do the same thing with @Json. That's all well and good, but it seemed really easy to me to make a mistake here, where a property is parsed under different names in Gson vs. Moshi.Thus, I wrote some unit tests that would verify that our generated Moshi adapters would have the same outcome as Gson’s parsing. In particular, I tested......that Moshi could generate an adapter (not necessarily a correct one!) for each class we wanted to deserialize. (If it couldn't, Moshi would throw an exception.)...that each field annotated with @SerializedName was also annotated with @Json (using the same key).Between these two checks, it was easy to find when I’d made a mistake updating our classes in later steps.(I can’t include the source here, but basically we used Guava’s ClassPath to gather all our classes, then scan through them for problems.)Step 3 - Remove Gson-Specific ClassesGson allows you to parse generic JSON trees using JsonElement (and friends). We found this useful in some contexts like parsing socket updates (where we wouldn’t know how, exactly, to parse the response model until after some initial processing).Obviously, Moshi is not going to be happy about using Gson’s classes, so we switched to using Map\u003cString, Any?\u003e (and sometimes List\u003cMap\u003cString, Any?\u003e\u003e) for generic trees of data. Both Gson and Moshi can parse these:fun \u003cT\u003e fromJson(map: Map\u003cString, Any?\u003e?, clz: Class\u003cT\u003e): T? { return if (USE_MOSHI) { moshi.adapter(clz).fromJsonValue(map) } else { gson.fromJson(gson.toJsonTree(map), clz) } }In addition, Gson is friendly towards parsing via Readers, but Moshi is not. I found that using BufferedSource was a good alternative, as it can be converted to a Reader for old Gson code.Step 4 - Create Moshi AdaptersThe easiest adapters for Moshi are the ones where you just slap @JsonClass on them and call it a day. Unfortunately, as I mentioned earlier, we had a lot of unfortunate custom deserialization logic in our Gson parser.It’s pretty easy to write a custom Moshi adapter, but because there was so much custom logic in our deserializers, just writing a single adapter wouldn’t cut it. We ended up having to create interstitial models to parse the raw JSON, then adapt from that to the models we’re used to using.To give a concrete example, imagine we have a data class Foo(val count: Int), but the actual JSON we get back is of the form:{ \"data\": { \"count\": 5 } }With Gson, we could just manually look at the tree and grab the count out of the data object, but we have discovered that way lies madness. We'd rather just parse using simple POJOs, but we still want to output a Foo in the end (so we don't have to change our whole codebase).To solve that problem, we’d create new models and use those in custom adapter, like so:@JsonClass(generateAdapter = true) data class JsonFoo(val data: JsonData) @JsonClass(generateAdapter = true) data class JsonData(val count: Int) object FooAdapter { @FromJson fun fromJson(json: JsonFoo): Foo { return Foo(count = json.data.count) } }Voila! Now the parser can still output Foo, but we’re using simple POJOs to model our data. It’s both easier to interpret and easy to test.Step 5 - Iron Out BugsRemember how I said that Gson will happily parse null values into non-null models? It turns out that we were (sadly) relying on this behavior in all sorts of places. In particular, Trello’s sockets often return partial models - so while we’d normally expect, say, a card to come back with a name, in some cases it won’t.That meant having to monitor our crashes for cases where the Moshi would blow up (due to a null value) when Gson would be happy as a clam. This is where feature flags really shine, since you don’t want to have to push a buggy parser on unsuspecting production users!After fixing a dozen of these bugs, I feel like I’ve gained a hearty appreciation for non-JSON technologies with well-defined schemas like protocol buffers. There are a lot of bugs I ran into that simply wouldn’t have happened if we had a contract between the server and the client.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eTrello Android recently converted from using \u003ca href=\"https://github.com/google/gson?ref=blog.danlew.net\"\u003e\u003cu\u003eGson\u003c/u\u003e\u003c/a\u003e to \u003ca href=\"https://github.com/square/moshi?ref=blog.danlew.net\"\u003e\u003cu\u003eMoshi\u003c/u\u003e\u003c/a\u003e for handling JSON. It was a bit tricky so I wanted to document the process.\u003c/p\u003e\u003cp\u003e\u003cem\u003e(For context, Trello Android primarily parses JSON. We rarely serialize JSON, and thus most of the focus here is on deserializing.)\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"why-refactor\"\u003eWhy Refactor?\u003c/h2\u003e\u003cp\u003eThere were three main reasons for the switch from Gson to Moshi: \u003cstrong\u003esafety\u003c/strong\u003e, \u003cstrong\u003espeed\u003c/strong\u003e, and \u003cstrong\u003ebad life choices\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSafety\u003c/strong\u003e - Gson does not understand Kotlin’s null safety and will happily place null values into non-null properties. Also, default values only sometimes work (depending on the constructor setup).\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSpeed\u003c/strong\u003e - Plenty of benchmarks (\u003ca href=\"https://zacsweers.github.io/json-serialization-benchmarking/results/android-polymorphic/?ref=blog.danlew.net\"\u003e\u003cu\u003e1\u003c/u\u003e\u003c/a\u003e, \u003ca href=\"https://www.ericthecoder.com/2020/10/13/benchmarking-gson-vs-jackson-vs-moshi-2020/?ref=blog.danlew.net\"\u003e\u003cu\u003e2\u003c/u\u003e\u003c/a\u003e, \u003ca href=\"https://github.com/fabienrenaud/java-json-benchmark?ref=blog.danlew.net\"\u003e\u003cu\u003e3\u003c/u\u003e\u003c/a\u003e) have demonstrated that Moshi is usually faster than Gson. After we converted, we set up \u003ca href=\"https://developer.android.com/studio/profile/benchmark?ref=blog.danlew.net\"\u003esome benchmarks\u003c/a\u003e to see how real-world parsing compared in our app, and we saw a 2x-3.5x speedup:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://blog.danlew.net/content/images/2021/09/chart.png\" alt=\"\" loading=\"lazy\" width=\"600\" height=\"371\" srcset=\"https://blog.danlew.net/content/images/2021/09/chart.png 600w\"/\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eBad life choices\u003c/strong\u003e - Instead of using Gson to parse JSON into simple models, we would write elaborate, confusing, brittle custom deserializers that had entirely too much logic in them. Refactoring gave us an opportunity to correct this architectural snafu.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eAs for why we picked Moshi over competitors (e.g. \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization?ref=blog.danlew.net\"\u003e\u003cu\u003eKotlin serialization\u003c/u\u003e\u003c/a\u003e), we generally trust Square\u0026#39;s libraries, we\u0026#39;ve used Moshi in the past for projects (both at work and at home) and felt it worked well. We did not do an in-depth study of alternatives.\u003c/p\u003e\u003ch2 id=\"step-1feature-flags\"\u003eStep 1 - Feature Flags\u003c/h2\u003e\u003cp\u003eThe first step was to ensure that we could use feature flags to switch between using our old Gson implementation and the new Moshi one. I wrote a \u003ccode\u003eJsonInterop\u003c/code\u003e class which, based on the flag, would either parse all JSON responses using Gson or Moshi.\u003c/p\u003e\u003cp\u003e(I opted to avoid using tools like \u003ca href=\"https://github.com/slackhq/moshi-gson-interop?ref=blog.danlew.net\"\u003e\u003cu\u003emoshi-gson-interop\u003c/u\u003e\u003c/a\u003e because I wanted to test whether Moshi parsing worked in its entirety. If you’d rather have a mix of Gson and Moshi at the same time, that library would be useful.)\u003c/p\u003e\u003ch2 id=\"step-2safety-checks\"\u003eStep 2 - Safety Checks\u003c/h2\u003e\u003cp\u003eGson gives you opportunities to override the default naming of a key using \u003ccode\u003e@SerializedName\u003c/code\u003e. Moshi lets you do the same thing with \u003ccode\u003e@Json\u003c/code\u003e. That\u0026#39;s all well and good, but it seemed really easy to me to make a mistake here, where a property is parsed under different names in Gson vs. Moshi.\u003c/p\u003e\u003cp\u003eThus, I wrote some unit tests that would verify that our generated Moshi adapters would have the same outcome as Gson’s parsing. In particular, I tested...\u003c/p\u003e\u003cul\u003e\u003cli\u003e...that Moshi could generate an adapter (not necessarily a correct one!) for each class we wanted to deserialize. (If it couldn\u0026#39;t, Moshi would throw an exception.)\u003c/li\u003e\u003cli\u003e...that each field annotated with \u003ccode\u003e@SerializedName\u003c/code\u003e was also annotated with \u003ccode\u003e@Json\u003c/code\u003e (using the same key).\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBetween these two checks, it was easy to find when I’d made a mistake updating our classes in later steps.\u003c/p\u003e\u003cp\u003e(I can’t include the source here, but basically we used \u003ca href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/reflect/ClassPath.java?ref=blog.danlew.net\"\u003eGuava’s ClassPath\u003c/a\u003e to gather all our classes, then scan through them for problems.)\u003c/p\u003e\u003ch2 id=\"step-3remove-gson-specific-classes\"\u003eStep 3 - Remove Gson-Specific Classes\u003c/h2\u003e\u003cp\u003eGson allows you to parse generic JSON trees using \u003ca href=\"https://www.javadoc.io/doc/com.google.code.gson/gson/2.8.6/com.google.gson/com/google/gson/JsonElement.html?ref=blog.danlew.net\"\u003e\u003cu\u003eJsonElement\u003c/u\u003e\u003c/a\u003e (and friends). We found this useful in some contexts like parsing socket updates (where we wouldn’t know how, exactly, to parse the response model until after some initial processing).\u003c/p\u003e\u003cp\u003eObviously, Moshi is not going to be happy about using Gson’s classes, so we switched to using \u003ccode\u003eMap\u0026lt;String, Any?\u0026gt;\u003c/code\u003e (and sometimes \u003ccode\u003eList\u0026lt;Map\u0026lt;String, Any?\u0026gt;\u0026gt;\u003c/code\u003e) for generic trees of data. Both Gson and Moshi can parse these:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efun \u0026lt;T\u0026gt; fromJson(map: Map\u0026lt;String, Any?\u0026gt;?, clz: Class\u0026lt;T\u0026gt;): T? {\n  return if (USE_MOSHI) {\n    moshi.adapter(clz).fromJsonValue(map)\n  }\n  else {\n    gson.fromJson(gson.toJsonTree(map), clz)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn addition, Gson is friendly towards parsing via \u003ca href=\"https://docs.oracle.com/javase/7/docs/api/java/io/Reader.html?ref=blog.danlew.net\"\u003e\u003cu\u003eReaders\u003c/u\u003e\u003c/a\u003e, but Moshi is not. I found that using \u003ca href=\"https://square.github.io/okio/2.x/okio/okio/-buffered-source/index.html?ref=blog.danlew.net\"\u003e\u003cu\u003eBufferedSource\u003c/u\u003e\u003c/a\u003e was a good alternative, as it can be converted to a Reader for old Gson code.\u003c/p\u003e\u003ch2 id=\"step-4create-moshi-adapters\"\u003eStep 4 - Create Moshi Adapters\u003c/h2\u003e\u003cp\u003eThe easiest adapters for Moshi are the ones where you just slap \u003ccode\u003e@JsonClass\u003c/code\u003e on them and call it a day. Unfortunately, as I mentioned earlier, we had a lot of unfortunate custom deserialization logic in our Gson parser.\u003c/p\u003e\u003cp\u003eIt’s pretty easy to \u003ca href=\"https://github.com/square/moshi?ref=blog.danlew.net#custom-type-adapters\"\u003e\u003cu\u003ewrite a custom Moshi adapter\u003c/u\u003e\u003c/a\u003e, but because there was \u003cem\u003eso much\u003c/em\u003e custom logic in our deserializers, just writing a single adapter wouldn’t cut it. We ended up having to create interstitial models to parse the raw JSON, then adapt from that to the models we’re used to using.\u003c/p\u003e\u003cp\u003eTo give a concrete example, imagine we have a \u003ccode\u003edata class Foo(val count: Int)\u003c/code\u003e, but the actual JSON we get back is of the form:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;data\u0026#34;: { \n    \u0026#34;count\u0026#34;: 5\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith Gson, we could just manually look at the tree and grab the count out of the \u003ccode\u003edata\u003c/code\u003e object, but we have discovered that way lies madness. We\u0026#39;d rather just parse using simple POJOs, but we still want to output a Foo in the end (so we don\u0026#39;t have to change our whole codebase).\u003c/p\u003e\u003cp\u003eTo solve that problem, we’d create new models and use those in custom adapter, like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@JsonClass(generateAdapter = true) data class JsonFoo(val data: JsonData)\n\n@JsonClass(generateAdapter = true) data class JsonData(val count: Int)\n\nobject FooAdapter {\n  @FromJson\n  fun fromJson(json: JsonFoo): Foo {\n    return Foo(count = json.data.count)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eVoila! Now the parser can still output Foo, but we’re using simple POJOs to model our data. It’s both easier to interpret and easy to test.\u003c/p\u003e\u003ch2 id=\"step-5iron-out-bugs\"\u003eStep 5 - Iron Out Bugs\u003c/h2\u003e\u003cp\u003eRemember how I said that Gson will happily parse null values into non-null models? It turns out that we were (sadly) relying on this behavior in all sorts of places. In particular, Trello’s sockets often return partial models - so while we’d normally expect, say, a card to come back with a name, in some cases it won’t.\u003c/p\u003e\u003cp\u003eThat meant having to monitor our crashes for cases where the Moshi would blow up (due to a null value) when Gson would be happy as a clam. This is where feature flags really shine, since you don’t want to have to push a buggy parser on unsuspecting production users!\u003c/p\u003e\u003cp\u003eAfter fixing a dozen of these bugs, I feel like I’ve gained a hearty appreciation for non-JSON technologies with well-defined schemas like \u003ca href=\"https://developers.google.com/protocol-buffers?ref=blog.danlew.net\"\u003e\u003cu\u003eprotocol buffers\u003c/u\u003e\u003c/a\u003e. There are a lot of bugs I ran into that simply wouldn’t have happened if we had a contract between the server and the client.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2021-11-01T14:00:00Z",
  "modifiedTime": "2021-11-01T14:00:08Z"
}
