{
  "id": "a8a21e0a-2e01-49f8-943a-869f0a3c9f47",
  "title": "Gradle dependency license validation",
  "link": "https://code.cash.app/gradle-dependency-license-validation",
  "description": "",
  "author": "",
  "published": "2021-06-08T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "Jake Wharton",
  "length": 2380,
  "excerpt": "Six years ago we added a screen to the Android Cash App to display the open source libraries we use and their licenses. This screen had to be updated manually, which meant it occasionally was missing a library or displayed one no longer in use.",
  "siteName": "Cash App Code Blog",
  "favicon": "https://code.cash.app/assets/icon-196.png",
  "text": "Posted by Jake Wharton on June 8, 2021 Six years ago we added a screen to the Android Cash App to display the open source libraries we use and their licenses. This screen had to be updated manually, which meant it occasionally was missing a library or displayed one no longer in use. There are existing Gradle plugins for aggregating license info from your dependencies, but they usually produce an HTML page for display in a WebView which does not meet our UI requirements. In a recent hack week I sought to solve this in a way where we could retain the same UI but automate discovering the libraries and their licenses. However, once you start tugging on this rope, other interesting problems start to fall out: We use short names like “Apache 2”, but the raw license data uses long names (“The Apache Software License, Version 2.0”) and URLs (http://www.apache.org/licenses/LICENSE-2.0.txt). How do we map between them? The license name and URL of each library will vary even when they refer to the same license (http://www.apache.org/licenses/LICENSE-2.0.txt vs. http://www.apache.org/licenses/LICENSE-2.0). How do we normalize these? As we’re now parsing the license information of our dependencies, how do we ensure only accepted licenses are in use? The SPDX License List gives us the tools to solve both #1 and #2. By using its list of standard license URLs and adding additional variants from the wild, each license can be normalized to a SPDX identifier. This identifier is short (such as “Apache-2.0”) and very similar to what we’re already displaying. With each license now mapped to a SPDX identifier, solving #3 is as simple as creating an allow-list of identifiers and failing the build if a disallowed license shows up. Finally, let’s not forget our original goal was automating the data behind the open source screen. The normalized license data can be serialized as JSON and either be bundled directly or further manipulated before displaying. All of this functionality is available in a new Gradle plugin called Licensee. Despite being driven by the needs of our Android app, the plugin should work for any Gradle-based project. And as its documentation details, there is support for a bunch of edge cases like internal dependencies, commercial SDKs, and non-standard licenses that show up in real-world projects.",
  "image": "https://code.cash.app/assets/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n\n  \u003cdiv\u003e\u003cp\u003e\n    Posted by\n    \u003ca href=\"https://mastodon.jakewharton.com/@jw\"\u003eJake Wharton\u003c/a\u003e\n    \n      \u003cspan\u003eon \u003c/span\u003e\u003ctime datetime=\"2021-06-08 00:00:00 +0000\"\u003eJune  8, 2021\u003c/time\u003e\n    \n  \u003c/p\u003e\u003c/div\u003e\n\n  \u003cp\u003eSix years ago we added a screen to the Android Cash App to display the open source libraries we use and their licenses. This screen had to be updated manually, which meant it occasionally was missing a library or displayed one no longer in use.\u003c/p\u003e\n\n\n\n\u003cvideo autoplay=\"\" muted=\"\" loop=\"\" height=\"540\"\u003e\n\u003csource src=\"https://code.cash.app/assets/2021-06/casha-oss.mp4\" type=\"video/mp4\"/\u003e\n\u003c/video\u003e\n\n\u003cp\u003eThere are existing Gradle plugins for aggregating license info from your dependencies, but they usually produce an HTML page for display in a WebView which does not meet our UI requirements. In a recent hack week I sought to solve this in a way where we could retain the same UI but automate discovering the libraries and their licenses.\u003c/p\u003e\n\n\u003cp\u003eHowever, once you start tugging on this rope, other interesting problems start to fall out:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eWe use short names like “Apache 2”, but the raw license data uses long names (“The Apache Software License, Version 2.0”) and URLs (http://www.apache.org/licenses/LICENSE-2.0.txt). How do we map between them?\u003c/li\u003e\n  \u003cli\u003eThe license name and URL of each library will vary even when they refer to the same license (http://www.apache.org/licenses/LICENSE-2.0.txt vs. http://www.apache.org/licenses/LICENSE-2.0). How do we normalize these?\u003c/li\u003e\n  \u003cli\u003eAs we’re now parsing the license information of our dependencies, how do we ensure only accepted licenses are in use?\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://spdx.org/licenses/\"\u003eSPDX License List\u003c/a\u003e gives us the tools to solve both #1 and #2. By using its list of standard license URLs and adding additional variants from the wild, each license can be normalized to a SPDX identifier. This identifier is short (such as “Apache-2.0”) and very similar to what we’re already displaying.\u003c/p\u003e\n\n\u003cp\u003eWith each license now mapped to a SPDX identifier, solving #3 is as simple as creating an allow-list of identifiers and failing the build if a disallowed license shows up.\u003c/p\u003e\n\n\u003cp\u003eFinally, let’s not forget our original goal was automating the data behind the open source screen. The normalized license data can be serialized as JSON and either be bundled directly or further manipulated before displaying.\u003c/p\u003e\n\n\u003cp\u003eAll of this functionality is available in a new Gradle plugin called \u003ca href=\"https://github.com/cashapp/licensee\"\u003eLicensee\u003c/a\u003e. Despite being driven by the needs of our Android app, the plugin should work for any Gradle-based project. And as its documentation details, there is support for a bunch of edge cases like internal dependencies, commercial SDKs, and non-standard licenses that show up in real-world projects.\u003c/p\u003e\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2021-06-08T00:00:00Z",
  "modifiedTime": null
}
