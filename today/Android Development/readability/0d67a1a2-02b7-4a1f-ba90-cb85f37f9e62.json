{
  "id": "0d67a1a2-02b7-4a1f-ba90-cb85f37f9e62",
  "title": "Displaying HTML tags on TextView the right way",
  "link": "https://saket.me/html-tags-textview/",
  "description": "While going through the codebase of a former client, I found that I was using four different ways for showing HTML on Android. This made me realize that I didn’t really know what the correct way of showing them is and I’ve always hammered my way using trial \u0026 error until the HTML tags have showed up. Embarrassed, I decided to explore how […] The post Displaying HTML tags on TextView the right way appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Thu, 29 Jun 2017 12:59:12 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Android",
    "html",
    "spans",
    "textview"
  ],
  "byline": "Saket Narayan",
  "length": 4228,
  "excerpt": "A brief explanation of how Android uses spans for displaying HTML on TextView and why Resources#getString() is the wrong way to generate them",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "While going through the codebase of a former client, I found that I was using four different ways for showing HTML on Android. This made me realize that I didn’t really know what the correct way of showing them is and I’ve always hammered my way using trial \u0026 error until the HTML tags have showed up. Embarrassed, I decided to explore how HTML parsing internally works and learned that they’re actually fairly simple to understand, even for someone who doesn’t understand how text is drawn on the canvas. I’m fairly certain that I’m not alone in this and we can confirm this by taking a small quiz. Here are 4 potential ways of showing HTML on TextView. Your job is to guess their output — whether the HTML characters will show up or not. 1. Using TextView#setText() \u003cem\u003e// strings.xml:\u003c/em\u003e \u003cstring name=\"what_the_html\"\u003e\u003cb\u003eWhat\u003c/b\u003e \u003ci\u003ethe\u003c/i\u003e \u003cu\u003eHtml\u003c/u\u003e\u003c/string\u003e \u003cem\u003e// Activity.java:\u003c/em\u003e textView.setText(R.string.what_the_html); 2. Using Resources#getString() textView.setText(getString(R.string.what_the_html)); 3. Using Html.fromHtml() textView.setText( Html.fromHtml( getString(R.string.what_the_html) ) ); 4. Using Html.fromHtml() + CDATA \u003cem\u003e// strings.xml:\u003c/em\u003e \u003cstring name=\"what_the_html\"\u003e \u003cstrong\u003e\u003c![CDATA[\u003c/strong\u003e \u003cb\u003eWhat\u003c/b\u003e \u003ci\u003ethe\u003c/i\u003e \u003cu\u003eHtml\u003c/u\u003e \u003cstrong\u003e?]]\u003e\u003c/strong\u003e \u003c/string\u003e // Activity.java: \u003c/em\u003etextView.setText( Html.fromHtml( getString(R.string.what_the_html) ) ); If you failed to guess that only #1 and #4 will correctly show HTML, then you may continue reading my findings and learn what is happening. Problem: String vs CharSequence The first step in my understanding was to learn that TextView#setText() accepts a CharSequence whereas Resources#getString() returns a String and that these two classes are not always interchangeable. The reason we’re still able to pass a String is because it implements CharSequence. The other implementation of CharSequence that we need to instead use is Spanned, which supports modifying the visual representation of text by using something known as “spans”. Spans are tiny objects that contain information about how a piece of text should be drawn and Android uses them heavily across the framework. Some common examples include: StyleSpan, for bold and italic text UnderlineSpan, for underlined text TypefaceSpan, for using custom fonts ImageSpan, for inserting images (e.g., non-Android emojis) URLSpan, for hyperlinking URLs Fun fact #1: The blinking cursor you see in an EditText is implemented using a span. Fun fact #2: Spans are also used for highlighting text, when we long press on a TextView or an EditText. Solution Now when a piece of HTML has to be parsed, Android uses the same span objects for converting the HTML tags into a format that TextView can understand and draw on screen. In order to generate these, Android offers us two options: 1. Resources#getText() Resources#getText() parses all HTML tags in a string resource and returns a “styled” CharSequence object. This should be the preferred way whenever HTML has to be displayed from a string resource and the resource ID cannot be used: CharSequence styledText = getText(R.string.what_the_html); textView.setText(styledText); The reason why using Resources#getString() is wrong can also be understood by reading its source. It internally calls Resources#getText() and converts it to a String, throwing away all the styling: // Resources.java: public String getString(@StringRes int resId) { return getText(resId).toString(); } Resources#getText() is also what TextView#setText(@StringRes int) internally uses when a resource ID is passed instead of a String. 2. Html.fromHtml() Html.fromHtml() is what Resources#getText() internally uses for parsing HTML tags. This can directly be used in cases where HTML is dynamically generated. Similar to Resources#getText(), this method returns a Spanned object: // Html.java: public static Spanned fromHtml(String source) { ... } To conclude: use Resources#getText() instead of Resources#getString() for displaying HTML from a String resource file and Html.fromHtml() for HTML from Java source code. If you have any questions about spans (or life in general) or something to share, feel free to @ me on Twitter.",
  "image": "https://saket.me/wp-content/uploads/2017/06/HTML-on-TextView.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eWhile going through the codebase of a former client, I found that I was using four different ways for showing HTML on Android. This made me realize that I didn’t really know what the correct way of showing them is and I’ve always hammered my way using trial \u0026amp; error until the HTML tags have showed up.\u003c/p\u003e\n\u003cp\u003eEmbarrassed, I decided to explore how HTML parsing internally works and learned that they’re actually fairly simple to understand, even for someone who doesn’t understand how text is drawn on the canvas.\u003c/p\u003e\n\u003cp\u003eI’m fairly certain that I’m not alone in this and we can confirm this by taking a small quiz. Here are 4 \u003cstrong\u003epotential\u003c/strong\u003e ways of showing HTML on TextView. Your job is to guess their output — whether the HTML characters will show up or not.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Using TextView#setText()\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;em\u0026gt;// strings.xml:\u0026lt;/em\u0026gt;\n\u0026lt;string name=\u0026#34;what_the_html\u0026#34;\u0026gt;\u0026lt;b\u0026gt;What\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;the\u0026lt;/i\u0026gt; \u0026lt;u\u0026gt;Html\u0026lt;/u\u0026gt;\u0026lt;/string\u0026gt;\n\n\u0026lt;em\u0026gt;// Activity.java:\u0026lt;/em\u0026gt;\ntextView.setText(R.string.what_the_html);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2. Using Resources#getString()\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etextView.setText(getString(R.string.what_the_html));\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3. Using Html.fromHtml()\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etextView.setText(\n  Html.fromHtml(\n    getString(R.string.what_the_html)\n  )\n);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4. Using Html.fromHtml() + CDATA\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;em\u0026gt;// strings.xml:\u0026lt;/em\u0026gt;\n\u0026lt;string name=\u0026#34;what_the_html\u0026#34;\u0026gt;\n  \u0026lt;strong\u0026gt;\u0026lt;![CDATA[\u0026lt;/strong\u0026gt;\n    \u0026lt;b\u0026gt;What\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;the\u0026lt;/i\u0026gt; \u0026lt;u\u0026gt;Html\u0026lt;/u\u0026gt;\n  \u0026lt;strong\u0026gt;?]]\u0026gt;\u0026lt;/strong\u0026gt;\n\u0026lt;/string\u0026gt;\n\n// Activity.java:\n\u0026lt;/em\u0026gt;textView.setText(\n  Html.fromHtml(\n    getString(R.string.what_the_html)\n  )\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you failed to guess that only #1 and #4 will correctly show HTML, then you may continue reading my findings and learn what is happening.\u003c/p\u003e\n\u003ch4\u003eProblem: String vs CharSequence\u003c/h4\u003e\n\u003cp\u003eThe first step in my understanding was to learn that \u003ccode\u003eTextView#setText()\u003c/code\u003e accepts a \u003ccode\u003eCharSequence\u003c/code\u003e whereas \u003ccode\u003eResources#getString()\u003c/code\u003e returns a String and that these two classes are not always interchangeable. The reason we’re still able to pass a \u003ccode\u003eString\u003c/code\u003e is because it implements \u003ccode\u003eCharSequence\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe other implementation of CharSequence that we need to instead use is \u003ccode\u003eSpanned\u003c/code\u003e, which supports modifying the visual representation of text by using something known as “spans”. Spans are tiny objects that contain information about how a piece of text should be drawn and Android uses them heavily across the framework. Some common examples include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/android/text/style/StyleSpan.html\"\u003e\u003ccode\u003eStyleSpan\u003c/code\u003e\u003c/a\u003e, for bold and italic text\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/android/text/style/UnderlineSpan.html\"\u003e\u003ccode\u003eUnderlineSpan\u003c/code\u003e\u003c/a\u003e, for underlined text\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/android/text/style/TypefaceSpan.html\"\u003e\u003ccode\u003eTypefaceSpan\u003c/code\u003e\u003c/a\u003e, for using custom fonts\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/android/text/style/ImageSpan.html\"\u003e\u003ccode\u003eImageSpan\u003c/code\u003e\u003c/a\u003e, for inserting images (e.g., non-Android emojis)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://saket.me/better-url-handler-textview-android/\"\u003e\u003ccode\u003eURLSpan\u003c/code\u003e\u003c/a\u003e, for hyperlinking URLs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eFun fact #1: The blinking cursor you see in an EditText is implemented using a span.\u003cbr/\u003e\nFun fact #2: Spans are also used for highlighting text, when we long press on a TextView or an EditText.\u003c/em\u003e\u003c/p\u003e\n\u003ch4\u003eSolution\u003c/h4\u003e\n\u003cp\u003eNow when a piece of HTML has to be parsed, Android uses the same span objects for converting the HTML tags into a format that TextView can understand and draw on screen. In order to generate these, Android offers us two options:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Resources#getText()\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eResources#getText()\u003c/code\u003e parses all HTML tags in a string resource and returns a “styled” CharSequence object. This should be the preferred way whenever HTML has to be displayed from a string resource and the resource ID cannot be used:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCharSequence styledText = getText(R.string.what_the_html);\ntextView.setText(styledText);\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reason why using \u003ccode\u003eResources#getString()\u003c/code\u003e is wrong can also be understood by reading its source. It internally calls \u003ccode\u003eResources#getText()\u003c/code\u003e and converts it to a String, throwing away all the styling:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Resources.java:\npublic String getString(@StringRes int resId) {\n  return getText(resId).toString();\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eResources#getText()\u003c/code\u003e is also what \u003ccode\u003eTextView#setText(@StringRes int)\u003c/code\u003e internally uses when a resource ID is passed instead of a String.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. Html.fromHtml()\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eHtml.fromHtml()\u003c/code\u003e is what \u003ccode\u003eResources#getText()\u003c/code\u003e internally uses for parsing HTML tags. This can directly be used in cases where HTML is dynamically generated. Similar to \u003ccode\u003eResources#getText()\u003c/code\u003e, this method returns a \u003ccode\u003eSpanned\u003c/code\u003e object:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Html.java:\npublic static Spanned fromHtml(String source) {\n  ...\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo conclude: use \u003ccode\u003eResources#getText()\u003c/code\u003e instead of \u003ccode\u003eResources#getString()\u003c/code\u003e for displaying HTML from a String resource file and \u003ccode\u003eHtml.fromHtml()\u003c/code\u003e for HTML from Java source code.\u003c/p\u003e\n\u003cp\u003eIf you have any questions about spans (or life in general) or something to share, feel free to \u003ca href=\"https://twitter.com/Saketme\"\u003e@ me on Twitter\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2017-06-29T12:59:12Z",
  "modifiedTime": "2018-03-25T16:48:32Z"
}
