{
  "id": "2c69491f-7a24-45d9-b4fa-b3c221d11096",
  "title": "Kotlin Generics Explained: Once Upon a Type…",
  "link": "https://proandroiddev.com/understanding-kotlin-generics-through-a-fantasy-story-6143b49e0c4d?source=rss----c72404660798---4",
  "description": "",
  "author": "Suhyeon Kim",
  "published": "Sat, 19 Apr 2025 23:30:21 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "android-app-development",
    "generics",
    "android",
    "kotlin"
  ],
  "byline": "Suhyeon Kim",
  "length": 15736,
  "excerpt": "Understanding Generics in Kotlin can be tough for beginners; trust me, I’ve been there. Let me tell you a little fantasy story to understand them easily. In the land of Generics, three Android heroes…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Kotlin Generics Explained: Once Upon a Type…Understanding Generics in Kotlin can be tough for beginners; trust me, I’ve been there. Let me tell you a little fantasy story to understand them easily.After reading this, you will be able to :Understand how covariant, contravariant, and invariant types work(with in, out keywords).Understand that Kotlin erases type information at runtime and how reified keyword works.Learn use-site variance, star-projections, and null safety in Generics.Discover how Generics are applied in the real world(in Kotlin APIs).Once Upon a Type…Note: The story has some embellishments to fit the narrative.In the land of Generics, three Android heroes — Warrior, Mage, and Archer — embarked on a quest to defeat the legendary Lord Ambiguous, who threatened the land of Generics.They had to pass through the Forbidden Forest to reach the Lord Ambiguous, which taught them the variance rules in the land of Generics.Table of ContentsChapter 1: The Mystic Gate and InvarianceChapter 2: The Magical Scroll and CovarianceChapter 3: The Lord Ambiguous and ContravarianceChapter 4: The Final Battle and Type ErasureChapter 5: The Spell of ReifiedChapter 6: The EndingBonus Chapter: Advanced Kotlin GenericsChapter 1: The Mystic Gate and InvarianceAt the entrance of the Forbidden Forest stood the Mystic Gate.A stern gatekeeper materialized. “Halt! If you are a warrior, only those who carry Sheath\u003cSword\u003e may enter.”The warrior confidently held a Sheath\u003cExcalibur\u003e, but despite Excalibur being a subtype of Sword, the gatekeeper refused to let them pass.open class Swordclass Excalibur : Sword()class Sheath\u003cT\u003e(val item: T)val sword: Sheath\u003cSword\u003e = Sheath\u003cExcalibur\u003e(Excalibur()) // ❌ Compile Error: Type mismatch!val excalibur: Sheath\u003cExcalibur\u003e = Sheath\u003cSword\u003e(Sword()) // ❌ Compile Error: Type mismatch!The rule was clear. Even if Excalibur is a Sword, Sheath\u003cExcalibur\u003e is not a subtype of Sheath\u003cSword\u003e(and vice versa).Explanation — Variance and InvarianceIn Kotlin, variance defines how subtyping between complex types relates to subtyping between their type parameters.Generic types are invariant by default(written simply as \u003cT\u003e), which means the type parameter must match exactly. No substitutions with subtypes or supertypes are allowed for the generic type itself.That’s because invariance allows you to read/write. If Kotlin allowed you to treat Sheath\u003cExcalibur\u003e as Sheath\u003cSword\u003e, you might read an Excalibur safely, but attempting to write a basic Sword back into it would break type safety (as the variable expects a Sheath\u003cExcalibur\u003e). Invariance prevents potential conflicts by ensuring an exact type match, thus ensuring the safety of both read and write operations.// ✅ Invariance allows you to read/writeclass Sheath\u003cT\u003e(private var item: T) { fun get(): T = item fun replace(newItem: T) { item = newItem }}Chapter 2: The Magical Scroll and CovarianceAfter passing through the Mystic Gate with some refactoring, the heroes found a hidden Knowledge Vault full of magical bookshelves.Mage approached a magical bookshelf BookShelf\u003cout T\u003e.She could read all kinds of scrolls: FireScroll, IceScroll, and so on.But every time she tried to add a new scroll… the bookshelf refused.open class Scrollclass FireScroll : Scroll()class IceScroll : Scroll()class Bookshelf\u003cout T\u003e(val scroll: T) { fun read(): T = scroll // ✅ // fun add(newScroll: T) { ... } // ❌ Compile error: T is declared as 'out'}val fireShelf: BookShelf\u003cFireScroll\u003e = BookShelf(FireScroll())val generalShelf: BookShelf\u003cScroll\u003e = fireShelf // ✅The vault was covariant. It allowed her to safely read more specific types within a general type, but didn’t allow for any mutable operations.Explanation — Covariance with ‘out’Covariance, declared with the out keyword (out T), means you can safely read values of type T, but you cannot write to it(read-only). This is because the actual object might be a subtype of T, and writing something of type T might break type safety.This explains why List\u003cout E\u003e from Kotlin Collections can read elements of type T from the list, but adding elements is not allowed, since the list might internally be holding a more specific type than T.// Declarationpublic interface List\u003cout E\u003e : Collection\u003cE\u003e { ... }// Usageval children: List\u003cChild\u003e = listOf(Child())val parents: List\u003cParent\u003e = children // ✅While MutableList\u003cE\u003e is invariant, read/write access is supported, so no substitutions with subtypes or supertypes are allowed.// Declarationpublic interface MutableList\u003cE\u003e : List\u003cE\u003e, MutableCollection\u003cE\u003e { ... }// Usageval children: MutableList\u003cChild\u003e = mutableListOf(Child())// val parents: MutableList\u003cParent\u003e = children // ❌ Compile error: Type mismatch.Chapter 3: The Lord Ambiguous and ContravarianceAt last, the heroes reached the Lord Ambiguous.No one knew what kind of damage would be most effective. The Lord Ambiguous revealed nothing; his weakness remained a mystery. But he could take damage. Any kind.Each hero tried what they could:The warrior attacked with DamageThe mage unleashed FireDamageThe archer struck with ArrowDamageAnd the Lord Ambiguous… took all the damages.open class Damageclass FireDamage : Damage()class ArrowDamage : Damage()class Enemy\u003cin T\u003e { fun takeHit(damage: T) { println(\"The enemy took damage: $damage\") } // fun getWeakness(): T { } // ❌ Compile error: T is declared as 'in'}val enemy = Enemy\u003cDamage\u003e()enemy.takeHit(Damage()) // ✅enemy.takeHit(FireDamage()) // ✅enemy.takeHit(ArrowDamage()) // ✅With the Enemy\u003cin T\u003e type, the heroes could put in many forms of attack, but could never inspect the actual type.Explanation — Contravariance with ‘in’With contravariance, expressed with the in keyword (in T), you can safely write values of type T, but you cannot read from it. This is useful when you're passing data into a generic type, like a consumer. Kotlin allows you to pass a T value into the structure because any supertype of can safely accept it T, but reading from it is unsafe since the actual contents might be of a more general type.This explains why Comparable\u003cin T\u003e in Kotlin can safely write values of type T, but does not involve reading aT value.// Declarationpublic interface Comparable\u003cin T\u003e { public operator fun compareTo(other: T): Int}Since Comparable only needs to accept values to compare against, we don’t need to know the exact type inside — we just need to be sure we can safely pass a T. This makes it a perfect case for contravariant design with in T.Chapter 4: The Final Battle and Type ErasureThe Lord Ambiguous roared in fury. Despite all their knowledge of variance, despite every type-safe strike… it still stood. “You know how to attack,” it growled, “but do you truly know what I am?”Then the Mage recalled something she read in the Knowledge Vault:“In this land of Generics, much of the specific type information is lost after the initial checks. It’s called… Type Erasure.”That meant they couldn’t check the enemy’s actual type at runtime. During the runtime, everything specific often just looked like * — a star-projection, representing some type, but unknown.Explanation — Runtime Type ErasureIn Kotlin(as in Java), generic type arguments are erased at runtime. This means that although you may write and interact with a List\u003cInt\u003e or List\u003cString\u003e at compile time, at runtime, both types are simply treated as List\u003c*\u003e.This process, known as the Type Erasure, does not retain generic type information in its type system at runtime. This happens mainly for historical reasons(ensuring compatibility with older Java versions that didn’t have generics), and to avoid potential runtime performance overhead associated with carrying detailed type information for every generic instance.Note: Some type information can be retained in specific contexts, like superclass tokens or reflection on class definitions themselves. Please refer to more: https://www.baeldung.com/java-super-type-tokensConsequently, runtime type safety cannot distinguish between generic instantiations like List\u003cInt\u003e and List\u003cString\u003e.// ❌ Runtime error: Both constructor have the same JVM signatureclass Foo(val ints: List\u003cInt\u003e) { constructor(strings: List\u003cString\u003e) : this(strings.map { it.toInt() })}But due to type erasure, both constructors are treated to have the same JVM method signature, and it error will occur at runtime. (To solve constructor/function signature clashes like this, factory functions or using @JvmName might help. Please refer to more: https://kt.academy/article/ek-factory-functions)Note: Type erasure does not mean generics are useless! It’s only after these strict compile-time checks pass that the specific type information is typically erased, making it unavailable for inspection at runtime.Chapter 5: The Spell of ReifiedSince the generic type arguments are erased at runtime, the heroes couldn’t guess the proper weakness of the Lord Ambiguous.fun \u003cT : Damage\u003e isWeakTo(): Boolean { // ❌ Compile error: Cannot check for instance of erased type: T // return T is hiddenWeakness }But Mage knew one ancient technique, an inline spell with reified type that preserved type information even in runtime.She cast:inline fun \u003creified T : Damage\u003e isWeakTo(): Boolean { return hiddenWeakness is T // ✅ Check becomes possible at runtime}val weakToFire = isWeakTo\u003cFireDamage\u003e()println(\"Is weak to FireDamage? $weakToFire\") // Output: falseval weakToIce = isWeakTo\u003cIceDamage\u003e()println(\"Is weak to IceDamage? $weakToIce\") // Output: trueFor once, the spell whispered back the truth at runtime. The Lord Ambiguous was vulnerable to IceDamage!Explanation — Inline Reified Type ParametersNormally, as discussed with Type Erasure, you lose access to the specific generic type argument T at runtime. Trying to check hiddenWeakness is T results in a compile error because T’s specific type information isn’t preserved. But if you use reified with an inline function, Kotlin allows you to use is, as, and even T::class safely at runtime.When you mark a function with inline, the compiler doesn’t just generate a standard function call. Instead, it copies the bytecode of the inline function directly into the location where the function is called. This can sometimes improve performance, especially with lambda arguments, by avoiding the overhead of creating function objects.With inline +reified keyword, the function’s code is being copied directly to the call site, the compiler knows the actual type argument being used at that specific call site. Within the context of that specific inline function call, the type information is not erased, making it “reified”. This allows you to perform runtime operations that are normally forbidden for generic types:Type checks: value is TType casts: value as TAccessing the type’s KClass: T::class (e.g., T::class.java)Note: This only works because the code is inlined. Also means reified type parameters can only be used with inline functions. Please refer to more:https://kotlinlang.org/docs/inline-functions.html#reified-type-parametersThis also explains why operations like filterIsInstance from Kotlin Collections, can keep elements of type T with no reflection needed:// Declarationinline fun \u003creified R\u003e Iterable\u003c*\u003e.filterIsInstance(): List\u003c...\u003e {...}// Usageval list = listOf(1, \"2\", 3.0)val ints = list.filterIsInstance\u003cInt\u003e() // [1]Chapter 6: The EndingAs soon as the Mage attacked with IceDamage, The Lord Ambiguous screamed. His type-shield shattered, no longer protected by generic ambiguity.The classic ending of the fantasy fictions.The Lord Ambiguous was finally defeated! Not by brute force, but by understanding how types worked in their deepest form. The land was saved. And the heroes? They were type-safe(not ambiguous for sure!).And the heroes in the land of Generics lived happily ever after! 🎉Bonus Chapter: Mastering the Deeper MagicWhile the main storyline ended on a positive note, the land of Generics contains more magical forces. Let’s discover more!1. Use-Site VarianceRemember how we declared variance on the BookShelf(out T) and Enemy(in T) above? That’s declaration-site variance — the variance rule is fixed in the class definition. However, there are occasions you may prefer to work with classes that are invariant (like MutableList\u003cE\u003e), but you only need to use them in a covariant or contravariant way in a specific function or context.Look at the example below; while copying from a list, no write operations are needed in the list from.fun copy(from: MutableList\u003cout Any\u003e, to: MutableList\u003cAny\u003e) { for (i in from.indices) { to[i] = from[i] }}To prohibit writing to from , simply use the out keyword, which performs type projection. It means that from is a restricted list. This can temporarily make a normally read/write generic type behave as read-only (out) or write-only (in) for that specific use.2. Null Safety in GenericsA standard generic type parameter T has an implicit upper bound of Any?. Which means T itself can represent a nullable type!That's why List\u003cT\u003e can be instantiated as List\u003cString?\u003e.val list: List\u003cString?\u003e = listOf(\"null\", null)So it’s important to enforce non-null types by using the constraint if you need to guarantee that the type argument provided for T is non-nullable.We can set boundaries for T to have specific capabilities, and T : Any ensures that the type argument itself cannot be nullable.class NonNullGeneric\u003cT : Any\u003e// val n = NonNullGeneric\u003cString?\u003e() // ❌ Compile error: Not within its boundsIt’s also possible to make non-nullable function type arguments that have a nullable class generic type.class NullableGeneric\u003cT\u003e { fun nonNullOperation(t: T \u0026 Any) { ... }}val n = NullableGeneric\u003cString?\u003e() // ✅// n.nonNullOperation(null) // ❌ Compile error: receives non-null type StringThe most common use case for declaring non-nullable types is when you want to override a Java method that contains @NotNull as an argument.Note: It’s possible to set multiple bounds using where when T needs to satisfy multiple conditions. Please refer to more: https://kotlinlang.org/docs/generics.html#upper-bounds3. Star-projectionsStar-projection(*) provides a type-safe way to handle generic types when the specific type argument is unknown, allowing safe read access as Any?.val mysterySpells: List\u003c*\u003e = listOf(...)This is Kotlin’s safe wildcard, like Java’s raw types, but safer.For covariant types like List\u003cout T\u003e, List\u003c*\u003e is equivalent to List\u003cout Any?\u003e. You can safely read values Any?.For contravariant types like Comparator\u003cin T\u003e, Comparator\u003c*\u003e is equivalent to Comparator\u003cin Nothing\u003e. You can’t safely write anything in (since Nothing has no instances).For invariant types like MutableList\u003cT\u003e, MutableList\u003c*\u003e is equivalent to MutableList\u003cout T\u003e for reading values, and to MutableList\u003cin Nothing\u003e for writing values.4. Variance Cheat Sheet \u0026 PECSThis concept is also known as PECS.Producer → out, Extends / Consumer → in, SuperProducer (out) corresponds to ‘Extends’ in PECS, meaning you can get items out (read). Consumer (in) corresponds to ‘Super’ in PECS, meaning you can put items in (write/consume). (Please refer to more: https://www.baeldung.com/java-generics-pecs)ConclusionAnd that’s it!I found Kotlin Generics to be a bit challenging when I first started learning the language). But by understanding how keywords like in, out, reified work and how they were designed, you’re not just learning syntax; you’re taking a step to write more type-safe code.Hope our journey through the fantasy land of Generics with our heroes has made these concepts easier to understand! 🏞️Referenceshttps://kotlinlang.org/docs/generics.htmlhttps://kotlinlang.org/docs/inline-functions.htmlhttps://www.baeldung.com/java-generics-pecsAll images are generated by GPT-4o",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Y5z2dLTMbDkg_pru24EwmA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"a7c7\" data-testid=\"storyTitle\"\u003eKotlin Generics Explained: Once Upon a Type…\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@wisemuji?source=post_page---byline--6143b49e0c4d---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Suhyeon Kim\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*uhIHZHsEj-22VhI1sOebjA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--6143b49e0c4d---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"0acf\"\u003eUnderstanding \u003ca href=\"https://kotlinlang.org/docs/generics.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGenerics in Kotlin\u003c/a\u003e can be tough for beginners; trust me, I’ve been there. Let me tell you a little fantasy story to understand them \u003cstrong\u003eeasily\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"abf8\"\u003eAfter reading this, you will be able to :\u003c/p\u003e\u003cul\u003e\u003cli id=\"69a2\"\u003eUnderstand how covariant, contravariant, and invariant types work(with \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e keywords).\u003c/li\u003e\u003cli id=\"7575\"\u003eUnderstand that Kotlin erases type information at runtime and how reified keyword works.\u003c/li\u003e\u003cli id=\"c16a\"\u003eLearn use-site variance, star-projections, and null safety in Generics.\u003c/li\u003e\u003cli id=\"f0aa\"\u003eDiscover how Generics are applied in the real world(in Kotlin APIs).\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"204c\"\u003eOnce Upon a Type…\u003c/h2\u003e\u003cp id=\"252e\"\u003e\u003cem\u003eNote: The story has some embellishments to fit the narrative.\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2b40\"\u003e\u003cspan\u003eIn\u003c/span\u003e the \u003cstrong\u003eland of Generics\u003c/strong\u003e, three Android heroes —\u003cstrong\u003e Warrior, Mage, \u003c/strong\u003eand\u003cstrong\u003e Archer \u003c/strong\u003e— embarked on a quest to defeat the legendary \u003cstrong\u003eLord Ambiguous\u003c/strong\u003e, who threatened the land of Generics.\u003c/p\u003e\u003cp id=\"6c4b\"\u003eThey had to pass through the \u003cstrong\u003eForbidden Forest\u003c/strong\u003e to reach the Lord Ambiguous, which taught them the variance rules in the land of Generics.\u003c/p\u003e\u003ch2 id=\"64ef\"\u003eTable of Contents\u003c/h2\u003e\u003cul\u003e\u003cli id=\"e147\"\u003eChapter 1: The Mystic Gate and Invariance\u003c/li\u003e\u003cli id=\"ac23\"\u003eChapter 2: The Magical Scroll and Covariance\u003c/li\u003e\u003cli id=\"f9ca\"\u003eChapter 3: The Lord Ambiguous and Contravariance\u003c/li\u003e\u003cli id=\"26c5\"\u003eChapter 4: The Final Battle and Type Erasure\u003c/li\u003e\u003cli id=\"61a0\"\u003eChapter 5: The Spell of Reified\u003c/li\u003e\u003cli id=\"3d5a\"\u003eChapter 6: The Ending\u003c/li\u003e\u003cli id=\"377c\"\u003eBonus Chapter: Advanced Kotlin Generics\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"94cf\"\u003eChapter 1: The Mystic Gate and Invariance\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7af0\"\u003eAt the entrance of the Forbidden Forest stood the \u003cstrong\u003eMystic Gate\u003c/strong\u003e.\u003cbr/\u003eA stern gatekeeper materialized. \u003cem\u003e“Halt! If you are a warrior, only those who carry \u003c/em\u003e\u003ccode\u003eSheath\u0026lt;Sword\u0026gt;\u003c/code\u003e\u003cem\u003e may enter.”\u003c/em\u003e\u003c/p\u003e\u003cp id=\"4ade\"\u003eThe warrior confidently held a \u003ccode\u003eSheath\u0026lt;Excalibur\u0026gt;\u003c/code\u003e, but despite \u003ccode\u003eExcalibur\u003c/code\u003e being a subtype of \u003ccode\u003eSword\u003c/code\u003e, the gatekeeper refused to let them pass.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b04d\"\u003eopen class Sword\u003cbr/\u003eclass Excalibur : Sword()\u003cp\u003eclass Sheath\u0026lt;T\u0026gt;(val item: T)\u003c/p\u003e\u003cp\u003eval sword: Sheath\u0026lt;Sword\u0026gt; = Sheath\u0026lt;Excalibur\u0026gt;(Excalibur()) // ❌ Compile Error: Type mismatch!\u003cbr/\u003eval excalibur: Sheath\u0026lt;Excalibur\u0026gt; = Sheath\u0026lt;Sword\u0026gt;(Sword()) // ❌ Compile Error: Type mismatch!\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4677\"\u003eThe rule was clear. Even if \u003ccode\u003eExcalibur\u003c/code\u003e is a \u003ccode\u003eSword\u003c/code\u003e, \u003ccode\u003eSheath\u0026lt;Excalibur\u0026gt;\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e a subtype of \u003ccode\u003eSheath\u0026lt;Sword\u0026gt;\u003c/code\u003e(and vice versa).\u003c/p\u003e\u003ch2 id=\"2823\"\u003eExplanation — V\u003cstrong\u003eariance and I\u003c/strong\u003envariance\u003c/h2\u003e\u003cp id=\"d9c4\"\u003eIn Kotlin, \u003cstrong\u003evariance\u003c/strong\u003e defines how subtyping between complex types relates to subtyping between their type parameters.\u003c/p\u003e\u003cp id=\"d406\"\u003eGeneric types are \u003cstrong\u003einvariant\u003c/strong\u003e by default(written simply as \u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e), which means the type parameter must match \u003cstrong\u003eexactly\u003c/strong\u003e. No substitutions with subtypes or supertypes are allowed for the generic type itself.\u003c/p\u003e\u003cp id=\"f221\"\u003eThat’s because invariance\u003cstrong\u003e allows you to read/write\u003c/strong\u003e. If Kotlin allowed you to treat \u003ccode\u003eSheath\u0026lt;Excalibur\u0026gt;\u003c/code\u003e as \u003ccode\u003eSheath\u0026lt;Sword\u0026gt;\u003c/code\u003e, you might read an \u003ccode\u003eExcalibur\u003c/code\u003e safely, but attempting to write a basic \u003ccode\u003eSword\u003c/code\u003e back into it would break type safety (as the variable expects a \u003ccode\u003eSheath\u0026lt;Excalibur\u0026gt;\u003c/code\u003e). Invariance prevents potential conflicts by ensuring an exact type match, thus ensuring the safety of both read and write operations.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4d1a\"\u003e// ✅ Invariance allows you to read/write\u003cbr/\u003eclass Sheath\u0026lt;T\u0026gt;(private var item: T) {\u003cbr/\u003e    fun get(): T = item\u003cbr/\u003e    fun replace(newItem: T) {\u003cbr/\u003e        item = newItem\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"a561\"\u003eChapter 2: The Magical Scroll and Covariance\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5bfe\"\u003eAfter passing through the Mystic Gate with some refactoring, the heroes found a hidden \u003cstrong\u003eKnowledge Vault\u003c/strong\u003e full of magical bookshelves.\u003c/p\u003e\u003cp id=\"0319\"\u003eMage approached a magical bookshelf \u003ccode\u003eBookShelf\u0026lt;out T\u0026gt;\u003c/code\u003e.\u003cbr/\u003eShe could read all kinds of scrolls: \u003ccode\u003eFireScroll\u003c/code\u003e, \u003ccode\u003eIceScroll\u003c/code\u003e, and so on.\u003c/p\u003e\u003cp id=\"e892\"\u003eBut every time she tried to add a new scroll… the bookshelf refused.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a080\"\u003eopen class Scroll\u003cbr/\u003eclass FireScroll : Scroll()\u003cbr/\u003eclass IceScroll : Scroll()\u003cp\u003eclass Bookshelf\u0026lt;out T\u0026gt;(val scroll: T) {\u003cbr/\u003e    fun read(): T = scroll // ✅\u003cbr/\u003e    // fun add(newScroll: T) { ... } // ❌ Compile error: T is declared as \u0026#39;out\u0026#39;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eval fireShelf: BookShelf\u0026lt;FireScroll\u0026gt; = BookShelf(FireScroll())\u003cbr/\u003eval generalShelf: BookShelf\u0026lt;Scroll\u0026gt; = fireShelf // ✅\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"43cd\"\u003eThe vault was \u003cstrong\u003ecovariant.\u003c/strong\u003e It allowed her to safely \u003cstrong\u003eread\u003c/strong\u003e more specific types within a general type, but didn’t allow for any mutable operations.\u003c/p\u003e\u003ch2 id=\"a5ea\"\u003eExplanation — Covariance with ‘out’\u003c/h2\u003e\u003cp id=\"ac80\"\u003e\u003cstrong\u003eCovariance\u003c/strong\u003e, declared with the \u003ccode\u003eout\u003c/code\u003e keyword (\u003ccode\u003eout T\u003c/code\u003e), means you can \u003cstrong\u003esafely read\u003c/strong\u003e values of type \u003ccode\u003eT\u003c/code\u003e, but \u003cstrong\u003eyou cannot write\u003c/strong\u003e to it(read-only). This is because the actual object might be a subtype of \u003ccode\u003eT\u003c/code\u003e, and writing something of type \u003ccode\u003eT\u003c/code\u003e might break type safety.\u003c/p\u003e\u003cp id=\"cf58\"\u003eThis explains why \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/-list/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eList\u003c/a\u003e\u0026lt;out E\u0026gt;\u003c/code\u003e from Kotlin Collections can read elements of type \u003ccode\u003eT\u003c/code\u003e from the list, but adding elements is not allowed, since the list might internally be holding a more specific type than \u003ccode\u003eT\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3d2b\"\u003e// Declaration\u003cbr/\u003epublic interface List\u0026lt;out E\u0026gt; : Collection\u0026lt;E\u0026gt; { ... }\u003cp\u003e// Usage\u003cbr/\u003eval children: List\u0026lt;Child\u0026gt; = listOf(Child())\u003cbr/\u003eval parents: List\u0026lt;Parent\u0026gt; = children // ✅\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e84d\"\u003eWhile \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/-mutable-list/index.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMutableList\u003c/a\u003e\u0026lt;E\u0026gt;\u003c/code\u003e is invariant, read/write access is supported, so no substitutions with subtypes or supertypes are allowed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"309e\"\u003e// Declaration\u003cbr/\u003epublic interface MutableList\u0026lt;E\u0026gt; : List\u0026lt;E\u0026gt;, MutableCollection\u0026lt;E\u0026gt; { ... }\u003cp\u003e// Usage\u003cbr/\u003eval children: MutableList\u0026lt;Child\u0026gt; = mutableListOf(Child())\u003cbr/\u003e// val parents: MutableList\u0026lt;Parent\u0026gt; = children // ❌ Compile error: Type mismatch.\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"78bc\"\u003eChapter 3: The \u003cstrong\u003eLord Ambiguous\u003c/strong\u003e and Contravariance\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"140c\"\u003eAt last, the heroes reached the \u003cstrong\u003eLord Ambiguous\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"62ed\"\u003eNo one knew what kind of damage would be most effective. The Lord Ambiguous revealed nothing; his weakness remained a mystery. But he could take damage. Any kind.\u003c/p\u003e\u003cp id=\"5cf8\"\u003eEach hero tried what they could:\u003c/p\u003e\u003cul\u003e\u003cli id=\"73a1\"\u003eThe warrior attacked with \u003ccode\u003eDamage\u003c/code\u003e\u003c/li\u003e\u003cli id=\"4475\"\u003eThe mage unleashed \u003ccode\u003eFireDamage\u003c/code\u003e\u003c/li\u003e\u003cli id=\"156d\"\u003eThe archer struck with \u003ccode\u003eArrowDamage\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3c3a\"\u003eAnd the Lord Ambiguous… took all the damages.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a145\"\u003eopen class Damage\u003cbr/\u003eclass FireDamage : Damage()\u003cbr/\u003eclass ArrowDamage : Damage()\u003cp\u003eclass Enemy\u0026lt;in T\u0026gt; {\u003cbr/\u003e    fun takeHit(damage: T) {\u003cbr/\u003e        println(\u0026#34;The enemy took damage: $damage\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    // fun getWeakness(): T { } // ❌ Compile error: T is declared as \u0026#39;in\u0026#39;\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003eval enemy = Enemy\u0026lt;Damage\u0026gt;()\u003cbr/\u003eenemy.takeHit(Damage()) // ✅\u003cbr/\u003eenemy.takeHit(FireDamage()) // ✅\u003cbr/\u003eenemy.takeHit(ArrowDamage()) // ✅\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"27c2\"\u003eWith the \u003ccode\u003eEnemy\u0026lt;in T\u0026gt;\u003c/code\u003e type, the heroes could put in many forms of attack, but could never inspect the actual type.\u003c/p\u003e\u003ch2 id=\"9a84\"\u003eExplanation — Contravariance with ‘in’\u003c/h2\u003e\u003cp id=\"348f\"\u003eWith \u003cstrong\u003econtravariance\u003c/strong\u003e, expressed with the \u003ccode\u003ein\u003c/code\u003e keyword (\u003ccode\u003ein T\u003c/code\u003e), you can \u003cstrong\u003esafely write\u003c/strong\u003e values of type \u003ccode\u003eT\u003c/code\u003e, but \u003cstrong\u003eyou cannot read\u003c/strong\u003e from it. This is useful when you\u0026#39;re passing data into a generic type, like a consumer. Kotlin allows you to pass a \u003ccode\u003eT\u003c/code\u003e value into the structure because any supertype of can safely accept it \u003ccode\u003eT\u003c/code\u003e, but reading from it is unsafe since the actual contents might be of a more general type.\u003c/p\u003e\u003cp id=\"4f0b\"\u003eThis explains why \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/-comparable/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eComparable\u003c/a\u003e\u0026lt;in T\u0026gt;\u003c/code\u003e in Kotlin can safely \u003cstrong\u003ewrite\u003c/strong\u003e values of type \u003ccode\u003eT\u003c/code\u003e, but does not involve reading a\u003ccode\u003eT\u003c/code\u003e value.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"123d\"\u003e// Declaration\u003cbr/\u003epublic interface Comparable\u0026lt;in T\u0026gt; {\u003cbr/\u003e    public operator fun compareTo(other: T): Int\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b411\"\u003eSince \u003ccode\u003eComparable\u003c/code\u003e only needs to accept values to compare against, we don’t need to know the exact type inside — we just need to be sure we can safely pass a \u003ccode\u003eT\u003c/code\u003e. This makes it a perfect case for contravariant design with \u003ccode\u003ein T\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"42ff\"\u003eChapter 4: The Final Battle and Type Erasure\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"290b\"\u003eThe Lord Ambiguous roared in fury. Despite all their knowledge of variance, despite every type-safe strike… it still stood. \u003cbr/\u003e\u003cem\u003e“You know how to attack,” \u003c/em\u003eit growled,\u003cem\u003e “but do you truly know what I am?”\u003c/em\u003e\u003c/p\u003e\u003cp id=\"765f\"\u003eThen the Mage recalled something she read in the Knowledge Vault:\u003cbr/\u003e\u003cem\u003e“In this land of Generics, much of the specific type information is lost after the initial checks. It’s called… \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eType Erasure\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e.”\u003c/em\u003e\u003c/p\u003e\u003cp id=\"f77f\"\u003eThat meant they couldn’t check the enemy’s actual type at \u003cstrong\u003eruntime\u003c/strong\u003e. During the runtime, everything specific often just looked like \u003ccode\u003e*\u003c/code\u003e — a star-projection, representing \u003cem\u003esome\u003c/em\u003e type, but unknown.\u003c/p\u003e\u003ch2 id=\"08eb\"\u003eExplanation — Runtime Type Erasure\u003c/h2\u003e\u003cp id=\"cdfc\"\u003eIn Kotlin(as in Java), generic type arguments are erased at runtime. This means that although you may write and interact with a \u003ccode\u003eList\u0026lt;Int\u0026gt;\u003c/code\u003e or \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e at compile time, at runtime, both types are simply treated as \u003ccode\u003eList\u0026lt;*\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"9458\"\u003eThis process, known as the \u003cstrong\u003eType Erasure\u003c/strong\u003e, does not retain generic type information in its type system at runtime. This happens mainly for historical reasons(ensuring compatibility with older Java versions that didn’t have generics), and to avoid potential runtime performance overhead associated with carrying detailed type information for every generic instance.\u003c/p\u003e\u003cp id=\"5b81\"\u003e\u003cem\u003eNote: Some type information can be retained in specific contexts, like superclass tokens or reflection on class definitions themselves. Please refer to more: \u003c/em\u003e\u003ca href=\"https://www.baeldung.com/java-super-type-tokens\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://www.baeldung.com/java-super-type-tokens\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"8d1d\"\u003eConsequently, runtime type safety cannot distinguish between generic instantiations like \u003ccode\u003eList\u0026lt;Int\u0026gt;\u003c/code\u003e and \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f6cc\"\u003e// ❌ Runtime error: Both constructor have the same JVM signature\u003cbr/\u003eclass Foo(val ints: List\u0026lt;Int\u0026gt;) {\u003cbr/\u003e    constructor(strings: List\u0026lt;String\u0026gt;) : this(strings.map { it.toInt() })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e6be\"\u003eBut due to type erasure, both constructors are treated to have the same JVM method signature, and it error will occur at runtime. \u003cem\u003e(To solve constructor/function signature clashes like this, factory functions or using \u003c/em\u003e\u003ccode\u003e\u003cem\u003e@JvmName\u003c/em\u003e\u003c/code\u003e\u003cem\u003e might help.\u003c/em\u003e \u003cem\u003ePlease refer to more: \u003c/em\u003e\u003ca href=\"https://kt.academy/article/ek-factory-functions\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://kt.academy/article/ek-factory-functions\u003c/em\u003e\u003c/a\u003e\u003cem\u003e)\u003c/em\u003e\u003c/p\u003e\u003cp id=\"16b1\"\u003e\u003cem\u003eNote: Type erasure \u003c/em\u003e\u003cstrong\u003e\u003cem\u003edoes not\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e mean generics are useless! It’s only after these strict compile-time checks pass that the specific type information is typically erased, making it unavailable for inspection at runtime.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"136c\"\u003eChapter 5: The Spell of Reified\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7941\"\u003eSince the generic type arguments are erased at runtime, the heroes couldn’t guess the proper weakness of the Lord Ambiguous.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c5b5\"\u003efun \u0026lt;T : Damage\u0026gt; isWeakTo(): Boolean {\u003cbr/\u003e    // ❌ Compile error: Cannot check for instance of erased type: T\u003cbr/\u003e    // return T is hiddenWeakness \u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f4f9\"\u003eBut Mage knew one ancient technique, an \u003cstrong\u003einline spell with reified type\u003c/strong\u003e that preserved type information even in runtime.\u003c/p\u003e\u003cp id=\"db67\"\u003eShe cast:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9241\"\u003einline fun \u0026lt;reified T : Damage\u0026gt; isWeakTo(): Boolean {\u003cbr/\u003e    return hiddenWeakness is T // ✅ Check becomes possible at runtime\u003cbr/\u003e}\u003cp\u003eval weakToFire = isWeakTo\u0026lt;FireDamage\u0026gt;()\u003cbr/\u003eprintln(\u0026#34;Is weak to FireDamage? $weakToFire\u0026#34;) // Output: false\u003cbr/\u003eval weakToIce = isWeakTo\u0026lt;IceDamage\u0026gt;()\u003cbr/\u003eprintln(\u0026#34;Is weak to IceDamage? $weakToIce\u0026#34;) // Output: true\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b5c4\"\u003eFor once, the spell whispered back the truth at runtime. \u003cbr/\u003e\u003cem\u003eThe Lord Ambiguous was vulnerable to \u003c/em\u003e\u003ccode\u003e\u003cem\u003eIceDamage\u003c/em\u003e\u003c/code\u003e\u003cem\u003e!\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"a892\"\u003eExplanation — Inline Reified Type Parameters\u003c/h2\u003e\u003cp id=\"592f\"\u003eNormally, as discussed with Type Erasure, you lose access to the specific generic type argument \u003ccode\u003eT\u003c/code\u003e at runtime. Trying to check \u003ccode\u003ehiddenWeakness is T\u003c/code\u003e results in a compile error because \u003ccode\u003eT\u003c/code\u003e’s specific type information isn’t preserved. But if you use \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e with an \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e function\u003c/strong\u003e, Kotlin\u003cstrong\u003e \u003c/strong\u003eallows you to use \u003ccode\u003eis\u003c/code\u003e, \u003ccode\u003eas\u003c/code\u003e, and even \u003ccode\u003eT::class\u003c/code\u003e safely at runtime.\u003c/p\u003e\u003cp id=\"56a5\"\u003eWhen you mark a function with \u003ccode\u003einline\u003c/code\u003e, the compiler doesn’t just generate a standard function call. Instead, it copies the bytecode of the inline function directly into the location where the function is called. This can \u003cem\u003esometimes\u003c/em\u003e improve performance, especially with lambda arguments, by avoiding the overhead of creating function objects.\u003c/p\u003e\u003cp id=\"ef30\"\u003eWith \u003ccode\u003einline\u003c/code\u003e +\u003ccode\u003ereified\u003c/code\u003e keyword, the function’s code is being copied directly to the call site, the compiler knows the actual type argument being used at that specific call site. \u003cstrong\u003eWithin the context of that specific inline function call, the type information is not erased, making it “reified”\u003c/strong\u003e. This allows you to perform runtime operations that are normally forbidden for generic types:\u003c/p\u003e\u003cul\u003e\u003cli id=\"156c\"\u003eType checks: \u003ccode\u003evalue is T\u003c/code\u003e\u003c/li\u003e\u003cli id=\"c29f\"\u003eType casts: \u003ccode\u003evalue as T\u003c/code\u003e\u003c/li\u003e\u003cli id=\"db40\"\u003eAccessing the type’s KClass: \u003ccode\u003eT::class (e.g., T::class.java)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d6ca\"\u003e\u003cem\u003eNote: This only works because the code is inlined. Also means \u003c/em\u003e\u003ccode\u003e\u003cem\u003ereified\u003c/em\u003e\u003c/code\u003e\u003cem\u003e type parameters \u003c/em\u003e\u003cstrong\u003e\u003cem\u003ecan only be used with inline functions\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e. Please refer to more:\u003cbr/\u003e\u003c/em\u003e\u003ca href=\"https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://kotlinlang.org/docs/inline-functions.html#reified-type-parameters\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"7767\"\u003eThis also explains why operations like \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.collections/filter-is-instance.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efilterIsInstance\u003c/a\u003e\u003c/code\u003e from Kotlin Collections, can keep elements of type \u003ccode\u003eT\u003c/code\u003e with no reflection needed:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"401b\"\u003e// Declaration\u003cbr/\u003einline fun \u0026lt;reified R\u0026gt; Iterable\u0026lt;*\u0026gt;.filterIsInstance(): List\u0026lt;...\u0026gt; {...}\u003cp\u003e// Usage\u003cbr/\u003eval list = listOf(1, \u0026#34;2\u0026#34;, 3.0)\u003cbr/\u003eval ints = list.filterIsInstance\u0026lt;Int\u0026gt;()  // [1]\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"17ef\"\u003eChapter 6: The Ending\u003c/h2\u003e\u003cp id=\"a5d3\"\u003eAs soon as the Mage attacked with \u003ccode\u003eIceDamage\u003c/code\u003e, The Lord Ambiguous screamed. His type-shield shattered, no longer protected by generic ambiguity.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe classic ending of the fantasy fictions.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2c91\"\u003eThe Lord Ambiguous was finally defeated! Not by brute force, but by understanding how types worked in their deepest form. The land was saved. And the heroes? They were type-safe(not ambiguous for sure!).\u003c/p\u003e\u003cp id=\"e692\"\u003e\u003cstrong\u003e\u003cem\u003eAnd the heroes in the land of Generics lived happily ever after! 🎉\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"4eb5\"\u003e\u003cstrong\u003eBonus Chapter: Mastering the Deeper Magic\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0f52\"\u003eWhile the main storyline ended on a positive note, the land of Generics contains more magical forces. Let’s discover more!\u003c/p\u003e\u003ch2 id=\"6893\"\u003e\u003cstrong\u003e1. Use-Site Variance\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"8409\"\u003eRemember how we declared variance on the \u003ccode\u003eBookShelf(out T)\u003c/code\u003e and \u003ccode\u003eEnemy(in T)\u003c/code\u003e above? That’s \u003cstrong\u003edeclaration-site variance\u003c/strong\u003e — the variance rule is fixed in the class definition. However, there are occasions you may prefer to work with classes that are invariant (like \u003ccode\u003eMutableList\u0026lt;E\u0026gt;\u003c/code\u003e), but you only need to use them in a covariant or contravariant way in a specific function or context.\u003c/p\u003e\u003cp id=\"4ed0\"\u003eLook at the example below; while copying from a list, no write operations are needed in the list \u003ccode\u003efrom\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f8d5\"\u003efun copy(from: MutableList\u0026lt;out Any\u0026gt;, to: MutableList\u0026lt;Any\u0026gt;) {\u003cbr/\u003e    for (i in from.indices) {\u003cbr/\u003e        to[i] = from[i]\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dbb9\"\u003eTo prohibit writing to \u003ccode\u003efrom\u003c/code\u003e , simply use the \u003ccode\u003eout\u003c/code\u003e keyword, which performs\u003cstrong\u003e type projection\u003c/strong\u003e. It means that \u003ccode\u003efrom\u003c/code\u003e is a restricted list. This can \u003cstrong\u003etemporarily\u003c/strong\u003e make a normally read/write generic type behave as read-only (\u003ccode\u003eout\u003c/code\u003e) or write-only (\u003ccode\u003ein\u003c/code\u003e) for that specific use.\u003c/p\u003e\u003ch2 id=\"ebda\"\u003e2. Null Safety in Generics\u003c/h2\u003e\u003cp id=\"e139\"\u003eA standard generic type parameter \u003ccode\u003eT\u003c/code\u003e has an implicit upper bound of \u003ccode\u003eAny?\u003c/code\u003e. Which means \u003ccode\u003eT\u003c/code\u003e itself can represent a nullable type!\u003c/p\u003e\u003cp id=\"a885\"\u003eThat\u0026#39;s why \u003ccode\u003eList\u0026lt;T\u0026gt;\u003c/code\u003e can be instantiated as \u003ccode\u003eList\u0026lt;String?\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9eb3\"\u003eval list: List\u0026lt;String?\u0026gt; = listOf(\u0026#34;null\u0026#34;, null)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a24e\"\u003eSo it’s important to enforce non-null types by using the constraint if you need to guarantee that the type argument provided for \u003ccode\u003eT\u003c/code\u003e is non-nullable.\u003c/p\u003e\u003cp id=\"b1c1\"\u003eWe can set boundaries for \u003ccode\u003eT\u003c/code\u003e to have specific capabilities, and \u003ccode\u003eT : Any\u003c/code\u003e ensures that the type argument itself cannot be nullable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4c8f\"\u003eclass NonNullGeneric\u0026lt;T : Any\u0026gt;\u003cp\u003e// val n = NonNullGeneric\u0026lt;String?\u0026gt;() // ❌ Compile error: Not within its bounds\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d635\"\u003eIt’s also possible to make non-nullable function type arguments that have a nullable class generic type.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c650\"\u003eclass NullableGeneric\u0026lt;T\u0026gt; {\u003cbr/\u003e    fun nonNullOperation(t: T \u0026amp; Any) { ... }\u003cbr/\u003e}\u003cp\u003eval n = NullableGeneric\u0026lt;String?\u0026gt;() // ✅\u003cbr/\u003e// n.nonNullOperation(null) // ❌ Compile error: receives non-null type String\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp id=\"98d7\"\u003eThe most common use case for declaring non-nullable types is when you want to override a Java method that contains \u003ccode\u003e@NotNull\u003c/code\u003e as an argument.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"6e6b\"\u003e\u003cem\u003eNote: It’s possible to set multiple bounds using \u003c/em\u003e\u003ccode\u003e\u003cem\u003ewhere\u003c/em\u003e\u003c/code\u003e\u003cem\u003e when \u003c/em\u003e\u003ccode\u003e\u003cem\u003eT\u003c/em\u003e\u003c/code\u003e\u003cem\u003e needs to satisfy multiple conditions. Please refer to more: \u003c/em\u003e\u003ca href=\"https://kotlinlang.org/docs/generics.html#upper-bounds\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://kotlinlang.org/docs/generics.html#upper-bounds\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"12e5\"\u003e3. Star-projections\u003c/h2\u003e\u003cp id=\"5ddb\"\u003eStar-projection(\u003ccode\u003e*\u003c/code\u003e) provides a type-safe way to handle generic types when the specific type argument is unknown, allowing safe read access as \u003ccode\u003eAny?\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cf03\"\u003eval mysterySpells: List\u0026lt;*\u0026gt; = listOf(...)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ce7d\"\u003eThis is Kotlin’s \u003cstrong\u003esafe wildcard\u003c/strong\u003e, like Java’s raw types, but safer.\u003c/p\u003e\u003cul\u003e\u003cli id=\"8e90\"\u003eFor \u003cstrong\u003ecovariant\u003c/strong\u003e types like \u003ccode\u003eList\u0026lt;out T\u0026gt;\u003c/code\u003e, \u003ccode\u003eList\u0026lt;*\u0026gt;\u003c/code\u003e is equivalent to \u003ccode\u003eList\u0026lt;out Any?\u0026gt;\u003c/code\u003e. You can safely read values \u003ccode\u003eAny?\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"a20e\"\u003eFor \u003cstrong\u003econtravariant\u003c/strong\u003e types like \u003ccode\u003eComparator\u0026lt;in T\u0026gt;\u003c/code\u003e, \u003ccode\u003eComparator\u0026lt;*\u0026gt;\u003c/code\u003e is equivalent to \u003ccode\u003eComparator\u0026lt;in Nothing\u0026gt;\u003c/code\u003e. You can’t safely write anything in (since \u003ccode\u003eNothing\u003c/code\u003e has no instances).\u003c/li\u003e\u003cli id=\"37af\"\u003eFor \u003cstrong\u003einvariant\u003c/strong\u003e types like \u003ccode\u003eMutableList\u0026lt;T\u0026gt;\u003c/code\u003e, \u003ccode\u003eMutableList\u0026lt;*\u0026gt;\u003c/code\u003e is equivalent to \u003ccode\u003eMutableList\u0026lt;out T\u0026gt;\u003c/code\u003e for reading values, and to \u003ccode\u003eMutableList\u0026lt;in Nothing\u0026gt;\u003c/code\u003e for writing values.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a33c\"\u003e4. Variance Cheat Sheet \u0026amp; PECS\u003c/h2\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"63da\"\u003eThis concept is also known as \u003cstrong\u003ePECS.\u003c/strong\u003e\u003cbr/\u003e\u003cstrong\u003e\u003cem\u003eP\u003c/em\u003e\u003c/strong\u003e\u003cem\u003eroducer → \u003c/em\u003e\u003ccode\u003e\u003cem\u003eout\u003c/em\u003e\u003c/code\u003e\u003cem\u003e, \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eE\u003c/em\u003e\u003c/strong\u003e\u003cem\u003extends / \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eC\u003c/em\u003e\u003c/strong\u003e\u003cem\u003eonsumer → \u003c/em\u003e\u003ccode\u003e\u003cem\u003ein\u003c/em\u003e\u003c/code\u003e\u003cem\u003e, \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eS\u003c/em\u003e\u003c/strong\u003e\u003cem\u003euper\u003c/em\u003e\u003c/p\u003e\u003cp id=\"c5bf\"\u003eProducer (\u003ccode\u003eout\u003c/code\u003e) corresponds to ‘Extends’ in PECS, meaning you can get items \u003cem\u003eout\u003c/em\u003e (read). Consumer (\u003ccode\u003ein\u003c/code\u003e) corresponds to ‘Super’ in PECS, meaning you can put items \u003cem\u003ein\u003c/em\u003e (write/consume). (\u003cem\u003ePlease refer to more: \u003c/em\u003e\u003ca href=\"https://www.baeldung.com/java-generics-pecs\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://www.baeldung.com/java-generics-pecs\u003c/em\u003e\u003c/a\u003e\u003cem\u003e)\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"d688\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"c4f0\"\u003eAnd that’s it!\u003c/p\u003e\u003cp id=\"0dbb\"\u003eI found Kotlin Generics to be a bit challenging when I first started learning the language). But by understanding how keywords like \u003ccode\u003ein\u003c/code\u003e, \u003ccode\u003eout\u003c/code\u003e, \u003ccode\u003ereified\u003c/code\u003e work and how they were designed, you’re not just learning syntax; you’re taking a step to write more type-safe code.\u003c/p\u003e\u003cp id=\"0bf1\"\u003eHope our journey through the fantasy land of Generics with our heroes has made these concepts easier to understand! 🏞️\u003c/p\u003e\u003ch2 id=\"7013\"\u003eReferences\u003c/h2\u003e\u003cul\u003e\u003cli id=\"052f\"\u003e\u003ca href=\"https://kotlinlang.org/docs/generics.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://kotlinlang.org/docs/generics.html\u003c/a\u003e\u003c/li\u003e\u003cli id=\"9c7d\"\u003e\u003ca href=\"https://kotlinlang.org/docs/inline-functions.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://kotlinlang.org/docs/inline-functions.html\u003c/a\u003e\u003c/li\u003e\u003cli id=\"2ab8\"\u003e\u003ca href=\"https://www.baeldung.com/java-generics-pecs\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://www.baeldung.com/java-generics-pecs\u003c/a\u003e\u003c/li\u003e\u003cli id=\"097a\"\u003e\u003cem\u003eAll images are generated by GPT-4o\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2025-04-19T15:49:25.481Z",
  "modifiedTime": null
}
