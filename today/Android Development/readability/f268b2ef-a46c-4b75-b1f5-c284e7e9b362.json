{
  "id": "f268b2ef-a46c-4b75-b1f5-c284e7e9b362",
  "title": "Exploring the Compose Preview Screenshot Testing tool",
  "link": "https://joebirch.co/android/exploring-screenshot-testing-for-jetpack-compose/",
  "description": "At Google I/O 2024, one of the announcements that caught my eye was support for Compose Preview Screenshot Testing using the Compose Preview Screenshot Testing tool. Even though this is still in an experimental state, I couldnâ€™t wait to dive in and have a play with this! My new book, CI/CD for Android using GitHub... Continue reading â†’",
  "author": "hitherejoe",
  "published": "Thu, 23 May 2024 12:46:15 +0000",
  "source": "https://joebirch.co/feed",
  "categories": [
    "Android",
    "Jetpack Compose",
    "Android App Development",
    "Android Development",
    "AndroidDev",
    "App Development",
    "jetpack compose",
    "jetpackcompose",
    "Mobile App Development"
  ],
  "byline": "by hitherejoe",
  "length": 7327,
  "excerpt": "At Google I/O 2024, one of the announcements that caught my eye was support for Compose Preview Screenshot Testing using the Compose Preview Screenshot Testing tool. Even though this is still in an experimental state, I couldn't wait to dive in and have a play with this! My new book, CI/CD f",
  "siteName": "Joe Birch",
  "favicon": "",
  "text": "At Google I/O 2024, one of the announcements that caught my eye was support for Compose Preview Screenshot Testing using the Compose Preview Screenshot Testing tool. Even though this is still in an experimental state, I couldnâ€™t wait to dive in and have a play with this! My new book, CI/CD for Android using GitHub Actions is now available ðŸš€ Setting up Screenshot Testing Before we can start with screenshot testing, we need to configure our project to access this functionality. Weâ€™ll start here by adding the required library and plugin declarations to our libs.versions.toml file. Here we are adding the androidx-compose-ui-tooling library, along with the compose.screenshot plugin â€“ this is what will handle the generation and verification of our screenshots. Note: youâ€™ll need to at least be using version 8.5.0-beta of the android gradle plugin, and 1.9.20 for Kotlin [versions] agp = \"8.5.0-beta01\" kotlin = \"1.9.20\" screenshot = \"0.0.1-alpha01\" [libraries] androidx-compose-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\"} [plugins] ... screenshot = { id = \"com.android.compose.screenshot\", version.ref = \"screenshot\"} Weâ€™ll then need to apply this plugin within the module build.gradle file where we want this plugin to be enabled. plugins { ... alias(libs.plugins.screenshot) } Next, weâ€™ll need to enable the experimental screenshot testing feature within our gradle.properties file. android.experimental.enableScreenshotTest=true Weâ€™ll also need to apply this experimental flag at the module-level. android { experimentalProperties[\"android.experimental.enableScreenshotTest\"] = true } Itâ€™s important to note that here, we must be using at least version 1.5.4 of the compose compiler to enable screenshot testing support. android { ... composeOptions { kotlinCompilerExtensionVersion = \"1.5.4\" } } Finally, weâ€™ll add the compose tooling package as a dependency for our screenshot tests using screenshotTestImplementation. dependencies { screenshotTestImplementation(libs.androidx.compose.ui.tooling) } Now that we have our project configured for compose screenshot testing, weâ€™re ready to get started writing some tests! Creating a screenshot test So that we can create a screenshot test, weâ€™ll need to start by creating a composable. Iâ€™ll create a simple composable representing a TextButton. For examples sake Iâ€™m going to override the colors, as weâ€™ll use this to break the tests later! @Composable fun ActionButton(modifier: Modifier = Modifier) { TextButton(modifier = modifier, onClick = { }, colors = ButtonDefaults.textButtonColors( containerColor = MaterialTheme.colorScheme.secondary, contentColor = MaterialTheme.colorScheme.onSecondary )) { Text( text = \"Sign Up\" ) } } For our composable, weâ€™ll need to create a new screenshot test so that snapshots can be generated. Here weâ€™ll need to create a new sourceset, screenshotTest and created a new test file. Within this file weâ€™ll add a new preview for our composable, composing the previously created ActionButton composable. If you already have a preview for the corresponding composable, you can simply paste this into your test file. class ScreenshotTest { @Preview(showBackground = true) @Composable fun GreetingPreview() { MaterialTheme { ActionButton() } } } Generating Screenshots Now that we have our screenshot test in place, weâ€™ll want to run the gradle command so that the screenshot generated (this will be used later for comparison). ./gradlew updateDebugScreenshotTest Once this has been run, weâ€™ll notice that a screenshotTest directory has been created within the debug source set. Within this, theyâ€™ll be a nested reference directory that contains the generated png file. If you open up this file youâ€™ll notice an image representation of our composable, this will be the same as you should see in the generated preview within Android Studio. Validating Screenshots Now that our screenshots have been generated, we can validate our existing implementation against them. Weâ€™ll do this by running the following command: ./gradlew validateDebugScreenshotTest We havenâ€™t changed any of our composable implementation, so as expected, the screenshot validation provides us with a successful result. So that we can see an example of this failing, letâ€™s go ahead and tweak the styling of our composable. For examples sake, letâ€™s image an engineer changes the containerColor of our TextButton. @Composable fun ActionButton(modifier: Modifier = Modifier) { TextButton(modifier = modifier, onClick = { }, colors = ButtonDefaults.textButtonColors( containerColor = MaterialTheme.colorScheme.secondaryContainer, contentColor = MaterialTheme.colorScheme.onSecondary )) { Text( text = \"Sign Up\" ) } } Intentional or not, if we run the same test command again we will see that the tests fail because the result of our test does not match the snapshots in our project. This failure alerts us that something visual has changed in our composable, drawing our attention to it so that we can avoid a UI regression. When to run screenshot commands From the above section youâ€™ll notice that there were two commands we used â€“ updateDebugScreenshotTest and validateDebugScreenshotTest. With these commands we need to make sure that our screenshots are kept up-to-date with the latest changes in our project, but we donâ€™t want to be updating them all of the time â€“ as we could accidentally update screenshots with UI regressions. For validateDebugScreenshotTest, weâ€™ll want to run this whenever code is being committed to the project â€“ so ideally on pull requests, failing the request if the check fails. When it comes to updateDebugScreenshotTest, weâ€™ll only want to run this when there are intended changes made to our UI. Some examples of this could include: making a change to a component in our design system adding a new component to a pre-existing screen adding a new screen that we want to have screenshot tests for With the examples above, we can see that we only want to run this update command when we are making intended changes to screens and/or components. It could also be the case that we have a pull request that makes intended and unintended changes â€“ so it could be possible to accidentally update screenshots when it was not intended to. To avoid any accident changes, updateDebugScreenshotTest should not be run automatically by CI and any screenshot changes in pull requests should be flagged be automation so that changes can be checked by reviewers. If youâ€™re looking to learn more about how to automate these kinds of processes in your Android projects, check out my new book. And thatâ€™s it! As we can see, adding screenshot tests for our composables involves very little effort. With these tests we can reduce the number of UI regressions occurring our project, helping us to create a consistent design experience in our app. Iâ€™ll be taking a look at some more things from Google I/O in some following posts, so stated tuned for more Android!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\t\n\u003cp\u003eAt Google I/O 2024, one of the announcements that caught my eye was support for \u003ca href=\"https://developer.android.com/studio/preview/compose-screenshot-testing\"\u003eCompose Preview Screenshot Testing\u003c/a\u003e using the Compose Preview Screenshot Testing tool. Even though this is still in an experimental state, I couldnâ€™t wait to dive in and have a play with this! \u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eMy new book, \u003ca href=\"https://androidactions.com/\"\u003eCI/CD for Android using GitHub Actions\u003c/a\u003e is now available ðŸš€\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eSetting up Screenshot Testing\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore we can start with screenshot testing, we need to configure our project to access this functionality. Weâ€™ll start here by adding the required library and plugin declarations to our \u003cstrong\u003elibs.versions.toml\u003c/strong\u003e file. Here we are adding the \u003cstrong\u003eandroidx-compose-ui-tooling\u003c/strong\u003e library, along with the \u003cstrong\u003ecompose.screenshot\u003c/strong\u003e plugin â€“ this is what will handle the generation and verification of our screenshots.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: youâ€™ll need to at least be using version 8.5.0-beta of the android gradle plugin, and 1.9.20 for Kotlin\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003e[versions]\nagp = \u0026#34;8.5.0-beta01\u0026#34;\nkotlin = \u0026#34;1.9.20\u0026#34;\nscreenshot = \u0026#34;0.0.1-alpha01\u0026#34;\n\n[libraries]\nandroidx-compose-ui-tooling = { group = \u0026#34;androidx.compose.ui\u0026#34;, name = \u0026#34;ui-tooling\u0026#34;}\n\n[plugins]\n...\nscreenshot = { id = \u0026#34;com.android.compose.screenshot\u0026#34;, version.ref = \u0026#34;screenshot\u0026#34;}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWeâ€™ll then need to apply this plugin within the module build.gradle file where we want this plugin to be enabled.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003eplugins {\n    ...\n    alias(libs.plugins.screenshot)\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, weâ€™ll need to enable the experimental screenshot testing feature within our \u003cstrong\u003egradle.properties\u003c/strong\u003e file.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003eandroid.experimental.enableScreenshotTest=true\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWeâ€™ll also need to apply this experimental flag at the module-level.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003eandroid {\n    experimentalProperties[\u0026#34;android.experimental.enableScreenshotTest\u0026#34;] = true\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eItâ€™s important to note that here, we must be using at least version 1.5.4 of the compose compiler to enable screenshot testing support.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eandroid {\n    ...\n    composeOptions {\n        kotlinCompilerExtensionVersion = \u0026#34;1.5.4\u0026#34;\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFinally, weâ€™ll add the compose tooling package as a dependency for our screenshot tests using \u003cstrong\u003escreenshotTestImplementation\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003edependencies {\n  screenshotTestImplementation(libs.androidx.compose.ui.tooling)\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have our project configured for compose screenshot testing, weâ€™re ready to get started writing some tests!\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eCreating a screenshot test\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo that we can create a screenshot test, weâ€™ll need to start by creating a composable. Iâ€™ll create a simple composable representing a \u003cstrong\u003eTextButton\u003c/strong\u003e. For examples sake Iâ€™m going to override the colors, as weâ€™ll use this to break the tests later!\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun ActionButton(modifier: Modifier = Modifier) {\n    TextButton(modifier = modifier, onClick = { }, colors = ButtonDefaults.textButtonColors(\n        containerColor = MaterialTheme.colorScheme.secondary,\n        contentColor = MaterialTheme.colorScheme.onSecondary\n    )) {\n        Text(\n            text = \u0026#34;Sign Up\u0026#34;\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor our composable, weâ€™ll need to create a new screenshot test so that snapshots can be generated. Here weâ€™ll need to create a new sourceset, \u003cstrong\u003escreenshotTest\u003c/strong\u003e and created a new test file.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"944\" height=\"339\" src=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00.png 944w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-300x108.png 300w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-768x276.png 768w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-500x180.png 500w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-150x54.png 150w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-400x144.png 400w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-800x287.png 800w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.14.00-200x72.png 200w\" sizes=\"(max-width: 944px) 100vw, 944px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWithin this file weâ€™ll add a new preview for our composable, composing the previously created \u003cstrong\u003eActionButton\u003c/strong\u003e composable. If you already have a preview for the corresponding composable, you can simply paste this into your test file.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eclass ScreenshotTest {\n\n    @Preview(showBackground = true)\n    @Composable\n    fun GreetingPreview() {\n        MaterialTheme {\n            ActionButton()\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eGenerating Screenshots\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we have our screenshot test in place, weâ€™ll want to run the gradle command so that the screenshot generated (this will be used later for comparison).\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003e./gradlew updateDebugScreenshotTest\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOnce this has been run, weâ€™ll notice that a \u003cstrong\u003escreenshotTest\u003c/strong\u003e directory has been created within the \u003cstrong\u003edebug\u003c/strong\u003e source set. Within this, theyâ€™ll be a nested \u003cstrong\u003ereference\u003c/strong\u003e directory that contains the generated png file.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"943\" height=\"340\" src=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22.png 943w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-300x108.png 300w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-768x277.png 768w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-500x180.png 500w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-150x54.png 150w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-400x144.png 400w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-800x288.png 800w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.08.22-200x72.png 200w\" sizes=\"(max-width: 943px) 100vw, 943px\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIf you open up this file youâ€™ll notice an image representation of our composable, this will be the same as you should see in the generated preview within Android Studio.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"191\" height=\"126\" src=\"https://joebirch.co/wp-content/uploads/2024/05/academy.droid_.screenshot_testing.ScreenshotTest.GreetingPreview_3d8b4969_da39a3ee_0-1.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2024/05/academy.droid_.screenshot_testing.ScreenshotTest.GreetingPreview_3d8b4969_da39a3ee_0-1.png 191w, https://joebirch.co/wp-content/uploads/2024/05/academy.droid_.screenshot_testing.ScreenshotTest.GreetingPreview_3d8b4969_da39a3ee_0-1-150x99.png 150w\" sizes=\"(max-width: 191px) 100vw, 191px\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eValidating Screenshots\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that our screenshots have been generated, we can validate our existing implementation against them. Weâ€™ll do this by running the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"markdown\"\u003e./gradlew validateDebugScreenshotTest\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe havenâ€™t changed any of our composable implementation, so as expected, the screenshot validation provides us with a successful result.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"767\" height=\"588\" src=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42.png 767w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42-300x230.png 300w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42-500x383.png 500w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42-150x115.png 150w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42-400x307.png 400w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.25.42-200x153.png 200w\" sizes=\"(max-width: 767px) 100vw, 767px\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSo that we can see an example of this failing, letâ€™s go ahead and tweak the styling of our composable. For examples sake, letâ€™s image an engineer changes the \u003cstrong\u003econtainerColor\u003c/strong\u003e of our \u003cstrong\u003eTextButton\u003c/strong\u003e.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun ActionButton(modifier: Modifier = Modifier) {\n    TextButton(modifier = modifier, onClick = { }, colors = ButtonDefaults.textButtonColors(\n        containerColor = MaterialTheme.colorScheme.secondaryContainer,\n        contentColor = MaterialTheme.colorScheme.onSecondary\n    )) {\n        Text(\n            text = \u0026#34;Sign Up\u0026#34;\n        )\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIntentional or not, if we run the same test command again we will see that the tests fail because the result of our test does not match the snapshots in our project. This failure alerts us that something visual has changed in our composable, drawing our attention to it so that we can avoid a UI regression.\u003c/p\u003e\n\n\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"768\" height=\"613\" src=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52.png\" alt=\"\" srcset=\"https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52.png 768w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52-300x239.png 300w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52-500x399.png 500w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52-150x120.png 150w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52-400x319.png 400w, https://joebirch.co/wp-content/uploads/2024/05/Screenshot-2024-05-23-at-07.24.52-200x160.png 200w\" sizes=\"(max-width: 768px) 100vw, 768px\"/\u003e\u003c/figure\u003e\u003c/div\u003e\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eWhen to run screenshot commands\u003c/h2\u003e\n\n\n\n\u003cp\u003eFrom the above section youâ€™ll notice that there were two commands we used â€“ \u003cstrong\u003eupdateDebugScreenshotTest\u003c/strong\u003e and \u003cstrong\u003evalidateDebugScreenshotTest\u003c/strong\u003e. With these commands we need to make sure that our screenshots are kept up-to-date with the latest changes in our project, but we donâ€™t want to be updating them all of the time â€“ as we could accidentally update screenshots with UI regressions.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor \u003cstrong\u003evalidateDebugScreenshotTest\u003c/strong\u003e, weâ€™ll want to run this whenever code is being committed to the project â€“ so ideally on pull requests, failing the request if the check fails.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen it comes to \u003cstrong\u003eupdateDebugScreenshotTest\u003c/strong\u003e, weâ€™ll only want to run this when there are \u003cstrong\u003eintended\u003c/strong\u003e changes made to our UI. Some examples of this could include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003emaking a change to a component in our design system\u003c/li\u003e\n\n\n\n\u003cli\u003eadding a new component to a pre-existing screen\u003c/li\u003e\n\n\n\n\u003cli\u003eadding a new screen that we want to have screenshot tests for\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWith the examples above, we can see that we only want to run this update command when we are making intended changes to screens and/or components. It could also be the case that we have a pull request that makes intended and unintended changes â€“ so it could be possible to accidentally update screenshots when it was not intended to.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo avoid any accident changes, \u003cstrong\u003eupdateDebugScreenshotTest\u003c/strong\u003e should not be run automatically by CI and any screenshot changes in pull requests should be flagged be automation so that changes can be checked by reviewers.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf youâ€™re looking to learn more about how to automate these kinds of processes in your Android projects, \u003ca href=\"https://androidactions.com/\"\u003echeck out my new book\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eAnd thatâ€™s it! As we can see, adding screenshot tests for our composables involves very little effort. With these tests we can reduce the number of UI regressions occurring our project, helping us to create a consistent design experience in our app.\u003c/p\u003e\n\n\n\n\u003cp\u003eIâ€™ll be taking a look at some more things from Google I/O in some following posts, so stated tuned for more Android!\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-05-23T12:46:15Z",
  "modifiedTime": "2024-05-23T15:20:23Z"
}
