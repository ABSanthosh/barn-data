{
  "id": "bb86bb36-c6c2-435e-9fdb-07e2a70c918b",
  "title": "All About Opt-In Annotations",
  "link": "https://zsmb.co/opt-in-annotations/",
  "description": "Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.",
  "author": "Márton Braun",
  "published": "Tue, 28 Sep 2021 15:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 13262,
  "excerpt": "Have you ever encountered APIs that show warnings or errors when you use them, saying that they're internal or experimental? In this guide, you'll learn everything you need to know about opt-in APIs in Kotlin: how to create and use them, and all their nuances.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "The opt-in mechanism in Kotlin allows you to mark APIs that should be used carefully – or perhaps not at all. If you mark a declaration (a class, a function, a property, anything really) as opt-in required, using it will produce a warning or error in the code, prompting the user to explicitly opt in to using it. This can guarantee that there has been a conscious decision made about using the API on the use site. This post was updated in March 2024, removing the outdated instructions about opting in for opt-in annotations, and converting Gradle snippets from Groovy to Kotlin. This is very similar to how you deprecate declarations to prevent people from using them. You can read more about deprecations in Maintaining Compatibility in Kotlin Libraries. Opt-in APIs are really useful if you’re building libraries, but it also applies if you want to control the visibility and usages of APIs within any multi-module project. You also have to know how to interact with opt-in APIs correctly as a user. In this article, we’ll look at everything you need to know about opt-in APIs: How to create them How to use them Real life use cases and useful conventions And we’ll also touch on some auxiliary topics around opt-in: Java interop Android usage API verification We have a lot of ground to cover, so let’s get started. Feel free to use the links above to jump around to different parts of this guide! Creating Opt-In APIs First, let’s see how you can create APIs that will require their users to opt-in to using them. This is done in two steps: Creating an opt-in marker annotation Marking APIs as opt-in required Creating an Opt-in Marker Annotation To create an opt-in marker annotation, create a new annotation class and annotate it with RequiresOptIn: package com.example.lib.core @RequiresOptIn( level = RequiresOptIn.Level.WARNING, message = \"This is an experimental API. It may be changed or removed in the future.\" ) public annotation class ExperimentalLibraryApi This annotation has very similar properties to the @Deprecated annotation. Let’s review what they are. First, you can set a severity level: WARNING will show a yellow warning on the call site and a warning during compilation. This is a “soft” warning, as it can be ignored and the code will still compile. ERROR will cause a “hard” compilation error on the call site. Anyone using an API that has this opt-in level must explicitly opt-in to using it, otherwise their code won’t compile. You can also set a message that describes what the given opt-in marker annotation indicates. For this example, we’re creating an annotation to mark APIs that are still experimental in a library, but are expected to become stable in later versions. Note that marking experimental APIs is just one use case for opt-in annotations. See the Use Cases and Conventions below for other examples. Marking APIs as Opt-in Required With the marker annotation created, you can now mark pieces of API as experimental! For example, you can annotate a function like this: @ExperimentalLibraryApi public fun someExperimentalApi() Calling this function will now produce a warning on the call site: You can also place these markers on larger scopes. For example, you can mark an entire class: @ExperimentalLibraryApi class Stack { fun push(data: Int) fun pop(): Int } With this in place, any usage of the class’ APIs (as well as the usage of the type itself) will produce warnings: Let’s see how you can handle these on the call site. Using Opt-In APIs There are several ways of making the warnings and errors produced by calling opt-in APIs go away. Let’s see when you want to use each of them. Propagating the Opt-in Requirement One way to use an opt-in API is to mark the code that’s calling it with the same opt-in annotation, propagating the requirement further: @ExperimentalLibraryApi public fun anotherExperimentalApi() { someExperimentalApi() } This allows you to use other APIs that are marked with the same annotation within the implementation of this function. However, anyone using this function will now have to deal with the opt-in requirement as well. This is useful within your own code to make sure that you don’t accidentally create stable APIs that rely on experimental APIs in their implementation. If something relies on an experimental declaration, it too should likely be experimental. However, you shouldn’t do this in client code, as that’d just be putting off the issue. Instead, you want to actually opt in there. We’ll look at this next. Opting in an Entire Module If you want to enable all usages of a certain kind of opt-in API in a module, you can use the same -Xopt-in compiler option that you used to opt in to using opt-in earlier, but provide the specific annotation as the value. This configuration allows all usages of our experimental APIs within its module: kotlin { compilerOptions { freeCompilerArgs.add(\"-Xopt-in=com.example.lib.core.ExperimentalLibraryApi\") } } You should use this with care, as enabling a certain opt-in API module-wide can lead to creating lots of usages of that API accidentally. Since there are no warnings in the code this way, you can easily miss these usages. On the other hand, this fits certain use cases really well, such as opting in to using internal APIs that are shared between different modules of the same library. Opting in Locally A more precise approach is opting in locally. You can do this for each usage of opt-in APIs, using the OptIn annotation: public fun clientCode() { @OptIn(InternalMyLibraryApi::class) someExperimentalApi() } This comes with the benefit that each usage of opt-in APIs will be clearly visible in the code thanks to the OptIn annotation being present on the use site. You can opt-in at the statement level, like seen above, but also in broader scopes, such as for an entire function: @OptIn(InternalMyLibraryApi::class) public fun clientCode() { someExperimentalApi() someExperimentalApi() } Or even an entire file, using an annotation use-site target, @file: : @file:OptIn(InternalMyLibraryApi::class) public fun firstFunction() { someExperimentalApi() } public fun secondFunction() { someExperimentalApi() } Next, let’s expand beyond using these annotations to mark experimental APIs, and see what other scenarios they can be useful in. Use Cases and Conventions Some of the best examples of opt-in APIs are in first-party Kotlin libraries. A great example is the kotlinx.coroutines library, which uses four different opt-in marker annotations across its API. The annotation naming conventions used in this library are also widely adopted in other libraries. You should consider aligning your own opt-in usages with this as well. These opt-in annotations all follow the [Prefix][LibraryName]Api pattern, and each prefix carries different semantics. Let’s see what each of them mean: ExperimentalCoroutinesApi: Perhaps the most frequently used convention, it marks APIs that are not stable yet. These might have known issues or ongoing design discussions that can change the API or its behaviour in the future. InternalCoroutinesApi: Marks APIs that are only exposed for cross-module usage within a single library group, and should not be relied on by end users. They should be considered internal and can change or be removed at any time. See Mastering API Visibility in Kotlin for a detailed example of how to use these. ObsoleteCoroutinesApi: A more niche marker than previous ones, this marks APIs that should not be used anymore. However, they are not deprecated yet, as they don’t have replacements ready that users could migrate to. DelicateCoroutinesApi: Another niche convention, delicate APIs should only be used in very specific situations, and users should make sure they understand the implications of using such APIs. On Android, Google’s own Jetpack libraries also make generous use of opt-in APIs. In the API guidelines document for Jetpack, using opt-in annotations is the recommended way of “annotating API surfaces as unstable”. As a result, you’ll see lots of these annotations when interacting with Jetpack libraries. They are especially widespread in Jetpack Compose libraries, given that the framework is still very new. Some common examples of these: InternalComposeApi and ExperimentalComposeApi InternalFoundationApi andExperimentalFoundationApi ExperimentalMaterialApi InternalTextApi and ExperimentalTextApi InternalComposeUiApi and ExperimentalComposeUiApi InternalTestApi and ExperimentalTestApi … and more! As you can see, these usually come in pairs, and a separate pair is created for each of the different Compose packages. They are generally not documented in Kdoc, but you can find out what their purpose is by reading the provided message. A good place to do this is on cs.android.com. For example, you can find the sources of InternalFoundationApi here, and the sources of ExperimentalFoundationApi here, in the same package. They, of course, follow the conventions layed out by kotlinx.coroutines above. Java Interop Until now, we’ve discussed using Kotlin’s own opt-in annotations: kotlin.RequiresOptIn and kotlin.OptIn. Usages of these are verified by the Kotlin compiler, which produces warnings and errors around them as needed. In most cases, the API marked with opt-in annotations is public, but the annotation being present deters clients from using it. However, when Java source code uses these APIs, they’ll only see it as regular public API. The Java compiler does not understand or respect these opt-in requirements. You can either ignore this and accept that Java users (if they exist) will be able to access these APIs freely, and not be warned at all, or you can take extra steps to make sure that Java clients don’t access opt-in APIs accidentally. One solution is to mark your opt-in declarations with @JvmSynthetic as well. Synthetic declarations are inaccessible from Java source code, preventing all Java usages of these APIs (with no way to opt-in). @JvmSynthetic @ExperimentalLibraryApi public fun someExperimentalApi() If you’re on Android, keep reading for another one. Opt-In on Android Android is now officially Kotlin-first, but Java is also still a fully-supported language on the platform. To work around the Java compatibility issue described above, Android has its own set of opt-in annotations (androidx.annotation.RequiresOptIn and androidx.annotation.OptIn), which can be used the exact same way as described earlier for the Kotlin annotations. The difference is in how these are verified. Instead of the Kotlin compiler performing the checks, verifying these Android-specific annotations is up to the Android Lint tool. As Lint checks are performed on the UAST (Unified Abstract Syntax Tree), these annotations are verified not only in Kotlin, but also in Java code. This means that the opt-in marker annotation, its usage, and the code using the opt-in APIs can all be in either language. To use these annotations in your project, you need to add a dependency on the annotation-experimental artifact: dependencies { implementation(\"androidx.annotation:annotation-experimental:1.4.0\") } Note that you can still use the Kotlin opt-in system on Android, you’ll just miss out on Java support. API Verification If you mark some pieces of public API in your module as experimental or internal using opt-in annotations, you will probably want to ignore them when checking for changes (especially breaking changes) in your public API. A common tool you can use for Kotlin projects is the Binary compatibility validator plugin. This plugin calls annotations that mark API that shouldn’t be considered public “non-public markers”. These can be configured in the plugin’s configuration block by adding the fully qualified names of the marker annotations to nonPublicMarkers: apiValidation { nonPublicMarkers.add(\"com.example.lib.core.InternalLibraryApi\") } APIs annotated with non-public markers will be excluded from the API dumps of the validator plugin (they won’t show up in the generated .api files). Conclusion That’s – hopefully – everything you’d ever want to know about opt-in annotations, and more. With this, you should now be ready to use these annotations in your own library or multi-module projects as well, whether you just need to interact with experimental APIs while building your apps or create your own opt-in APIs. Thanks to István Juhos, Arnaud Giuliani, Thomas Künneth, and Annyce Davis for taking an early look and reviewing this post :) When designing a library, minimizing your API surface - the types, methods, properties, and functions you expose to the outside world - is a great idea. This doesn't apply to just libraries: it's a consideration you should make for every module in a multi-module project.Not breaking client code is an essential duty of a library developer. Let's take a look at a couple rarely discussed issues you might face in this area.Introducing a new library to conveniently require values from common Android types.Kotlin 1.5 will bring exciting new features, among them improvements to sealed classes and an introduction of sealed interfaces. Let's take a look at what that will look like!",
  "image": "https://zsmb.co/images/opt-in-annotations/meta.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003eThe \u003ca href=\"https://kotlinlang.org/docs/opt-in-requirements.html\"\u003eopt-in mechanism in Kotlin\u003c/a\u003e allows you to mark APIs that should be used carefully – or perhaps not at all. If you mark a declaration (a class, a function, a property, anything really) as \u003cem\u003eopt-in required\u003c/em\u003e, using it will produce a warning or error in the code, prompting the user to explicitly opt in to using it. This can guarantee that there has been a conscious decision made about using the API on the use site.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis post was updated in March 2024, removing the outdated instructions about opting in for opt-in annotations, and converting Gradle snippets from Groovy to Kotlin.\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis is \u003cem\u003every\u003c/em\u003e similar to how you deprecate declarations to prevent people from using them. You can read more about deprecations in \u003ca href=\"https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/#deprecation\"\u003eMaintaining Compatibility in Kotlin Libraries\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOpt-in APIs are really useful if you’re building libraries, but it also applies if you want to control the visibility and usages of APIs within any multi-module project. You also have to know how to interact with opt-in APIs correctly as a user.\u003c/p\u003e\n\u003cp\u003eIn this article, we’ll look at everything you need to know about opt-in APIs:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#creating-opt-in-apis\"\u003eHow to create them\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#using-opt-in-apis\"\u003eHow to use them\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#use-cases-and-conventions\"\u003eReal life use cases and useful conventions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd we’ll also touch on some auxiliary topics around opt-in:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#java-interop\"\u003eJava interop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#opt-in-on-android\"\u003eAndroid usage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#api-verification\"\u003eAPI verification\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe have a lot of ground to cover, so let’s get started. Feel free to use the links above to jump around to different parts of this guide!\u003c/p\u003e\n\u003ch2 id=\"creating-opt-in-apis\"\u003eCreating Opt-In APIs\u003c/h2\u003e\n\u003cp\u003eFirst, let’s see how you can create APIs that will require their users to opt-in to using them. This is done in two steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCreating an opt-in marker annotation\u003c/li\u003e\n\u003cli\u003eMarking APIs as opt-in required\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"creating-an-opt-in-marker-annotation\"\u003eCreating an Opt-in Marker Annotation\u003c/h4\u003e\n\u003cp\u003eTo create an opt-in marker annotation, create a new \u003ccode\u003eannotation class\u003c/code\u003e and annotate it with \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-requires-opt-in/\"\u003e\u003ccode\u003eRequiresOptIn\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage com.example.lib.core\n\n@RequiresOptIn(\n    level = RequiresOptIn.Level.WARNING,\n    message = \u0026#34;This is an experimental API. It may be changed or removed in the future.\u0026#34;\n)\npublic annotation class ExperimentalLibraryApi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis annotation has very similar properties to the \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/\"\u003e\u003ccode\u003e@Deprecated\u003c/code\u003e\u003c/a\u003e annotation. Let’s review what they are.\u003c/p\u003e\n\u003cp\u003eFirst, you can set a severity \u003ccode\u003elevel\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eWARNING\u003c/code\u003e will show a yellow warning on the call site and a warning during compilation. This is a “soft” warning, as it can be ignored and the code will still compile.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eERROR\u003c/code\u003e will cause a “hard” compilation error on the call site. Anyone using an API that has this opt-in level \u003cem\u003emust\u003c/em\u003e explicitly opt-in to using it, otherwise their code won’t compile.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can also set a \u003ccode\u003emessage\u003c/code\u003e that describes what the given opt-in marker annotation indicates. For this example, we’re creating an annotation to mark APIs that are still experimental in a library, but are expected to become stable in later versions.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that marking experimental APIs is just one use case for opt-in annotations. See the \u003ca href=\"#use-cases-and-conventions\"\u003eUse Cases and Conventions\u003c/a\u003e below for other examples.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"marking-apis-as-opt-in-required\"\u003eMarking APIs as Opt-in Required\u003c/h4\u003e\n\u003cp\u003eWith the marker annotation created, you can now mark pieces of API as experimental! For example, you can annotate a function like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@ExperimentalLibraryApi\npublic fun someExperimentalApi()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCalling this function will now produce a warning on the call site:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/opt-in-annotations/function-warning.png\" alt=\"Warning on the call site of the function\"/\u003e\u003c/p\u003e\n\u003cp\u003eYou can also place these markers on larger scopes. For example, you can mark an entire class:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@ExperimentalLibraryApi\nclass Stack {\n    fun push(data: Int)\n    fun pop(): Int\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this in place, any usage of the class’ APIs (as well as the usage of the type itself) will produce warnings:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/opt-in-annotations/class-warnings.png\" alt=\"Warnings on the call site of the class\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s see how you can handle these on the call site.\u003c/p\u003e\n\u003ch2 id=\"using-opt-in-apis\"\u003eUsing Opt-In APIs\u003c/h2\u003e\n\u003cp\u003eThere are several ways of making the warnings and errors produced by calling opt-in APIs go away. Let’s see when you want to use each of them.\u003c/p\u003e\n\u003ch4 id=\"propagating-the-opt-in-requirement\"\u003ePropagating the Opt-in Requirement\u003c/h4\u003e\n\u003cp\u003eOne way to use an opt-in API is to mark the code that’s calling it with the same opt-in annotation, propagating the requirement further:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@ExperimentalLibraryApi\npublic fun anotherExperimentalApi() {\n    someExperimentalApi()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis allows you to use other APIs that are marked with the same annotation within the implementation of this function. However, anyone using \u003cem\u003ethis\u003c/em\u003e function will now have to deal with the opt-in requirement as well.\u003c/p\u003e\n\u003cp\u003eThis is useful within your own code to make sure that you don’t accidentally create stable APIs that rely on experimental APIs in their implementation. If something relies on an experimental declaration, it too should likely be experimental.\u003c/p\u003e\n\u003cp\u003eHowever, you shouldn’t do this in client code, as that’d just be putting off the issue. Instead, you want to actually opt in there. We’ll look at this next.\u003c/p\u003e\n\u003ch4 id=\"opting-in-an-entire-module\"\u003eOpting in an Entire Module\u003c/h4\u003e\n\u003cp\u003eIf you want to enable all usages of a certain kind of opt-in API in a module, you can use the same \u003ccode\u003e-Xopt-in\u003c/code\u003e compiler option that you used to opt in to using opt-in earlier, but provide the specific annotation as the value.\u003c/p\u003e\n\u003cp\u003eThis configuration allows all usages of our experimental APIs within its module:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ekotlin {\n    compilerOptions {\n        freeCompilerArgs.add(\u0026#34;-Xopt-in=com.example.lib.core.ExperimentalLibraryApi\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou should use this with care, as enabling a certain opt-in API module-wide can lead to creating lots of usages of that API accidentally. Since there are no warnings in the code this way, you can easily miss these usages.\u003c/p\u003e\n\u003cp\u003eOn the other hand, this fits certain \u003ca href=\"#use-cases-and-conventions\"\u003euse cases\u003c/a\u003e really well, such as opting in to using internal APIs that are shared between different modules of the same library.\u003c/p\u003e\n\u003ch4 id=\"opting-in-locally\"\u003eOpting in Locally\u003c/h4\u003e\n\u003cp\u003eA more precise approach is opting in locally. You can do this for each usage of opt-in APIs, using the \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-opt-in/\"\u003e\u003ccode\u003eOptIn\u003c/code\u003e\u003c/a\u003e annotation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epublic fun clientCode() {\n    @OptIn(InternalMyLibraryApi::class)\n    someExperimentalApi()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis comes with the benefit that each usage of opt-in APIs will be clearly visible in the code thanks to the \u003ccode\u003eOptIn\u003c/code\u003e annotation being present on the use site.\u003c/p\u003e\n\u003cp\u003eYou can opt-in at the statement level, like seen above, but also in broader scopes, such as for an entire function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@OptIn(InternalMyLibraryApi::class)\npublic fun clientCode() {\n    someExperimentalApi()\n    someExperimentalApi()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr even an entire file, using an \u003ca href=\"https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets\"\u003eannotation use-site target\u003c/a\u003e, \u003ccode\u003e@file:\u003c/code\u003e :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@file:OptIn(InternalMyLibraryApi::class)\n\npublic fun firstFunction() {\n    someExperimentalApi()\n}\n\npublic fun secondFunction() {\n    someExperimentalApi()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, let’s expand beyond using these annotations to mark experimental APIs, and see what other scenarios they can be useful in.\u003c/p\u003e\n\u003ch2 id=\"use-cases-and-conventions\"\u003eUse Cases and Conventions\u003c/h2\u003e\n\u003cp\u003eSome of the best examples of opt-in APIs are in first-party Kotlin libraries. A great example is the \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines\"\u003ekotlinx.coroutines\u003c/a\u003e library, which uses four different opt-in marker annotations across its API.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe annotation naming conventions used in this library are also widely adopted in other libraries. You should consider aligning your own opt-in usages with this as well.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThese opt-in annotations all follow the \u003ccode\u003e[Prefix][LibraryName]Api\u003c/code\u003e pattern, and each prefix carries different semantics. Let’s see what each of them mean:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-experimental-coroutines-api/\"\u003e\u003ccode\u003eExperimentalCoroutinesApi\u003c/code\u003e\u003c/a\u003e: Perhaps the most frequently used convention, it marks APIs that are not stable yet. These might have known issues or ongoing design discussions that can change the API or its behaviour in the future.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-internal-coroutines-api/\"\u003e\u003ccode\u003eInternalCoroutinesApi\u003c/code\u003e\u003c/a\u003e: Marks APIs that are only exposed for cross-module usage within a single library group, and should not be relied on by end users. They should be considered \u003ccode\u003einternal\u003c/code\u003e and can change or be removed at any time. See \u003ca href=\"https://zsmb.co/talks/mastering-api-visibility/\"\u003eMastering API Visibility in Kotlin\u003c/a\u003e for a detailed example of how to use these.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-obsolete-coroutines-api/\"\u003e\u003ccode\u003eObsoleteCoroutinesApi\u003c/code\u003e\u003c/a\u003e: A more niche marker than previous ones, this marks APIs that should not be used anymore. However, they are not deprecated yet, as they don’t have replacements ready that users could migrate to.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-delicate-coroutines-api/\"\u003e\u003ccode\u003eDelicateCoroutinesApi\u003c/code\u003e\u003c/a\u003e: Another niche convention, delicate APIs should only be used in very specific situations, and users should make sure they understand the implications of using such APIs.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn Android, Google’s own Jetpack libraries also make generous use of opt-in APIs. In the \u003ca href=\"https://android.googlesource.com/platform/frameworks/support/+/androidx-main/docs/api_guidelines.md#experimental-api\"\u003eAPI guidelines document for Jetpack\u003c/a\u003e, using opt-in annotations is the recommended way of “annotating API surfaces as unstable”.\u003c/p\u003e\n\u003cp\u003eAs a result, you’ll see lots of these annotations when interacting with Jetpack libraries. They are especially widespread in Jetpack Compose libraries, given that the framework is still very new. Some common examples of these:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/InternalComposeApi\"\u003e\u003ccode\u003eInternalComposeApi\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/runtime/ExperimentalComposeApi\"\u003e\u003ccode\u003eExperimentalComposeApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/InternalFoundationApi\"\u003e\u003ccode\u003eInternalFoundationApi\u003c/code\u003e\u003c/a\u003e and\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/ExperimentalFoundationApi\"\u003e\u003ccode\u003eExperimentalFoundationApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material/ExperimentalMaterialApi\"\u003e\u003ccode\u003eExperimentalMaterialApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/text/InternalTextApi\"\u003e\u003ccode\u003eInternalTextApi\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/text/ExperimentalTextApi\"\u003e\u003ccode\u003eExperimentalTextApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/InternalComposeUiApi\"\u003e\u003ccode\u003eInternalComposeUiApi\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/ExperimentalComposeUiApi\"\u003e\u003ccode\u003eExperimentalComposeUiApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/test/InternalTestApi\"\u003e\u003ccode\u003eInternalTestApi\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/ui/test/ExperimentalTestApi\"\u003e\u003ccode\u003eExperimentalTestApi\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e… and more!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs you can see, these usually come in pairs, and a separate pair is created for each of the different Compose packages.\u003c/p\u003e\n\u003cp\u003eThey are generally not documented in Kdoc, but you can find out what their purpose is by reading the provided \u003ccode\u003emessage\u003c/code\u003e. A good place to do this is on \u003ca href=\"https://cs.android.com/\"\u003ecs.android.com\u003c/a\u003e. For example, you can find the sources of \u003ccode\u003eInternalFoundationApi\u003c/code\u003e \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/InternalFoundationApi.kt\"\u003ehere\u003c/a\u003e, and the sources of \u003ccode\u003eExperimentalFoundationApi\u003c/code\u003e \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/ExperimentalFoundationApi.kt\"\u003ehere\u003c/a\u003e, in the same package.\u003c/p\u003e\n\u003cp\u003eThey, of course, follow the conventions layed out by \u003cem\u003ekotlinx.coroutines\u003c/em\u003e above.\u003c/p\u003e\n\u003ch2 id=\"java-interop\"\u003eJava Interop\u003c/h2\u003e\n\u003cp\u003eUntil now, we’ve discussed using Kotlin’s own opt-in annotations: \u003ccode\u003ekotlin.RequiresOptIn\u003c/code\u003e and \u003ccode\u003ekotlin.OptIn\u003c/code\u003e. Usages of these are verified by the Kotlin compiler, which produces warnings and errors around them as needed.\u003c/p\u003e\n\u003cp\u003eIn most cases, the API marked with opt-in annotations is public, but the annotation being present deters clients from using it. However, when Java source code uses these APIs, they’ll only see it as regular public API. The Java compiler does not understand or respect these opt-in requirements.\u003c/p\u003e\n\u003cp\u003eYou can either ignore this and accept that Java users (if they exist) will be able to access these APIs freely, and not be warned at all, or you can take extra steps to make sure that Java clients don’t access opt-in APIs accidentally.\u003c/p\u003e\n\u003cp\u003eOne solution is to mark your opt-in declarations with \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-synthetic/\"\u003e\u003ccode\u003e@JvmSynthetic\u003c/code\u003e\u003c/a\u003e as well. Synthetic declarations are inaccessible from Java source code, preventing all Java usages of these APIs (with no way to opt-in).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@JvmSynthetic\n@ExperimentalLibraryApi\npublic fun someExperimentalApi()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you’re on Android, keep reading for another one.\u003c/p\u003e\n\u003ch2 id=\"opt-in-on-android\"\u003eOpt-In on Android\u003c/h2\u003e\n\u003cp\u003eAndroid is now officially \u003ca href=\"https://developer.android.com/kotlin/first\"\u003eKotlin-first\u003c/a\u003e, but Java is also still a fully-supported language on the platform. To work around the Java compatibility issue described above, Android has its own set of opt-in annotations (\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/annotation/RequiresOptIn\"\u003e\u003ccode\u003eandroidx.annotation.RequiresOptIn\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/annotation/OptIn\"\u003e\u003ccode\u003eandroidx.annotation.OptIn\u003c/code\u003e\u003c/a\u003e), which can be used the exact same way as described earlier for the Kotlin annotations.\u003c/p\u003e\n\u003cp\u003eThe difference is in how these are verified. Instead of the Kotlin compiler performing the checks, verifying these Android-specific annotations is up to the \u003ca href=\"https://developer.android.com/studio/write/lint\"\u003eAndroid Lint tool\u003c/a\u003e. As Lint checks are performed on the \u003ca href=\"https://plugins.jetbrains.com/docs/intellij/uast.html\"\u003eUAST (Unified Abstract Syntax Tree)\u003c/a\u003e, these annotations are verified not only in Kotlin, but also in Java code. This means that the opt-in marker annotation, its usage, and the code using the opt-in APIs can all be in either language.\u003c/p\u003e\n\u003cp\u003eTo use these annotations in your project, you need to add a dependency on the \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/annotation\"\u003e\u003ccode\u003eannotation-experimental\u003c/code\u003e artifact\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edependencies {\n    implementation(\u0026#34;androidx.annotation:annotation-experimental:1.4.0\u0026#34;)\n}\t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that you can still use the Kotlin opt-in system on Android, you’ll just miss out on Java support.\u003c/p\u003e\n\u003ch2 id=\"api-verification\"\u003eAPI Verification\u003c/h2\u003e\n\u003cp\u003eIf you mark some pieces of public API in your module as experimental or internal using opt-in annotations, you will probably want to ignore them when checking for changes (especially breaking changes) in your public API.\u003c/p\u003e\n\u003cp\u003eA common tool you can use for Kotlin projects is the \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator\"\u003eBinary compatibility validator\nplugin\u003c/a\u003e. This plugin calls annotations that mark API that shouldn’t be considered public “non-public markers”.\u003c/p\u003e\n\u003cp\u003eThese can be configured in the plugin’s configuration block by adding the fully qualified names of the marker annotations to \u003ccode\u003enonPublicMarkers\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapiValidation {\n    nonPublicMarkers.add(\u0026#34;com.example.lib.core.InternalLibraryApi\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAPIs annotated with non-public markers will be excluded from the API dumps of the validator plugin (they won’t show up in the generated \u003ccode\u003e.api\u003c/code\u003e files).\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThat’s – hopefully – everything you’d ever want to know about opt-in annotations, and more. With this, you should now be ready to use these annotations in your own library or multi-module projects as well, whether you just need to interact with experimental APIs while building your apps or create your own opt-in APIs.\u003c/p\u003e\n\u003cp\u003eThanks to \u003ca href=\"https://twitter.com/stewemetal\"\u003eIstván Juhos\u003c/a\u003e, \u003ca href=\"https://twitter.com/arnogiu\"\u003eArnaud Giuliani\u003c/a\u003e, \u003ca href=\"https://twitter.com/tkuenneth\"\u003eThomas Künneth\u003c/a\u003e, and \u003ca href=\"https://twitter.com/brwngrldev\"\u003eAnnyce Davis\u003c/a\u003e for taking an early look and reviewing this post :)\u003c/p\u003e\n\n\u003c/div\u003e\u003cp\u003eWhen designing a library, minimizing your API surface - the types, methods, properties, and functions you expose to the outside world - is a great idea. This doesn\u0026#39;t apply to just libraries: it\u0026#39;s a consideration you should make for every module in a multi-module project.\u003c/p\u003e\u003cp\u003eNot breaking client code is an essential duty of a library developer. Let\u0026#39;s take a look at a couple rarely discussed issues you might face in this area.\u003c/p\u003e\u003cp\u003eIntroducing a new library to conveniently require values from common Android types.\u003c/p\u003e\u003cp\u003eKotlin 1.5 will bring exciting new features, among them improvements to sealed classes and an introduction of sealed interfaces. Let\u0026#39;s take a look at what that will look like!\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
