{
  "id": "d3620a44-fbc9-4969-bcaa-80edee0506b3",
  "title": "Exploring Thread-Safe Lazy Initialization with Coroutines: LazySuspend Comes into Play",
  "link": "https://proandroiddev.com/exploring-lazysuspend-in-kotlin-a-thread-safe-lazy-initialization-with-coroutines-4cf8e18f55ac?source=rss----c72404660798---4",
  "description": "",
  "author": "Leo N",
  "published": "Fri, 07 Feb 2025 21:35:40 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "kotlin",
    "coroutine",
    "androiddev"
  ],
  "byline": "Leo N",
  "length": 8445,
  "excerpt": "In October 2018, a GitHub user proposed introducing a suspending version of Kotlin‚Äôs lazy { ... } function to handle expensive initializations without blocking threads. While lazy effectively defers‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "ü§î Problem StatementIn October 2018, a GitHub user proposed introducing a suspending version of Kotlin‚Äôs lazy { ... } function to handle expensive initializations without blocking threads. While lazy effectively defers initialization until needed, it can still block execution, making it less suitable for coroutine-based, non-blocking applications. To solve this, contributors suggested using async(start = LAZY), allowing initialization to be deferred and executed asynchronously on first access. Several custom coroutine-based implementations emerged to bridge this gap, but despite strong interest, the feature was never integrated into the standard Kotlin library.As of now, the Kotlin standard library does not include a built-in suspending version of the lazy function. The discussion on GitHub Issue #706 concluded without integrating this feature into the library. In the meantime, developers have explored alternative approaches, such as Mr Roman Elizarov, from his gistüì£ üì£ üì£ Everyone finding this gist via Google! Modern kotlinx.coroutines has out-of-the-box support for asyncLazy with the following expression: val myLazyValue = async(start = CoroutineStart.LAZY) { ... }. Use myLazyValue.await() when you need it.as well as lazily-started-async. However, it's important to note that the use of CoroutineStart.LAZY has been debated within the community. A recent discussion in GitHub Issue #4147 considered discouraging its use due to potential complexities and difficulties in code readability.Given these considerations, if you require suspending lazy initialization, you might opt for a custom implementation tailored to your specific use case. So, how can we implement true non-blocking lazy initialization in coroutines?Let‚Äôs explore some practical solutions. üöÄüéØ Introductionüî• ImplementationüèÜ Conclusionüåê ReferencesüéØ IntroductionLazy initialization is a powerful pattern that delays object creation until it‚Äôs actually needed, improving performance and resource management. But what if you need to initialize a value asynchronously inside Kotlin coroutines? That‚Äôs where LazySuspend comes in! üåüüõ† Why Do We Need LazySuspend?Kotlin provides lazy {} for synchronous lazy initialization, but it does not support suspending functions. Imagine you need to load data from a database or fetch an API response asynchronously. ü§Ø Consider this example:val storageProvider by lazy { initializeStorageProvider() // Cannot be a suspend function üò¢}suspend fun initializeStorageProvider(){ // ... long-running task}This won‚Äôt work if initializeStorageProvider is a suspend function! Instead, we need a coroutine-friendly lazy initialization mechanism. üí°üî• Implementation1Ô∏è‚É£ Approach 1import kotlinx.coroutines.*import kotlin.coroutines.*class LazySuspend\u003cT\u003e(private val initializer: suspend () -\u003e T) { @Volatile private var cachedValue: T? = null private val mutex = Mutex() suspend fun getValue(): T { if (cachedValue != null) return cachedValue!! return mutex.withLock { if (cachedValue == null) { cachedValue = initializer() } cachedValue!! } }}‚úÖ Uses a suspending function for initialization.‚úÖ Uses a mutex (withLock) to ensure thread safety (prevents race conditions in multithreading).‚úÖ Stores the computed value after the first call, so subsequent calls return instantly.suspend fun main() { val lazyValue = LazySuspend { println(\"Initializing...\") delay(1000) // Simulate long computation \"Hello, Coroutine Lazy!\" } println(\"Before accessing value...\") println(\"Value: ${lazyValue.getValue()}\") // Triggers initialization println(\"Value again: ${lazyValue.getValue()}\") // Uses cached value}// outputBefore accessing value...Initializing...Value: Hello, Coroutine Lazy!Value again: Hello, Coroutine Lazy!2Ô∏è‚É£ Approach 2: Deferredclass LazySuspendDeferred\u003cT\u003e(scope: CoroutineScope, initializer: suspend () -\u003e T) { private val deferred = scope.async(start = CoroutineStart.LAZY) { initializer() } suspend fun getValue(): T = deferred.await()}3Ô∏è‚É£ Approach 3: SuspendLazy from kt.academyThis function allows deferred execution of a block of code that is initialized only once in a coroutine, similar to lazy initialization. It ensures thread safety by using a Mutex and provides mechanisms to handle initialization failures and context propagation, for further details, visit the original article.https://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f0424Ô∏è‚É£ Approach 4: LazySuspend from ME ‚úåÔ∏èüòäWhy I choose LazySuspend instead of SuspendLazy?Both LazySuspend and SuspendLazy are reasonable names, but the better choice depends on readability, consistency, and convention.Matches the existing lazy { ... } function in Kotlin.Emphasizes ‚Äúlazy‚Äù behavior first, making it clear this is an alternative to lazy { ... }.Easier to recognize for Kotlin developers already familiar with lazy.The approach 3 may have some ‚ú® potential improvements, so that‚Äôs why I come up with LazySuspend‚úÖ Avoid Unsafe Casts: The code currently casts holder to T, which might cause issues if holder was never properly assigned. Instead, you can use a sealed class or an AtomicReference.üîê Ensuring Thread-Safety with Mutex we ensure that only one coroutine initializes the value at a time, preventing race conditions. üèéüí®‚ö†Ô∏è Handling Exceptions Gracefully: If the initializer fails, holder remains Any?, causing an unsafe cast, leading to a ClassCastException.https://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123aeLazyState Sealed Class: This class is used to represent the current state of a value, whether it‚Äôs uninitialized, initialized with a value, or failed due to an exception.LazySuspend Interface: This interface extends a suspending function (suspend () -\u003e T) and adds additional properties and methods:isInitialized: A boolean property to check if the value has been initialized.getOrNull(): Returns the value if initialized, or null if not.invoke(): The main suspending function to retrieve the lazily initialized value.lazySuspend Function: This function creates an instance of LazySuspend that lazily initializes a value using the provided suspending function (initializer). It uses atomic references for thread-safety and double-checked locking to ensure that the value is initialized only once.How can I ensure that the LazySuspend initialization runs on a background thread instead of the main thread in Kotlin?To ensure that the lazySuspend initialization does not run on the main thread, you can explicitly use a different coroutine dispatcher when invoking the suspending function inside the initializer. You can use Dispatchers.IO, Dispatchers.Default, or any custom dispatcher to offload the work to a background thread. Here‚Äôs how you can modify your lazySuspend initialization to run on a background thread:import kotlinx.coroutines.*val lazyValue = lazySuspend { withContext(Dispatchers.IO) { // Ensure this runs on a background thread println(\"Initialized on thread: ${Thread.currentThread().name}\") longRunningTask() // Simulate some background work }}üö® DisclaimersApproach 4 may have some disadvantages:Complexity: The custom implementation adds complexity compared to Kotlin‚Äôs built-in lazy.Potential Overhead: Double-checked locking may introduce unnecessary overhead in single-threaded scenarios.Limited Use Case: The extra control may not be required for simpler lazy initialization needs.üèÜ ConclusionThe LazySuspend interface includes methods to check if the value is initialized (isInitialized), retrieve it if available (getOrNull()), and lazily initialize it when accessed (invoke()). The LazySuspend provides lazy, suspend-aware initialization while ensuring thread safety and error handling. üöÄ Whether you're fetching API data, caching results, or managing expensive computations, LazySuspend is a powerful tool in your Kotlin arsenal.Give it a try in your next project! üõ†Ô∏è// Step 1: Grab from Maven central at the coordinates:repositories { google() mavenCentral() maven { url = uri(\"https://maven.pkg.github.com/nphausg/loomIn\") }}// Step 2: Implementation from your module$latestVersion = \"0.0.1-alpha\"implementation(\"com.nphausg:loom:$latestVersion\")üåê ReferencesKotlin Coroutines Documentation ‚Äî Kotlinlang.orgMutex in Kotlin Coroutines ‚Äî Kotlin Coroutines GuideLazy Initialization in Kotlin ‚Äî JetBrains BlogAtomicReference in Java ‚Äî Java Documentation",
  "image": "https://miro.medium.com/v2/resize:fit:1019/1*aGYc3X0_UTO4kZT9IJX10g.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://nphausg.medium.com/?source=post_page---byline--4cf8e18f55ac--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Leo N\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Tb0dILXcghQeKPocCvlv6g.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--4cf8e18f55ac--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"d12f\"\u003eü§î Problem Statement\u003c/h2\u003e\u003cp id=\"c392\"\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/706\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eIn October 2018, a GitHub user proposed introducing a \u003cstrong\u003esuspending version\u003c/strong\u003e\u003c/a\u003e of Kotlin‚Äôs \u003ccode\u003elazy { ... }\u003c/code\u003e function to handle expensive initializations \u003cstrong\u003ewithout blocking threads\u003c/strong\u003e. While \u003ccode\u003elazy\u003c/code\u003e effectively defers initialization until needed, it can still \u003cstrong\u003eblock\u003c/strong\u003e execution, making it less suitable for coroutine-based, non-blocking applications. To solve this, contributors suggested using \u003ccode\u003easync(start = LAZY)\u003c/code\u003e, allowing initialization to be deferred and executed \u003cstrong\u003easynchronously\u003c/strong\u003e on first access. Several custom coroutine-based implementations emerged to bridge this gap, but despite strong interest, the feature was \u003cstrong\u003enever integrated\u003c/strong\u003e into the standard Kotlin library.\u003c/p\u003e\u003cp id=\"a608\"\u003eAs of now, the Kotlin standard library \u003cstrong\u003edoes not include a built-in suspending version of the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003elazy\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e function\u003c/strong\u003e. The discussion on \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/issues/706\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Issue #706\u003c/a\u003e concluded without integrating this feature into the library. In the meantime, developers have explored alternative approaches, such as Mr \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/4762e889f8fc?source=post_page---user_mention--4cf8e18f55ac--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eRoman Elizarov\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e, from his \u003ca href=\"https://gist.github.com/elizarov/f27400a55c1502aacc35b4a3b2f5c9af\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egist\u003c/a\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"816e\"\u003eüì£ üì£ üì£ Everyone finding this gist via Google! Modern \u003ccode\u003ekotlinx.coroutines\u003c/code\u003e has out-of-the-box support for \u003ccode\u003easyncLazy\u003c/code\u003e with the following expression: \u003ccode\u003eval myLazyValue = async(start = CoroutineStart.LAZY) { ... }\u003c/code\u003e. Use \u003ccode\u003emyLazyValue.await()\u003c/code\u003e when you need it.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3dd2\"\u003eas well as \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/topics/composing-suspending-functions.md#lazily-started-async\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elazily-started-async\u003c/a\u003e. However, it\u0026#39;s important to note that the use of \u003ccode\u003eCoroutineStart.LAZY\u003c/code\u003e has been debated within the community. A recent discussion in \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/pull/4147#discussion_r1696736494\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub Issue #4147\u003c/a\u003e considered discouraging its use due to potential complexities and difficulties in code readability.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"debb\"\u003e\u003cem\u003eGiven these considerations, if you require suspending lazy initialization, you might opt for a custom implementation tailored to your specific use case. So, how can we implement \u003c/em\u003e\u003cstrong\u003e\u003cem\u003etrue non-blocking lazy initialization\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e in coroutines?\u003c/em\u003e\u003c/p\u003e\u003cp id=\"bd79\"\u003e\u003cem\u003eLet‚Äôs explore some practical solutions. üöÄ\u003c/em\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7440\"\u003eüéØ Introduction\u003c/li\u003e\u003cli id=\"42c2\"\u003eüî• Implementation\u003c/li\u003e\u003cli id=\"3ea8\"\u003eüèÜ Conclusion\u003c/li\u003e\u003cli id=\"793c\"\u003eüåê References\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"25d1\"\u003eüéØ Introduction\u003c/h2\u003e\u003cp id=\"f268\"\u003e\u003cstrong\u003eLazy\u003c/strong\u003e initialization is a powerful pattern that delays object creation until it‚Äôs actually needed, improving performance and resource management. But what if you need to initialize a value \u003cstrong\u003easynchronously\u003c/strong\u003e inside Kotlin coroutines? That‚Äôs where \u003ccode\u003eLazySuspend\u003c/code\u003e comes in! üåü\u003c/p\u003e\u003ch2 id=\"6040\"\u003eüõ† Why Do We Need \u003ccode\u003eLazySuspend\u003c/code\u003e?\u003c/h2\u003e\u003cp id=\"f405\"\u003eKotlin provides \u003ccode\u003elazy {}\u003c/code\u003e for \u003cstrong\u003esynchronous\u003c/strong\u003e lazy initialization, but it does not support suspending functions. Imagine you need to load data from a database or fetch an API response asynchronously. ü§Ø Consider this example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3430\"\u003eval storageProvider by lazy {\u003cbr/\u003e    initializeStorageProvider() // Cannot be a suspend function üò¢\u003cbr/\u003e}\u003cp\u003esuspend fun initializeStorageProvider(){\u003cbr/\u003e   // ... long-running task\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7d64\"\u003eThis won‚Äôt work if \u003ccode\u003einitializeStorageProvider\u003c/code\u003e is a \u003ccode\u003esuspend\u003c/code\u003e function! Instead, we need a coroutine-friendly lazy initialization mechanism. üí°\u003c/p\u003e\u003ch2 id=\"d357\"\u003eüî• Implementation\u003c/h2\u003e\u003ch2 id=\"272c\"\u003e1Ô∏è‚É£ Approach 1\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"104a\"\u003eimport kotlinx.coroutines.*\u003cbr/\u003eimport kotlin.coroutines.*\u003cp\u003eclass LazySuspend\u0026lt;T\u0026gt;(private val initializer: suspend () -\u0026gt; T) {\u003cbr/\u003e    @Volatile\u003cbr/\u003e    private var cachedValue: T? = null\u003cbr/\u003e    private val mutex = Mutex()\u003c/p\u003e\u003cp\u003e    suspend fun getValue(): T {\u003cbr/\u003e        if (cachedValue != null) return cachedValue!!\u003c/p\u003e\u003cp\u003e        return mutex.withLock {\u003cbr/\u003e            if (cachedValue == null) {\u003cbr/\u003e                cachedValue = initializer()\u003cbr/\u003e            }\u003cbr/\u003e            cachedValue!!\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"6345\"\u003e‚úÖ Uses a \u003cstrong\u003esuspending function\u003c/strong\u003e for initialization.\u003c/li\u003e\u003cli id=\"4268\"\u003e‚úÖ Uses a \u003cstrong\u003emutex (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ewithLock\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e to ensure \u003cstrong\u003ethread safety\u003c/strong\u003e (prevents race conditions in multithreading).\u003c/li\u003e\u003cli id=\"8301\"\u003e‚úÖ Stores the computed value \u003cstrong\u003eafter the first call\u003c/strong\u003e, so subsequent calls \u003cstrong\u003ereturn instantly\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"0469\"\u003esuspend fun main() {\u003cbr/\u003e    val lazyValue = LazySuspend {\u003cbr/\u003e        println(\u0026#34;Initializing...\u0026#34;)\u003cbr/\u003e        delay(1000)  // Simulate long computation\u003cbr/\u003e        \u0026#34;Hello, Coroutine Lazy!\u0026#34;\u003cbr/\u003e    }\u003cp\u003e    println(\u0026#34;Before accessing value...\u0026#34;)\u003cbr/\u003e    println(\u0026#34;Value: ${lazyValue.getValue()}\u0026#34;)  // Triggers initialization\u003cbr/\u003e    println(\u0026#34;Value again: ${lazyValue.getValue()}\u0026#34;)  // Uses cached value\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// output\u003cbr/\u003eBefore accessing value...\u003cbr/\u003eInitializing...\u003cbr/\u003eValue: Hello, Coroutine Lazy!\u003cbr/\u003eValue again: Hello, Coroutine Lazy!\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"5af5\"\u003e2Ô∏è‚É£ Approach 2: Deferred\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4906\"\u003eclass LazySuspendDeferred\u0026lt;T\u0026gt;(scope: CoroutineScope, initializer: suspend () -\u0026gt; T) {\u003cbr/\u003e    private val deferred = scope.async(start = CoroutineStart.LAZY) { initializer() }\u003cbr/\u003e    suspend fun getValue(): T = deferred.await()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4902\"\u003e3Ô∏è‚É£ Approach 3: SuspendLazy from kt.academy\u003c/h2\u003e\u003cp id=\"44a1\"\u003eThis function allows deferred execution of a block of code that is initialized only once in a coroutine, similar to lazy initialization. It ensures thread safety by using a \u003ccode\u003eMutex\u003c/code\u003e and provides mechanisms to handle initialization failures and context propagation, for further details, visit the \u003ca href=\"https://kt.academy/article/s_suspended_lazy\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eoriginal article\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f042\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/nphausg/d5f8a5e49f199dd4903a696052f5f042\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"e28f\"\u003e4Ô∏è‚É£ Approach 4: LazySuspend from ME ‚úåÔ∏èüòä\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"bb48\"\u003eWhy I choose \u003cstrong\u003eLazySuspend \u003c/strong\u003einstead of \u003cstrong\u003eSuspendLazy?\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"4cb1\"\u003eBoth \u003cstrong\u003eLazySuspend\u003c/strong\u003e and \u003cstrong\u003eSuspendLazy\u003c/strong\u003e are reasonable names, but the better choice depends on \u003cstrong\u003ereadability, consistency, and convention\u003c/strong\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"78b8\"\u003eMatches the existing \u003ccode\u003elazy { ... }\u003c/code\u003e function in Kotlin.\u003c/li\u003e\u003cli id=\"7a6d\"\u003eEmphasizes ‚Äúlazy‚Äù behavior first, making it clear this is an alternative to \u003ccode\u003elazy { ... }\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"3ac9\"\u003eEasier to recognize for Kotlin developers already familiar with \u003ccode\u003elazy\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"1ba2\"\u003eThe approach 3 may have some ‚ú® potential improvements, so that‚Äôs why I come up with LazySuspend\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"588e\"\u003e‚úÖ \u003cstrong\u003eAvoid Unsafe Casts: \u003c/strong\u003eThe code currently casts \u003ccode\u003eholder\u003c/code\u003e to \u003ccode\u003eT\u003c/code\u003e, which might cause issues if \u003ccode\u003eholder\u003c/code\u003e was never properly assigned. Instead, you can use a sealed class or an \u003ccode\u003eAtomicReference\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"0144\"\u003e\u003cstrong\u003eüîê Ensuring Thread-Safety with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMutex\u003c/strong\u003e\u003c/code\u003e we ensure that \u003cstrong\u003eonly one coroutine initializes the value\u003c/strong\u003e at a time, preventing race conditions. üèéüí®\u003c/p\u003e\u003cp id=\"ddfc\"\u003e\u003cstrong\u003e‚ö†Ô∏è Handling Exceptions Gracefully: \u003c/strong\u003eIf the \u003ccode\u003einitializer\u003c/code\u003e fails, \u003ccode\u003eholder\u003c/code\u003e remains \u003ccode\u003eAny?\u003c/code\u003e, causing an unsafe cast, leading to a \u003cstrong\u003eClassCastException\u003c/strong\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123ae\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://gist.github.com/nphausg/d370986b1575b7c75085a6132bc123ae\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"8d50\"\u003e\u003ccode\u003e\u003cstrong\u003eLazyState\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Sealed Class\u003c/strong\u003e: This class is used to represent the current state of a value, whether it‚Äôs uninitialized, initialized with a value, or failed due to an exception.\u003c/li\u003e\u003cli id=\"b39c\"\u003e\u003ccode\u003e\u003cstrong\u003eLazySuspend\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Interface\u003c/strong\u003e: This interface extends a suspending function (\u003ccode\u003esuspend () -\u0026gt; T\u003c/code\u003e) and adds additional properties and methods:\u003c/li\u003e\u003cli id=\"1c9a\"\u003e\u003ccode\u003eisInitialized\u003c/code\u003e: A boolean property to check if the value has been initialized.\u003c/li\u003e\u003cli id=\"1e43\"\u003e\u003ccode\u003egetOrNull()\u003c/code\u003e: Returns the value if initialized, or null if not.\u003c/li\u003e\u003cli id=\"2174\"\u003e\u003ccode\u003einvoke()\u003c/code\u003e: The main suspending function to retrieve the lazily initialized value.\u003c/li\u003e\u003cli id=\"bc28\"\u003e\u003ccode\u003e\u003cstrong\u003elazySuspend\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Function\u003c/strong\u003e: This function creates an instance of \u003ccode\u003eLazySuspend\u003c/code\u003e that lazily initializes a value using the provided suspending function (\u003ccode\u003einitializer\u003c/code\u003e). It uses atomic references for thread-safety and double-checked locking to ensure that the value is initialized only once.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"5058\"\u003eHow can I ensure that the \u003ccode\u003eLazySuspend\u003c/code\u003e initialization runs on a background thread instead of the main thread in Kotlin?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"3a31\"\u003eTo ensure that the \u003ccode\u003elazySuspend\u003c/code\u003e initialization does not run on the main thread, you can explicitly use a different coroutine dispatcher when invoking the suspending function inside the initializer. You can use \u003ccode\u003eDispatchers.IO\u003c/code\u003e, \u003ccode\u003eDispatchers.Default\u003c/code\u003e, or any custom dispatcher to offload the work to a background thread. Here‚Äôs how you can modify your \u003ccode\u003elazySuspend\u003c/code\u003e initialization to run on a background thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bcfa\"\u003eimport kotlinx.coroutines.*\u003cp\u003eval lazyValue = lazySuspend {\u003cbr/\u003e    withContext(Dispatchers.IO) {  // Ensure this runs on a background thread\u003cbr/\u003e        println(\u0026#34;Initialized on thread: ${Thread.currentThread().name}\u0026#34;)\u003cbr/\u003e        longRunningTask()  // Simulate some background work\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d56b\"\u003eüö® Disclaimers\u003c/h2\u003e\u003cp id=\"4441\"\u003eApproach 4 may have some disadvantages:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9649\"\u003e\u003cstrong\u003eComplexity\u003c/strong\u003e: The custom implementation adds complexity compared to Kotlin‚Äôs built-in \u003ccode\u003elazy\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"21af\"\u003e\u003cstrong\u003ePotential Overhead\u003c/strong\u003e: Double-checked locking may introduce unnecessary overhead in single-threaded scenarios.\u003c/li\u003e\u003cli id=\"b298\"\u003e\u003cstrong\u003eLimited Use Case\u003c/strong\u003e: The extra control may not be required for simpler lazy initialization needs.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0dd3\"\u003eüèÜ Conclusion\u003c/h2\u003e\u003cp id=\"6304\"\u003e\u003cem\u003eThe \u003c/em\u003e\u003ccode\u003e\u003cem\u003eLazySuspend\u003c/em\u003e\u003c/code\u003e\u003cem\u003e interface includes methods to check if the value is initialized (\u003c/em\u003e\u003ccode\u003e\u003cem\u003eisInitialized\u003c/em\u003e\u003c/code\u003e\u003cem\u003e), retrieve it if available (\u003c/em\u003e\u003ccode\u003e\u003cem\u003egetOrNull()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e), and lazily initialize it when accessed (\u003c/em\u003e\u003ccode\u003e\u003cem\u003einvoke()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e). \u003c/em\u003eThe \u003ccode\u003eLazySuspend\u003c/code\u003e provides \u003cstrong\u003elazy, suspend-aware initialization\u003c/strong\u003e while ensuring \u003cstrong\u003ethread safety\u003c/strong\u003e and \u003cstrong\u003eerror handling\u003c/strong\u003e. üöÄ Whether you\u0026#39;re fetching API data, caching results, or managing expensive computations, \u003ccode\u003eLazySuspend\u003c/code\u003e is a \u003cstrong\u003epowerful tool\u003c/strong\u003e in your Kotlin arsenal.\u003c/p\u003e\u003cp id=\"a077\"\u003eGive it a try in your next project! üõ†Ô∏è\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7c5b\"\u003e// Step 1: Grab from Maven central at the coordinates:\u003cp\u003erepositories {\u003cbr/\u003e  google()\u003cbr/\u003e  mavenCentral()\u003cbr/\u003e  maven {\u003cbr/\u003e    url = uri(\u0026#34;https://maven.pkg.github.com/nphausg/loomIn\u0026#34;)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Step 2: Implementation from your module\u003cbr/\u003e$latestVersion = \u0026#34;0.0.1-alpha\u0026#34;\u003cbr/\u003eimplementation(\u0026#34;com.nphausg:loom:$latestVersion\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4544\"\u003eüåê References\u003c/h2\u003e\u003cul\u003e\u003cli id=\"73f8\"\u003eKotlin Coroutines Documentation ‚Äî Kotlinlang.org\u003c/li\u003e\u003cli id=\"ef79\"\u003eMutex in Kotlin Coroutines ‚Äî Kotlin Coroutines Guide\u003c/li\u003e\u003cli id=\"48e0\"\u003eLazy Initialization in Kotlin ‚Äî \u003ca href=\"https://blog.jetbrains.com/kotlin/2020/06/idiomatic-kotlin-lazy-initialization/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJetBrains Blog\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5d0c\"\u003eAtomicReference in Java ‚Äî \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicReference.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJava Documentation\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-02-07T21:35:39.921Z",
  "modifiedTime": null
}
