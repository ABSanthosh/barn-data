{
  "id": "787a16a8-614c-4d85-b248-d9a6d0d0bc02",
  "title": "My Evolving Approach to Learning Programming Languages",
  "link": "https://blog.danlew.net/2024/09/24/my-evolving-approach-to-learning-programming-languages/",
  "description": "I’ve recently started a new job that uses Python.The last time I professionally Python’d was 15 years ago, writing backends for mobile apps I worked on. At the time, I was still a novice developer, only a couple years out of college. While I’",
  "author": "Dan Lew",
  "published": "Tue, 24 Sep 2024 13:00:05 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": [
    "python"
  ],
  "byline": "Dan Lew",
  "length": 5118,
  "excerpt": "I’ve recently started a new job that uses Python. The last time I professionally Python’d was 15 years ago, writing backends for mobile apps I worked on. At the time, I was still a novice developer, only a couple years out of college. While I’ve returned to Python from time to time for tiny throwaway scripts, I’ve not seriously examined the language or its ecosystem since. Now I’m back in the thick of it with Python. And it’s been a fascinating journey diving into a language again as a far mor",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "I’ve recently started a new job that uses Python.The last time I professionally Python’d was 15 years ago, writing backends for mobile apps I worked on. At the time, I was still a novice developer, only a couple years out of college. While I’ve returned to Python from time to time for tiny throwaway scripts, I’ve not seriously examined the language or its ecosystem since.Now I’m back in the thick of it with Python. And it’s been a fascinating journey diving into a language again as a far more experienced developer.For example, when I last used Python, I found list comprehensions totally incomprehensible. These strange constructs scared me; any code snippets I found online using them felt like arcana. Why would anyone use these over simple `for` loops?Now, having become experienced in the ways of map/filter, list comprehensions make so much sense. What before seemed like magic now seems like table stakes - of course your language should have some way to do a map/filter quickly!While brushing up on Python, I found myself paying attention to different aspects of the language than I did as a novice developer. I think those differences are telling - the sorts of things one worries about as a more experienced developer.Here’s (some) of the questions I ask nowadays… (I’ve opted not to actually answer any of the questions I’ve raised because I am sure those answers would be horribly outdated within a year.)Reproducible EnvironmentQuestion: If I were to check out my source code on another computer, how many steps would I have to take before I could run it?Me, 15 Years Ago: All I need is for this code to work on my computer and the server. Therefore, I use Python 2.whatever; it’s installed by default on both machines! I try to avoid libraries because it is scary to depend on strangers’ code. If I do use one, I never update - not because I fear breaking anything, but because I literally don’t know libraries are regularly updated!Why I Care Now: The more deterministic your software is, the easier it is to develop. That starts with your environment; “works on my machine” doesn’t cut it when working with other people (and deploying software to the cloud). Plus, the tools that allow reproducible environments tend to also make it easier to install dependencies.Unit TestingQuestion: How do I run unit tests?Me, 15 Years Ago: I had a derisive attitude towards automated testing. It’s a waste of time, tests always break, and it’s easier to just run the code myself.Why I Care Now: I’m big into test-driven development now, primarily because it is a much faster way to test the code myself. Sure, writing the test takes time, but then I can repeatedly verify my solution as I develop it. Also, whenever I want to refactor the code in the future, the tests keep me from shooting myself in the foot. As a cherry on top, writing testable code often results in better code design.TypingQuestion: How do I get type checking?Me, 15 Years Ago: Who cares about types? It’s a small server, I know all the inputs and outputs. If something goes wrong, I can always fix it quickly; I know the codebase top to bottom.Why I Care Now: The codebases I work with now are too large to know it all. I want to know what the inputs/outputs of a function are without having to read the implementation! Also, people make mistakes all the time - letting the type checker figure out those mistakes quickly now is better than finding out later, in production.PrivacyQuestion: How do I hide the private implementation details of my public APIs?Me, 15 Years Ago: I had no concept whatsoever of what an “implementation detail” is.Why I Care Now: I work hard to reduce accidental complexity in a codebase (so that it remains maintainable). Tightly defining your API is a great way to do that, which means hiding all the implementation details that consumers shouldn’t need to know about or use directly.Data ClassesQuestion: How do I make a structured collection of data that’s immutable?Me, 15 Years Ago: How could you ever write a program with immutable data? Isn’t data all about mutation? Mutable dicts for everyone!Why I Care Now: Nowadays I’m a fan of functional programming (as a way of keeping side effects to a minimum, which in turn reduces code complexity). Part of what makes it work is immutable data, which prevents subroutines from changing your inputs unexpectedly.ConclusionThese concerns are not exclusive to Python - they’re the sort of questions I’d ask of any language when getting started these days. What’s fascinating to me is that there was nothing stopping me from asking these questions last time I used Python! Though, some of the answers would’ve been more frustrating - there were no type hints, no dataclasses, etc. In some ways, the concerns I have now are modern concerns that people (in general) weren’t thinking about as much 15 years ago.Think about how differently we’ll view software development in 15 years! I’m sure there are patterns we’ll develop in the next decade that become standard - truly unthinkable that you wouldn’t use them - that no one has thought up yet today. We’ll see!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eI’ve recently started \u003ca href=\"https://www.snofox.com/?ref=blog.danlew.net\"\u003e\u003cu\u003ea new job\u003c/u\u003e\u003c/a\u003e that uses Python.\u003c/p\u003e\u003cp\u003eThe last time I professionally Python’d was 15 years ago, writing backends for mobile apps I worked on. At the time, I was still a novice developer, only a couple years out of college. While I’ve returned to Python from time to time for tiny throwaway scripts, I’ve not seriously examined the language or its ecosystem since.\u003c/p\u003e\u003cp\u003eNow I’m back in the thick of it with Python. And \u003cstrong\u003eit’s been a fascinating journey diving into a language again as a far more experienced developer\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eFor example, when I last used Python, I found \u003ca href=\"https://docs.python.org/3/tutorial/datastructures.html?ref=blog.danlew.net#list-comprehensions\"\u003e\u003cu\u003elist comprehensions\u003c/u\u003e\u003c/a\u003e totally incomprehensible. These strange constructs scared me; any code snippets I found online using them felt like arcana. Why would anyone use these over simple `for` loops?\u003c/p\u003e\u003cp\u003eNow, having become experienced in the ways of map/filter, list comprehensions make \u003cem\u003eso much sense\u003c/em\u003e. What before seemed like magic now seems like table stakes - of \u003cem\u003ecourse\u003c/em\u003e your language should have some way to do a map/filter quickly!\u003c/p\u003e\u003cp\u003eWhile brushing up on Python, I found myself paying attention to different aspects of the language than I did as a novice developer. I think those differences are telling - the sorts of things one worries about as a more experienced developer.\u003c/p\u003e\u003cp\u003eHere’s (some) of the questions I ask nowadays… (I’ve opted not to actually \u003cem\u003eanswer\u003c/em\u003e any of the questions I’ve raised because I am sure those answers would be horribly outdated within a year.)\u003c/p\u003e\u003ch2 id=\"reproducible-environment\"\u003eReproducible Environment\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eQuestion:\u003c/strong\u003e If I were to check out my source code on another computer, how many steps would I have to take before I could run it?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMe, 15 Years Ago\u003c/strong\u003e: All I need is for this code to work on my computer and the server. Therefore, I use Python 2.whatever; it’s installed by default on both machines! I try to avoid libraries because it is scary to depend on strangers’ code. If I do use one, I never update - not because I fear breaking anything, but because I literally don’t know libraries are regularly updated!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhy I Care Now: \u003c/strong\u003eThe more deterministic your software is, the easier it is to develop. That starts with your environment; “works on my machine” doesn’t cut it when working with other people (and deploying software to the cloud). Plus, the tools that allow reproducible environments tend to also make it easier to install dependencies.\u003c/p\u003e\u003ch2 id=\"unit-testing\"\u003eUnit Testing\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eQuestion: \u003c/strong\u003eHow do I run unit tests?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMe, 15 Years Ago\u003c/strong\u003e: I had a derisive attitude towards automated testing. It’s a waste of time, tests always break, and it’s easier to just run the code myself.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhy I Care Now:\u003c/strong\u003e I’m big into \u003ca href=\"https://en.wikipedia.org/wiki/Test-driven_development?ref=blog.danlew.net\"\u003e\u003cu\u003etest-driven development\u003c/u\u003e\u003c/a\u003e now, primarily because it is a much \u003cem\u003efaster\u003c/em\u003e way to test the code myself. Sure, writing the test takes time, but then I can repeatedly verify my solution as I develop it. Also, whenever I want to refactor the code in the future, the tests keep me from shooting myself in the foot. As a cherry on top, writing testable code often results in better code design.\u003c/p\u003e\u003ch2 id=\"typing\"\u003eTyping\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eQuestion\u003c/strong\u003e: How do I get type checking?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMe, 15 Years Ago\u003c/strong\u003e: Who cares about types? It’s a small server, I know all the inputs and outputs. If something goes wrong, I can always fix it quickly; I know the codebase top to bottom.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhy I Care Now: \u003c/strong\u003eThe codebases I work with now are too large to know it all. I want to know what the inputs/outputs of a function are without having to read the implementation! Also, people make mistakes all the time - letting the type checker figure out those mistakes quickly now is better than finding out later, in production.\u003c/p\u003e\u003ch2 id=\"privacy\"\u003ePrivacy\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eQuestion:\u003c/strong\u003e How do I hide the private implementation details of my public APIs?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMe, 15 Years Ago\u003c/strong\u003e: I had no concept whatsoever of what an “implementation detail” is.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhy I Care Now: \u003c/strong\u003eI work hard to reduce accidental complexity in a codebase (so that it remains maintainable). Tightly defining your API is a great way to do that, which means hiding all the implementation details that consumers shouldn’t need to know about or use directly.\u003c/p\u003e\u003ch2 id=\"data-classes\"\u003eData Classes\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eQuestion: \u003c/strong\u003eHow do I make a structured collection of data that’s immutable?\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMe, 15 Years Ago\u003c/strong\u003e: How could you ever write a program with immutable data? Isn’t data all about mutation? Mutable dicts for everyone!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWhy I Care Now: \u003c/strong\u003eNowadays I’m a fan of functional programming (as a way of keeping side effects to a minimum, which in turn reduces code complexity). Part of what makes it work is immutable data, which prevents subroutines from changing your inputs unexpectedly.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eThese concerns are not exclusive to Python - they’re the sort of questions I’d ask of any language when getting started these days. \u003c/p\u003e\u003cp\u003eWhat’s fascinating to me is that there was nothing stopping me from asking these questions last time I used Python! Though, some of the answers would’ve been more frustrating - there were no type hints, no dataclasses, etc. In some ways, the concerns I have now are modern concerns that people (in general) weren’t thinking about as much 15 years ago.\u003c/p\u003e\u003cp\u003eThink about how differently we’ll view software development in 15 years! I’m sure there are patterns we’ll develop in the next decade that become standard - truly unthinkable that you wouldn’t use them - that no one has thought up yet today. We’ll see!\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-09-24T13:00:05Z",
  "modifiedTime": "2024-09-24T13:00:04Z"
}
