{
  "id": "4b37b386-11ad-4bf4-8a24-9daae21a7dd8",
  "title": "My Programming Earworms",
  "link": "https://blog.danlew.net/2021/10/26/my-programming-earworms/",
  "description": "There are tons of articles online that discuss the articles/talks/books that you must consume to become a true programmer. I dislike this framing; it’s gatekeeping, plus software development is such a varied discipline that one person’s essential reading is entirely unnecessary for another.Instead,",
  "author": "Dan Lew",
  "published": "Tue, 26 Oct 2021 13:31:50 GMT",
  "source": "https://blog.danlew.net/rss/",
  "categories": null,
  "byline": "Dan Lew",
  "length": 7351,
  "excerpt": "There are tons of articles online that discuss the articles/talks/books that you must consume to become a true programmer [https://en.wikipedia.org/wiki/No_true_Scotsman]. I dislike this framing; it’s gatekeeping, plus software development is such a varied discipline that one person’s essential reading is entirely unnecessary for another. Instead, I’d like to present to you my programming earworms. An earworm [https://en.wikipedia.org/wiki/Earworm] is a song that gets stuck in your head and ju",
  "siteName": "Dan Lew Codes",
  "favicon": "",
  "text": "There are tons of articles online that discuss the articles/talks/books that you must consume to become a true programmer. I dislike this framing; it’s gatekeeping, plus software development is such a varied discipline that one person’s essential reading is entirely unnecessary for another.Instead, I’d like to present to you my programming earworms.An earworm is a song that gets stuck in your head and just keeps popping up at random times. Likewise, the following are articles/talks/books I consumed years ago yet somehow keep coming back to mind, over and over, because they really struck a nerve.I’m going to list out my programming earworms and why they have been stuck in my head for so long. Will these be useful to you? I don’t know! What I can say is that they have all shaped my thinking about programming greatly.Before I begin, some context...I have worked professionally on JavaScript for a couple years and Android for over a decade.I’m listing them approximately in the frequency that they return to my head.I do not 100% agree with everything stated in each link - rather, there’s some aspect to each that really resonated with me.Simple Made Easy by Rich HickeyThe foremost problem I deal with is complexity. The more complex a system is, the harder it is to do everything, from maintenance to feature work to reliability.This talk tackles this problem in a fundamental manner that has forever shaped how I think about addressing complexity. In short, it’s key to make code as simple as possible, but beware of falling into the trap of confusing “easy” with “simple.”(A quick simple vs. easy example: anyone can play the triangle; you just hit it. That’s simple. By contrast, it’s easy for me to play trombone because I’ve practiced for years, but most people would find it difficult.)Integrated Tests Are A Scam by J. B. RainsbergerThe basic point of this talk is that tests that run the entire application (“integrated tests”) can’t come anywhere close to covering all your bases. Each additional variable in an app exponentially increases the tests needed to cover every possible state. Ouch!If, instead, you architect your app such that it’s just a series of components talking to each other, then you can test the contracts between components in a sane manner without having to invoke the whole app due to transitive properties. That is, if you can test A \u003c-\u003e B, and test B \u003c-\u003e C, then you don’t need to test A \u003c-\u003e C.This is one of those great ideas that pays off in multiple ways - not only are your tests better, but supporting those tests also forces your software architecture to be better, too.(If you’ve got limited time, there’s an article instead, but I prefer the talk because it also discusses solutions.)The Future of the Testing Role by James BachI’ve always worked with manual testers and I highly appreciate them because they find my mistakes before users do.Unfortunately, not everyone feels that appreciation. For a long time, I’ve had to push back against management who wants to get rid of manual testing. They would prefer to replace it with developer-driven initiatives, like automation.This talk makes the best case for manual testing I’ve seen. It deconstructs why testing is a unique role and how expert testers provide special skills that others don’t. It also explains why people often overlook the importance of manual testing.(This is a long talk; you can get a lot out of this by only watching the first half, as the back half is directed towards testers themselves.)Technical leadership and glue work by Tanya ReillyThis is a fantastic talk about a situation everyone should be aware of - people doing important glue work that no one realizes is crucial.I keep spreading this talk around for a few reasons. It’s got good advice for people who are stuck doing underappreciated glue work. For developers who don’t realize glue work exists, it points out stuff they ought to learn to do beyond coding. And it is a warning to management not to pigeonhole people into being glue and not giving them a chance to flourish in other ways.Underlying it all, the talk highlights how developers contribute to software in many different ways besides just coding. It continually reminds me to appreciate the many ways people are contributing to a piece of software.(This talk is also available in blog form.)What if the user was a function? by André StaltzThis was the talk that introduced me to unidirectional architecture, and to me is still one of the best introductions to the concept.Instead of a complicated dance between different components (e.g. model-view-controller), instead you just have data flow in one direction: a model would be fed into a view, the user would interact with the view, then those interactions would get fed back into the model, which would update the view...This setup instantly felt so much simpler to me than any other architecture I’d seen before. I suspect many others feel the same, as numerous popular frameworks now use unidirectional data flow.(I want to give an honorable mention here to Christina Lee’s Borrowing the Best of the Web to Make Native Better, which really helped contextualize this idea within Android for me.)Notes on structured concurrency by Nathaniel J. SmithConcurrency is hard. Really hard.Structured concurrency is the idea that you are required to keep track of all your concurrent calls by scoping them, rather than letting your asynchronous code just fly off into the wild yonder. I’ve been blindly feeling my way towards a solution like this for years (i.e. my failed library RxLifecycle), so when I read this article, it instantly struck a chord with me.I think the idea of structured concurrency is fantastic; I’m really pleased that it’s getting a big trial run with Kotlin coroutines, which adapted it. I suspect that in time, structured concurrency will be commonplace, much like how unidirectional data flow has taken over UI frameworks.JavaScript: The Good Parts by Douglas CrockfordWhen I was a young programmer, I assumed that all languages and frameworks were essentially good. If a lot of people were using a technology, then it had to be designed well, right?This book blew those naive assumptions out of the water. It systematically and convincingly breaks down JavaScript into the parts that work well and the parts that do not. It turns out that there are a lot of bad parts to JavaScript!Ever since reading it, I have kept a skeptical eye towards system design. What works well in a system and what doesn’t? How do we mitigate problems caused by unchangeable design snafus?Nowadays, I seek out “The Good Parts” book for whatever language I’m working with. For example, the Java version of this book is Effective Java.The mythical 10x programmer by Salvatore SanfilippoIs there such a thing as a 10x programmer? I don’t know, and I generally steer clear of the 10x programmer debate entirely (as it only leads to unproductive flame wars) but unfortunately for me here this article launches from the idea.The reason I return to this article again and again is because I think it makes a fantastic point on how non-linear programming is as a discipline. From that viewpoint, there are definitely ways to exponentially speed up some work. I especially like his point about sacrificing design perfection in order to get the work done.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eThere are tons of articles online that discuss the articles/talks/books that you must consume to become \u003ca href=\"https://en.wikipedia.org/wiki/No_true_Scotsman?ref=blog.danlew.net\"\u003ea true programmer\u003c/a\u003e. I dislike this framing; it’s gatekeeping, plus software development is such a varied discipline that one person’s essential reading is entirely unnecessary for another.\u003c/p\u003e\u003cp\u003eInstead, I’d like to present to you my \u003cstrong\u003eprogramming earworms\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eAn \u003ca href=\"https://en.wikipedia.org/wiki/Earworm?ref=blog.danlew.net\"\u003eearworm\u003c/a\u003e is a song that gets stuck in your head and just keeps popping up at random times. Likewise, the following are articles/talks/books I consumed years ago yet somehow keep coming back to mind, over and over, because they really struck a nerve.\u003c/p\u003e\u003cp\u003eI’m going to list out my programming earworms and \u003cem\u003ewhy\u003c/em\u003e they have been stuck in my head for so long. Will these be useful to you? I don’t know! What I can say is that they have all shaped \u003cem\u003emy\u003c/em\u003e thinking about programming greatly.\u003c/p\u003e\u003cp\u003eBefore I begin, some context...\u003c/p\u003e\u003cul\u003e\u003cli\u003eI have worked professionally on JavaScript for a couple years and Android for over a decade.\u003c/li\u003e\u003cli\u003eI’m listing them approximately in the frequency that they return to my head.\u003c/li\u003e\u003cli\u003eI do not 100% agree with everything stated in each link - rather, there’s some aspect to each that really resonated with me.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"simple-made-easy-by-rich-hickey\"\u003e\u003ca href=\"https://www.infoq.com/presentations/Simple-Made-Easy/?ref=blog.danlew.net\"\u003eSimple Made Easy\u003c/a\u003e by Rich Hickey\u003c/h2\u003e\u003cp\u003eThe foremost problem I deal with is complexity. The more complex a system is, the harder it is to do \u003cem\u003eeverything\u003c/em\u003e, from maintenance to feature work to reliability.\u003c/p\u003e\u003cp\u003eThis talk tackles this problem in a fundamental manner that has forever shaped how I think about addressing complexity. In short, it’s key to make code as simple as possible, but beware of falling into the trap of confusing “easy” with “simple.”\u003c/p\u003e\u003cp\u003e(A quick simple vs. easy example: anyone can play the triangle; you just hit it. That’s \u003cstrong\u003esimple\u003c/strong\u003e. By contrast, it’s \u003cstrong\u003eeasy \u003c/strong\u003efor me to play trombone because I’ve practiced for years, but most people would find it difficult.)\u003c/p\u003e\u003ch2 id=\"integrated-tests-are-a-scam-by-j-b-rainsberger\"\u003e\u003ca href=\"https://vimeo.com/80533536?ref=blog.danlew.net\"\u003eIntegrated Tests Are A Scam\u003c/a\u003e by J. B. Rainsberger\u003c/h2\u003e\u003cp\u003eThe basic point of this talk is that tests that run the entire application (“integrated tests”) can’t come anywhere close to covering all your bases. Each additional variable in an app exponentially increases the tests needed to cover every possible state. Ouch!\u003c/p\u003e\u003cp\u003eIf, instead, you architect your app such that it’s just a series of components talking to each other, then you can test the contracts between components in a sane manner without having to invoke the whole app due to transitive properties. That is, if you can test A \u0026lt;-\u0026gt; B, and test B \u0026lt;-\u0026gt; C, then you don’t need to test A \u0026lt;-\u0026gt; C.\u003c/p\u003e\u003cp\u003eThis is one of those great ideas that pays off in multiple ways - not only are your tests better, but supporting those tests also forces your software architecture to be better, too.\u003c/p\u003e\u003cp\u003e(If you’ve got limited time, there’s \u003ca href=\"https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam?ref=blog.danlew.net\"\u003ean article\u003c/a\u003e instead, but I prefer the talk because it also discusses solutions.)\u003c/p\u003e\u003ch2 id=\"the-future-of-the-testing-role-by-james-bach\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=c5821YeWico\u0026amp;ref=blog.danlew.net\"\u003eThe Future of the Testing Role\u003c/a\u003e by James Bach\u003c/h2\u003e\u003cp\u003eI’ve always worked with manual testers and I highly appreciate them because they find my mistakes before users do.\u003c/p\u003e\u003cp\u003eUnfortunately, not everyone feels that appreciation. For a long time, I’ve had to push back against management who wants to get rid of manual testing. They would prefer to replace it with developer-driven initiatives, like automation.\u003c/p\u003e\u003cp\u003eThis talk makes the best case for manual testing I’ve seen. It deconstructs why testing is a unique role and how expert testers provide special skills that others don’t. It also explains why people often overlook the importance of manual testing.\u003c/p\u003e\u003cp\u003e(This is a long talk; you can get a lot out of this by only watching the first half, as the back half is directed towards testers themselves.)\u003c/p\u003e\u003ch2 id=\"technical-leadership-and-glue-work-by-tanya-reilly\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=KClAPipnKqw\u0026amp;ref=blog.danlew.net\"\u003eTechnical leadership and glue work\u003c/a\u003e by Tanya Reilly\u003c/h2\u003e\u003cp\u003eThis is a fantastic talk about a situation everyone should be aware of - people doing important glue work that no one realizes is crucial.\u003c/p\u003e\u003cp\u003eI keep spreading this talk around for a few reasons. It’s got good advice for people who are stuck doing underappreciated glue work. For developers who don’t realize glue work exists, it points out stuff they ought to learn to do beyond coding. And it is a warning to management not to pigeonhole people into being glue and not giving them a chance to flourish in other ways.\u003c/p\u003e\u003cp\u003eUnderlying it all, the talk highlights how developers contribute to software in many different ways besides just coding. It continually reminds me to appreciate the many ways people are contributing to a piece of software.\u003c/p\u003e\u003cp\u003e(This talk is also available in \u003ca href=\"https://noidea.dog/glue?ref=blog.danlew.net\"\u003eblog form\u003c/a\u003e.)\u003c/p\u003e\u003ch2 id=\"what-if-the-user-was-a-function-by-andr%C3%A9-staltz\"\u003e\u003ca href=\"https://www.youtube.com/watch?v=1zj7M1LnJV4\u0026amp;ref=blog.danlew.net\"\u003eWhat if the user was a function?\u003c/a\u003e by André Staltz\u003c/h2\u003e\u003cp\u003eThis was the talk that introduced me to unidirectional architecture, and to me is still one of the best introductions to the concept.\u003c/p\u003e\u003cp\u003eInstead of a complicated dance between different components (e.g. model-view-controller), instead you just have data flow in one direction: a model would be fed into a view, the user would interact with the view, then those interactions would get fed back into the model, which would update the view...\u003c/p\u003e\u003cp\u003eThis setup instantly felt so much simpler to me than any other architecture I’d seen before. I suspect many others feel the same, as numerous popular frameworks now use unidirectional data flow.\u003c/p\u003e\u003cp\u003e(I want to give an honorable mention here to Christina Lee’s \u003ca href=\"https://www.youtube.com/watch?v=GOVMkQp3LZ4\u0026amp;ref=blog.danlew.net\"\u003eBorrowing the Best of the Web to Make Native Better\u003c/a\u003e, which really helped contextualize this idea within Android for me.)\u003c/p\u003e\u003ch2 id=\"notes-on-structured-concurrency-by-nathaniel-j-smith\"\u003e\u003ca href=\"https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/?ref=blog.danlew.net\"\u003eNotes on structured concurrency\u003c/a\u003e by Nathaniel J. Smith\u003c/h2\u003e\u003cp\u003eConcurrency is hard. Really hard.\u003c/p\u003e\u003cp\u003eStructured concurrency is the idea that you are required to keep track of all your concurrent calls by scoping them, rather than letting your asynchronous code just fly off into the wild yonder. I’ve been blindly feeling my way towards a solution like this for years (i.e. \u003ca href=\"https://blog.danlew.net/2017/08/02/why-not-rxlifecycle/\"\u003emy failed library RxLifecycle\u003c/a\u003e), so when I read this article, it instantly struck a chord with me.\u003c/p\u003e\u003cp\u003eI think the idea of structured concurrency is fantastic; I’m really pleased that it’s getting a big trial run with Kotlin coroutines, which adapted it. I suspect that in time, structured concurrency will be commonplace, much like how unidirectional data flow has taken over UI frameworks.\u003c/p\u003e\u003ch2 id=\"javascript-the-good-parts-by-douglas-crockford\"\u003e\u003ca href=\"https://www.goodreads.com/book/show/2998152-javascript?ref=blog.danlew.net\"\u003eJavaScript: The Good Parts\u003c/a\u003e by Douglas Crockford\u003c/h2\u003e\u003cp\u003eWhen I was a young programmer, I assumed that all languages and frameworks were essentially \u003cem\u003egood\u003c/em\u003e. If a lot of people were using a technology, then it had to be designed well, right?\u003c/p\u003e\u003cp\u003eThis book blew those naive assumptions out of the water. It systematically and convincingly breaks down JavaScript into the parts that work well and the parts that do not. It turns out that there are a lot of bad parts to JavaScript!\u003c/p\u003e\u003cp\u003eEver since reading it, I have kept a skeptical eye towards system design. What works well in a system and what doesn’t? How do we mitigate problems caused by unchangeable design snafus?\u003c/p\u003e\u003cp\u003eNowadays, I seek out “The Good Parts” book for whatever language I’m working with. For example, the Java version of this book is \u003ca href=\"https://www.goodreads.com/book/show/34927404-effective-java?ref=blog.danlew.net\"\u003eEffective Java\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"the-mythical-10x-programmer-by-salvatore-sanfilippo\"\u003e\u003ca href=\"http://antirez.com/news/112?ref=blog.danlew.net\"\u003eThe mythical 10x programmer\u003c/a\u003e by Salvatore Sanfilippo\u003c/h2\u003e\u003cp\u003eIs there such a thing as a 10x programmer? I don’t know, and I generally steer clear of the 10x programmer debate entirely (as it only leads to unproductive flame wars) but unfortunately for me here this article launches from the idea.\u003c/p\u003e\u003cp\u003eThe reason I return to this article again and again is because I think it makes a fantastic point on how non-linear programming is as a discipline. From that viewpoint, there are definitely ways to exponentially speed up some work. I especially like his point about sacrificing design perfection in order to get the work done.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2021-10-26T13:31:50Z",
  "modifiedTime": "2021-10-26T13:31:50Z"
}
