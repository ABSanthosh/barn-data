{
  "id": "fbeb58c5-ab9f-4f49-a2a4-52aef96069b9",
  "title": "Nonsensical Maven is still a Gradle problem",
  "link": "https://jakewharton.com/nonsensical-maven-is-still-a-gradle-problem/",
  "description": "",
  "author": "",
  "published": "2024-03-28T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 13413,
  "excerpt": "28 March 2024",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Nonsensical Maven is still a Gradle problem 28 March 2024 There was a time when I used Maven heavily, but today all the libraries I work on build with Gradle. Even though I’m publishing with Gradle, consumers can use Gradle, Maven, Bazel, jars in libs/ (but please don’t), or anything else. That’s a huge JVM ecosystem win! In general, I don’t have to think about what build system someone is using. I’m not here to debate subjective pros and cons of one versus any other. There is one notable exception, however. Maven’s dependency resolution strategy is objectively bonkers. And if we want to support Maven consumers, we need to think about it. If you already are familiar with the concept of dependency resolution, you can skip to the nonsense. Dependency resolution primer Chances are your build system of choice (or a separate dependency resolver tool) gives you a declarative way to describe your dependencies. At build time, those declarations are resolved to .jars which can be put on the compiler classpath. Sometimes we call this a dependency tree, but it’s actually a dependency graph, as separate nodes can converge back to something common to both. Project (build.gradle) ├── A │ └── B │ └── C v1.0 └── D └── C v1.0 If library B and library D agree on the version of library C, then that is the .jar version which is used. If they disagree on versions, some policy needs to decide the appropriate single version to use. Pop quiz: If library B wants version 1.1 of library C, and library D wants version 1.0 of library C, which single version of C should we use? Project (build.gradle) ├── A │ └── B │ └── C v1.1 └── D └── C v1.0 This is not a trick question. Hopefully the answer feels obvious: you use the newer version, 1.1. That version is probably compatible with 1.0, so it’s safe for both library B and library D to use. We can’t know for sure, to be clear, but it’s a safe choice. This behavior is the default in many dependency resolvers, including the one inside Gradle. The nonsense When building with Maven, given two dependencies who disagree on a transitive dependency version, the default resolution strategy is… uh… let’s say “interesting”. From their docs, Maven picks the “nearest definition”. That is, it uses the version of the closest dependency to your project in the tree of dependencies. … Note that if two dependency versions are at the same depth in the dependency tree, the first declaration wins. So in a dependency graph, if library B wants version 1.1 of library C, and library D wants version 1.0 of library C, which single version of C does Maven choose? Project (pom.xml) ├── A │ └── B │ └── C v1.1 └── D └── C v1.0 The final build will use version 1.0 of library C. Wat. If library B was using a new API from library C’s version 1.1, the application will throw a NoSuchMethodException or the like at runtime. As if that wasn’t bad enough, disagreements which occur on the same conceptual level of the graph are resolved by whichever comes first. If our project replaces its library A with direct usage of library B, suddenly the resolved version is 1.1 because it came first. Project (pom.xml) ├── B │ └── C v1.1 └── D └── C v1.0 But if by chance library D was declared first in the pom.xml then oops! we’re back to getting 1.0. Project (pom.xml) ├── D │ └── C v1.0 └── B └── C v1.1 This behavior is not user-friendly. You can always force a specific version by declaring it directly in your pom.xml, but that also means you take ownership of monitoring the versions requested by the entire dependency graph and ensuring you declare the one you need. Gee, that sounds like something it should do for you. Still a Gradle problem So Maven has some nonsensical dependency resolution semantics. Why should you, a Gradle user, even care? In the examples above, the version mismatches were demonstrated using peer dependencies on the Maven project. But disagreements can occur within the transitive graph of a single Gradle-built library. If I am the author of library A from above, I only have a dependency on library B and it has a dependency on library C. Project A (build.gradle) └── B └── C v1.1 If I want to start using library C, I may add my own dependency (such as if C is an implementation dependency of B) and select an older version. Project A (build.gradle) ├── B │ └── C v1.1 +└── C v1.0 I have just unknowingly created a time bomb for all of my Maven consumers. Not a hypothetical Is this a frequent problem? Seems like no. Is this a real problem? Absolutely. OkHttp 4.12 ships with two dependencies: Okio 3.6 and the Kotlin stdlib 1.8.21. Okio 3.6, however, depends on Kotlin stdlib 1.9.10. OkHttp v4.12.0 ├── Okio v3.6.0 │ └── Kotlin stdlib v1.9.10 └── Kotlin stdlib v1.8.21 This specific configuration is probably okay in practice, as Okio is unlikely to have used anything new. In general, however, the ability to create such a dependency graph with a mismatch is setting our Maven users up for future failure. Detecting from Maven If you are a Maven user, you can eagerly detect this case by using the Maven enforcer plugin and its built-in dependency convergence rule. A Maven project with an OkHttp 4.12 dependency will now fail like this: [ERROR] Rule 0: org.apache.maven.enforcer.rules.dependency.DependencyConvergence failed with message: [ERROR] Failed while enforcing releasability. [ERROR] [ERROR] Dependency convergence error for org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.9.10 paths to dependency are: [ERROR] +-com.example:example:jar:1.0-SNAPSHOT [ERROR] +-com.squareup.okhttp3:okhttp:jar:4.12.0:compile [ERROR] +-com.squareup.okio:okio:jar:3.6.0:compile [ERROR] +-com.squareup.okio:okio-jvm:jar:3.6.0:compile [ERROR] +-org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.9.10:compile [ERROR] and [ERROR] +-com.example:example:jar:1.0-SNAPSHOT [ERROR] +-com.squareup.okhttp3:okhttp:jar:4.12.0:compile [ERROR] +-org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.8.21:compile Now a Maven consumer can temporarily resolve the conflict, and go and ask the library maintainer to correct this configuration. Ignoring the problem with Gradle Since Gradle is going to resolve to the newest version of a dependency, your tests end up running with the newest version rather than the declared version. As such, you can tell Gradle to replace your declared version with the resolved version when publishing. This behavior is not Gradle’s default, so we must choose it when setting up publishing. The Gradle docs has an example: publishing { publications { mavenJava(MavenPublication) { versionMapping { usage('java-api') { fromResolutionOf('runtimeClasspath') } usage('java-runtime') { fromResolutionResult() } } } } } There’s very little harm in doing this, and it will prevent the Maven issue completely. Nice! The tradeoff is that it somewhat undermines the versions you declare. Keep in mind, though, even if you declare a dependency version and resolve to that same version, a downstream consumer may resolve a newer version or force an older version. For me, I want the versions which I declare to be those which are resolved, at least local to my project. So this solution isn’t going to work, but it might for your projects. (Thanks to Paul Merlin for suggesting this solution which was added after initial publishing) Trying to fix with Gradle I’m going to outright dismiss “just don’t use Maven” as a potential fix. There are lots of reasons not to use Maven that one can explore elsewhere. Ultimately it remains in widespread use, and you can either be sympathetic to those users or not. Library developers using Gradle could change the default resolution strategy to fail on version conflict. This does precisely what it says, fails your build if the transitive graph contains conflicts. // OkHttp's build.gradle dependencies { implementation 'com.squareup.okio:okio:3.6.0' implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.21' } configurations.configureEach { resolutionStrategy.failOnVersionConflict() } Now when building we get a failure: Execution failed for task ':compileJava'. \u003e Could not resolve all dependencies for configuration ':compileClasspath'. \u003e Conflicts found for the following modules: - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.10 and 1.8.21 - org.jetbrains.kotlin:kotlin-stdlib between versions 1.9.10 and 1.8.21 The failure suggests running dependencyInsight, which shows you a wall of text containing the subgraph of affected dependencies which led to the conflict. \u003e Task :dependencyInsight Dependency resolution failed because of conflicts on the following modules: - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.10 and 1.8.21 org.jetbrains.kotlin:kotlin-stdlib-common:1.9.10 Variant compile: | Attribute Name | Provided | Requested | |--------------------------------|----------|--------------| | org.gradle.status | release | | | org.gradle.category | library | library | | org.gradle.libraryelements | jar | classes | | org.gradle.usage | java-api | java-api | | org.gradle.dependency.bundling | | external | | org.gradle.jvm.environment | | standard-jvm | | org.gradle.jvm.version | | 21 | Selection reasons: - By conflict resolution: between versions 1.9.10 and 1.8.21 org.jetbrains.kotlin:kotlin-stdlib-common:1.9.10 +--- com.squareup.okio:okio-jvm:3.6.0 | \\--- com.squareup.okio:okio:3.6.0 | \\--- compileClasspath \\--- org.jetbrains.kotlin:kotlin-stdlib:1.9.10 +--- compileClasspath (requested org.jetbrains.kotlin:kotlin-stdlib:1.8.21) +--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10 | \\--- com.squareup.okio:okio-jvm:3.6.0 (*) \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.9.10 \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10 (*) The fix for OkHttp is simple: upgrade to a matching version. Unfortunately, if you upgrade to a version that’s newer than your transitive dependency, the build still fails. \u003e Could not resolve all dependencies for configuration ':compileClasspath'. \u003e Conflicts found for the following modules: - org.jetbrains.kotlin:kotlin-stdlib between versions 1.9.23 and 1.9.10 - org.jetbrains.kotlin:kotlin-stdlib-jdk8 between versions 1.9.10 and 1.8.0 - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.23 and 1.9.10 - org.jetbrains.kotlin:kotlin-stdlib-jdk7 between versions 1.9.10 and 1.8.0 You have to force the use of 1.9.23 everywhere, but doing so will ironically prevent failOnVersionConflict() from detecting mismatches in the future. Gradle has other mechanisms like constraints and resolution strategy callbacks that have tons of power to customize dependency resolution, but none provide the ability to reject upgrades. I would love to be corrected on this, but I spent a few days searching and experimenting with no success. Instead, we have to build our own solution. Actually fixing with Gradle I wrote a task which consumes the dependency graph and checks if the first-order dependencies (i.e., those your project declared directly) select the same version as they request. \u003e Task :sympathyForMrMaven FAILED e: org.jetbrains.kotlin:kotlin-stdlib:1.8.21 changed to 1.9.10 * What went wrong: Execution failed for task ':sympathyForMrMaven'. \u003e Declared dependencies were upgraded transitively. See task output above. Please update their versions. When I bump my declaration to 1.9.10 to match, or even 1.9.23 which is the latest right now, the task no longer fails. BUILD SUCCESSFUL in 354ms 4 actionable tasks: 4 executed This is what I hacked up in Groovy very quickly this morning (and to finish the damn post): def fail = false def root = configuration.incoming.resolutionResult.rootComponent.get() ((ResolvedComponentResult) root).dependencies.forEach { if (it instanceof ResolvedDependencyResult) { def rdr = it as ResolvedDependencyResult def requested = rdr.requested def selected = rdr.selected if (requested instanceof ModuleComponentSelector) { def requestedVersion = (requested as ModuleComponentSelector).version def selectedVersion = selected.moduleVersion.version if (requestedVersion != selectedVersion) { logger.log(ERROR, \"e: ${rdr.requested} changed to ${selectedVersion}\") fail = true } } } } if (fail) { throw new IllegalStateException(\"Declared dependencies were upgraded transitively. See task output above. Please update their versions.\") } This needs cleaned up before it can be used generally–sorry! In a long post about how Maven’s dependency resolution is annoying, I instead became very annoyed at Gradle and just want to stop working on this. Someone please change it to Java, wrap it in a task, wrap that in a com.yourname.maven-sympathy plugin, publish to Maven Central, and ping me to update this post. I have about 30 projects I’d love to slap it on, and hopefully other sympathetic library authors who read this post will too! — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eNonsensical Maven is still a Gradle problem\u003c/h2\u003e\n      \u003cp\u003e28 March 2024\u003c/p\u003e\n\n      \u003cp\u003eThere was a time when I used Maven heavily, but today all the libraries I work on build with Gradle. Even though I’m publishing with Gradle, consumers can use Gradle, Maven, Bazel, jars in \u003ccode\u003elibs/\u003c/code\u003e (but please don’t), or anything else. That’s a huge JVM ecosystem win!\u003c/p\u003e\n\n\u003cp\u003eIn general, I don’t have to think about what build system someone is using. I’m not here to debate subjective pros and cons of one versus any other. There is one notable exception, however. Maven’s dependency resolution strategy is objectively bonkers. And if we want to support Maven consumers, we need to think about it.\u003c/p\u003e\n\n\u003cp\u003eIf you already are familiar with the concept of dependency resolution, you can skip to \u003ca href=\"#the-nonsense\"\u003ethe nonsense\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"dependency-resolution-primer\"\u003eDependency resolution primer\u003c/h3\u003e\n\n\u003cp\u003eChances are your build system of choice (or a separate dependency resolver tool) gives you a declarative way to describe your dependencies. At build time, those declarations are resolved to \u003ccode\u003e.jar\u003c/code\u003es which can be put on the compiler classpath.\u003c/p\u003e\n\n\u003cp\u003eSometimes we call this a \u003cem\u003edependency tree\u003c/em\u003e, but it’s actually a \u003cem\u003edependency graph\u003c/em\u003e, as separate nodes can converge back to something common to both.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject (build.gradle)\n├── A\n│   └── B\n│       └── C v1.0\n└── D\n    └── C v1.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf library \u003ccode\u003eB\u003c/code\u003e and library \u003ccode\u003eD\u003c/code\u003e agree on the version of library \u003ccode\u003eC\u003c/code\u003e, then that is the \u003ccode\u003e.jar\u003c/code\u003e version which is used. If they disagree on versions, some policy needs to decide the appropriate single version to use.\u003c/p\u003e\n\n\u003cp\u003ePop quiz: If library \u003ccode\u003eB\u003c/code\u003e wants version 1.1 of library \u003ccode\u003eC\u003c/code\u003e, and library \u003ccode\u003eD\u003c/code\u003e wants version 1.0 of library \u003ccode\u003eC\u003c/code\u003e, which single version of \u003ccode\u003eC\u003c/code\u003e should we use?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject (build.gradle)\n├── A\n│   └── B\n│       └── C v1.1\n└── D\n    └── C v1.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is not a trick question. Hopefully the answer feels obvious: you use the newer version, 1.1. That version is \u003cem\u003eprobably\u003c/em\u003e compatible with 1.0, so it’s safe for both library \u003ccode\u003eB\u003c/code\u003e and library \u003ccode\u003eD\u003c/code\u003e to use. We can’t know for sure, to be clear, but it’s a safe choice. This behavior is the default in many dependency resolvers, including the one inside Gradle.\u003c/p\u003e\n\n\u003ch3 id=\"the-nonsense\"\u003eThe nonsense\u003c/h3\u003e\n\n\u003cp\u003eWhen building with Maven, given two dependencies who disagree on a transitive dependency version, the default resolution strategy is… uh… let’s say “interesting”. From \u003ca href=\"https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Transitive_Dependencies\"\u003etheir docs\u003c/a\u003e,\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eMaven picks the “nearest definition”. That is, it uses the version of the closest dependency to your project in the tree of dependencies. … Note that if two dependency versions are at the same depth in the dependency tree, the first declaration wins.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSo in a dependency graph, if library \u003ccode\u003eB\u003c/code\u003e wants version 1.1 of library \u003ccode\u003eC\u003c/code\u003e, and library \u003ccode\u003eD\u003c/code\u003e wants version 1.0 of library \u003ccode\u003eC\u003c/code\u003e, which single version of \u003ccode\u003eC\u003c/code\u003e does Maven choose?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject (pom.xml)\n├── A\n│   └── B\n│       └── C v1.1\n└── D\n    └── C v1.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe final build will use version 1.0 of library \u003ccode\u003eC\u003c/code\u003e. Wat.\u003c/p\u003e\n\n\u003cp\u003eIf library \u003ccode\u003eB\u003c/code\u003e was using a new API from library \u003ccode\u003eC\u003c/code\u003e’s version 1.1, the application will throw a \u003ccode\u003eNoSuchMethodException\u003c/code\u003e or the like at runtime.\u003c/p\u003e\n\n\u003cp\u003eAs if that wasn’t bad enough, disagreements which occur on the same conceptual level of the graph are resolved by whichever comes first. If our project replaces its library \u003ccode\u003eA\u003c/code\u003e with direct usage of library \u003ccode\u003eB\u003c/code\u003e, suddenly the resolved version is 1.1 because it came first.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject (pom.xml)\n├── B\n│   └── C v1.1\n└── D\n    └── C v1.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eBut if by chance library \u003ccode\u003eD\u003c/code\u003e was declared first in the \u003ccode\u003epom.xml\u003c/code\u003e then oops! we’re back to getting 1.0.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject (pom.xml)\n├── D\n│   └── C v1.0\n└── B\n    └── C v1.1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis behavior is not user-friendly. You can always force a specific version by declaring it directly in your \u003ccode\u003epom.xml\u003c/code\u003e, but that also means you take ownership of monitoring the versions requested by the entire dependency graph and ensuring you declare the one you need. Gee, that sounds like something it should do for you.\u003c/p\u003e\n\n\u003ch3 id=\"still-a-gradle-problem\"\u003eStill a Gradle problem\u003c/h3\u003e\n\n\u003cp\u003eSo Maven has some nonsensical dependency resolution semantics. Why should you, a Gradle user, even care?\u003c/p\u003e\n\n\u003cp\u003eIn the examples above, the version mismatches were demonstrated using peer dependencies on the Maven project. But disagreements can occur within the transitive graph of a single Gradle-built library.\u003c/p\u003e\n\n\u003cp\u003eIf I am the author of library \u003ccode\u003eA\u003c/code\u003e from above, I only have a dependency on library \u003ccode\u003eB\u003c/code\u003e and it has a dependency on library \u003ccode\u003eC\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eProject A (build.gradle)\n└── B\n    └── C v1.1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf I want to start using library \u003ccode\u003eC\u003c/code\u003e, I \u003cem\u003emay\u003c/em\u003e add my own dependency (such as if \u003ccode\u003eC\u003c/code\u003e is an implementation dependency of \u003ccode\u003eB\u003c/code\u003e) and select an older version.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e Project A (build.gradle)\n ├── B\n │   └── C v1.1\n\u003cspan\u003e+└── C v1.0\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI have just unknowingly created a time bomb for all of my Maven consumers.\u003c/p\u003e\n\n\u003ch3 id=\"not-a-hypothetical\"\u003eNot a hypothetical\u003c/h3\u003e\n\n\u003cp\u003eIs this a frequent problem? Seems like no. Is this a real problem? Absolutely.\u003c/p\u003e\n\n\u003cp\u003eOkHttp 4.12 \u003ca href=\"https://repo1.maven.org/maven2/com/squareup/okhttp3/okhttp/4.12.0/okhttp-4.12.0.pom\"\u003eships with two dependencies\u003c/a\u003e: Okio 3.6 and the Kotlin stdlib 1.8.21. Okio 3.6, however, \u003ca href=\"https://repo1.maven.org/maven2/com/squareup/okio/okio-jvm/3.6.0/okio-jvm-3.6.0.pom\"\u003edepends on\u003c/a\u003e Kotlin stdlib 1.9.10.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eOkHttp v4.12.0\n├── Okio v3.6.0\n│   └── Kotlin stdlib v1.9.10\n└── Kotlin stdlib v1.8.21\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis specific configuration is probably okay in practice, as Okio is unlikely to have used anything new. In general, however, the ability to create such a dependency graph with a mismatch is setting our Maven users up for future failure.\u003c/p\u003e\n\n\u003ch3 id=\"detecting-from-maven\"\u003eDetecting from Maven\u003c/h3\u003e\n\n\u003cp\u003eIf you are a Maven user, you can eagerly detect this case by using the \u003ca href=\"https://maven.apache.org/enforcer/maven-enforcer-plugin/index.html\"\u003eMaven enforcer plugin\u003c/a\u003e and its built-in \u003ca href=\"https://maven.apache.org/enforcer/enforcer-rules/dependencyConvergence.html\"\u003edependency convergence rule\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eA Maven project with an OkHttp 4.12 dependency will now fail like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e[ERROR] Rule 0: org.apache.maven.enforcer.rules.dependency.DependencyConvergence failed with message:\n[ERROR] Failed while enforcing releasability.\n[ERROR]\n[ERROR] Dependency convergence error for org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.9.10 paths to dependency are:\n[ERROR] +-com.example:example:jar:1.0-SNAPSHOT\n[ERROR]   +-com.squareup.okhttp3:okhttp:jar:4.12.0:compile\n[ERROR]     +-com.squareup.okio:okio:jar:3.6.0:compile\n[ERROR]       +-com.squareup.okio:okio-jvm:jar:3.6.0:compile\n[ERROR]         +-org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.9.10:compile\n[ERROR] and\n[ERROR] +-com.example:example:jar:1.0-SNAPSHOT\n[ERROR]   +-com.squareup.okhttp3:okhttp:jar:4.12.0:compile\n[ERROR]     +-org.jetbrains.kotlin:kotlin-stdlib-jdk8:jar:1.8.21:compile\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNow a Maven consumer can temporarily resolve the conflict, and go and ask the library maintainer to correct this configuration.\u003c/p\u003e\n\n\u003ch3 id=\"ignoring-the-problem-with-gradle\"\u003eIgnoring the problem with Gradle\u003c/h3\u003e\n\n\u003cp\u003eSince Gradle is going to resolve to the newest version of a dependency, your tests end up running with the newest version rather than the declared version. As such, you can tell Gradle to replace your declared version with the resolved version when publishing.\u003c/p\u003e\n\n\u003cp\u003eThis behavior is not Gradle’s default, so we must choose it when setting up publishing. The \u003ca href=\"https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:resolved_dependencies\"\u003eGradle docs\u003c/a\u003e has an example:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublishing\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003epublications\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003emavenJava\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMavenPublication\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003eversionMapping\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eusage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;java-api\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n          \u003cspan\u003efromResolutionOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;runtimeClasspath\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eusage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;java-runtime\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n          \u003cspan\u003efromResolutionResult\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThere’s very little harm in doing this, and it will prevent the Maven issue completely. Nice!\u003c/p\u003e\n\n\u003cp\u003eThe tradeoff is that it somewhat undermines the versions you declare. Keep in mind, though, even if you declare a dependency version and resolve to that same version, a downstream consumer may resolve a newer version or force an older version.\u003c/p\u003e\n\n\u003cp\u003eFor me, I want the versions which I declare to be those which are resolved, at least local to my project. So this solution isn’t going to work, but it might for your projects.\u003c/p\u003e\n\n\u003cp\u003e(Thanks to \u003ca href=\"https://mastodon.social/@eskatos/112174733070682832\"\u003ePaul Merlin\u003c/a\u003e for suggesting this solution which was added after initial publishing)\u003c/p\u003e\n\n\u003ch3 id=\"trying-to-fix-with-gradle\"\u003eTrying to fix with Gradle\u003c/h3\u003e\n\n\u003cp\u003eI’m going to outright dismiss “just don’t use Maven” as a potential fix. There are lots of reasons not to use Maven that one can explore elsewhere. Ultimately it remains in widespread use, and you can either be sympathetic to those users or not.\u003c/p\u003e\n\n\u003cp\u003eLibrary developers using Gradle could change the default resolution strategy to \u003ca href=\"https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:failOnVersionConflict()\"\u003efail on version conflict\u003c/a\u003e. This does precisely what it says, fails your build if the transitive graph contains conflicts.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// OkHttp\u0026#39;s build.gradle\u003c/span\u003e\n\u003cspan\u003edependencies\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eimplementation\u003c/span\u003e \u003cspan\u003e\u0026#39;com.squareup.okio:okio:3.6.0\u0026#39;\u003c/span\u003e\n  \u003cspan\u003eimplementation\u003c/span\u003e \u003cspan\u003e\u0026#39;org.jetbrains.kotlin:kotlin-stdlib:1.8.21\u0026#39;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003econfigurations\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econfigureEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eresolutionStrategy\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efailOnVersionConflict\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNow when building we get a failure:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eExecution failed for task \u0026#39;:compileJava\u0026#39;.\n\u0026gt; Could not resolve all dependencies for configuration \u0026#39;:compileClasspath\u0026#39;.\n   \u0026gt; Conflicts found for the following modules:\n       - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.10 and 1.8.21\n       - org.jetbrains.kotlin:kotlin-stdlib between versions 1.9.10 and 1.8.21\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe failure suggests running \u003ccode\u003edependencyInsight\u003c/code\u003e, which shows you a wall of text containing the subgraph of affected dependencies which led to the conflict.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; Task :dependencyInsight\nDependency resolution failed because of conflicts on the following modules:\n   - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.10 and 1.8.21\n\norg.jetbrains.kotlin:kotlin-stdlib-common:1.9.10\n  Variant compile:\n    | Attribute Name                 | Provided | Requested    |\n    |--------------------------------|----------|--------------|\n    | org.gradle.status              | release  |              |\n    | org.gradle.category            | library  | library      |\n    | org.gradle.libraryelements     | jar      | classes      |\n    | org.gradle.usage               | java-api | java-api     |\n    | org.gradle.dependency.bundling |          | external     |\n    | org.gradle.jvm.environment     |          | standard-jvm |\n    | org.gradle.jvm.version         |          | 21           |\n   Selection reasons:\n      - By conflict resolution: between versions 1.9.10 and 1.8.21\n\norg.jetbrains.kotlin:kotlin-stdlib-common:1.9.10\n+--- com.squareup.okio:okio-jvm:3.6.0\n|    \\--- com.squareup.okio:okio:3.6.0\n|         \\--- compileClasspath\n\\--- org.jetbrains.kotlin:kotlin-stdlib:1.9.10\n     +--- compileClasspath (requested org.jetbrains.kotlin:kotlin-stdlib:1.8.21)\n     +--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10\n     |    \\--- com.squareup.okio:okio-jvm:3.6.0 (*)\n     \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.9.10\n          \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10 (*)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe fix for OkHttp is simple: upgrade to a matching version.\u003c/p\u003e\n\n\u003cp\u003eUnfortunately, if you upgrade to a version that’s newer than your transitive dependency, the build still fails.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; Could not resolve all dependencies for configuration \u0026#39;:compileClasspath\u0026#39;.\n   \u0026gt; Conflicts found for the following modules:\n       - org.jetbrains.kotlin:kotlin-stdlib between versions 1.9.23 and 1.9.10\n       - org.jetbrains.kotlin:kotlin-stdlib-jdk8 between versions 1.9.10 and 1.8.0\n       - org.jetbrains.kotlin:kotlin-stdlib-common between versions 1.9.23 and 1.9.10\n       - org.jetbrains.kotlin:kotlin-stdlib-jdk7 between versions 1.9.10 and 1.8.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eYou have to force the use of 1.9.23 everywhere, but doing so will ironically prevent \u003ccode\u003efailOnVersionConflict()\u003c/code\u003e from detecting mismatches in the future.\u003c/p\u003e\n\n\u003cp\u003eGradle has other mechanisms like \u003ca href=\"https://docs.gradle.org/current/userguide/rich_versions.html\"\u003econstraints\u003c/a\u003e and \u003ca href=\"https://docs.gradle.org/current/userguide/resolution_rules.html\"\u003eresolution strategy callbacks\u003c/a\u003e that have tons of power to customize dependency resolution, but none provide the ability to reject upgrades. I would love to be corrected on this, but I spent a few days searching and experimenting with no success. Instead, we have to build our own solution.\u003c/p\u003e\n\n\u003ch3 id=\"actually-fixing-with-gradle\"\u003eActually fixing with Gradle\u003c/h3\u003e\n\n\u003cp\u003eI wrote a task which consumes the dependency graph and checks if the first-order dependencies (i.e., those your project declared directly) select the same version as they request.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; Task :sympathyForMrMaven FAILED\ne: org.jetbrains.kotlin:kotlin-stdlib:1.8.21 changed to 1.9.10\n\n* What went wrong:\nExecution failed for task \u0026#39;:sympathyForMrMaven\u0026#39;.\n\u0026gt; Declared dependencies were upgraded transitively. See task output above. Please update their versions.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhen I bump my declaration to 1.9.10 to match, or even 1.9.23 which is the latest right now, the task no longer fails.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eBUILD SUCCESSFUL in 354ms\n4 actionable tasks: 4 executed\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is what I hacked up in Groovy \u003cem\u003every\u003c/em\u003e quickly this morning (and to finish the damn post):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003efail\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eroot\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econfiguration\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eincoming\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresolutionResult\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erootComponent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eResolvedComponentResult\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003eroot\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003edependencies\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eit\u003c/span\u003e \u003cspan\u003einstanceof\u003c/span\u003e \u003cspan\u003eResolvedDependencyResult\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003erdr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eResolvedDependencyResult\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003erequested\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erdr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erequested\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eselected\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erdr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eselected\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erequested\u003c/span\u003e \u003cspan\u003einstanceof\u003c/span\u003e \u003cspan\u003eModuleComponentSelector\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003erequestedVersion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erequested\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eModuleComponentSelector\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003eversion\u003c/span\u003e\n      \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eselectedVersion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eselected\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emoduleVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eversion\u003c/span\u003e\n      \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erequestedVersion\u003c/span\u003e \u003cspan\u003e!=\u003c/span\u003e \u003cspan\u003eselectedVersion\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eERROR\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;e: ${rdr.requested} changed to ${selectedVersion}\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003efail\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\n      \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efail\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eIllegalStateException\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Declared dependencies were upgraded transitively. See task output above. Please update their versions.\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis needs cleaned up before it can be used generally–sorry! In a long post about how Maven’s dependency resolution is annoying, I instead became \u003ca href=\"https://jakewharton.com/@jw/112171457869714385\"\u003e\u003cem\u003every\u003c/em\u003e annoyed at Gradle\u003c/a\u003e and just want to stop working on this.\u003c/p\u003e\n\n\u003cp\u003eSomeone please change it to Java, wrap it in a task, wrap that in a \u003ccode\u003ecom.yourname.maven-sympathy\u003c/code\u003e plugin, publish to Maven Central, and ping me to update this post. I have about 30 projects I’d love to slap it on, and hopefully other sympathetic library authors who read this post will too!\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-03-28T00:00:00Z",
  "modifiedTime": null
}
