{
  "id": "8bb3647b-110c-4c53-802e-ad7e6ae3af61",
  "title": "Better Previews in Compose with State Hoisting + MVI template",
  "link": "https://proandroiddev.com/better-previews-in-compose-with-state-hoisting-mvi-template-c22774184d26?source=rss----c72404660798---4",
  "description": "",
  "author": "Dhanesh Katre",
  "published": "Sat, 31 May 2025 10:58:31 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "preview",
    "state-hoisting",
    "mobile-app-development",
    "jetpack-compose",
    "android"
  ],
  "byline": "Dhanesh Katre",
  "length": 10434,
  "excerpt": "A short dive into Jetpack Compose State Hoisting concepts to build better UI with rich \u0026 full previews and a standard MVI template to be used commonly",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Better Previews in Compose with State Hoisting + MVI templateImage generated by AI showing Parent Android bot giving “State” to Child Android botNot again!State hoisting caught my attention immediately when Jetpack Compose was introduced a few years ago! And why not.. from all those DevRel's at Google to my favourite YouTubers, everyone was talking about that. Over time, as I continued developing in Compose, or rather thinking in Compose, I realised the significance of this term.That began my journey towards truly understanding declarative UIs and State as an entity. It wasn’t just separating concerns; it was about building truly independent, testable, and most importantly, preview-enabled rich Compose screens that I was focusing on.When I started scaling my apps and dealing with multiple screens daily, I realised the true power of having rich previews for every screen and why state hoisting was originally there to guide us. So here’s a short dive into my learnings so far and my current favourite way of building quick and easy Composable screens.Types of StateI believe that the State entity which drives a particular UI has 2 different types, i.e., Internal (or Local) state and External (or Global) state.Consider a small UI element written in Compose, demonstrating the 2 types:Here, as you can see, our component StateDemoComponent creates a piece of state internalState on its own internally, whereas another piece of state externalState is passed down to the component as an argument. Our component truly owns the internal state, while it has to be dependent on the external state. Now we can say that this component is tightly coupled with the state that it creates internally, i.e., internalState whereas it is loosely coupled with the state that is getting received externally, i.e., externalState. Understanding this is crucial, as this is the very base of what State Hoisting is.The Problem of UI-State Tight CouplingAs seen in the above explanation of types of State, the component becomes tightly coupled with the given state if the component owns it, rather than being dependent on it. This makes the component less flexible, less testable, and more isolated. Full \u0026 rich preview generation of such components is also not possible due to missing branches.Apart from the issue regarding the types of State, there can be another issue. This occurs when we try to pass on such a parameter in the arguments, the instance of which cannot be easily created at the time of preview generation. A classic example of this is passing down an instance of a ViewModel.HomeScreen in this example directly takes in an instance of a ViewModel as its argument. This is fine in runtime, as a DI framework, such as HILT, takes care of the creation of this instance. But since now this screen is tightly coupled with a ViewModel (yes, tightly, as we are directly depending the UI on an entireViewModel), which is cumbersome to create in previews (or at compile time), generating a preview for HomeScreen is no longer possible (or is at least a very cumbersome task).What is State Hoisting?State hoisting is a solution to the above problems. It aims to simplify a Composable component by allowing it to be loosely coupled with its state.Here’s a clear definition given by ChatGPT:At its core, state hoisting is the practice of lifting the state out of a composable function and passing it in as parameters, along with the event handlers that modify it.Instead of managing the state of a component inside it, we allow some higher-level entity (in most cases, the parent of the composable) to manage/handle it for the component. This makes the component free and more open to new modifications if needed. This turns our component into a passive UI creator which just reacts to inputs- perfect for the projects where reusability \u0026 preview-ability matter!Why bother so much?I feel the need to have previews for every Composable component that I write, to see that it's getting rendered correctly. Previews can help in identifying any issues on multiple screens of different dimensions even before running it on actual device. It feels like unit testing your UI for stability \u0026 responsiveness and state hoisting makes that possible.Also, as someone who is a big fan of reusable components, state hoisting allows me to create highly reusable \u0026 modular components, even full-fledged screens, that I can plug \u0026 play across my app. This increases development speed along with lesser redundant code.State Hoisting and my favourite MVI templateThe popular MVI architecture is widely used with Compose as it provides firm control over the state management \u0026 updates while enforcing a strict Unidirectional Data Flow (UDF) policy. Over time, I found myself gravitating towards a particular pattern- A simple \u0026 lightweight Composable screen structure which works elegantly with State Hoisting, while following each \u0026 every principle that we have discussed so far. It separates UI \u0026 State so neatly that previewing each \u0026 every different state of the screen is possible.Here’s how I structure a screenGiven any screen, it is divided into 4 parts/blocks:Screen- Composable screen accepting a state \u0026 reacting to eventsViewModel- A state holder \u0026 business logic processorEvent- A sealed class enumerating all the different events a given screen should react toState- A data class (or a sealed class) depicting various aspects of the screen’s stateLet’s say that you have to develop a screen for your “Profile” destination. So, the structure would be as follows:Since we are developing a feature “Profile” we have added a prefix “Profile” to each entity.ProfileEventThis is a sealed class to manage all the events that are generated regarding this screen. These events can either be user-generated or system-generated (auto-triggered). Screen’s ViewModel is the processor of these events. So, to not forget about a certain event, we have added it under a sealed class, so it becomes an all-or-nothing type of processing. Here we can elegantly use Kotlin’s data classes or objects to achieve a clean event structure as seen in the above code. Let’s see further how we use them in our screen \u0026 ViewModel for processing.ProfileScreenStateI usually like to name it as \u003cFeature\u003eScreenState rather than just State, as it may lead to confusion. Stating that it's a ScreenState means only one thing- to drive our UI efficiently. Now, there are 2 approaches here that one can follow- Either to use a data class or to use a sealed class/interface. Both approaches have their pros \u0026 cons, and are currently out of scope for this article. I prefer to wrap my state under a common data class, so updates to the state can be dispatched easily with a copy function. So, we have 3 different pieces of state for our ProfileScreen here that are well described in our state. Notice that the state has a default value (i.e., all the fields have a default value). This is done to quickly build our first Preview. We just have to create new instances of this state class to see different previews. Let’s see further how.ProfileViewModelThe main logic processor of our screen. Our ViewModel contains a private mutable state, which is exposed to our Composable screen as an immutable State. The screen can only observe this state and cannot directly edit it. ViewModel also contains a function onEvent(Event) that is the main processor of all the events received from the screen. Our screen gets a reference to this function and can invoke any event by calling it with the relevant event instance. So, you can see a UDF pattern here, as the ViewModel only emits state out and doesn’t emit events as such on its own. Whereas the Screen gets the State object, cannot manipulate it on its own, and can only emit events for our ViewModel to process. All of this while maintaining a strict loose coupling \u0026 high preview-ability.ProfileScreenFinally! Our screen class gets everything together to build a beautiful UI. Notice that the Screen is divided into 3 parts. The entry point itself is the Screen, which then invokes actual content that the screen draws. The third part is an independent Preview of that screen. The main screen Composable does all the heavy-lifting for its UI, such as doing things according to the current Context, reacting to SideEffects, applying themes, etc. Typically, all the logic that is not previewable on its own can go in this part, which is different than the original screen’s content. We have used the State Hoisting here to loose-couple these parts. This way, we can still achieve a full \u0026 rich preview of the screen while also incorporating side logic. This entry point receives state object and a lambda onEvent(Event) to drive itself. The screen reacts to the state changes \u0026 emits all the events that are generated. These are passed down into this screen from the ViewModel; state is created in the ViewModel itself \u0026 onEvent lambda can be passed as a reference from the ViewModel directly as shown below-The biggest advantage of this architecture, with proper State Hoisting, is that now we can generate previews for ProfileScreen easily. We can even preview different states that this screen can be into, just by passing a correctly formatted state object into the screen’s Content Composable-As you can see, we can now preview each \u0026 every aspect of the Screen just by tweaking the passed State object. We have also made our screen highly independent, such that now it does not directly depend on the ViewModel itself, as seen earlier.⚠️ Please note, it’s not always a good idea to keep every piece of data in the Global state or External state (as discussed earlier). Sometimes it’s better to use the internal state for brevity. It then becomes a good trade-off between the state management \u0026 previews generation that will help you in your apps. You can divide your Composables into smaller pieces in this case, so that they are individually preview-able.Wrapping upWe’ve seen how state hoisting can help us create independent and fully previewable Composables. The lightweight MVI template we explored allows you to quickly scaffold clean, scalable screens in no time.Feel free to check out the entire app constructed with this MVI template — https://github.com/dkexception/aqi-appI hope you found this walkthrough helpful, and that it inspires you to build more modular, highly previewable \u0026 independent UIs in your projects.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*QBsCndiRobzTOouyO757XQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"b50f\" data-testid=\"storyTitle\"\u003eBetter Previews in Compose with State Hoisting + MVI template\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://dkexception.medium.com/?source=post_page---byline--c22774184d26---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dhanesh Katre\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*3WQguI_sK-8dRlEdfxsWKQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage generated by AI showing Parent Android bot giving “State” to Child Android bot\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"ce89\"\u003eNot again!\u003c/h2\u003e\u003cp id=\"29e6\"\u003eState hoisting caught my attention immediately when Jetpack Compose was introduced a few years ago! And why not.. from all those DevRel\u0026#39;s at Google to my favourite YouTubers, everyone was talking about that. Over time, as I continued developing in Compose, or rather thinking in Compose, I realised the significance of this term.\u003c/p\u003e\u003cp id=\"0bb4\"\u003eThat began my journey towards truly understanding declarative UIs and State as an entity. It wasn’t just separating concerns; it was about building truly independent, testable, and most importantly, preview-enabled rich Compose screens that I was focusing on.\u003c/p\u003e\u003cp id=\"3bf6\"\u003eWhen I started scaling my apps and dealing with multiple screens daily, I realised the true power of having rich previews for every screen and why state hoisting was originally there to guide us. So here’s a short dive into my learnings so far and my current favourite way of building quick and easy Composable screens.\u003c/p\u003e\u003ch2 id=\"ad53\"\u003eTypes of State\u003c/h2\u003e\u003cp id=\"efdf\"\u003eI believe that the State entity which drives a particular UI has 2 different types, i.e., Internal (or Local) state and External (or Global) state.\u003c/p\u003e\u003cp id=\"892a\"\u003eConsider a small UI element written in Compose, demonstrating the 2 types:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"cdcf\"\u003eHere, as you can see, our component \u003ccode\u003eStateDemoComponent\u003c/code\u003e creates a piece of state \u003ccode\u003einternalState\u003c/code\u003e on its own internally, whereas another piece of state \u003ccode\u003eexternalState\u003c/code\u003e is passed down to the component as an argument. Our component truly \u003cstrong\u003eowns\u003c/strong\u003e the internal state, while it has to be \u003cstrong\u003edependent\u003c/strong\u003e on the external state. Now we can say that this component is tightly coupled with the state that it creates internally, i.e., \u003ccode\u003einternalState\u003c/code\u003e whereas it is loosely coupled with the state that is getting received externally, i.e., \u003ccode\u003eexternalState\u003c/code\u003e. Understanding this is crucial, as this is the very base of what State Hoisting is.\u003c/p\u003e\u003ch2 id=\"d7e6\"\u003eThe Problem of UI-State Tight Coupling\u003c/h2\u003e\u003cp id=\"060d\"\u003eAs seen in the above explanation of types of State, the component becomes tightly coupled with the given state if the component owns it, rather than being dependent on it. This makes the component less flexible, less testable, and more isolated. Full \u0026amp; rich preview generation of such components is also not possible due to missing branches.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7a9b\"\u003eApart from the issue regarding the types of State, there can be another issue. This occurs when we try to pass on such a parameter in the arguments, the instance of which cannot be easily created at the time of preview generation. A classic example of this is passing down an instance of a \u003ccode\u003eViewModel\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"25e9\"\u003e\u003ccode\u003eHomeScreen\u003c/code\u003e in this example directly takes in an instance of a \u003ccode\u003eViewModel\u003c/code\u003e as its argument. This is fine in runtime, as a DI framework, such as HILT, takes care of the creation of this instance. But since now this screen is tightly coupled with a \u003ccode\u003eViewModel\u003c/code\u003e (yes, \u003cstrong\u003etightly\u003c/strong\u003e, as we are directly depending the UI on an entire\u003ccode\u003eViewModel\u003c/code\u003e), which is cumbersome to create in previews (or at compile time), generating a preview for \u003ccode\u003eHomeScreen\u003c/code\u003e is no longer possible (or is at least a very cumbersome task).\u003c/p\u003e\u003ch2 id=\"d73a\"\u003eWhat is State Hoisting?\u003c/h2\u003e\u003cp id=\"d471\"\u003eState hoisting is a solution to the above problems. It aims to simplify a Composable component by allowing it to be loosely coupled with its state.\u003c/p\u003e\u003cp id=\"7eab\"\u003eHere’s a clear definition given by ChatGPT:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"b225\"\u003eAt its core, \u003cstrong\u003estate hoisting\u003c/strong\u003e is the practice of \u003cstrong\u003elifting the state out of a composable function and passing it in as parameters\u003c/strong\u003e, along with the event handlers that modify it.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"b942\"\u003eInstead of managing the state of a component inside it, we allow some higher-level entity (in most cases, the parent of the composable) to manage/handle it for the component. This makes the component free and more open to new modifications if needed. This turns our component into a passive UI creator which just reacts to inputs- perfect for the projects where reusability \u0026amp; preview-ability matter!\u003c/p\u003e\u003ch2 id=\"dfe8\"\u003eWhy bother so much?\u003c/h2\u003e\u003cp id=\"c6a1\"\u003eI feel the need to have previews for every Composable component that I write, to see that it\u0026#39;s getting rendered correctly. Previews can help in identifying any issues on multiple screens of different dimensions even before running it on actual device. It feels like unit testing your UI for stability \u0026amp; responsiveness and state hoisting makes that possible.\u003c/p\u003e\u003cp id=\"7c71\"\u003eAlso, as someone who is a big fan of reusable components, state hoisting allows me to create highly reusable \u0026amp; modular components, even full-fledged screens, that I can plug \u0026amp; play across my app. This increases development speed along with lesser redundant code.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"eaa4\"\u003eState Hoisting and my favourite MVI template\u003c/h2\u003e\u003cp id=\"92d0\"\u003eThe popular MVI architecture is widely used with Compose as it provides firm control over the state management \u0026amp; updates while enforcing a strict Unidirectional Data Flow (UDF) policy. Over time, I found myself gravitating towards a particular pattern- A simple \u0026amp; lightweight Composable screen structure which works elegantly with State Hoisting, while following each \u0026amp; every principle that we have discussed so far. It separates UI \u0026amp; State so neatly that previewing each \u0026amp; every different state of the screen is possible.\u003c/p\u003e\u003ch2 id=\"9ca8\"\u003eHere’s how I structure a screen\u003c/h2\u003e\u003cp id=\"697e\"\u003eGiven any screen, it is divided into 4 parts/blocks:\u003c/p\u003e\u003col\u003e\u003cli id=\"5ab0\"\u003e\u003cstrong\u003eScreen\u003c/strong\u003e- Composable screen accepting a state \u0026amp; reacting to events\u003c/li\u003e\u003cli id=\"c308\"\u003e\u003cstrong\u003eViewModel\u003c/strong\u003e- A state holder \u0026amp; business logic processor\u003c/li\u003e\u003cli id=\"2cbc\"\u003e\u003cstrong\u003eEvent\u003c/strong\u003e- A sealed class enumerating all the different events a given screen should react to\u003c/li\u003e\u003cli id=\"5f43\"\u003e\u003cstrong\u003eState\u003c/strong\u003e- A data class (or a sealed class) depicting various aspects of the screen’s state\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"69e0\"\u003eLet’s say that you have to develop a screen for your “Profile” destination. So, the structure would be as follows:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b6f8\"\u003eSince we are developing a feature “Profile” we have added a prefix “Profile” to each entity.\u003c/p\u003e\u003ch2 id=\"e288\"\u003e\u003cstrong\u003eProfileEvent\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"00a5\"\u003eThis is a sealed class to manage all the events that are generated regarding this screen. These events can either be user-generated or system-generated (auto-triggered). Screen’s ViewModel is the processor of these events. So, to not forget about a certain event, we have added it under a sealed class, so it becomes an all-or-nothing type of processing. Here we can elegantly use Kotlin’s \u003ccode\u003edata\u003c/code\u003e classes or objects to achieve a clean event structure as seen in the above code. Let’s see further how we use them in our screen \u0026amp; ViewModel for processing.\u003c/p\u003e\u003ch2 id=\"7949\"\u003e\u003cstrong\u003eProfileScreenState\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0b11\"\u003eI usually like to name it as \u003ccode\u003e\u0026lt;Feature\u0026gt;ScreenState\u003c/code\u003e rather than just State, as it may lead to confusion. Stating that it\u0026#39;s a ScreenState means only one thing- to drive our UI efficiently. Now, there are 2 approaches here that one can follow- Either to use a \u003ccode\u003edata class\u003c/code\u003e or to use a \u003ccode\u003esealed class/interface\u003c/code\u003e. Both approaches have their pros \u0026amp; cons, and are currently out of scope for this article. I prefer to wrap my state under a common data class, so updates to the state can be dispatched easily with a \u003ccode\u003ecopy\u003c/code\u003e function. So, we have 3 different pieces of state for our ProfileScreen here that are well described in our state. Notice that the state has a default value (i.e., all the fields have a default value). This is done to quickly build our first Preview. We just have to create new instances of this state class to see different previews. Let’s see further how.\u003c/p\u003e\u003ch2 id=\"64a6\"\u003e\u003cstrong\u003eProfileViewModel\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"5cdc\"\u003eThe main logic processor of our screen. Our ViewModel contains a private mutable state, which is exposed to our Composable screen as an immutable State. The screen can only observe this state and cannot directly edit it. ViewModel also contains a function \u003ccode\u003eonEvent(Event)\u003c/code\u003e that is the main processor of all the events received from the screen. Our screen gets a reference to this function and can invoke any event by calling it with the relevant event instance. So, you can see a UDF pattern here, as the ViewModel only emits state out and doesn’t emit events as such on its own. Whereas the Screen gets the State object, cannot manipulate it on its own, and can only emit events for our ViewModel to process. All of this while maintaining a strict loose coupling \u0026amp; high preview-ability.\u003c/p\u003e\u003ch2 id=\"3287\"\u003e\u003cstrong\u003eProfileScreen\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"94c7\"\u003eFinally! Our screen class gets everything together to build a beautiful UI. Notice that the Screen is divided into 3 parts. The entry point itself is the Screen, which then invokes actual content that the screen draws. The third part is an independent Preview of that screen. The main screen Composable does all the heavy-lifting for its UI, such as doing things according to the current Context, reacting to SideEffects, applying themes, etc. Typically, all the logic that is not previewable on its own can go in this part, which is different than the original screen’s content. We have used the State Hoisting here to loose-couple these parts. This way, we can still achieve a full \u0026amp; rich preview of the screen while also incorporating side logic. This entry point receives \u003ccode\u003estate\u003c/code\u003e object and a lambda \u003ccode\u003eonEvent(Event)\u003c/code\u003e to drive itself. The screen reacts to the state changes \u0026amp; emits all the events that are generated. These are passed down into this screen from the ViewModel; state is created in the ViewModel itself \u0026amp; onEvent lambda can be passed as a reference from the ViewModel directly as shown below-\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2788\"\u003eThe biggest advantage of this architecture, with proper State Hoisting, is that now we can generate previews for ProfileScreen easily. We can even preview different states that this screen can be into, just by passing a correctly formatted state object into the screen’s \u003ccode\u003eContent\u003c/code\u003e Composable-\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"32c9\"\u003eAs you can see, we can now preview each \u0026amp; every aspect of the Screen just by tweaking the passed \u003ccode\u003eState\u003c/code\u003e object. We have also made our screen highly independent, such that now it does not directly depend on the ViewModel itself, as seen earlier.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"71f2\"\u003e⚠️ Please note, it’s not always a good idea to keep every piece of data in the Global state or External state (as discussed earlier). Sometimes it’s better to use the internal state for brevity. It then becomes a good trade-off between the state management \u0026amp; previews generation that will help you in your apps. You can divide your Composables into smaller pieces in this case, so that they are individually preview-able.\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a9d8\"\u003eWrapping up\u003c/h2\u003e\u003cp id=\"0eaa\"\u003eWe’ve seen how state hoisting can help us create independent and fully previewable Composables. The lightweight MVI template we explored allows you to quickly scaffold clean, scalable screens in no time.\u003c/p\u003e\u003cp id=\"0f30\"\u003eFeel free to check out the entire app constructed with this MVI template — \u003ca href=\"https://github.com/dkexception/aqi-app\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/dkexception/aqi-app\u003c/a\u003e\u003c/p\u003e\u003cp id=\"db5b\"\u003eI hope you found this walkthrough helpful, and that it inspires you to build more modular, highly previewable \u0026amp; independent UIs in your projects.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-05-26T11:29:27.227Z",
  "modifiedTime": null
}
