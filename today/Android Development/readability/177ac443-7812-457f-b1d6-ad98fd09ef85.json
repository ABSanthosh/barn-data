{
  "id": "177ac443-7812-457f-b1d6-ad98fd09ef85",
  "title": "Getting Started With EXO Player in Jetpack Compose",
  "link": "https://proandroiddev.com/getting-started-with-exo-player-in-jetpack-compose-72173ed1a86b?source=rss----c72404660798---4",
  "description": "",
  "author": "Siva Ganesh Kantamani",
  "published": "Fri, 04 Jul 2025 00:21:35 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "exoplayer2",
    "android-app-development",
    "androiddev",
    "media-player"
  ],
  "byline": "Siva Ganesh Kantamani",
  "length": 17844,
  "excerpt": "This is the first part of our series exploring the EXO Player in Android. We’ll start with the basic concepts, then set up the project and add the required dependencies. Next, we’ll develop the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Getting Started With EXO Player in Jetpack ComposeBasics, Custom Video Controls, and Playlist SupportPhoto by Kelly Sikkema on UnsplashOverview of the SeriesThis is the first part of our series exploring the EXO Player in Android. We’ll start with the basic concepts, then set up the project and add the required dependencies. Next, we’ll develop the player with a single item and eventually create a playlist with play, pause, previous, and next controls.Introduction to EXO PlayerWhat is ExoPlayer? Why use it over Android’s MediaPlayer?A team at Google developed EXO Player as a standalone library with core, ui, etc., modules. Later on, it became part of the Jetpack suite to improve the lifecycle-aware playback, ease of integration on Android Auto, and other form factors.Media3 EXO Player is actively maintained and recommended to use in new projects. Media3 EXO Player has close integration with MediaSession, MediaController, and Media2.Key features and advantages of modern media playbackEXO Player being part of the Media3 Jetpack library provides advantages like lifecycle-aware playback, meaning that when the activity/fragment goes to the background, playback will be handled accordingly without any manual work(though it has limitations like with only particular player surfaces).Consistent updates alongside the Jetpack suite of libraries and easier integration with Jetpack Compose.Easier integration in Android Auto, Wear OS, TV, etc.It also supports persistent playback out of the box with the media3-database module. This adds significant value to the product in real-time by keeping the user engaged with minimal buffering.Setting Up Your ProjectFire up Android Studio and create a simple project with an empty Jetpack Compose template. Then we’ll start adding the libraries required as the project progresses.Overview of project structureWe’ll create a simple EXO Player compose screen. This screen will be hosted by an Activity that can handle composable views. We’ll also create a view-model to manage the EXO Player and necessary data classes and state flows for communication. At this point, we’ll keep the project simple, so no modular architecture. The vital point of this series is to learn about the EXO player.We’ll use Jetpack Compose for the UI, meaning compatible libraries to host the EXO player within Compose without relying on the AndroidView bridge. Additionally, we’ll use view models to address real-time challenges, such as persisting the player state across configuration changes. As we’ve Compose and view models, it’s always better to have a dependency injection framework. For that purpose, we’ll use Hilt.Integration of required EXO player and Jetpack Compose dependenciesTo integrate dependencies, I’m using the latest recommended approach, which involves using the version catalog with toml files. Additionally, I have switched from the old Groovy scripts to using Kotlin Gradle scripts.Let’s start by adding Hilt, material icons, and view-models library configuration to the toml file. Note that we integrate material icons as part of the compose BOM integration.[versions]lifecycleRuntimeKtx = \"2.8.7\"hiltNavigationCompose = \"1.2.0\"[libraries]androidx-hilt-navigation-compose = { module = \"androidx.hilt:hilt-navigation-compose\", version.ref = \"hiltNavigationCompose\" }androidx-lifecycle-viewmodel-compose = { module = \"androidx.lifecycle:lifecycle-viewmodel-compose\", version.ref = \"lifecycleRuntimeKtx\" }androidx-material-icons-extended = { group = \"androidx.compose.material\", name = \"material-icons-extended\" }Let’s complete the integration of these libraries by adding them to the dependencies node of the app-level Gradle file. Have a look:implementation(libs.androidx.lifecycle.viewmodel.compose)implementation(libs.androidx.hilt.navigation.compose)implementation(libs.androidx.material.icons.extended)kotlinNow let’s add Media3 EXO Player libraries, starting with the toml file:[versions]media3ExoplayerDash = \"1.6.1\"[libraries]androidx-media3-exoplayer = { module = \"androidx.media3:media3-exoplayer\", version.ref = \"media3ExoplayerDash\" }androidx-media3-exoplayer-dash = { module = \"androidx.media3:media3-exoplayer-dash\", version.ref = \"media3ExoplayerDash\" }androidx-media3-ui-compose = { module = \"androidx.media3:media3-ui-compose\", version.ref = \"media3ExoplayerDash\" }Then add them in the app-level gradle file:// For building media playback UIs using Jetpack Composeimplementation(libs.androidx.media3.ui.compose)// For media playback using ExoPlayerimplementation(libs.androidx.media3.exoplayer)Build the UI with Jetpack Compose and View Model to hold EXO PlayerLet’s begin by creating the PlayerScreen composable. This composable will use the PlayerSurface composable function from the Media3 compose UI library. It takes a Media3 player as a parameter and manages it within the compose layers. Since the EXO player is part of the media3-exoplayer module extends the Media3 player, we can directly pass it to the PlayerSurface.Have a look at the implementation:@Composablefun PlayerScreen( modifier: Modifier = Modifier, exoPlayer: ExoPlayer,) { Box( modifier = modifier ) { PlayerSurface( player = exoPlayer, modifier = Modifier .fillMaxWidth() .aspectRatio(16f / 9f) .align(Alignment.Center) ) }}Player ViewModelNow, let’s create PlayerViewModel kotlin class and extend it with ViewModel() and annotate it with @HiltViewModel for DI purpose. This class will contain two components for now: a stateflow with an EXO player and a companion object that holds sample video URLs.. Have a look:@HiltViewModelclass PlayerViewModel: ViewModel() { companion object { // Source for videos: https://gist.github.com/jsturgis/3b19447b304616f18657 const val Video_1 = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\" const val Video_2 = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4\" const val Video_3 = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4\" const val Video_4 = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4\" } private val _playerState = MutableStateFlow\u003cExoPlayer?\u003e(null) val playerState: StateFlow\u003cExoPlayer?\u003e = _playerState}Player compose routeNow, let’s create a top-level composable called PlayerRoute to host the player screen and manage state-level operations. Have a look:@Composablefun PlayerRoute( modifier: Modifier = Modifier, playerViewModel: PlayerViewModel = viewModel(),) { val exoPlayer = playerViewModel.playerState.collectAsStateWithLifecycle() Box(modifier.fillMaxSize()) { exoPlayer.value?.let { PlayerScreen(exoPlayer = it) } }}For now, this function appears to be overkill, but as the project grows, more and more aspects like side effects and states will be part of it. This function will be effective in isolating these elements from the PlayerScreen.Activity level integrationFinally, create PlayerActivity and integrate PlayerRoute inside the onCreate via the setContent function. Have a look:class PlayerActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContent { ExoPlayerLearningTheme { Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -\u003e PlayerRoute( modifier = Modifier.padding(innerPadding) ) } } } }}Managing Playback with ViewModelNow that we’ve completed building the compose UI and basic view model configuration, it’s time to build the EXO player and update UI via stateflow.Step 1: Create a Media3 MediaItem with a sample URL as shown below:val mediaItem = MediaItem.Builder().setUri(Video_1).setMediaId(\"Video_1\").build(),Step 2: Create the EXO player instance with this media item as shown below:ExoPlayer.Builder(context).build().apply { setMediaItem(mediaItem) prepare() playWhenReady = true play()}Step 3: Update the stateflow with the EXO Player created in step 2.Finally, have a look at the function after putting things together:fun createPlayerWithMediaItems(context: Context,) { if (_playerState.value == null) { // Create Media item val mediaItem = MediaItem.Builder().setUri(Video_1).setMediaId(\"Video_1\").build(), // Create the player instance and update it to UI via stateFlow _playerState.update { ExoPlayer.Builder(context).build().apply { setMediaItem(mediaItem) prepare() playWhenReady = true } } }}setMediaItemSet the media source to the player.prepare() will tell the player to prepare the media item to be played.playWhenReady Will tell the player to start playing once the media item is ready.Now, let’s call this function from PlayerRoute via LaunchedEffect as shown below:@Composablefun PlayerRoute( modifier: Modifier = Modifier, playerViewModel: PlayerViewModel = viewModel(),) { val exoPlayer = playerViewModel.playerState.collectAsStateWithLifecycle() val context = LocalContext.current Box(modifier.fillMaxSize()) { exoPlayer.value?.let { PlayerScreen(exoPlayer = it) } } LaunchedEffect(Unit) { playerViewModel.createPlayerWithMediaItems(context) }}If you run the application, you should be able to see a video playback, and it can survive configuration changes.Implementing a Playlist in ExoPlayerConfigure PlaylistNow let’s get into the playlist, first step is to create the list of media items that we intend to play. Have a look:val mediaItems = listOf( MediaItem.Builder().setUri(Video_1).setMediaId(\"Video_1\").build(), MediaItem.Builder().setUri(Video_2).setMediaId(\"Video_2\").build(), MediaItem.Builder().setUri(Video_3).setMediaId(\"Video_3\").build(), MediaItem.Builder().setUri(Video_4).setMediaId(\"Video_4\").build(),)Then, instead of using setMediaItemWe’ll use setMediaItems and pass the list we created above.ExoPlayer.Builder(context).build().apply { setMediaItems(mediaItems) prepare() playWhenReady = true}Now, if you run the application upon finishing the first video, the player moves to the next media item in the list.Design Player Controls to Manage Playback and PlaylistNow that we’ve created the playlist, it’s time to develop controls that allow users to navigate between media items using the previous and next buttons. To enhance the user experience, let’s also include play/pause, rewind, and forward buttons.Let’s begin by creating a simple enum class that represents the player action type and maps it to the viewmodel.enum class ActionType { PLAY, PAUSE, REWIND, FORWARD, PREVIOUS, NEXT}Let’s wrap this enum inside a data, along with Any type variable, so that we can associate data along with action type on click actions in the UI to communicate to the view model.Let’s wrap this enum inside a data class, along with a variable of typeAny, so that we can associate data with the ActionType when clicked on UI elements to communicate to the view model.data class PlayerAction( val actionType: ActionType, val data: Any? = null,)Now, let’s create a composable function VideoControls with two parameters: Exo Player and a lambda function for the click action. Here we’ll have two states representing the playback status and controls visibility.Now, let’s create a composable function called VideoControls that takes two parameters: an Exo Player and a lambda function representing the click action. This function will have two states: one for the playback status and another for the visibility of the controls. Have a look:@Composablefun VideoControls( player: ExoPlayer, playerActions: (PlayerAction) -\u003e Unit,) { var isPlaying by remember { mutableStateOf(player.isPlaying) } var controlsVisible by remember { mutableStateOf(true) }|Before going to the design part, let’s put these states to use:Update states on necessary callbacksisPlaying has to be updated whenever there is a change in the playback. For this, we’ll attach a local player listener to the player to get the playback updates. We’ll use DisposableEffect so that we can remove the listener when not required. Have a look:DisposableEffect(player) { val listener = object : Player.Listener { override fun onIsPlayingChanged(isPlayingNow: Boolean) { isPlaying = isPlayingNow } } player.addListener(listener) onDispose { player.removeListener(listener) }}Then, we need to make the controllers visible. We’ll toggle their visibility for every touch interaction and ensure that the controllers are removed from the player after three seconds of interaction. In this case, we’ll use LaunchedEffect because we don’t need to dispose any resources. Have a look:LaunchedEffect(isPlaying, controlsVisible) { if (isPlaying \u0026\u0026 controlsVisible) { delay(3000) controlsVisible = false }}Let’s design the ControlsIt’s quite a straightforward implementation. At the core, we use the Row component to align the buttons. To represent each action, we use the IconButton component from compose. At the top level, we use the Box component to represent the Row of actions or an empty Box based on the controlsVisible state. Have a look:Player actions in the View modelLet’s create a function in the view model with a PlayerAction as a parameter. Then handle the action type as shown below:That’s all, now we just have to trigger the executeAction from the compose layer. The flow will execute based on the action type.Playback ImprovementsIf you run the application, everything works fine. However, there are a couple of improvements we can make.Lifecycle-aware playbackWhen the user clicks on the device’s home button and the app goes into the background, the video continues to play. This is because the PlayerSurface is not lifecycle-aware by default. We can fix this by executing play/pause actions on the player based on the lifecycle changes on the composable. We’ll use DisposableEffect for this purpose. Have a look:val lifecycleOwner = LocalLifecycleOwner.currentDisposableEffect(lifecycleOwner) { val observer = LifecycleEventObserver { _, event -\u003e when (event) { Lifecycle.Event.ON_PAUSE -\u003e playerViewModel.executeAction(PlayerAction(ActionType.PAUSE)) Lifecycle.Event.ON_RESUME -\u003e playerViewModel.executeAction(PlayerAction(ActionType.PLAY)) else -\u003e Unit } } lifecycleOwner.lifecycle.addObserver(observer) onDispose { lifecycleOwner.lifecycle.removeObserver(observer) }}The above code inside PlayerRoute will make sure to play and pause based on the lifecycle owner events.Remember the current playback positionWhen users switch between playlist items, the video starts from the beginning instead of where the user left off. Developers must manually handle this issue. To resolve this problem, developers can manually track the current position and save it in the view model. When the user returns to the video, they can use the saved position to seek to that time.Let’s start by creating a VideoItem data class with currentPosition as a Long variable.data class VideoItem( val currentPosition: Long = 0)We’ll have a hashmap in the view model to keep track of the positions. The key of the map is the video ID, and the value is VideoItem. Have a look:private val hashMapVideoStates = mutableMapOf\u003cString,VideoItem\u003e()The following is the function to update the hashmap with the current position while playback is ongoing.fun updateCurrentPosition(id: String, position: Long) { hashMapVideoStates[id] = hashMapVideoStates[id]?.copy(currentPosition = position) ?: VideoItem(currentPosition = position)}Finally, we need to trigger the above function from the PlayerRoute function every second. We can do this as shown below via LaunchedEffect. Have a look:LaunchedEffect(Unit) { while (true) { exoPlayer.value?.currentMediaItem?.mediaId?.let { playerViewModel.updateCurrentPosition( it, exoPlayer.value?.currentPosition ?: 0 ) } delay(1000) }}Now, whenever the user triggers previous or next actions, we can fetch the current time from the hashMapVideoStates and apply the return value via seek function as shown below:private fun ExoPlayer.playNext() { if (hasNextMediaItem()) { val nextIndex = currentMediaItemIndex + 1 val mediaItemId = getMediaItemAt(nextIndex) val seekPosition = hashMapVideoStates[mediaItemId.mediaId]?.currentPosition ?: 0L seekTo(nextIndex, seekPosition) }}private fun ExoPlayer.playPrevious() { if ( isCommandAvailable(Player.COMMAND_SEEK_TO_MEDIA_ITEM) \u0026\u0026 hasPreviousMediaItem() ) { val previousIndex = currentMediaItemIndex - 1 val mediaItemId = getMediaItemAt(previousIndex) val seekPosition = hashMapVideoStates[mediaItemId.mediaId]?.currentPosition ?: 0L seekTo(previousIndex, seekPosition) }}End Note:Following is a link to the sample project, if you need it. Make sure to check out feature/bascis_play_list For this article related code :In this part of the series, we explored the origins of the Media3 EXO player, its creation and management within the view model, and integration into Jetpack Compose. Additionally, we learned how to create playlists and manage video playback controls. In the next part, I’ll focus on Player listeners, timeline view implementation, analytics, the cache mechanism, and more.That is all for now. I hope you learned something useful. Thanks for reading!",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*1Px65AlaG_NtvXhQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"b45e\" data-testid=\"storyTitle\"\u003e\u003cstrong\u003eGetting Started With EXO Player in Jetpack Compose\u003c/strong\u003e\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"17b3\"\u003eBasics, Custom Video Controls, and Playlist Support\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://sgkantamani.medium.com/?source=post_page---byline--72173ed1a86b---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Siva Ganesh Kantamani\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*bVSRBKr1Pb75KQuhsPXO7g.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@kellysikkema?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKelly Sikkema\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"1704\"\u003eOverview of the Series\u003c/h2\u003e\u003cp id=\"c1f7\"\u003eThis is the first part of our series exploring the EXO Player in Android. We’ll start with the basic concepts, then set up the project and add the required dependencies. Next, we’ll develop the player with a single item and eventually create a playlist with play, pause, previous, and next controls.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5514\"\u003eIntroduction to EXO Player\u003c/h2\u003e\u003ch2 id=\"acb4\"\u003eWhat is ExoPlayer? Why use it over Android’s MediaPlayer?\u003c/h2\u003e\u003cp id=\"29bb\"\u003eA team at Google developed EXO Player as a standalone library with core, ui, etc., modules. Later on, it became part of the Jetpack suite to improve the lifecycle-aware playback, ease of integration on Android Auto, and other form factors.\u003c/p\u003e\u003cp id=\"0506\"\u003eMedia3 EXO Player is actively maintained and recommended to use in new projects. Media3 EXO Player has close integration with \u003ccode\u003eMediaSession\u003c/code\u003e, \u003ccode\u003eMediaController\u003c/code\u003e, and \u003ccode\u003eMedia2\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"660f\"\u003eKey features and advantages of modern media playback\u003c/h2\u003e\u003col\u003e\u003cli id=\"cd32\"\u003eEXO Player being part of the Media3 Jetpack library provides advantages like lifecycle-aware playback, meaning that when the activity/fragment goes to the background, playback will be handled accordingly without any manual work(though it has limitations like with only particular player surfaces).\u003c/li\u003e\u003cli id=\"4fe8\"\u003eConsistent updates alongside the Jetpack suite of libraries and easier integration with Jetpack Compose.\u003c/li\u003e\u003cli id=\"315e\"\u003eEasier integration in Android Auto, Wear OS, TV, etc.\u003c/li\u003e\u003cli id=\"8978\"\u003eIt also supports persistent playback out of the box with the media3-database module. This adds significant value to the product in real-time by keeping the user engaged with minimal buffering.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0afa\"\u003eSetting Up Your Project\u003c/h2\u003e\u003cp id=\"eac8\"\u003eFire up Android Studio and create a simple project with an empty Jetpack Compose template. Then we’ll start adding the libraries required as the project progresses.\u003c/p\u003e\u003ch2 id=\"3ceb\"\u003eOverview of project structure\u003c/h2\u003e\u003cp id=\"1f62\"\u003eWe’ll create a simple EXO Player compose screen. This screen will be hosted by an Activity that can handle composable views. We’ll also create a view-model to manage the EXO Player and necessary data classes and state flows for communication. At this point, we’ll keep the project simple, so no modular architecture. The vital point of this series is to learn about the EXO player.\u003c/p\u003e\u003cp id=\"1a4c\"\u003eWe’ll use Jetpack Compose for the UI, meaning compatible libraries to host the EXO player within Compose without relying on the \u003ccode\u003eAndroidView\u003c/code\u003e bridge. Additionally, we’ll use view models to address real-time challenges, such as persisting the player state across configuration changes. As we’ve Compose and view models, it’s always better to have a dependency injection framework. For that purpose, we’ll use Hilt.\u003c/p\u003e\u003ch2 id=\"f040\"\u003eIntegration of required EXO player and Jetpack Compose dependencies\u003c/h2\u003e\u003cp id=\"0914\"\u003eTo integrate dependencies, I’m using the latest recommended approach, which involves using the version catalog with \u003ccode\u003etoml\u003c/code\u003e files. Additionally, I have switched from the old Groovy scripts to using Kotlin Gradle scripts.\u003c/p\u003e\u003cp id=\"bb12\"\u003eLet’s start by adding Hilt, material icons, and view-models library configuration to the toml file. Note that we integrate material icons as part of the compose BOM integration.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ded6\"\u003e[versions]\u003cbr/\u003elifecycleRuntimeKtx = \u0026#34;2.8.7\u0026#34;\u003cbr/\u003ehiltNavigationCompose = \u0026#34;1.2.0\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-hilt-navigation-compose = { module = \u0026#34;androidx.hilt:hilt-navigation-compose\u0026#34;, version.ref = \u0026#34;hiltNavigationCompose\u0026#34; }\u003cbr/\u003eandroidx-lifecycle-viewmodel-compose = { module = \u0026#34;androidx.lifecycle:lifecycle-viewmodel-compose\u0026#34;, version.ref = \u0026#34;lifecycleRuntimeKtx\u0026#34; }\u003cbr/\u003eandroidx-material-icons-extended = { group = \u0026#34;androidx.compose.material\u0026#34;, name = \u0026#34;material-icons-extended\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"995f\"\u003eLet’s complete the integration of these libraries by adding them to the dependencies node of the app-level Gradle file. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f674\"\u003eimplementation(libs.androidx.lifecycle.viewmodel.compose)\u003cbr/\u003eimplementation(libs.androidx.hilt.navigation.compose)\u003cbr/\u003eimplementation(libs.androidx.material.icons.extended)kotlin\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a02f\"\u003eNow let’s add Media3 EXO Player libraries, starting with the toml file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"35ca\"\u003e[versions]\u003cbr/\u003emedia3ExoplayerDash = \u0026#34;1.6.1\u0026#34;\u003cp\u003e[libraries]\u003cbr/\u003eandroidx-media3-exoplayer = { module = \u0026#34;androidx.media3:media3-exoplayer\u0026#34;, version.ref = \u0026#34;media3ExoplayerDash\u0026#34; }\u003cbr/\u003eandroidx-media3-exoplayer-dash = { module = \u0026#34;androidx.media3:media3-exoplayer-dash\u0026#34;, version.ref = \u0026#34;media3ExoplayerDash\u0026#34; }\u003cbr/\u003eandroidx-media3-ui-compose = { module = \u0026#34;androidx.media3:media3-ui-compose\u0026#34;, version.ref = \u0026#34;media3ExoplayerDash\u0026#34; }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"003c\"\u003eThen add them in the app-level gradle file:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"071e\"\u003e// For building media playback UIs using Jetpack Compose\u003cbr/\u003eimplementation(libs.androidx.media3.ui.compose)\u003cp\u003e// For media playback using ExoPlayer\u003cbr/\u003eimplementation(libs.androidx.media3.exoplayer)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a4cc\"\u003eBuild the UI with Jetpack Compose and View Model to hold EXO Player\u003c/h2\u003e\u003cp id=\"730d\"\u003eLet’s begin by creating the PlayerScreen composable. This composable will use the \u003ccode\u003ePlayerSurface\u003c/code\u003e composable function from the Media3 compose UI library. It takes a Media3 player as a parameter and manages it within the compose layers. Since the EXO player is part of the \u003ccode\u003emedia3-exoplayer \u003c/code\u003emodule extends the Media3 player, we can directly pass it to the \u003ccode\u003ePlayerSurface\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ed80\"\u003eHave a look at the implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c99\"\u003e@Composable\u003cbr/\u003efun PlayerScreen(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    exoPlayer: ExoPlayer,\u003cbr/\u003e) {\u003cbr/\u003e    Box(\u003cbr/\u003e        modifier = modifier\u003cbr/\u003e    ) {\u003cbr/\u003e        PlayerSurface(\u003cbr/\u003e            player = exoPlayer,\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxWidth()\u003cbr/\u003e                .aspectRatio(16f / 9f)\u003cbr/\u003e                .align(Alignment.Center)\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e187\"\u003ePlayer ViewModel\u003c/h2\u003e\u003cp id=\"d7e2\"\u003eNow, let’s create \u003ccode\u003ePlayerViewModel\u003c/code\u003e kotlin class and extend it with \u003ccode\u003eViewModel() \u003c/code\u003eand annotate it with \u003ccode\u003e@HiltViewModel\u003c/code\u003e for DI purpose. This class will contain two components for now: a stateflow with an EXO player and a companion object that holds sample video URLs.. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"19f8\"\u003e@HiltViewModel\u003cbr/\u003eclass PlayerViewModel: ViewModel() {\u003cp\u003e    companion object {\u003cbr/\u003e        // Source for videos: https://gist.github.com/jsturgis/3b19447b304616f18657\u003cbr/\u003e        const val Video_1 = \u0026#34;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\u0026#34;\u003cbr/\u003e        const val Video_2 = \u0026#34;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4\u0026#34;\u003cbr/\u003e        const val Video_3 = \u0026#34;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4\u0026#34;\u003cbr/\u003e        const val Video_4 = \u0026#34;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4\u0026#34;\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    private val _playerState = MutableStateFlow\u0026lt;ExoPlayer?\u0026gt;(null)\u003cbr/\u003e    val playerState: StateFlow\u0026lt;ExoPlayer?\u0026gt; = _playerState\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"7975\"\u003ePlayer compose route\u003c/h2\u003e\u003cp id=\"664b\"\u003eNow, let’s create a top-level composable called \u003ccode\u003ePlayerRoute\u003c/code\u003e to host the player screen and manage state-level operations. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7296\"\u003e@Composable\u003cbr/\u003efun PlayerRoute(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    playerViewModel: PlayerViewModel = viewModel(),\u003cbr/\u003e) {\u003cbr/\u003e    val exoPlayer = playerViewModel.playerState.collectAsStateWithLifecycle()\u003cp\u003e    Box(modifier.fillMaxSize()) {\u003cbr/\u003e        exoPlayer.value?.let {\u003cbr/\u003e            PlayerScreen(exoPlayer = it)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1bc1\"\u003eFor now, this function appears to be overkill, but as the project grows, more and more aspects like side effects and states will be part of it. This function will be effective in isolating these elements from the \u003ccode\u003ePlayerScreen\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"5e2c\"\u003eActivity level integration\u003c/h2\u003e\u003cp id=\"280a\"\u003eFinally, create PlayerActivity and integrate PlayerRoute inside the onCreate via the \u003ccode\u003e\u003cem\u003esetContent\u003c/em\u003e\u003c/code\u003e\u003cem\u003e \u003c/em\u003efunction\u003cem\u003e.\u003c/em\u003e Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6421\"\u003eclass PlayerActivity : ComponentActivity() {\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        enableEdgeToEdge()\u003cbr/\u003e        setContent {\u003cbr/\u003e            ExoPlayerLearningTheme {\u003cbr/\u003e                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -\u0026gt;\u003cbr/\u003e                    PlayerRoute(\u003cbr/\u003e                        modifier = Modifier.padding(innerPadding)\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b31d\"\u003eManaging Playback with ViewModel\u003c/h2\u003e\u003cp id=\"7fe5\"\u003eNow that we’ve completed building the compose UI and basic view model configuration, it’s time to build the EXO player and update UI via stateflow.\u003c/p\u003e\u003cp id=\"9e26\"\u003e\u003cstrong\u003eStep 1: \u003c/strong\u003eCreate a Media3 MediaItem with a sample URL as shown below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"20f8\"\u003eval mediaItem = MediaItem.Builder().setUri(Video_1).setMediaId(\u0026#34;Video_1\u0026#34;).build(),\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7e2b\"\u003e\u003cstrong\u003eStep 2:\u003c/strong\u003e Create the EXO player instance with this media item as shown below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8c12\"\u003eExoPlayer.Builder(context).build().apply {\u003cbr/\u003e    setMediaItem(mediaItem)\u003cbr/\u003e    prepare()\u003cbr/\u003e    playWhenReady = true\u003cbr/\u003e    play()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d30\"\u003e\u003cstrong\u003eStep 3:\u003c/strong\u003e Update the stateflow with the EXO Player created in step 2.\u003c/p\u003e\u003cp id=\"cd6b\"\u003eFinally, have a look at the function after putting things together:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bac6\"\u003efun createPlayerWithMediaItems(context: Context,) {\u003cbr/\u003e    if (_playerState.value == null) {\u003cbr/\u003e        // Create Media item\u003cbr/\u003e        val mediaItem = MediaItem.Builder().setUri(Video_1).setMediaId(\u0026#34;Video_1\u0026#34;).build(),\u003cp\u003e        // Create the player instance and update it to UI via stateFlow\u003cbr/\u003e        _playerState.update {\u003cbr/\u003e            ExoPlayer.Builder(context).build().apply {\u003cbr/\u003e                setMediaItem(mediaItem)\u003cbr/\u003e                prepare()\u003cbr/\u003e                playWhenReady = true\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"82ea\"\u003e\u003ccode\u003esetMediaItem\u003c/code\u003eSet the media source to the player.\u003c/li\u003e\u003cli id=\"162b\"\u003e\u003ccode\u003eprepare()\u003c/code\u003e will tell the player to prepare the media item to be played.\u003c/li\u003e\u003cli id=\"e43f\"\u003e\u003ccode\u003eplayWhenReady\u003c/code\u003e Will tell the player to start playing once the media item is ready.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"1c0f\"\u003eNow, let’s call this function from PlayerRoute via LaunchedEffect as shown below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"25cd\"\u003e@Composable\u003cbr/\u003efun PlayerRoute(\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    playerViewModel: PlayerViewModel = viewModel(),\u003cbr/\u003e) {\u003cbr/\u003e    val exoPlayer = playerViewModel.playerState.collectAsStateWithLifecycle()\u003cbr/\u003e    val context = LocalContext.current\u003cp\u003e    Box(modifier.fillMaxSize()) {\u003cbr/\u003e        exoPlayer.value?.let {\u003cbr/\u003e            PlayerScreen(exoPlayer = it)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    LaunchedEffect(Unit) {\u003cbr/\u003e        playerViewModel.createPlayerWithMediaItems(context)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ae16\"\u003eIf you run the application, you should be able to see a video playback, and it can survive configuration changes.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e32b\"\u003eImplementing a Playlist in ExoPlayer\u003c/h2\u003e\u003ch2 id=\"126c\"\u003eConfigure Playlist\u003c/h2\u003e\u003cp id=\"5968\"\u003eNow let’s get into the playlist, first step is to create the list of media items that we intend to play. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9f98\"\u003eval mediaItems = listOf(\u003cbr/\u003e    MediaItem.Builder().setUri(Video_1).setMediaId(\u0026#34;Video_1\u0026#34;).build(),\u003cbr/\u003e    MediaItem.Builder().setUri(Video_2).setMediaId(\u0026#34;Video_2\u0026#34;).build(),\u003cbr/\u003e    MediaItem.Builder().setUri(Video_3).setMediaId(\u0026#34;Video_3\u0026#34;).build(),\u003cbr/\u003e    MediaItem.Builder().setUri(Video_4).setMediaId(\u0026#34;Video_4\u0026#34;).build(),\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"02a1\"\u003eThen, instead of using \u003ccode\u003esetMediaItem\u003c/code\u003eWe’ll use \u003ccode\u003esetMediaItems\u003c/code\u003e and pass the list we created above.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1b30\"\u003eExoPlayer.Builder(context).build().apply {\u003cbr/\u003e    setMediaItems(mediaItems)\u003cbr/\u003e    prepare()\u003cbr/\u003e    playWhenReady = true\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3d48\"\u003eNow, if you run the application upon finishing the first video, the player moves to the next media item in the list.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7026\"\u003eDesign Player Controls to Manage Playback and Playlist\u003c/h2\u003e\u003cp id=\"c6c4\"\u003eNow that we’ve created the playlist, it’s time to develop controls that allow users to navigate between media items using the previous and next buttons. To enhance the user experience, let’s also include play/pause, rewind, and forward buttons.\u003c/p\u003e\u003cp id=\"139f\"\u003eLet’s begin by creating a simple enum class that represents the player action type and maps it to the viewmodel.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b22b\"\u003eenum class ActionType {\u003cbr/\u003e    PLAY, PAUSE, REWIND, FORWARD, PREVIOUS, NEXT\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"66be\"\u003eLet’s wrap this enum inside a data, along with \u003ccode\u003eAny\u003c/code\u003e type variable, so that we can associate data along with action type on click actions in the UI to communicate to the view model.\u003c/p\u003e\u003cp id=\"b75e\"\u003eLet’s wrap this enum inside a data class, along with a variable of type\u003ccode\u003eAny\u003c/code\u003e, so that we can associate data with the \u003ccode\u003eActionType\u003c/code\u003e when clicked on UI elements to communicate to the view model.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9d9c\"\u003edata class PlayerAction(\u003cbr/\u003e    val actionType: ActionType,\u003cbr/\u003e    val data: Any? =  null,\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"437d\"\u003eNow, let’s create a composable function VideoControls with two parameters: Exo Player and a lambda function for the click action. Here we’ll have two states representing the playback status and controls visibility.\u003c/p\u003e\u003cp id=\"dd3d\"\u003eNow, let’s create a composable function called \u003ccode\u003eVideoControls\u003c/code\u003e that takes two parameters: an Exo Player and a lambda function representing the click action. This function will have two states: one for the playback status and another for the visibility of the controls. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"300d\"\u003e@Composable\u003cbr/\u003efun VideoControls(\u003cbr/\u003e    player: ExoPlayer,\u003cbr/\u003e    playerActions: (PlayerAction) -\u0026gt; Unit,\u003cbr/\u003e) {\u003cbr/\u003e    var isPlaying by remember { mutableStateOf(player.isPlaying) }\u003cbr/\u003e    var controlsVisible by remember { mutableStateOf(true) }\u003cbr/\u003e|\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0666\"\u003eBefore going to the design part, let’s put these states to use:\u003c/p\u003e\u003ch2 id=\"c6f2\"\u003eUpdate states on necessary callbacks\u003c/h2\u003e\u003cp id=\"36b0\"\u003e\u003ccode\u003eisPlaying\u003c/code\u003e has to be updated whenever there is a change in the playback. For this, we’ll attach a local player listener to the player to get the playback updates. We’ll use DisposableEffect so that we can remove the listener when not required. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"03f9\"\u003eDisposableEffect(player) {\u003cbr/\u003e    val listener = object : Player.Listener {\u003cbr/\u003e        override fun onIsPlayingChanged(isPlayingNow: Boolean) {\u003cbr/\u003e            isPlaying = isPlayingNow\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    player.addListener(listener)\u003cp\u003e    onDispose {\u003cbr/\u003e        player.removeListener(listener)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"143b\"\u003eThen, we need to make the controllers visible. We’ll toggle their visibility for every touch interaction and ensure that the controllers are removed from the player after three seconds of interaction. In this case, we’ll use \u003ccode\u003eLaunchedEffect\u003c/code\u003e because we don’t need to dispose any resources. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b3d7\"\u003eLaunchedEffect(isPlaying, controlsVisible) {\u003cbr/\u003e    if (isPlaying \u0026amp;\u0026amp; controlsVisible) {\u003cbr/\u003e        delay(3000)\u003cbr/\u003e        controlsVisible = false\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8cdc\"\u003eLet’s design the Controls\u003c/h2\u003e\u003cp id=\"001c\"\u003eIt’s quite a straightforward implementation. At the core, we use the \u003ccode\u003eRow\u003c/code\u003e component to align the buttons. To represent each action, we use the \u003ccode\u003eIconButton\u003c/code\u003e component from compose. At the top level, we use the \u003ccode\u003eBox\u003c/code\u003e component to represent the \u003ccode\u003eRow\u003c/code\u003e of actions or an empty \u003ccode\u003eBox\u003c/code\u003e based on the \u003ccode\u003econtrolsVisible\u003c/code\u003e state. Have a look:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c927\"\u003ePlayer actions in the View model\u003c/h2\u003e\u003cp id=\"4b19\"\u003eLet’s create a function in the view model with a PlayerAction as a parameter. Then handle the action type as shown below:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9180\"\u003eThat’s all, now we just have to trigger the \u003ccode\u003eexecuteAction\u003c/code\u003e from the compose layer. The flow will execute based on the action type.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d685\"\u003ePlayback Improvements\u003c/h2\u003e\u003cp id=\"7de9\"\u003eIf you run the application, everything works fine. However, there are a couple of improvements we can make.\u003c/p\u003e\u003ch2 id=\"7562\"\u003eLifecycle-aware playback\u003c/h2\u003e\u003cp id=\"0e7b\"\u003eWhen the user clicks on the device’s home button and the app goes into the background, the video continues to play. This is because the \u003ccode\u003ePlayerSurface\u003c/code\u003e is not lifecycle-aware by default. We can fix this by executing play/pause actions on the player based on the lifecycle changes on the composable. We’ll use DisposableEffect for this purpose. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e313\"\u003eval lifecycleOwner = LocalLifecycleOwner.current\u003cp\u003eDisposableEffect(lifecycleOwner) {\u003cbr/\u003e    val observer = LifecycleEventObserver { _, event -\u0026gt;\u003cbr/\u003e        when (event) {\u003cbr/\u003e            Lifecycle.Event.ON_PAUSE -\u0026gt; playerViewModel.executeAction(PlayerAction(ActionType.PAUSE))\u003cbr/\u003e            Lifecycle.Event.ON_RESUME -\u0026gt; playerViewModel.executeAction(PlayerAction(ActionType.PLAY))\u003cbr/\u003e            else -\u0026gt; Unit\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    lifecycleOwner.lifecycle.addObserver(observer)\u003c/p\u003e\u003cp\u003e    onDispose {\u003cbr/\u003e        lifecycleOwner.lifecycle.removeObserver(observer)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c272\"\u003eThe above code inside \u003ccode\u003ePlayerRoute\u003c/code\u003e will make sure to play and pause based on the lifecycle owner events.\u003c/p\u003e\u003ch2 id=\"278b\"\u003eRemember the current playback position\u003c/h2\u003e\u003cp id=\"18ef\"\u003eWhen users switch between playlist items, the video starts from the beginning instead of where the user left off. Developers must manually handle this issue. To resolve this problem, developers can manually track the current position and save it in the view model. When the user returns to the video, they can use the saved position to seek to that time.\u003c/p\u003e\u003cp id=\"73a5\"\u003eLet’s start by creating a VideoItem data class with currentPosition as a \u003ccode\u003eLong\u003c/code\u003e variable.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"949b\"\u003edata class VideoItem(\u003cbr/\u003e    val currentPosition: Long = 0\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"26f0\"\u003eWe’ll have a hashmap in the view model to keep track of the positions. The key of the map is the video ID, and the value is \u003ccode\u003eVideoItem\u003c/code\u003e. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ff26\"\u003eprivate val hashMapVideoStates = mutableMapOf\u0026lt;String,VideoItem\u0026gt;()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4335\"\u003eThe following is the function to update the hashmap with the current position while playback is ongoing.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"787c\"\u003efun updateCurrentPosition(id: String, position: Long) {\u003cbr/\u003e    hashMapVideoStates[id] = hashMapVideoStates[id]?.copy(currentPosition = position)\u003cbr/\u003e        ?: VideoItem(currentPosition = position)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ee94\"\u003eFinally, we need to trigger the above function from the \u003ccode\u003ePlayerRoute\u003c/code\u003e function every second. We can do this as shown below via \u003ccode\u003eLaunchedEffect\u003c/code\u003e. Have a look:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9899\"\u003eLaunchedEffect(Unit) {\u003cp\u003e    while (true) {\u003cbr/\u003e        exoPlayer.value?.currentMediaItem?.mediaId?.let {\u003cbr/\u003e            playerViewModel.updateCurrentPosition(\u003cbr/\u003e                it, exoPlayer.value?.currentPosition ?: 0\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e        delay(1000)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cdd4\"\u003eNow, whenever the user triggers previous or next actions, we can fetch the current time from the hashMapVideoStates and apply the return value via \u003ccode\u003eseek\u003c/code\u003e function as shown below:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ffa9\"\u003eprivate fun ExoPlayer.playNext() {\u003cbr/\u003e    if (hasNextMediaItem()) {\u003cbr/\u003e        val nextIndex = currentMediaItemIndex + 1\u003cbr/\u003e        val mediaItemId = getMediaItemAt(nextIndex)\u003cbr/\u003e        val seekPosition = hashMapVideoStates[mediaItemId.mediaId]?.currentPosition ?: 0L\u003cbr/\u003e        seekTo(nextIndex, seekPosition)\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003eprivate fun ExoPlayer.playPrevious() {\u003cbr/\u003e    if (\u003cbr/\u003e        isCommandAvailable(Player.COMMAND_SEEK_TO_MEDIA_ITEM) \u0026amp;\u0026amp;\u003cbr/\u003e        hasPreviousMediaItem()\u003cbr/\u003e    ) {\u003cbr/\u003e        val previousIndex = currentMediaItemIndex - 1\u003cbr/\u003e        val mediaItemId = getMediaItemAt(previousIndex)\u003cbr/\u003e        val seekPosition = hashMapVideoStates[mediaItemId.mediaId]?.currentPosition ?: 0L\u003cbr/\u003e        seekTo(previousIndex, seekPosition)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0169\"\u003eEnd Note:\u003c/h2\u003e\u003cp id=\"20a1\"\u003eFollowing is a link to the sample project, if you need it. Make sure to check out \u003ccode\u003efeature/bascis_play_list\u003c/code\u003e For this article related code :\u003c/p\u003e\u003cp id=\"baa1\"\u003eIn this part of the series, we explored the origins of the Media3 EXO player, its creation and management within the view model, and integration into Jetpack Compose. Additionally, we learned how to create playlists and manage video playback controls. In the next part, I’ll focus on Player listeners, timeline view implementation, analytics, the cache mechanism, and more.\u003c/p\u003e\u003cp id=\"4eff\"\u003eThat is all for now. I hope you learned something useful. Thanks for reading!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-07-04T00:21:35.053Z",
  "modifiedTime": null
}
