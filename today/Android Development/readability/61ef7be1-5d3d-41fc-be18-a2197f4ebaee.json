{
  "id": "61ef7be1-5d3d-41fc-be18-a2197f4ebaee",
  "title": "Building Type Mode for Stories on iOS and Android",
  "link": "https://instagram-engineering.com/building-type-mode-for-stories-on-ios-and-android-8804e927feba?source=rss----37dc2a3034f2--android",
  "description": "",
  "author": "Instagram Engineering",
  "published": "Thu, 12 Apr 2018 17:39:36 GMT",
  "source": "https://instagram-engineering.com/feed/tagged/android",
  "categories": [
    "ui",
    "android",
    "ios",
    "ui-design"
  ],
  "byline": "Instagram Engineering",
  "length": 12192,
  "excerpt": "Instagram recently launched Type Mode, a new way to post creative, dynamic text styles and backgrounds to Stories. Type Mode was an interesting challenge for us because it is the first time we were…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Instagram recently launched Type Mode, a new way to post creative, dynamic text styles and backgrounds to Stories. Type Mode was an interesting challenge for us because it is the first time we were going to create a way for people to post Stories without photo or video components — and we wanted to make sure Type Mode was still a fun, customizable and visually expressive experience.Making Type Mode function seamlessly on both iOS and Android had its own set of challenges, including dynamically resizing text and custom background fills. In this post we’ll take a look at how we approached this work on both iOS and Android platforms.Dynamically Resizing Text InputWith Type Mode, we wanted to create a text input experience that let people emphasize certain words or phrases. One way to do that was to build fully justified text styles that dynamically resize each line to fill the available width (used in Modern, Neon, and Strong).iOSThe main challenge on iOS was to render dynamically resizing text in a native UITextView, which would let people enter text in a quick and familiar way.RESIZING PRE-TEXT STORAGE COMMITWhile you input text on a line, the size of text on that line should scale down until it hits some minimum font size.To accomplish this, we use a combination of UITextView.typingAttributes, NSAttributedString, and NSLayoutManager. First, we need to calculate what font size our text will be rendered as. We can grab the range of the line we are currently typing on using [NSLayoutManager enumerateLineFragmentsForGlyphRange:usingBlock:]. From that range we can create a sizing string to calculate a minimum font size.CGFloat pointSize = 24.0; // arbitraryNSAttributedString *attributedString = [[NSAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont fontWithName:fontName size:pointSize]}];CGFloat textWidth = CGRectGetWidth([attributedString boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) options:NULL context:nil]);CGFloat scaleFactor = (textViewContainerWidth / textWidth);CGFloat preferredFontSize = (pointSize * scaleFactor);return CLAMP_MIN_MAX(preferredFontSize, minimumFontSize, maximumFontSize) // Clamps value between min and maxIn order to actually draw the text at the correct size, we need to use our new font size in our UITextView's typingAttributes. UITextView.typingAttributes are attributes that apply to new text being typed by the user. A good place for this is [id\u003cUITextViewDelegate\u003e textView:shouldChangeTextInRange:replacementText:].- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text { NSMutableDictionary *typingAttributes = [textView.typingAttributes mutableCopy]; typingAttributes[NSFontAttributeName] = [UIFont fontWithDescriptor:fontDescriptor size:calculatedFontSize]; textView.typingAttributes = typingAttributes; return YES;}This means that as the user types, the font size will shrink until we hit some specified minimum. When this happens, the UITextView will wrap our text as it normally would.FINALIZE TEXT POST STORAGE COMMITAfter our text has been committed to text storage, we may need to clean up some sizing attributes. Our text could have wrapped, or the user could have “emphasized” text by manually adding a line break to write larger text on a separate line.A good place to put this logic is in [id\u003cUITextViewDelegate\u003e textViewDidChange:]. This happens after the text has been committed to text storage and initially laid out by the text engine. To get a list of character ranges for each line, we can use NSLayoutManager:NSMutableArray\u003cNSValue *\u003e *lineRanges = [NSMutableArray array];[textView.layoutManager enumerateLineFragmentsForGlyphRange:NSMakeRange(0, layoutManager.numberOfGlyphs) usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer * _Nonnull textContainer, NSRange glyphRange, BOOL * _Nonnull stop) { NSRange characterRange = [layoutManager characterRangeForGlyphRange:glyphRange actualGlyphRange:NULL]; [lineRanges addObject:[NSValue valueWithRange:characterRange]];}];We then need to manipulate the NSTextStorage by setting attributes on ranges that have the correct font size for each row. There are three stages to editing NSTextStorage, which is itself a subclass of NSMutableAttributedString.Call [textStorage beginEditing] to indicate we are making one or more changes to the text storage.Send some editing messages to NSTextStorage. In our case, the NSFontAttributeName attribute should be set with the correct font size for that row. We can use a similar method for calculating the font size as we did earlier.for (NSValue *lineRangeValue in lineRanges) { NSRange lineRange = lineRangeValue.rangeValue; const CGFloat fontSize = ... // Same font size calculation from earlier [textStorage setAttributes:@{NSFontAttributeName : [UIFont fontWithDescriptor:fontDescriptor size:fontSize]} range:lineRange];}3. Call [textStorage endEditing] to indicate we are done editing text storage. This invokes the [NSTextStorage processEditing] method which will fix attributes on the ranges we changed. This also invokes the correct NSTextStorageDelegate methods. TextKit is a powerful and modern API that is tightly integrated with UIKit. Many text experiences can be designed with it, and new text APIs are being released in most new iOS versions. With TextKit, you can do anything from creating custom text containers to modifying the actual generation of glyphs. And since it is built on top of CoreText and integrated with APIs like UITextView, text input and editing continues to feel like a native iOS experience.AndroidAndroid doesn’t support full width justification out of the box, but the framework APIs give us all the tools we need to implement it ourselves. The first step is to lay the text out at the minimum text size. We’ll scale things up later, but this will tell us how many lines we have and where the line breaks are:TextPaint textPaint = new TextPaint();textPaint.setTextSize(SIZE_MIN);Layout layout = new StaticLayout( text, textPaint, availableWidth, Layout.Alignment.ALIGN_CENTER, 1 /* spacingMult */, 0 /* spacingAdd */, true /*includePad */);int lineCount = layout.getLineCount();Next we need to go through the layout and resize each line individually. There’s no direct way to find the perfect text size for a particular line, but we can easily approximate it with a binary search for the largest text size that doesn’t force a line break:int lowSize = SIZE_MIN;int highSize = SIZE_MAX;int currentSize = lowSize + (int) Math.floor((highSize - lowSize) / 2f);while (low \u003c current) { if (hasLineBreak(text, currentSize)) { highSize = currentSize; } else { lowSize = currentSize; } currentSize = lowSize + (int) Math.floor((highSize - lowSize) / 2f);}Once we’ve found the right size for each line, we apply it as a span. Spans let us use different text sizes for each line instead of a single text size for the entire string:text.setSpan( new AbsoluteSizeSpan(textSize), layout.getLineStart(lineNumber), layout.getLineEnd(lineNumber), Spanned.SPAN_INCLUSIVE_EXCLUSIVE);Now each line of text fills the available width! We can repeat this process each time the text changes to get the dynamic resizing behavior we’re looking for.Custom BackgroundsWe also wanted Type Mode to let people emphasize words and phrases with text backgrounds (used in Typewriter and Strong).iOSAnother way we can leverage NSLayoutManager is for drawing custom background fills. NSAttributedString does have a NSBackgroundColorAttributeName, but it is not customizable nor extensible.For example, if we used NSBackgroundColorAttributeName, the background of the entire text view would be filled in. We could not exclude whitespace, have spaces between the lines, or draw the fill with a corner radius. Thankfully, NSLayoutManager lets us override drawing the background fill. We need to create a NSLayoutManager subclass and override drawBackgroundForGlyphRange:atPoint:@interface IGSomeCustomLayoutManager : NSLayoutManager@end @implementation IGSomeCustomLayoutManager- (void)drawBackgroundForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin { // Draw custom background fill [super drawBackgroundForGlyphRange:glyphsToShow atPoint:origin];} }];@endWith our drawBackgroundForGlyphRange:atPoint method, we can once again leverage [NSLayoutManager enumerateLineFragmentsForGlyphRange:usingBlock] to grab the glyph ranges of each line fragment. We can then use [NSLayoutManager boundingRectForGlyphRange:inTextContainer] to get the bounding rectangle of each line.- (void)drawBackgroundForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin { [self enumerateLineFragmentsForGlyphRange:NSMakeRange(0, self.numberOfGlyphs) usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer * _Nonnull textContainer, NSRange glyphRange, BOOL * _Nonnull stop) { CGRect lineBoundingRect = [self boundingRectForGlyphRange:glyphRange inTextContainer:textContainer]; CGRect adjustedLineRect = CGRectOffset(lineBoundingRect, origin.x + kSomePadding, origin.y + kSomePadding); UIBezierPath *fillColorPath = [UIBezierPath bezierPathWithRoundedRect:adjustedLineRect cornerRadius:kSomeCornerRadius]; [[UIColor redColor] setFill]; [fillColorPath fill]; }];}This allows us to draw a background fill around any arbitrary text with our own specified shapes and padding. NSLayoutManager can also be utilized to draw other text attributes like strikethroughs and underlines.AndroidAt first glance, it feels like this should be simple to implement on Android. We can add a span that modifies the text background color and be done:new CharacterStyle() { @Override public void updateDrawState(TextPaint textPaint) { textPaint.bgColor = color; }}That’s a good first attempt (and was the first thing we built), but it comes with a few limitations:The background tightly wraps the text and there’s no way to adjust the padding.The background is rectangular and there’s no way to adjust the corner radius.To address those issues, we tried using LineBackgroundSpan. We were already using it to render the rounded bubble background on Classic text, so it seemed like a natural fit for the new text styles as well. Unfortunately our new use case uncovered a subtle bug in the framework Layout class. If your text has multiple LineBackgroundSpan instances on different lines, then Layout will not iterate through them properly and some of them may never be rendered.Thankfully we can sidestep the framework bug by applying a single LineBackgroundSpan to the entire string and then delegating to individual background spans ourselves:class BackgroundCoordinator implements LineBackgroundSpan { @Override public void drawBackground( Canvas canvas, Paint paint, int left, int right, int top, int baseline, int bottom, CharSequence text, int start, int end, int currentLine) { Spanned spanned = (Spanned) text; for (BackgroundSpan span : spanned.getSpans(start, end, BackgroundSpan.class)) { span.draw(canvas, spanned); } }}class BackgroundSpan { public void draw(Canvas canvas, Spanned spanned) { // Custom background rendering... }}ConclusionInstagram has a very strong prototyping culture, and the design team’s Type Mode prototypes let us get a real feel for the user experience with each iteration along the way. For example, with the Neon style, we needed a way to take a single color from our palette and then generate an interior color and a glow color for the text. A designer on the project played around with some approaches in his prototype, and when he found one he liked we essentially just copied his logic on Android and iOS. This level of collaboration with the design team was a special part of this launch and made the development process really efficient. If you’re interested in working with us on Stories, check out our careers page for roles in Menlo Park, New York, and San Francisco. Christopher Wendel and Patrick Theisen are iOS and Android engineers at Instagram, respectively.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*B_eL2GjOQGhd_OxC3nEXKA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@InstagramEng?source=post_page-----8804e927feba--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*8x_1IP3b75o5u9M4LgFBig.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page-----8804e927feba--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"1f64\"\u003eInstagram recently launched \u003ca href=\"https://instagram-press.com/blog/2018/02/01/introducing-type-mode-in-stories/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eType Mode\u003c/a\u003e, a new way to post creative, dynamic text styles and backgrounds to Stories. Type Mode was an interesting challenge for us because it is the first time we were going to create a way for people to post Stories without photo or video components — and we wanted to make sure Type Mode was still a fun, customizable and visually expressive experience.\u003c/p\u003e\u003cp id=\"9b9b\"\u003eMaking Type Mode function seamlessly on both iOS and Android had its own set of challenges, including dynamically resizing text and custom background fills. In this post we’ll take a look at how we approached this work on both iOS and Android platforms.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"233f\"\u003eDynamically Resizing Text Input\u003c/h2\u003e\u003cp id=\"e8f7\"\u003eWith Type Mode, we wanted to create a text input experience that let people emphasize certain words or phrases. One way to do that was to build fully justified text styles that dynamically resize each line to fill the available width (used in Modern, Neon, and Strong).\u003c/p\u003e\u003cp id=\"cb6a\"\u003e\u003cstrong\u003eiOS\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"c73b\"\u003eThe main challenge on iOS was to render dynamically resizing text in a native \u003ccode\u003eUITextView,\u003c/code\u003e which would let people enter text in a quick and familiar way.\u003c/p\u003e\u003cp id=\"44d1\"\u003e\u003cstrong\u003eRESIZING PRE-TEXT STORAGE COMMIT\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7917\"\u003eWhile you input text on a line, the size of text on that line should scale down until it hits some minimum font size.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"2e11\"\u003e\u003cp\u003eTo accomplish this, we use a combination of \u003ccode\u003eUITextView.typingAttributes\u003c/code\u003e, \u003ccode\u003eNSAttributedString\u003c/code\u003e, and \u003ccode\u003eNSLayoutManager\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e First, we need to calculate what font size our text will be rendered as. We can grab the range of the line we are currently typing on using \u003ccode\u003e[NSLayoutManager enumerateLineFragmentsForGlyphRange:usingBlock:]\u003c/code\u003e. From that range we can create a sizing string to calculate a minimum font size.\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\u003cspan id=\"b765\"\u003eCGFloat pointSize = 24.0; // arbitrary\u003cbr/\u003eNSAttributedString *attributedString = [[NSAttributedString alloc] initWithString:string attributes:@{NSFontAttributeName:[UIFont fontWithName:fontName size:pointSize]}];\u003cbr/\u003eCGFloat textWidth = CGRectGetWidth([attributedString boundingRectWithSize:CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX) options:NULL context:nil]);\u003cbr/\u003eCGFloat scaleFactor = (textViewContainerWidth / textWidth);\u003cbr/\u003eCGFloat preferredFontSize = (pointSize * scaleFactor);\u003cbr/\u003ereturn CLAMP_MIN_MAX(preferredFontSize, minimumFontSize, maximumFontSize) // Clamps value between min and max\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"62f0\"\u003eIn order to actually draw the text at the correct size, we need to use our new font size in our \u003ccode\u003eUITextView\u003c/code\u003e\u0026#39;s \u003ccode\u003etypingAttributes\u003c/code\u003e. \u003ccode\u003eUITextView.typingAttributes\u003c/code\u003e are attributes that apply to new text being typed by the user. A good place for this is \u003ccode\u003e[id\u0026lt;UITextViewDelegate\u0026gt; textView:shouldChangeTextInRange:replacementText:]\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e064\"\u003e- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text {\u003cbr/\u003e    NSMutableDictionary *typingAttributes = [textView.typingAttributes mutableCopy];\u003cbr/\u003e    typingAttributes[NSFontAttributeName] = [UIFont fontWithDescriptor:fontDescriptor size:calculatedFontSize];\u003cbr/\u003e    textView.typingAttributes = typingAttributes;\u003cbr/\u003e    return YES;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3489\"\u003eThis means that as the user types, the font size will shrink until we hit some specified minimum. When this happens, the \u003ccode\u003eUITextView\u003c/code\u003e will wrap our text as it normally would.\u003c/p\u003e\u003cp id=\"9e23\"\u003e\u003cstrong\u003eFINALIZE TEXT POST STORAGE COMMIT\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3291\"\u003eAfter our text has been committed to text storage, we may need to clean up some sizing attributes. Our text could have wrapped, or the user could have “emphasized” text by manually adding a line break to write larger text on a separate line.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"43e4\"\u003e\u003cp\u003eA good place to put this logic is in \u003ccode\u003e[id\u0026lt;UITextViewDelegate\u0026gt; textViewDidChange:]\u003c/code\u003e. This happens after the text has been committed to text storage and initially laid out by the text engine. \u003c/p\u003e\u003cp\u003e To get a list of character ranges for each line, we can use \u003ccode\u003eNSLayoutManager\u003c/code\u003e:\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\u003cspan id=\"721a\"\u003eNSMutableArray\u0026lt;NSValue *\u0026gt; *lineRanges = [NSMutableArray array];\u003cbr/\u003e[textView.layoutManager enumerateLineFragmentsForGlyphRange:NSMakeRange(0, layoutManager.numberOfGlyphs) usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer * _Nonnull textContainer, NSRange glyphRange, BOOL * _Nonnull stop) {\u003cbr/\u003e    NSRange characterRange = [layoutManager characterRangeForGlyphRange:glyphRange actualGlyphRange:NULL];\u003cbr/\u003e    [lineRanges addObject:[NSValue valueWithRange:characterRange]];\u003cbr/\u003e}];\u003c/span\u003e\u003c/pre\u003e\u003cdiv id=\"5b07\"\u003e\u003cp\u003eWe then need to manipulate the \u003ccode\u003eNSTextStorage\u003c/code\u003e by setting attributes on ranges that have the correct font size for each row.\u003c/p\u003e\u003cp\u003e There are three stages to editing \u003ccode\u003eNSTextStorage\u003c/code\u003e, which is itself a subclass of \u003ccode\u003eNSMutableAttributedString\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e\u003col\u003e\u003cli id=\"37c5\"\u003eCall \u003ccode\u003e[textStorage beginEditing]\u003c/code\u003e to indicate we are making one or more changes to the text storage.\u003c/li\u003e\u003cli id=\"d203\"\u003eSend some editing messages to \u003ccode\u003eNSTextStorage\u003c/code\u003e. In our case, the \u003ccode\u003eNSFontAttributeName\u003c/code\u003e attribute should be set with the correct font size for that row. We can use a similar method for calculating the font size as we did earlier.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"e31e\"\u003efor (NSValue *lineRangeValue in lineRanges) {\u003cbr/\u003e    NSRange lineRange = lineRangeValue.rangeValue;\u003cbr/\u003e    const CGFloat fontSize = ... // Same font size calculation from earlier\u003cbr/\u003e    [textStorage setAttributes:@{NSFontAttributeName : [UIFont fontWithDescriptor:fontDescriptor size:fontSize]} range:lineRange];\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cdiv id=\"84d3\"\u003e\u003cp\u003e3. Call \u003ccode\u003e[textStorage endEditing]\u003c/code\u003e to indicate we are done editing text storage. This invokes the \u003ccode\u003e[NSTextStorage processEditing]\u003c/code\u003e method which will fix attributes on the ranges we changed. This also invokes the correct \u003ccode\u003eNSTextStorageDelegate\u003c/code\u003e methods.\u003c/p\u003e\u003cp\u003e TextKit is a powerful and modern API that is tightly integrated with UIKit. Many text experiences can be designed with it, and new text APIs are being released in most new iOS versions. With TextKit, you can do anything from creating custom text containers to modifying the actual generation of glyphs. And since it is built on top of CoreText and integrated with APIs like UITextView, text input and editing continues to feel like a native iOS experience.\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"423e\"\u003eAndroid\u003c/h2\u003e\u003cdiv id=\"64cc\"\u003e\u003cp\u003eAndroid doesn’t support full width justification out of the box, but the framework APIs give us all the tools we need to implement it ourselves.\u003c/p\u003e\u003cp\u003e The first step is to lay the text out at the minimum text size. We’ll scale things up later, but this will tell us how many lines we have and where the line breaks are:\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\u003cspan id=\"cb58\"\u003eTextPaint textPaint = new TextPaint();\u003cbr/\u003etextPaint.setTextSize(SIZE_MIN);\u003cbr/\u003eLayout layout =\u003cbr/\u003e    new StaticLayout(\u003cbr/\u003e        text,\u003cbr/\u003e        textPaint,\u003cbr/\u003e        availableWidth,\u003cbr/\u003e        Layout.Alignment.ALIGN_CENTER,\u003cbr/\u003e        1 /* spacingMult */,\u003cbr/\u003e        0 /* spacingAdd */,\u003cbr/\u003e        true /*includePad */);\u003cbr/\u003eint lineCount = layout.getLineCount();\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"36bc\"\u003eNext we need to go through the layout and resize each line individually. There’s no direct way to find the perfect text size for a particular line, but we can easily approximate it with a binary search for the largest text size that doesn’t force a line break:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"13d0\"\u003eint lowSize = SIZE_MIN;\u003cbr/\u003eint highSize = SIZE_MAX;\u003cbr/\u003eint currentSize = lowSize + (int) Math.floor((highSize - lowSize) / 2f);\u003cbr/\u003ewhile (low \u0026lt; current) {\u003cbr/\u003e  if (hasLineBreak(text, currentSize)) {\u003cbr/\u003e    highSize = currentSize;\u003cbr/\u003e  } else {\u003cbr/\u003e    lowSize = currentSize;\u003cbr/\u003e  }\u003cbr/\u003e  currentSize = lowSize + (int) Math.floor((highSize - lowSize) / 2f);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"792f\"\u003eOnce we’ve found the right size for each line, we apply it as a span. Spans let us use different text sizes for each line instead of a single text size for the entire string:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2d5e\"\u003etext.setSpan(\u003cbr/\u003e    new AbsoluteSizeSpan(textSize),\u003cbr/\u003e    layout.getLineStart(lineNumber),\u003cbr/\u003e    layout.getLineEnd(lineNumber),\u003cbr/\u003e    Spanned.SPAN_INCLUSIVE_EXCLUSIVE);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2cfd\"\u003eNow each line of text fills the available width! We can repeat this process each time the text changes to get the dynamic resizing behavior we’re looking for.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"d8cd\"\u003eCustom Backgrounds\u003c/h2\u003e\u003cp id=\"71a7\"\u003eWe also wanted Type Mode to let people emphasize words and phrases with text backgrounds (used in Typewriter and Strong).\u003c/p\u003e\u003ch2 id=\"5ac5\"\u003eiOS\u003c/h2\u003e\u003cp id=\"f891\"\u003eAnother way we can leverage \u003ccode\u003eNSLayoutManager\u003c/code\u003e is for drawing custom background fills. \u003ccode\u003eNSAttributedString\u003c/code\u003e does have a \u003ccode\u003eNSBackgroundColorAttributeName\u003c/code\u003e, but it is not customizable nor extensible.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"edb3\"\u003eFor example, if we used \u003ccode\u003eNSBackgroundColorAttributeName\u003c/code\u003e, the background of the entire text view would be filled in. We could not exclude whitespace, have spaces between the lines, or draw the fill with a corner radius. Thankfully, \u003ccode\u003eNSLayoutManager\u003c/code\u003e lets us override drawing the background fill. We need to create a \u003ccode\u003eNSLayoutManager\u003c/code\u003e subclass and override \u003ccode\u003edrawBackgroundForGlyphRange:atPoint:\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"342b\"\u003e@interface IGSomeCustomLayoutManager : NSLayoutManager\u003cbr/\u003e@end \u003c/span\u003e\u003cspan id=\"f644\"\u003e@implementation IGSomeCustomLayoutManager\u003c/span\u003e\u003cspan id=\"ba3b\"\u003e- (void)drawBackgroundForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin {\u003cbr/\u003e    // Draw custom background fill\u003c/span\u003e\u003cspan id=\"e88b\"\u003e    [super drawBackgroundForGlyphRange:glyphsToShow atPoint:origin];\u003cbr/\u003e}\u003cp\u003e    }];\u003cbr/\u003e@end\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d3a8\"\u003eWith our \u003ccode\u003edrawBackgroundForGlyphRange:atPoint\u003c/code\u003e method, we can once again leverage \u003ccode\u003e[NSLayoutManager enumerateLineFragmentsForGlyphRange:usingBlock]\u003c/code\u003e to grab the glyph ranges of each line fragment. We can then use \u003ccode\u003e[NSLayoutManager boundingRectForGlyphRange:inTextContainer]\u003c/code\u003e to get the bounding rectangle of each line.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"239f\"\u003e- (void)drawBackgroundForGlyphRange:(NSRange)glyphsToShow atPoint:(CGPoint)origin {\u003cbr/\u003e  [self enumerateLineFragmentsForGlyphRange:NSMakeRange(0, self.numberOfGlyphs) usingBlock:^(CGRect rect, CGRect usedRect, NSTextContainer * _Nonnull textContainer, NSRange glyphRange, BOOL * _Nonnull stop) {\u003cbr/\u003e       CGRect lineBoundingRect = [self boundingRectForGlyphRange:glyphRange inTextContainer:textContainer];\u003cbr/\u003e       CGRect adjustedLineRect = CGRectOffset(lineBoundingRect, origin.x + kSomePadding, origin.y + kSomePadding);\u003cbr/\u003e       UIBezierPath *fillColorPath = [UIBezierPath bezierPathWithRoundedRect:adjustedLineRect cornerRadius:kSomeCornerRadius];\u003cbr/\u003e       [[UIColor redColor] setFill];\u003cbr/\u003e       [fillColorPath fill];\u003cbr/\u003e  }];\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9d0d\"\u003eThis allows us to draw a background fill around any arbitrary text with our own specified shapes and padding. \u003ccode\u003eNSLayoutManager\u003c/code\u003e can also be utilized to draw other text attributes like strikethroughs and underlines.\u003c/p\u003e\u003cp id=\"94d6\"\u003e\u003cstrong\u003eAndroid\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"ba2f\"\u003eAt first glance, it feels like this should be simple to implement on Android. We can add a span that modifies the text background color and be done:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"81f3\"\u003enew CharacterStyle() {\u003cbr/\u003e  @Override\u003cbr/\u003e  public void updateDrawState(TextPaint textPaint) {\u003cbr/\u003e    textPaint.bgColor = color;\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"22e7\"\u003eThat’s a good first attempt (and was the first thing we built), but it comes with a few limitations:\u003c/p\u003e\u003col\u003e\u003cli id=\"a6fc\"\u003eThe background tightly wraps the text and there’s no way to adjust the padding.\u003c/li\u003e\u003cli id=\"364a\"\u003eThe background is rectangular and there’s no way to adjust the corner radius.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3295\"\u003eTo address those issues, we tried using \u003ccode\u003eLineBackgroundSpan\u003c/code\u003e. We were already using it to render the rounded bubble background on Classic text, so it seemed like a natural fit for the new text styles as well. Unfortunately our new use case uncovered a subtle bug in the framework \u003ccode\u003eLayout\u003c/code\u003e class. If your text has multiple \u003ccode\u003eLineBackgroundSpan\u003c/code\u003e instances on different lines, then \u003ccode\u003eLayout\u003c/code\u003e will not iterate through them properly and some of them may never be rendered.\u003c/p\u003e\u003cp id=\"efdd\"\u003eThankfully we can sidestep the framework bug by applying a single \u003ccode\u003eLineBackgroundSpan\u003c/code\u003e to the entire string and then delegating to individual background spans ourselves:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"64f7\"\u003eclass BackgroundCoordinator implements LineBackgroundSpan {\u003cbr/\u003e  @Override\u003cbr/\u003e  public void drawBackground(\u003cbr/\u003e      Canvas canvas,\u003cbr/\u003e      Paint paint,\u003cbr/\u003e      int left,\u003cbr/\u003e      int right,\u003cbr/\u003e      int top,\u003cbr/\u003e      int baseline,\u003cbr/\u003e      int bottom,\u003cbr/\u003e      CharSequence text,\u003cbr/\u003e      int start,\u003cbr/\u003e      int end,\u003cbr/\u003e      int currentLine) {\u003cbr/\u003e    Spanned spanned = (Spanned) text;\u003cbr/\u003e    for (BackgroundSpan span : spanned.getSpans(start, end, BackgroundSpan.class)) {\u003cbr/\u003e      span.draw(canvas, spanned);\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003cp\u003eclass BackgroundSpan {\u003cbr/\u003e  public void draw(Canvas canvas, Spanned spanned) {\u003cbr/\u003e    // Custom background rendering...\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"b176\"\u003eConclusion\u003c/h2\u003e\u003cdiv id=\"68cb\"\u003e\u003cp\u003eInstagram has a very strong prototyping culture, and the design team’s Type Mode prototypes let us get a real feel for the user experience with each iteration along the way. For example, with the Neon style, we needed a way to take a single color from our palette and then generate an interior color and a glow color for the text. A designer on the project played around with some approaches in his prototype, and when he found one he liked we essentially just copied his logic on Android and iOS. This level of collaboration with the design team was a special part of this launch and made the development process really efficient. \u003c/p\u003e\u003cp\u003e If you’re interested in working with us on Stories, check out our \u003ca href=\"https://m.facebook.com/careers/teams/instagram/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecareers page\u003c/a\u003e for roles in Menlo Park, New York, and San Francisco. \u003c/p\u003e\u003cp\u003e \u003cem\u003eChristopher Wendel and Patrick Theisen are iOS and Android engineers at Instagram, respectively.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2018-04-12T17:39:35.5Z",
  "modifiedTime": null
}
