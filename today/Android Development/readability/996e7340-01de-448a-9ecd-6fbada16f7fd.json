{
  "id": "996e7340-01de-448a-9ecd-6fbada16f7fd",
  "title": "Custom modifiers in Jetpack Compose",
  "link": "https://proandroiddev.com/custom-modifiers-in-jetpack-compose-a950e6f9eb72?source=rss----c72404660798---4",
  "description": "",
  "author": "Siddharth Gupta",
  "published": "Fri, 22 Nov 2024 04:11:37 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "tech",
    "jetpack-compose",
    "apps",
    "android",
    "development"
  ],
  "byline": "Siddharth Gupta",
  "length": 8265,
  "excerpt": "Modifiers in Jetpack Compose are a powerful tool for customising and enhancing UI components. They allow developers to modify the appearance, behaviour, and layout of composable functions without…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Modifiers in Jetpack Compose are a powerful tool for customising and enhancing UI components. They allow developers to modify the appearance, behaviour, and layout of composable functions without changing their core implementation.Key aspects of modifiers:Chainable: Modifiers can be chained together, allowing for multiple modifications to be applied sequentially.Reusable: Custom modifiers can be created and reused across different components, promoting code reusability.Extensible: Developers can create their own custom modifiers to add specific functionality.The Reusable and Extensible aspects is what make modifiers super powerful. Hence in this blog we’ll be looking at how to create custom modifiers.Three Wayscomposed { }@composable modifier factoryModifier.Node APIUsing composed() to Create Custom ModifiersThe composed() function is a convenient way to create custom modifiers in Jetpack Compose. It allows you to define a modifier that can contain composable content.Here’s a basic structure of using composed():fun Modifier.customModifier( // parameters) = composed { // Your custom modifier logic here // Can include other composables this.then( // Additional modifiers )}Key points about using composed():Composable context: Inside composed{}, you have access to the composable context, allowing you to use other @Composable functions.State observation: You can observe state and trigger recomposition when needed.Chaining: Use this.then() to chain additional modifiers.Example of a custom modifier using composed():This example creates a shimmer effect modifier that can be applied to any composable to add a shimmering animation.Using @Composable Modifier Factory to Create Custom ModifiersAnother approach to creating custom modifiers in Jetpack Compose is using @Composable modifier factories. This method allows you to create modifiers that can use other @Composable functions and observe state changes.Here’s the basic structure of a @Composable modifier factory:@Composablefun Modifier.customModifier( // parameters): Modifier { // Your custom modifier logic here return this.then( // Additional modifiers )}Key points about using @Composable modifier factories:Composable context: The function is marked with @Composable, giving you access to other composable functions and state.Return type: The function explicitly returns a Modifier.Flexibility: You can use remember, derivedStateOf, and other composable functions within the modifier.Example of a custom modifier using @Composable modifier factory:This example creates a pulsating scale effect modifier that can be applied to any composable to add a pulsating animation. The scale and duration of the pulse can be customised through parameters.This is an excellent article which explains the key differences b/w the 2 approaches. Here is the summary:1. Extractability: CMF is limited to use within the Composition scope, while composed() can be extracted and used more flexibly.2. CompositionLocal resolution: CMF resolves CompositionLocal values at the call site, while composed() resolves them at the usage site.3. State resolution: CMF resolves state only once at the call site, while composed() resolves state at the usage site for each Layout.4. Performance: CMF performs better than composed() due to avoiding the expensive materialize() call.The Recommended Way: New Modifier.Node APIAs we can see above, creating custom modifiers using composed { } makes more sense than using the CMF approach. Using CMF is ideal when you need inline modifiers or extract a modifier for using it in only one component. On the other hand, composed is useful when designing generic modifiers.But here’s the catch, the composed way has few performance issues and the new recommended way of creating custom modifiers is to use the Modifier.Node API.Compose 1.3 introduced the Modifier.Node API where the team has migrated all the pre-defined modifiers to this new API. I would highly recommend to watch this youtube video of Android Dev Summit which explains why this change has been done.So if you want the best of both worlds — performance, extractability, skippability, reusable modifiers, use Modifier.Node APIThere are three parts to implementing a custom modifier using Modifier.Node:A Modifier.Node implementation that holds the logic and state of your modifier.A ModifierNodeElement that creates and updates modifier node instances.An optional modifier factory as detailed above.ModifierNodeElement classes are stateless and new instances are allocated each recomposition, whereas Modifier.Node classes can be stateful and will survive across multiple recompositions, and can even be reused.Here is the very basic example of drawing a circle of specific color as shared in the official documentation.Let’s breakdown to our processModifier.Node:The first step is to create a class which implements the Modifier.Node along with DrawModifierNode. There are multiple factory nodes which compose provides out of the box. Here we want to draw something hence we are using the DrawModifierNode. If we wanted to do something with user inputs or gestures we might want to use PointerInputModifierNodeAvailable nodes to override (image taken from Android Documentation)ModifierNodeElement:A ModifierNodeElement is an immutable class that holds the data to create or update your custom modifier:// ModifierNodeElementprivate data class CircleElement(val color: Color) : ModifierNodeElement\u003cCircleNode\u003e() { override fun create() = CircleNode(color) override fun update(node: CircleNode) { node.color = color }}ModifierNodeElement implementations need to override the following methods:create: This is the function that instantiates your modifier node. This gets called to create the node when your modifier is first applied. Usually, this amounts to constructing the node and configuring it with the parameters that were passed in to the modifier factory.update: This function is called whenever this modifier is provided in the same spot this node already exists, but a property has changed. This is determined by the equals method of the class. The modifier node that was previously created is sent as a parameter to the update call. At this point, you should update the nodes' properties to correspond with the updated parameters. The ability for nodes to be reused this way is key to the performance gains that Modifier.Node brings; therefore, you must update the existing node rather than creating a new one in the update method. In our circle example, the color of the node is updated.Additionally, ModifierNodeElement implementations also need to implement equals and hashCode. update will only get called if an equals comparison with the previous element returns false.Modifier Factory:This is the public API surface of your modifier. Most implementations simply create the modifier element and add it to the modifier chain:// Modifier factoryfun Modifier.circle(color: Color) = this then CircleElement(color)SummaryIn this blog post, we’ve explored the power and flexibility of custom modifiers in Jetpack Compose. We’ve covered three main approaches to creating custom modifiers:Using the Composable Modifier Function (CMF)Using the composed { } functionUsing the new Modifier.Node API (recommended)We’ve learned that while CMF and composed { } methods have their uses, the Modifier.Node API is now the recommended approach for creating custom modifiers. This new API offers better performance, reusability, and extensibility.Key takeaways:The Modifier.Node API consists of three main parts: a Modifier.Node implementation, a ModifierNodeElement, and an optional modifier factory.There are various types of modifier nodes available for different purposes, such as DrawModifierNode, LayoutModifierNode, and PointerInputModifierNode.The ModifierNodeElement is responsible for creating and updating modifier node instances, which can be stateful and survive across recompositions.The modifier factory provides a clean, public API for using your custom modifier.By mastering custom modifiers, especially using the Modifier.Node API, you can create more efficient, reusable, and powerful UI components in your Jetpack Compose applications.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*Oe-DGannPg34NnFtp02TjA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@siddh.gupta99?source=post_page---byline--a950e6f9eb72--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Siddharth Gupta\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*6rI29yuZZDr-3XD0qlJ-RQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--a950e6f9eb72--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3a16\"\u003eModifiers in Jetpack Compose are a powerful tool for customising and enhancing UI components. They allow developers to modify the appearance, behaviour, and layout of composable functions without changing their core implementation.\u003c/p\u003e\u003ch2 id=\"a300\"\u003eKey aspects of modifiers:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"87fb\"\u003e\u003cstrong\u003eChainable:\u003c/strong\u003e Modifiers can be chained together, allowing for multiple modifications to be applied sequentially.\u003c/li\u003e\u003cli id=\"6e91\"\u003e\u003cstrong\u003eReusable:\u003c/strong\u003e Custom modifiers can be created and reused across different components, promoting code reusability.\u003c/li\u003e\u003cli id=\"93cf\"\u003e\u003cstrong\u003eExtensible:\u003c/strong\u003e Developers can create their own custom modifiers to add specific functionality.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2a7e\"\u003eThe Reusable and Extensible aspects is what make modifiers super powerful. Hence in this blog we’ll be looking at how to create custom modifiers.\u003c/p\u003e\u003ch2 id=\"ce89\"\u003eThree Ways\u003c/h2\u003e\u003col\u003e\u003cli id=\"d877\"\u003ecomposed { }\u003c/li\u003e\u003cli id=\"12ba\"\u003e@composable modifier factory\u003c/li\u003e\u003cli id=\"bde2\"\u003eModifier.Node API\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"9be4\"\u003eUsing composed() to Create Custom Modifiers\u003c/h2\u003e\u003cp id=\"a8b0\"\u003eThe composed() function is a convenient way to create custom modifiers in Jetpack Compose. It allows you to define a modifier that can contain composable content.\u003c/p\u003e\u003cp id=\"543f\"\u003eHere’s a basic structure of using composed():\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b025\"\u003efun Modifier.customModifier(\u003cbr/\u003e    // parameters\u003cbr/\u003e) = composed {\u003cbr/\u003e    // Your custom modifier logic here\u003cbr/\u003e    // Can include other composables\u003cbr/\u003e    this.then(\u003cbr/\u003e        // Additional modifiers\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c329\"\u003eKey points about using composed():\u003c/p\u003e\u003cul\u003e\u003cli id=\"310c\"\u003e\u003cstrong\u003eComposable context:\u003c/strong\u003e Inside composed{}, you have access to the composable context, allowing you to use other @Composable functions.\u003c/li\u003e\u003cli id=\"43a0\"\u003e\u003cstrong\u003eState observation:\u003c/strong\u003e You can observe state and trigger recomposition when needed.\u003c/li\u003e\u003cli id=\"0cf6\"\u003e\u003cstrong\u003eChaining:\u003c/strong\u003e Use this.then() to chain additional modifiers.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2976\"\u003eExample of a custom modifier using composed():\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"da7e\"\u003eThis example creates a shimmer effect modifier that can be applied to any composable to add a shimmering animation.\u003c/p\u003e\u003ch2 id=\"cc39\"\u003eUsing @Composable Modifier Factory to Create Custom Modifiers\u003c/h2\u003e\u003cp id=\"d774\"\u003eAnother approach to creating custom modifiers in Jetpack Compose is using @Composable modifier factories. This method allows you to create modifiers that can use other @Composable functions and observe state changes.\u003c/p\u003e\u003cp id=\"e025\"\u003eHere’s the basic structure of a @Composable modifier factory:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3292\"\u003e@Composable\u003cbr/\u003efun Modifier.customModifier(\u003cbr/\u003e    // parameters\u003cbr/\u003e): Modifier {\u003cbr/\u003e    // Your custom modifier logic here\u003cbr/\u003e    return this.then(\u003cbr/\u003e        // Additional modifiers\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9e31\"\u003eKey points about using @Composable modifier factories:\u003c/p\u003e\u003cul\u003e\u003cli id=\"859e\"\u003e\u003cstrong\u003eComposable context:\u003c/strong\u003e The function is marked with @Composable, giving you access to other composable functions and state.\u003c/li\u003e\u003cli id=\"7ff0\"\u003e\u003cstrong\u003eReturn type:\u003c/strong\u003e The function explicitly returns a Modifier.\u003c/li\u003e\u003cli id=\"4258\"\u003e\u003cstrong\u003eFlexibility:\u003c/strong\u003e You can use remember, derivedStateOf, and other composable functions within the modifier.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9c50\"\u003eExample of a custom modifier using @Composable modifier factory:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c41c\"\u003eThis example creates a pulsating scale effect modifier that can be applied to any composable to add a pulsating animation. The scale and duration of the pulse can be customised through parameters.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d86f\"\u003e\u003cem\u003eThis is an excellent \u003c/em\u003e\u003ca href=\"https://engineering.teknasyon.com/composable-modifier-vs-composed-factory-in-jetpack-compose-6cbb675b0e7b\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003earticle\u003c/em\u003e\u003c/a\u003e\u003cem\u003e which explains the key differences b/w the 2 approaches. Here is the summary:\u003c/em\u003e\u003c/p\u003e\u003cp id=\"989e\"\u003e\u003cem\u003e1. \u003c/em\u003e\u003cstrong\u003eExtractability\u003c/strong\u003e: CMF is limited to use within the Composition scope, while composed() can be extracted and used more flexibly.\u003c/p\u003e\u003cp id=\"6dd1\"\u003e2. \u003cstrong\u003eCompositionLocal resolution\u003c/strong\u003e: CMF resolves CompositionLocal values at the call site, while composed() resolves them at the usage site.\u003c/p\u003e\u003cp id=\"8e14\"\u003e3. \u003cstrong\u003eState resolution\u003c/strong\u003e: CMF resolves state only once at the call site, while composed() resolves state at the usage site for each Layout.\u003c/p\u003e\u003cp id=\"db31\"\u003e4. \u003cstrong\u003ePerformance\u003c/strong\u003e: CMF performs better than composed() due to avoiding the expensive materialize() call.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"cb56\"\u003eThe Recommended Way: New Modifier.Node API\u003c/h2\u003e\u003cp id=\"17c2\"\u003eAs we can see above, creating custom modifiers using \u003ccode\u003ecomposed { }\u003c/code\u003e makes more sense than using the \u003cstrong\u003eCMF\u003c/strong\u003e approach. Using \u003cstrong\u003eCMF\u003c/strong\u003e is ideal when you need inline modifiers or extract a modifier for using it in only one component. On the other hand, \u003cstrong\u003ecomposed\u003c/strong\u003e is useful when designing generic modifiers.\u003c/p\u003e\u003cp id=\"6a9e\"\u003eBut here’s the catch, the \u003cstrong\u003ecomposed\u003c/strong\u003e way has few performance issues and the new recommended way of creating custom modifiers is to use the Modifier.Node API.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"29d0\"\u003e\u003cstrong\u003e\u003cem\u003eCompose 1.3\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e introduced the \u003c/em\u003eModifier.Node\u003cem\u003e API where the team has migrated all the pre-defined modifiers to this new API. I would highly recommend to watch \u003c/em\u003e\u003ca href=\"https://www.youtube.com/watch?v=BjGX2RftXsU\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ethis\u003c/em\u003e\u003c/a\u003e\u003cem\u003e youtube video of Android Dev Summit which explains why this change has been done.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"1636\"\u003eSo if you want the best of both worlds — performance, extractability, skippability, reusable modifiers, use Modifier.Node API\u003c/p\u003e\u003cp id=\"261d\"\u003eThere are three parts to implementing a custom modifier using Modifier.Node:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0337\"\u003eA \u003ccode\u003eModifier.Node\u003c/code\u003e implementation that holds the logic and state of your modifier.\u003c/li\u003e\u003cli id=\"5309\"\u003eA \u003ccode\u003eModifierNodeElement\u003c/code\u003e that creates and updates modifier node instances.\u003c/li\u003e\u003cli id=\"c37c\"\u003eAn optional modifier factory as detailed above.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cecb\"\u003e\u003ccode\u003eModifierNodeElement\u003c/code\u003e classes are stateless and new instances are allocated each recomposition, whereas \u003ccode\u003eModifier.Node\u003c/code\u003e classes can be stateful and will survive across multiple recompositions, and can even be reused.\u003c/p\u003e\u003cp id=\"cc01\"\u003eHere is the very basic example of drawing a circle of specific color as shared in the official documentation.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"841d\"\u003eLet’s breakdown to our process\u003c/p\u003e\u003ch2 id=\"3a9a\"\u003e\u003cstrong\u003eModifier.Node:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"f295\"\u003eThe first step is to create a class which implements the \u003ccode\u003eModifier.Node\u003c/code\u003e along with \u003ccode\u003eDrawModifierNode\u003c/code\u003e. There are multiple factory nodes which compose provides out of the box. Here we want to draw something hence we are using the \u003ccode\u003eDrawModifierNode\u003c/code\u003e. If we wanted to do something with user inputs or gestures we might want to use \u003ccode\u003ePointerInputModifierNode\u003c/code\u003e\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAvailable nodes to override (image taken from Android Documentation)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"6582\"\u003eModifierNodeElement\u003cstrong\u003e:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"da4f\"\u003eA \u003ccode\u003eModifierNodeElement\u003c/code\u003e is an immutable class that holds the data to create or update your custom modifier:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fa41\"\u003e// ModifierNodeElement\u003cbr/\u003eprivate data class CircleElement(val color: Color) : ModifierNodeElement\u0026lt;CircleNode\u0026gt;() {\u003cbr/\u003e    override fun create() = CircleNode(color)\u003cp\u003e    override fun update(node: CircleNode) {\u003cbr/\u003e        node.color = color\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9d94\"\u003e\u003ccode\u003eModifierNodeElement\u003c/code\u003e implementations need to override the following methods:\u003c/p\u003e\u003col\u003e\u003cli id=\"7f0c\"\u003e\u003ccode\u003ecreate\u003c/code\u003e: This is the function that instantiates your modifier node. This gets called to create the node when your modifier is first applied. Usually, this amounts to constructing the node and configuring it with the parameters that were passed in to the modifier factory.\u003c/li\u003e\u003cli id=\"1c8f\"\u003e\u003ccode\u003eupdate\u003c/code\u003e: This function is called whenever this modifier is provided in the same spot this node already exists, but a property has changed. This is determined by the \u003ccode\u003eequals\u003c/code\u003e method of the class. The modifier node that was previously created is sent as a parameter to the \u003ccode\u003eupdate\u003c/code\u003e call. At this point, you should update the nodes\u0026#39; properties to correspond with the updated parameters. The ability for nodes to be reused this way is key to the performance gains that \u003ccode\u003eModifier.Node\u003c/code\u003e brings; therefore, you must update the existing node rather than creating a new one in the \u003ccode\u003eupdate\u003c/code\u003e method. In our circle example, the color of the node is updated.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"7474\"\u003eAdditionally, \u003ccode\u003eModifierNodeElement\u003c/code\u003e implementations also need to implement \u003ccode\u003eequals\u003c/code\u003e and \u003ccode\u003ehashCode\u003c/code\u003e. \u003ccode\u003eupdate\u003c/code\u003e will only get called if an equals comparison with the previous element returns false.\u003c/p\u003e\u003ch2 id=\"aa97\"\u003eModifier Factory:\u003c/h2\u003e\u003cp id=\"c1dc\"\u003eThis is the public API surface of your modifier. Most implementations simply create the modifier element and add it to the modifier chain:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c101\"\u003e// Modifier factory\u003cbr/\u003efun Modifier.circle(color: Color) = this then CircleElement(color)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bb1e\"\u003eSummary\u003c/h2\u003e\u003cp id=\"cb80\"\u003eIn this blog post, we’ve explored the power and flexibility of custom modifiers in Jetpack Compose. We’ve covered three main approaches to creating custom modifiers:\u003c/p\u003e\u003col\u003e\u003cli id=\"7cb4\"\u003eUsing the Composable Modifier Function (CMF)\u003c/li\u003e\u003cli id=\"9fb4\"\u003eUsing the composed { } function\u003c/li\u003e\u003cli id=\"d99e\"\u003eUsing the new Modifier.Node API (recommended)\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"c6ae\"\u003eWe’ve learned that while CMF and composed { } methods have their uses, the Modifier.Node API is now the recommended approach for creating custom modifiers. This new API offers better performance, reusability, and extensibility.\u003c/p\u003e\u003cp id=\"a8cb\"\u003eKey takeaways:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2a47\"\u003eThe \u003cem\u003eModifier.Node API\u003c/em\u003e consists of three main parts: a Modifier.Node implementation, a ModifierNodeElement, and an optional modifier factory.\u003c/li\u003e\u003cli id=\"17a8\"\u003eThere are various types of modifier nodes available for different purposes, such as DrawModifierNode, LayoutModifierNode, and PointerInputModifierNode.\u003c/li\u003e\u003cli id=\"ba7e\"\u003eThe ModifierNodeElement is responsible for creating and updating modifier node instances, which can be stateful and survive across recompositions.\u003c/li\u003e\u003cli id=\"b907\"\u003eThe modifier factory provides a clean, public API for using your custom modifier.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"52ba\"\u003eBy mastering custom modifiers, especially using the Modifier.Node API, you can create more efficient, reusable, and powerful UI components in your Jetpack Compose applications.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2024-11-22T04:11:37.52Z",
  "modifiedTime": null
}
