{
  "id": "e0e871ff-d047-493d-a7d2-30f166b56443",
  "title": "Designing a flick dismissible image viewer",
  "link": "https://saket.me/flick-dismissible-images/",
  "description": "While working on Dank, my primary goal was to ensure that user generated content on Reddit receive as much attention in the app as possible, while letting the UI take a back-seat. As part of this experience, all images and videos in Dank are flick-dismissible so that the user can browse through high quality cat […] The post Designing a flick dismissible image viewer appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Wed, 15 Aug 2018 11:37:46 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Open Source",
    "gestures",
    "library"
  ],
  "byline": "Saket Narayan",
  "length": 5474,
  "excerpt": "Flick is a tiny library for flick dismissing images (or anything actually). Here's a short explanation of how the gesture was written and the challenges involved.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "While working on Dank, my primary goal was to ensure that user generated content on Reddit receive as much attention in the app as possible, while letting the UI take a back-seat. As part of this experience, all images and videos in Dank are flick-dismissible so that the user can browse through high quality cat photos as fast as possible. Because flick dismissible images are not a new idea, I was hoping that some kind soul on the internet would have already solved this problem as a reusable library. I found a few, but they weren’t simple enough. So I decided to do what we developers naturally do — write my own implementation. The result was Flick, a tiny library for flick dismissing images (or anything actually). I’m putting it up on Github so that anyone can use it: https://github.com/saket/flick. \u003cme.saket.flick.FlickDismissLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"\u003e \u003cImageView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/\u003e \u003c/me.saket.flick.FlickDismissLayout\u003e Flick’s detailed usage instructions can be found on Github, but it’s easy to drop into existing projects. If you’re interested in learning how the gesture was written, you may continue reading. Let’s start with the basics. All touch events travel through the View hierarchy from top to bottom and back to top. That is, they start at the root layout and travel through the tree of Views until they’re consumed. If all leaves are reached without any consumers, the events travel back to the root. At any point during this travel, ViewGroups are allowed to “watch” these touch events as they travel to their child Views and intercept them if they want to. Flick uses this behaviour to “watch” scrolls. Vertical scrolls are intercepted, horizontal scrolls (on a ViewPager for instance) are allowed to pass. If a scroll is registered, all subsequent touch events until the next finger release are intercepted, blocking the content Views from receiving them. fun onInterceptTouchEvent(ev: MotionEvent): Boolean { val intercepted = flickGestureListener.onTouch(this, ev) return intercepted || super.onInterceptTouchEvent(ev) } For every movement registered, the content image is moved with the distance moved. override fun onTouch(view, event): Boolean { val touchX = event.rawX val touchY = event.rawY val deltaX = touchX - lastTouchX val deltaY = touchY - lastTouchY lastTouchX = touchX lastTouchY = touchY when (event.action) { ACTION_MOVE -\u003e { view.translationX += deltaX view.translationY += deltaY } } } To make the gesture feel more fluid — as if the user is actually flicking photos in the physical world, Flick rotates the image in the direction of the gesture. override fun onTouch(view, event): Boolean { when (event.action) { ACTION_DOWN -\u003e { touchStartedOnLeftSide = touchX \u003c view.width / 2 } ACTION_MOVE -\u003e { val moveRatioDelta = deltaY / view.height * (if (touchStartedOnLeftSide) -20F else 20F) view.pivotY = 0F view.rotation = view.rotation + moveRatioDelta } } } Rotation of images introduces an interesting problem — jagged and pixelated edges. When a Bitmap is scaled or rotated, Android’s renderer turns on Bilinear filtering, which works by sampling 4 pixels from the texture. When sampling the edges, there’s nothing to sample outside of the bitmap so they get rendered as jagged edges. A quick and dirty solution is to add 1px borders to the image. This causes Bilinear filtering to sample transparent pixels and average them with the actual texture, creating an illusion of anti-aliasing. Drawing the image directly on the canvas using drawRect() with a BitmapShader might produce a better result, but 1px borders are good enough for now. Picasso.get() .load(...) .transform(PaddingTransformation(px = 1F, color = Color.TRANSPARENT)) .into(imageView) Source: PaddingTransformation.kt. Thanks to Romain Guy for this tip. When the finger is released, Flick checks if the scroll distance was sufficient to dismiss the image. If it was sufficient, the image is animated out of the display or animated back into its original position otherwise. when (event.action) { ACTION_DOWN -\u003e { downY = event.rawY } ACTION_UP -\u003e { val distanceYAbs = Math.abs(event.rawY - downY) val thresholdDistanceY = contentHeight() * flickThreshold val eligibleForDismiss = distanceYAbs \u003e thresholdDistanceY if (eligibleForDismiss) { animateDismissal(view) } else { animateBackToPosition() } } } Registering discrete movements isn’t enough for making the gesture feel right. Apart from calculating the distance moved between touch-down and touch-up, the velocity of the scroll is also useful. If the distance doesn’t cross the threshold distance but the velocity was fast enough, it is treated as a fling. when (event.action) { ACTION_DOWN -\u003e { velocityTracker = VelocityTracker.obtain() } ACTION_UP -\u003e { velocityTracker.computeCurrentVelocity() if (velocityTracker.yVelocity \u003e requiredVelocity(...)) { // Fling'd! animateDismissal() } velocityTracker.recycle() } ACTION_MOVE -\u003e { velocityTracker.addMovement(event) } } As a final polish, Dank adds a subtle animation for making the entry transition look pleasing. This is not included in the library, but can easily be done using a Picasso/Glide target (example).",
  "image": "https://saket.me/wp-content/uploads/2018/08/Aliased-edges.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\n\u003cp\u003eWhile working on \u003ca href=\"https://saket.me/dank\"\u003eDank\u003c/a\u003e, my primary goal was to ensure that user generated content on Reddit receive as much attention in the app as possible, while letting the UI take a back-seat. As part of this experience, all images and videos in Dank are flick-dismissible so that the user can browse through high quality cat photos as fast as possible.\u003c/p\u003e\n\u003cp\u003eBecause flick dismissible images are not a new idea, I was hoping that some kind soul on the internet would have already solved this problem as a reusable library. I found a few, but they weren’t simple enough. So I decided to do what we developers naturally do — write my own implementation.\u003c/p\u003e\n\u003cp\u003eThe result was \u003cstrong\u003eFlick\u003c/strong\u003e, a tiny library for flick dismissing images (or anything actually). I’m putting it up on Github so that anyone can use it: \u003ca href=\"https://github.com/saket/flick\"\u003ehttps://github.com/saket/flick\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;me.saket.flick.FlickDismissLayout\n  android:layout_width=\u0026#34;match_parent\u0026#34;\n  android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt;\n\n  \u0026lt;ImageView\n    android:layout_width=\u0026#34;match_parent\u0026#34;\n    android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt;\n\u0026lt;/me.saket.flick.FlickDismissLayout\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFlick’s detailed usage instructions can be found on Github, but it’s easy to drop into existing projects. If you’re interested in learning how the gesture was written, you may continue reading.\u003c/p\u003e\n\u003cp\u003eLet’s start with the basics. All touch events travel through the View hierarchy from top to bottom and back to top. That is, they start at the root layout and travel through the tree of Views until they’re consumed. If all leaves are reached without any consumers, the events travel back to the root. At any point during this travel, ViewGroups are allowed to “watch” these touch events as they travel to their child Views and intercept them if they want to.\u003c/p\u003e\n\u003cp\u003eFlick uses this behaviour to “watch” scrolls. Vertical scrolls are intercepted, horizontal scrolls (on a \u003ccode\u003eViewPager\u003c/code\u003e for instance) are allowed to pass. If a scroll is registered, all subsequent touch events until the next finger release are intercepted, blocking the content Views from receiving them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efun onInterceptTouchEvent(ev: MotionEvent): Boolean {\n  val intercepted = flickGestureListener.onTouch(this, ev)\n  return intercepted || super.onInterceptTouchEvent(ev)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor every movement registered, the content image is moved with the distance moved.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eoverride fun onTouch(view, event): Boolean {\n  val touchX = event.rawX\n  val touchY = event.rawY\n\n  val deltaX = touchX - lastTouchX\n  val deltaY = touchY - lastTouchY\n\n  lastTouchX = touchX\n  lastTouchY = touchY\n\n  when (event.action) {\n    ACTION_MOVE -\u0026gt; {\n      view.translationX += deltaX\n      view.translationY += deltaY\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make the gesture feel more fluid — as if the user is actually flicking photos in the physical world, Flick rotates the image in the direction of the gesture.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eoverride fun onTouch(view, event): Boolean {\n  when (event.action) {\n    ACTION_DOWN -\u0026gt; {\n      touchStartedOnLeftSide = touchX \u0026lt; view.width / 2\n    }\n\n    ACTION_MOVE -\u0026gt; {\n      val moveRatioDelta = deltaY / view.height * (if (touchStartedOnLeftSide) -20F else 20F)\n      view.pivotY = 0F\n      view.rotation = view.rotation + moveRatioDelta\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRotation of images introduces an interesting problem — jagged and pixelated edges. When a Bitmap is scaled or rotated, Android’s renderer turns on Bilinear filtering, which works by sampling 4 pixels from the texture. When sampling the edges, there’s nothing to sample outside of the bitmap so they get rendered as jagged edges.\u003c/p\u003e\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg data-attachment-id=\"723\" data-permalink=\"https://saket.me/flick-dismissible-images/aliased-edges/\" data-orig-file=\"https://saket.me/wp-content/uploads/2018/08/Aliased-edges.jpg\" data-orig-size=\"1848,888\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"Aliased-edges\" data-image-description=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2018/08/Aliased-edges-300x144.jpg\" data-large-file=\"https://saket.me/wp-content/uploads/2018/08/Aliased-edges-1024x492.jpg\" decoding=\"async\" width=\"1848\" height=\"888\" src=\"https://saket.me/wp-content/uploads/2018/08/Aliased-edges.jpg\" alt=\"\" srcset=\"https://saket.me/wp-content/uploads/2018/08/Aliased-edges.jpg 1848w, https://saket.me/wp-content/uploads/2018/08/Aliased-edges-300x144.jpg 300w, https://saket.me/wp-content/uploads/2018/08/Aliased-edges-768x369.jpg 768w, https://saket.me/wp-content/uploads/2018/08/Aliased-edges-1024x492.jpg 1024w, https://saket.me/wp-content/uploads/2018/08/Aliased-edges-1200x577.jpg 1200w, https://saket.me/wp-content/uploads/2018/08/Aliased-edges-600x288.jpg 600w\" sizes=\"(max-width: 1848px) 100vw, 1848px\"/\u003e\u003c/figure\u003e\n\u003c/div\u003e\n\u003cp\u003eA quick and dirty solution is to add 1px borders to the image. This causes Bilinear filtering to sample transparent pixels and average them with the actual texture, creating an illusion of anti-aliasing. Drawing the image directly on the canvas using \u003ccode\u003edrawRect()\u003c/code\u003e with a \u003ca href=\"https://thecodebutchery.com/2015/04/02/using-bitmapshader-in-android/\" rel=\"nofollow\"\u003e\u003ccode\u003eBitmapShader\u003c/code\u003e\u003c/a\u003e might produce a better result, but 1px borders are good enough for now.\u003c/p\u003e\n\u003cdiv\u003e\n\u003cfigure\u003e\u003cimg data-attachment-id=\"724\" data-permalink=\"https://saket.me/flick-dismissible-images/anti-aliased/\" data-orig-file=\"https://saket.me/wp-content/uploads/2018/08/Anti-aliased.jpg\" data-orig-size=\"1848,888\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"Anti-aliased\" data-image-description=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2018/08/Anti-aliased-300x144.jpg\" data-large-file=\"https://saket.me/wp-content/uploads/2018/08/Anti-aliased-1024x492.jpg\" decoding=\"async\" loading=\"lazy\" width=\"1848\" height=\"888\" src=\"https://saket.me/wp-content/uploads/2018/08/Anti-aliased.jpg\" alt=\"\" srcset=\"https://saket.me/wp-content/uploads/2018/08/Anti-aliased.jpg 1848w, https://saket.me/wp-content/uploads/2018/08/Anti-aliased-300x144.jpg 300w, https://saket.me/wp-content/uploads/2018/08/Anti-aliased-768x369.jpg 768w, https://saket.me/wp-content/uploads/2018/08/Anti-aliased-1024x492.jpg 1024w, https://saket.me/wp-content/uploads/2018/08/Anti-aliased-1200x577.jpg 1200w, https://saket.me/wp-content/uploads/2018/08/Anti-aliased-600x288.jpg 600w\" sizes=\"(max-width: 1848px) 100vw, 1848px\"/\u003e\u003c/figure\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003ePicasso.get()\n    .load(...)\n    .transform(PaddingTransformation(px = 1F, color = Color.TRANSPARENT))\n    .into(imageView)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSource: \u003ca href=\"https://github.com/saket/Flick/blob/master/sample/src/main/java/me/saket/flick/sample/viewer/PicassoPaddingTransformation.kt\"\u003ePaddingTransformation.kt\u003c/a\u003e. Thanks to \u003ca href=\"https://twitter.com/romainguy\"\u003eRomain Guy \u003c/a\u003efor this tip.\u003c/p\u003e\n\u003cp\u003eWhen the finger is released, Flick checks if the scroll distance was sufficient to dismiss the image. If it was sufficient, the image is animated out of the display or animated back into its original position otherwise.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhen (event.action) {\n  ACTION_DOWN -\u0026gt; {\n    downY = event.rawY\n  }\n\n  ACTION_UP -\u0026gt; {\n    val distanceYAbs = Math.abs(event.rawY - downY)\n    val thresholdDistanceY = contentHeight() * flickThreshold\n    val eligibleForDismiss = distanceYAbs \u0026gt; thresholdDistanceY\n\n    if (eligibleForDismiss) {\n      animateDismissal(view)\n\n    } else {\n      animateBackToPosition()\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRegistering discrete movements isn’t enough for making the gesture feel right. Apart from calculating the distance moved between touch-down and touch-up, the velocity of the scroll is also useful. If the distance doesn’t cross the threshold distance but the velocity was fast enough, it is treated as a fling.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhen (event.action) {\n  ACTION_DOWN -\u0026gt; {\n    velocityTracker = VelocityTracker.obtain()\n  }\n\n  ACTION_UP -\u0026gt; {\n    velocityTracker.computeCurrentVelocity()\n    if (velocityTracker.yVelocity \u0026gt; requiredVelocity(...)) {\n      // Fling\u0026#39;d!\n      animateDismissal()\n    }\n\n    velocityTracker.recycle()\n  }\n\n  ACTION_MOVE -\u0026gt; {\n    velocityTracker.addMovement(event)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a final polish, Dank adds a subtle animation for making the entry transition look pleasing. This is not included in the library, but can easily be done using a Picasso/Glide target (\u003ca href=\"https://github.com/saket/Flick/blob/master/sample/src/main/java/me/saket/flick/sample/viewer/PicassoTargetWithEntryAnimation.kt\"\u003eexample\u003c/a\u003e).\u003c/p\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2018-08-15T11:37:46Z",
  "modifiedTime": "2021-01-10T06:56:25Z"
}
