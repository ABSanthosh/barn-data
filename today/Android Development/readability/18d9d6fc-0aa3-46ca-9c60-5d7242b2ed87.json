{
  "id": "18d9d6fc-0aa3-46ca-9c60-5d7242b2ed87",
  "title": "Maintaining crisp code with type aliases",
  "link": "https://okkotlin.com/typealias/",
  "description": "For us lot, who strive to clean up and make our code look pretty, Kotlin has a nifty little feature. It's called type aliasing, and we can…",
  "author": "",
  "published": "Sun, 24 Nov 2019 00:00:00 GMT",
  "source": "https://okkotlin.com/rss.xml",
  "categories": null,
  "byline": "",
  "length": 6901,
  "excerpt": "Type aliasing is that small but nifty feature that will help you keep your code readable. Let's see how.",
  "siteName": "",
  "favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABlmWCKAAAFGUlEQVR4Ae1Zb2wURRT/zc5eqxQM2BZIJQEKUk1D/BewBg0otIAiwcAXEb4ZP0hsAkbUiCQYY4wmajBGiZiYmPiBWEMNH6SUaIEoJhA0Go1FW62FRNuKkYtpe7szvtm73e7e7rW0t6Xc3Uyy2Tdv/r3fb9+8ebsL6KIZ0AxoBjQDmgHNgGZAM6AZ0AyUIgNsvKCH96+5Q1pyEw28T4LdxJiskRLTxzvPVPYv33Xcw21eqSHWm01bbNgvE/g6NUY6AyUIfEGXMQmQbzctTKXEx7a0GwoaaQ7jRyUgtb9xZcoSLfScK3OML3h1TgIUeGmLY+TiiYJHOQoAI6pNub20ZUuxg1fYIz1A7flidnv/Qw95gIr2BL4oA54fuCuHCFBHndtYCvcAASrJoQPeOedLAbzCGCBAZXilAtzFGQiC6fTWbZqCu0HmVNyYXjg1CAz+O+lGBAhQub2b5MaxMpt9M9jcW+laAja9GrK/C/LPTogLPwDJvtASrGoBEo+95+jtn9phf/5qqE/cigABmReb/NcorwB/oBn8ltXBuebf5dSlNQz71EGIc58G26egFowBMbzVscr5SGw/GAIvlUtnCjPLYK56EuYjr1AU4q56Su4BD8jbAmaAN+0Gm1HtTCX/uwT7i3cgfj8LDF0GZs0DX/oQjDu3gDEGY8FykjdDnDmU99ITnSDgAROdxB2ngBlz06eoTA4g9dETEJ1fpsGrTpd6YZ84ALvtdXcIeMN2YMZsrx4pELEoqxi5VD2mEt9MZBBfut4zy+54FyAPiCrixzaIP751mljiehhLVkZ1S+sIrLlhL8p2tDqXuf554JokgIBg5jzHaGmnIH45mRsUtYjODq+dVdV6crbAG5+GsfheRy1+OwPryD4abGV3m3A9Ng9g1Yucfa0skeTqEPaoRsm/e7x2VrXQk/0CX7UDvH6to1IeY322FyBy4yzxBUHLF+XLpo1to7/PUDLU36i9B4yOU1VE7/ewDu8h8MOhfvkqYvMAOdBD3weFYw+7YQ6QMT6Xgcpj3CL/Ou+K3t0FrxSy/1fAR7DXKQYhNgLU05H93Z5JfNmjnhwSKKLz2zZ6apUdRhWZ2Ub89k0wspOqqAET0MVHAC1uf/WhZ4Jz1i9a4dU9gYKlufYZsEzOL/q6IM6f8JpdQfR+B6tlNzwS1uxErljhjpnIPVYCZNfXED3nHDsYN5HYuA/8wRdg1K8DU0nP8q1IbDvgRXUFzskJIgKmvNwHSSTYpz5Iz5e4DubDdAKMsbXGS0J8QTCzsnXkJZjrnoVR2+BoeN39gLqyihxMwj7+FqL2v7+rOHsIoqaeSFsBNrOG5n4OVuuL/i55ybF6gGMJpbxW6x5YJ9+HTPaHjFNPXXR/Q1ni4+ksMdQjrLCOvgb5z0WnQZ0Oxt3bwp2uUMMAyslHCtVHytAbq+P/zzNtFticOnodroSk/S77KKJPwnE2gmIsiXWW72r3vnrFvgVCy1M6LLtPZ36lhVqvuoJBXvAvGv8W8M9+Dcrk4oEcveQIYCY77H8upUUAw89lze3pczrDQkkRwMHphSJYSoYABnba3Nn2SRB+jn+D2Z0KvU6f3wYSprE1CkfRewB9ekwxzjazp9pG3tR8TBQ1AerJM240JpqPdfgwB8SiJUDteXL7ZaOBV0xMfiYY4PsqVOioU9E+KuBFrV7QBND+TkrJLqr0VmV4KsnJPuejQGudZkAzoBnQDGgGNAOaAc2AZkAzoBn4H3WFe3QRC8LrAAAAAElFTkSuQmCC",
  "text": "For us lot, who strive to clean up and make our code look pretty, Kotlin has a nifty little feature. It's called type aliasing, and we can harness the functionality with the keyword typealias. This week, we will be seeing where and how type aliasing makes sense and how to start using type aliases in our Kotlin based projects right away. Type aliases, like a.k.a.? For those who are new to the concept of type aliases, here's a quick primer: A type alias is like another name for one of our existing types to make it look and resolve differently in our code. Take this as an example: To declare a list of users, we generally write List\u003cUser\u003e. What if, we want to make this declaration look more readable and natural like Users or UserList? Traditionally, we would declare a plain model class to mask the less attractive List\u003cUser\u003e to something like Users. Kind of like this: data class Users(val userList: List\u003cUser\u003e) With type aliases, we can have the same result with less burden and no extra classes. When I say less burden, what I'm trying to mean is that type aliases don't add a new type to our project. Therefore, there is no additional heap allocation, as there is no class initialisation. Also, type aliases have the exact behaviour of the underlying type. Whatever our original class can do, a type alias can as well. The aliasing process is straightforward For our list of users, we can declare a type alias as the one below: typealias Users = List\u003cUser\u003e This little declaration allows us to use our new Users type exactly like a list. Therefore, we can call list methods like add() on Users and even use cool Kotlin features like subscripts. Take a look at the following code snippet: typealias Users = MutableList\u003cUser\u003e val users: Users users.add(User(name = \"Rahul\")) println(users[0]) While this might not look much of an improvement apart from the initial fancy Users type, this is one of those little things which makes our code read like sentences. Apart from this, we can level up our type aliasing game to cases such as: Accommodating conflicting class names Another use case where type aliases shine out is while importing two or more classes with the same name but placed in different packages. You might have come across situations where some of your class names conflict with classes from a framework that you are using. For Android developers, a typical example is Android's View class. If we were to create our very own View class, we are at the complete liberty to do so, but with the tradeoff that we can't refer to both of them as View in a single class or file. We have to refer one of them with their fully qualified name, like this: fun compareViews(androidView: android.view.View, appView: View) For cases similar to this, we can use type aliases to mask the framework's classes with a different name, such as: typealias AndroidView = android.view.View Now, instead of relying on the fully qualified class names to differentiate our classes, we can have readable names like: fun compareViews(androidView: AndroidView, appView: View) Doesn't it look better now? A note of caution though Type aliases don't create new types. I repeat type aliases are just a different name, just like you might have two names, one formal and the other, your super-cool spy name. Why does knowing this matter? Because type aliases don't mean type safety, they are like caskets for your types but identical to one another. Consider this example, suppose we are building a maps function which accepts a latitude and longitude to display a map of the place: fun showMap(latitude: Double, longitude: Double) We can make this function more readable by adding type aliases to separate the latitude from the longitude. typealias Latitude = Double typealias Longitude = Double fun showMap(latitude: Latitude, longitude: Longitude) While this above snippet will compile and run just fine, we can still easily pass a Longitude object as latitude to the function, and the compiler won't budge. val latitude: Latitude = 12.7 val longitude: Longitude = 88.5 showMap(longitude, latitude) The reason behind this is although we aliased the Double type into \"apparently\" two new types, Kotlin didn't actually create the types Latitude and Longitude. It just let us use Double by the names Latitude or Longitude. Therefore, the type Latitude is precisely the same as the type Longitude. They're both Double underneath. If we open up the equivalent Java file of our Kotlin code, we will see that the none of our type aliases are present in the Java code. They were all replaced with their actual types when Kotlin compiled our code. Also, any extension function or property we add to our type aliases will reflect in all instances of the underlying type. For type safety, one way is to create model classes like this: data class Latitude(value: Double) Another way is to use Kotlin's inline classes. We will discuss more on this topic in a later article. Common places where we can type alias Masking lambdas in our callbacks: typealias Result\u003cT\u003e = (T) -\u003e Unit fun fetchData(callback: Result\u003cString\u003e) Marking nullable types: typealias MaybeBook = Book? Make nested classes look great: typealias DialogBuilder = AlertDialog.Builder val dialog = DialogBuilder().build() I like type aliases because... Although at first, they might seem to abstract away the actual types making it hard to know what's going on in the code, they are not that bad. If we ever want to find out what the real type is, we can ⌘/Ctrl + Click on the alias to get to the declaration point. Also, we can see the underlying type in the autocomplete section while referring to the type alias name. Over time, it's something we get used to and keeps our codebase comfortable to read through and understand for us and also our teammates. For me, one of the main things I use type aliases for is masking lambdas as I showed before. With auto-suggest to help, it's easy to glide through writing lambdas using type aliases in a few keystrokes. One more thing We can only add type aliases at the top level in our Kotlin file. Therefore, unlike Swift, we cannot declare a type alias inside a class or an interface. The following code won't compile and give us a compile-time error: class OkKotlin { typealias SuperInt = Int } However, this one will work just fine: typealias SuperInt = Int class OkKotlin { val superInt: SuperInt } This is the only major drawback when using type aliases as we have to declare them at the top-level instead of scoping out to classes. We are, however, free to scope module or file-level access by using the regular visibility modifiers like private and internal. Now that you have witnessed the magic of type aliasing, will you be refactoring your code with type aliases anytime soon? Here's a sketch note on the topic",
  "image": "https://okkotlin.com/images/typealiases-featured.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eFor us lot, who strive to clean up and make our code look pretty, Kotlin has a nifty little feature. It\u0026#39;s called type aliasing, and we can harness the functionality with the keyword \u003ccode\u003etypealias\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis week, we will be seeing where and how type aliasing makes sense and how to start using type aliases in our Kotlin based projects right away.\u003c/p\u003e\n\u003ch2 id=\"type-aliases-like-aka\"\u003eType aliases, like a.k.a.?\u003c/h2\u003e\n\u003cp\u003eFor those who are new to the concept of type aliases, here\u0026#39;s a quick primer: \u003c/p\u003e\n\u003cp\u003eA type alias is like another name for one of our existing types to make it look and resolve differently in our code.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/e50e7/typealias-aka.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Typealias or also known as\" title=\"Typealias or also known as\" src=\"https://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/dbb61/typealias-aka.png\" srcset=\"https://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/19bd1/typealias-aka.png 163w,\nhttps://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/d3bcb/typealias-aka.png 325w,\nhttps://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/dbb61/typealias-aka.png 650w,\nhttps://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/6b691/typealias-aka.png 975w,\nhttps://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/91670/typealias-aka.png 1300w,\nhttps://okkotlin.com/static/27b7253cdb1318c4978be153ae719d81/e50e7/typealias-aka.png 2750w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eTake this as an example:\u003c/p\u003e\n\u003cp\u003eTo declare a list of users, we generally write \u003ccode\u003eList\u0026lt;User\u0026gt;\u003c/code\u003e. What if, we want to make this declaration look more readable and natural like \u003ccode\u003eUsers\u003c/code\u003e or \u003ccode\u003eUserList\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eTraditionally, we would declare a plain model class to mask the less attractive \u003ccode\u003eList\u0026lt;User\u0026gt;\u003c/code\u003e to something like \u003ccode\u003eUsers\u003c/code\u003e. Kind of like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eUsers\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eval\u003c/span\u003e userList\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003eUser\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWith type aliases, we can have the same result with less burden and no extra classes. \u003c/p\u003e\n\u003cp\u003eWhen I say less burden, what I\u0026#39;m trying to mean is that type aliases don\u0026#39;t add a new type to our project. Therefore, there is no additional heap allocation, as there is no class initialisation.\u003c/p\u003e\n\u003cp\u003eAlso, type aliases have the exact behaviour of the underlying type. Whatever our original class can do, a type alias can as well.\u003c/p\u003e\n\u003ch2 id=\"the-aliasing-process-is-straightforward\"\u003eThe aliasing process is straightforward\u003c/h2\u003e\n\u003cp\u003eFor our list of users, we can declare a type alias as the one below:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e Users \u003cspan\u003e=\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003eUser\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis little declaration allows us to use our new \u003ccode\u003eUsers\u003c/code\u003e type exactly like a list. Therefore, we can call list methods like \u003ccode\u003eadd()\u003c/code\u003e on \u003ccode\u003eUsers\u003c/code\u003e and even use cool Kotlin features like subscripts.\u003c/p\u003e\n\u003cp\u003eTake a look at the following code snippet:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e Users \u003cspan\u003e=\u003c/span\u003e MutableList\u003cspan\u003e\u0026lt;\u003c/span\u003eUser\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \n\u003cspan\u003eval\u003c/span\u003e users\u003cspan\u003e:\u003c/span\u003e Users\nusers\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eUser\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ename \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Rahul\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eusers\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhile this might not look much of an improvement apart from the initial fancy \u003ccode\u003eUsers\u003c/code\u003e type, this is one of those little things which makes our code read like sentences.\u003c/p\u003e\n\u003cp\u003eApart from this, we can level up our type aliasing game to cases such as:\u003c/p\u003e\n\u003ch2 id=\"accommodating-conflicting-class-names\"\u003eAccommodating conflicting class names\u003c/h2\u003e\n\u003cp\u003eAnother use case where type aliases shine out is while importing two or more classes with the same name but placed in different packages.\u003c/p\u003e\n\u003cp\u003eYou might have come across situations where some of your class names conflict with classes from a framework that you are using.\u003c/p\u003e\n\u003cp\u003eFor Android developers, a typical example is Android\u0026#39;s \u003ccode\u003eView\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eIf we were to create our very own \u003ccode\u003eView\u003c/code\u003e class, we are at the complete liberty to do so, but with the tradeoff that we can\u0026#39;t refer to both of them as \u003ccode\u003eView\u003c/code\u003e in a single class or file.\u003c/p\u003e\n\u003cp\u003eWe have to refer one of them with their fully qualified name, like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecompareViews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eandroidView\u003cspan\u003e:\u003c/span\u003e android\u003cspan\u003e.\u003c/span\u003eview\u003cspan\u003e.\u003c/span\u003eView\u003cspan\u003e,\u003c/span\u003e appView\u003cspan\u003e:\u003c/span\u003e View\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor cases similar to this, we can use type aliases to mask the framework\u0026#39;s classes with a different name, such as:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e AndroidView \u003cspan\u003e=\u003c/span\u003e android\u003cspan\u003e.\u003c/span\u003eview\u003cspan\u003e.\u003c/span\u003eView\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow, instead of relying on the fully qualified class names to differentiate our classes, we can have readable names like:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecompareViews\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eandroidView\u003cspan\u003e:\u003c/span\u003e AndroidView\u003cspan\u003e,\u003c/span\u003e appView\u003cspan\u003e:\u003c/span\u003e View\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eDoesn\u0026#39;t it look better now?\u003c/p\u003e\n\u003ch2 id=\"a-note-of-caution-though\"\u003eA note of caution though\u003c/h2\u003e\n\u003cp\u003eType aliases don\u0026#39;t create new types. I repeat type aliases are just a different name, just like you might have two names, one formal and the other, your super-cool spy name.\u003c/p\u003e\n\u003cp\u003eWhy does knowing this matter?\u003c/p\u003e\n\u003cp\u003eBecause type aliases don\u0026#39;t mean type safety, they are like caskets for your types but identical to one another.\u003c/p\u003e\n\u003cp\u003eConsider this example, suppose we are building a maps function which accepts a latitude and longitude to display a map of the place:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eshowMap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe can make this function more readable by adding type aliases to separate the latitude from the longitude.\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e Latitude \u003cspan\u003e=\u003c/span\u003e Double\n\u003cspan\u003etypealias\u003c/span\u003e Longitude \u003cspan\u003e=\u003c/span\u003e Double\n    \n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eshowMap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elatitude\u003cspan\u003e:\u003c/span\u003e Latitude\u003cspan\u003e,\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Longitude\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhile this above snippet will compile and run just fine, we can still easily pass a \u003ccode\u003eLongitude\u003c/code\u003e object as latitude to the function, and the compiler won\u0026#39;t budge.\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e latitude\u003cspan\u003e:\u003c/span\u003e Latitude \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e12.7\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e longitude\u003cspan\u003e:\u003c/span\u003e Longitude \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e88.5\u003c/span\u003e\n    \n\u003cspan\u003eshowMap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003elongitude\u003cspan\u003e,\u003c/span\u003e latitude\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe reason behind this is although we aliased the \u003ccode\u003eDouble\u003c/code\u003e type into \u0026#34;apparently\u0026#34; two new types, Kotlin didn\u0026#39;t actually create the types \u003ccode\u003eLatitude\u003c/code\u003e and \u003ccode\u003eLongitude\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt just let us use \u003ccode\u003eDouble\u003c/code\u003e by the names \u003ccode\u003eLatitude\u003c/code\u003e or \u003ccode\u003eLongitude\u003c/code\u003e. Therefore, the type \u003ccode\u003eLatitude\u003c/code\u003e is precisely the same as the type \u003ccode\u003eLongitude\u003c/code\u003e. They\u0026#39;re both \u003ccode\u003eDouble\u003c/code\u003e underneath.\u003c/p\u003e\n\u003cp\u003eIf we open up the equivalent Java file of our Kotlin code, we will see that the none of our type aliases are present in the Java code. They were all replaced with their actual types when Kotlin compiled our code.\u003c/p\u003e\n\u003cp\u003eAlso, any extension function or property we add to our type aliases will reflect in all instances of the underlying type.\u003c/p\u003e\n\u003cp\u003eFor type safety, one way is to create model classes like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eLatitude\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003evalue\u003cspan\u003e:\u003c/span\u003e Double\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnother way is to use Kotlin\u0026#39;s \u003ca href=\"https://kotlinlang.org/docs/reference/inline-classes.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003einline classes\u003c/a\u003e. We will discuss more on this topic in a later article.\u003c/p\u003e\n\u003ch2 id=\"common-places-where-we-can-type-alias\"\u003eCommon places where we can type alias\u003c/h2\u003e\n\u003cp\u003eMasking lambdas in our callbacks:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e Result\u003cspan\u003e\u0026lt;\u003c/span\u003eT\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eT\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e Unit\n    \n\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003efetchData\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ecallback\u003cspan\u003e:\u003c/span\u003e Result\u003cspan\u003e\u0026lt;\u003c/span\u003eString\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eMarking nullable types:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e MaybeBook \u003cspan\u003e=\u003c/span\u003e Book\u003cspan\u003e?\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eMake nested classes look great:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e DialogBuilder \u003cspan\u003e=\u003c/span\u003e AlertDialog\u003cspan\u003e.\u003c/span\u003eBuilder\n    \n\u003cspan\u003eval\u003c/span\u003e dialog \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDialogBuilder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebuild\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"i-like-type-aliases-because\"\u003eI like type aliases because...\u003c/h2\u003e\n\u003cp\u003eAlthough at first, they might seem to abstract away the actual types making it hard to know what\u0026#39;s going on in the code, they are not that bad.\u003c/p\u003e\n\u003cp\u003eIf we ever want to find out what the real type is, we can \u003ckbd\u003e⌘\u003c/kbd\u003e/\u003ckbd\u003eCtrl\u003c/kbd\u003e + Click on the alias to get to the declaration point. Also, we can see the underlying type in the autocomplete section while referring to the type alias name.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/652a7/typealias-autocomplete.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Peek underlying type on auto-complete\" title=\"Peek underlying type on auto-complete\" src=\"https://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/dbb61/typealias-autocomplete.png\" srcset=\"https://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/19bd1/typealias-autocomplete.png 163w,\nhttps://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/d3bcb/typealias-autocomplete.png 325w,\nhttps://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/dbb61/typealias-autocomplete.png 650w,\nhttps://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/6b691/typealias-autocomplete.png 975w,\nhttps://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/91670/typealias-autocomplete.png 1300w,\nhttps://okkotlin.com/static/30186ecf5037d194edd3ad2bf3e1c2ed/652a7/typealias-autocomplete.png 2375w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eOver time, it\u0026#39;s something we get used to and keeps our codebase comfortable to read through and understand for us and also our teammates.\u003c/p\u003e\n\u003cp\u003eFor me, one of the main things I use type aliases for is masking lambdas as I showed before. With auto-suggest to help, it\u0026#39;s easy to glide through writing lambdas using type aliases in a few keystrokes.\u003c/p\u003e\n\u003ch2 id=\"one-more-thing\"\u003eOne more thing\u003c/h2\u003e\n\u003cp\u003eWe can only add type aliases at the top level in our Kotlin file. Therefore, unlike Swift, we cannot declare a type alias inside a class or an interface.\u003c/p\u003e\n\u003cp\u003eThe following code won\u0026#39;t compile and give us a compile-time error:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e OkKotlin \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003etypealias\u003c/span\u003e SuperInt \u003cspan\u003e=\u003c/span\u003e Int\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHowever, this one will work just fine:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etypealias\u003c/span\u003e SuperInt \u003cspan\u003e=\u003c/span\u003e Int\n    \n\u003cspan\u003eclass\u003c/span\u003e OkKotlin \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e superInt\u003cspan\u003e:\u003c/span\u003e SuperInt\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is the only major drawback when using type aliases as we have to declare them at the top-level instead of scoping out to classes. \u003c/p\u003e\n\u003cp\u003eWe are, however, free to scope module or file-level access by using the regular visibility modifiers like \u003ccode\u003eprivate\u003c/code\u003e and \u003ccode\u003einternal\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNow that you have witnessed the magic of type aliasing, will you be refactoring your code with type aliases anytime soon?\u003c/p\u003e\n\u003ch2 id=\"heres-a-sketch-note-on-the-topic\"\u003eHere\u0026#39;s a sketch note on the topic\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/d40c8/typealias-sketch-note.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Kotlin type alias sketch note\" title=\"Kotlin type alias sketch note\" src=\"https://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/dbb61/typealias-sketch-note.png\" srcset=\"https://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/19bd1/typealias-sketch-note.png 163w,\nhttps://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/d3bcb/typealias-sketch-note.png 325w,\nhttps://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/dbb61/typealias-sketch-note.png 650w,\nhttps://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/6b691/typealias-sketch-note.png 975w,\nhttps://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/91670/typealias-sketch-note.png 1300w,\nhttps://okkotlin.com/static/c41bd5fc56d54e9804f42a186353450d/d40c8/typealias-sketch-note.png 2000w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
