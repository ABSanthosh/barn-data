{
  "id": "db20647e-6244-494e-b792-6adeb9c86add",
  "title": "Introducing: Anvil-KSP",
  "link": "https://www.zacsweers.dev/introducing-anvil-ksp/",
  "description": "After more than a year of work and contributions from a number of developers in the community, I'm pleased to share a functionally-complete KSP implementation of Anvil code gen.",
  "author": "Zac Sweers",
  "published": "Fri, 09 Aug 2024 20:04:59 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Open Source",
    "Dagger",
    "KSP",
    "Anvil"
  ],
  "byline": "Zac Sweers",
  "length": 6342,
  "excerpt": "After more than a year of work and contributions from a number of developers in the community, I'm pleased to share a functionally-complete KSP implementation of Anvil code gen.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "09 Aug 2024 • 4 min read After more than a year of work and contributions from a number of developers in the community, I'm pleased to share a functionally-complete KSP implementation of Anvil code gen. GitHub - ZacSweers/anvil: A Kotlin compiler plugin to make dependency injection with Dagger 2 easier.A Kotlin compiler plugin to make dependency injection with Dagger 2 easier. - ZacSweers/anvilGitHubZacSweersUsage is easy and you can find instructions here: https://github.com/ZacSweers/anvil/blob/main/FORK.mdWhy a fork?Firstly, it's important to acknowledge the elephant in the room: it's a fork!Much of the phase 1 work for KSP was implemented in the upstream square/anvil, but contribution merging wasn't implemented yet. As the folks at Square are focused on the existing Anvil implementation for the time being and in the interest of finishing this work to make it available to folks that want it, I continued in this fork. This is not \"the\" Anvil KSP or Anvil K2 implementation, just \"an\" implementation.MotivationsAt the point of divergence (~2.0.0-beta09), square/anvil (\"upstream\") had some notable caveats:It only supports Kotlin 1.x.Its code gen is implemented in K1 compiler plugin APIs and its IR merging mechanism is no longer supported in K2.This means that Anvil users today must force Kotlin 1.9.Once Kotlin 2.1 is out, this will no longer be possible as Kotlin only supports n+1 forward compatibility.Heavily mixing K1 and K2 compilers in the same build causes higher pressure on JVM code cache that results in both performing slower.This is the primary motivation for making this fork's implementation available now, as 2.1 is only a few months away at the time of writing.It doesn't support Dagger-KSP.This means KAPT or Java annotation processing is always imposed somewhere in the build pipeline. Given the performance costs of KAPT, this isn't ideal. You can try to optimize this by extracting a separate Java-only project, but this is at the cost of yet another Gradle subproject.Dagger-KSP performance isn't there yet either, but it's clear that this is a long term focus for the Dagger team.It has a long history of issues with incremental compilationThis causes extensive build flakes and lost time due to needing to rebuild with --rerun-tasks.Exacerbated with the introduction of compilation avoidance introduced in later versions of Kotlin 1.xA lot of valuable work has gone in to attempting to patch this. But, even with the latest fixes in the latest betas, incremental compilation must still be disabled in the expensive KAPT stub generation task in order for IR merging to work correctly. And, to reiterate the above, these fixes are only useful for K1.KSP BenefitsA KSP implementation functionally addresses all of the above.KSP will natively support K2 via KSP2 (currently KSP2 is in beta).This Anvil-KSP implementation, aside from obviously running in KSP, changes generated merged component code in a source-compatible way that supports Dagger-KSP.If Dagger-KSP isn't performant enough yet, Anvil-KSP also allows for continuing to run dagger in KAPT/Java APT. This is what we are doing in Slack for now.KSP has native incremental processing support and none of the incremental compilation issues.I've tested this implementation with multiple different IC issue repro cases across my projects and the community and all of them work with KSP.KSP CostsAs with any solution, KSP isn't perfect.It is not and cannot be as fast as running as an embedded compiler plugin.KSP2, as mentioned above, is in beta.Dagger-KSP is in beta and has known performance issues with larger projects, more so when used in KSP2. This issue appears to be on the dagger-side rather than KSP itself though.This does require (only a couple!) source changes to work.I've tried to documented all the known rough edges here.Long TermI plan to maintain this for the foreseeable future, until Anvil either supports K2 or upstreams this implementation.StatsTL;DR At the time of writing, the optimal scenario is to use KSP contribution merging merging + KAPT for dagger-compiler in large project. dagger-ksp performance may be fine for your needs in a smaller project. You should measure!I've tested with three primary modesKAPT merging - KSP contribution gen, KAPT for everything else (IR contribution merging, dagger-compiler)Hybrid - KSP contribution gen and merging, KAPT for dagger-compilerKSP only - KSP for contribution gen, merging, and dagger-compilerIn the Slack app on Kotlin 1.9.25 + Dagger 2.52, I measured around a ~12% improvement switching from mode 1 (our starting baseline) to mode 2. Mode 3 was a non-starter as it appears that dagger-ksp struggles in larger projects and runs significantly slower (possibly some pathological case with a large number of modules).Slack Profiling NotesSurprisingly, Anvil's IR merging appears to have a statistically significant impact and is actually the biggest mover going from KAPT -\u003e KSP.Our project's \"app-di\" subproject is extremely thin, only has components and one module. Four classes.This means that stub generation doesn't really change much even when run non-incrementally, so it's not captured well in these benchmarks. In a larger module, I would expect this to be exacerbated.Both configurations 2 and 3 enable component merging in their build like so.anvil { useKsp( contributesAndFactoryGeneration = true, componentMerging = true, ) }Configurations examples for the rest are belowHybrid Mode// Connect KSP outputs to KAPT inputs afterEvaluate { // Example config for a \"release\" build variant in an android project val buildType = \"Release val kspTaskName = \"ksp${buildType}Kotlin\" val useKSP2 = providers.gradleProperty(\"ksp.useKSP2\").getOrElse(\"false\").toBoolean() val generatedKspKotlinFiles = if (useKSP2) { val kspReleaseTask = tasks.named\u003cKspAATask\u003e(kspTaskName) kspReleaseTask.flatMap { it.kspConfig.kotlinOutputDir } } else { val kspReleaseTask = tasks.named\u003cKspTaskJvm\u003e(kspTaskName) kspReleaseTask.flatMap { it.destination } } tasks.named\u003cKotlinCompile\u003e(\"kaptGenerateStubs${buildType}Kotlin${target}\").configure { source(generatedKspKotlinFiles) } } dependencies { kapt(libs.dagger.compiler) }KSP-only Modedependencies { ksp(libs.dagger.compiler) }",
  "image": "https://www.zacsweers.dev/content/images/2024/08/DALL-E-2024-08-04-20.21.24---Create-a-cartoon-style-image-of-a-large--heavy-anvil-with-the-letters--KSP--prominently-imprinted-on-its-side.-The-anvil-should-be-depicted-in-a-class.webp",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cspan\u003e09 Aug 2024\u003c/span\u003e\n    \u003ci\u003e•\u003c/i\u003e\n    \u003cspan\u003e4 min read\u003c/span\u003e\n  \u003c/p\u003e\n  \n    \u003cp\u003eAfter more than a year of work and contributions from a number of developers in the community, I\u0026#39;m pleased to share a functionally-complete KSP implementation of Anvil code gen.\u003c/p\u003e\n    \n    \u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/size/w1200/format/webp/2024/08/DALL-E-2024-08-04-20.21.24---Create-a-cartoon-style-image-of-a-large--heavy-anvil-with-the-letters--KSP--prominently-imprinted-on-its-side.-The-anvil-should-be-depicted-in-a-class.webp\" data-src=\"/content/images/size/w1200/format/webp/2024/08/DALL-E-2024-08-04-20.21.24---Create-a-cartoon-style-image-of-a-large--heavy-anvil-with-the-letters--KSP--prominently-imprinted-on-its-side.-The-anvil-should-be-depicted-in-a-class.webp\" alt=\"A cartoon Anvil with the letters \u0026#34;KSP\u0026#34; imprinted onto it.\"/\u003e\n\n    \u003c/p\u003e\n\u003c/div\u003e\u003cdiv\u003e\n    \u003cfigure\u003e\u003ca href=\"https://github.com/zacsweers/anvil?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003eGitHub - ZacSweers/anvil: A Kotlin compiler plugin to make dependency injection with Dagger 2 easier.\u003c/p\u003e\u003cp\u003eA Kotlin compiler plugin to make dependency injection with Dagger 2 easier. - ZacSweers/anvil\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://github.githubassets.com/assets/pinned-octocat-093da3e6fa40.svg\" alt=\"\"/\u003e\u003cspan\u003eGitHub\u003c/span\u003e\u003cspan\u003eZacSweers\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://opengraph.githubassets.com/a3cc89cb4b4431fe3eb575b8bfbdcbf5d05321e120981484172e2cf23394f07e/ZacSweers/anvil\" alt=\"\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cp\u003eUsage is easy and you can find instructions here: \u003ca href=\"https://github.com/ZacSweers/anvil/blob/main/FORK.md?ref=zacsweers.dev\"\u003ehttps://github.com/ZacSweers/anvil/blob/main/FORK.md\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"why-a-fork\"\u003eWhy a fork?\u003c/h2\u003e\u003cp\u003eFirstly, it\u0026#39;s important to acknowledge the elephant in the room: it\u0026#39;s a fork!\u003c/p\u003e\u003cp\u003eMuch of the phase 1 work for KSP was implemented in the upstream square/anvil, but contribution merging wasn\u0026#39;t implemented yet. As the folks at Square are focused on the existing Anvil implementation for the time being and in the interest of finishing this work to make it available to folks that want it, I continued in this fork. This is not \u0026#34;the\u0026#34; Anvil KSP or Anvil K2 implementation, just \u0026#34;an\u0026#34; implementation.\u003c/p\u003e\u003ch2 id=\"motivations\"\u003eMotivations\u003c/h2\u003e\u003cp\u003eAt the point of divergence (~2.0.0-beta09), square/anvil (\u0026#34;upstream\u0026#34;) had some notable caveats:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eIt only supports Kotlin 1.x.\u003c/strong\u003e\u003cul\u003e\u003cli\u003eIts code gen is implemented in K1 compiler plugin APIs and its IR merging mechanism is no longer supported in K2.\u003c/li\u003e\u003cli\u003eThis means that Anvil users today must force Kotlin 1.9.\u003c/li\u003e\u003cli\u003eOnce Kotlin 2.1 is out, this will no longer be possible as Kotlin only supports n+1 forward compatibility.\u003c/li\u003e\u003cli\u003eHeavily mixing K1 and K2 compilers in the same build causes higher pressure on JVM code cache that results in both performing slower.\u003c/li\u003e\u003cli\u003eThis is the primary motivation for making this fork\u0026#39;s implementation available now, as 2.1 is only a few months away at the time of writing.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eIt doesn\u0026#39;t support Dagger-KSP.\u003c/strong\u003e\u003cul\u003e\u003cli\u003eThis means KAPT or Java annotation processing is always imposed \u003cem\u003esomewhere\u003c/em\u003e in the build pipeline. Given the performance costs of KAPT, this isn\u0026#39;t ideal. You can try to optimize this by extracting a separate Java-only project, but this is at the cost of yet another Gradle subproject.\u003c/li\u003e\u003cli\u003eDagger-KSP performance isn\u0026#39;t there yet either, but it\u0026#39;s clear that this is a long term focus for the Dagger team.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eIt has a long history of issues with incremental compilation\u003c/strong\u003e\u003cul\u003e\u003cli\u003eThis causes extensive build flakes and lost time due to needing to rebuild with \u003ccode\u003e--rerun-tasks\u003c/code\u003e.\u003c/li\u003e\u003cli\u003eExacerbated with the introduction of compilation avoidance introduced in later versions of Kotlin 1.x\u003c/li\u003e\u003cli\u003eA \u003cstrong\u003elot\u003c/strong\u003e of valuable work has gone in to attempting to patch this. But, even with the latest fixes in the latest betas, incremental compilation must still be disabled in the expensive KAPT stub generation task in order for IR merging to work correctly. And, to reiterate the above, these fixes are only useful for K1.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ksp-benefits\"\u003eKSP Benefits\u003c/h2\u003e\u003cp\u003eA KSP implementation functionally addresses all of the above.\u003c/p\u003e\u003cul\u003e\u003cli\u003eKSP will natively support K2 via KSP2 (\u003cem\u003ecurrently KSP2 is in beta\u003c/em\u003e).\u003c/li\u003e\u003cli\u003eThis Anvil-KSP implementation, aside from obviously running in KSP, changes generated merged component code in a source-compatible way that supports Dagger-KSP.\u003cul\u003e\u003cli\u003eIf Dagger-KSP isn\u0026#39;t performant enough yet, Anvil-KSP also allows for continuing to run dagger in KAPT/Java APT. This is what we are doing in Slack for now.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eKSP has native incremental processing support and none of the incremental compilation issues.\u003cul\u003e\u003cli\u003eI\u0026#39;ve tested this implementation with multiple different IC issue repro cases across my projects and the community and all of them work with KSP.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"ksp-costs\"\u003eKSP Costs\u003c/h2\u003e\u003cp\u003eAs with any solution, KSP isn\u0026#39;t perfect.\u003c/p\u003e\u003cul\u003e\u003cli\u003eIt is not and cannot be as fast as running as an embedded compiler plugin.\u003c/li\u003e\u003cli\u003eKSP2, as mentioned above, is in beta.\u003c/li\u003e\u003cli\u003eDagger-KSP is in beta and has known performance issues with larger projects, more so when used in KSP2. This issue appears to be on the dagger-side rather than KSP itself though.\u003c/li\u003e\u003cli\u003eThis does require (only a couple!) source changes to work.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI\u0026#39;ve tried to documented all the known rough edges \u003ca href=\"https://github.com/ZacSweers/anvil/issues/16?ref=zacsweers.dev\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"long-term\"\u003eLong Term\u003c/h2\u003e\u003cp\u003eI plan to maintain this for the foreseeable future, until Anvil either supports K2 or upstreams this implementation.\u003c/p\u003e\u003ch2 id=\"stats\"\u003eStats\u003c/h2\u003e\u003cblockquote\u003eTL;DR At the time of writing, the optimal scenario is to use \u003cstrong\u003eKSP contribution merging merging + KAPT for dagger-compiler in large project\u003c/strong\u003e. dagger-ksp performance may be fine for your needs in a smaller project. You should measure!\u003c/blockquote\u003e\u003cp\u003eI\u0026#39;ve tested with three primary modes\u003c/p\u003e\u003col\u003e\u003cli\u003eKAPT merging - KSP contribution gen, KAPT for everything else (IR contribution merging, dagger-compiler)\u003c/li\u003e\u003cli\u003eHybrid - KSP contribution gen and merging, KAPT for dagger-compiler\u003c/li\u003e\u003cli\u003eKSP only - KSP for contribution gen, merging, and dagger-compiler\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eIn the Slack app on Kotlin 1.9.25 + Dagger 2.52, I measured around a ~12% improvement switching from mode 1 (our starting baseline) to mode 2. Mode 3 was a non-starter as it appears that dagger-ksp struggles in larger projects and runs significantly slower (possibly some pathological case with a large number of modules).\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/08/image-1.png\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"794\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/08/image-1.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2024/08/image-1.png 1000w, https://www.zacsweers.dev/content/images/size/w1600/2024/08/image-1.png 1600w, https://www.zacsweers.dev/content/images/2024/08/image-1.png 2000w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eSlack Profiling Notes\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eSurprisingly, Anvil\u0026#39;s IR merging appears to have a statistically significant impact and is actually the biggest mover going from KAPT -\u0026gt; KSP.\u003c/li\u003e\u003cli\u003eOur project\u0026#39;s \u0026#34;app-di\u0026#34; subproject is extremely thin, only has components and one module. Four classes.\u003cul\u003e\u003cli\u003eThis means that stub generation doesn\u0026#39;t really change much even when run non-incrementally, so it\u0026#39;s not captured well in these benchmarks. In a larger module, I would expect this to be exacerbated.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBoth configurations 2 and 3 enable component merging in their build like so.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eanvil {\n  useKsp(\n    contributesAndFactoryGeneration = true,\n    componentMerging = true,\n  )\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eConfigurations examples for the rest are below\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHybrid Mode\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Connect KSP outputs to KAPT inputs\nafterEvaluate {\n  // Example config for a \u0026#34;release\u0026#34; build variant in an android project\n  val buildType = \u0026#34;Release\n  val kspTaskName = \u0026#34;ksp${buildType}Kotlin\u0026#34;\n  val useKSP2 = providers.gradleProperty(\u0026#34;ksp.useKSP2\u0026#34;).getOrElse(\u0026#34;false\u0026#34;).toBoolean()\n  val generatedKspKotlinFiles =\n    if (useKSP2) {\n      val kspReleaseTask = tasks.named\u0026lt;KspAATask\u0026gt;(kspTaskName)\n      kspReleaseTask.flatMap { it.kspConfig.kotlinOutputDir }\n    } else {\n      val kspReleaseTask = tasks.named\u0026lt;KspTaskJvm\u0026gt;(kspTaskName)\n      kspReleaseTask.flatMap { it.destination }\n    }\n  tasks.named\u0026lt;KotlinCompile\u0026gt;(\u0026#34;kaptGenerateStubs${buildType}Kotlin${target}\u0026#34;).configure {\n    source(generatedKspKotlinFiles)\n  }\n}\n\ndependencies {\n  kapt(libs.dagger.compiler)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eKSP-only Mode\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edependencies {\n  ksp(libs.dagger.compiler)\n}\u003c/code\u003e\u003c/pre\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-08-09T20:04:59Z",
  "modifiedTime": "2024-08-09T20:53:48Z"
}
