{
  "id": "34e14fb6-616d-4fac-b342-e1c7670aad30",
  "title": "Disposables Can Cause Memory Leaks",
  "link": "https://www.zacsweers.dev/disposables-can-cause-memory-leaks/",
  "description": "Every Disposable holds a strong reference to the observer it binds. This can lead to surprising memory leaks.",
  "author": "Zac Sweers",
  "published": "Wed, 03 Feb 2021 04:13:49 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "RxJava"
  ],
  "byline": "Zac Sweers",
  "length": 6719,
  "excerpt": "Every Disposable holds a strong reference to the observer it binds. This can lead to surprising memory leaks.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "02 Feb 2021 ‚Ä¢ 3 min read Every Disposable holds a strong reference to the observer it binds. This can lead to surprising memory leaks. Consider the following example:class TacoViewModel : ViewModel() { var compositeDisposable = CompositeDisposable() fun loadTaco(activity: Activity) { compositeDisposable.add( Single.just(Taco()) .subscribe { taco -\u003e // Handle taco... println(\"Taco created in $activity\") } ) } override fun onCleared() { compositeDisposable.clear() } }Simple, right? This is a classic pattern for avoiding memory leaks in RxJava code: keep the returned Disposable and dispose/clear it in the \"end\" event of whatever scope you're in. This is great if you want to prevent memory leaks if your TacoViewModel lifecycle ends before the Single terminates.However, this actually leaks activities anyway because even though they're disposed, we keep Disposable instances around until onCleared() is called.Congratulations, you now have a good old-fashioned Android Activity memory leak. Drop this into your app, load some tacos, rotate, and watch LeakCanary start to chirp üê§. ‚î¨‚îÄ‚îÄ‚îÄ ‚îÇ GC Root: System class ‚îÇ /// ... ‚îÇ ‚îú‚îÄ autodispose2.sample.TacoViewModel instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 289.4 kB in 7953 objects ‚îÇ ‚Üì TacoViewModel.compositeDisposable ‚îÇ ~~~~~~~~~~~~~~~~~~~ ‚îú‚îÄ io.reactivex.rxjava3.disposables.CompositeDisposable instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 289.3 kB in 7949 objects ‚îÇ ‚Üì CompositeDisposable.resources ‚îÇ ~~~~~~~~~ ‚îú‚îÄ io.reactivex.rxjava3.internal.util.OpenHashSet instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 289.3 kB in 7948 objects ‚îÇ ‚Üì OpenHashSet.keys ‚îÇ ~~~~ ‚îú‚îÄ java.lang.Object[] array ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 289.3 kB in 7947 objects ‚îÇ ‚Üì Object[].[0] ‚îÇ ~~~ ‚îú‚îÄ io.reactivex.rxjava3.internal.observers.ConsumerSingleObserver instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 36 B in 2 objects ‚îÇ ‚Üì ConsumerSingleObserver.onSuccess ‚îÇ ~~~~~~~~~ ‚îú‚îÄ autodispose2.sample.TacoViewModel$loadTaco$1 instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 16 B in 1 objects ‚îÇ Anonymous class implementing io.reactivex.rxjava3.functions.Consumer ‚îÇ $activity instance of autodispose2.sample.HomeActivity with mDestroyed = ‚îÇ true ‚îÇ ‚Üì TacoViewModel$loadTaco$1.$activity ‚îÇ ~~~~~~~~~ ‚ï∞‚Üí autodispose2.sample.HomeActivity instance ‚Äã Leaking: YES (ObjectWatcher was watching this because autodispose2.sample. ‚Äã HomeActivity received Activity#onDestroy() callback and ‚Äã Activity#mDestroyed is true) ‚Äã Retaining 144.8 kB in 3973 objectsüê§Springing the LeakIn our example, the Consumer lambda passed to subscribe() is what's called a capturing lambda, because it retains a reference to the original activity. The returned Disposable, in turn, keeps a reference to this consumer. You can actually see this directly in the leak canary trace, where the disposable is actually the ConsumerSingleObserver it refs: ‚îú‚îÄ io.reactivex.rxjava3.internal.observers.ConsumerSingleObserver instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 36 B in 2 objects ‚îÇ ‚Üì ConsumerSingleObserver.onSuccess ‚îÇ ~~~~~~~~~ ‚îú‚îÄ autodispose2.sample.TacoViewModel$loadTaco$1 instance ‚îÇ Leaking: UNKNOWN ‚îÇ Retaining 16 B in 1 objects ‚îÇ Anonymous class implementing io.reactivex.rxjava3.functions.Consumer ‚îÇ $activity instance of autodispose2.sample.HomeActivity with mDestroyed = ‚îÇ true ‚îÇ ‚Üì TacoViewModel$loadTaco$1.$activity ‚îÇ ~~~~~~~~~This instance lives on forever inside the CompositeDisposable until onCleared() is called. This means every activity passed into loadTaco() is leaked, even if temporarily, until onCleared is called.Even though we've added what looks like proper disposal in onCleared(), our retained Disposable instance is, itself, a leak because it's still transitively holding onto a reference to anything captured in the lambda!This can happen with any Disposable too. CompositeDisposable exacerbates this further because it will accumulate these potential leaks. \"I don't use ViewModel and nothing in our codebase outlives Activity, do I need to think about this?\"Yes! The example above uses a simple ViewModel because I'm aware of my Android-centric audience :). This isn't unique to them however, or even to Android. Replace ViewModel with whatever construct you want (Presenter, Manager, etc) and Activity with anything you don't want to leak.@Singleton class HttpClient { val compositeDisposable = CompositeDisposable() fun request(url: String, callback: Callback) { // Leaks every callback and everything it // references unless you call shutdown() üôÉ compositeDisposable.add(makeRequestSingle(url) .subscribe { callback.onResponse(it) }) } fun cancelRequests() { compositeDisposable.clear() } }A singleton HttpClient that leaks every request callback unless you call cancelRequests()class MyPresenter { var disposable: Disposable? = null fun bind(context: Context) { // Leaks context until onStop() disposable = Single.just(1) .subscribe { println(context) } } fun onStop() { disposable?.dispose() // Persists even after this unless you // discard your Presenter or null out the disposable disposable = null } }A Presenter that leaks every context until onStop(). Maybe this is fine in your use case, but the context is still technically leaked until stopped!...and so on and so forth. Disposable holds on to everything captured in your observer/consumer, regardless of the context and whether or not you've called dispose() on it.SolutionsIf you're keeping the returned Disposable, plan to do something with it or discard it. Don't just dispose() it when needed but rather also clear your reference to it when the stream terminates if possible. You could explore writing your own WeakLambdaObserver or something similar, too.Avoid capturing lambdas where possible, but these happen easily. Would be neat if there was a lint check to warn about these ü§î.Save yourself some time and use AutoDispose (disclaimer: I'm the original author). AutoDispose doesn't avoid this exact issue per se, but it does eliminate the need to keep the returned Disposable around 99% of the time.Special thanks to Py and Dan for reviewing this.",
  "image": "https://images.unsplash.com/photo-1578651714116-2a1645b70c0f?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=MXwxMTc3M3wwfDF8c2VhcmNofDJ8fHNwaWxsZWQlMjBjb2ZmZWV8ZW58MHx8fA\u0026ixlib=rb-1.2.1\u0026q=80\u0026w=2000",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cspan\u003e02 Feb 2021\u003c/span\u003e\n    \u003ci\u003e‚Ä¢\u003c/i\u003e\n    \u003cspan\u003e3 min read\u003c/span\u003e\n  \u003c/p\u003e\n  \n    \u003cp\u003eEvery Disposable holds a strong reference to the observer it binds. This can lead to surprising memory leaks.\u003c/p\u003e\n    \n    \u003cp\u003e\u003cimg src=\"https://images.unsplash.com/photo-1578651714116-2a1645b70c0f?crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;fm=webp\u0026amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDJ8fHNwaWxsZWQlMjBjb2ZmZWV8ZW58MHx8fA\u0026amp;ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;w=180\" data-src=\"https://images.unsplash.com/photo-1578651714116-2a1645b70c0f?crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;fm=webp\u0026amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDJ8fHNwaWxsZWQlMjBjb2ZmZWV8ZW58MHx8fA\u0026amp;ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;w=1200\" alt=\"Disposables Can Cause Memory Leaks\"/\u003e\n\n    \u003c/p\u003e\n\u003c/div\u003e\u003cdiv\u003e\n    \u003cp\u003eConsider the following example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass TacoViewModel : ViewModel() {\n\n  var compositeDisposable = CompositeDisposable()\n\n  fun loadTaco(activity: Activity) {\n    compositeDisposable.add(\n      Single.just(Taco())\n        .subscribe { taco -\u0026gt;\n          // Handle taco...\n          println(\u0026#34;Taco created in $activity\u0026#34;)\n        }\n    )\n  }\n\n  override fun onCleared() {\n    compositeDisposable.clear()\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSimple, right? This is a classic pattern for avoiding memory leaks in RxJava code: keep the returned \u003ccode\u003eDisposable\u003c/code\u003e and dispose/clear it in the \u0026#34;end\u0026#34; event of whatever scope you\u0026#39;re in. This is great if you want to prevent memory leaks if your \u003ccode\u003eTacoViewModel\u003c/code\u003e lifecycle ends before the \u003ccode\u003eSingle\u003c/code\u003e terminates.\u003c/p\u003e\u003cp\u003eHowever, this actually leaks activities anyway because even though they\u0026#39;re disposed, we keep \u003ccode\u003eDisposable\u003c/code\u003e instances around until \u003ccode\u003eonCleared()\u003c/code\u003e is called.\u003c/p\u003e\u003cp\u003eCongratulations, you now have a good old-fashioned Android \u003ccode\u003eActivity\u003c/code\u003e memory leak. Drop this into your app, load some tacos, rotate, and watch \u003ca href=\"https://github.com/square/leakcanary?ref=zacsweers.dev\"\u003eLeakCanary\u003c/a\u003e start to chirp üê§.\u003c/p\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e    ‚î¨‚îÄ‚îÄ‚îÄ\n    ‚îÇ GC Root: System class\n    ‚îÇ\n   /// ...\n    ‚îÇ  \n    ‚îú‚îÄ autodispose2.sample.TacoViewModel instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 289.4 kB in 7953 objects\n    ‚îÇ    ‚Üì TacoViewModel.compositeDisposable\n    ‚îÇ                    ~~~~~~~~~~~~~~~~~~~\n    ‚îú‚îÄ io.reactivex.rxjava3.disposables.CompositeDisposable instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 289.3 kB in 7949 objects\n    ‚îÇ    ‚Üì CompositeDisposable.resources\n    ‚îÇ                          ~~~~~~~~~\n    ‚îú‚îÄ io.reactivex.rxjava3.internal.util.OpenHashSet instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 289.3 kB in 7948 objects\n    ‚îÇ    ‚Üì OpenHashSet.keys\n    ‚îÇ                  ~~~~\n    ‚îú‚îÄ java.lang.Object[] array\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 289.3 kB in 7947 objects\n    ‚îÇ    ‚Üì Object[].[0]\n    ‚îÇ               ~~~\n    ‚îú‚îÄ io.reactivex.rxjava3.internal.observers.ConsumerSingleObserver instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 36 B in 2 objects\n    ‚îÇ    ‚Üì ConsumerSingleObserver.onSuccess\n    ‚îÇ                             ~~~~~~~~~\n    ‚îú‚îÄ autodispose2.sample.TacoViewModel$loadTaco$1 instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 16 B in 1 objects\n    ‚îÇ    Anonymous class implementing io.reactivex.rxjava3.functions.Consumer\n    ‚îÇ    $activity instance of autodispose2.sample.HomeActivity with mDestroyed =\n    ‚îÇ    true\n    ‚îÇ    ‚Üì TacoViewModel$loadTaco$1.$activity\n    ‚îÇ                               ~~~~~~~~~\n    ‚ï∞‚Üí autodispose2.sample.HomeActivity instance\n    ‚Äã     Leaking: YES (ObjectWatcher was watching this because autodispose2.sample.\n    ‚Äã     HomeActivity received Activity#onDestroy() callback and\n    ‚Äã     Activity#mDestroyed is true)\n    ‚Äã     Retaining 144.8 kB in 3973 objects\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003eüê§\u003c/figcaption\u003e\u003c/figure\u003e\u003ch3 id=\"springing-the-leak\"\u003eSpringing the Leak\u003c/h3\u003e\u003cp\u003eIn our example, the \u003ccode\u003eConsumer\u003c/code\u003e lambda passed to \u003ccode\u003esubscribe()\u003c/code\u003e is what\u0026#39;s called a \u003cem\u003ecapturing\u003c/em\u003e lambda, because it retains a reference to the original \u003ccode\u003eactivity\u003c/code\u003e. The returned \u003ccode\u003eDisposable\u003c/code\u003e, in turn, keeps a reference to this consumer. You can actually see this directly in the leak canary trace, where the \u003ccode\u003edisposable\u003c/code\u003e is actually the \u003ccode\u003eConsumerSingleObserver\u003c/code\u003e it refs:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e    ‚îú‚îÄ io.reactivex.rxjava3.internal.observers.ConsumerSingleObserver instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 36 B in 2 objects\n    ‚îÇ    ‚Üì ConsumerSingleObserver.onSuccess\n    ‚îÇ                             ~~~~~~~~~\n    ‚îú‚îÄ autodispose2.sample.TacoViewModel$loadTaco$1 instance\n    ‚îÇ    Leaking: UNKNOWN\n    ‚îÇ    Retaining 16 B in 1 objects\n    ‚îÇ    Anonymous class implementing io.reactivex.rxjava3.functions.Consumer\n    ‚îÇ    $activity instance of autodispose2.sample.HomeActivity with mDestroyed =\n    ‚îÇ    true\n    ‚îÇ    ‚Üì TacoViewModel$loadTaco$1.$activity\n    ‚îÇ                               ~~~~~~~~~\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis instance lives on forever inside the \u003ccode\u003eCompositeDisposable\u003c/code\u003e until \u003ccode\u003eonCleared()\u003c/code\u003e is called. This means every activity passed into \u003ccode\u003eloadTaco()\u003c/code\u003e is leaked, even if temporarily, until \u003ccode\u003eonCleared\u003c/code\u003e is called.\u003c/p\u003e\u003cblockquote\u003e\u003cem\u003eEven though we\u0026#39;ve added what looks like proper disposal in \u003ccode\u003eonCleared()\u003c/code\u003e, our retained \u003ccode\u003eDisposable\u003c/code\u003e instance is, itself, a leak because it\u0026#39;s still transitively holding onto a reference to anything captured in the lambda!\u003c/em\u003e\u003c/blockquote\u003e\u003cp\u003eThis can happen with any \u003ccode\u003eDisposable\u003c/code\u003e too. \u003ccode\u003eCompositeDisposable\u003c/code\u003e exacerbates this further because it will \u003cem\u003eaccumulate\u003c/em\u003e these potential leaks. \u003c/p\u003e\u003ch3 id=\"i-don-t-use-viewmodel-and-nothing-in-our-codebase-outlives-activity-do-i-need-to-think-about-this\"\u003e\u0026#34;I don\u0026#39;t use ViewModel and nothing in our codebase outlives Activity, do I need to think about this?\u0026#34;\u003c/h3\u003e\u003cp\u003eYes! The example above uses a simple \u003ccode\u003eViewModel\u003c/code\u003e because I\u0026#39;m aware of my Android-centric audience :). This isn\u0026#39;t unique to them however, or even to Android. Replace \u003ccode\u003eViewModel\u003c/code\u003e with whatever construct you want (\u003ccode\u003ePresenter\u003c/code\u003e, \u003ccode\u003eManager\u003c/code\u003e, etc) and \u003ccode\u003eActivity\u003c/code\u003e with anything you don\u0026#39;t want to leak.\u003c/p\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003e@Singleton\nclass HttpClient {\n  val compositeDisposable = CompositeDisposable()\n  \n  fun request(url: String, callback: Callback) {\n    // Leaks every callback and everything it \n    // references unless you call shutdown() üôÉ\n    compositeDisposable.add(makeRequestSingle(url)\n        .subscribe { callback.onResponse(it) })\n  }\n  \n  fun cancelRequests() {\n    compositeDisposable.clear()\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003eA singleton HttpClient that leaks every request callback unless you call \u003ccode\u003ecancelRequests()\u003c/code\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003cpre\u003e\u003ccode\u003eclass MyPresenter {\n  var disposable: Disposable? = null\n  \n  fun bind(context: Context) {\n    // Leaks context until onStop()\n    disposable = Single.just(1)\n        .subscribe { println(context) } \n  }\n  \n  fun onStop() {\n    disposable?.dispose()\n    // Persists even after this unless you \n    // discard your Presenter or null out the disposable\n    disposable = null\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cfigcaption\u003eA Presenter that leaks every context until \u003ccode\u003eonStop()\u003c/code\u003e. Maybe this is fine in your use case, but the context is still technically leaked until stopped!\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e...and so on and so forth. \u003ccode\u003eDisposable\u003c/code\u003e holds on to everything captured in your observer/consumer, regardless of the context and whether or not you\u0026#39;ve called \u003ccode\u003edispose()\u003c/code\u003e on it.\u003c/p\u003e\u003ch3 id=\"solutions\"\u003eSolutions\u003c/h3\u003e\u003cul\u003e\u003cli\u003eIf you\u0026#39;re keeping the returned \u003ccode\u003eDisposable\u003c/code\u003e, plan to do something with it or discard it. Don\u0026#39;t just \u003ccode\u003edispose()\u003c/code\u003e it when needed but rather also clear your reference to it when the stream terminates if possible. You could explore writing your own \u003ccode\u003eWeakLambdaObserver\u003c/code\u003e or something similar, too.\u003c/li\u003e\u003cli\u003eAvoid capturing lambdas where possible, but these happen easily. Would be neat if there was a lint check to warn about these ü§î.\u003c/li\u003e\u003cli\u003eSave yourself some time and use \u003ca href=\"https://github.com/uber/autodispose?ref=zacsweers.dev\"\u003eAutoDispose\u003c/a\u003e (disclaimer: I\u0026#39;m the original author). AutoDispose doesn\u0026#39;t avoid this exact issue per se, but it does eliminate the need to keep the returned \u003ccode\u003eDisposable\u003c/code\u003e around 99% of the time.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cem\u003eSpecial thanks to \u003ca href=\"https://twitter.com/Piwai?ref=zacsweers.dev\"\u003ePy\u003c/a\u003e and \u003ca href=\"https://twitter.com/danlew42?ref=zacsweers.dev\"\u003eDan\u003c/a\u003e for reviewing this.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2021-02-03T04:13:49Z",
  "modifiedTime": "2021-02-03T04:13:49Z"
}
