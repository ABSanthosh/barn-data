{
  "id": "4d92fd10-92f3-4af4-a40b-b2d8ff001db1",
  "title": "Handling Token Expiration in Ktor: Automatic Token Refresh for API Calls",
  "link": "https://proandroiddev.com/handling-token-expiration-in-ktor-automatic-token-refresh-for-api-calls-e79badd379dc?source=rss----c72404660798---4",
  "description": "",
  "author": "Dobri Kostadinov",
  "published": "Thu, 27 Feb 2025 15:20:42 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "androiddev",
    "coroutine",
    "mobile-app-development",
    "kotlin",
    "android-app-development"
  ],
  "byline": "Dobri Kostadinov",
  "length": 11656,
  "excerpt": "In my previous article on Retrofit, I explained how to handle token expiration using OkHttp‚Äôs Authenticator and Interceptor. However, many modern Android applications are switching to Ktor Client as‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "A Complete Guide to Seamlessly Managing Token Expiry and Refresh in Ktor-based Android AppsIntroductionIn my previous article on Retrofit, I explained how to handle token expiration using OkHttp‚Äôs Authenticator and Interceptor. However, many modern Android applications are switching to Ktor Client as a lightweight and flexible alternative to Retrofit.If your app relies on authentication tokens, they will eventually expire, requiring a refresh before making further API calls. Instead of manually handling this across API calls, we can automate the token refresh process in Ktor using request interceptors and a well-structured authentication mechanism.Goals of This Guide‚úÖ Automatic token refresh when a 401 Unauthorized response is received.‚úÖ Efficient and synchronized refresh mechanism to prevent multiple refresh calls.‚úÖ Seamless request retrying with the new token.‚úÖ Graceful failure handling, including logging out the user when necessary.Let‚Äôs dive in! üöÄThe Problem: Expiring TokensConsider a scenario where your API service has multiple endpoints:interface ApiService { @GET(\"products\") suspend fun getProducts(): List\u003cProduct\u003e}If the access token expires, the backend returns a 401 Unauthorized response, causing the request to fail. The ideal solution should:1Ô∏è‚É£ Detect the 401 Unauthorized response.2Ô∏è‚É£ Automatically refresh the access token using the refresh_token.3Ô∏è‚É£ Retry the original request with the new access token.4Ô∏è‚É£ Log out the user if the refresh token is also expired.Instead of handling this manually across API calls, we can leverage Ktor‚Äôs interceptors to automate the process.Step 1: Creating an Interceptor to Add Authorization HeadersFirst, we need an interceptor that attaches the Authorization header to every request.class AuthInterceptor(private val sharedPreferences: SharedPreferences) { fun intercept(builder: HttpRequestBuilder) { val accessToken = sharedPreferences.getString(\"access_token\", \"\") ?: \"\" builder.header(\"Authorization\", \"Bearer $accessToken\") }}How It Works‚úÖ Fetches the latest access token from SharedPreferences.‚úÖ Appends it to the Authorization header for every request.Step 2: Implementing a Synchronized Token Refresh MechanismWhen a request fails with 401 Unauthorized, we must refresh the token before retrying the request. Instead of using synchronized(this), we use Kotlin‚Äôs Mutex for coroutine-safe synchronization.import kotlinx.coroutines.sync.Muteximport kotlinx.coroutines.sync.withLockclass TokenAuthenticator( private val apiService: ApiService, private val sharedPreferences: SharedPreferences) { private val lock = Mutex() // Ensures only one refresh at a time suspend fun refreshToken(): Boolean { return lock.withLock { val currentAccessToken = sharedPreferences.getString(\"access_token\", null) val refreshToken = sharedPreferences.getString(\"refresh_token\", null) ?: return false // If another request has refreshed the token, return success if (currentAccessToken != sharedPreferences.getString(\"access_token\", null)) { return true } return try { val response = apiService.refreshToken(refreshToken) sharedPreferences.edit() .putString(\"access_token\", response.accessToken) .putString(\"refresh_token\", response.refreshToken) .apply() true } catch (e: Exception) { false // Refresh failed, logout user } } }}How It Works‚úÖ Uses Mutex.withLock {} to prevent multiple refresh calls when multiple requests fail at the same time.‚úÖ Before refreshing, checks if another request has already updated the token.‚úÖ Calls the refresh token API, stores the new tokens, and returns true if successful.‚úÖ Returns false if the refresh fails, indicating that the user should be logged out.Step 3: Intercepting Requests and Handling Token Expiry in KtorNow, we configure Ktor Client to:Attach authorization headers to all requests.Handle 401 Unauthorized responses by triggering a token refresh.Retry the original request automatically if the refresh succeeds.In point 6 at the end of the current article I provide all DI examplesfun provideKtorClient( authInterceptor: AuthInterceptor, tokenAuthenticator: TokenAuthenticator, sharedPreferences: SharedPreferences): HttpClient { return HttpClient { install(HttpRequestRetry) { retryOnServerErrors(maxRetries = 3) exponentialDelay() } install(DefaultRequest) { authInterceptor.intercept(this) } HttpResponseValidator { handleResponseExceptionWithRequest { exception, request -\u003e if (exception is ClientRequestException \u0026\u0026 exception.response.status == HttpStatusCode.Unauthorized) { val refreshed = tokenAuthenticator.refreshToken() if (refreshed) { request.headers[\"Authorization\"] = \"Bearer ${sharedPreferences.getString(\"access_token\", \"\")}\" throw exception // Rethrow to let Ktor retry } else { logoutUser() // Handle logout scenario } } } } }}How It Works‚úÖ Attaches tokens to every request using AuthInterceptor. ‚úÖ Handles 401 Unauthorized errors by calling refreshToken(). ‚úÖ Retries the original request automatically if the token refresh succeeds. ‚úÖ Logs out the user if the token refresh fails.Step 4: Implementing the Refresh Token API in ApiServiceYour API service should include an endpoint for refreshing tokens:interface ApiService { @POST(\"auth/refresh\") suspend fun refreshToken(@Body refreshToken: String): TokenResponse}data class TokenResponse( val accessToken: String, val refreshToken: String)Handling Edge CasesEven with automatic token refresh, certain edge cases need to be managed:1. Refresh Token Expired?If the refresh token is also expired, the user must be logged out(or do any related to your app logic):if (!tokenAuthenticator.refreshToken()) { logoutUser()}2. Multiple Requests Fail at the Same Time?If multiple API calls fail with 401 simultaneously, only one refresh request should be made.‚úÖ Solution: We use Mutex.withLock {} in refreshToken() to prevent duplicate refresh calls.3. Network Failure During Token Refresh?If the network is down when refreshing the token, we need a retry mechanism.‚úÖ Solution: We handle retries with exponential backoff inside HttpRequestRetry.Step 6: Setting Up Dependency Injection for Ktor ClientTo make our AuthInterceptor and TokenAuthenticator reusable across the app, we should instantiate them properly. Here‚Äôs an example of how to do this using Dagger/Hilt or a simple manual dependency injection approach.Option 1: Manual Dependency Injection (Basic Approach)If you‚Äôre not using a dependency injection framework, instantiate the dependencies like this:// Create SharedPreferences instance (e.g., in Application class)val sharedPreferences: SharedPreferences = context.getSharedPreferences(\"app_prefs\", Context.MODE_PRIVATE)// Create ApiService instance using Ktor Clientval apiService: ApiService = provideRetrofit(sharedPreferences).create(ApiService::class.java)// Instantiate the dependenciesval authInterceptor = AuthInterceptor(sharedPreferences)val tokenAuthenticator = TokenAuthenticator(apiService, sharedPreferences)// Provide the Ktor client instanceval ktorClient = provideKtorClient(authInterceptor, tokenAuthenticator, sharedPreferences)This ensures that the same AuthInterceptor and TokenAuthenticator are used throughout the application.Option 2: Using Hilt (Recommended for Larger Projects)For projects using Hilt for dependency injection, define the necessary dependencies like this:1Ô∏è‚É£ Provide SharedPreferences in a Hilt Module@Module@InstallIn(SingletonComponent::class)object AppModule {@Provides @Singleton fun provideSharedPreferences(@ApplicationContext context: Context): SharedPreferences { return context.getSharedPreferences(\"app_prefs\", Context.MODE_PRIVATE) }}2Ô∏è‚É£ Provide ApiService (Ktor)@Module@InstallIn(SingletonComponent::class)object NetworkModule {@Provides @Singleton fun provideApiService(sharedPreferences: SharedPreferences): ApiService { return provideRetrofit(sharedPreferences).create(ApiService::class.java) }}3Ô∏è‚É£ Provide AuthInterceptor and TokenAuthenticator@Module@InstallIn(SingletonComponent::class)object AuthModule {@Provides @Singleton fun provideAuthInterceptor(sharedPreferences: SharedPreferences): AuthInterceptor { return AuthInterceptor(sharedPreferences) } @Provides @Singleton fun provideTokenAuthenticator( apiService: ApiService, sharedPreferences: SharedPreferences ): TokenAuthenticator { return TokenAuthenticator(apiService, sharedPreferences) }}4Ô∏è‚É£ Provide the Ktor Client@Module@InstallIn(SingletonComponent::class)object KtorModule { @Provides @Singleton fun provideKtorClient( authInterceptor: AuthInterceptor, tokenAuthenticator: TokenAuthenticator, sharedPreferences: SharedPreferences ): HttpClient { return HttpClient { install(HttpRequestRetry) { retryOnServerErrors(maxRetries = 3) exponentialDelay() } install(DefaultRequest) { authInterceptor.intercept(this) } HttpResponseValidator { handleResponseExceptionWithRequest { exception, request -\u003e if (exception is ClientRequestException \u0026\u0026 exception.response.status == HttpStatusCode.Unauthorized) { val refreshed = tokenAuthenticator.refreshToken() if (refreshed) { request.headers[\"Authorization\"] = \"Bearer ${sharedPreferences.getString(\"access_token\", \"\")}\" throw exception // Rethrow to let Ktor retry } else { logoutUser() // Handle logout scenario } } } } } }}Now, your ViewModel or Repository can inject the Ktor client easily:@HiltViewModelclass ProductsViewModel @Inject constructor( private val ktorClient: HttpClient) : ViewModel() { suspend fun getProducts(): List\u003cProduct\u003e { return ktorClient.get(\"https://api.example.com/products\").body() }}Why This Step is Important?‚úÖ Ensures AuthInterceptor and TokenAuthenticator are created once and shared across API calls.‚úÖ Prevents creating new instances on each API request.‚úÖ Scales well when using DI frameworks like Hilt.ConclusionBy implementing an interceptor-based approach, we have achieved automatic token refresh in Ktor. This ensures:‚úÖ Seamless token refresh without manual user intervention.‚úÖ Prevents multiple refresh calls by synchronizing requests.‚úÖ Retries failed requests automatically after refreshing the token.‚úÖ Handles refresh failures gracefully by logging out the user when necessary.Final ThoughtThis approach provides a robust, efficient, and scalable way to manage token expiration in Ktor-based Android apps. By leveraging Ktor‚Äôs interceptors, retry mechanisms, and coroutines, we ensure a smooth, uninterrupted user experience. üöÄDo you use a different method for handling token refresh in Ktor? Let me know in the comments below! üëáDobri KostadinovAndroid Consultant | TrainerEmail me | Follow me on LinkedIn | Follow me on Medium | Buy me a coffee",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*fVU79-x_7MyEE9MOP6FeVg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"9669\"\u003eA Complete Guide to Seamlessly Managing Token Expiry and Refresh in Ktor-based Android Apps\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dobri.kostadinov?source=post_page---byline--e79badd379dc---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dobri Kostadinov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*PDWUz7RmoqP9kmFnZzGPUg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--e79badd379dc---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"63ea\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"7dd5\"\u003eIn my \u003ca href=\"https://medium.com/proandroiddev/handling-token-expiration-in-retrofit-automatic-token-refresh-with-okhttp-d5673e4d4c41\" rel=\"noopener\"\u003eprevious article\u003c/a\u003e on Retrofit, I explained how to handle token expiration using OkHttp‚Äôs \u003ccode\u003eAuthenticator\u003c/code\u003e and \u003ccode\u003eInterceptor\u003c/code\u003e. However, many modern Android applications are switching to \u003cstrong\u003eKtor Client\u003c/strong\u003e as a lightweight and flexible alternative to Retrofit.\u003c/p\u003e\u003cp id=\"a771\"\u003eIf your app relies on authentication tokens, they will eventually \u003cstrong\u003eexpire\u003c/strong\u003e, requiring a refresh before making further API calls. Instead of manually handling this across API calls, we can \u003cstrong\u003eautomate the token refresh process\u003c/strong\u003e in Ktor using request interceptors and a well-structured authentication mechanism.\u003c/p\u003e\u003ch2 id=\"65ce\"\u003eGoals of This Guide\u003c/h2\u003e\u003cp id=\"3954\"\u003e‚úÖ \u003cstrong\u003eAutomatic token refresh\u003c/strong\u003e when a \u003ccode\u003e401 Unauthorized\u003c/code\u003e response is received.\u003cbr/\u003e‚úÖ \u003cstrong\u003eEfficient and synchronized\u003c/strong\u003e refresh mechanism to prevent multiple refresh calls.\u003cbr/\u003e‚úÖ \u003cstrong\u003eSeamless request retrying\u003c/strong\u003e with the new token.\u003cbr/\u003e‚úÖ \u003cstrong\u003eGraceful failure handling\u003c/strong\u003e, including logging out the user when necessary.\u003c/p\u003e\u003cp id=\"6995\"\u003eLet‚Äôs dive in! üöÄ\u003c/p\u003e\u003ch2 id=\"18d2\"\u003eThe Problem: Expiring Tokens\u003c/h2\u003e\u003cp id=\"8467\"\u003eConsider a scenario where your API service has multiple endpoints:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0e97\"\u003einterface ApiService {\u003cbr/\u003e    @GET(\u0026#34;products\u0026#34;)\u003cbr/\u003e    suspend fun getProducts(): List\u0026lt;Product\u0026gt;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c082\"\u003eIf the \u003cstrong\u003eaccess token expires\u003c/strong\u003e, the backend returns a \u003ccode\u003e401 Unauthorized\u003c/code\u003e response, causing the request to fail. The ideal solution should:\u003c/p\u003e\u003cp id=\"eb68\"\u003e1Ô∏è‚É£ Detect the \u003ccode\u003e401 Unauthorized\u003c/code\u003e response.\u003cbr/\u003e2Ô∏è‚É£ Automatically refresh the access token using the \u003ccode\u003erefresh_token\u003c/code\u003e.\u003cbr/\u003e3Ô∏è‚É£ Retry the original request with the new access token.\u003cbr/\u003e4Ô∏è‚É£ Log out the user if the \u003cstrong\u003erefresh token\u003c/strong\u003e is also expired.\u003c/p\u003e\u003cp id=\"fbeb\"\u003eInstead of handling this manually across API calls, we can \u003cstrong\u003eleverage Ktor‚Äôs interceptors\u003c/strong\u003e to automate the process.\u003c/p\u003e\u003ch2 id=\"ac2e\"\u003eStep 1: Creating an Interceptor to Add Authorization Headers\u003c/h2\u003e\u003cp id=\"72b0\"\u003eFirst, we need an \u003cstrong\u003einterceptor\u003c/strong\u003e that attaches the \u003ccode\u003eAuthorization\u003c/code\u003e header to every request.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8ba3\"\u003eclass AuthInterceptor(private val sharedPreferences: SharedPreferences) {\u003cbr/\u003e    fun intercept(builder: HttpRequestBuilder) {\u003cbr/\u003e        val accessToken = sharedPreferences.getString(\u0026#34;access_token\u0026#34;, \u0026#34;\u0026#34;) ?: \u0026#34;\u0026#34;\u003cbr/\u003e        builder.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer $accessToken\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"95b6\"\u003eHow It Works\u003c/h2\u003e\u003cp id=\"65a9\"\u003e‚úÖ Fetches the latest access token from \u003cstrong\u003eSharedPreferences\u003c/strong\u003e.\u003cbr/\u003e‚úÖ Appends it to the \u003ccode\u003eAuthorization\u003c/code\u003e header for every request.\u003c/p\u003e\u003ch2 id=\"a03f\"\u003eStep 2: Implementing a Synchronized Token Refresh Mechanism\u003c/h2\u003e\u003cp id=\"99ad\"\u003eWhen a request fails with \u003ccode\u003e401 Unauthorized\u003c/code\u003e, we must \u003cstrong\u003erefresh the token\u003c/strong\u003e before retrying the request. Instead of using \u003ccode\u003esynchronized(this)\u003c/code\u003e, we use \u003cstrong\u003eKotlin‚Äôs \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eMutex\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e for coroutine-safe synchronization\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1093\"\u003eimport kotlinx.coroutines.sync.Mutex\u003cbr/\u003eimport kotlinx.coroutines.sync.withLock\u003cp\u003eclass TokenAuthenticator(\u003cbr/\u003e    private val apiService: ApiService,\u003cbr/\u003e    private val sharedPreferences: SharedPreferences\u003cbr/\u003e) {\u003cbr/\u003e    private val lock = Mutex() // Ensures only one refresh at a time\u003cbr/\u003e    suspend fun refreshToken(): Boolean {\u003cbr/\u003e        return lock.withLock {\u003cbr/\u003e            val currentAccessToken = sharedPreferences.getString(\u0026#34;access_token\u0026#34;, null)\u003cbr/\u003e            val refreshToken = sharedPreferences.getString(\u0026#34;refresh_token\u0026#34;, null) ?: return false\u003cbr/\u003e            // If another request has refreshed the token, return success\u003cbr/\u003e            if (currentAccessToken != sharedPreferences.getString(\u0026#34;access_token\u0026#34;, null)) {\u003cbr/\u003e                return true\u003cbr/\u003e            }\u003cbr/\u003e            return try {\u003cbr/\u003e                val response = apiService.refreshToken(refreshToken)\u003cbr/\u003e                sharedPreferences.edit()\u003cbr/\u003e                    .putString(\u0026#34;access_token\u0026#34;, response.accessToken)\u003cbr/\u003e                    .putString(\u0026#34;refresh_token\u0026#34;, response.refreshToken)\u003cbr/\u003e                    .apply()\u003cbr/\u003e                true\u003cbr/\u003e            } catch (e: Exception) {\u003cbr/\u003e                false // Refresh failed, logout user\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"8d4c\"\u003eHow It Works\u003c/h2\u003e\u003cp id=\"3e04\"\u003e‚úÖ Uses \u003ccode\u003e\u003cstrong\u003eMutex.withLock {}\u003c/strong\u003e\u003c/code\u003e to \u003cstrong\u003eprevent multiple refresh calls\u003c/strong\u003e when multiple requests fail at the same time.\u003cbr/\u003e‚úÖ Before refreshing, checks if another request has already updated the token.\u003cbr/\u003e‚úÖ Calls the \u003cstrong\u003erefresh token API\u003c/strong\u003e, stores the new tokens, and returns \u003ccode\u003etrue\u003c/code\u003e if successful.\u003cbr/\u003e‚úÖ Returns \u003ccode\u003efalse\u003c/code\u003e if the refresh fails, indicating that the user should be logged out.\u003c/p\u003e\u003ch2 id=\"7df4\"\u003eStep 3: Intercepting Requests and Handling Token Expiry in Ktor\u003c/h2\u003e\u003cp id=\"8ff9\"\u003eNow, we configure \u003cstrong\u003eKtor Client\u003c/strong\u003e to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b1d4\"\u003eAttach \u003cstrong\u003eauthorization headers\u003c/strong\u003e to all requests.\u003c/li\u003e\u003cli id=\"b7a1\"\u003eHandle \u003ccode\u003e401 Unauthorized\u003c/code\u003e responses by \u003cstrong\u003etriggering a token refresh\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"e2a5\"\u003eRetry the \u003cstrong\u003eoriginal request\u003c/strong\u003e automatically if the refresh succeeds.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6f1d\"\u003e\u003cstrong\u003eIn point 6 at the end of the current article I provide all DI examples\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6c64\"\u003efun provideKtorClient(\u003cbr/\u003e    authInterceptor: AuthInterceptor,\u003cbr/\u003e    tokenAuthenticator: TokenAuthenticator,\u003cbr/\u003e    sharedPreferences: SharedPreferences\u003cbr/\u003e): HttpClient {\u003cbr/\u003e    return HttpClient {\u003cbr/\u003e        install(HttpRequestRetry) {\u003cbr/\u003e            retryOnServerErrors(maxRetries = 3)\u003cbr/\u003e            exponentialDelay()\u003cbr/\u003e        }\u003cbr/\u003e        install(DefaultRequest) {\u003cbr/\u003e            authInterceptor.intercept(this)\u003cbr/\u003e        }\u003cbr/\u003e        HttpResponseValidator {\u003cbr/\u003e            handleResponseExceptionWithRequest { exception, request -\u0026gt;\u003cbr/\u003e                if (exception is ClientRequestException \u0026amp;\u0026amp; exception.response.status == HttpStatusCode.Unauthorized) {\u003cbr/\u003e                    val refreshed = tokenAuthenticator.refreshToken()\u003cbr/\u003e                    if (refreshed) {\u003cbr/\u003e                        request.headers[\u0026#34;Authorization\u0026#34;] = \u0026#34;Bearer ${sharedPreferences.getString(\u0026#34;access_token\u0026#34;, \u0026#34;\u0026#34;)}\u0026#34;\u003cbr/\u003e                        throw exception // Rethrow to let Ktor retry\u003cbr/\u003e                    } else {\u003cbr/\u003e                        logoutUser() // Handle logout scenario\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"35d5\"\u003eHow It Works\u003c/h2\u003e\u003cp id=\"bdba\"\u003e‚úÖ \u003cstrong\u003eAttaches tokens\u003c/strong\u003e to every request using \u003ccode\u003eAuthInterceptor\u003c/code\u003e.\u003cbr/\u003e ‚úÖ \u003cstrong\u003eHandles 401 Unauthorized errors\u003c/strong\u003e by calling \u003ccode\u003erefreshToken()\u003c/code\u003e.\u003cbr/\u003e ‚úÖ \u003cstrong\u003eRetries the original request automatically\u003c/strong\u003e if the token refresh succeeds.\u003cbr/\u003e ‚úÖ \u003cstrong\u003eLogs out the user\u003c/strong\u003e if the token refresh fails.\u003c/p\u003e\u003ch2 id=\"c4fd\"\u003eStep 4: Implementing the Refresh Token API in \u003ccode\u003eApiService\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"82ac\"\u003eYour API service should include an \u003cstrong\u003eendpoint for refreshing tokens\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c78d\"\u003einterface ApiService {\u003cbr/\u003e    @POST(\u0026#34;auth/refresh\u0026#34;)\u003cbr/\u003e    suspend fun refreshToken(@Body refreshToken: String): TokenResponse\u003cbr/\u003e}\u003cp\u003edata class TokenResponse(\u003cbr/\u003e    val accessToken: String,\u003cbr/\u003e    val refreshToken: String\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1b80\"\u003eHandling Edge Cases\u003c/h2\u003e\u003cp id=\"5032\"\u003eEven with automatic token refresh, certain \u003cstrong\u003eedge cases\u003c/strong\u003e need to be managed:\u003c/p\u003e\u003ch2 id=\"bffb\"\u003e1. Refresh Token Expired?\u003c/h2\u003e\u003cp id=\"b11b\"\u003eIf the refresh token is \u003cstrong\u003ealso expired\u003c/strong\u003e, the user must be \u003cstrong\u003elogged out(or do any related to your app logic)\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5dd1\"\u003eif (!tokenAuthenticator.refreshToken()) {\u003cbr/\u003e    logoutUser()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"ba55\"\u003e2. Multiple Requests Fail at the Same Time?\u003c/h2\u003e\u003cp id=\"91b0\"\u003eIf multiple API calls fail with \u003ccode\u003e401\u003c/code\u003e \u003cstrong\u003esimultaneously\u003c/strong\u003e, only \u003cstrong\u003eone refresh request should be made\u003c/strong\u003e.\u003cbr/\u003e‚úÖ \u003cstrong\u003eSolution:\u003c/strong\u003e We use \u003ccode\u003e\u003cstrong\u003eMutex.withLock {}\u003c/strong\u003e\u003c/code\u003e in \u003ccode\u003erefreshToken()\u003c/code\u003e to \u003cstrong\u003eprevent duplicate refresh calls\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"1ad7\"\u003e3. Network Failure During Token Refresh?\u003c/h2\u003e\u003cp id=\"205d\"\u003eIf the \u003cstrong\u003enetwork is down\u003c/strong\u003e when refreshing the token, we need a retry mechanism.\u003cbr/\u003e‚úÖ \u003cstrong\u003eSolution:\u003c/strong\u003e We handle \u003cstrong\u003eretries with exponential backoff\u003c/strong\u003e inside \u003ccode\u003eHttpRequestRetry\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"e0ea\"\u003eStep 6: Setting Up Dependency Injection for Ktor Client\u003c/h2\u003e\u003cp id=\"3b5a\"\u003eTo make our \u003ccode\u003eAuthInterceptor\u003c/code\u003e and \u003ccode\u003eTokenAuthenticator\u003c/code\u003e reusable across the app, we should instantiate them \u003cstrong\u003eproperly\u003c/strong\u003e. Here‚Äôs an example of how to do this using \u003cstrong\u003eDagger/Hilt\u003c/strong\u003e or a simple manual dependency injection approach.\u003c/p\u003e\u003ch2 id=\"6387\"\u003eOption 1: Manual Dependency Injection (Basic Approach)\u003c/h2\u003e\u003cp id=\"c8ee\"\u003eIf you‚Äôre not using a dependency injection framework, instantiate the dependencies like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"80c1\"\u003e// Create SharedPreferences instance (e.g., in Application class)\u003cbr/\u003eval sharedPreferences: SharedPreferences = \u003cbr/\u003e    context.getSharedPreferences(\u0026#34;app_prefs\u0026#34;, Context.MODE_PRIVATE)\u003cp\u003e// Create ApiService instance using Ktor Client\u003cbr/\u003eval apiService: ApiService = provideRetrofit(sharedPreferences).create(ApiService::class.java)\u003cbr/\u003e// Instantiate the dependencies\u003cbr/\u003eval authInterceptor = AuthInterceptor(sharedPreferences)\u003cbr/\u003eval tokenAuthenticator = TokenAuthenticator(apiService, sharedPreferences)\u003cbr/\u003e// Provide the Ktor client instance\u003cbr/\u003eval ktorClient = provideKtorClient(authInterceptor, tokenAuthenticator, sharedPreferences)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5c24\"\u003eThis ensures that the same \u003ccode\u003eAuthInterceptor\u003c/code\u003e and \u003ccode\u003eTokenAuthenticator\u003c/code\u003e are used throughout the application.\u003c/p\u003e\u003ch2 id=\"091b\"\u003eOption 2: Using Hilt (Recommended for Larger Projects)\u003c/h2\u003e\u003cp id=\"b088\"\u003eFor projects using \u003cstrong\u003eHilt\u003c/strong\u003e for dependency injection, define the necessary dependencies like this:\u003c/p\u003e\u003cp id=\"1682\"\u003e1Ô∏è‚É£ \u003cstrong\u003eProvide SharedPreferences in a Hilt Module\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e13b\"\u003e@Module\u003cbr/\u003e@InstallIn(SingletonComponent::class)\u003cbr/\u003eobject AppModule {\u003cbr/\u003e@Provides\u003cbr/\u003e    @Singleton\u003cbr/\u003e    fun provideSharedPreferences(@ApplicationContext context: Context): SharedPreferences {\u003cbr/\u003e        return context.getSharedPreferences(\u0026#34;app_prefs\u0026#34;, Context.MODE_PRIVATE)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d048\"\u003e2Ô∏è‚É£ \u003cstrong\u003eProvide \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eApiService\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e (Ktor)\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8008\"\u003e@Module\u003cbr/\u003e@InstallIn(SingletonComponent::class)\u003cbr/\u003eobject NetworkModule {\u003cbr/\u003e@Provides\u003cbr/\u003e    @Singleton\u003cbr/\u003e    fun provideApiService(sharedPreferences: SharedPreferences): ApiService {\u003cbr/\u003e        return provideRetrofit(sharedPreferences).create(ApiService::class.java)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d899\"\u003e3Ô∏è‚É£ \u003cstrong\u003eProvide \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eAuthInterceptor\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e and \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eTokenAuthenticator\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f922\"\u003e@Module\u003cbr/\u003e@InstallIn(SingletonComponent::class)\u003cbr/\u003eobject AuthModule {\u003cbr/\u003e@Provides\u003cbr/\u003e    @Singleton\u003cbr/\u003e    fun provideAuthInterceptor(sharedPreferences: SharedPreferences): AuthInterceptor {\u003cbr/\u003e        return AuthInterceptor(sharedPreferences)\u003cbr/\u003e    }\u003cbr/\u003e    @Provides\u003cbr/\u003e    @Singleton\u003cbr/\u003e    fun provideTokenAuthenticator(\u003cbr/\u003e        apiService: ApiService, \u003cbr/\u003e        sharedPreferences: SharedPreferences\u003cbr/\u003e    ): TokenAuthenticator {\u003cbr/\u003e        return TokenAuthenticator(apiService, sharedPreferences)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9086\"\u003e4Ô∏è‚É£ \u003cstrong\u003eProvide the Ktor Client\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d6cd\"\u003e@Module\u003cbr/\u003e@InstallIn(SingletonComponent::class)\u003cbr/\u003eobject KtorModule {\u003cp\u003e    @Provides\u003cbr/\u003e    @Singleton\u003cbr/\u003e    fun provideKtorClient(\u003cbr/\u003e        authInterceptor: AuthInterceptor, \u003cbr/\u003e        tokenAuthenticator: TokenAuthenticator,\u003cbr/\u003e        sharedPreferences: SharedPreferences\u003cbr/\u003e    ): HttpClient {\u003cbr/\u003e        return HttpClient {\u003cbr/\u003e            install(HttpRequestRetry) {\u003cbr/\u003e                retryOnServerErrors(maxRetries = 3)\u003cbr/\u003e                exponentialDelay()\u003cbr/\u003e            }\u003cbr/\u003e            install(DefaultRequest) {\u003cbr/\u003e                authInterceptor.intercept(this)\u003cbr/\u003e            }\u003cbr/\u003e            HttpResponseValidator {\u003cbr/\u003e                handleResponseExceptionWithRequest { exception, request -\u0026gt;\u003cbr/\u003e                    if (exception is ClientRequestException \u0026amp;\u0026amp; exception.response.status == HttpStatusCode.Unauthorized) {\u003cbr/\u003e                        val refreshed = tokenAuthenticator.refreshToken()\u003cbr/\u003e                        if (refreshed) {\u003cbr/\u003e                            request.headers[\u0026#34;Authorization\u0026#34;] = \u003cbr/\u003e                                \u0026#34;Bearer ${sharedPreferences.getString(\u0026#34;access_token\u0026#34;, \u0026#34;\u0026#34;)}\u0026#34;\u003cbr/\u003e                            throw exception // Rethrow to let Ktor retry\u003cbr/\u003e                        } else {\u003cbr/\u003e                            logoutUser() // Handle logout scenario\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f7c6\"\u003eNow, your \u003cstrong\u003eViewModel\u003c/strong\u003e or Repository can inject the Ktor client easily:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"efd2\"\u003e@HiltViewModel\u003cbr/\u003eclass ProductsViewModel @Inject constructor(\u003cbr/\u003e    private val ktorClient: HttpClient\u003cbr/\u003e) : ViewModel() {\u003cp\u003e        suspend fun getProducts(): List\u0026lt;Product\u0026gt; {\u003cbr/\u003e        return ktorClient.get(\u0026#34;https://api.example.com/products\u0026#34;).body()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"bdca\"\u003eWhy This Step is Important?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d2b0\"\u003e‚úÖ Ensures \u003ccode\u003eAuthInterceptor\u003c/code\u003e and \u003ccode\u003eTokenAuthenticator\u003c/code\u003e are \u003cstrong\u003ecreated once\u003c/strong\u003e and \u003cstrong\u003eshared\u003c/strong\u003e across API calls.\u003c/li\u003e\u003cli id=\"cd5f\"\u003e‚úÖ Prevents creating new instances on each API request.\u003c/li\u003e\u003cli id=\"201f\"\u003e‚úÖ \u003cstrong\u003eScales well\u003c/strong\u003e when using DI frameworks like Hilt.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"9ec1\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"c869\"\u003eBy implementing an \u003cstrong\u003einterceptor-based approach\u003c/strong\u003e, we have achieved \u003cstrong\u003eautomatic token refresh\u003c/strong\u003e in Ktor. This ensures:\u003c/p\u003e\u003cp id=\"a637\"\u003e‚úÖ \u003cstrong\u003eSeamless token refresh\u003c/strong\u003e without manual user intervention.\u003cbr/\u003e‚úÖ \u003cstrong\u003ePrevents multiple refresh calls\u003c/strong\u003e by \u003cstrong\u003esynchronizing requests\u003c/strong\u003e.\u003cbr/\u003e‚úÖ \u003cstrong\u003eRetries failed requests automatically\u003c/strong\u003e after refreshing the token.\u003cbr/\u003e‚úÖ \u003cstrong\u003eHandles refresh failures gracefully\u003c/strong\u003e by logging out the user when necessary.\u003c/p\u003e\u003ch2 id=\"7bac\"\u003eFinal Thought\u003c/h2\u003e\u003cp id=\"c8e9\"\u003eThis approach provides a \u003cstrong\u003erobust, efficient, and scalable\u003c/strong\u003e way to manage token expiration in \u003cstrong\u003eKtor-based Android apps\u003c/strong\u003e. By leveraging \u003cstrong\u003eKtor‚Äôs interceptors, retry mechanisms, and coroutines\u003c/strong\u003e, we ensure a \u003cstrong\u003esmooth, uninterrupted user experience\u003c/strong\u003e. üöÄ\u003c/p\u003e\u003cp id=\"3f5d\"\u003eDo you use a different method for handling token refresh in Ktor? Let me know in the comments below! üëá\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a347\"\u003e\u003cem\u003eDobri Kostadinov\u003c/em\u003e\u003cbr/\u003eAndroid Consultant | Trainer\u003cbr/\u003e\u003ca href=\"mailto:dobri.kostadinov@gmail.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEmail me\u003c/a\u003e | \u003ca href=\"https://www.linkedin.com/in/dobrikostadinov/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFollow me on LinkedIn\u003c/a\u003e | \u003ca href=\"https://medium.com/@dobri.kostadinov\" rel=\"noopener\"\u003eFollow me on Medium\u003c/a\u003e | \u003ca href=\"https://www.buymeacoffee.com/dobri.kostadinov\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBuy me a coffee\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-02-27T15:20:42.457Z",
  "modifiedTime": null
}
