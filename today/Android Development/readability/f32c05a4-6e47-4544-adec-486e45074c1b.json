{
  "id": "f32c05a4-6e47-4544-adec-486e45074c1b",
  "title": "Decisions, Deciders, and Executors",
  "link": "https://publicobject.com/2024/03/10/deciders-decisions-and-executors/",
  "description": "Most of the software I write exists to automate a process. It might automate a high-level workflow like peer-to-peer money transfers, or a low-level implementation detail like encoding an HTTP request as bytes.I’ve learned that my code is healthier when it’s strictly divided into value objects, service",
  "author": "Jesse Wilson",
  "published": "Sun, 10 Mar 2024 19:09:46 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 7952,
  "excerpt": "Most of the software I write exists to automate a process. It might automate a high-level workflow like peer-to-peer money transfers, or a low-level implementation detail like encoding an HTTP request as bytes. I’ve learned that my code is healthier when it’s strictly divided into value objects, service objects, and glue [/2019/06/10/value-objects-service-objects-and-glue/]. But even with this rule I struggle with service objects that are difficult to write \u0026 maintain. I’m building a chess web",
  "siteName": "Public Object",
  "favicon": "",
  "text": "Most of the software I write exists to automate a process. It might automate a high-level workflow like peer-to-peer money transfers, or a low-level implementation detail like encoding an HTTP request as bytes.I’ve learned that my code is healthier when it’s strictly divided into value objects, service objects, and glue. But even with this rule I struggle with service objects that are difficult to write \u0026 maintain.I’m building a chess web service. I’ve decided to send each player a monthly email with their stats \u0026 stuff. Here’s the service object that implements that automation:class MonthlySummaryEmailer( val db: ChessDatabase, val emailSender: EmailSender, ) { fun sendEmail(playerId: PlayerId, month: Int, year: Int) { val player = db.playerQueries.selectPlayer(playerId).executeAsOne() val emailAddress = player.email_address ?: return // No email address. val from = LocalDateTime.of(year, month, 1, 0, 0) val until = from.plusMonths(1) val (wins, losses) = db.gameQueries .selectWinsAndLosses( player_id = playerId, from = from.atZone(player.zone_id).toInstant(), until = until.atZone(player.zone_id).toInstant(), ) .executeAsOne() if (wins == 0L \u0026\u0026 losses == 0L) return // No games in this month. val incompleteGames = db.gameQueries .selectIncompleteGames(playerId) .executeAsList() val message = createHTML().body { h1 { +\"This month you won $wins games!\" } p { +\"Your win rate is ${100 * wins / (wins + losses)}%\" } if (incompleteGames.isNotEmpty()) { p { +\"You've got games to finish with \" for (game in incompleteGames) { a(href = \"https://publicobject.com/chess/game/${game.id}\") { +game.opponent_username } } } } } emailSender.sendEmail( emailAddress = emailAddress, subject = \"Your Chess summary for ${from.month}\", body = message, ) } } I’ve written tons of code like this. This is how the first draft comes out when I build software: gather inputs, make decisions, and perform actions.But I don’t like this code! I don’t like testing it and I don’t like changing it.I don’t like what happens in the unit test for customers that haven’t played any games. With this structure, that test needs to assert that EmailSender.sendEmail() is never called. That feels weird!Let’s borrow some ideas from the functional programming nerds and refactor this thing. I like to separate the code that makes decisions from the code that effects those decisions.DecisionsThis is a value object – or a hierarchy of value objects – that describe the action to take.I call this a Decision, Plan or Action and use that word as a suffix.sealed interface MonthlyEmailDecision object SkipReportNoEmailAddress : MonthlyEmailDecision object SkipReportNoGamesPlayed : MonthlyEmailDecision data class SendPlayReport( val emailAddress: String, val month: Month, val wins: Long, val losses: Long, val incompleteGames: List\u003cIncompleteGame\u003e, ) : MonthlyEmailDecision { data class IncompleteGame( val gameId: GameId, val opponentUsername: String, ) }Kotlin’s rich type system is awesome for describing value objects like these. I enjoy it all: sealed types, data classes, objects, named \u0026 default parameters, and concise property declarations.When I was writing Java full time, the amount of boilerplate required to model something like this was prohibitive! But in 2024 Java is better now too.I’ll extract a Decision object after writing it the wrong way first.DecidersThis is a service that makes a decision. It gathers input data that it needs to make a decision, but doesn’t act upon that decision. It’s the code base’s chief analyst.I’ll use the suffix Decider or a Planner on these.I don’t let any side-effects into these. I don’t even like logging here. That way I can use it to dry-run decisions: ‘how would our email volume change if we notified everyone who’s played in the last 90 days?’ From the perspective of the decider, its decision making could be hypothetical!class MonthlySummaryDecider( val db: ChessDatabase, ) { fun decide(playerId: PlayerId, month: Int, year: Int): MonthlyEmailDecision { val player = db.playerQueries.selectPlayer(playerId).executeAsOne() val emailAddress = player.email_address ?: return SkipReportNoEmailAddress val from = LocalDateTime.of(year, month, 1, 0, 0) val until = from.plusMonths(1) val (wins, losses) = db.gameQueries .selectWinsAndLosses( player_id = playerId, from = from.atZone(player.zone_id).toInstant(), until = until.atZone(player.zone_id).toInstant(), ) .executeAsOne() if (wins == 0L \u0026\u0026 losses == 0L) return SkipReportNoGamesPlayed val incompleteGames = db.gameQueries .selectIncompleteGames(playerId) .executeAsList() return SendPlayReport( emailAddress = emailAddress, month = from.month, wins = wins, losses = losses, incompleteGames = incompleteGames.map { SendPlayReport.IncompleteGame(it.id, it.opponent_username) }, ) } } This implementation isn’t strictly functional! It makes DB queries which means I’ll use a real database when I test it. I’m okay with that, especially since that gives me coverage for my fancy SQL.ExecutorsNow it’s time to take action. This is a service that takes a decision and makes it real. It sends messages, calls APIs, or positions widgets on the screen. It’s the code base’s dumb muscle.I don’t have a beloved naming convention for these. Usually it’s something task-specific.class MonthlyEmailSender( val emailSender: EmailSender, ) { fun execute(decision: MonthlyEmailDecision) { when (decision) { SkipReportNoEmailAddress, SkipReportNoGamesPlayed -\u003e return is SendPlayReport -\u003e { val message = createHTML().body { val wins = decision.wins val losses = decision.losses h1 { +\"This month you won $wins games!\" } p { +\"Your win rate is ${100 * wins / (wins + losses)}%\" } if (decision.incompleteGames.isNotEmpty()) { p { +\"You've got games to finish with \" for (game in decision.incompleteGames) { a(href = \"https://publicobject.com/chess/game/${game.gameId}\") { +game.opponentUsername } } } } } emailSender.sendEmail( emailAddress = decision.emailAddress, subject = \"Your Chess summary for ${decision.month}\", body = message, ) } } } }This particular executor is still too smart! If you’re asked to code review the above code, tell the author to extract a MonthlyEmailMessageFormatter class too.Optimistic Locking and TransactionsThis approach breaks atomicity between making decisions and acting upon them. It’s clumsy and awkward to put a database transaction that spans the decide and execute parts.I tend to give in and add optimistic locking metadata to my decision models. I’ll add an idempotence token or row version to the value object and let the execution step fail if these invariants have changed.Decisions in Distributed SystemsOn the services I’ve worked on, sometimes one microservice wants to collect \u0026 process data from another microservice. Decision objects are quite helpful here! Publish ’em on your event bus thing, possibly with extra context on what the inputs were that lead to each decision.More Code to Write, Easier to ReadIf I get another programming tattoo, it’ll be this gem from Wil Shipley:Less code is better code∴ No code is the best codeBut by introducing a decision object, we’ve added more code. Fortunately, when you read the (small) decision model code, you learn how the larger decider and executor code must work.I’m okay with this.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eMost of the software I write exists to automate a process. It might automate a high-level workflow like peer-to-peer money transfers, or a low-level implementation detail like encoding an HTTP request as bytes.\u003c/p\u003e\u003cp\u003eI’ve learned that my code is healthier when it’s strictly divided into \u003ca href=\"https://publicobject.com/2019/06/10/value-objects-service-objects-and-glue/\"\u003evalue objects, service objects, and glue\u003c/a\u003e. But even with this rule I struggle with service objects that are difficult to write \u0026amp; maintain.\u003c/p\u003e\u003cp\u003eI’m building a chess web service. I’ve decided to send each player a monthly email with their stats \u0026amp; stuff. Here’s the service object that implements that automation:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MonthlySummaryEmailer(\n  val db: ChessDatabase,\n  val emailSender: EmailSender,\n) {\n  fun sendEmail(playerId: PlayerId, month: Int, year: Int) {\n    val player = db.playerQueries.selectPlayer(playerId).executeAsOne()\n    val emailAddress = player.email_address ?: return // No email address.\n\n    val from = LocalDateTime.of(year, month, 1, 0, 0)\n    val until = from.plusMonths(1)\n\n    val (wins, losses) = db.gameQueries\n      .selectWinsAndLosses(\n        player_id = playerId,\n        from = from.atZone(player.zone_id).toInstant(),\n        until = until.atZone(player.zone_id).toInstant(),\n      )\n      .executeAsOne()\n\n    if (wins == 0L \u0026amp;\u0026amp; losses == 0L) return // No games in this month.\n\n    val incompleteGames = db.gameQueries\n      .selectIncompleteGames(playerId)\n      .executeAsList()\n\n    val message = createHTML().body {\n      h1 { +\u0026#34;This month you won $wins games!\u0026#34; }\n      p { +\u0026#34;Your win rate is ${100 * wins / (wins + losses)}%\u0026#34; }\n\n      if (incompleteGames.isNotEmpty()) {\n        p {\n          +\u0026#34;You\u0026#39;ve got games to finish with \u0026#34;\n          for (game in incompleteGames) {\n            a(href = \u0026#34;https://publicobject.com/chess/game/${game.id}\u0026#34;) {\n              +game.opponent_username\n            }\n          }\n        }\n      }\n    }\n\n    emailSender.sendEmail(\n      emailAddress = emailAddress,\n      subject = \u0026#34;Your Chess summary for ${from.month}\u0026#34;,\n      body = message,\n    )\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI’ve written tons of code like this. This is how the first draft comes out when I build software: gather inputs, make decisions, and perform actions.\u003c/p\u003e\u003cp\u003eBut I don’t like this code! I don’t like testing it and I don’t like changing it.\u003c/p\u003e\u003cp\u003eI don’t like what happens in the unit test for customers that haven’t played any games. With this structure, that test needs to assert that \u003ccode\u003eEmailSender.sendEmail()\u003c/code\u003e is never called. That feels weird!\u003c/p\u003e\u003cp\u003eLet’s borrow some ideas from the functional programming nerds and refactor this thing. I like to separate the code that \u003cem\u003emakes\u003c/em\u003e decisions from the code that \u003cem\u003eeffects\u003c/em\u003e those decisions.\u003c/p\u003e\u003ch3 id=\"decisions\"\u003eDecisions\u003c/h3\u003e\u003cp\u003eThis is a value object – or a hierarchy of value objects – that describe the action to take.\u003c/p\u003e\u003cp\u003eI call this a \u003ccode\u003eDecision\u003c/code\u003e, \u003ccode\u003ePlan\u003c/code\u003e or \u003ccode\u003eAction\u003c/code\u003e and use that word as a suffix.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003esealed interface MonthlyEmailDecision\n\nobject SkipReportNoEmailAddress : MonthlyEmailDecision\n\nobject SkipReportNoGamesPlayed : MonthlyEmailDecision\n\ndata class SendPlayReport(\n  val emailAddress: String,\n  val month: Month,\n  val wins: Long,\n  val losses: Long,\n  val incompleteGames: List\u0026lt;IncompleteGame\u0026gt;,\n) : MonthlyEmailDecision {\n  data class IncompleteGame(\n    val gameId: GameId,\n    val opponentUsername: String,\n  )\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eKotlin’s rich type system is awesome for describing value objects like these. I enjoy it all: sealed types, data classes, objects, named \u0026amp; default parameters, and concise property declarations.\u003c/p\u003e\u003cp\u003eWhen I was writing Java full time, the amount of boilerplate required to model something like this was prohibitive! But in 2024 Java is better now too.\u003c/p\u003e\u003cp\u003eI’ll extract a \u003ccode\u003eDecision\u003c/code\u003e object after writing it the wrong way first.\u003c/p\u003e\u003ch3 id=\"deciders\"\u003eDeciders\u003c/h3\u003e\u003cp\u003eThis is a service that makes a decision. It gathers input data that it needs to make a decision, but doesn’t act upon that decision. It’s the code base’s chief analyst.\u003c/p\u003e\u003cp\u003eI’ll use the suffix \u003ccode\u003eDecider\u003c/code\u003e or a \u003ccode\u003ePlanner\u003c/code\u003e on these.\u003c/p\u003e\u003cp\u003eI don’t let any side-effects into these. I don’t even like logging here. That way I can use it to dry-run decisions: \u003cem\u003e‘how would our email volume change if we notified everyone who’s played in the last 90 days?’\u003c/em\u003e From the perspective of the decider, its decision making could be hypothetical!\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MonthlySummaryDecider(\n  val db: ChessDatabase,\n) {\n  fun decide(playerId: PlayerId, month: Int, year: Int): MonthlyEmailDecision {\n    val player = db.playerQueries.selectPlayer(playerId).executeAsOne()\n    val emailAddress = player.email_address ?: return SkipReportNoEmailAddress\n\n    val from = LocalDateTime.of(year, month, 1, 0, 0)\n    val until = from.plusMonths(1)\n\n    val (wins, losses) = db.gameQueries\n      .selectWinsAndLosses(\n        player_id = playerId,\n        from = from.atZone(player.zone_id).toInstant(),\n        until = until.atZone(player.zone_id).toInstant(),\n      )\n      .executeAsOne()\n\n    if (wins == 0L \u0026amp;\u0026amp; losses == 0L) return SkipReportNoGamesPlayed\n\n    val incompleteGames = db.gameQueries\n      .selectIncompleteGames(playerId)\n      .executeAsList()\n\n    return SendPlayReport(\n      emailAddress = emailAddress,\n      month = from.month,\n      wins = wins,\n      losses = losses,\n      incompleteGames = incompleteGames.map {\n        SendPlayReport.IncompleteGame(it.id, it.opponent_username)\n      },\n    )\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis implementation isn’t strictly functional! It makes DB queries which means I’ll use a real database when I test it. I’m okay with that, especially since that gives me coverage for my \u003ca href=\"https://cashapp.github.io/sqldelight/\"\u003efancy SQL\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"executors\"\u003eExecutors\u003c/h3\u003e\u003cp\u003eNow it’s time to take action. This is a service that takes a decision and makes it real. It sends messages, calls APIs, or positions widgets on the screen. It’s the code base’s dumb muscle.\u003c/p\u003e\u003cp\u003eI don’t have a beloved naming convention for these. Usually it’s something task-specific.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MonthlyEmailSender(\n  val emailSender: EmailSender,\n) {\n  fun execute(decision: MonthlyEmailDecision) {\n    when (decision) {\n      SkipReportNoEmailAddress,\n      SkipReportNoGamesPlayed -\u0026gt; return\n\n      is SendPlayReport -\u0026gt; {\n        val message = createHTML().body {\n          val wins = decision.wins\n          val losses = decision.losses\n          h1 { +\u0026#34;This month you won $wins games!\u0026#34; }\n          p { +\u0026#34;Your win rate is ${100 * wins / (wins + losses)}%\u0026#34; }\n\n          if (decision.incompleteGames.isNotEmpty()) {\n            p {\n              +\u0026#34;You\u0026#39;ve got games to finish with \u0026#34;\n              for (game in decision.incompleteGames) {\n                a(href = \u0026#34;https://publicobject.com/chess/game/${game.gameId}\u0026#34;) {\n                  +game.opponentUsername\n                }\n              }\n            }\n          }\n        }\n\n        emailSender.sendEmail(\n          emailAddress = decision.emailAddress,\n          subject = \u0026#34;Your Chess summary for ${decision.month}\u0026#34;,\n          body = message,\n        )\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis particular executor is still too smart! If you’re asked to code review the above code, tell the author to extract a \u003ccode\u003eMonthlyEmailMessageFormatter\u003c/code\u003e class too.\u003c/p\u003e\u003ch3 id=\"optimistic-locking-and-transactions\"\u003eOptimistic Locking and Transactions\u003c/h3\u003e\u003cp\u003eThis approach breaks atomicity between making decisions and acting upon them. It’s clumsy and awkward to put a database transaction that spans the decide and execute parts.\u003c/p\u003e\u003cp\u003eI tend to give in and add optimistic locking metadata to my decision models. I’ll add an idempotence token or row version to the value object and let the execution step fail if these invariants have changed.\u003c/p\u003e\u003ch3 id=\"decisions-in-distributed-systems\"\u003eDecisions in Distributed Systems\u003c/h3\u003e\u003cp\u003eOn the services I’ve worked on, sometimes one microservice wants to collect \u0026amp; process data from another microservice. Decision objects are quite helpful here! Publish ’em on your event bus thing, possibly with extra context on what the inputs were that lead to each decision.\u003c/p\u003e\u003ch3 id=\"more-code-to-write-easier-to-read\"\u003eMore Code to Write, Easier to Read\u003c/h3\u003e\u003cp\u003eIf I get another programming tattoo, it’ll be this gem from \u003ca href=\"http://blog.wilshipley.com/\"\u003eWil Shipley\u003c/a\u003e:\u003c/p\u003e\u003cblockquote\u003eLess code is better code\u003cbr/\u003e∴ No code is the best code\u003c/blockquote\u003e\u003cp\u003eBut by introducing a decision object, we’ve added more code. Fortunately, when you read the (small) decision model code, you learn how the larger decider and executor code must work.\u003c/p\u003e\u003cp\u003eI’m okay with this.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2024-03-10T19:09:46Z",
  "modifiedTime": "2024-03-15T02:18:50Z"
}
