{
  "id": "66770852-a2c2-4edf-becc-818fbb3caada",
  "title": "Introducing Trio | Part I",
  "link": "https://medium.com/airbnb-engineering/introducing-trio-part-i-7f5017a1a903?source=rss----53c7c27702d5--android",
  "description": "",
  "author": "Eli Hart",
  "published": "Thu, 28 Mar 2024 17:02:32 GMT",
  "source": "https://medium.com/feed/airbnb-engineering/tagged/android",
  "categories": [
    "android",
    "mobile-app-development",
    "engineering",
    "jetpack-compose",
    "mobile"
  ],
  "byline": "Eli Hart",
  "length": 15679,
  "excerpt": "At Airbnb, we have developed an Android framework for Jetpack Compose screen architecture, which we call Trio. Trio is built on our open-source library Mavericks, which it leverages to maintain both…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "A three part series on how we built a Compose based architecture with Mavericks in the Airbnb Android appBy: Eli Hart, Ben Schwab, Yvonne WongAt Airbnb, we have developed an Android framework for Jetpack Compose screen architecture, which we call Trio. Trio is built on our open-source library Mavericks, which it leverages to maintain both navigation and application state within the ViewModel.Airbnb began development of Trio more than two years ago, and has been using it in production for over a year and a half. It is powering a significant portion of our production screens in Airbnb’s Android app, and has enabled our engineers to create features in 100% Compose UI.In this blog post series, we will look at how Mavericks can be used in modern, Compose based applications. We will discuss the challenges of Compose-based architecture and how Trio has attempted to solve them. This will include an exploration of concepts such as:Type-safe navigation between feature modulesStoring navigation state in a ViewModelCommunication between Compose-based screens, including opening screens for results and two-way communication between screensCompile-time validation of navigation and communication interfacesDeveloper tools created to support Trio workflowsThis series is split into three parts. Part 1 (this blog post) covers Trio’s high-level architecture. In Part 2 we detail Trio’s navigation system, and Part 3 examines how Trio uses Props for communication between screens.Background on MavericksTo understand Trio’s architecture, it’s important to know the basics of Mavericks, which Trio is built on top of. Airbnb originally open sourced Mavericks in 2018 to simplify and standardize how state is managed in a Jetpack ViewModel. Check out this post from the initial Mavericks (“MvRx”) launch for a deeper dive.Used in virtually all the hundreds of screens in Airbnb’s Android app (and by many other companies too!), Mavericks is a state management library that is decoupled from the UI, and can be used with any UI system. The core concept is that screen UI is modeled as a function of state. This ensures that even the most complex screen can be rendered in a way that’s thread safe, independent of the order of events leading up to it, and easy to reason about and test.To achieve this, Mavericks enforces the pattern that all data exposed by the ViewModel must be contained within a single MavericksState data class. In a simple Counter example, the state would contain the current count.data class CounterState( val count: Int = 0) : MavericksStateState properties can only be updated in the ViewModel via calls to setState. The setState function takes a “reducer” lambda, which, given a previous state, outputs a new state. We can use a reducer to increment the count by simply adding 1 to the previous value.class CounterViewModel : MavericksViewModel\u003cCounterState\u003e(...) { fun incrementCount() { setState { // this = previous state this.copy(count = count + 1) } }}The base MavericksViewModel enqueues all calls to setState and runs them serially in a background thread. This guarantees thread safety when changes are made in multiple places at once, and ensures that changes to multiple properties in the state are atomic, so the UI never sees a state that is only partially updated.MavericksViewModel exposes state changes via a coroutine Flow property. When paired with reactive UI, like Compose, we can collect the latest state value and guarantee that the UI is updated with every state change.counterViewModel.stateFlow.collectAsState().countThis unidirectional cycle can be visualized with the following diagram:Challenges with Fragment-based architectureWhile Mavericks works well for state management, we were still experiencing some challenges with Android UI development, stemming from the fact that we were using a Fragment-based architecture integrated with Mavericks. With this approach, ViewModels are mainly scoped to the Activity and shared between Fragments via injection. Fragment views are updated by state changes from the ViewModel, and call back to the ViewModel to make state changes. The Fragment Manager manages navigation independently when Fragments need to be pushed or popped.Due to this architecture, we were running up against some ongoing difficulties, which became the motivation for building Trio.Scoping — Sharing ViewModels between multiple Fragments relies on the implicit injection of the ViewModel. Thus, it isn’t clear which Fragment is responsible for creating the Activity ViewModel originally, or for providing the initial arguments to it.Communication — It’s difficult to share data between Fragments directly and with type safety. Again, because ViewModels are injected, it’s hard to have them communicate directly, and we don’t have good control over the ordering of their creation.Navigation — Navigation is done via the Fragment Manager and must happen in the Fragment. However, state changes are done in the ViewModel. This leads to synchronization problems between ViewModel and navigation states. It’s hard to coordinate if-then scenarios like making a navigation call only after updating a state value in the ViewModel.Testability — It’s difficult to isolate the UI for testing because it is wrapped in the Fragment. Screenshot tests are prone to flakiness and a lot of indirection is required for mocking the ViewModel state, because ViewModels are injected into the Fragment with property delegates.Reactivity — Mavericks provides a unidirectional state flow to the View, which is helpful for consistency and testing, but the View system doesn’t lend itself well to reactive updates to state changes, and it can be difficult or inefficient to update the view incrementally on each state change.While some of these problems could have been mitigated by using a better Fragment based architecture, we found that Fragments were overall too limiting with Compose and decided to move away from them entirely.Why we built TrioIn 2021, our team began to explore adopting Jetpack Compose and completely transitioning away from Fragments. By fully embracing Compose, we could better prepare ourselves for future Android developments and eliminate years of accumulated tech debt.Continuing to use Mavericks was important to us because we have a large amount of internal experience with it, and we didn’t want to further complicate an architectural migration by also changing our state management approach. We saw an opportunity to rethink how Mavericks could support a modern Android application, and address problems we encountered with our previous architectureWith Fragments, we struggled to guarantee type safe communication between screens at runtime. We wanted to be able to codify the expectations about how ViewModels are used and shared, and what interfaces look like between screens.We also didn’t feel our needs were fully met by the Jetpack Navigation component, especially given our heavily modularized code base and large app. The Navigation component is not type safe, requires defining the navigation graph in a single place, and doesn’t allow us to co-locate state in our ViewModel. We looked for a new architecture that could provide better type safety and modularization support.Finally, we wanted an architecture that would improve testability, such as more stable screenshot and UI tests, and simpler navigation testing.We considered the open source libraries Workflow and RIBs, but opted not to use them because they were not Compose-first and were not compatible with Mavericks and our other pre-existing internal frameworks.Given these requirements, our decision was to develop our own solution, which we named Trio.Trio ArchitectureTrio is an opinionated framework for building features. It helps us to define and manage boundaries and state in Compose UI. Trio also standardizes how state is hoisted from Compose UI and how events are handled, enforcing unidirectional data flow with Mavericks. The design was inspired by Square’s Workflow library; Trio differs in that it was designed specifically for Compose and uses Mavericks ViewModels for managing state and events.Self-contained blocks are called “Trios”, named for the three main classes they contain. Each Trio has its own ViewModel, State, and UI, and can communicate with and be nested in other Trios. The following diagram represents how these components work together. The ViewModel makes changes to state via Mavericks reducers, the UI receives the latest state value to render, and events are routed back to the ViewModel for further state updates.If you’re already familiar with Mavericks this pattern should look very similar! The ViewModel and State usage is very similar to what we did with Fragments. What’s new is how we embed the ViewModels in Compose UI and add Routing and Props based communication via Trio.Trios are nested to form custom, flexible navigation hierarchies. “Parent” Trios create child Trios with initial arguments through a Router, and store those children in their State. The parent can then communicate dynamically with its children through a flow of Props, which provide data, dependencies, and functional callbacks.The framework helps us to guarantee type safety when navigating and communicating between Trios, especially across module boundaries.Each Trio can be tested individually by instantiating it with mocked arguments, State, and Props. Coupled with Compose’s state-based rendering and Maverick’s immutable state patterns, this provides controlled and deterministic testing environments.The Trio ClassCreating a new Trio implementation requires subclassing the Trio base class. The Trio class is typed to define Args, Props, State, ViewModel, and UI; this allows us to guarantee type-safe navigation and inter-screen communication.class CounterScreen : Trio\u003c CounterArgs, CounterProps, CounterState, CounterViewModel, CounterUI\u003eA Trio is created with either an initial set of arguments or an initial state, which are wrapped in a sealed class called the Initializer. In production, the Initializer will only contain Args passed from another screen, but in development we can seed the Initializer with mock state so that the screen can be loaded standalone, independent of the normal navigation hierarchy.class CounterScreen( initializer: Initializer\u003cCounterArgs, CounterState\u003e) Then, in our subclass body, we define how we want to create our State, ViewModel, and UI, given the starting values of Args and Props.Args and Props both provide input data, with the difference being that Args are static while Props are dynamic. Args guarantee the stability of static information, such as IDs used to start a screen, while Props allow us to subscribe to data that may change over time.override fun createInitialState(args: CounterArgs, props: CounterProps) { return CounterState(args.count)}Trio provides an initializer to create a new ViewModel instance, passing necessary information like the Trio’s unique ID, a Flow of Props, and a reference to the parent Activity. Dependencies from the application’s dependency graph can also be also passed to the ViewModel through its constructor.override fun createViewModel( initializer: Initializer\u003cCounterProps, CounterState\u003e) { return CounterViewModel(initializer)}Finally, the UI class wraps the composable code used to render the Trio. The UI class receives a flow of the latest State from the ViewModel, and also uses the ViewModel reference to call back to it when handling UI events.override fun createUI(viewModel: CounterViewModel ): CounterUI { return CounterUI(viewModel)}We like that grouping all of these factory functions in the Trio class makes it explicit how each class is created, and standardizes where to look to understand dependencies. However, it can also feel like boilerplate. As an improvement, we often use reflection to create the UI class, and we use assisted inject to automate creation of the ViewModel with Dagger dependencies.The resulting Trio declaration as a whole looks like this:class CounterScreen( initializer: Initializer\u003cCounterArgs, CounterState\u003e) : Trio\u003c CounterArgs, CounterProps, CounterState, CounterViewModel, CounterUI\u003e(initializer) { override fun createInitialState(CounterArgs, CounterProps) { return CounterState(args.count) }}The UI ClassThe Trio’s UI class implements a single Composable function named “Content”, which determines the UI that the Trio shows. Additionally, the Content function has a “TrioRenderScope” receiver type. This is a Compose animation scope that allows us to customize the Trio’s animations when it is displayed.class CounterUI( override val viewModel: CounterViewModel) : UI\u003cCounterState, CounterViewModel\u003e { @Composable override fun TrioRenderScope.Content(state: CounterState) { Column { TopAppBar() Button( text = state.count, modifier = Modifier.clickable { viewModel.incrementCount() } ) ... } }}The Content function is recomposed every time the State from the ViewModel changes. The UI directs all UI events, such as clicks, back to the ViewModel for handling.This design enforces unidirectional data flow, and testing the UI is easy because it is decoupled from the logic of state changes and event handling. It also standardizes how Compose state is hoisted for consistency across screens, while removing the boilerplate of setting up access to the ViewModel’s state flow.Rendering a TrioGiven a Trio instance, we can render it by invoking its Content function, which uses the previously mentioned factory functions to create initial values of the ViewModel, State, and UI. The state flow is collected from the ViewModel and passed to the UI’s Content function. The UI is wrapped in a Box to respect the constraints and modifier of the caller.@Composableinternal fun TrioRenderScope.Content(modifier: Modifier = Modifier) { key(trioId) { val activity = LocalContext.current as ComponentActivity val viewModel = remember { getOrCreateViewModel(activity) } val ui = remember { createUI(viewModel) } val state = viewModel.stateFlow .collectAsState(viewModel.currentState).value Box(propagateMinConstraints = true, modifier = modifier) { ui.Content(state = state) } }}To enable customizing entry and exit animations, the Content function also uses a TrioRenderScope receiver; this wraps an implementation of Compose’s AnimatedVisibilityScope which displays the Content. A helper function is used to coordinate this.@Composablefun ShowTrio(trio: Trio, modifier: Modifier) { AnimatedVisibility( visible = true, enter = EnterTransition.None, exit = ExitTransition.None ) { val animationScope = TrioRenderScopeImpl(this) trio.Content(modifier, animationScope) }}In practice, the actual implementation of Trio.Content is quite a bit more complex because of additional tooling and edge cases we want to support — such as tracking the Trio’s lifecycle, managing saved state, and mocking the ViewModel when shown within a screenshot test or IDE preview.ConclusionIn this introduction to Trio we discussed Airbnb’s background with Mavericks and Fragments, and why we built Trio to transition to a Jetpack Compose-based architecture. We presented an overview of Trio’s architecture, and looked at core components such as the Trio class and UI class.In part 2 of this series you will see how navigation works with Trio, and in part 3 we will learn how Trio’s Props allow dynamic communication between screens. And if this work sounds interesting to you, check out open roles at Airbnb!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*Iiod_-uJ2bHY5BSbXyStfg.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"628f\"\u003eA three part series on how we built a Compose based architecture with Mavericks in the Airbnb Android app\u003c/h2\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@konakid?source=post_page-----7f5017a1a903--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Eli Hart\" src=\"https://miro.medium.com/v2/resize:fill:88:88/2*qR91fuLzUz5PI59hjTTcRQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/airbnb-engineering?source=post_page-----7f5017a1a903--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"The Airbnb Tech Blog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*MlNQKg-sieBGW5prWoe9HQ.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"e5e1\"\u003e\u003cstrong\u003eBy:\u003c/strong\u003e \u003ca href=\"https://www.linkedin.com/in/eli-hart-54a4b975/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eEli Hart\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/schwabben/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBen Schwab\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/yvonnejwong\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eYvonne Wong\u003c/a\u003e\u003c/p\u003e\u003cp id=\"ff65\"\u003eAt Airbnb, we have developed an Android framework for Jetpack Compose screen architecture, which we call Trio. Trio is built on our open-source library Mavericks, which it leverages to maintain both navigation and application state within the ViewModel.\u003c/p\u003e\u003cp id=\"80be\"\u003eAirbnb began development of Trio more than two years ago, and has been using it in production for over a year and a half. It is powering a significant portion of our production screens in Airbnb’s Android app, and has enabled our engineers to create features in 100% Compose UI.\u003c/p\u003e\u003cp id=\"839e\"\u003eIn this blog post series, we will look at how Mavericks can be used in modern, Compose based applications. We will discuss the challenges of Compose-based architecture and how Trio has attempted to solve them. This will include an exploration of concepts such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bba6\"\u003eType-safe navigation between feature modules\u003c/li\u003e\u003cli id=\"8bd4\"\u003eStoring navigation state in a ViewModel\u003c/li\u003e\u003cli id=\"8d8d\"\u003eCommunication between Compose-based screens, including opening screens for results and two-way communication between screens\u003c/li\u003e\u003cli id=\"aef3\"\u003eCompile-time validation of navigation and communication interfaces\u003c/li\u003e\u003cli id=\"4e16\"\u003eDeveloper tools created to support Trio workflows\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c4fd\"\u003eThis series is split into three parts. Part 1 (this blog post) covers Trio’s high-level architecture. In \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-trio-part-ii-fe836013a798\"\u003ePart 2\u003c/a\u003e we detail Trio’s navigation system, and \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-trio-part-iii-033fbfe2171b\"\u003ePart 3\u003c/a\u003e examines how Trio uses Props for communication between screens.\u003c/p\u003e\u003ch2 id=\"0db4\"\u003eBackground on Mavericks\u003c/h2\u003e\u003cp id=\"5ef0\"\u003eTo understand Trio’s architecture, it’s important to know the basics of Mavericks, which Trio is built on top of. Airbnb originally open sourced \u003ca href=\"https://github.com/airbnb/mavericks\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMavericks\u003c/a\u003e in 2018 to simplify and standardize how state is managed in a Jetpack ViewModel. Check out \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-mvrx-android-on-autopilot-552bca86bd0a\"\u003ethis post\u003c/a\u003e from the initial Mavericks (“MvRx”) launch for a deeper dive.\u003c/p\u003e\u003cp id=\"f82f\"\u003eUsed in virtually all the hundreds of screens in Airbnb’s Android app (and by many other companies too!), Mavericks is a state management library that is decoupled from the UI, and can be used with any UI system. The core concept is that screen UI is modeled as a function of state. This ensures that even the most complex screen can be rendered in a way that’s thread safe, independent of the order of events leading up to it, and easy to reason about and test.\u003c/p\u003e\u003cp id=\"4f41\"\u003eTo achieve this, Mavericks enforces the pattern that all data exposed by the ViewModel must be contained within a single MavericksState data class. In a simple Counter example, the state would contain the current count.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8bfb\"\u003edata class CounterState(\u003cbr/\u003e  val count: Int = 0\u003cbr/\u003e) : MavericksState\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f1e3\"\u003eState properties can only be updated in the ViewModel via calls to \u003ccode\u003esetState\u003c/code\u003e. The \u003ccode\u003esetState\u003c/code\u003e function takes a “reducer” lambda, which, given a previous state, outputs a new state. We can use a reducer to increment the count by simply adding 1 to the previous value.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"baa9\"\u003eclass CounterViewModel : MavericksViewModel\u0026lt;CounterState\u0026gt;(...) {\u003cbr/\u003e  fun incrementCount() {\u003cbr/\u003e    setState {\u003cbr/\u003e      // this = previous state\u003cbr/\u003e      this.copy(count = count + 1)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2203\"\u003eThe base \u003ccode\u003eMavericksViewModel\u003c/code\u003e enqueues all calls to \u003ccode\u003esetState\u003c/code\u003e and runs them serially in a background thread. This guarantees thread safety when changes are made in multiple places at once, and ensures that changes to multiple properties in the state are atomic, so the UI never sees a state that is only partially updated.\u003c/p\u003e\u003cp id=\"0620\"\u003e\u003ccode\u003eMavericksViewModel\u003c/code\u003e exposes state changes via a coroutine \u003ccode\u003eFlow\u003c/code\u003e property. When paired with reactive UI, like Compose, we can collect the latest state value and guarantee that the UI is updated with every state change.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"50bb\"\u003ecounterViewModel.stateFlow.collectAsState().count\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc95\"\u003eThis unidirectional cycle can be visualized with the following diagram:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c777\"\u003eChallenges with Fragment-based architecture\u003c/h2\u003e\u003cp id=\"c4a8\"\u003eWhile Mavericks works well for state management, we were still experiencing some challenges with Android UI development, stemming from the fact that we were using a \u003ca href=\"https://developer.android.com/reference/android/app/Fragment\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFragment\u003c/a\u003e-based architecture integrated with Mavericks. With this approach, ViewModels are mainly scoped to the Activity and shared between Fragments via injection. Fragment views are updated by state changes from the ViewModel, and call back to the ViewModel to make state changes. The Fragment Manager manages navigation independently when Fragments need to be pushed or popped.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5b44\"\u003eDue to this architecture, we were running up against some ongoing difficulties, which became the motivation for building Trio.\u003c/p\u003e\u003col\u003e\u003cli id=\"c81e\"\u003e\u003cstrong\u003eScoping\u003c/strong\u003e — Sharing ViewModels between multiple Fragments relies on the implicit injection of the ViewModel. Thus, it isn’t clear which Fragment is responsible for creating the Activity ViewModel originally, or for providing the initial arguments to it.\u003c/li\u003e\u003cli id=\"4282\"\u003e\u003cstrong\u003eCommunication\u003c/strong\u003e — It’s difficult to share data between Fragments directly and with type safety. Again, because ViewModels are injected, it’s hard to have them communicate directly, and we don’t have good control over the ordering of their creation.\u003c/li\u003e\u003cli id=\"4a8f\"\u003e\u003cstrong\u003eNavigation\u003c/strong\u003e — Navigation is done via the Fragment Manager and must happen in the Fragment. However, state changes are done in the ViewModel. This leads to synchronization problems between ViewModel and navigation states. It’s hard to coordinate if-then scenarios like making a navigation call only after updating a state value in the ViewModel.\u003c/li\u003e\u003cli id=\"ef8e\"\u003e\u003cstrong\u003eTestability\u003c/strong\u003e — It’s difficult to isolate the UI for testing because it is wrapped in the Fragment. Screenshot tests are prone to flakiness and a lot of indirection is required for mocking the ViewModel state, because ViewModels are injected into the Fragment with property delegates.\u003c/li\u003e\u003cli id=\"0212\"\u003e\u003cstrong\u003eReactivity\u003c/strong\u003e — Mavericks provides a unidirectional state flow to the View, which is helpful for consistency and testing, but the View system doesn’t lend itself well to reactive updates to state changes, and it can be difficult or inefficient to update the view incrementally on each state change.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"5eeb\"\u003eWhile some of these problems could have been mitigated by using a better Fragment based architecture, we found that Fragments were overall too limiting with Compose and decided to move away from them entirely.\u003c/p\u003e\u003ch2 id=\"82f1\"\u003eWhy we built Trio\u003c/h2\u003e\u003cp id=\"cd45\"\u003eIn 2021, our team began to explore \u003ca href=\"https://android-developers.googleblog.com/2022/05/airbnb-uses-jetpack-compose.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eadopting Jetpack Compose\u003c/a\u003e and completely transitioning away from Fragments. By fully embracing Compose, we could better prepare ourselves for future Android developments and eliminate years of accumulated tech debt.\u003c/p\u003e\u003cp id=\"5490\"\u003eContinuing to use Mavericks was important to us because we have a large amount of internal experience with it, and we didn’t want to further complicate an architectural migration by also changing our state management approach. We saw an opportunity to rethink how Mavericks could support a modern Android application, and address problems we encountered with our previous architecture\u003c/p\u003e\u003cp id=\"5932\"\u003eWith Fragments, we struggled to guarantee type safe communication between screens at runtime. We wanted to be able to codify the expectations about how ViewModels are used and shared, and what interfaces look like between screens.\u003c/p\u003e\u003cp id=\"07f3\"\u003eWe also didn’t feel our needs were fully met by the Jetpack Navigation component, especially given our heavily modularized code base and large app. The Navigation component is \u003ca href=\"https://developer.android.com/jetpack/compose/navigation#type-safety\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enot type safe\u003c/a\u003e, requires defining the navigation graph in a single place, and doesn’t allow us to co-locate state in our ViewModel. We looked for a new architecture that could provide better type safety and modularization support.\u003c/p\u003e\u003cp id=\"c2fd\"\u003eFinally, we wanted an architecture that would improve testability, such as more stable screenshot and UI tests, and simpler navigation testing.\u003c/p\u003e\u003cp id=\"a3cc\"\u003eWe considered the open source libraries Workflow and RIBs, but opted not to use them because they were not Compose-first and were not compatible with Mavericks and our other pre-existing internal frameworks.\u003c/p\u003e\u003cp id=\"6702\"\u003eGiven these requirements, our decision was to develop our own solution, which we named Trio.\u003c/p\u003e\u003ch2 id=\"6924\"\u003eTrio Architecture\u003c/h2\u003e\u003cp id=\"0953\"\u003eTrio is an opinionated framework for building features. It helps us to define and manage boundaries and state in Compose UI. Trio also standardizes how state is hoisted from Compose UI and how events are handled, enforcing unidirectional data flow with Mavericks. The design was inspired by Square’s \u003ca href=\"https://github.com/square/workflow\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWorkflow\u003c/a\u003e library; Trio differs in that it was designed specifically for Compose and uses Mavericks ViewModels for managing state and events.\u003c/p\u003e\u003cp id=\"1f2e\"\u003eSelf-contained blocks are called “Trios”, named for the three main classes they contain. Each Trio has its own ViewModel, State, and UI, and can communicate with and be nested in other Trios. The following diagram represents how these components work together. The ViewModel makes changes to state via Mavericks reducers, the UI receives the latest state value to render, and events are routed back to the ViewModel for further state updates.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7bf1\"\u003eIf you’re already familiar with Mavericks this pattern should look very similar! The ViewModel and State usage is very similar to what we did with Fragments. What’s new is how we embed the ViewModels in Compose UI and add Routing and Props based communication via Trio.\u003c/p\u003e\u003cp id=\"8a72\"\u003eTrios are nested to form custom, flexible navigation hierarchies. “Parent” Trios create child Trios with initial arguments through a Router, and store those children in their State. The parent can then communicate dynamically with its children through a flow of Props, which provide data, dependencies, and functional callbacks.\u003c/p\u003e\u003cp id=\"a171\"\u003eThe framework helps us to guarantee type safety when navigating and communicating between Trios, especially across module boundaries.\u003c/p\u003e\u003cp id=\"0572\"\u003eEach Trio can be tested individually by instantiating it with mocked arguments, State, and Props. Coupled with Compose’s state-based rendering and Maverick’s immutable state patterns, this provides controlled and deterministic testing environments.\u003c/p\u003e\u003ch2 id=\"5fb3\"\u003eThe Trio Class\u003c/h2\u003e\u003cp id=\"0ae4\"\u003eCreating a new Trio implementation requires subclassing the Trio base class. The Trio class is typed to define Args, Props, State, ViewModel, and UI; this allows us to guarantee type-safe navigation and inter-screen communication.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df3a\"\u003eclass CounterScreen : Trio\u0026lt;\u003cbr/\u003e  CounterArgs, \u003cbr/\u003e  CounterProps, \u003cbr/\u003e  CounterState,     \u003cbr/\u003e  CounterViewModel, \u003cbr/\u003e  CounterUI\u003cbr/\u003e\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8864\"\u003eA Trio is created with either an initial set of arguments or an initial state, which are wrapped in a sealed class called the Initializer. In production, the Initializer will only contain Args passed from another screen, but in development we can seed the Initializer with mock state so that the screen can be loaded standalone, independent of the normal navigation hierarchy.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"971d\"\u003eclass CounterScreen(\u003cbr/\u003e  initializer: Initializer\u0026lt;CounterArgs, CounterState\u0026gt;\u003cbr/\u003e) \u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a5ec\"\u003eThen, in our subclass body, we define how we want to create our State, ViewModel, and UI, given the starting values of Args and Props.\u003c/p\u003e\u003cp id=\"e112\"\u003eArgs and Props both provide input data, with the difference being that Args are static while Props are dynamic. Args guarantee the stability of static information, such as IDs used to start a screen, while Props allow us to subscribe to data that may change over time.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4404\"\u003eoverride fun createInitialState(args: CounterArgs, props:  CounterProps) {\u003cbr/\u003e  return CounterState(args.count)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cd66\"\u003eTrio provides an initializer to create a new ViewModel instance, passing necessary information like the Trio’s unique ID, a Flow of Props, and a reference to the parent Activity. Dependencies from the application’s dependency graph can also be also passed to the ViewModel through its constructor.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4a5b\"\u003eoverride fun createViewModel(\u003cbr/\u003e  initializer: Initializer\u0026lt;CounterProps, CounterState\u0026gt;\u003cbr/\u003e) {\u003cbr/\u003e  return CounterViewModel(initializer)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8652\"\u003eFinally, the UI class wraps the composable code used to render the Trio. The UI class receives a flow of the latest State from the ViewModel, and also uses the ViewModel reference to call back to it when handling UI events.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ce44\"\u003eoverride fun createUI(viewModel: CounterViewModel ): CounterUI {\u003cbr/\u003e  return CounterUI(viewModel)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c3a2\"\u003eWe like that grouping all of these factory functions in the Trio class makes it explicit how each class is created, and standardizes where to look to understand dependencies. However, it can also feel like boilerplate. As an improvement, we often use reflection to create the UI class, and we use assisted inject to automate creation of the ViewModel with Dagger dependencies.\u003c/p\u003e\u003cp id=\"118b\"\u003eThe resulting Trio declaration as a whole looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4b81\"\u003eclass CounterScreen(\u003cbr/\u003e  initializer: Initializer\u0026lt;CounterArgs, CounterState\u0026gt;\u003cbr/\u003e) : Trio\u0026lt;\u003cbr/\u003e  CounterArgs, \u003cbr/\u003e  CounterProps, \u003cbr/\u003e  CounterState,     \u003cbr/\u003e  CounterViewModel, \u003cbr/\u003e  CounterUI\u003cbr/\u003e\u0026gt;(initializer) {\u003cp\u003e  override fun createInitialState(CounterArgs, CounterProps) {\u003cbr/\u003e    return CounterState(args.count)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"3303\"\u003eThe UI Class\u003c/h2\u003e\u003cp id=\"cc00\"\u003eThe Trio’s UI class implements a single Composable function named “Content”, which determines the UI that the Trio shows. Additionally, the Content function has a “TrioRenderScope” receiver type. This is a Compose animation scope that allows us to customize the Trio’s animations when it is displayed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1c08\"\u003eclass CounterUI(\u003cbr/\u003e  override val viewModel: CounterViewModel\u003cbr/\u003e) : UI\u0026lt;CounterState, CounterViewModel\u0026gt; {\u003cp\u003e     @Composable\u003cbr/\u003e  override fun TrioRenderScope.Content(state: CounterState) {\u003cbr/\u003e    Column {\u003cbr/\u003e      TopAppBar()\u003cbr/\u003e      Button(\u003cbr/\u003e        text = state.count,\u003cbr/\u003e        modifier = Modifier.clickable {\u003cbr/\u003e          viewModel.incrementCount()\u003cbr/\u003e        }\u003cbr/\u003e      )\u003cbr/\u003e      ...\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c94d\"\u003eThe Content function is recomposed every time the State from the ViewModel changes. The UI directs all UI events, such as clicks, back to the ViewModel for handling.\u003c/p\u003e\u003cp id=\"e724\"\u003eThis design enforces unidirectional data flow, and testing the UI is easy because it is decoupled from the logic of state changes and event handling. It also standardizes how Compose state is hoisted for consistency across screens, while removing the boilerplate of setting up access to the ViewModel’s state flow.\u003c/p\u003e\u003ch2 id=\"b702\"\u003eRendering a Trio\u003c/h2\u003e\u003cp id=\"7e8c\"\u003eGiven a Trio instance, we can render it by invoking its \u003ccode\u003eContent\u003c/code\u003e function, which uses the previously mentioned factory functions to create initial values of the ViewModel, State, and UI. The state flow is collected from the ViewModel and passed to the UI’s Content function. The UI is wrapped in a Box to respect the constraints and modifier of the caller.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a06e\"\u003e@Composable\u003cbr/\u003einternal fun TrioRenderScope.Content(modifier: Modifier = Modifier) {\u003cbr/\u003e  key(trioId) {\u003cbr/\u003e    val activity = LocalContext.current as ComponentActivity\u003cp\u003e    val viewModel = remember {\u003cbr/\u003e      getOrCreateViewModel(activity)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    val ui = remember { createUI(viewModel) }\u003c/p\u003e\u003cp\u003e    val state = viewModel.stateFlow\u003cbr/\u003e                    .collectAsState(viewModel.currentState).value\u003c/p\u003e\u003cp\u003e    Box(propagateMinConstraints = true, modifier = modifier) {\u003cbr/\u003e      ui.Content(state = state)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5f7d\"\u003eTo enable customizing entry and exit animations, the Content function also uses a \u003ccode\u003eTrioRenderScope\u003c/code\u003e receiver; this wraps an implementation of Compose’s \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedVisibilityScope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAnimatedVisibilityScope\u003c/a\u003e which displays the Content. A helper function is used to coordinate this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0722\"\u003e@Composable\u003cbr/\u003efun ShowTrio(trio: Trio, modifier: Modifier) {\u003cbr/\u003e  AnimatedVisibility(\u003cbr/\u003e    visible = true,\u003cbr/\u003e    enter = EnterTransition.None,\u003cbr/\u003e    exit = ExitTransition.None\u003cbr/\u003e  ) {\u003cbr/\u003e    val animationScope = TrioRenderScopeImpl(this)\u003cbr/\u003e    trio.Content(modifier, animationScope)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0410\"\u003eIn practice, the actual implementation of \u003ccode\u003eTrio.Content\u003c/code\u003e is quite a bit more complex because of additional tooling and edge cases we want to support — such as tracking the Trio’s lifecycle, managing saved state, and mocking the ViewModel when shown within a screenshot test or IDE preview.\u003c/p\u003e\u003ch2 id=\"d19a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"8632\"\u003eIn this introduction to Trio we discussed Airbnb’s background with Mavericks and Fragments, and why we built Trio to transition to a Jetpack Compose-based architecture. We presented an overview of Trio’s architecture, and looked at core components such as the Trio class and UI class.\u003c/p\u003e\u003cp id=\"dcf6\"\u003eIn \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-trio-part-ii-fe836013a798\"\u003epart 2\u003c/a\u003e of this series you will see how navigation works with Trio, and in \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-trio-part-iii-033fbfe2171b\"\u003epart 3\u003c/a\u003e we will learn how Trio’s Props allow dynamic communication between screens. And if this work sounds interesting to you, check out \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eopen roles\u003c/a\u003e at Airbnb!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-03-28T17:02:31.707Z",
  "modifiedTime": null
}
