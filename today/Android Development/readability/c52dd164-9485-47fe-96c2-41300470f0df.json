{
  "id": "c52dd164-9485-47fe-96c2-41300470f0df",
  "title": "Top-Level Constants vs Companion-Enclosed Constants Using Kotlin in Android",
  "link": "https://proandroiddev.com/top-level-constants-vs-companion-enclosed-constants-using-kotlin-in-android-cbb067732428?source=rss----c72404660798---4",
  "description": "",
  "author": "Aung Thiha",
  "published": "Thu, 06 Feb 2025 00:47:35 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "bytecode",
    "android",
    "kotlin",
    "android-app-development",
    "androiddev"
  ],
  "byline": "Aung Thiha",
  "length": 8427,
  "excerpt": "We often declare Kotlin constants in Android without giving them a second thought. Some use top-level constants while others wrap them inside a companion object. But does this choice affect…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Louis Tsai on UnsplashBackgroundWe often declare Kotlin constants in Android without giving them a second thought. Some use top-level constants while others wrap them inside a companion object. But does this choice affect performance, APK size, or memory usage? Let’s break it down by diving into the bytecode and R8 optimizations.Preparing the Codeconst val TOP_LEVEL_CONSTANT = \"TOP_LEVEL_CONSTANT\"class MainActivity : ComponentActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) println(TOP_LEVEL_CONSTANT) println(COMPANION_ENCLOSED_CONSTANT) } companion object { const val COMPANION_ENCLOSED_CONSTANT = \"COMPANION_ENCLOSED_CONSTANT\" }}We have top-level constant at the top and a companion object containing a constant at the bottom of MainActivity. The constants are used in onCreate.Decompiling the Class With Android StudioTo get the Java bytecode, we’ll simply go to the Tools menu in Android Studio -\u003e Kotlin -\u003e Show Kotlin Bytecode. A new pane showing Java bytecode will appear on the right.Since reading Java bytecode directly is complex, we’ll click the Decompile button in the pane to get a Java representation.public final class MainActivity extends ComponentActivity { @NotNull public static final Companion Companion = new Companion((DefaultConstructorMarker)null); @NotNull public static final String COMPANION_ENCLOSED_CONSTANT = \"COMPANION_ENCLOSED_CONSTANT\"; protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); String var2 = \"TOP_LEVEL_CONSTANT\"; System.out.println(var2); var2 = \"COMPANION_ENCLOSED_CONSTANT\"; System.out.println(var2); } public static final class Companion { private Companion() { } public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }}public final class MainActivityKt { @NotNull public static final String TOP_LEVEL_CONSTANT = \"TOP_LEVEL_CONSTANT\";}I removed the parts that aren’t relevant to our discussion to make it easy to read. Let’s break down the relevant parts. protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); String var2 = \"TOP_LEVEL_CONSTANT\"; System.out.println(var2); var2 = \"COMPANION_ENCLOSED_CONSTANT\"; System.out.println(var2); }Inside the onCreate method, we can see that the constants are inlined and that’s great.public final class MainActivityKt { @NotNull public static final String TOP_LEVEL_CONSTANT = \"TOP_LEVEL_CONSTANT\";}However, now we end up with a redundant MainActivityKt class that isn’t even used. This comes from the top-level constant and it increases the app size.public final class MainActivity extends ComponentActivity { @NotNull public static final Companion Companion = new Companion((DefaultConstructorMarker)null); @NotNull public static final String COMPANION_ENCLOSED_CONSTANT = \"COMPANION_ENCLOSED_CONSTANT\"; ... public static final class Companion { private Companion() { } public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }}With a companion-enclosed constant, it’s even worse. The companion object becomes a static inner class which gets instantiated during the outer class loading and assigned to a static field. This introduces unnecessary object creation and memory overhead.Relevance of D8 and R8It’s important to note that the Java code we looked at came from Java bytecode and Android does not run Java bytecode. The Java bytecode still needs to go through a dex compiler called D8 to turn into Dalvik bytecode that Android can run [1][2]. More importantly, our code hasn’t gone through R8 optimization yet. R8 optimization will remove unused code [3].Code shrinking (also known as tree shaking), is the process of removing code that R8 determines is not required at runtime. This process can greatly reduce your app’s size if, for example, your app includes many library dependencies but utilizes only a small part of their functionality.So, to apply R8, we can enable it in the project-level Gradle file (also known as root-level Gradle file).isMinifyEnabled = trueNext, we go to the Build menu of the Android Studio -\u003e Build APK(s) to build an APK that contains Dalvik bytecode.Decompiling the APK With Apktool and JadxNow that we got our APK ready, let’s see what happens when D8 and R8 are involved in the compilation process.So, to get the Dalvik bytecode from the APK, we’ll use apktool [4].Decompiled Dalvik BytecodeWe get these two files. Let’s see what’s inside each of them but first, to simplify our analysis, we need to translate the the Dalvik bytecode into Java representation. (If you wanna check the Dalvik bytecode, I’ve posted them here.)The easiest way to get the Java representation from smali files is to use jadx [5].public final class MainActivity$Companion { public /* synthetic */ MainActivity$Companion(DefaultConstructorMarker defaultConstructorMarker) { this(); } private MainActivity$Companion() { }}This is what we get for MainActivity$Companion.smali.Looking at the code, we now know that R8 doesn’t remove the static inner class derived from the companion object but what happened to MainActivityKt that comes from the top-level constant? Let’s look into MainActivity.smali to find out.public final class MainActivity extends ComponentActivity { public static final Companion Companion = new Companion((DefaultConstructorMarker) null); protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); System.out.println((Object) \"TOP_LEVEL_CONSTANT\"); System.out.println((Object) \"COMPANION_ENCLOSED_CONSTANT\"); }}MainActivityKt is not here either, so we can conclude that R8 removes it. This happens because nothing references MainActivityKt. So, R8 knows it’s unused. As for the static inner class derived from the companion object, because it’s referenced by MainActivity, R8 doesn’t remove it.Sharing Constants Across Different ClassesSometimes, you might wanna share the constants across different classes. For that, we can declare top-level constants in a dedicated file, now that we know classes generated for enclosing only constants are removed by R8 because they’re not referenced by any classes after the constants are inlined.Grouping Multiple Constants for ReadabilitySometimes, keeping all constants at one level is not enough. Sometimes, you might wanna group them for readability. Let’s see if grouping with singleton objects is a viable option.object MyConstants { const val FIRST_LEVEL = \"FIRST_LEVEL\" object NestConstants { const val SECOND_LEVEL = \"SECOND_LEVEL\" }}So, we create the MyConstants class and simply print the constants in MainActivity.We’ll also create HelloActivity, declare it in the manifest and make it use FIRST_LEVEL and SECOND_LEVEL. (I’ll leave out the code for HelloActivity to keep the article short.)Then, we’ll build the APK and use apktool to decompile it.Decompiled Dalvik Bytecode After Adding MyConstantsThis is all we get. MyConstants is gone. R8 can remove it for the same reason it can remove MainActivityKt. It’s because after inlining the constants from that class, the class is no longer referenced by any other class which helps R8 know it’s not used. (If you still wanna take a look at the smali files, I’ve posted them here.)ConclusionCompanion-enclosed Constants: Avoid them, as they generate redundant static inner class that introduces unnecessary object creation and memory overhead.Top-level Constants: Best for single-file usage.Shared Constants Across Multiple Classes: Use a dedicated file with top-level constants.Grouped Constants: Use singleton objects.R8 Optimization: Always enable isMinifyEnabled for production builds to benefit from code shrinking. R8 removes the enclosing classes of top-level, shared, and grouped constants because the classes are no longer referenced after the constants are inlined.Happy coding, everyone!Referenceshttps://source.android.com/docs/core/runtime [Accessed on: 6 Feb 2025]https://developer.android.com/tools/d8 [Accessed on: 6 Feb 2025]https://developer.android.com/build/shrink-code [Accessed on: 6 Feb 2025]https://apktool.org/ [Accessed on: 6 Feb 2025]https://github.com/skylot/jadx [Accessed on: 6 Feb 2025]",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*RtGlTLdx4Qffsl8M",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@AungThiha3?source=post_page---byline--cbb067732428--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Aung Thiha\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*xJwJr3ikr-5WFAI8nIdCyQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--cbb067732428--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@louis993546?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLouis Tsai\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9fcc\"\u003eBackground\u003c/h2\u003e\u003cp id=\"b6f0\"\u003eWe often declare Kotlin constants in Android without giving them a second thought. Some use top-level constants while others wrap them inside a companion object. But does this choice affect performance, APK size, or memory usage? Let’s break it down by diving into the bytecode and R8 optimizations.\u003c/p\u003e\u003ch2 id=\"42f3\"\u003ePreparing the Code\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a156\"\u003econst val TOP_LEVEL_CONSTANT = \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;\u003cp\u003eclass MainActivity : ComponentActivity() {\u003c/p\u003e\u003cp\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        println(TOP_LEVEL_CONSTANT)\u003cbr/\u003e        println(COMPANION_ENCLOSED_CONSTANT)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    companion object {\u003cbr/\u003e        const val COMPANION_ENCLOSED_CONSTANT = \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2952\"\u003eWe have top-level constant at the top and a companion object containing a constant at the bottom of \u003ccode\u003eMainActivity\u003c/code\u003e. The constants are used in \u003ccode\u003eonCreate\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"8ed2\"\u003eDecompiling the Class With Android Studio\u003c/h2\u003e\u003cp id=\"1421\"\u003eTo get the Java bytecode, we’ll simply go to the \u003ccode\u003eTools\u003c/code\u003e menu in Android Studio -\u0026gt; \u003ccode\u003eKotlin\u003c/code\u003e -\u0026gt; \u003ccode\u003eShow Kotlin Bytecode\u003c/code\u003e. A new pane showing Java bytecode will appear on the right.\u003c/p\u003e\u003cp id=\"8dd3\"\u003eSince reading Java bytecode directly is complex, we’ll click the \u003ccode\u003eDecompile\u003c/code\u003e button in the pane to get a Java representation.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aab1\"\u003epublic final class MainActivity extends ComponentActivity {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final Companion Companion = new Companion((DefaultConstructorMarker)null);\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final String COMPANION_ENCLOSED_CONSTANT = \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;;\u003cp\u003e   protected void onCreate(@Nullable Bundle savedInstanceState) {\u003cbr/\u003e      super.onCreate(savedInstanceState);\u003cbr/\u003e      String var2 = \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;;\u003cbr/\u003e      System.out.println(var2);\u003cbr/\u003e      var2 = \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;;\u003cbr/\u003e      System.out.println(var2);\u003cbr/\u003e   }\u003c/p\u003e\u003cp\u003e   public static final class Companion {\u003cbr/\u003e      private Companion() {\u003cbr/\u003e      }\u003c/p\u003e\u003cp\u003e      public Companion(DefaultConstructorMarker $constructor_marker) {\u003cbr/\u003e         this();\u003cbr/\u003e      }\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003epublic final class MainActivityKt {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final String TOP_LEVEL_CONSTANT = \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ec11\"\u003eI removed the parts that aren’t relevant to our discussion to make it easy to read. Let’s break down the relevant parts.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"02ee\"\u003e  protected void onCreate(@Nullable Bundle savedInstanceState) {\u003cbr/\u003e      super.onCreate(savedInstanceState);\u003cbr/\u003e      String var2 = \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;;\u003cbr/\u003e      System.out.println(var2);\u003cbr/\u003e      var2 = \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;;\u003cbr/\u003e      System.out.println(var2);\u003cbr/\u003e   }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"22b8\"\u003eInside the \u003ccode\u003eonCreate\u003c/code\u003e method, we can see that the constants are inlined and that’s great.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1452\"\u003epublic final class MainActivityKt {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final String TOP_LEVEL_CONSTANT = \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f1be\"\u003eHowever, now we end up with a redundant \u003ccode\u003eMainActivityKt\u003c/code\u003e class that isn’t even used. This comes from the top-level constant and it increases the app size.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fcc0\"\u003epublic final class MainActivity extends ComponentActivity {\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final Companion Companion = new Companion((DefaultConstructorMarker)null);\u003cbr/\u003e   @NotNull\u003cbr/\u003e   public static final String COMPANION_ENCLOSED_CONSTANT = \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;;\u003cp\u003e   ...\u003c/p\u003e\u003cp\u003e   public static final class Companion {\u003cbr/\u003e      private Companion() {\u003cbr/\u003e      }\u003c/p\u003e\u003cp\u003e      public Companion(DefaultConstructorMarker $constructor_marker) {\u003cbr/\u003e         this();\u003cbr/\u003e      }\u003cbr/\u003e   }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1599\"\u003eWith a companion-enclosed constant, it’s even worse. The companion object becomes a static inner class which gets instantiated during the outer class loading and assigned to a static field. This introduces unnecessary object creation and memory overhead.\u003c/p\u003e\u003ch2 id=\"c666\"\u003eRelevance of D8 and R8\u003c/h2\u003e\u003cp id=\"254e\"\u003eIt’s important to note that the Java code we looked at came from Java bytecode and Android does not run Java bytecode. The Java bytecode still needs to go through a dex compiler called D8 to turn into Dalvik bytecode that Android can run [1][2]. More importantly, our code hasn’t gone through R8 optimization yet. R8 optimization will remove unused code [3].\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"bf77\"\u003eCode shrinking (also known as tree shaking), is the process of removing code that R8 determines is not required at runtime. This process can greatly reduce your app’s size if, for example, your app includes many library dependencies but utilizes only a small part of their functionality.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"7e0f\"\u003eSo, to apply R8, we can enable it in the project-level Gradle file (also known as root-level Gradle file).\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b258\"\u003eisMinifyEnabled = true\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5ed3\"\u003eNext, we go to the \u003ccode\u003eBuild\u003c/code\u003e menu of the Android Studio -\u0026gt; \u003ccode\u003eBuild APK(s)\u003c/code\u003e to build an APK that contains Dalvik bytecode.\u003c/p\u003e\u003ch2 id=\"0926\"\u003eDecompiling the APK With Apktool and Jadx\u003c/h2\u003e\u003cp id=\"561d\"\u003eNow that we got our APK ready, let’s see what happens when D8 and R8 are involved in the compilation process.\u003c/p\u003e\u003cp id=\"d4bc\"\u003eSo, to get the Dalvik bytecode from the APK, we’ll use \u003ca href=\"https://apktool.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eapktool\u003c/a\u003e [4].\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDecompiled Dalvik Bytecode\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d840\"\u003eWe get these two files. Let’s see what’s inside each of them but first, to simplify our analysis, we need to translate the the Dalvik bytecode into Java representation. (If you wanna check the Dalvik bytecode, I’ve posted them \u003ca href=\"https://gist.github.com/AungThiha/6e7de0cb845890f24b396c7c3e5f22f9\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.)\u003c/p\u003e\u003cp id=\"8862\"\u003eThe easiest way to get the Java representation from smali files is to use \u003ca href=\"https://github.com/skylot/jadx\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ejadx\u003c/a\u003e [5].\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9468\"\u003epublic final class MainActivity$Companion {\u003cbr/\u003e    public /* synthetic */ MainActivity$Companion(DefaultConstructorMarker defaultConstructorMarker) {\u003cbr/\u003e        this();\u003cbr/\u003e    }\u003cp\u003e    private MainActivity$Companion() {\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2328\"\u003eThis is what we get for \u003ccode\u003eMainActivity$Companion.smali\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"8027\"\u003eLooking at the code, we now know that R8 doesn’t remove the static inner class derived from the companion object but what happened to \u003ccode\u003eMainActivityKt\u003c/code\u003e that comes from the top-level constant? Let’s look into \u003ccode\u003eMainActivity.smali\u003c/code\u003e to find out.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"42b0\"\u003epublic final class MainActivity extends ComponentActivity {\u003cbr/\u003e    public static final Companion Companion = new Companion((DefaultConstructorMarker) null);\u003cp\u003e    protected void onCreate(Bundle savedInstanceState) {\u003cbr/\u003e        super.onCreate(savedInstanceState);\u003cbr/\u003e        System.out.println((Object) \u0026#34;TOP_LEVEL_CONSTANT\u0026#34;);\u003cbr/\u003e        System.out.println((Object) \u0026#34;COMPANION_ENCLOSED_CONSTANT\u0026#34;);\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cb9c\"\u003e\u003ccode\u003eMainActivityKt\u003c/code\u003e is not here either, so we can conclude that R8 removes it. This happens because nothing references \u003ccode\u003eMainActivityKt\u003c/code\u003e. So, R8 knows it’s unused. As for the static inner class derived from the companion object, because it’s referenced by \u003ccode\u003eMainActivity\u003c/code\u003e, R8 doesn’t remove it.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a05f\"\u003eSharing Constants Across Different Classes\u003c/h2\u003e\u003cp id=\"ad6b\"\u003eSometimes, you might wanna share the constants across different classes. For that, we can declare top-level constants in a dedicated file, now that we know classes generated for enclosing only constants are removed by R8 because they’re not referenced by any classes after the constants are inlined.\u003c/p\u003e\u003ch2 id=\"cfdc\"\u003eGrouping Multiple Constants for Readability\u003c/h2\u003e\u003cp id=\"090f\"\u003eSometimes, keeping all constants at one level is not enough. Sometimes, you might wanna group them for readability. Let’s see if grouping with singleton objects is a viable option.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f815\"\u003eobject MyConstants {\u003cp\u003e    const val FIRST_LEVEL = \u0026#34;FIRST_LEVEL\u0026#34;\u003c/p\u003e\u003cp\u003e    object NestConstants {\u003cbr/\u003e        const val SECOND_LEVEL = \u0026#34;SECOND_LEVEL\u0026#34;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"60d9\"\u003eSo, we create the \u003ccode\u003eMyConstants\u003c/code\u003e class and simply print the constants in \u003ccode\u003eMainActivity\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"e3ce\"\u003eWe’ll also create \u003ccode\u003eHelloActivity\u003c/code\u003e, declare it in the manifest and make it use \u003ccode\u003eFIRST_LEVEL\u003c/code\u003e and \u003ccode\u003eSECOND_LEVEL\u003c/code\u003e. (I’ll leave out the code for \u003ccode\u003eHelloActivity\u003c/code\u003e to keep the article short.)\u003c/p\u003e\u003cp id=\"8ac4\"\u003eThen, we’ll build the APK and use apktool to decompile it.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eDecompiled Dalvik Bytecode After Adding MyConstants\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f90a\"\u003eThis is all we get. \u003ccode\u003eMyConstants\u003c/code\u003e is gone. R8 can remove it for the same reason it can remove \u003ccode\u003eMainActivityKt\u003c/code\u003e. It’s because after inlining the constants from that class, the class is no longer referenced by any other class which helps R8 know it’s not used. (If you still wanna take a look at the smali files, I’ve posted them \u003ca href=\"https://gist.github.com/AungThiha/aff23d3ce95c90c04af533fb9e786acd\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.)\u003c/p\u003e\u003ch2 id=\"45ae\"\u003eConclusion\u003c/h2\u003e\u003cul\u003e\u003cli id=\"ee0d\"\u003e\u003cstrong\u003eCompanion-enclosed Constants:\u003c/strong\u003e Avoid them, as they generate redundant static inner class that introduces unnecessary object creation and memory overhead.\u003c/li\u003e\u003cli id=\"4c19\"\u003e\u003cstrong\u003eTop-level Constants\u003c/strong\u003e: Best for single-file usage.\u003c/li\u003e\u003cli id=\"2141\"\u003e\u003cstrong\u003eShared Constants Across Multiple Classes:\u003c/strong\u003e Use a dedicated file with top-level constants.\u003c/li\u003e\u003cli id=\"87c1\"\u003e\u003cstrong\u003eGrouped Constants\u003c/strong\u003e: Use singleton objects.\u003c/li\u003e\u003cli id=\"3077\"\u003e\u003cstrong\u003eR8 Optimization:\u003c/strong\u003e Always enable \u003ccode\u003eisMinifyEnabled\u003c/code\u003e for production builds to benefit from code shrinking. R8 removes the enclosing classes of top-level, shared, and grouped constants because the classes are no longer referenced after the constants are inlined.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6752\"\u003eHappy coding, everyone!\u003c/p\u003e\u003ch2 id=\"9bb1\"\u003eReferences\u003c/h2\u003e\u003col\u003e\u003cli id=\"d3ed\"\u003e\u003ca href=\"https://source.android.com/docs/core/runtime\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://source.android.com/docs/core/runtime\u003c/a\u003e [Accessed on: 6 Feb 2025]\u003c/li\u003e\u003cli id=\"dfb2\"\u003e\u003ca href=\"https://developer.android.com/tools/d8\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/tools/d8\u003c/a\u003e [Accessed on: 6 Feb 2025]\u003c/li\u003e\u003cli id=\"1018\"\u003e\u003ca href=\"https://developer.android.com/build/shrink-code\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/build/shrink-code\u003c/a\u003e [Accessed on: 6 Feb 2025]\u003c/li\u003e\u003cli id=\"7735\"\u003e\u003ca href=\"https://apktool.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://apktool.org/\u003c/a\u003e [Accessed on: 6 Feb 2025]\u003c/li\u003e\u003cli id=\"55b1\"\u003e\u003ca href=\"https://github.com/skylot/jadx\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/skylot/jadx\u003c/a\u003e [Accessed on: 6 Feb 2025]\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-02-06T00:47:35.756Z",
  "modifiedTime": null
}
