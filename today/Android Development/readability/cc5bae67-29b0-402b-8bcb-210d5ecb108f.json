{
  "id": "cc5bae67-29b0-402b-8bcb-210d5ecb108f",
  "title": "Is ViewPump A Security Risk?",
  "link": "https://www.zacsweers.dev/is-viewpump-a-security-risk/",
  "description": "Exploring a claim that ViewPump is a data leak.",
  "author": "Zac Sweers",
  "published": "Mon, 17 Oct 2022 20:45:36 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Open Source",
    "Android",
    "AndroidDev"
  ],
  "byline": "Zac Sweers",
  "length": 7744,
  "excerpt": "Exploring a claim that ViewPump is a data leak.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "17 Oct 2022 • 4 min read Exploring a claim that ViewPump is a data leak. A confused red balloon locked in a cage in a dark room, photorealistic. Generated with DALL-E Disclosure: This post discusses the Intune SDK and my current employer ships an Intune variant of their app. I am not speaking on behalf of my employer, only as an open source contributor to ViewPump.ViewPump is nifty little Android library that offers an OkHttp-style interceptor API for Android View inflation.It was written primarily by James Barr and Chris Jenkins in 2017, but has roots going all the way back to Chris's Calligraphy library (at one point the canonical way to use custom fonts in Android apps). I was also involved early on in its development, having pitched the idea to James and introduced him to Chris.It uses the same public LayoutInflater APIs that AndroidX AppCompat and Material Design Components Android (MDC) use for their own view inflation hooks, so it's running on battle-tested foundations.The ClaimIt's largely in maintenance mode now, not because it's abandoned but rather because it's largely Done™️. It has a very specific purpose and a very specific API, and it has been able to do that largely without issue all these years. So, you can imagine my surprise recently to hear that Microsoft's Intune team had classified it as a \"data leak\" and wouldn't support apps using it or seek to fix a crash reported around it by a user. https://github.com/msintuneappsdk/ms-intune-app-sdk-android/issues/85#issuecomment-1204362165What is Intune?Microsoft Intune is an MDM service with mobile support, apps can become \"Intune\"-compliant by applying a Gradle plugin that performs bytecode post-processing to hook into myriad Android framework calls and intercept/monitor them with their companion SDK. Apps that are compliant can ship an \"Intune\" version of their app separate from their primary app.So what changed? Well, nothing. There hadn't been any restrictions introduced to the LayoutInflater APIs in recent Android releases, appcompat and MDC still used similar hooks and they obviously weren't classified this way. They were asked for more details, but at the time of writing have not responded.The CrashThis section is largely the same as this comment and just adapted for this blog.In the meantime, I sought to look into the original crash. It's a fairly standard stack overflow exception.at com.microsoft.intune.mam.client.view.OfflineLayoutInflaterManagementBehavior.setFactory2(OfflineLayoutInflaterManagementBehavior.java:22) at com.microsoft.intune.mam.client.view.MAMLayoutInflaterManagement.setFactory2(MAMLayoutInflaterManagement.java:42) at io.github.inflationx.viewpump.internal.-ViewPumpLayoutInflater.setFactory2(-ViewPumpLayoutInflater.kt:94) at com.microsoft.intune.mam.client.view.OfflineLayoutInflaterManagementBehavior.setFactory2(OfflineLayoutInflaterManagementBehavior.java:22)This is one of the mentioned ways that Intune tries to intercept framework calls in its bytecode transformer. It had rewritten this line in ViewPump's inflater to pass through to its own static interceptor. override fun setFactory2(factory2: LayoutInflater.Factory2) { if (factory2 !is WrapperFactory2) { super.setFactory2(WrapperFactory2(factory2)) } else { // This line! super.setFactory2(factory2) } }This is a pretty simple bit of code. So simple, in fact, that we can recreated it with an isolated non-ViewPump case.class InflaterTest(context: Context) : LayoutInflater(context) { override fun cloneInContext(newContext: Context?): LayoutInflater { return this } override fun setFactory2(factory: Factory2?) { super.setFactory2(factory) } }This is a fairly trivial demo, but the relevant part is the super call in setFactory2(). The post-processed bytecode (in dalvik) looks like this using the latest Intune version:.method public setFactory2(Landroid/view/LayoutInflater$Factory2;)V .registers 2 .param p1, \"factory\" # Landroid/view/LayoutInflater$Factory2; .annotation system Ldalvik/annotation/MethodParameters; accessFlags = { 0x0 } names = { \"factory\" } .end annotation .line 12 invoke-super {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u003esetFactory2(Landroid/view/LayoutInflater$Factory2;)V .line 13 return-void .end methodWhere the relevant bit is .line 12 invoke-super {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u003esetFactory2(Landroid/view/LayoutInflater$Factory2;)VThis is invalid bytecode in two different waysThe invoke-super instruction is now invoking the static MAMLayoutInflaterManagement.setFactory2(...) method, which would result in a VerifyError at runtime. This is what I saw when testing with the latest release (8.6.1) as well.MAMLayoutInflaterManagement.setFactory2(...) method accepts two parameters (original and factory), but MAM has written this only passing a single factory param. This would result in a NoSuchMethodError at runtime even if the first issue was fixed.There's no way to intercept super calls like this without replacing the superclass itself. I know MAM does that for other classes, but it doesn't appear to do this with LayoutInflater subclasses. The relevant ViewPump code in the OP stack trace is such a super.setFactory2(...) call here, so it gets broken in the same way.To bring this back to the original stack overflow in the OP, I suspected the SDK changed between when OP tested this and when I looked. Looking at the stacktrace, I guessed that the previous implementation rewrote the call to look something like this (hand-wavy pseudocode)-super.setFactory2(factory) +MAMLayoutInflaterManagement.setFactory2(this, factory)If you then build against an earlier version of the SDK (8.1.1), you'd see the final transformed dalvik code does indeed do that..method public setFactory2(Landroid/view/LayoutInflater$Factory2;)V .registers 2 .param p1, \"factory\" # Landroid/view/LayoutInflater$Factory2; .annotation system Ldalvik/annotation/MethodParameters; accessFlags = { 0x0 } names = { \"factory\" } .end annotation .line 14 invoke-static {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u003esetFactory2(Landroid/view/LayoutInflater;Landroid/view/LayoutInflater$Factory2;)V .line 15 return-void .end methodThis is both functionally different than what was there before (no super call now) and would definitely result in the stackoverflow seen above since MAMLayoutInflaterManagement (as best I can tell) just forwards calls to a cached OfflineLayoutInflaterManagementBehavior that just no-ops and forwards the call to the passed in LayoutInflater param, which is just this again.I tried to best-effort diagram it here.TL;DR: MAM is generating invalid bytecode. Irregardless of its stance on ViewPump as a library, this is a bug that should be fixed, either by not transforming super calls like this or inserting its own MAM LayoutInflater superclass like it does with some other classes. Any LayoutInflater subclass is susceptible to this issue if they override + call super.Edit: Jake Wharton pointed out an even simpler solution here.Is ViewPump A Security Risk?Well, I don't think so. I haven't seen any concrete evidence to support this claim. If it is, so is any other use of LayoutInflater or code that subclasses a framework class and dares to call super. I hope the SDK's maintainers will revisit their claim and address the real bug instead.Thanks to James and Chris for reviewing this.",
  "image": "https://www.zacsweers.dev/content/images/2022/10/DALL-E-2022-10-15-00.44.42---A-confused-red-balloon-locked-in-a-cage-in-a-dark-room--photorealistic.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cspan\u003e17 Oct 2022\u003c/span\u003e\n    \u003ci\u003e•\u003c/i\u003e\n    \u003cspan\u003e4 min read\u003c/span\u003e\n  \u003c/p\u003e\n  \n    \u003cp\u003eExploring a claim that ViewPump is a data leak.\u003c/p\u003e\n    \n    \u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/size/w1200/format/webp/2022/10/DALL-E-2022-10-15-00.44.42---A-confused-red-balloon-locked-in-a-cage-in-a-dark-room--photorealistic.png\" data-src=\"/content/images/size/w1200/format/webp/2022/10/DALL-E-2022-10-15-00.44.42---A-confused-red-balloon-locked-in-a-cage-in-a-dark-room--photorealistic.png\" alt=\"A confused red balloon locked in a cage in a dark room, photorealistic. Generated with DALL-E\"/\u003e\n\n    \u003c/p\u003e\n    \u003cfigcaption\u003eA confused red balloon locked in a cage in a dark room, photorealistic. Generated with DALL-E\u003c/figcaption\u003e\n\u003c/div\u003e\u003cdiv\u003e\n    \u003cblockquote\u003eDisclosure: This post discusses the Intune SDK and my current employer ships an Intune variant of their app. I am not speaking on behalf of my employer, only as an open source contributor to ViewPump.\u003c/blockquote\u003e\u003cp\u003e\u003ca href=\"https://github.com/InflationX/ViewPump?ref=zacsweers.dev\"\u003eViewPump\u003c/a\u003e is nifty little Android library that offers an OkHttp-style interceptor API for Android View inflation.\u003c/p\u003e\u003cp\u003eIt was written primarily by \u003ca href=\"https://twitter.com/jbarr21?ref=zacsweers.dev\"\u003eJames Barr\u003c/a\u003e and \u003ca href=\"https://twitter.com/chrisjenx?ref=zacsweers.dev\"\u003eChris Jenkins\u003c/a\u003e in 2017, but has roots going all the way back to Chris\u0026#39;s \u003ca href=\"https://github.com/chrisjenx/Calligraphy?ref=zacsweers.dev\"\u003eCalligraphy\u003c/a\u003e library (at one point \u003cem\u003ethe\u003c/em\u003e canonical way to use custom fonts in Android apps). I was also involved early on in its development, having pitched the idea to James and introduced him to Chris.\u003c/p\u003e\u003cp\u003eIt uses the same public \u003ccode\u003eLayoutInflater\u003c/code\u003e APIs that AndroidX AppCompat and Material Design Components Android (MDC) use for their own view inflation hooks, so it\u0026#39;s running on battle-tested foundations.\u003c/p\u003e\u003ch2 id=\"the-claim\"\u003eThe Claim\u003c/h2\u003e\u003cp\u003eIt\u0026#39;s largely in maintenance mode now, not because it\u0026#39;s abandoned but rather because it\u0026#39;s largely Done™️. It has a very specific purpose and a very specific API, and it has been able to do that largely without issue all these years. So, you can imagine my surprise recently to hear that Microsoft\u0026#39;s Intune team had classified it as a \u003ca href=\"https://github.com/msintuneappsdk/ms-intune-app-sdk-android/issues/85?ref=zacsweers.dev#issuecomment-1204362165\"\u003e\u0026#34;data leak\u0026#34;\u003c/a\u003e and wouldn\u0026#39;t support apps using it or seek to fix a crash reported around it by a user. \u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2022/10/image.png\" alt=\"\" loading=\"lazy\" width=\"1632\" height=\"340\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2022/10/image.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2022/10/image.png 1000w, https://www.zacsweers.dev/content/images/size/w1600/2022/10/image.png 1600w, https://www.zacsweers.dev/content/images/2022/10/image.png 1632w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003cfigcaption\u003e\u003ca href=\"https://github.com/msintuneappsdk/ms-intune-app-sdk-android/issues/85?ref=zacsweers.dev#issuecomment-1204362165\"\u003ehttps://github.com/msintuneappsdk/ms-intune-app-sdk-android/issues/85#issuecomment-1204362165\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cblockquote\u003eWhat is Intune?\u003cp\u003eMicrosoft Intune is an MDM service with mobile support, apps can become \u0026#34;Intune\u0026#34;-compliant by applying a Gradle plugin that performs bytecode post-processing to hook into myriad Android framework calls and intercept/monitor them with their companion SDK. Apps that are compliant can ship an \u0026#34;Intune\u0026#34; version of their app separate from their primary app.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eSo what changed? Well, nothing. There hadn\u0026#39;t been any restrictions introduced to the \u003ccode\u003eLayoutInflater\u003c/code\u003e APIs in recent Android releases, appcompat and MDC still used similar hooks and they obviously weren\u0026#39;t classified this way. They were asked for more details, but at the time of writing have not responded.\u003c/p\u003e\u003ch2 id=\"the-crash\"\u003eThe Crash\u003c/h2\u003e\u003cblockquote\u003eThis section is largely the same as \u003ca href=\"https://github.com/msintuneappsdk/ms-intune-app-sdk-android/issues/85?ref=zacsweers.dev#issuecomment-1216890136\"\u003ethis comment\u003c/a\u003e and just adapted for this blog.\u003c/blockquote\u003e\u003cp\u003eIn the meantime, I sought to look into the original crash. It\u0026#39;s a fairly standard stack overflow exception.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eat com.microsoft.intune.mam.client.view.OfflineLayoutInflaterManagementBehavior.setFactory2(OfflineLayoutInflaterManagementBehavior.java:22)\n        at com.microsoft.intune.mam.client.view.MAMLayoutInflaterManagement.setFactory2(MAMLayoutInflaterManagement.java:42)\n        at io.github.inflationx.viewpump.internal.-ViewPumpLayoutInflater.setFactory2(-ViewPumpLayoutInflater.kt:94)\n        at com.microsoft.intune.mam.client.view.OfflineLayoutInflaterManagementBehavior.setFactory2(OfflineLayoutInflaterManagementBehavior.java:22)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is one of the mentioned ways that Intune tries to intercept framework calls in its bytecode transformer. It had rewritten \u003ca href=\"https://github.com/InflationX/ViewPump/blob/8dbefccc27dce258b391efa5adfb94ec5ebbbadd/viewpump/src/main/java/io/github/inflationx/viewpump/internal/-ViewPumpLayoutInflater.kt?ref=zacsweers.dev#L94\"\u003ethis line\u003c/a\u003e in ViewPump\u0026#39;s inflater to pass through to its own static interceptor.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  override fun setFactory2(factory2: LayoutInflater.Factory2) {\n    if (factory2 !is WrapperFactory2) {\n      super.setFactory2(WrapperFactory2(factory2))\n    } else {\n      // This line!\n      super.setFactory2(factory2)\n    }\n  }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is a pretty simple bit of code. So simple, in fact, that we can recreated it with an isolated non-ViewPump case.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass InflaterTest(context: Context) : LayoutInflater(context) {\n  override fun cloneInContext(newContext: Context?): LayoutInflater {\n    return this\n  }\n\n  override fun setFactory2(factory: Factory2?) {\n    super.setFactory2(factory)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is a fairly trivial demo, but the relevant part is the \u003ccode\u003esuper\u003c/code\u003e call in \u003ccode\u003esetFactory2()\u003c/code\u003e. The post-processed bytecode (in dalvik) looks like this using the latest Intune version:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.method public setFactory2(Landroid/view/LayoutInflater$Factory2;)V\n    .registers 2\n    .param p1, \u0026#34;factory\u0026#34;    # Landroid/view/LayoutInflater$Factory2;\n    .annotation system Ldalvik/annotation/MethodParameters;\n        accessFlags = {\n            0x0\n        }\n        names = {\n            \u0026#34;factory\u0026#34;\n        }\n    .end annotation\n\n    .line 12\n    invoke-super {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u0026gt;setFactory2(Landroid/view/LayoutInflater$Factory2;)V\n\n    .line 13\n    return-void\n.end method\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhere the relevant bit is \u003ccode\u003e.line 12\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e    invoke-super {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u0026gt;setFactory2(Landroid/view/LayoutInflater$Factory2;)V\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is invalid bytecode in two different ways\u003c/p\u003e\u003col\u003e\u003cli\u003eThe \u003ccode\u003einvoke-super\u003c/code\u003e instruction is now invoking the static \u003ccode\u003eMAMLayoutInflaterManagement.setFactory2(...)\u003c/code\u003e method, which would result in a \u003ccode\u003eVerifyError\u003c/code\u003e at runtime. This is what I saw when testing with the latest release (8.6.1) as well.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eMAMLayoutInflaterManagement.setFactory2(...)\u003c/code\u003e method accepts two parameters (\u003ccode\u003eoriginal\u003c/code\u003e and \u003ccode\u003efactory\u003c/code\u003e), but MAM has written this only passing a single \u003ccode\u003efactory\u003c/code\u003e param. This would result in a \u003ccode\u003eNoSuchMethodError\u003c/code\u003e at runtime even if the first issue was fixed.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eThere\u0026#39;s no way to intercept \u003ccode\u003esuper\u003c/code\u003e calls like this without replacing the superclass itself. I know MAM does that for other classes, but it doesn\u0026#39;t appear to do this with \u003ccode\u003eLayoutInflater\u003c/code\u003e subclasses. The relevant ViewPump code in the OP stack trace is such a \u003ccode\u003esuper.setFactory2(...)\u003c/code\u003e call \u003ca href=\"https://github.com/InflationX/ViewPump/blob/8dbefccc27dce258b391efa5adfb94ec5ebbbadd/viewpump/src/main/java/io/github/inflationx/viewpump/internal/-ViewPumpLayoutInflater.kt?ref=zacsweers.dev#L94\"\u003ehere\u003c/a\u003e, so it gets broken in the same way.\u003c/p\u003e\u003cp\u003eTo bring this back to the original stack overflow in the OP, I suspected the SDK changed between when OP tested this and when I looked. Looking at the stacktrace, I guessed that the previous implementation rewrote the call to look something like this (hand-wavy pseudocode)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e-super.setFactory2(factory)\n+MAMLayoutInflaterManagement.setFactory2(this, factory)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you then build against an earlier version of the SDK (8.1.1), you\u0026#39;d see the final transformed dalvik code does indeed do that.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.method public setFactory2(Landroid/view/LayoutInflater$Factory2;)V\n    .registers 2\n    .param p1, \u0026#34;factory\u0026#34;    # Landroid/view/LayoutInflater$Factory2;\n    .annotation system Ldalvik/annotation/MethodParameters;\n        accessFlags = {\n            0x0\n        }\n        names = {\n            \u0026#34;factory\u0026#34;\n        }\n    .end annotation\n\n    .line 14\n    invoke-static {p0, p1}, Lcom/microsoft/intune/mam/client/view/MAMLayoutInflaterManagement;-\u0026gt;setFactory2(Landroid/view/LayoutInflater;Landroid/view/LayoutInflater$Factory2;)V\n\n    .line 15\n    return-void\n.end method\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is both functionally different than what was there before (no super call now) and would definitely result in the stackoverflow seen above since \u003ccode\u003eMAMLayoutInflaterManagement\u003c/code\u003e (as best I can tell) just forwards calls to a cached \u003ccode\u003eOfflineLayoutInflaterManagementBehavior\u003c/code\u003e that just no-ops and forwards the call to the passed in \u003ccode\u003eLayoutInflater\u003c/code\u003e param, which is just \u003ccode\u003ethis\u003c/code\u003e again\u003ca href=\"https://user-images.githubusercontent.com/1361086/184931734-729bfa5f-8cdd-4fd7-8741-b7926c562432.png?ref=zacsweers.dev\" rel=\"nofollow\"\u003e.\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI tried to best-effort diagram it \u003ca href=\"https://user-images.githubusercontent.com/1361086/184933431-5c77f43a-8b1c-48d4-ad67-f714d88c8ac1.png?ref=zacsweers.dev\" rel=\"nofollow\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTL;DR:\u003c/strong\u003e MAM is generating invalid bytecode. Irregardless of its stance on ViewPump as a library, this is a bug that should be fixed, either by not transforming \u003ccode\u003esuper\u003c/code\u003e calls like this or inserting its own MAM \u003ccode\u003eLayoutInflater\u003c/code\u003e superclass like it does with some other classes. Any \u003ccode\u003eLayoutInflater\u003c/code\u003e subclass is susceptible to this issue if they override + call \u003ccode\u003esuper\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cem\u003eEdit: Jake Wharton pointed out an even simpler solution \u003ca href=\"https://twitter.com/JakeWharton/status/1582117262474981376?s=20\u0026amp;t=jQmPuzePRNRAECHm7lz5Qg\u0026amp;ref=zacsweers.dev\"\u003ehere\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"is-viewpump-a-security-risk\"\u003eIs ViewPump A Security Risk?\u003c/h2\u003e\u003cp\u003eWell, I don\u0026#39;t think so. I haven\u0026#39;t seen any concrete evidence to support this claim. If it is, so is any other use of \u003ccode\u003eLayoutInflater\u003c/code\u003e or code that subclasses a framework class and dares to call \u003ccode\u003esuper\u003c/code\u003e. I hope the SDK\u0026#39;s maintainers will revisit their claim and address the real bug instead.\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003eThanks to James and Chris for reviewing this.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2022-10-17T20:45:36Z",
  "modifiedTime": "2022-10-17T21:19:00Z"
}
