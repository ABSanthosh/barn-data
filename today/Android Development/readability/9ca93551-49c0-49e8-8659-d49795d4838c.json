{
  "id": "9ca93551-49c0-49e8-8659-d49795d4838c",
  "title": "SharedFlow — Practical Examples",
  "link": "https://proandroiddev.com/sharedflow-practical-examples-591f70e27711?source=rss----c72404660798---4",
  "description": "",
  "author": "Dilipchandar",
  "published": "Wed, 21 May 2025 09:31:09 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "android-app-development",
    "programming",
    "androiddev",
    "kotlin"
  ],
  "byline": "Dilipchandar",
  "length": 6017,
  "excerpt": "SharedFlow is a hot flow. Actually, a Flow is a stream of data that can be computed asynchronously. There are two types of Flows, Since SharedFlow is a hot flow, it can emit regardless of the…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "SharedFlow — Practical ExamplesHow does it work?IntroductionSharedFlow is a hot flow. Actually, a Flow is a stream of data that can be computed asynchronously. There are two types of Flows,Cold Flow - Emits only when a collector is presentHot Flow -Emits even though there is no collectorSince SharedFlow is a hot flow, it can emit regardless of the collector’s presence. And it doesn’t hold any value like StateFlow unless specified.For example, see the code belowval sharedFlow = MutableSharedFlow\u003cString\u003e()This creates a MutableSharedFlow of type String. But inside constructor, three parameters replay, extraBufferCapacity and onBufferOverflow are not specified. But still kotlin compiler doesn’t throw any error as all the 3 parameters have default values as shown in the internal implementation of MutableSharedFlow.Suppress(\"FunctionName\", \"UNCHECKED_CAST\")public fun \u003cT\u003e MutableSharedFlow( replay: Int = 0, extraBufferCapacity: Int = 0, onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND): MutableSharedFlow\u003cT\u003e But in StateFlow, we need an initial value likeval stateFlow = MutableStateFlow(0)Okay, since we are going to focus more on SharedFlow, let’s deep dive with practical examples.Practical Examplesval sharedFlow = MutableSharedFlow\u003cString\u003e() lifecycleScope.launch { sharedFlow.emit(\"Ram\") sharedFlow.emit(\"Kumar\") // Emission sharedFlow .onEach { println(it) } // Collection .launchIn(this) }In the above code, the first line of code is a MutableSharedFlow creation that we already discussed.Then we are launching a coroutine on lifecycleScope which is either an activity or a fragment. So once we use lifecycleScope, it’s dispatcher is Dispatchers.Main.immediate which executes the code immediately.Inside this coroutine, we are emitting 2 values of SharedFlow and using onEach to iterate through all the emitted values and print them. And finally, we are using launchIn(this).Internal implementation of launchInpublic fun \u003cT\u003e Flow\u003cT\u003e.launchIn(scope: CoroutineScope): Job = scope.launch { collect() // tail-call}As you can see, it internally calls collect(), which is a terminal operator. So similar to collect, we can also use launchIn as a collector to collect emitted values of SharedFlow. It launches a collector in a separate non-blocking coroutine.But if we run the above code, we may expect that Ram and Kumar will be printed but nothing will get printed. Why?Because SharedFlow doesn't remember past emissions.That means we have emitted first (past emission) and collected next. So it doesn't print anything.Okay, let’s collect first and then emitval sharedFlow = MutableSharedFlow\u003cString\u003e() lifecycleScope.launch { sharedFlow .onEach { println(it) } // Collection .launchIn(this) sharedFlow.emit(\"Ram\") // Emission sharedFlow.emit(\"Kumar\") }Now, it won’t print anything. Why?Even though launchIn(this) starts the collection, it's asynchronous — the collector may not yet be active when emit() is called.So what’s happening:onEach().launchIn(this) launches a collector in a separate coroutine.The next lines (emit(...)) run immediately, possibly before the collector is ready.Result: emissions are lost → nothing is printed.To solve this, we have to emit in a separate coroutine like below.val sharedFlow = MutableSharedFlow\u003cString\u003e() lifecycleScope.launch { sharedFlow .onEach { println(it) } // Collection .launchIn(this) launch { sharedFlow.emit(\"Ram\") // Emission sharedFlow.emit(\"Kumar\") } }OrAdd a delay. Since delay() is a suspend function, it delays the emission process until the collector becomes active or ready.val sharedFlow = MutableSharedFlow\u003cString\u003e() lifecycleScope.launch { sharedFlow .onEach { println(it) } // Collection .launchIn(this) delay(100) sharedFlow.emit(\"Ram\") // Emission sharedFlow.emit(\"Kumar\") }Now the output will be as expected.RamKumarThe same is the case when we use collect instead of launchIn(this), like below.val sharedFlow = MutableSharedFlow\u003cString\u003e() lifecycleScope.launch { sharedFlow.collect { println(it) } // Collection sharedFlow.emit(\"Ram\") // Emission sharedFlow.emit(\"Kumar\") }In the above code, the Kotlin compiler will issue a warning Unreachable code becausecollect is suspending, so any code after it in the same coroutine will not execute until the flow completes.Now let’s emit first (past emission) and collect by using replay in SharedFlow.val sharedFlow = MutableSharedFlow\u003cString\u003e(replay = 1) lifecycleScope.launch { sharedFlow.emit(\"Ram\") sharedFlow.emit(\"Kumar\") // Emission sharedFlow .onEach { println(it) } // Collection .launchIn(this) }In the above, we have specified a replay value of 1 while initializing MutableSharedFlow. By this, we wantSharedFlow to remember the last emission if replay = 1.SharedFlow to remember the last 2 emissions if replay = 2 and so on.Also, we have emitted and collected inside the same coroutine. When we run the above code, the output will beKumarSince we have asked SharedFlow to remember the most recent emission, only that value is printed.",
  "image": "https://miro.medium.com/v2/resize:fit:752/1*22M3lMdMrQgfAD_r_ZQUkQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"a530\" data-testid=\"storyTitle\"\u003eSharedFlow — Practical Examples\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"8211\"\u003eHow does it work?\u003c/h2\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@dilipchandar89?source=post_page---byline--591f70e27711---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Dilipchandar\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*_ahsRfI76vTCn4JWIGHHGg.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"5e9d\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"b859\"\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSharedFlow\u003c/a\u003e is a hot flow. Actually, a Flow is a stream of data that can be computed asynchronously. There are two types of Flows,\u003c/p\u003e\u003cul\u003e\u003cli id=\"5d4a\"\u003eCold Flow - Emits only when a collector is present\u003c/li\u003e\u003cli id=\"f9b5\"\u003eHot Flow -Emits even though there is no collector\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3fb3\"\u003eSince SharedFlow is a hot flow, it can emit regardless of the collector’s presence. And it doesn’t hold any value like \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStateFlow\u003c/a\u003e unless specified.\u003c/p\u003e\u003cp id=\"5daa\"\u003eFor example, see the code below\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c1a6\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cdfc\"\u003eThis creates a \u003ca href=\"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMutableSharedFlow\u003c/a\u003e of type String. But inside constructor, three parameters \u003cem\u003ereplay\u003c/em\u003e, \u003cem\u003eextraBufferCapacity\u003c/em\u003e and \u003cem\u003eonBufferOverflow\u003c/em\u003e are not specified. But still kotlin compiler doesn’t throw any error as all the 3 parameters have default values as shown in the internal implementation of MutableSharedFlow.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fdea\"\u003eSuppress(\u0026#34;FunctionName\u0026#34;, \u0026#34;UNCHECKED_CAST\u0026#34;)\u003cbr/\u003epublic fun \u0026lt;T\u0026gt; MutableSharedFlow(\u003cbr/\u003e    replay: Int = 0,\u003cbr/\u003e    extraBufferCapacity: Int = 0,\u003cbr/\u003e    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND\u003cbr/\u003e): MutableSharedFlow\u0026lt;T\u0026gt; \u003c/span\u003e\u003c/pre\u003e\u003cp id=\"26d4\"\u003eBut in StateFlow, we need an initial value like\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd45\"\u003eval stateFlow = MutableStateFlow(0)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"708a\"\u003eOkay, since we are going to focus more on SharedFlow, let’s deep dive with practical examples.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8092\"\u003ePractical Examples\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"df0a\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()  \u003cp\u003e        lifecycleScope.launch {                              \u003cbr/\u003e            sharedFlow.emit(\u0026#34;Ram\u0026#34;)\u003cbr/\u003e            sharedFlow.emit(\u0026#34;Kumar\u0026#34;)      // Emission\u003c/p\u003e\u003cp\u003e            sharedFlow                                       \u003cbr/\u003e                .onEach { println(it) }  // Collection\u003cbr/\u003e                .launchIn(this)\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b963\"\u003eIn the above code, the first line of code is a \u003cem\u003eMutableSharedFlow\u003c/em\u003e creation that we already discussed.\u003c/p\u003e\u003cp id=\"b053\"\u003eThen we are launching a coroutine on \u003cstrong\u003elifecycleScope\u003c/strong\u003e which is either an activity or a fragment. So once we use lifecycleScope, it’s dispatcher is \u003cstrong\u003eDispatchers.Main.immediate \u003c/strong\u003ewhich executes the code immediately.\u003c/p\u003e\u003cp id=\"370e\"\u003eInside this coroutine, we are emitting 2 values of SharedFlow and using \u003cem\u003eonEach\u003c/em\u003e to iterate through all the emitted values and print them. And finally, we are using launchIn(this).\u003c/p\u003e\u003cp id=\"4764\"\u003eInternal implementation of \u003cstrong\u003elaunchIn\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e8b4\"\u003epublic fun \u0026lt;T\u0026gt; Flow\u0026lt;T\u0026gt;.launchIn(scope: CoroutineScope): Job = scope.launch {\u003cbr/\u003e    collect() // tail-call\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7610\"\u003eAs you can see, it internally calls \u003cem\u003ecollect()\u003c/em\u003e, which is a terminal operator. So similar to \u003cem\u003ecollect\u003c/em\u003e, we can also use \u003cem\u003elaunchIn\u003c/em\u003e as a collector to collect emitted values of SharedFlow. It launches a collector in a separate non-blocking coroutine.\u003c/p\u003e\u003cp id=\"8744\"\u003eBut if we run the above code, we may expect that Ram and Kumar will be printed but nothing will get printed. Why?\u003c/p\u003e\u003cp id=\"53ac\"\u003e\u003cstrong\u003eBecause SharedFlow doesn\u0026#39;t remember past emissions.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"1e66\"\u003eThat means we have emitted first (past emission) and collected next. So it doesn\u0026#39;t print anything.\u003c/p\u003e\u003cp id=\"08d8\"\u003eOkay, let’s collect first and then emit\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fdb5\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()  \u003cp\u003e        lifecycleScope.launch {                              \u003c/p\u003e\u003cp\u003e                        sharedFlow                                       \u003cbr/\u003e                .onEach { println(it) }     // Collection\u003cbr/\u003e                .launchIn(this)\u003c/p\u003e\u003cp\u003e            sharedFlow.emit(\u0026#34;Ram\u0026#34;)         // Emission\u003cbr/\u003e            sharedFlow.emit(\u0026#34;Kumar\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a7cb\"\u003eNow, it won’t print anything. Why?\u003c/p\u003e\u003cul\u003e\u003cli id=\"54e7\"\u003eEven though \u003ccode\u003elaunchIn(this)\u003c/code\u003e starts the collection, it\u0026#39;s asynchronous — the collector \u003cstrong\u003emay not yet be active\u003c/strong\u003e when \u003ccode\u003eemit()\u003c/code\u003e is called.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9c89\"\u003eSo what’s happening:\u003c/p\u003e\u003cp id=\"04f0\"\u003e\u003ccode\u003eonEach().launchIn(this)\u003c/code\u003e launches a collector in a separate coroutine.\u003c/p\u003e\u003cp id=\"924b\"\u003eThe next lines (\u003ccode\u003eemit(...)\u003c/code\u003e) run immediately, possibly before the collector is ready.\u003c/p\u003e\u003cp id=\"0ebe\"\u003eResult: emissions are lost → \u003cstrong\u003enothing is printed\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"8642\"\u003eTo solve this, we have to emit in a separate coroutine like below.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"df99\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()  \u003cp\u003e        lifecycleScope.launch {                              \u003c/p\u003e\u003cp\u003e                        sharedFlow                                       \u003cbr/\u003e                .onEach { println(it) }            // Collection\u003cbr/\u003e                .launchIn(this)\u003c/p\u003e\u003cp\u003e            launch {\u003cbr/\u003e                   sharedFlow.emit(\u0026#34;Ram\u0026#34;)         // Emission\u003cbr/\u003e                   sharedFlow.emit(\u0026#34;Kumar\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4bbb\"\u003eOr\u003c/p\u003e\u003cp id=\"7aad\"\u003eAdd a \u003cstrong\u003edelay\u003c/strong\u003e. Since delay() is a suspend function, it delays the emission process until the collector becomes active or ready.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6378\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()  \u003cp\u003e        lifecycleScope.launch {                              \u003c/p\u003e\u003cp\u003e                        sharedFlow                                       \u003cbr/\u003e                .onEach { println(it) }            // Collection\u003cbr/\u003e                .launchIn(this)\u003c/p\u003e\u003cp\u003e            delay(100)\u003c/p\u003e\u003cp\u003e            sharedFlow.emit(\u0026#34;Ram\u0026#34;)                // Emission\u003cbr/\u003e            sharedFlow.emit(\u0026#34;Kumar\u0026#34;)\u003c/p\u003e\u003cp\u003e                    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c790\"\u003eNow the output will be as expected.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"220e\"\u003eRam\u003cbr/\u003eKumar\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6de3\"\u003eThe same is the case when we use collect instead of launchIn(this), like below.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"78e5\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;()  \u003cp\u003e        lifecycleScope.launch {                              \u003c/p\u003e\u003cp\u003e                        sharedFlow.collect { println(it) }            // Collection\u003c/p\u003e\u003cp\u003e            sharedFlow.emit(\u0026#34;Ram\u0026#34;)                       // Emission\u003cbr/\u003e            sharedFlow.emit(\u0026#34;Kumar\u0026#34;)\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a50c\"\u003eIn the above code, the Kotlin compiler will issue a warning \u003cstrong\u003eUnreachable code \u003c/strong\u003ebecause\u003c/p\u003e\u003cp id=\"30ac\"\u003e\u003ccode\u003e\u003cstrong\u003ecollect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eis\u003cstrong\u003e suspending\u003c/strong\u003e, so any code after it in the same coroutine will not execute until the flow completes.\u003c/p\u003e\u003cp id=\"ef3a\"\u003eNow let’s emit first (past emission) and collect by using replay in SharedFlow.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9de0\"\u003eval sharedFlow = MutableSharedFlow\u0026lt;String\u0026gt;(replay = 1)  \u003cp\u003e        lifecycleScope.launch {                              \u003cbr/\u003e            sharedFlow.emit(\u0026#34;Ram\u0026#34;)\u003cbr/\u003e            sharedFlow.emit(\u0026#34;Kumar\u0026#34;)      // Emission\u003c/p\u003e\u003cp\u003e            sharedFlow                                       \u003cbr/\u003e                .onEach { println(it) }  // Collection\u003cbr/\u003e                .launchIn(this)\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0937\"\u003eIn the above, we have specified a replay value of 1 while initializing MutableSharedFlow. By this, we want\u003c/p\u003e\u003cul\u003e\u003cli id=\"51f7\"\u003eSharedFlow to remember the last emission if replay = 1.\u003c/li\u003e\u003cli id=\"82b2\"\u003eSharedFlow to remember the last 2 emissions if replay = 2 and so on.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9dd8\"\u003eAlso, we have emitted and collected inside the same coroutine. When we run the above code, the output will be\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3ed1\"\u003eKumar\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a508\"\u003eSince we have asked SharedFlow to remember the most recent emission, only that value\u003cstrong\u003e \u003c/strong\u003eis printed.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-05-21T09:31:08.96Z",
  "modifiedTime": null
}
