{
  "id": "d434e481-0cc1-46cd-8436-c355ad823803",
  "title": "Beautiful, Performant Android UI",
  "link": "https://instagram-engineering.com/beautiful-performant-android-ui-62ce61ca748c?source=rss----37dc2a3034f2--android",
  "description": "",
  "author": "Instagram Engineering",
  "published": "Tue, 21 Jun 2016 12:15:09 GMT",
  "source": "https://instagram-engineering.com/feed/tagged/android",
  "categories": [
    "instagram",
    "android-app-development",
    "android"
  ],
  "byline": "Instagram Engineering",
  "length": 13301,
  "excerpt": "At Instagram, our mission is to help people capture and share the world’s moments. We care deeply about the moments that people share on our platform, so enhancing how people view these moments is…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "At Instagram, our mission is to help people capture and share the world’s moments. We care deeply about the moments that people share on our platform, so enhancing how people view these moments is really important. Instagram recently launched a new design for Explore that includes “video channels”, which play in a new, full-screen, immersive experience. We optimized the user interface to make videos easier to watch, and it serves as a great example of how we approach building user interfaces on Android. We’ll share our approach and techniques, and hope they help you improve the look and feel of your own apps!Overview: The Immersive ViewerAs we were building this video viewer, we had several goals in mind. We wanted to provide an immersive user experience where you come to “sit back and watch” funny, creative, and engaging videos from holidays and special events like Halloween, New Year’s Eve, and the Oscars. The viewer automatically scrolls for you at the end of each video, but you still have control over the viewer by being able to scroll at the pace you want (as in feed). We also gave the immersive viewer a new look to make it a distinct experience from feed. Important differences to note are:The viewer paginates and centers the playing video in the middle of screen for you so that you don’t have to scroll. In feed, you have to manually drag and make sure the video is on the screen. In the viewer, switching to the previous or the next video is as simple as a fling or tap.We remove nonessential UI (such as video icons and feedback tools) to create fewer distractions.We use full-screen mode, hiding the status bar, to make the viewer feel immersive.The viewer has a dark theme and only the center video is highlighted to make it easier to focus while it’s playing.The immersive viewer is built as a subclass of ListView, to which we added custom touch event handling by overriding dispatchTouchEvent(). This allows us to reroute the touch events through a GestureDetector to our gesture listener, which would then determine whether it should consume these events and perform a custom action, or do nothing and just let the ListView handle them. Let’s take a fling action as an example. When you fling a video in the viewer, our gesture listener consumes it and initiates a custom pagination animation. The normal ListView fling action will not be triggered:@Overridepublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { .. If velocityY meets threshold for pagination, initiate pagination in the correct direction .. .. else, snap back to current video .. return true;}Other scroll actions like dragging are not consumed by our gesture listener, and are instead dispatched to the ListView so that you can still drag the viewer as you would with a normal ListView.Beautiful UI: Delight Users with Subtle, Natural AnimationsAnimations are fun. For this reason, they are often misused. It’s tempting to add flashy transitions that look really cool the first few times they are viewed, but quickly get obnoxious. The best animations bridge the gap between action and reaction, clarifying changes in UI elements in response to an external or internal trigger (i.e. user input, video finished playing, etc). They are quick, smooth, and subtle. In fact, they are so subtle that they may not be consciously registered by the user as animations, rather contributing to a general feeling of delight. For the immersive viewer, we used a combination of alpha and scale animations to accentuate certain UI elements during navigation. We applied spring-based interpolations, rather than polynomial, to make these animations feel natural.Alpha AnimationsLet’s say you need a view to appear or disappear in your UI. To achieve this effect, you’d normally just change its visibility via setVisibility(View.VISIBLE) or setVisibility(View.GONE). But when you test, it can feel quite jarring because there is no transition whatsoever but your UI is suddenly changed. Alpha animations can make this experience much nicer. We use many alpha animations in immersive viewer, including:Fade in/out the video header containing the usernameFade in/out the dark color overlay for an idle videoFade in/out the blurred cover overlay for an idle videoFade in/out the top and bottom shadows for the center videoFade in/out the heart that appears when double tapping to likeTaking the video header as an example, here is how it looks like with and without the alpha animation when navigating to another video: Left (without animation), Right (with animation):The alpha animations make these experiences more natural and smooth as the current header fades out and the next header fades in. Without the animation, the headers pop in and out and the UI feels choppy.Spring PhysicsRebound is a library built by Will Bailey (a fellow Instagram engineer) that makes it easy to apply spring physics to animations. We use Rebound for many animations in our app because we believe the spring dynamics make them look more natural than the polynomial-based interpolations provided by Android’s native Animation and Animator classes. Also, Rebound gives us the ability to incorporate real world properties, such as the velocity at which the user flings their finger on screen, into a spring’s motion.The pagination animation respects the velocity of the fling such that if you fling slowly, the viewer paginates with the respective low velocity. If you fling quickly, the viewer paginates with the respective high velocity. This natural experience is the reason why we chose springs to drive animations in the viewer. When building the viewer, we started with a single spring to sync together all the animations that run in parallel as you navigate: the pagination animation and the alpha animations. We made this decision because if, for example, the pagination animation finishes before the alpha animations, the views would continue to change in opacity even after they stop moving. Code structure and fling example:Our scroller object, PagingListViewScroller, encapsulates spring operations and tracks information like the current list position of the center video. We also have the custom ListView, scrubber, and other components (e.g. fragment) that listen to notifications from the scroller. When you fling a video in the viewer, it is handled as follows:The ListView consumes the action and triggers a vertical scroll event through the scroller, which sets the underlying spring in motion with the appropriate velocity and target offset.Then whenever the spring value updates, the scroller gets notified which in turn invokes the appropriate callback on each listener to take action.Scale AnimationsScale animations can be used to create visual effects that complement the UI. When entering the immersive viewer, we have an opening animation where a black background starts with zero height in the middle of the screen and then scales up to fill the entire screen, after which we fade in the immersive viewer. The motivation behind this was to mimic the behavior of turning on an old television and give the transition a fun, nostalgic touch. Left (Without animation), Right (With animation):The transition is much smoother with the animation, and we avoid the sudden change in UI that we discussed previously with alpha animations.Performant UI: It’s Not OptionalBuilding UI with cool animations and beautiful designs is important, but none of it is worthwhile if it isn’t performant. By making the correct optimizations, we can improve the design and feel of the UI without degrading performance. Using the Hierarchy Viewer to analyze view render times and the Traceview to profile method time spent, we optimized the immersive viewer to provide a smooth experience.Reduce Number of ViewsOne optimization we made to the viewer was to use the minimum number of views. This is something to consider in any application; the more views you have on screen, the more work your device has to do to render them. Furthermore, they take up memory and time to be instantiated, which could significantly impact memory on lower end devices and slow down loading of the UI. Our first implementation had four views per video:Blurred cover image overlayDark color overlayTop shadowBottom shadowWe reduced these views into one custom ImageView where the source is set to the blurred cover image. Then we overrode its onDraw() method to draw color for the dark color overlay and two drawables, one for each shadow. On animation steps, we set a custom alpha on each of these elements and invalidate the view, so that its onDraw() method will be called to be redrawn and reflect the current state of the animation.Optimize Alpha AnimationsThere are numerous alpha animations in the immersive viewer that take place as you navigate, so we had to optimize the way we change the alpha property of elements. There are different ways to change the alpha property — one is all setAlpha(float) on a View. This method is a two step process, where the first step is to allocate an off-screen buffer in GPU memory called a hardware layer and draw the view onto it. Then in the second step, the GPU copies pixels from the hardware layer to the screen, applying any alpha value that we set. The advantage of this two-step process is that the alpha blending will be correct on overlapping content on the screen. However, the significant downside is that the first step adds a lot of overhead.There are two approaches to optimize this method, but each has tradeoffs:view.setLayerType(View.LAYER_TYPE_HARDWARE, null);One approach is to set hardware layer type on the view you’re animating. This caches the hardware layer and reuses it so that we only do the first step once. While this approach keeps the alpha blending correct and makes the alpha animation performant, it still takes up GPU memory, so you have to remember to release the layer when you’re done using it. Also, this approach loses much of its performance gains if you invalidate the view too many times because the first step is run again on each invalidation. Hence it is not applicable to the immersive viewer because the viewer is built on ListView, which frequently invalidates its children views due to recycling and view rebinding.@Overridepublic boolean hasOverlappingRendering() { return false;}Another approach is to create a custom view and override this method to return false. This bypasses the hardware layer and the view is drawn directly to screen when you change its alpha property. A downside is that the alpha blending will be incorrect on overlapping content, but this may not be a problem depending on your application. You may also have to create numerous custom views if you want alpha animations on multiple views, as in the case of immersive viewer. Most importantly, this method is only supported on API level 16 and above.Another way to change the alpha property is to call setAlpha(int) on a Drawable. We chose this method for the alpha animations in immersive viewer as neither of the optimization approaches above fit our use case. This changes the alpha property of the drawable instance, as opposed to a view. It also doesn’t use any hardware layer, so the drawable is drawn directly onto screen. Compared to the hasOverlappingRendering() approach, this is better on two accounts. Not only is the method supported on all API levels, but we can also easily change the alpha property of the drawable underlying our view instead of defining a custom view. The downside is that the alpha blending will be incorrect on overlapping content. However, this is acceptable for the viewer as there are very few instances of overlapping content and we do not need 100% correct alpha blending even when elements overlap.Here’s an example in the immersive viewer to show the difference in performance between the two setAlpha methods: Left (setAlpha on views), Right (setAlpha on drawables):By setting alpha on views, the viewer begins to stutter as we scroll and its performance becomes worse with all the allocation of hardware layers. By setting alpha on drawables, the viewer remains smooth throughout the navigation.Redraw Specific ViewsIt’s important to redraw only the views that changed, especially during animations. For a ListView, this means invalidating only the child views whose properties have changed instead of calling notifyDataSetChanged() on the adapter, which redraws the entire ListView. In immersive viewer, we do not call notifyDataSetChanged() during our animations because we only want to reflect the UI state changes of the current video and the next video to play instead of the entire list.Wrapping UpFor every one of our features, we strive to provide the best user experience possible without regressing performance. Immersive viewer is no exception. We used various animations to make video viewing on Instagram more delightful, but we also put a ton of effort into making performance optimizations to ensure this delight is shared amongst all users, not just those with high-end devices. We hope that you can incorporate some of our approaches to building beautiful and performant experiences into your own Android development!Kevin Jung is a software engineer at Instagram.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:480/1*LaIFJO7g00xJoTx_HKukOg.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@InstagramEng?source=post_page-----62ce61ca748c--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*8x_1IP3b75o5u9M4LgFBig.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page-----62ce61ca748c--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"4b9d\"\u003eAt Instagram, our mission is to help people capture and share the world’s moments. We care deeply about the moments that people share on our platform, so enhancing \u003cem\u003ehow \u003c/em\u003epeople view these moments is really important. Instagram recently launched a new design for Explore that includes “video channels”, which play in a new, full-screen, immersive experience. We optimized the user interface to make videos easier to watch, and it serves as a great example of how we approach building user interfaces on Android. We’ll share our approach and techniques, and hope they help you improve the look and feel of your own apps!\u003c/p\u003e\u003ch2 id=\"51f7\"\u003eOverview: The Immersive Viewer\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"c935\"\u003e\u003cp\u003eAs we were building this video viewer, we had several goals in mind. We wanted to provide an immersive user experience where you come to “sit back and watch” funny, creative, and engaging videos from holidays and special events like Halloween, New Year’s Eve, and the Oscars. The viewer automatically scrolls for you at the end of each video, but you still have control over the viewer by being able to scroll at the pace you want (as in feed).\u003c/p\u003e\u003cp\u003e  We also gave the immersive viewer a new look to make it a distinct experience from feed. Important differences to note are:\u003c/p\u003e\u003c/div\u003e\u003cul\u003e\u003cli id=\"64bb\"\u003eThe viewer paginates and centers the playing video in the middle of screen for you so that you don’t have to scroll. In feed, you have to manually drag and make sure the video is on the screen. In the viewer, switching to the previous or the next video is as simple as a fling or tap.\u003c/li\u003e\u003cli id=\"4c96\"\u003eWe remove nonessential UI (such as video icons and feedback tools) to create fewer distractions.\u003c/li\u003e\u003cli id=\"a76d\"\u003eWe use full-screen mode, hiding the status bar, to make the viewer feel immersive.\u003c/li\u003e\u003cli id=\"6ef9\"\u003eThe viewer has a dark theme and only the center video is highlighted to make it easier to focus while it’s playing.\u003c/li\u003e\u003c/ul\u003e\u003cdiv id=\"88e4\"\u003e\u003cp\u003eThe immersive viewer is built as a subclass of ListView, to which we added custom touch event handling by overriding dispatchTouchEvent(). This allows us to reroute the touch events through a GestureDetector to our gesture listener, which would then determine whether it should consume these events and perform a custom action, or do nothing and just let the ListView handle them. \u003c/p\u003e\u003cp\u003e  Let’s take a fling action as an example. When you fling a video in the viewer, our gesture listener consumes it and initiates a custom pagination animation. The normal ListView fling action will not be triggered:\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\u003cspan id=\"c0c3\"\u003e@Override\u003cbr/\u003epublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {\u003cbr/\u003e  .. If velocityY meets threshold for pagination, initiate pagination in the correct direction ..\u003cbr/\u003e  .. else, snap back to current video ..\u003cp\u003e    return true;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"57f7\"\u003eOther scroll actions like dragging are not consumed by our gesture listener, and are instead dispatched to the ListView so that you can still drag the viewer as you would with a normal ListView.\u003c/p\u003e\u003ch2 id=\"5d6f\"\u003eBeautiful UI: Delight Users with Subtle, Natural Animations\u003c/h2\u003e\u003cdiv id=\"c6c8\"\u003e\u003cp\u003eAnimations are fun. For this reason, they are often misused. It’s tempting to add flashy transitions that look really cool the first few times they are viewed, but quickly get obnoxious.\u003c/p\u003e\u003cp\u003e  The best animations bridge the gap between action and reaction, clarifying changes in UI elements in response to an external or internal trigger (i.e. user input, video finished playing, etc). They are quick, smooth, and subtle. In fact, they are so subtle that they may not be consciously registered by the user as animations, rather contributing to a general feeling of delight.\u003c/p\u003e\u003cp\u003e  For the immersive viewer, we used a combination of alpha and scale animations to accentuate certain UI elements during navigation. We applied spring-based interpolations, rather than polynomial, to make these animations feel natural.\u003c/p\u003e\u003c/div\u003e\u003cp id=\"8600\"\u003e\u003cstrong\u003eAlpha Animations\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"346d\"\u003eLet’s say you need a view to appear or disappear in your UI. To achieve this effect, you’d normally just change its visibility via setVisibility(View.VISIBLE) or setVisibility(View.GONE). But when you test, it can feel quite jarring because there is no transition whatsoever but your UI is suddenly changed. Alpha animations can make this experience much nicer. We use many alpha animations in immersive viewer, including:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a362\"\u003eFade in/out the video header containing the username\u003c/li\u003e\u003cli id=\"5296\"\u003eFade in/out the dark color overlay for an idle video\u003c/li\u003e\u003cli id=\"e16f\"\u003eFade in/out the blurred cover overlay for an idle video\u003c/li\u003e\u003cli id=\"36bc\"\u003eFade in/out the top and bottom shadows for the center video\u003c/li\u003e\u003cli id=\"5940\"\u003eFade in/out the heart that appears when double tapping to like\u003c/li\u003e\u003c/ul\u003e\u003cdiv id=\"796e\"\u003e\u003cp\u003eTaking the video header as an example, here is how it looks like with and without the alpha animation when navigating to another video:\u003c/p\u003e\u003cp\u003e  Left (without animation), Right (with animation):\u003c/p\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"7e19\"\u003eThe alpha animations make these experiences more natural and smooth as the current header fades out and the next header fades in. Without the animation, the headers pop in and out and the UI feels choppy.\u003c/p\u003e\u003cp id=\"3e91\"\u003e\u003cstrong\u003eSpring Physics\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"7cd6\"\u003e\u003ca href=\"http://facebook.github.io/rebound/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRebound\u003c/a\u003e is a library built by Will Bailey (a fellow Instagram engineer) that makes it easy to apply spring physics to animations. We use Rebound for many animations in our app because we believe the spring dynamics make them look more natural than the polynomial-based interpolations provided by Android’s native Animation and Animator classes. Also, Rebound gives us the ability to incorporate real world properties, such as the velocity at which the user flings their finger on screen, into a spring’s motion.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"4fcc\"\u003e\u003cp\u003eThe pagination animation respects the velocity of the fling such that if you fling slowly, the viewer paginates with the respective low velocity. If you fling quickly, the viewer paginates with the respective high velocity. This natural experience is the reason why we chose springs to drive animations in the viewer.\u003c/p\u003e\u003cp\u003e  When building the viewer, we started with a single spring to sync together all the animations that run in parallel as you navigate: the pagination animation and the alpha animations. We made this decision because if, for example, the pagination animation finishes before the alpha animations, the views would continue to change in opacity even after they stop moving.\u003c/p\u003e\u003cp\u003e  Code structure and fling example:\u003c/p\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv id=\"ef91\"\u003e\u003cp\u003eOur scroller object, PagingListViewScroller, encapsulates spring operations and tracks information like the current list position of the center video. We also have the custom ListView, scrubber, and other components (e.g. fragment) that listen to notifications from the scroller.\u003c/p\u003e\u003cp\u003e  When you fling a video in the viewer, it is handled as follows:\u003c/p\u003e\u003c/div\u003e\u003cul\u003e\u003cli id=\"06bf\"\u003eThe ListView consumes the action and triggers a vertical scroll event through the scroller, which sets the underlying spring in motion with the appropriate velocity and target offset.\u003c/li\u003e\u003cli id=\"2907\"\u003eThen whenever the spring value updates, the scroller gets notified which in turn invokes the appropriate callback on each listener to take action.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7452\"\u003e\u003cstrong\u003eScale Animations\u003c/strong\u003e\u003c/p\u003e\u003cdiv id=\"59ad\"\u003e\u003cp\u003eScale animations can be used to create visual effects that complement the UI. When entering the immersive viewer, we have an opening animation where a black background starts with zero height in the middle of the screen and then scales up to fill the entire screen, after which we fade in the immersive viewer. The motivation behind this was to mimic the behavior of turning on an old television and give the transition a fun, nostalgic touch.\u003c/p\u003e\u003cp\u003e  Left (Without animation), Right (With animation):\u003c/p\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c675\"\u003eThe transition is much smoother with the animation, and we avoid the sudden change in UI that we discussed previously with alpha animations.\u003c/p\u003e\u003ch2 id=\"f1fc\"\u003ePerformant UI: It’s Not Optional\u003c/h2\u003e\u003cp id=\"e619\"\u003eBuilding UI with cool animations and beautiful designs is important, but none of it is worthwhile if it isn’t performant. By making the correct optimizations, we can improve the design and feel of the UI without degrading performance. Using the \u003ca href=\"https://developer.android.com/studio/profile/optimize-ui.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHierarchy Viewer\u003c/a\u003e to analyze view render times and the \u003ca href=\"https://developer.android.com/studio/profile/traceview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTraceview\u003c/a\u003e to profile method time spent, we optimized the immersive viewer to provide a smooth experience.\u003c/p\u003e\u003cp id=\"847f\"\u003e\u003cstrong\u003eReduce Number of Views\u003c/strong\u003e\u003c/p\u003e\u003cdiv id=\"2b0c\"\u003e\u003cp\u003eOne optimization we made to the viewer was to use the minimum number of views. This is something to consider in any application; the more views you have on screen, the more work your device has to do to render them. Furthermore, they take up memory and time to be instantiated, which could significantly impact memory on lower end devices and slow down loading of the UI.\u003c/p\u003e\u003cp\u003e  Our first implementation had four views per video:\u003c/p\u003e\u003c/div\u003e\u003cul\u003e\u003cli id=\"e995\"\u003eBlurred cover image overlay\u003c/li\u003e\u003cli id=\"5436\"\u003eDark color overlay\u003c/li\u003e\u003cli id=\"9cf6\"\u003eTop shadow\u003c/li\u003e\u003cli id=\"08eb\"\u003eBottom shadow\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"bc31\"\u003eWe reduced these views into one custom ImageView where the source is set to the blurred cover image. Then we overrode its onDraw() method to draw color for the dark color overlay and two drawables, one for each shadow. On animation steps, we set a custom alpha on each of these elements and invalidate the view, so that its onDraw() method will be called to be redrawn and reflect the current state of the animation.\u003c/p\u003e\u003cp id=\"6b28\"\u003e\u003cstrong\u003eOptimize Alpha Animations\u003c/strong\u003e\u003c/p\u003e\u003cdiv id=\"191b\"\u003e\u003cp\u003eThere are numerous alpha animations in the immersive viewer that take place as you navigate, so we had to optimize the way we change the alpha property of elements.\u003c/p\u003e\u003cp\u003e There are different ways to change the alpha property — one is all setAlpha(float) on a View. This method is a two step process, where the first step is to allocate an off-screen buffer in GPU memory called a hardware layer and draw the view onto it. Then in the second step, the GPU copies pixels from the hardware layer to the screen, applying any alpha value that we set. The advantage of this two-step process is that the alpha blending will be correct on overlapping content on the screen. However, the significant downside is that the first step adds a lot of overhead.\u003c/p\u003e\u003c/div\u003e\u003cp id=\"a32f\"\u003eThere are two approaches to optimize this method, but each has tradeoffs:\u003c/p\u003e\u003cp id=\"d075\"\u003e\u003cstrong\u003eview.setLayerType(View.LAYER_TYPE_HARDWARE, null);\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"51b2\"\u003eOne approach is to set hardware layer type on the view you’re animating. This caches the hardware layer and reuses it so that we only do the first step once. While this approach keeps the alpha blending correct and makes the alpha animation performant, it still takes up GPU memory, so you have to remember to release the layer when you’re done using it. Also, this approach loses much of its performance gains if you invalidate the view too many times because the first step is run again on each invalidation. Hence it is not applicable to the immersive viewer because the viewer is built on ListView, which frequently invalidates its children views due to recycling and view rebinding.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e7db\"\u003e\u003cstrong\u003e@Override\u003cbr/\u003epublic boolean hasOverlappingRendering() {\u003cbr/\u003e return false;\u003cbr/\u003e}\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9682\"\u003eAnother approach is to create a custom view and override this method to return false. This bypasses the hardware layer and the view is drawn directly to screen when you change its alpha property. A downside is that the alpha blending will be incorrect on overlapping content, but this may not be a problem depending on your application. You may also have to create numerous custom views if you want alpha animations on multiple views, as in the case of immersive viewer. Most importantly, this method is only supported on API level 16 and above.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ee51\"\u003eAnother way to change the alpha property is to call setAlpha(int) on a Drawable. We chose this method for the alpha animations in immersive viewer as neither of the optimization approaches above fit our use case. This changes the alpha property of the drawable instance, as opposed to a view. It also doesn’t use any hardware layer, so the drawable is drawn directly onto screen. Compared to the hasOverlappingRendering() approach, this is better on two accounts. Not only is the method supported on all API levels, but we can also easily change the alpha property of the drawable underlying our view instead of defining a custom view. The downside is that the alpha blending will be incorrect on overlapping content. However, this is acceptable for the viewer as there are very few instances of overlapping content and we do not need 100% correct alpha blending even when elements overlap.\u003c/p\u003e\u003cdiv id=\"d246\"\u003e\u003cp\u003eHere’s an example in the immersive viewer to show the difference in performance between the two setAlpha methods:\u003c/p\u003e\u003cp\u003e  Left (setAlpha on views), Right (setAlpha on drawables):\u003c/p\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"71c1\"\u003eBy setting alpha on views, the viewer begins to stutter as we scroll and its performance becomes worse with all the allocation of hardware layers. By setting alpha on drawables, the viewer remains smooth throughout the navigation.\u003c/p\u003e\u003cp id=\"d53e\"\u003e\u003cstrong\u003eRedraw Specific Views\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"5511\"\u003eIt’s important to redraw only the views that changed, especially during animations. For a ListView, this means invalidating only the child views whose properties have changed instead of calling notifyDataSetChanged() on the adapter, which redraws the entire ListView. In immersive viewer, we do not call notifyDataSetChanged() during our animations because we only want to reflect the UI state changes of the current video and the next video to play instead of the entire list.\u003c/p\u003e\u003ch2 id=\"cf00\"\u003eWrapping Up\u003c/h2\u003e\u003cp id=\"f32b\"\u003eFor every one of our features, we strive to provide the best user experience possible without regressing performance. Immersive viewer is no exception. We used various animations to make video viewing on Instagram more delightful, but we also put a ton of effort into making performance optimizations to ensure this delight is shared amongst all users, not just those with high-end devices. We hope that you can incorporate some of our approaches to building beautiful and performant experiences into your own Android development!\u003c/p\u003e\u003cp id=\"55e8\"\u003e\u003cem\u003eKevin Jung is a software engineer at Instagram.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2016-06-21T05:26:03.593Z",
  "modifiedTime": null
}
