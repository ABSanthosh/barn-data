{
  "id": "0aca8745-6b50-496e-ba99-25c00ac5e0c0",
  "title": "Routines to Coroutines: How Kotlin Revolutionized Asynchronous Programming",
  "link": "https://proandroiddev.com/routines-to-coroutines-how-kotlin-revolutionized-asynchronous-programming-420df96b59f7?source=rss----c72404660798---4",
  "description": "",
  "author": "Ninad Bhase",
  "published": "Mon, 31 Mar 2025 15:04:07 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "kotlin",
    "programming",
    "coroutines-in-kotlin"
  ],
  "byline": "Ninad Bhase",
  "length": 5065,
  "excerpt": "In traditional programming, execution flow is structured around a main routine (the entry point of the program) and subroutines (helper functions that perform specific tasks). In our previous example…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "The Basics: Main Routine and SubroutinesIn traditional programming, execution flow is structured around a main routine (the entry point of the program) and subroutines (helper functions that perform specific tasks).What is a Main Routine?The main routine (often called main()) is:The entry point of every program.The first function that executes when you run your code.Responsible for orchestrating the program’s workflow.In Kotlin/Java/C-style languages, it looks like this:fun main() { // Program starts executing here first() second()}Key characteristics:Mandatory — Every executable program must have oneParent function — Calls other subroutinesLifecycle controller — Determines the order of operationsWhat are Subroutines?Subroutines (also called functions/methods) are:Reusable blocks of code that perform specific tasksCalled by the main routine or other subroutinesModularize code into logical unitsfun first() { // Does task A}fun second() { // Does task B}Key characteristics:Single Responsibility — Each should do one thing wellCallable — Can be invoked multiple timesStack-based — Follows Last-In-First-Out (LIFO) executionfun main() { first() //subroutine second() //subroutine}fun first() { var first = 1 while (true) { println(\"first: ${first++}\") }}fun second() { var second = 1 while (true) { println(\"second: ${second++}\") }}What actually happens:Program launches → main() starts executingmain() calls first() → execution jumps to first()first() enters infinite loop → never returnssecond() never gets called because control never returns to main()The Critical LimitationThis demonstrates a fundamental programming constraint:Subroutines are blocking — The caller waits until completionNo concurrency — Only one function executes at any momentOrder-dependent — Strict sequential executionVisualizing the Call StackCall Stack State----------- -------- Program startsmain() Calls first()first() Enters loop[stack frozen] first() never returnsThis blocking behavior is exactly what coroutines solve by introducing:Suspendable functionsNon-blocking operationsConcurrent executionIn our previous example with traditional subroutines, we saw how first()'s infinite loop completely blocked execution of second(). Now let's examine how coroutines revolutionize this behavior:fun main(): Unit = runBlocking { launch { first() } // coroutine 1 launch { second() } // coroutine 2}suspend fun first() { var first = 1 while (true) { println(\"first: ${first++}\") delay(2000) // Suspension point }}suspend fun second() { var second = 1 while (true) { println(\"second: ${second++}\") delay(1000) // Suspension point }}Key Differences from Subroutines1. Non-Blocking Concurrent ExecutionBoth functions now run concurrently instead of sequentiallyOutput will interleave: “second” prints twice as often as “first”Neither function blocks the other2. The Magic of Suspension Pointsdelay() is a suspension function that pauses execution without blockingWhen encountered, the coroutine:Yields the threadSchedules resumptionAllows other coroutines to run3. Structured ConcurrencyrunBlocking creates a coroutine scopelaunch starts new coroutines as children of this scopeAll coroutines are automatically cancelled when the scope completesHow This Works InternallyCoroutine Execution TimelineTime (ms) | Coroutine 1 (first) | Coroutine 2 (second)----------|--------------------------|----------------------0 | Prints \"first: 1\" | | Suspends for 2000ms | Prints \"second: 1\" | | Suspends for 1000ms1000 | | Resumes, prints \"second: 2\" | | Suspends for 1000ms2000 | Resumes, prints \"first: 2\"| | Suspends for 2000ms | Prints \"second: 3\"3000 | | Resumes, prints \"second: 4\"... | ... | ...Why This MattersResource EfficiencyTraditional threads: ~1MB stack per threadCoroutines: ~50 bytes per suspended coroutine2. Simplified ConcurrencyNo callback hellSequential-looking code with asynchronous execution3. Responsive ApplicationsNever blocks the main threadEasy to implement features like:Parallel network requestsAnimations with delaysBackground processingVisual ComparisonSubroutine Executionmain()└── first() (runs forever) └── second() (never reached)Coroutine ExecutionrunBlocking├── launch { first() } (suspends/resumes)└── launch { second() } (suspends/resumes)ConclusionThis demonstrates the paradigm shift from linear, blocking execution to flexible, non-blocking concurrency. By leveraging suspension points and structured concurrency, coroutines enable efficient multitasking without sacrificing code clarity. This evolution from rigid subroutine execution to flexible coroutines represents a fundamental advancement in asynchronous programming.Hope you liked this article. Happy Coding!!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*GA2-MxyMW4IxSNjQGgIQ2g.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@ninadbhase?source=post_page---byline--420df96b59f7---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ninad Bhase\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*8WbCaAGOMdDID42CWxRg5A.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--420df96b59f7---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"9a90\"\u003eThe Basics: Main Routine and Subroutines\u003c/h2\u003e\u003cp id=\"3f73\"\u003eIn traditional programming, execution flow is structured around a \u003cstrong\u003emain routine\u003c/strong\u003e (the entry point of the program) and \u003cstrong\u003esubroutines\u003c/strong\u003e (helper functions that perform specific tasks).\u003c/p\u003e\u003ch2 id=\"c640\"\u003eWhat is a Main Routine?\u003c/h2\u003e\u003cp id=\"a6d1\"\u003eThe \u003cstrong\u003emain routine\u003c/strong\u003e (often called \u003ccode\u003emain()\u003c/code\u003e) is:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ad54\"\u003eThe \u003cstrong\u003eentry point\u003c/strong\u003e of every program.\u003c/li\u003e\u003cli id=\"3d93\"\u003eThe \u003cstrong\u003efirst function\u003c/strong\u003e that executes when you run your code.\u003c/li\u003e\u003cli id=\"c018\"\u003eResponsible for \u003cstrong\u003eorchestrating\u003c/strong\u003e the program’s workflow.\u003c/li\u003e\u003cli id=\"77c4\"\u003eIn Kotlin/Java/C-style languages, it looks like this:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"a435\"\u003efun main() {\u003cbr/\u003e    // Program starts executing here\u003cbr/\u003e    first()\u003cbr/\u003e    second()\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5b28\"\u003eKey characteristics:\u003c/p\u003e\u003col\u003e\u003cli id=\"0e04\"\u003e\u003cstrong\u003eMandatory\u003c/strong\u003e — Every executable program must have one\u003c/li\u003e\u003cli id=\"d48f\"\u003e\u003cstrong\u003eParent function\u003c/strong\u003e — Calls other subroutines\u003c/li\u003e\u003cli id=\"8c7d\"\u003e\u003cstrong\u003eLifecycle controller\u003c/strong\u003e — Determines the order of operations\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"22a6\"\u003eWhat are Subroutines?\u003c/h2\u003e\u003cp id=\"91ca\"\u003eSubroutines (also called functions/methods) are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0028\"\u003e\u003cstrong\u003eReusable blocks\u003c/strong\u003e of code that perform specific tasks\u003c/li\u003e\u003cli id=\"576c\"\u003e\u003cstrong\u003eCalled by\u003c/strong\u003e the main routine or other subroutines\u003c/li\u003e\u003cli id=\"5923\"\u003e\u003cstrong\u003eModularize\u003c/strong\u003e code into logical units\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"4b59\"\u003efun first() {\u003cbr/\u003e    // Does task A\u003cbr/\u003e}\u003cp\u003efun second() {\u003cbr/\u003e    // Does task B\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2187\"\u003eKey characteristics:\u003c/p\u003e\u003col\u003e\u003cli id=\"5754\"\u003e\u003cstrong\u003eSingle Responsibility\u003c/strong\u003e — Each should do one thing well\u003c/li\u003e\u003cli id=\"ed02\"\u003e\u003cstrong\u003eCallable\u003c/strong\u003e — Can be invoked multiple times\u003c/li\u003e\u003cli id=\"3292\"\u003e\u003cstrong\u003eStack-based\u003c/strong\u003e — Follows Last-In-First-Out (LIFO) execution\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"d78f\"\u003efun main() {\u003cbr/\u003e    first() //subroutine\u003cbr/\u003e    second() //subroutine\u003cbr/\u003e}\u003cp\u003efun first() {\u003cbr/\u003e    var first = 1\u003cbr/\u003e    while (true) {\u003cbr/\u003e        println(\u0026#34;first: ${first++}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun second() {\u003cbr/\u003e    var second = 1\u003cbr/\u003e    while (true) {\u003cbr/\u003e        println(\u0026#34;second: ${second++}\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"44a4\"\u003eWhat actually happens:\u003c/p\u003e\u003col\u003e\u003cli id=\"6202\"\u003eProgram launches → \u003ccode\u003emain()\u003c/code\u003e starts executing\u003c/li\u003e\u003cli id=\"8bff\"\u003e\u003ccode\u003emain()\u003c/code\u003e calls \u003ccode\u003efirst()\u003c/code\u003e → execution jumps to \u003ccode\u003efirst()\u003c/code\u003e\u003c/li\u003e\u003cli id=\"629a\"\u003e\u003ccode\u003efirst()\u003c/code\u003e enters infinite loop → \u003cstrong\u003enever returns\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"eca4\"\u003e\u003ccode\u003esecond()\u003c/code\u003e \u003cstrong\u003enever gets called\u003c/strong\u003e because control never returns to \u003ccode\u003emain()\u003c/code\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"6425\"\u003eThe Critical Limitation\u003c/h2\u003e\u003cp id=\"e56a\"\u003eThis demonstrates a fundamental programming constraint:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0966\"\u003e\u003cstrong\u003eSubroutines are blocking\u003c/strong\u003e — The caller waits until completion\u003c/li\u003e\u003cli id=\"9bce\"\u003e\u003cstrong\u003eNo concurrency\u003c/strong\u003e — Only one function executes at any moment\u003c/li\u003e\u003cli id=\"dc33\"\u003e\u003cstrong\u003eOrder-dependent\u003c/strong\u003e — Strict sequential execution\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"11ba\"\u003eVisualizing the Call Stack\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"8df7\"\u003eCall Stack          State\u003cbr/\u003e-----------        --------\u003cbr/\u003e                    Program starts\u003cbr/\u003emain()             Calls first()\u003cbr/\u003efirst()            Enters loop\u003cbr/\u003e[stack frozen]     first() never returns\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0106\"\u003eThis blocking behavior is exactly what \u003cstrong\u003ecoroutines\u003c/strong\u003e solve by introducing:\u003c/p\u003e\u003cul\u003e\u003cli id=\"67f9\"\u003eSuspendable functions\u003c/li\u003e\u003cli id=\"0bad\"\u003eNon-blocking operations\u003c/li\u003e\u003cli id=\"6e8f\"\u003eConcurrent execution\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c58e\"\u003eIn our previous example with traditional subroutines, we saw how \u003ccode\u003efirst()\u003c/code\u003e\u0026#39;s infinite loop completely blocked execution of \u003ccode\u003esecond()\u003c/code\u003e. Now let\u0026#39;s examine how coroutines revolutionize this behavior:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b867\"\u003efun main(): Unit = runBlocking {\u003cbr/\u003e    launch { first() }  // coroutine 1\u003cbr/\u003e    launch { second() } // coroutine 2\u003cbr/\u003e}\u003cp\u003esuspend fun first() {\u003cbr/\u003e    var first = 1\u003cbr/\u003e    while (true) {\u003cbr/\u003e        println(\u0026#34;first: ${first++}\u0026#34;)\u003cbr/\u003e        delay(2000) // Suspension point\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003esuspend fun second() {\u003cbr/\u003e    var second = 1\u003cbr/\u003e    while (true) {\u003cbr/\u003e        println(\u0026#34;second: ${second++}\u0026#34;)\u003cbr/\u003e        delay(1000) // Suspension point\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c391\"\u003eKey Differences from Subroutines\u003c/h2\u003e\u003ch2 id=\"93db\"\u003e1. Non-Blocking Concurrent Execution\u003c/h2\u003e\u003cul\u003e\u003cli id=\"08c2\"\u003eBoth functions now run \u003cstrong\u003econcurrently\u003c/strong\u003e instead of sequentially\u003c/li\u003e\u003cli id=\"a0a7\"\u003eOutput will interleave: “second” prints twice as often as “first”\u003c/li\u003e\u003cli id=\"79db\"\u003eNeither function blocks the other\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5be2\"\u003e2. The Magic of Suspension Points\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1104\"\u003e\u003ccode\u003edelay()\u003c/code\u003e is a \u003cstrong\u003esuspension function\u003c/strong\u003e that pauses execution without blocking\u003c/li\u003e\u003cli id=\"31d5\"\u003eWhen encountered, the coroutine:\u003c/li\u003e\u003cli id=\"3269\"\u003eYields the thread\u003c/li\u003e\u003cli id=\"363c\"\u003eSchedules resumption\u003c/li\u003e\u003cli id=\"7621\"\u003eAllows other coroutines to run\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f229\"\u003e3. Structured Concurrency\u003c/h2\u003e\u003cul\u003e\u003cli id=\"4e2c\"\u003e\u003ccode\u003erunBlocking\u003c/code\u003e creates a coroutine scope\u003c/li\u003e\u003cli id=\"b5b5\"\u003e\u003ccode\u003elaunch\u003c/code\u003e starts new coroutines as children of this scope\u003c/li\u003e\u003cli id=\"1b0b\"\u003eAll coroutines are automatically cancelled when the scope completes\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4d33\"\u003eHow This Works Internally\u003c/h2\u003e\u003cp id=\"8c9f\"\u003eCoroutine Execution Timeline\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7b3d\"\u003eTime (ms) | Coroutine 1 (first)      | Coroutine 2 (second)\u003cbr/\u003e----------|--------------------------|----------------------\u003cbr/\u003e0         | Prints \u0026#34;first: 1\u0026#34;        | \u003cbr/\u003e          | Suspends for 2000ms      | Prints \u0026#34;second: 1\u0026#34;\u003cbr/\u003e          |                          | Suspends for 1000ms\u003cbr/\u003e1000      |                          | Resumes, prints \u0026#34;second: 2\u0026#34;\u003cbr/\u003e          |                          | Suspends for 1000ms\u003cbr/\u003e2000      | Resumes, prints \u0026#34;first: 2\u0026#34;|\u003cbr/\u003e          | Suspends for 2000ms      | Prints \u0026#34;second: 3\u0026#34;\u003cbr/\u003e3000      |                          | Resumes, prints \u0026#34;second: 4\u0026#34;\u003cbr/\u003e...       | ...                      | ...\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"f95a\"\u003eWhy This Matters\u003c/h2\u003e\u003col\u003e\u003cli id=\"805b\"\u003e\u003cstrong\u003eResource Efficiency\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"eb0c\"\u003eTraditional threads: ~1MB stack per thread\u003c/li\u003e\u003cli id=\"910c\"\u003eCoroutines: ~50 bytes per suspended coroutine\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"afab\"\u003e2. \u003cstrong\u003eSimplified Concurrency\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8162\"\u003eNo callback hell\u003c/li\u003e\u003cli id=\"1a4b\"\u003eSequential-looking code with asynchronous execution\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fed7\"\u003e3\u003cstrong\u003e. Responsive Applications\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"fcb6\"\u003eNever blocks the main thread\u003c/li\u003e\u003cli id=\"93de\"\u003eEasy to implement features like:\u003c/li\u003e\u003cli id=\"3f4a\"\u003eParallel network requests\u003c/li\u003e\u003cli id=\"d1cd\"\u003eAnimations with delays\u003c/li\u003e\u003cli id=\"881d\"\u003eBackground processing\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"63b7\"\u003e\u003cstrong\u003eVisual Comparison\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"fb4a\"\u003e\u003cstrong\u003eSubroutine Execution\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"07e8\"\u003emain()\u003cbr/\u003e└── first() (runs forever)\u003cbr/\u003e    └── second() (never reached)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0fa8\"\u003e\u003cstrong\u003eCoroutine Execution\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b6bf\"\u003erunBlocking\u003cbr/\u003e├── launch { first() } (suspends/resumes)\u003cbr/\u003e└── launch { second() } (suspends/resumes)\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"f317\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"afea\"\u003eThis demonstrates the paradigm shift from linear, blocking execution to flexible, non-blocking concurrency. By leveraging suspension points and structured concurrency, coroutines enable efficient multitasking without sacrificing code clarity. This evolution from rigid subroutine execution to flexible coroutines represents a fundamental advancement in asynchronous programming.\u003c/p\u003e\u003cp id=\"c43e\"\u003eHope you liked this article. Happy Coding!!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-03-30T07:25:26.11Z",
  "modifiedTime": null
}
