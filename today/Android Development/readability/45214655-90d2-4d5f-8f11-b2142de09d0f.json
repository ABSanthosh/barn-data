{
  "id": "45214655-90d2-4d5f-8f11-b2142de09d0f",
  "title": "Kotlin Multiplatform Scalability Challenges on a Large Project",
  "link": "https://proandroiddev.com/kotlin-multiplatform-scalability-challenges-on-a-large-project-b3140e12da9d?source=rss----c72404660798---4",
  "description": "",
  "author": "Andrei Beriukhov",
  "published": "Mon, 24 Feb 2025 14:29:41 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "multiplatform",
    "mobile",
    "kotlin",
    "kmp",
    "enterprise"
  ],
  "byline": "Andrei Beriukhov",
  "length": 13878,
  "excerpt": "Real-world experiences, including migration strategies, developer trade-offs, and lessons learned from integrating.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "I started native Android engineering in 2015, and in 2017 I was inspired by two new multiplatform frameworks: Flutter and Kotlin Multiplatform. Although KMP was harder to build and use compared to Flutter, I believed from the beginning that it had more potential.This was mainly because it reuses native Android language and practices while offering a most delicate approach to multiplatform features.Since then, I have continued to follow its progress, experimenting with new features in my open-source projects like Coffegram.When it became stable, I looked for an opportunity to try it in a real project. Here, I will describe my experience in one real large-scale project.This article consists of four parts:Background on the project I worked on and the company’s previous experience with KMP in a library.A comparison of two component development approaches: library vs. product feature, which is important for the following sections.A description of methods for migrating components to KMP, including the challenges faced.Finally, an overview of our experiment moving a product feature from native to KMP, along with A/B test results.First company’s experience with KMP in a libraryI mentioned a large project in the title because it introduces challenges you might never encounter in a smaller-scale project.I consider the project I worked on large because it had more than 1000 Gradle modules in the native Android app (with a similar scale in iOS) and was developed by more than 150 mobile developers (iOS \u0026 Android).Code for each platform is located in two monorepositories and assembled at once.Each repository is developed by two types of developers:Product developers included in cross-functional product teamsPlatform developers included in separate 4x2 platform teams (architecture, build tools, design system, and performance for each mobile platform)Before the current experiment with KMP, part of the team had already gained successful experience.They created a library for in-app calls using WebRTC and WebSockets.WebRTC is a complex C++ library that needed an additional business logic layer.The reason colleagues tried KMP was that the product team lacked an iOS engineer at that time.So they persuaded management to try KMP for both Android and iOS.If something went wrong, they planned to rewrite it natively once an iOS engineer was hired, keeping the library native at least on Android in the worst-case scenario.However, the experiment, the KMP library, and the feature as a whole succeeded. It has been working well in production for more than two years.The downside was that almost none of the other mobile developers knew how it was created or how to work with KMP.This library is still located in a separate repository, built separately, and connected to each project as a third-party artifact. And that is almost all we know.Product feature vs libraryIn this part I’ll describe why product feature development on KMP differs significantly from a separate library.To do that we should clearly define the boundaries between them.Let’s look at the scheme. It is a rethinking of Clean Architecture applied to mobile development.Typical structure of product featureIt helps us align on the idea that a product feature is a codebase encompassing all layers — from UI through business logic to data retrieval from the backend or a local database.This differs from a library, which is usually separate from product features and behaves like an external SDK.Typically, it has minimal dependencies on other project components.On the contrary, a product feature relies on many core platform libraries, including:Common UI architecture libraryProduct analytics libraryPerformance metrics libraryDeeplinks libraryCommon DI frameworkCore network layer…Referring back to the scheme, we determined that all parts except the native UI could be migrated to KMP.Shareable parts of product feature with KMPFor the UI we intentionally did not explore Compose Multiplatform, opting to keep the native UI.Core libs migration to KMP: Methods and ChallengesTo launch the product feature in KMP, we first needed to migrate core libraries. For that, we had two main approaches:First: take a native Android library (also called a platform feature) and refactor it to be multiplatform.Second: write a common adapter over two same native libraries — wrapping Android and iOS. This allows the adapter to be used in common code.Android Library Migration ExampleWe used the first approach to migrate the internal MVI Flow library.Previously, MVI was chosen as the common UI architecture for the entire Android app.Colleagues created a library for it based on Coroutines Flows for component communication.While migrating it to KMP, we were fortunate that the library was relatively new and ready for common code extraction — it had already separated platform-independent and dependent code from the beginning.Pros of this approach: we can reuse the existing native part. This means we only need to support two libraries (KMP and iOS-native) for three platforms (Android, iOS, KMP) instead of three separate implementations.Main downside: since we migrated the library in a separate KMP repository (to avoid disrupting development for 70+ others), its native version diverged slightly.In most cases an existing native library may not be ready for easy migration.If it was built for Android long ago, it may have issues like leaking resources, context dependencies, and Java-based dependencies in many places, making migration a significant challenge.Another downside: You still need to adapt iOS native code to be compatible with the KMP library.Adapting MVI for iOSIn our case with MVI on KMP, we still had to adapt the native UI code. We used four layers of abstraction:In commonMain source set of MVI Flow we had CommonViewModel with a suspend function to receive Intents from UI and a Coroutines Flow for State updates. It was used in both Android \u0026 iOS.In iosMain, the Coroutines Flow was wrapped with CFlow, and iOSViewModel extended CommonViewModel.In native iOS, it was wrapped into @Published + ViewModel: ObservableObject, enabling its use in SwiftUI.However, this was not our case, as iOS engineers were uncertain about using SwiftUI yet.We adopted this ViewModel for UIKit in presenters.The last part of the code took as much effort as the previous three combined, as seen in the screenshot.UIKit vs SwiftUI wrappers size for MVI from KMPNetwork layer unification optionsAfter migrating the UI architecture we switched to a common network layer.The most challenging part: it is rather thick due to the common network request logic and product feature contracts.The contracts themselves have a common issue — they differ slightly between the two platforms: they may use different API versions or support different field lists.Even for a single product feature, migrating to KMP involves handling a lot of network logic, including:JSON parsingAttaching mandatory headersAuthorization session lifecycle handling — it should be synchronized across native and multiplatform requestsAntifraud mechanismsRequest performance metric…The network core logic also had differences between iOS and Android.One platform could have some dead features with unused headers still being sent.Other features could work differently.Like many others, we tried using a standard solution — Ktor library.I won’t describe its implementation but will highlight the issues and needs it could not help us with:1. Ktor in iOS works with the Darwin Engine based on NSUrlSession.We couldn’t use it with our preconfigured iOS native network layers because parts of the logic were built on NSUrlSession, others on Alamofire library, while some were just callbacks on each request.We looked for a way to use the Darwin Engine based on a preconfigured Alamofire instead of NSUrlSession and even raised an issue.2. During the migration process, we unexpectedly discovered (due to communication gaps in a large team) that the platform performance team was actively researching a migration from HTTP/2 to HTTP/3 over the QUIC protocol.They planned to migrate all requests to QUIC soon.However, QUIC was not supported in Ktor or even in the native Android OkHttp library directly (we used Cronet).At that time, OkHttp was planned for KMP support in 5.0.0-alpha.4.But from 5.0.0-alpha.13 onward, this support was dropped in favor of Ktor.Currently, work on QUIC in Ktor is in progress. You can track progress on GitHub or this issue.Since our experiment couldn’t wait, we agreed to use Ktor without QUIC for a single feature.We rewrote the core logic for it and planned to revisit the decision later.To sum up, the network library was written from scratch, incorporating research from both platform implementations.Native Libs Wrapping DownsidesMostly, we wrapped other platform libraries with a small API.But why didn’t we try to wrap native network implementations?Firstly, we would need to support this adapter after every major change in the native part. This means we would have three dependent libraries, making maintenance difficult.Secondly, wrapping two different native implementations is harder than migrating one (e.g., Android, as it is already in Kotlin).As we have seen in network logic, native libraries can differ significantly, causing platform-specific behaviors to leak into the common interface.Of course, this approach has some benefits:First, it usually does not require adaption of the native iOS code.The native iOS application continues using the native iOS library directly, while the common code interacts with it through an adapter.Any updates to the native iOS library will be automatically reflected in both implementaion, ensuring consistency across.Secondly, in the future, we can use the adapter to replace the implementation.For example, if we wrap the network layer, we could later switch to Ktor or another multiplatform library when they support QUIC, without additional costs.The experimentIt’s time to proceed to the main part of the article: an A/B test on a real product feature that we migrated from native to KMP, measuring the results in production.Feature choiceWe began by defining criteria to ensure the feature was representative yet not too difficult to migrate:It uses the MVI Flow library, allowing us to migrate its business logic as is.The feature is covered by performance metrics, which we compared in an A/B test with the native implementation.It requires authorization, including session-refresh logic and necessary headers, making it relevant to most features.The feature was experimental not only for KMP but also for Compose UI on Android.Since Compose and SwiftUI seem to be converging in modern mobile development, we tested them together.It is covered by UI E2E tests, helping us verify that the migration didn’t break business logic.It is small in size (2 server requests, 2 screens), making it easy to implement and roll back if needed.It has minimal internal dependencies, reducing the need to migrate core libraries beforehand.It has no dependencies on other product features.Experiment requirementsThe primary measurable metrics were the existing performance metrics automatically tracked by the split service (more on it).On iOS: Native UI (UIKit) + Native logic vs. Native UI (UIKit) + KMP logic.On Android: Native UI (XML) + Native logic vs. Native UI (Compose) + KMP logic.Additionally, platform teams set specific requirements:The Build Tools (aka Speed) team, responsible for local and CI build times, required that KMP have no impact on build speed.The Mobile Architecture team focused on the developer experience when using KMP, particularly regarding:Incremental changesDebugging errors in common codePublishing new versionsIt was expected that most challenges would arise from the iOS build process.Results🟢 A/B test — No performance issuesWe expected KMP to be slower on iOS, but it was not. Both platforms showed neutral (gray) results, meaning no significant difference in performance metrics.🟢 Native project build time — No impactWe added KMP to the main projects as a built library (via Artifactory), so it did not affect build time at all.🟢 Incremental KMP development experienceFor local development, we used Maven Local for Android and a local framework for iOS.On Android, performance was similar to a regular Android module, making it fast for feature development and debugging before checking on iOS.Kotlin for iOS builds was initially slow but has improved significantly over time with Kotlin/Native enhancements.🟢 Debugging experienceDebugging was smooth, both in understanding UI state changes through MVI Flow logs and handling crashes.On iOS, stack traces directly pointed to Kotlin code, making debugging easier.🟡 New version publicationChallenges arose from:The prior KMP library setup.The iOS limitation of supporting only one KMP framework per app (KT-42250).A common solution is to use a single umbrella module for the iOS framework, incorporating all other KMP modules. We had to:Change the Calls publication format to klib.Include WebRTC transitively.Build a single bundle containing the migrated feature and core code.Use this as a single framework (with a unified namespace) in the iOS app.While the process was clear, implementing it correctly took time and required collaboration with the Calls team.🟡 iOS build issues and workaroundsThe native iOS app had many modules and used a custom build tool.Unlike standard tutorials, we couldn’t simply add the KMP framework to Xcode and auto-include it.Instead, we had to adapt it for the custom build tool with help from the iOS platform team.1 year laterColleagues removed the remnants of the experiment from the code, shifting the development focus toward a backend-driven UI framework.Its client-side implementation is based on KMP with native UI components.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*ArDkW2gnaDJN_mHLhsqXnQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://beriukhov.medium.com/?source=post_page---byline--b3140e12da9d---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Andrei Beriukhov\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*GVYwwMwoxko446IXnqe3fA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--b3140e12da9d---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9ddc\"\u003eI started native Android engineering in 2015, and in 2017 I was inspired by two new multiplatform frameworks: Flutter and Kotlin Multiplatform. Although KMP was harder to build and use compared to Flutter, I believed from the beginning that it had more potential.\u003cbr/\u003eThis was mainly because it reuses native Android language and practices while offering a most delicate approach to multiplatform features.\u003cbr/\u003eSince then, I have continued to follow its progress, experimenting with new features in my open-source projects like \u003ca href=\"https://github.com/phansier/Coffeegram\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCoffegram\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"40f8\"\u003eWhen it became stable, I looked for an opportunity to try it in a real project. Here, I will describe my experience in one real large-scale project.\u003c/p\u003e\u003cp id=\"1eed\"\u003eThis article consists of four parts:\u003c/p\u003e\u003cul\u003e\u003cli id=\"437d\"\u003eBackground on the project I worked on and the company’s previous experience with KMP in a library.\u003c/li\u003e\u003cli id=\"8de7\"\u003eA comparison of two component development approaches: library vs. product feature, which is important for the following sections.\u003c/li\u003e\u003cli id=\"05d9\"\u003eA description of methods for migrating components to KMP, including the challenges faced.\u003c/li\u003e\u003cli id=\"5ef0\"\u003eFinally, an overview of our experiment moving a product feature from native to KMP, along with A/B test results.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5e32\"\u003eFirst company’s experience with KMP in a library\u003c/h2\u003e\u003cp id=\"e412\"\u003eI mentioned a large project in the title because it introduces challenges you might never encounter in a smaller-scale project.\u003cbr/\u003eI consider the project I worked on large because it had more than 1000 Gradle modules in the native Android app (with a similar scale in iOS) and was developed by more than 150 mobile developers (iOS \u0026amp; Android).\u003cbr/\u003eCode for each platform is located in two monorepositories and assembled at once.\u003cbr/\u003eEach repository is developed by two types of developers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"4d03\"\u003eProduct developers included in cross-functional product teams\u003c/li\u003e\u003cli id=\"da5f\"\u003ePlatform developers included in separate 4x2 platform teams (architecture, build tools, design system, and performance for each mobile platform)\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b807\"\u003eBefore the current experiment with KMP, part of the team had already gained successful experience.\u003cbr/\u003eThey created a library for in-app calls using WebRTC and WebSockets.\u003c/p\u003e\u003cp id=\"f1f3\"\u003eWebRTC is a complex C++ library that needed an additional business logic layer.\u003cbr/\u003eThe reason colleagues tried KMP was that the product team lacked an iOS engineer at that time.\u003cbr/\u003eSo they persuaded management to try KMP for both Android and iOS.\u003cbr/\u003eIf something went wrong, they planned to rewrite it natively once an iOS engineer was hired, keeping the library native at least on Android in the worst-case scenario.\u003c/p\u003e\u003cp id=\"95bb\"\u003eHowever, the experiment, the KMP library, and the feature as a whole succeeded. It has been working well in production for more than two years.\u003cbr/\u003eThe downside was that almost none of the other mobile developers knew how it was created or how to work with KMP.\u003c/p\u003e\u003cp id=\"a356\"\u003eThis library is still located in a separate repository, built separately, and connected to each project as a third-party artifact. And that is almost all we know.\u003c/p\u003e\u003ch2 id=\"e4a7\"\u003eProduct feature vs library\u003c/h2\u003e\u003cp id=\"dcea\"\u003eIn this part I’ll describe why product feature development on KMP differs significantly from a separate library.\u003cbr/\u003eTo do that we should clearly define the boundaries between them.\u003c/p\u003e\u003cp id=\"2815\"\u003eLet’s look at the scheme. It is a rethinking of Clean Architecture applied to mobile development.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eTypical structure of product feature\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"7f3e\"\u003eIt helps us align on the idea that a product feature is a codebase encompassing all layers — from UI through business logic to data retrieval from the backend or a local database.\u003cbr/\u003eThis differs from a library, which is usually separate from product features and behaves like an external SDK.\u003cbr/\u003eTypically, it has minimal dependencies on other project components.\u003cbr/\u003eOn the contrary, a product feature relies on many core platform libraries, including:\u003c/p\u003e\u003cul\u003e\u003cli id=\"926f\"\u003eCommon UI architecture library\u003c/li\u003e\u003cli id=\"85d3\"\u003eProduct analytics library\u003c/li\u003e\u003cli id=\"5118\"\u003ePerformance metrics library\u003c/li\u003e\u003cli id=\"7161\"\u003eDeeplinks library\u003c/li\u003e\u003cli id=\"cf0e\"\u003eCommon DI framework\u003c/li\u003e\u003cli id=\"ef7c\"\u003eCore network layer\u003c/li\u003e\u003cli id=\"9b42\"\u003e…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e843\"\u003eReferring back to the scheme, we determined that all parts except the native UI could be migrated to KMP.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eShareable parts of product feature with KMP\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"41cf\"\u003eFor the UI we intentionally did not explore Compose Multiplatform, opting to keep the native UI.\u003c/p\u003e\u003ch2 id=\"6140\"\u003eCore libs migration to KMP: Methods and Challenges\u003c/h2\u003e\u003cp id=\"0248\"\u003eTo launch the product feature in KMP, we first needed to migrate core libraries. For that, we had two main approaches:\u003c/p\u003e\u003cp id=\"71cb\"\u003eFirst: take a native Android library (also called a platform feature) and refactor it to be multiplatform.\u003cbr/\u003eSecond: write a common adapter over two same native libraries — wrapping Android and iOS. This allows the adapter to be used in common code.\u003c/p\u003e\u003ch2 id=\"d12c\"\u003eAndroid Library Migration Example\u003c/h2\u003e\u003cp id=\"1d57\"\u003eWe used the first approach to migrate the internal MVI Flow library.\u003cbr/\u003ePreviously, MVI was chosen as the common UI architecture for the entire Android app.\u003cbr/\u003eColleagues created a library for it based on Coroutines Flows for component communication.\u003c/p\u003e\u003cp id=\"83a2\"\u003eWhile migrating it to KMP, we were fortunate that the library was relatively new and ready for common code extraction — it had already separated platform-independent and dependent code from the beginning.\u003c/p\u003e\u003cp id=\"73cc\"\u003e\u003cstrong\u003ePros of this approach\u003c/strong\u003e: we can reuse the existing native part. This means we only need to support two libraries (KMP and iOS-native) for three platforms (Android, iOS, KMP) instead of three separate implementations.\u003c/p\u003e\u003cp id=\"cfd5\"\u003e\u003cstrong\u003eMain downside\u003c/strong\u003e: since we migrated the library in a separate KMP repository (to avoid disrupting development for 70+ others), its native version diverged slightly.\u003c/p\u003e\u003cp id=\"5e62\"\u003eIn most cases an existing native library may not be ready for easy migration.\u003cbr/\u003eIf it was built for Android long ago, it may have issues like leaking resources, context dependencies, and Java-based dependencies in many places, making migration a significant challenge.\u003c/p\u003e\u003cp id=\"85ff\"\u003e\u003cstrong\u003eAnother downside\u003c/strong\u003e: You still need to adapt iOS native code to be compatible with the KMP library.\u003c/p\u003e\u003ch2 id=\"5530\"\u003eAdapting MVI for iOS\u003c/h2\u003e\u003cp id=\"c8f4\"\u003eIn our case with MVI on KMP, we still had to adapt the native UI code. We used four layers of abstraction:\u003c/p\u003e\u003col\u003e\u003cli id=\"2b9c\"\u003eIn \u003ccode\u003ecommonMain\u003c/code\u003e source set of MVI Flow we had \u003ccode\u003eCommonViewModel\u003c/code\u003e with a suspend function to receive Intents from UI and a Coroutines Flow for State updates. It was used in both Android \u0026amp; iOS.\u003c/li\u003e\u003cli id=\"b383\"\u003eIn \u003ccode\u003eiosMain\u003c/code\u003e, the Coroutines Flow was wrapped with \u003ca href=\"https://github.com/Kotlin/kmm-production-sample/blob/master/shared/src/iosMain/kotlin/com/github/jetbrains/rssreader/core/CFlow.kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCFlow\u003c/a\u003e, and \u003ccode\u003eiOSViewModel\u003c/code\u003e extended \u003ccode\u003eCommonViewModel\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"ce39\"\u003eIn native iOS, it was wrapped into \u003ccode\u003e@Published + ViewModel: ObservableObject\u003c/code\u003e, enabling its use in SwiftUI.\u003cbr/\u003eHowever, this was not our case, as iOS engineers were uncertain about using SwiftUI yet.\u003c/li\u003e\u003cli id=\"cd58\"\u003eWe adopted this ViewModel for UIKit in presenters.\u003cbr/\u003eThe last part of the code took as much effort as the previous three combined, as seen in the screenshot.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003eUIKit vs SwiftUI wrappers size for MVI from KMP\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9ef9\"\u003eNetwork layer unification options\u003c/h2\u003e\u003cp id=\"a4ce\"\u003eAfter migrating the UI architecture we switched to a common network layer.\u003cbr/\u003eThe most challenging part: it is rather thick due to the common network request logic and product feature contracts.\u003cbr/\u003eThe contracts themselves have a common issue — they differ slightly between the two platforms: they may use different API versions or support different field lists.\u003c/p\u003e\u003cp id=\"36b5\"\u003eEven for a single product feature, migrating to KMP involves handling a lot of network logic, including:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1989\"\u003eJSON parsing\u003c/li\u003e\u003cli id=\"aec9\"\u003eAttaching mandatory headers\u003c/li\u003e\u003cli id=\"eee8\"\u003eAuthorization session lifecycle handling — it should be synchronized across native and multiplatform requests\u003c/li\u003e\u003cli id=\"7638\"\u003eAntifraud mechanisms\u003c/li\u003e\u003cli id=\"5bee\"\u003eRequest performance metric\u003c/li\u003e\u003cli id=\"fbde\"\u003e…\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9d30\"\u003eThe network core logic also had differences between iOS and Android.\u003cbr/\u003eOne platform could have some dead features with unused headers still being sent.\u003cbr/\u003eOther features could work differently.\u003c/p\u003e\u003cp id=\"f9fb\"\u003eLike many others, we tried using a standard solution — Ktor library.\u003cbr/\u003eI won’t describe its implementation but will highlight the issues and needs it could not help us with:\u003c/p\u003e\u003cp id=\"dbe3\"\u003e1. Ktor in iOS works with the Darwin Engine based on \u003ccode\u003eNSUrlSession\u003c/code\u003e.\u003cbr/\u003eWe couldn’t use it with our preconfigured iOS native network layers because parts of the logic were built on \u003ccode\u003eNSUrlSession\u003c/code\u003e, others on Alamofire library, while some were just callbacks on each request.\u003c/p\u003e\u003cp id=\"fe60\"\u003eWe looked for a way to use the Darwin Engine based on a preconfigured Alamofire instead of \u003ccode\u003eNSUrlSession\u003c/code\u003e and even raised an \u003ca href=\"https://youtrack.jetbrains.com/issue/KTOR-5942/Ktor-client-Alamofire-based-engine-for-iOS\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eissue\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"9133\"\u003e2. During the migration process, we unexpectedly discovered (due to communication gaps in a large team) that the platform performance team was actively researching a migration from HTTP/2 to HTTP/3 over the QUIC protocol.\u003cbr/\u003eThey planned to migrate all requests to QUIC soon.\u003c/p\u003e\u003cp id=\"1658\"\u003eHowever, QUIC was not supported in Ktor or even in the native Android OkHttp library directly (we used \u003ca href=\"https://developer.android.com/develop/connectivity/cronet\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCronet\u003c/a\u003e).\u003c/p\u003e\u003cp id=\"9664\"\u003eAt that time, OkHttp was planned for KMP support in \u003ca href=\"https://square.github.io/okhttp/changelogs/changelog/#version-500-alpha4\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e5.0.0-alpha.4\u003c/a\u003e.\u003cbr/\u003eBut from \u003ca href=\"https://square.github.io/okhttp/changelogs/changelog/#version-500-alpha13\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e5.0.0-alpha.13\u003c/a\u003e onward, this support was dropped in favor of Ktor.\u003c/p\u003e\u003cp id=\"6aed\"\u003eCurrently, work on QUIC in Ktor is in progress. You can track progress on \u003ca href=\"https://github.com/ktorio/ktor/issues?q=quic\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e or \u003ca href=\"https://youtrack.jetbrains.com/issue/KTOR-6008/Support-QUIC-protocol\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis issue\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"6ec1\"\u003eSince our experiment couldn’t wait, we agreed to use Ktor without QUIC for a single feature.\u003cbr/\u003eWe rewrote the core logic for it and planned to revisit the decision later.\u003c/p\u003e\u003cp id=\"125e\"\u003eTo sum up, the network library was written from scratch, incorporating research from both platform implementations.\u003c/p\u003e\u003ch2 id=\"e236\"\u003eNative Libs Wrapping Downsides\u003c/h2\u003e\u003cp id=\"2dcf\"\u003eMostly, we wrapped other platform libraries with a small API.\u003c/p\u003e\u003cp id=\"951e\"\u003eBut why didn’t we try to wrap native network implementations?\u003c/p\u003e\u003cp id=\"4310\"\u003eFirstly, we would need to support this adapter after every major change in the native part. This means we would have three dependent libraries, making maintenance difficult.\u003c/p\u003e\u003cp id=\"e62b\"\u003eSecondly, wrapping two different native implementations is harder than migrating one (e.g., Android, as it is already in Kotlin).\u003cbr/\u003eAs we have seen in network logic, native libraries can differ significantly, causing platform-specific behaviors to leak into the common interface.\u003c/p\u003e\u003cp id=\"2299\"\u003eOf course, this approach has some benefits:\u003c/p\u003e\u003cp id=\"85bc\"\u003eFirst, it usually does not require adaption of the native iOS code.\u003cbr/\u003eThe native iOS application continues using the native iOS library directly, while the common code interacts with it through an adapter.\u003cbr/\u003eAny updates to the native iOS library will be automatically reflected in both implementaion, ensuring consistency across.\u003c/p\u003e\u003cp id=\"f157\"\u003eSecondly, in the future, we can use the adapter to replace the implementation.\u003cbr/\u003eFor example, if we wrap the network layer, we could later switch to Ktor or another multiplatform library when they support QUIC, without additional costs.\u003c/p\u003e\u003ch2 id=\"7958\"\u003eThe experiment\u003c/h2\u003e\u003cp id=\"46ba\"\u003eIt’s time to proceed to the main part of the article: an A/B test on a real product feature that we migrated from native to KMP, measuring the results in production.\u003c/p\u003e\u003ch2 id=\"37f9\"\u003eFeature choice\u003c/h2\u003e\u003cp id=\"a0c9\"\u003eWe began by defining criteria to ensure the feature was representative yet not too difficult to migrate:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d311\"\u003eIt uses the MVI Flow library, allowing us to migrate its business logic as is.\u003c/li\u003e\u003cli id=\"97b9\"\u003eThe feature is covered by performance metrics, which we compared in an A/B test with the native implementation.\u003c/li\u003e\u003cli id=\"98cd\"\u003eIt requires authorization, including session-refresh logic and necessary headers, making it relevant to most features.\u003c/li\u003e\u003cli id=\"340f\"\u003eThe feature was experimental not only for KMP but also for Compose UI on Android.\u003cbr/\u003eSince Compose and SwiftUI seem to be converging in modern mobile development, we tested them together.\u003c/li\u003e\u003cli id=\"f6ba\"\u003eIt is covered by UI E2E tests, helping us verify that the migration didn’t break business logic.\u003c/li\u003e\u003cli id=\"c2fb\"\u003eIt is small in size (2 server requests, 2 screens), making it easy to implement and roll back if needed.\u003c/li\u003e\u003cli id=\"3807\"\u003eIt has minimal internal dependencies, reducing the need to migrate core libraries beforehand.\u003c/li\u003e\u003cli id=\"b9dd\"\u003eIt has no dependencies on other product features.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f83f\"\u003eExperiment requirements\u003c/h2\u003e\u003cp id=\"bfbe\"\u003eThe primary measurable metrics were the existing performance metrics automatically tracked by the split service (\u003ca href=\"https://habr.com/ru/companies/avito/articles/871428/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emore on it\u003c/a\u003e).\u003c/p\u003e\u003cul\u003e\u003cli id=\"1426\"\u003eOn iOS: Native UI (UIKit) + Native logic vs. Native UI (UIKit) + KMP logic.\u003c/li\u003e\u003cli id=\"6007\"\u003eOn Android: Native UI (XML) + Native logic vs. Native UI (Compose) + KMP logic.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7258\"\u003eAdditionally, platform teams set specific requirements:\u003c/p\u003e\u003cul\u003e\u003cli id=\"31ea\"\u003eThe Build Tools (aka Speed) team, responsible for local and CI build times, required that KMP have no impact on build speed.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7431\"\u003eThe Mobile Architecture team focused on the developer experience when using KMP, particularly regarding:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0323\"\u003eIncremental changes\u003c/li\u003e\u003cli id=\"3c67\"\u003eDebugging errors in common code\u003c/li\u003e\u003cli id=\"54f9\"\u003ePublishing new versions\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5341\"\u003eIt was expected that most challenges would arise from the iOS build process.\u003c/p\u003e\u003ch2 id=\"723c\"\u003eResults\u003c/h2\u003e\u003cp id=\"3939\"\u003e🟢 A/B test — No performance issues\u003c/p\u003e\u003cp id=\"6279\"\u003eWe expected KMP to be slower on iOS, but it was not. Both platforms showed neutral (gray) results, meaning no significant difference in performance metrics.\u003c/p\u003e\u003cp id=\"a13a\"\u003e🟢 Native project build time — No impact\u003c/p\u003e\u003cp id=\"bfc2\"\u003eWe added KMP to the main projects as a built library (via Artifactory), so it did not affect build time at all.\u003c/p\u003e\u003cp id=\"1713\"\u003e🟢 Incremental KMP development experience\u003c/p\u003e\u003cp id=\"4709\"\u003eFor local development, we used Maven Local for Android and a local framework for iOS.\u003c/p\u003e\u003cul\u003e\u003cli id=\"5fd9\"\u003eOn Android, performance was similar to a regular Android module, making it fast for feature development and debugging before checking on iOS.\u003c/li\u003e\u003cli id=\"ff72\"\u003eKotlin for iOS builds was initially slow but has improved significantly over time with Kotlin/Native enhancements.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1a3a\"\u003e🟢 Debugging experience\u003c/p\u003e\u003cp id=\"6bb4\"\u003eDebugging was smooth, both in understanding UI state changes through MVI Flow logs and handling crashes.\u003cbr/\u003eOn iOS, stack traces directly pointed to Kotlin code, making debugging easier.\u003c/p\u003e\u003cp id=\"d1f5\"\u003e🟡 New version publication\u003c/p\u003e\u003cp id=\"8c5f\"\u003eChallenges arose from:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f69a\"\u003eThe prior KMP library setup.\u003c/li\u003e\u003cli id=\"e257\"\u003eThe iOS limitation of supporting only one KMP framework per app (\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-42250\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKT-42250\u003c/a\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a867\"\u003eA common solution is to use a single umbrella module for the iOS framework, incorporating all other KMP modules. We had to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0159\"\u003eChange the Calls publication format to klib.\u003c/li\u003e\u003cli id=\"aae2\"\u003eInclude WebRTC transitively.\u003c/li\u003e\u003cli id=\"ea41\"\u003eBuild a single bundle containing the migrated feature and core code.\u003c/li\u003e\u003cli id=\"853c\"\u003eUse this as a single framework (with a unified namespace) in the iOS app.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0671\"\u003eWhile the process was clear, implementing it correctly took time and required collaboration with the Calls team.\u003c/p\u003e\u003cp id=\"a126\"\u003e🟡 iOS build issues and workarounds\u003c/p\u003e\u003cp id=\"31fd\"\u003eThe native iOS app had many modules and used a \u003ca href=\"https://avito.tech/tpost/ih07kypu31-independency-sbrasivaem-okovi-cocoapods\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecustom build tool\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"f89c\"\u003eUnlike standard tutorials, we couldn’t simply add the KMP framework to Xcode and auto-include it.\u003cbr/\u003eInstead, we had to adapt it for the custom build tool with help from the iOS platform team.\u003c/p\u003e\u003ch2 id=\"8f65\"\u003e1 year later\u003c/h2\u003e\u003cp id=\"f8e9\"\u003eColleagues removed the remnants of the experiment from the code, shifting the development focus toward a backend-driven UI framework.\u003cbr/\u003eIts client-side implementation is based on KMP with native UI components.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-02-19T08:33:53.855Z",
  "modifiedTime": null
}
