{
  "id": "a07a8d2f-9f18-46f8-87ae-66213f798eb8",
  "title": "Introducing InboxRecyclerView, a library for building expandable descendant navigation",
  "link": "https://saket.me/inboxrecyclerview/",
  "description": "When Google released Inbox for Android some 4 years ago, their UI was rad. I was obsessed with the navigation transition, where emails expanded from their list item when clicked, pushing all other items out of the screen. When pulled downwards, the emails collapsed back to their positions. I wanted to recreate this UI. I […] The post Introducing InboxRecyclerView, a library for building expandable descendant navigation appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Fri, 14 Sep 2018 06:19:26 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Open Source",
    "animation",
    "gestures",
    "library",
    "recyclerview"
  ],
  "byline": "Saket Narayan",
  "length": 5986,
  "excerpt": "Recreating Google Inbox's rad UI for building expandable descendant navigation. And a story of how developers take 4 years to release anything.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "When Google released Inbox for Android some 4 years ago, their UI was rad. I was obsessed with the navigation transition, where emails expanded from their list item when clicked, pushing all other items out of the screen. When pulled downwards, the emails collapsed back to their positions. I wanted to recreate this UI. I started by capturing a screen-recording of Inbox and playing it many hundred times at 1/10th the speed. When animations are slowed down, our eyes are able to catch all the details that otherwise look like magic at 60 frames per second. After spending a few days on it, I had a working prototype. That was 4 years ago. I never managed to finish it for public usage — until now. Today, I’m releasing it for everyone to use. Thankfully, the design is still in line with the newest material design guidelines. Google has also used this transition in a case study for a hypothetical app called Reply. Introducing, InboxRecyclerView — a library for building expandable descendant navigation with pull-to-dismiss gesture: https://github.com/saket/InboxRecyclerView If you’re interested in knowing how InboxRecyclerView works, here’s a detailed explanation. Smoke and mirrors There are two parts to the library: InboxRecyclerView for the list items and ExpandablePageLayout for the expandable content. When an item is clicked, InboxRecyclerView performs three steps: 1. Prepare to expand InboxRecyclerView aligns the content with the clicked list item. During expansion, they are cross-faded into each other to make it look like the list item itself is expanding. val itemLocation: Rect = captureViewLocation(clickedItem) contentPage.visibility = View.VISIBLE contentPage.translationY = itemLocation.y contentPage.setDimensions(itemLocation.width, itemLocation.height) At this point, the app will also load the content into ExpandablePageLayout. You can take a look at the sample app for reference. 2. Expanding content Once the content is aligned, the next step is to animate its expansion. I initially experimented with animating the dimensions by updating the View’s LayoutParams. As you might have already guessed, this resulted in terrible performance. Any change in dimensions invalidates the entire View hierarchy in a recursive manner (except in some cases where a ViewGroup is smart enough to optimize this). Doing this on a loop at 60fps was a bad idea. My breakthrough came in when I learned that Views are also capable of clipping their content. Using View#setClippedBounds(Rect), the visible portion of a View can be animated to create an illusion that it’s getting resized. fun animateDimensions(toWidth: Int, toHeight: Int) { val fromWidth = clipBounds.width() val fromHeight = clipBounds.height() ObjectAnimator.ofFloat(0F, 1F) .addUpdateListener { val scale = it.animatedValue as Float val newWidth = (toWidth - fromWidth) * scale + fromWidth val newHeight = (toHeight - fromHeight) * scale + fromHeight) contentPage.clipBounds = Rect(0, 0, newWidth, newHeight) } .start() } Using the Transitions API with ChangeBounds is also an option. It takes advantage of a hidden function called ViewGroup#suppressLayout() that disables invalidation of the View hierarchy, resulting in equally smooth animations. fun animateDimensions(toWidth: Int, toHeight: Int) { val transition = TransitionSet() .addTransition(ChangeBounds()) .addTransition(ChangeTransform()) .addTransition(Slide()) .setOrdering(TransitionSet.ORDERING_TOGETHER) TransitionManager.beginDelayedTransition(parent as ViewGroup, transition) val params = contentPage.layoutParams params.width = toWidth params.height = toHeight contentPage.layoutParams = params } Unfortunately, I had a bad experience with Transitions API where the expand animation was occasionally completing abruptly. So I decided to stay away from using it. 3. Animating list items To make it look like the expanding item is pushing other items outside the screen, the items are also moved in sync with the expanding content during the animation. This is done inside ItemExpandAnimator, and is customisable. Pull to collapse This is probably my favourite part of InboxRecyclerView. The content can be collapsed by dragging it vertically in either direction. The gesture for this takes advantage of a property of Views where touch events can be intercepted by ViewGroups before they reach their children. I’ve explained this in a bit more detail in my other post. When a vertical gesture is detected, the page is scrolled along with the gesture. The interesting part of this is that the content doesn’t exactly move with the user’s finger. Some friction is added to the movement. override fun onTouch(view, event): Boolean { when (event.action) { ACTION_MOVE -\u003e { val deltaY = event.rawY - lastTouchY val friction = 4F var deltaYWithFriction = deltaY / frictionFactor view.translationY += deltaYWithFriction val lastTouchY = event.rawY } ACTION_UP -\u003e { if (isEligibleForCollapse()) { collapsePage() } else { smoothlyResetPage() } } } } This friction grows even larger once the page has crossed the threshold distance and is eligible for collapse. if (isEligibleForCollapse()) { val extraFriction = collapseDistanceThreshold / view.translationY deltaYWithFriction *= extraFriction } Polish InboxRecyclerView applies a soft tint on the list when its covered. When the content page is pulled, the tint is faded away to give a visual indication when the page can be released to collapse. Apps can be really creative with this. Dank, for example, uses the status bar color to indicate when the content is eligible for collapse. The material case study also features a beautiful FAB animation. While my less than stellar design skills cannot recreate that, I did manage to create a good enough animation using ShapeShifter by Alex Lockwood. That’s all folks!",
  "image": "http://saket.me/wp-content/uploads/2018/09/inboxrecyclerview.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\n\u003cp\u003eWhen Google released Inbox for Android some 4 years ago, their UI was rad. I was obsessed with the navigation transition, where emails expanded from their list item when clicked, pushing all other items out of the screen. When pulled downwards, the emails collapsed back to their positions.\u003c/p\u003e\n\u003cp\u003eI wanted to recreate this UI. I started by capturing a screen-recording of Inbox and playing it many hundred times at 1/10th the speed. When animations are slowed down, our eyes are able to catch all the details that otherwise look like magic at 60 frames per second. After spending a few days on it, I had a working prototype.\u003c/p\u003e\n\u003cp\u003eThat was 4 years ago. I never managed to finish it for public usage — until now. Today, I’m releasing it for everyone to use. Thankfully, the design is still in line with the newest \u003ca href=\"https://material.io/design/navigation/navigation-transitions.html#hierarchical-transitions\"\u003ematerial design guidelines\u003c/a\u003e. Google has also used this transition in a case study for a hypothetical app called \u003ca href=\"https://material.io/design/material-studies/reply.html\"\u003eReply\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIntroducing, \u003cstrong\u003eInboxRecyclerView\u003c/strong\u003e — a library for building expandable descendant navigation with pull-to-dismiss gesture: \u003ca href=\"https://github.com/saket/InboxRecyclerView\"\u003ehttps://github.com/saket/InboxRecyclerView\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIf you’re interested in knowing how \u003ccode\u003eInboxRecyclerView\u003c/code\u003e works, here’s a detailed explanation.\u003c/p\u003e\n\u003ch4\u003eSmoke and mirrors\u003c/h4\u003e\n\u003cp\u003eThere are two parts to the library: \u003ccode\u003eInboxRecyclerView\u003c/code\u003e for the list items and \u003ccode\u003eExpandablePageLayout\u003c/code\u003e for the expandable content. When an item is clicked, \u003ccode\u003eInboxRecyclerView\u003c/code\u003e performs three steps:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1. Prepare to expand\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eInboxRecyclerView\u003c/code\u003e aligns the content with the clicked list item. During expansion, they are cross-faded into each other to make it look like the list item itself is expanding.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eval itemLocation: Rect = captureViewLocation(clickedItem)\ncontentPage.visibility = View.VISIBLE\ncontentPage.translationY = itemLocation.y\ncontentPage.setDimensions(itemLocation.width, itemLocation.height)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, the app will also load the content into \u003ccode\u003eExpandablePageLayout\u003c/code\u003e. You can take a look at the \u003ca href=\"https://github.com/saket/InboxRecyclerView/blob/9e5881c945767aae4d627dbf4f3963bc65131d69/sample/src/main/java/me/saket/inboxrecyclerview/sample/inbox/InboxActivity.kt#L88\"\u003esample app\u003c/a\u003e for reference.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2. Expanding content\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOnce the content is aligned, the next step is to animate its expansion.\u003c/p\u003e\n\u003cp\u003eI initially experimented with animating the dimensions by updating the View’s \u003ccode\u003eLayoutParams\u003c/code\u003e. As you might have already guessed, this resulted in terrible performance. Any change in dimensions invalidates the entire View hierarchy in a recursive manner (except in some cases where a \u003ccode\u003eViewGroup\u003c/code\u003e is smart enough to optimize this). Doing this on a loop at 60fps was a bad idea.\u003c/p\u003e\n\u003cp\u003eMy breakthrough came in when I learned that Views are also capable of clipping their content. Using \u003ca href=\"https://developer.android.com/reference/android/view/View.html#setClipBounds(android.graphics.Rect)\"\u003eView#setClippedBounds(Rect)\u003c/a\u003e, the visible portion of a View can be animated to create an illusion that it’s getting resized.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun animateDimensions(toWidth: Int, toHeight: Int) {\n  val fromWidth = clipBounds.width()\n  val fromHeight = clipBounds.height()\n\n  ObjectAnimator.ofFloat(0F, 1F)\n    .addUpdateListener {\n      val scale = it.animatedValue as Float\n      val newWidth = (toWidth - fromWidth) * scale + fromWidth\n      val newHeight = (toHeight - fromHeight) * scale + fromHeight)\n      contentPage.clipBounds = Rect(0, 0, newWidth, newHeight)\n    }\n    .start()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing the Transitions API with \u003ca href=\"https://developer.android.com/reference/android/transition/ChangeBounds\"\u003eChangeBounds\u003c/a\u003e is also an option. It takes advantage of a hidden function called \u003ca href=\"https://github.com/aosp-mirror/platform_frameworks_base/blob/afd30193a2949afc2cdfb706ce3e948b090d56ee/core/java/android/view/ViewGroup.java#L7028\"\u003eViewGroup#suppressLayout()\u003c/a\u003e that disables invalidation of the View hierarchy, resulting in equally smooth animations.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efun animateDimensions(toWidth: Int, toHeight: Int) {\n  val transition = TransitionSet()\n    .addTransition(ChangeBounds())\n    .addTransition(ChangeTransform())\n    .addTransition(Slide())\n    .setOrdering(TransitionSet.ORDERING_TOGETHER)\n  TransitionManager.beginDelayedTransition(parent as ViewGroup, transition)\n\n  val params = contentPage.layoutParams\n  params.width = toWidth\n  params.height = toHeight\n  contentPage.layoutParams = params\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnfortunately, I had a bad experience with Transitions API where the expand animation was occasionally completing abruptly. So I decided to stay away from using it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3. Animating list items\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo make it look like the expanding item is pushing other items outside the screen, the items are also moved in sync with the expanding content during the animation. This is done inside \u003ca href=\"https://github.com/saket/InboxRecyclerView/blob/master/inboxrecyclerview/src/main/java/me/saket/inboxrecyclerview/animation/SplitExpandAnimator.kt\"\u003eItemExpandAnimator\u003c/a\u003e, and is customisable.\u003c/p\u003e\n\n\u003ch4\u003ePull to collapse\u003c/h4\u003e\n\u003cp\u003eThis is probably my favourite part of \u003ccode\u003eInboxRecyclerView\u003c/code\u003e. The content can be collapsed by dragging it vertically in either direction.\u003c/p\u003e\n\u003cp\u003eThe gesture for this takes advantage of a property of Views where touch events can be intercepted by ViewGroups before they reach their children. I’ve explained this in a bit more detail in \u003ca href=\"https://saket.me/flick-dismissible-images/\"\u003emy other post\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhen a vertical gesture is detected, the page is scrolled along with the gesture. The interesting part of this is that the content doesn’t exactly move with the user’s finger. Some friction is added to the movement.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eoverride fun onTouch(view, event): Boolean {\n\n  when (event.action) {\n    ACTION_MOVE -\u0026gt; {\n      val deltaY = event.rawY - lastTouchY\n      val friction = 4F\n      var deltaYWithFriction = deltaY / frictionFactor\n\n      view.translationY += deltaYWithFriction\n      val lastTouchY = event.rawY\n    }\n\n    ACTION_UP -\u0026gt; {\n      if (isEligibleForCollapse()) {\n        collapsePage()\n      } else {\n        smoothlyResetPage()\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis friction grows even larger once the page has crossed the threshold distance and is eligible for collapse.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eif (isEligibleForCollapse()) {\n  val extraFriction = collapseDistanceThreshold / view.translationY\n  deltaYWithFriction *= extraFriction\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003ePolish\u003c/h4\u003e\n\u003cp\u003eInboxRecyclerView applies a soft tint on the list when its covered. When the content page is pulled, the tint is faded away to give a visual indication when the page can be released to collapse.\u003c/p\u003e\n\n\u003cp\u003eApps can be really creative with this. \u003ca href=\"https://saket.me/dank\"\u003eDank\u003c/a\u003e, for example, uses the status bar color to indicate when the content is eligible for collapse.\u003c/p\u003e\n\n\u003cp\u003eThe material case study also features a beautiful FAB \u003ca href=\"https://material.io/design/material-studies/reply.html#motion\" rel=\"nofollow\"\u003eanimation\u003c/a\u003e. While my less than stellar design skills cannot recreate that, I did manage to create a good enough animation using \u003ca href=\"https://shapeshifter.design/\" rel=\"nofollow\"\u003eShapeShifter\u003c/a\u003e by \u003ca href=\"https://twitter.com/alexjlockwood\" rel=\"nofollow\"\u003eAlex Lockwood\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThat’s all folks!\u003c/p\u003e\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2018-09-14T06:19:26Z",
  "modifiedTime": "2021-01-10T06:56:09Z"
}
