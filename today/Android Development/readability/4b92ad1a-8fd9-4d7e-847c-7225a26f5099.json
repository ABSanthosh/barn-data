{
  "id": "4b92ad1a-8fd9-4d7e-847c-7225a26f5099",
  "title": "Android ViewModels : Under the hood",
  "link": "https://medium.com/mindorks/android-viewmodels-under-the-hood-ddc679d77dd5?source=rss----f1a763fc7443--android",
  "description": "",
  "author": "Deepanshu",
  "published": "Tue, 14 Jul 2020 02:58:24 GMT",
  "source": "https://medium.com/feed/mindorks/tagged/android",
  "categories": [
    "android",
    "mobile-apps",
    "android-app-development",
    "mobile-app-development",
    "androiddev"
  ],
  "byline": "Deepanshu",
  "length": 11090,
  "excerpt": "This article discusses about the internals of Android ViewModel. It discusses briefly about the usages of ViewModel and then goes in detail about how ViewModel retains itself on configuration changes.",
  "siteName": "MindOrks",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "In this article, we are going to discuss the internals of ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes.Originally published at blog.mindorks.comAccording to the documentation, the ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.The ViewModel class also helps in implementing MVVM(Model-View-ViewModel) design pattern which is also the recommended Android app architecture for Android applications by Google.Also, there are other various advantages of using ViewModel class provided by Android framework like:Handle configuration changes: ViewModel objects are automatically retained whenever activity is recreated due to configuration changes.Lifecycle Awareness: ViewModel objects are also lifecycle-aware. They are automatically cleared when the Lifecycle they are observing gets permanently destroyed.Data Sharing: Data can be easily shared between fragments in an activity using ViewModels.Avoid memory leaks: Viemodels also help in avoiding memory leaks as they do not keep an instance of activity/fragment.Kotlin-Coroutines support: ViewModel includes support for Kotlin-Coroutines. So, they can be easily integrated for any asynchronous processing.How ViewModel work internally?Link to the sample projectThis is the sample project we are going to use for explaining how the viewmodel retains itself on configuration changes.This is a very simple application with a single activity named MainActivity which shows a counter. The counter value is our view state kept inside the CounterViewModel using a LiveData object. The activity also shows the hashcode of the current activity instance.On any configuration change, the current activity instance is destroyed and a new instance of the activity is created which makes the hashcode to change. But the counter value is retained as we are keeping it inside our ViewModel and the viewmodels are not destroyed if the activity is getting recreated due to configuration changes.The first thought around how viewmodels are retained might be that they are stored somewhere at the global(application) level and that’s why they are not destroyed when the activity is recreated. But this assumption is wrong. The viewmodels are stored inside the activity (or FragmentManager in case of fragments).So let’s discuss how this magic happens and how our viewmodel instance is retained even if the activity is recreated.viewModel = ViewModelProvider(this, ViewModelFactory()).get(CounterViewModel::class.java)This is the code to get a viewmodel instance in an activity. As we can see, we are getting an instance of ViewModelProvider by passing two arguments, our activity instance and an instance of ViewModelFactory. Then, we are using this ViewModelProvider instance to get our CounterViewModel object.Note: In the above example, passing ViewModelFactory is redundant as our CounterViewModel does not have a parameterized constructor. In case we do not pass ViewModelFactory, ViewModelProvider uses a default view model factory.So the creation of viewmodel involves 2 steps:Creation of ViewModelProviderGetting the instance of Viewmodel from ViewModelProviderCreation of ViewModelProviderpublic ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) { this(owner.getViewModelStore(), factory);}The constructor of ViewModelProvider takes two parameters, ViewModelStoreOwner and Factory. In our example, the activity is the ViewModelStoreOwner and we are passing our own custom factory. ViewModelStoreOwner is a simple interface with a single method named getViewModelStore()public interface ViewModelStoreOwner { @NonNull ViewModelStore getViewModelStore();}In the constructor, we are simply getting the ViewModelStore from ViewModelStoreOwner and passing it to the other constructor where they are just assigned to the respective class members.public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) { mFactory = factory; mViewModelStore = store;}So now we know that our activity is the ViewModelStoreOwner and its the responsibility of our activity to provide the ViewModelStore.Getting the ViewModel from ViewModelProviderpublic \u003cT extends ViewModel\u003e T get(@NonNull Class\u003cT\u003e modelClass) { String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) { throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); } return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);}When we invoke get() method on our ViewModelProvider, it gets the canonical name of the view model class and creates a key by appending the canonical name to a DEFAULT_KEY.public \u003cT extends ViewModel\u003e T get(@NonNull String key, @NonNull Class\u003cT\u003e modelClass) { ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) { if (mFactory instanceof OnRequeryFactory) { ((OnRequeryFactory) mFactory).onRequery(viewModel); } return (T) viewModel; } else { //noinspection StatementWithEmptyBody if (viewModel != null) { // TODO: log a warning. } } if (mFactory instanceof KeyedFactory) { viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass); } else { viewModel = (mFactory).create(modelClass); } mViewModelStore.put(key, viewModel); return (T) viewModel;}After creating the key from the model class, it checks the ViewModelStore (which is provided by our activity) whether a viewmodel instance for the given key is already present or not. If the viewmodel is already present, it simply returns the viewmodel instance present in ViewModelStore and if it’s not present, the ViewModelProvider uses the Factory instance to create a new viewmodel object and also stores it in ViewModelStore.Now we know that our activity is responsible for storing the ViewModel instances. But it’s still a mystery that how these ViewModel instances are retained even when the activity instance is recreated on configuration change.How ViewModel retain itself?As we saw earlier when we created ViewModelProvider we were passing an instance of ViewModelStoreOwner i.e., our activity instance.public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, SavedStateRegistryOwner, OnBackPressedDispatcherOwnerOur activity implements the ViewModelStoreOwner the interface which has a single method named getViewModelStore()public interface ViewModelStoreOwner { @NonNull ViewModelStore getViewModelStore();}Now let’s have a look at the implementation of this method.@NonNull@Overridepublic ViewModelStore getViewModelStore() { if (getApplication() == null) { throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); } //This is true when invoked for the first time if (mViewModelStore == null) { NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { // Restore the ViewModelStore from NonConfigurationInstances mViewModelStore = nc.viewModelStore; } if (mViewModelStore == null) { mViewModelStore = new ViewModelStore(); } } return mViewModelStore;}Here we can see that getViewModelStore() returns the mViewModelStore. When our activity is recreated due to any configuration change, nc(NonConfigurationInstances) contains the previous instance of ViewModelStore. nc(NonConfigurationInstances) is null when our activity is created for the first time and a new ViewModelStore is created in this case.//ComponentActivity.javastatic final class NonConfigurationInstances { Object custom; ViewModelStore viewModelStore;}//Activity.javastatic final class NonConfigurationInstances { Object activity; //NonConfigurationInstances(ComponentActivity) HashMap\u003cString, Object\u003e children; FragmentManagerNonConfig fragments; ArrayMap\u003cString, LoaderManager\u003e loaders; VoiceInteractor voiceInteractor;}NonConfigurationInstances(Activity.java) is the object which is retained by the Android system even when the activity gets recreated. It has a member named activity which is an instance of NonConfigurationInstances(ComponentActivity.java). This instance contains ViewModelStore.Note: ViewModels are not retained directly. Instead, ViewModelStore is retained on configuration changes which internally maintains a map of viewmodels.Let’s deep dive more into this.//Activity.javapublic Object getLastNonConfigurationInstance() { return mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.activity : null;}//ComponentActivity.javapublic final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) { // No one called getViewModelStore(), so see if there was an existing // ViewModelStore from our last NonConfigurationInstance NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { viewModelStore = nc.viewModelStore; } } if (viewModelStore == null \u0026\u0026 custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci;}Whenever our activity is getting recreated due to any configuration change, onRetainNonConfigurationInstance() gets invoked which returns the NonConfigurationInstances(ComponentActivity.java) instance. This object is retained by the Android system so that it can be delivered to the next activity instance on recreation.Similarly, we can also retain our own custom objects by implementing the onRetainCustomNonConfigurationInstance().After the recreation of our activity, NonConfigurationInstances(Activity.java) is received in the attach() method of the Activity class.final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)This is how the viewmodels are retained on configuration changes.You can also connect with me on LinkedIn, Twitter, Facebook, and Github.Thank You!!!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*mFk0dnBc4PGDEsh_SYUQIw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@deepanshu42?source=post_page-----ddc679d77dd5--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Deepanshu\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*ahNCTh530KBf-CFfWtS6nA@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/mindorks?source=post_page-----ddc679d77dd5--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"MindOrks\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CWnVPd6NnwpcBIJdoUmkYg.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"60cb\"\u003eIn this article, we are going to discuss the internals of ViewModel which is a part of Android Architecture Components. We will first briefly discuss the usages of ViewModel in Android and then we will go in detail about how ViewModel actually works and how it retains itself on configuration changes.\u003c/p\u003e\u003cp id=\"e784\"\u003e\u003cstrong\u003eOriginally published at \u003c/strong\u003e\u003ca href=\"https://blog.mindorks.com/android-viewmodels-under-the-hood\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eblog.mindorks.com\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"ea2a\"\u003eAccording to the \u003ca href=\"https://developer.android.com/topic/libraries/architecture/viewmodel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e, the ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way. The ViewModel class allows data to survive configuration changes such as screen rotations.\u003c/p\u003e\u003cp id=\"76b8\"\u003eThe \u003ccode\u003eViewModel\u003c/code\u003e class also helps in implementing \u003cstrong\u003eMVVM(Model-View-ViewModel)\u003c/strong\u003e design pattern which is also the recommended Android app architecture for Android applications by Google.\u003c/p\u003e\u003cp id=\"c8d7\"\u003eAlso, there are other various advantages of using \u003ccode\u003eViewModel\u003c/code\u003e class provided by Android framework like:\u003c/p\u003e\u003cul\u003e\u003cli id=\"53d3\"\u003e\u003cstrong\u003eHandle configuration changes:\u003c/strong\u003e \u003ccode\u003eViewModel\u003c/code\u003e objects are automatically retained whenever activity is recreated due to configuration changes.\u003c/li\u003e\u003cli id=\"0402\"\u003e\u003cstrong\u003eLifecycle Awareness:\u003c/strong\u003e \u003ccode\u003eViewModel\u003c/code\u003e objects are also lifecycle-aware. They are automatically cleared when the \u003ccode\u003eLifecycle\u003c/code\u003e they are observing gets permanently destroyed.\u003c/li\u003e\u003cli id=\"587e\"\u003e\u003cstrong\u003eData Sharing:\u003c/strong\u003e Data can be easily shared between fragments in an activity using \u003ccode\u003eViewModels\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"e7b6\"\u003e\u003cstrong\u003eAvoid memory leaks:\u003c/strong\u003e \u003ccode\u003eViemodels\u003c/code\u003e also help in avoiding memory leaks as they do not keep an instance of activity/fragment.\u003c/li\u003e\u003cli id=\"5177\"\u003e\u003cstrong\u003eKotlin-Coroutines support:\u003c/strong\u003e \u003ccode\u003eViewModel\u003c/code\u003e includes support for \u003ca href=\"https://blog.mindorks.com/mastering-kotlin-coroutines-in-android-step-by-step-guide\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin-Coroutines\u003c/a\u003e. So, they can be easily integrated for any asynchronous processing.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b56b\"\u003eHow ViewModel work internally?\u003c/h2\u003e\u003cp id=\"1e22\"\u003e\u003ca href=\"https://github.com/deepanshu42/viewmodel-sample\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLink to the sample project\u003c/a\u003e\u003c/p\u003e\u003cp id=\"d376\"\u003eThis is the sample project we are going to use for explaining how the \u003ccode\u003eviewmodel\u003c/code\u003e retains itself on configuration changes.\u003c/p\u003e\u003cp id=\"bd58\"\u003eThis is a very simple application with a single activity named \u003ccode\u003eMainActivity\u003c/code\u003e which shows a counter. The counter value is our view state kept inside the \u003ccode\u003eCounterViewModel\u003c/code\u003e using a \u003ccode\u003eLiveData\u003c/code\u003e object. The activity also shows the \u003ccode\u003ehashcode\u003c/code\u003e of the current activity instance.\u003c/p\u003e\u003cp id=\"6244\"\u003eOn any configuration change, the current activity instance is destroyed and a new instance of the activity is created which makes the \u003ccode\u003ehashcode\u003c/code\u003e to change. But the counter value is retained as we are keeping it inside our \u003ccode\u003eViewModel\u003c/code\u003e and the \u003ccode\u003eviewmodels\u003c/code\u003e are not destroyed if the activity is getting recreated due to configuration changes.\u003c/p\u003e\u003cp id=\"51e4\"\u003eThe first thought around how \u003ccode\u003eviewmodels\u003c/code\u003e are retained might be that they are stored somewhere at the global(application) level and that’s why they are not destroyed when the activity is recreated. But this assumption is wrong. The viewmodels are stored inside the activity (or \u003ccode\u003eFragmentManager\u003c/code\u003e in case of fragments).\u003c/p\u003e\u003cp id=\"f7e7\"\u003eSo let’s discuss how this magic happens and how our \u003ccode\u003eviewmodel\u003c/code\u003e instance is retained even if the activity is recreated.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8684\"\u003eviewModel = ViewModelProvider(\u003cstrong\u003ethis\u003c/strong\u003e, ViewModelFactory()).get(CounterViewModel::\u003cstrong\u003eclass\u003c/strong\u003e.\u003cstrong\u003ejava\u003c/strong\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fe95\"\u003eThis is the code to get a \u003ccode\u003eviewmodel\u003c/code\u003e instance in an activity. As we can see, we are getting an instance of \u003ccode\u003eViewModelProvider\u003c/code\u003e by passing two arguments, our activity instance and an instance of \u003ccode\u003eViewModelFactory\u003c/code\u003e. Then, we are using this \u003ccode\u003eViewModelProvider\u003c/code\u003e instance to get our \u003ccode\u003eCounterViewModel\u003c/code\u003e object.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"8dc7\"\u003eNote: In the above example, passing \u003cstrong\u003eViewModelFactory\u003c/strong\u003e is redundant as our \u003cstrong\u003eCounterViewModel\u003c/strong\u003e does not have a parameterized constructor. In case we do not pass \u003cstrong\u003eViewModelFactory,\u003c/strong\u003e ViewModelProvider uses a default view model factory.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"28a1\"\u003eSo the creation of viewmodel involves 2 steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"ddf2\"\u003eCreation of \u003ccode\u003eViewModelProvider\u003c/code\u003e\u003c/li\u003e\u003cli id=\"899e\"\u003eGetting the instance of \u003ccode\u003eViewmodel\u003c/code\u003e from \u003ccode\u003eViewModelProvider\u003c/code\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"ed75\"\u003eCreation of \u003ccode\u003eViewModelProvider\u003c/code\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"19ac\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003eViewModelProvider\u003c/strong\u003e(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) {\u003cbr/\u003e    \u003cstrong\u003ethis\u003c/strong\u003e(owner.getViewModelStore(), factory);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a76d\"\u003eThe constructor of \u003ccode\u003eViewModelProvider\u003c/code\u003e takes two parameters, \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e and \u003ccode\u003eFactory\u003c/code\u003e. In our example, the activity is the \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e and we are passing our own custom factory. \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e is a simple interface with a single method named \u003ccode\u003egetViewModelStore()\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ba8b\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003einterface\u003c/strong\u003e \u003cstrong\u003eViewModelStoreOwner\u003c/strong\u003e {\u003cbr/\u003e    \u003cstrong\u003e@NonNull\u003c/strong\u003e\u003cbr/\u003e    ViewModelStore \u003cstrong\u003egetViewModelStore\u003c/strong\u003e();\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a694\"\u003eIn the constructor, we are simply getting the \u003ccode\u003eViewModelStore\u003c/code\u003e from \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e and passing it to the other constructor where they are just assigned to the respective class members.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd1e\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003eViewModelProvider\u003c/strong\u003e(@NonNull ViewModelStore store, @NonNull Factory factory) {\u003cbr/\u003e    mFactory = factory;\u003cbr/\u003e    mViewModelStore = store;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6f3e\"\u003eSo now we know that our activity is the \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e and its the responsibility of our activity to provide the \u003ccode\u003eViewModelStore\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"d5e0\"\u003eGetting the \u003ccode\u003eViewModel\u003c/code\u003e from \u003ccode\u003eViewModelProvider\u003c/code\u003e\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"dcb0\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u0026lt;T extends ViewModel\u0026gt; T \u003cstrong\u003eget\u003c/strong\u003e(@NonNull Class\u0026lt;T\u0026gt; modelClass) {\u003cbr/\u003e    String canonicalName = modelClass.getCanonicalName();\u003cbr/\u003e    \u003cstrong\u003eif\u003c/strong\u003e (canonicalName == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e        \u003cstrong\u003ethrow\u003c/strong\u003e \u003cstrong\u003enew\u003c/strong\u003e IllegalArgumentException(\u0026#34;Local and anonymous classes can not be ViewModels\u0026#34;);\u003cbr/\u003e    }\u003cbr/\u003e    \u003cstrong\u003ereturn\u003c/strong\u003e get(DEFAULT_KEY + \u0026#34;:\u0026#34; + canonicalName, modelClass);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eb58\"\u003eWhen we invoke \u003ccode\u003eget()\u003c/code\u003e method on our \u003ccode\u003eViewModelProvider\u003c/code\u003e, it gets the \u003cstrong\u003ecanonical name\u003c/strong\u003e of the view model class and creates a key by appending the \u003cstrong\u003ecanonical name\u003c/strong\u003e to a \u003cstrong\u003e\u003cem\u003eDEFAULT_KEY\u003c/em\u003e\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a7f\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u0026lt;T extends ViewModel\u0026gt; T \u003cstrong\u003eget\u003c/strong\u003e(@NonNull String key, @NonNull Class\u0026lt;T\u0026gt; modelClass) {\u003cbr/\u003e    ViewModel viewModel = mViewModelStore.get(key);\u003c/span\u003e\u003cspan id=\"5ac3\"\u003e    \u003cstrong\u003eif\u003c/strong\u003e (modelClass.isInstance(viewModel)) {\u003cbr/\u003e        \u003cstrong\u003eif\u003c/strong\u003e (mFactory \u003cstrong\u003einstanceof\u003c/strong\u003e OnRequeryFactory) {\u003cbr/\u003e            ((OnRequeryFactory) mFactory).onRequery(viewModel);\u003cbr/\u003e        }\u003cbr/\u003e        \u003cstrong\u003ereturn\u003c/strong\u003e (T) viewModel;\u003cbr/\u003e    } \u003cstrong\u003eelse\u003c/strong\u003e {\u003cbr/\u003e        \u003cem\u003e//noinspection StatementWithEmptyBody\u003c/em\u003e\u003cbr/\u003e        \u003cstrong\u003eif\u003c/strong\u003e (viewModel != \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e            \u003cem\u003e// TODO: log a warning.\u003c/em\u003e\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    \u003cstrong\u003eif\u003c/strong\u003e (mFactory \u003cstrong\u003einstanceof\u003c/strong\u003e KeyedFactory) {\u003cbr/\u003e        viewModel = ((KeyedFactory) (mFactory)).create(key, modelClass);\u003cbr/\u003e    } \u003cstrong\u003eelse\u003c/strong\u003e {\u003cbr/\u003e        viewModel = (mFactory).create(modelClass);\u003cbr/\u003e    }\u003cbr/\u003e    mViewModelStore.put(key, viewModel);\u003cbr/\u003e    \u003cstrong\u003ereturn\u003c/strong\u003e (T) viewModel;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"62b8\"\u003eAfter creating the key from the model class, it checks the \u003ccode\u003eViewModelStore\u003c/code\u003e (which is provided by our activity) whether a \u003ccode\u003eviewmodel\u003c/code\u003e instance for the given key is already present or not. If the \u003ccode\u003eviewmodel\u003c/code\u003e is already present, it simply returns the \u003ccode\u003eviewmodel\u003c/code\u003e instance present in \u003ccode\u003eViewModelStore\u003c/code\u003e and if it’s not present, the \u003ccode\u003eViewModelProvider\u003c/code\u003e uses the \u003ccode\u003eFactory\u003c/code\u003e instance to create a new \u003ccode\u003eviewmodel\u003c/code\u003e object and also stores it in \u003ccode\u003eViewModelStore\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"7635\"\u003eNow we know that our activity is responsible for storing the ViewModel instances. But it’s still a mystery that how these \u003ccode\u003eViewModel\u003c/code\u003e instances are retained even when the activity instance is recreated on configuration change.\u003c/p\u003e\u003ch2 id=\"ad8f\"\u003eHow ViewModel retain itself?\u003c/h2\u003e\u003cp id=\"c0fe\"\u003eAs we saw earlier when we created \u003ccode\u003eViewModelProvider\u003c/code\u003e we were passing an instance of \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e i.e., our \u003ccode\u003eactivity\u003c/code\u003e instance.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e76b\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003eclass\u003c/strong\u003e \u003cstrong\u003eComponentActivity\u003c/strong\u003e \u003cstrong\u003eextends\u003c/strong\u003e \u003cstrong\u003eandroidx\u003c/strong\u003e.\u003cstrong\u003ecore\u003c/strong\u003e.\u003cstrong\u003eapp\u003c/strong\u003e.\u003cstrong\u003eComponentActivity\u003c/strong\u003e \u003cstrong\u003eimplements\u003c/strong\u003e\u003cbr/\u003e        \u003cstrong\u003eLifecycleOwner\u003c/strong\u003e,\u003cbr/\u003e        \u003cstrong\u003eViewModelStoreOwner\u003c/strong\u003e,\u003cbr/\u003e        \u003cstrong\u003eSavedStateRegistryOwner\u003c/strong\u003e,\u003cbr/\u003e        \u003cstrong\u003eOnBackPressedDispatcherOwner\u003c/strong\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"abbb\"\u003eOur activity implements the \u003ccode\u003eViewModelStoreOwner\u003c/code\u003e the interface which has a single method named \u003ccode\u003egetViewModelStore()\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"afca\"\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003einterface\u003c/strong\u003e \u003cstrong\u003eViewModelStoreOwner\u003c/strong\u003e {\u003cbr/\u003e    \u003cstrong\u003e@NonNull\u003c/strong\u003e\u003cbr/\u003e    ViewModelStore \u003cstrong\u003egetViewModelStore\u003c/strong\u003e();\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f07c\"\u003eNow let’s have a look at the implementation of this method.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6651\"\u003e\u003cstrong\u003e@NonNull\u003c/strong\u003e\u003cbr/\u003e\u003cstrong\u003e@Override\u003c/strong\u003e\u003cbr/\u003e\u003cstrong\u003epublic\u003c/strong\u003e ViewModelStore \u003cstrong\u003egetViewModelStore\u003c/strong\u003e() {\u003cbr/\u003e    \u003cstrong\u003eif\u003c/strong\u003e (getApplication() == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e        \u003cstrong\u003ethrow\u003c/strong\u003e \u003cstrong\u003enew\u003c/strong\u003e IllegalStateException(\u0026#34;Your activity is not yet attached to the \u0026#34;\u003cbr/\u003e                + \u0026#34;Application instance. You can\u0026#39;t request ViewModel before onCreate call.\u0026#34;);\u003cbr/\u003e    }    \u003cem\u003e//This is true when invoked for the first time\u003c/em\u003e\u003cbr/\u003e    \u003cstrong\u003eif\u003c/strong\u003e (mViewModelStore == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e        NonConfigurationInstances nc =\u003cbr/\u003e                (NonConfigurationInstances) getLastNonConfigurationInstance();\u003cbr/\u003e        \u003cstrong\u003eif\u003c/strong\u003e (nc != \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e            \u003cem\u003e// Restore the ViewModelStore from NonConfigurationInstances\u003c/em\u003e\u003cbr/\u003e            mViewModelStore = nc.viewModelStore;\u003cbr/\u003e        }\u003cbr/\u003e        \u003cstrong\u003eif\u003c/strong\u003e (mViewModelStore == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e            mViewModelStore = \u003cstrong\u003enew\u003c/strong\u003e ViewModelStore();\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    \u003cstrong\u003ereturn\u003c/strong\u003e mViewModelStore;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8153\"\u003eHere we can see that \u003ccode\u003egetViewModelStore()\u003c/code\u003e returns the \u003ccode\u003e\u003cstrong\u003emViewModelStore\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e.\u003c/strong\u003e When our activity is recreated due to any configuration change, \u003ccode\u003enc(NonConfigurationInstances)\u003c/code\u003e contains the previous instance of \u003ccode\u003eViewModelStore\u003c/code\u003e. \u003ccode\u003enc(NonConfigurationInstances)\u003c/code\u003e is null when our activity is created for the first time and a new \u003ccode\u003eViewModelStore\u003c/code\u003e is created in this case.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"69a6\"\u003e\u003cem\u003e//ComponentActivity.java\u003c/em\u003e\u003cbr/\u003e\u003cstrong\u003estatic\u003c/strong\u003e \u003cstrong\u003efinal\u003c/strong\u003e \u003cstrong\u003eclass\u003c/strong\u003e \u003cstrong\u003eNonConfigurationInstances\u003c/strong\u003e {\u003cbr/\u003e    Object custom;\u003cbr/\u003e    ViewModelStore viewModelStore;\u003cbr/\u003e}\u003cem\u003e//Activity.java\u003c/em\u003e\u003cbr/\u003e\u003cstrong\u003estatic\u003c/strong\u003e \u003cstrong\u003efinal\u003c/strong\u003e \u003cstrong\u003eclass\u003c/strong\u003e \u003cstrong\u003eNonConfigurationInstances\u003c/strong\u003e {\u003cbr/\u003e    Object activity;  \u003cem\u003e//NonConfigurationInstances(ComponentActivity)\u003c/em\u003e\u003cbr/\u003e    HashMap\u0026lt;String, Object\u0026gt; children;\u003cbr/\u003e    FragmentManagerNonConfig fragments;\u003cbr/\u003e    ArrayMap\u0026lt;String, LoaderManager\u0026gt; loaders;\u003cbr/\u003e    VoiceInteractor voiceInteractor;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"51dd\"\u003e\u003ccode\u003eNonConfigurationInstances(Activity.java)\u003c/code\u003e is the object which is retained by the Android system even when the activity gets recreated. It has a member named \u003ccode\u003eactivity\u003c/code\u003e which is an instance of \u003ccode\u003eNonConfigurationInstances(ComponentActivity.java)\u003c/code\u003e. This instance contains \u003ccode\u003eViewModelStore\u003c/code\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"6b9d\"\u003eNote: \u003ccode\u003eViewModels\u003c/code\u003e are not retained directly. Instead, \u003ccode\u003eViewModelStore\u003c/code\u003e is retained on configuration changes which internally maintains a map of \u003ccode\u003eviewmodels\u003c/code\u003e.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"1c33\"\u003eLet’s deep dive more into this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e84d\"\u003e\u003cem\u003e//Activity.java\u003c/em\u003e\u003cbr/\u003e\u003cstrong\u003epublic\u003c/strong\u003e Object \u003cstrong\u003egetLastNonConfigurationInstance\u003c/strong\u003e() {\u003cbr/\u003e    \u003cstrong\u003ereturn\u003c/strong\u003e mLastNonConfigurationInstances != \u003cstrong\u003enull\u003c/strong\u003e\u003cbr/\u003e            ? mLastNonConfigurationInstances.activity : \u003cstrong\u003enull\u003c/strong\u003e;\u003cbr/\u003e}\u003cem\u003e//ComponentActivity.java\u003c/em\u003e\u003cbr/\u003e\u003cstrong\u003epublic\u003c/strong\u003e \u003cstrong\u003efinal\u003c/strong\u003e Object \u003cstrong\u003eonRetainNonConfigurationInstance\u003c/strong\u003e() {\u003cbr/\u003e    Object custom = onRetainCustomNonConfigurationInstance();\u003c/span\u003e\u003cspan id=\"b5b4\"\u003e    ViewModelStore viewModelStore = mViewModelStore;\u003cbr/\u003e    \u003cstrong\u003eif\u003c/strong\u003e (viewModelStore == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e        \u003cem\u003e// No one called getViewModelStore(), so see if there was an existing\u003c/em\u003e\u003cbr/\u003e        \u003cem\u003e// ViewModelStore from our last NonConfigurationInstance\u003c/em\u003e\u003cbr/\u003e        NonConfigurationInstances nc =\u003cbr/\u003e                (NonConfigurationInstances) getLastNonConfigurationInstance();\u003cbr/\u003e        \u003cstrong\u003eif\u003c/strong\u003e (nc != \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e            viewModelStore = nc.viewModelStore;\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"6c7f\"\u003e    \u003cstrong\u003eif\u003c/strong\u003e (viewModelStore == \u003cstrong\u003enull\u003c/strong\u003e \u0026amp;\u0026amp; custom == \u003cstrong\u003enull\u003c/strong\u003e) {\u003cbr/\u003e        \u003cstrong\u003ereturn\u003c/strong\u003e \u003cstrong\u003enull\u003c/strong\u003e;\u003cbr/\u003e    }\u003c/span\u003e\u003cspan id=\"bf19\"\u003e    NonConfigurationInstances nci = \u003cstrong\u003enew\u003c/strong\u003e NonConfigurationInstances();\u003cbr/\u003e    nci.custom = custom;\u003cbr/\u003e    nci.viewModelStore = viewModelStore;\u003cbr/\u003e    \u003cstrong\u003ereturn\u003c/strong\u003e nci;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0864\"\u003eWhenever our activity is getting recreated due to any configuration change, \u003ccode\u003eonRetainNonConfigurationInstance()\u003c/code\u003e gets invoked which returns the \u003ccode\u003eNonConfigurationInstances(ComponentActivity.java)\u003c/code\u003e instance. This object is retained by the Android system so that it can be delivered to the next activity instance on recreation.\u003c/p\u003e\u003cp id=\"c8a4\"\u003eSimilarly, we can also retain our own custom objects by implementing the \u003ccode\u003eonRetainCustomNonConfigurationInstance()\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"ae4b\"\u003eAfter the recreation of our activity, \u003ccode\u003eNonConfigurationInstances(Activity.java)\u003c/code\u003e is received in the \u003ccode\u003eattach()\u003c/code\u003e method of the \u003ccode\u003eActivity\u003c/code\u003e class.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3f0c\"\u003e\u003cstrong\u003efinal\u003c/strong\u003e \u003cstrong\u003evoid\u003c/strong\u003e \u003cstrong\u003eattach\u003c/strong\u003e(Context context, ActivityThread aThread,\u003cbr/\u003e        Instrumentation instr, IBinder token, \u003cstrong\u003eint\u003c/strong\u003e ident,\u003cbr/\u003e        Application application, Intent intent, ActivityInfo info,\u003cbr/\u003e        CharSequence title, Activity parent, String id,\u003cbr/\u003e        NonConfigurationInstances lastNonConfigurationInstances,\u003cbr/\u003e        Configuration config, String referrer, IVoiceInteractor voiceInteractor,\u003cbr/\u003e        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"69a9\"\u003eThis is how the \u003ccode\u003eviewmodels\u003c/code\u003e are retained on configuration changes.\u003c/p\u003e\u003cp id=\"0695\"\u003eYou can also connect with me on \u003ca href=\"https://www.linkedin.com/in/deepanshu42/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinkedIn\u003c/a\u003e, \u003ca href=\"https://twitter.com/deep1743\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTwitter\u003c/a\u003e, \u003ca href=\"https://www.facebook.com/deepanshu42\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFacebook\u003c/a\u003e, and \u003ca href=\"https://github.com/deepanshu42\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGithub\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"a640\"\u003eThank You!!!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2020-07-14T02:58:24.437Z",
  "modifiedTime": null
}
