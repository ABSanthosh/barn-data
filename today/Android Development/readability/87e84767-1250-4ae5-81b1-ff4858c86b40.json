{
  "id": "87e84767-1250-4ae5-81b1-ff4858c86b40",
  "title": "App modularization and module lazy loading at Instagram and beyond",
  "link": "https://instagram-engineering.com/app-modularization-and-module-lazy-loading-at-instagram-and-beyond-46b9daa3fea4?source=rss----37dc2a3034f2--android",
  "description": "",
  "author": "Instagram Engineering",
  "published": "Fri, 03 Nov 2017 17:02:32 GMT",
  "source": "https://instagram-engineering.com/feed/tagged/android",
  "categories": [
    "android",
    "instagram"
  ],
  "byline": "Instagram Engineering",
  "length": 6897,
  "excerpt": "Instagram prides itself on having a lean app. But as the number of engineers and features grows, so do the challenges to size. We start to face issues like: To tackle these issues, we recently…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Instagram prides itself on having a lean app. But as the number of engineers and features grows, so do the challenges to size. We start to face issues like:increase in application size downloaded from an app storeincrease in cold start time, and more generally, increased time to interaction with different surfaces inside the appincrease in disk space usagedecrease in developer velocity from increased complexity of the app or build timeTo tackle these issues, we recently enacted an Instagram-wide code modularization effort to create strict isolation between features. We do this on both Android and iOS, but this post will primarily focus on Android. Once a feature is modularized, we can take the feature out of the primary executable file and compile it to the dedicated file and lazily load it during app runtime on-demand. Lazy loading can bring a combination of benefits like improved cold start time (especially on Dalvik) and overall runtime, decreased disk footprint, and better developer velocity if module hotswapping is implemented. This post will walk through how we approach modularization and lazy loading at Instagram, and how you can implement it in your own app with our new open-sourced framework.App modularizationWhat is modularizationModularization is the process of separating and creating clear boundaries between logical components of code. For Instagram, we’ve been focused on modularizing feature code since it represents a large part of the codebase, and each feature has clear boundaries. Reducing cross-feature dependencies with modularization helps us solve the challenges of a growing app in a couple of ways. One benefit is that it helps us protect our app’s start time from growing as the amount of code in the app increases. Before modularization, a chain of code references from one feature to another might have risked loading in all of that code during app start time. But by breaking apart these references with modularization, we can wait to load code when it’s actually needed using methods like Lazy Loading (see below). In addition, modularization has other great benefits for overall codebase sanity, build times, developer velocity, Instant Apps, etc.How to modularizeThe goal of modularization is to have a clearly defined interface that separates the implementation of the feature from outside code. Start by auditing all the incoming dependencies to the feature. For each dependency, figure out if it should be removed or kept. Since each case is different, there is no simple way of making this evaluation — but here are some considerations to make:Is the dependency a result of misplaced code? Sometimes a dependency exists because there’s a shared library method or misplaced method in the feature that should actually live outside of the feature. If so, move the referenced code out of the feature and into the appropriate place.Is there a way to rewrite the dependency to be more generic rather than have it reference feature-specific code?Does the dependency exist because we’re accessing some feature-specific logic earlier than necessary? If so, try to defer this logic until later.Is the surrounding logic overloaded? If so, simplify the logic into the feature-specific part to make it simpler to reason about the necessity of the dependency.If the dependency is still necessary after making these considerations, then it belongs as part of the feature’s interface. If we’ve done the modularization well, the feature’s interface should contain just a few critical methods. Some examples are:Methods that allow navigating to the featureLifecycle methods that listen for app-wide lifecycle eventsMethods that expose core functionality in the feature.Module lazy loadingWhat is lazy loadingWhile modularization will decouple a feature from the outside world and create a clean interface to the feature, lazy loading will take this further and compile the feature out of the main executable (dex) file to a separate dex file. Each lazily loaded feature will live in a separate file, which will bring benefits like:allowing the feature to load in memory only when really needed instead of on every cold start. It offloads code from the main executable file, which remains smaller and guarantees better cold start time. On Dalvik it offloads methods off the main dex file, decreasing performance penalty of multi dex.clustering feature code together in memory, as it lives in one file and provides most optimal execution in terms of memory accessusing less disk space if some modules remain unused because feature code will never be uncompressedpossibility of having an adaptable app with different sets of features shipped to different users (e.g. non-business users don’t need business features), thus decreasing initial app sizeAnd for developer velocity, we added support for hotswapping of lazy loaded modules, which means developers will be able to keep coding and seeing changes without restarting the app.When we trigger lazy loadingGenerally speaking we load a module when we expect it to be used in the near future. Once the module is loaded it will remain in memory until the next cold start. Module loading may incur a small latency (depending on the size of the module), so different tactics may be applied:Loading a module in the background when the user is one click away from the module. This may mean that the module remains unused if the user doesn’t decide to click into that feature or navigates back. But if there’s high probability of clicking into that module, then it’s a good solution.Loading a module once the user navigates into the module. If loading latency is small (below 50ms) for the majority of cases (e.g. p99), then we could simply block on loading, and once it’s done navigate into the feature. Otherwise a simple spinner or a progress bar can be displayed so that the app does not appear as frozen.Some modules are by nature asynchronous, which eases lazy loading since it will be the part of the asynchronous loading. An example is a video player that runs in a secondary process. Instagram initially shows a screenshot of the video while it loads in the background (often times fetched from the network). Lazy loading would happen in that secondary process and be completely transparent to users.We open sourced our framework for lazy loading at ig-lazy-module-loader so that other developers can use it in their apps, or simply learn from our implementation. It can be beneficial if you’re hitting a performance penalty of multi-dex on Dalvik or have many features which may remain unused by some users and you want to save disk space. We recently moved our mobile infrastructure engineering teams (iOS and Android) to New York City. If this blog post got you excited about what we’re doing, we’re hiring — check out our careers page. Mona Huang and Julian Krzeminski work on Android at Instagram.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@InstagramEng?source=post_page-----46b9daa3fea4--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*8x_1IP3b75o5u9M4LgFBig.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page-----46b9daa3fea4--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"53e5\"\u003eInstagram prides itself on having a lean app. But as the number of engineers and features grows, so do the challenges to size. We start to face issues like:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2e65\"\u003eincrease in application size downloaded from an app store\u003c/li\u003e\u003cli id=\"8929\"\u003eincrease in cold start time, and more generally, increased time to interaction with different surfaces inside the app\u003c/li\u003e\u003cli id=\"d7a2\"\u003eincrease in disk space usage\u003c/li\u003e\u003cli id=\"6730\"\u003edecrease in developer velocity from increased complexity of the app or build time\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1fa2\"\u003eTo tackle these issues, we recently enacted an Instagram-wide code modularization effort to create strict isolation between features. We do this on both Android and iOS, but this post will primarily focus on Android. Once a feature is modularized, we can take the feature out of the primary executable file and compile it to the dedicated file and lazily load it during app runtime on-demand. Lazy loading can bring a combination of benefits like improved cold start time (especially on Dalvik) and overall runtime, decreased disk footprint, and better developer velocity if module hotswapping is implemented. This post will walk through how we approach modularization and lazy loading at Instagram, and how you can implement it in your own app with our new open-sourced framework.\u003c/p\u003e\u003ch2 id=\"cebd\"\u003eApp modularization\u003c/h2\u003e\u003ch2 id=\"3134\"\u003eWhat is modularization\u003c/h2\u003e\u003cdiv id=\"3714\"\u003e\u003cp\u003eModularization is the process of separating and creating clear boundaries between logical components of code. For Instagram, we’ve been focused on modularizing feature code since it represents a large part of the codebase, and each feature has clear boundaries. Reducing cross-feature dependencies with modularization helps us solve the challenges of a growing app in a couple of ways. One benefit is that it helps us protect our app’s start time from growing as the amount of code in the app increases. Before modularization, a chain of code references from one feature to another might have risked loading in all of that code during app start time. But by breaking apart these references with modularization, we can wait to load code when it’s actually needed using methods like Lazy Loading (see below). \u003c/p\u003e\u003cp\u003e  In addition, modularization has other great benefits for overall codebase sanity, build times, developer velocity, Instant Apps, etc.\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"bfd8\"\u003eHow to modularize\u003c/h2\u003e\u003cp id=\"943a\"\u003eThe goal of modularization is to have a clearly defined interface that separates the implementation of the feature from outside code. Start by auditing all the incoming dependencies to the feature. For each dependency, figure out if it should be removed or kept. Since each case is different, there is no simple way of making this evaluation — but here are some considerations to make:\u003c/p\u003e\u003cul\u003e\u003cli id=\"70c0\"\u003eIs the dependency a result of misplaced code? Sometimes a dependency exists because there’s a shared library method or misplaced method in the feature that should actually live outside of the feature. If so, move the referenced code out of the feature and into the appropriate place.\u003c/li\u003e\u003cli id=\"3b87\"\u003eIs there a way to rewrite the dependency to be more generic rather than have it reference feature-specific code?\u003c/li\u003e\u003cli id=\"8efa\"\u003eDoes the dependency exist because we’re accessing some feature-specific logic earlier than necessary? If so, try to defer this logic until later.\u003c/li\u003e\u003cli id=\"8c84\"\u003eIs the surrounding logic overloaded? If so, simplify the logic into the feature-specific part to make it simpler to reason about the necessity of the dependency.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"85e6\"\u003eIf the dependency is still necessary after making these considerations, then it belongs as part of the feature’s interface. If we’ve done the modularization well, the feature’s interface should contain just a few critical methods. Some examples are:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f617\"\u003eMethods that allow navigating to the feature\u003c/li\u003e\u003cli id=\"a3ad\"\u003eLifecycle methods that listen for app-wide lifecycle events\u003c/li\u003e\u003cli id=\"e20e\"\u003eMethods that expose core functionality in the feature.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c7b4\"\u003eModule lazy loading\u003c/h2\u003e\u003ch2 id=\"63a1\"\u003eWhat is lazy loading\u003c/h2\u003e\u003cp id=\"fde8\"\u003eWhile modularization will decouple a feature from the outside world and create a clean interface to the feature, lazy loading will take this further and compile the feature out of the main executable (dex) file to a separate dex file. Each lazily loaded feature will live in a separate file, which will bring benefits like:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6aa9\"\u003eallowing the feature to load in memory only when really needed instead of on every cold start. It offloads code from the main executable file, which remains smaller and guarantees better cold start time. On Dalvik it offloads methods off the main dex file, decreasing performance penalty of multi dex.\u003c/li\u003e\u003cli id=\"b1de\"\u003eclustering feature code together in memory, as it lives in one file and provides most optimal execution in terms of memory access\u003c/li\u003e\u003cli id=\"a032\"\u003eusing less disk space if some modules remain unused because feature code will never be uncompressed\u003c/li\u003e\u003cli id=\"315e\"\u003epossibility of having an adaptable app with different sets of features shipped to different users (e.g. non-business users don’t need business features), thus decreasing initial app size\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"042b\"\u003eAnd for developer velocity, we added support for hotswapping of lazy loaded modules, which means developers will be able to keep coding and seeing changes without restarting the app.\u003c/p\u003e\u003ch2 id=\"6e09\"\u003eWhen we trigger lazy loading\u003c/h2\u003e\u003cp id=\"8649\"\u003eGenerally speaking we load a module when we expect it to be used in the near future. Once the module is loaded it will remain in memory until the next cold start. Module loading may incur a small latency (depending on the size of the module), so different tactics may be applied:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0b35\"\u003eLoading a module in the background when the user is one click away from the module. This may mean that the module remains unused if the user doesn’t decide to click into that feature or navigates back. But if there’s high probability of clicking into that module, then it’s a good solution.\u003c/li\u003e\u003cli id=\"3e31\"\u003eLoading a module once the user navigates into the module. If loading latency is small (below 50ms) for the majority of cases (e.g. p99), then we could simply block on loading, and once it’s done navigate into the feature. Otherwise a simple spinner or a progress bar can be displayed so that the app does not appear as frozen.\u003c/li\u003e\u003cli id=\"5bde\"\u003eSome modules are by nature asynchronous, which eases lazy loading since it will be the part of the asynchronous loading. An example is a video player that runs in a secondary process. Instagram initially shows a screenshot of the video while it loads in the background (often times fetched from the network). Lazy loading would happen in that secondary process and be completely transparent to users.\u003c/li\u003e\u003c/ul\u003e\u003cdiv id=\"b30d\"\u003e\u003cp\u003eWe open sourced our framework for lazy loading at \u003ca href=\"https://github.com/Instagram/ig-lazy-module-loader\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eig-lazy-module-loader\u003c/a\u003e so that other developers can use it in their apps, or simply learn from our implementation. It can be beneficial if you’re hitting a performance penalty of multi-dex on Dalvik or have many features which may remain unused by some users and you want to save disk space.\u003c/p\u003e\u003cp\u003e  \u003cem\u003eWe recently moved our mobile infrastructure engineering teams (iOS and Android) to New York City. If this blog post got you excited about what we’re doing, we’re hiring — check out our \u003c/em\u003e\u003ca href=\"https://www.instagram.com/about/jobs/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ecareers page\u003c/em\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e  \u003cem\u003eMona Huang and Julian Krzeminski work on Android at Instagram.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2017-11-03T17:02:32.139Z",
  "modifiedTime": null
}
