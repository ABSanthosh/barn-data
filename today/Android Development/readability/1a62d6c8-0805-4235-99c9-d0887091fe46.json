{
  "id": "1a62d6c8-0805-4235-99c9-d0887091fe46",
  "title": "“Expect Actual” Mechanism in Kotlin Multiplatform Explained",
  "link": "https://proandroiddev.com/expect-actual-mechanism-in-kotlin-multiplatform-explained-a91e7d85af4e?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Mon, 30 Jun 2025 09:03:33 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "ios-app-development",
    "kotlin-multiplatform",
    "kotlin",
    "mobile-app-development",
    "android-development"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 18210,
  "excerpt": "A deep dive into the expect/actual mechanism in Kotlin Multiplatform (KMM). Learn how it works, see examples, and compare it to interfaces.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Learn how it works, see examples, and compare it to interfaces.IntroductionKotlin Multiplatform (KMM) is a modern way to write code that works on many platforms such as Android, iOS, desktop computers, and even web applications. Instead of writing the same code many times for different platforms, you write it once and share it. This saves time, reduces mistakes, and makes your apps more consistent.One of the powerful features of Kotlin Multiplatform is the expect/actual mechanism. This article explains what “expect/actual” is, how it works, and why it is very useful in modern cross-platform development.What You’ll LearnCore concepts of Kotlin Multiplatform and the expect/actual mechanismPractical implementation patterns with real-world examplesAdvanced dependency injection using Koin 4.1.0+Comparison with alternative approaches like interfacesBest practices and common pitfalls to avoidBy the end of this article, you will have a strong understanding of the “expect/actual” mechanism in Kotlin Multiplatform, and you will be able to apply these ideas in your projects.For more details, see the official Kotlin documentation: Expect and Actual Declarations | Kotlin Multiplatform.1. Understanding Kotlin MultiplatformKotlin Multiplatform (KMM) OverviewKotlin Multiplatform is a way to write code that can run on many different platforms without having to rewrite the same logic over and over again.Imagine you are writing a recipe. Instead of writing separate recipes for each family member, you write one recipe that everyone can use, but sometimes you add a small note on how to adjust it for each person’s taste.Benefits of Kotlin MultiplatformCode Reusability: Write business logic, data models, and algorithms once, use everywhereType Safety: Kotlin’s strong typing extends across all platforms, catching errors at compile timeGradual Adoption: Start with shared modules and expand as needed — you’re not forced to share everythingNative Performance: Compiles to native code on each platform, ensuring optimal performanceTooling Support: Full IDE support with code completion, refactoring, and debuggingHowever, KMP does not force you to share everything. For instance, UI code is often different for Android and iOS, because each platform has its own design language and frameworks.KMP provides the option to share what makes sense (like data handling or domain logic) and keep platform-specific components separate.2. The “Expect Actual” Mechanism ExplainedEven though Kotlin Multiplatform allows you to share a lot of code, some parts of your application need to work differently depending on the platform. For example, reading a file or saving data might work differently on an Android phone than on an iPhone.2.1 The Core ConceptYou can think of “expect/actual” like a contract:expect: In your shared (common) module, you declare what you need, such as a function or class for storage.actual: In each platform-specific module (Android, iOS, etc.), you provide the concrete implementation of that function or class.This approach keeps your shared code simple, because it just calls getBatteryLevel() or getPlatformName(), and it does not care how each different platform might approach the request, as long as it replies with the expected response.2.2 How It Works Under the HoodWhen you declare an expect function, class, or property, you're essentially creating a placeholder that the Kotlin compiler will resolve at build time.Each target platform must provide a matching actual implementation, or compilation fails.// Common module - the contractexpect fun getPlatformName(): String// Android module - the implementationactual fun getPlatformName(): String = \"Android\"// iOS module - the implementationactual fun getPlatformName(): String = \"iOS\"2.3 Compiler EnforcementThe beauty of expect/actual lies in its compile-time safety. Unlike runtime checks or dependency injection alone, the compiler ensures:Every expect has a corresponding actual for each target platformThe signatures match exactly (name, parameters, return type)No platform is accidentally left without implementation3. What Can Use Expect/Actual?The mechanism supports various declaration types:Functions — Most common use caseexpect fun getCurrentTimestamp(): LongProperties — For platform-specific valuesexpect val deviceId: StringClasses — When entire objects need platform-specific behaviorexpect class FileManager() { fun readFile(path: String): String fun writeFile(path: String, content: String)}Objects — For singleton platform servicesexpect object PlatformConfig { val apiEndpoint: String}Interfaces, Enums, and Annotations — Less common but supported4. Learn by Example4.1. Step-by-Step Explanation by a Simple ExampleLet’s say we want to use some function that is defined differently for Android and iOS.Declare the Requirement with expect:In the common code, you write a declaration without a body.expect fun getCurrentTime(): LongThis line means: “I need a function called getCurrentTime() that returns a number (Long), but I will explain how it works later for each platform.\"2. Provide the Details with actual:In the platform-specific code, you write the implementation.// Androidactual fun getCurrentTime(): Long = System.currentTimeMillis()// iOSimport platform.Foundation.NSDateimport platform.Foundation.timeIntervalSince1970actual fun getCurrentTime(): Long = (NSDate().timeIntervalSince1970 * 1000).toLong()Each target platform must provide a matching function to satisfy the expect contract.3. Use the Function in Shared Code:Now, in your shared module, you can use the function without worrying about the platform differences:val currentTime = getCurrentTime()println(\"Current Time is: $currentTime\")4. Compiler Safety:The Kotlin compiler checks that every expect has a matching actual. If one platform is missing the implementation, the code will not compile. This makes the mechanism safe and reliable.That’s it! Now, from any shared Kotlin code, you can call getCurrentTime() and know that the correct implementation will be used at runtime, depending on whether you are on Android or iOS.4.2 A “Hello World” Class Example: Identifying the PlatformAs already mentioned, you are not limited to functions. You can also use expect/actual on classes, properties, interfaces, and even annotation classes. A classic \"hello world\" example for Kotlin Multiplatform is to get the name of the operating system.Let’s define a Platform class that holds the name of the current platform.1. Define the expect class in the common module:// Common moduleexpect class Platform() { val name: String}This declares that we expect a class named Platform to exist on every target. This class must have a property called name of type String.2. Provide the actual class for Android: On Android, we can use the Build class to get the OS version.// androidMain module import android.os.Buildactual class Platform actual constructor() { actual val name: String = \"Android ${Build.VERSION.SDK_INT}\"}3. Provide the actual class for iOS: On iOS, we can use UIDevice from the UIKit framework.// iosMain moduleimport platform.UIKit.UIDeviceactual class Platform actual constructor() { actual val name: String = UIDevice.currentDevice.systemName() + \" \" + UIDevice.currentDevice.systemVersion}Now, you can instantiate and use this class in your shared code at commonMain:// In your shared codeval platform = Platform()println(\"Hello from ${platform.name}!\")This simple example shows how expect/actual can be used on classes to provide platform-specific data, keeping the shared code that uses it clean and unaware of the underlying platform details.5. Limitationsexpect Declarations Cannot Contain CodeA common point of confusion for developers is how expect relates to concepts like abstract classes or interfaces with default methods. It’s crucial to understand a fundamental rule: an expect declaration is purely a template. It cannot contain any concrete default implementation code or logic in the common module.You cannot mix implemented methods with expected methods in the same expect block.What You CANNOT Do The following code will fail to compile because it tries to add shared logic directly inside an expect class:// THIS WILL NOT COMPILE!expect class MixedDeclarations { // This part is a valid expect function expect fun platformSpecificLog() // This part is NOT valid because it has an implementation body {} fun sharedLog() { println(\"This shared logic is not allowed inside an expect class.\") }}6. InitializationsHere comes a very crucial part of the expect/actual mechanism that is both practical and powerful.You see, many times we need to declare a class that can be used in both Android and iOS, but its dependencies during creation may vary between Android and iOS. For example, in Android you might need to make use of a Context which is not applicable in iOS. Or in Ktor, you normally need to define a Darwin http client for iOS and OkHttp for Android.6.1 KoinExample by: https://github.com/ioannisa/CMPMasterDetail/Koin is the most recommended way to create Dependencies for Kotlin Multiplatform.To create dependencies with Koin you need to register Koin Modules for your project. For KMP you are expected to at least have have one such module per platform module, and another for the commonMain module.In Koin 4.1.0 the KoinMultiplatformApplication is introduced as a one-line setup for starting Koin and applying modules in our KMP Project.1. Let’s begin by setting up Koin.// App.kt (your KMP application entry point)fun App() { KoinMultiplatformApplication( config = KoinConfiguration { modules(sharedModule, platformModule) } ) { MyKMPSuperAppTheme { // ... }}Here we are exposing two modules, the sharedModule which will contain all common dependency initializations for all platforms and the platformModule which as you can guess is using the expect/actual mechanism to define different dependency initializations per platform.2. The commonMain Koin Module CodeLet’s hit a scenario where we have an http-client with Ktor and a Movies Database factory for Room.// commonMain/di/Modules.ktexpect val platformModule: Moduleval sharedModule = module { single\u003cMoviesHttpClient\u003e { MoviesHttpClient( engine = get(), baseUrl = BuildConfig.BASE_URL_MOVIES, apiKey = BuildConfig.API_KEY_MOVIES, logging = true ) } single { get\u003cMoviesDatabaseFactory\u003e().create() .setDriver(BundledSQLiteDriver()) .build() // .build() returns MoviesDatabase instance } single { get\u003cMoviesDatabase\u003e().moviesDao }}Notice some interesting facts here.First, our Modules.kt file at commonMain defines its a Koin sharedModule together with an expect platformModule that is expected to define separate Dependency Injection instances for each platform.Note we are expecting an HttpClientEngine at the engine parameter for our network setup. Seems like we are going to define that differently in our platforms. Wow, we are going to define part of the dependency for network per platform, while the rest of it in commonMain? Just wow!Our MoviesDatabase instance utilizes the creation of a MoviesDatabaseFactory object, and while just creating it here, we will interestingly see it is defined differently for iOS and Android.3. The androidMain Koin ModuleHere we witness the actual implementation of the platformModule for Android!Yes, everything here is customized just for object dependencies provided for the Android platform.actual val platformModule: Module get() = module { single\u003cHttpClientEngine\u003e { OkHttp.create() } single\u003cVault\u003e { Vault(androidApplication()) } single { MoviesDatabaseFactory(androidApplication()) } }Ok, here we seethat the engine that the commomMain Koin Module required gets initialized here and we pass an OkHttp as HttpClientEngine that works fine with Android!We also see Vault that didn’t exist at commonModule at the first place, initialized passing a Context.Also, we see that our MoviesDatabaseFactory needed for MoviesDatabase creation gets initialized here, because in the case of Android there is also need of Context.4. The iosMain Koin ModuleNow is the time for the actual implementation of the platformModule for iOS! So here we have object creations only for builds targeting iOS devices.actual val platformModule: Module get() = module { single\u003cHttpClientEngine\u003e { Darwin.create() } single { MoviesDatabaseFactory() } single\u003cVault\u003e { Vault() } factory\u003cSavedStateHandle\u003e { SavedStateHandle() } }Here we see even more interesting facts about the way our actual mechanism works for providing specialized object instances for iOS builds.This time the HttpClientEngine is Darwin that can be used for iOS, rather than the OkHttp that is Java-based which is being used by Android.We note that we initialized the MoviesDatabaseFactory and Vault to their equivalent classes definitions in iosMain that don’t require passing Context.We create a SavedStateHandle() wrapper instance to pass a specialized version of the SavedStateHandle so we don’t get crashes on iOS which doesn’t handle app-death similarly to Android, while maintaining parameter passing to the ViewModel via our navigation component.7. TL;DR Explanation of Expect ActualHow Expect Actual Worksexpect/actual is a feature built into the Kotlin language to handle platform differences in KMM. Here’s the process step by step:Expect Declaration: In the common module, you use expect to define a function, property, or class without writing its implementation. This tells the Kotlin compiler, “This will exist, but the platforms will fill in the details.”Actual Declaration: In each platform-specific module (like Android or iOS), you use actual to provide the real code for that declaration. The actual version must match the expect version exactly — same name, same parameters, same return type.Compiler Safety: When you build your project, the Kotlin compiler checks that every expect in the common module has a matching actual in every platform module. If one is missing (say, you forgot the iOS version), the compiler stops the build with an error, preventing broken apps.This system ensures that your shared code can depend on certain features being available, while each platform handles them in its own way.8. Comparing “Expect Actual” and InterfacesBoth “expect actual” and interfaces allow you to define a contract for your code. However, they work in different ways.8.1. InterfacesWith interfaces, you define functions in a common module, and then each platform must provide its own version. However, interfaces have some differences:Default Implementations: Interfaces in Kotlin can have default implementations. This means you can write some code in the interface itself.Extra Setup Needed: Using interfaces often requires additional work like setting up factories or dependency injection. This can increase the amount of code you need to write.8.2. Advantages of “Expect Actual”Less Boilerplate: “Expect actual” is direct. You declare your need in the common module and then simply provide the details on each platform without extra setup.Compiler Checks: The Kotlin compiler makes sure every expect has a matching actual. If you forget one, you will see an error at compile time rather than a runtime crash.9. Best Practices and Limitations9.1. Best PracticesTo make the most out of the “expect actual” mechanism, follow these guidelines:Keep Expect Declarations Small: Only declare what really needs to be different between platforms. This keeps your shared module clean.Use Clear, Descriptive Names: Use names like getPlatformName() or readUserData() so that it is obvious what the function does.Write Thorough Tests: Make sure that the actual implementations on each platform work correctly by writing unit tests for each platform.Document Your Code: Explain in comments or documentation why you are using “expect actual” and what each implementation is supposed to do. This is very helpful for teams and future maintenance.Consider Interfaces for Shared Logic: When you need default behavior or more flexibility, consider using interfaces instead of “expect actual”.9.2. Limitations to Be Aware OfNo Default Code in Expect: Since you cannot provide a default implementation in the common module, you must duplicate some logic if it applies to all platforms.Maintenance Overhead: In large projects with many platforms, you may need to write many actual implementations. Good planning and documentation are essential.Not Suitable for UI Code: The “expect actual” mechanism works best for non-UI logic. Since each platform has its own design language and framework, user interface code often remains platform-specific.10. ConclusionThe expect/actual mechanism is central to Kotlin Multiplatform. It provides a direct, compiler-enforced way to manage platform-specific implementations, making cross-platform code more reliable and maintainable. While interfaces offer flexibility with default implementations, expect/actual shines with its simplicity and compile-time safety for direct platform access.We’ve explored:The fundamental expect/actual contract and its compile-time guarantees.Simple, practical examples for functions, classes, and properties.The key limitation that expect declarations cannot contain implementation code.A real-world pattern for dependency injection using an expect val for Koin modules to provide platform-specific dependencies like Ktor's HttpClientEngine and database factories.By understanding these patterns and applying the best practices outlined, you can leverage expect/actual to build efficient, scalable, and maintainable cross-platform applications, maximizing code sharing without sacrificing access to native capabilities.Further ReadingExpected and Actual Declarations — Kotlin DocumentationKotlin Multiplatform expect/actual on Interface — Stack OverflowKotlin Multiplatform Dependency Injection — Koin",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*4WLP2xY1PiEvWJ2CsGlbDQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"14ef\"\u003eLearn how it works, see examples, and compare it to interfaces.\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--a91e7d85af4e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*CPyc3y-sp02vMh239V_suQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"4024\"\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"4303\"\u003e\u003cstrong\u003eKotlin Multiplatform (KMM)\u003c/strong\u003e is a modern way to write code that works on many platforms such as \u003cstrong\u003eAndroid\u003c/strong\u003e, \u003cstrong\u003eiOS\u003c/strong\u003e, \u003cstrong\u003edesktop computers\u003c/strong\u003e, and even \u003cstrong\u003eweb applications\u003c/strong\u003e. Instead of writing the same code many times for different platforms, you write it \u003cstrong\u003eonce\u003c/strong\u003e and share it. This saves time, reduces mistakes, and makes your apps more consistent.\u003c/p\u003e\u003cp id=\"9403\"\u003eOne of the powerful features of \u003cstrong\u003eKotlin Multiplatform\u003c/strong\u003e is the \u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e/\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e mechanism. This article explains what \u003cstrong\u003e“\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e/\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e”\u003c/strong\u003e is, how it works, and why it is very useful in modern cross-platform development.\u003c/p\u003e\u003ch2 id=\"4be9\"\u003eWhat You’ll Learn\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b7c4\"\u003e\u003cstrong\u003eCore concepts\u003c/strong\u003e of Kotlin Multiplatform and the \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e mechanism\u003c/li\u003e\u003cli id=\"e40c\"\u003e\u003cstrong\u003ePractical implementation patterns\u003c/strong\u003e with real-world examples\u003c/li\u003e\u003cli id=\"3442\"\u003e\u003cstrong\u003eAdvanced dependency injection\u003c/strong\u003e using Koin 4.1.0+\u003c/li\u003e\u003cli id=\"5204\"\u003e\u003cstrong\u003eComparison with \u003c/strong\u003ealternative approaches like \u003cstrong\u003einterfaces\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"bb76\"\u003e\u003cstrong\u003eBest practices\u003c/strong\u003e and \u003cstrong\u003ecommon pitfalls\u003c/strong\u003e to avoid\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e773\"\u003eBy the end of this article, you will have a strong understanding of the \u003cstrong\u003e“\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e/\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e”\u003c/strong\u003e mechanism in \u003cstrong\u003eKotlin Multiplatform\u003c/strong\u003e, and you will be able to apply these ideas in your projects.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"6c1e\"\u003e\u003cem\u003eFor more details, see the official Kotlin documentation: \u003c/em\u003e\u003ca href=\"https://kotlinlang.org/docs/multiplatform-expect-actual.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003eExpect and Actual Declarations | Kotlin Multiplatform\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3fac\"\u003e1. Understanding Kotlin Multiplatform\u003c/h2\u003e\u003ch2 id=\"8aaa\"\u003eKotlin Multiplatform (KMM) Overview\u003c/h2\u003e\u003cp id=\"1580\"\u003e\u003cstrong\u003eKotlin Multiplatform\u003c/strong\u003e is a way to write code that can run on many different platforms without having to rewrite the same logic over and over again.\u003c/p\u003e\u003cp id=\"353e\"\u003eImagine you are writing a recipe. Instead of writing separate recipes for each family member, you write one recipe that everyone can use, but sometimes you add a small note on how to adjust it for each person’s taste.\u003c/p\u003e\u003ch2 id=\"f160\"\u003eBenefits of Kotlin Multiplatform\u003c/h2\u003e\u003cul\u003e\u003cli id=\"53da\"\u003e\u003cstrong\u003eCode Reusability\u003c/strong\u003e: Write business logic, data models, and algorithms once, use everywhere\u003c/li\u003e\u003cli id=\"f259\"\u003e\u003cstrong\u003eType Safety\u003c/strong\u003e: Kotlin’s strong typing extends across all platforms, catching errors at compile time\u003c/li\u003e\u003cli id=\"3020\"\u003e\u003cstrong\u003eGradual Adoption\u003c/strong\u003e: Start with shared modules and expand as needed — you’re not forced to share everything\u003c/li\u003e\u003cli id=\"a14b\"\u003e\u003cstrong\u003eNative Performance\u003c/strong\u003e: Compiles to native code on each platform, ensuring optimal performance\u003c/li\u003e\u003cli id=\"0459\"\u003e\u003cstrong\u003eTooling Support\u003c/strong\u003e: Full IDE support with code completion, refactoring, and debugging\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"dd86\"\u003eHowever, KMP does not force you to share \u003cstrong\u003eeverything\u003c/strong\u003e. For instance, UI code is often different for Android and iOS, because each platform has its own design language and frameworks.\u003c/p\u003e\u003cp id=\"8f73\"\u003eKMP provides the \u003cstrong\u003eoption\u003c/strong\u003e to share what makes sense (like data handling or domain logic) and keep platform-specific components separate.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e999\"\u003e2. The “Expect Actual” Mechanism Explained\u003c/h2\u003e\u003cp id=\"4802\"\u003eEven though \u003cstrong\u003eKotlin Multiplatform\u003c/strong\u003e allows you to share a lot of code, some parts of your application need to work differently depending on the platform. For example, reading a file or saving data might work differently on an \u003cstrong\u003eAndroid\u003c/strong\u003e phone than on an \u003cstrong\u003eiPhone\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"1607\"\u003e2.1 The Core Concept\u003c/h2\u003e\u003cp id=\"2fb7\"\u003eYou can think of \u003cstrong\u003e“\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e/\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e”\u003c/strong\u003e like a \u003cstrong\u003econtract\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b2c4\"\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e: In your shared (common) module, you declare \u003cstrong\u003ewhat\u003c/strong\u003e you need, such as a function or class for storage.\u003c/li\u003e\u003cli id=\"7424\"\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e: In each platform-specific module (Android, iOS, etc.), you provide the \u003cstrong\u003econcrete implementation\u003c/strong\u003e of that function or class.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5f6e\"\u003eThis approach keeps your shared code simple, because it just calls \u003ccode\u003egetBatteryLevel()\u003c/code\u003e or \u003ccode\u003egetPlatformName()\u003c/code\u003e, and it does not care how each different platform might approach the request, as long as it replies with the expected response.\u003c/p\u003e\u003ch2 id=\"c591\"\u003e2.2 How It Works Under the Hood\u003c/h2\u003e\u003cp id=\"eaf6\"\u003eWhen you declare an \u003ccode\u003eexpect\u003c/code\u003e function, class, or property, you\u0026#39;re essentially creating a placeholder that the \u003cstrong\u003eKotlin compiler\u003c/strong\u003e will resolve at build time.\u003c/p\u003e\u003cp id=\"786b\"\u003eEach target platform must provide a matching \u003ccode\u003eactual\u003c/code\u003e implementation, or compilation fails.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4ff7\"\u003e// Common module - the contract\u003cbr/\u003eexpect fun getPlatformName(): String\u003cp\u003e// Android module - the implementation\u003cbr/\u003eactual fun getPlatformName(): String = \u0026#34;Android\u0026#34;\u003c/p\u003e\u003cp\u003e// iOS module - the implementation\u003cbr/\u003eactual fun getPlatformName(): String = \u0026#34;iOS\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c075\"\u003e2.3 Compiler Enforcement\u003c/h2\u003e\u003cp id=\"febc\"\u003eThe beauty of \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e lies in its compile-time safety. Unlike runtime checks or dependency injection alone, the compiler ensures:\u003c/p\u003e\u003col\u003e\u003cli id=\"794e\"\u003eEvery \u003ccode\u003eexpect\u003c/code\u003e has a corresponding \u003ccode\u003eactual\u003c/code\u003e for each target platform\u003c/li\u003e\u003cli id=\"ce8b\"\u003eThe signatures match exactly (name, parameters, return type)\u003c/li\u003e\u003cli id=\"3c8f\"\u003eNo platform is accidentally left without implementation\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"e6ea\"\u003e3. What Can Use Expect/Actual?\u003c/h2\u003e\u003cp id=\"6562\"\u003eThe mechanism supports various declaration types:\u003c/p\u003e\u003cp id=\"84fd\"\u003e\u003cstrong\u003eFunctions\u003c/strong\u003e — Most common use case\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2e46\"\u003eexpect fun getCurrentTimestamp(): Long\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3cb3\"\u003e\u003cstrong\u003eProperties\u003c/strong\u003e — For platform-specific values\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"003c\"\u003eexpect val deviceId: String\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9659\"\u003e\u003cstrong\u003eClasses\u003c/strong\u003e — When entire objects need platform-specific behavior\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c31d\"\u003eexpect class FileManager() {\u003cbr/\u003e    fun readFile(path: String): String\u003cbr/\u003e    fun writeFile(path: String, content: String)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c7e9\"\u003e\u003cstrong\u003eObjects\u003c/strong\u003e — For singleton platform services\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5111\"\u003eexpect object PlatformConfig {\u003cbr/\u003e    val apiEndpoint: String\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8e39\"\u003e\u003cstrong\u003eInterfaces, Enums, and Annotations\u003c/strong\u003e — Less common but supported\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f1b5\"\u003e4. Learn by Example\u003c/h2\u003e\u003ch2 id=\"5641\"\u003e4.1. Step-by-Step Explanation by a Simple Example\u003c/h2\u003e\u003cp id=\"c41b\"\u003eLet’s say we want to use some function that is defined differently for Android and iOS.\u003c/p\u003e\u003col\u003e\u003cli id=\"55bc\"\u003e\u003cstrong\u003eDeclare the Requirement with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e\u003cbr/\u003eIn the \u003cstrong\u003ecommon code\u003c/strong\u003e, you write a declaration without a body.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"8f80\"\u003eexpect fun getCurrentTime(): Long\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b3bd\"\u003eThis line means: \u003cstrong\u003e“I need a function called \u003c/strong\u003e\u003ccode\u003egetCurrentTime()\u003c/code\u003e\u003cstrong\u003e that returns a number (Long), but I will explain how it works later for each platform.\u0026#34;\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"1d87\"\u003e\u003cstrong\u003e2. Provide the Details with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e\u003cbr/\u003eIn the \u003cstrong\u003eplatform-specific code\u003c/strong\u003e, you write the implementation.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cdc5\"\u003e// Android\u003cbr/\u003eactual fun getCurrentTime(): Long = System.currentTimeMillis()\u003c/span\u003e\u003c/pre\u003e\u003cpre\u003e\u003cspan id=\"a78d\"\u003e// iOS\u003cbr/\u003eimport platform.Foundation.NSDate\u003cbr/\u003eimport platform.Foundation.timeIntervalSince1970\u003cp\u003eactual fun getCurrentTime(): Long = (NSDate().timeIntervalSince1970 * 1000).toLong()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a96f\"\u003eEach target platform must provide a matching function to satisfy the \u003ccode\u003eexpect\u003c/code\u003e contract.\u003c/p\u003e\u003cp id=\"ab10\"\u003e\u003cstrong\u003e3. Use the Function in Shared Code:\u003c/strong\u003e\u003cbr/\u003eNow, in your \u003cstrong\u003eshared module\u003c/strong\u003e, you can use the function without worrying about the platform differences:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b920\"\u003eval currentTime = getCurrentTime()\u003cbr/\u003eprintln(\u0026#34;Current Time is: $currentTime\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3129\"\u003e\u003cstrong\u003e4. Compiler Safety:\u003c/strong\u003e\u003cbr/\u003eThe \u003cstrong\u003eKotlin compiler\u003c/strong\u003e checks that every \u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e has a matching \u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e. If one platform is missing the implementation, the code will not compile. This makes the mechanism \u003cstrong\u003esafe and reliable\u003c/strong\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"4c3f\"\u003e\u003cstrong\u003e\u003cem\u003eThat’s it!\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e Now, from any shared Kotlin code, you can call \u003c/em\u003e\u003ccode\u003e\u003cem\u003egetCurrentTime()\u003c/em\u003e\u003c/code\u003e\u003cem\u003e and know that the correct implementation will be used at runtime, depending on whether you are on Android or iOS.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"48fc\"\u003e4.2 A “Hello World” Class Example: Identifying the Platform\u003c/h2\u003e\u003cp id=\"c957\"\u003eAs already mentioned, you are not limited to functions. You can also use \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e on classes, properties, interfaces, and even annotation classes. A classic \u0026#34;hello world\u0026#34; example for Kotlin Multiplatform is to get the name of the operating system.\u003c/p\u003e\u003cp id=\"659b\"\u003eLet’s define a \u003ccode\u003ePlatform\u003c/code\u003e class that holds the name of the current platform.\u003c/p\u003e\u003cp id=\"8ad0\"\u003e1. Define the \u003ccode\u003eexpect\u003c/code\u003e class in the common module:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b5b6\"\u003e// Common module\u003cbr/\u003eexpect class Platform() {\u003cbr/\u003e    val name: String\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8fc1\"\u003eThis declares that we expect a class named \u003ccode\u003ePlatform\u003c/code\u003e to exist on every target. This class must have a property called \u003ccode\u003ename\u003c/code\u003e of type \u003ccode\u003eString\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"9e9c\"\u003e\u003cstrong\u003e2. Provide the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e class for Android:\u003c/strong\u003e On Android, we can use the \u003ccode\u003eBuild\u003c/code\u003e class to get the OS version.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6bab\"\u003e// androidMain module \u003cbr/\u003eimport android.os.Build\u003cp\u003eactual class Platform actual constructor() {\u003cbr/\u003e    actual val name: String = \u0026#34;Android ${Build.VERSION.SDK_INT}\u0026#34;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"df7a\"\u003e\u003cstrong\u003e3. Provide the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eactual\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e class for iOS:\u003c/strong\u003e On iOS, we can use \u003ccode\u003eUIDevice\u003c/code\u003e from the UIKit framework.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4390\"\u003e// iosMain module\u003cbr/\u003eimport platform.UIKit.UIDevice\u003cp\u003eactual class Platform actual constructor() {\u003cbr/\u003e    actual val name: String = UIDevice.currentDevice.systemName() + \u0026#34; \u0026#34; + UIDevice.currentDevice.systemVersion\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cf5c\"\u003eNow, you can instantiate and use this class in your shared code at \u003ccode\u003ecommonMain\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"853a\"\u003e// In your shared code\u003cbr/\u003eval platform = Platform()\u003cbr/\u003eprintln(\u0026#34;Hello from ${platform.name}!\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"883f\"\u003eThis simple example shows how \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e can be used on classes to provide platform-specific data, keeping the shared code that uses it clean and unaware of the underlying platform details.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3800\"\u003e5. Limitations\u003c/h2\u003e\u003ch2 id=\"6525\"\u003e\u003ccode\u003eexpect\u003c/code\u003e Declarations Cannot Contain Code\u003c/h2\u003e\u003cp id=\"1469\"\u003eA common point of confusion for developers is how \u003ccode\u003eexpect\u003c/code\u003e relates to concepts like abstract classes or interfaces with default methods. It’s crucial to understand a fundamental rule: \u003cstrong\u003ean \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eexpect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e declaration is purely a template. It cannot contain any concrete default implementation code or logic in the common module.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"0a05\"\u003eYou cannot mix implemented methods with expected methods in the same \u003ccode\u003eexpect\u003c/code\u003e block.\u003c/p\u003e\u003cp id=\"7fd3\"\u003e\u003cstrong\u003eWhat You CANNOT Do\u003c/strong\u003e The following code will \u003cstrong\u003efail to compile\u003c/strong\u003e because it tries to add shared logic directly inside an \u003ccode\u003eexpect\u003c/code\u003e class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"743c\"\u003e// THIS WILL NOT COMPILE!\u003cbr/\u003eexpect class MixedDeclarations {\u003cbr/\u003e    // This part is a valid expect function\u003cbr/\u003e    expect fun platformSpecificLog()\u003cp\u003e    // This part is NOT valid because it has an implementation body {}\u003cbr/\u003e    fun sharedLog() {\u003cbr/\u003e        println(\u0026#34;This shared logic is not allowed inside an expect class.\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b9f2\"\u003e6. Initializations\u003c/h2\u003e\u003cp id=\"f1fe\"\u003eHere comes a very crucial part of the \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e mechanism that is both practical and powerful.\u003c/p\u003e\u003cp id=\"8b10\"\u003eYou see, many times we need to declare a class that can be used in both Android and iOS, but its dependencies during creation may vary between Android and iOS. For example, in Android you might need to make use of a \u003ccode\u003eContext\u003c/code\u003e which is not applicable in iOS. Or in Ktor, you normally need to define a \u003ccode\u003eDarwin\u003c/code\u003e http client for iOS and \u003ccode\u003eOkHttp\u003c/code\u003e for Android.\u003c/p\u003e\u003ch2 id=\"fde5\"\u003e6.1 Koin\u003c/h2\u003e\u003cblockquote\u003e\u003cp id=\"e127\"\u003e\u003cem\u003eExample by: \u003c/em\u003e\u003ca href=\"https://github.com/ioannisa/CMPMasterDetail/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cem\u003ehttps://github.com/ioannisa/CMPMasterDetail/\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"9b9f\"\u003eKoin is the most recommended way to create Dependencies for Kotlin Multiplatform.\u003c/p\u003e\u003cp id=\"5827\"\u003eTo create dependencies with Koin you need to register Koin Modules for your project. For KMP you are expected to at least have have one such module per platform module, and another for the \u003ccode\u003ecommonMain\u003c/code\u003e module.\u003c/p\u003e\u003cp id=\"7522\"\u003eIn Koin 4.1.0 the \u003ccode\u003eKoinMultiplatformApplication\u003c/code\u003e is introduced as a one-line setup for starting Koin and applying modules in our KMP Project.\u003c/p\u003e\u003cp id=\"2aef\"\u003e\u003cstrong\u003e1. Let’s begin by setting up Koin.\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"47c2\"\u003e// App.kt (your KMP application entry point)\u003cbr/\u003efun App() {\u003cbr/\u003e    KoinMultiplatformApplication(\u003cbr/\u003e        config = KoinConfiguration {\u003cbr/\u003e            modules(sharedModule, platformModule)\u003cbr/\u003e        }\u003cbr/\u003e    ) {\u003cp\u003e     MyKMPSuperAppTheme {\u003cbr/\u003e      // ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7a3a\"\u003eHere we are exposing two modules, the \u003ccode\u003esharedModule\u003c/code\u003e which will contain all common dependency initializations for all platforms and the \u003ccode\u003eplatformModule\u003c/code\u003e which as you can guess is using the \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e mechanism to define different dependency initializations per platform.\u003c/p\u003e\u003cp id=\"e13e\"\u003e\u003cstrong\u003e2. The \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecommonMain\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Koin Module Code\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3c89\"\u003eLet’s hit a scenario where we have an http-client with Ktor and a Movies Database factory for Room.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"46c7\"\u003e// commonMain/di/Modules.kt\u003cp\u003eexpect val platformModule: Module\u003c/p\u003e\u003cp\u003eval sharedModule = module {\u003c/p\u003e\u003cp\u003e    single\u0026lt;MoviesHttpClient\u0026gt; {\u003cbr/\u003e        MoviesHttpClient(\u003cbr/\u003e            engine = get(),\u003cbr/\u003e            baseUrl = BuildConfig.BASE_URL_MOVIES,\u003cbr/\u003e            apiKey = BuildConfig.API_KEY_MOVIES,\u003cbr/\u003e            logging = true\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    single {\u003cbr/\u003e        get\u0026lt;MoviesDatabaseFactory\u0026gt;().create()\u003cbr/\u003e            .setDriver(BundledSQLiteDriver())\u003cbr/\u003e            .build() // .build() returns MoviesDatabase instance\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    single { get\u0026lt;MoviesDatabase\u0026gt;().moviesDao }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"54e5\"\u003eNotice some interesting facts here.\u003c/p\u003e\u003col\u003e\u003cli id=\"7a89\"\u003eFirst, our \u003ccode\u003eModules.kt\u003c/code\u003e file at \u003ccode\u003ecommonMain\u003c/code\u003e defines its a Koin \u003ccode\u003esharedModule\u003c/code\u003e together with an \u003ccode\u003eexpect\u003c/code\u003e \u003ccode\u003eplatformModule\u003c/code\u003e that is expected to define separate Dependency Injection instances for each platform.\u003c/li\u003e\u003cli id=\"c83f\"\u003eNote we are expecting an \u003ccode\u003eHttpClientEngine\u003c/code\u003e at the \u003ccode\u003eengine\u003c/code\u003e parameter for our network setup. Seems like we are going to define that differently in our platforms. Wow, we are going to define part of the dependency for network per platform, while the rest of it in \u003ccode\u003ecommonMain\u003c/code\u003e? Just wow!\u003c/li\u003e\u003cli id=\"6ead\"\u003eOur \u003ccode\u003eMoviesDatabase\u003c/code\u003e instance utilizes the creation of a \u003ccode\u003eMoviesDatabaseFactory\u003c/code\u003e object, and while just creating it here, we will interestingly see it is defined differently for iOS and Android.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"1374\"\u003e\u003cstrong\u003e3. The androidMain Koin Module\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"250e\"\u003eHere we witness the \u003ccode\u003eactual\u003c/code\u003e implementation of the \u003ccode\u003eplatformModule\u003c/code\u003e for Android!\u003c/p\u003e\u003cp id=\"521d\"\u003eYes, everything here is customized just for object dependencies provided for the Android platform.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c79e\"\u003eactual val platformModule: Module\u003cbr/\u003e    get() = module {\u003cbr/\u003e        single\u0026lt;HttpClientEngine\u0026gt; {\u003cbr/\u003e            OkHttp.create()\u003cbr/\u003e        }\u003cp\u003e        single\u0026lt;Vault\u0026gt; {\u003cbr/\u003e            Vault(androidApplication())\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        single {\u003cbr/\u003e            MoviesDatabaseFactory(androidApplication())\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"43bf\"\u003eOk, here we see\u003c/p\u003e\u003col\u003e\u003cli id=\"0728\"\u003ethat the \u003ccode\u003eengine\u003c/code\u003e that the \u003ccode\u003ecommomMain\u003c/code\u003e Koin Module required gets initialized here and we pass an \u003ccode\u003eOkHttp\u003c/code\u003e as \u003ccode\u003eHttpClientEngine\u003c/code\u003e that works fine with Android!\u003c/li\u003e\u003cli id=\"1ed8\"\u003eWe also see \u003ccode\u003eVault\u003c/code\u003e that didn’t exist at \u003ccode\u003ecommonModule\u003c/code\u003e at the first place, initialized passing a \u003ccode\u003eContext\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"ee17\"\u003eAlso, we see that our \u003ccode\u003eMoviesDatabaseFactory\u003c/code\u003e needed for \u003ccode\u003eMoviesDatabase\u003c/code\u003e creation gets initialized here, because in the case of Android there is also need of \u003ccode\u003eContext\u003c/code\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"5658\"\u003e\u003cstrong\u003e4. The iosMain Koin Module\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"098e\"\u003eNow is the time for the \u003ccode\u003eactual\u003c/code\u003e implementation of the \u003ccode\u003eplatformModule\u003c/code\u003e for iOS! So here we have object creations only for builds targeting iOS devices.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"96c7\"\u003eactual val platformModule: Module\u003cbr/\u003e    get() = module {\u003cp\u003e        single\u0026lt;HttpClientEngine\u0026gt; {\u003cbr/\u003e            Darwin.create()\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        single {\u003cbr/\u003e            MoviesDatabaseFactory()\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        single\u0026lt;Vault\u0026gt; {\u003cbr/\u003e            Vault()\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        factory\u0026lt;SavedStateHandle\u0026gt; {\u003cbr/\u003e            SavedStateHandle()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3e87\"\u003eHere we see even more interesting facts about the way our \u003ccode\u003eactual\u003c/code\u003e mechanism works for providing specialized object instances for iOS builds.\u003c/p\u003e\u003col\u003e\u003cli id=\"0770\"\u003eThis time the \u003ccode\u003eHttpClientEngine\u003c/code\u003e is \u003ccode\u003eDarwin\u003c/code\u003e that can be used for iOS, rather than the \u003ccode\u003eOkHttp\u003c/code\u003e that is Java-based which is being used by Android.\u003c/li\u003e\u003cli id=\"1b7f\"\u003eWe note that we initialized the \u003ccode\u003eMoviesDatabaseFactory\u003c/code\u003e and \u003ccode\u003eVault\u003c/code\u003e to their equivalent classes definitions in \u003ccode\u003eiosMain\u003c/code\u003e that don’t require passing \u003ccode\u003eContext\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c08c\"\u003eWe create a \u003ccode\u003eSavedStateHandle()\u003c/code\u003e wrapper instance to pass a specialized version of the \u003ccode\u003eSavedStateHandle\u003c/code\u003e so we don’t get crashes on iOS which doesn’t handle app-death similarly to Android, while maintaining parameter passing to the \u003ccode\u003eViewModel\u003c/code\u003e via our navigation component.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"58f4\"\u003e\u003cstrong\u003e7. TL;DR Explanation of Expect Actual\u003c/strong\u003e\u003c/h2\u003e\u003ch2 id=\"30c7\"\u003e\u003cstrong\u003eHow Expect Actual Works\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"e207\"\u003e\u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e is a feature built into the Kotlin language to handle platform differences in KMM. Here’s the process step by step:\u003c/p\u003e\u003col\u003e\u003cli id=\"762e\"\u003e\u003cstrong\u003eExpect Declaration\u003c/strong\u003e: In the common module, you use expect to define a function, property, or class without writing its implementation. This tells the Kotlin compiler, “This will exist, but the platforms will fill in the details.”\u003c/li\u003e\u003cli id=\"0225\"\u003e\u003cstrong\u003eActual Declaration\u003c/strong\u003e: In each platform-specific module (like Android or iOS), you use actual to provide the real code for that declaration. The actual version must match the \u003ccode\u003eexpect\u003c/code\u003e version exactly — same name, same parameters, same return type.\u003c/li\u003e\u003cli id=\"35c3\"\u003e\u003cstrong\u003eCompiler Safety\u003c/strong\u003e: When you build your project, the Kotlin compiler checks that every \u003ccode\u003eexpect\u003c/code\u003e in the common module has a matching actual in every platform module. If one is missing (say, you forgot the iOS version), the compiler stops the build with an error, preventing broken apps.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"7b79\"\u003eThis system ensures that your shared code can depend on certain features being available, while each platform handles them in its own way.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"ac93\"\u003e8. Comparing “Expect Actual” and Interfaces\u003c/h2\u003e\u003cp id=\"d568\"\u003eBoth \u003cstrong\u003e“expect actual”\u003c/strong\u003e and \u003cstrong\u003einterfaces\u003c/strong\u003e allow you to define a \u003cstrong\u003econtract\u003c/strong\u003e for your code. However, they work in different ways.\u003c/p\u003e\u003ch2 id=\"cae5\"\u003e8.1. Interfaces\u003c/h2\u003e\u003cp id=\"24f7\"\u003eWith \u003cstrong\u003einterfaces\u003c/strong\u003e, you define functions in a \u003cstrong\u003ecommon module\u003c/strong\u003e, and then each platform must provide its own version. However, interfaces have some differences:\u003c/p\u003e\u003cul\u003e\u003cli id=\"be6c\"\u003e\u003cstrong\u003eDefault Implementations:\u003c/strong\u003e Interfaces in Kotlin can have default implementations. This means you can write some code in the interface itself.\u003c/li\u003e\u003cli id=\"ae7e\"\u003e\u003cstrong\u003eExtra Setup Needed:\u003c/strong\u003e Using interfaces often requires additional work like setting up factories or dependency injection. This can increase the amount of code you need to write.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e994\"\u003e8.2. Advantages of “Expect Actual”\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1373\"\u003e\u003cstrong\u003eLess Boilerplate:\u003c/strong\u003e \u003cstrong\u003e“Expect actual”\u003c/strong\u003e is direct. You declare your need in the common module and then simply provide the details on each platform without extra setup.\u003c/li\u003e\u003cli id=\"1357\"\u003e\u003cstrong\u003eCompiler Checks:\u003c/strong\u003e The \u003cstrong\u003eKotlin compiler\u003c/strong\u003e makes sure every \u003cstrong\u003eexpect\u003c/strong\u003e has a matching \u003cstrong\u003eactual\u003c/strong\u003e. If you forget one, you will see an error at compile time rather than a runtime crash.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2fe5\"\u003e9. Best Practices and Limitations\u003c/h2\u003e\u003ch2 id=\"b1b5\"\u003e9.1. Best Practices\u003c/h2\u003e\u003cp id=\"92f1\"\u003eTo make the most out of the \u003cstrong\u003e“expect actual”\u003c/strong\u003e mechanism, follow these guidelines:\u003c/p\u003e\u003cul\u003e\u003cli id=\"ddcf\"\u003e\u003cstrong\u003eKeep Expect Declarations Small:\u003c/strong\u003e Only declare what really needs to be different between platforms. This keeps your \u003cstrong\u003eshared module clean\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"6c36\"\u003e\u003cstrong\u003eUse Clear, Descriptive Names:\u003c/strong\u003e Use names like \u003ccode\u003e\u003cstrong\u003egetPlatformName()\u003c/strong\u003e\u003c/code\u003e or \u003ccode\u003e\u003cstrong\u003ereadUserData()\u003c/strong\u003e\u003c/code\u003e so that it is obvious what the function does.\u003c/li\u003e\u003cli id=\"328e\"\u003e\u003cstrong\u003eWrite Thorough Tests:\u003c/strong\u003e Make sure that the actual implementations on each platform work correctly by writing \u003cstrong\u003eunit tests\u003c/strong\u003e for each platform.\u003c/li\u003e\u003cli id=\"009c\"\u003e\u003cstrong\u003eDocument Your Code:\u003c/strong\u003e Explain in comments or documentation why you are using \u003cstrong\u003e“expect actual”\u003c/strong\u003e and what each implementation is supposed to do. This is very helpful for teams and future maintenance.\u003c/li\u003e\u003cli id=\"4f23\"\u003e\u003cstrong\u003eConsider Interfaces for Shared Logic:\u003c/strong\u003e When you need default behavior or more flexibility, consider using \u003cstrong\u003einterfaces\u003c/strong\u003e instead of \u003cstrong\u003e“expect actual”\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"335f\"\u003e9.2. Limitations to Be Aware Of\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d5ac\"\u003e\u003cstrong\u003eNo Default Code in Expect:\u003c/strong\u003e Since you \u003cstrong\u003ecannot provide a default implementation\u003c/strong\u003e in the common module, you must duplicate some logic if it applies to all platforms.\u003c/li\u003e\u003cli id=\"3201\"\u003e\u003cstrong\u003eMaintenance Overhead:\u003c/strong\u003e In large projects with many platforms, you may need to write many \u003cstrong\u003eactual implementations\u003c/strong\u003e. Good planning and documentation are essential.\u003c/li\u003e\u003cli id=\"5929\"\u003e\u003cstrong\u003eNot Suitable for UI Code:\u003c/strong\u003e The \u003cstrong\u003e“expect actual”\u003c/strong\u003e mechanism works best for \u003cstrong\u003enon-UI logic\u003c/strong\u003e. Since each platform has its own design language and framework, user interface code often remains platform-specific.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5708\"\u003e10. Conclusion\u003c/h2\u003e\u003cp id=\"343b\"\u003eThe \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e mechanism is central to Kotlin Multiplatform. It provides a \u003cstrong\u003edirect\u003c/strong\u003e, \u003cstrong\u003ecompiler-enforced\u003c/strong\u003e way to manage platform-specific implementations, making cross-platform code more \u003cstrong\u003ereliable\u003c/strong\u003e and \u003cstrong\u003emaintainable\u003c/strong\u003e. While \u003cstrong\u003einterfaces\u003c/strong\u003e offer flexibility with default implementations, \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e shines with its simplicity and compile-time safety for direct platform access.\u003c/p\u003e\u003cp id=\"d72e\"\u003eWe’ve explored:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3d3b\"\u003eThe fundamental \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e contract and its compile-time guarantees.\u003c/li\u003e\u003cli id=\"da09\"\u003eSimple, practical examples for functions, classes, and properties.\u003c/li\u003e\u003cli id=\"aaab\"\u003eThe key limitation that \u003ccode\u003eexpect\u003c/code\u003e declarations cannot contain implementation code.\u003c/li\u003e\u003cli id=\"940c\"\u003eA real-world pattern for dependency injection using an \u003ccode\u003eexpect val\u003c/code\u003e for Koin modules to provide platform-specific dependencies like Ktor\u0026#39;s \u003ccode\u003eHttpClientEngine\u003c/code\u003e and database factories.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1d08\"\u003eBy understanding these patterns and applying the \u003cstrong\u003ebest practices\u003c/strong\u003e outlined, you can leverage \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e to build efficient, scalable, and maintainable cross-platform applications, maximizing code sharing without sacrificing access to native capabilities.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0a31\"\u003e\u003cstrong\u003eFurther Reading\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a7c5\"\u003e\u003ca href=\"https://kotlinlang.org/docs/multiplatform-expect-actual.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eExpected and Actual Declarations — Kotlin Documentation\u003c/a\u003e\u003c/li\u003e\u003cli id=\"536d\"\u003e\u003ca href=\"https://stackoverflow.com/questions/77581421/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform expect/actual on Interface — Stack Overflow\u003c/a\u003e\u003c/li\u003e\u003cli id=\"a923\"\u003e\u003ca href=\"https://insert-koin.io/docs/reference/koin-mp/kmp/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKotlin Multiplatform Dependency Injection — Koin\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-06-30T09:03:33.694Z",
  "modifiedTime": null
}
