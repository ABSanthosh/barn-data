{
  "id": "e4a28663-27ea-46d7-a647-81592d740d83",
  "title": "Building an Open Source, Carefree Android Disk Cache",
  "link": "https://instagram-engineering.com/building-an-open-source-carefree-android-disk-cache-af57aa9b7c7?source=rss----37dc2a3034f2--android",
  "description": "",
  "author": "Instagram Engineering",
  "published": "Tue, 21 Jun 2016 16:27:39 GMT",
  "source": "https://instagram-engineering.com/feed/tagged/android",
  "categories": [
    "open-source",
    "tech",
    "android"
  ],
  "byline": "Instagram Engineering",
  "length": 6628,
  "excerpt": "Caching various files on disk has always been an integral part of many mobile apps. At Instagram, we use caching to store and recover images, videos, and text files. As a media-heavy application, the…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Caching various files on disk has always been an integral part of many mobile apps. At Instagram, we use caching to store and recover images, videos, and text files. As a media-heavy application, the Instagram Android app requires a lightweight but stable disk cache system. When we first built the app, we started with the open source DiskLruCache library. It served us well until we found one major issue with the cache’s design: the cache code’s exception handling logic is cumbersome and prone to developer error.For example, the following code snippet shows how to properly handle a simple write-to-disk operation using DiskLruCache:// Writing to Cache before using IgDiskCacheif (mDiskLruCache != null) { final String key = hashKeyForDisk(data); DiskLruCache.Editor editor = null; OutputStream out = null; try { editor = mDiskLruCache.edit(key); if (editor != null) { out = editor.newOutputStream(DISK_CACHE_INDEX); writeFileToOutputStream(out); out.close(); editor.commit(); } } catch (IOException e) { if (out != null) { try { out.close(); } catch (IOException e) { Log.d(LOG_TAG, \"can't close output stream\", e); } } if (editor != null) { try { // This is an Instagram modification to DiskLruCache. // Making sure the cache will be in a good state even if an IOException is thrown. editor.removeEntryAndAbort(); } catch (IOException e) { Log.d(LOG_TAG, \"can't abort editor\", e); } } }} else { // Handle the disk cache not available case.}As you can see, because the DiskLruCache doesn’t support stub instances, when the file storage is not available (either the cache directory not accessible, or there is not enough storage space left), we have no choice but to let the mDiskLruCache fallback to NULL. This seemingly harmless fallback requires all engineers to explicitly check that the cache is not equal to NULL before they ever want to use it. After confirming that the cache is available, the disk caching code also needs to go two extra steps to get to the OutputStream: retrieving the Editor object from the cache entry using the cache key, and then getting the OutputStream from the Editor. Both of these steps might throw IOExceptions, and the retrieving Editor from disk cache could also return NULL. If any of these failed cases ever happens, the engineers need to figure out on their own how to gracefully handle the crash, properly close all the streams/editors/snapshots, and make sure the partial files won’t mess up the cache.If you think this is already complicated, just imagine how complicated it could get when handling two editors in the same code block, or implementing a read-process-write case inside a single method. Missing any one of those NULL checking or mishandling any of the IOExceptions will result in many crashes daily on client devices. Over time, as our app becomes more complex and more engineers joined and worked on the same code base, the disk caching code became extremely flaky and hard to maintain. For over a year, cache-related NPEs (Null Pointer Exception) and IOExceptions topped our crash list. After doing several small patches, we soon figured out these small fixes won’t solve the problem. The fix made the code look even worse, and new crashes kept coming.To fix the issue completely, we knew we had to rethink what a disk cache is, and to redesign the disk cache to make the whole thing easier to use and maintain. A cache, by definition, can always tell the developer “I don’t have this item.” We use this principle to simplify the case that the cache can’t even be opened, or that there are disk errors. We simply report that we don’t have the item, and let writes fail silently. And for cases like IOExceptions, we ideally shouldn’t let the developers guess what’s happening inside the cache, and handle all the possible scenarios. The cache should be smart enough to handle most of the failed cases itself, and guarantee that no incomplete file will be cached and that all cache entries get closed properly.When we decided to build IGDiskCache, we decided to focus on four main changes:1. Simplify cache initialization and null-checking: Support stub cache instance when the disk cache is not available or accessible, so that we don’t need to check the mDiskLruCache != null every time we want to use it.Handle the IOExceptions smartly, as most of the exception handling logic (e.g. close cache entry, close input/output stream, discard the incomplete file) is reusable and there is no need to make the programmers handle all these edge cases themselves.Flatten the cache, and remove the unnecessary level of Editors/Snapshots. This makes the cache entry’s commit/abort/close logic much cleaner and easier to read.Prevent engineers from mis-using the cache. This includes requiring NULL checking for the cache entries after retrieving them from the cache; and ensuring all the time-consuming tasks (like cache initialization and close) to be executed only on non-UI threads.From initial design to implementation, it took us about a month to build the initial version of the IgDiskCache, and a few more weeks to update all the call sites and test the module thoroughly. After we launched it in production, we were able to dramatically reduce the number of crashes in the app. Also, because of the built-in enhanced checking conditions, IgDiskCache was able to help us identify quite a few race conditions in our apps which were extremely hard to detect otherwise. The UI thread checking also prevents engineers from executing inefficient disk IO operations on the main thread. The code also looks much simpler, and easier to reason about.// Writing to cache using IgDiskCacheOptionalStream \u003cEditorOutputStream\u003e output = mIgDiskCache.edit(key);if (output.isPresent()) { EditorOutputStream outputStream = output.get(); try { writeFileToOutputStream(outputStream); outputStream.commit(); } catch (IOException e) { outputStream.abort(); }}Our story with IgDiskCache is a good example of how we tackle app reliability issues, and make our code cleaner and easier to maintain. We hope you’ll find it useful too!We recently moved our mobile infrastructure engineering teams (iOS and Android) to New York City. If this blog post got you excited about what we’re doing, we’re hiring — check out our careers page.Jimmy (He) Zhang is a software engineer at Instagram.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@InstagramEng?source=post_page-----af57aa9b7c7--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*8x_1IP3b75o5u9M4LgFBig.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page-----af57aa9b7c7--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"54be\"\u003eCaching various files on disk has always been an integral part of many mobile apps. At Instagram, we use caching to store and recover images, videos, and text files. As a media-heavy application, the Instagram Android app requires a lightweight but stable disk cache system. When we first built the app, we started with the open source DiskLruCache library. It served us well until we found one major issue with the cache’s design: the cache code’s exception handling logic is cumbersome and prone to developer error.\u003c/p\u003e\u003cp id=\"17c3\"\u003eFor example, the following code snippet shows how to properly handle a simple write-to-disk operation using DiskLruCache:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6367\"\u003e// Writing to Cache before using IgDiskCache\u003cbr/\u003eif (mDiskLruCache != null) {\u003cbr/\u003e    final String key = hashKeyForDisk(data);\u003cbr/\u003e    DiskLruCache.Editor editor = null;\u003cbr/\u003e    OutputStream out = null;\u003cbr/\u003e    try {\u003cbr/\u003e        editor = mDiskLruCache.edit(key);\u003cbr/\u003e        if (editor != null) {\u003cbr/\u003e            out = editor.newOutputStream(DISK_CACHE_INDEX);\u003cbr/\u003e            writeFileToOutputStream(out);\u003cbr/\u003e            out.close();\u003cbr/\u003e            editor.commit();\u003cbr/\u003e        }\u003cbr/\u003e    } catch (IOException e) {\u003cbr/\u003e        if (out != null) {\u003cbr/\u003e            try {\u003cbr/\u003e                out.close();\u003cbr/\u003e            } catch (IOException e) {\u003cbr/\u003e                Log.d(LOG_TAG, \u0026#34;can\u0026#39;t close output stream\u0026#34;, e);\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        if (editor != null) {\u003cbr/\u003e            try {\u003cbr/\u003e                // This is an Instagram modification to DiskLruCache. \u003cbr/\u003e                // Making sure the cache will be in a good state even if an IOException is thrown.\u003cbr/\u003e                  editor.removeEntryAndAbort();\u003cbr/\u003e            } catch (IOException e) {\u003cbr/\u003e                Log.d(LOG_TAG, \u0026#34;can\u0026#39;t abort editor\u0026#34;, e);\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e} else {\u003cbr/\u003e    // Handle the disk cache not available case.\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ed03\"\u003eAs you can see, because the DiskLruCache doesn’t support stub instances, when the file storage is not available (either the cache directory not accessible, or there is not enough storage space left), we have no choice but to let the mDiskLruCache fallback to NULL. This seemingly harmless fallback requires all engineers to explicitly check that the cache is not equal to NULL before they ever want to use it. After confirming that the cache is available, the disk caching code also needs to go two extra steps to get to the OutputStream: retrieving the Editor object from the cache entry using the cache key, and then getting the OutputStream from the Editor. Both of these steps might throw IOExceptions, and the retrieving Editor from disk cache could also return NULL. If any of these failed cases ever happens, the engineers need to figure out on their own how to gracefully handle the crash, properly close all the streams/editors/snapshots, and make sure the partial files won’t mess up the cache.\u003c/p\u003e\u003cp id=\"e0c2\"\u003eIf you think this is already complicated, just imagine how complicated it could get when handling two editors in the same code block, or implementing a read-process-write case inside a single method. Missing any one of those NULL checking or mishandling any of the IOExceptions will result in many crashes daily on client devices. Over time, as our app becomes more complex and more engineers joined and worked on the same code base, the disk caching code became extremely flaky and hard to maintain. For over a year, cache-related NPEs (Null Pointer Exception) and IOExceptions topped our crash list. After doing several small patches, we soon figured out these small fixes won’t solve the problem. The fix made the code look even worse, and new crashes kept coming.\u003c/p\u003e\u003cp id=\"3b64\"\u003eTo fix the issue completely, we knew we had to rethink what a disk cache is, and to redesign the disk cache to make the whole thing easier to use and maintain. A cache, by definition, can always tell the developer “I don’t have this item.” We use this principle to simplify the case that the cache can’t even be opened, or that there are disk errors. We simply report that we don’t have the item, and let writes fail silently. And for cases like IOExceptions, we ideally shouldn’t let the developers guess what’s happening inside the cache, and handle all the possible scenarios. The cache should be smart enough to handle most of the failed cases itself, and guarantee that no incomplete file will be cached and that all cache entries get closed properly.\u003c/p\u003e\u003cp id=\"5ec2\"\u003eWhen we decided to build \u003ca href=\"https://our.intern.facebook.com/l.php?d=AQHOAKqZwd-fJ1fWQZjYRgMpMcENDV5svngF9-KD9wKO1n-h2eglwFwTVgw\u0026amp;u=https%3A%2F%2Fgithub.com%2FInstagram%2Fig-disk-cache\u0026amp;h=2AQFUFiK_\u0026amp;s=1\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eIGDiskCache\u003c/strong\u003e\u003c/a\u003e, we decided to focus on four main changes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3bdb\"\u003e1. Simplify cache initialization and null-checking: Support stub cache instance when the disk cache is not available or accessible, so that we don’t need to check the mDiskLruCache != null every time we want to use it.\u003c/li\u003e\u003cli id=\"76de\"\u003eHandle the IOExceptions smartly, as most of the exception handling logic (e.g. close cache entry, close input/output stream, discard the incomplete file) is reusable and there is no need to make the programmers handle all these edge cases themselves.\u003c/li\u003e\u003cli id=\"5292\"\u003eFlatten the cache, and remove the unnecessary level of Editors/Snapshots. This makes the cache entry’s commit/abort/close logic much cleaner and easier to read.\u003c/li\u003e\u003cli id=\"6ece\"\u003ePrevent engineers from mis-using the cache. This includes requiring NULL checking for the cache entries after retrieving them from the cache; and ensuring all the time-consuming tasks (like cache initialization and close) to be executed only on non-UI threads.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"66d1\"\u003eFrom initial design to implementation, it took us about a month to build the initial version of the IgDiskCache, and a few more weeks to update all the call sites and test the module thoroughly. After we launched it in production, we were able to dramatically reduce the number of crashes in the app. Also, because of the built-in enhanced checking conditions, IgDiskCache was able to help us identify quite a few race conditions in our apps which were extremely hard to detect otherwise. The UI thread checking also prevents engineers from executing inefficient disk IO operations on the main thread. The code also looks much simpler, and easier to reason about.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8116\"\u003e// Writing to cache using IgDiskCache\u003cbr/\u003eOptionalStream \u0026lt;EditorOutputStream\u0026gt; output = mIgDiskCache.edit(key);\u003cbr/\u003eif (output.isPresent()) {\u003cbr/\u003e    EditorOutputStream outputStream = output.get();\u003cbr/\u003e    try {\u003cbr/\u003e        writeFileToOutputStream(outputStream);\u003cbr/\u003e        outputStream.commit();\u003cbr/\u003e    } catch (IOException e) {\u003cbr/\u003e        outputStream.abort();\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bde0\"\u003eOur story with IgDiskCache is a good example of how we tackle app reliability issues, and make our code cleaner and easier to maintain. We hope you’ll find it useful too!\u003c/p\u003e\u003cp id=\"53dd\"\u003e\u003cem\u003eWe recently moved our mobile infrastructure engineering teams (iOS and Android) to New York City. If this blog post got you excited about what we’re doing, we’re hiring — check out our \u003c/em\u003e\u003ca href=\"https://our.intern.facebook.com/l.php?d=AQHtPpH_2FKp-3oVD3c57N8Xi13ihf6dqJh6FoNsgrYMTVn7YWz-VEHqIRY\u0026amp;u=https%3A%2F%2Fwww.instagram.com%2Fabout%2Fjobs%2F\u0026amp;h=8AQFXdAKr\u0026amp;s=1\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003e\u003cem\u003ecareers page\u003c/em\u003e\u003c/strong\u003e\u003c/a\u003e\u003cem\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"97dc\"\u003e\u003cem\u003eJimmy (He) Zhang is a software engineer at Instagram.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2016-06-21T16:27:29.052Z",
  "modifiedTime": null
}
