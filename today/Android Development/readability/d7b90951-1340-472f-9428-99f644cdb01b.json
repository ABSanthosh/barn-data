{
  "id": "d7b90951-1340-472f-9428-99f644cdb01b",
  "title": "Mastering LinkAnnotation: The Modern Approach to Text Links",
  "link": "https://proandroiddev.com/mastering-linkannotation-the-modern-approach-to-text-links-26fbde09b158?source=rss----c72404660798---4",
  "description": "",
  "author": "Nav Singh",
  "published": "Fri, 02 May 2025 05:54:40 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "annotations",
    "android-app-development",
    "androiddev",
    "url"
  ],
  "byline": "Nav Singh",
  "length": 7396,
  "excerpt": "In this article, we will learn how to migrate ClickableText to a LinkAnnotation-based solution for text that contains clickable text [URL, custom-actions, etc.] I was working on a ticket to fix the‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In this article, we will learn how to migrate ClickableText to a LinkAnnotation-based solution for text that contains clickable text [URL, custom-actions, etc.]I was working on a ticket to fix the issue where the URL link opens in an external browser instead of within the app (Chrome Custom Tab Intent or Custom WebView).When I opened the relevant code, it looked like this üëá@Composablefun ClickableTextEx() { val uriHandler = LocalUriHandler.current val linkLabel = \"Link label....\" val link = \"https://......\" val annotatedDescription = buildAnnotatedString { withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onBackground)) { append(\"Please read the ... here\") } pushStringAnnotation(tag = \"Policy\", annotation = link) withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.primary)) { append(linkLabel) } pop() } ClickableText( text = annotatedDescription, onClick = { offset -\u003e annotatedDescription.getStringAnnotations( tag = \"Policy\", start = offset, end = offset ).firstOrNull()?.let { stringAnnotation -\u003e uriHandler.openUri(stringAnnotation.item) } } )}You might have already found the issue üêõ why the link is opening in an external browser üï∏Ô∏èuriHandler.openUri(stringAnnotation.item)It's because we have used the Compose‚Äôs UriHandler, which fires the following intent:AndroidUriHandler‚Äôs code can be found hereclass AndroidUriHandler(private val context: Context) : UriHandler { /** * Open given URL in browser * * @throws IllegalArgumentException when given [uri] is invalid and/or can't be handled by the * system */ override fun openUri(uri: String) { try { context.startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(uri))) } catch (e: ActivityNotFoundException) { throw IllegalArgumentException(\"Can't open $uri.\", e) } }}So at this point, we have two optionsFix the Uri handling code ‚úÖ and leave the deprecated API as it is.ORFix the code and replace the deprecated API with the recommended one ‚úÖ ‚≠êÔ∏èI picked the 2nd, so let's see how we can migrate this code to the new API LinkAnnotation and handle the URI in a way that checks if Chrome custom tabs are supported, then opens the URI in one; otherwise, fire the intent with the necessary action and data.LinkAnnotation classIt's an abstract class with two abstract propertiesstyleslinkInteractionListenerBy default, we have two implementations available for usUrl: It has three properties: 2 from LinkedAnnotation + 1 its ownClickable: It has three properties: 2 from LinkedAnnotation + 1 its ownAs per our use case, I decided to use the Url class because in our case, we have Text, which includes the HTTP URLs.@Composablefun LinkAnnotationExample() { Text(buildAnnotatedString { append(\"Some other text \") withLink( LinkAnnotation.Url( // Added the sample Url here. url = \"https://developer.android.com/jetpack/compose\", styles = TextLinkStyles( style = SpanStyle(color = Color.Blue), hoveredStyle = SpanStyle( color = Color.Red, textDecoration = TextDecoration.Underline ), focusedStyle = SpanStyle( color = Color.Red, textDecoration = TextDecoration.LineThrough ), pressedStyle = SpanStyle( color = Color.Green, textDecoration = TextDecoration.LineThrough ), ) ) ) { append(\"Jetpack Compose\") } })}As you can see üëÜ, it's a better approach than ClickableText. Here, we don‚Äôt need to worry about the offset, get annotations, and then get the Uri, and proceed from there.We used the withLink extension function to add the link to AnnotatedString‚ÑπÔ∏è If we don‚Äôt pass the LinkInteractionListener to the Url class then internally Text uses the UriHandler to open the link, which under the hood fires the intent for us.Here is the code for the handleLink function from TextLinkScope classhttps://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/text/TextLinkScope.kt;l=285?q=TextLinkScope private fun handleLink(link: LinkAnnotation, uriHandler: UriHandler) { when (link) { is LinkAnnotation.Url -\u003e link.linkInteractionListener?.onClick(link) ?: try { uriHandler.openUri(link.url) } catch (_: IllegalArgumentException) { // .. } is LinkAnnotation.Clickable -\u003e // ... } }So if you want to handle the URL opening within your application or want to listen to the link interactions, for example, for analytics purposes, then you can provide your own linkInteractionListener@Composablefun LinkAnnotationExample() { Text(buildAnnotatedString { append(\"Build better apps faster with \") withLink( LinkAnnotation.Url( url = \"https://developer.android.com/jetpack/compose\" ){ linkAnnotation -\u003e val url = (linkAnnotation as LinkAnnotation.Url).url Log.d(\"TAG\", \"LinkAnnotationExample: $url\") } ) { append(\"Jetpack Compose\") } })}Chrome custom tab support implementationAdd a query tag to the manifest file\u003cqueries\u003e \u003cintent\u003e \u003caction android:name= \"android.support.customtabs.action.CustomTabsService\" /\u003e \u003c/intent\u003e\u003c/queries\u003eAdd code to check if custom tabs are supported or notprivate const val ACTION_CUSTOM_TABS_CONNECTION = \"android.support.customtabs.action.CustomTabsService\"private const val CHROME_PACKAGE = \"com.android.chrome\"fun isChromeCustomTabsSupported(context: Context): Boolean { val serviceIntent = Intent(ACTION_CUSTOM_TABS_CONNECTION).apply { setPackage(CHROME_PACKAGE) } val resolveInfo: MutableList\u003cResolveInfo?\u003e? = context.packageManager.queryIntentServices(serviceIntent, 0) return resolveInfo?.filterNotNull()?.isNotEmpty() == true}Add an extension function on Uri to open in a custom tab or a browserfun Uri.openInBrowser(context: Context) { try { when (isChromeCustomTabsSupported(context)) { true -\u003e { val builder: CustomTabsIntent.Builder = CustomTabsIntent.Builder() val customTabsIntent: CustomTabsIntent = builder.build() customTabsIntent.launchUrl(context, this) } false -\u003e { val browserIntent = Intent(Intent.ACTION_VIEW, this).apply { putExtra(Browser.EXTRA_APPLICATION_ID, context.packageName) } context.startActivity(browserIntent) } } } catch (activityNotFoundException: ActivityNotFoundException) { Log.e(\"ChromeCustomTab\", activityNotFoundException.message.toString()) } catch (exception: Exception) { Log.e(\"ChromeCustomTab\", exception.message.toString()) }}References",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*d61HU4uK6jocUbdcsE8rhQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://navczydev.medium.com/?source=post_page---byline--26fbde09b158---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Nav Singh\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*fgXFMgSUVAlGSdmMkx9TYw.png\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"0b5b\"\u003eIn this article, we will learn how to migrate \u003ccode\u003e\u003cstrong\u003eClickableText\u003c/strong\u003e\u003c/code\u003e to a \u003ccode\u003e\u003cstrong\u003eLinkAnnotation\u003c/strong\u003e\u003c/code\u003e-based solution for text that contains clickable text [URL, custom-actions, etc.]\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"c5f5\"\u003eI was working on a ticket to fix the issue where the URL link opens in an external browser instead of within the app (Chrome Custom Tab Intent or Custom WebView).\u003c/p\u003e\u003cp id=\"4053\"\u003eWhen I opened the relevant code, it looked like this üëá\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"975b\"\u003e@Composable\u003cbr/\u003efun ClickableTextEx() {\u003cbr/\u003e    val uriHandler = LocalUriHandler.current\u003cbr/\u003e    val linkLabel = \u0026#34;Link label....\u0026#34;\u003cbr/\u003e    val link = \u0026#34;https://......\u0026#34;\u003cp\u003e    val annotatedDescription = buildAnnotatedString {\u003cbr/\u003e        withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.onBackground)) {\u003cbr/\u003e            append(\u0026#34;Please read the ... here\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        pushStringAnnotation(tag = \u0026#34;Policy\u0026#34;, annotation = link)\u003cbr/\u003e        withStyle(style = SpanStyle(color = MaterialTheme.colorScheme.primary)) {\u003cbr/\u003e            append(linkLabel)\u003cbr/\u003e        }\u003cbr/\u003e        pop()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    ClickableText(\u003cbr/\u003e        text = annotatedDescription,\u003cbr/\u003e        onClick = { offset -\u0026gt;\u003cbr/\u003e            annotatedDescription.getStringAnnotations(\u003cbr/\u003e                tag = \u0026#34;Policy\u0026#34;,\u003cbr/\u003e                start = offset,\u003cbr/\u003e                end = offset\u003cbr/\u003e            ).firstOrNull()?.let { stringAnnotation -\u0026gt;\u003cbr/\u003e                uriHandler.openUri(stringAnnotation.item)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"bde6\"\u003eYou might have already found the issue üêõ why the link is opening in an external browser üï∏Ô∏è\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"afb6\"\u003euriHandler.openUri(stringAnnotation.item)\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e939\"\u003eIt\u0026#39;s because we have used the Compose‚Äôs \u003ccode\u003e\u003cstrong\u003eUriHandler\u003c/strong\u003e\u003c/code\u003e, which fires the following \u003ccode\u003e\u003cstrong\u003eintent\u003c/strong\u003e\u003c/code\u003e:\u003c/li\u003e\u003cli id=\"878f\"\u003e\u003cstrong\u003eAndroidUriHandler‚Äôs \u003c/strong\u003ecode can be found \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/ui/ui/src/androidMain/kotlin/androidx/compose/ui/platform/AndroidUriHandler.android.kt;l=24?q=AndroidUriHandler\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"ad5b\"\u003eclass AndroidUriHandler(private val context: Context) : UriHandler {\u003cp\u003e    /**\u003cbr/\u003e     * Open given URL in browser\u003cbr/\u003e     *\u003cbr/\u003e     * @throws IllegalArgumentException when given [uri] is invalid and/or can\u0026#39;t be handled by the\u003cbr/\u003e     *   system\u003cbr/\u003e     */\u003cbr/\u003e    override fun openUri(uri: String) {\u003cbr/\u003e        try {\u003cbr/\u003e            context.startActivity(Intent(Intent.ACTION_VIEW, Uri.parse(uri)))\u003cbr/\u003e        } catch (e: ActivityNotFoundException) {\u003cbr/\u003e            throw IllegalArgumentException(\u0026#34;Can\u0026#39;t open $uri.\u0026#34;, e)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6b9d\"\u003eSo at this point, we have \u003cstrong\u003etwo\u003c/strong\u003e options\u003c/h2\u003e\u003col\u003e\u003cli id=\"698f\"\u003eFix the Uri handling code ‚úÖ and leave the deprecated API as it is.\u003cbr/\u003e\u003cstrong\u003eOR\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"a1a2\"\u003eFix the code and replace the \u003cstrong\u003edeprecated API\u003c/strong\u003e with the recommended one ‚úÖ ‚≠êÔ∏è\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"2223\"\u003eI picked the 2nd, so let\u0026#39;s see how we can migrate this code to the new API \u003ccode\u003e\u003cstrong\u003eLinkAnnotation\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eand\u003cstrong\u003e \u003c/strong\u003ehandle the URI in a way that checks if Chrome custom tabs are supported, then opens the URI in one; otherwise, fire the \u003cstrong\u003eintent\u003c/strong\u003e with the necessary \u003cstrong\u003eaction\u003c/strong\u003e and \u003cstrong\u003edata\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3121\"\u003eLinkAnnotation class\u003c/h2\u003e\u003cul\u003e\u003cli id=\"404e\"\u003eIt\u0026#39;s an abstract class with \u003cstrong\u003etwo\u003c/strong\u003e abstract properties\u003c/li\u003e\u003c/ul\u003e\u003col\u003e\u003cli id=\"6054\"\u003estyles\u003c/li\u003e\u003cli id=\"3614\"\u003elinkInteractionListener\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"860a\"\u003eBy default, we have two implementations available for us\u003c/h2\u003e\u003cul\u003e\u003cli id=\"48a9\"\u003e\u003cstrong\u003eUrl\u003c/strong\u003e: It has \u003cstrong\u003ethree\u003c/strong\u003e properties: 2 from \u003ccode\u003e\u003cstrong\u003eLinkedAnnotation\u003c/strong\u003e\u003c/code\u003e + 1 its own\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"f7e4\"\u003e\u003cstrong\u003eClickable: \u003c/strong\u003eIt has \u003cstrong\u003ethree\u003c/strong\u003e properties: 2 from \u003ccode\u003e\u003cstrong\u003eLinkedAnnotation\u003c/strong\u003e\u003c/code\u003e + 1 its own\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"ea97\"\u003eAs per our use case, I decided to use the \u003cstrong\u003eUrl \u003c/strong\u003eclass because in our case, we have Text, which includes the \u003cstrong\u003eHTTP\u003c/strong\u003e \u003ccode\u003e\u003cstrong\u003eURLs\u003c/strong\u003e\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"38f9\"\u003e@Composable\u003cbr/\u003efun LinkAnnotationExample() {\u003cbr/\u003e    Text(buildAnnotatedString {\u003cbr/\u003e        append(\u0026#34;Some other text \u0026#34;)\u003cbr/\u003e        withLink( \u003cbr/\u003e            LinkAnnotation.Url(\u003cbr/\u003e                // Added the sample Url here.\u003cbr/\u003e                url = \u0026#34;https://developer.android.com/jetpack/compose\u0026#34;,\u003cbr/\u003e                styles = TextLinkStyles(\u003cbr/\u003e                    style = SpanStyle(color = Color.Blue),\u003cbr/\u003e                    hoveredStyle = SpanStyle(\u003cbr/\u003e                        color = Color.Red,\u003cbr/\u003e                        textDecoration = TextDecoration.Underline\u003cbr/\u003e                    ),\u003cbr/\u003e                    focusedStyle = SpanStyle(\u003cbr/\u003e                        color = Color.Red,\u003cbr/\u003e                        textDecoration = TextDecoration.LineThrough\u003cbr/\u003e                    ),\u003cbr/\u003e                    pressedStyle = SpanStyle(\u003cbr/\u003e                        color = Color.Green,\u003cbr/\u003e                        textDecoration = TextDecoration.LineThrough\u003cbr/\u003e                    ),\u003cbr/\u003e                )\u003cbr/\u003e            )\u003cbr/\u003e        ) {\u003cbr/\u003e            append(\u0026#34;Jetpack Compose\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"4ecd\"\u003eAs you can see üëÜ, it\u0026#39;s a better approach than \u003cstrong\u003eClickableText. \u003c/strong\u003eHere, we don‚Äôt need to worry about the \u003cstrong\u003eoffset\u003c/strong\u003e, get \u003cstrong\u003eannotations\u003c/strong\u003e, and then get the \u003cstrong\u003eUri\u003c/strong\u003e, and \u003cstrong\u003eproceed\u003c/strong\u003e from there.\u003c/li\u003e\u003cli id=\"9b8b\"\u003eWe used the \u003ccode\u003e\u003cstrong\u003ewithLink\u003c/strong\u003e\u003c/code\u003e extension function to add the \u003cstrong\u003elink\u003c/strong\u003e to \u003cstrong\u003eAnnotatedString\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4725\"\u003e‚ÑπÔ∏è If we don‚Äôt pass the \u003ccode\u003e\u003cstrong\u003eLinkInteractionListener\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eto the\u003cstrong\u003e \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eUrl\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e class \u003c/strong\u003ethen internally \u003ccode\u003e\u003cstrong\u003eText\u003c/strong\u003e\u003c/code\u003e uses the \u003ccode\u003e\u003cstrong\u003eUriHandler\u003c/strong\u003e\u003c/code\u003e to open the \u003cstrong\u003elink\u003c/strong\u003e, which under the hood fires the \u003ccode\u003e\u003cstrong\u003eintent\u003c/strong\u003e\u003c/code\u003e for us.\u003c/p\u003e\u003cul\u003e\u003cli id=\"cfae\"\u003eHere is the code for the \u003cstrong\u003ehandleLink\u003c/strong\u003e function from \u003ccode\u003e\u003cstrong\u003eTextLinkScope\u003c/strong\u003e\u003c/code\u003e class\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e3d9\"\u003e\u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/text/TextLinkScope.kt;l=285?q=TextLinkScope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/text/TextLinkScope.kt;l=285?q=TextLinkScope\u003c/a\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8c2e\"\u003e    private fun handleLink(link: LinkAnnotation, uriHandler: UriHandler) {\u003cbr/\u003e        when (link) {\u003cbr/\u003e            is LinkAnnotation.Url -\u0026gt;\u003cbr/\u003e                link.linkInteractionListener?.onClick(link)\u003cbr/\u003e                    ?: try {\u003cbr/\u003e                        uriHandler.openUri(link.url)\u003cbr/\u003e                    } catch (_: IllegalArgumentException) {\u003cbr/\u003e                       // ..\u003cbr/\u003e                    }\u003cbr/\u003e            is LinkAnnotation.Clickable -\u0026gt; // ...\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"67ef\"\u003eSo if you want to handle the \u003cstrong\u003eURL\u003c/strong\u003e opening within your application or want to listen to the link interactions, for example, for analytics purposes, then you can provide your own \u003ccode\u003e\u003cstrong\u003elinkInteractionListener\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0784\"\u003e@Composable\u003cbr/\u003efun LinkAnnotationExample() {\u003cbr/\u003e    Text(buildAnnotatedString {\u003cbr/\u003e        append(\u0026#34;Build better apps faster with \u0026#34;)\u003cbr/\u003e        withLink(\u003cbr/\u003e            LinkAnnotation.Url(\u003cbr/\u003e                url = \u0026#34;https://developer.android.com/jetpack/compose\u0026#34;\u003cbr/\u003e            ){ linkAnnotation -\u0026gt;\u003cbr/\u003e                val url = (linkAnnotation as LinkAnnotation.Url).url\u003cbr/\u003e                Log.d(\u0026#34;TAG\u0026#34;, \u0026#34;LinkAnnotationExample: $url\u0026#34;)\u003cp\u003e                            }\u003cbr/\u003e        ) {\u003cbr/\u003e            append(\u0026#34;Jetpack Compose\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    })\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3752\"\u003eChrome custom tab support implementation\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0643\"\u003eAdd a query tag to the manifest file\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"6021\"\u003e\u0026lt;queries\u0026gt;\u003cbr/\u003e    \u0026lt;intent\u0026gt;\u003cbr/\u003e        \u0026lt;action android:name=\u003cbr/\u003e            \u0026#34;android.support.customtabs.action.CustomTabsService\u0026#34; /\u0026gt;\u003cbr/\u003e    \u0026lt;/intent\u0026gt;\u003cbr/\u003e\u0026lt;/queries\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"69fd\"\u003eAdd code to check if \u003cstrong\u003ecustom tabs\u003c/strong\u003e are \u003cstrong\u003esupported\u003c/strong\u003e or \u003cstrong\u003enot\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"78e3\"\u003eprivate const val ACTION_CUSTOM_TABS_CONNECTION =\u003cbr/\u003e    \u0026#34;android.support.customtabs.action.CustomTabsService\u0026#34;\u003cp\u003eprivate const val CHROME_PACKAGE = \u0026#34;com.android.chrome\u0026#34;\u003c/p\u003e\u003cp\u003efun isChromeCustomTabsSupported(context: Context): Boolean {\u003cbr/\u003e    val serviceIntent = Intent(ACTION_CUSTOM_TABS_CONNECTION).apply {\u003cbr/\u003e        setPackage(CHROME_PACKAGE)\u003cbr/\u003e    }\u003cbr/\u003e    val resolveInfo: MutableList\u0026lt;ResolveInfo?\u0026gt;? =\u003cbr/\u003e        context.packageManager.queryIntentServices(serviceIntent, 0)\u003cbr/\u003e    return resolveInfo?.filterNotNull()?.isNotEmpty() == true\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"5769\"\u003eAdd an extension function on \u003cstrong\u003eUri\u003c/strong\u003e to open in a \u003cstrong\u003ecustom tab\u003c/strong\u003e or a browser\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"bde8\"\u003efun Uri.openInBrowser(context: Context) {\u003cp\u003e        try {\u003cbr/\u003e        when (isChromeCustomTabsSupported(context)) {\u003cbr/\u003e            true -\u0026gt; {\u003cbr/\u003e                val builder: CustomTabsIntent.Builder = CustomTabsIntent.Builder()\u003cbr/\u003e                val customTabsIntent: CustomTabsIntent = builder.build()\u003cbr/\u003e                customTabsIntent.launchUrl(context, this)\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e            false -\u0026gt; {\u003cbr/\u003e                val browserIntent = Intent(Intent.ACTION_VIEW, this).apply {\u003cbr/\u003e                    putExtra(Browser.EXTRA_APPLICATION_ID, context.packageName)\u003cbr/\u003e                }\u003cbr/\u003e                context.startActivity(browserIntent)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    } catch (activityNotFoundException: ActivityNotFoundException) {\u003cbr/\u003e        Log.e(\u0026#34;ChromeCustomTab\u0026#34;, activityNotFoundException.message.toString())\u003cbr/\u003e    } catch (exception: Exception) {\u003cbr/\u003e        Log.e(\u0026#34;ChromeCustomTab\u0026#34;, exception.message.toString())\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"acb3\"\u003eReferences\u003c/h2\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-04-30T01:06:43.488Z",
  "modifiedTime": null
}
