{
  "id": "f09d670a-7d54-4492-bc7f-49be98cf65b7",
  "title": "Using Ktor In Jetpack Compose",
  "link": "https://proandroiddev.com/using-ktor-in-jetpack-compose-e00b1b32eef0?source=rss----c72404660798---4",
  "description": "",
  "author": "tomerpacific",
  "published": "Sat, 15 Feb 2025 16:12:36 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "ktor",
    "android",
    "android-app-development",
    "jetpack-compose",
    "androiddev"
  ],
  "byline": "tomerpacific",
  "length": 5853,
  "excerpt": "Yes, I am late to the party. There are plenty of articles online explaining how to use Ktor in an Android application. I visited some of them while trying to learn how to actually use Ktor. But what…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Setup - KtorKtor is separated into several libraries, but regardless of what you want to do, you will need to add these two dependencies (at the very least):dependencies { implementation(\"io.ktor:ktor-client-core:2.3.12\") implementation(\"io.ktor:ktor-client-android:2.3.12\")}The core dependency, as the name implies, holds the main client functionality, while the second dependency is the ktor engine. An engine in ktor is responsible for handling the network requests and there are different variants of engines for different platforms. Since we are developing on Android, we need the Android engine.You can read more about Engines hereSince we want to also work with JSON in our response and to deserialize it, we will add the following package:dependencies { implementation(\"io.ktor:ktor-client-core:2.3.12\") implementation(\"io.ktor:ktor-client-android:2.3.12\") implementation(\"io.ktor:ktor-client-content-negotiation:2.3.12\") //\u003c-- This}The Content Negotiation dependency is responsible for serializing/deserializing the data into a specific format (I.E. JSON)More on serialization in Kotlin and Jetpack Compose later in this articleNow we can start by creating our HttpClient.import io.ktor.client.HttpClientimport io.ktor.client.engine.android.Androidval myHttpClient = HttpClient(Android)Pretty simple, right? We basically instantiated a ktor HttpClient and passed as an argument the specific Engine type we want. Since we want to make our HttpClient also handle JSON, we need to install a configuration to this client. This object is known as the HttpClientConfig and allows us to configure how our HttpClient will work in many ways.import io.ktor.client.HttpClientimport io.ktor.client.engine.android.Androidimport io.ktor.client.plugins.contentnegotiation.ContentNegotiationimport io.ktor.serialization.kotlinx.json.jsonval myHttpClient = HttpClient(Android) { install(ContentNegotiation) { json() } }Here, we are telling ktor to install the ContentNegotiation plugin and we are configuring this plugin to work with the JSON serializer. There is a lot more that you can configure inside the HttpClientConfig. For example, you can set the request timeout in milliseconds by installing the HttpTimeout extension:val myHttpClient = HttpClient(Android) { install(HttpTimeout) { requestTimeoutMillis = 10000 } install(ContentNegotiation) { json() } }Setup - SerializationI have covered setting up serialization in Jetpack Compose in a previous article and you can read it here:But if I would have to condense that article down into a few lines, it would be these:Understand which Jetpack Compose version you are working withThis will tell you which Kotlin version you need to work withThen you must find a corresponding kotlin-serialization library version that matches the Kotlin version you found in step #2Once you have all that figured out, go to your project level build.gradle.kts file you put the following in the plugins block:plugins { ... kotlin(\"jvm\") version \"1.5.0\" kotlin(\"plugin.serialization\") version \"1.5.0\"}And in your application level build.gradle.kts file, modify the plugins block and the dependencies block:plugins { ... id(\"org.jetbrains.kotlin.plugin.serialization\")}...dependencies { ... implementation(\"io.ktor:ktor-serialization-kotlinx-json:2.3.12\") implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.0\")}Serialization \u0026 DeserializationWith all the setup behind us, it is time to deal with creating our data class and converting a response to it. Let’s imagine we have a server that returns data about a car. Meaning, it can return it’s make, model, year of production and so on. So, let’s create a data class that models this data:@Serializabledata class CarDetails( @SerialName(\"car_make\") val make: String, @SerialName(\"car_model\") val model: String, @SerialName(\"year_of_production\") val productionYear: Int ...)Regardless of how you will structure your application, you will have a class responsible for making the requests. Inside of this class, we will instantiate our HttpClient and use it. Below is an example of a Get request:val httpResponse: HttpResponse = try { myHttpClient.get { url { protocol = URLProtocol.HTTPS host = \"www.google.com\" encodedPath = \"path/file.html\" } } } catch (e: Exception) { //Handle exception in request }After specifying the type of request using the get block, which holds a HttpRequestBuilder object. We then create a url block, which holds a URLBuilder object. In the code snippet above, you can see that it is possible to set the protocol (http/https), the host and the query parameters of the GET request. Having said that, there is more that can be configured and you can also choose to just pass the entire endpoint, without settings the various URL components separately:val httpResponse: HTTPResponse = myHttpClient.get(\"https://www.domain.com/path/file.html\")Executing a POST request is just as simple:val httpResponse: HTTPResponse = myHttpClient.post(\"https://www.domain.com/path/file.html\") { setBody(\"body content goes here\")}But how do we handle the response?First, the HttpResponse object has a status field that can let us know if the response has a status of 200 or not. Once we know that, we can cast the response’s body as the data class we created.val httpResponse: HTTPResponse = myHttpClient.get(\"https://www.domain.com/path/file.html\")when (httpResponse.status.value) { in 200..299 -\u003e { val carDetails = httpResponse.body() as CarDetails } else -\u003e { // Handle various server errors } }",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*SAYmXuUYHdKD4eIq",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"4952\"\u003eSetup - Ktor\u003c/h2\u003e\u003cp id=\"a3c9\"\u003eKtor is separated into several libraries, but regardless of what you want to do, you will need to add these two dependencies (at the very least):\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"85ff\"\u003edependencies {\u003cbr/\u003e    implementation(\u0026#34;io.ktor:ktor-client-core:2.3.12\u0026#34;)\u003cbr/\u003e    implementation(\u0026#34;io.ktor:ktor-client-android:2.3.12\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1f94\"\u003eThe core dependency, as the name implies, holds the main client functionality, while the second dependency is the ktor engine. An engine in ktor is responsible for handling the network requests and there are different variants of engines for different platforms. Since we are developing on Android, we need the Android engine.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"2f3e\"\u003e\u003ca href=\"https://ktor.io/docs/client-engines.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eYou can read more about Engines here\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"0692\"\u003eSince we want to also work with JSON in our response and to deserialize it, we will add the following package:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d319\"\u003edependencies {\u003cbr/\u003e    implementation(\u0026#34;io.ktor:ktor-client-core:2.3.12\u0026#34;)\u003cbr/\u003e    implementation(\u0026#34;io.ktor:ktor-client-android:2.3.12\u0026#34;)\u003cbr/\u003e    implementation(\u0026#34;io.ktor:ktor-client-content-negotiation:2.3.12\u0026#34;) //\u0026lt;-- This\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6d9f\"\u003eThe Content Negotiation dependency is responsible for serializing/deserializing the data into a specific format (I.E. JSON)\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"25dd\"\u003eMore on serialization in Kotlin and Jetpack Compose later in this article\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"68e4\"\u003eNow we can start by creating our HttpClient.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4099\"\u003eimport io.ktor.client.HttpClient\u003cbr/\u003eimport io.ktor.client.engine.android.Android\u003cp\u003eval myHttpClient = HttpClient(Android)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2e70\"\u003ePretty simple, right? We basically instantiated a ktor HttpClient and passed as an argument the specific Engine type we want. Since we want to make our HttpClient also handle JSON, we need to install a configuration to this client. This object is known as the \u003ca href=\"https://api.ktor.io/ktor-client/ktor-client-core/io.ktor.client/-http-client-config/index.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHttpClientConfig\u003c/a\u003e and allows us to configure how our HttpClient will work in many ways.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9848\"\u003eimport io.ktor.client.HttpClient\u003cbr/\u003eimport io.ktor.client.engine.android.Android\u003cbr/\u003eimport io.ktor.client.plugins.contentnegotiation.ContentNegotiation\u003cbr/\u003eimport io.ktor.serialization.kotlinx.json.json\u003cp\u003eval myHttpClient = HttpClient(Android) {\u003cbr/\u003e        install(ContentNegotiation) {\u003cbr/\u003e            json()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9af4\"\u003eHere, we are telling ktor to install the ContentNegotiation \u003cstrong\u003eplugin \u003c/strong\u003eand we are configuring this plugin to work with the JSON serializer. There is a lot more that you can configure inside the HttpClientConfig. For example, you can set the request timeout in milliseconds by installing the HttpTimeout extension:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d3df\"\u003eval myHttpClient = HttpClient(Android) {\u003cbr/\u003e        install(HttpTimeout) {\u003cbr/\u003e            requestTimeoutMillis = 10000\u003cbr/\u003e        }\u003cbr/\u003e        install(ContentNegotiation) {\u003cbr/\u003e            json()\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"0f1e\"\u003eSetup - Serialization\u003c/h2\u003e\u003cp id=\"05ad\"\u003eI have covered setting up serialization in Jetpack Compose in a previous article and you can read it here:\u003c/p\u003e\u003cp id=\"14b5\"\u003eBut if I would have to condense that article down into a few lines, it would be these:\u003c/p\u003e\u003col\u003e\u003cli id=\"037c\"\u003eUnderstand which Jetpack Compose version you are working with\u003c/li\u003e\u003cli id=\"0963\"\u003eThis will tell you which Kotlin version you need to work with\u003c/li\u003e\u003cli id=\"4100\"\u003eThen you must find a corresponding kotlin-serialization library version that matches the Kotlin version you found in step #2\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"8771\"\u003eOnce you have all that figured out, go to your project level build.gradle.kts file you put the following in the \u003cstrong\u003eplugins\u003c/strong\u003e block:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7adb\"\u003eplugins {\u003cbr/\u003e    ...\u003cbr/\u003e    kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;1.5.0\u0026#34;\u003cbr/\u003e    kotlin(\u0026#34;plugin.serialization\u0026#34;) version \u0026#34;1.5.0\u0026#34;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"55e7\"\u003eAnd in your application level build.gradle.kts file, modify the \u003cstrong\u003eplugins \u003c/strong\u003eblock and the \u003cstrong\u003edependencies \u003c/strong\u003eblock:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"360e\"\u003eplugins {\u003cbr/\u003e    ...\u003cbr/\u003e    id(\u0026#34;org.jetbrains.kotlin.plugin.serialization\u0026#34;)\u003cbr/\u003e}\u003cp\u003e...\u003c/p\u003e\u003cp\u003edependencies {\u003cbr/\u003e  ...\u003cbr/\u003e  implementation(\u0026#34;io.ktor:ktor-serialization-kotlinx-json:2.3.12\u0026#34;)\u003cbr/\u003e  implementation(\u0026#34;org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.0\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c18c\"\u003eSerialization \u0026amp; Deserialization\u003c/h2\u003e\u003cp id=\"ebad\"\u003eWith all the setup behind us, it is time to deal with creating our data class and converting a response to it. Let’s imagine we have a server that returns data about a car. Meaning, it can return it’s make, model, year of production and so on. So, let’s create a data class that models this data:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"552b\"\u003e@Serializable\u003cbr/\u003edata class CarDetails(\u003cbr/\u003e    @SerialName(\u0026#34;car_make\u0026#34;)\u003cbr/\u003e    val make: String,\u003cbr/\u003e    @SerialName(\u0026#34;car_model\u0026#34;)\u003cbr/\u003e    val model: String,\u003cbr/\u003e    @SerialName(\u0026#34;year_of_production\u0026#34;)\u003cbr/\u003e    val productionYear: Int\u003cbr/\u003e    ...\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a491\"\u003eRegardless of how you will structure your application, you will have a class responsible for making the requests. Inside of this class, we will instantiate our HttpClient and use it. Below is an example of a Get request:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd65\"\u003eval httpResponse: HttpResponse = try {\u003cbr/\u003e            myHttpClient.get {\u003cbr/\u003e                url {\u003cbr/\u003e                    protocol = URLProtocol.HTTPS\u003cbr/\u003e                    host = \u0026#34;www.google.com\u0026#34;\u003cbr/\u003e                    encodedPath = \u0026#34;path/file.html\u0026#34;\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Exception) {\u003cbr/\u003e            //Handle exception in request\u003cbr/\u003e        }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fe74\"\u003eAfter specifying the type of request using the get block, which holds a \u003cstrong\u003eHttpRequestBuilder \u003c/strong\u003eobject. We then create a url block, which holds a \u003ca href=\"https://api.ktor.io/ktor-http/io.ktor.http/-u-r-l-builder/index.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eURLBuilder\u003c/strong\u003e \u003c/a\u003eobject. In the code snippet above, you can see that it is possible to set the protocol (http/https), the host and the query parameters of the GET request. Having said that, there is more that can be configured and you can also choose to just pass the entire endpoint, without settings the various URL components separately:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6449\"\u003eval httpResponse: HTTPResponse = myHttpClient.get(\u0026#34;https://www.domain.com/path/file.html\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"924a\"\u003eExecuting a POST request is just as simple:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"467b\"\u003eval httpResponse: HTTPResponse = myHttpClient.post(\u0026#34;https://www.domain.com/path/file.html\u0026#34;) {\u003cbr/\u003e  setBody(\u0026#34;body content goes here\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4b3b\"\u003eBut how do we handle the response?\u003c/p\u003e\u003cp id=\"c319\"\u003eFirst, the HttpResponse object has a \u003cstrong\u003estatus \u003c/strong\u003efield that can let us know if the response has a status of 200 or not. Once we know that, we can cast the response’s body as the data class we created.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"aac5\"\u003eval httpResponse: HTTPResponse = myHttpClient.get(\u0026#34;https://www.domain.com/path/file.html\u0026#34;)\u003cp\u003ewhen (httpResponse.status.value) {\u003cbr/\u003e            in 200..299 -\u0026gt; {\u003cbr/\u003e                val carDetails = httpResponse.body() as CarDetails\u003cbr/\u003e            }\u003cbr/\u003e            else -\u0026gt; {\u003cbr/\u003e                // Handle various server errors\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-02-15T16:12:36.235Z",
  "modifiedTime": null
}
