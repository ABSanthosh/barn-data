{
  "id": "027a7bdb-a0f8-4003-897d-bc4899c23cc1",
  "title": "Load Initial Data When Screen Appears",
  "link": "https://proandroiddev.com/load-initial-data-when-screen-appears-358f77126a08?source=rss----c72404660798---4",
  "description": "",
  "author": "Caner Ka≈üeler",
  "published": "Thu, 03 Apr 2025 14:08:36 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "androiddev",
    "android-app-development",
    "jetpack-compose",
    "kotlin-multiplatform"
  ],
  "byline": "Caner Ka≈üeler",
  "length": 11156,
  "excerpt": "Many mobile applications need to fetch data to display on the screen when a screen is shown. Additionally, when the application configuration changes, it may not always be necessary to send new API‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Load Initial Data When Screen AppearsMany mobile applications need to fetch data to display on the screen when a screen is shown. Additionally, when the application configuration changes, it may not always be necessary to send new API requests, read from the database, etc.In Android application development, we have several options for handling this. In this article, I will discuss some of them along with my personal preference.I no longer use Fragments in my projects. However, these days, the likelihood of encountering both Fragments and Jetpack Compose together is higher than encountering Fragments alone. Therefore, I have included both in this article. Lastly, I will provide an example of fetching data, but there may be other possible approaches as well.Article image made by Caner Ka≈üeler.Table of contents:Example Project Structure üèóÔ∏èPossible Ways üõ£Ô∏èMy Personal Preference üëÄLast Words üìù1) Example Project Structure üèóÔ∏èFirstly, let‚Äôs have a quick look at the project structure. I used Hilt for dependency injection in this article.ApplicationIt is basic application class with Hilt annotation.package com.canerkaselerimport android.app.Applicationimport dagger.hilt.android.HiltAndroidApp@HiltAndroidAppclass App: Application()MainActivityProject has single fragment which is HomeFragment:package com.canerkaselerimport android.os.Bundleimport androidx.activity.enableEdgeToEdgeimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport androidx.fragment.app.addimport androidx.fragment.app.commitimport dagger.hilt.android.AndroidEntryPoint@AndroidEntryPointclass MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) enableEdgeToEdge() setContentView(R.layout.activity_main) ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -\u003e val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()) v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom) insets } if (savedInstanceState == null) { supportFragmentManager.commit { setReorderingAllowed(true) // I added single fragment which is HomeFragment. add\u003cHomeFragment\u003e(R.id.fragment_container_view) } } }}FragmentHomeFragment includes a compose screen:package com.canerkaselerimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.compose.foundation.layout.Boximport androidx.compose.foundation.layout.fillMaxSizeimport androidx.compose.material3.Textimport androidx.compose.runtime.Composableimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.platform.ComposeViewimport androidx.compose.ui.platform.ViewCompositionStrategyimport androidx.compose.ui.unit.spimport androidx.fragment.app.Fragmentimport androidx.fragment.app.viewModelsclass HomeFragment: Fragment(R.layout.home_fragment) { private val homeViewModel: HomeViewModel by viewModels() override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { val view = inflater.inflate(R.layout.home_fragment, container, false) val composeView = view.findViewById\u003cComposeView\u003e(R.id.compose_view) composeView.apply { setViewCompositionStrategy( ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed ) setContent { HomeScreen() } } return view } @Composable private fun HomeScreen() { Box( modifier = Modifier .fillMaxSize(), contentAlignment = Alignment.Center ) { Text( text = \"Hello Caner\", fontSize = 24.sp ) } }}ViewModelHomeViewModel has a function to act like data fetching:package com.canerkaselerimport android.util.Logimport androidx.lifecycle.ViewModelimport dagger.hilt.android.lifecycle.HiltViewModelimport javax.inject.Inject@HiltViewModelclass HomeViewModel @Inject constructor() : ViewModel() { fun fetchArticleList() { Log.i(\"CANER\", \"--\u003e fetchArticleList\") }}I will not share gradle, gradle.settings, xml, etc. kind of files in here but if you would like to look at them, please check out the repository.2) Possible Ways üõ£Ô∏èThere are some possible approaches to send request with screen opening.class HomeFragment: Fragment(R.layout.home_fragment) { private val homeViewModel: HomeViewModel by viewModels() // Approach A. override fun onCreate(savedInstanceState: Bundle?) { ... // Approach A - fetch data. homeViewModel.fetchArticleList(from = \"27-Fragment onCreate\") } // Approach B. override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View { ... // Approach B - fetch data. homeViewModel.fetchArticleList(from = \"38-Fragment onCreateView\") composeView.apply { ... setContent { HomeScreen() } } return view } @Composable private fun HomeScreen() { // Approach C. LaunchedEffect(Unit) { // Approach C- fetch data. homeViewModel.fetchArticleList(from = \"55-Compose LaunchedEffect\") } ... }}Almost all of us used these approaches before Flow and Compose. However, the main question is:What is the problem with these approaches?The main issue is that they cannot prevent sending new requests when a configuration change occurs.Configuration of android application can change by many ways, such as:Screen orientationFont size and weightLocaleDark mode versus light modeEtc.You can find more in here. There is my example:The example above shows that the app sends requests again when the theme changes. Therefore, if you follow this approach, your app may send multiple requests due to users who frequently change configurations while the screen is open.How about ‚Äúinit‚Äù function of ViewModel?Yes, it survives configuration changes. However, it creates a dependency on ViewModel creation. For instance, if you want to write a unit test without triggering the initial loading during ViewModel creation, you can‚Äôt avoid it because the init function runs as soon as the ViewModel is created.If this is not an issue for your project or test cases, then in my opinion, this approach is still valid.3) My Personal Preference üëÄInstead of sending request from Fragment or Compose sides, my choice is fetching data from ViewModel side:data class ScreenState( val text: String = \"\", val counter: Int = 1,)@HiltViewModelclass HomeViewModel @Inject constructor() : ViewModel() { private val screenState = MutableStateFlow(value = ScreenState()) val uiState = screenState .onStart { fetchArticleList(from = \"ViewModel\") } .stateIn( scope = viewModelScope, started = SharingStarted .WhileSubscribed(stopTimeoutMillis = 5000L), initialValue = screenState.value, ) suspend fun fetchArticleList(from: String) { delay(timeMillis = 2000L) Log.i(\"CANER\", \"--\u003e fetchArticleList from: $from\") screenState.update { state -\u003e state.copy( text = \"Fetch Data ${state.counter}\", counter = state.counter + 1 ) } }}Then, UI side can collect state:val uiState = homeViewModel.uiState.collectAsStateWithLifecycle()HomeScreen( text = uiState.value.text)As summary, below gif shows that app does not send a new request when configuration changes. However, app sends a new request when it waits more than 5 seconds on background.Final result.More details are that we have screenState as StateFlow which has ScreenState data class with default values. When app would like to collect state in compose function, uiState provides value of screenState. First time, default value of text is empty string. So, we see just ‚ÄúHello Caner,‚Äù text in first time.Then, onStart function runs. You can call suspend function in onStart. In our example, we can see that screenState is updated in fetchArticleList() function. Thus, uiState provides new value and app shows ‚ÄúHello Caner, Fetch Data 1‚Äù.Next, gif shows that app goes background and foreground under 5 seconds, so app does not send a request in view model. It is happening because of giving 5 seconds in here: WhileSubscribed(stopTimeoutMillis = 5000L). Basically, if the compose function still subscribed for 5 seconds, the flow provides same result. However, when app waits more than 5 seconds, onStart function re-run. So, app shows ‚ÄúHello Caner, Fetch Data 2‚Äù text.Because of above explanation, theme changing (one of the configuration change ways) does not trigger screen loading because it happens under 5 seconds.Hence, 5 seconds are important duration. If your app must need to show fresh data every time, you should not use 5 seconds. There can be zero duration: WhileSubscribed(stopTimeoutMillis = 0L). In this way, you will always have fresh data with screen opening.Before reasons of my preference, as you know code reviewing is crucial especially when topic is about architecture, state management, etc. However, if you are a pull request reviewer, how you should communicate with your colleagues in multicultural team? How should you start your reviewing? What do you need to check? How can you avoid conflicts before they start? How should you write your comments?For answers and more tips, please check out my new 9 pages article, Professional Code Review Skills on Amazon Kindle and Gumroad. üìöWhy I prefer this approach?Screen state in single place.You can use combine() for more complex works.No need to think about configuration changes.There is flexibility about screen refreshing with sstopTimeoutMillis().When you cannot use init because of architecture or any other reason, you can use this approach.I use this approach in my personal projects and open-source projects.Important: 5 seconds is ANR timeout duration. So, if you follow this approach, play safe and do not enter more than 5 seconds. You can read more about it in official document.4) Last Words üìùAlthough this article touches on many topics, it does not cover all the details, such as Flow types, Compose design, Hilt, etc. Instead of presenting a long text with every detail, this article serves as a starting point for your research on state management and initial loading approaches. Plus, if you would like to run your own tests, I have prepared a GitHub repository for you. üìöI hope this article is helpful to you! If you would like to support my work, coffee is my best friend when writing code and articles: https://buymeacoffee.com/canerkaseler ‚òïÔ∏èDon‚Äôt forget to check out my other Medium articles. You can reach me on social media platforms ‚Äî stay tuned! ü§ù",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*yE5AsIWITMmBE76EpoGzhA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"99b0\" data-testid=\"storyTitle\"\u003eLoad Initial Data When Screen Appears\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@canerkaseler?source=post_page---byline--358f77126a08---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Caner Ka≈üeler\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*qHZkBc5zIIM7JPUX0eIG3w@2x.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--358f77126a08---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"3802\"\u003e\u003cspan\u003eM\u003c/span\u003eany mobile applications need to fetch data to display on the screen when a screen is shown. Additionally, when the application configuration changes, it may not always be necessary to send new API requests, read from the database, etc.\u003c/p\u003e\u003cp id=\"4e25\"\u003eIn Android application development, we have several options for handling this. In this article, I will discuss some of them along with my personal preference.\u003c/p\u003e\u003cp id=\"659c\"\u003eI no longer use Fragments in my projects. However, these days, the likelihood of encountering both Fragments and Jetpack Compose together is higher than encountering Fragments alone. Therefore, I have included both in this article. Lastly, I will provide an example of fetching data, but there may be other possible approaches as well.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eArticle image made by Caner Ka≈üeler.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"d3d0\"\u003eTable of contents:\u003c/p\u003e\u003col\u003e\u003cli id=\"56c5\"\u003eExample Project Structure üèóÔ∏è\u003c/li\u003e\u003cli id=\"db3a\"\u003ePossible Ways üõ£Ô∏è\u003c/li\u003e\u003cli id=\"23db\"\u003eMy Personal Preference üëÄ\u003c/li\u003e\u003cli id=\"6b54\"\u003eLast Words üìù\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"4a18\"\u003e1) Example Project Structure üèóÔ∏è\u003c/h2\u003e\u003cp id=\"b68b\"\u003eFirstly, let‚Äôs have a quick look at the project structure. I used Hilt for dependency injection in this article.\u003c/p\u003e\u003ch2 id=\"48fd\"\u003eApplication\u003c/h2\u003e\u003cp id=\"a153\"\u003eIt is basic application class with Hilt annotation.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3a4b\"\u003epackage com.canerkaseler\u003cp\u003eimport android.app.Application\u003cbr/\u003eimport dagger.hilt.android.HiltAndroidApp\u003c/p\u003e\u003cp\u003e@HiltAndroidApp\u003cbr/\u003eclass App: Application()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"dab3\"\u003eMainActivity\u003c/h2\u003e\u003cp id=\"bda5\"\u003eProject has single fragment which is \u003cem\u003eHomeFragment\u003c/em\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6ae3\"\u003epackage com.canerkaseler\u003cp\u003eimport android.os.Bundle\u003cbr/\u003eimport androidx.activity.enableEdgeToEdge\u003cbr/\u003eimport androidx.appcompat.app.AppCompatActivity\u003cbr/\u003eimport androidx.core.view.ViewCompat\u003cbr/\u003eimport androidx.core.view.WindowInsetsCompat\u003cbr/\u003eimport androidx.fragment.app.add\u003cbr/\u003eimport androidx.fragment.app.commit\u003cbr/\u003eimport dagger.hilt.android.AndroidEntryPoint\u003c/p\u003e\u003cp\u003e@AndroidEntryPoint\u003cbr/\u003eclass MainActivity : AppCompatActivity() {\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        super.onCreate(savedInstanceState)\u003cbr/\u003e        enableEdgeToEdge()\u003cbr/\u003e        setContentView(R.layout.activity_main)\u003cbr/\u003e        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -\u0026gt;\u003cbr/\u003e            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())\u003cbr/\u003e            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)\u003cbr/\u003e            insets\u003cbr/\u003e        }\u003cbr/\u003e        if (savedInstanceState == null) {\u003cbr/\u003e            supportFragmentManager.commit {\u003cbr/\u003e                setReorderingAllowed(true)\u003c/p\u003e\u003cp\u003e                // I added single fragment which is HomeFragment.\u003cbr/\u003e                add\u0026lt;HomeFragment\u0026gt;(R.id.fragment_container_view)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d499\"\u003eFragment\u003c/h2\u003e\u003cp id=\"769d\"\u003e\u003cem\u003eHomeFragment\u003c/em\u003e includes a compose screen:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f13c\"\u003epackage com.canerkaseler\u003cp\u003eimport android.os.Bundle\u003cbr/\u003eimport android.view.LayoutInflater\u003cbr/\u003eimport android.view.View\u003cbr/\u003eimport android.view.ViewGroup\u003cbr/\u003eimport androidx.compose.foundation.layout.Box\u003cbr/\u003eimport androidx.compose.foundation.layout.fillMaxSize\u003cbr/\u003eimport androidx.compose.material3.Text\u003cbr/\u003eimport androidx.compose.runtime.Composable\u003cbr/\u003eimport androidx.compose.ui.Alignment\u003cbr/\u003eimport androidx.compose.ui.Modifier\u003cbr/\u003eimport androidx.compose.ui.platform.ComposeView\u003cbr/\u003eimport androidx.compose.ui.platform.ViewCompositionStrategy\u003cbr/\u003eimport androidx.compose.ui.unit.sp\u003cbr/\u003eimport androidx.fragment.app.Fragment\u003cbr/\u003eimport androidx.fragment.app.viewModels\u003c/p\u003e\u003cp\u003eclass HomeFragment: Fragment(R.layout.home_fragment) {\u003c/p\u003e\u003cp\u003e    private val homeViewModel: HomeViewModel by viewModels()\u003c/p\u003e\u003cp\u003e    override fun onCreateView(\u003cbr/\u003e        inflater: LayoutInflater,\u003cbr/\u003e        container: ViewGroup?,\u003cbr/\u003e        savedInstanceState: Bundle?\u003cbr/\u003e    ): View {\u003cbr/\u003e        val view = inflater.inflate(R.layout.home_fragment, container, false)\u003cbr/\u003e        val composeView = view.findViewById\u0026lt;ComposeView\u0026gt;(R.id.compose_view)\u003c/p\u003e\u003cp\u003e        composeView.apply {\u003cbr/\u003e            setViewCompositionStrategy(\u003cbr/\u003e                ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed\u003cbr/\u003e            )\u003cbr/\u003e            setContent {\u003cbr/\u003e                HomeScreen()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return view\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @Composable\u003cbr/\u003e    private fun HomeScreen() {\u003cbr/\u003e        Box(\u003cbr/\u003e            modifier = Modifier\u003cbr/\u003e                .fillMaxSize(),\u003cbr/\u003e            contentAlignment = Alignment.Center\u003cbr/\u003e        ) {\u003cbr/\u003e            Text(\u003cbr/\u003e                text = \u0026#34;Hello Caner\u0026#34;,\u003cbr/\u003e                fontSize = 24.sp\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e827\"\u003eViewModel\u003c/h2\u003e\u003cp id=\"52a6\"\u003e\u003cem\u003eHomeViewModel\u003c/em\u003e has a function to act like data fetching:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6beb\"\u003epackage com.canerkaseler\u003cp\u003eimport android.util.Log\u003cbr/\u003eimport androidx.lifecycle.ViewModel\u003cbr/\u003eimport dagger.hilt.android.lifecycle.HiltViewModel\u003cbr/\u003eimport javax.inject.Inject\u003c/p\u003e\u003cp\u003e@HiltViewModel\u003cbr/\u003eclass HomeViewModel @Inject constructor() : ViewModel() {\u003c/p\u003e\u003cp\u003e    fun fetchArticleList() {\u003cbr/\u003e        Log.i(\u0026#34;CANER\u0026#34;, \u0026#34;--\u0026gt; fetchArticleList\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c270\"\u003eI will not share \u003cem\u003egradle\u003c/em\u003e, \u003cem\u003egradle.settings\u003c/em\u003e, \u003cem\u003exml\u003c/em\u003e, etc. kind of files in here but if you would like to look at them, please check out the repository.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a99f\"\u003e2) Possible Ways üõ£Ô∏è\u003c/h2\u003e\u003cp id=\"6b25\"\u003eThere are some possible approaches to send request with screen opening.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9a14\"\u003eclass HomeFragment: Fragment(R.layout.home_fragment) {\u003cp\u003e    private val homeViewModel: HomeViewModel by viewModels()\u003c/p\u003e\u003cp\u003e    // Approach A.\u003cbr/\u003e    override fun onCreate(savedInstanceState: Bundle?) {\u003cbr/\u003e        ...\u003c/p\u003e\u003cp\u003e        // Approach A - fetch data.\u003cbr/\u003e        homeViewModel.fetchArticleList(from = \u0026#34;27-Fragment onCreate\u0026#34;)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    // Approach B.\u003cbr/\u003e    override fun onCreateView(\u003cbr/\u003e        inflater: LayoutInflater,\u003cbr/\u003e        container: ViewGroup?,\u003cbr/\u003e        savedInstanceState: Bundle?\u003cbr/\u003e    ): View {\u003cbr/\u003e        ...\u003c/p\u003e\u003cp\u003e        // Approach B - fetch data.\u003cbr/\u003e        homeViewModel.fetchArticleList(from = \u0026#34;38-Fragment onCreateView\u0026#34;)\u003c/p\u003e\u003cp\u003e        composeView.apply {\u003cbr/\u003e            ...\u003cbr/\u003e            setContent {\u003cbr/\u003e                HomeScreen()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return view\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @Composable\u003cbr/\u003e    private fun HomeScreen() {\u003c/p\u003e\u003cp\u003e        // Approach C.\u003cbr/\u003e        LaunchedEffect(Unit) {\u003c/p\u003e\u003cp\u003e            // Approach C- fetch data.\u003cbr/\u003e            homeViewModel.fetchArticleList(from = \u0026#34;55-Compose LaunchedEffect\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fe88\"\u003eAlmost all of us used these approaches before Flow and Compose. However, the main question is:\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"a33c\"\u003eWhat is the problem with these approaches?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"df0d\"\u003eThe main issue is that they cannot prevent sending new requests when a configuration change occurs.\u003c/p\u003e\u003cp id=\"bfce\"\u003eConfiguration of android application can change by many ways, such as:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6f9e\"\u003eScreen orientation\u003c/li\u003e\u003cli id=\"35fb\"\u003eFont size and weight\u003c/li\u003e\u003cli id=\"0fbb\"\u003eLocale\u003c/li\u003e\u003cli id=\"6fb9\"\u003eDark mode versus light mode\u003c/li\u003e\u003cli id=\"2dcd\"\u003eEtc.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"45f6\"\u003eYou can find more in \u003ca href=\"https://developer.android.com/guide/topics/resources/runtime-changes\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e. There is my example:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fb94\"\u003eThe example above shows that the app sends requests again when the theme changes. Therefore, if you follow this approach, your app may send multiple requests due to users who frequently change configurations while the screen is open.\u003c/p\u003e\u003ch2 id=\"539a\"\u003eHow about ‚Äúinit‚Äù function of ViewModel?\u003c/h2\u003e\u003cp id=\"3bda\"\u003eYes, it survives configuration changes. However, it creates a dependency on ViewModel creation. For instance, if you want to write a unit test without triggering the initial loading during ViewModel creation, you can‚Äôt avoid it because the \u003ccode\u003einit\u003c/code\u003e function runs as soon as the ViewModel is created.\u003c/p\u003e\u003cp id=\"d527\"\u003eIf this is not an issue for your project or test cases, then in my opinion, this approach is still valid.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d5cf\"\u003e3) My Personal Preference üëÄ\u003c/h2\u003e\u003cp id=\"ce89\"\u003eInstead of sending request from \u003cem\u003eFragment\u003c/em\u003e or \u003cem\u003eCompose\u003c/em\u003e sides, my choice is fetching data from \u003cem\u003eViewModel\u003c/em\u003e side:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"199b\"\u003edata class ScreenState(\u003cbr/\u003e    val text: String = \u0026#34;\u0026#34;,\u003cbr/\u003e    val counter: Int = 1,\u003cbr/\u003e)\u003cp\u003e@HiltViewModel\u003cbr/\u003eclass HomeViewModel @Inject constructor() : ViewModel() {\u003c/p\u003e\u003cp\u003e    private val screenState = MutableStateFlow(value = ScreenState())\u003cbr/\u003e    val uiState = screenState\u003cbr/\u003e        .onStart {\u003cbr/\u003e            fetchArticleList(from = \u0026#34;ViewModel\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        .stateIn(\u003cbr/\u003e            scope = viewModelScope,\u003cbr/\u003e            started = SharingStarted\u003cbr/\u003e                .WhileSubscribed(stopTimeoutMillis = 5000L),\u003cbr/\u003e            initialValue = screenState.value,\u003cbr/\u003e        )\u003c/p\u003e\u003cp\u003e    suspend fun fetchArticleList(from: String) {\u003cbr/\u003e        delay(timeMillis = 2000L)\u003c/p\u003e\u003cp\u003e        Log.i(\u0026#34;CANER\u0026#34;, \u0026#34;--\u0026gt; fetchArticleList from: $from\u0026#34;)\u003c/p\u003e\u003cp\u003e        screenState.update { state -\u0026gt;\u003cbr/\u003e            state.copy(\u003cbr/\u003e                text = \u0026#34;Fetch Data ${state.counter}\u0026#34;,\u003cbr/\u003e                counter = state.counter + 1\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e2cc\"\u003eThen, UI side can collect state:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"258f\"\u003eval uiState = homeViewModel.uiState.collectAsStateWithLifecycle()\u003cp\u003eHomeScreen(\u003cbr/\u003e    text = uiState.value.text\u003cbr/\u003e)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fec9\"\u003eAs summary, below gif shows that app does not send a new request when configuration changes. However, app sends a new request when it waits more than 5 seconds on background.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eFinal result.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2414\"\u003eMore details are that we have \u003ccode\u003escreenState\u003c/code\u003e as \u003ccode\u003eStateFlow\u003c/code\u003e which has \u003ccode\u003eScreenState\u003c/code\u003e data class with default values. When app would like to collect state in compose function, \u003ccode\u003euiState\u003c/code\u003e provides value of \u003ccode\u003escreenState\u003c/code\u003e. First time, default value of text is empty string. So, we see just ‚Äú\u003cem\u003eHello Caner,\u003c/em\u003e‚Äù text in first time.\u003c/p\u003e\u003cp id=\"92ec\"\u003eThen, \u003ccode\u003eonStart\u003c/code\u003e function runs. You can call \u003ccode\u003esuspend\u003c/code\u003e function in \u003ccode\u003eonStart\u003c/code\u003e. In our example, we can see that \u003ccode\u003escreenState\u003c/code\u003e is updated in \u003ccode\u003efetchArticleList()\u003c/code\u003e function. Thus, \u003ccode\u003euiState\u003c/code\u003e provides new value and app shows ‚Äú\u003cem\u003eHello Caner, Fetch Data 1\u003c/em\u003e‚Äù.\u003c/p\u003e\u003cp id=\"4f2a\"\u003eNext, gif shows that app goes background and foreground under 5 seconds, so app does not send a request in view model. It is happening because of giving 5 seconds in here: \u003ccode\u003eWhileSubscribed(stopTimeoutMillis = 5000L)\u003c/code\u003e. Basically, if the compose function still subscribed for 5 seconds, the flow provides same result. However, when app waits more than 5 seconds, \u003ccode\u003eonStart\u003c/code\u003e function re-run. So, app shows ‚Äú\u003cem\u003eHello Caner, Fetch Data 2\u003c/em\u003e‚Äù text.\u003c/p\u003e\u003cp id=\"b12b\"\u003eBecause of above explanation, theme changing (\u003cem\u003eone of the configuration change ways\u003c/em\u003e) does not trigger screen loading because it happens under 5 seconds.\u003c/p\u003e\u003cp id=\"91e4\"\u003eHence, 5 seconds are important duration. If your app must need to show fresh data every time, you should not use 5 seconds. There can be zero duration: \u003ccode\u003eWhileSubscribed(stopTimeoutMillis = 0L)\u003c/code\u003e. In this way, you will always have fresh data with screen opening.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"d255\"\u003eBefore reasons of my preference, as you know \u003cstrong\u003ecode reviewing\u003c/strong\u003e is crucial especially when topic is about architecture, state management, etc. However, if you are a pull request reviewer, how you should communicate with your colleagues in multicultural team? How should you start your reviewing? What do you need to check? How can you avoid conflicts before they start? How should you write your comments?\u003c/p\u003e\u003cp id=\"e2f9\"\u003eFor answers and more tips, please check out my \u003cstrong\u003enew\u003c/strong\u003e 9 pages article, \u003cstrong\u003eProfessional Code Review Skills\u003c/strong\u003e on \u003ca href=\"https://www.amazon.com/dp/B0DZ97652J\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAmazon Kindle\u003c/a\u003e and \u003ca href=\"https://canerkaseler.gumroad.com/l/ProfessionalCodeReviewSkills?layout=profile\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGumroad\u003c/a\u003e. üìö\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"4ab3\"\u003eWhy I prefer this approach?\u003c/p\u003e\u003cul\u003e\u003cli id=\"0bbe\"\u003eScreen state in single place.\u003c/li\u003e\u003cli id=\"85e6\"\u003eYou can use \u003ccode\u003ecombine()\u003c/code\u003e for more complex works.\u003c/li\u003e\u003cli id=\"f889\"\u003eNo need to think about configuration changes.\u003c/li\u003e\u003cli id=\"01d5\"\u003eThere is flexibility about screen refreshing with \u003ccode\u003esstopTimeoutMillis()\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"6f5d\"\u003eWhen you cannot use \u003ccode\u003einit\u003c/code\u003e because of architecture or any other reason, you can use this approach.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c707\"\u003eI use this approach in my personal projects and open-source projects.\u003c/p\u003e\u003cp id=\"4ec0\"\u003e\u003cstrong\u003eImportant\u003c/strong\u003e: 5 seconds is ANR timeout duration. So, if you follow this approach, play safe and do not enter more than 5 seconds. You can read more about it in \u003ca href=\"https://developer.android.com/topic/performance/vitals/anr\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eofficial document\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f334\"\u003e4) Last Words üìù\u003c/h2\u003e\u003cp id=\"fd7f\"\u003eAlthough this article touches on many topics, it does not cover all the details, such as Flow types, Compose design, Hilt, etc. Instead of presenting a long text with every detail, this article serves as a starting point for your research on state management and initial loading approaches. Plus, if you would like to run your own tests, I have prepared a \u003ca href=\"https://github.com/canerkaseler/jetpack-compose-fetch-first-time-data\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub repository\u003c/a\u003e for you. üìö\u003c/p\u003e\u003cp id=\"60de\"\u003eI hope this article is helpful to you! If you would like to support my work, coffee is my best friend when writing code and articles: \u003ca href=\"https://buymeacoffee.com/canerkaseler\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://buymeacoffee.com/canerkaseler\u003c/a\u003e ‚òïÔ∏è\u003c/p\u003e\u003cp id=\"ba68\"\u003eDon‚Äôt forget to check out my other Medium \u003ca href=\"https://medium.com/@canerkaseler\" rel=\"noopener\"\u003earticles\u003c/a\u003e. You can reach me on social media platforms ‚Äî stay tuned! ü§ù\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-04-03T14:08:36.857Z",
  "modifiedTime": null
}
