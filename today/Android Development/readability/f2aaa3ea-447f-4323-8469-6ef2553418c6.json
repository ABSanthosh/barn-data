{
  "id": "f2aaa3ea-447f-4323-8469-6ef2553418c6",
  "title": "Unifying Your Android App’s Analytics: A Provider-Agnostic Approach with Jetpack Compose",
  "link": "https://proandroiddev.com/unifying-your-android-apps-analytics-a-provider-agnostic-approach-with-jetpack-compose-3d1d54f1f3a6?source=rss----c72404660798---4",
  "description": "",
  "author": "Kartik Arora",
  "published": "Fri, 14 Feb 2025 17:31:54 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "jetpack-compose",
    "androiddev",
    "android",
    "analytics",
    "android-app-development"
  ],
  "byline": "Kartik Arora",
  "length": 9856,
  "excerpt": "In the dynamic world of mobile app development, understanding user behaviour and fine-tuning your app is paramount. This is where analytics come into play, offering invaluable insights into how users…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In the dynamic world of mobile app development, understanding user behaviour and fine-tuning your app is paramount. This is where analytics come into play, offering invaluable insights into how users interact with your app. However, implementing analytics often presents a tangled web of challenges: vendor lock-in, clunky SDKs, and the ever-evolving landscape of Android development, particularly with Jetpack Compose.This article delves into a flexible, provider-agnostic approach to streamline analytics integration in Jetpack Compose apps, leveraging smart design patterns and Compose’s unique features.The Common Analytics HurdlesLet’s face it: dealing with analytics can be a real headache. You might find yourself grappling with these common issues:Provider Lock-in: Your app’s analytics are tightly coupled to a specific provider, making switching a nightmare of code rewrites.Managing Multiple Providers: You need to send data to multiple analytics platforms, leading to code duplication and messy logic.Taming the Beast: Abstraction and the Composite PatternAbstraction is our knight in shining armor against vendor lock-in. Imagine defining a simple interface that outlines the essential analytics actions your app needs, like tracking screen views (trackScreen) and user actions (trackAction). This interface acts as a middleman, decoupling your core app code from the nitty-gritty of specific analytics providers.Let’s visualize it with some code! Imagine an interface like this:interface AnalyticsInterface { fun trackScreen(screenName: String) fun trackAction(actionName: String)}Now, you can create concrete implementations of this interface for different providers. For instance, here’s a Firebase implementation:class FirebaseAnalyticsImpl() : AnalyticsInterface { // FirebaseAnalytics instance override fun trackScreen(screenName: String) { // Convert Event.View to Firebase parameters and log the event } override fun trackAction(actionName: String) { // Convert Event.Action to Firebase parameters and log the event }}To tackle the multiple provider conundrum, the composite pattern swoops in. Think of it like a central command center that orchestrates multiple devices. A composite class holds a collection of these AnalyticsInterface implementations and delegates calls to each of them.class CompositeAnalytics( private val providers: List\u003cAnalyticsInterface\u003e) : AnalyticsInterface { override fun trackScreen(screenName: String) { providers.forEach { provider -\u003e provider.trackScreen(screenName) } } override fun trackAction(actionName: String) { providers.forEach { provider -\u003e provider.trackAction(actionName) } }}Let’s say you have implementations for Firebase, Adobe, and Mixpanel analytics. Creating a composite setup would look like this:val firebaseImpl = FirebaseImpl()val adobeImpl = AdobeImpl()val mixpanelImpl = MixpanelImpl()val compositeAnalytics = CompositeAnalytics( listOf(firebaseImpl, adobeImpl, mixpanelImpl))compositeAnalytics.trackScreen(\"HomeScreen\") compositeAnalytics.trackAction(\"ButtonClicked\")In this scenario, a single call to trackScreen on the compositeAnalytics object would simultaneously send the screen view event to Firebase, Adobe, and Mixpanel.The composite pattern empowers you to build a flexible and maintainable analytics system that adapts to changing requirements and provider preferences.Embracing Jetpack Compose: LaunchedEffect and CompositionLocalJetpack Compose revolutionizes Android UI development with its declarative approach, moving away from the traditional imperative style. This shift brings new opportunities and challenges, particularly when it comes to integrating analytics. We can no easily use the familiar Android lifecycle methods like onResume and onPause. They do exist in the compose world, however it isn’t as easy as overriding the functions. Instead, we leverage Jetpack Compose features like LaunchedEffect and Composition Locals.LaunchedEffect enables us to perform side effects, such as sending analytics data. Its strength lies in executing a code block only once during the initial composition of a composable function and optionally again when specified dependencies change.To illustrate, let’s imagine tracking a screen view every time it appears. With LaunchedEffect, we achieve this as follows:@Composablefun MyScreen(screenName: String, analytics: AnalyticsInterface) { LaunchedEffect(Unit) { // Triggered only once upon initial composition analytics.trackScreen(screenName) } // ...The rest of your composable content...}Passing the analytics object through each layer of our composable functions can quickly become unwieldy. Composition Locals come to the rescue, acting as invisible data containers accessible to any composable function within a defined scope. We can provide the AnalyticsInterface through a Composition Local, eliminating the need for manual passing.Let’s break down the setup:1. Creating a Composition Local:val LocalAnalytics = compositionLocalOf\u003cAnalyticsInterface\u003e { error(\"No analytics provided!\") }We define a Composition Local named LocalAnalytics designed to hold an AnalyticsInterface. The error function safeguards against instances where the AnalyticsInterface is not provided, causing a crash.2. Providing the Analytics Implementation:@Composablefun MyApp(analytics: AnalyticsInterface) { CompositionLocalProvider(LocalAnalytics provides analytics) { // ... Your app's composables ... }}We wrap our top-level composable, likely residing in your Activity or root composable, with CompositionLocalProvider. This makes the actual analytics implementation accessible to all child composables within the defined scope.3. Accessing Analytics in Any Composable:@Composablefun SomeDeeplyNestedComposable() { val analytics = LocalAnalytics.current analytics.trackAction(\"ButtonClicked\") // ... The remaining composable content ... }Even from a deeply nested composable, we can directly obtain the AnalyticsInterface via LocalAnalytics.current. This allows us to track events without the overhead of manual parameter passing.In essence, Jetpack Compose provides a fresh perspective on integrating analytics into our applications. Features like LaunchedEffect and CompositionLocal offer elegant solutions to the challenges presented by this new paradigm.What if you could skip the heavy lifting and focus on what truly matters: building an amazing app?Introducing AnylyticsAnylytics is an intuitive, open-source Android library designed to make analytics integration in Jetpack Compose applications a breeze.Here’s why you should choose Anylytics:Say Goodbye to Vendor Lock-in: Migrating between analytics providers becomes effortless. Whether you’re using Firebase Analytics, Adobe Analytics, or considering other options, Anylytics adapts to your choices, ensuring a smooth transition without code rewrites.Seamless Integration with Jetpack Compose: Anylytics leverages Composition Locals, a powerful feature in Jetpack Compose. Access your analytics implementation from any composable function, eliminating the need to pass instances through multiple layers of your UI.Simplicity and Ease of Use: Anylytics offers a concise and intuitive API. Tracking screen views, user actions, and capturing rich context data is as simple as a few lines of code.Support for Multiple Analytics Providers: Send data to multiple providers simultaneously using Anylytics’ built-in support for the Composite pattern.Anylytics is your solution — an intuitive, open-source Android library that simplifies analytics integration in Jetpack Compose. Stop wrestling with SDKs and start focusing on building exceptional user experiences.Let’s see Anylytics in action:Implementation:Define Your Analytics Interface: Anylytics provides the AnylyticsInterface with functions like trackScreen and trackAction. Implement this interface for each analytics provider you intend to use.Create Provider-Specific Implementations: Create concrete implementations of the AnylyticsInterface for your chosen providers.Use the CompositionLocalProvider : In your main Activity or root composable, utilise CompositionLocalProviderto make your analytics implementation accessible throughout your application.Track Events Effortlessly: Inside any composable, access the analytics implementation using LocalAnylyticsInterace.current, and log events using functions like trackScreen and trackAction.Data Classes: The Heart of AnylyticsAnylytics uses data classes to structure analytics data for clarity and ease of use.Event: Represents different types of events, such as screen views (Event.View) and user actions (Event.Action).ContextData: Holds additional contextual information related to an event, including a screen name and a mutable map for key-value pairs.Breadcrumbs: Captures user navigation flow through your app, storing information about the current section, subsection, and sub-subsection.Example Usage:val screenViewEvent = Event.View( screenName = \"HomeScreen\", contextData = ContextData( screenName = \"HomeScreen\", contextMap = mutableMapOf(\"item_id\" to \"123\") ), breadCrumbs = BreadCrumbs( section = \"Home\", subSection = \"Products\", subSubSection = \"Details\" ))analytics.trackScreen(screenViewEvent)Current State and Future RoadmapAnylytics, currently in its early stages, is available on GitHub and Maven Central. The library includes artifacts for Firebase Analytics and Adobe Analytics. The roadmap includes:Improving API documentation.Exploring multiplatform support for wider adoption beyond Android.Anylytics is more than just an analytics library - it is a step towards a simpler, more adaptable analytics integration experience for Jetpack Compose.",
  "image": "https://miro.medium.com/v2/resize:fit:960/1*QcfRmxQre3IatmArdk4yew.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@kartikarora?source=post_page---byline--3d1d54f1f3a6---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Kartik Arora\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Bfg0QskBEl83xWt39G86tQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--3d1d54f1f3a6---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"0ab8\"\u003eIn the dynamic world of mobile app development, understanding user behaviour and fine-tuning your app is paramount. This is where analytics come into play, offering invaluable insights into how users interact with your app. However, implementing analytics often presents a tangled web of challenges: vendor lock-in, clunky SDKs, and the ever-evolving landscape of Android development, particularly with Jetpack Compose.\u003c/p\u003e\u003cp id=\"a599\"\u003eThis article delves into a \u003cstrong\u003eflexible, provider-agnostic approach to streamline analytics integration in Jetpack Compose apps\u003c/strong\u003e, leveraging smart design patterns and Compose’s unique features.\u003c/p\u003e\u003ch2 id=\"cc0b\"\u003eThe Common Analytics Hurdles\u003c/h2\u003e\u003cp id=\"dab5\"\u003eLet’s face it: dealing with analytics can be a real headache. You might find yourself grappling with these common issues:\u003c/p\u003e\u003cul\u003e\u003cli id=\"991f\"\u003e\u003cstrong\u003eProvider Lock-in:\u003c/strong\u003e Your app’s analytics are tightly coupled to a specific provider, making switching a nightmare of code rewrites.\u003c/li\u003e\u003cli id=\"d81d\"\u003e\u003cstrong\u003eManaging Multiple Providers:\u003c/strong\u003e You need to send data to multiple analytics platforms, leading to code duplication and messy logic.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"faf7\"\u003eTaming the Beast: Abstraction and the Composite Pattern\u003c/h2\u003e\u003cp id=\"3ae6\"\u003e\u003cstrong\u003eAbstraction\u003c/strong\u003e is our knight in shining armor against vendor lock-in.\u003cstrong\u003e \u003c/strong\u003eImagine defining a simple interface that outlines the essential analytics actions your app needs, like tracking screen views (trackScreen) and user actions (trackAction). This interface acts as a middleman, decoupling your core app code from the nitty-gritty of specific analytics providers.\u003c/p\u003e\u003cp id=\"4ddc\"\u003eLet’s visualize it with some code! Imagine an interface like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f15a\"\u003einterface AnalyticsInterface {\u003cbr/\u003e    fun trackScreen(screenName: String)\u003cbr/\u003e    fun trackAction(actionName: String)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"db29\"\u003eNow, you can create concrete implementations of this interface for different providers. For instance, here’s a Firebase implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fd93\"\u003eclass FirebaseAnalyticsImpl() : AnalyticsInterface {\u003cbr/\u003e    // FirebaseAnalytics instance \u003cp\u003e    override fun trackScreen(screenName: String) {\u003cbr/\u003e        // Convert Event.View to Firebase parameters and log the event\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun trackAction(actionName: String) {\u003cbr/\u003e        // Convert Event.Action to Firebase parameters and log the event\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d090\"\u003eTo tackle the multiple provider conundrum, the \u003cstrong\u003ecomposite pattern\u003c/strong\u003e swoops in. Think of it like a central command center that orchestrates multiple devices. A composite class holds a collection of these AnalyticsInterface implementations and delegates calls to each of them.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a404\"\u003eclass CompositeAnalytics(\u003cbr/\u003e    private val providers: List\u0026lt;AnalyticsInterface\u0026gt;\u003cbr/\u003e) : AnalyticsInterface {\u003cbr/\u003e    override fun trackScreen(screenName: String) {\u003cbr/\u003e        providers.forEach { provider -\u0026gt;\u003cbr/\u003e            provider.trackScreen(screenName)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cp\u003e    override fun trackAction(actionName: String) {\u003cbr/\u003e        providers.forEach { provider -\u0026gt;\u003cbr/\u003e            provider.trackAction(actionName)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e9a7\"\u003eLet’s say you have implementations for Firebase, Adobe, and Mixpanel analytics. Creating a composite setup would look like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"99a1\"\u003eval firebaseImpl = FirebaseImpl()\u003cbr/\u003eval adobeImpl = AdobeImpl()\u003cbr/\u003eval mixpanelImpl = MixpanelImpl()\u003cp\u003eval compositeAnalytics = CompositeAnalytics(\u003cbr/\u003e    listOf(firebaseImpl, adobeImpl, mixpanelImpl)\u003cbr/\u003e)\u003cbr/\u003ecompositeAnalytics.trackScreen(\u0026#34;HomeScreen\u0026#34;) \u003cbr/\u003ecompositeAnalytics.trackAction(\u0026#34;ButtonClicked\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a89e\"\u003eIn this scenario, a single call to trackScreen on the \u003ccode\u003ecompositeAnalytics\u003c/code\u003e object would simultaneously send the screen view event to Firebase, Adobe, and Mixpanel.\u003c/p\u003e\u003cp id=\"0ef1\"\u003eThe composite pattern empowers you to build a flexible and maintainable analytics system that adapts to changing requirements and provider preferences.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"2d1b\"\u003eEmbracing Jetpack Compose: LaunchedEffect and CompositionLocal\u003c/h2\u003e\u003cp id=\"7a35\"\u003eJetpack Compose revolutionizes Android UI development with its declarative approach, moving away from the traditional imperative style. This shift brings new opportunities and challenges, particularly when it comes to integrating analytics. We can no easily use the familiar Android lifecycle methods like onResume and onPause. They do exist in the compose world, however it isn’t as easy as overriding the functions. Instead, we leverage Jetpack Compose features like LaunchedEffect and Composition Locals.\u003c/p\u003e\u003cp id=\"3633\"\u003e\u003cstrong\u003eLaunchedEffect\u003c/strong\u003e enables us to perform side effects, such as sending analytics data. Its strength lies in executing a code block only once during the initial composition of a composable function and optionally again when specified dependencies change.\u003c/p\u003e\u003cp id=\"4e2b\"\u003eTo illustrate, let’s imagine tracking a screen view every time it appears. With LaunchedEffect, we achieve this as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4f30\"\u003e@Composable\u003cbr/\u003efun MyScreen(screenName: String, analytics: AnalyticsInterface) {\u003cbr/\u003e    LaunchedEffect(Unit) { // Triggered only once upon initial composition\u003cbr/\u003e        analytics.trackScreen(screenName)\u003cbr/\u003e    }\u003cbr/\u003e    // ...The rest of your composable content...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0d62\"\u003ePassing the analytics object through each layer of our composable functions can quickly become unwieldy. \u003cstrong\u003eComposition Locals\u003c/strong\u003e come to the rescue, acting as invisible data containers accessible to any composable function within a defined scope. We can provide the AnalyticsInterface through a Composition Local, eliminating the need for manual passing.\u003c/p\u003e\u003cp id=\"9f2a\"\u003eLet’s break down the setup:\u003c/p\u003e\u003cp id=\"fe7a\"\u003e\u003cstrong\u003e1. Creating a Composition Local:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b7cf\"\u003eval LocalAnalytics = compositionLocalOf\u0026lt;AnalyticsInterface\u0026gt; {\u003cbr/\u003e    error(\u0026#34;No analytics provided!\u0026#34;) \u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1032\"\u003eWe define a Composition Local named LocalAnalytics designed to hold an AnalyticsInterface. The error function safeguards against instances where the AnalyticsInterface is not provided, causing a crash.\u003c/p\u003e\u003cp id=\"1288\"\u003e\u003cstrong\u003e2. Providing the Analytics Implementation:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dd76\"\u003e@Composable\u003cbr/\u003efun MyApp(analytics: AnalyticsInterface) {\u003cbr/\u003e    CompositionLocalProvider(LocalAnalytics provides analytics) {\u003cbr/\u003e        // ... Your app\u0026#39;s composables ...\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7116\"\u003eWe wrap our top-level composable, likely residing in your Activity or root composable, with CompositionLocalProvider. This makes the actual analytics implementation accessible to all child composables within the defined scope.\u003c/p\u003e\u003cp id=\"03a5\"\u003e\u003cstrong\u003e3. Accessing Analytics in Any Composable:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"885c\"\u003e@Composable\u003cbr/\u003efun SomeDeeplyNestedComposable() {\u003cbr/\u003e    val analytics = LocalAnalytics.current \u003cbr/\u003e    analytics.trackAction(\u0026#34;ButtonClicked\u0026#34;)\u003cbr/\u003e    // ... The remaining composable content ... \u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a9e1\"\u003eEven from a deeply nested composable, we can directly obtain the AnalyticsInterface via LocalAnalytics.current. This allows us to track events without the overhead of manual parameter passing.\u003c/p\u003e\u003cp id=\"74d0\"\u003eIn essence, Jetpack Compose provides a fresh perspective on integrating analytics into our applications. Features like \u003cstrong\u003eLaunchedEffect\u003c/strong\u003e and \u003cstrong\u003eCompositionLocal\u003c/strong\u003e offer elegant solutions to the challenges presented by this new paradigm.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"9d90\"\u003e\u003cstrong\u003eWhat if you could skip the heavy lifting and focus on what truly matters: building an amazing app?\u003c/strong\u003e\u003c/p\u003e\u003ch2 id=\"db3a\"\u003eIntroducing Anylytics\u003c/h2\u003e\u003cp id=\"d9ff\"\u003eAnylytics is an intuitive, open-source Android library designed to make analytics integration in Jetpack Compose applications a breeze.\u003c/p\u003e\u003cp id=\"4ef8\"\u003eHere’s why you should choose Anylytics:\u003c/p\u003e\u003cul\u003e\u003cli id=\"5e26\"\u003e\u003cstrong\u003eSay Goodbye to Vendor Lock-in:\u003c/strong\u003e Migrating between analytics providers becomes effortless. Whether you’re using Firebase Analytics, Adobe Analytics, or considering other options, Anylytics adapts to your choices, ensuring a smooth transition without code rewrites.\u003c/li\u003e\u003cli id=\"2ea6\"\u003e\u003cstrong\u003eSeamless Integration with Jetpack Compose:\u003c/strong\u003e Anylytics leverages Composition Locals, a powerful feature in Jetpack Compose. Access your analytics implementation from any composable function, eliminating the need to pass instances through multiple layers of your UI.\u003c/li\u003e\u003cli id=\"ce03\"\u003e\u003cstrong\u003eSimplicity and Ease of Use:\u003c/strong\u003e Anylytics offers a concise and intuitive API. Tracking screen views, user actions, and capturing rich context data is as simple as a few lines of code.\u003c/li\u003e\u003cli id=\"eb16\"\u003e\u003cstrong\u003eSupport for Multiple Analytics Providers:\u003c/strong\u003e Send data to multiple providers simultaneously using Anylytics’ built-in support for the Composite pattern.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"c3f6\"\u003e\u003cstrong\u003eAnylytics is your solution — an intuitive, open-source Android library that simplifies analytics integration in Jetpack Compose.\u003c/strong\u003e Stop wrestling with SDKs and start focusing on building exceptional user experiences.\u003c/p\u003e\u003cp id=\"a64e\"\u003e\u003cstrong\u003eLet’s see Anylytics in action:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3053\"\u003e\u003cstrong\u003eImplementation:\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli id=\"4861\"\u003e\u003cstrong\u003eDefine Your Analytics Interface\u003c/strong\u003e: Anylytics provides the \u003ccode\u003eAnylyticsInterface\u003c/code\u003e with functions like trackScreen and trackAction. Implement this interface for each analytics provider you intend to use.\u003c/li\u003e\u003cli id=\"1173\"\u003e\u003cstrong\u003eCreate Provider-Specific Implementations\u003c/strong\u003e: Create concrete implementations of the AnylyticsInterface for your chosen providers.\u003c/li\u003e\u003cli id=\"ba27\"\u003e\u003cstrong\u003eUse the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eCompositionLocalProvider\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e: In your main Activity or root composable, utilise \u003ccode\u003eCompositionLocalProvider\u003c/code\u003eto make your analytics implementation accessible throughout your application.\u003c/li\u003e\u003cli id=\"f392\"\u003e\u003cstrong\u003eTrack Events Effortlessly\u003c/strong\u003e: Inside any composable, access the analytics implementation using \u003ccode\u003eLocalAnylyticsInterace.current\u003c/code\u003e, and log events using functions like trackScreen and trackAction.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"99fd\"\u003e\u003cstrong\u003eData Classes: The Heart of Anylytics\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"2ced\"\u003eAnylytics uses data classes to structure analytics data for clarity and ease of use.\u003c/p\u003e\u003cul\u003e\u003cli id=\"23b3\"\u003e\u003cstrong\u003eEvent\u003c/strong\u003e: Represents different types of events, such as screen views (Event.View) and user actions (Event.Action).\u003c/li\u003e\u003cli id=\"1f11\"\u003e\u003cstrong\u003eContextData\u003c/strong\u003e: Holds additional contextual information related to an event, including a screen name and a mutable map for key-value pairs.\u003c/li\u003e\u003cli id=\"3b54\"\u003e\u003cstrong\u003eBreadcrumbs\u003c/strong\u003e: Captures user navigation flow through your app, storing information about the current section, subsection, and sub-subsection.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e696\"\u003e\u003cstrong\u003eExample Usage:\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1cb5\"\u003eval screenViewEvent = Event.View(\u003cbr/\u003e    screenName = \u0026#34;HomeScreen\u0026#34;,\u003cbr/\u003e    contextData = ContextData(\u003cbr/\u003e        screenName = \u0026#34;HomeScreen\u0026#34;,\u003cbr/\u003e        contextMap = mutableMapOf(\u0026#34;item_id\u0026#34; to \u0026#34;123\u0026#34;)\u003cbr/\u003e    ),\u003cbr/\u003e    breadCrumbs = BreadCrumbs(\u003cbr/\u003e        section = \u0026#34;Home\u0026#34;, \u003cbr/\u003e        subSection = \u0026#34;Products\u0026#34;, \u003cbr/\u003e        subSubSection = \u0026#34;Details\u0026#34; \u003cbr/\u003e    )\u003cbr/\u003e)\u003cbr/\u003eanalytics.trackScreen(screenViewEvent)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"16b8\"\u003e\u003cstrong\u003eCurrent State and Future Roadmap\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"996b\"\u003eAnylytics, currently in its early stages, is available on \u003ca href=\"https://github.com/kartikarora/anylytics\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eGitHub\u003c/a\u003e and Maven Central. The library includes artifacts for Firebase Analytics and Adobe Analytics. The roadmap includes:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a095\"\u003eImproving API documentation.\u003c/li\u003e\u003cli id=\"eafa\"\u003eExploring multiplatform support for wider adoption beyond Android.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"53d6\"\u003eAnylytics is more than just an analytics library - it is a step towards a simpler, more adaptable analytics integration experience for Jetpack Compose.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-02-14T17:31:54.704Z",
  "modifiedTime": null
}
