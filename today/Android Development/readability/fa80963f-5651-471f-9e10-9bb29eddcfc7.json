{
  "id": "fa80963f-5651-471f-9e10-9bb29eddcfc7",
  "title": "Kotlin inline reified to Solve Type Erasure, and a Practical Guide on noinline, crossinline, and…",
  "link": "https://proandroiddev.com/kotlin-inline-reified-to-solve-type-erasure-and-a-practical-guide-on-noinline-crossinline-and-63ecbf693250?source=rss----c72404660798---4",
  "description": "",
  "author": "Ioannis Anifantakis",
  "published": "Sun, 23 Feb 2025 15:21:33 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "programming",
    "kotlin",
    "android-app-development",
    "software-engineering",
    "androiddev"
  ],
  "byline": "Ioannis Anifantakis",
  "length": 21502,
  "excerpt": "Master how Kotlin inline reified deals with Type Erasure, and explore noinline and crossinline modifiers.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "IntroductionKotlin has become very popular, especially for writing native Android apps and recently for multiplatform apps. One of its most powerful features which is a little hard to understand are inline functions used together with reified type parameters. These functions let you write type-safe code and avoid problems caused by type erasure, without relying on slow reflection.In this guide, I will explain how these functions work, why they are so useful, show a real-world example using type-safe navigation in Android, and discuss their performance benefits. We will build up the concepts step by step, so you can fully understand the reasoning behind this approach.The Problem: Generics and the Vanishing TypeBefore we introduce the solution, we need to clarify the problem. It all starts with generics.Generics are a wonderful way to write reusable code that can handle different data types. For example, you might want a list that holds various elements — numbers, strings, or custom objects. Generics allow you to do this without writing separate code for each type.val stringList: List\u003cString\u003e = listOf(\"apple\", \"banana\", \"orange\")val numberList: List\u003cInt\u003e = listOf(1, 2, 3)In this example, we have two lists: one for String values and one for Int values. \u003cString\u003e and \u003cInt\u003e are the generic type parameters, which tell the compiler what type of data each list can contain.This feature is called compile-time type safety: the compiler detects mistakes early. If you try to add a number to stringList, the compiler will raise an error.However, there is a catch: the detailed type information (String, Int, or another type) is not preserved when your code executes. This phenomenon is called type erasure.Understanding Type ErasureWhen Kotlin compiles your code, it removes the detailed generic type information. For example, both List\u003cString\u003e and List\u003cInt\u003e end up as list of unknown type List\u003c*\u003e at runtime.Often, people say “they become List\u003cAny\u003e” for simplicity, but it’s more accurate to consider them as raw or wildcard types (List\u003c?\u003e).While generics help you catch mistakes during compilation, they do not carry detailed type information at runtime, since that information is erased.Type Erasure: Why does Erasure exist?This concept of type erasure exists because of how the Java Virtual Machine (JVM), which Kotlin runs on, handles generics. It was introduced for backward compatibility with older Java code that did not use generics.To allow newer, generic code to work with older libraries, the JVM “forgets” the specific type parameters at runtime. As a result, both List\u003cString\u003e and List\u003cInt\u003e effectively become List\u003c?\u003e, and the JVM no longer distinguishes between them.The Consequences of Type ErasureThis “forgetting” has some important consequences:No Runtime Type Checks: You cannot check at runtime whether a list is a List\u003cString\u003e or a List\u003cInt\u003e because that “type information” no longer exists.Casting Limitations: You cannot simply cast an object to a generic type parameter (for example, “cast this object to type T”) because the runtime does not know what T is.Example of Type Erasure Limitationfun \u003cT\u003e printClassName(obj: T) { println(obj::class.java.name)}fun main() { val listOfStrings: List\u003cString\u003e = listOf(\"Kotlin\", \"Java\") printClassName(listOfStrings) // The runtime only sees it as a List, not List\u003cString\u003e}We expect printClassName to output \"List\u003cString\u003e\". But it outputs the raw type (ArrayList or similar) because the generic type information (\u003cString\u003e) is lost. The function sees a generic List, not the specific List\u003cString\u003e.The Solution: inline reified to the RescueThis is where inline reified comes into play. By using these two keywords together, you can maintain type information at runtime, thus overcoming the limitations caused by type erasure.inline: This keyword tells the compiler to copy (or “inline”) the entire function’s code into the location where it is called. Instead of calling a separate function, the function’s body is embedded directly. This can also improve performance in some scenarios (more on that later).reified: This keyword, which can only be used with inline functions, ensures the type parameter becomes “real” (reified) at runtime. It instructs the compiler to keep type information for that parameter.Let’s modify our previous example:inline fun \u003creified T\u003e printClassName(item: T) { println(T::class.java.name) // Now this works!}fun main() { val myList = listOf(\"hello\", \"world\") printClassName(myList) // Output: java.util.ArrayList (or similar, but the important part is...) printClassName(\"hello\") // Output: java.lang.String printClassName(123) // Output: java.lang.Integer}Let’s Explore furtherTo deeply understand the mechanics and the reasons between inline and reified, I have prepared a real example that highlights the concept.Real Scenario: Type-Safe Navigation in AndroidIn Android Navigation 2.8 and onward, there is built-in support for TypeSafety.You define in a data class the parameters to pass from one screen to another. You can also pass data classes via serialization. However, to pass custom data types, you need to specify a certain NavType, which helps the system serialize and deserialize the custom type when navigating between screens. val PersonType = object : NavType\u003cPerson\u003e( isNullableAllowed = false ) { override fun put(bundle: Bundle, key: String, value: Person) { bundle.putParcelable(key, value) } override fun get(bundle: Bundle, key: String): Person? { return if (Build.VERSION.SDK_INT \u003c 34) { @Suppress(\"DEPRECATION\") bundle.getParcelable(key) } else { bundle.getParcelable(key, Person::class.java) } } override fun parseValue(value: String): Person { return Json.decodeFromString\u003cPerson\u003e(value) } override fun serializeAsValue(value: Person): String { return Json.encodeToString(value) } override val name = Person::class.java.name}With this code, you define a custom NavType for the data class Person. Now you can pass a full Person object as a parameter with the new navigation component.But notice how lengthy the code is. It works for one type, but if you have multiple types—like Person and Car—duplicating this logic can lead to boilerplate and mistakes.We obviously need to replace our Person with a type T here to get the job done so we don’t repeat all this code if we want to pass for example a Car as well.Attempt 1: A Generic Function (But It Fails)We might wrap the snippet inside a function, replacing Person for a generic type T. That should give us the freedom to reuse the same logic for any Parcelable type, instead of rewriting everything for every type.fun \u003cT : Parcelable\u003e NavType.Companion.mapper(): NavType\u003cT\u003e { return object : NavType\u003cT\u003e( isNullableAllowed = false ) { override fun put(bundle: Bundle, key: String, value: T) { bundle.putParcelable(key, value) } override fun get(bundle: Bundle, key: String): T? { return if (Build.VERSION.SDK_INT \u003c Build.VERSION_CODES.TIRAMISU) { @Suppress(\"DEPRECATION\") bundle.getParcelable(key) } else { bundle.getParcelable(key, T::class.java) } } override fun parseValue(value: String): T { return Json.decodeFromString\u003cT\u003e(value) } override fun serializeAsValue(value: T): String { return Json.encodeToString(value) } override val name = T::class.java.name }This seems perfect, but it does not compile. The problem is still type erasure. We cannot call T::class.java because the runtime does not know what T is.Attempt 2: Introducing reifiedThis is where reified comes in. By adding the reified keyword before T, we tell the compiler to preserve the type at runtime.val personType = NavType.mapper\u003cPerson\u003e()val carType = NavType.mapper\u003cCar\u003e() fun \u003creified T : Parcelable\u003e NavType.Companion.mapper(): NavType\u003cT\u003e { // same code here}Now, T::class.java is valid. We can access T’s class at runtime because reified makes T a real type in the function. But we still get a compiler error:‘reified’ type parameter modifier is only allowed on inline functionsAttempt 3: The Missing Piece — inlineWe are almost there. The compiler insists that reified can only be used within inline functions. Why?Here’s the key: To make reified work, the compiler needs to know the actual type of T at the place where the function is called. It can't just pass a generic T around. It needs to substitute T with User, Product, or whatever type we're using.The inline keyword enables this by letting the compiler embed the function body directly at the call site, instead of using a traditional function call.Think of it this way: when we call NavType.mapper\u003cPerson\u003e(), the compiler knows T is Person. Because the function is inline, it creates a specialized version of the function, replacing T with Person throughout its body:val personType = NavType.mapper\u003cPerson\u003e()val carType = NavType.mapper\u003cCar\u003e()inline fun \u003creified T : Parcelable\u003e NavType.Companion.mapper(): NavType\u003cT\u003e { // same code here}This is why inline and reified must be used together. reified requires the actual type information at the call site, and inline provides the mechanism to perform that substitution.inline reified TL;DRLet’s summarize why reified goes hand-by-hand with inlineTo maintain the type at runtime, any T marked as reified gets replaced by its concrete type at compile time, producing behind the scenes a new function in which every occurrence of T is replaced by concrete type.The compiler then inlines this specialized version of the function at the caller site, since inline allows the function body to be copied and adapted with the concrete types. Without inline, the compiler could not generate or embed this specialized function.inline keyword — Performance Improvementsinline reified provides type safety, but the inline keyword also offers potential performance improvements.inline places the function’s code directly where it is called, avoiding the usual overhead of a function call (like stack operations and function lookups).This is especially helpful when working with lambdas. When you pass a lambda to a regular function, an object is created. Inline functions avoid creating that object, which makes them much more efficient. Kotlin’s collection functions (map, filter, forEach) are inline for this exact reason: they rely heavily on lambdas.However, inlining also has downsides. It can grow the size of your code, especially if the function is large or used in many different places (often called code bloat).In summary, other than addressing reified issues, inlining by itself is a performance strategy, usually best for small, frequently called functions — especially those that accept lambdas. It might not be suitable for large functions or those called from many locations, since it can lead to code bloat/increased bytecode size and make your app bigger.Controlling Inlining: `noinline` and `crossinline`While inline offers significant advantages, Kotlin provides further control over the inlining process with two important modifiers: noinline and crossinline. These modifiers are used with lambda parameters of inline functions.noinline — Preventing Lambda InliningSometimes, you might want to use an inline function for its performance benefits (or for reified types) but not inline a specific lambda parameter. This is where noinline comes in. You mark the lambda parameter with noinline to prevent it from being inlined.There are two primary reasons to use noinline:1. Passing the Lambda to Another Non-Inline Function: If you need to pass the lambda to another function that is not marked inline, you must use noinline. If you try to pass an inlined lambda to a non-inline function, you’ll get a compiler error. The lambda needs to exist as a separate object to be passed.// NON inline functionfun anotherFunction(lambda: () -\u003e Unit) { lambda()}// inline functioninline fun doSomething(first: () -\u003e Unit, noinline second: () -\u003e Unit) { first() // This lambda will be inlined anotherFunction(second) // 'second' is passed as a regular lambda object (not inlined)}In this example, first will be inlined as usual. second, however, is marked noinline. This prevents its code from being copied into doSomething and allows it to be passed as a function object to anotherFunction.2. Controlling Code Size: If you have an inline function with a very large lambda, inlining that lambda repeatedly could lead to significant code bloat. Using noinline prevents this.inline fun processData(data: List\u003cString\u003e, noinline largeProcessingLogic: (String) -\u003e Unit) { for (item in data) { // Some small, frequently executed code that benefits from inlining if (item.isNotEmpty()) { largeProcessingLogic(item) } }}fun main() { val data = listOf(\"a\", \"b\", \"\", \"c\", \"d\", \"\", \"e\") processData(data) { item -\u003e // Imagine this is a VERY large lambda, with hundreds of lines // of complex logic, database calls, network requests, etc. }}Without noinline, the entire largeProcessingLogic lambda would be copied into the loop for each call to processData, drastically increasing the bytecode size. With noinline, only a reference to the lambda is passed, avoiding code duplication.crossinline — Managing Non-Local Returnscrossinline helps you control how the return keyword works inside lambdas passed to inline functions. It makes return behave in a more predictable way.Normal return (in regular functions and non-inline lambdas): A return statement exits only the lambda or function it’s directly inside.Non-Local return (in inline functions, without crossinline): A return statement inside an inlined lambda exits the function that called the inline function. This can be surprising!Local return (with crossinline): crossinline prevents non-local returns. A return inside a crossinline lambda will only exit the lambda itself, just like a normal return.// Example 1: Non-Local Return (without crossinline)inline fun doSomething(action: () -\u003e Unit) { println(\"Start doSomething\") action() println(\"End doSomething\") // This might NOT be printed}fun test1() { doSomething { println(\"Inside lambda\") return // This exits test1(), NOT just the lambda! } println(\"This will NOT be printed\")}// Example 2: Local Return (with crossinline)inline fun doSomethingSafely(crossinline action: () -\u003e Unit) { println(\"Start doSomethingSafely\") action() println(\"End doSomethingSafely\") // This WILL be printed}fun test2() { doSomethingSafely { println(\"Inside lambda\") return // This exits ONLY the lambda } println(\"This WILL be printed\")}fun main() { println(\"Running test1:\") test1() // Output: Start doSomething, Inside lambda println(\"\\nRunning test2:\") test2() // Output: Start doSomethingSafely, Inside lambda, End doSomethingSafely, This WILL be printed}test1: The return inside the lambda exits test1 completely. \"End doSomething\" and \"This will NOT be printed\" are never reached.test2: The crossinline keyword forces the return to be local. It only exits the lambda, not test2. \"End doSomethingSafely\" and \"This WILL be printed\" are executed.Compiler Error: If you try to pass a lambda marked with crossinline to another lambda or anonymous object, you will get a compiler error.Use crossinline when:You want the return in a lambda to behave like a normal return (exiting only the lambda).You are making a library, and you want to make sure users of your inline function don't accidentally use non-local returns, which could change the flow of their program in unexpected ways.Summary of Modifiersinline: Copies the function's code and lambda code (by default) to the place where it's called. Allows return in a lambda to exit the calling function (non-local return).noinline: Prevents a specific lambda parameter from being inlined. Necessary for passing lambdas to non-inline functions.crossinline: Allows a lambda to be copied (inlined), but forces return to only exit the lambda itself (local return).Limitations and When Reflection is Necessaryinline reified is a powerful tool, but it’s not a universal solution. There are specific situations where it cannot be used. In these cases, reflection (or other, less common workarounds) becomes necessary.Here are some key scenarios where inline reified cannot be used:Dynamic Type Discovery: If you truly don’t know the type of an object until runtime, you can’t use inline reified. reified requires the type to be known where you call the inline function. For example, if you’re reading data from a file and the file format dictates the data type, you won’t know the type until you’ve read the file. Reflection would be needed here.Interacting with Non-Kotlin Code (Without Known Types): If you’re calling Java code (or code from other JVM languages) that doesn’t provide generic type information in a way that Kotlin can understand, you might not be able to use `reified`. You might need to use reflection to interact with the returned objects.Interface method with default implementation: If the method with reified is declared inside an Interface with default implementation.Recursive inline functions: You can’t use inline with functions that call themselves (\"recursive\" functions). The computer copies the function's code each time it's used. If a function calls itself, this copying would never stop.Accessing Non-Public Members (Without @PublishedApi): inline functions can’t directly access non-public members of a class unless those members are marked with the @PublishedApi annotation.Variable Type Arguments: You cannot use a variable as a type argument for a reified type.inline fun \u003creified T\u003e myFun() { println(T::class.simpleName)}fun \u003cT\u003e otherFun() { myFun\u003cT\u003e() // Compilation error}In the code above, we are trying to use the type variable T as a type argument. But this is not allowed.Reflection: The Alternative (and Its Costs)When inline reified isn’t an option, reflection is often the fallback. Reflection allows a program to inspect and manipulate the structure and behavior of objects at runtime. This includes examining types, accessing fields, and invoking methods, even if those elements are not known at compile time.However, this power comes at a cost:Speed: Reflection is significantly slower than direct type access. It involves dynamic lookups and checks that add overhead.Type Safety: Reflection doesn’t check types when you write your code. This means you might get errors when your program runs that you would normally find earlier.Code Complication: Code that uses reflection is often longer and harder to understand.Reflection can do some of the same things as inline reified, but it's usually slower, less safe, and harder to use. inline reified is the best way to do this in most cases where you need to know the type while the program is running.Another Alternative: KClassAnother approach, particularly when you just need to know the Class of a type, is to pass a KClass object as an argument to your function. KClass is Kotlin’s representation of a class.It’s like a blueprint of the class, providing information about its properties, functions, and constructors. For example:fun \u003cT : Any\u003e printClassName(obj: T, clazz: KClass\u003cT\u003e) { println(\"The class name is: ${clazz.simpleName}\")}fun main() { printClassName(\"Hello\", String::class) // Pass String::class printClassName(123, Int::class) // Pass Int::class}This works, but it adds extra code, you have to explicitly pass the KClass every time you call the function. inline reified avoids this extra step because the compiler automatically inserts the type information.It’s important to understand that KClass is not a complete replacement for inline reified. KClass provides information about a type, while inline reified allows you to use a type as if it were concrete, even in the presence of type erasure.They serve different, though related, purposes. inline reified gives you more power within the function where it's used.Conclusioninline reified is a powerful feature in Kotlin that solves the problem of type erasure while providing performance advantages.By using inline and reified together, you can write code that is generic, type-safe, and efficient. It avoids repetitive code (as in our Android Navigation example) and removes the reflection overhead otherwise needed to access runtime type information.Learning how to use inline reified effectively helps you create cleaner, more maintainable, and faster Kotlin code, whether you are developing Android apps, managing complex data, or working with Java libraries.It is an essential tool for improving the quality and performance of your Kotlin projects.Further ReadingKotlin Official DocumentationInline functions: The official Kotlin documentation explaining inline functions, performance benefits, and how they work with lambdas and noinline/crossinline.Reified type parameters: Specifically focuses on reified type parameters within inline functions, detailing how they address type erasure.Generics: A comprehensive overview of generics in Kotlin, essential for understanding the context of type erasure and inline reified.BlogKotlin’s Noinline \u0026 Crossline, once for all: A comprehensive guide specifically on noinline and crossinline.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*0f-m_3fC_4FVEO5js7BVxg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://ioannisanif.medium.com/?source=post_page---byline--63ecbf693250---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Ioannis Anifantakis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*CPyc3y-sp02vMh239V_suQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--63ecbf693250---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"0f5f\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"1205\"\u003eKotlin has become very popular, especially for writing native Android apps and recently for multiplatform apps. One of its most powerful features which is a little hard to understand are \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e functions used together with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e type parameters\u003c/strong\u003e. These functions let you write \u003cstrong\u003etype-safe\u003c/strong\u003e code and avoid problems caused by \u003cstrong\u003etype erasure\u003c/strong\u003e, without relying on slow \u003cstrong\u003ereflection\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"6572\"\u003eIn this guide, I will explain how these functions work, why they are so useful, show a real-world example using \u003cstrong\u003etype-safe navigation\u003c/strong\u003e in Android, and discuss their \u003cstrong\u003eperformance benefits\u003c/strong\u003e. We will build up the concepts step by step, so you can fully understand the reasoning behind this approach.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f5b1\"\u003eThe Problem: Generics and the Vanishing Type\u003c/h2\u003e\u003cp id=\"daf0\"\u003eBefore we introduce the solution, we need to clarify the problem. \u003cstrong\u003eIt all starts with \u003cem\u003egenerics\u003c/em\u003e.\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"0585\"\u003eGenerics are a wonderful way to write reusable code that can handle different data types. For example, you might want a list that holds various elements — numbers, strings, or custom objects. Generics allow you to do this without writing separate code for each type.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cb76\"\u003eval stringList: List\u0026lt;String\u0026gt; = listOf(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;orange\u0026#34;)\u003cbr/\u003eval numberList: List\u0026lt;Int\u0026gt; = listOf(1, 2, 3)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bbe9\"\u003eIn this example, we have two lists: one for \u003ccode\u003eString\u003c/code\u003e values and one for \u003ccode\u003eInt\u003c/code\u003e values. \u003ccode\u003e\u0026lt;String\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;Int\u0026gt;\u003c/code\u003e are the generic type parameters, which tell the compiler what type of data each list can contain.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"520b\"\u003e\u003cem\u003eThis feature is called \u003c/em\u003e\u003cstrong\u003e\u003cem\u003ecompile-time type safety\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e: the compiler detects mistakes early. If you try to add a number to \u003c/em\u003e\u003ccode\u003e\u003cem\u003estringList\u003c/em\u003e\u003c/code\u003e\u003cem\u003e, the compiler will raise an error.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"7830\"\u003eHowever, there is a catch: the detailed type information (\u003ccode\u003eString\u003c/code\u003e, \u003ccode\u003eInt\u003c/code\u003e, or another type) is not preserved when your code executes. This phenomenon is called \u003cstrong\u003etype erasure\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"21bf\"\u003eUnderstanding Type Erasure\u003c/h2\u003e\u003cp id=\"aca6\"\u003eWhen Kotlin compiles your code, it removes the detailed generic type information. For example, both \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e and \u003ccode\u003eList\u0026lt;Int\u0026gt;\u003c/code\u003e end up as list of unknown type \u003ccode\u003eList\u0026lt;*\u0026gt;\u003c/code\u003e at \u003cstrong\u003eruntime\u003c/strong\u003e.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"f6b4\"\u003eOften, people say “they become \u003ccode\u003eList\u0026lt;Any\u0026gt;\u003c/code\u003e” for simplicity, but it’s more accurate to consider them as raw or wildcard types (\u003ccode\u003eList\u0026lt;?\u0026gt;\u003c/code\u003e).\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"5686\"\u003eWhile generics help you catch mistakes during compilation, they do not carry detailed type information at runtime, since that information is erased.\u003c/p\u003e\u003ch2 id=\"6a27\"\u003eType Erasure: Why does Erasure exist?\u003c/h2\u003e\u003cp id=\"aa8e\"\u003eThis concept of \u003cstrong\u003etype erasure\u003c/strong\u003e exists because of how the \u003cstrong\u003eJava Virtual Machine (JVM)\u003c/strong\u003e, which Kotlin runs on, handles generics. It was introduced for backward compatibility with older Java code that did not use generics.\u003c/p\u003e\u003cp id=\"1ac8\"\u003eTo allow newer, generic code to work with older libraries, the JVM “forgets” the specific type parameters at runtime. As a result, both \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e and \u003ccode\u003eList\u0026lt;Int\u0026gt;\u003c/code\u003e effectively become \u003ccode\u003eList\u0026lt;?\u0026gt;\u003c/code\u003e, and the JVM no longer distinguishes between them.\u003c/p\u003e\u003ch2 id=\"3eeb\"\u003eThe Consequences of Type Erasure\u003c/h2\u003e\u003cp id=\"c11b\"\u003eThis “forgetting” has some important consequences:\u003c/p\u003e\u003cul\u003e\u003cli id=\"c097\"\u003e\u003cstrong\u003eNo Runtime Type Checks:\u003c/strong\u003e You cannot check at runtime whether a list is a \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e or a \u003ccode\u003eList\u0026lt;Int\u0026gt;\u003c/code\u003e because that “type information” no longer exists.\u003c/li\u003e\u003cli id=\"25c6\"\u003e\u003cstrong\u003eCasting Limitations:\u003c/strong\u003e You cannot simply cast an object to a generic type parameter (\u003cem\u003efor example, “cast this object to type \u003c/em\u003e\u003ccode\u003e\u003cem\u003eT\u003c/em\u003e\u003c/code\u003e\u003cem\u003e”\u003c/em\u003e) because the runtime does not know what \u003ccode\u003eT\u003c/code\u003e is.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"9a29\"\u003eExample of Type Erasure Limitation\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"23f4\"\u003efun \u0026lt;T\u0026gt; printClassName(obj: T) {\u003cbr/\u003e    println(obj::class.java.name)\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    val listOfStrings: List\u0026lt;String\u0026gt; = listOf(\u0026#34;Kotlin\u0026#34;, \u0026#34;Java\u0026#34;)\u003cbr/\u003e    printClassName(listOfStrings) // The runtime only sees it as a List, not List\u0026lt;String\u0026gt;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a6b4\"\u003eWe expect \u003ccode\u003eprintClassName\u003c/code\u003e to output \u0026#34;List\u0026lt;String\u0026gt;\u0026#34;. But it outputs the raw type (\u003ccode\u003eArrayList\u003c/code\u003e or similar) because the generic type information (\u003ccode\u003e\u0026lt;String\u0026gt;\u003c/code\u003e) is lost. The function sees a generic \u003ccode\u003eList\u003c/code\u003e, not the specific \u003ccode\u003eList\u0026lt;String\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9f86\"\u003eThe Solution: \u003ccode\u003einline reified\u003c/code\u003e to the Rescue\u003c/h2\u003e\u003cp id=\"0f60\"\u003eThis is where \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e comes into play. By using these two keywords together, you can \u003cstrong\u003emaintain type information at runtime\u003c/strong\u003e, thus overcoming the limitations caused by \u003cstrong\u003etype erasure\u003c/strong\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"4ef2\"\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e This keyword tells the compiler to \u003cstrong\u003ecopy (\u003cem\u003eor “inline”\u003c/em\u003e) the entire function’s code into the location where it is called\u003c/strong\u003e. Instead of calling a separate function, the function’s body is embedded directly. This can also improve performance in some scenarios (\u003cem\u003emore on that later\u003c/em\u003e).\u003c/li\u003e\u003cli id=\"0deb\"\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e This keyword, which \u003cstrong\u003ecan only be used with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e functions\u003c/strong\u003e, ensures the type parameter becomes “real” (reified) at runtime. It instructs the compiler to keep type information for that parameter.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d249\"\u003eLet’s modify our previous example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ee4e\"\u003einline fun \u0026lt;reified T\u0026gt; printClassName(item: T) {\u003cbr/\u003e    println(T::class.java.name) // Now this works!\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    val myList = listOf(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;)\u003cbr/\u003e    printClassName(myList) // Output: java.util.ArrayList (or similar, but the important part is...)\u003cbr/\u003e    printClassName(\u0026#34;hello\u0026#34;)   // Output: java.lang.String\u003cbr/\u003e    printClassName(123)      // Output: java.lang.Integer\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"94e5\"\u003eLet’s Explore further\u003c/h2\u003e\u003cp id=\"bb2a\"\u003eTo deeply understand the mechanics and the reasons between \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e and \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e, I have prepared a real example that highlights the concept.\u003c/p\u003e\u003ch2 id=\"6624\"\u003eReal Scenario: Type-Safe Navigation in Android\u003c/h2\u003e\u003cp id=\"220a\"\u003eIn Android Navigation 2.8 and onward, there is built-in support for \u003cstrong\u003eTypeSafety\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"5c2d\"\u003eYou define in a data class the parameters to pass from one screen to another. You can also pass data classes via serialization. However, to pass custom data types, you need to specify a certain \u003ccode\u003eNavType\u003c/code\u003e, which helps the system serialize and deserialize the custom type when navigating between screens.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"43bd\"\u003e val PersonType = object : NavType\u0026lt;Person\u0026gt;(\u003cbr/\u003e      isNullableAllowed = false\u003cbr/\u003e  ) {\u003cbr/\u003e    override fun put(bundle: Bundle, key: String, value: Person) {\u003cbr/\u003e        bundle.putParcelable(key, value)\u003cbr/\u003e    }\u003cp\u003e    override fun get(bundle: Bundle, key: String): Person? {\u003cbr/\u003e        return if (Build.VERSION.SDK_INT \u0026lt; 34) {\u003cbr/\u003e            @Suppress(\u0026#34;DEPRECATION\u0026#34;)\u003cbr/\u003e            bundle.getParcelable(key)\u003cbr/\u003e        } else {\u003cbr/\u003e            bundle.getParcelable(key, Person::class.java)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun parseValue(value: String): Person {\u003cbr/\u003e        return Json.decodeFromString\u0026lt;Person\u0026gt;(value)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override fun serializeAsValue(value: Person): String {\u003cbr/\u003e        return Json.encodeToString(value)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    override val name = Person::class.java.name\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ecb4\"\u003eWith this code, you define a custom \u003ccode\u003eNavType\u003c/code\u003e for the data class \u003ccode\u003ePerson\u003c/code\u003e. Now you can pass a full \u003ccode\u003ePerson\u003c/code\u003e object as a parameter with the new navigation component.\u003c/p\u003e\u003cp id=\"7299\"\u003eBut notice how lengthy the code is. It works for one type, but if you have multiple types—like \u003ccode\u003ePerson\u003c/code\u003e and \u003ccode\u003eCar\u003c/code\u003e—duplicating this logic can lead to boilerplate and mistakes.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"38d8\"\u003eWe obviously need to replace our \u003ccode\u003ePerson\u003c/code\u003e with a type \u003ccode\u003eT\u003c/code\u003e here to get the job done so we don’t repeat all this code if we want to pass for example a \u003ccode\u003eCar\u003c/code\u003e as well.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"6147\"\u003eAttempt 1: A Generic Function (But It Fails)\u003c/h2\u003e\u003cp id=\"bb63\"\u003eWe might wrap the snippet inside a function, replacing \u003ccode\u003ePerson\u003c/code\u003e for a generic type \u003ccode\u003eT\u003c/code\u003e. That should give us the freedom to reuse the same logic for any \u003ccode\u003eParcelable\u003c/code\u003e type, instead of rewriting everything for every type.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a86a\"\u003efun \u0026lt;T : Parcelable\u0026gt; NavType.Companion.mapper(): NavType\u0026lt;T\u0026gt; {\u003cbr/\u003e    return object : NavType\u0026lt;T\u0026gt;(\u003cbr/\u003e        isNullableAllowed = false\u003cbr/\u003e    ) {\u003cbr/\u003e        override fun put(bundle: Bundle, key: String, value: T) {\u003cbr/\u003e            bundle.putParcelable(key, value)\u003cbr/\u003e        }\u003cp\u003e        override fun get(bundle: Bundle, key: String): T? {\u003cbr/\u003e            return if (Build.VERSION.SDK_INT \u0026lt; Build.VERSION_CODES.TIRAMISU) {\u003cbr/\u003e                @Suppress(\u0026#34;DEPRECATION\u0026#34;)\u003cbr/\u003e                bundle.getParcelable(key)\u003cbr/\u003e            } else {\u003cbr/\u003e                bundle.getParcelable(key, T::class.java)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        override fun parseValue(value: String): T {\u003cbr/\u003e            return Json.decodeFromString\u0026lt;T\u0026gt;(value)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        override fun serializeAsValue(value: T): String {\u003cbr/\u003e            return Json.encodeToString(value)\u003cbr/\u003e        }\u003c/p\u003e\u003cp\u003e        override val name = T::class.java.name\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9dcf\"\u003eThis seems perfect, but it does not compile. The problem is still \u003cstrong\u003etype erasure\u003c/strong\u003e. We cannot call \u003ccode\u003eT::class.java\u003c/code\u003e because the runtime does not know what \u003ccode\u003eT\u003c/code\u003e is.\u003c/p\u003e\u003ch2 id=\"98a2\"\u003eAttempt 2: Introducing \u003ccode\u003ereified\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"7dca\"\u003eThis is where \u003ccode\u003ereified\u003c/code\u003e comes in. By adding the \u003ccode\u003ereified\u003c/code\u003e keyword before \u003ccode\u003eT\u003c/code\u003e, we tell the compiler to \u003cstrong\u003epreserve the type at runtime\u003c/strong\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c8bc\"\u003eval personType = NavType.mapper\u0026lt;Person\u0026gt;()\u003cbr/\u003eval carType = NavType.mapper\u0026lt;Car\u0026gt;() \u003cp\u003efun \u0026lt;reified T : Parcelable\u0026gt; NavType.Companion.mapper(): NavType\u0026lt;T\u0026gt; { \u003cbr/\u003e  // same code here\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9302\"\u003eNow, \u003ccode\u003eT::class.java\u003c/code\u003e is valid. We can access \u003ccode\u003eT\u003c/code\u003e’s class at runtime because \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e makes \u003ccode\u003eT\u003c/code\u003e a real type in the function. But we still get a compiler error:\u003c/p\u003e\u003cp id=\"ae5f\"\u003e\u003ccode\u003e‘reified’ type parameter modifier is only allowed on inline functions\u003c/code\u003e\u003c/p\u003e\u003ch2 id=\"4c82\"\u003eAttempt 3: The Missing Piece — \u003ccode\u003einline\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"cf34\"\u003eWe are almost there. The compiler insists that \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e can only be used within \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e functions. \u003cstrong\u003eWhy?\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9026\"\u003eHere’s the key: To make \u003ccode\u003ereified\u003c/code\u003e work, the compiler needs to know the \u003cem\u003eactual\u003c/em\u003e type of \u003ccode\u003eT\u003c/code\u003e \u003cstrong\u003eat the place where the function is called\u003c/strong\u003e. It can\u0026#39;t just pass a generic \u003ccode\u003eT\u003c/code\u003e around. It needs to substitute \u003ccode\u003eT\u003c/code\u003e with \u003ccode\u003eUser\u003c/code\u003e, \u003ccode\u003eProduct\u003c/code\u003e, or whatever type we\u0026#39;re using.\u003c/p\u003e\u003cp id=\"555d\"\u003eThe \u003cstrong\u003einline\u003c/strong\u003e keyword enables this by letting the compiler \u003cstrong\u003eembed the function body directly at the call site\u003c/strong\u003e, instead of using a traditional function call.\u003c/p\u003e\u003cp id=\"a4a1\"\u003eThink of it this way: when we call \u003ccode\u003eNavType.mapper\u0026lt;Person\u0026gt;()\u003c/code\u003e, the compiler knows T is \u003ccode\u003ePerson\u003c/code\u003e. Because the function is \u003cstrong\u003einline\u003c/strong\u003e, it creates a specialized version of the function, replacing T with \u003ccode\u003ePerson\u003c/code\u003e throughout its body:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"93ab\"\u003eval personType = NavType.mapper\u0026lt;Person\u0026gt;()\u003cbr/\u003eval carType = NavType.mapper\u0026lt;Car\u0026gt;()\u003cp\u003einline fun \u0026lt;reified T : Parcelable\u0026gt; NavType.Companion.mapper(): NavType\u0026lt;T\u0026gt; { \u003cbr/\u003e  // same code here\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0241\"\u003eThis is why \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e and \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e \u003cstrong\u003emust be used together\u003c/strong\u003e. \u003ccode\u003ereified\u003c/code\u003e requires the actual type information at the call site, and \u003ccode\u003einline\u003c/code\u003e provides the mechanism to perform that substitution.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"01f2\"\u003einline reified TL;DR\u003c/h2\u003e\u003cp id=\"3e85\"\u003e\u003cstrong\u003eLet’s summarize why \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e goes hand-by-hand with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003c/p\u003e\u003cp id=\"50b0\"\u003eTo maintain the type at runtime, any \u003ccode\u003e\u003cstrong\u003eT\u003c/strong\u003e\u003c/code\u003e marked as \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e gets replaced by its concrete type at compile time, producing behind the scenes a new function in which every occurrence of \u003ccode\u003e\u003cstrong\u003eT\u003c/strong\u003e\u003c/code\u003e is replaced by concrete type.\u003c/p\u003e\u003cp id=\"a365\"\u003eThe compiler then inlines this specialized version of the function at the caller site, since \u003cstrong\u003einline\u003c/strong\u003e allows the function body to be copied and adapted with the concrete types. Without \u003cstrong\u003einline\u003c/strong\u003e, the compiler could not generate or embed this specialized function.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"19cd\"\u003einline keyword — Performance Improvements\u003c/h2\u003e\u003cp id=\"2408\"\u003e\u003ccode\u003einline\u003c/code\u003e \u003ccode\u003ereified\u003c/code\u003e provides type safety, but the \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e keyword also offers potential performance improvements.\u003c/p\u003e\u003cp id=\"1be4\"\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e places the function’s code directly where it is called, avoiding the usual overhead of a function call (like stack operations and function lookups).\u003c/p\u003e\u003cp id=\"71b3\"\u003eThis is especially helpful when working with lambdas. When you pass a lambda to a regular function, an object is created. \u003cstrong\u003eInline\u003c/strong\u003e functions avoid creating that object, which makes them much more efficient. Kotlin’s collection functions (\u003ccode\u003emap\u003c/code\u003e, \u003ccode\u003efilter\u003c/code\u003e, \u003ccode\u003eforEach\u003c/code\u003e) are \u003cstrong\u003einline\u003c/strong\u003e for this exact reason: they rely heavily on lambdas.\u003c/p\u003e\u003cp id=\"9252\"\u003eHowever, inlining also has downsides. It can grow the size of your code, especially if the function is large or used in many different places (often called \u003cstrong\u003ecode bloat\u003c/strong\u003e).\u003c/p\u003e\u003cp id=\"f203\"\u003eIn summary, other than addressing \u003ccode\u003ereified\u003c/code\u003e issues, \u003cstrong\u003einlining\u003c/strong\u003e by itself is a performance strategy, usually best for small, frequently called functions — especially those that accept lambdas. It might not be suitable for large functions or those called from many locations, since it can lead to code bloat/increased bytecode size and make your app bigger.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"0a93\"\u003eControlling Inlining: `noinline` and `crossinline`\u003c/h2\u003e\u003cp id=\"7f68\"\u003eWhile \u003ccode\u003einline\u003c/code\u003e offers significant advantages, Kotlin provides further control over the inlining process with two important modifiers: \u003ccode\u003e\u003cstrong\u003enoinline\u003c/strong\u003e\u003c/code\u003e and \u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e. These modifiers are used with lambda parameters of \u003ccode\u003einline\u003c/code\u003e functions.\u003c/p\u003e\u003ch2 id=\"b798\"\u003e\u003ccode\u003e\u003cstrong\u003enoinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e — Preventing Lambda Inlining\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"efca\"\u003eSometimes, you might want to use an \u003ccode\u003einline\u003c/code\u003e function for its performance benefits (or for \u003ccode\u003ereified\u003c/code\u003e types) but \u003cstrong\u003enot\u003c/strong\u003e inline a specific lambda parameter. This is where \u003ccode\u003enoinline\u003c/code\u003e comes in. You mark the lambda parameter with \u003ccode\u003enoinline\u003c/code\u003e to prevent it from being inlined.\u003c/p\u003e\u003cp id=\"5137\"\u003eThere are two primary reasons to use \u003ccode\u003enoinline\u003c/code\u003e:\u003c/p\u003e\u003cp id=\"9ab2\"\u003e\u003cstrong\u003e1. Passing the Lambda to Another Non-Inline Function:\u003c/strong\u003e If you need to pass the lambda to another function that is \u003cstrong\u003e\u003cem\u003enot\u003c/em\u003e\u003c/strong\u003e marked \u003ccode\u003einline\u003c/code\u003e, you \u003cstrong\u003emust\u003c/strong\u003e use \u003ccode\u003enoinline\u003c/code\u003e. If you try to pass an inlined lambda to a non-inline function, you’ll get a compiler error. The lambda needs to exist as a separate object to be passed.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"272f\"\u003e// NON inline function\u003cbr/\u003efun anotherFunction(lambda: () -\u0026gt; Unit) {\u003cbr/\u003e  lambda()\u003cbr/\u003e}\u003cp\u003e// inline function\u003cbr/\u003einline fun doSomething(first: () -\u0026gt; Unit, noinline second: () -\u0026gt; Unit) {\u003cbr/\u003e  first()                 // This lambda will be inlined\u003cbr/\u003e  anotherFunction(second) // \u0026#39;second\u0026#39; is passed as a regular lambda object (not inlined)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a23f\"\u003eIn this example, \u003ccode\u003efirst\u003c/code\u003e will be inlined as usual. \u003ccode\u003esecond\u003c/code\u003e, however, is marked \u003ccode\u003enoinline\u003c/code\u003e. This prevents its code from being copied into \u003ccode\u003edoSomething\u003c/code\u003e and allows it to be passed as a function object to \u003ccode\u003eanotherFunction\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"3ba2\"\u003e\u003cstrong\u003e2. Controlling Code Size:\u003c/strong\u003e If you have an \u003ccode\u003einline\u003c/code\u003e function with a very large lambda, inlining that lambda repeatedly could lead to significant code bloat. Using \u003ccode\u003enoinline\u003c/code\u003e prevents this.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b3f8\"\u003einline fun processData(data: List\u0026lt;String\u0026gt;, noinline largeProcessingLogic: (String) -\u0026gt; Unit) {\u003cbr/\u003e    for (item in data) {\u003cbr/\u003e        // Some small, frequently executed code that benefits from inlining\u003cbr/\u003e        if (item.isNotEmpty()) {\u003cbr/\u003e            largeProcessingLogic(item)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e    val data = listOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;e\u0026#34;)\u003c/p\u003e\u003cp\u003e    processData(data) { item -\u0026gt;\u003cbr/\u003e      // Imagine this is a VERY large lambda, with hundreds of lines\u003cbr/\u003e      // of complex logic, database calls, network requests, etc.\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9800\"\u003eWithout \u003ccode\u003enoinline\u003c/code\u003e, the entire \u003ccode\u003elargeProcessingLogic\u003c/code\u003e lambda would be copied into the loop \u003cstrong\u003e\u003cem\u003efor each call to processData\u003c/em\u003e\u003c/strong\u003e, drastically increasing the bytecode size. With \u003ccode\u003enoinline\u003c/code\u003e, only a reference to the lambda is passed, avoiding code duplication.\u003c/p\u003e\u003ch2 id=\"ff3f\"\u003ecrossinline — Managing Non-Local Returns\u003c/h2\u003e\u003cp id=\"b9b2\"\u003e\u003ccode\u003ecrossinline\u003c/code\u003e helps you control how the \u003ccode\u003ereturn\u003c/code\u003e keyword works inside lambdas passed to \u003ccode\u003einline\u003c/code\u003e functions. It makes \u003ccode\u003ereturn\u003c/code\u003e behave in a more predictable way.\u003c/p\u003e\u003cul\u003e\u003cli id=\"d4ce\"\u003e\u003cstrong\u003eNormal \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereturn\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e (in regular functions and non-inline lambdas):\u003c/strong\u003e A \u003ccode\u003ereturn\u003c/code\u003e statement exits \u003cem\u003eonly\u003c/em\u003e the lambda or function it’s directly inside.\u003c/li\u003e\u003cli id=\"b4e2\"\u003e\u003cstrong\u003eNon-Local \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereturn\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e (in \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e functions, \u003cem\u003ewithout\u003c/em\u003e \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e A \u003ccode\u003ereturn\u003c/code\u003e statement inside an inlined lambda exits the function that \u003cem\u003ecalled\u003c/em\u003e the \u003ccode\u003einline\u003c/code\u003e function. This can be surprising!\u003c/li\u003e\u003cli id=\"1641\"\u003e\u003cstrong\u003eLocal \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ereturn\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e (with \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e \u003ccode\u003ecrossinline\u003c/code\u003e \u003cem\u003eprevents\u003c/em\u003e non-local returns. A \u003ccode\u003ereturn\u003c/code\u003e inside a \u003ccode\u003ecrossinline\u003c/code\u003e lambda will only exit the \u003cem\u003elambda itself\u003c/em\u003e, just like a normal \u003ccode\u003ereturn\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"bb72\"\u003e// Example 1: Non-Local Return (without crossinline)\u003cbr/\u003einline fun doSomething(action: () -\u0026gt; Unit) {\u003cbr/\u003e    println(\u0026#34;Start doSomething\u0026#34;)\u003cbr/\u003e    action()\u003cbr/\u003e    println(\u0026#34;End doSomething\u0026#34;) // This might NOT be printed\u003cbr/\u003e}\u003cp\u003efun test1() {\u003cbr/\u003e    doSomething {\u003cbr/\u003e        println(\u0026#34;Inside lambda\u0026#34;)\u003cbr/\u003e        return // This exits test1(), NOT just the lambda!\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;This will NOT be printed\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e// Example 2: Local Return (with crossinline)\u003cbr/\u003einline fun doSomethingSafely(crossinline action: () -\u0026gt; Unit) {\u003cbr/\u003e    println(\u0026#34;Start doSomethingSafely\u0026#34;)\u003cbr/\u003e    action()\u003cbr/\u003e    println(\u0026#34;End doSomethingSafely\u0026#34;) // This WILL be printed\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun test2() {\u003cbr/\u003e    doSomethingSafely {\u003cbr/\u003e        println(\u0026#34;Inside lambda\u0026#34;)\u003cbr/\u003e        return // This exits ONLY the lambda\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;This WILL be printed\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efun main() {\u003cbr/\u003e    println(\u0026#34;Running test1:\u0026#34;)\u003cbr/\u003e    test1() // Output: Start doSomething, Inside lambda\u003cbr/\u003e    println(\u0026#34;\\nRunning test2:\u0026#34;)\u003cbr/\u003e    test2() // Output: Start doSomethingSafely, Inside lambda, End doSomethingSafely, This WILL be printed\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"606c\"\u003e\u003ccode\u003e\u003cstrong\u003etest1\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e The \u003ccode\u003ereturn\u003c/code\u003e inside the lambda exits \u003ccode\u003etest1\u003c/code\u003e completely. \u0026#34;End doSomething\u0026#34; and \u0026#34;This will NOT be printed\u0026#34; are \u003cem\u003enever\u003c/em\u003e reached.\u003c/li\u003e\u003cli id=\"2ede\"\u003e\u003ccode\u003e\u003cstrong\u003etest2\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e The \u003ccode\u003ecrossinline\u003c/code\u003e keyword \u003cem\u003eforces\u003c/em\u003e the \u003ccode\u003ereturn\u003c/code\u003e to be local. It only exits the lambda, \u003cem\u003enot\u003c/em\u003e \u003ccode\u003etest2\u003c/code\u003e. \u0026#34;End doSomethingSafely\u0026#34; and \u0026#34;This WILL be printed\u0026#34; \u003cem\u003eare\u003c/em\u003e executed.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"7ff1\"\u003e\u003cstrong\u003eCompiler Error\u003c/strong\u003e: If you try to pass a lambda marked with \u003ccode\u003ecrossinline\u003c/code\u003e to another lambda or anonymous object, you will get a compiler error.\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"80c1\"\u003e\u003cstrong\u003eUse \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e when:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"eeff\"\u003eYou want the \u003ccode\u003ereturn\u003c/code\u003e in a lambda to behave like a normal \u003ccode\u003ereturn\u003c/code\u003e (exiting only the lambda).\u003c/li\u003e\u003cli id=\"08e6\"\u003eYou are making a library, and you want to make sure users of your \u003ccode\u003einline\u003c/code\u003e function don\u0026#39;t accidentally use non-local returns, which could change the flow of their program in unexpected ways.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"33c2\"\u003e\u003cstrong\u003eSummary of Modifiers\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a8dc\"\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e Copies the function\u0026#39;s code and lambda code (by default) to the place where it\u0026#39;s called. Allows \u003ccode\u003ereturn\u003c/code\u003e in a lambda to exit the calling function (non-local return).\u003c/li\u003e\u003cli id=\"2d38\"\u003e\u003ccode\u003e\u003cstrong\u003enoinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e Prevents a specific lambda parameter from being inlined. Necessary for passing lambdas to non-inline functions.\u003c/li\u003e\u003cli id=\"0ac0\"\u003e\u003ccode\u003e\u003cstrong\u003ecrossinline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e Allows a lambda to be copied (inlined), but \u003cem\u003eforces\u003c/em\u003e \u003ccode\u003ereturn\u003c/code\u003e to only exit the lambda itself (local return).\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"5228\"\u003eLimitations and When Reflection is Necessary\u003c/h2\u003e\u003cp id=\"19d6\"\u003e\u003ccode\u003einline reified\u003c/code\u003e is a powerful tool, but it’s not a universal solution. There are specific situations where it \u003cem\u003ecannot\u003c/em\u003e be used. In these cases, reflection (or other, less common workarounds) becomes necessary.\u003c/p\u003e\u003cp id=\"bf11\"\u003eHere are some key scenarios where \u003ccode\u003einline reified\u003c/code\u003e \u003cem\u003ecannot\u003c/em\u003e be used:\u003c/p\u003e\u003col\u003e\u003cli id=\"e5f0\"\u003e\u003cstrong\u003eDynamic Type Discovery:\u003c/strong\u003e If you truly don’t know the type of an object until runtime, you can’t use \u003ccode\u003einline reified\u003c/code\u003e. \u003ccode\u003ereified\u003c/code\u003e requires the type to be known where you call the \u003ccode\u003einline\u003c/code\u003e function. \u003cem\u003eFor example, if you’re reading data from a file and the file format dictates the data type, you won’t know the type until you’ve read the file. Reflection would be needed here.\u003c/em\u003e\u003c/li\u003e\u003cli id=\"33c3\"\u003e\u003cstrong\u003eInteracting with Non-Kotlin Code (Without Known Types):\u003c/strong\u003e If you’re calling Java code (or code from other JVM languages) that doesn’t provide generic type information in a way that Kotlin can understand, you might not be able to use `reified`. \u003cem\u003eYou might need to use reflection to interact with the returned objects.\u003c/em\u003e\u003c/li\u003e\u003cli id=\"565a\"\u003e\u003cstrong\u003eInterface method with default implementation:\u003c/strong\u003e If the method with \u003ccode\u003ereified\u003c/code\u003e is declared inside an Interface with default implementation.\u003c/li\u003e\u003cli id=\"5b14\"\u003e\u003cstrong\u003eRecursive \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e functions:\u003c/strong\u003e You can’t use \u003ccode\u003einline\u003c/code\u003e with functions that call themselves (\u0026#34;recursive\u0026#34; functions). The computer copies the function\u0026#39;s code each time it\u0026#39;s used. If a function calls itself, this copying would never stop.\u003c/li\u003e\u003cli id=\"2c0c\"\u003e\u003cstrong\u003eAccessing Non-Public Members (Without \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e@PublishedApi\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e):\u003c/strong\u003e \u003ccode\u003einline\u003c/code\u003e functions can’t directly access non-public members of a class unless those members are marked with the \u003ccode\u003e@PublishedApi\u003c/code\u003e annotation.\u003c/li\u003e\u003cli id=\"d744\"\u003e\u003cstrong\u003eVariable Type Arguments:\u003c/strong\u003e You cannot use a variable as a type argument for a reified type.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"7f95\"\u003einline fun \u0026lt;reified T\u0026gt; myFun() {\u003cbr/\u003e  println(T::class.simpleName)\u003cbr/\u003e}\u003cp\u003efun \u0026lt;T\u0026gt; otherFun() {\u003cbr/\u003e   myFun\u0026lt;T\u0026gt;() // Compilation error\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f9a8\"\u003eIn the code above, we are trying to use the type variable \u003ccode\u003eT\u003c/code\u003e as a type argument. But this is not allowed.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9cfe\"\u003eReflection: The Alternative (and Its Costs)\u003c/h2\u003e\u003cp id=\"4d5f\"\u003eWhen \u003ccode\u003einline reified\u003c/code\u003e isn’t an option, \u003cstrong\u003ereflection\u003c/strong\u003e is often the fallback. Reflection allows a program to inspect and manipulate the structure and behavior of objects at runtime. This includes examining types, accessing fields, and invoking methods, even if those elements are not known at compile time.\u003c/p\u003e\u003cp id=\"f8e8\"\u003eHowever, this power comes at a cost:\u003c/p\u003e\u003cul\u003e\u003cli id=\"994e\"\u003e\u003cstrong\u003eSpeed:\u003c/strong\u003e Reflection is significantly slower than direct type access. It involves dynamic lookups and checks that add overhead.\u003c/li\u003e\u003cli id=\"25f5\"\u003e\u003cstrong\u003eType Safety:\u003c/strong\u003e Reflection doesn’t check types when you write your code. This means you might get errors when your program runs that you would normally find earlier.\u003c/li\u003e\u003cli id=\"6379\"\u003e\u003cstrong\u003eCode Complication:\u003c/strong\u003e Code that uses reflection is often longer and harder to understand.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"03eb\"\u003e\u003cstrong\u003eReflection\u003c/strong\u003e \u003cem\u003ecan\u003c/em\u003e do some of the same things as \u003ccode\u003einline reified\u003c/code\u003e, but it\u0026#39;s usually slower, less safe, and harder to use. \u003ccode\u003einline reified\u003c/code\u003e is the best way to do this in most cases where you need to know the type while the program is running.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"d972\"\u003eAnother Alternative: KClass\u003c/h2\u003e\u003cp id=\"8832\"\u003eAnother approach, particularly when you just need to know the \u003ccode\u003eClass\u003c/code\u003e of a type, is to pass a \u003ccode\u003eKClass\u003c/code\u003e object as an argument to your function. \u003ccode\u003eKClass\u003c/code\u003e is Kotlin’s representation of a class.\u003c/p\u003e\u003cp id=\"9f3d\"\u003eIt’s like a blueprint of the class, providing information about its properties, functions, and constructors. For example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cf5d\"\u003efun \u0026lt;T : Any\u0026gt; printClassName(obj: T, clazz: KClass\u0026lt;T\u0026gt;) {\u003cbr/\u003e   println(\u0026#34;The class name is: ${clazz.simpleName}\u0026#34;)\u003cbr/\u003e}\u003cp\u003efun main() {\u003cbr/\u003e  printClassName(\u0026#34;Hello\u0026#34;, String::class) // Pass String::class\u003cbr/\u003e  printClassName(123, Int::class)        // Pass Int::class\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1760\"\u003eThis works, but it adds extra code, you have to explicitly pass the \u003ccode\u003eKClass\u003c/code\u003e every time you call the function. \u003ccode\u003einline reified\u003c/code\u003e avoids this extra step because the compiler automatically inserts the type information.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"aec8\"\u003e\u003cem\u003eIt’s important to understand that \u003c/em\u003e\u003ccode\u003e\u003cstrong\u003e\u003cem\u003eKClass\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e\u003cem\u003e is not a complete replacement for \u003c/em\u003e\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003e\u003cem\u003einline reified\u003c/em\u003e\u003c/strong\u003e\u003c/code\u003e\u003cem\u003e. \u003c/em\u003e\u003ccode\u003e\u003cem\u003eKClass\u003c/em\u003e\u003c/code\u003e\u003cem\u003e provides information about a type, while \u003c/em\u003e\u003ccode\u003e\u003cem\u003einline reified\u003c/em\u003e\u003c/code\u003e\u003cem\u003e allows you to use a type as if it were concrete, even in the presence of type erasure.\u003c/em\u003e\u003c/p\u003e\u003cp id=\"7ccb\"\u003e\u003cem\u003eThey serve different, though related, purposes. \u003c/em\u003e\u003ccode\u003e\u003cem\u003einline reified\u003c/em\u003e\u003c/code\u003e\u003cem\u003e gives you more power within the function where it\u0026#39;s used.\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"6062\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"64cd\"\u003e\u003ccode\u003einline\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003e\u003ccode\u003ereified\u003c/code\u003e is a powerful feature in Kotlin that solves the problem of \u003cstrong\u003etype erasure\u003c/strong\u003e while providing performance advantages.\u003c/p\u003e\u003cp id=\"b238\"\u003eBy using \u003ccode\u003e\u003cstrong\u003einline\u003c/strong\u003e\u003c/code\u003e and \u003ccode\u003e\u003cstrong\u003ereified\u003c/strong\u003e\u003c/code\u003e together, you can write code that is generic, type-safe, and efficient. It avoids repetitive code (as in our Android Navigation example) and removes the \u003cstrong\u003ereflection\u003c/strong\u003e overhead otherwise needed to access runtime type information.\u003c/p\u003e\u003cp id=\"6cb4\"\u003eLearning how to use \u003cstrong\u003einline reified\u003c/strong\u003e effectively helps you create cleaner, more maintainable, and faster Kotlin code, whether you are developing Android apps, managing complex data, or working with Java libraries.\u003c/p\u003e\u003cp id=\"9e71\"\u003eIt is an essential tool for improving the quality and performance of your Kotlin projects.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a125\"\u003e\u003cstrong\u003eFurther Reading\u003c/strong\u003e\u003c/h2\u003e\u003ch2 id=\"bcb8\"\u003e\u003cstrong\u003eKotlin Official Documentation\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d5af\"\u003e\u003ca href=\"https://kotlinlang.org/docs/inline-functions.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eInline functions\u003c/strong\u003e\u003c/a\u003e: The official Kotlin documentation explaining inline functions, performance benefits, and how they work with lambdas and \u003ccode\u003enoinline\u003c/code\u003e/\u003ccode\u003ecrossinline\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"d529\"\u003e\u003ca href=\"https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eReified type parameters\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e:\u003c/strong\u003e Specifically focuses on reified type parameters within inline functions, detailing how they address type erasure.\u003c/li\u003e\u003cli id=\"2de0\"\u003e\u003ca href=\"https://kotlinlang.org/docs/generics.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eGenerics\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e: \u003c/strong\u003eA comprehensive overview of generics in Kotlin, essential for understanding the context of type erasure and \u003ccode\u003einline reified\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"57aa\"\u003eBlog\u003c/h2\u003e\u003cul\u003e\u003cli id=\"663c\"\u003e\u003ca href=\"https://ncorti.com/blog/noinline-and-crossline-once-for-all\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKotlin’s Noinline \u0026amp; Crossline, once for all\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e: \u003c/strong\u003eA comprehensive guide specifically on \u003ccode\u003enoinline\u003c/code\u003e and \u003ccode\u003ecrossinline\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2025-02-23T15:21:33.486Z",
  "modifiedTime": null
}
