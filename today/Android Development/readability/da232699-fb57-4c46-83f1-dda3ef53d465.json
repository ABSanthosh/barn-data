{
  "id": "da232699-fb57-4c46-83f1-dda3ef53d465",
  "title": "Compose for Web (WASM) – What and Why?",
  "link": "https://handstandsam.com/2023/09/05/compose-for-web-wasm/",
  "description": "As a former web-developer myself, I still gravitate back to browser-based UIs. They are so easy to access from anywhere, and are globally available. It’s hard to argue the utility of the amazing web platform. Compose for Web (WASM) is the latest technology in Kotlin Multiplatform and I’m pretty bullish about it. In this post […]",
  "author": "Sam Edwards",
  "published": "Wed, 06 Sep 2023 02:43:11 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Updates"
  ],
  "byline": "Sam Edwards",
  "length": 6234,
  "excerpt": "As a former web-developer myself, I still gravitate back to browser-based UIs. They are so easy to access from anywhere, and are globally available. It’s hard to argue the utility of the amazing web platform. Compose for Web (WASM) is the latest technology in Kotlin Multiplatform and I’m pretty bullish about it.",
  "siteName": "",
  "favicon": "",
  "text": "As a former web-developer myself, I still gravitate back to browser-based UIs. They are so easy to access from anywhere, and are globally available. It’s hard to argue the utility of the amazing web platform. Compose for Web (WASM) is the latest technology in Kotlin Multiplatform and I’m pretty bullish about it. In this post I’ll take you through what it is and why I think it’s going to be pretty big. My Past Explorations into Kotlin + Web I have previously dabbled in Kotlin Multiplatform for JavaScript and Compose HTML in my ShoppingApp project. I find them both very exciting, but I’ve only seen them useful in limited use cases. I’ve started digging to Compose for Web (WASM), but wanted to give some context to start as there are similarly named things and disambiguation is needed. Kotlin/JS This JavaScript (Kotlin/JS) compilation target is here to stay, and is useful not only in the browser, but for backends using Node.js. This technology allows code to be compiled to JavaScript, but doesn’t have any concept of UI itself. Kotlin/JS is great for complex business logic so it doesn’t have to be re-written and tested in multiple languages. Kotlin/JS is not so great at size (KBs), and therefore a hard sell to use in Web UIs. I pitched some password validation rule logic to a set of Angular web devs and was told that the JavaScript that was generated was over 10x the size it would be if they wrote it in typescript. That was fair, but I can see the argument tipping the other way if there is really complex business logic. At that point, the consistency and maintainence costs can be more important than page load time (which should get better as time goes on). Note: The reason why the generated JavaScript is so large is because it needs to bring along the Kotlin Standard Library (stdlib), implemented in JS. That is an upfront cost though, so adding additional logic should be fairly linear. Compose HTML (Previously “Compose for Web”) Compose HTML allows the compose runtime to render HTML elements. While very cool from a technical standpoint, the marketing behind this has fizzled out (rightfully so) to try and make room for “Compose for Web” (WASM), and create less ambiguity. You can see in this JetBrains blog post first announcing it where it was branded “Compose for Web”, but is now specifically named Compose HTML to disambiguate. This reminds me of Mosaic, which allows you to leverage the Compose runtime to create terminal apps. Both are very cool from a technical standpoint, and allow you to leverage the Compose runtime, but you have to bind to platform specific UI elements. Because of this additional work, the developer friction will most likely prevent broader adoption. Convergence on Compose Multiplatform UI Jetpack Compose for Android had incredible investment for multiple years and created really solid foundational UI components. The goal is to reuse code that is already written for Jetpack Compose, and bring it to other platforms. That’s why JetBrains uses the same package and classnames in compose-multiplatform. These implementations of compose-multiplatform enable Kotlin Multiplatform UI for Desktop, iOS and now Web (WASM). These additional (non-Android) multiplatform implementations render to a 2 Dimensional (2D) canvas using SKIA (similar technique used by Flutter). Note: As of very recently, Flutter now leverages the Impeller as the 2D rendering for better performance. Because a developer can now code against a single set of Compose APIs that can render UIs across multiple platforms, the value is there to start seeing more use cases for Compose Multiplatform UI. Compose for Web (WASM) leverages Web-Assembly (WASM) to run native binaries in the browser. For browser based UIs, this is a very real future as it’s already supported in Chrome, Safari, Firefox and more. For myself (someone who does Compose UI development for Android), Compose for Web allows me to re-use my existing skills, and create UIs that can be shared via a URL. Not only that, but it is code that will be familiar to other developers on my team, and therefore make it more approachable and have better chance for success. This Compose for Web technology is current incubating, but is really powerful. Run the samples and check it out, but there are animations and images, and gradients. It’s beautiful. Getting a mobile developer to learn React requires a full paradigm shift and isn’t scalable. The same could be said about shifting to coding in Swift and iOS. Being able to create a consistent set of solutions on a single technology will drive adoption. Why Compose for Web (WASM)? I think this will be big for Kotlin developers to get their code running in a browser. I am currently building developer tools for small projects, and making them accessible to everyone in an organization is so much easier to do via a web url instead of having to download an APK and run it. I have always wanted to share a design system library with others in an organization via a URL. That friction for installing an application is just so cumbersome. Additionally, we can start to do many test/run cycles in the browser if that test/debug cycle story gets better. I already do that today with Compose for Desktop as it removes the need for a device at all. Android Studio’s Compose previews work great in some use cases, but other times it is nicer to run a bit more code via Compose for Desktop. With WASM, we will get native performance with this technology, and soon be able to access system level APIs to make very powerful applications. Next: Under The Surface of Compose for Web (WASM) I want to dive deeper into Compose for Web (WASM). I’ve been running the samples locally and dived into the generated html, js and wasm files generated by the Compose for Web implementation. As I learn more I’ll share what I learn. Other related articles I found after writing this: The huge potential of Kotlin/Wasm https://news.ycombinator.com/item?id=34779746 https://www.reddit.com/r/Kotlin/comments/12nar6u/on_the_compose_html_rebranding_tldr_everything_is/ To be continued…",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eAs a former web-developer myself, I still gravitate back to browser-based UIs.  They are so easy to access from anywhere, and are globally available.  It’s hard to argue the utility of the amazing web platform. \u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples\"\u003eCompose for Web (WASM)\u003c/a\u003e is the latest technology in Kotlin Multiplatform and I’m pretty bullish about it.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this post I’ll take you through what it is and why I think it’s going to be pretty big.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMy Past Explorations into Kotlin + Web\u003c/h2\u003e\n\n\n\n\u003cp\u003eI have previously dabbled in \u003ca href=\"https://handstandsam.com/2021/03/13/intro-to-kotlin-multiplatform-javascript/\"\u003eKotlin Multiplatform for JavaScript\u003c/a\u003e and \u003ca href=\"https://github.com/handstandsam/ShoppingApp/blob/4c3ae6d93fda223581b546c062c09e22e40be53e/multiplatform/src/jsMain/kotlin/Main.kt\"\u003eCompose HTML in my ShoppingApp project\u003c/a\u003e. I find them both very exciting, but I’ve only seen them useful in limited use cases.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ve started digging to \u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples\"\u003eCompose for Web (WASM)\u003c/a\u003e, but wanted to give some context to start as there are similarly named things and disambiguation is needed.\u003c/p\u003e\n\n\n\n\u003ch3\u003eKotlin/JS\u003c/h3\u003e\n\n\n\n\u003cp\u003eThis \u003ca href=\"https://kotlinlang.org/docs/js-project-setup.html\"\u003eJavaScript (Kotlin/JS) compilation target\u003c/a\u003e is here to stay, and is useful not only in the browser, but for backends using Node.js.  This technology allows code to be compiled to JavaScript, but doesn’t have any concept of UI itself.\u003c/p\u003e\n\n\n\n\u003cp\u003eKotlin/JS is great for complex business logic so it doesn’t have to be re-written and tested in multiple languages.\u003c/p\u003e\n\n\n\n\u003cp\u003eKotlin/JS is not so great at size (KBs), and therefore a hard sell to use in Web UIs.  I pitched some password validation rule logic to a set of Angular web devs and was told that the JavaScript that was generated was over 10x the size it would be if they wrote it in typescript.  That was fair, but I can see the argument tipping the other way if there is really complex business logic.  At that point, the consistency and maintainence costs can be more important than page load time (which should get better as time goes on).  Note: The reason why the generated JavaScript is so large is because it needs to bring along the Kotlin Standard Library (stdlib), implemented in JS.  That is an upfront cost though, so adding additional logic should be fairly linear.\u003c/p\u003e\n\n\n\n\u003ch3\u003eCompose HTML (Previously “Compose for Web”)\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/JetBrains/compose-multiplatform/tree/eb124feb4bc3536a00388e20c4a66e680400c5fe/tutorials/HTML/Getting_Started\"\u003eCompose HTML\u003c/a\u003e allows the compose runtime to render HTML elements.  While very cool from a technical standpoint, the marketing behind this has fizzled out (rightfully so) to try and make room for “\u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples/tree/dda11c44f3edfe3a9dac761633d0ade95f07b67f/compose-imageviewer#compose-multiplatform-for-web\"\u003eCompose for Web\u003c/a\u003e” (WASM), and create less ambiguity.  You can see in this \u003ca href=\"https://blog.jetbrains.com/kotlin/2021/05/technology-preview-jetpack-compose-for-web/\"\u003eJetBrains blog post first announcing it where it was branded “Compose for Web”\u003c/a\u003e, but is now specifically named Compose HTML to disambiguate.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis reminds me of \u003ca href=\"https://github.com/JakeWharton/mosaic\"\u003eMosaic\u003c/a\u003e, which allows you to leverage the Compose runtime to create terminal apps.\u003c/p\u003e\n\n\n\n\u003cp\u003eBoth are very cool from a technical standpoint, and allow you to leverage the Compose runtime, but you have to bind to platform specific UI elements.  Because of this additional work, the developer friction will most likely prevent broader adoption.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConvergence on Compose Multiplatform UI\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://developer.android.com/jetpack/compose\"\u003eJetpack Compose\u003c/a\u003e for Android had incredible investment for multiple years and created really solid foundational UI components.  The goal is to reuse code that is already written for Jetpack Compose, and bring it to other platforms.  That’s why JetBrains uses the same package and classnames in \u003ca href=\"https://github.com/JetBrains/compose-multiplatform\"\u003ecompose-multiplatform\u003c/a\u003e.  These implementations of compose-multiplatform enable Kotlin Multiplatform UI for Desktop, iOS and now Web (WASM).\u003c/p\u003e\n\n\n\n\u003cp\u003eThese additional (non-Android) multiplatform implementations render to a 2 Dimensional (2D) canvas using \u003ca href=\"https://skia.org/\"\u003eSKIA\u003c/a\u003e (similar technique used by \u003ca href=\"https://flutter.dev/\"\u003eFlutter\u003c/a\u003e).  Note: As of very recently, \u003ca href=\"https://docs.flutter.dev/perf/impeller\"\u003eFlutter now leverages the Impeller\u003c/a\u003e as the 2D rendering for better performance.\u003c/p\u003e\n\n\n\n\u003cp\u003eBecause a developer can now code against a single set of Compose APIs that can render UIs across multiple platforms, the value is there to start seeing more use cases for Compose Multiplatform UI.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples\"\u003eCompose for Web (WASM)\u003c/a\u003e leverages \u003ca href=\"https://webassembly.org/\"\u003eWeb-Assembly (WASM)\u003c/a\u003e to run native binaries in the browser.  For browser based UIs, this is a very real future as it’s already supported in Chrome, Safari, Firefox and more.  For myself (someone who does Compose UI development for Android), Compose for Web allows me to re-use my existing skills, and create UIs that can be shared via a URL.  Not only that, but it is code that will be familiar to other developers on my team, and therefore make it more approachable and have better chance for success.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis Compose for Web technology is current incubating, but is really powerful.  Run \u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples\"\u003ethe samples\u003c/a\u003e and check it out, but there are animations and images, and gradients.  It’s beautiful.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples/tree/main/compose-jetsnack\"\u003e\u003cimg fetchpriority=\"high\" decoding=\"async\" width=\"1024\" height=\"852\" src=\"https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-1024x852.png\" alt=\"\" srcset=\"https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-1024x852.png 1024w, https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-300x250.png 300w, https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-768x639.png 768w, https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-1536x1278.png 1536w, https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-2048x1705.png 2048w, https://handstandsam.com/wp-content/uploads/2023/09/Screenshot-2023-09-05-at-10.42.47-PM-700x583.png 700w\" sizes=\"(max-width: 1024px) 100vw, 1024px\"/\u003e\u003c/a\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eGetting a mobile developer to learn \u003ca href=\"https://react.dev/\"\u003eReact\u003c/a\u003e requires a full paradigm shift and isn’t scalable.  The same could be said about shifting to coding in Swift and iOS.  Being able to create a consistent set of solutions on a single technology will drive adoption.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy Compose for Web (WASM)?\u003c/h2\u003e\n\n\n\n\u003cp\u003eI think this will be big for Kotlin developers to get their code running in a browser.  I am currently building developer tools for small projects, and making them accessible to everyone in an organization is so much easier to do via a web url instead of having to download an APK and run it.\u003c/p\u003e\n\n\n\n\u003cp\u003eI have always wanted to share a design system library with others in an organization via a URL.  That friction for installing an application is just so cumbersome.\u003c/p\u003e\n\n\n\n\u003cp\u003eAdditionally, we can start to do many test/run cycles in the browser if that test/debug cycle story gets better.  I already do that today with Compose for Desktop as it removes the need for a device at all.  Android Studio’s Compose previews work great in some use cases, but other times it is nicer to run a bit more code via Compose for Desktop.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith WASM, we will get native performance with this technology, and soon be able to access system level APIs to make very powerful applications.\u003c/p\u003e\n\n\n\n\u003ch2\u003eNext: Under The Surface of Compose for Web (WASM)\u003c/h2\u003e\n\n\n\n\u003cp\u003eI want to dive deeper into Compose for Web (WASM).  I’ve been running \u003ca href=\"https://github.com/Kotlin/kotlin-wasm-examples\"\u003ethe samples\u003c/a\u003e locally and dived into the generated html, js and wasm files generated by the Compose for Web implementation.  As I learn more I’ll share what I learn.\u003c/p\u003e\n\n\n\n\u003cp\u003eOther related articles I found after writing this:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://seb.deleuze.fr/the-huge-potential-of-kotlin-wasm/\"\u003eThe huge potential of Kotlin/Wasm\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://news.ycombinator.com/item?id=34779746\"\u003ehttps://news.ycombinator.com/item?id=34779746\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.reddit.com/r/Kotlin/comments/12nar6u/on_the_compose_html_rebranding_tldr_everything_is/\"\u003ehttps://www.reddit.com/r/Kotlin/comments/12nar6u/on_the_compose_html_rebranding_tldr_everything_is/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eTo be continued…\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
