{
  "id": "3db0f74a-01ce-48b0-b1df-fa9eab33c950",
  "title": "Optimizing Your Kotlin Build",
  "link": "https://www.zacsweers.dev/optimizing-your-kotlin-build/",
  "description": "Kotlin build times are often slow, this is a laundry list of common issues and what you can or can't do about them.",
  "author": "Zac Sweers",
  "published": "Fri, 23 Jul 2021 05:12:24 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Kotlin",
    "Gradle",
    "Build Performance",
    "Kapt"
  ],
  "byline": "Zac Sweers",
  "length": 11546,
  "excerpt": "Kotlin build times are often slow, this is a laundry list of common issues and what you can or can't do about them.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "23 Jul 2021 • 7 min read Kotlin build times are often slow, this is a laundry list of common issues and what you can or can't do about them. An actual white whale Kotlin, strictly speaking, is awesome. Kotlin build times, strictly speaking, are not awesome. While many developers have weighed these and concluded the build times are worth it, it doesn't change the fact that they're paying this cost.There are promising changes coming down the pipeline, but the unfortunate reality is that Kotlin builds today are often slow for avoidable reasons. Some are Gradle issues, some are Kotlin issues. This post is intended to detail a number of common pitfalls to be aware of and what you can do about them.TL;DR: Modularize, ensure every project is a Kotlin project with at least one Kotlin source file, help test KSP now and Kotlin FIR later.Disclaimer: Usage of the word \"broken\" below means different things to different people, so substitute it with whatever word you think suits the described issue best. \"unexpected\", \"unreliable\", \"actually this a feature request\", \"source of pain\", \"literally worse than my ex\", etc.Build CacheOne of Gradle's main tools for improving build times is build caching. Build caching is the act of caching task outputs and reusing them if inputs to the task have not changed. It can be enabled for local builds (where the cache is located in ~/.gradle) via org.gradle.caching=true Gradle property and can be enabled remotely for sharing cached builds across multiple workspaces (CI, developer machines, etc).When it works, it's great! When it doesn't, it's frustrating at best (cache misses) and a major problem at worst (incorrect/corrupt cache entries).If you use the Wire Gradle plugin, it breaks remote build caching because it uses absolute paths. Avoid putting this on hot build paths. There are likely other Kotlin-generating plugins with similar issues. square/wire#1859.Edit 1: this is fixed in its next release now.Edit 2: There's another issue! square/wire#2006Kotlin often breaks remote build caching because it uses absolute paths in some places. KT-43686 (just fixed in Kotlin 1.5.20!)Kotlin build cache entries often break incremental compilation. KT-34862Gradle build cache entries can only be used within the same major JDK version. This means that two builds targeting JDK 8 but built with JDK 8 and 11 respectively will produce incompatible cache entries. This applies to JavaCompile tasks as well. Note that you can build Kotlin all the way up to the (at the time of writing) current JDK of 16, but you may need some extra Gradle daemon JVM args to make it work.It's worth noting that the local cache also breaks in the above cases if you have multiple repo clones in different locations, as the absolute paths fail to match in those places too.There are a number of people that have deduced that disabling (remote) build cache for Kotlin compile tasks is a net-gain for them because incremental builds are more reliable as a result. See the discussion on KT-34862 for more details.Incremental CompilationIf you have any pure Java projects, they will break incremental compilation in every project that depends on them, directly or transitively. To resolve this, you should add a simple private unused Kotlin file in those projects to ensure kotlinc generates incremental data. This applies to resources-only projects too, as they produce effectively a \"Java-only\" project with their R.java/R.jar files and possibly generated ViewBinding files. KT-30980 KT-38622If any annotation processors generate non-deterministic outputs, this will break build caching. Most common ones take care not to do this, but it's worth double checking that one random one someone added from jitpack once. A classic example is ordering mismatches or nondeterministic names.Non-incremental annotation processing, while still compatible with \"incremental\" IC, will obviously slow down your build. Kapt will verbosely warn about these processors in recent versions of Kotlin.Any resource \"ABI\" change (new resource, removed, etc), is a breaking ABI change to code too and kotlinc will recompile non-incrementally. KT-40772Running clean will wipe incremental compilation data and you should avoid running this when possible. Otherwise the next build will be non-incremental and you won't restore incremental builds until after.You can find a detailed writeup on future needs for improving incremental compilation, caching, and current issues with both in KT-40184.Task ConfigurationGradle AbstractCompile tasks (i.e. KotlinCompile) are sensitive to classpath jar ordering. Even if you have distinct jars A, B, and C on your classpath for a KotlinCompile task, it will be invalidated if their order on the classpath changes. You can see this in a Gradle build scan. This is the one that burns our repo the most. gradle/gradle#15626If adding freeCompilerArgs in a KotlinCompile task, be sure to add to the existing list and don't replace it. Otherwise you may accidentally replace/clear existing arguments. JetBrains is hoping to improve this in Kotlin 1.6. KT-41985KotlinCompile tasks inherit Gradle's source/target compatibility properties but doesn't use them. They're still used by Gradle as inputs though, so it's useful to set them to something like \"unused\". KT-32805KaptWithoutKotlincTask eagerly resolves dependencies during construction/configuration. KT-47853Wire's Gradle plugin also eagerly resolves dependencies during configuration time. square/wire#1637KaptKapt is highly susceptible to classpath changes. This applies even if they are implementation dependencies of upstream dependencies, so it's better to avoid transitive dependencies where possible (i.e. split into api/impl projects, only depend on api). Anything that participates in stub generation can affect its incrementalism.Kapt does not support multiple processing rounds for generated Kotlin code. Only Java code, as it's handed off to javac. KT-41064Kapt runs its tasks on all configurations that it registers, including both main and test source sets. This means kapt may be running on your tests even if it doesn't need to. More here. Edit: this was just fixed in 1.5.20 via KT-24533FutureMost of the issues linked above have some plans for eventual fixing. In particular, Google engineers (namely Ivan Gavrilović) have contributed a lot of Kapt fixes.KSP is a new tool from Google in the pipeline that aims to supplant Kapt with promises of improved performance, support for multiple rounds, no stub generation, and is actively developed/maintained. If you use Room or Moshi, please give it a try in your project and help test it with moshi-ksp or Room 2.3.0-beta02 (or later). Dagger is actively working on adding KSP support as well using the same shared infrastructure as Room's implementation.Kotlin needs a performant compilation avoidance mechanism, which can also support better build cache hit rate and incremental compilation after a cache hit. This will also help when Android resources are modified.Kotlin FIR is the eventual new frontend compiler, offering significant compilation speed improvements (currently ~2-4x faster). It will potentially be available for testing later this year, so consider using shadow jobs to help test it when that happens.Namespaced resources (i.e. android.nonTransitiveRClass) can help avoid breaking IC when resources are modified in some cases (namely javac) (KT-40772) but needs help from compilation avoidance to better support Kotlin.JetBrains hopes to improve compilation avoidance and remote caching in Kotlin 1.6 by moving away from history files (which can't be relocated) and moving from producer-side history storing to consumer-side. They are also hoping to make IC indifferent to classpath jar ordering, which would hopefully avoid gradle/gradle#15626.Configuration Caching is an experimental new feature in Gradle to effectively cache configuration and allow for nearly-instant execution (i.e. tasks start executing almost immediately after you invoke the Gradle command). The plugin community is slowly catching up, but Kotlin should hopefully support this in 1.5.30 assuming no more issues (please help test 1.5.30-M1!).Supplementary tools/patternsModularization. Incremental compilation will always be slower than not compiling at all. Split up monolithic subprojects and avoid build bottlenecks.Anvil is a compiler plugin from Square that can, on top of its special dagger complementing features, replace Kapt in simple projects only using dagger to generate factories.Anvil, Kapt, and KSP are all built on top of something called AnalysisHandlerExtension, which is something you could build your own plugins on too if you don't want to go all the way down to the IR layer. Anvil is probably the simplest example to look at for this.Some annotation processors offer functionally equivalent reflection implementations, such as Moshi. For these cases, you could (at the cost of build cache) speed up local builds by using reflection in debug builds and kapt only on CI and prod builds.In the event of a bad cache entry, you can rebuild with --rerun-tasks to force task re-runs and populate new cache entries.Nuclear option: make all developers on your team + CI clone the repo into the exact same path to avoid remote build cache issues. Horribly inflexible, but honestly not terrible in practice.What about Bazel/Buck/Pants/etc?Your mileage may vary, but it's probably slower. There's no notion of IC for Bazel-like build systems and Kotlin relies heavily on IC to smoothen over its lack of better compilation avoidance. Bazel-like builds may handle simple compilation avoidance better in some cases though.ConclusionsSome of it is on Kotlin for often allowing critical build tools like Kapt to fall behind, some of it is on Gradle for having legacy APIs that regularly invite you to do the wrong thing (I hope they'll consider a progressive mode or more aggressive deprecation policy).The easiest way to test for caching issues is to:Run the same build twice with --scan and see which tasks weren't cached.After you've resolved #1, have two project clones in different locations and run identical builds with --scan, then compare them to see which tasks weren't cached.You can find more common caching problems on Gradle's docs here.The easiest way to test for IC issues is to run a Gradle build with --debug and grep for [IC] to log detailed incremental compilation data about all this from kotlinc. It's noisy so better to pipe it to a file and search in a text editor of your choice.Edit: @atsvetkv pointed me at the following Gradle properties that will be less noisy for debugging IC issues and getting metrics!# gradle.properties for debugging kotlin.build.report.enable=true kotlin.build.report.verbose=true # gradle property for metrics kotlin.build.report.metrics=trueMy possibly controversial 2¢: You should take one pass at cleaning up IC issues in your project, then focus on modularizing in the long run rather than rely on IC. Simple* compilation avoidance will win every day of the week and no other investment will yield as significant of results or be as broadly applicable. Incremental compilation is and always will be the white whale of Gradle and Kotlin build performance.Special thanks to Nelson, Ivan, Eugene, and Tony for reviewing this.*I define simple compilation avoidance as just avoiding project dependencies. There is also \"true\", ABI-based compilation avoidance discussed above but not yet available.",
  "image": "https://images.unsplash.com/photo-1512330905118-bab4c9f0d29a?crop=entropy\u0026cs=tinysrgb\u0026fit=max\u0026fm=jpg\u0026ixid=MXwxMTc3M3wwfDF8c2VhcmNofDZ8fHdoaXRlJTIwd2hhbGV8ZW58MHx8fA\u0026ixlib=rb-1.2.1\u0026q=80\u0026w=2000",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003e\u003cspan\u003e23 Jul 2021\u003c/span\u003e\n    \u003ci\u003e•\u003c/i\u003e\n    \u003cspan\u003e7 min read\u003c/span\u003e\n  \u003c/p\u003e\n  \n    \u003cp\u003eKotlin build times are often slow, this is a laundry list of common issues and what you can or can\u0026#39;t do about them.\u003c/p\u003e\n    \n    \u003cp\u003e\u003cimg src=\"https://images.unsplash.com/photo-1512330905118-bab4c9f0d29a?crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;fm=webp\u0026amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDZ8fHdoaXRlJTIwd2hhbGV8ZW58MHx8fA\u0026amp;ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;w=180\" data-src=\"https://images.unsplash.com/photo-1512330905118-bab4c9f0d29a?crop=entropy\u0026amp;cs=tinysrgb\u0026amp;fit=max\u0026amp;fm=webp\u0026amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDZ8fHdoaXRlJTIwd2hhbGV8ZW58MHx8fA\u0026amp;ixlib=rb-1.2.1\u0026amp;q=80\u0026amp;w=1200\" alt=\"A beluga whale, which is white.\"/\u003e\n\n    \u003c/p\u003e\n    \u003cfigcaption\u003eAn actual white whale\u003c/figcaption\u003e\n\u003c/div\u003e\u003cdiv\u003e\n    \u003cp\u003eKotlin, strictly speaking, is awesome. Kotlin build times, strictly speaking, are \u003cem\u003enot\u003c/em\u003e awesome. While many developers have weighed these and concluded the build times are worth it, it doesn\u0026#39;t change the fact that they\u0026#39;re paying this cost.\u003c/p\u003e\u003cp\u003eThere are promising changes coming down the pipeline, but the unfortunate reality is that Kotlin builds today are often slow for avoidable reasons. Some are Gradle issues, some are Kotlin issues. This post is intended to detail a number of common pitfalls to be aware of and what you can do about them.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTL;DR: \u003c/strong\u003eModularize, ensure every project is a Kotlin project with at least one Kotlin source file, help test KSP now and Kotlin FIR later.\u003c/p\u003e\u003chr/\u003e\u003cblockquote\u003eDisclaimer: Usage of the word \u0026#34;broken\u0026#34; below means different things to different people, so substitute it with whatever word you think suits the described issue best. \u0026#34;unexpected\u0026#34;, \u0026#34;unreliable\u0026#34;, \u0026#34;actually this a feature request\u0026#34;, \u0026#34;source of pain\u0026#34;, \u0026#34;literally worse than my ex\u0026#34;, etc.\u003c/blockquote\u003e\u003chr/\u003e\u003ch3 id=\"build-cache\"\u003eBuild Cache\u003c/h3\u003e\u003cp\u003eOne of Gradle\u0026#39;s main tools for improving build times is build caching. Build caching is the act of caching task outputs and reusing them if inputs to the task have not changed. It can be \u003ca href=\"https://docs.gradle.org/current/userguide/build_cache.html?ref=zacsweers.dev#sec:build_cache_enable\"\u003eenabled\u003c/a\u003e for local builds (where the cache is located in \u003ccode\u003e~/.gradle\u003c/code\u003e) via \u003ccode\u003eorg.gradle.caching=true\u003c/code\u003e\u003cstrong\u003e \u003c/strong\u003eGradle property and can be enabled remotely for sharing cached builds across multiple workspaces (CI, developer machines, etc).\u003c/p\u003e\u003cp\u003eWhen it works, it\u0026#39;s great! When it doesn\u0026#39;t, it\u0026#39;s frustrating at best (cache misses) and a major problem at worst (incorrect/corrupt cache entries).\u003c/p\u003e\u003cul\u003e\u003cli\u003eIf you use the Wire Gradle plugin, it breaks remote build caching because it uses absolute paths. Avoid putting this on hot build paths. There are likely other Kotlin-generating plugins with similar issues. \u003ca href=\"https://github.com/square/wire/issues/1859?ref=zacsweers.dev\"\u003esquare/wire#1859\u003c/a\u003e.\u003cbr/\u003e\u003cem\u003eEdit 1: this is fixed in its next release now.\u003c/em\u003e\u003cbr/\u003e\u003cem\u003eEdit 2: There\u0026#39;s another issue! \u003c/em\u003e\u003ca href=\"https://github.com/square/wire/issues/2006?ref=zacsweers.dev\"\u003esquare/wire#2006\u003c/a\u003e\u003c/li\u003e\u003cli\u003eKotlin often breaks remote build caching because it uses absolute paths in some places. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-43686?ref=zacsweers.dev\"\u003eKT-43686\u003c/a\u003e (just fixed in Kotlin 1.5.20!)\u003c/li\u003e\u003cli\u003eKotlin build cache entries often break incremental compilation. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-34862?ref=zacsweers.dev\"\u003eKT-34862\u003c/a\u003e\u003c/li\u003e\u003cli\u003eGradle build cache entries can only be used within the same major JDK version. This means that two builds targeting JDK 8 but built with JDK 8 and 11 respectively will produce incompatible cache entries. This applies to \u003ccode\u003eJavaCompile\u003c/code\u003e tasks as well. Note that you \u003cem\u003ecan\u003c/em\u003e build Kotlin all the way up to the (at the time of writing) current JDK of 16, but you may need some extra \u003ca href=\"https://github.com/ZacSweers/MoshiX/blob/main/gradle.properties?ref=zacsweers.dev#L21-L33\"\u003eGradle daemon JVM args \u003c/a\u003eto make it work.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt\u0026#39;s worth noting that the local cache also breaks in the above cases if you have multiple repo clones in different locations, as the absolute paths fail to match in those places too.\u003c/p\u003e\u003cp\u003eThere are a number of people that have deduced that disabling (remote) build cache for Kotlin compile tasks is a net-gain for them because incremental builds are more reliable as a result. See the discussion on \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-34862?ref=zacsweers.dev\"\u003eKT-34862\u003c/a\u003e for more details.\u003c/p\u003e\u003ch3 id=\"incremental-compilation\"\u003eIncremental Compilation\u003c/h3\u003e\u003cul\u003e\u003cli\u003eIf you have any pure Java projects, they will break incremental compilation in \u003cem\u003e\u003cstrong\u003eevery project that depends on them\u003c/strong\u003e\u003c/em\u003e, directly or transitively. To resolve this, you should add a simple private unused Kotlin file in those projects to ensure \u003ccode\u003ekotlinc\u003c/code\u003e generates incremental data. This applies to resources-only projects too, as they produce effectively a \u0026#34;Java-only\u0026#34; project with their \u003ccode\u003eR.java\u003c/code\u003e/\u003ccode\u003eR.jar\u003c/code\u003e files and possibly generated ViewBinding files. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-30980?ref=zacsweers.dev\"\u003eKT-30980\u003c/a\u003e \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-38622?ref=zacsweers.dev\"\u003eKT-38622\u003c/a\u003e\u003c/li\u003e\u003cli\u003eIf any annotation processors generate non-deterministic outputs, this will break build caching. Most common ones take care not to do this, but it\u0026#39;s worth double checking that one random one someone added from jitpack once. A classic example is ordering mismatches or nondeterministic names.\u003c/li\u003e\u003cli\u003eNon-incremental annotation processing, while still compatible with \u0026#34;incremental\u0026#34; IC, will obviously slow down your build. Kapt will verbosely warn about these processors in recent versions of Kotlin.\u003c/li\u003e\u003cli\u003e\u003cem\u003eAny\u003c/em\u003e resource \u0026#34;ABI\u0026#34; change (new resource, removed, etc), is a breaking ABI change to code too and \u003ccode\u003ekotlinc\u003c/code\u003e will recompile non-incrementally. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-40772?ref=zacsweers.dev\"\u003eKT-40772\u003c/a\u003e\u003c/li\u003e\u003cli\u003eRunning \u003ccode\u003eclean\u003c/code\u003e will wipe incremental compilation data and you should avoid running this when possible. Otherwise the next build will be non-incremental and you won\u0026#39;t restore incremental builds until after.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYou can find a detailed writeup on future needs for improving incremental compilation, caching, and current issues with both in \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-40184?ref=zacsweers.dev\"\u003eKT-40184\u003c/a\u003e.\u003c/p\u003e\u003ch3 id=\"task-configuration\"\u003eTask Configuration\u003c/h3\u003e\u003cul\u003e\u003cli\u003eGradle \u003ccode\u003eAbstractCompile\u003c/code\u003e tasks (i.e. \u003ccode\u003eKotlinCompile\u003c/code\u003e) are sensitive to classpath jar ordering. Even if you have distinct jars A, B, and C on your classpath for a \u003ccode\u003eKotlinCompile\u003c/code\u003e task, it will be invalidated if their \u003cem\u003eorder\u003c/em\u003e on the classpath changes. You can see this in a Gradle build scan. This is the one that burns our repo the most. \u003ca href=\"https://github.com/gradle/gradle/issues/15626?ref=zacsweers.dev\"\u003egradle/gradle#15626\u003c/a\u003e\u003c/li\u003e\u003cli\u003eIf adding \u003ccode\u003efreeCompilerArgs\u003c/code\u003e in a \u003ccode\u003eKotlinCompile\u003c/code\u003e task, be sure to \u003cem\u003eadd\u003c/em\u003e to the existing list and don\u0026#39;t replace it. Otherwise you may accidentally replace/clear existing arguments. JetBrains is hoping to improve this in Kotlin 1.6. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-41985?ref=zacsweers.dev\"\u003eKT-41985\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003eKotlinCompile\u003c/code\u003e tasks inherit Gradle\u0026#39;s source/target compatibility properties but doesn\u0026#39;t use them. They\u0026#39;re still used by Gradle as inputs though, so it\u0026#39;s useful to set them to something like \u0026#34;unused\u0026#34;. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-32805?ref=zacsweers.dev\"\u003eKT-32805\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003eKaptWithoutKotlincTask\u003c/code\u003e eagerly resolves dependencies during construction/configuration. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-47853?ref=zacsweers.dev\"\u003eKT-47853\u003c/a\u003e\u003c/li\u003e\u003cli\u003eWire\u0026#39;s Gradle plugin also eagerly resolves dependencies during configuration time. \u003ca href=\"https://github.com/square/wire/issues/1637?ref=zacsweers.dev\"\u003esquare/wire#1637\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"kapt\"\u003eKapt\u003c/h3\u003e\u003cul\u003e\u003cli\u003eKapt is \u003cem\u003ehighly\u003c/em\u003e susceptible to classpath changes. This applies even if they are \u003ccode\u003eimplementation\u003c/code\u003e dependencies of upstream dependencies, so it\u0026#39;s better to avoid transitive dependencies where possible (i.e. split into api/impl projects, only depend on api). Anything that participates in stub generation can affect its incrementalism.\u003c/li\u003e\u003cli\u003eKapt does not support multiple processing rounds for generated Kotlin code. Only Java code, as it\u0026#39;s handed off to javac. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-41064?ref=zacsweers.dev\"\u003eKT-41064\u003c/a\u003e\u003c/li\u003e\u003cli\u003eKapt runs its tasks on \u003cem\u003eall \u003c/em\u003econfigurations that it registers, including both \u003ccode\u003emain\u003c/code\u003e and \u003ccode\u003etest\u003c/code\u003e source sets. This means kapt may be running on your tests even if it doesn\u0026#39;t need to. \u003ca href=\"https://www.zacsweers.dev/kapts-hidden-test-costs/\"\u003eMore here\u003c/a\u003e. \u003cbr/\u003e\u003cem\u003eEdit: this was just fixed in 1.5.20 via \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-24533?ref=zacsweers.dev\"\u003eKT-24533\u003c/a\u003e\u003c/em\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"future\"\u003eFuture\u003c/h2\u003e\u003cul\u003e\u003cli\u003eMost of the issues linked above have some plans for eventual fixing. In particular, Google engineers (namely \u003ca href=\"https://twitter.com/gavra0?ref=zacsweers.dev\"\u003eIvan Gavrilović\u003c/a\u003e) have contributed a lot of Kapt fixes.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp?ref=zacsweers.dev\"\u003eKSP\u003c/a\u003e is a new tool from Google in the pipeline that aims to supplant Kapt with promises of improved performance, support for multiple rounds, no stub generation, and is actively developed/maintained. If you use Room or Moshi, please give it a try in your project and help test it with \u003ca href=\"https://github.com/ZacSweers/MoshiX/tree/main/moshi-ksp?ref=zacsweers.dev\"\u003emoshi-ksp\u003c/a\u003e or \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/room?ref=zacsweers.dev#2.3.0-beta02\"\u003eRoom 2.3.0-beta02\u003c/a\u003e (or later). Dagger is actively working on adding KSP support as well using the same shared infrastructure as Room\u0026#39;s implementation.\u003c/li\u003e\u003cli\u003eKotlin needs a performant compilation avoidance mechanism, which can also support better build cache hit rate and incremental compilation after a cache hit. This will also help when Android resources are modified.\u003c/li\u003e\u003cli\u003eKotlin FIR is the eventual new frontend compiler, offering significant compilation speed improvements (\u003ca href=\"https://kotlinlang.slack.com/archives/C7L3JB43G/p1614074334005600?thread_ts=1614068243.005100\u0026amp;cid=C7L3JB43G\u0026amp;ref=zacsweers.dev\"\u003ecurrently ~2-4x faster\u003c/a\u003e). It will potentially be available for testing later this year, so consider using \u003ca href=\"https://slack.engineering/shadow-jobs/?ref=zacsweers.dev\"\u003eshadow jobs\u003c/a\u003e to help test it when that happens.\u003c/li\u003e\u003cli\u003eNamespaced resources (i.e. \u003ccode\u003eandroid.nonTransitiveRClass\u003c/code\u003e) can help avoid breaking IC when resources are modified in some cases (namely javac) (\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-40772?ref=zacsweers.dev\"\u003eKT-40772\u003c/a\u003e) but needs help from compilation avoidance to better support Kotlin.\u003c/li\u003e\u003cli\u003eJetBrains hopes to improve compilation avoidance and remote caching in Kotlin 1.6 by moving away from \u003ccode\u003ehistory files\u003c/code\u003e (which can\u0026#39;t be relocated) and moving from \u003ccode\u003eproducer-side\u003c/code\u003e history storing to \u003ccode\u003econsumer-side\u003c/code\u003e. They are also hoping to make IC indifferent to classpath jar ordering, which would hopefully avoid \u003ca href=\"https://github.com/gradle/gradle/issues/15626?ref=zacsweers.dev\"\u003egradle/gradle#15626\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://docs.gradle.org/current/userguide/configuration_cache.html?ref=zacsweers.dev\"\u003eConfiguration Caching\u003c/a\u003e is an experimental new feature in Gradle to effectively cache configuration and allow for nearly-instant execution (i.e. tasks start executing almost immediately after you invoke the Gradle command). The \u003ca href=\"https://github.com/gradle/gradle/issues/13490?ref=zacsweers.dev\"\u003eplugin community is slowly catching up\u003c/a\u003e, but Kotlin should hopefully support this in 1.5.30 assuming no more issues (please help test 1.5.30-M1!).\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"supplementary-tools-patterns\"\u003eSupplementary tools/patterns\u003c/h3\u003e\u003cul\u003e\u003cli\u003eModularization. Incremental compilation will always be slower than not compiling at all. Split up monolithic subprojects and avoid build bottlenecks.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/square/anvil?ref=zacsweers.dev\"\u003eAnvil\u003c/a\u003e is a compiler plugin from Square that can, on top of its special dagger complementing features, replace Kapt in simple projects only using dagger to \u003ca href=\"https://github.com/square/anvil?ref=zacsweers.dev#dagger-factory-generation\"\u003egenerate factories\u003c/a\u003e.\u003c/li\u003e\u003cli\u003eAnvil, Kapt, and KSP are all built on top of something called \u003ccode\u003eAnalysisHandlerExtension\u003c/code\u003e, which is something you could build your own plugins on too if you don\u0026#39;t want to go all the way down to the IR layer. Anvil is probably the simplest example to look at for this.\u003c/li\u003e\u003cli\u003eSome annotation processors offer functionally equivalent \u003cem\u003ereflection\u003c/em\u003e implementations, such as \u003ca href=\"https://github.com/square/moshi?ref=zacsweers.dev\"\u003eMoshi\u003c/a\u003e. For these cases, you could (at the cost of build cache) speed up local builds by using reflection in debug builds and kapt only on CI and prod builds.\u003c/li\u003e\u003cli\u003eIn the event of a bad cache entry, you can rebuild with \u003ccode\u003e--rerun-tasks\u003c/code\u003e to force task re-runs and populate new cache entries.\u003c/li\u003e\u003cli\u003eNuclear option: make all developers on your team + CI clone the repo into the \u003cem\u003eexact same path\u003c/em\u003e to avoid remote build cache issues. Horribly inflexible, but honestly not terrible in practice.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003eWhat about Bazel/Buck/Pants/etc?\u003c/blockquote\u003e\u003cp\u003eYour mileage may vary, but it\u0026#39;s probably slower. There\u0026#39;s no notion of IC for Bazel-like build systems and Kotlin relies heavily on IC to smoothen over its lack of better compilation avoidance. Bazel-like builds may handle simple compilation avoidance better in some cases though.\u003c/p\u003e\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\u003cp\u003eSome of it is on Kotlin for often allowing critical build tools like Kapt to fall behind, some of it is on Gradle for having legacy APIs that regularly invite you to do the wrong thing (I hope they\u0026#39;ll consider \u003ca href=\"https://github.com/gradle/gradle/issues/16344?ref=zacsweers.dev\"\u003ea progressive mode\u003c/a\u003e or more aggressive deprecation policy).\u003c/p\u003e\u003cp\u003eThe easiest way to test for caching issues is to:\u003c/p\u003e\u003col\u003e\u003cli\u003eRun the same build twice with \u003ccode\u003e--scan\u003c/code\u003e and see which tasks weren\u0026#39;t cached.\u003c/li\u003e\u003cli\u003eAfter you\u0026#39;ve resolved #1, have two project clones in different locations and run identical builds with \u003ccode\u003e--scan\u003c/code\u003e, then compare them to see which tasks weren\u0026#39;t cached.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eYou can find more common caching problems on Gradle\u0026#39;s docs \u003ca href=\"https://docs.gradle.org/current/userguide/common_caching_problems.html?ref=zacsweers.dev\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003eThe easiest way to test for IC issues is to run a Gradle build with \u003ccode\u003e--debug\u003c/code\u003e and grep for \u003ccode\u003e[IC]\u003c/code\u003e to log detailed incremental compilation data about all this from \u003ccode\u003ekotlinc\u003c/code\u003e. It\u0026#39;s noisy so better to pipe it to a file and search in a text editor of your choice.\u003c/p\u003e\u003cp\u003e\u003cem\u003eEdit: \u003c/em\u003e\u003ca href=\"https://twitter.com/atsvetkv?ref=zacsweers.dev\"\u003e\u003cem\u003e@\u003c/em\u003eatsvetkv\u003c/a\u003e pointed me at the following Gradle properties that will be less noisy for debugging IC issues and getting metrics!\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode\u003e# gradle.properties for debugging\nkotlin.build.report.enable=true\nkotlin.build.report.verbose=true\n\n# gradle property for metrics\nkotlin.build.report.metrics=true\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003eMy possibly controversial 2¢: You should take one pass at cleaning up IC issues in your project, then focus on \u003cstrong\u003emodularizing\u003c/strong\u003e in the long run rather than rely on IC. Simple* compilation avoidance will win every day of the week and no other investment will yield as significant of results or be as broadly applicable. Incremental compilation is and always will be the white whale of Gradle and Kotlin build performance.\u003c/blockquote\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003eSpecial thanks to \u003ca href=\"https://twitter.com/nellyspageli?ref=zacsweers.dev\"\u003eNelson\u003c/a\u003e, \u003ca href=\"https://twitter.com/gavra0?ref=zacsweers.dev\"\u003eIvan\u003c/a\u003e, \u003ca href=\"https://twitter.com/ERubilov?ref=zacsweers.dev\"\u003eEugene\u003c/a\u003e, and \u003ca href=\"https://twitter.com/AutonomousApps?ref=zacsweers.dev\"\u003eTony\u003c/a\u003e for reviewing this.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cem\u003e*I define simple compilation avoidance as just avoiding project dependencies. There is also \u0026#34;true\u0026#34;, ABI-based compilation avoidance discussed above but not yet available.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2021-07-23T05:12:24Z",
  "modifiedTime": "2021-07-23T17:33:40Z"
}
