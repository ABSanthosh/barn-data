{
  "id": "2377e702-c451-402e-a365-807898163c0b",
  "title": "Elementary RecyclerView Adapter",
  "link": "https://android-arsenal.com/details/1/8487",
  "description": "Features: easy-to-use DSL-methods for making adapters support of multiple item types build-in listeners DiffUtil under the hood",
  "author": "",
  "published": "Sun, 17 Mar 2024 15:49:36 +0300",
  "source": "https://feeds.feedburner.com/Android_Arsenal",
  "categories": null,
  "byline": "Vladislav Bauer",
  "length": 13171,
  "excerpt": "View Adapters | Elementary RecyclerView Adapter by Roman Andrushchenko (romychab)",
  "siteName": "Android Arsenal",
  "favicon": "https://android-arsenal.com/favicon.png",
  "text": "Elementary RecyclerView Adapter Another one easy-to-use adapter for RecyclerView ???? Features: DSL-like methods for building adapters similar to Jetpack Compose but designed for RecyclerView no view holders; bind any model object directly to auto-generated view bindings support of multiple item types build-in click listeners the library uses DiffUtil under the hood for fast updating of your list support of integration either with your own adapters or with third-party adapters upd: now payloads are supported starting from v0.4 Usage example This library adds a couple of methods for easier implementation of ListAdapter. It relies on View Binding so you don't need to create view holders. Simple example (1 item type) Let's image you have Cat model class and R.layout.item_cat (View Binding generates ItemCatBinding class for this layout). Then you can write the following code: val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { areItemsSame = { oldCat, newCat -\u003e oldCat.id == newCat.id } bind { cat -\u003e catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { root.onClick { cat -\u003e showCatDetails(cat) } } } recyclerView.adapter = adapter viewModel.catsLiveData.observe(viewLifecycleOwner) { list -\u003e adapter.submitList(list) } As you see, simpleAdapter\u003cItem, ViewBinding\u003e accepts 2 types: any type of your model (Cat) an implementation of ViewBinding which you don't need to write because the official View Binding library can do it. Then use bind and listeners methods to bind your item to views and assign listeners respectively. You can access all views from you binding class inside the bind and the listeners sections by this reference (which can be also omitted): val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { bind { cat -\u003e // \u003c--- your item to bind // access views by 'this' reference this.myTextView.text = cat.name // or directly by name in the generated binding class: myTextView.text = cat.name } } It's highly recommended to use a separate listeners section to assign click and long-click listeners to your views to avoid unnecessary object creation during item binding: val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { // ... listeners { // onClick for clicks deleteButton.onClick { cat -\u003e viewModel.delete(cat) } // onLongClick for long clicks root.onLongClick { cat -\u003e Toast.makeText(requireContext(), \"Oooops\", Toast.LENGTH_SHORT).show() true } } } Optionally you can adjust the logic of comparing old and new items by using areItemsSame and areContentsSame properties. They work in the same way as methods of DiffUtil.ItemCallback (click here for details). By default areItemsSame and areContentsSame compare items in terms of equals/hashCode so usually you don't need to use areContentsSame for data classes. But it's recommended to implement at least areItemsSame to compare your items by identifiers. Typical example: val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { // compare by ID areItemsSame = { oldCat, newCat -\u003e oldCat.id == newCat.id } // compare content areContentsSame = { oldCat, newCat -\u003e oldCat == newCat } } Another example (2 item types) Let's add headers after every 10th cat to the list. For example, we can define the following structure: sealed class ListItem { data class Header( val id: Int, val fromIndex: Int, val toIndex: Int ) : ListItem() data class Cat( val id: Long, val name: String, val description: String ) : ListItem() } Add layout for each item type: R.layout.item_cat (ItemCatBinding will be generated) and R.layout.item_header (ItemHeaderBinding will be generated). Then we can write an adapter by using adapter and addBinding methods: val adapter = adapter\u003cListItem\u003e { // \u003c--- Base type // map concrete subtype ListItem.Cat to the ItemCatBinding: addBinding\u003cListItem.Cat, ItemCatBinding\u003e { areItemsSame = { oldCat, newCat -\u003e oldCat.id == newCat.id } bind { cat -\u003e catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { deleteImageView.onClick(viewModel::deleteCat) root.onClick { cat -\u003e viewModel.openDetails(cat) } } } // map concrete subtype ListItem.Header to the ItemHeaderBinding: addBinding\u003cListItem.Header, ItemHeaderBinding\u003e { areItemsSame = { oldHeader, newHeader -\u003e oldHeader.id == newHeader.id } bind { header -\u003e titleTextView.text = \"Cats ${header.fromIndex}...${header.toIndex}\" } } } Then assign the list with cats and headers to the adapter by using submitList method: val list: List\u003cListItem\u003e = getListFromSomewhere() adapter.submitList(list) Advanced usage Working with indexes You can take into account an element's index within bind { ... } block and within event callbacks such as onClick { ... } and so on. ⚠️ Please note if you want to render items differently depending on element index then you need to specify areContentsSame callback which should take into account index changes. For example: val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { areContentsSame = { oldCat, newCat -\u003e // here you should pass an argument to the index() because // indexes may be different for old and new items. oldCat == newCat \u0026\u0026 index(oldCat) == index(newCat) } bind { item -\u003e // here index() is called without args because it refers to the current item being rendered root.background = if (index() % 2 == 0) Color.GRAY else Color.WHITE // ... render other properties } } Referencing to indexes within event callbacks is very simple (for this case you don't need to check indexes in areContentsSame): val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { areContentsSame = { oldCat, newCat -\u003e oldCat == newCat } bind { // ... render item } listeners { button.onClick { val elementIndex = index() Toast.makeText(context(), \"Clicked on index: ${elementIndex}\", Toast.LENGTH_SHORT).show() } customView.onCustomListener { customView.setOnMyCustomListener { val elementIndex = index() Toast.makeText(context(), \"Custom event on index: ${elementIndex}\", Toast.LENGTH_SHORT).show() } } } } Multi-choice / single-choice We recommend to implement multi-choice, single-choice, expand/collapse logic and so on in the view-model. And then just submit the result list to the adapter via either LiveData or StateFlow. But in case if you don't care about this, you can check the example of simple multi-choice implementation in the example app module (see SimpleMultiChoiceActivity). Payloads Sometimes you need to implement custom animations in your list or update only specific views. In this case you can use payloads. Specify changePayload property: in the addBinding block (for adapter method) directly in the simpleAdapter block Then use bindWithPayload instead of bind. The bindWithPayload block sends you 2 arguments instead of one: the second argument is a payload list which is exactly the same as in a typical RecyclerView.Adapter.onBindViewHolder method: val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { bindWithPayload { cat, payloads -\u003e // draw cat // use payloads } } Usage example with adapter (see example-add module in the sources for more details): val catsAdapter = adapter\u003cCatListItem\u003e { addBinding\u003cCatListItem.Cat, ItemCatBinding\u003e { // ... areItemsSame, areContentsSame here ... // payloads callback: changePayload = { oldCat, newCat -\u003e if (!oldCat.isFavorite \u0026\u0026 newCat.isFavorite) { FAVORITE_FLAG_CHANGED } else { NO_ANIMATION } } // bind with payloads bindWithPayloads { cat, payloads -\u003e // ... render the cat here ... // if the payload list contains FAVORITE_FLAG_CHANGED: if (payloads.any { it == FAVORITE_FLAG_CHANGED }) { // render changes with animation favoriteImageView.startAnimation(buildMyAwesomeAnimation()) } } } // ... bind some other item types here } Custom listeners Sometimes simple clicks and long clicks are not enough for your list items. To integrate custom listeners, you can use onCustomListener { ... } method. Usage example (let's assume some view can accept a double tap listener): val adapter = simpleAdapter\u003cCat, ItemCatBinding\u003e { // ... listeners { someDoubleTapView.onCustomListener { someDoubleTapView.setOnDoubleTapListener { // \u003c-- this is a method of the view // use item() call for getting the current item data val cat = item() viewModel.onDoubleTap(cat) } } } } Integration with other libraries It's possible to tie together your own adapters or adapters from other third-party libraries with this library. You can use adapterDelegate() or simpleAdapterDelegate() calls in order to create a bridge between libraries. For example, you can tie the PagingDataAdapter (see Paging Library V3) and this library. Usage example: Implement a subclass of PagingDataAdapter (add AdapterDelegate to the constructor): class PagingDataAdapterBridge\u003cT : Any\u003e( private val delegate: AdapterDelegate\u003cT\u003e ) : PagingDataAdapter\u003cT, BindingHolder\u003e( delegate.noIndexItemCallback() ) { override fun onBindViewHolder(holder: BindingHolder, position: Int, payloads: MutableList\u003cAny\u003e) { // please note, NULL values are not supported! val item = getItem(position) ?: return delegate.onBindViewHolder(holder, position, item, payloads) } override fun onBindViewHolder(holder: BindingHolder, position: Int) { } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BindingHolder { return delegate.onCreateViewHolder(parent, viewType) } override fun getItemViewType(position: Int): Int { // please note, NULL values are not supported! val item = getItem(position) ?: return 0 return delegate.getItemViewType(item) } } Write a method for creating instances of PagingDataAdapter: inline fun \u003creified T : Any, reified B : ViewBinding\u003e pagingAdapter( noinline block: ConcreteItemTypeScope\u003cT, B\u003e.() -\u003e Unit ): PagingDataAdapter\u003cT, BindingHolder\u003e { val delegate = simpleAdapterDelegate(block) return PagingDataAdapterBridge(delegate) } Now you can use pagingAdapter { ... } call for creating instances of PagingDataAdapter from Paging Library V3 val adapter = pagingAdapter\u003cCat, ItemCatBinding\u003e { areItemsSame = { oldCat, newCat -\u003e oldCat.id == newCat.id } bind { cat -\u003e catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { root.onClick { cat -\u003e Toast.makeText(context(), \"${cat.name} meow-meows\", Toast.LENGTH_SHORT).show() } } } recyclerView.adapter = adapter lifecycleScope.launch { viewModel.catsPagingDataFlow.collectLatest { adapter.submitData(it) } } Installation Add View Binding to your build.gradle file: android { ... buildFeatures { viewBinding true } ... } Add the library to the dependencies section of your build.gradle script: dependencies { ... implementation 'com.elveum:element-adapter:0.6' } Changelog v0.6 Upgraded gradle plugin and dependencies Changed target SDK to 33 Now you can specify defaultAreItemsSame, defaultAreContentsSame and defaultChangePayload callbacks directly in the adapter { ... } block. They will be used as default callbacks for all addBinding { ... } sub-blocks. Default implementation of areItemsSame now compares items by reference (e.g. oldItem === newItem instead of oldItem == newItem) v0.5 Added index() method which can be called within: bind { ... } block onClick { ... }, onLongClick { ... } blocks onCustomListener { view.onMyListener { ... } } block Added index(item) method to areContentsSame { ... }, areItemsSame { ... } and changePayload { ... } blocks. For these blocks you should call index() with arg because there is a need to specify for which item (oldItem or newItem) you want to get an index. v0.4 Added support of RecyclerView payloads v0.3 Added a couple of extension methods for getting resources to the bind and listeners block Added onCustomListener { ... } method for assigning custom listeners Added adapterDelegate { ... } and simpleAdapterDelegate { ... } methods for easier integration with third-party adapters v0.2 Added context() extension method Updated minSDK from 23 to 21 v0.1 The first release License Apache License 2.0",
  "image": "https://raw.githubusercontent.com/romychab/element-adapter/main/docs/screenshot.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"description\"\u003e\u003carticle\u003e\u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eElementary RecyclerView Adapter\u003c/h2\u003e\u003c/p\u003e  \u003cblockquote\u003e \u003cp dir=\"auto\"\u003eAnother one easy-to-use adapter for \u003ccode\u003eRecyclerView\u003c/code\u003e ????\u003c/p\u003e \u003c/blockquote\u003e \u003cp dir=\"auto\"\u003e\u003cstrong\u003eFeatures:\u003c/strong\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eDSL-like methods for building adapters similar to Jetpack Compose but designed for \u003ccode\u003eRecyclerView\u003c/code\u003e\u003c/li\u003e \u003cli\u003eno view holders; bind any model object directly to auto-generated \u003ca href=\"https://developer.android.com/topic/libraries/view-binding\" rel=\"nofollow\" target=\"_blank\"\u003eview bindings\u003c/a\u003e\u003c/li\u003e \u003cli\u003esupport of multiple item types\u003c/li\u003e \u003cli\u003ebuild-in click listeners\u003c/li\u003e \u003cli\u003ethe library uses \u003ccode\u003eDiffUtil\u003c/code\u003e under the hood for fast updating of your list\u003c/li\u003e \u003cli\u003esupport of integration either with your own adapters or with third-party adapters\u003c/li\u003e \u003cli\u003eupd: now payloads are supported starting from v0.4\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ca href=\"https://github.com/romychab/element-adapter/raw/main/docs/screenshot.png\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg data-layzr=\"https://raw.githubusercontent.com/romychab/element-adapter/main/docs/screenshot.png\" src=\"https://raw.githubusercontent.com/romychab/element-adapter/main/docs/screenshot.png\"/\u003e\u003c/a\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eUsage example\u003c/h2\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eThis library adds a couple of methods for easier implementation of \u003ccode\u003eListAdapter\u003c/code\u003e. It relies on \u003ca href=\"https://developer.android.com/topic/libraries/view-binding\" rel=\"nofollow\" target=\"_blank\"\u003eView Binding\u003c/a\u003e so you don\u0026#39;t need to create view holders.\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003cstrong\u003eSimple example (1 item type)\u003c/strong\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eLet\u0026#39;s image you have \u003ccode\u003eCat\u003c/code\u003e model class and \u003ccode\u003eR.layout.item_cat\u003c/code\u003e (\u003ca href=\"https://developer.android.com/topic/libraries/view-binding\" rel=\"nofollow\" target=\"_blank\"\u003eView Binding\u003c/a\u003e generates \u003ccode\u003eItemCatBinding\u003c/code\u003e class for this layout). Then you can write the following code:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { areItemsSame = { oldCat, newCat -\u0026gt; oldCat.id == newCat.id } bind { cat -\u0026gt; catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { root.onClick { cat -\u0026gt; showCatDetails(cat) } } } recyclerView.adapter = adapter viewModel.catsLiveData.observe(viewLifecycleOwner) { list -\u0026gt; adapter.submitList(list) }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n     areItemsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat.id \u003cspan\u003e==\u003c/span\u003e newCat.id }\n     bind { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n         catNameTextView.text \u003cspan\u003e=\u003c/span\u003e cat.name\n         catDescriptionTextView.text \u003cspan\u003e=\u003c/span\u003e cat.description\n     }\n     listeners {\n         root.onClick { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n             showCatDetails(cat)\n         }\n     }\n }\n\n recyclerView.adapter \u003cspan\u003e=\u003c/span\u003e adapter\n\n viewModel.catsLiveData.observe(viewLifecycleOwner) { list \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n     adapter.submitList(list)\n }\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eAs you see, \u003ccode\u003esimpleAdapter\u0026lt;Item, ViewBinding\u0026gt;\u003c/code\u003e accepts 2 types:\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eany type of your model (\u003ccode\u003eCat\u003c/code\u003e)\u003c/li\u003e \u003cli\u003ean implementation of \u003ccode\u003eViewBinding\u003c/code\u003e which you don\u0026#39;t need to write because the official \u003ca href=\"https://developer.android.com/topic/libraries/view-binding\" rel=\"nofollow\" target=\"_blank\"\u003eView Binding\u003c/a\u003e library can do it.\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003eThen use \u003ccode\u003ebind\u003c/code\u003e and \u003ccode\u003elisteners\u003c/code\u003e methods to bind your item to views and assign listeners respectively. You can access all views from you binding class inside the \u003ccode\u003ebind\u003c/code\u003e and the \u003ccode\u003elisteners\u003c/code\u003e sections by \u003ccode\u003ethis\u003c/code\u003e reference (which can be also omitted):\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { bind { cat -\u0026gt; // \u0026lt;--- your item to bind // access views by \u0026#39;this\u0026#39; reference this.myTextView.text = cat.name // or directly by name in the generated binding class: myTextView.text = cat.name } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    bind { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e \u0026lt;--- your item to bind\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e access views by \u0026#39;this\u0026#39; reference\u003c/span\u003e\n        \u003cspan\u003ethis\u003c/span\u003e.myTextView.text \u003cspan\u003e=\u003c/span\u003e cat.name\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e or directly by name in the generated binding class:\u003c/span\u003e\n        myTextView.text \u003cspan\u003e=\u003c/span\u003e cat.name\n    }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eIt\u0026#39;s highly recommended to use a separate \u003ccode\u003elisteners\u003c/code\u003e section to assign click and long-click listeners to your views to avoid unnecessary object creation during item binding:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { // ... listeners { // onClick for clicks deleteButton.onClick { cat -\u0026gt; viewModel.delete(cat) } // onLongClick for long clicks root.onLongClick { cat -\u0026gt; Toast.makeText(requireContext(), \u0026#34;Oooops\u0026#34;, Toast.LENGTH_SHORT).show() true } } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ...\u003c/span\u003e\n    listeners {\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e onClick for clicks\u003c/span\u003e\n        deleteButton.onClick { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            viewModel.delete(cat)\n        }\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e onLongClick for long clicks\u003c/span\u003e\n        root.onLongClick { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            \u003cspan\u003eToast\u003c/span\u003e.makeText(requireContext(), \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eOooops\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, \u003cspan\u003eToast\u003c/span\u003e.\u003cspan\u003eLENGTH_SHORT\u003c/span\u003e).show()\n            \u003cspan\u003etrue\u003c/span\u003e\n        }\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eOptionally you can adjust the logic of comparing old and new items by using \u003ccode\u003eareItemsSame\u003c/code\u003e and \u003ccode\u003eareContentsSame\u003c/code\u003e properties. They work in the same way as methods of \u003ccode\u003eDiffUtil.ItemCallback\u003c/code\u003e (\u003ca href=\"https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil.ItemCallback\" rel=\"nofollow\" target=\"_blank\"\u003eclick here\u003c/a\u003e for details). By default \u003ccode\u003eareItemsSame\u003c/code\u003e and \u003ccode\u003eareContentsSame\u003c/code\u003e compare items in terms of \u003ccode\u003eequals\u003c/code\u003e/\u003ccode\u003ehashCode\u003c/code\u003e so usually you don\u0026#39;t need to use \u003ccode\u003eareContentsSame\u003c/code\u003e for data classes. But it\u0026#39;s recommended to implement at least \u003ccode\u003eareItemsSame\u003c/code\u003e to compare your items by identifiers.\u003c/p\u003e \u003cp dir=\"auto\"\u003eTypical example:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { // compare by ID areItemsSame = { oldCat, newCat -\u0026gt; oldCat.id == newCat.id } // compare content areContentsSame = { oldCat, newCat -\u0026gt; oldCat == newCat } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e compare by ID\u003c/span\u003e\n    areItemsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat.id \u003cspan\u003e==\u003c/span\u003e newCat.id }\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e compare content\u003c/span\u003e\n    areContentsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat \u003cspan\u003e==\u003c/span\u003e newCat }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003e\u003cstrong\u003eAnother example (2 item types)\u003c/strong\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eLet\u0026#39;s add headers after every 10th cat to the list. For example, we can define the following structure:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"sealed class ListItem { data class Header( val id: Int, val fromIndex: Int, val toIndex: Int ) : ListItem() data class Cat( val id: Long, val name: String, val description: String ) : ListItem() }\"\u003e\u003cpre\u003e\u003cspan\u003esealed\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eListItem\u003c/span\u003e {\n\n    \u003cspan\u003edata class\u003c/span\u003e \u003cspan\u003eHeader\u003c/span\u003e(\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e,\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003efromIndex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e,\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003etoIndex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n    ) : ListItem()\n\n    \u003cspan\u003edata class\u003c/span\u003e \u003cspan\u003eCat\u003c/span\u003e(\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLong\u003c/span\u003e,\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e,\n        \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e\n    ) : ListItem()\n\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eAdd layout for each item type: \u003ccode\u003eR.layout.item_cat\u003c/code\u003e (\u003ccode\u003eItemCatBinding\u003c/code\u003e will be generated) and \u003ccode\u003eR.layout.item_header\u003c/code\u003e (\u003ccode\u003eItemHeaderBinding\u003c/code\u003e will be generated).\u003c/p\u003e \u003cp dir=\"auto\"\u003eThen we can write an adapter by using \u003ccode\u003eadapter\u003c/code\u003e and \u003ccode\u003eaddBinding\u003c/code\u003e methods:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = adapter\u0026lt;ListItem\u0026gt; { // \u0026lt;--- Base type // map concrete subtype ListItem.Cat to the ItemCatBinding: addBinding\u0026lt;ListItem.Cat, ItemCatBinding\u0026gt; { areItemsSame = { oldCat, newCat -\u0026gt; oldCat.id == newCat.id } bind { cat -\u0026gt; catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { deleteImageView.onClick(viewModel::deleteCat) root.onClick { cat -\u0026gt; viewModel.openDetails(cat) } } } // map concrete subtype ListItem.Header to the ItemHeaderBinding: addBinding\u0026lt;ListItem.Header, ItemHeaderBinding\u0026gt; { areItemsSame = { oldHeader, newHeader -\u0026gt; oldHeader.id == newHeader.id } bind { header -\u0026gt; titleTextView.text = \u0026#34;Cats ${header.fromIndex}...${header.toIndex}\u0026#34; } } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e adapter\u0026lt;\u003cspan\u003eListItem\u003c/span\u003e\u0026gt; { \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e \u0026lt;--- Base type\u003c/span\u003e\n\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e map concrete subtype ListItem.Cat to the ItemCatBinding:\u003c/span\u003e\n    addBinding\u0026lt;\u003cspan\u003eListItem\u003c/span\u003e.\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n        areItemsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat.id \u003cspan\u003e==\u003c/span\u003e newCat.id }\n        bind { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            catNameTextView.text \u003cspan\u003e=\u003c/span\u003e cat.name\n            catDescriptionTextView.text \u003cspan\u003e=\u003c/span\u003e cat.description\n        }\n        listeners {\n            deleteImageView.onClick(viewModel::deleteCat)\n            root.onClick { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n                viewModel.openDetails(cat)\n            }\n        }\n    }\n\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e map concrete subtype ListItem.Header to the ItemHeaderBinding:\u003c/span\u003e\n    addBinding\u0026lt;\u003cspan\u003eListItem\u003c/span\u003e.\u003cspan\u003eHeader\u003c/span\u003e, \u003cspan\u003eItemHeaderBinding\u003c/span\u003e\u0026gt; {\n        areItemsSame \u003cspan\u003e=\u003c/span\u003e { oldHeader, newHeader \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldHeader.id \u003cspan\u003e==\u003c/span\u003e newHeader.id }\n        bind { header \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            titleTextView.text \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eCats \u003cspan\u003e${header.fromIndex}\u003c/span\u003e...\u003cspan\u003e${header.toIndex}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e\n        }\n    }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eThen assign the list with cats and headers to the adapter by using \u003ccode\u003esubmitList\u003c/code\u003e method:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val list: List\u0026lt;ListItem\u0026gt; = getListFromSomewhere() adapter.submitList(list)\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e list\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eList\u003c/span\u003e\u0026lt;\u003cspan\u003eListItem\u003c/span\u003e\u0026gt; \u003cspan\u003e=\u003c/span\u003e getListFromSomewhere()\nadapter.submitList(list)\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eAdvanced usage\u003c/h2\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003eWorking with indexes\u003c/h3\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eYou can take into account an element\u0026#39;s index within \u003ccode\u003ebind { ... }\u003c/code\u003e block and within event callbacks such as \u003ccode\u003eonClick { ... }\u003c/code\u003e and so on.\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003cg-emoji alias=\"warning\"\u003e⚠️\u003c/g-emoji\u003e Please note if you want to render items differently depending on element index then you need to specify \u003ccode\u003eareContentsSame\u003c/code\u003e callback which should take into account index changes.\u003c/p\u003e \u003cp dir=\"auto\"\u003eFor example:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { areContentsSame = { oldCat, newCat -\u0026gt; // here you should pass an argument to the index() because // indexes may be different for old and new items. oldCat == newCat \u0026amp;\u0026amp; index(oldCat) == index(newCat) } bind { item -\u0026gt; // here index() is called without args because it refers to the current item being rendered root.background = if (index() % 2 == 0) Color.GRAY else Color.WHITE // ... render other properties } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    areContentsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e here you should pass an argument to the index() because\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e indexes may be different for old and new items.\u003c/span\u003e\n      oldCat \u003cspan\u003e==\u003c/span\u003e newCat \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e index(oldCat) \u003cspan\u003e==\u003c/span\u003e index(newCat)\n    }\n    bind { item \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e here index() is called without args because it refers to the current item being rendered\u003c/span\u003e\n        root.background \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eif\u003c/span\u003e (index() \u003cspan\u003e%\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e) \u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eGRAY\u003c/span\u003e \u003cspan\u003eelse\u003c/span\u003e \u003cspan\u003eColor\u003c/span\u003e.\u003cspan\u003eWHITE\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ... render other properties\u003c/span\u003e\n    }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003eReferencing to indexes within event callbacks is very simple (for this case you don\u0026#39;t need to check indexes in \u003ccode\u003eareContentsSame\u003c/code\u003e):\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { areContentsSame = { oldCat, newCat -\u0026gt; oldCat == newCat } bind { // ... render item } listeners { button.onClick { val elementIndex = index() Toast.makeText(context(), \u0026#34;Clicked on index: ${elementIndex}\u0026#34;, Toast.LENGTH_SHORT).show() } customView.onCustomListener { customView.setOnMyCustomListener { val elementIndex = index() Toast.makeText(context(), \u0026#34;Custom event on index: ${elementIndex}\u0026#34;, Toast.LENGTH_SHORT).show() } } } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    areContentsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat \u003cspan\u003e==\u003c/span\u003e newCat }\n    bind {\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ... render item\u003c/span\u003e\n    }\n    listeners {\n        button.onClick {\n            \u003cspan\u003eval\u003c/span\u003e elementIndex \u003cspan\u003e=\u003c/span\u003e index()\n            \u003cspan\u003eToast\u003c/span\u003e.makeText(context(), \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eClicked on index: \u003cspan\u003e${elementIndex}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, \u003cspan\u003eToast\u003c/span\u003e.\u003cspan\u003eLENGTH_SHORT\u003c/span\u003e).show()\n        }\n        customView.onCustomListener {\n            customView.setOnMyCustomListener {\n                \u003cspan\u003eval\u003c/span\u003e elementIndex \u003cspan\u003e=\u003c/span\u003e index()\n                \u003cspan\u003eToast\u003c/span\u003e.makeText(context(), \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003eCustom event on index: \u003cspan\u003e${elementIndex}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, \u003cspan\u003eToast\u003c/span\u003e.\u003cspan\u003eLENGTH_SHORT\u003c/span\u003e).show()\n            }\n        }\n    }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003eMulti-choice / single-choice\u003c/h3\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eWe recommend to implement multi-choice, single-choice, expand/collapse logic and so on in the view-model. And then just submit the result list to the adapter via either \u003ccode\u003eLiveData\u003c/code\u003e or \u003ccode\u003eStateFlow\u003c/code\u003e.\u003c/p\u003e \u003cp dir=\"auto\"\u003eBut in case if you don\u0026#39;t care about this, you can check the example of simple multi-choice implementation in the example app module (see \u003ca href=\"https://github.com/romychab/element-adapter/blob/main/example-app/src/main/java/com/elveum/elementadapter/app/SimpleMultiChoiceActivity.kt\" rel=\"nofollow\" target=\"_blank\"\u003eSimpleMultiChoiceActivity\u003c/a\u003e).\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ePayloads\u003c/h3\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eSometimes you need to implement custom animations in your list or update only specific views. In this case you can use \u003cem\u003epayloads\u003c/em\u003e.\u003c/p\u003e \u003col dir=\"auto\"\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eSpecify \u003ccode\u003echangePayload\u003c/code\u003e property:\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003ein the \u003ccode\u003eaddBinding\u003c/code\u003e block (for \u003ccode\u003eadapter\u003c/code\u003e method)\u003c/li\u003e \u003cli\u003edirectly in the \u003ccode\u003esimpleAdapter\u003c/code\u003e block\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eThen use \u003ccode\u003ebindWithPayload\u003c/code\u003e instead of \u003ccode\u003ebind\u003c/code\u003e. The \u003ccode\u003ebindWithPayload\u003c/code\u003e block sends you 2 arguments instead of one: the second argument is a payload list which is exactly the same as in a typical \u003ccode\u003eRecyclerView.Adapter.onBindViewHolder\u003c/code\u003e method:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { bindWithPayload { cat, payloads -\u0026gt; // draw cat // use payloads } }\"\u003e\u003cpre\u003e    \u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n        bindWithPayload { cat, payloads \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e draw cat\u003c/span\u003e\n            \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e use payloads\u003c/span\u003e\n        }\n    }\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eUsage example with \u003ccode\u003eadapter\u003c/code\u003e (see \u003ccode\u003eexample-add\u003c/code\u003e module in the sources for more details):\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val catsAdapter = adapter\u0026lt;CatListItem\u0026gt; { addBinding\u0026lt;CatListItem.Cat, ItemCatBinding\u0026gt; { // ... areItemsSame, areContentsSame here ... // payloads callback: changePayload = { oldCat, newCat -\u0026gt; if (!oldCat.isFavorite \u0026amp;\u0026amp; newCat.isFavorite) { FAVORITE_FLAG_CHANGED } else { NO_ANIMATION } } // bind with payloads bindWithPayloads { cat, payloads -\u0026gt; // ... render the cat here ... // if the payload list contains FAVORITE_FLAG_CHANGED: if (payloads.any { it == FAVORITE_FLAG_CHANGED }) { // render changes with animation favoriteImageView.startAnimation(buildMyAwesomeAnimation()) } } } // ... bind some other item types here }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e catsAdapter \u003cspan\u003e=\u003c/span\u003e adapter\u0026lt;\u003cspan\u003eCatListItem\u003c/span\u003e\u0026gt; {\n     addBinding\u0026lt;\u003cspan\u003eCatListItem\u003c/span\u003e.\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n\n         \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ... areItemsSame, areContentsSame here ...\u003c/span\u003e\n\n         \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e payloads callback:\u003c/span\u003e\n         changePayload \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n             \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003e!\u003c/span\u003eoldCat.isFavorite \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e newCat.isFavorite) {\n                 \u003cspan\u003eFAVORITE_FLAG_CHANGED\u003c/span\u003e\n             } \u003cspan\u003eelse\u003c/span\u003e {\n                 \u003cspan\u003eNO_ANIMATION\u003c/span\u003e\n             }\n         }\n\n         \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e bind with payloads\u003c/span\u003e\n         bindWithPayloads { cat, payloads \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n\n             \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ... render the cat here ...\u003c/span\u003e\n\n             \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e if the payload list contains FAVORITE_FLAG_CHANGED:\u003c/span\u003e\n             \u003cspan\u003eif\u003c/span\u003e (payloads.any { it \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eFAVORITE_FLAG_CHANGED\u003c/span\u003e }) {\n                 \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e render changes with animation\u003c/span\u003e\n                 favoriteImageView.startAnimation(buildMyAwesomeAnimation())\n             }\n         }\n\n     }\n\n     \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ... bind some other item types here\u003c/span\u003e\n\n }\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003c/ol\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003eCustom listeners\u003c/h3\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eSometimes simple clicks and long clicks are not enough for your list items. To integrate custom listeners, you can use \u003ccode\u003eonCustomListener { ... }\u003c/code\u003e method.\u003c/p\u003e \u003cp dir=\"auto\"\u003eUsage example (let\u0026#39;s assume some view can accept a double tap listener):\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = simpleAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { // ... listeners { someDoubleTapView.onCustomListener { someDoubleTapView.setOnDoubleTapListener { // \u0026lt;-- this is a method of the view // use item() call for getting the current item data val cat = item() viewModel.onDoubleTap(cat) } } } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e simpleAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e ...\u003c/span\u003e\n    listeners {\n        someDoubleTapView.onCustomListener {\n            someDoubleTapView.setOnDoubleTapListener { \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e \u0026lt;-- this is a method of the view\u003c/span\u003e\n                \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e use item() call for getting the current item data\u003c/span\u003e\n                \u003cspan\u003eval\u003c/span\u003e cat \u003cspan\u003e=\u003c/span\u003e item()\n                viewModel.onDoubleTap(cat)\n            }\n        }\n    }\n}\u003c/pre\u003e\u003c/div\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003eIntegration with other libraries\u003c/h3\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003eIt\u0026#39;s possible to tie together your own adapters or adapters from other third-party libraries with this library. You can use \u003ccode\u003eadapterDelegate()\u003c/code\u003e or \u003ccode\u003esimpleAdapterDelegate()\u003c/code\u003e calls in order to create a bridge between libraries.\u003c/p\u003e \u003cp dir=\"auto\"\u003eFor example, you can tie the \u003ccode\u003ePagingDataAdapter\u003c/code\u003e (see \u003ca href=\"https://developer.android.com/topic/libraries/architecture/paging/v3-overview\" rel=\"nofollow\" target=\"_blank\"\u003ePaging Library V3\u003c/a\u003e) and this library.\u003c/p\u003e \u003cp dir=\"auto\"\u003eUsage example:\u003c/p\u003e \u003col dir=\"auto\"\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eImplement a subclass of \u003ccode\u003ePagingDataAdapter\u003c/code\u003e (add \u003ccode\u003eAdapterDelegate\u003c/code\u003e to the constructor):\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"class PagingDataAdapterBridge\u0026lt;T : Any\u0026gt;( private val delegate: AdapterDelegate\u0026lt;T\u0026gt; ) : PagingDataAdapter\u0026lt;T, BindingHolder\u0026gt;( delegate.noIndexItemCallback() ) { override fun onBindViewHolder(holder: BindingHolder, position: Int, payloads: MutableList\u0026lt;Any\u0026gt;) { // please note, NULL values are not supported! val item = getItem(position) ?: return delegate.onBindViewHolder(holder, position, item, payloads) } override fun onBindViewHolder(holder: BindingHolder, position: Int) { } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BindingHolder { return delegate.onCreateViewHolder(parent, viewType) } override fun getItemViewType(position: Int): Int { // please note, NULL values are not supported! val item = getItem(position) ?: return 0 return delegate.getItemViewType(item) } }\"\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePagingDataAdapterBridge\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u0026gt;(\n    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003edelegate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAdapterDelegate\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e\u0026gt;\n) : PagingDataAdapter\u0026lt;T, BindingHolder\u0026gt;(\n    delegate.noIndexItemCallback()\n) {\n\n    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonBindViewHolder\u003c/span\u003e(\u003cspan\u003eholder\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBindingHolder\u003c/span\u003e, \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e, \u003cspan\u003epayloads\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eMutableList\u003c/span\u003e\u0026lt;\u003cspan\u003eAny\u003c/span\u003e\u0026gt;) {\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e please note, NULL values are not supported!\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e item \u003cspan\u003e=\u003c/span\u003e getItem(position) \u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e\n        delegate.onBindViewHolder(holder, position, item, payloads)\n    }\n\n    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonBindViewHolder\u003c/span\u003e(\u003cspan\u003eholder\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBindingHolder\u003c/span\u003e, \u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e) {\n    }\n\n    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eonCreateViewHolder\u003c/span\u003e(\u003cspan\u003eparent\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eViewGroup\u003c/span\u003e, \u003cspan\u003eviewType\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e): \u003cspan\u003eBindingHolder\u003c/span\u003e {\n        \u003cspan\u003ereturn\u003c/span\u003e delegate.onCreateViewHolder(parent, viewType)\n    }\n\n    \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003egetItemViewType\u003c/span\u003e(\u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e): \u003cspan\u003eInt\u003c/span\u003e {\n        \u003cspan\u003e\u003cspan\u003e//\u003c/span\u003e please note, NULL values are not supported!\u003c/span\u003e\n        \u003cspan\u003eval\u003c/span\u003e item \u003cspan\u003e=\u003c/span\u003e getItem(position) \u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e delegate.getItemViewType(item)\n    }\n\n}\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eWrite a method for creating instances of \u003ccode\u003ePagingDataAdapter\u003c/code\u003e:\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"inline fun \u0026lt;reified T : Any, reified B : ViewBinding\u0026gt; pagingAdapter( noinline block: ConcreteItemTypeScope\u0026lt;T, B\u0026gt;.() -\u0026gt; Unit ): PagingDataAdapter\u0026lt;T, BindingHolder\u0026gt; { val delegate = simpleAdapterDelegate(block) return PagingDataAdapterBridge(delegate) }\"\u003e\u003cpre\u003e\u003cspan\u003einline\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u0026lt;\u003cspan\u003ereified\u003c/span\u003e \u003cspan\u003eT\u003c/span\u003e : \u003cspan\u003eAny\u003c/span\u003e, \u003cspan\u003ereified\u003c/span\u003e \u003cspan\u003eB\u003c/span\u003e : \u003cspan\u003eViewBinding\u003c/span\u003e\u0026gt; \u003cspan\u003epagingAdapter\u003c/span\u003e(\n    noinline \u003cspan\u003eblock\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eConcreteItemTypeScope\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e, \u003cspan\u003eB\u003c/span\u003e\u0026gt;.() \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnit\u003c/span\u003e\n): \u003cspan\u003ePagingDataAdapter\u003c/span\u003e\u0026lt;\u003cspan\u003eT\u003c/span\u003e, \u003cspan\u003eBindingHolder\u003c/span\u003e\u0026gt; {\n    \u003cspan\u003eval\u003c/span\u003e delegate \u003cspan\u003e=\u003c/span\u003e simpleAdapterDelegate(block)\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePagingDataAdapterBridge\u003c/span\u003e(delegate)\n}\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eNow you can use \u003ccode\u003epagingAdapter { ... }\u003c/code\u003e call for creating instances of \u003ccode\u003ePagingDataAdapter\u003c/code\u003e from \u003ca href=\"https://developer.android.com/topic/libraries/architecture/paging/v3-overview\" rel=\"nofollow\" target=\"_blank\"\u003ePaging Library V3\u003c/a\u003e\u003c/p\u003e \u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"val adapter = pagingAdapter\u0026lt;Cat, ItemCatBinding\u0026gt; { areItemsSame = { oldCat, newCat -\u0026gt; oldCat.id == newCat.id } bind { cat -\u0026gt; catNameTextView.text = cat.name catDescriptionTextView.text = cat.description } listeners { root.onClick { cat -\u0026gt; Toast.makeText(context(), \u0026#34;${cat.name} meow-meows\u0026#34;, Toast.LENGTH_SHORT).show() } } } recyclerView.adapter = adapter lifecycleScope.launch { viewModel.catsPagingDataFlow.collectLatest { adapter.submitData(it) } }\"\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e adapter \u003cspan\u003e=\u003c/span\u003e pagingAdapter\u0026lt;\u003cspan\u003eCat\u003c/span\u003e, \u003cspan\u003eItemCatBinding\u003c/span\u003e\u0026gt; {\n    areItemsSame \u003cspan\u003e=\u003c/span\u003e { oldCat, newCat \u003cspan\u003e-\u0026gt;\u003c/span\u003e oldCat.id \u003cspan\u003e==\u003c/span\u003e newCat.id }\n    bind { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n        catNameTextView.text \u003cspan\u003e=\u003c/span\u003e cat.name\n        catDescriptionTextView.text \u003cspan\u003e=\u003c/span\u003e cat.description\n    }\n    listeners {\n        root.onClick { cat \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n            \u003cspan\u003eToast\u003c/span\u003e.makeText(context(), \u003cspan\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e${cat.name}\u003c/span\u003e meow-meows\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/span\u003e, \u003cspan\u003eToast\u003c/span\u003e.\u003cspan\u003eLENGTH_SHORT\u003c/span\u003e).show()\n        }\n    }\n}\n\nrecyclerView.adapter \u003cspan\u003e=\u003c/span\u003e adapter\n\nlifecycleScope.launch {\n    viewModel.catsPagingDataFlow.collectLatest {\n        adapter.submitData(it)\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003c/ol\u003e \u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eInstallation\u003c/h2\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eAdd \u003ca href=\"https://developer.android.com/topic/libraries/view-binding\" rel=\"nofollow\" target=\"_blank\"\u003eView Binding\u003c/a\u003e to your \u003ccode\u003ebuild.gradle\u003c/code\u003e file:\u003c/p\u003e \u003cdiv data-snippet-clipboard-copy-content=\"android { ... buildFeatures { viewBinding true } ... }\"\u003e\u003cpre\u003e\u003ccode\u003eandroid {\n    ...\n    buildFeatures {\n        viewBinding true\n    }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cp dir=\"auto\"\u003eAdd the library to the \u003ccode\u003edependencies\u003c/code\u003e section of your \u003ccode\u003ebuild.gradle\u003c/code\u003e script:\u003c/p\u003e \u003cdiv data-snippet-clipboard-copy-content=\"dependencies { ... implementation \u0026#39;com.elveum:element-adapter:0.6\u0026#39; }\"\u003e\u003cpre\u003e\u003ccode\u003edependencies {\n    ...\n    implementation \u0026#39;com.elveum:element-adapter:0.6\u0026#39;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eChangelog\u003c/h2\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.6\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eUpgraded gradle plugin and dependencies\u003c/li\u003e \u003cli\u003eChanged target SDK to 33\u003c/li\u003e \u003cli\u003eNow you can specify \u003ccode\u003edefaultAreItemsSame\u003c/code\u003e, \u003ccode\u003edefaultAreContentsSame\u003c/code\u003e and \u003ccode\u003edefaultChangePayload\u003c/code\u003e callbacks directly in the \u003ccode\u003eadapter { ... }\u003c/code\u003e block. They will be used as default callbacks for all \u003ccode\u003eaddBinding { ... }\u003c/code\u003e sub-blocks.\u003c/li\u003e \u003cli\u003eDefault implementation of \u003ccode\u003eareItemsSame\u003c/code\u003e now compares items by reference (e.g. \u003ccode\u003eoldItem === newItem\u003c/code\u003e instead of \u003ccode\u003eoldItem == newItem\u003c/code\u003e)\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.5\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eAdded \u003ccode\u003eindex()\u003c/code\u003e method which can be called within: \u003cul dir=\"auto\"\u003e \u003cli\u003e\u003ccode\u003ebind { ... }\u003c/code\u003e block\u003c/li\u003e \u003cli\u003e\u003ccode\u003eonClick { ... }\u003c/code\u003e, \u003ccode\u003eonLongClick { ... }\u003c/code\u003e blocks\u003c/li\u003e \u003cli\u003e\u003ccode\u003eonCustomListener { view.onMyListener { ... } }\u003c/code\u003e block\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eAdded \u003ccode\u003eindex(item)\u003c/code\u003e method to \u003ccode\u003eareContentsSame { ... }\u003c/code\u003e, \u003ccode\u003eareItemsSame { ... }\u003c/code\u003e and \u003ccode\u003echangePayload { ... }\u003c/code\u003e blocks. For these blocks you should call \u003ccode\u003eindex()\u003c/code\u003e with arg because there is a need to specify for which item (\u003ccode\u003eoldItem\u003c/code\u003e or \u003ccode\u003enewItem\u003c/code\u003e) you want to get an index.\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.4\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eAdded support of RecyclerView payloads\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.3\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eAdded a couple of extension methods for getting resources to the \u003ccode\u003ebind\u003c/code\u003e and \u003ccode\u003elisteners\u003c/code\u003e block\u003c/li\u003e \u003cli\u003eAdded \u003ccode\u003eonCustomListener { ... }\u003c/code\u003e method for assigning custom listeners\u003c/li\u003e \u003cli\u003eAdded \u003ccode\u003eadapterDelegate { ... }\u003c/code\u003e and \u003ccode\u003esimpleAdapterDelegate { ... }\u003c/code\u003e methods for easier integration with third-party adapters\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.2\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eAdded \u003ccode\u003econtext()\u003c/code\u003e extension method\u003c/li\u003e \u003cli\u003eUpdated minSDK from 23 to 21\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch3 dir=\"auto\"\u003ev0.1\u003c/h3\u003e\u003c/p\u003e \u003cul dir=\"auto\"\u003e \u003cli\u003eThe first release\u003c/li\u003e \u003c/ul\u003e \u003cp dir=\"auto\"\u003e\u003ch2 dir=\"auto\"\u003eLicense\u003c/h2\u003e\u003c/p\u003e \u003cp dir=\"auto\"\u003e\u003ca href=\"https://github.com/romychab/element-adapter/blob/main/LICENSE\" rel=\"nofollow\" target=\"_blank\"\u003eApache License 2.0\u003c/a\u003e\u003c/p\u003e \u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
