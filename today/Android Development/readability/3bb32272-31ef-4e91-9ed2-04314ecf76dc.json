{
  "id": "3bb32272-31ef-4e91-9ed2-04314ecf76dc",
  "title": "Uniform list access with subscripts",
  "link": "https://okkotlin.com/subscripts/",
  "description": "Accessing values from an array using subscripts is a light and easy way to fetch list data. Kotlin brought uniformity in data access across…",
  "author": "",
  "published": "Sun, 22 Dec 2019 00:00:00 GMT",
  "source": "https://okkotlin.com/rss.xml",
  "categories": null,
  "byline": "",
  "length": 5531,
  "excerpt": "Subscripts make accessing data from lists unambiguous. Let's see how we can add subscripts support for our custom data models.",
  "siteName": "",
  "favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABlmWCKAAAFGUlEQVR4Ae1Zb2wURRT/zc5eqxQM2BZIJQEKUk1D/BewBg0otIAiwcAXEb4ZP0hsAkbUiCQYY4wmajBGiZiYmPiBWEMNH6SUaIEoJhA0Go1FW62FRNuKkYtpe7szvtm73e7e7rW0t6Xc3Uyy2Tdv/r3fb9+8ebsL6KIZ0AxoBjQDmgHNgGZAM6AZ0AyUIgNsvKCH96+5Q1pyEw28T4LdxJiskRLTxzvPVPYv33Xcw21eqSHWm01bbNgvE/g6NUY6AyUIfEGXMQmQbzctTKXEx7a0GwoaaQ7jRyUgtb9xZcoSLfScK3OML3h1TgIUeGmLY+TiiYJHOQoAI6pNub20ZUuxg1fYIz1A7flidnv/Qw95gIr2BL4oA54fuCuHCFBHndtYCvcAASrJoQPeOedLAbzCGCBAZXilAtzFGQiC6fTWbZqCu0HmVNyYXjg1CAz+O+lGBAhQub2b5MaxMpt9M9jcW+laAja9GrK/C/LPTogLPwDJvtASrGoBEo+95+jtn9phf/5qqE/cigABmReb/NcorwB/oBn8ltXBuebf5dSlNQz71EGIc58G26egFowBMbzVscr5SGw/GAIvlUtnCjPLYK56EuYjr1AU4q56Su4BD8jbAmaAN+0Gm1HtTCX/uwT7i3cgfj8LDF0GZs0DX/oQjDu3gDEGY8FykjdDnDmU99ITnSDgAROdxB2ngBlz06eoTA4g9dETEJ1fpsGrTpd6YZ84ALvtdXcIeMN2YMZsrx4pELEoqxi5VD2mEt9MZBBfut4zy+54FyAPiCrixzaIP751mljiehhLVkZ1S+sIrLlhL8p2tDqXuf554JokgIBg5jzHaGmnIH45mRsUtYjODq+dVdV6crbAG5+GsfheRy1+OwPryD4abGV3m3A9Ng9g1Yucfa0skeTqEPaoRsm/e7x2VrXQk/0CX7UDvH6to1IeY322FyBy4yzxBUHLF+XLpo1to7/PUDLU36i9B4yOU1VE7/ewDu8h8MOhfvkqYvMAOdBD3weFYw+7YQ6QMT6Xgcpj3CL/Ou+K3t0FrxSy/1fAR7DXKQYhNgLU05H93Z5JfNmjnhwSKKLz2zZ6apUdRhWZ2Ub89k0wspOqqAET0MVHAC1uf/WhZ4Jz1i9a4dU9gYKlufYZsEzOL/q6IM6f8JpdQfR+B6tlNzwS1uxErljhjpnIPVYCZNfXED3nHDsYN5HYuA/8wRdg1K8DU0nP8q1IbDvgRXUFzskJIgKmvNwHSSTYpz5Iz5e4DubDdAKMsbXGS0J8QTCzsnXkJZjrnoVR2+BoeN39gLqyihxMwj7+FqL2v7+rOHsIoqaeSFsBNrOG5n4OVuuL/i55ybF6gGMJpbxW6x5YJ9+HTPaHjFNPXXR/Q1ni4+ksMdQjrLCOvgb5z0WnQZ0Oxt3bwp2uUMMAyslHCtVHytAbq+P/zzNtFticOnodroSk/S77KKJPwnE2gmIsiXWW72r3vnrFvgVCy1M6LLtPZ36lhVqvuoJBXvAvGv8W8M9+Dcrk4oEcveQIYCY77H8upUUAw89lze3pczrDQkkRwMHphSJYSoYABnba3Nn2SRB+jn+D2Z0KvU6f3wYSprE1CkfRewB9ekwxzjazp9pG3tR8TBQ1AerJM240JpqPdfgwB8SiJUDteXL7ZaOBV0xMfiYY4PsqVOioU9E+KuBFrV7QBND+TkrJLqr0VmV4KsnJPuejQGudZkAzoBnQDGgGNAOaAc2AZkAzoBn4H3WFe3QRC8LrAAAAAElFTkSuQmCC",
  "text": "Accessing values from an array using subscripts is a light and easy way to fetch list data. Kotlin brought uniformity in data access across regular arrays and Lists by allowing us to access data from a List using subscripts. But, what about our custom data models? Can they have subscripts if they mostly represent a list of data? This week, we will be discussing how we can add subscript access to our custom data models through operator overloading. Subscripts are handy Subscripts or the [] make it possible to have an incredibly lightweight and consistent syntax for accessing elements in an array. It's like moving a small window over a list of items to pick one. In Java, subscripts are not available for data structures such as List. To access an element from the List we have to call the get(index: Int) method. In Kotlin, however, we can access List elements the same way we access an array. val names: List\u003cString\u003e = listOf( “James Arthur”, “Brett Eldredge” ) println(“Artist: ${names[0]}”) This improved syntax is handy because we don’t have to remember different method names or access strategies for different data structures. No matter if we have an array or a List, as long as our naming convention represents the property to be a sequence of data, we can apply the same access method. Our code becomes robust in the sense that we can easily swap out arrays with Lists and our code will work. Now the question is, can we build subscript access for our custom data models? Yes, we can. Before we get into the implementation, let’s see how subscripts work for Lists in Kotlin. It’s a case of operator overloading Kotlin supports operator overloading with the keyword operator. While there are plenty of standard operator overloads available, we will focus on getting the [] access working for our custom class in this article. A quick look into the List\u003cE\u003e class of kotlin.collections shows up an overloaded get(index: Int) like this: public operator fun get(index: Int): E The standard behaviour is that Kotlin transforms get(index: Int) methods marked with the operator keyword to [] during access. With this little syntactic sugar, we can access List and ArrayList items with the subscript notation. Let’s make a mixtape To understand how and where we can leverage subscripts, we are going to work through an everyday use case, mixtapes. Popular music apps these days provide personalised lists of tracks for us to listen every day. Some, like YouTube music, call these playlists as mixtapes. Building on this idea, we can have our custom data model called Mixtape like this: data class Mixtape( val title: String, val forUser: String, val tracks: List\u003cTrack\u003e ) operator fun Mixtape.get(index: Int): Track = tracks[index] val Mixtape.size get(): Int = tracks.size Here, we have defined a get(index: Int) method marked as an operator to enable subscript access for our class. For brevity, our Mixtape here simply returns elements from the tracks list. However, we can have logic inside this get() method to suit our needs. An example would be returning sorted or filtered tracks. We have also defined a size property to add list-like functionality to our Mixtape class, so that we can use it like this: for (index in 0 until mixtape.size) { val track = mixtape[index] println(“${track.title} - ${track.artist}”) } Wondering why we have used extension functions and properties for our Mixtape instead of having them defined inside the class? It’s because, with this approach, we can have clean models with logic separated from the data, as we discussed in the clean models article. How is this helpful? At a glance, this little technique might not seem to be of much value. However, semantically it’s a win. Data classes like Mixtape and Podcasts indicate they are a list of items. Having a uniform data access strategy for lists in our project helps us skip the appropriate method lookup. For example, whenever we get a Mixtape object, we know it’s a list of songs, and we can traverse it like an array. We don’t have to dig into the implementation of Mixtape to find out how to extract elements from it. This semantic structuring not only saves us time but also prevents us from writing code like this: for (index in 0 until mixtape.tracks.size) { val track = mixtape.tracks[index] println(“${track.title} - ${track.artist}”) } We can go a step further to hide our List\u003cTrack\u003e from external access if we have some business logic inside our Mixtapes get() method: data class Mixtape( val title: String, val forUser: String, private val tracks: List\u003cTrack\u003e ) { operator fun get(index: Int): Track = tracks[index] val size get(): Int = tracks.size } With this encapsulation, we can ensure that our Mixtape always returns the output we intend it to, like a sorted or filtered list of tracks. Careful access means fewer bugs. A quick note: If we resort to locking down our class members to private visibility, we cannot access the private members inside an extension function/property defined outside the class. Therefore, we need to move get(index: Int) and size inside the Mixtape class block. Small but incremental wins As always, improvements like subscripts aren’t going to make our code faster or increase our productivity tenfold. These are small improvements, like type aliases or inline classes which compound to a clean and well-maintained project. Choose how you use them. Here's a sketch note on the topic",
  "image": "https://okkotlin.com/images/subscripts-featured-image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eAccessing values from an array using subscripts is a light and easy way to fetch list data.\u003c/p\u003e\n\u003cp\u003eKotlin brought uniformity in data access across regular arrays and \u003ccode\u003eList\u003c/code\u003es by allowing us to access data from a \u003ccode\u003eList\u003c/code\u003e using subscripts.\u003c/p\u003e\n\u003cp\u003eBut, what about our custom data models? Can they have subscripts if they mostly represent a list of data?\u003c/p\u003e\n\u003cp\u003eThis week, we will be discussing how we can add subscript access to our custom data models through operator overloading.\u003c/p\u003e\n\u003ch2 id=\"subscripts-are-handy\"\u003eSubscripts are handy\u003c/h2\u003e\n\u003cp\u003eSubscripts or the \u003ccode\u003e[]\u003c/code\u003e  make it possible to have an incredibly lightweight and consistent syntax for accessing elements in an array.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s like moving a small window over a list of items to pick one. \u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/0bfbb/subscripts-access.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Subscripts access strategy\" title=\"Subscripts access strategy\" src=\"https://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/dbb61/subscripts-access.png\" srcset=\"https://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/19bd1/subscripts-access.png 163w,\nhttps://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/d3bcb/subscripts-access.png 325w,\nhttps://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/dbb61/subscripts-access.png 650w,\nhttps://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/6b691/subscripts-access.png 975w,\nhttps://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/91670/subscripts-access.png 1300w,\nhttps://okkotlin.com/static/bb2356b02762b1fe4a354d7e9784a4de/0bfbb/subscripts-access.png 1972w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eIn Java, subscripts are not available for data structures such as \u003ccode\u003eList\u003c/code\u003e. To access an element from the \u003ccode\u003eList\u003c/code\u003e we have to call the \u003ccode\u003eget(index: Int)\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eIn Kotlin, however, we can access \u003ccode\u003eList\u003c/code\u003e elements the same way we access an array. \u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e names\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003eString\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elistOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    “James Arthur”\u003cspan\u003e,\u003c/span\u003e\n    “Brett Eldredge”\n\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e“Artist\u003cspan\u003e:\u003c/span\u003e $\u003cspan\u003e{\u003c/span\u003enames\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e”\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis improved syntax is handy because we don’t have to remember different method names or access strategies for different data structures.\u003c/p\u003e\n\u003cp\u003eNo matter if we have an array or a \u003ccode\u003eList\u003c/code\u003e, as long as our naming convention represents the property to be a sequence of data, we can apply the same access method.\u003c/p\u003e\n\u003cp\u003eOur code becomes robust in the sense that we can easily swap out arrays with \u003ccode\u003eList\u003c/code\u003es and our code will work.\u003c/p\u003e\n\u003cp\u003eNow the question is, can we build subscript access for our custom data models?\u003c/p\u003e\n\u003cp\u003eYes, we can. Before we get into the implementation, let’s see how subscripts work for \u003ccode\u003eList\u003c/code\u003es in Kotlin.\u003c/p\u003e\n\u003ch2 id=\"its-a-case-of-operator-overloading\"\u003eIt’s a case of operator overloading\u003c/h2\u003e\n\u003cp\u003eKotlin supports operator overloading with the keyword \u003ccode\u003eoperator\u003c/code\u003e. While there are plenty of standard operator overloads available, we will focus on getting the \u003ccode\u003e[]\u003c/code\u003e access working for our custom class in this article.\u003c/p\u003e\n\u003cp\u003eA quick look into the \u003ccode\u003eList\u0026lt;E\u0026gt;\u003c/code\u003e class of \u003ccode\u003ekotlin.collections\u003c/code\u003e shows up an overloaded \u003ccode\u003eget(index: Int)\u003c/code\u003e like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eindex\u003cspan\u003e:\u003c/span\u003e Int\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e E\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe standard behaviour is that Kotlin transforms \u003ccode\u003eget(index: Int)\u003c/code\u003e methods marked with the \u003ccode\u003eoperator\u003c/code\u003e keyword to  \u003ccode\u003e[]\u003c/code\u003e during access.\u003c/p\u003e\n\u003cp\u003eWith this little syntactic sugar, we can access \u003ccode\u003eList\u003c/code\u003e and \u003ccode\u003eArrayList\u003c/code\u003e items with the subscript notation.\u003c/p\u003e\n\u003ch2 id=\"lets-make-a-mixtape\"\u003eLet’s make a mixtape\u003c/h2\u003e\n\u003cp\u003eTo understand how and where we can leverage subscripts, we are going to work through an everyday use case, mixtapes.\u003c/p\u003e\n\u003cp\u003ePopular music apps these days provide personalised lists of tracks for us to listen every day. Some, like YouTube music, call these playlists as mixtapes.\u003c/p\u003e\n\u003cp\u003eBuilding on this idea, we can have our custom data model called \u003ccode\u003eMixtape\u003c/code\u003e like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMixtape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e title\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e forUser\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e tracks\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003eTrack\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003eoperator\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e Mixtape\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eindex\u003cspan\u003e:\u003c/span\u003e Int\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e Track \u003cspan\u003e=\u003c/span\u003e tracks\u003cspan\u003e[\u003c/span\u003eindex\u003cspan\u003e]\u003c/span\u003e\n\n\u003cspan\u003eval\u003c/span\u003e Mixtape\u003cspan\u003e.\u003c/span\u003esize\n    \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e Int \u003cspan\u003e=\u003c/span\u003e tracks\u003cspan\u003e.\u003c/span\u003esize\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere, we have defined a \u003ccode\u003eget(index: Int)\u003c/code\u003e method marked as an \u003ccode\u003eoperator\u003c/code\u003e to enable subscript access for our class.\u003c/p\u003e\n\u003cp\u003eFor brevity, our \u003ccode\u003eMixtape\u003c/code\u003e here simply returns elements from the tracks list. However, we can have logic inside this \u003ccode\u003eget()\u003c/code\u003e method to suit our needs. An example would be returning sorted or filtered tracks. \u003c/p\u003e\n\u003cp\u003eWe have also defined a \u003ccode\u003esize\u003c/code\u003e property to add list-like functionality to our \u003ccode\u003eMixtape\u003c/code\u003e class, so that we can use it like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eindex \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e until mixtape\u003cspan\u003e.\u003c/span\u003esize\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e track \u003cspan\u003e=\u003c/span\u003e mixtape\u003cspan\u003e[\u003c/span\u003eindex\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e“$\u003cspan\u003e{\u003c/span\u003etrack\u003cspan\u003e.\u003c/span\u003etitle\u003cspan\u003e}\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e $\u003cspan\u003e{\u003c/span\u003etrack\u003cspan\u003e.\u003c/span\u003eartist\u003cspan\u003e}\u003c/span\u003e”\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWondering why we have used extension functions and properties for our \u003ccode\u003eMixtape\u003c/code\u003e instead of having them defined inside the class?\u003c/p\u003e\n\u003cp\u003eIt’s because, with this approach, we can have clean models with logic separated from the data, as we discussed in the \u003ca href=\"https://okkotlin.com/clean-models/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eclean models article\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"how-is-this-helpful\"\u003eHow is this helpful?\u003c/h2\u003e\n\u003cp\u003eAt a glance, this little technique might not seem to be of much value. However, semantically it’s a win.\u003c/p\u003e\n\u003cp\u003eData classes like \u003ccode\u003eMixtape\u003c/code\u003e and \u003ccode\u003ePodcasts\u003c/code\u003e indicate they are a list of items. Having a uniform data access strategy for lists in our project helps us skip the appropriate method lookup.\u003c/p\u003e\n\u003cp\u003eFor example,  whenever we get a \u003ccode\u003eMixtape\u003c/code\u003e object, we know it’s a list of songs, and we can traverse it like an array. We don’t have to dig into the implementation of \u003ccode\u003eMixtape\u003c/code\u003e to find out how to extract elements from it.\u003c/p\u003e\n\u003cp\u003eThis semantic structuring not only saves us time but also prevents us from writing code like this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eindex \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e until mixtape\u003cspan\u003e.\u003c/span\u003etracks\u003cspan\u003e.\u003c/span\u003esize\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e track \u003cspan\u003e=\u003c/span\u003e mixtape\u003cspan\u003e.\u003c/span\u003etracks\u003cspan\u003e[\u003c/span\u003eindex\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e“$\u003cspan\u003e{\u003c/span\u003etrack\u003cspan\u003e.\u003c/span\u003etitle\u003cspan\u003e}\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e $\u003cspan\u003e{\u003c/span\u003etrack\u003cspan\u003e.\u003c/span\u003eartist\u003cspan\u003e}\u003c/span\u003e”\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe can go a step further to hide our \u003ccode\u003eList\u0026lt;Track\u0026gt;\u003c/code\u003e from external access if we have some business logic inside our \u003ccode\u003eMixtape\u003c/code\u003es \u003ccode\u003eget()\u003c/code\u003e method:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMixtape\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e title\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eval\u003c/span\u003e forUser\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003eval\u003c/span\u003e tracks\u003cspan\u003e:\u003c/span\u003e List\u003cspan\u003e\u0026lt;\u003c/span\u003eTrack\u003cspan\u003e\u0026gt;\u003c/span\u003e\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eoperator\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eindex\u003cspan\u003e:\u003c/span\u003e Int\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e Track \u003cspan\u003e=\u003c/span\u003e tracks\u003cspan\u003e[\u003c/span\u003eindex\u003cspan\u003e]\u003c/span\u003e\n\n    \u003cspan\u003eval\u003c/span\u003e size\n        \u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e Int \u003cspan\u003e=\u003c/span\u003e tracks\u003cspan\u003e.\u003c/span\u003esize\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWith this encapsulation, we can ensure that our \u003ccode\u003eMixtape\u003c/code\u003e always returns the output we intend it to, like a sorted or filtered list of tracks. Careful access means fewer bugs.\u003c/p\u003e\n\u003cp\u003eA quick note:\u003c/p\u003e\n\u003cp\u003eIf we resort to locking down our class members to \u003ccode\u003eprivate\u003c/code\u003e visibility, we cannot access the private members inside an extension function/property defined outside the class.\u003c/p\u003e\n\u003cp\u003eTherefore, we need to move \u003ccode\u003eget(index: Int)\u003c/code\u003e  and \u003ccode\u003esize\u003c/code\u003e inside the \u003ccode\u003eMixtape\u003c/code\u003e class block.\u003c/p\u003e\n\u003ch2 id=\"small-but-incremental-wins\"\u003eSmall but incremental wins\u003c/h2\u003e\n\u003cp\u003eAs always, improvements like subscripts aren’t going to make our code faster or increase our productivity tenfold.\u003c/p\u003e\n\u003cp\u003eThese are small improvements, like \u003ca href=\"https://okkotlin.com/typealias/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003etype aliases\u003c/a\u003e or \u003ca href=\"https://okkotlin.com/inline-classes/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003einline classes\u003c/a\u003e which compound to a clean and well-maintained project.\u003c/p\u003e\n\u003cp\u003eChoose how you use them.\u003c/p\u003e\n\u003ch2 id=\"heres-a-sketch-note-on-the-topic\"\u003eHere\u0026#39;s a sketch note on the topic\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/d40c8/subscripts-sketch-note.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Subscripts sketch note\" title=\"Subscripts sketch note\" src=\"https://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/dbb61/subscripts-sketch-note.png\" srcset=\"https://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/19bd1/subscripts-sketch-note.png 163w,\nhttps://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/d3bcb/subscripts-sketch-note.png 325w,\nhttps://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/dbb61/subscripts-sketch-note.png 650w,\nhttps://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/6b691/subscripts-sketch-note.png 975w,\nhttps://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/91670/subscripts-sketch-note.png 1300w,\nhttps://okkotlin.com/static/e2929a0b801034f647d9bfae0d6658df/d40c8/subscripts-sketch-note.png 2000w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
