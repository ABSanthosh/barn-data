{
  "id": "ef7493e2-0c9d-45bb-b493-b1e3c0ceb385",
  "title": "Intermediate collection avoidance",
  "link": "https://jakewharton.com/intermediate-collection-avoidance/",
  "description": "",
  "author": "",
  "published": "2024-02-07T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 3041,
  "excerpt": "07 February 2024",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Intermediate collection avoidance 07 February 2024 Given a list of users, extract their names and join them into a comma-separated list. Kotlin’s extension functions on collections make this trivial. users.map { it.name }.joinToString() Writing this in IntelliJ IDEA produces a “weak warning” offering advice. Call chain on collection type may be simplified An intention action will refactor the code for you to a more efficient form. users.joinToString() { it.name } Mapping the user to their name now occurs during construction of the joined string rather than as a discrete operation. The additional iterator and intermediate collection produced by the map is eliminated. This code is both shorter and faster, and the IDE helps you discover this superior form. Two similar fused operations that I like but which don’t benefit from IDE advice are array and pre-sized list initialization with a lambda. If we wanted to create an array of our user’s names, instead of doing users.map { it.name }.toTypedArray() we can use Array(users.size) { users[it].name } This again trades the intermediate iterator and collection within map for an indexed loop. Primitive array versions are also available. IntArray(users.size) { users[it].age } Arrays are not used too often. Mostly for memory-sensitive or performance-sensitive code, or when calling out to a Java API. Thankfully this lambda-accepting initializer is also available for pre-sized lists. MutableList(users.size) { users[it].name } Use this to initialize element default values, compute elements based on the index, or derive data from another source. In the case of deriving data, the source needs to support random access in order to actually result in a more efficient computation.1 If you use a list backed by an alternate structure (linked, persistent, etc.) performance will be abysmal. This technique works best for internal library usage and should not be used when you don’t control the original list. Benchmark Score Error Units --------------------------------------------- ---------- -------- ----- NamesJoinToString.map 126.582 ± 38.237 ns/op NamesJoinToString.map:·gc.alloc.rate.norm 232.000 ± 0.001 B/op NamesJoinToString.lambda 73.586 ± 1.960 ns/op NamesJoinToString.lambda:·gc.alloc.rate.norm 168.000 ± 0.001 B/op NamesToTypedArray.map 78.444 ± 22.427 ns/op NamesToTypedArray.map:·gc.alloc.rate.norm 120.000 ± 0.001 B/op NamesToTypedArray.lambda 10.326 ± 0.129 ns/op NamesToTypedArray.lambda:·gc.alloc.rate.norm 40.000 ± 0.001 B/op As you can see in the benchmarks above, the lambda initialization variants are both faster due to the use of indexed loops and allocate fewer bytes with no iterator or intermediate collection. We could hand-write such loops, but Kotlin’s zero-overhead functions keep our code short and sweet. — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eIntermediate collection avoidance\u003c/h2\u003e\n      \u003cp\u003e07 February 2024\u003c/p\u003e\n\n      \u003cp\u003eGiven a list of users, extract their names and join them into a comma-separated list.\nKotlin’s extension functions on collections make this trivial.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e}.\u003c/span\u003e\u003cspan\u003ejoinToString\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWriting this in IntelliJ IDEA produces a “weak warning” offering advice.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eCall chain on collection type may be simplified\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eAn intention action will refactor the code for you to a more efficient form.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejoinToString\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eMapping the user to their name now occurs during construction of the joined string rather than as a discrete operation.\nThe additional iterator and intermediate collection produced by the \u003ccode\u003emap\u003c/code\u003e is eliminated.\u003c/p\u003e\n\n\u003cp\u003eThis code is both shorter and faster, and the IDE helps you discover this superior form.\u003c/p\u003e\n\n\u003cp\u003eTwo similar fused operations that I like but which don’t benefit from IDE advice are array and pre-sized list initialization with a lambda.\u003c/p\u003e\n\n\u003cp\u003eIf we wanted to create an array of our user’s names, instead of doing\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e}.\u003c/span\u003e\u003cspan\u003etoTypedArray\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003ewe can use\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis again trades the intermediate iterator and collection within \u003ccode\u003emap\u003c/code\u003e for an indexed loop.\nPrimitive array versions are also available.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eIntArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eArrays are not used too often.\nMostly for memory-sensitive or performance-sensitive code, or when calling out to a Java API.\nThankfully this lambda-accepting initializer is also available for pre-sized lists.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eMutableList\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eusers\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e].\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eUse this to initialize element default values, compute elements based on the index, or derive data from another source.\u003c/p\u003e\n\n\u003cp\u003eIn the case of deriving data, the source needs to support random access in order to actually result in a more efficient computation.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\"\u003e1\u003c/a\u003e\u003c/sup\u003e If you use a list backed by an alternate structure (linked, persistent, etc.) performance will be abysmal. This technique works best for internal library usage and should not be used when you don’t control the original list.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eBenchmark                                       Score     Error   Units\n--------------------------------------------- ---------- -------- -----\nNamesJoinToString.map                         126.582 ±  38.237   ns/op\nNamesJoinToString.map:·gc.alloc.rate.norm     232.000 ±   0.001    B/op\nNamesJoinToString.lambda                       73.586 ±   1.960   ns/op\nNamesJoinToString.lambda:·gc.alloc.rate.norm  168.000 ±   0.001    B/op\n\nNamesToTypedArray.map                          78.444 ±  22.427   ns/op\nNamesToTypedArray.map:·gc.alloc.rate.norm     120.000 ±   0.001    B/op\nNamesToTypedArray.lambda                       10.326 ±   0.129   ns/op\nNamesToTypedArray.lambda:·gc.alloc.rate.norm   40.000 ±   0.001    B/op\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAs you can see in the benchmarks above, the lambda initialization variants are both faster due to the use of indexed loops and allocate fewer bytes with no iterator or intermediate collection. We could hand-write such loops, but Kotlin’s zero-overhead functions keep our code short and sweet.\u003c/p\u003e\n\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-02-07T00:00:00Z",
  "modifiedTime": null
}
