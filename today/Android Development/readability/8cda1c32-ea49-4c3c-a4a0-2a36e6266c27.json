{
  "id": "8cda1c32-ea49-4c3c-a4a0-2a36e6266c27",
  "title": "Jetpack WindowManager 1.4 is stable",
  "link": "http://android-developers.googleblog.com/2025/03/jetpack-windowmanager-14-is-stable.html",
  "description": "",
  "author": "Android Developers",
  "published": "2025-03-12T14:00:00.000-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "Activity Stack Pinning",
    "Android",
    "dialog full-screen dim",
    "interactive divider",
    "Large screen",
    "Pane expansion",
    "Window Manager"
  ],
  "byline": "",
  "length": 6867,
  "excerpt": "Jetpack WindowManager 1.4 is now stable introducing new features like activity stack pinning, pane expansion, dialog full-screen dim, and more.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Xiaodao Wu - Developer Relations Engineer Jetpack WindowManager keeps getting better. WindowManager gives you tools to build adaptive apps that work seamlessly across all kinds of large screen devices. Version 1.4, which is stable now, introduces new features that make multi-window experiences even more powerful and flexible. While Jetpack Compose is still the best way to create app layouts for different screen sizes, 1.4 makes some big improvements to activity embedding, including activity stack spinning, pane expansion, and dialog full-screen dim. Multi-activity apps can easily take advantage of all these great features. What's new in WindowManager 1.4 WindowManager 1.4 introduces a range of enhancements. Here are some of the highlights. WindowSizeClass We’ve updated the WindowSizeClass API to support custom values. We changed the API shape to make it easy and extensible to support custom values and add new values in the future. The high level changes are as follows: Opened the constructor to take in minWidthDp and minHeightDp parameters so you can create your own window size classes Added convenience methods for checking breakpoint validity Deprecated WindowWidthSizeClass and WindowHeightSizeClass in favor of WindowSizeClass#isWidthAtLeastBreakpoint() and WindowSizeClass#isHeightAtLeastBreakpoint() respectively Here’s a migration example: // old val sizeClass = WindowSizeClass.compute(widthDp, heightDp) when (sizeClass.widthSizeClass) { COMPACT -\u003e doCompact() MEDIUM -\u003e doMedium() EXPANDED -\u003e doExpanded() else -\u003e doDefault() } // new val sizeClass = WindowSizeClass.BREAKPOINTS_V1 .computeWindowSizeClass(widthDp, heightDp) when { sizeClass.isWidthAtLeastBreakpoint(WIDTH_DP_EXPANDED_LOWER_BOUND) -\u003e { doExpanded() } sizeClass.isWidthAtLeastBreakpoint(WIDTH_DP_MEDIUM_LOWER_BOUND) -\u003e { doMedium() } else -\u003e { doCompact() } } Some things to note in the new API: The order of the when branches should go from largest to smallest to support custom values from developers or new values in the future The default branch should be treated as the smallest window size class Activity embedding Activity stack pinning Activity stack pinning provides a way to keep an activity stack always on screen, no matter what else is happening in your app. This new feature lets you pin an activity stack to a specific window, so the top activity stays visible even when the user navigates to other parts of the app in a different window. This is perfect for things like live chats or video players that you want to keep on screen while users explore other content. private fun pinActivityStackExample(taskId: Int) { val splitAttributes: SplitAttributes = SplitAttributes.Builder() .setSplitType(SplitAttributes.SplitType.ratio(0.66f)) .setLayoutDirection(SplitAttributes.LayoutDirection.LEFT_TO_RIGHT) .build() val pinSplitRule = SplitPinRule.Builder() .setDefaultSplitAttributes(splitAttributes) .build() SplitController.getInstance(applicationContext).pinTopActivityStack(taskId, pinSplitRule) } Pane expansion The new pane expansion feature, also known as interactive divider, lets you create a visual separation between two activities in split-screen mode. You can make the pane divider draggable so users can resize the panes – and the activities in the panes – on the fly. This gives users control over how they want to view the app’s content. val splitAttributesBuilder: SplitAttributes.Builder = SplitAttributes.Builder() .setSplitType(SplitAttributes.SplitType.ratio(0.33f)) .setLayoutDirection(SplitAttributes.LayoutDirection.LEFT_TO_RIGHT) if (WindowSdkExtensions.getInstance().extensionVersion \u003e= 6) { splitAttributesBuilder.setDividerAttributes( DividerAttributes.DraggableDividerAttributes.Builder() .setColor(getColor(context, R.color.divider_color)) .setWidthDp(4) .setDragRange( DividerAttributes.DragRange.DRAG_RANGE_SYSTEM_DEFAULT) .build() ) } val splitAttributes: SplitAttributes = splitAttributesBuilder.build() Dialog full-screen dim WindowManager 1.4 gives you more control over how dialogs dim the background. With dialog full-screen dim, you can choose to dim just the container where the dialog appears or the entire task window for a unified UI experience. The entire app window dims by default when a dialog opens (see EmbeddingConfiguration.DimAreaBehavior.ON_TASK).To dim only the container of the activity that opened the dialog, use EmbeddingConfiguration.DimAreaBehavior.ON_ACTIVITY_STACK. This gives you more flexibility in designing dialogs and makes for a smoother, more coherent user experience. Temu is among the first developers to integrate this feature, the full-screen dialog dim has reduced screen invalid touches by about 5%. Customised shopping cart reminder with dialog full-screen dim in Temu. Enhanced posture support WindowManager 1.4 makes building apps that work flawlessly on foldables straightforward by providing more information about the physical capabilities of the device. The new WindowInfoTracker#supportedPostures API lets you know if a device supports tabletop mode, so you can optimize your app's layout and features accordingly. val currentSdkVersion = WindowSdkExtensions.getInstance().extensionVersion val message = if (currentSdkVersion \u003e= 6) { val supportedPostures = WindowInfoTracker.getOrCreate(LocalContext.current).supportedPostures buildString { append(supportedPostures.isNotEmpty()) if (supportedPostures.isNotEmpty()) { append(\" \") append( supportedPostures.joinToString( separator = \",\", prefix = \"(\", postfix = \")\")) } } } else { \"N/A (WindowSDK version 6 is needed, current version is $currentSdkVersion)\" } Other API changes WindowManager 1.4 includes several API changes and additions to support the new features. Notable changes include: Stable and no longer experimental APIs: ActivityEmbeddingController#invalidateVisibleActivityStacks ActivityEmbeddingController#getActivityStack SplitController#updateSplitAttributes API added to set activity embedding animation background: SplitAttributes.Builder#setAnimationParams API to get updated WindowMetrics information: ActivityEmbeddingController#embeddedActivityWindowInfo API to finish all activities in an activity stack: ActivityEmbeddingController#finishActivityStack How to get started To start using Jetpack WindowManager 1.4 in your Android projects, update your app dependencies in build.gradle.kts to the latest stable version: dependencies { implementation(\"androidx.window:window:1.4.0\") // or, if you're using the WindowManager testing library: testImplementation(\"androidx.window:window-testing:1.4.0\") } Happy coding!",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvmObDTm_UvKKZP8bDM_YVpknfPh2MBo1pZun6Vc_0CTOsoxvFAq0O_tIa33owHNckOXqKEGGf35C7PccmUFU9gA9VX7djih13zWISVNwdqAHY7waJ7tcWoZJUSuCwSnrLCmhQzNCr21e61IJ_8PLUzj6eKApPrxmK-cwMHrYp-iCbQ6XPyiLxIKvRZPU/w1200-h630-p-k-no-nu/Jetpack%20Adaptive%20Compose%20Metadata.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvmObDTm_UvKKZP8bDM_YVpknfPh2MBo1pZun6Vc_0CTOsoxvFAq0O_tIa33owHNckOXqKEGGf35C7PccmUFU9gA9VX7djih13zWISVNwdqAHY7waJ7tcWoZJUSuCwSnrLCmhQzNCr21e61IJ_8PLUzj6eKApPrxmK-cwMHrYp-iCbQ6XPyiLxIKvRZPU/s1600/Jetpack%20Adaptive%20Compose%20Metadata.png\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by  Xiaodao Wu - Developer Relations Engineer\u003c/em\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiq-xjyTG_ks5AfowEaHg8NFwpTVt0EqH59N_7RExbYOHp8WESDEmFbRFPB7kc3_tP0B7XGARTbDvX6woNwZgRtwX2xH8xJI0uq4w7T3b2JFOjzB3qfU6EZC-MpYSZ537orOmLoI5VY69Fc-h9XMiJ3MRe7rk66yTMcEdDxSWlrOY71cQ04-kxG-kFalms/s1600/Jetpack%20Adaptive%20Compose%20%281%29.png\"\u003e\u003cimg data-original-height=\"800\" data-original-width=\"100%\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiq-xjyTG_ks5AfowEaHg8NFwpTVt0EqH59N_7RExbYOHp8WESDEmFbRFPB7kc3_tP0B7XGARTbDvX6woNwZgRtwX2xH8xJI0uq4w7T3b2JFOjzB3qfU6EZC-MpYSZ537orOmLoI5VY69Fc-h9XMiJ3MRe7rk66yTMcEdDxSWlrOY71cQ04-kxG-kFalms/s1600/Jetpack%20Adaptive%20Compose%20%281%29.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003eJetpack WindowManager keeps getting better. WindowManager gives you tools to build adaptive apps that work seamlessly across all kinds of large screen devices. Version 1.4, which is stable now, introduces new features that make multi-window experiences even more powerful and flexible. While Jetpack Compose is still the best way to create app layouts for different screen sizes, 1.4 makes some big improvements to activity embedding, including activity stack spinning, pane expansion, and dialog full-screen dim. Multi-activity apps can easily take advantage of all these great features.\u003c/p\u003e\n\n\u003ch2\u003eWhat\u0026#39;s new in WindowManager 1.4\u003c/h2\u003e\n\n\u003cp\u003eWindowManager 1.4 introduces a range of enhancements. Here are some of the highlights.\u003c/p\u003e\n\n\u003ch2\u003e\u003cspan\u003eWindowSizeClass\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eWe’ve updated the \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/compose/material3/windowsizeclass/WindowSizeClass\" target=\"_blank\"\u003eWindowSizeClass\u003c/a\u003e\u003c/span\u003e API to support custom values. We changed the API shape to make it easy and extensible to support custom values and add new values in the future. The high level changes are as follows:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eOpened the constructor to take in \u003cspan\u003eminWidthDp\u003c/span\u003e and \u003cspan\u003eminHeightDp\u003c/span\u003e parameters so you can create your own window size classes\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eAdded convenience methods for checking breakpoint validity\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eDeprecated \u003cspan\u003eWindowWidthSizeClass\u003c/span\u003e and \u003cspan\u003eWindowHeightSizeClass\u003c/span\u003e in favor of \u003cspan\u003eWindowSizeClass#isWidthAtLeastBreakpoint()\u003c/span\u003e and \u003cspan\u003eWindowSizeClass#isHeightAtLeastBreakpoint()\u003c/span\u003e respectively\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eHere’s a migration example:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// old \u003c/span\u003e\n\n\u003cspan\u003eval\u003c/span\u003e sizeClass = WindowSizeClass.compute(widthDp, heightDp)\n\u003cspan\u003ewhen\u003c/span\u003e (sizeClass.widthSizeClass) {\n  COMPACT -\u0026gt; doCompact()\n  MEDIUM -\u0026gt; doMedium()\n  EXPANDED -\u0026gt; doExpanded()\n  \u003cspan\u003eelse\u003c/span\u003e -\u0026gt; doDefault()\n}\n\n\u003cspan\u003e// new\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e sizeClass = WindowSizeClass.BREAKPOINTS_V1\n                               .computeWindowSizeClass(widthDp, heightDp)\n\n\u003cspan\u003ewhen\u003c/span\u003e {\n  sizeClass.isWidthAtLeastBreakpoint(WIDTH_DP_EXPANDED_LOWER_BOUND) -\u0026gt; {\n    doExpanded()\n  }\n  sizeClass.isWidthAtLeastBreakpoint(WIDTH_DP_MEDIUM_LOWER_BOUND) -\u0026gt; {\n    doMedium()\n  }\n  \u003cspan\u003eelse\u003c/span\u003e -\u0026gt; {\n    doCompact()\n  }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSome things to note in the new API:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eThe order of the \u003cspan\u003ewhen\u003c/span\u003e branches should go from largest to smallest to support custom values from developers or new values in the future\u003c/li\u003e\n\u003cli\u003eThe default branch should be treated as the smallest window size class\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003ch2\u003e\u003cspan\u003eActivity embedding\u003c/span\u003e\u003c/h2\u003e\n\n\u003ch3\u003e\u003cspan\u003e\u003cb\u003eActivity stack pinning\u003c/b\u003e\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003cb\u003eActivity stack pinning\u003c/b\u003e provides a way to keep an activity stack always on screen, no matter what else is happening in your app. This new feature lets you pin an activity stack to a specific window, so the top activity stays visible even when the user navigates to other parts of the app in a different window. This is perfect for things like live chats or video players that you want to keep on screen while users explore other content.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003epinActivityStackExample\u003c/span\u003e(taskId: Int) {\n \u003cspan\u003eval\u003c/span\u003e splitAttributes: SplitAttributes = SplitAttributes.Builder()\n   .setSplitType(SplitAttributes.SplitType.ratio(\u003cspan\u003e0.66f\u003c/span\u003e))\n   .setLayoutDirection(SplitAttributes.LayoutDirection.LEFT_TO_RIGHT)\n   .build()\n\n \u003cspan\u003eval\u003c/span\u003e pinSplitRule = SplitPinRule.Builder()\n   .setDefaultSplitAttributes(splitAttributes)\n   .build()\n\n SplitController.getInstance(applicationContext).pinTopActivityStack(taskId, pinSplitRule)\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003e\u003cb\u003ePane expansion\u003c/b\u003e\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eThe new \u003cb\u003e\u003ca href=\"https://m3.material.io/foundations/layout/applying-layout/pane-layouts#d3ef6c37-d8a5-4029-99d1-033ec6db39a6\" target=\"_blank\"\u003epane expansion\u003c/a\u003e\u003c/b\u003e feature, also known as \u003cb\u003einteractive divider\u003c/b\u003e, lets you create a visual separation between two activities in split-screen mode. You can make the pane divider draggable so users can resize the panes – and the activities in the panes – on the fly. This gives users control over how they want to view the app’s content.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e splitAttributesBuilder: SplitAttributes.Builder = SplitAttributes.Builder()\n   .setSplitType(SplitAttributes.SplitType.ratio(\u003cspan\u003e0.33f\u003c/span\u003e))\n   .setLayoutDirection(SplitAttributes.LayoutDirection.LEFT_TO_RIGHT)\n\n\u003cspan\u003eif\u003c/span\u003e (WindowSdkExtensions.getInstance().extensionVersion \u0026gt;= \u003cspan\u003e6\u003c/span\u003e) {\n   splitAttributesBuilder.setDividerAttributes(\n       DividerAttributes.DraggableDividerAttributes.Builder()\n           .setColor(getColor(context, R.color.divider_color))\n           .setWidthDp(\u003cspan\u003e4\u003c/span\u003e)\n           .setDragRange(\n               DividerAttributes.DragRange.DRAG_RANGE_SYSTEM_DEFAULT)\n           .build()\n   )\n}\n\u003cspan\u003eval\u003c/span\u003e splitAttributes: SplitAttributes = splitAttributesBuilder.build()\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch3\u003e\u003cspan\u003e\u003cb\u003eDialog full-screen dim\u003c/b\u003e\u003c/span\u003e\u003c/h3\u003e\n\n\u003cp\u003eWindowManager 1.4 gives you more control over how dialogs dim the background. With \u003cb\u003edialog full-screen dim\u003c/b\u003e, you can choose to dim just the container where the dialog appears or the entire task window for a unified UI experience. The entire app window dims by default when a dialog opens (see \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/androidx/window/embedding/EmbeddingConfiguration.DimAreaBehavior#ON_TASK%28%29\" target=\"_blank\"\u003eEmbeddingConfiguration.DimAreaBehavior.ON_TASK\u003c/a\u003e\u003c/span\u003e).To dim only the container of the activity that opened the dialog, use \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/androidx/window/embedding/EmbeddingConfiguration.DimAreaBehavior#ON_ACTIVITY_STACK%28%29\" target=\"_blank\"\u003eEmbeddingConfiguration.DimAreaBehavior.ON_ACTIVITY_STACK\u003c/a\u003e\u003c/span\u003e. This gives you more flexibility in designing dialogs and makes for a smoother, more coherent user experience. Temu is among the first developers to integrate this feature, \u003cb\u003ethe full-screen dialog dim has reduced screen invalid touches by about 5%\u003c/b\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg alt=\"Customised shopping cart reminder with dialog full-screen dim in the Temu app\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLiE6tczDdr2zyqCLvzFCMWwOev6PfUDyotLJBA2tmdjeiNM7179ZbUXKo7S4aZk0cB2vi4hIeK9PmRSRw5q_CHsJgIEE8tIEKdTKQdbV5FwsmZLRHeRG7uxzSmqk2cNy2ox5luCaz2YvK9G4MBw_7TpKUiwhPouvoaVG_3XHnQFbGPHoxjDbqMi-I2vU/s1600/image1.png\" width=\"640\"/\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eCustomised shopping cart reminder with dialog full-screen dim in Temu.\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\u003cbr/\u003e\n\n\u003ch2\u003e\u003cspan\u003eEnhanced posture support\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eWindowManager 1.4 makes building apps that work flawlessly on foldables straightforward by providing more information about the physical capabilities of the device. The new \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/kotlin/androidx/window/layout/WindowInfoTracker#supportedPostures%28%29\" target=\"_blank\"\u003eWindowInfoTracker#supportedPostures\u003c/a\u003e\u003c/span\u003e API lets you know if a device supports tabletop mode, so you can optimize your app\u0026#39;s layout and features accordingly.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eval\u003c/span\u003e currentSdkVersion = WindowSdkExtensions.getInstance().extensionVersion\n\u003cspan\u003eval\u003c/span\u003e message =\n\u003cspan\u003eif\u003c/span\u003e (currentSdkVersion \u0026gt;= \u003cspan\u003e6\u003c/span\u003e) {\n  \u003cspan\u003eval\u003c/span\u003e supportedPostures = WindowInfoTracker.getOrCreate(LocalContext.current).supportedPostures\n  buildString {\n    append(supportedPostures.isNotEmpty())\n    \u003cspan\u003eif\u003c/span\u003e (supportedPostures.isNotEmpty()) {\n      append(\u003cspan\u003e\u0026#34; \u0026#34;\u003c/span\u003e)\n      append(\n      supportedPostures.joinToString(\n      separator = \u003cspan\u003e\u0026#34;,\u0026#34;\u003c/span\u003e, prefix = \u003cspan\u003e\u0026#34;(\u0026#34;\u003c/span\u003e, postfix = \u003cspan\u003e\u0026#34;)\u0026#34;\u003c/span\u003e))\n    }\n  }\n} \u003cspan\u003eelse\u003c/span\u003e {\n  \u003cspan\u003e\u0026#34;N/A (WindowSDK version 6 is needed, current version is $currentSdkVersion)\u0026#34;\u003c/span\u003e\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2\u003e\u003cspan\u003eOther API changes\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eWindowManager 1.4 includes several API changes and additions to support the new features. Notable changes include:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eStable and no longer experimental APIs:\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eActivityEmbeddingController#invalidateVisibleActivityStacks\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eActivityEmbeddingController#getActivityStack\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eSplitController#updateSplitAttributes\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003cul\u003e\u003cul\u003e\n  \u003cli\u003eAPI added to set activity embedding animation background:\u003c/li\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eSplitAttributes.Builder#setAnimationParams\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003cul\u003e\u003cul\u003e\n  \u003cli\u003eAPI to get updated WindowMetrics information:\u003c/li\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eActivityEmbeddingController#embeddedActivityWindowInfo\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\u003cul\u003e\u003cul\u003e\n  \u003cli\u003eAPI to finish all activities in an activity stack:\u003c/li\u003e\n  \u003cul\u003e\u003cli\u003e\u003cspan\u003eActivityEmbeddingController#finishActivityStack\u003c/span\u003e\u003c/li\u003e\n  \u003c/ul\u003e\u003c/ul\u003e\u003c/ul\u003e\n \n\u003ch2\u003e\u003cspan\u003eHow to get started\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eTo start using Jetpack WindowManager 1.4 in your Android projects, update your app dependencies in build.gradle.kts to the latest stable version:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003edependencies {\n    implementation(\u003cspan\u003e\u0026#34;androidx.window:window:1.4.0\u0026#34;\u003c/span\u003e) \n    \u003cspan\u003e// or, if you\u0026#39;re using the WindowManager testing library:\u003c/span\u003e\n    testImplementation(\u003cspan\u003e\u0026#34;androidx.window:window-testing:1.4.0\u0026#34;\u003c/span\u003e)\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHappy coding!\u003c/p\u003e\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
