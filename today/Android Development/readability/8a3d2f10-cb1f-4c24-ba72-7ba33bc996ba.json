{
  "id": "8a3d2f10-cb1f-4c24-ba72-7ba33bc996ba",
  "title": "Encapsulate your @Composable functions",
  "link": "https://chrynan.codes/encapsulate-your-composables/",
  "description": "A convenient convention for complex composable components.",
  "author": "Christopher Keenan",
  "published": "Thu, 20 Apr 2023 22:00:00 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "jetpack compose",
    "jetpack",
    "compose",
    "jetpack-compose",
    "composable",
    "declarative ui",
    "ui",
    "convention",
    "design"
  ],
  "byline": "Christopher Keenan",
  "length": 5488,
  "excerpt": "A convenient convention for complex composable components.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "A convenient convention for complex composable components. Apr 20, 2023 • 3 min read TL;DREncapsulate your composable functions and associated types with a surrounding object and use the operator fun invoke of that object as your composable function. This is a convenient convention for complex components.DetailsComplex Composable functions often require numerous associated types for their implementation: state holders, UI models, default values, etc. While it does not seem to be defined within the Jetpack Compose API Guidelines, the common convention, promoted by the Jetpack Compose library component implementations, is to preface each associated type with the name of the composable function. For example, consider the Button composable function and its related types from the compose.material module: @Composable fun Button( onClick: () -\u003e Unit, modifier: Modifier = Modifier, enabled: Boolean = true, interactionSource: MutableInteractionSource = remember { MutableInteractionSource() }, elevation: ButtonElevation? = ButtonDefaults.elevation(), shape: Shape = MaterialTheme.shapes.small, border: BorderStroke? = null, colors: ButtonColors = ButtonDefaults.buttonColors(), contentPadding: PaddingValues = ButtonDefaults.ContentPadding, content: @Composable RowScope.() -\u003e Unit ) { ... } @Stable interface ButtonElevation { ... } @Stable interface ButtonColors { ... } object ButtonDefaults { ... } These types all begin with the word \"Button\" and are located within the androidx.compose.material package. This convention associates the related types by a prefix, but has several drawbacks: No strict enforcement of the convention as it relies on knowledge of the convention and willingness to conform to it. This could easily lead to inconsistencies between different components within the same library, by error, such as typos, overlooking a type, or simple ignorance of the convention. Static analysis tools may help to alleviate these issues, but it would prove rather difficult since each composable function is very different and may require external types as well.Polluting of the package scope. There might be many different composable components within a single package, for instance, the androidx.compose.material package has greater than twenty different composable components, each of which has numerous of their own associated types. This might be beneficial for listing all types within a package, but with such a large amount of types, it might be difficult to find the type you are looking for. Code completion from an IDE may help this issue, but as you will see, this will work well with my proposition too.Convention ProposalAssociate composable component related types by an encapsulating object instead of a naming convention, and include the composable function itself within the encapsulating object by utilizing Kotlin's invoke operator function. For example, the Button composable function and its related types can be rewritten as follows: object Button { @Composable operator fun invoke( onClick: () -\u003e Unit, modifier: Modifier = Modifier, enabled: Boolean = true, interactionSource: MutableInteractionSource = remember { MutableInteractionSource() }, elevation: ButtonElevation? = ButtonDefaults.elevation(), shape: Shape = MaterialTheme.shapes.small, border: BorderStroke? = null, colors: ButtonColors = ButtonDefaults.buttonColors(), contentPadding: PaddingValues = ButtonDefaults.ContentPadding, content: @Composable RowScope.() -\u003e Unit ) { ... } @Stable interface Elevation { ... } @Stable interface Colors { ... } object Defaults { ... } } Now, instead of everything being scoped to the package with a naming convention prefix, everything is scoped to an object with a statically enforced prefix of that object's name. And since the encapsulating component is an object, it is a singleton, so different instances cannot be mistakenly passed to a composable function. This approach has the following benefits:Encapsulation of all the related types.Easy finding and usage of related types through IDE code completion.Cleaner package namespaces.Better static enforcement of the convention.The composable function invocation looks almost identical to the previous approach, but with cleaner accessing of related types: Button( onClick = { ... }, colors = Button.Defaults.colors() ) { ... } However, it should be noted that one possible downside of this approach is incorrectly requiring the encapsulating object type as a parameter to another composable function. For instance: @Composable fun MyComponent( button: Button // Incorrect, though not dangerous, per se ) { ... } This shouldn't be an issue, since the type is a singleton so there is no benefit in passing an instance as a parameter, and the invoke function will have to be explicitly called for the component to be added to the UI tree. ConclusionEncapsulating your composable function and associated types with a surrounding object, along with the usage of Kotlin's invoke operator function, provide a convenient approach to implementing UI components.",
  "image": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/04/encapsulate_composables_logo.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"site-main\"\u003e\n\u003carticle\u003e\n\n    \u003cheader\u003e\n\n        \n\n        \n\n            \u003cp\u003eA convenient convention for complex composable components.\u003c/p\u003e\n\n        \u003csection\u003e\n\n            \u003cul\u003e\n                \u003cli\u003e\n                    \u003ca href=\"https://chrynan.codes/author/chrynan/\" aria-label=\"Read more of Christopher Keenan\"\u003e\n                        \u003cimg src=\"https://www.gravatar.com/avatar/2179fa575001969b7a3397951ef91a8f?s=250\u0026amp;d=mm\u0026amp;r=x\" alt=\"Christopher Keenan\"/\u003e\n                    \u003c/a\u003e\n                \u003c/li\u003e\n            \u003c/ul\u003e\n\n            \u003cdiv\u003e\n                \n                \u003cp\u003e\u003ctime datetime=\"2023-04-20\"\u003eApr 20, 2023\u003c/time\u003e\n                        \u003cspan\u003e\u003cspan\u003e•\u003c/span\u003e 3 min read\u003c/span\u003e\n                \u003c/p\u003e\n            \u003c/div\u003e\n\n        \u003c/section\u003e\n\n            \u003cfigure\u003e\n                \u003cimg srcset=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w300/2023/04/encapsulate_composables_logo.png 300w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w600/2023/04/encapsulate_composables_logo.png 600w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/size/w1000/2023/04/encapsulate_composables_logo.png 1000w,\n                            https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/04/encapsulate_composables_logo.png 2000w\" sizes=\"(min-width: 1400px) 1400px, 92vw\" src=\"https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/04/encapsulate_composables_logo.png\" alt=\"Encapsulate your @Composable functions\"/\u003e\n            \u003c/figure\u003e\n\n    \u003c/header\u003e\n\n    \u003csection\u003e\n        \u003ch3 id=\"tldr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eEncapsulate your composable functions and associated types with a surrounding object and use the \u003ccode\u003eoperator fun invoke\u003c/code\u003e of that object as your composable function. This is a convenient convention for complex components.\u003c/p\u003e\u003ch3 id=\"details\"\u003eDetails\u003c/h3\u003e\u003cp\u003eComplex Composable functions often require numerous associated types for their implementation: state holders, UI models, default values, etc. While it does not seem to be defined within the \u003ca href=\"https://android.googlesource.com/platform/frameworks/support/+/androidx-main/compose/docs/compose-api-guidelines.md?ref=chrynan.codes\"\u003eJetpack Compose API Guidelines\u003c/a\u003e, the common convention, promoted by the Jetpack Compose library component implementations, is to preface each associated type with the name of the composable function. For example, consider the \u003ca href=\"https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt?ref=chrynan.codes\"\u003eButton\u003c/a\u003e composable function and its related types from the \u003ccode\u003ecompose.material\u003c/code\u003e module:\u003c/p\u003e\u003cpre\u003e\t\u003ccode\u003e\n@Composable\nfun Button(\n    onClick: () -\u0026gt; Unit,\n    modifier: Modifier = Modifier,\n    enabled: Boolean = true,\n    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },\n    elevation: ButtonElevation? = ButtonDefaults.elevation(),\n    shape: Shape = MaterialTheme.shapes.small,\n    border: BorderStroke? = null,\n    colors: ButtonColors = ButtonDefaults.buttonColors(),\n    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,\n    content: @Composable RowScope.() -\u0026gt; Unit\n) { ... }\n\n@Stable\ninterface ButtonElevation { ... }\n\n@Stable\ninterface ButtonColors { ... }\n\nobject ButtonDefaults { ... }\n\t\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThese types all begin with the word \u0026#34;Button\u0026#34; and are located within the \u003ccode\u003eandroidx.compose.material\u003c/code\u003e package. This convention associates the related types by a prefix, but has several drawbacks: \u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eNo strict enforcement of the convention\u003c/strong\u003e as it relies on knowledge of the convention and willingness to conform to it. This could easily lead to inconsistencies between different components within the same library, by error, such as typos, overlooking a type, or simple ignorance of the convention. Static analysis tools may help to alleviate these issues, but it would prove rather difficult since each composable function is very different and may require external types as well.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePolluting of the package scope\u003c/strong\u003e. There might be many different composable components within a single package, for instance, the \u003ccode\u003eandroidx.compose.material\u003c/code\u003e package has greater than twenty different composable components, each of which has numerous of their own associated types. This might be beneficial for listing all types within a package, but with such a large amount of types, it might be difficult to find the type you are looking for. Code completion from an IDE may help this issue, but as you will see, this will work well with my proposition too.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"convention-proposal\"\u003eConvention Proposal\u003c/h3\u003e\u003cp\u003eAssociate composable component related types by an encapsulating object instead of a naming convention, and include the composable function itself within the encapsulating object by utilizing Kotlin\u0026#39;s \u003ccode\u003einvoke\u003c/code\u003e operator function. For example, the \u003ca href=\"https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-main/compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt?ref=chrynan.codes\"\u003eButton\u003c/a\u003e composable function and its related types can be rewritten as follows:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nobject Button {\n\n  @Composable\n  operator fun invoke(\n    onClick: () -\u0026gt; Unit,\n    modifier: Modifier = Modifier,\n    enabled: Boolean = true,\n    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },\n    elevation: ButtonElevation? = ButtonDefaults.elevation(),\n    shape: Shape = MaterialTheme.shapes.small,\n    border: BorderStroke? = null,\n    colors: ButtonColors = ButtonDefaults.buttonColors(),\n    contentPadding: PaddingValues = ButtonDefaults.ContentPadding,\n    content: @Composable RowScope.() -\u0026gt; Unit\n  ) { ... }\n  \n  @Stable\n  interface Elevation { ... }\n  \n  @Stable\n  interface Colors { ... }\n  \n  object Defaults { ... }\n}\n\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNow, instead of everything being scoped to the package with a naming convention prefix, everything is scoped to an object with a statically enforced prefix of that object\u0026#39;s name. And since the encapsulating component is an \u003ccode\u003eobject\u003c/code\u003e, it is a singleton, so different instances cannot be mistakenly passed to a composable function. This approach has the following benefits:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eEncapsulation of all the related types\u003c/strong\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eEasy finding and usage of related types\u003c/strong\u003e through IDE code completion.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCleaner package namespaces\u003c/strong\u003e.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eBetter static enforcement of the convention\u003c/strong\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe composable function invocation looks almost identical to the previous approach, but with cleaner accessing of related types:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nButton(\n  onClick = { ... },\n  colors = Button.Defaults.colors()\n) { ... }\n\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eHowever, it should be noted that one possible downside of this approach is incorrectly requiring the encapsulating object type as a parameter to another composable function. For instance:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\n@Composable\nfun MyComponent(\n  button: Button // Incorrect, though not dangerous, per se\n) { ... }\n\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis shouldn\u0026#39;t be an issue, since the type is a singleton so there is no benefit in passing an instance as a parameter, and the \u003ccode\u003einvoke\u003c/code\u003e function will have to be explicitly called for the component to be added to the UI tree. \u003c/p\u003e\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\u003cp\u003eEncapsulating your composable function and associated types with a surrounding object, along with the usage of Kotlin\u0026#39;s \u003ccode\u003einvoke\u003c/code\u003e operator function, provide a convenient approach to implementing UI components.\u003c/p\u003e\n    \u003c/section\u003e\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2023-04-20T22:00:00Z",
  "modifiedTime": "2023-04-20T22:00:00Z"
}
