{
  "id": "0a47129c-98f2-463d-beab-7b5f6c31be14",
  "title": "Exploring Kotlin Coroutines through Output Questions",
  "link": "https://proandroiddev.com/exploring-kotlin-coroutines-through-output-questions-aa0760383569?source=rss----c72404660798---4",
  "description": "",
  "author": "Tanya Arora",
  "published": "Sat, 16 Nov 2024 06:27:45 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "android",
    "programming",
    "kotlin",
    "asynchronous",
    "kotlin-coroutines"
  ],
  "byline": "Tanya Arora",
  "length": 16066,
  "excerpt": "In this unique blog, we delve into the world of Kotlin coroutines through a series of output questions. Each question presents a distinct scenario, allowing us to understand and reinforce our…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In this unique blog, we delve into the world of Kotlin coroutines through a series of output questions. Each question presents a distinct scenario, allowing us to understand and reinforce our knowledge of coroutine concepts. By exploring and analyzing the outputs, we gain a deeper understanding of the behavior and intricacies of Kotlin coroutines. Join me on this journey as we unravel the power of coroutines in Kotlin and enhance our proficiency in concurrent programming.I’ll be using the following two suspend functions in the questionssuspend fun doLongRunningTaskOne(): Int { delay(2400) println(\"Task one is getting executed\") return 33}suspend fun doLongRunningTaskTwo(): Int { delay(1500) println(\"Task two is getting executed\") return 6}Let’s jump right in now:Question 1runBlocking { doLongRunningTaskOne() doLongRunningTaskTwo() println(\"Fired both tasks\")}println(\"Completed my execution\")OutputTask one is getting executedTask two is getting executedFired both tasksCompleted my executionExplanationrunBlocking gives us a coroutine scope on main threadIt is a blocking call which means until the code inside runBlocking is completed, the next statements will not be executedBy default, the code inside a coroutine is sequentialSo first the task one gets completed, then the second task is called, and when that gets completed, the last print statement is executedQuestion 2runBlocking { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines\") }println(\"Completed my execution\")OutputI've launched both coroutinesTask two is getting executedTask one is getting executedCompleted my executionExplanationlaunch is fire and forget, it doesn’t care about the result returned by the tasks. So both the child coroutines (launch) start executing on different threads and don’t block our main threadSince they will take some time to run, the first statement printed is “I’ve launched both coroutines”Task two is executed faster as it has shorted delay in it that’s why the next statement printed is from task 2Then the print statement in task one is printedLastly, since runBlocking is a blocking call, no code is executed outside it until it’s execution is completed. So once it is completed, the last “Completed my execution” statement is printedQuestion 3runBlocking { coroutineScope { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines\") } println(\"I'm outside coroutineScope\")}println(\"Completed my execution\")OutputI've launched both coroutinesTask two is getting executedTask one is getting executedI'm outside coroutineScopeCompleted my executionExplanationWhat’s changed here is that we have added a coroutineScope inside runBlocking and both the launch methods are called inside itcoroutineScope is a suspending function so the “I’m outside coroutineScope” statement will be printed after the coroutineScope has completed it’s executionQuestion 4runBlocking { coroutineScope { launch { doLongRunningTaskOne() }.join() launch { doLongRunningTaskTwo() }.join() println(\"I've launched both coroutines\") } println(\"I'm outside coroutineScope\")}println(\"Completed my execution\")OutputTask one is getting executedTask two is getting executedI've launched both coroutinesI'm outside coroutineScopeCompleted my executionExplanationHere we have added join() on the two launch functionsjoin is a suspending function, it waits for the coroutine to complete before moving to the next statementThat is why the task one statement is printed first this timeThis code will take more time to execute because we have made the calls sequential hereQuestion 5runBlocking { CoroutineScope(Dispatchers.IO).launch { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines\") } println(\"I'm outside coroutineScope\")}println(\"Completed my execution\")OutputI'm outside coroutineScopeCompleted my executionExplanationWhooo!!! What happened here??None of the code inside the custom coroutine scope got executedThe runBlocking scope finished even before the CoroutineScope could get finishedThis is because the runBlocking function is intended to block the current thread until it’s scope completed.However, any nested coroutines scopes launched within it will not be awaited unless explicitly done soQuestion 6runBlocking { CoroutineScope(Dispatchers.IO).launch { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines\") }.join() println(\"I'm outside coroutineScope\")}println(\"Completed my execution\")OutputI've launched both coroutinesTask two is getting executedTask one is getting executedI'm outside coroutineScopeCompleted my executionExplanationThis time the block of code inside the custom Coroutine scope gets executed because we added join to addJoin is a suspend function which asks the system to wait until it’s execution is completedQuestion 7runBlocking { CoroutineScope(Dispatchers.IO).launch { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines of scope 1\") CoroutineScope(Dispatchers.IO).launch { launch { doLongRunningTaskOne() } launch { doLongRunningTaskTwo() } println(\"I've launched both coroutines of scope 2\") } }.join() println(\"I'm outside coroutineScope\") }println(\"Completed my execution\")OutputI've launched both coroutines of scope 1I've launched both coroutines of scope 2Task two is getting executedTask two is getting executedTask one is getting executedTask one is getting executedI'm outside coroutineScopeCompleted my executionExplanationHere we didn’t add join to the second nested coroutine scope but still it got executedQuestion 8runBlocking { val one = async { doSomethingUsefulOne() } val two = async { doSomethingUsefulTwo() } println(\"Final answer is ${one.await() + two.await()}\")}OutputTask two is getting executedTask one is getting executedFinal answer is 39Completed my executionExplanationHere we are using the result returned by our two suspend functionsBoth the suspend functions are called parallellyawait is a suspend functions which blocks the main thread. It gets the result from the Deferred objectQuestion 9runBlocking { val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() } val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() } println(\"Final answer is ${one.await() + two.await()}\")}println(\"Completed my execution\")OutputTask one is getting executedTask two is getting executedFinal answer is 39Completed my executionExplanationThis code is executed sequentially because we used Lazy start for our coroutinesWhat Lazy does is it starts the coroutine only when it’s result is requiredSo when we write our print statement, we called one.await first so the system waits until it gets the result for the first task which would be after around 2400 msOnce it gets result of first task, then it starts second task and get’s it’s result after another 1500 msSo this block of code will take more time as compared to our last code(Question 6) because of sequential callsQuestion 10runBlocking { val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() } val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() } one.start() two.start() println(\"Final answer is ${one.await() + two.await()}\") } println(\"Completed my execution\")OutputTask two is getting executedTask one is getting executedFinal answer is 39Completed my executionExplanationThis time the output is same as Question 6 because even though we used lazy start, we started the coroutines parallelly before using them in the same print statementThe time taken to execute this block of code will also be same as the one in Question 6Question 11runBlocking { launch { repeat(5){ println(\"Iteration $it in Coroutine 1\") } } launch { repeat(5){ println(\"Iteration $it in Coroutine 2\") } } }OutputIteration 0 in Coroutine 1Iteration 1 in Coroutine 1Iteration 2 in Coroutine 1Iteration 3 in Coroutine 1Iteration 4 in Coroutine 1Iteration 0 in Coroutine 2Iteration 1 in Coroutine 2Iteration 2 in Coroutine 2Iteration 3 in Coroutine 2Iteration 4 in Coroutine 2ExplanationEven though both launch coroutines are running in parallel, the first coroutine completes instantaneously since there is no much computation involved.Question 12runBlocking { launch { repeat(5){ println(\"Iteration $it in Coroutine 1\") yield() } } launch { repeat(5){ println(\"Iteration $it in Coroutine 2\") } } }OutputIteration 0 in Coroutine 1Iteration 0 in Coroutine 2Iteration 1 in Coroutine 2Iteration 2 in Coroutine 2Iteration 3 in Coroutine 2Iteration 4 in Coroutine 2Iteration 1 in Coroutine 1Iteration 2 in Coroutine 1Iteration 3 in Coroutine 1Iteration 4 in Coroutine 1Explanationyield is a suspending function which tells the coroutine scheduler that this coroutine wants to pause it’s execution and allow other coroutines to use this threadSo what happens here is, after the first iteration in the first coroutine, it encounters yield, asking the scheduler to pause it’s executionScheduler looks if there are other coroutines which need to be executedWhen it finds one it starts executing the second coroutine and completes itAfter the second coroutine is completed, it again jumps back to the first coroutine and resume it’s executionQuestion 13runBlocking { launch { repeat(5){ println(\"Iteration $it in Coroutine 1\") yield() } } launch { repeat(5){ println(\"Iteration $it in Coroutine 2\") yield() } } }OutputIteration 0 in Coroutine 1Iteration 0 in Coroutine 2Iteration 1 in Coroutine 1Iteration 1 in Coroutine 2Iteration 2 in Coroutine 1Iteration 2 in Coroutine 2Iteration 3 in Coroutine 1Iteration 3 in Coroutine 2Iteration 4 in Coroutine 1Iteration 4 in Coroutine 2ExplanationHere yield is there is both the coroutinesAfter the first iteration in Coroutine 1, it looks if there are other coroutines waiting to be executedIt finds one and starts executing Coroutine 2After the first iteration of Coroutine 2, it again finds yield, which means pause coroutine 2So it again looks for waiting coroutines, and it finds that Coroutine 1 is paused and waiting to be resumedSo it resumes Coroutine 1, where again after second iteration it finds yield and is again pausedThis process continues until both the coroutines are completedQuestion 14runBlocking { launch { repeat(5){ println(\"Iteration $it in Coroutine 1\") yield() } }}OutputIteration 0 in Coroutine 1Iteration 1 in Coroutine 1Iteration 2 in Coroutine 1Iteration 3 in Coroutine 1Iteration 4 in Coroutine 1ExplanationSince there is one coroutine, yield has no affect on the outputIt executes all the iteration and completes the coroutine in a single goQuestion 15runBlocking { val job = launch { repeat(1000) { doLongRunningTaskTwo() } } delay(4000L) println(\"I'm tired of waiting!\") job.cancel() job.join() println(\"Now I can quit.\")}OutputTask two is getting executedTask two is getting executedI'm tired of waiting!Now I can quit.ExplanationThe task two takes 1500 ms to get executedAnd we have cancelled our job after 4000 ms that’s why task two got executed only twice as 2 iterations took 3000 msThird iteration would have returned at 4500 ms before which we cancelled our jobQuestion 16runBlocking { var sum = 0 val job = launch(Dispatchers.Default) { for (i in 1..1000) { sum += i println(\"Partial sum after $i iterations: $sum\") } } delay(5) println(\"I'm tired of waiting!\") job.cancelAndJoin() println(\"Now I can quit.\")}OutputPartial sum after 1 iterations: 1Partial sum after 2 iterations: 3...Partial sum after 999 iterations: 499500Partial sum after 1000 iterations: 500500I'm tired of waiting!Now I can quitExplanationWhat happened here???We cancelled the job only after 5 ms and still the coroutine didn’t get cancelledIt executed all the iterations and a 1000 sum iterations could not have completed in 5 msThis is because the all the suspend functions inside a coroutine are cancellable. They check for cancellation of coroutine and throw CancellationException when cancelled.However, if a coroutine is working on a computation, it will not check for cancellation, hence can not be cancelled.Question 17runBlocking { var sum = 0 val job = launch(Dispatchers.Default) { for (i in 1..1000) { sum += i println(\"Partial sum after $i iterations: $sum\") delay(500) } } println(\"I'm tired of waiting!\") job.cancelAndJoin() println(\"Now I can quit.\")}OutputI'm tired of waiting!Partial sum after 1 iterations: 1Now I can quit.ExplanationIn this case, there is a delay after each iteration which is a suspend function and suspend functions checks for cancellationsSo, before the loop could go over to the second iteration, the launch coroutine is cancelledThat is why only iteration of the loop get’s executedAlso, notice that in this case “I’m tired of waiting!” is printed before even the first iteration where as in the last question, it was printed after the 1000 iterations of the loopIf here also we add a delay before the “I’m tired of waiting!” print statement, it would have been printed after the loop iterationsQuestion 18runBlocking { var sum = 0 val job = launch(Dispatchers.Default) { for (i in 1..1000) { yield() sum += i println(\"Partial sum after $i iterations: $sum\") } } println(\"I'm tired of waiting!\") job.cancelAndJoin() println(\"Now I can quit.\")}OutputI'm tired of waiting!Partial sum after 1 iterations: 1Partial sum after 2 iterations: 3...Partial sum after 49 iterations: 1225Partial sum after 50 iterations: 1275Now I can quit.ExplanationHere also, the code got cancelled before completing the 1000 iterationsThis is because yield is also a suspend function so this also allows us to cancel computable codeThough this is not the primary purpose of yield but it does our jobQuestion 19runBlocking { var sum = 0 val job = launch(Dispatchers.Default) { for (i in 1..1000) { if (isActive) { sum += i println(\"Partial sum after $i iterations: $sum\") } } } println(\"I'm tired of waiting!\") job.cancelAndJoin() println(\"Now I can quit.\")}OutputI'm tired of waiting!Partial sum after 1 iterations: 1Partial sum after 2 iterations: 3...Partial sum after 246 iterations: 30381Partial sum after 247 iterations: 30628Now I can quit.ExplanationThis is the primary way we can check for cancellations in a coroutine which allows computationisActive checks if the coroutine is active or has been cancelledIf we find the cancellation of the coroutine has been requested then we don’t execute the next iterations, hence achieving cancellation in a computable codeThat’s it for this article. Hope it was helpful! If you like it, please hit like.Other articles of this series:Exploring Coroutine ContextComposing Suspend FunctionsCoroutine Cancellations and TimeoutsKotlin Coroutines",
  "image": "https://miro.medium.com/v2/resize:fit:924/1*qgzGgrMeE9raugNDYbsfVQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://tanyandroid.medium.com/?source=post_page---byline--aa0760383569--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Tanya Arora\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*yEkfsQNgR3VHbOT2VzHrIg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--aa0760383569--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"afa2\"\u003eIn this unique blog, we delve into the world of Kotlin coroutines through a series of output questions. Each question presents a distinct scenario, allowing us to understand and reinforce our knowledge of coroutine concepts. By exploring and analyzing the outputs, we gain a deeper understanding of the behavior and intricacies of Kotlin coroutines. Join me on this journey as we unravel the power of coroutines in Kotlin and enhance our proficiency in concurrent programming.\u003c/p\u003e\u003cp id=\"e903\"\u003eI’ll be using the following two suspend functions in the questions\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c0d5\"\u003esuspend fun doLongRunningTaskOne(): Int {\u003cbr/\u003e    delay(2400)\u003cbr/\u003e    println(\u0026#34;Task one is getting executed\u0026#34;)\u003cbr/\u003e    return 33\u003cbr/\u003e}\u003cp\u003esuspend fun doLongRunningTaskTwo(): Int {\u003cbr/\u003e    delay(1500)\u003cbr/\u003e    println(\u0026#34;Task two is getting executed\u0026#34;)\u003cbr/\u003e    return 6\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b96e\"\u003eLet’s jump right in now:\u003c/p\u003e\u003ch2 id=\"662b\"\u003eQuestion 1\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"2c52\"\u003erunBlocking {\u003cbr/\u003e        doLongRunningTaskOne()\u003cbr/\u003e        doLongRunningTaskTwo()\u003cbr/\u003e        println(\u0026#34;Fired both tasks\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f5a4\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bbf3\"\u003eTask one is getting executed\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eFired both tasks\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"cf2e\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"01dd\"\u003erunBlocking gives us a coroutine scope on main thread\u003c/li\u003e\u003cli id=\"ee75\"\u003eIt is a blocking call which means until the code inside runBlocking is completed, the next statements will not be executed\u003c/li\u003e\u003cli id=\"08f0\"\u003eBy default, the code inside a coroutine is sequential\u003c/li\u003e\u003cli id=\"e668\"\u003eSo first the task one gets completed, then the second task is called, and when that gets completed, the last print statement is executed\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5e64\"\u003eQuestion 2\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"045c\"\u003erunBlocking {\u003cbr/\u003e        launch { doLongRunningTaskOne() }\u003cbr/\u003e        launch { doLongRunningTaskTwo() }\u003cbr/\u003e        println(\u0026#34;I\u0026#39;ve launched both coroutines\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7c69\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a811\"\u003eI\u0026#39;ve launched both coroutines\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c7d1\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"88c4\"\u003elaunch is fire and forget, it doesn’t care about the result returned by the tasks. So both the child coroutines (launch) start executing on different threads and don’t block our main thread\u003c/li\u003e\u003cli id=\"f410\"\u003eSince they will take some time to run, the first statement printed is “I’ve launched both coroutines”\u003c/li\u003e\u003cli id=\"620c\"\u003eTask two is executed faster as it has shorted delay in it that’s why the next statement printed is from task 2\u003c/li\u003e\u003cli id=\"0947\"\u003eThen the print statement in task one is printed\u003c/li\u003e\u003cli id=\"1234\"\u003eLastly, since runBlocking is a blocking call, no code is executed outside it until it’s execution is completed. So once it is completed, the last “Completed my execution” statement is printed\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0604\"\u003eQuestion 3\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9a01\"\u003erunBlocking {\u003cbr/\u003e        coroutineScope {\u003cbr/\u003e            launch { doLongRunningTaskOne() }\u003cbr/\u003e            launch { doLongRunningTaskTwo() }\u003cbr/\u003e            println(\u0026#34;I\u0026#39;ve launched both coroutines\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m outside coroutineScope\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d2a9\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9566\"\u003eI\u0026#39;ve launched both coroutines\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eI\u0026#39;m outside coroutineScope\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3f8e\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"20e5\"\u003eWhat’s changed here is that we have added a coroutineScope inside runBlocking and both the launch methods are called inside it\u003c/li\u003e\u003cli id=\"b0b0\"\u003ecoroutineScope is a suspending function so the “I’m outside coroutineScope” statement will be printed after the coroutineScope has completed it’s execution\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"146a\"\u003eQuestion 4\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9c69\"\u003erunBlocking {\u003cbr/\u003e        coroutineScope {\u003cbr/\u003e            launch { doLongRunningTaskOne() }.join()\u003cbr/\u003e            launch { doLongRunningTaskTwo() }.join()\u003cbr/\u003e            println(\u0026#34;I\u0026#39;ve launched both coroutines\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m outside coroutineScope\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7835\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d2f0\"\u003eTask one is getting executed\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eI\u0026#39;ve launched both coroutines\u003cbr/\u003eI\u0026#39;m outside coroutineScope\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"26f5\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5ad2\"\u003eHere we have added join() on the two launch functions\u003c/li\u003e\u003cli id=\"dbcb\"\u003ejoin is a suspending function, it waits for the coroutine to complete before moving to the next statement\u003c/li\u003e\u003cli id=\"1d5a\"\u003eThat is why the task one statement is printed first this time\u003c/li\u003e\u003cli id=\"d927\"\u003eThis code will take more time to execute because we have made the calls sequential here\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"706c\"\u003eQuestion 5\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"b8c7\"\u003erunBlocking {\u003cbr/\u003e        CoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e            launch { doLongRunningTaskOne() }\u003cbr/\u003e            launch { doLongRunningTaskTwo() }\u003cbr/\u003e            println(\u0026#34;I\u0026#39;ve launched both coroutines\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m outside coroutineScope\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1439\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6fcc\"\u003eI\u0026#39;m outside coroutineScope\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3f34\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d645\"\u003eWhooo!!! What happened here??\u003c/li\u003e\u003cli id=\"b2f5\"\u003eNone of the code inside the custom coroutine scope got executed\u003c/li\u003e\u003cli id=\"8404\"\u003eThe runBlocking scope finished even before the CoroutineScope could get finished\u003c/li\u003e\u003cli id=\"7abf\"\u003eThis is because the runBlocking function is intended to block the current thread until it’s scope completed.\u003c/li\u003e\u003cli id=\"2722\"\u003eHowever, any nested coroutines scopes launched within it will not be awaited unless explicitly done so\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"dcee\"\u003eQuestion 6\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"d5bf\"\u003erunBlocking {\u003cbr/\u003e        CoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e            launch { doLongRunningTaskOne() }\u003cbr/\u003e            launch { doLongRunningTaskTwo() }\u003cbr/\u003e            println(\u0026#34;I\u0026#39;ve launched both coroutines\u0026#34;)\u003cbr/\u003e        }.join()\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m outside coroutineScope\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"08f1\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7fb4\"\u003eI\u0026#39;ve launched both coroutines\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eI\u0026#39;m outside coroutineScope\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6396\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"63fe\"\u003eThis time the block of code inside the custom Coroutine scope gets executed because we added join to add\u003c/li\u003e\u003cli id=\"21a8\"\u003eJoin is a suspend function which asks the system to wait until it’s execution is completed\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f45c\"\u003eQuestion 7\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"a745\"\u003erunBlocking {\u003cbr/\u003e        CoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e            launch { doLongRunningTaskOne() }\u003cbr/\u003e            launch { doLongRunningTaskTwo() }\u003cbr/\u003e            println(\u0026#34;I\u0026#39;ve launched both coroutines of scope 1\u0026#34;)\u003cp\u003e            CoroutineScope(Dispatchers.IO).launch {\u003cbr/\u003e                launch { doLongRunningTaskOne() }\u003cbr/\u003e                launch { doLongRunningTaskTwo() }\u003cbr/\u003e                println(\u0026#34;I\u0026#39;ve launched both coroutines of scope 2\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }.join()\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m outside coroutineScope\u0026#34;)\u003cbr/\u003e }\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6efd\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8bb\"\u003eI\u0026#39;ve launched both coroutines of scope 1\u003cbr/\u003eI\u0026#39;ve launched both coroutines of scope 2\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eI\u0026#39;m outside coroutineScope\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f590\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1292\"\u003eHere we didn’t add join to the second nested coroutine scope but still it got executed\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c0f3\"\u003eQuestion 8\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"009f\"\u003erunBlocking {\u003cbr/\u003e        val one = async { doSomethingUsefulOne() }\u003cbr/\u003e        val two = async { doSomethingUsefulTwo() }\u003cbr/\u003e        println(\u0026#34;Final answer is ${one.await() + two.await()}\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eeba\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fe76\"\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eFinal answer is 39\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bf8e\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c0ba\"\u003eHere we are using the result returned by our two suspend functions\u003c/li\u003e\u003cli id=\"0d16\"\u003eBoth the suspend functions are called parallelly\u003c/li\u003e\u003cli id=\"5aea\"\u003eawait is a suspend functions which blocks the main thread. It gets the result from the Deferred object\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"8c14\"\u003eQuestion 9\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4957\"\u003erunBlocking {\u003cbr/\u003e        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\u003cbr/\u003e        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\u003cbr/\u003e        println(\u0026#34;Final answer is ${one.await() + two.await()}\u0026#34;)\u003cbr/\u003e}\u003cbr/\u003eprintln(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"070c\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4822\"\u003eTask one is getting executed\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eFinal answer is 39\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"db4c\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e6ad\"\u003eThis code is executed sequentially because we used Lazy start for our coroutines\u003c/li\u003e\u003cli id=\"a485\"\u003eWhat Lazy does is it starts the coroutine only when it’s result is required\u003c/li\u003e\u003cli id=\"4913\"\u003eSo when we write our print statement, we called one.await first so the system waits until it gets the result for the first task which would be after around 2400 ms\u003c/li\u003e\u003cli id=\"c236\"\u003eOnce it gets result of first task, then it starts second task and get’s it’s result after another 1500 ms\u003c/li\u003e\u003cli id=\"4c75\"\u003eSo this block of code will take more time as compared to our last code(Question 6) because of sequential calls\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5227\"\u003eQuestion 10\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"4015\"\u003erunBlocking {\u003cbr/\u003e        val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }\u003cbr/\u003e        val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }\u003cbr/\u003e        one.start()\u003cbr/\u003e        two.start()\u003cbr/\u003e        println(\u0026#34;Final answer is ${one.await() + two.await()}\u0026#34;)\u003cbr/\u003e }\u003cbr/\u003e println(\u0026#34;Completed my execution\u0026#34;)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bcdf\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1290\"\u003eTask two is getting executed\u003cbr/\u003eTask one is getting executed\u003cbr/\u003eFinal answer is 39\u003cbr/\u003eCompleted my execution\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c7cb\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8218\"\u003eThis time the output is same as Question 6 because even though we used lazy start, we started the coroutines parallelly before using them in the same print statement\u003c/li\u003e\u003cli id=\"27ad\"\u003eThe time taken to execute this block of code will also be same as the one in Question 6\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"556e\"\u003eQuestion 11\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"1417\"\u003erunBlocking {\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 1\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 2\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5451\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a4d\"\u003eIteration 0 in Coroutine 1\u003cbr/\u003eIteration 1 in Coroutine 1\u003cbr/\u003eIteration 2 in Coroutine 1\u003cbr/\u003eIteration 3 in Coroutine 1\u003cbr/\u003eIteration 4 in Coroutine 1\u003cbr/\u003eIteration 0 in Coroutine 2\u003cbr/\u003eIteration 1 in Coroutine 2\u003cbr/\u003eIteration 2 in Coroutine 2\u003cbr/\u003eIteration 3 in Coroutine 2\u003cbr/\u003eIteration 4 in Coroutine 2\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"87af\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6036\"\u003eEven though both launch coroutines are running in parallel, the first coroutine completes instantaneously since there is no much computation involved.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0664\"\u003eQuestion 12\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"7906\"\u003erunBlocking {\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 1\u0026#34;)\u003cbr/\u003e                yield()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 2\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0486\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4b67\"\u003eIteration 0 in Coroutine 1\u003cbr/\u003eIteration 0 in Coroutine 2\u003cbr/\u003eIteration 1 in Coroutine 2\u003cbr/\u003eIteration 2 in Coroutine 2\u003cbr/\u003eIteration 3 in Coroutine 2\u003cbr/\u003eIteration 4 in Coroutine 2\u003cbr/\u003eIteration 1 in Coroutine 1\u003cbr/\u003eIteration 2 in Coroutine 1\u003cbr/\u003eIteration 3 in Coroutine 1\u003cbr/\u003eIteration 4 in Coroutine 1\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9277\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"083c\"\u003eyield is a suspending function which tells the coroutine scheduler that this coroutine wants to pause it’s execution and allow other coroutines to use this thread\u003c/li\u003e\u003cli id=\"a223\"\u003eSo what happens here is, after the first iteration in the first coroutine, it encounters yield, asking the scheduler to pause it’s execution\u003c/li\u003e\u003cli id=\"d2cd\"\u003eScheduler looks if there are other coroutines which need to be executed\u003c/li\u003e\u003cli id=\"6a5f\"\u003eWhen it finds one it starts executing the second coroutine and completes it\u003c/li\u003e\u003cli id=\"824c\"\u003eAfter the second coroutine is completed, it again jumps back to the first coroutine and resume it’s execution\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"9a07\"\u003eQuestion 13\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"08f8\"\u003erunBlocking {\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 1\u0026#34;)\u003cbr/\u003e                yield()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e         launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 2\u0026#34;)\u003cbr/\u003e                yield()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3191\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6936\"\u003eIteration 0 in Coroutine 1\u003cbr/\u003eIteration 0 in Coroutine 2\u003cbr/\u003eIteration 1 in Coroutine 1\u003cbr/\u003eIteration 1 in Coroutine 2\u003cbr/\u003eIteration 2 in Coroutine 1\u003cbr/\u003eIteration 2 in Coroutine 2\u003cbr/\u003eIteration 3 in Coroutine 1\u003cbr/\u003eIteration 3 in Coroutine 2\u003cbr/\u003eIteration 4 in Coroutine 1\u003cbr/\u003eIteration 4 in Coroutine 2\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"18f7\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"a655\"\u003eHere yield is there is both the coroutines\u003c/li\u003e\u003cli id=\"4d6f\"\u003eAfter the first iteration in Coroutine 1, it looks if there are other coroutines waiting to be executed\u003c/li\u003e\u003cli id=\"a4b1\"\u003eIt finds one and starts executing Coroutine 2\u003c/li\u003e\u003cli id=\"ce2b\"\u003eAfter the first iteration of Coroutine 2, it again finds yield, which means pause coroutine 2\u003c/li\u003e\u003cli id=\"084b\"\u003eSo it again looks for waiting coroutines, and it finds that Coroutine 1 is paused and waiting to be resumed\u003c/li\u003e\u003cli id=\"b861\"\u003eSo it resumes Coroutine 1, where again after second iteration it finds yield and is again paused\u003c/li\u003e\u003cli id=\"7b8c\"\u003eThis process continues until both the coroutines are completed\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"322f\"\u003eQuestion 14\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"fb5d\"\u003erunBlocking {\u003cbr/\u003e        launch {\u003cbr/\u003e            repeat(5){\u003cbr/\u003e                println(\u0026#34;Iteration $it in Coroutine 1\u0026#34;)\u003cbr/\u003e                yield()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dbbc\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6a92\"\u003eIteration 0 in Coroutine 1\u003cbr/\u003eIteration 1 in Coroutine 1\u003cbr/\u003eIteration 2 in Coroutine 1\u003cbr/\u003eIteration 3 in Coroutine 1\u003cbr/\u003eIteration 4 in Coroutine 1\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fa8a\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4ce5\"\u003eSince there is one coroutine, yield has no affect on the output\u003c/li\u003e\u003cli id=\"dc04\"\u003eIt executes all the iteration and completes the coroutine in a single go\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3099\"\u003eQuestion 15\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"93fb\"\u003erunBlocking {\u003cbr/\u003e        val job = launch {\u003cbr/\u003e            repeat(1000) {\u003cbr/\u003e                doLongRunningTaskTwo()\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        delay(4000L)\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m tired of waiting!\u0026#34;)\u003cbr/\u003e        job.cancel()\u003cbr/\u003e        job.join()\u003cbr/\u003e        println(\u0026#34;Now I can quit.\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"fc18\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"de10\"\u003eTask two is getting executed\u003cbr/\u003eTask two is getting executed\u003cbr/\u003eI\u0026#39;m tired of waiting!\u003cbr/\u003eNow I can quit.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e675\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6336\"\u003eThe task two takes 1500 ms to get executed\u003c/li\u003e\u003cli id=\"1b1b\"\u003eAnd we have cancelled our job after 4000 ms that’s why task two got executed only twice as 2 iterations took 3000 ms\u003c/li\u003e\u003cli id=\"6a7a\"\u003eThird iteration would have returned at 4500 ms before which we cancelled our job\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"257d\"\u003eQuestion 16\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"5e16\"\u003erunBlocking {\u003cbr/\u003e        var sum = 0\u003cbr/\u003e        val job = launch(Dispatchers.Default) {\u003cbr/\u003e            for (i in 1..1000) {\u003cbr/\u003e                sum += i\u003cbr/\u003e                println(\u0026#34;Partial sum after $i iterations: $sum\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        delay(5)\u003cbr/\u003e        println(\u0026#34;I\u0026#39;m tired of waiting!\u0026#34;)\u003cbr/\u003e        job.cancelAndJoin()\u003cbr/\u003e        println(\u0026#34;Now I can quit.\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"0498\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1c0c\"\u003ePartial sum after 1 iterations: 1\u003cbr/\u003ePartial sum after 2 iterations: 3\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003ePartial sum after 999 iterations: 499500\u003cbr/\u003ePartial sum after 1000 iterations: 500500\u003cbr/\u003eI\u0026#39;m tired of waiting!\u003cbr/\u003eNow I can quit\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8f79\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"bb5a\"\u003eWhat happened here???\u003c/li\u003e\u003cli id=\"bc7f\"\u003eWe cancelled the job only after 5 ms and still the coroutine didn’t get cancelled\u003c/li\u003e\u003cli id=\"3c53\"\u003eIt executed all the iterations and a 1000 sum iterations could not have completed in 5 ms\u003c/li\u003e\u003cli id=\"162d\"\u003eThis is because the all the suspend functions inside a coroutine are cancellable. They check for cancellation of coroutine and throw CancellationException when cancelled.\u003c/li\u003e\u003cli id=\"5891\"\u003eHowever, if a coroutine is working on a computation, it will not check for cancellation, hence can not be cancelled.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2ee9\"\u003eQuestion 17\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"694d\"\u003erunBlocking {\u003cbr/\u003e    var sum = 0\u003cbr/\u003e    val job = launch(Dispatchers.Default) {\u003cbr/\u003e        for (i in 1..1000) {\u003cbr/\u003e            sum += i\u003cbr/\u003e            println(\u0026#34;Partial sum after $i iterations: $sum\u0026#34;)\u003cbr/\u003e            delay(500)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;I\u0026#39;m tired of waiting!\u0026#34;)\u003cbr/\u003e    job.cancelAndJoin()\u003cbr/\u003e    println(\u0026#34;Now I can quit.\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dcf9\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3e3d\"\u003eI\u0026#39;m tired of waiting!\u003cbr/\u003ePartial sum after 1 iterations: 1\u003cbr/\u003eNow I can quit.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ef5b\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e8e4\"\u003eIn this case, there is a delay after each iteration which is a suspend function and suspend functions checks for cancellations\u003c/li\u003e\u003cli id=\"3ecf\"\u003eSo, before the loop could go over to the second iteration, the launch coroutine is cancelled\u003c/li\u003e\u003cli id=\"9e04\"\u003eThat is why only iteration of the loop get’s executed\u003c/li\u003e\u003cli id=\"5cbd\"\u003eAlso, notice that in this case “I’m tired of waiting!” is printed before even the first iteration where as in the last question, it was printed after the 1000 iterations of the loop\u003c/li\u003e\u003cli id=\"32a4\"\u003eIf here also we add a delay before the “I’m tired of waiting!” print statement, it would have been printed after the loop iterations\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b69a\"\u003eQuestion 18\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"9fe0\"\u003erunBlocking {\u003cbr/\u003e    var sum = 0\u003cbr/\u003e    val job = launch(Dispatchers.Default) {\u003cbr/\u003e        for (i in 1..1000) {\u003cbr/\u003e            yield()\u003cbr/\u003e            sum += i\u003cbr/\u003e            println(\u0026#34;Partial sum after $i iterations: $sum\u0026#34;)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;I\u0026#39;m tired of waiting!\u0026#34;)\u003cbr/\u003e    job.cancelAndJoin()\u003cbr/\u003e    println(\u0026#34;Now I can quit.\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e75a\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3992\"\u003eI\u0026#39;m tired of waiting!\u003cbr/\u003ePartial sum after 1 iterations: 1\u003cbr/\u003ePartial sum after 2 iterations: 3\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003ePartial sum after 49 iterations: 1225\u003cbr/\u003ePartial sum after 50 iterations: 1275\u003cbr/\u003eNow I can quit.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c3e8\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"333c\"\u003eHere also, the code got cancelled before completing the 1000 iterations\u003c/li\u003e\u003cli id=\"1d89\"\u003eThis is because yield is also a suspend function so this also allows us to cancel computable code\u003c/li\u003e\u003cli id=\"f8ce\"\u003eThough this is not the primary purpose of yield but it does our job\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f3c1\"\u003eQuestion 19\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"aa68\"\u003erunBlocking {\u003cbr/\u003e    var sum = 0\u003cbr/\u003e    val job = launch(Dispatchers.Default) {\u003cbr/\u003e        for (i in 1..1000) {\u003cbr/\u003e            if (isActive) {\u003cbr/\u003e                sum += i\u003cbr/\u003e                println(\u0026#34;Partial sum after $i iterations: $sum\u0026#34;)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    println(\u0026#34;I\u0026#39;m tired of waiting!\u0026#34;)\u003cbr/\u003e    job.cancelAndJoin()\u003cbr/\u003e    println(\u0026#34;Now I can quit.\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7be1\"\u003e\u003cstrong\u003eOutput\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eeea\"\u003eI\u0026#39;m tired of waiting!\u003cbr/\u003ePartial sum after 1 iterations: 1\u003cbr/\u003ePartial sum after 2 iterations: 3\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003e.\u003cbr/\u003ePartial sum after 246 iterations: 30381\u003cbr/\u003ePartial sum after 247 iterations: 30628\u003cbr/\u003eNow I can quit.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"85cb\"\u003e\u003cstrong\u003eExplanation\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0e2e\"\u003eThis is the primary way we can check for cancellations in a coroutine which allows computation\u003c/li\u003e\u003cli id=\"3d09\"\u003eisActive checks if the coroutine is active or has been cancelled\u003c/li\u003e\u003cli id=\"566f\"\u003eIf we find the cancellation of the coroutine has been requested then we don’t execute the next iterations, hence achieving cancellation in a computable code\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d3b3\"\u003e\u003cem\u003eThat’s it for this article. Hope it was helpful! If you like it, please hit \u003c/em\u003elike.\u003c/p\u003e\u003cp id=\"2e6f\"\u003e\u003cstrong\u003eOther articles of this series:\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"a384\"\u003e\u003ca href=\"https://tanyatechzone.com/2024/06/26/exploring-coroutinecontext/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eExploring Coroutine Context\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"20be\"\u003e\u003ca href=\"https://tanyatechzone.com/2024/05/15/composing-suspend-functions/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eComposing Suspend Functions\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"7f82\"\u003e\u003ca href=\"https://tanyatechzone.com/2024/03/15/coroutine-cancellation-and-timeouts/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eCoroutine Cancellations and Timeouts\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003cp id=\"32a5\"\u003e\u003ca href=\"https://tanyatechzone.com/2024/02/15/kotlin-coroutines/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e\u003cstrong\u003eKotlin Coroutines\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-11-16T06:27:45.538Z",
  "modifiedTime": null
}
