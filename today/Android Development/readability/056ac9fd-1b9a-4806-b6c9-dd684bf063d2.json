{
  "id": "056ac9fd-1b9a-4806-b6c9-dd684bf063d2",
  "title": "Keeping public API in check with the Kotlin binary validator plugin",
  "link": "https://dev.to/zsmb13/keeping-public-api-in-check-with-the-kotlin-binary-validator-plugin-2b6m",
  "description": "As your library code is evolving over time, you have to be mindful of changes in your public API. Here’s how you can keep it in check.",
  "author": "Márton Braun",
  "published": "Wed, 14 Jul 2021 07:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 7941,
  "excerpt": "Within the Stream Chat Android SDK project, we use the Kotlin binary compatibility validator plugin...",
  "siteName": "DEV Community",
  "favicon": "https://media.dev.to/dynamic/image/width=192,height=,fit=scale-down,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F8j7kvp660rqzt99zui8e.png",
  "text": "Within the Stream Chat Android SDK project, we use the Kotlin binary compatibility validator plugin to keep track of all the changes we make to our public API. This is a first-party plugin by JetBrains, though it's still experimental (it's an incubator project by JetBrains on GitHub). In this article, you'll learn what the plugin does, how to set up and configure it, and how you can use it to make your library project better. Core concept Let's start with a TL;DR of what the plugin does: It generates .api files that describe the public API for each module, and if you make changes to public API, you have to explicitly update the content of the .api files (otherwise, checks will fail, alerting you of the accidental API change). By doing this, it guarantees that developers on the project are always aware of the exact changes they're making to public API. Since the plugin works on binary API, it will catch incompatible changes that might not be obvious when looking at source code. For example, when writing Kotlin code, using data classes, default implementations, or companion objects might create binary API that you're usually unaware of. Setup and configuration The binary validator is available as a simple Gradle plugin, which makes setup really quick. Just add this code to your top level build.gradle file: buildscript { dependencies { classpath 'org.jetbrains.kotlinx:binary-compatibility-validator:0.6.0' } } apply plugin: 'binary-compatibility-validator' Enter fullscreen mode Exit fullscreen mode With the plugin added, it's now time to configure it. You can do this inside the apiValidation block. Here's the configuration we use in our SDK as an example: apiValidation { ignoredPackages += [ // 1 'com/getstream/sdk/chat/databinding', 'io/getstream/chat/android/ui/databinding', ] ignoredProjects += [ // 2 'stream-chat-android-docs', 'stream-chat-android-sample', 'stream-chat-android-ui-components-sample', 'stream-chat-android-test', ] nonPublicMarkers += [ // 3 'io.getstream.chat.android.core.internal.InternalStreamChatApi', ] } Enter fullscreen mode Exit fullscreen mode Let's look at each of the options we're using: ignoredPackages allows you to exclude some packages from validation. In our case, we don't want to keep track of the files generated by View Binding. You could also use ignoredClasses to exclude individual classes by name. By default, the plugin will be enabled for all modules of a project. We use ignoredProjects to exclude non-published modules, like documentation and sample apps. The nonPublicMarkers entry allows you to specify any Kotlin Opt-in annotations that you're using on API that's not considered publicly available. To learn more about these, watch Mastering API Visibility in Kotlin. Usage To (re)generate the .api files, you'll have to run the apiDump Gradle task. When you're doing this for the first time, you should review all the generated .api files to make sure that everything in there is really supposed to be public API, and then commit them to your repository. Here's a small sample of what you'll see in these files: public abstract interface class io/getstream/chat/android/ui/StyleTransformer { public abstract fun transform (Ljava/lang/Object;)Ljava/lang/Object; } public final class io/getstream/chat/android/ui/common/Debouncer { public fun \u003cinit\u003e (J)V public final fun shutdown ()V public final fun submit (Lkotlin/jvm/functions/Function0;)V public final fun submitSuspendable (Lkotlin/jvm/functions/Function1;)V } public abstract interface class io/getstream/chat/android/ui/common/UrlSigner { public abstract fun signFileUrl (Ljava/lang/String;)Ljava/lang/String; public abstract fun signImageUrl (Ljava/lang/String;)Ljava/lang/String; } Enter fullscreen mode Exit fullscreen mode You can then use the apiCheck Gradle task to verify that your current source code still has the same API as your committed .api files. This task will create up-to-date .api dumps in temporary build folders, and compare them to the .api files you have in your repository. If they don't match, it will fail, and report the differences detected. For example, see this error the task generates after moving a property from a data class' constructor to its body: Execution failed for task ':stream-chat-android-client:apiCheck'. \u003e API check failed for project stream-chat-android-client. @@ -218,9 +218,8 @@ public final class io/getstream/chat/android/client/api/models/AutocompleteFilterObject : io/getstream/chat/android/client/api/models/FilterObject { public final fun component1 ()Ljava/lang/String; - public final fun component2 ()Ljava/lang/String; - public final fun copy (Ljava/lang/String;Ljava/lang/String;)Lio/getstream/chat/android/client/api/models/AutocompleteFilterObject; + public final fun copy (Ljava/lang/String;)Lio/getstream/chat/android/client/api/models/AutocompleteFilterObject; public fun equals (Ljava/lang/Object;)Z public final fun getFieldName ()Ljava/lang/String; public final fun getValue ()Ljava/lang/String; You can run :stream-chat-android-client:apiDump task to overwrite API declarations Enter fullscreen mode Exit fullscreen mode If those differences are intentional, you should run the apiDump task again, which updates the stored .api files, now including any changes in the API you've created by changing the source code. Running the apiCheck task at this point will complete successfully, as the sources and the .api files are in sync again. This is the goal of the plugin: making developers explicitly run a task to update the API description files when they touch public API. You should then commit the changes you've introduced to the .api files. These will show up in commits and on pull requests, allowing reviewers to easily tell when you've made changes to the binary API, and catch any unintentional changes. Git hooks and CI checks The power of the plugin really shows if you have automated checks in place to make sure that whenever you change your public API, you've actually updated the .api files to match. At Stream, we run the checks in two ways: Using a pre-commit git hook in our repository that will run the apiCheck task (and automatically run apiDump for you if it fails) when you try to create a new commit in the repository. With a GitHub Action step in our PR checks workflow that makes sure that the api files are up-to-date before we merge changes. Limitations This plugin is a binary validator. This means that it doesn't track public API changes that don't affect binary compatibility. For example, reified functions are part of source-level API but are not present in the binary API. Thankfully, changes in these should be obvious from the source file changes anyway (and they're not very frequent). There are also some known issues in the library, as you can see on GitHub. We've reported some of these ourselves, mostly for problems in respecting non-public markers, which we use extensively in our project (see #36 and #58). Conclusion Even with those limitations in mind, the binary compatibility validator plugin is a great tool for making sure that you don't make any accidental changes in your public binary API when building a library. Check it out on GitHub. You'll also find our Android Chat SDK on GitHub, and you can try our In-App Messaging Tutorial to get started with it. More library development topics you might be interested in: Our guide to Publishing Android libraries to MavenCentral Maintaining Compatibility in Kotlin Libraries Mastering API Visibility in Kotlin",
  "image": "https://media.dev.to/dynamic/image/width=1000,height=500,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Foovt8pin2ombf42knfkd.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main-title\"\u003e\n            \u003ca href=\"https://media.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Foovt8pin2ombf42knfkd.png\"\u003e\n              \u003cimg src=\"https://media.dev.to/dynamic/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Foovt8pin2ombf42knfkd.png\" width=\"1000\" height=\"420\" alt=\"Cover image for Keeping public API in check with the Kotlin binary validator plugin\"/\u003e\n            \u003c/a\u003e\n\n          \n        \u003c/div\u003e\u003cdiv data-article-id=\"758924\" id=\"article-body\"\u003e\n            \u003cp\u003eWithin the \u003ca href=\"https://github.com/GetStream/stream-chat-android\"\u003eStream Chat Android SDK\u003c/a\u003e project, we use the \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator\"\u003eKotlin binary compatibility validator plugin\u003c/a\u003e to keep track of all the changes we make to our public API. This is a first-party plugin by JetBrains, though it\u0026#39;s still experimental (it\u0026#39;s an \u003ca href=\"https://confluence.jetbrains.com/display/ALL/JetBrains+on+GitHub\"\u003eincubator project\u003c/a\u003e by JetBrains on GitHub).\u003c/p\u003e\n\n\u003cp\u003eIn this article, you\u0026#39;ll learn what the plugin does, how to set up and configure it, and how you can use it to make your library project better.\u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"core-concept\" href=\"#core-concept\"\u003e\n  \u003c/a\u003e\n  Core concept\n\u003c/h2\u003e\n\n\u003cp\u003eLet\u0026#39;s start with a TL;DR of what the plugin does:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eIt generates \u003ccode\u003e.api\u003c/code\u003e files that describe the public API for each module, and if you make changes to public API, you have to explicitly update the content of the \u003ccode\u003e.api\u003c/code\u003e files (otherwise, checks will fail, alerting you of the accidental API change).\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBy doing this, it guarantees that developers on the project are always aware of the exact changes they\u0026#39;re making to public API. Since the plugin works on binary API, it will catch incompatible changes that might not be obvious when looking at source code. For example, when writing Kotlin code, using data classes, default implementations, or companion objects might create binary API that you\u0026#39;re usually unaware of.\u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"setup-and-configuration\" href=\"#setup-and-configuration\"\u003e\n  \u003c/a\u003e\n  Setup and configuration\n\u003c/h2\u003e\n\n\u003cp\u003eThe binary validator is available as a simple Gradle plugin, which makes setup really quick. Just add this code to your top level \u003ccode\u003ebuild.gradle\u003c/code\u003e file:\u003cbr/\u003e\n\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003ebuildscript\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003edependencies\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eclasspath\u003c/span\u003e \u003cspan\u003e\u0026#39;org.jetbrains.kotlinx:binary-compatibility-validator:0.6.0\u0026#39;\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eapply\u003c/span\u003e \u003cspan\u003eplugin:\u003c/span\u003e \u003cspan\u003e\u0026#39;binary-compatibility-validator\u0026#39;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eEnter fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eExit fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eWith the plugin added, it\u0026#39;s now time to configure it. You can do this inside the \u003ccode\u003eapiValidation\u003c/code\u003e block. Here\u0026#39;s \u003ca href=\"https://github.com/GetStream/stream-chat-android/blob/fd990322367c97eafc165995de1f065a9c89d9ec/build.gradle#L66-L82\"\u003ethe configuration we use in our SDK\u003c/a\u003e as an example:\u003cbr/\u003e\n\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eapiValidation\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eignoredPackages\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e \u003cspan\u003e// 1\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;com/getstream/sdk/chat/databinding\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;io/getstream/chat/android/ui/databinding\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e]\u003c/span\u003e\n\n    \u003cspan\u003eignoredProjects\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e \u003cspan\u003e// 2\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;stream-chat-android-docs\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;stream-chat-android-sample\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;stream-chat-android-ui-components-sample\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;stream-chat-android-test\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e]\u003c/span\u003e\n\n    \u003cspan\u003enonPublicMarkers\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e \u003cspan\u003e// 3\u003c/span\u003e\n            \u003cspan\u003e\u0026#39;io.getstream.chat.android.core.internal.InternalStreamChatApi\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eEnter fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eExit fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eLet\u0026#39;s look at each of the options we\u0026#39;re using:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\n\u003ccode\u003eignoredPackages\u003c/code\u003e allows you to exclude some packages from validation. In our case, we don\u0026#39;t want to keep track of the files generated by \u003ca href=\"https://developer.android.com/topic/libraries/view-binding\"\u003eView Binding\u003c/a\u003e. You could also use \u003ccode\u003eignoredClasses\u003c/code\u003e to exclude individual classes by name.\u003c/li\u003e\n\u003cli\u003eBy default, the plugin will be enabled for all modules of a project. We use \u003ccode\u003eignoredProjects\u003c/code\u003e to exclude non-published modules, like documentation and sample apps.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003enonPublicMarkers\u003c/code\u003e entry allows you to specify any Kotlin \u003ca href=\"https://kotlinlang.org/docs/opt-in-requirements.html\"\u003eOpt-in annotations\u003c/a\u003e that you\u0026#39;re using on API that\u0026#39;s not considered publicly available. To learn more about these, watch \u003ca href=\"https://zsmb.co/talks/mastering-api-visibility/\"\u003eMastering API Visibility in Kotlin\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"usage\" href=\"#usage\"\u003e\n  \u003c/a\u003e\n  Usage\n\u003c/h2\u003e\n\n\u003cp\u003eTo (re)generate the \u003ccode\u003e.api\u003c/code\u003e files, you\u0026#39;ll have to run the \u003ccode\u003eapiDump\u003c/code\u003e Gradle task. When you\u0026#39;re doing this for the first time, you should review all the generated \u003ccode\u003e.api\u003c/code\u003e files to make sure that everything in there is \u003cem\u003ereally supposed to be\u003c/em\u003e public API, and then commit them to your repository.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a small sample of what you\u0026#39;ll see in these files:\u003cbr/\u003e\n\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003e\u003ccode\u003epublic abstract interface class io/getstream/chat/android/ui/StyleTransformer {\n    public abstract fun transform (Ljava/lang/Object;)Ljava/lang/Object;\n}\n\npublic final class io/getstream/chat/android/ui/common/Debouncer {\n    public fun \u0026lt;init\u0026gt; (J)V\n    public final fun shutdown ()V\n    public final fun submit (Lkotlin/jvm/functions/Function0;)V\n    public final fun submitSuspendable (Lkotlin/jvm/functions/Function1;)V\n}\n\npublic abstract interface class io/getstream/chat/android/ui/common/UrlSigner {\n    public abstract fun signFileUrl (Ljava/lang/String;)Ljava/lang/String;\n    public abstract fun signImageUrl (Ljava/lang/String;)Ljava/lang/String;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eEnter fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eExit fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eYou can then use the \u003ccode\u003eapiCheck\u003c/code\u003e Gradle task to verify that your current source code still has the same API as your committed \u003ccode\u003e.api\u003c/code\u003e files. This task will create up-to-date \u003ccode\u003e.api\u003c/code\u003e dumps in temporary build folders, and compare them to the \u003ccode\u003e.api\u003c/code\u003e files you have in your repository. If they don\u0026#39;t match, it will fail, and report the differences detected.\u003c/p\u003e\n\n\u003cp\u003eFor example, see this error the task generates after moving a property from a data class\u0026#39; constructor to its body:\u003cbr/\u003e\n\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003e\u003ccode\u003eExecution failed for task \u0026#39;:stream-chat-android-client:apiCheck\u0026#39;.\n\u0026gt; API check failed for project stream-chat-android-client.\n   @@ -218,9 +218,8 @@\n\n   public final class io/getstream/chat/android/client/api/models/AutocompleteFilterObject : io/getstream/chat/android/client/api/models/FilterObject {\n    public final fun component1 ()Ljava/lang/String;\n  - public final fun component2 ()Ljava/lang/String;\n  - public final fun copy (Ljava/lang/String;Ljava/lang/String;)Lio/getstream/chat/android/client/api/models/AutocompleteFilterObject;\n  + public final fun copy (Ljava/lang/String;)Lio/getstream/chat/android/client/api/models/AutocompleteFilterObject;\n    public fun equals (Ljava/lang/Object;)Z\n    public final fun getFieldName ()Ljava/lang/String;\n    public final fun getValue ()Ljava/lang/String;\n\n   You can run :stream-chat-android-client:apiDump task to overwrite API declarations\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eEnter fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20px\" height=\"20px\" viewBox=\"0 0 24 24\"\u003e\u003ctitle\u003eExit fullscreen mode\u003c/title\u003e\n    \u003cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eIf those differences are intentional, you should run the \u003ccode\u003eapiDump\u003c/code\u003e task again, which updates the stored \u003ccode\u003e.api\u003c/code\u003e files, now including any changes in the API you\u0026#39;ve created by changing the source code. Running the \u003ccode\u003eapiCheck\u003c/code\u003e task at this point will complete successfully, as the sources and the \u003ccode\u003e.api\u003c/code\u003e files are in sync again.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eThis is the goal of the plugin: making developers explicitly run a task to update the API description files when they touch public API.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eYou should then commit the changes you\u0026#39;ve introduced to the \u003ccode\u003e.api\u003c/code\u003e files. These will show up in commits and on pull requests, allowing reviewers to easily tell when you\u0026#39;ve made changes to the binary API, and catch any unintentional changes.\u003c/p\u003e\n\n\u003ch3\u003e\n  \u003ca name=\"git-hooks-and-ci-checks\" href=\"#git-hooks-and-ci-checks\"\u003e\n  \u003c/a\u003e\n  Git hooks and CI checks\n\u003c/h3\u003e\n\n\u003cp\u003eThe power of the plugin really shows if you have \u003cstrong\u003eautomated checks\u003c/strong\u003e in place to make sure that whenever you change your public API, you\u0026#39;ve actually updated the \u003ccode\u003e.api\u003c/code\u003e files to match.\u003c/p\u003e\n\n\u003cp\u003eAt Stream, we run the checks in two ways:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eUsing a pre-commit \u003ca href=\"https://github.com/GetStream/stream-chat-android/blob/fd990322367c97eafc165995de1f065a9c89d9ec/hooks/pre-commit#L16-L25\"\u003egit hook\u003c/a\u003e in our repository that will run the \u003ccode\u003eapiCheck\u003c/code\u003e task (and automatically run \u003ccode\u003eapiDump\u003c/code\u003e for you if it fails) when you try to create a new commit in the repository.\u003c/li\u003e\n\u003cli\u003eWith \u003ca href=\"https://github.com/GetStream/stream-chat-android/blob/fd990322367c97eafc165995de1f065a9c89d9ec/.github/workflows/pr-checks.yml#L19-L30\"\u003ea GitHub Action step\u003c/a\u003e in our PR checks workflow that makes sure that the \u003ccode\u003eapi\u003c/code\u003e files are up-to-date before we merge changes.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"limitations\" href=\"#limitations\"\u003e\n  \u003c/a\u003e\n  Limitations\n\u003c/h2\u003e\n\n\u003cp\u003eThis plugin is a \u003cem\u003ebinary\u003c/em\u003e validator. This means that it doesn\u0026#39;t track public API changes that don\u0026#39;t affect binary compatibility. \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator/issues/35\"\u003eFor example, reified functions are part of source-level API but are not present in the binary API\u003c/a\u003e. Thankfully, changes in these should be obvious from the source file changes anyway (and they\u0026#39;re not very frequent).\u003c/p\u003e\n\n\u003cp\u003eThere are also some known issues in the library, \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator/issues\"\u003eas you can see on GitHub\u003c/a\u003e. We\u0026#39;ve reported some of these ourselves, mostly for problems in respecting non-public markers, which we use extensively in our project (see \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator/issues/36\"\u003e#36\u003c/a\u003e and \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator/issues/58\"\u003e#58\u003c/a\u003e).\u003c/p\u003e\n\n\u003ch2\u003e\n  \u003ca name=\"conclusion\" href=\"#conclusion\"\u003e\n  \u003c/a\u003e\n  Conclusion\n\u003c/h2\u003e\n\n\u003cp\u003eEven with those limitations in mind, the binary compatibility validator plugin is a great tool for making sure that you don\u0026#39;t make any accidental changes in your public binary API when building a library. Check it out \u003ca href=\"https://github.com/Kotlin/binary-compatibility-validator\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou\u0026#39;ll also find our \u003ca href=\"https://github.com/GetStream/stream-chat-android\"\u003eAndroid Chat SDK on GitHub\u003c/a\u003e, and you can try our \u003ca href=\"https://getstream.io/tutorials/android-chat/\"\u003eIn-App Messaging Tutorial\u003c/a\u003e to get started with it.\u003c/p\u003e\n\n\u003cp\u003eMore library development topics you might be interested in:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eOur guide to \u003ca href=\"https://getstream.io/blog/publishing-libraries-to-mavencentral-2021/\"\u003ePublishing Android libraries to MavenCentral\u003c/a\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/\"\u003eMaintaining Compatibility in Kotlin Libraries\n\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zsmb.co/mastering-api-visibility-in-kotlin/\"\u003eMastering API Visibility in Kotlin\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n          \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2021-07-14T07:50:56Z",
  "modifiedTime": null
}
