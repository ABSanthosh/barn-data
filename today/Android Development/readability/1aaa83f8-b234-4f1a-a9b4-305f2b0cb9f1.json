{
  "id": "1aaa83f8-b234-4f1a-a9b4-305f2b0cb9f1",
  "title": "Migrating to the new coroutines 1.6 test APIs",
  "link": "https://medium.com/androiddevelopers/migrating-to-the-new-coroutines-1-6-test-apis-b99f7fc47774",
  "description": "See the steps we took to migrate our samples to the new APIs, and then get started on migrating your own project!",
  "author": "Márton Braun",
  "published": "Wed, 29 Jun 2022 20:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Marton Braun",
  "length": 6611,
  "excerpt": "We've recently migrated our own samples to the new coroutine testing APIs. See the steps we took to learn how you can migrate your own project too!",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "kotlinx.coroutines 1.6 introduces a set of new testing APIs, and the previous testing APIs are now deprecated. Using the old APIs will produce deprecation errors soon, and they’re scheduled to be removed completely around the end of 2022.We have recently published a guide on how to use the new testing APIs, which explains how they work in detail. In this post, we’ll focus on the migration from the old APIs by looking at how we’ve migrated some of our own samples. You can find links to view the full diffs at the end of this post.The migration steps we took should cover a lot of the necessary work for most Android projects. If you find that these are not enough for your project, you can take a look at the detailed migration guide by JetBrains which covers advanced usages of the testing APIs as well.Start with runTestLet’s start at the entry point of the new testing APIs, the runTest coroutine builder. This replaces runBlockingTest from the old APIs, which could be called as a top-level function, but it was also often invoked on a test scope, test dispatcher, or test rule.We’ve replaced all of these with calls to the top-level runTest function:If you weren’t using an expression body (directly returning runTest’s result from the function) yet, it’s a great time to adopt that convention, too! It’s nice for consistency, and it’s required if you’ll ever use the coroutine testing APIs in a multiplatform project with a KotlinJS target.In some advanced cases, you might still want to create your own TestScope, but most tests will need only to call runTest on its own.Handle the Main threadAs the Android UI thread is not available in unit tests, any tests relying on the Main dispatcher need to replace it with a TestDispatcher implementation for the duration of the test. You can either inject it like other dispatchers, or replace it using Dispatchers.setMain. Using setMain replaces the dispatcher in a static way, which means that you can use constructs that rely on a hardcoded Main dispatcher in your tests, such as viewModelScope.A frequently used method for this is to put the code replacing Main into a reusable JUnit test rule (or for JUnit 5, a test extension). You can see an example of such a rule in the iosched project. If you have a rule like this using the old APIs, update it like this:The rule is then used like this, as a property of the test class (unchanged from before):Be more eager: collecting FlowsTests often start new coroutines to collect values from Flows. These tests tend to rely on these new coroutines being started eagerly, so that whenever the Flow emits a value the collector will already be ready to process it.While runBlockingTest starts new coroutines created within the test eagerly, runTest starts them lazily instead, as it uses a StandardTestDispatcher for the test coroutine by default.To make Flow-collecting coroutines in tests start eagerly again, create a new UnconfinedTestDispatcher, and pass it to the builder that creates the collecting coroutine:Note that in this code snippet, a new TestDispatcher is created without passing in a scheduler explicitly. This is safe to do only if the Main dispatcher has been replaced by a TestDispatcher, which makes scheduler sharing automatic. Otherwise, you have to pass in the existing scheduler to any TestDispatchers you create:It’s also worth remembering that calling collect explicitly is not the only way to collect a Flow, other methods like Flow.toList() also collect the Flow internally. If you’re using such methods, you might also want to call them in new coroutines that are started with an UnconfinedTestDispatcher.Be less eager: Main dispatcher executionAs you’ve seen above in the implementation of MainDispatcherRule, we default to using UnconfinedTestDispatcher for the Main dispatcher to eagerly launch coroutines. This is useful when testing ViewModels, where using Dispatchers.Main.immediatewould have similar eager behavior in production code when called from the main thread.However, some tests in our samples needed lazy scheduling for Main dispatcher coroutines. Typically, this would be for tests that need to assert an intermediate loading state of a ViewModel, where eagerly starting the data-loading coroutine would mean that the test can only observe the final loaded state. With the old APIs, these tests used pauseDispatcher to prevent new coroutines from executing too early, like this:To perform the same test with the new APIs, the Main dispatcher needs to be set to a StandardTestDispatcher, so we need a different TestDispatcher type than what our rule uses by default. As the type of TestDispatcher used for MainDispatcherRule affects all tests within the test class, we had two choices:split tests into two test classes based on the type of Main dispatcher needed for each test, using a rule with a different type of dispatcher in the two test classes, orkeep using a single class where the rule always sets an UnconfinedTestDispatcher for Main, and then override the Main dispatcher’s type in just a few of the tests that require a different type.We opted for the latter solution, starting these tests by replacing the already-replaced TestDispatcher in Main with a new StandardTestDispatcher to lazily start new coroutines on Main. Then, later in the test code when we’d call resumeDispatcher with the old APIs, we can advance those coroutines by using advanceUntilIdle.This approach keeps tests that belong together in the same test class, making the codebase easier to navigate, with the tradeoff that some tests have to include extra code for replacing Main with the desired type of TestDispatcher.Clean up that cleanup codeFinally, some quick tidying-up to do. The iosched sample had some test code that explicitly waited for coroutines to complete on the TestCoroutineDispatcher before the test would end:However, runTest automatically waits for all known coroutines, which include children of the test coroutine and any coroutines running on TestDispatchers. This means that you can just remove any cleanup code that waits for some loose coroutines to complete!Wrap-upThese migration steps should get you most of the way toward using the new coroutine testing APIs. For more, you can check out all the changes we made in our samples:iosched PR (and a small follow-up)architecture-samples PRtrackr PRAnd of course, the new Now in Android sample app already uses the new testing APIs for its tests!Finally, if you need more help with the migration, check out the official migration guide by JetBrains, which covers the intricacies of the coroutine testing API.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*XQmi35H84FdYhY_ONP6ntQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@zsmb13?source=post_page-----b99f7fc47774--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Marton Braun\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*suFfDiFgPFED3dXss3LJHA.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page-----b99f7fc47774--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"7e28\"\u003e\u003ccode\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ekotlinx.coroutines\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/releases/tag/1.6.0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e 1.6\u003c/a\u003e introduces a set of new testing APIs, and the previous testing APIs are now deprecated. Using the old APIs will produce deprecation errors soon, and they’re scheduled to be removed completely around the end of 2022.\u003c/p\u003e\u003cp id=\"1241\"\u003eWe have recently published a \u003ca href=\"https://developer.android.com/kotlin/coroutines/test\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eguide on how to use the new testing APIs\u003c/a\u003e, which explains how they work in detail. In this post, we’ll focus on the migration from the old APIs by looking at how we’ve migrated some of our own samples. You can find links to view the full diffs at the end of this post.\u003c/p\u003e\u003cp id=\"b741\"\u003eThe migration steps we took should cover a lot of the necessary work for most Android projects. If you find that these are not enough for your project, you can take a look at the detailed \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emigration guide\u003c/a\u003e by JetBrains which covers advanced usages of the testing APIs as well.\u003c/p\u003e\u003ch2 id=\"0672\"\u003e\u003cstrong\u003eStart with runTest\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"6401\"\u003eLet’s start at the entry point of the new testing APIs, the \u003ccode\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003erunTest\u003c/a\u003e\u003c/code\u003e coroutine builder. This replaces \u003ccode\u003erunBlockingTest\u003c/code\u003e from the old APIs, which could be called as a top-level function, but it was also often invoked on a test scope, test dispatcher, or test rule.\u003c/p\u003e\u003cp id=\"5447\"\u003eWe’ve replaced all of these with calls to the top-level \u003ccode\u003erunTest\u003c/code\u003e function:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"38b4\"\u003eIf you weren’t using an expression body (directly returning \u003ccode\u003erunTest\u003c/code\u003e’s result from the function) yet, it’s a great time to adopt that convention, too! It’s nice for consistency, and it’s required if you’ll ever use the coroutine testing APIs in a multiplatform project with a KotlinJS target.\u003c/p\u003e\u003cp id=\"5416\"\u003eIn some advanced cases, you might still want to \u003ca href=\"https://developer.android.com/kotlin/coroutines/test#creating-your-own-testscope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecreate your own \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/test#creating-your-own-testscope\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTestScope\u003c/a\u003e\u003c/code\u003e, but most tests will need only to call \u003ccode\u003erunTest\u003c/code\u003e on its own.\u003c/p\u003e\u003ch2 id=\"4fca\"\u003e\u003cstrong\u003eHandle the Main thread\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0061\"\u003eAs the Android UI thread is not available in unit tests, any tests relying on the \u003ccode\u003eMain\u003c/code\u003e dispatcher need to replace it with a \u003ccode\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/test#testdispatchers\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eTestDispatcher\u003c/a\u003e\u003c/code\u003e implementation for the duration of the test. You can either \u003ca href=\"https://developer.android.com/kotlin/coroutines/test#injecting-test-dispatchers\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003einject it like other dispatchers\u003c/a\u003e, or replace it using \u003ccode\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/set-main.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDispatchers.setMain\u003c/a\u003e\u003c/code\u003e. Using \u003ccode\u003esetMain\u003c/code\u003e replaces the dispatcher in a static way, which means that you can use constructs that rely on a hardcoded \u003ccode\u003eMain\u003c/code\u003e dispatcher in your tests, such as \u003ccode\u003e\u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471\"\u003eviewModelScope\u003c/a\u003e\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"a547\"\u003eA frequently used method for this is to put the code replacing \u003ccode\u003eMain\u003c/code\u003e into a reusable \u003ca href=\"https://junit.org/junit4/javadoc/4.12/org/junit/rules/TestRule.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eJUnit test rule\u003c/a\u003e (or for JUnit 5, a test extension). You can see \u003ca href=\"https://github.com/google/iosched/blob/69db6ea7772093fc286df5d1f317aff8f3b02c5d/test-shared/src/main/java/com/google/samples/apps/iosched/test/data/MainCoroutineRule.kt#L29-L43\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ean example of such a rule\u003c/a\u003e in the iosched project. If you have a rule like this using the old APIs, update it like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fe4f\"\u003eThe rule is then used like this, as a property of the test class (unchanged from before):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"a12a\"\u003e\u003cstrong\u003eBe more eager: collecting Flows\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"8890\"\u003eTests often start new coroutines to collect values from Flows. These tests tend to rely on these new coroutines being started eagerly, so that whenever the Flow emits a value the collector will already be ready to process it.\u003c/p\u003e\u003cp id=\"e228\"\u003eWhile \u003ccode\u003erunBlockingTest\u003c/code\u003e starts new coroutines created within the test eagerly, \u003ccode\u003erunTest\u003c/code\u003e starts them lazily instead, as it uses a \u003ccode\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/test#standardtestdispatcher\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eStandardTestDispatcher\u003c/a\u003e\u003c/code\u003e for the test coroutine by default.\u003c/p\u003e\u003cp id=\"2801\"\u003eTo make Flow-collecting coroutines in tests start eagerly again, create a new \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e, and pass it to the builder that creates the collecting coroutine:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3f03\"\u003eNote that in this code snippet, a new \u003ccode\u003eTestDispatcher\u003c/code\u003e is created without passing in a scheduler explicitly. This is safe to do only if the \u003ccode\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/test#setting-main-dispatcher\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMain\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://developer.android.com/kotlin/coroutines/test#setting-main-dispatcher\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e dispatcher has been replaced\u003c/a\u003e by a \u003ccode\u003eTestDispatcher\u003c/code\u003e, which makes scheduler sharing automatic. Otherwise, you have to pass in the existing scheduler to any \u003ccode\u003eTestDispatchers\u003c/code\u003e you create:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"4cb3\"\u003eIt’s also worth remembering that calling collect explicitly is not the only way to collect a Flow, other methods like \u003ccode\u003e\u003ca href=\"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFlow.toList()\u003c/a\u003e\u003c/code\u003e also collect the Flow internally. If you’re using such methods, you might also want to call them in new coroutines that are started with an \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"2e79\"\u003e\u003cstrong\u003eBe less eager: Main dispatcher execution\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"77b1\"\u003eAs you’ve seen above in the implementation of \u003ccode\u003eMainDispatcherRule\u003c/code\u003e, we default to using \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e for the \u003ccode\u003eMain\u003c/code\u003e dispatcher to eagerly launch coroutines. This is useful when testing ViewModels, where using \u003ccode\u003eDispatchers.Main.immediate\u003c/code\u003ewould have similar eager behavior in production code when called from the main thread.\u003c/p\u003e\u003cp id=\"f19e\"\u003eHowever, \u003ca href=\"https://github.com/android/architecture-samples/blob/f042c781a6cb959426c4606160cf9d2da50eb045/app/src/test/java/com/example/android/architecture/blueprints/todoapp/statistics/StatisticsViewModelTest.kt#L102-L118\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003esome tests\u003c/a\u003e in our samples needed lazy scheduling for \u003ccode\u003eMain\u003c/code\u003e dispatcher coroutines. Typically, this would be for tests that need to assert an intermediate loading state of a ViewModel, where eagerly starting the data-loading coroutine would mean that the test can only observe the final loaded state. With the old APIs, these tests used \u003ccode\u003epauseDispatcher\u003c/code\u003e to prevent new coroutines from executing too early, like this:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3740\"\u003eTo perform the same test with the new APIs, the \u003ccode\u003eMain\u003c/code\u003e dispatcher needs to be set to a \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e, so we need a different \u003ccode\u003eTestDispatcher\u003c/code\u003e type than what our rule uses by default. As the type of \u003ccode\u003eTestDispatcher\u003c/code\u003e used for \u003ccode\u003eMainDispatcherRule\u003c/code\u003e affects all tests within the test class, we had two choices:\u003c/p\u003e\u003cul\u003e\u003cli id=\"dd53\"\u003esplit tests into two test classes based on the type of \u003ccode\u003eMain\u003c/code\u003e dispatcher needed for each test, using a rule with a different type of dispatcher in the two test classes, or\u003c/li\u003e\u003cli id=\"9409\"\u003ekeep using a single class where the rule always sets an \u003ccode\u003eUnconfinedTestDispatcher\u003c/code\u003e for \u003ccode\u003eMain\u003c/code\u003e, and then override the \u003ccode\u003eMain\u003c/code\u003e dispatcher’s type in just a few of the tests that require a different type.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"290c\"\u003eWe opted for the latter solution, starting these tests by replacing the already-replaced \u003ccode\u003eTestDispatcher\u003c/code\u003e in \u003ccode\u003eMain\u003c/code\u003e with a new \u003ccode\u003eStandardTestDispatcher\u003c/code\u003e to lazily start new coroutines on \u003ccode\u003eMain\u003c/code\u003e. Then, later in the test code when we’d call \u003ccode\u003eresumeDispatcher\u003c/code\u003e with the old APIs, we can advance those coroutines by using \u003ccode\u003eadvanceUntilIdle\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0d9d\"\u003eThis approach keeps tests that belong together in the same test class, making the codebase easier to navigate, with the tradeoff that some tests have to include extra code for replacing \u003ccode\u003eMain\u003c/code\u003e with the desired type of \u003ccode\u003eTestDispatcher\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"5518\"\u003e\u003cstrong\u003eClean up that cleanup code\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"ddb1\"\u003eFinally, some quick tidying-up to do. The iosched sample had some \u003ca href=\"https://github.com/google/iosched/blob/69db6ea7772093fc286df5d1f317aff8f3b02c5d/mobile/src/test/java/com/google/samples/apps/iosched/ui/feed/FeedViewModelTest.kt#L104-L105\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003etest code that explicitly waited\u003c/a\u003e for coroutines to complete on the \u003ccode\u003eTestCoroutineDispatcher\u003c/code\u003e before the test would end:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"0da5\"\u003eHowever, \u003ccode\u003erunTest\u003c/code\u003e automatically waits for all known coroutines, which include children of the test coroutine and any coroutines running on \u003ccode\u003eTestDispatchers\u003c/code\u003e. This means that you can just remove any cleanup code that waits for some loose coroutines to complete!\u003c/p\u003e\u003ch2 id=\"a6ae\"\u003e\u003cstrong\u003eWrap-up\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"2d98\"\u003eThese migration steps should get you most of the way toward using the new coroutine testing APIs. For more, you can check out all the changes we made in our samples:\u003c/p\u003e\u003cul\u003e\u003cli id=\"7bd9\"\u003e\u003ca href=\"https://github.com/google/iosched/pull/404\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eiosched PR\u003c/a\u003e (and a small \u003ca href=\"https://github.com/google/iosched/pull/428\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efollow-up\u003c/a\u003e)\u003c/li\u003e\u003cli id=\"b0b4\"\u003e\u003ca href=\"https://github.com/android/architecture-samples/pull/825\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003earchitecture-samples PR\u003c/a\u003e\u003c/li\u003e\u003cli id=\"62fe\"\u003e\u003ca href=\"https://github.com/android/trackr/pull/45\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003etrackr PR\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4a81\"\u003eAnd of course, the new \u003ca href=\"https://github.com/android/nowinandroid\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNow in Android sample app\u003c/a\u003e already uses the new testing APIs for its tests!\u003c/p\u003e\u003cp id=\"8167\"\u003eFinally, if you need more help with the migration, check out the official \u003ca href=\"https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-test/MIGRATION.md\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003emigration guide\u003c/a\u003e by JetBrains, which covers the intricacies of the coroutine testing API.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2022-06-29T17:00:45.134Z",
  "modifiedTime": null
}
