{
  "id": "e65ffb88-da84-4639-8362-3bae7cb0664e",
  "title": "Most Android Apps Break This One Clean Code Rule!",
  "link": "https://proandroiddev.com/most-android-apps-break-this-one-clean-code-rule-f2fb44f98e90?source=rss----c72404660798---4",
  "description": "",
  "author": "Reza",
  "published": "Tue, 20 May 2025 20:14:06 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "push-notification",
    "android",
    "testing",
    "dependency-injection",
    "clean-architecture"
  ],
  "byline": "Reza",
  "length": 2467,
  "excerpt": "Learn how to write clean, testable Android code by keeping FirebaseMessagingService, BroadcastReceiver, and other components dumb and logic-free.",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "ğŸ“¦ FCM Push Notifications: A Case Study:Setting up Firebase Cloud Messaging (FCM) on Android is straightforward. You set up the AndroidManifest.xml, request permissions, and override two key methods:onNewToken(String token) â€” called when a new FCM token is generatedonMessageReceived(RemoteMessage message) â€” triggered when a push message arrivesThen youâ€™d have something like:âš ï¸ It worksâ€¦ until it doesnâ€™t. Why?âŒ You canâ€™t unit test itâŒ You canâ€™t reuse the logicâŒ You need real pushes to test itLetâ€™s clean it up.âœ… The Better Way: Delegate EverythingğŸ§© 1. Keep FirebaseMessagingService ThinYour service shouldnâ€™t contain logic. It should forward work to injected, testable components.This gives you the power of dependency injection (e.g., Hilt or Koin), and isolates the logic for reuse and testing.ğŸ§± 2. Map to a Clean Domain ModelDonâ€™t pass around Firebaseâ€™s RemoteMessage. Instead, extract a platform-agnostic model that reflects your appâ€™s needs.Map FCM data into this class:By abstracting RemoteMessage, you decouple your core logic from Firebase.ğŸ› ï¸ 3. Inject and Test Business LogicNow create a PushHandler that takes your domain model and decides what to do.Now your logic is testable, extendable, and easy to maintain.ğŸ” Same Pattern for BroadcastReceiversThis mistake isnâ€™t limited to push notifications. BroadcastReceiver is another classic offender.Bad pattern â€” logic inside the receiver:Better pattern â€” delegate logic:This allows you to test rescheduling logic with unit tests â€” no need to simulate broadcasts.ğŸ§ª Unit Testing with Robolectric and FakesThis is where it gets fun. Because your core logic is no longer tied to Android components, testing is simple:You donâ€™t need a device or emulator â€” just plain Kotlin and Robolectric.ğŸ“² End-to-End Verification with UIAutomatorYou can also test real system-level behavior with UIAutomator:Perfect for verifying real device behavior on CI or pre-release tests.ğŸ’¡ Final AdviceKeep your Android components dumb, and your logic clean.ğŸ¤– FirebaseMessagingService should not contain notification codeğŸ“¡ BroadcastReceiver should not enqueue jobsğŸ¬ Activity should not contain business logicUse @Inject, @Binds, and interfaces to make every part of your system testable and modular.âœ… TL;DRAndroid components should delegate, not doMove logic into injectable classesCreate domain models to decouple from SDKsUnit test with fakes, verify UI with UIAutomatorğŸ§¼ Clean architecture starts with one rule: Keep Components Dumb.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*BsHHctxJ_B2DZQxs",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"000b\"\u003eğŸ“¦ FCM Push Notifications: A Case Study:\u003c/h2\u003e\u003cp id=\"45e5\"\u003eSetting up Firebase Cloud Messaging (FCM) on Android is straightforward. You set up the AndroidManifest.xml, request permissions, and override two key methods:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"6dbf\"\u003eonNewToken(String token) â€” called when a new FCM token is generated\u003c/li\u003e\u003cli id=\"3685\"\u003eonMessageReceived(RemoteMessage message) â€” triggered when a push message arrives\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3fe2\"\u003eThen youâ€™d have something like:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"10aa\"\u003eâš ï¸ It worksâ€¦ until it doesnâ€™t. Why?\u003c/p\u003e\u003cul\u003e\u003cli id=\"533c\"\u003eâŒ You canâ€™t unit test it\u003c/li\u003e\u003cli id=\"fe44\"\u003eâŒ You canâ€™t reuse the logic\u003c/li\u003e\u003cli id=\"53d4\"\u003eâŒ You need real pushes to test it\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8912\"\u003eLetâ€™s clean it up.\u003c/p\u003e\u003ch2 id=\"9cb9\"\u003eâœ… The Better Way: Delegate Everything\u003c/h2\u003e\u003ch2 id=\"5c6f\"\u003eğŸ§© 1. Keep FirebaseMessagingService Thin\u003c/h2\u003e\u003cp id=\"d6b5\"\u003eYour service shouldnâ€™t contain logic. It should forward work to injected, testable components.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"27b8\"\u003eThis gives you the power of dependency injection (e.g., Hilt or Koin), and isolates the logic for reuse and testing.\u003c/p\u003e\u003ch2 id=\"754c\"\u003eğŸ§± 2. Map to a Clean Domain Model\u003c/h2\u003e\u003cp id=\"91e8\"\u003eDonâ€™t pass around Firebaseâ€™s RemoteMessage. Instead, extract a platform-agnostic model that reflects your appâ€™s needs.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"56d6\"\u003eMap FCM data into this class:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f763\"\u003eBy abstracting RemoteMessage, you decouple your core logic from Firebase.\u003c/p\u003e\u003ch2 id=\"edaa\"\u003eğŸ› ï¸ 3. Inject and Test Business Logic\u003c/h2\u003e\u003cp id=\"92e2\"\u003eNow create a PushHandler that takes your domain model and decides what to do.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"099e\"\u003eNow your logic is testable, extendable, and easy to maintain.\u003c/p\u003e\u003ch2 id=\"77e7\"\u003eğŸ” Same Pattern for BroadcastReceivers\u003c/h2\u003e\u003cp id=\"224c\"\u003eThis mistake isnâ€™t limited to push notifications. BroadcastReceiver is another classic offender.\u003c/p\u003e\u003cp id=\"834a\"\u003e\u003cstrong\u003eBad pattern\u003c/strong\u003e â€” logic inside the receiver:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5540\"\u003e\u003cstrong\u003eBetter pattern\u003c/strong\u003e â€” delegate logic:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3b11\"\u003eThis allows you to test rescheduling logic with unit tests â€” no need to simulate broadcasts.\u003c/p\u003e\u003ch2 id=\"b4bf\"\u003eğŸ§ª Unit Testing with Robolectric and Fakes\u003c/h2\u003e\u003cp id=\"8162\"\u003eThis is where it gets fun. Because your core logic is no longer tied to Android components, testing is simple:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"db95\"\u003eYou donâ€™t need a device or emulator â€” just plain Kotlin and Robolectric.\u003c/p\u003e\u003ch2 id=\"b473\"\u003eğŸ“² End-to-End Verification with UIAutomator\u003c/h2\u003e\u003cp id=\"4a28\"\u003eYou can also test real system-level behavior with UIAutomator:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5735\"\u003ePerfect for verifying real device behavior on CI or pre-release tests.\u003c/p\u003e\u003ch2 id=\"a79d\"\u003eğŸ’¡ Final Advice\u003c/h2\u003e\u003cp id=\"8fcd\"\u003eKeep your Android components \u003cstrong\u003edumb\u003c/strong\u003e, and your logic \u003cstrong\u003eclean\u003c/strong\u003e.\u003c/p\u003e\u003cul\u003e\u003cli id=\"7573\"\u003eğŸ¤– FirebaseMessagingService should not contain notification code\u003c/li\u003e\u003cli id=\"90ee\"\u003eğŸ“¡ BroadcastReceiver should not enqueue jobs\u003c/li\u003e\u003cli id=\"b985\"\u003eğŸ¬ Activity should not contain business logic\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f8da\"\u003eUse \u003ccode\u003e@Inject\u003c/code\u003e, \u003ccode\u003e@Binds\u003c/code\u003e, and \u003ccode\u003einterfaces\u003c/code\u003e to make every part of your system testable and modular.\u003c/p\u003e\u003ch2 id=\"4758\"\u003eâœ… TL;DR\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d475\"\u003eAndroid components should \u003cstrong\u003edelegate\u003c/strong\u003e, not \u003cstrong\u003edo\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"80f6\"\u003eMove logic into injectable classes\u003c/li\u003e\u003cli id=\"ea9f\"\u003eCreate domain models to decouple from SDKs\u003c/li\u003e\u003cli id=\"57c2\"\u003eUnit test with fakes, verify UI with UIAutomator\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"f9fe\"\u003e\u003cem\u003eğŸ§¼ Clean architecture starts with one rule: \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eKeep Components Dumb.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2025-05-20T20:14:06.846Z",
  "modifiedTime": null
}
