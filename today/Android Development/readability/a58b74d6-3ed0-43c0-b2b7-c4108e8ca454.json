{
  "id": "a58b74d6-3ed0-43c0-b2b7-c4108e8ca454",
  "title": "Kotlin's JDK release compatibility flag",
  "link": "https://jakewharton.com/kotlins-jdk-release-compatibility-flag/",
  "description": "",
  "author": "",
  "published": "2024-03-13T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "",
  "length": 7065,
  "excerpt": "13 March 2024",
  "siteName": "Jake Wharton",
  "favicon": "",
  "text": "Kotlin's JDK release compatibility flag 13 March 2024 Yesterday, our Android app crashed with a weird NoSuchMethodError. java.lang.NoSuchMethodError: No interface method removeFirst()Ljava/lang/Object; in class Ljava/util/List; or its super classes (declaration of 'java.util.List' appears in /apex/com.android.art/javalib/core-oj.jar) at app.cash.redwood.lazylayout.widget.LazyListUpdateProcessor.onEndChanges(SourceFile:165) at app.cash.redwood.lazylayout.view.ViewLazyList.onEndChanges(SourceFile:210) at app.cash.redwood.protocol.widget.ProtocolBridge.sendChanges(SourceFile:125) at app.cash.redwood.treehouse.ViewContentCodeBinding.receiveChangesOnUiDispatcher(SourceFile:419) at app.cash.redwood.treehouse.ViewContentCodeBinding$sendChanges$1.invokeSuspend(SourceFile:383) at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(SourceFile:33) at kotlinx.coroutines.DispatchedTask.run(SourceFile:104) at android.os.Handler.handleCallback(Handler.java:938) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:250) at android.app.ActivityThread.main(ActivityThread.java:7868) The offending code is written in Kotlin, and looks like this: The IDE showing an italicized blue style for removeFirst means it’s a Kotlin extension function which compiles down to a static helper in the bytecode. However, the exception clearly indicates we are calling a member function on List directly. What gives? In JDK 21, as part of the sequenced collection effort, the List interface added removeFirst() and removeLast() methods. According to the Kotlin docs on extension functions: If a class has a member function, and an extension function is defined which has the same receiver type, the same name, and is applicable to given arguments, the member always wins. When we bumped our build JDK to 21, the new member became available and accidentally took precedence. Oops! But wait, we set our Kotlin jvmTarget to 1.8 in order to be backwards compatible. Is that not enough? val javaVersion = JavaVersion.VERSION_1_8 tasks.withType(KotlinJvmCompile::class.java).configureEach { it.kotlinOptions.jvmTarget = javaVersion.toString() } // Kotlin requires the Java compatibility matches despite have no sources. tasks.withType(JavaCompile::class.java).configureEach { it.sourceCompatibility = javaVersion.toString() it.targetCompatibility = javaVersion.toString() } This setting controls the Java bytecode version that the Kotlin compiler emits for JVM and Android targets. We can confirm this is being honored by inspecting the offending class with javap. $ javap -v redwood-lazylayout-widget/build/classes/kotlin/jvm/main/app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor.class | head -8 Classfile redwood-lazylayout-widget/build/classes/kotlin/jvm/main/app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor.class Last modified Mar 13, 2024; size 16001 bytes SHA-256 checksum dbeed7bba16c023a98fa356bab7cada7abe686d5da7d4824781790de577e94a2 Compiled from \"LazyListUpdateProcessor.kt\" public abstract class app.cash.redwood.lazylayout.widget.LazyListUpdateProcessor\u003cV extends java.lang.Object, W extends java.lang.Object\u003e extends java.lang.Object minor version: 0 major version: 52 flags: (0x0421) ACC_PUBLIC, ACC_SUPER, ACC_ABSTRACT The classfile’s major version is listed at 52, which we can reverse lookup using a version table and see that this corresponds to Java 8. So we know that’s working, at least. Further down the output, however, the offending reference can also be seen. 405: checkcast #101 // class app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert 408: invokevirtual #107 // Method app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert.getWidgets:()Ljava/util/List; 411: invokeinterface #151, 1 // InterfaceMethod java/util/List.removeFirst:()Ljava/lang/Object; 416: checkcast #121 // class app/cash/redwood/widget/Widget 419: astore 6 The reason this can happen is that the Java bytecode version is independent from the set of JDK APIs that you can reference. This is not unique to Kotlin. javac’s -target flag behaves the same way, as you can see in this Godbolt sample. This can be fixed with javac by specifying the -bootclasspath argument and pointing at the rt.jar from a JDK 8 install. The JDK 21 compiler emits a warning telling us to do this when target any bytecode version other than the default: warning: [options] bootstrap class path not set in conjunction with -source 8 Starting with Java 9, javac has a new flag, --release, which sets the -source, -target, and -bootclasspath flags automatically to the same version (and doesn’t require having the old JDK available). If we switch the Java sample to use --release it now fails to compile! Kotlin 1.7 brought a new flag to kotlinc (Kotlin’s JVM compiler) which acts just like javac’s --release: -Xjdk-release. As far as I can tell, this has flown massively under the radar but is an essential piece to the cross-compilation toolkit. Let’s configure our JVM target’s compilation to use this flag and see what changes. kotlin.targets.withType(KotlinJvmTarget::class.java) { target -\u003e target.compilations.configureEach { it.kotlinOptions.freeCompilerArgs += listOf( \"-Xjdk-release=$javaVersion\", ) } } After compiling and dumping the Java bytecode there is a welcome change. 405: checkcast #101 // class app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert 408: invokevirtual #107 // Method app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert.getWidgets:()Ljava/util/List; -411: invokeinterface #151, 1 // InterfaceMethod java/util/List.removeFirst:()Ljava/lang/Object; +411: invokestatic #152 // Method kotlin/collections/CollectionsKt.removeFirst:(Ljava/util/List;)Ljava/lang/Object; 414: checkcast #121 // class app/cash/redwood/widget/Widget 417: astore 6 With the JDK API unavailable, the removeFirst extension now resolves to the static method in the Kotlin standard library. The -Xjdk-release flag is useful for the Kotlin JVM plugin or the JVM targets of the Kotlin multiplatform plugin to ensure compatibility with your target minimum JVM. Users of the Kotlin Android plugin or the Android targets of the Kotlin multiplatform plugin do not need to do this, as the use of the android.jar as the boot classpath limits the java.* APIs to those of your compileSdk (and Android Lint ensures you don’t use anything newer than your minSdk). Unforunately there’s no Gradle DSL for this yet, but KT-49746 tracks that. If you use Gradle toolchains you don’t have this problem. This is because you actually use the ancient JDK and JVM of your minimum target to run javac and kotlinc and miss out on a decade’s worth of compiler improvements. Gradle toolchains are rarely a good idea. But that’s a topic for next week… — Jake Wharton",
  "image": "https://jakewharton.com/static/default_image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \u003ch2\u003eKotlin\u0026#39;s JDK release compatibility flag\u003c/h2\u003e\n      \u003cp\u003e13 March 2024\u003c/p\u003e\n\n      \u003cp\u003eYesterday, our Android app crashed with a weird \u003ccode\u003eNoSuchMethodError\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003ejava.lang.NoSuchMethodError: No interface method removeFirst()Ljava/lang/Object; in class Ljava/util/List; or its super classes (declaration of \u0026#39;java.util.List\u0026#39; appears in /apex/com.android.art/javalib/core-oj.jar)\n    at app.cash.redwood.lazylayout.widget.LazyListUpdateProcessor.onEndChanges(SourceFile:165)\n    at app.cash.redwood.lazylayout.view.ViewLazyList.onEndChanges(SourceFile:210)\n    at app.cash.redwood.protocol.widget.ProtocolBridge.sendChanges(SourceFile:125)\n    at app.cash.redwood.treehouse.ViewContentCodeBinding.receiveChangesOnUiDispatcher(SourceFile:419)\n    at app.cash.redwood.treehouse.ViewContentCodeBinding$sendChanges$1.invokeSuspend(SourceFile:383)\n    at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(SourceFile:33)\n    at kotlinx.coroutines.DispatchedTask.run(SourceFile:104)\n    at android.os.Handler.handleCallback(Handler.java:938)\n    at android.os.Handler.dispatchMessage(Handler.java:99)\n    at android.os.Looper.loop(Looper.java:250)\n    at android.app.ActivityThread.main(ActivityThread.java:7868)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/cashapp/redwood/blob/2db41653e3887387b8c8468cb3f01d0c326eb39d/redwood-lazylayout-widget/src/commonMain/kotlin/app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor.kt#L165\"\u003eThe offending code\u003c/a\u003e is written in Kotlin, and looks like this:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://jakewharton.com/static/post-image/removeFirst.png\" alt=\"val widget = edit.widgets.removeFirst()\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe IDE showing an italicized blue style for \u003ccode\u003eremoveFirst\u003c/code\u003e means \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/remove-first.html\"\u003eit’s a Kotlin extension function\u003c/a\u003e which compiles down to a static helper in the bytecode.\nHowever, the exception clearly indicates we are calling a member function on \u003ccode\u003eList\u003c/code\u003e directly. What gives?\u003c/p\u003e\n\n\u003cp\u003eIn JDK 21, as part of the \u003ca href=\"https://openjdk.org/jeps/431\"\u003esequenced collection\u003c/a\u003e effort, the \u003ccode\u003eList\u003c/code\u003e interface \u003ca href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html#removeFirst()\"\u003eadded \u003ccode\u003eremoveFirst()\u003c/code\u003e and \u003ccode\u003eremoveLast()\u003c/code\u003e\u003c/a\u003e methods. According to the \u003ca href=\"https://kotlinlang.org/docs/extensions.html#extensions-are-resolved-statically\"\u003eKotlin docs on extension functions\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIf a class has a member function, and an extension function is defined which has the same receiver type, the same name, and is applicable to given arguments, the \u003cstrong\u003emember always wins\u003c/strong\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eWhen we bumped our build JDK to 21, the new member became available and accidentally took precedence. Oops!\u003c/p\u003e\n\n\u003cp\u003eBut wait, we set our Kotlin \u003ccode\u003ejvmTarget\u003c/code\u003e to 1.8 in order to be backwards compatible. Is that not enough?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ejavaVersion\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eJavaVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eVERSION_1_8\u003c/span\u003e\n\u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewithType\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eKotlinJvmCompile\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003econfigureEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ekotlinOptions\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejvmTarget\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejavaVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoString\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e// Kotlin requires the Java compatibility matches despite have no sources.\u003c/span\u003e\n\u003cspan\u003etasks\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewithType\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eJavaCompile\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003econfigureEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esourceCompatibility\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejavaVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoString\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n  \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etargetCompatibility\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ejavaVersion\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoString\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis setting controls the Java bytecode version that the Kotlin compiler emits for JVM and Android targets.\nWe can confirm this is being honored by inspecting the offending class with \u003ccode\u003ejavap\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ javap -v redwood-lazylayout-widget/build/classes/kotlin/jvm/main/app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor.class | head -8\nClassfile redwood-lazylayout-widget/build/classes/kotlin/jvm/main/app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor.class\n  Last modified Mar 13, 2024; size 16001 bytes\n  SHA-256 checksum dbeed7bba16c023a98fa356bab7cada7abe686d5da7d4824781790de577e94a2\n  Compiled from \u0026#34;LazyListUpdateProcessor.kt\u0026#34;\npublic abstract class app.cash.redwood.lazylayout.widget.LazyListUpdateProcessor\u0026lt;V extends java.lang.Object, W extends java.lang.Object\u0026gt; extends java.lang.Object\n  minor version: 0\n  major version: 52\n  flags: (0x0421) ACC_PUBLIC, ACC_SUPER, ACC_ABSTRACT\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe classfile’s major version is listed at 52, which we can reverse lookup using \u003ca href=\"https://javaalmanac.io/bytecode/versions/\"\u003ea version table\u003c/a\u003e and see that this corresponds to Java 8. So we know that’s working, at least.\u003c/p\u003e\n\n\u003cp\u003eFurther down the output, however, the offending reference can also be seen.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e405: checkcast     #101        // class app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert\n408: invokevirtual #107        // Method app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert.getWidgets:()Ljava/util/List;\n411: invokeinterface #151,  1  // InterfaceMethod java/util/List.removeFirst:()Ljava/lang/Object;\n416: checkcast     #121        // class app/cash/redwood/widget/Widget\n419: astore        6\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe reason this can happen is that the Java bytecode version is independent from the set of JDK APIs that you can reference.\nThis is not unique to Kotlin.\n\u003ccode\u003ejavac\u003c/code\u003e’s \u003ccode\u003e-target\u003c/code\u003e flag behaves the same way, as you can see \u003ca href=\"https://java.godbolt.org/z/rKWv4K9jG\"\u003ein this Godbolt sample\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis can be fixed with \u003ccode\u003ejavac\u003c/code\u003e by specifying the \u003ccode\u003e-bootclasspath\u003c/code\u003e argument and pointing at the \u003ccode\u003ert.jar\u003c/code\u003e from a JDK 8 install.\nThe JDK 21 compiler emits a warning telling us to do this when target \u003cem\u003eany\u003c/em\u003e bytecode version other than the default:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ewarning: [options] bootstrap class path not set in conjunction with -source 8\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eStarting with Java 9, \u003ccode\u003ejavac\u003c/code\u003e has a new flag, \u003ccode\u003e--release\u003c/code\u003e, which sets the \u003ccode\u003e-source\u003c/code\u003e, \u003ccode\u003e-target\u003c/code\u003e, and \u003ccode\u003e-bootclasspath\u003c/code\u003e flags automatically to the same version (and doesn’t require having the old JDK available).\nIf we switch the Java sample to use \u003ccode\u003e--release\u003c/code\u003e \u003ca href=\"https://java.godbolt.org/z/bP6baz9GT\"\u003eit now fails to compile\u003c/a\u003e!\u003c/p\u003e\n\n\u003cp\u003eKotlin 1.7 brought a new flag to \u003ccode\u003ekotlinc\u003c/code\u003e (Kotlin’s JVM compiler) which acts just like \u003ccode\u003ejavac\u003c/code\u003e’s \u003ccode\u003e--release\u003c/code\u003e: \u003ccode\u003e-Xjdk-release\u003c/code\u003e.\nAs far as I can tell, this has flown massively under the radar but is an essential piece to the cross-compilation toolkit.\u003c/p\u003e\n\n\u003cp\u003eLet’s configure our JVM target’s compilation to use this flag and see what changes.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e \u003cspan\u003ekotlin\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etargets\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewithType\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eKotlinJvmTarget\u003c/span\u003e\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejava\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003etarget\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n  \u003cspan\u003etarget\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecompilations\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econfigureEach\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eit\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ekotlinOptions\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efreeCompilerArgs\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003elistOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n      \u003cspan\u003e\u0026#34;-Xjdk-release=$javaVersion\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAfter compiling and dumping the Java bytecode there is a welcome change.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e 405: checkcast     #101        // class app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert\n 408: invokevirtual #107        // Method app/cash/redwood/lazylayout/widget/LazyListUpdateProcessor$Edit$Insert.getWidgets:()Ljava/util/List;\n\u003cspan\u003e-411: invokeinterface #151,  1  // InterfaceMethod java/util/List.removeFirst:()Ljava/lang/Object;\n\u003c/span\u003e\u003cspan\u003e+411: invokestatic  #152        // Method kotlin/collections/CollectionsKt.removeFirst:(Ljava/util/List;)Ljava/lang/Object;\n\u003c/span\u003e 414: checkcast     #121        // class app/cash/redwood/widget/Widget\n 417: astore        6\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith the JDK API unavailable, the \u003ccode\u003eremoveFirst\u003c/code\u003e extension now resolves to the static method in the Kotlin standard library.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e-Xjdk-release\u003c/code\u003e flag is useful for the Kotlin JVM plugin or the JVM targets of the Kotlin multiplatform plugin to ensure compatibility with your target minimum JVM. Users of the Kotlin Android plugin or the Android targets of the Kotlin multiplatform plugin do not need to do this, as the use of the \u003ccode\u003eandroid.jar\u003c/code\u003e as the boot classpath limits the \u003ccode\u003ejava.*\u003c/code\u003e APIs to those of your \u003ccode\u003ecompileSdk\u003c/code\u003e (and Android Lint ensures you don’t use anything newer than your \u003ccode\u003eminSdk\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eUnforunately there’s no Gradle DSL for this yet, but \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-49746/Support-Xjdk-release-in-gradle-toolchain#focus=Comments-27-8935065.0-0\"\u003eKT-49746\u003c/a\u003e tracks that.\u003c/p\u003e\n\n\u003cp\u003eIf you use Gradle toolchains you don’t have this problem. This is because you actually use the ancient JDK and JVM of your minimum target to run \u003ccode\u003ejavac\u003c/code\u003e and \u003ccode\u003ekotlinc\u003c/code\u003e and miss out on a decade’s worth of compiler improvements. Gradle toolchains are rarely a good idea. But that’s a topic for next week…\u003c/p\u003e\n\n\n      \u003cp\u003e— Jake Wharton\u003c/p\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-03-13T00:00:00Z",
  "modifiedTime": null
}
