{
  "id": "341d3b36-fa58-4fe1-8e14-a395b5e628b8",
  "title": "CameraX update makes dual concurrent camera even easier",
  "link": "http://android-developers.googleblog.com/2024/10/camerax-update-makes-dual-concurrent-camera-easier.html",
  "description": "",
  "author": "Android Developers",
  "published": "2024-10-16T14:00:00.001-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "Announcements",
    "Camera",
    "Camera X",
    "Developer Tools",
    "How-To Guide",
    "Jetpack",
    "mobile",
    "Solve"
  ],
  "byline": "",
  "length": 4632,
  "excerpt": "CameraX's Dual Concurrent Camera feature is now updated, making it easier to integrate into apps, offering developers more flexibility and control.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Donovan McMurray – Developer Relations Engineer CameraX, Android's Jetpack camera library, is getting an exciting update to its Dual Concurrent Camera feature, making it even easier to integrate this feature into your app. This feature allows you to stream from 2 different cameras at the same time. The original version of Dual Concurrent Camera was released in CameraX 1.3.0, and it was already a huge leap in making this feature easier to implement. Starting with 1.5.0-alpha01, CameraX will now handle the composition of the 2 camera streams as well. This update is additional functionality, and it doesn’t remove any prior functionality nor is it a breaking change to your existing Dual Concurrent Camera code. To tell CameraX to handle the composition, simply use the new SingleCameraConfig constructor which has a new parameter for a CompositionSettings object. Since you’ll be creating 2 SingleCameraConfigs, you should be consistent with what constructor you use. Nothing has changed in the way you check for concurrent camera support from the prior version of this feature. As a reminder, here is what that code looks like. // Set up primary and secondary camera selectors if supported on device. var primaryCameraSelector: CameraSelector? = null var secondaryCameraSelector: CameraSelector? = null for (cameraInfos in cameraProvider.availableConcurrentCameraInfos) { primaryCameraSelector = cameraInfos.first { it.lensFacing == CameraSelector.LENS_FACING_FRONT }.cameraSelector secondaryCameraSelector = cameraInfos.first { it.lensFacing == CameraSelector.LENS_FACING_BACK }.cameraSelector if (primaryCameraSelector == null || secondaryCameraSelector == null) { // If either a primary or secondary selector wasn't found, reset both // to move on to the next list of CameraInfos. primaryCameraSelector = null secondaryCameraSelector = null } else { // If both primary and secondary camera selectors were found, we can // conclude the search. break } } if (primaryCameraSelector == null || secondaryCameraSelector == null) { // Front and back concurrent camera not available. Handle accordingly. } Here’s the updated code snippet showing how to implement picture-in-picture, with the front camera stream scaled down to fit into the lower right corner. In this example, CameraX handles the composition of the camera streams. // If 2 concurrent camera selectors were found, create 2 SingleCameraConfigs // and compose them in a picture-in-picture layout. val primary = SingleCameraConfig( cameraSelectorPrimary, useCaseGroup, CompositionSettings.Builder() .setAlpha(1.0f) .setOffset(0.0f, 0.0f) .setScale(1.0f, 1.0f) .build(), lifecycleOwner); val secondary = SingleCameraConfig( cameraSelectorSecondary, useCaseGroup, CompositionSettings.Builder() .setAlpha(1.0f) .setOffset(2 / 3f - 0.1f, -2 / 3f + 0.1f) .setScale(1 / 3f, 1 / 3f) .build() lifecycleOwner); // Bind to lifecycle ConcurrentCamera concurrentCamera = cameraProvider.bindToLifecycle(listOf(primary, secondary)); You are not constrained to a picture-in-picture layout. For instance, you could define a side-by-side layout by setting the offsets and scaling factors accordingly. You want to keep both dimensions scaled by the same amount to avoid a stretched preview. Here’s how that might look. // If 2 concurrent camera selectors were found, create 2 SingleCameraConfigs // and compose them in a picture-in-picture layout. val primary = SingleCameraConfig( cameraSelectorPrimary, useCaseGroup, CompositionSettings.Builder() .setAlpha(1.0f) .setOffset(0.0f, 0.25f) .setScale(0.5f, 0.5f) .build(), lifecycleOwner); val secondary = SingleCameraConfig( cameraSelectorSecondary, useCaseGroup, CompositionSettings.Builder() .setAlpha(1.0f) .setOffset(0.5f, 0.25f) .setScale(0.5f, 0.5f) .build() lifecycleOwner); // Bind to lifecycle ConcurrentCamera concurrentCamera = cameraProvider.bindToLifecycle(listOf(primary, secondary)); We’re excited to offer this improvement to an already developer-friendly feature. Truly the CameraX way! CompositionSettings in Dual Concurrent Camera is currently in alpha, so if you have feature requests to improve upon it before the API is locked in, please give us feedback in the CameraX Discussion Group. And check out the full CameraX 1.5.0-alpha01 release notes to see what else is new in CameraX.",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj23eacL7I9W71-SdbqFZ7LXwVcaeJN3EROAUN8XBwF7_ZF8tw1cql0xxjc3iBOsudo3Rp2i1cMLmXUXD_5Cq44hcOA5LRshWvrs9WY92dXtIbH9WpiEs_VSrgGcs7F6ZSTlhHCQ-5C36KSkRC0nzcsg8rVzGNwpNlMzCRmo198wz9SVowNA1MRlNFKWbU/w1200-h630-p-k-no-nu/AndroidSpotlight_Adaptive_CameraX_Metadata_01.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta name=\"twitter:image\" content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj23eacL7I9W71-SdbqFZ7LXwVcaeJN3EROAUN8XBwF7_ZF8tw1cql0xxjc3iBOsudo3Rp2i1cMLmXUXD_5Cq44hcOA5LRshWvrs9WY92dXtIbH9WpiEs_VSrgGcs7F6ZSTlhHCQ-5C36KSkRC0nzcsg8rVzGNwpNlMzCRmo198wz9SVowNA1MRlNFKWbU/s1600/AndroidSpotlight_Adaptive_CameraX_Metadata_01.png\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by Donovan McMurray – Developer Relations Engineer\u003c/em\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhwVBYvbASuJqx4wj4F6d6lIGlmENzJQPII78U__fio6gGLoup4vZA7RcGh40VZrszXXaFZYv8oLBX0GcSBwIJi6Mk-wFeocM4sjG0-nUAgNLwdR9fFVSDQluveqXESCqCr0QqxPhth0gZCSMwCvjUG4kMdhmpOiIY66uXNFnQvdB3otfn89i9IU_2Ip9I/s1600/AndroidSpotlight_Adaptive_CameraX_Banner_01.png\" imageanchor=\"1\"\u003e\u003cimg data-original-height=\"800\" data-original-width=\"100%\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhwVBYvbASuJqx4wj4F6d6lIGlmENzJQPII78U__fio6gGLoup4vZA7RcGh40VZrszXXaFZYv8oLBX0GcSBwIJi6Mk-wFeocM4sjG0-nUAgNLwdR9fFVSDQluveqXESCqCr0QqxPhth0gZCSMwCvjUG4kMdhmpOiIY66uXNFnQvdB3otfn89i9IU_2Ip9I/s1600/AndroidSpotlight_Adaptive_CameraX_Banner_01.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://developer.android.com/media/camera/camerax\" target=\"_blank\"\u003eCameraX\u003c/a\u003e, Android\u0026#39;s Jetpack camera library, is getting an exciting update to its Dual Concurrent Camera feature, making it even easier to integrate this feature into your app. This feature allows you to stream from 2 different cameras at the same time. The original version of Dual Concurrent Camera was \u003ca href=\"https://android-developers.googleblog.com/2023/06/camerax-13-is-now-in-beta.html\" target=\"_blank\"\u003ereleased in CameraX 1.3.0\u003c/a\u003e, and it was already a huge leap in making this feature easier to implement.\u003c/p\u003e \n\n\u003cp\u003eStarting with \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/camera#1.5.0-alpha01\" target=\"_blank\"\u003e1.5.0-alpha01\u003c/a\u003e, CameraX will now handle the composition of the 2 camera streams as well. This update is additional functionality, and it doesn’t remove any prior functionality nor is it a breaking change to your existing Dual Concurrent Camera code. To tell CameraX to handle the composition, simply use the \u003ca href=\"https://developer.android.com/reference/androidx/camera/core/ConcurrentCamera.SingleCameraConfig#SingleCameraConfig%28androidx.camera.core.CameraSelector,androidx.camera.core.UseCaseGroup,androidx.camera.core.CompositionSettings,androidx.lifecycle.LifecycleOwner%29\" target=\"_blank\"\u003enew \u003cspan\u003eSingleCameraConfig\u003c/span\u003e constructor\u003c/a\u003e which has a new parameter for a \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/androidx/camera/core/CompositionSettings\" target=\"_blank\"\u003eCompositionSettings\u003c/a\u003e\u003c/span\u003e object. Since you’ll be creating 2 SingleCameraConfigs, you should be consistent with what constructor you use.\u003c/p\u003e \n\n\u003cp\u003eNothing has changed in the way you check for concurrent camera support from the prior version of this feature. As a reminder, here is what that code looks like.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// Set up primary and secondary camera selectors if supported on device.\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e primaryCameraSelector: CameraSelector? = \u003cspan\u003enull\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e secondaryCameraSelector: CameraSelector? = \u003cspan\u003enull\u003c/span\u003e\n\n\u003cspan\u003efor\u003c/span\u003e (cameraInfos \u003cspan\u003ein\u003c/span\u003e cameraProvider.availableConcurrentCameraInfos) {\n    primaryCameraSelector = cameraInfos.first {\n        it.lensFacing == CameraSelector.LENS_FACING_FRONT\n    }.cameraSelector\n    secondaryCameraSelector = cameraInfos.first {\n        it.lensFacing == CameraSelector.LENS_FACING_BACK\n    }.cameraSelector\n\n    \u003cspan\u003eif\u003c/span\u003e (primaryCameraSelector == \u003cspan\u003enull\u003c/span\u003e || secondaryCameraSelector == \u003cspan\u003enull\u003c/span\u003e) {\n        \u003cspan\u003e// If either a primary or secondary selector wasn\u0026#39;t found, reset both\u003c/span\u003e\n        \u003cspan\u003e// to move on to the next list of CameraInfos.\u003c/span\u003e\n        primaryCameraSelector = \u003cspan\u003enull\u003c/span\u003e\n        secondaryCameraSelector = \u003cspan\u003enull\u003c/span\u003e\n    } \u003cspan\u003eelse\u003c/span\u003e {\n        \u003cspan\u003e// If both primary and secondary camera selectors were found, we can\u003c/span\u003e\n        \u003cspan\u003e// conclude the search.\u003c/span\u003e\n        \u003cspan\u003ebreak\u003c/span\u003e\n    }\n}\n\n\u003cspan\u003eif\u003c/span\u003e (primaryCameraSelector == \u003cspan\u003enull\u003c/span\u003e || secondaryCameraSelector == \u003cspan\u003enull\u003c/span\u003e) {\n    \u003cspan\u003e// Front and back concurrent camera not available. Handle accordingly.\u003c/span\u003e\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHere’s the updated code snippet showing how to implement picture-in-picture, with the front camera stream scaled down to fit into the lower right corner. In this example, CameraX handles the composition of the camera streams.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// If 2 concurrent camera selectors were found, create 2 SingleCameraConfigs\u003c/span\u003e\n\u003cspan\u003e// and compose them in a picture-in-picture layout.\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e primary = SingleCameraConfig(\n    cameraSelectorPrimary,\n    useCaseGroup,\n    CompositionSettings.Builder()\n        .setAlpha(\u003cspan\u003e1.0f\u003c/span\u003e)\n        .setOffset(\u003cspan\u003e0.0f\u003c/span\u003e, \u003cspan\u003e0.0f\u003c/span\u003e)\n        .setScale(\u003cspan\u003e1.0f\u003c/span\u003e, \u003cspan\u003e1.0f\u003c/span\u003e)\n        .build(),\n    lifecycleOwner);\n\u003cspan\u003eval\u003c/span\u003e secondary = SingleCameraConfig(\n    cameraSelectorSecondary,\n    useCaseGroup,\n    CompositionSettings.Builder()\n        .setAlpha(\u003cspan\u003e1.0f\u003c/span\u003e)\n        .setOffset(\u003cspan\u003e2\u003c/span\u003e / \u003cspan\u003e3f\u003c/span\u003e - \u003cspan\u003e0.1f\u003c/span\u003e, -\u003cspan\u003e2\u003c/span\u003e / \u003cspan\u003e3f\u003c/span\u003e + \u003cspan\u003e0.1f\u003c/span\u003e)\n        .setScale(\u003cspan\u003e1\u003c/span\u003e / \u003cspan\u003e3f\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e / \u003cspan\u003e3f\u003c/span\u003e)\n        .build()\n    lifecycleOwner);\n\n\u003cspan\u003e// Bind to lifecycle\u003c/span\u003e\nConcurrentCamera concurrentCamera =\n    cameraProvider.bindToLifecycle(listOf(primary, secondary));\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eYou are not constrained to a picture-in-picture layout. For instance, you could define a side-by-side layout by setting the offsets and scaling factors accordingly. You want to keep both dimensions scaled by the same amount to avoid a stretched preview. Here’s how that might look.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e// If 2 concurrent camera selectors were found, create 2 SingleCameraConfigs\u003c/span\u003e\n\u003cspan\u003e// and compose them in a picture-in-picture layout.\u003c/span\u003e\n\u003cspan\u003eval\u003c/span\u003e primary = SingleCameraConfig(\n    cameraSelectorPrimary,\n    useCaseGroup,\n    CompositionSettings.Builder()\n        .setAlpha(\u003cspan\u003e1.0f\u003c/span\u003e)\n        .setOffset(\u003cspan\u003e0.0f\u003c/span\u003e, \u003cspan\u003e0.25f\u003c/span\u003e)\n        .setScale(\u003cspan\u003e0.5f\u003c/span\u003e, \u003cspan\u003e0.5f\u003c/span\u003e)\n        .build(),\n    lifecycleOwner);\n\u003cspan\u003eval\u003c/span\u003e secondary = SingleCameraConfig(\n    cameraSelectorSecondary,\n    useCaseGroup,\n    CompositionSettings.Builder()\n        .setAlpha(\u003cspan\u003e1.0f\u003c/span\u003e)\n        .setOffset(\u003cspan\u003e0.5f\u003c/span\u003e, \u003cspan\u003e0.25f\u003c/span\u003e)\n        .setScale(\u003cspan\u003e0.5f\u003c/span\u003e, \u003cspan\u003e0.5f\u003c/span\u003e)\n        .build()\n    lifecycleOwner);\n\n\u003cspan\u003e// Bind to lifecycle\u003c/span\u003e\nConcurrentCamera concurrentCamera =\n    cameraProvider.bindToLifecycle(listOf(primary, secondary));\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe’re excited to offer this improvement to an already developer-friendly feature. Truly the CameraX way! \u003cspan\u003eCompositionSettings\u003c/span\u003e in Dual Concurrent Camera is currently in alpha, so if you have feature requests to improve upon it before the API is locked in, please give us feedback in the \u003ca href=\"https://groups.google.com/a/android.com/g/camerax-developers\" target=\"_blank\"\u003eCameraX Discussion Group\u003c/a\u003e. And check out the \u003ca href=\"https://developer.android.com/jetpack/androidx/releases/camera#1.5.0-alpha01\" target=\"_blank\"\u003efull CameraX 1.5.0-alpha01\u003c/a\u003e release notes to see what else is new in CameraX.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
