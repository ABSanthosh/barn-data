{
  "id": "d8a4dc68-1eb4-437c-9036-b4c7366e1c6b",
  "title": "Great teams merge fast",
  "link": "https://saket.me/great-teams-merge-fast/",
  "description": "One of the many things I was constantly amazed about during my first few weeks at Square/Cash App was seeing how fast this team shipped code. All members of the Android team (and likely other platforms as well) were merging to the main git branch multiple times every day. This was in stark contrast to […] The post Great teams merge fast appeared first on Saket Narayan.",
  "author": "Saket Narayan",
  "published": "Tue, 23 Feb 2021 23:15:21 +0000",
  "source": "https://saket.me/feed/",
  "categories": [
    "Uncategorized",
    "square"
  ],
  "byline": "Saket Narayan",
  "length": 5196,
  "excerpt": "Observations from watching my team at Square produce stellar work while moving fast and not breaking things.",
  "siteName": "Saket Narayan",
  "favicon": "",
  "text": "One of the many things I was constantly amazed about during my first few weeks at Square/Cash App was seeing how fast this team shipped code. All members of the Android team (and likely other platforms as well) were merging to the main git branch multiple times every day. This was in stark contrast to my previous company where it was common for us to raise large PRs after a couple days of work. Getting them merged-in wasn’t fast either. Reviewing these PRs was one of my least favorite parts of my work. In all fairness, I was always the first person to object that we can’t merge faster. Boy was I wrong. To other teams who feel they can be merging faster, here are a few things I’ve noticed I’m doing differently at Square: Trust your team members When reviewing PRs, we approve them immediately after leaving our feedback instead of holding it to ransom until our requested changes are made. This unblocks people from merging their PRs once they’ve resolved all feedback instead of waiting for another round of reviews. We trust our team members that they’re also trying to do their best for the project. If someone merges code that shouldn’t have been merged, that’s okay. A broken main branch can be quickly fixed. Bad commits can be easily reverted because rolling release windows are very forgiving. Nobody expects internal staging builds to be fully stable. Automate nitpicking and bikeshedding Code suggestions that often come up in PR reviews are bad signs (Dan Lew agrees). One of my favorite parts of our stack of static checks is a DenyListedApiDetector linter that discourages developers from using APIs we dislike. It’s like Kotlin’s @Deprecated annotation, but for code we don’t own — like the Android SDK or third-party libraries. For example, we block usages of Observable#test() in favor of an internal implementation that’s like cashapp/turbine but for RxJava. Here’s another example/question for you: how many of these APIs does your Android app use for reading XML drawables? 1. Context#getDrawable() 2. ContextCompat.getDrawable() 3. AppCompatResources.getDrawable() 4. ResourcesCompat.getDrawable() Only one of them is universally correct. We’ve deny-listed the rest of them. Stack PRs PRs that introduce 200 lines of changes or lower are the best. Anything more than that and the likelihood of reviewers skimming through crucial changes increases with every line, especially if they own Logitech MX Master that can scroll billions of lines with a single flick. For related work, we stack our PRs on top of each other so that they can be reviewed super quickly. GitHub automatically handles re-targeting of stacked PRs when their base is merged. I like to think that by making it easy to review PRs, we’re essentially showing empathy towards our customers. An unsuspecting bad piece of code can potentially result in people being unable to use their money and that’ll be a terrible thing to do. Ship work-in-progress code to production if (featureFlags[SuperSecretFeature].isEnabled) { navigator.goTo(SuperSecretScreen()) } else { navigator.goTo(BoringOldScreen()) } Merging code daily effectively translates to shipping work-in-progress code in production builds. To keep customers from running new features or incomplete refactorings of old code, we use feature flags. While this may sound obvious to some, I’ve worked on teams that instead held off merging their work until it’s ready. We were able to make it work, but it had huge downsides. Feature branches isolate your team, preventing other developers from seeing what you’re working on until it’s done. In large teams, this often leads to people organizing merge-conflict resolving parties. They’re not fun. Feature flags are also great for undoing mistakes. At Cash App’s scale, refactoring code that’s used by millions of customers is sometimes scary, but I feel comfortable knowing that I can push a button and remotely switch all our customers from BottomSheetV2 to BottomSheetV1 if an obscure bug is found in v2. JUnit snapshot tests com.squareup.cash.mooncake.AlertDialogViewTest \u003e message only FAILED java.lang.AssertionError: Images differ (by 0.7%) While unit tests are great for increasing confidence in making changes to existing business logic, the same hasn’t been true for UI. Companies often rely on a combination of Android tests and manual QA, both of which aren’t ideal. Android tests are super slow and manual testing is… well humans will make mistakes. We’re solving this with paparazzi that lets us write snapshot tests as JUnit tests, without the requirement of an actual device. Automated snapshot tests are great for ensuring that our layouts look pixel perfect with various configuration factors like display density, dark mode, up-scaled font size for accessibility, etc. Paparazzi is being actively developed, but you can try out an early preview: github.com/cashapp/paparazzi. Wrapping up, I like to think that when an engineering team is empowered to merge fast, it both demonstrates and cultivates trust in each other. Barriers to merging code are best used for high-level design discussions and pain points in the codebase, and not as a substitute for pairing sessions.",
  "image": "https://saket.me/wp-content/uploads/2021/02/great_teams_merge_fast_cover.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\t\t\u003cp\u003eOne of the many things I was constantly amazed about during my first few weeks at \u003ca href=\"https://square.com\"\u003eSquare\u003c/a\u003e/\u003ca href=\"https://cash.app\"\u003eCash App\u003c/a\u003e was seeing how fast this team shipped code. All members of the Android team (and likely other platforms as well) were merging to the main git branch multiple times every day.\u003c/p\u003e\n\u003cp\u003eThis was in stark contrast to my previous company where it was common for us to raise large PRs after a couple days of work. Getting them merged-in wasn’t fast either. Reviewing these PRs was one of my least favorite parts of my work. In all fairness, I was always the first person to object that we can’t merge faster. Boy was I wrong.\u003c/p\u003e\n\u003cp\u003eTo other teams who feel they can be merging faster, here are a few things I’ve noticed I’m doing differently at Square:\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eTrust your team members\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003eWhen reviewing PRs, we approve them immediately after leaving our feedback instead of holding it to ransom until our requested changes are made. This unblocks people from merging their PRs once they’ve resolved all feedback instead of waiting for another round of reviews. We trust our team members that they’re also trying to do their best for the project.\u003c/p\u003e\n\u003cp\u003eIf someone merges code that shouldn’t have been merged, that’s okay. A broken main branch can be quickly fixed. Bad commits can be easily reverted because rolling release windows are very forgiving. Nobody expects internal staging builds to be fully stable.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eAutomate nitpicking and bikeshedding\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg data-attachment-id=\"1460\" data-permalink=\"https://saket.me/great-teams-merge-fast/deny_listed_api_detector/\" data-orig-file=\"https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector.png\" data-orig-size=\"1602,587\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"deny_listed_api_detector\" data-image-description=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-300x110.png\" data-large-file=\"https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-1024x375.png\" decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector.png\" alt=\"\" width=\"1602\" height=\"587\" srcset=\"https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector.png 1602w, https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-300x110.png 300w, https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-768x281.png 768w, https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-1024x375.png 1024w, https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-1200x440.png 1200w, https://saket.me/wp-content/uploads/2021/02/deny_listed_api_detector-600x220.png 600w\" sizes=\"(max-width: 1602px) 100vw, 1602px\"/\u003e\u003c/p\u003e\n\u003cp\u003eCode suggestions that often come up in PR reviews are bad signs (\u003ca href=\"https://blog.danlew.net/2021/02/23/stop-nitpicking-in-code-reviews/\"\u003eDan Lew agrees\u003c/a\u003e). One of my favorite parts of our stack of static checks is a \u003ccode\u003eDenyListedApiDetector\u003c/code\u003e linter that discourages developers from using APIs we dislike. It’s like Kotlin’s \u003ccode\u003e@Deprecated\u003c/code\u003e annotation, but for code we don’t own — like the Android SDK or third-party libraries. For example, we block usages of \u003ccode\u003eObservable#test()\u003c/code\u003e in favor of an internal implementation that’s like \u003ca href=\"https://github.com/cashapp/turbine\"\u003ecashapp/turbine\u003c/a\u003e but for RxJava.\u003c/p\u003e\n\u003cp\u003eHere’s another example/question for you: how many of these APIs does your Android app use for reading XML drawables?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. Context#getDrawable()\n2. ContextCompat.getDrawable()\n3. AppCompatResources.getDrawable()\n4. ResourcesCompat.getDrawable()\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly one of them is universally correct. We’ve deny-listed the rest of them.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eStack PRs\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003ePRs that introduce 200 lines of changes or lower are the best. Anything more than that and the likelihood of reviewers skimming through crucial changes increases with every line, especially if they own Logitech MX Master that can scroll billions of lines with a single flick. For related work, we stack our PRs on top of each other so that they can be reviewed super quickly. GitHub automatically handles re-targeting of stacked PRs when their base is merged.\u003c/p\u003e\n\u003cp\u003eI like to think that by making it easy to review PRs, we’re essentially showing empathy towards our customers. An unsuspecting bad piece of code can potentially result in people being unable to use their money and that’ll be a terrible thing to do.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eShip work-in-progress code to production\u003c/b\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif (featureFlags[SuperSecretFeature].isEnabled) {\n  navigator.goTo(SuperSecretScreen())\n} else {\n  navigator.goTo(BoringOldScreen())\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMerging code daily effectively translates to shipping work-in-progress code in production builds. To keep customers from running new features or incomplete refactorings of old code, we use feature flags.\u003c/p\u003e\n\u003cp\u003eWhile this may sound obvious to some, I’ve worked on teams that instead held off merging their work until it’s ready. We were able to make it work, but it had huge downsides. Feature branches isolate your team, preventing other developers from seeing what you’re working on until it’s done. In large teams, this often leads to people organizing merge-conflict resolving parties. They’re not fun.\u003c/p\u003e\n\u003cp\u003eFeature flags are also great for undoing mistakes. At Cash App’s scale, refactoring code that’s used by millions of customers is sometimes scary, but I feel comfortable knowing that I can push a button and remotely switch all our customers from \u003ccode\u003eBottomSheetV2\u003c/code\u003e to \u003ccode\u003eBottomSheetV1\u003c/code\u003e if an obscure bug is found in v2.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eJUnit snapshot tests\u003c/b\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg data-attachment-id=\"1459\" data-permalink=\"https://saket.me/great-teams-merge-fast/paparazzi_snapshot_diff_on_github/\" data-orig-file=\"https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github.png\" data-orig-size=\"1806,783\" data-comments-opened=\"0\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"paparazzi_snapshot_diff_on_github\" data-image-description=\"\" data-medium-file=\"https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-300x130.png\" data-large-file=\"https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-1024x444.png\" decoding=\"async\" loading=\"lazy\" src=\"https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github.png\" alt=\"\" width=\"1806\" height=\"783\" srcset=\"https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github.png 1806w, https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-300x130.png 300w, https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-768x333.png 768w, https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-1024x444.png 1024w, https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-1200x520.png 1200w, https://saket.me/wp-content/uploads/2021/02/paparazzi_snapshot_diff_on_github-600x260.png 600w\" sizes=\"(max-width: 1806px) 100vw, 1806px\"/\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecom.squareup.cash.mooncake.AlertDialogViewTest \u0026gt; message only FAILED\njava.lang.AssertionError: Images differ (by 0.7%)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile unit tests are great for increasing confidence in making changes to existing business logic, the same hasn’t been true for UI. Companies often rely on a combination of Android tests and manual QA, both of which aren’t ideal. Android tests are super slow and manual testing is… well humans will make mistakes. We’re solving this with \u003ca href=\"https://github.com/cashapp/paparazzi\"\u003epaparazzi\u003c/a\u003e that lets us write snapshot tests as JUnit tests, without the requirement of an actual device.\u003c/p\u003e\n\u003cp\u003eAutomated snapshot tests are great for ensuring that our layouts look pixel perfect with various configuration factors like display density, dark mode, up-scaled font size for accessibility, etc. Paparazzi is being actively developed, but you can try out an early preview: \u003ca href=\"https://github.com/cashapp/paparazzi\"\u003egithub.com/cashapp/paparazzi\u003c/a\u003e.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eWrapping up, I like to think that when an engineering team is empowered to merge fast, it both demonstrates and cultivates trust in each other. Barriers to merging code are best used for high-level design discussions and pain points in the codebase, and not as a substitute for pairing sessions.\u003c/p\u003e\n\n\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2021-02-23T23:15:21Z",
  "modifiedTime": "2022-06-04T20:30:27Z"
}
