{
  "id": "de71ba80-1bb2-4c5d-80fa-70cf0a412945",
  "title": "How to smash a Jetpack Compose feature from Product‚Ää‚Äî‚Ääincluding testing!",
  "link": "https://proandroiddev.com/how-to-smash-a-jetpack-compose-feature-from-product-including-testing-c294e5357926?source=rss----c72404660798---4",
  "description": "",
  "author": "Raphael Cohen",
  "published": "Sat, 02 Nov 2024 14:39:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "android-app-development",
    "jetpack-compose",
    "android",
    "androiddev"
  ],
  "byline": "Raphael Cohen",
  "length": 19047,
  "excerpt": "To create exceptional Jetpack Compose features, start by aligning them with your product goals and user needs. Design, prototype, and develop features that provide value. For this specific feature‚Ä¶",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "The Team Leaders feature for the NHL app on Google PlayIntroductionTo create exceptional Jetpack Compose features, start by aligning them with your product goals and user needs. Design, prototype, and develop features that provide value. For this specific feature, Product aims to deliver interactive widgets and comprehensive player data, enhancing the user experience. üèÜüéâü•áüí™Key Points:Define product goals.Identify key features.Leverage Jetpack Compose‚Äôs strengths.Design and prototype.Develop with best practices.Test rigorously.Iterate and refine!Understanding the TeamLeadersViewModelThe TeamLeadersViewModel is a key component responsible for managing data and state in this Jetpack Compose app displaying team leader information.What it Does:collects team player data (getPlayers) and enriches it with player stats (enrichPlayersWithTeamData).Manages UI state using a MutableStateFlow that emits different states:Loading: While data is being fetched.Success: When data is retrieved successfully, holding skater and goalie leader lists.Error: If an error occurs during data fetching.Key Points:Uses dependency injection (@HiltViewModel) to access repositories and dispatchers.Leverages runCatching for concise error handling.Exposes a uiState StateFlow for UI components to observe data changes.Encapsulates player data enrichment logic in a private testable function.Benefits:Improved separation of concerns by isolating data fetching and state management.Reactive UI updates through StateFlow.Testable code with private functions accessible for unit testing (@VisibleForTesting).data class EnrichedPlayerData( val id: Int = 0, val headshot: String = \"\", val sweaterNumber: Int = 0, val positionCode: String = \"\", val firstName: String = \"\", val lastName: String = \"\", val points: Int = 0, val goals: Int = 0, val assists: Int = 0, val goalsAgainstAverage: Double = 0.0, val savePercentage: Double = 0.0)sealed class TeamLeadersUiState { data object Loading : TeamLeadersUiState() data class Success(val skaters: List\u003cEnrichedPlayerData\u003e, val goalies: List\u003cEnrichedPlayerData\u003e) : TeamLeadersUiState() data class Error(val throwable: Throwable) : TeamLeadersUiState()}@HiltViewModelclass TeamLeadersViewModel @Inject constructor( private val nhlRepository: NhlRepository, private val dateUtilsRepository: DateUtilsRepository, @IoDispatcher private val ioDispatcher: CoroutineDispatcher,) : ViewModel() { private val _uiState = MutableStateFlow\u003cTeamLeadersUiState\u003e(TeamLeadersUiState.Loading) val uiState: StateFlow\u003cTeamLeadersUiState\u003e = _uiState.asStateFlow() suspend fun getPlayers(teamAbbrevId: String) = withContext(context = ioDispatcher) { try { viewModelScope.launch { nhlRepository.getPlayers(teamAbbrevId).collect { team -\u003e val players = (team.forwards + team.defensemen + team.goalies).map { player -\u003e player.copy(teamLogo = team.defensemen[0].teamLogo, fullTeamName = Default(team.defensemen[0].fullTeamName.default)) } enrichPlayersWithTeamData(teamAbbrevId, players) } } } catch (e: Throwable) { _uiState.emit(TeamLeadersUiState.Error(Throwable(\"Oops, something went wrong. Try again.\"))) } } @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE) suspend fun enrichPlayersWithTeamData(teamAbbrevId: String, allPlayers: List\u003cPlayer\u003e) { var enrichedSkaters = emptyList\u003cEnrichedPlayerData\u003e() var enrichedGoalies = emptyList\u003cEnrichedPlayerData\u003e() runCatching { nhlRepository.getClubStats(teamAbbrevId, dateUtilsRepository.getCurrentSeasonInYears()).collect { clubStats -\u003e enrichedSkaters = clubStats.skaters.map { skater -\u003e val player = allPlayers.find { it.firstName.default == skater.firstName.default } ?: Player(firstName = \"N/A\") EnrichedPlayerData( id = player.id, headshot = player.headshot, sweaterNumber = player.sweaterNumber, positionCode = player.positionCode, firstName = player.firstName.default, lastName = player.lastName.default, points = skater.points, goals = skater.goals, assists = skater.assists ) } enrichedGoalies = clubStats.goalies.map { goalie -\u003e val player = allPlayers.find { it.firstName.default == goalie.firstName.default } ?: Player(firstName = \"N/A\") EnrichedPlayerData( id = player.id, headshot = player.headshot, sweaterNumber = player.sweaterNumber, positionCode = player.positionCode, firstName = player.firstName.default, lastName = player.lastName.default, savePercentage = goalie.savePercentage, goalsAgainstAverage = goalie.goalsAgainstAverage ) } } }.onSuccess { _uiState.emit( TeamLeadersUiState.Success(skaters = enrichedSkaters, goalies = enrichedGoalies) ) }.onFailure { throwable -\u003e _uiState.emit(TeamLeadersUiState.Error(Throwable(throwable.message))) } }}Analyzing the Unit Test for TeamLeadersViewModelPurpose:This unit test verifies that the enrichPlayersWithTeamData function in the TeamLeadersViewModel correctly transforms player and club-stat data into EnrichedPlayerData objects. By simulating network calls and providing mock data, the test ensures that the function accurately maps player information with relevant team statistics.Key Components:Mock objects: mockNhlRepository and mockDateUtilsRepository are mocked to control their behavior during testing.Test dispatcher: standardTestDispatcher is used to manage coroutines within the test environment.Test setup: The setUp method initializes the TeamLeadersViewModel with mocked dependencies.Test case: The enrichPlayersWithTeamData() emits players with team stats test case verifies that:The correct data is returned from mocked repositories.The player data is enriched with team statistics.The uiState is updated with the enriched player data.Code Breakdown:Mock setup: Mocks are created for nhlRepository and mockDateUtilsRepository to control their behavior.Data preparation: Sample player data, season, team ID, and expected club stats are created.Mock interactions: The mocked repositories are set up to return expected data.Function call: enrichPlayersWithTeamData is called with sample data.Verification: The emitted uiState is checked to ensure it contains the expected enriched player data.Overall, this unit test effectively verifies the core functionality of the enrichPlayersWithTeamData function. It tests the interaction with mocked repositories, the enrichment process, and the correct update of the uiState.Additional Considerations:Edge cases: Consider testing edge cases, such as empty player lists or missing data from the club stats.Error handling: Test how the function handles errors from the repositories.UI state updates: Verify that the uiState is updated correctly in different scenarios (success, error, loading).@ExperimentalCoroutinesApi@RunWith(JUnit4::class)class TeamLeadersViewModelTest { @MockK lateinit var mockNhlRepository: NhlRepository @MockK lateinit var mockDateUtilsRepository: DateUtilsRepository private lateinit var viewModel: TeamLeadersViewModel private val standardTestDispatcher = StandardTestDispatcher() @Before fun setUp() { Dispatchers.setMain(standardTestDispatcher) MockKAnnotations.init(this) viewModel = TeamLeadersViewModel( nhlRepository = mockNhlRepository, dateUtilsRepository = mockDateUtilsRepository, ioDispatcher = standardTestDispatcher ) } @After fun tearDown() { unmockkAll() } @Test fun `enrichPlayersWithTeamData() emits players with team stats`() = runTest { val mockPlayers = listOf(Player(id = 101, firstName = \"ScoobyDoo\")) val mockSeason = \"20232024\" val mockTeamAbbrevId = \"LAK\" val mockSkater = Skater(id = 101, firstName = \"ScoobyDoo\", goals = 16) val mockClubStats = ClubStats(skaters = listOf(mockSkater)) coEvery { mockDateUtilsRepository.getCurrentSeasonInYears() } returns mockSeason coEvery { mockNhlRepository.getClubStats(mockTeamAbbrevId, mockSeason) } returns flowOf(mockClubStats) advanceUntilIdle() viewModel.enrichPlayersWithTeamData(mockTeamAbbrevId, mockPlayers) val actualSkater = (viewModel.uiState.value as? TeamLeadersUiState.Success)?.topGoalsPlayers.orEmpty() assertEquals(mockSkater.goals, actualSkater[0].goals) }}Yay, Unit test passed!By writing comprehensive unit tests, you can ensure the reliability and correctness of your ViewModel‚Äôs behavior. More importantly the test is there as a refactoring shield üõ°Ô∏è if your refactored code changes and the test breaks, you know to update your viewModel code because it‚Äôs not a perfect world and you don‚Äôt know the business decision made at the initial time of implementation. ü§∑Dissecting the TeamLeadersScreen ComposableThis section dives into the TeamLeadersScreen composable and its related components used to display team leaders information.TeamLeadersScreen:Responds to changes in the TeamLeadersViewModel state using LaunchedEffect and collectAsState.Handles different UI states:Error: Navigates back with an error message.Loading: Displays a loading screen.Success (with players): Shows the team leaders screenShowTeamLeadersScreen:Manages the overall layout using a Scaffold composable.Implements a parallax scrolling toolbar with dynamic title based on collapsing state.Displays an asynchronous image for the team logo.Shows a bottom app bar with an ad banner (not covered here).Renders leader categories using LazyColumn and TeamLeadersListCard.TeamLeadersListCard:Represents a card displaying leaders for a specific category (points, goals, assists).Uses a ConstraintLayout for flexible layout of player information:Headshot image using AsyncImage.Player details like name, number, position, and team abbreviation.Text displaying the relevant stat (points, goals, assists).Enables user navigation to the player profile screen.Overall Design:This composable structure promotes separation of concerns by dividing the screen layout, content loading, and individual leader card rendering into separate composables.Effective usage of Jetpack Compose features like LaunchedEffect, collectAsState, Scaffold, LazyColumn, and ConstraintLayout for a dynamic and user-friendly interface.@Composablefun TeamLeadersScreen( teamAbbrevId: String, viewModel: TeamLeadersViewModel = hiltViewModel(), navController: NavController) { LaunchedEffect(Unit) { viewModel.getPlayers(teamAbbrevId) } val uiState by viewModel.uiState.collectAsState() when (uiState) { is TeamLeadersUiState.Error -\u003e { NavigateBackWithMessageScreen(message = stringResource(id = R.string.sin_bin_no_players_found), navController = navController) } is TeamLeadersUiState.Loading -\u003e LoadingScreen() is TeamLeadersUiState.Success -\u003e { ShowTeamLeadersScreen( teamColor = teamColor, teamAbbrevId = teamAbbrevId, uiState = uiState, navController = navController ) } }}@OptIn(ExperimentalMaterial3Api::class)@Composablefun ShowTeamLeadersScreen( teamColor: String, teamAbbrevId: String, uiState: TeamLeadersUiState.Succes, navController: NavController) { val coroutineScope = rememberCoroutineScope() DisposableEffect(coroutineScope) { onDispose { coroutineScope.cancel() } } val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior(rememberTopAppBarState()) val isCollapsed: Boolean by remember { derivedStateOf { scrollBehavior.state.collapsedFraction == 1f } } val toolbarTitle = if (!isCollapsed) \"TEAM\".plus(\"\\nLEADERS\") else \"LEADERS\" Scaffold( modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection), topBar = { ParallaxToolBar( scrollBehavior = scrollBehavior, navController = navController, title = toolbarTitle, color = teamColor, actions = { AsyncImage( model = ImageRequest.Builder(LocalContext.current) .data(\"https://nhl.com/logos/\".plus(teamAbbrevId)) .decoderFactory(SvgDecoder.Factory()) .crossfade(true) .diskCachePolicy(CachePolicy.ENABLED) .build(), contentDescription = null ) } ) }, bottomBar = { BottomAppBar(Modifier.fillMaxWidth()) { SetAdmobAdaptiveBanner() } } ) { padding -\u003e LazyColumn(Modifier.padding(padding)) { item { TeamLeadersListCard(title = POINTS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.points }, navController = navController) } item { TeamLeadersListCard(title = GOALS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.goals }, navController = navController) } item { TeamLeadersListCard(title = ASSISTS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.assists }, navController = navController) } } }}@Composablefun TeamLeadersListCard(title: String, teamColor: String, players: List\u003cEnrichedPlayerData\u003e, navController: NavController) { val coroutineScope = rememberCoroutineScope() DisposableEffect(coroutineScope) { onDispose { coroutineScope.cancel() } } Column(Modifier.padding(all = 10.dp).border(1.dp, lightGrayColor, RoundedCornerShape(4))) { Text(text = title, textAlign = TextAlign.Start) players.forEachIndexed { index, player -\u003e val bgColor = if (index == 0) Color(parseColor(teamColor)) else Color.White val borderColor = if (index == 0) Color.Transparent else lightGrayColor ConstraintLayout( Modifier .border(1.dp, borderColor, RoundedCornerShape(8)) .background(color = bgColor, shape = RoundedCornerShape(8)) .clickable { coroutineScope.launch { navController.navigate(PlayerProfile.createRoute(id = player.id)) } } .fillMaxSize() ) { val (headshot, firstName, lastName, playerTeamNumAndPos, number) = createRefs() val chainRef = createVerticalChain(firstName, lastName, playerTeamNumAndPos, chainStyle = ChainStyle.Packed) constrain(chainRef) { top.linkTo(headshot.top) bottom.linkTo(headshot.bottom) } Box(Modifier .clip(CircleShape) .background(colorResource(R.color.offWhiteColor)) .border(shape = CircleShape, width = 1.dp, color = colorResource(R.color.whiteSmokeColor)) .constrainAs(headshot) { start.linkTo(parent.start) top.linkTo(parent.top) } ) { AsyncImage(model = player.headshot, contentDescription = null, modifier = Modifier.fillMaxSize()) } Text( text = player.firstName.default, modifier = Modifier .constrainAs(firstName) { start.linkTo(headshot.end) end.linkTo(number.start) top.linkTo(headshot.top) bottom.linkTo(lastName.top) width = Dimension.fillToConstraints } ) Text( text = player.lastName.default, textAlign = TextAlign.Start, modifier = Modifier .constrainAs(lastName) { start.linkTo(headshot.end) end.linkTo(number.start) top.linkTo(firstName.bottom) bottom.linkTo(playerTeamNumAndPos.top) width = Dimension.fillToConstraints } ) val regexTeamNameAbbr = Regex(\"[A-Z]{3}\").find(player.headshot) val teamNameAbbr = regexTeamNameAbbr?.value ?: \"NHL\" Text( text = \"$teamNameAbbr ‚Ä¢ #${player.sweaterNumber} ‚Ä¢ ${player.positionCode}\", textAlign = TextAlign.Start, modifier = Modifier .constrainAs(playerTeamNumAndPos) { start.linkTo(headshot.end) end.linkTo(number.start) top.linkTo(lastName.bottom) bottom.linkTo(headshot.bottom) width = Dimension.fillToConstraints } ) val numberString = when (title) { POINTS -\u003e player.points.toString() GOALS -\u003e player.goals.toString() ASSISTS -\u003e player.assists.toString() else -\u003e \"N/A\" } Text( text = numberString, textAlign = TextAlign.Center, modifier = Modifier .constrainAs(number) { start.linkTo(playerTeamNumAndPos.end) end.linkTo(parent.end) top.linkTo(firstName.top) bottom.linkTo(playerTeamNumAndPos.bottom) width = Dimension.fillToConstraints } ) } } }}This blog post provides a comprehensive guide to building Jetpack Compose features from a product-centric perspective. It covers key steps such as understanding product goals, designing and prototyping, developing with best practices, testing, and iterating for improvement. By following these guidelines, you can create exceptional mobile app experiences using Jetpack Compose.To download the sample app and this feature, visit the following link on Google Play: https://play.google.com/store/apps/details?id=com.brickyard.nhlBest,RC",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*AL-_I94EqY2peWcduHOzDw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@cohen.n.raphael?source=post_page---byline--c294e5357926--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Raphael Cohen\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*xhANrotyDl7RWXyQpNyZCQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--c294e5357926--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe Team Leaders feature for the NHL app on Google Play\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"9dc1\"\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"9f2f\"\u003eTo create exceptional Jetpack Compose features, start by aligning them with your product goals and user needs. Design, prototype, and develop features that provide value. For this specific feature, Product aims to deliver interactive widgets and comprehensive player data, enhancing the user experience. üèÜüéâü•áüí™\u003c/p\u003e\u003ch2 id=\"054e\"\u003e\u003cstrong\u003eKey Points:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b103\"\u003eDefine product goals.\u003c/li\u003e\u003cli id=\"86cf\"\u003eIdentify key features.\u003c/li\u003e\u003cli id=\"64f6\"\u003eLeverage Jetpack Compose‚Äôs strengths.\u003c/li\u003e\u003cli id=\"1d3a\"\u003eDesign and prototype.\u003c/li\u003e\u003cli id=\"bc31\"\u003eDevelop with best practices.\u003c/li\u003e\u003cli id=\"cfa9\"\u003eTest rigorously.\u003c/li\u003e\u003cli id=\"7557\"\u003eIterate and refine!\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"c75e\"\u003eUnderstanding the TeamLeadersViewModel\u003c/h2\u003e\u003cp id=\"ffb0\"\u003eThe \u003ccode\u003eTeamLeadersViewModel\u003c/code\u003e is a key component responsible for managing data and state in this Jetpack Compose app displaying team leader information.\u003c/p\u003e\u003ch2 id=\"b29c\"\u003e\u003cstrong\u003eWhat it Does:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"ee66\"\u003e\u003ccode\u003ecollects\u003c/code\u003e team player data (\u003ccode\u003egetPlayers\u003c/code\u003e) and enriches it with player stats (\u003ccode\u003eenrichPlayersWithTeamData\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"dcb4\"\u003eManages UI state using a \u003ccode\u003eMutableStateFlow\u003c/code\u003e that emits different states:\u003c/li\u003e\u003cli id=\"df28\"\u003e\u003ccode\u003eLoading\u003c/code\u003e: While data is being fetched.\u003c/li\u003e\u003cli id=\"e236\"\u003e\u003ccode\u003eSuccess\u003c/code\u003e: When data is retrieved successfully, holding skater and goalie leader lists.\u003c/li\u003e\u003cli id=\"2874\"\u003e\u003ccode\u003eError\u003c/code\u003e: If an error occurs during data fetching.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"4064\"\u003e\u003cstrong\u003eKey Points:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"0934\"\u003eUses dependency injection (\u003ccode\u003e@HiltViewModel\u003c/code\u003e) to access repositories and dispatchers.\u003c/li\u003e\u003cli id=\"e525\"\u003eLeverages \u003ccode\u003erunCatching\u003c/code\u003e for concise error handling.\u003c/li\u003e\u003cli id=\"d7e7\"\u003eExposes a \u003ccode\u003euiState\u003c/code\u003e \u003ccode\u003eStateFlow\u003c/code\u003e for UI components to observe data changes.\u003c/li\u003e\u003cli id=\"33e9\"\u003eEncapsulates player data enrichment logic in a private testable function.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3386\"\u003e\u003cstrong\u003eBenefits:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1f3d\"\u003eImproved \u003cstrong\u003e\u003cem\u003eseparation of concerns\u003c/em\u003e\u003c/strong\u003e by isolating data fetching and state management.\u003c/li\u003e\u003cli id=\"69f9\"\u003e\u003cstrong\u003eReactive\u003c/strong\u003e UI updates through \u003ccode\u003eStateFlow\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"c458\"\u003e\u003cstrong\u003eTestable code\u003c/strong\u003e with private functions accessible for unit testing (\u003ccode\u003e@VisibleForTesting\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"ae9d\"\u003edata class EnrichedPlayerData(\u003cbr/\u003e    val id: Int = 0,\u003cbr/\u003e    val headshot: String = \u0026#34;\u0026#34;,\u003cbr/\u003e    val sweaterNumber: Int = 0,\u003cbr/\u003e    val positionCode: String = \u0026#34;\u0026#34;,\u003cbr/\u003e    val firstName: String = \u0026#34;\u0026#34;,\u003cbr/\u003e    val lastName: String = \u0026#34;\u0026#34;,\u003cbr/\u003e    val points: Int = 0,\u003cbr/\u003e    val goals: Int = 0,\u003cbr/\u003e    val assists: Int = 0,\u003cbr/\u003e    val goalsAgainstAverage: Double = 0.0,\u003cbr/\u003e    val savePercentage: Double = 0.0\u003cbr/\u003e)\u003cp\u003esealed class TeamLeadersUiState {\u003cbr/\u003e    data object Loading : TeamLeadersUiState()\u003cbr/\u003e    data class Success(val skaters: List\u0026lt;EnrichedPlayerData\u0026gt;, val goalies: List\u0026lt;EnrichedPlayerData\u0026gt;) : TeamLeadersUiState()\u003cbr/\u003e    data class Error(val throwable: Throwable) : TeamLeadersUiState()\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@HiltViewModel\u003cbr/\u003eclass TeamLeadersViewModel @Inject constructor(\u003cbr/\u003e    private val nhlRepository: NhlRepository,\u003cbr/\u003e    private val dateUtilsRepository: DateUtilsRepository,\u003cbr/\u003e    @IoDispatcher private val ioDispatcher: CoroutineDispatcher,\u003cbr/\u003e) : ViewModel() {\u003c/p\u003e\u003cp\u003e    private val _uiState = MutableStateFlow\u0026lt;TeamLeadersUiState\u0026gt;(TeamLeadersUiState.Loading)\u003cbr/\u003e    val uiState: StateFlow\u0026lt;TeamLeadersUiState\u0026gt; = _uiState.asStateFlow()\u003c/p\u003e\u003cp\u003e    suspend fun getPlayers(teamAbbrevId: String) = withContext(context = ioDispatcher) {\u003cbr/\u003e        try {\u003cbr/\u003e            viewModelScope.launch {\u003cbr/\u003e                nhlRepository.getPlayers(teamAbbrevId).collect { team -\u0026gt;\u003cbr/\u003e                    val players = (team.forwards + team.defensemen + team.goalies).map { player -\u0026gt;\u003cbr/\u003e                        player.copy(teamLogo = team.defensemen[0].teamLogo, fullTeamName = Default(team.defensemen[0].fullTeamName.default))\u003cbr/\u003e                    }\u003cbr/\u003e                    enrichPlayersWithTeamData(teamAbbrevId, players)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        } catch (e: Throwable) {\u003cbr/\u003e            _uiState.emit(TeamLeadersUiState.Error(Throwable(\u0026#34;Oops, something went wrong. Try again.\u0026#34;)))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE)\u003cbr/\u003e    suspend fun enrichPlayersWithTeamData(teamAbbrevId: String, allPlayers: List\u0026lt;Player\u0026gt;) {\u003cbr/\u003e        var enrichedSkaters = emptyList\u0026lt;EnrichedPlayerData\u0026gt;()\u003cbr/\u003e        var enrichedGoalies = emptyList\u0026lt;EnrichedPlayerData\u0026gt;()\u003cbr/\u003e        runCatching {\u003cbr/\u003e            nhlRepository.getClubStats(teamAbbrevId, dateUtilsRepository.getCurrentSeasonInYears()).collect { clubStats -\u0026gt;\u003cbr/\u003e                enrichedSkaters = clubStats.skaters.map { skater -\u0026gt;\u003cbr/\u003e                    val player = allPlayers.find { it.firstName.default == skater.firstName.default } ?: Player(firstName = \u0026#34;N/A\u0026#34;)\u003cbr/\u003e                    EnrichedPlayerData(\u003cbr/\u003e                        id = player.id,\u003cbr/\u003e                        headshot = player.headshot,\u003cbr/\u003e                        sweaterNumber = player.sweaterNumber,\u003cbr/\u003e                        positionCode = player.positionCode,\u003cbr/\u003e                        firstName = player.firstName.default,\u003cbr/\u003e                        lastName = player.lastName.default,\u003cbr/\u003e                        points = skater.points,\u003cbr/\u003e                        goals = skater.goals,\u003cbr/\u003e                        assists = skater.assists\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e                enrichedGoalies = clubStats.goalies.map { goalie -\u0026gt;\u003cbr/\u003e                    val player = allPlayers.find { it.firstName.default == goalie.firstName.default } ?: Player(firstName = \u0026#34;N/A\u0026#34;)\u003cbr/\u003e                    EnrichedPlayerData(\u003cbr/\u003e                        id = player.id,\u003cbr/\u003e                        headshot = player.headshot,\u003cbr/\u003e                        sweaterNumber = player.sweaterNumber,\u003cbr/\u003e                        positionCode = player.positionCode,\u003cbr/\u003e                        firstName = player.firstName.default,\u003cbr/\u003e                        lastName = player.lastName.default,\u003cbr/\u003e                        savePercentage = goalie.savePercentage,\u003cbr/\u003e                        goalsAgainstAverage = goalie.goalsAgainstAverage\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }.onSuccess {\u003cbr/\u003e            _uiState.emit(\u003cbr/\u003e                TeamLeadersUiState.Success(skaters = enrichedSkaters, goalies = enrichedGoalies)\u003cbr/\u003e            )\u003cbr/\u003e        }.onFailure { throwable -\u0026gt;\u003cbr/\u003e            _uiState.emit(TeamLeadersUiState.Error(Throwable(throwable.message)))\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2a80\"\u003eAnalyzing the Unit Test for \u003ccode\u003eTeamLeadersViewModel\u003c/code\u003e\u003c/h2\u003e\u003ch2 id=\"facd\"\u003e\u003cstrong\u003ePurpose:\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"6b8a\"\u003eThis unit test verifies that the \u003ccode\u003eenrichPlayersWithTeamData\u003c/code\u003e function in the \u003ccode\u003eTeamLeadersViewModel\u003c/code\u003e correctly transforms \u003cstrong\u003eplayer\u003c/strong\u003e and \u003cstrong\u003eclub-stat\u003c/strong\u003e data into \u003ccode\u003eEnrichedPlayerData\u003c/code\u003e objects. By simulating network calls and providing mock data, the test ensures that the function accurately maps player information with relevant team statistics.\u003c/p\u003e\u003ch2 id=\"c1ba\"\u003e\u003cstrong\u003eKey Components:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a6c9\"\u003e\u003cstrong\u003eMock objects:\u003c/strong\u003e \u003ccode\u003emockNhlRepository\u003c/code\u003e and \u003ccode\u003emockDateUtilsRepository\u003c/code\u003e are mocked to control their behavior during testing.\u003c/li\u003e\u003cli id=\"7752\"\u003e\u003cstrong\u003eTest dispatcher:\u003c/strong\u003e \u003ccode\u003estandardTestDispatcher\u003c/code\u003e is used to manage coroutines within the test environment.\u003c/li\u003e\u003cli id=\"8aea\"\u003e\u003cstrong\u003eTest setup:\u003c/strong\u003e The \u003ccode\u003esetUp\u003c/code\u003e method initializes the \u003ccode\u003eTeamLeadersViewModel\u003c/code\u003e with mocked dependencies.\u003c/li\u003e\u003cli id=\"5d08\"\u003e\u003cstrong\u003eTest case:\u003c/strong\u003e The \u003ccode\u003eenrichPlayersWithTeamData() emits players with team stats\u003c/code\u003e test case verifies that:\u003c/li\u003e\u003cli id=\"b97c\"\u003eThe correct data is returned from mocked repositories.\u003c/li\u003e\u003cli id=\"d26f\"\u003eThe player data is enriched with team statistics.\u003c/li\u003e\u003cli id=\"1288\"\u003eThe \u003ccode\u003euiState\u003c/code\u003e is updated with the enriched player data.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"1628\"\u003e\u003cstrong\u003eCode Breakdown:\u003c/strong\u003e\u003c/h2\u003e\u003col\u003e\u003cli id=\"e954\"\u003e\u003cstrong\u003eMock setup:\u003c/strong\u003e Mocks are created for \u003ccode\u003enhlRepository\u003c/code\u003e and \u003ccode\u003emockDateUtilsRepository\u003c/code\u003e to control their behavior.\u003c/li\u003e\u003cli id=\"400a\"\u003e\u003cstrong\u003eData preparation:\u003c/strong\u003e Sample player data, season, team ID, and expected club stats are created.\u003c/li\u003e\u003cli id=\"acb5\"\u003e\u003cstrong\u003eMock interactions:\u003c/strong\u003e The mocked repositories are set up to return expected data.\u003c/li\u003e\u003cli id=\"0233\"\u003e\u003cstrong\u003eFunction call:\u003c/strong\u003e \u003ccode\u003eenrichPlayersWithTeamData\u003c/code\u003e is called with sample data.\u003c/li\u003e\u003cli id=\"2bc9\"\u003e\u003cstrong\u003eVerification:\u003c/strong\u003e The emitted \u003ccode\u003euiState\u003c/code\u003e is checked to ensure it contains the expected enriched player data.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"2546\"\u003e\u003cstrong\u003eOverall, this unit test effectively verifies the core functionality of the \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eenrichPlayersWithTeamData\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e function.\u003c/strong\u003e It tests the interaction with mocked repositories, the enrichment process, and the correct update of the \u003ccode\u003euiState\u003c/code\u003e.\u003c/p\u003e\u003ch2 id=\"1311\"\u003e\u003cstrong\u003eAdditional Considerations:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"869f\"\u003e\u003cstrong\u003eEdge cases:\u003c/strong\u003e Consider testing edge cases, such as empty player lists or missing data from the club stats.\u003c/li\u003e\u003cli id=\"175d\"\u003e\u003cstrong\u003eError handling:\u003c/strong\u003e Test how the function handles errors from the repositories.\u003c/li\u003e\u003cli id=\"6049\"\u003e\u003cstrong\u003eUI state updates:\u003c/strong\u003e Verify that the \u003ccode\u003euiState\u003c/code\u003e is updated correctly in different scenarios (success, error, loading).\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"98fe\"\u003e@ExperimentalCoroutinesApi\u003cbr/\u003e@RunWith(JUnit4::class)\u003cbr/\u003eclass TeamLeadersViewModelTest {\u003cp\u003e    @MockK\u003cbr/\u003e    lateinit var mockNhlRepository: NhlRepository\u003c/p\u003e\u003cp\u003e    @MockK\u003cbr/\u003e    lateinit var mockDateUtilsRepository: DateUtilsRepository\u003c/p\u003e\u003cp\u003e    private lateinit var viewModel: TeamLeadersViewModel\u003c/p\u003e\u003cp\u003e    private val standardTestDispatcher = StandardTestDispatcher()\u003c/p\u003e\u003cp\u003e    @Before\u003cbr/\u003e    fun setUp() {\u003cbr/\u003e        Dispatchers.setMain(standardTestDispatcher)\u003cbr/\u003e        MockKAnnotations.init(this)\u003c/p\u003e\u003cp\u003e        viewModel = TeamLeadersViewModel(\u003cbr/\u003e            nhlRepository = mockNhlRepository,\u003cbr/\u003e            dateUtilsRepository = mockDateUtilsRepository,\u003cbr/\u003e            ioDispatcher = standardTestDispatcher\u003cbr/\u003e        )\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @After\u003cbr/\u003e    fun tearDown() {\u003cbr/\u003e        unmockkAll()\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    @Test\u003cbr/\u003e    fun `enrichPlayersWithTeamData() emits players with team stats`() = runTest {\u003cbr/\u003e        val mockPlayers = listOf(Player(id = 101, firstName = \u0026#34;ScoobyDoo\u0026#34;))\u003cbr/\u003e        val mockSeason = \u0026#34;20232024\u0026#34;\u003cbr/\u003e        val mockTeamAbbrevId = \u0026#34;LAK\u0026#34;\u003cbr/\u003e        val mockSkater = Skater(id = 101, firstName = \u0026#34;ScoobyDoo\u0026#34;, goals = 16)\u003cbr/\u003e        val mockClubStats = ClubStats(skaters = listOf(mockSkater))\u003c/p\u003e\u003cp\u003e                coEvery { mockDateUtilsRepository.getCurrentSeasonInYears() } returns mockSeason\u003cbr/\u003e        coEvery { mockNhlRepository.getClubStats(mockTeamAbbrevId, mockSeason) } returns flowOf(mockClubStats)\u003cbr/\u003e        advanceUntilIdle()\u003c/p\u003e\u003cp\u003e                viewModel.enrichPlayersWithTeamData(mockTeamAbbrevId, mockPlayers)\u003c/p\u003e\u003cp\u003e                val actualSkater = (viewModel.uiState.value as? TeamLeadersUiState.Success)?.topGoalsPlayers.orEmpty()\u003cbr/\u003e        assertEquals(mockSkater.goals, actualSkater[0].goals)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003eYay, Unit test passed!\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"bc5a\"\u003eBy writing comprehensive unit tests, you can ensure the reliability and correctness of your ViewModel‚Äôs behavior. More importantly the test is there as a refactoring shield üõ°Ô∏è if your refactored code changes and the test breaks, you know to update your viewModel code because it‚Äôs not a perfect world and you don‚Äôt know the business decision made at the initial time of implementation. ü§∑\u003c/p\u003e\u003ch2 id=\"a39f\"\u003eDissecting the TeamLeadersScreen Composable\u003c/h2\u003e\u003cp id=\"2fb5\"\u003eThis section dives into the \u003ccode\u003eTeamLeadersScreen\u003c/code\u003e composable and its related components used to display team leaders information.\u003c/p\u003e\u003ch2 id=\"1a50\"\u003e\u003cstrong\u003eTeamLeadersScreen:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"2308\"\u003eResponds to changes in the \u003ccode\u003eTeamLeadersViewModel\u003c/code\u003e state using \u003ccode\u003eLaunchedEffect\u003c/code\u003e and \u003ccode\u003ecollectAsState\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"472c\"\u003eHandles different UI states:\u003c/li\u003e\u003cli id=\"e633\"\u003e\u003ccode\u003eError\u003c/code\u003e: Navigates back with an error message.\u003c/li\u003e\u003cli id=\"96aa\"\u003e\u003ccode\u003eLoading\u003c/code\u003e: Displays a loading screen.\u003c/li\u003e\u003cli id=\"fce7\"\u003e\u003ccode\u003eSuccess\u003c/code\u003e (with players): Shows the team leaders screen\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6721\"\u003e\u003cstrong\u003eShowTeamLeadersScreen:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"34c0\"\u003eManages the overall layout using a \u003ccode\u003eScaffold\u003c/code\u003e composable.\u003c/li\u003e\u003cli id=\"5f9e\"\u003eImplements a parallax scrolling toolbar with dynamic title based on collapsing state.\u003c/li\u003e\u003cli id=\"d985\"\u003eDisplays an asynchronous image for the team logo.\u003c/li\u003e\u003cli id=\"0800\"\u003eShows a bottom app bar with an ad banner (not covered here).\u003c/li\u003e\u003cli id=\"1814\"\u003eRenders leader categories using \u003ccode\u003eLazyColumn\u003c/code\u003e and \u003ccode\u003eTeamLeadersListCard\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"405b\"\u003e\u003cstrong\u003eTeamLeadersListCard:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"4066\"\u003eRepresents a card displaying leaders for a specific category (points, goals, assists).\u003c/li\u003e\u003cli id=\"02ba\"\u003eUses a \u003ccode\u003eConstraintLayout\u003c/code\u003e for flexible layout of player information:\u003c/li\u003e\u003cli id=\"e5a7\"\u003eHeadshot image using \u003ccode\u003eAsyncImage\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"330b\"\u003ePlayer details like name, number, position, and team abbreviation.\u003c/li\u003e\u003cli id=\"3ab2\"\u003eText displaying the relevant stat (points, goals, assists).\u003c/li\u003e\u003cli id=\"c3d0\"\u003eEnables user navigation to the player profile screen.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"db2d\"\u003e\u003cstrong\u003eOverall Design:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"baa1\"\u003eThis composable structure promotes separation of concerns by dividing the screen layout, content loading, and individual leader card rendering into separate composables.\u003c/li\u003e\u003cli id=\"a825\"\u003eEffective usage of Jetpack Compose features like \u003ccode\u003eLaunchedEffect\u003c/code\u003e, \u003ccode\u003ecollectAsState\u003c/code\u003e, \u003ccode\u003eScaffold\u003c/code\u003e, \u003ccode\u003eLazyColumn\u003c/code\u003e, and \u003ccode\u003eConstraintLayout\u003c/code\u003e for a dynamic and user-friendly interface.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"f73b\"\u003e@Composable\u003cbr/\u003efun TeamLeadersScreen(\u003cbr/\u003e    teamAbbrevId: String,\u003cbr/\u003e    viewModel: TeamLeadersViewModel = hiltViewModel(),\u003cbr/\u003e    navController: NavController\u003cbr/\u003e) {\u003cbr/\u003e    LaunchedEffect(Unit) { viewModel.getPlayers(teamAbbrevId) }\u003cbr/\u003e    val uiState by viewModel.uiState.collectAsState()\u003cbr/\u003e      when (uiState) {\u003cbr/\u003e        is TeamLeadersUiState.Error -\u0026gt; {\u003cbr/\u003e            NavigateBackWithMessageScreen(message = stringResource(id = R.string.sin_bin_no_players_found), navController = navController)\u003cbr/\u003e        }\u003cbr/\u003e        is TeamLeadersUiState.Loading -\u0026gt; LoadingScreen()\u003cbr/\u003e        is TeamLeadersUiState.Success -\u0026gt; {\u003cbr/\u003e            ShowTeamLeadersScreen(\u003cbr/\u003e                teamColor = teamColor,\u003cbr/\u003e                teamAbbrevId = teamAbbrevId,\u003cbr/\u003e                uiState = uiState,\u003cbr/\u003e                navController = navController\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e@OptIn(ExperimentalMaterial3Api::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun ShowTeamLeadersScreen(\u003cbr/\u003e    teamColor: String,\u003cbr/\u003e    teamAbbrevId: String,\u003cbr/\u003e    uiState: TeamLeadersUiState.Succes,\u003cbr/\u003e    navController: NavController\u003cbr/\u003e) {\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    DisposableEffect(coroutineScope) { onDispose { coroutineScope.cancel() } }\u003cbr/\u003e    val scrollBehavior = TopAppBarDefaults.exitUntilCollapsedScrollBehavior(rememberTopAppBarState())\u003cbr/\u003e    val isCollapsed: Boolean by remember {\u003cbr/\u003e        derivedStateOf { scrollBehavior.state.collapsedFraction == 1f }\u003cbr/\u003e    }\u003cbr/\u003e    val toolbarTitle = if (!isCollapsed) \u0026#34;TEAM\u0026#34;.plus(\u0026#34;\\nLEADERS\u0026#34;) else \u0026#34;LEADERS\u0026#34;\u003cbr/\u003e    Scaffold(\u003cbr/\u003e        modifier = Modifier.nestedScroll(scrollBehavior.nestedScrollConnection),\u003cbr/\u003e        topBar = {\u003cbr/\u003e            ParallaxToolBar(\u003cbr/\u003e                scrollBehavior = scrollBehavior,\u003cbr/\u003e                navController = navController,\u003cbr/\u003e                title = toolbarTitle,\u003cbr/\u003e                color = teamColor,\u003cbr/\u003e                actions = {\u003cbr/\u003e                    AsyncImage(\u003cbr/\u003e                        model = ImageRequest.Builder(LocalContext.current)\u003cbr/\u003e                            .data(\u0026#34;https://nhl.com/logos/\u0026#34;.plus(teamAbbrevId))\u003cbr/\u003e                            .decoderFactory(SvgDecoder.Factory())\u003cbr/\u003e                            .crossfade(true)\u003cbr/\u003e                            .diskCachePolicy(CachePolicy.ENABLED)\u003cbr/\u003e                            .build(),\u003cbr/\u003e                        contentDescription = null\u003cbr/\u003e                    )\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        bottomBar = { BottomAppBar(Modifier.fillMaxWidth()) { SetAdmobAdaptiveBanner() } }\u003cbr/\u003e    ) { padding -\u0026gt;\u003cbr/\u003e        LazyColumn(Modifier.padding(padding)) {\u003cbr/\u003e            item {\u003cbr/\u003e                TeamLeadersListCard(title = POINTS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.points }, navController = navController)\u003cbr/\u003e            }\u003cbr/\u003e            item {\u003cbr/\u003e                TeamLeadersListCard(title = GOALS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.goals }, navController = navController)\u003cbr/\u003e            }\u003cbr/\u003e            item {\u003cbr/\u003e                TeamLeadersListCard(title = ASSISTS, teamColor = teamColor, players = uiState.skaters.sortedByDescending { it.assists }, navController = navController)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003efun TeamLeadersListCard(title: String, teamColor: String, players: List\u0026lt;EnrichedPlayerData\u0026gt;, navController: NavController) {\u003cbr/\u003e    val coroutineScope = rememberCoroutineScope()\u003cbr/\u003e    DisposableEffect(coroutineScope) { onDispose { coroutineScope.cancel() } }\u003cbr/\u003e    Column(Modifier.padding(all = 10.dp).border(1.dp, lightGrayColor, RoundedCornerShape(4))) {\u003cbr/\u003e        Text(text = title, textAlign = TextAlign.Start)\u003cbr/\u003e        players.forEachIndexed { index, player -\u0026gt;\u003cbr/\u003e            val bgColor = if (index == 0) Color(parseColor(teamColor)) else Color.White\u003cbr/\u003e            val borderColor = if (index == 0) Color.Transparent else lightGrayColor\u003cbr/\u003e            ConstraintLayout(\u003cbr/\u003e                Modifier \u003cbr/\u003e                    .border(1.dp, borderColor, RoundedCornerShape(8))\u003cbr/\u003e                    .background(color = bgColor, shape = RoundedCornerShape(8))\u003cbr/\u003e                    .clickable { coroutineScope.launch { navController.navigate(PlayerProfile.createRoute(id = player.id)) } }\u003cbr/\u003e                    .fillMaxSize()\u003cbr/\u003e            ) {\u003cbr/\u003e                val (headshot, firstName, lastName, playerTeamNumAndPos, number) = createRefs()\u003cbr/\u003e                val chainRef = createVerticalChain(firstName, lastName, playerTeamNumAndPos, chainStyle = ChainStyle.Packed)\u003cbr/\u003e                constrain(chainRef) {\u003cbr/\u003e                    top.linkTo(headshot.top)\u003cbr/\u003e                    bottom.linkTo(headshot.bottom)\u003cbr/\u003e                }\u003cbr/\u003e                Box(Modifier\u003cbr/\u003e                    .clip(CircleShape)\u003cbr/\u003e                    .background(colorResource(R.color.offWhiteColor))\u003cbr/\u003e                    .border(shape = CircleShape, width = 1.dp, color = colorResource(R.color.whiteSmokeColor))\u003cbr/\u003e                    .constrainAs(headshot) {\u003cbr/\u003e                        start.linkTo(parent.start)\u003cbr/\u003e                        top.linkTo(parent.top)\u003cbr/\u003e                    }\u003cbr/\u003e                ) {\u003cbr/\u003e                    AsyncImage(model = player.headshot, contentDescription = null, modifier = Modifier.fillMaxSize())\u003cbr/\u003e                }\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = player.firstName.default,\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .constrainAs(firstName) {\u003cbr/\u003e                            start.linkTo(headshot.end)\u003cbr/\u003e                            end.linkTo(number.start)\u003cbr/\u003e                            top.linkTo(headshot.top)\u003cbr/\u003e                            bottom.linkTo(lastName.top)\u003cbr/\u003e                            width = Dimension.fillToConstraints\u003cbr/\u003e                        }\u003cbr/\u003e                )\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = player.lastName.default,\u003cbr/\u003e                    textAlign = TextAlign.Start,\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .constrainAs(lastName) {\u003cbr/\u003e                            start.linkTo(headshot.end)\u003cbr/\u003e                            end.linkTo(number.start)\u003cbr/\u003e                            top.linkTo(firstName.bottom)\u003cbr/\u003e                            bottom.linkTo(playerTeamNumAndPos.top)\u003cbr/\u003e                            width = Dimension.fillToConstraints\u003cbr/\u003e                        }\u003cbr/\u003e                )\u003cbr/\u003e                val regexTeamNameAbbr = Regex(\u0026#34;[A-Z]{3}\u0026#34;).find(player.headshot)\u003cbr/\u003e                val teamNameAbbr = regexTeamNameAbbr?.value ?: \u0026#34;NHL\u0026#34;\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = \u0026#34;$teamNameAbbr ‚Ä¢ #${player.sweaterNumber} ‚Ä¢ ${player.positionCode}\u0026#34;,\u003cbr/\u003e                    textAlign = TextAlign.Start,\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .constrainAs(playerTeamNumAndPos) {\u003cbr/\u003e                            start.linkTo(headshot.end)\u003cbr/\u003e                            end.linkTo(number.start)\u003cbr/\u003e                            top.linkTo(lastName.bottom)\u003cbr/\u003e                            bottom.linkTo(headshot.bottom)\u003cbr/\u003e                            width = Dimension.fillToConstraints\u003cbr/\u003e                        }\u003cbr/\u003e                )\u003cbr/\u003e                val numberString = when (title) {\u003cbr/\u003e                    POINTS -\u0026gt; player.points.toString()\u003cbr/\u003e                    GOALS -\u0026gt; player.goals.toString()\u003cbr/\u003e                    ASSISTS -\u0026gt; player.assists.toString()\u003cbr/\u003e                    else -\u0026gt; \u0026#34;N/A\u0026#34;\u003cbr/\u003e                }\u003cbr/\u003e                Text(\u003cbr/\u003e                    text = numberString,\u003cbr/\u003e                    textAlign = TextAlign.Center,\u003cbr/\u003e                    modifier = Modifier\u003cbr/\u003e                        .constrainAs(number) {\u003cbr/\u003e                            start.linkTo(playerTeamNumAndPos.end)\u003cbr/\u003e                            end.linkTo(parent.end)\u003cbr/\u003e                            top.linkTo(firstName.top)\u003cbr/\u003e                            bottom.linkTo(playerTeamNumAndPos.bottom)\u003cbr/\u003e                            width = Dimension.fillToConstraints\u003cbr/\u003e                        }\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"d48b\"\u003eThis blog post provides a comprehensive guide to building Jetpack Compose features from a \u003cstrong\u003e\u003cem\u003eproduct-centric perspective\u003c/em\u003e\u003c/strong\u003e. It covers key steps such as understanding product goals, designing and prototyping, developing with best practices, testing, and iterating for improvement. By following these guidelines, you can create exceptional mobile app experiences using Jetpack Compose.\u003c/p\u003e\u003cp id=\"53fb\"\u003e\u003cstrong\u003eTo download the sample app and this feature, visit the following link on Google Play:\u003c/strong\u003e \u003ca href=\"https://play.google.com/store/apps/details?id=com.brickyard.nhl\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://play.google.com/store/apps/details?id=com.brickyard.nhl\u003c/a\u003e\u003c/p\u003e\u003cp id=\"545e\"\u003eBest,\u003cbr/\u003eRC\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-10-03T08:04:24.983Z",
  "modifiedTime": null
}
