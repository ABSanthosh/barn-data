{
  "id": "0225d317-505b-4b72-9c31-4517eca4d38b",
  "title": "Tools, not Rules: become a better Android developer with Compiler Explorer",
  "link": "http://android-developers.googleblog.com/2024/09/become-better-android-developer-compiler-explorer.html",
  "description": "",
  "author": "Android Developers",
  "published": "2024-09-18T09:00:00.000-07:00",
  "source": "http://feeds.feedburner.com/blogspot/hsDu",
  "categories": [
    "Android",
    "ART",
    "compiler",
    "d8",
    "decompile",
    "dex2oat",
    "disassembly",
    "efficiency",
    "explorer",
    "Performance",
    "R8",
    "runtime"
  ],
  "byline": "",
  "length": 20417,
  "excerpt": "Compiler Explorer allows developers to optimize code and enhance app performance by visualizing code compilation processes to make informed decisions.",
  "siteName": "Android Developers Blog",
  "favicon": "",
  "text": "Posted by Shai Barack ‚Äì Android Platform Performance lead Introducing Android support in Compiler Explorer In a previous blog post you learned how Android engineers continuously improve the Android Runtime (ART) in ways that boost app performance on user devices. These changes to the compiler make system and app code faster or smaller. Developers don‚Äôt need to change their code and rebuild their apps to benefit from new optimizations, and users get a better experience. In this blog post I‚Äôll take you inside the compiler with a tool called Compiler Explorer and witness some of these optimizations in action. Compiler Explorer is an interactive website for studying how compilers work. It is an open source project that anyone can contribute to. This year, our engineers added support to Compiler Explorer for the Java and Kotlin programming languages on Android. You can use Compiler Explorer to understand how your source code is translated to assembly language, and how high-level programming language constructs in a language like Kotlin become low-level instructions that run on the processor. At Google our engineers use this tool to study different coding patterns for efficiency, to see how existing compiler optimizations work, to share new optimization opportunities, and to teach and learn. Learning is best when it‚Äôs done through tools, not rules. Instead of teaching developers to memorize different rules for how to write efficient code or what the compiler might or might not optimize, give the engineers the tools to find out for themselves what happens when they write their code in different ways, and let them experiment and learn. Let‚Äôs learn together! Start by going to godbolt.org. By default we see C++ sample code, so click the dropdown that says C++ and select Android Java. You should see this sample code: class Square { static int square(int num) { return num * num; } } click to enlarge On the left you‚Äôll see a very simple program. You might say that this is a one line program. But this is not a meaningful statement in terms of performance - how many lines of code there are doesn‚Äôt tell us how long this program will take to run, or how much memory will be occupied by the code when the program is loaded. On the right you‚Äôll see a disassembly of the compiler output. This is expressed in terms of assembly language for the target architecture, where every line is a CPU instruction. Looking at the instructions, we can say that the implementation of the square(int num) method consists of 2 instructions in the target architecture. The number and type of instructions give us a better idea for how fast the program is than the number of lines of source code. Since the target architecture is AArch64 aka ARM64, every instruction is 4 bytes, which means that our program‚Äôs code occupies 8 bytes in RAM when the program is compiled and loaded. Let‚Äôs take a brief detour and introduce some Android toolchain concepts. The Android build toolchain (in brief) When you write your Android app, you‚Äôre typically writing source code in the Java or Kotlin programming languages. When you build your app in Android Studio, it‚Äôs initially compiled by a language-specific compiler into language-agnostic JVM bytecode in a .jar. Then the Android build tools transform the .jar into Dalvik bytecode in .dex files, which is what the Android Runtime executes on Android devices. Typically developers use d8 in their Debug builds, and r8 for optimized Release builds. The .dex files go in the .apk that you push to test devices or upload to an app store. Once the .apk is installed on the user‚Äôs device, an on-device compiler which knows the specific target device architecture can convert the bytecode to instructions for the device‚Äôs CPU. We can use Compiler Explorer to learn how all these tools come together, and to experiment with different inputs and see how they affect the outputs. Going back to our default view for Android Java, on the left is Java source code and on the right is the disassembly for the on-device compiler dex2oat, the very last step in our toolchain diagram. The target architecture is ARM64 as this is the most common CPU architecture in use today by Android devices. The ARM64 Instruction Set Architecture offers many instructions and extensions, but as you read disassemblies you will find that you only need to memorize a few key instructions. You can look for ARM64 Quick Reference cards online to help you read disassemblies. At Google we study the output of dex2oat in Compiler Explorer for different reasons, such as: Gaining intuition for what optimizations the compiler performs in order to think about how to write more efficient code. Estimating how much memory will be required when a program with this snippet of code is loaded into memory. Identifying optimization opportunities in the compiler - ways to generate instructions for the same code that are more efficient, resulting in faster execution or in lower memory usage without requiring app developers to change and rebuild their code. Troubleshooting compiler bugs! üêû Compiler optimizations demystified Let‚Äôs look at a real example of compiler optimizations in practice. In the previous blog post you can read about compiler optimizations that the ART team recently added, such as coalescing returns. Now you can see the optimization, with Compiler Explorer! Let‚Äôs load this example: class CoalescingReturnsDemo { String intToString(int num) { switch (num) { case 1: return \"1\"; case 2: return \"2\"; case 3: return \"3\"; default: return \"other\"; } } } click to enlarge How would a compiler implement this code in CPU instructions? Every case would be a branch target, with a case body that has some unique instructions (such as referencing the specific string) and some common instructions (such as assigning the string reference to a register and returning to the caller). Coalescing returns means that some instructions at the tail of each case body can be shared across all cases. The benefits grow for larger switches, proportional to the number of the cases. You can see the optimization in action! Simply create two compiler windows, one for dex2oat from the October 2022 release (the last release before the optimization was added), and another for dex2oat from the November 2023 release (the first release after the optimization was added). You should see that before the optimization, the size of the method body for intToString was 124 bytes. After the optimization, it‚Äôs down to just 76 bytes. This is of course a contrived example for simplicity‚Äôs sake. But this pattern is very common in Android code. For instance consider an implementation of Handler.handleMessage(Message), where you might implement a switch statement over the value of Message#what. How does the compiler implement optimizations such as this? Compiler Explorer lets us look inside the compiler‚Äôs pipeline of optimization passes. In a compiler window, click Add New \u003e Opt Pipeline. A new window will open, showing the High-level Internal Representation (HIR) that the compiler uses for the program, and how it‚Äôs transformed at every step. click to enlarge If you look at the code_sinking pass you will see that the November 2023 compiler replaces Return HIR instructions with Goto instructions. Most of the passes are hidden when Filters \u003e Hide Inconsequential Passes is checked. You can uncheck this option and see all optimization passes, including ones that did not change the HIR (i.e. have no ‚Äúdiff‚Äù over the HIR). Let‚Äôs study another simple optimization, and look inside the optimization pipeline to see it in action. Consider this code: class ConstantFoldingDemo { static int demo(int num) { int result = num; if (num == 2) { result = num + 2; } return result; } } The above is functionally equivalent to the below: class ConstantFoldingDemo { static int demo(int num) { int result = num; if (num == 2) { result = 4; } return result; } } Can the compiler make this optimization for us? Let‚Äôs load it in Compiler Explorer and turn to the Opt Pipeline Viewer for answers. click to enlarge The disassembly shows us that the compiler never bothers with ‚Äútwo plus two‚Äù, it knows that if num is 2 then result needs to be 4. This optimization is called constant folding. Inside the conditional block where we know that num == 2 we propagate the constant 2 into the symbolic name num, then fold num + 2 into the constant 4. You can see this optimization happening over the compiler‚Äôs IR by selecting the constant_folding pass in the Opt Pipeline Viewer. Kotlin and Java, side by side Now that we‚Äôve seen the instructions for Java code, try changing the language to Android Kotlin. You should see this sample code, the Kotlin equivalent of the basic Java sample we‚Äôve seen before: fun square(num: Int): Int = num * num click to enlarge You will notice that the source code is different but the sample program is functionally identical, and so is the output from dex2oat. Finding the square of a number results in the same instructions, whether you write your source code in Java or in Kotlin. You can take this opportunity to study interesting language features and discover how they work. For instance, let‚Äôs compare Java String concatenation with Kotlin String interpolation. In Java, you might write your code as follows: class StringConcatenationDemo { void stringConcatenationDemo(String myVal) { System.out.println(\"The value of myVal is \" + myVal); } } Let‚Äôs find out how Java String concatenation actually works by trying this example in Compiler Explorer. click to enlarge First you will notice that we changed the output compiler from dex2oat to d8. Reading Dalvik bytecode, which is the output from d8, is usually easier than reading the ARM64 instructions that dex2oat outputs. This is because Dalvik bytecode uses higher level concepts. Indeed you can see the names of types and methods from the source code on the left side reflected in the bytecode on the right side. Try changing the compiler to dex2oat and back to see the difference. As you read the d8 output you may realize that Java String concatenation is actually implemented by rewriting your source code to use a StringBuilder. The source code above is rewritten internally by the Java compiler as follows: class StringConcatenationDemo { void stringConcatenationDemo(String myVal) { StringBuilder sb = new StringBuilder(); sb.append(\"The value of myVal is \"); sb.append(myVal); System.out.println(sb.toString()); } } In Kotlin, we can use String interpolation: fun stringInterpolationDemo(myVal: String) { System.out.println(\"The value of myVal is $myVal\"); } The Kotlin syntax is easier to read and write, but does this convenience come at a cost? If you try this example in Compiler Explorer, you may find that the Dalvik bytecode output is roughly the same! In this case we see that Kotlin offers an improved syntax, while the compiler emits similar bytecode. At Google we study examples of language features in Compiler Explorer to learn about how high-level language features are implemented in lower-level terms, and to better inform ourselves on the different tradeoffs that we might make in choosing whether and how to adopt these language features. Recall our learning principle: tools, not rules. Rather than memorizing rules for how you should write your code, use the tools that will help you understand the upsides and downsides of different alternatives, and then make an informed decision. What happens when you minify your app? Speaking of making informed decisions as an app developer, you should be minifying your apps with R8 when building your Release APK. Minifying generally does three things to optimize your app to make it smaller and faster: 1. Dead code elimination: find all the live code (code that is reachable from well-known program entry points), which tells us that the remaining code is not used, and therefore can be removed. 2. Bytecode optimization: various specialized optimizations that rewrite your app‚Äôs bytecode to make it functionally identical but faster and/or smaller. 3. Obfuscation: renaming all types, methods, and fields in your program that are not accessed by reflection (and therefore can be safely renamed) from their names in source code (com.example.MyVeryLongFooFactorySingleton) to shorter names that fit in less memory (a.b.c). Let‚Äôs see an example of all three benefits! Start by loading this view in Compiler Explorer. click to enlarge First you will notice that we are referencing types from the Android SDK. You can do this in Compiler Explorer by clicking Libraries and adding Android API stubs. Second, you will notice that this view has multiple source files open. The Kotlin source code is in example.kt, but there is another file called proguard.cfg. -keep class MinifyDemo { public void goToSite(...); } Looking inside this file, you‚Äôll see directives in the format of Proguard configuration flags, which is the legacy format for configuring what to keep when minifying your app. You can see that we are asking to keep a certain method of MinifyDemo. ‚ÄúKeeping‚Äù in this context means don‚Äôt shrink (we tell the minifier that this code is live). Let‚Äôs say we‚Äôre developing a library and we‚Äôd like to offer our customer a prebuilt .jar where they can call this method, so we‚Äôre keeping this as part of our API contract. We set up a view that will let us see the benefits of minifying. On one side you‚Äôll see d8, showing the dex code without minification, and on the other side r8, showing the dex code with minification. By comparing the two outputs, we can see minification in action: 1. Dead code elimination: R8 removed all the logging code, since it never executes (as DEBUG is always false). We removed not just the calls to android.util.Log, but also the associated strings. 2. Bytecode optimization: since the specialized methods goToGodbolt, goToAndroidDevelopers, and goToGoogleIo just call goToUrl with a hardcoded parameter, R8 inlined the calls to goToUrl into the call sites in goToSite. This inlining saves us the overhead of defining a method, invoking the method, and returning from the method. 3. Obfuscation: we told R8 to keep the public method goToSite, and it did. R8 also decided to keep the method goToUrl as it‚Äôs used by goToSite, but you‚Äôll notice that R8 renamed that method to a. This method‚Äôs name is an internal implementation detail, so obfuscating its name saved us a few precious bytes. You can use R8 in Compiler Explorer to understand how minification affects your app, and to experiment with different ways to configure R8. At Google our engineers use R8 in Compiler Explorer to study how minification works on small samples. The authoritative tool for studying how a real app compiles is the APK Analyzer in Android Studio, as optimization is a whole-program problem and a snippet might not capture every nuance. But iterating on release builds of a real app is slow, so studying sample code in Compiler Explorer helps our engineers quickly learn and iterate. Google engineers build very large apps that are used by billions of people on different devices, so they care deeply about these kinds of optimizations, and strive to make the most use out of optimizing tools. But many of our apps are also very large, and so changing the configuration and rebuilding takes a very long time. Our engineers can now use Compiler Explorer to experiment with minification under different configurations and see results in seconds, not minutes. You may wonder what would happen if we changed our code to rename goToSite? Unfortunately our build would break, unless we also renamed the reference to that method in the Proguard flags. Fortunately, R8 now natively supports Keep Annotations as an alternative to Proguard flags. We can modify our program to use Keep Annotations: @UsedByReflection(kind = KeepItemKind.CLASS_AND_METHODS) public static void goToSite(Context context, String site) { ... } Here is the complete example. You‚Äôll notice that we removed the proguard.cfg file, and under Libraries we added ‚ÄúR8 keep-annotations‚Äù, which is how we‚Äôre importing @UsedByReflection. At Google our engineers prefer annotations over flags. Here we‚Äôve seen one benefit of annotations - keeping the information about the code in one place rather than two makes refactors easier. Another is that the annotations have a self-documenting aspect to them. For instance if this method was kept actually because it‚Äôs called from native code, we would annotate it as @UsedByNative instead. Baseline profiles and you Lastly, let‚Äôs touch on baseline profiles. So far you saw some demos where we looked at dex code, and others where we looked at ARM64 instructions. If you toggle between the different formats you will notice that the high-level dex bytecode is much more compact than low-level CPU instructions. There is an interesting tradeoff to explore here - whether, and when, to compile bytecode to CPU instructions? For any program method, the Android Runtime has three compilation options: 1. Compile the method Just in Time (JIT). 2. Compile the method Ahead of Time (AOT). 3. Don‚Äôt compile the method at all, instead use a bytecode interpreter. Running code in an interpreter is an order of magnitude slower, but doesn‚Äôt incur the cost of loading the representation of the method as CPU instructions which as we‚Äôve seen is more verbose. This is best used for ‚Äúcold‚Äù code - code that runs only once, and is not critical to user interactions. When ART detects that a method is ‚Äúhot‚Äù, it will be JIT-compiled if it‚Äôs not already been AOT compiled. JIT compilation accelerates execution times, but pays the one-time cost of compilation during app runtime. This is where baseline profiles come in. Using baseline profiles, you as the app developer can give ART a hint as to which methods are going to be hot or otherwise worth compiling. ART will use that hint before runtime, compiling the code AOT (usually at install time, or when the device is idle) rather than at runtime. This is why apps that use Baseline Profiles see faster startup times. With Compiler Explorer we can see Baseline Profiles in action. Let‚Äôs open this example. click to enlarge The Java source code has two method definitions, factorial and fibonacci. This example is set up with a manual baseline profile, listed in the file profile.prof.txt. You will notice that the profile only references the factorial method. Consequently, the dex2oat output will only show compiled code for factorial, while fibonacci shows in the output with no instructions and a size of 0 bytes. In the context of compilation modes, this means that factorial is compiled AOT, and fibonacci will be compiled JIT or interpreted. This is because we applied a different compiler filter in the profile sample. This is reflected in the dex2oat output, which reads: ‚ÄúCompiler filter: speed-profile‚Äù (AOT compile only profile code), where previous examples read ‚ÄúCompiler filter: speed‚Äù (AOT compile everything). Conclusion Compiler Explorer is a great tool for understanding what happens after you write your source code but before it can run on a target device. The tool is easy to use, interactive, and shareable. Compiler Explorer is best used with sample code, but it goes through the same procedures as building a real app, so you can see the impact of all steps in the toolchain. By learning how to use tools like this to discover how the compiler works under the hood, rather than memorizing a bunch of rules of optimization best practices, you can make more informed decisions. Now that you've seen how to use the Java and Kotlin programming languages and the Android toolchain in Compiler Explorer, you can level up your Android development skills. Lastly, don't forget that Compiler Explorer is an open source project on GitHub. If there is a feature you'd like to see then it's just a Pull Request away. Java and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.",
  "image": "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6eHy3tppfLFscmsn8p8iHMTYhH__yu1IKO_kr4ce-QNWvtOlfhcY7a8f1NfiuTbHd3ibqfdQ7jhcTY9gHsRHyJp2XibKEGbDOquTUeUg_zJr41AsDZWhUc9WbEXW2Fk2gdH7Yu9dbGHZ9fjTtI2Ffx7E2-p-YrsOn-NjMuma2gOF166Qa8LH8N_VWDZI/w1200-h630-p-k-no-nu/0008-AFD-%20Tools%20Banner%20Asset%20_%20Banner%20Design%20_%20Metadata%20Card_meta%20card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cmeta content=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg6eHy3tppfLFscmsn8p8iHMTYhH__yu1IKO_kr4ce-QNWvtOlfhcY7a8f1NfiuTbHd3ibqfdQ7jhcTY9gHsRHyJp2XibKEGbDOquTUeUg_zJr41AsDZWhUc9WbEXW2Fk2gdH7Yu9dbGHZ9fjTtI2Ffx7E2-p-YrsOn-NjMuma2gOF166Qa8LH8N_VWDZI/s1600/0008-AFD-%20Tools%20Banner%20Asset%20_%20Banner%20Design%20_%20Metadata%20Card_meta%20card.png\" name=\"twitter:image\"/\u003e\n\u003cp\u003e\n\n\u003cem\u003ePosted by Shai Barack ‚Äì Android Platform Performance lead\u003c/em\u003e\n\n\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9roV-Qta9lnME3ailZgsr8eVC_lq-BX8RTPQcfW51Y-vMcbvEBFf44_qgVngBX2LLnzr0Fu2Z3hWJJc1ovgsmdFF905VGCst3uopJmHHDw5esD29UMkhLgYn2yl2yE86Hoq-nR3PUxyWHu30kMTBjjfaGIDJet0wIQrB7NPF-H-kZChULzoZhd6Wavos/s1600/0008-AFD-%20Tools%20Banner%20Asset%20_%20Banner%20Design%20_banner.png\"\u003e\u003cimg data-original-height=\"800\" data-original-width=\"100%\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg9roV-Qta9lnME3ailZgsr8eVC_lq-BX8RTPQcfW51Y-vMcbvEBFf44_qgVngBX2LLnzr0Fu2Z3hWJJc1ovgsmdFF905VGCst3uopJmHHDw5esD29UMkhLgYn2yl2yE86Hoq-nR3PUxyWHu30kMTBjjfaGIDJet0wIQrB7NPF-H-kZChULzoZhd6Wavos/s1600/0008-AFD-%20Tools%20Banner%20Asset%20_%20Banner%20Design%20_banner.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003ch2\u003e\u003cspan\u003eIntroducing Android support in Compiler Explorer\u003c/span\u003e\u003c/h2\u003e \n\n\u003cp\u003eIn a \u003ca href=\"https://android-developers.googleblog.com/2023/11/the-secret-to-androids-improved-memory-latest-android-runtime-update.html\" target=\"_blank\"\u003eprevious blog post\u003c/a\u003e you learned how Android engineers continuously improve the Android Runtime (ART) in ways that boost app performance on user devices. These changes to the compiler make system and app code faster or smaller. Developers don‚Äôt need to change their code and rebuild their apps to benefit from new optimizations, and users get a better experience. In this blog post I‚Äôll take you inside the compiler with a tool called \u003ca href=\"http://godbolt.org\" target=\"_blank\"\u003eCompiler Explorer\u003c/a\u003e and witness some of these optimizations in action.\u003c/p\u003e\n\n\u003cp\u003eCompiler Explorer is an interactive website for studying how compilers work. It is an \u003ca href=\"https://github.com/compiler-explorer/compiler-explorer\" target=\"_blank\"\u003eopen source project\u003c/a\u003e that anyone can contribute to. This year, our engineers added support to Compiler Explorer for the Java and Kotlin programming languages on Android.\u003c/p\u003e\n\n\u003cp\u003eYou can use Compiler Explorer to understand how your source code is translated to assembly language, and how high-level programming language constructs in a language like Kotlin become low-level instructions that run on the processor.\u003c/p\u003e\n\n\u003cp\u003eAt Google our engineers use this tool to study different coding patterns for efficiency, to see how existing compiler optimizations work, to share new optimization opportunities, and to teach and learn.\nLearning is best when it‚Äôs done through \u003cb\u003e\u003ci\u003etools, not rules\u003c/i\u003e\u003c/b\u003e. Instead of teaching developers to memorize different rules for how to write efficient code or what the compiler might or might not optimize, give the engineers the tools to find out for themselves what happens when they write their code in different ways, and let them experiment and learn. Let‚Äôs learn together!\u003c/p\u003e\n\n\u003cp\u003eStart by going to \u003ca href=\"http://godbolt.org\" target=\"_blank\"\u003egodbolt.org\u003c/a\u003e. By default we see C++ sample code, so click the dropdown that says C++ and select Android Java. You should see this \u003ca href=\"https://godbolt.org/z/89f9vWE1q\" target=\"_blank\"\u003esample code\u003c/a\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eSquare\u003c/span\u003e {\n   static \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003esquare\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e num) {\n       \u003cspan\u003ereturn\u003c/span\u003e num * num;\n   }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi3GmyStlRmroF757mY7gsll-sU4fsvaQu9VBhh0AN8lEbyFlyMJN3SCG7sgHLBLZjUo9r3izPs88uCA7suwl5kmiWiuSfTCc_Mu1PSHVUqtRcfPcgHywu72swwxW1d8FnYkJg61hl-V4aMDf1JlfL4KhUgj_hg3GEA3JXfAuqHoNjc6t2bEnkXhk8wPFo/s1600/godbolt.org_z_jGvGEPsMb%20%281%29.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi3GmyStlRmroF757mY7gsll-sU4fsvaQu9VBhh0AN8lEbyFlyMJN3SCG7sgHLBLZjUo9r3izPs88uCA7suwl5kmiWiuSfTCc_Mu1PSHVUqtRcfPcgHywu72swwxW1d8FnYkJg61hl-V4aMDf1JlfL4KhUgj_hg3GEA3JXfAuqHoNjc6t2bEnkXhk8wPFo/w640-h174/godbolt.org_z_jGvGEPsMb%20(1).png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eOn the left you‚Äôll see a very simple program. You might say that this is a one line program. But this is not a meaningful statement in terms of performance - how many lines of code there are doesn‚Äôt tell us how long this program will take to run, or how much memory will be occupied by the code when the program is loaded.\u003c/p\u003e\n\n\u003cp\u003eOn the right you‚Äôll see a disassembly of the compiler output. This is expressed in terms of assembly language for the target architecture, where every line is a CPU instruction. Looking at the instructions, we can say that the implementation of the \u003cspan\u003esquare(int num)\u003c/span\u003e method consists of 2 instructions in the target architecture. The number and type of instructions give us a better idea for how fast the program is than the number of lines of source code. Since the target architecture is AArch64 aka ARM64, every instruction is 4 bytes, which means that our program‚Äôs code occupies 8 bytes in RAM when the program is compiled and loaded.\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs take a brief detour and introduce some Android toolchain concepts.\u003c/p\u003e\u003cbr/\u003e\n\n\u003ch3\u003eThe Android build toolchain (in brief)\u003c/h3\u003e\n\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQZjdZFK_hfeeuFZeUedM-9aqMBG-WFDlget780ho9FvJ96N5MOKCsAjGCYPZ7NWkIx7KdpZ3yqghwGtpNX96DGbLaMyDrkng9UE0hFyxxEsrd4VDRFcGm15TvaGyiuAF0B8FotPxvpKR0Ulyu-9xiZTvH9g2zSxYR1I8hztFA21Fj9-mJbUDgFg8INEM/s1600/Diagram%20for%20Compiler%20Explorer%20blog%20post%20showing%20toolchain.png\" target=\"_blank\"\u003e\u003cimg alt=\"a flow diagram of the Android build toolchain\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgQZjdZFK_hfeeuFZeUedM-9aqMBG-WFDlget780ho9FvJ96N5MOKCsAjGCYPZ7NWkIx7KdpZ3yqghwGtpNX96DGbLaMyDrkng9UE0hFyxxEsrd4VDRFcGm15TvaGyiuAF0B8FotPxvpKR0Ulyu-9xiZTvH9g2zSxYR1I8hztFA21Fj9-mJbUDgFg8INEM/s1600/Diagram%20for%20Compiler%20Explorer%20blog%20post%20showing%20toolchain.png\" width=\"100%\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eWhen you write your Android app, you‚Äôre typically writing source code in the Java or Kotlin programming languages. When you build your app in Android Studio, it‚Äôs initially compiled by a language-specific compiler into language-agnostic JVM bytecode in a \u003cspan\u003e.jar\u003c/span\u003e. Then the Android build tools transform the \u003cspan\u003e.jar\u003c/span\u003e into \u003ca href=\"https://source.android.com/docs/core/runtime/dalvik-bytecode\" target=\"_blank\"\u003eDalvik bytecode\u003c/a\u003e in \u003cspan\u003e.dex\u003c/span\u003e files, which is what the \u003ca href=\"https://source.android.com/docs/core/runtime\" target=\"_blank\"\u003eAndroid Runtime\u003c/a\u003e executes on Android devices. Typically developers use \u003cspan\u003ed8\u003c/span\u003e in their Debug builds, and \u003cspan\u003er8\u003c/span\u003e for \u003ca href=\"https://developer.android.com/build/shrink-code\" target=\"_blank\"\u003eoptimized \u003ci\u003eRelease builds\u003c/i\u003e\u003c/a\u003e. The \u003cspan\u003e.dex\u003c/span\u003e files go in the \u003cspan\u003e.apk\u003c/span\u003e that you push to test devices or upload to an app store. Once the \u003cspan\u003e.apk\u003c/span\u003e is installed on the user‚Äôs device, an on-device compiler which knows the specific target device architecture can convert the bytecode to instructions for the device‚Äôs CPU.\u003c/p\u003e\n  \n\u003cp\u003eWe can use Compiler Explorer to learn how all these tools come together, and to experiment with different inputs and see how they affect the outputs.\u003c/p\u003e\n\n\u003cp\u003eGoing back to our default view for Android Java, on the left is Java source code and on the right is the disassembly for the on-device compiler \u003cspan\u003edex2oat\u003c/span\u003e, the very last step in our toolchain diagram. The target architecture is ARM64 as this is the most common CPU architecture in use today by Android devices.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://developer.arm.com/documentation/102374/latest/\" target=\"_blank\"\u003eARM64 Instruction Set Architecture\u003c/a\u003e offers many instructions and extensions, but as you read disassemblies you will find that you only need to memorize a few key instructions. You can look for ARM64 Quick Reference cards online to help you read disassemblies.\u003c/p\u003e\n\n\u003cp\u003eAt Google we study the output of \u003cspan\u003edex2oat\u003c/span\u003e in Compiler Explorer for different reasons, such as:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cli\u003eGaining intuition for what optimizations the compiler performs in order to think about how to write more efficient code.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eEstimating how much memory will be required when a program with this snippet of code is loaded into memory.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eIdentifying optimization opportunities in the compiler - ways to generate instructions for the same code that are more efficient, resulting in faster execution or in lower memory usage without requiring app developers to change and rebuild their code.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cli\u003eTroubleshooting compiler bugs! üêû\u003c/li\u003e\n\u003c/ul\u003e\u003c/ul\u003e\u003cbr/\u003e\n\n\u003ch3\u003eCompiler optimizations demystified\u003c/h3\u003e\n\n\u003cp\u003eLet‚Äôs look at a real example of compiler optimizations in practice. In the \u003ca href=\"https://android-developers.googleblog.com/2023/11/the-secret-to-androids-improved-memory-latest-android-runtime-update.html\" target=\"_blank\"\u003eprevious blog post\u003c/a\u003e you can read about compiler optimizations that the ART team recently added, such as \u003ci\u003ecoalescing returns\u003c/i\u003e. Now you can see the optimization, with Compiler Explorer!\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs load \u003ca href=\"https://godbolt.org/z/695carsYh\" target=\"_blank\"\u003ethis example\u003c/a\u003e:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCoalescingReturnsDemo\u003c/span\u003e {\n   String \u003cspan\u003eintToString\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e num) {\n       switch (num) {\n           case \u003cspan\u003e1\u003c/span\u003e:\n               \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;1\u0026#34;\u003c/span\u003e;\n           case \u003cspan\u003e2\u003c/span\u003e:\n               \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;2\u0026#34;\u003c/span\u003e;\n           case \u003cspan\u003e3\u003c/span\u003e:\n               \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;3\u0026#34;\u003c/span\u003e;           \n           \u003cspan\u003edefault\u003c/span\u003e:\n               \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;other\u0026#34;\u003c/span\u003e;\n       }\n   }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhFT1jPAw-ufoFyz5DRSp2jAeUJos6gsC1GJI_-tVmFjY5Ct8hvYD3o9FnUC7ODyeTTkzb7b7N1HSiHgYiLoc8pBaI4D6bIfqZBsa7bV_LKbuFmj21Oi4-Ci-za4szrhTcl5p8reVcW52ZVMdi_n02bL8VtMIhrfYloWSiJ0vjGvw9b5JsNTfh1pk2Y4G0/s2256/godbolt.org_z_zjvYvTsT3.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhFT1jPAw-ufoFyz5DRSp2jAeUJos6gsC1GJI_-tVmFjY5Ct8hvYD3o9FnUC7ODyeTTkzb7b7N1HSiHgYiLoc8pBaI4D6bIfqZBsa7bV_LKbuFmj21Oi4-Ci-za4szrhTcl5p8reVcW52ZVMdi_n02bL8VtMIhrfYloWSiJ0vjGvw9b5JsNTfh1pk2Y4G0/s2256/godbolt.org_z_zjvYvTsT3.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eHow would a compiler implement this code in CPU instructions? Every case would be a branch target, with a case body that has some unique instructions (such as referencing the specific string) and some common instructions (such as assigning the string reference to a register and returning to the caller). \u003ci\u003eCoalescing returns\u003c/i\u003e means that some instructions at the tail of each case body can be shared across all cases. The benefits grow for larger switches, proportional to the number of the cases.\u003c/p\u003e\n\n\u003cp\u003eYou can see the optimization in action! Simply create two compiler windows, one for \u003cspan\u003edex2oat\u003c/span\u003e from the October 2022 release (the last release before the optimization was added), and another for \u003cspan\u003edex2oat\u003c/span\u003e from the November 2023 release (the first release after the optimization was added). You should see that before the optimization, the size of the method body for \u003cspan\u003eintToString\u003c/span\u003e was 124 bytes. After the optimization, it‚Äôs down to just 76 bytes.\u003c/p\u003e\n\n\u003cp\u003eThis is of course a contrived example for simplicity‚Äôs sake. But this pattern is very common in Android code. For instance consider an implementation of \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/android/os/Handler#handleMessage%28android.os.Message%29\" target=\"_blank\"\u003eHandler.handleMessage(Message)\u003c/a\u003e\u003c/span\u003e, where you might implement a switch statement over the value of \u003cspan\u003e\u003ca href=\"https://developer.android.com/reference/android/os/Message#what\" target=\"_blank\"\u003eMessage#what\u003c/a\u003e\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003eHow does the compiler implement optimizations such as this? Compiler Explorer lets us look inside the compiler‚Äôs pipeline of optimization passes. In a compiler window, click \u003ci\u003eAdd New \u0026gt; Opt Pipeline\u003c/i\u003e. A new window will open, showing the High-level Internal Representation (HIR) that the compiler uses for the program, and how it‚Äôs transformed at every step.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjBupj21MdD-TzUlhfrb7502StciqEwWWcqY2cF1MqJ5D1SGlJeNpP7ZiBdNb_J8fM5oqNiFo2RBnOnCv4qM7gj2JjZx9_q0Rk9iI97TPVAd3Y50UJqstFoUJ71h3Ai1xg7HOWxYF4mai08zMG9FU2m7RXxZHpEQWK7hm-cTESp8p2hGb6V8z2jll9cqZk/s1600/godbolt.org_z_bf96jsj9f.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of the high-level internal representation (HIR) the compiler uses for the program in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjBupj21MdD-TzUlhfrb7502StciqEwWWcqY2cF1MqJ5D1SGlJeNpP7ZiBdNb_J8fM5oqNiFo2RBnOnCv4qM7gj2JjZx9_q0Rk9iI97TPVAd3Y50UJqstFoUJ71h3Ai1xg7HOWxYF4mai08zMG9FU2m7RXxZHpEQWK7hm-cTESp8p2hGb6V8z2jll9cqZk/s1600/godbolt.org_z_bf96jsj9f.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eIf you look at the \u003cspan\u003ecode_sinking\u003c/span\u003e pass you will see that the November 2023 compiler replaces \u003cspan\u003eReturn\u003c/span\u003e HIR instructions with \u003cspan\u003eGoto\u003c/span\u003e instructions.\u003c/p\u003e\n\n\u003cp\u003eMost of the passes are hidden when \u003ci\u003eFilters \u0026gt; Hide Inconsequential Passes\u003c/i\u003e is checked. You can uncheck this option and see all optimization passes, including ones that did not change the HIR (i.e. have no ‚Äúdiff‚Äù over the HIR).\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs study another simple optimization, and look inside the optimization pipeline to see it in action. Consider this code:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eConstantFoldingDemo\u003c/span\u003e {\n   static \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003edemo\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e num) {\n       \u003cspan\u003eint\u003c/span\u003e result = num;\n       \u003cspan\u003eif\u003c/span\u003e (num == \u003cspan\u003e2\u003c/span\u003e) {\n           result = num + \u003cspan\u003e2\u003c/span\u003e;\n       }\n       \u003cspan\u003ereturn\u003c/span\u003e result;\n   }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe above is functionally equivalent to the below:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eConstantFoldingDemo\u003c/span\u003e {\n   static \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003edemo\u003c/span\u003e(\u003cspan\u003eint\u003c/span\u003e num) {\n       \u003cspan\u003eint\u003c/span\u003e result = num;\n       \u003cspan\u003eif\u003c/span\u003e (num == \u003cspan\u003e2\u003c/span\u003e) {\n           result = \u003cspan\u003e4\u003c/span\u003e;\n       }\n       \u003cspan\u003ereturn\u003c/span\u003e result;\n   }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eCan the compiler make this optimization for us? Let‚Äôs \u003ca href=\"https://godbolt.org/z/zjx1r4Pvh\" target=\"_blank\"\u003eload it in Compiler Explorer\u003c/a\u003e and turn to the Opt Pipeline Viewer for answers.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhl-IBHURMBmsLyRTi8bqG2UHpl9SSzgEjLpE5l42Dzdfc1ejl77_k1jxVuXKO2dnuYZX9YhbNCONwsUWN13AqexHMb1MukXzSVSXc0Jda41ZOo9x5byc1rRklf4Qj7p3AcxXZFgqcX9u0Nc09mpQzITxv06ZDLda9eQkoLKxta_1duiRfg-S1mu1NZgkk/s1600/godbolt.org_z_zjx1r4Pvh.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of Opt Pipeline Viewer in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhl-IBHURMBmsLyRTi8bqG2UHpl9SSzgEjLpE5l42Dzdfc1ejl77_k1jxVuXKO2dnuYZX9YhbNCONwsUWN13AqexHMb1MukXzSVSXc0Jda41ZOo9x5byc1rRklf4Qj7p3AcxXZFgqcX9u0Nc09mpQzITxv06ZDLda9eQkoLKxta_1duiRfg-S1mu1NZgkk/s1600/godbolt.org_z_zjx1r4Pvh.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eThe disassembly shows us that the compiler never bothers with ‚Äútwo plus two‚Äù, it knows that if \u003cspan\u003enum\u003c/span\u003e is 2 then \u003cspan\u003eresult\u003c/span\u003e needs to be 4. This optimization is called \u003ca href=\"https://en.wikipedia.org/wiki/Constant_folding\" target=\"_blank\"\u003econstant folding\u003c/a\u003e. Inside the conditional block where we know that \u003cspan\u003enum == 2\u003c/span\u003e we \u003ci\u003epropagate\u003c/i\u003e the constant \u003cspan\u003e2\u003c/span\u003e into the symbolic name \u003cspan\u003enum\u003c/span\u003e, then \u003ci\u003efold\u003c/i\u003e \u003cspan\u003enum + 2\u003c/span\u003e into the constant \u003cspan\u003e4\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou can see this optimization happening over the compiler‚Äôs IR by selecting the \u003cspan\u003econstant_folding\u003c/span\u003e pass in the Opt Pipeline Viewer.\u003c/p\u003e\n\n\u003ch3\u003eKotlin and Java, side by side\u003c/h3\u003e\n\n\u003cp\u003eNow that we‚Äôve seen the instructions for Java code, try changing the language to Android Kotlin. You should see this sample code, the Kotlin equivalent of the basic Java sample we‚Äôve seen before:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003esquare\u003c/span\u003e(num: Int): Int = num * num\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiZwhhCzxk-8E8Ht7cqNEM8Tt1AZnhwIEXJU8guUuIZi3hipe_8XYUebA28vEFdjRl-JAdr3CkIi-lC5U2DgwLjyn6EzBXAwn051NKUXk3H8DqTjNgCmKKwNcRevmIc2jtflWERGYxgxHJ3UsksU_NEMmHhhYulzOF9bZo6MxqLb98hurOAbvLBwfse0FI/s1600/godbolt.org_z_GqfEYhEjK.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Kotlin in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiZwhhCzxk-8E8Ht7cqNEM8Tt1AZnhwIEXJU8guUuIZi3hipe_8XYUebA28vEFdjRl-JAdr3CkIi-lC5U2DgwLjyn6EzBXAwn051NKUXk3H8DqTjNgCmKKwNcRevmIc2jtflWERGYxgxHJ3UsksU_NEMmHhhYulzOF9bZo6MxqLb98hurOAbvLBwfse0FI/s1600/godbolt.org_z_GqfEYhEjK.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eYou will notice that the source code is different but the sample program is functionally identical, and so is the output from \u003cspan\u003edex2oat\u003c/span\u003e. Finding the square of a number results in the same instructions, whether you write your source code in Java or in Kotlin.\u003c/p\u003e\n\n\u003cp\u003eYou can take this opportunity to study interesting language features and discover how they work. For instance, let‚Äôs compare Java String concatenation with Kotlin String interpolation.\u003c/p\u003e\n\n\u003cp\u003eIn Java, you might write your code as follows:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStringConcatenationDemo\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003estringConcatenationDemo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eString myVal\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n       System\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;The value of myVal is \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e myVal\u003cspan\u003e);\u003c/span\u003e\n   \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eLet‚Äôs find out how Java String concatenation actually works by \u003ca href=\"https://godbolt.org/z/7vqcea8fd\" target=\"_blank\"\u003etrying this example in Compiler Explorer\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiAWpK-SGyrc2k3n-vJdoESPcFyCv8_S8_wBQX9NZDFsJNHEYtcvJjFjbtBcmCNWoOeLnA7gC74EmVfTFU8zrvPO2uofmSW2r5EgKjHsFEBus4tSdwBS8JX6bOfhm1t0jY2CNG5t1rz4ikkOLdadkrkXY89FSttx-dKLqzxGURf4UWId5v5feGbKaMBcN8/s1600/godbolt.org_z_7vqcea8fd.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Kotlin in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiAWpK-SGyrc2k3n-vJdoESPcFyCv8_S8_wBQX9NZDFsJNHEYtcvJjFjbtBcmCNWoOeLnA7gC74EmVfTFU8zrvPO2uofmSW2r5EgKjHsFEBus4tSdwBS8JX6bOfhm1t0jY2CNG5t1rz4ikkOLdadkrkXY89FSttx-dKLqzxGURf4UWId5v5feGbKaMBcN8/s1600/godbolt.org_z_7vqcea8fd.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eFirst you will notice that we changed the output compiler from \u003cspan\u003edex2oat\u003c/span\u003e to \u003cspan\u003ed8\u003c/span\u003e. Reading Dalvik bytecode, which is the output from \u003cspan\u003ed8\u003c/span\u003e, is usually easier than reading the ARM64 instructions that \u003cspan\u003edex2oat\u003c/span\u003e outputs. This is because Dalvik bytecode uses higher level concepts. Indeed you can see the names of types and methods from the source code on the left side reflected in the bytecode on the right side. Try changing the compiler to \u003cspan\u003edex2oat\u003c/span\u003e and back to see the difference.\u003c/p\u003e\n\n\u003cp\u003eAs you read the \u003cspan\u003ed8\u003c/span\u003e output you may realize that Java String concatenation is actually implemented by rewriting your source code to use a \u003cspan\u003eStringBuilder\u003c/span\u003e. The source code above is rewritten internally by the Java compiler as follows:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStringConcatenationDemo\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003estringConcatenationDemo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eString myVal\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n       StringBuilder sb \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e StringBuilder\u003cspan\u003e();\u003c/span\u003e\n       sb\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;The value of myVal is \u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n       sb\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emyVal\u003cspan\u003e);\u003c/span\u003e\n       System\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003esb\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoString\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIn Kotlin, we can use String interpolation:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003efun \u003cspan\u003estringInterpolationDemo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emyVal:\u003c/span\u003e String\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   System\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprintln\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;The value of myVal is $myVal\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe Kotlin syntax is easier to read and write, but does this convenience come at a cost? If you try this example in Compiler Explorer, you may find that the Dalvik bytecode output is roughly the same! In this case we see that Kotlin offers an improved syntax, while the compiler emits similar bytecode.\n\n\u003c/p\u003e\u003cp\u003eAt Google we study examples of language features in Compiler Explorer to learn about how high-level language features are implemented in lower-level terms, and to better inform ourselves on the different tradeoffs that we might make in choosing whether and how to adopt these language features. Recall our learning principle: tools, not rules. Rather than memorizing rules for how you should write your code, use the tools that will help you understand the upsides and downsides of different alternatives, and then make an informed decision.\n\n\u003c/p\u003e\u003ch3\u003eWhat happens when you minify your app?\u003c/h3\u003e\n\n\u003cp\u003eSpeaking of making informed decisions as an app developer, you should be minifying your apps with R8 when building your Release APK. Minifying generally does three things to optimize your app to make it smaller and faster:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cp\u003e1. \u003cb\u003eDead code elimination:\u003c/b\u003e find all the live code (code that is reachable from well-known program entry points), which tells us that the remaining code is not used, and therefore can be removed.\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e2. \u003cb\u003eBytecode optimization:\u003c/b\u003e various specialized optimizations that rewrite your app‚Äôs bytecode to make it functionally identical but faster and/or smaller.\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e3. \u003cb\u003eObfuscation:\u003c/b\u003e renaming all types, methods, and fields in your program that are not accessed by reflection (and therefore can be safely renamed) from their names in source code (\u003cspan\u003ecom.example.MyVeryLongFooFactorySingleton\u003c/span\u003e) to shorter names that fit in less memory (\u003cspan\u003ea.b.c\u003c/span\u003e).\u003c/p\u003e\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eLet‚Äôs see an example of all three benefits! Start by \u003ca href=\"https://godbolt.org/z/hP4n7dq8n\" target=\"_blank\"\u003eloading this view in Compiler Explorer\u003c/a\u003e.\n\n\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg-lVfEDqLGMJ9vhPcqTA7Aj-YcizLtEYGJtBsPerSfWQIoy1nWDnGg4o0KhdkZpNCp_6-eDpLH9LW4YIjetHseA2NJhwmcaj0BS7DlRyqJbrerCn8Oc01JG8LocV4JKsGtHC5lPTvbBj8qHeWpmz6tYIvJkdTKf_jLA06tjF2xGyZZWw43JgFWMmCxId0/s1600/godbolt.org_z_hP4n7dq8n.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Kotlin in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg-lVfEDqLGMJ9vhPcqTA7Aj-YcizLtEYGJtBsPerSfWQIoy1nWDnGg4o0KhdkZpNCp_6-eDpLH9LW4YIjetHseA2NJhwmcaj0BS7DlRyqJbrerCn8Oc01JG8LocV4JKsGtHC5lPTvbBj8qHeWpmz6tYIvJkdTKf_jLA06tjF2xGyZZWw43JgFWMmCxId0/s1600/godbolt.org_z_hP4n7dq8n.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n  \n\u003cp\u003eFirst you will notice that we are referencing types from the Android SDK. You can do this in Compiler Explorer by clicking Libraries and adding \u003ci\u003eAndroid API stubs\u003c/i\u003e.\u003c/p\u003e\n  \n\u003cp\u003eSecond, you will notice that this view has multiple source files open. The Kotlin source code is in \u003cspan\u003eexample.kt\u003c/span\u003e, but there is another file called \u003cspan\u003eproguard.cfg\u003c/span\u003e.\u003c/p\u003e\n  \n\u003cdiv\u003e\u003cpre\u003e-keep \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMinifyDemo\u003c/span\u003e {\n   \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003egoToSite\u003c/span\u003e(...);\n}\n\u003c/pre\u003e\u003c/div\u003e\n  \n\u003cp\u003eLooking inside this file, you‚Äôll see directives in the format of Proguard configuration flags, which is the legacy format for configuring what to keep when minifying your app. You can see that we are asking to keep a certain method of \u003cspan\u003eMinifyDemo\u003c/span\u003e. ‚ÄúKeeping‚Äù in this context means don‚Äôt shrink (we tell the minifier that this code is live). Let‚Äôs say we‚Äôre developing a library and we‚Äôd like to offer our customer a prebuilt \u003cspan\u003e.jar\u003c/span\u003e where they can call this method, so we‚Äôre keeping this as part of our API contract.\u003c/p\u003e\n\n\u003cp\u003eWe set up a view that will let us see the benefits of minifying. On one side you‚Äôll see \u003cspan\u003ed8\u003c/span\u003e, showing the dex code without minification, and on the other side \u003cspan\u003er8\u003c/span\u003e, showing the dex code with minification. By comparing the two outputs, we can see minification in action:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cp\u003e1. \u003cb\u003eDead code elimination:\u003c/b\u003e R8 removed all the logging code, since it never executes (as \u003cspan\u003eDEBUG\u003c/span\u003e is always false). We removed not just the calls to \u003cspan\u003eandroid.util.Log\u003c/span\u003e, but also the associated strings.\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e2. \u003cb\u003eBytecode optimization:\u003c/b\u003e since the specialized methods \u003cspan\u003egoToGodbolt\u003c/span\u003e, \u003cspan\u003egoToAndroidDevelopers\u003c/span\u003e, and \u003cspan\u003egoToGoogleIo\u003c/span\u003e just call \u003cspan\u003egoToUrl\u003c/span\u003e with a hardcoded parameter, R8 inlined the calls to \u003cspan\u003egoToUrl\u003c/span\u003e into the call sites in \u003cspan\u003egoToSite\u003c/span\u003e. This inlining saves us the overhead of defining a method, invoking the method, and returning from the method.\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e3. \u003cb\u003eObfuscation:\u003c/b\u003e we told R8 to keep the public method \u003cspan\u003egoToSite\u003c/span\u003e, and it did. R8 also decided to keep the method \u003cspan\u003egoToUrl\u003c/span\u003e as it‚Äôs used by \u003cspan\u003egoToSite\u003c/span\u003e, but you‚Äôll notice that R8 renamed that method to \u003cspan\u003ea\u003c/span\u003e. This method‚Äôs name is an internal implementation detail, so obfuscating its name saved us a few precious bytes.\u003c/p\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eYou can use R8 in Compiler Explorer to understand how minification affects your app, and to experiment with different ways to configure R8.\u003c/p\u003e\n\n\u003cp\u003eAt Google our engineers use R8 in Compiler Explorer to study how minification works on small samples. The authoritative tool for studying how a real app compiles is the \u003ca href=\"https://developer.android.com/studio/debug/apk-analyzer#view_dex_files\" target=\"_blank\"\u003eAPK Analyzer in Android Studio\u003c/a\u003e, as optimization is a whole-program problem and a snippet might not capture every nuance. But iterating on release builds of a real app is slow, so studying sample code in Compiler Explorer helps our engineers quickly learn and iterate.\u003c/p\u003e\n\n\u003cp\u003eGoogle engineers build very large apps that are used by billions of people on different devices, so they care deeply about these kinds of optimizations, and strive to make the most use out of optimizing tools. But many of our apps are also very large, and so changing the configuration and rebuilding takes a very long time. Our engineers can now use Compiler Explorer to experiment with minification under different configurations and see results in seconds, not minutes.\u003c/p\u003e\n\n\u003cp\u003eYou may wonder what would happen if we changed our code to rename \u003cspan\u003egoToSite\u003c/span\u003e? Unfortunately our build would break, unless we also renamed the reference to that method in the Proguard flags. Fortunately, R8 now natively supports \u003ca href=\"https://r8.googlesource.com/r8/+/refs/heads/main/doc/keepanno-guide.md\" target=\"_blank\"\u003eKeep Annotations\u003c/a\u003e as an alternative to Proguard flags. We can modify our program to use Keep Annotations:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e@UsedByReflection(kind = KeepItemKind.CLASS_AND_METHODS)\n\u003cspan\u003epublic\u003c/span\u003e static \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003egoToSite\u003c/span\u003e(Context context, String site) {\n    ...\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eHere is the \u003ca href=\"https://godbolt.org/z/MPeqx7M4M\" target=\"_blank\"\u003ecomplete example\u003c/a\u003e. You‚Äôll notice that we removed the \u003cspan\u003eproguard.cfg\u003c/span\u003e file, and under \u003ci\u003eLibraries\u003c/i\u003e we added ‚ÄúR8 keep-annotations‚Äù, which is how we‚Äôre importing \u003cspan\u003e\u003ca href=\"https://storage.googleapis.com/r8-releases/raw/main/docs/keepanno/javadoc/com/android/tools/r8/keepanno/annotations/UsedByReflection.html\" target=\"_blank\"\u003e@UsedByReflection\u003c/a\u003e\u003c/span\u003e.\u003c/p\u003e\n\n\u003cp\u003eAt Google our engineers prefer annotations over flags. Here we‚Äôve seen one benefit of annotations - keeping the information about the code in one place rather than two makes refactors easier. Another is that the annotations have a self-documenting aspect to them. For instance if this method was kept actually because it‚Äôs called from native code, we would annotate it as \u003cspan\u003e@UsedByNative\u003c/span\u003e instead.\u003c/p\u003e\n\n\u003ch3\u003eBaseline profiles and you\u003c/h3\u003e\n\n\u003cp\u003eLastly, let‚Äôs touch on \u003ca href=\"https://developer.android.com/topic/performance/baselineprofiles/overview\" target=\"_blank\"\u003ebaseline profiles\u003c/a\u003e. So far you saw some demos where we looked at dex code, and others where we looked at ARM64 instructions. If you toggle between the different formats you will notice that the high-level dex bytecode is much more compact than low-level CPU instructions. There is an interesting tradeoff to explore here - whether, and when, to compile bytecode to CPU instructions?\u003c/p\u003e\n\n\u003cp\u003eFor any program method, the Android Runtime has three \u003ca href=\"https://source.android.com/docs/core/runtime/configure#how_art_works\" target=\"_blank\"\u003ecompilation options\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\u003cul\u003e\n\u003cp\u003e1. Compile the method Just in Time (\u003ca href=\"https://source.android.com/docs/core/runtime/jit-compiler\" target=\"_blank\"\u003eJIT\u003c/a\u003e).\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e2. Compile the method Ahead of Time (\u003ca href=\"https://source.android.com/docs/core/runtime#AOT_compilation\" target=\"_blank\"\u003eAOT\u003c/a\u003e).\u003c/p\u003e\u003c/ul\u003e\u003cul\u003e\n\u003cp\u003e3. Don‚Äôt compile the method at all, instead use a bytecode interpreter.\u003c/p\u003e\n\u003c/ul\u003e\u003c/ul\u003e\n\n\u003cp\u003eRunning code in an interpreter is an order of magnitude slower, but doesn‚Äôt incur the cost of loading the representation of the method as CPU instructions which as we‚Äôve seen is more verbose. This is best used for ‚Äúcold‚Äù code - code that runs only once, and is not critical to user interactions.\u003c/p\u003e\n\n\u003cp\u003eWhen ART detects that a method is ‚Äúhot‚Äù, it will be JIT-compiled if it‚Äôs not already been AOT compiled. JIT compilation accelerates execution times, but pays the one-time cost of compilation during app runtime. This is where baseline profiles come in. Using baseline profiles, you as the app developer can give ART a hint as to which methods are going to be hot or otherwise worth compiling. ART will use that hint before runtime, compiling the code AOT (usually at install time, or when the device is idle) rather than at runtime. This is why \u003ca href=\"https://android-developers.googleblog.com/2022/01/improving-app-performance-with-baseline.html\" target=\"_blank\"\u003eapps that use Baseline Profiles see faster startup times\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eWith Compiler Explorer we can see Baseline Profiles in action.\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs open \u003ca href=\"https://godbolt.org/z/MGKfxh9hE\" target=\"_blank\"\u003ethis example\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjOn0hsv0Am0aTPdSKLvaDNkpoTC1dj0hSwY7D-Ld7RST_KyW7rjTScxqRwHsCq6oj-ARQHunsPLawKOS3hXdhCKVh7aSxBTfPLXg-ch49NurJCp7x9-SErozEWOlnvwaLBskR4yDO_jC_c8bctNrqveDLGaGYSRvpq6bPLTPmnoGL3zKY4i3Rb2oK4rZ0/s1600/godbolt.org_z_hP4n7dq8n.png\" target=\"_blank\"\u003e\u003cimg alt=\"screenshot of sample code in Compiler Explorer\" height=\"174\" id=\"imgCaption\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjOn0hsv0Am0aTPdSKLvaDNkpoTC1dj0hSwY7D-Ld7RST_KyW7rjTScxqRwHsCq6oj-ARQHunsPLawKOS3hXdhCKVh7aSxBTfPLXg-ch49NurJCp7x9-SErozEWOlnvwaLBskR4yDO_jC_c8bctNrqveDLGaGYSRvpq6bPLTPmnoGL3zKY4i3Rb2oK4rZ0/s1600/godbolt.org_z_hP4n7dq8n.png\" width=\"640\"/\u003e\u003c/a\u003e\u003c/p\u003e\u003cimgcaption\u003e\u003ccenter\u003e\u003cem\u003eclick to enlarge\u003c/em\u003e\u003c/center\u003e\u003c/imgcaption\u003e\n\n\u003cp\u003eThe Java source code has two method definitions, \u003cspan\u003efactorial\u003c/span\u003e and \u003cspan\u003efibonacci\u003c/span\u003e. This example is set up with a \u003ca href=\"https://developer.android.com/topic/performance/baselineprofiles/manually-create-measure\" target=\"_blank\"\u003emanual baseline profile\u003c/a\u003e, listed in the file \u003cspan\u003eprofile.prof.txt\u003c/span\u003e. You will notice that the profile only references the \u003cspan\u003efactorial\u003c/span\u003e method. Consequently, the \u003cspan\u003edex2oat\u003c/span\u003e output will only show compiled code for \u003cspan\u003efactorial\u003c/span\u003e, while \u003cspan\u003efibonacci\u003c/span\u003e shows in the output with no instructions and a size of 0 bytes.\u003c/p\u003e\n\n\u003cp\u003eIn the context of compilation modes, this means that \u003cspan\u003efactorial\u003c/span\u003e is compiled AOT, and \u003cspan\u003efibonacci\u003c/span\u003e will be compiled JIT or interpreted. This is because we applied a different \u003ca href=\"https://source.android.com/docs/core/runtime/configure#compiler_filters\" target=\"_blank\"\u003ecompiler filter\u003c/a\u003e in the profile sample. This is reflected in the \u003cspan\u003edex2oat\u003c/span\u003e output, which reads: ‚ÄúCompiler filter: speed-profile‚Äù (AOT compile only profile code), where previous examples read ‚ÄúCompiler filter: speed‚Äù (AOT compile everything).\u003c/p\u003e\n\n\u003ch2\u003e\u003cspan\u003eConclusion\u003c/span\u003e\u003c/h2\u003e\n\n\u003cp\u003eCompiler Explorer is a great tool for understanding what happens after you write your source code but before it can run on a target device. The tool is easy to use, interactive, and shareable. Compiler Explorer is best used with sample code, but it goes through the same procedures as building a real app, so you can see the impact of all steps in the toolchain.\u003c/p\u003e\n\n\u003cp\u003eBy learning how to use tools like this to discover how the compiler works under the hood, rather than memorizing a bunch of rules of optimization best practices, you can make more informed decisions.\u003c/p\u003e\n\n\u003cp\u003eNow that you\u0026#39;ve seen how to use the Java and Kotlin programming languages and the Android toolchain in Compiler Explorer, you can level up your Android development skills.\u003c/p\u003e\n\n\u003cp\u003eLastly, don\u0026#39;t forget that Compiler Explorer is an open source project on \u003ca href=\"https://github.com/compiler-explorer/compiler-explorer\" target=\"_blank\"\u003eGitHub\u003c/a\u003e. If there is a feature you\u0026#39;d like to see then it\u0026#39;s just a Pull Request away.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e\u003csmall\u003eJava and OpenJDK are trademarks or registered trademarks of Oracle and/or its affiliates.\u003c/small\u003e\u003c/em\u003e\u003c/p\u003e\n\n  \n\n \n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": null,
  "modifiedTime": null
}
