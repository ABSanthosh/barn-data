{
  "id": "5d9c5af9-c679-4ea9-8a5d-94e6fe03fca5",
  "title": "Preparing for K2",
  "link": "https://www.zacsweers.dev/preparing-for-k2/",
  "description": "K2 is around the corner (RC2 at the time of writing) and if you haven't prepared your project(s) for it, this post'll help cover some of the areas to watch out for.",
  "author": "Zac Sweers",
  "published": "Mon, 06 May 2024 18:22:24 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Kotlin"
  ],
  "byline": "Zac Sweers",
  "length": 14118,
  "excerpt": "K2 is around the corner (RC2 at the time of writing) and if you haven't prepared your project(s) for it, this post'll help cover some of the areas to watch out for.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "Kotlin's K2 release is around the corner (RC2 at the time of writing) and if you haven't prepared your project(s) for it, this post'll help cover some of the areas to watch out for. This post won't seek to explain all the under the hood changes, JetBrains has plenty of good documentation on that in the Kotlin blog!The below is advice based on preparing over a dozen or so projects across my work and OSS for K2. JetBrains runs an \"EAP Champions\" program where they work closely with a bunch of us in the community to try to proactively find and engage issues with upcoming releases.I've been tracking all of my testing and repos tested in this spreadsheet, which also has links to all of the WIP PRs where you can see the changes that have had to go into them.I'd advise doing the following in order, getting your build working at each stage first before moving on to the next.Bump the Kotlin version to 2.0.This includes corresponding releases of KSP, compiler plugins, etc as needed.(If applicable) switch to KSP2.(If applicable) switch lint to the latest alphas.(If applicable) switch lint to use K2 UAST.The rest of this post is broken up into distinct sections. Feel free to skip any that don't apply to you!K2The compiler itself is nearly ready to go. JetBrains is now in the phase of squashing final bugs or postponing to 2.0.20/2.1.0. As of RC1, you can publish new binaries that can be used by projects still targeting Kotlin 1.9 (Kotlin supports N+1 forward compatibility). You should be able to use K2 2.0.0-RC2 in your projects today. Here's some things to look out for:There are some cases around nullability that K1 missed that K2 will capture and (correctly) warn or error on.Past suppression mechanisms like INVISIBLE_REFERENCE may now be warnings or be wholly unsupported. KT-67920INVISIBLE_REFERENCE suppressions are completely unsupported now.There are some new smart casting features that K2 can do, such as propagating smart casts across boolean checksval isString = somevar is String if (isString) { // Compiler understands you can do String APIs on somevar here. }If you use mockito in your project (please don't), un-stubbed coroutine functions may explode in exotic ways due to subtle changes in how the compiled bytecode works.Don't try to mock types you don't own. For example â€“ coroutines' internals make some assumptions about library internals that mockito breaks.Definitely don't try to mock language features like suspend functions.I've found some cases where kotlinc is more strict about generic type inference that you may need to explicitly declare in source.If using Kotlin in a Gradle plugin, lambdas in 2.0 will no longer automatically be Serializable unless you annotate them with @JvmSerializableLambda or pass -Xlambdas=class to force the older behavior. See KT-45375 for more details.At the time of writing, the above are the only areas I've still been needing to make source changes to prepare for. Where possible, you should backport these fixes into your main branch to minimize changes in the actual K2 branch cut-over. GradleGradle is a build system loaded with footguns and where you're most likely to run into integration issues with K2, especially in nontrivial or multiplatform projects. At the time of writing, KGP (kotlin gradle plugin) 2.0 doesn't have any issues left in the projects I test. The Compose Multiplatform and KMP plugins still have some rough edges, namely use you have a Desktop application with compose resources generation enabled.KT-67915 / https://github.com/JetBrains/compose-multiplatform/issues/4739KT-67636K2 IDE Plugin ModeIt appears the K2 IDE plugin will not release with K2 itself. It's still in alpha right now, and not available in the latest stable Android Studio stable release. At the time of writing:It does not support script files at all (particularly problematic if you use Kotlin Gradle DSL)In my experience, struggles with any large files (1k+ lines).Does not show diagnostic errors from third party FIR plugins.You should try it out, but don't expect much right now or at the release.Compiler PluginsWhile not a stable API yet, many projects use some form of compiler plugin. Popular examples include Compose, kotlinx-serialization, zipline, etc. I also publish a couple - redacted-compiler-plugin and MoshiX. For almost all of these, you will need to go find a 2.0-compatible release to test K2, as compiler APIs change often between releases and require new builds of plugins built on top of them. Any first-party plugin (i.e. hosted in the Kotlin monorepo) does not need this as they are versioned with Kotlin itself. Compose has more to it, see below.If a plugin does not have a corresponding release and your build fails with it, you will be stuck. See if the author is open to a PR to start a branch supporting K2 ASAP.If you're a plugin author, please publish preview releases built against K2 to help folks test your plugin! For the most part, it's no different than any other update. There's breaking API changes, you need to update for them you know the drill. Be particularly mindful of any APIs using Descriptors, as these will not work anymore in K2 but are also not completely annotated with obsolete annotations.ComposeCompose's compiler is moving to the Kotlin monorepo for K2, allowing it to simultaneously release with Kotlin. JetBrains and Google have written up great guides for setting this up. Do this in your prep branchCompose compiler | Kotlin Multiplatform DevelopmentKotlin Multiplatform Development HelpJetBrains' doc.Jetpack Compose compiler moving to the Kotlin repositoryWith the upcoming release of Kotlin 2.0, the Jetpack Compose a matching Compose compiler will release alongside each release of Kotlin.Android Developers BlogGoogle's doc.If you are using Compose Multiplatform, be sure to update to the latest 1.6.10 release. At the time of writing, that is 1.6.10-rc01: https://github.com/JetBrains/compose-multiplatform/releases/tag/v1.6.10-rc01Parcelize on MultiplatformHistorically, if you wanted to use Parcelable in KMP, you had to do a trick by creating an @CommonParcelize annotation that you could put in your commonMain sources and then expect/actual that accordingly. In androidMain, you'd then actualize that as a typealias to the real Parcelize annotation. This would be in addition to an expect/actual Parcelable supertype.In K2 this is no longer necessary. Not only does K2 now allow you to actualize with a superset of members and supertypes, but the Parcelize plugin has been updated to allow specifying a custom marker annotation. This means you can just write @CommonParcelize in your commonMain and that's it, no expect/actual needed for the annotation. You'll still need one for the Parcelable supertype, but that's simple. There's no Gradle DSL yet to specify this annotation, but you can pass the appropriate compiler option.// In src/commonMain/kotlin package com.example @Target(CLASS) annotation class CommonParcelize expect interface CommonParcelable // In src/androidMain/kotlin actual typealias CommonParcelable = Parcelable // In build.gradle.kts kotlin { compilerOptions.freeCompilerArgs.addAll( \"-P\", \"plugin:org.jetbrains.kotlin.parcelize:additionalAnnotation=com.example.CommonParcelize\", ) }KAPTKAPT is Kotlin's tool for Java annotation processing. Popular processors like Dagger, AutoValue, and more still rely on it to work in Kotlin projects. Something you may not know is that KAPT is versioned. For most of its life, we've used KAPT 3. It sits on top of an API in the K1 compiler frontend called AnalysisHandlerExtension. This API goes away in K2, so KAPT had to be reimplemented to work in K2. As such, we now have KAPT 4. Canonically in KGP, it's referred to as \"K2 KAPT\".KAPT 4 can be enabled via the kapt.use.k2=true gradle property. If all goes well, you shouldn't notice any functional changes. One caveat though is that it will no longer run the compiler IR backend during stub generation, so any compiler plugins that depend on that (i.e. Anvil) will require changes.KAPT 4 is still in preview and may not be enabled by default at K2's release, but you should still try it out anyway.If you are an annotation processor author and test your processor, I maintain a modernized fork of kotlin-compile-testing and added KAPT4 support in the WIP K2 branch (with releases available).KSP2KSP is a Kotlin-first annotation processing tool intended to replace KAPT for most use cases. Like KAPT, KSP was built on top of AnalysisHandlerExtension, and thus needed to be reimplemented to support K2. This is called KSP2. It plans to be API compatible with processors written for KSP 1.This change is a little more involved, as the new implementation is built on top of a new Kotlin Analysis API. This API is the same API the K2 IDE plugin is based on, and is similarly experimental and still under active development. KSP2 is released as a part of the standard KSP release and controlled via ksp.useKSP2=true Gradle property. Note that this is false by default, even in 2.0.0-x builds.KSP2 also requires significantly more memory than KSP 1. If you use KSP ubiquitously in your project, you may need to consider increasing your Gradle daemon memory. This should be resolved in 2.0.0-1.0.21 (context).Similarly to KAPT4, I've added support for this in kotlin-compile-testing if you're a plugin author and want to test it.It still has a lot of open issues though, so I don't think it's likely to be fully available by the K2 release. The version at the time of writing is still 2.0.0-RC2-2.0.20. You should still try it out. Below are a list of issues I've encountered in projects, in case any look likely to affect yours.https://github.com/google/ksp/issues/1861https://github.com/google/ksp/issues/1842https://github.com/google/ksp/issues/1845https://github.com/google/ksp/issues/1846https://github.com/google/ksp/issues/1839https://github.com/google/ksp/issues/1843kotlinx-metadata-jvm is an API for performantly reading and writing Kotlin @Metadata annotations. A number of Java annotation processing and static analysis tools use it to understand Kotlin language features about bytecode they are processing/analyzing. With K2, this API has been stabilized and will be published with every Kotlin release under the org.jetbrains.kotlin:kotlin-metadata-jvm artifact.JetBrains has published a migration doc here: https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/Migration.mdMore info: KT-48011Android LintAndroid Lint's analysis core has a new K2 UAST implementation, but it's still experimental and probably will not be enabled by default for some time after the K2 release. However, you should try it out and use it if it works for you. The Android team has been super responsive to issues filed, often turning around fixes within a release. Like KSP2, it's also built on top of the new Analysis APIs in K2.To enable it, set the android.lint.useK2Uast=true. You should also use the latest lint canary. If you didn't realize before, you can use newer lint versions with older/stable versions of AGP/Studio by setting the android.experimental.lint.version to the lint version you want to use. At the time of writing, the latest version is android.experimental.lint.version=8.5.0-alpha08.At the time of writing, the only remaining issue we've encountered is this: https://issuetracker.google.com/issues/338232684AnvilIf you use Anvil, there's a few caveats depending on your repo situation. In short, you need to hop on to the latest 2.5.0 betas we've been publishing and switch over to the new KSP support for any subproject that doesn't contain components or subcomponents.// in build.gradle.kts anvil { + useKsp(contributesAndFactoryGeneration = \u003ctrue|false\u003e) }Then in projects that contain components, you'll need to do the following.Set the language level of the KAPT stub gen task to 1.9. This is necessary because in K2, Anvil's IR plugin that merges contributions will no longer run in KAPT 4 (aka K2 KAPT).tasks.withType\u003cKaptGenerateStubsTask\u003e().configureEach { // TODO necessary until anvil supports something for K2 contribution merging compilerOptions { progressiveMode.set(false) languageVersion.set(KotlinVersion.KOTLIN_1_9) } }If you use interface merging/contribute interfaces to components, you will need to do the same for the regular KotlinCompile task. This is because the API that Anvil's IR plugin uses to add new superinterfaces is no longer supported in K2. If you don't use interface merging though, you don't need to do this.tasks.withType\u003cKotlinCompile\u003e().configureEach { // TODO necessary until anvil supports something for K2 contribution merging compilerOptions { progressiveMode.set(false) languageVersion.set(KotlinVersion.KOTLIN_1_9) } }In the medium term, we're working on supporting a workaround for interface merging to work in FIR instead of FIR. This would allow avoiding the second workaround above.In the long term, we're working on fully supporting Dagger KSP, which would obviate the need for using FIR/IR plugins entirely.PerformanceK2 promises a significant improvement to compiler and IDE plugin performance. At the time of writing however, the results on projects I've tested have been mixed. Anecdotally, others in the community have reported modest improvements in the compiler, but usually only around ~10%. Far from the 2x+ improvements that were advertised up to this point.At Slack, our benchmarks actually show a ~17% slowdown (still using KSP 1 though). In CatchUp on the other hand, I've found significant improvements. In Circuit, I found similar slowdowns again. It seems to vary widely depending on the repo, and I would highly recommend doing your own measurements using the helpful post/repo JetBrains has put together.Note that at the time of writing, I've not successfully been able to run the Kotlin Notebook in that repo.Call to ActionPlease test your projects now! Especially if you're a library developer, compiler plugin author, or Gradle plugin author.Special thanks to James Barr for reviewing this post.",
  "image": "https://www.zacsweers.dev/content/images/2024/05/DALL-E-2024-05-04-16.41.40---Create-a-photorealistic-image-of-the-Kotlin-K2-logo--built-out-of-LEGO-bricks.-The-logo-should-prominently-display-the-letters--K2--in-the-center--usi.webp",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eKotlin\u0026#39;s K2 release is around the corner (RC2 at the time of writing) and if you haven\u0026#39;t prepared your project(s) for it, this post\u0026#39;ll help cover some of the areas to watch out for. This post won\u0026#39;t seek to explain all the under the hood changes, JetBrains has plenty of good documentation on that in the Kotlin blog!\u003c/p\u003e\u003cp\u003eThe below is advice based on preparing over a dozen or so projects across my work and OSS for K2. JetBrains runs an \u0026#34;EAP Champions\u0026#34; program where they work closely with a bunch of us in the community to try to proactively find and engage issues with upcoming releases.\u003c/p\u003e\u003cp\u003eI\u0026#39;ve been tracking all of my testing and repos tested in \u003ca href=\"https://docs.google.com/spreadsheets/d/1_BDWsqK3G1C76lv5idoX7EmquanvRYcKxbcp8WzU7XY/edit?pli=1\u0026amp;ref=zacsweers.dev#gid=514147628\"\u003ethis spreadsheet\u003c/a\u003e, which also has links to all of the WIP PRs where you can see the changes that have had to go into them.\u003c/p\u003e\u003cp\u003eI\u0026#39;d advise doing the following in order, getting your build working at each stage first before moving on to the next.\u003c/p\u003e\u003cul\u003e\u003cli\u003eBump the Kotlin version to 2.0.\u003cul\u003e\u003cli\u003eThis includes corresponding releases of KSP, compiler plugins, etc as needed.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e(If applicable) switch to KSP2.\u003c/li\u003e\u003cli\u003e(If applicable) switch lint to the latest alphas.\u003c/li\u003e\u003cli\u003e(If applicable) switch lint to use K2 UAST.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe rest of this post is broken up into distinct sections. Feel free to skip any that don\u0026#39;t apply to you!\u003c/p\u003e\u003ch2 id=\"k2\"\u003eK2\u003c/h2\u003e\u003cp\u003eThe compiler itself is nearly ready to go. JetBrains is now in the phase of squashing final bugs or postponing to 2.0.20/2.1.0. As of RC1, you can publish new binaries that can be used by projects still targeting Kotlin 1.9 (Kotlin supports N+1 forward compatibility). You should be able to use K2 2.0.0-RC2 in your projects today. Here\u0026#39;s some things to look out for:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThere are some cases around nullability that K1 missed that K2 will capture and (correctly) warn or error on.\u003c/li\u003e\u003cli\u003ePast suppression mechanisms like \u003ccode\u003eINVISIBLE_REFERENCE\u003c/code\u003e may now be warnings or be wholly unsupported. \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-67920?ref=zacsweers.dev\"\u003eKT-67920\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003eINVISIBLE_REFERENCE\u003c/code\u003e suppressions are completely unsupported now.\u003c/li\u003e\u003cli\u003eThere are some new smart casting features that K2 can do, such as propagating smart casts across boolean checks\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003eval isString = somevar is String\nif (isString) {\n  // Compiler understands you can do String APIs on somevar here.\n}\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003eIf you use mockito in your project (\u003ca href=\"https://medium.com/@june.pravin/mocking-is-not-practical-use-fakes-e30cc6eaaf4e?ref=zacsweers.dev\"\u003eplease don\u0026#39;t\u003c/a\u003e), un-stubbed coroutine functions may explode in exotic ways due to subtle changes in how the compiled bytecode works.\u003cul\u003e\u003cli\u003eDon\u0026#39;t try to mock types you don\u0026#39;t own. For example â€“ coroutines\u0026#39; internals make some assumptions about library internals that mockito breaks.\u003c/li\u003e\u003cli\u003eDefinitely don\u0026#39;t try to mock language features like \u003ccode\u003esuspend\u003c/code\u003e functions.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eI\u0026#39;ve found some cases where kotlinc is more strict about generic type inference that you may need to explicitly declare in source.\u003c/li\u003e\u003cli\u003eIf using Kotlin in a Gradle plugin, lambdas in 2.0 will no longer automatically be \u003ccode\u003eSerializable\u003c/code\u003e unless you annotate them with \u003ccode\u003e@JvmSerializableLambda\u003c/code\u003e or pass \u003ccode\u003e-Xlambdas=class\u003c/code\u003e to force the older behavior. See \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-45375?ref=zacsweers.dev\"\u003eKT-45375\u003c/a\u003e for more details.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAt the time of writing, the above are the only areas I\u0026#39;ve still been needing to make source changes to prepare for. Where possible, you should backport these fixes into your main branch to minimize changes in the actual K2 branch cut-over. \u003c/p\u003e\u003ch2 id=\"gradle\"\u003eGradle\u003c/h2\u003e\u003cp\u003eGradle is a build system loaded with footguns and where you\u0026#39;re most likely to run into integration issues with K2, especially in nontrivial or multiplatform projects. At the time of writing, KGP (kotlin gradle plugin) 2.0 doesn\u0026#39;t have any issues left in the projects I test. The Compose Multiplatform and KMP plugins still have some rough edges, namely use you have a Desktop application with compose resources generation enabled.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-67915?ref=zacsweers.dev\"\u003eKT-67915\u003c/a\u003e / \u003ca href=\"https://github.com/JetBrains/compose-multiplatform/issues/4739?ref=zacsweers.dev\"\u003ehttps://github.com/JetBrains/compose-multiplatform/issues/4739\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-67636?ref=zacsweers.dev\"\u003eKT-67636\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"k2-ide-plugin-mode\"\u003eK2 IDE Plugin Mode\u003c/h2\u003e\u003cp\u003eIt appears the K2 IDE plugin will not release with K2 itself. It\u0026#39;s still in alpha right now, and not available in the latest stable Android Studio stable release. At the time of writing:\u003c/p\u003e\u003cul\u003e\u003cli\u003eIt does not support script files at all (particularly problematic if you use Kotlin Gradle DSL)\u003c/li\u003e\u003cli\u003eIn my experience, struggles with any large files (1k+ lines).\u003c/li\u003e\u003cli\u003eDoes not show diagnostic errors from third party FIR plugins.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYou should try it out, but don\u0026#39;t expect much right now or at the release.\u003c/p\u003e\u003ch2 id=\"compiler-plugins\"\u003eCompiler Plugins\u003c/h2\u003e\u003cp\u003eWhile not a stable API yet, many projects use some form of compiler plugin. Popular examples include Compose, kotlinx-serialization, zipline, etc. I also publish a couple - \u003ca href=\"https://github.com/zacsweers/redacted-compiler-plugin?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eredacted-compiler-plugin\u003c/a\u003e and \u003ca href=\"https://github.com/zacsweers/moshix?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eMoshiX\u003c/a\u003e. For almost all of these, you will need to go find a 2.0-compatible release to test K2, as compiler APIs change often between releases and require new builds of plugins built on top of them. Any first-party plugin (i.e. hosted in the Kotlin monorepo) does not need this as they are versioned with Kotlin itself. Compose has more to it, see below.\u003c/p\u003e\u003cp\u003eIf a plugin does \u003cem\u003enot\u003c/em\u003e have a corresponding release and your build fails with it, you will be stuck. See if the author is open to a PR to start a branch supporting K2 ASAP.\u003c/p\u003e\u003cp\u003eIf you\u0026#39;re a plugin author, please publish preview releases built against K2 to help folks test your plugin! For the most part, it\u0026#39;s no different than any other update. There\u0026#39;s breaking API changes, you need to update for them you know the drill. Be particularly mindful of any APIs using Descriptors, as these will not work anymore in K2 but are also not completely annotated with obsolete annotations.\u003c/p\u003e\u003ch2 id=\"compose\"\u003eCompose\u003c/h2\u003e\u003cp\u003eCompose\u0026#39;s compiler is moving to the Kotlin monorepo for K2, allowing it to simultaneously release with Kotlin. JetBrains and Google have written up great guides for setting this up. Do this in your prep branch\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-compiler.html?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003eCompose compiler | Kotlin Multiplatform Development\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://resources.jetbrains.com/storage/ui/favicons/apple-touch-icon-180x180.png\" alt=\"\"/\u003e\u003cspan\u003eKotlin Multiplatform Development Help\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png\" alt=\"\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eJetBrains\u0026#39; doc.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003ca href=\"https://android-developers.googleblog.com/2024/04/jetpack-compose-compiler-moving-to-kotlin-repository.html?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003eJetpack Compose compiler moving to the Kotlin repository\u003c/p\u003e\u003cp\u003eWith the upcoming release of Kotlin 2.0, the Jetpack Compose a matching Compose compiler will release alongside each release of Kotlin.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://android-developers.googleblog.com/favicon.ico\" alt=\"\"/\u003e\u003cspan\u003eAndroid Developers Blog\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhgC61NXp6ZCCo241W0zn6K4rx5Nq6GqhI6cfn6y09qRrCq7UwhhW6NRcb6rTI6fNhmMXB3BshPi6Cd94VxQjHNGnGZECyR8MaK_HcWsoYb9uktG2BHIdXBWbDUS5Yaoc8-TD7EOOMEm8-FCB9NfvNe9mN7dBAg3xFYB2Jzov9MnmFrLAAdc6zKouZFqYM/s1600/social1-Compose-Compiler-moving-to-the-Kotlin-repository.png\" alt=\"\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eGoogle\u0026#39;s doc.\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIf you are using Compose Multiplatform, be sure to update to the latest 1.6.10 release. At the time of writing, that is \u003ccode\u003e1.6.10-rc01\u003c/code\u003e: \u003ca href=\"https://github.com/JetBrains/compose-multiplatform/releases/tag/v1.6.10-rc01?ref=zacsweers.dev\"\u003ehttps://github.com/JetBrains/compose-multiplatform/releases/tag/v1.6.10-rc01\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"parcelize-on-multiplatform\"\u003eParcelize on Multiplatform\u003c/h2\u003e\u003cp\u003eHistorically, if you wanted to use Parcelable in KMP, you had to do a trick by creating an \u003ccode\u003e@CommonParcelize\u003c/code\u003e annotation that you could put in your \u003ccode\u003ecommonMain\u003c/code\u003e sources and then \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e that accordingly. In \u003ccode\u003eandroidMain\u003c/code\u003e, you\u0026#39;d then actualize that as a typealias to the real \u003ccode\u003eParcelize\u003c/code\u003e annotation. This would be in addition to an \u003ccode\u003eexpect\u003c/code\u003e/\u003ccode\u003eactual\u003c/code\u003e \u003ccode\u003eParcelable\u003c/code\u003e supertype.\u003c/p\u003e\u003cp\u003eIn K2 this is no longer necessary. Not only does K2 now allow you to actualize with a superset of members and supertypes, but the Parcelize plugin has been updated to allow specifying a custom marker annotation. This means you can just write \u003ccode\u003e@CommonParcelize\u003c/code\u003e in your \u003ccode\u003ecommonMain\u003c/code\u003e and that\u0026#39;s it, no expect/actual needed for the annotation. You\u0026#39;ll still need one for the \u003ccode\u003eParcelable\u003c/code\u003e supertype, but that\u0026#39;s simple. There\u0026#39;s no Gradle DSL yet to specify this annotation, but you can pass the appropriate compiler option.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// In src/commonMain/kotlin\npackage com.example\n\n@Target(CLASS)\nannotation class CommonParcelize\n\nexpect interface CommonParcelable\n\n// In src/androidMain/kotlin\nactual typealias CommonParcelable = Parcelable\n\n// In build.gradle.kts\nkotlin {\n  compilerOptions.freeCompilerArgs.addAll(\n    \u0026#34;-P\u0026#34;,\n        \u0026#34;plugin:org.jetbrains.kotlin.parcelize:additionalAnnotation=com.example.CommonParcelize\u0026#34;,\n  )\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"kapt\"\u003eKAPT\u003c/h2\u003e\u003cp\u003eKAPT is Kotlin\u0026#39;s tool for Java annotation processing. Popular processors like Dagger, AutoValue, and more still rely on it to work in Kotlin projects. Something you may not know is that KAPT is versioned. For most of its life, we\u0026#39;ve used KAPT 3. It sits on top of an API in the K1 compiler frontend called \u003ccode\u003eAnalysisHandlerExtension\u003c/code\u003e. This API goes away in K2, so KAPT had to be reimplemented to work in K2. As such, we now have KAPT 4. Canonically in KGP, it\u0026#39;s referred to as \u0026#34;K2 KAPT\u0026#34;.\u003c/p\u003e\u003cp\u003eKAPT 4 can be enabled via the \u003ccode\u003ekapt.use.k2=true\u003c/code\u003e gradle property. If all goes well, you shouldn\u0026#39;t notice any functional changes. One caveat though is that it will no longer run the compiler IR backend during stub generation, so any compiler plugins that depend on that (i.e. Anvil) will require changes.\u003c/p\u003e\u003cp\u003eKAPT 4 is still in preview and may not be enabled by default at K2\u0026#39;s release, but you should still try it out anyway.\u003c/p\u003e\u003cp\u003eIf you are an annotation processor author and test your processor, I maintain a modernized fork of \u003ca href=\"https://github.com/zacsweers/kotlin-compile-testing?ref=zacsweers.dev\" rel=\"noreferrer\"\u003ekotlin-compile-testing\u003c/a\u003e and added KAPT4 support in the \u003ca href=\"https://github.com/ZacSweers/kotlin-compile-testing/pull/196?ref=zacsweers.dev\"\u003eWIP K2 branch\u003c/a\u003e (with releases available).\u003c/p\u003e\u003ch2 id=\"ksp2\"\u003eKSP2\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/google/ksp?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eKSP\u003c/a\u003e is a Kotlin-first annotation processing tool intended to replace KAPT for most use cases. Like KAPT, KSP was built on top of \u003ccode\u003eAnalysisHandlerExtension\u003c/code\u003e, and thus needed to be reimplemented to support K2. This is called KSP2. It plans to be API compatible with processors written for KSP 1.\u003c/p\u003e\u003cp\u003eThis change is a little more involved, as the new implementation is built on top of a new Kotlin Analysis API. This API is the same API the K2 IDE plugin is based on, and is similarly experimental and still under active development. KSP2 is released as a part of the standard KSP release and controlled via \u003ccode\u003eksp.useKSP2=true\u003c/code\u003e Gradle property. Note that this is \u003ccode\u003efalse\u003c/code\u003e by default, even in \u003ccode\u003e2.0.0-x\u003c/code\u003e builds.\u003c/p\u003e\u003cp\u003eKSP2 also requires significantly more memory than KSP 1. If you use KSP ubiquitously in your project, you may need to consider increasing your Gradle daemon memory. This should be resolved in \u003ccode\u003e2.0.0-1.0.21\u003c/code\u003e (\u003ca href=\"https://youtrack.jetbrains.com/issue/KT-66689?ref=zacsweers.dev\"\u003econtext\u003c/a\u003e).\u003c/p\u003e\u003cp\u003eSimilarly to KAPT4, I\u0026#39;ve added support for this in kotlin-compile-testing if you\u0026#39;re a plugin author and want to test it.\u003c/p\u003e\u003cp\u003eIt still has a \u003cem\u003elot\u003c/em\u003e of open issues though, so I don\u0026#39;t think it\u0026#39;s likely to be fully available by the K2 release. The version at the time of writing is still \u003ccode\u003e2.0.0-RC2-2.0.20\u003c/code\u003e. You should still try it out. Below are a list of issues I\u0026#39;ve encountered in projects, in case any look likely to affect yours.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1861?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1861\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1842?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1842\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1845?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1845\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1846?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1846\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1839?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1839\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/ksp/issues/1843?ref=zacsweers.dev\" rel=\"noopener noreferrer\"\u003ehttps://github.com/google/ksp/issues/1843\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003ekotlinx-metadata-jvm\u003c/code\u003e is an API for performantly reading and writing Kotlin \u003ccode\u003e@Metadata\u003c/code\u003e annotations. A number of Java annotation processing and static analysis tools use it to understand Kotlin language features about bytecode they are processing/analyzing. With K2, this API has been stabilized and will be published with every Kotlin release under the \u003ccode\u003eorg.jetbrains.kotlin:kotlin-metadata-jvm\u003c/code\u003e artifact.\u003c/p\u003e\u003cp\u003eJetBrains has published a migration doc here: \u003ca href=\"https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/Migration.md?ref=zacsweers.dev\"\u003ehttps://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/Migration.md\u003c/a\u003e\u003c/p\u003e\u003cp\u003eMore info: \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-48011?ref=zacsweers.dev\"\u003eKT-48011\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"android-lint\"\u003eAndroid Lint\u003c/h2\u003e\u003cp\u003eAndroid Lint\u0026#39;s analysis core has a new K2 UAST implementation, but it\u0026#39;s still experimental and probably will not be enabled by default for some time after the K2 release. However, you should try it out and use it if it works for you. The Android team has been super responsive to issues filed, often turning around fixes within a release. Like KSP2, it\u0026#39;s also built on top of the new Analysis APIs in K2.\u003c/p\u003e\u003cp\u003eTo enable it, set the \u003ccode\u003eandroid.lint.useK2Uast=true\u003c/code\u003e. You should also use the latest lint canary. If you didn\u0026#39;t realize before, you can use newer lint versions with older/stable versions of AGP/Studio by setting the \u003ccode\u003eandroid.experimental.lint.version\u003c/code\u003e to the lint version you want to use. At the time of writing, the latest version is \u003ccode\u003eandroid.experimental.lint.version=8.5.0-alpha08\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eAt the time of writing, the only remaining issue we\u0026#39;ve encountered is this: \u003ca href=\"https://issuetracker.google.com/issues/338232684?ref=zacsweers.dev\"\u003ehttps://issuetracker.google.com/issues/338232684\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"anvil\"\u003eAnvil\u003c/h2\u003e\u003cp\u003eIf you use Anvil, there\u0026#39;s a few caveats depending on your repo situation. In short, you need to hop on to the latest 2.5.0 betas we\u0026#39;ve been publishing and switch over to the new KSP support for any subproject that doesn\u0026#39;t contain components or subcomponents.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// in build.gradle.kts\nanvil {\n+  useKsp(contributesAndFactoryGeneration = \u0026lt;true|false\u0026gt;)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThen in projects that contain components, you\u0026#39;ll need to do the following.\u003c/p\u003e\u003cul\u003e\u003cli\u003eSet the language level of the KAPT stub gen task to 1.9. This is necessary because in K2, Anvil\u0026#39;s IR plugin that merges contributions will no longer run in KAPT 4 (aka K2 KAPT).\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003etasks.withType\u0026lt;KaptGenerateStubsTask\u0026gt;().configureEach {\n  // TODO necessary until anvil supports something for K2 contribution merging\n  compilerOptions {\n    progressiveMode.set(false)\n    languageVersion.set(KotlinVersion.KOTLIN_1_9)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you use interface merging/contribute interfaces to components, you will need to do the same for the regular KotlinCompile task. This is because the API that Anvil\u0026#39;s IR plugin uses to add new superinterfaces is no longer supported in K2. If you don\u0026#39;t use interface merging though, you don\u0026#39;t need to do this.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etasks.withType\u0026lt;KotlinCompile\u0026gt;().configureEach {\n  // TODO necessary until anvil supports something for K2 contribution merging\n  compilerOptions {\n    progressiveMode.set(false)\n    languageVersion.set(KotlinVersion.KOTLIN_1_9)\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn the medium term, we\u0026#39;re working on supporting a workaround for interface merging to work in FIR instead of FIR. This would allow avoiding the second workaround above.\u003c/p\u003e\u003cp\u003eIn the long term, we\u0026#39;re working on fully supporting Dagger KSP, which would obviate the need for using FIR/IR plugins entirely.\u003c/p\u003e\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\u003cp\u003eK2 promises a significant improvement to compiler and IDE plugin performance. At the time of writing however, the results on projects I\u0026#39;ve tested have been mixed. Anecdotally, others in the community have reported modest improvements in the compiler, but usually only around ~10%. Far from the 2x+ improvements that were \u003ca href=\"https://youtu.be/QGtB--ABiNM?t=236\u0026amp;ref=zacsweers.dev\"\u003eadvertised\u003c/a\u003e up to this point.\u003c/p\u003e\u003cp\u003eAt Slack, our benchmarks actually show a ~17% \u003cem\u003eslowdown\u003c/em\u003e (still using KSP 1 though). In \u003ca href=\"https://github.com/zacsweers/catchup?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eCatchUp\u003c/a\u003e on the other hand, I\u0026#39;ve found significant improvements. In \u003ca href=\"https://github.com/slackhq/circuit?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eCircuit\u003c/a\u003e, I found similar slowdowns again. It seems to vary widely depending on the repo, and I would highly recommend doing your own measurements using the helpful \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/04/k2-compiler-performance-benchmarks-and-how-to-measure-them-on-your-projects/?ref=zacsweers.dev\"\u003epost/repo\u003c/a\u003e JetBrains has put together.\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote that at the time of writing, I\u0026#39;ve not successfully been able to run the Kotlin Notebook in that repo.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"call-to-action\"\u003eCall to Action\u003c/h2\u003e\u003cp\u003ePlease test your projects now! Especially if you\u0026#39;re a library developer, compiler plugin author, or Gradle plugin author.\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003eSpecial thanks to James Barr for reviewing this post.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-05-06T18:22:24Z",
  "modifiedTime": "2024-05-09T21:14:21Z"
}
