{
  "id": "1d8d69af-c7cf-4a7c-a2b0-b65bc9d2b44f",
  "title": "Organizing @Composables",
  "link": "https://handstandsam.com/2022/11/30/organizing-composables/",
  "description": "I saved this post as a draft on February 23, 2021 and never published it. Almost 2 years later this topic came up again, so I want to publish it as a current post to create discussion on the topic. Feel free to ping me on Mastodon with your thoughts and feedback. — Jetpack Compose […]",
  "author": "Sam Edwards",
  "published": "Wed, 30 Nov 2022 20:04:23 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Android",
    "Updates"
  ],
  "byline": "Sam Edwards Published November 30, 2022",
  "length": 5814,
  "excerpt": "I saved this post as a draft on February 23, 2021 and never published it. Almost 2 years later this topic came up again, so I want to publish it as a current post to create discussion on the topic. Feel free to ping me on Mastodon with your thoughts and feedback.",
  "siteName": "",
  "favicon": "",
  "text": "I saved this post as a draft on February 23, 2021 and never published it. Almost 2 years later this topic came up again, so I want to publish it as a current post to create discussion on the topic. Feel free to ping me on Mastodon with your thoughts and feedback. — Jetpack Compose for Android is AMAZING, and I’m so excited for it to be stable and the recommended way to build Android applications. I’ve been working with the alpha versions of Compose 1.0.0 on Android for the last 6 months on side projects and have been doing a lot of thinking based on my experiences. One thing that came to mind when I first started, and still does, is how to structure my project and organize all my @Composable functions. I’ve asked this question for #TheAndroidShow which is tomorrow, and hopefully will get some recommendations, but I’ve already had some good conversations on Twitter. Question for #TheAndroidShow :How should I organize all my Composables? Android Studio/IntelliJ has powerful refactoring capabilities when there is a single class or object in a Kotlin file, but this doesn't work with top level Composables. Tips/Tricks?— mastodon.social/@handstandsam (@HandstandSam) February 22, 2021 When I look around at the AndroidX Compose Library (Button.kt) and the compose-samples that the Google Developer Relations Team has published, I see that composables are organized by file. Over the last 4 years of being a full-time Kotlin developer, I have tried to keep a single class or object per file. I also try to avoid writing code at the root level of a file. The only exceptions I make when writing Kotlin code are for extension functions and typealiases, since those are required to be written directly in a file. I’m used to finding items by what class/object they are in, and not the function name. I’ve also historically found that large refactoring has been more successful when a file has a single Kotlin class or object. For this post, I made up the GreetingHeader and GreetingContent @Composables for the purpose of having an example of related @Composables. Let’s take a look at some options on how to group related @Composable functions. Root Level in a File @Composable fun GreetingHeader() { Text( text = \"Hello\", style = MaterialTheme.typography.h1 ) } @Composable fun GreetingContent() { Box(contentAlignment = Alignment.Center) { Text( text = \"How are you?\", modifier = Modifier.padding(16.dp) ) } } Top level functions for nice clean syntax, but how do you find these composables in a project you are unfamiliar with? Composables don’t extend other classes or implement interfaces, so it’s hard to use built in tools to Android Studio and Intellij to find related ones. In an object object Greetings { @Composable fun GreetingHeader() { Text( text = \"Hello\", style = MaterialTheme.typography.h1 ) } @Composable fun GreetingContent() { Box(contentAlignment = Alignment.Center) { Text( text = \"How are you?\", modifier = Modifier.padding(16.dp) ) } } } I originally leaned on this so I could search for a @Composable, and use auto complete. I do like it, but I don’t like the longer composable names, even though I can do static imports. In a class class Greetings { @Composable fun GreetingHeader() { Text( text = \"Hello\", style = MaterialTheme.typography.h1 ) } @Composable fun GreetingContent() { Box(contentAlignment = Alignment.Center) { Text( text = \"How are you?\", modifier = Modifier.padding(16.dp) ) } } } I haven’t tried this yet. It could work though (it compiled), especially if you want to be able to access injected dependencies, etc. In a class or object, via an interface interface HeaderAndContent { @Composable fun Header() @Composable fun Content() } object Greetings : HeaderAndContent { @Composable override fun Header() { Text( text = \"Hello\", style = MaterialTheme.typography.h1 ) } @Composable override fun Content() { Box(contentAlignment = Alignment.Center) { Text( text = \"How are you?\", modifier = Modifier.padding(16.dp) ) } } } I haven’t used an interface yet, but it’s an interesting thought. I checked it out and it’s possible and compiles. It could help with discoverability for similar @Composables. This also gets me thinking about capitalization of @Composables. It isn’t required from a compiler standpoint, so what if we did this. interface HeaderAndContent { @Composable fun header() @Composable fun content() } object Greetings : HeaderAndContent { @Composable override fun header() { Text( text = \"Hello\", style = MaterialTheme.typography.h1 ) } @Composable override fun content() { Box(contentAlignment = Alignment.Center) { Text( text = \"How are you?\", modifier = Modifier.padding(16.dp) ) } } } Conclusion It is very early on, and I’m not sure what the best way will be to organize @Composable functions. I typically say to do what the community is doing, but at this point we just have what the Google team is doing really. Let’s all use Compose some more, and figure out what works the best, but keep an open mind and try new things. Feel free to reach out with what you’re trying on Mastodon.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1618\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eI saved this post as a draft on February 23, 2021 and never published it.  Almost 2 years later this topic came up again, so I want to publish it as a current post to create discussion on the topic.  Feel free to \u003ca href=\"https://mastodon.social/@handstandsam\" data-type=\"URL\" data-id=\"https://mastodon.social/@handstandsam\"\u003eping me on Mastodon\u003c/a\u003e with your thoughts and feedback.\u003c/p\u003e\n\n\n\n\u003cp\u003e—\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://developer.android.com/jetpack/compose\" data-type=\"URL\" data-id=\"https://developer.android.com/jetpack/compose\"\u003eJetpack Compose for Android\u003c/a\u003e is AMAZING, and I’m so excited for it to be stable and the recommended way to build Android applications.  I’ve been working with the alpha versions of Compose 1.0.0 on Android for the last 6 months on side projects and have been doing a lot of thinking based on my experiences.  One thing that came to mind when I first started, and still does, is how to structure my project and organize all my @Composable functions.\u003c/p\u003e\n\n\n\n\u003cp\u003eI’ve asked this question for \u003ca href=\"https://landing.google.com/theandroidshow/\" data-type=\"URL\" data-id=\"https://landing.google.com/theandroidshow/\"\u003e#TheAndroidShow which is tomorrow\u003c/a\u003e, and hopefully will get some recommendations, but I’ve already had some good conversations on Twitter.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cdiv\u003e\n\u003cblockquote data-width=\"550\" data-dnt=\"true\"\u003e\u003cdiv lang=\"en\" dir=\"ltr\"\u003e\u003cp\u003eQuestion for \u003ca href=\"https://twitter.com/hashtag/TheAndroidShow?src=hash\u0026amp;ref_src=twsrc%5Etfw\"\u003e#TheAndroidShow\u003c/a\u003e :\u003c/p\u003e\u003cp\u003eHow should I organize all my Composables?  Android Studio/IntelliJ has powerful refactoring capabilities when there is a single class or object in a Kotlin file, but this doesn\u0026#39;t work with top level Composables.  Tips/Tricks?\u003c/p\u003e\u003c/div\u003e— mastodon.social/@handstandsam (@HandstandSam) \u003ca href=\"https://twitter.com/HandstandSam/status/1363891879708749826?ref_src=twsrc%5Etfw\"\u003eFebruary 22, 2021\u003c/a\u003e\u003c/blockquote\u003e\n\u003c/div\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWhen I look around at the \u003ca href=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt\" data-type=\"URL\" data-id=\"https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/material/material/src/commonMain/kotlin/androidx/compose/material/Button.kt\"\u003eAndroidX Compose Library (Button.kt)\u003c/a\u003e and the \u003ca href=\"https://github.com/android/compose-samples/\" data-type=\"URL\" data-id=\"https://github.com/android/compose-samples/\"\u003ecompose-samples\u003c/a\u003e that the Google Developer Relations Team has published, I see that composables are organized by file.  \u003c/p\u003e\n\n\n\n\u003cp\u003eOver the last 4 years of being a full-time Kotlin developer, I have tried to keep a single class or object per file.    I also try to avoid writing code at the root level of a file.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe only exceptions I make when writing Kotlin code are for extension functions and typealiases, since those are required to be written directly in a file.  I’m used to finding items by what class/object they are in, and not the function name.  I’ve also historically found that large refactoring has been more successful when a file has a single Kotlin \u003cem\u003eclass\u003c/em\u003e or \u003cem\u003eobject\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor this post, I made up the GreetingHeader and GreetingContent @Composables for the purpose of having an example of related @Composables.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s take a look at some options on how to group related @Composable functions.\u003c/p\u003e\n\n\n\n\u003ch4\u003eRoot Level in a File\u003c/h4\u003e\n\n\n\n\u003cpre title=\"Greetings.kt\"\u003e\u003ccode lang=\"kotlin\"\u003e@Composable\nfun GreetingHeader() {\n    Text(\n        text = \u0026#34;Hello\u0026#34;,\n        style = MaterialTheme.typography.h1\n    )\n}\n\n@Composable\nfun GreetingContent() {\n    \u003cem\u003eBox\u003c/em\u003e(contentAlignment = Alignment.Center) \u003cstrong\u003e{\n        \u003c/strong\u003eText(\n            text = \u0026#34;How are you?\u0026#34;,\n            modifier = Modifier.padding(16.\u003cem\u003edp\u003c/em\u003e)\n        )\n    \u003cstrong\u003e}\n\u003c/strong\u003e}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eTop level functions for nice clean syntax, but how do you find these composables in a project you are unfamiliar with?  Composables don’t extend other classes or implement interfaces, so it’s hard to use built in tools to Android Studio and Intellij to find related ones.\u003c/p\u003e\n\n\n\n\u003ch4\u003eIn an object\u003c/h4\u003e\n\n\n\n\u003cpre title=\"object Greetings\"\u003e\u003ccode lang=\"kotlin\"\u003eobject Greetings {\n    @Composable\n    fun GreetingHeader() {\n        Text(\n            text = \u0026#34;Hello\u0026#34;,\n            style = MaterialTheme.typography.h1\n        )\n    }\n\n    @Composable\n    fun GreetingContent() {\n        \u003cem\u003eBox\u003c/em\u003e(contentAlignment = Alignment.Center) \u003cstrong\u003e{\n            \u003c/strong\u003eText(\n                text = \u0026#34;How are you?\u0026#34;,\n                modifier = Modifier.padding(16.\u003cem\u003edp\u003c/em\u003e)\n            )\n        \u003cstrong\u003e}\n    \u003c/strong\u003e}\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI originally leaned on this so I could search for a @Composable, and use auto complete.  I do like it, but I don’t like the longer composable names, even though I can do static imports.\u003c/p\u003e\n\n\n\n\u003ch4\u003eIn a class\u003c/h4\u003e\n\n\n\n\u003cpre title=\"class Greetings\"\u003e\u003ccode lang=\"kotlin\"\u003eclass Greetings {\n    @Composable\n    fun GreetingHeader() {\n        Text(\n            text = \u0026#34;Hello\u0026#34;,\n            style = MaterialTheme.typography.h1\n        )\n    }\n\n    @Composable\n    fun GreetingContent() {\n        \u003cem\u003eBox\u003c/em\u003e(contentAlignment = Alignment.Center) \u003cstrong\u003e{\n            \u003c/strong\u003eText(\n                text = \u0026#34;How are you?\u0026#34;,\n                modifier = Modifier.padding(16.\u003cem\u003edp\u003c/em\u003e)\n            )\n        \u003cstrong\u003e}\n    \u003c/strong\u003e}\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI haven’t tried this yet.  It could work though (it compiled), especially if you want to be able to access injected dependencies, etc.\u003c/p\u003e\n\n\n\n\u003ch4\u003eIn a class or object, via an interface\u003c/h4\u003e\n\n\n\n\u003cpre title=\"implementing an interface\"\u003e\u003ccode lang=\"kotlin\"\u003einterface HeaderAndContent {\n    @Composable\n    fun Header()\n\n    @Composable\n    fun Content()\n}\n\nobject Greetings : HeaderAndContent {\n    @Composable\n    override fun Header() {\n        Text(\n            text = \u0026#34;Hello\u0026#34;,\n            style = MaterialTheme.typography.h1\n        )\n    }\n\n    @Composable\n    override fun Content() {\n        \u003cem\u003eBox\u003c/em\u003e(contentAlignment = Alignment.Center) \u003cstrong\u003e{\n            \u003c/strong\u003eText(\n                text = \u0026#34;How are you?\u0026#34;,\n                modifier = Modifier.padding(16.\u003cem\u003edp\u003c/em\u003e)\n            )\n        \u003cstrong\u003e}\n    \u003c/strong\u003e}\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eI haven’t used an interface yet, but it’s an interesting thought.  I checked it out and it’s possible and compiles.  It could help with discoverability for similar @Composables.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis also gets me thinking about capitalization of @Composables.  It isn’t required from a compiler standpoint, so what if we did this.\u003c/p\u003e\n\n\n\n\u003cpre title=\"lowercase composables\"\u003e\u003ccode lang=\"kotlin\"\u003einterface HeaderAndContent {\n    @Composable\n    fun header()\n\n    @Composable\n    fun content()\n}\n\nobject Greetings : HeaderAndContent {\n    @Composable\n    override fun header() {\n        Text(\n            text = \u0026#34;Hello\u0026#34;,\n            style = MaterialTheme.typography.h1\n        )\n    }\n\n    @Composable\n    override fun content() {\n        \u003cem\u003eBox\u003c/em\u003e(contentAlignment = Alignment.Center) \u003cstrong\u003e{\n            \u003c/strong\u003eText(\n                text = \u0026#34;How are you?\u0026#34;,\n                modifier = Modifier.padding(16.\u003cem\u003edp\u003c/em\u003e)\n            )\n        \u003cstrong\u003e}\n    \u003c/strong\u003e}\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch4\u003eConclusion\u003c/h4\u003e\n\n\n\n\u003cp\u003eIt is very early on, and I’m not sure what the best way will be to organize @Composable functions.  I typically say to do what the community is doing, but at this point we just have what the Google team is doing really.  Let’s all use Compose some more, and figure out what works the best, but keep an open mind and try new things.  Feel free to reach out with what you’re \u003ca href=\"https://mastodon.social/@handstandsam\"\u003etrying on Mastodon\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
