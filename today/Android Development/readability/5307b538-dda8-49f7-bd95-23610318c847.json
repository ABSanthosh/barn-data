{
  "id": "5307b538-dda8-49f7-bd95-23610318c847",
  "title": "Using Java Reflection with Kotlin Companion Objects",
  "link": "https://handstandsam.com/2023/02/01/using-java-reflection-with-kotlin-companion-objects/",
  "description": "Kotlin companion objects allow you to add static data and methods associated with a class. This is similar to how Java has static fields and methods. The problem is that Java doesnâ€™t really know what a companion object it, so trying to access one using standard Java reflection might make you go crazy. ðŸ¤ª The [â€¦]",
  "author": "Sam Edwards",
  "published": "Wed, 01 Feb 2023 18:45:27 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Updates"
  ],
  "byline": "Sam Edwards Published February 1, 2023",
  "length": 3605,
  "excerpt": "Kotlin companion objects allow you to add static data and methods associated with a class. This is similar to how Java has static fields and methods. The problem is that Java doesnâ€™t really know what a companion object it, so trying to access one using standard Java reflection might make you go crazy. ðŸ¤ª",
  "siteName": "",
  "favicon": "",
  "text": "Kotlin companion objects allow you to add static data and methods associated with a class. This is similar to how Java has static fields and methods. The problem is that Java doesnâ€™t really know what a companion object it, so trying to access one using standard Java reflection might make you go crazy. ðŸ¤ª package com.handstandsam /** This is contrived example of a companion object */ class SpecialFeature { companion object { var enabled: Boolean = false } } The decompiled Java class (created by the Kotlin Compiler) results in this: package com.handstandsam; import kotlin.Metadata; import kotlin.jvm.internal.DefaultConstructorMarker; import org.jetbrains.annotations.NotNull; public final class SpecialFeature { private static boolean enabled; @NotNull public static final Companion Companion = new Companion((DefaultConstructorMarker)null); public static final class Companion { public final boolean getEnabled() { return SpecialFeature.enabled; } public final void setEnabled(boolean var1) { SpecialFeature.enabled = var1; } private Companion() { } public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } } The Kotlin Standard Lib for Java has a really cool method called companionObjectInstance that allows you to grab an instance of the declared companion object from the KClass object. Why is companionObjectInstance helpful? When Kotlin is compiled to Java Class files, the companion object has a fully qualified class name of com.handstandsam.SpecialFeature$Companion. Mapping Kotlin -\u003e Java Byte Code can make your head hurt, so by using this companionObjectInstance helper method, we donâ€™t have to figure out how to get an instance of the companion object, or figure out the fully qualified class name. val companionObjectJavaClass = com.handstandsam.SpecialFeature::class.java val companionObjectInstance = companionObjectJavaClass.kotlin .companionObjectInstance!! Now that we have an instance of the companion object class, and know the Java class, we can use reflection to set the value of the enabled property on the companion object. companionObjectInstance::class.java .methods .first { it.name == \"setEnabled\" } .invoke(companionObjectInstance, true) Note: setEnabled is the name, and it is a method here. You might expect this to just be a property which is what I assumed, but when compiled to java byte code, it is marked private and has a getter and a setter. Bonus: Accessing private properties using Java Reflection You could alternatively use Java reflection to change the backing private static boolean enabled field directly if you choose. If you wanted to set the private static field value itself, rather than calling the setter, you can grab the declared field, and set it to accessible which allows us to bypass the private visibility. This sort of thing is why the JVM canâ€™t be considered secure as it can be modified at runtime. val privateEnabledField = SpecialFeature::class.java.getDeclaredField(\"enabled\") privateEnabledField.isAccessible=true privateEnabledField.set(companionObjectInstance, true) Conclusion Reflection is powerful, but confusing. I could have probably done this cleaner JUST using Kotlin Reflect and not Java Reflection, but in my case I wanted to use Java Reflection, but needed to interact with a Kotlin companion object. There is a lot of documentation on how to mix Kotlin + Reflection, so feel free to read up more there. Cheers!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1955\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eKotlin \u003ca href=\"https://kotlinlang.org/docs/object-declarations.html#companion-objects\" data-type=\"URL\" data-id=\"https://kotlinlang.org/docs/object-declarations.html#companion-objects\"\u003ecompanion objects\u003c/a\u003e allow you to add static data and methods associated with a class.  This is similar to how Java has \u003ccode\u003estatic\u003c/code\u003e fields and methods.  The problem is that Java doesnâ€™t really know what a companion object it, so trying to access one using standard \u003ca href=\"https://www.oracle.com/technical-resources/articles/java/javareflection.html\" data-type=\"URL\" data-id=\"https://www.oracle.com/technical-resources/articles/java/javareflection.html\"\u003eJava reflection\u003c/a\u003e might make you go crazy.  ðŸ¤ª\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epackage com.handstandsam\n\n/** This is contrived example of a companion object */\nclass SpecialFeature {\n  companion object {\n    var enabled: Boolean = false\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe decompiled Java class (created by the Kotlin Compiler) results in this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"java\"\u003epackage com.handstandsam;\n\nimport kotlin.Metadata;\nimport kotlin.jvm.internal.DefaultConstructorMarker;\nimport org.jetbrains.annotations.NotNull;\n\npublic final class SpecialFeature {\n   private static boolean enabled;\n\n   @NotNull\n   public static final Companion Companion = new Companion((DefaultConstructorMarker)null);\n\n   public static final class Companion {\n      public final boolean getEnabled() {\n         return SpecialFeature.enabled;\n      }\n\n      public final void setEnabled(boolean var1) {\n         SpecialFeature.enabled = var1;\n      }\n\n      private Companion() {\n      }\n\n      public Companion(DefaultConstructorMarker $constructor_marker) {\n         this();\n      }\n   }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/\"\u003eKotlin Standard Lib\u003c/a\u003e for Java has a really cool method called \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/companion-object-instance.html\"\u003ecompanionObjectInstance\u003c/a\u003e\u003c/code\u003e that allows you to grab an instance of the declared companion object from the \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/\"\u003eKClass\u003c/a\u003e\u003c/code\u003e object.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhy is companionObjectInstance helpful?\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen Kotlin is compiled to Java Class files, the \u003ccode\u003ecompanion object\u003c/code\u003e has a fully qualified class name of \u003ccode\u003ecom.handstandsam.SpecialFeature$Companion\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003eMapping Kotlin -\u0026gt; Java Byte Code can make your head hurt, so by using this \u003ccode\u003ecompanionObjectInstance\u003c/code\u003e helper method, we donâ€™t have to figure out how to get an instance of the companion object, or figure out the fully qualified class name.\u003c/p\u003e\n\n\n\n\u003cpre title=\"Java Class\"\u003e\u003ccode lang=\"kotlin\"\u003eval companionObjectJavaClass = com.handstandsam.SpecialFeature::class.java\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre title=\"Instance of Kotlin Companion Object\"\u003e\u003ccode lang=\"kotlin\"\u003eval companionObjectInstance = companionObjectJavaClass.kotlin\n        .companionObjectInstance!!\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow that we have an instance of the \u003ca href=\"https://kotlinlang.org/docs/object-declarations.html#companion-objects\"\u003ecompanion object\u003c/a\u003e class, and know the Java class, we can use reflection to set the value of the \u003ccode\u003eenabled\u003c/code\u003e property on the companion object.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003ecompanionObjectInstance::class.\u003cem\u003ejava\n    \u003c/em\u003e.\u003cem\u003emethods\n    \u003c/em\u003e.\u003cem\u003efirst \u003c/em\u003e\u003cstrong\u003e{ it\u003c/strong\u003e.\u003cem\u003ename \u003c/em\u003e== \u0026#34;setEnabled\u0026#34; \u003cstrong\u003e}\n    \u003c/strong\u003e.invoke(companionObjectInstance, true)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNote: \u003ccode\u003esetEnabled\u003c/code\u003e is the name, and it is a method here.  You might expect this to just be a property which is what I assumed, but when compiled to java byte code, it is marked private and has a getter and a setter.  \u003c/p\u003e\n\n\n\n\u003ch3\u003eBonus: Accessing private properties using Java Reflection\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou could alternatively use Java reflection to change the backing \u003ccode\u003eprivate static boolean enabled\u003c/code\u003e field directly if you choose.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you wanted to set the private static field value itself, rather than calling the setter, you can grab the declared field, and set it to accessible which allows us to bypass the \u003ccode\u003eprivate\u003c/code\u003e visibility.  This sort of thing is why the JVM canâ€™t be considered secure as it can be modified at runtime.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eval privateEnabledField = SpecialFeature::class.java.getDeclaredField(\u0026#34;enabled\u0026#34;)\nprivateEnabledField.isAccessible=true\nprivateEnabledField.set(companionObjectInstance, true)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch3\u003eConclusion\u003c/h3\u003e\n\n\n\n\u003cp\u003eReflection is powerful, but confusing. I could have probably done this cleaner JUST using Kotlin Reflect and not Java Reflection, but in my case I wanted to use Java Reflection, but needed to interact with a Kotlin \u003ccode\u003ecompanion object\u003c/code\u003e.  There is a lot of documentation on how to mix \u003ca href=\"https://kotlinlang.org/docs/reflection.html\" data-type=\"URL\" data-id=\"https://kotlinlang.org/docs/reflection.html\"\u003eKotlin + Reflection\u003c/a\u003e, so feel free to read up more there.  Cheers!\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
