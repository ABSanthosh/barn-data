{
  "id": "48dac8c1-1cd2-4b48-a6a8-47c3f1690be5",
  "title": "Writing a Kotlin Multiplatform App from Start to Store",
  "link": "https://www.zacsweers.dev/writing-a-kotlin-multiplatform-app-from-start-to-store/",
  "description": "Notes from writing a new toy Kotlin Multiplatform app this summer.",
  "author": "Zac Sweers",
  "published": "Sun, 25 Aug 2024 20:57:51 GMT",
  "source": "https://www.zacsweers.dev/rss/",
  "categories": [
    "Open Source",
    "Kotlin",
    "Circuit",
    "Multiplatform",
    "iOS",
    "Android",
    "Mobile"
  ],
  "byline": "Zac Sweers",
  "length": 14494,
  "excerpt": "Notes from writing a new toy Kotlin Multiplatform app this summer.",
  "siteName": "Zac Sweers",
  "favicon": "",
  "text": "I recently wrote a little toy app for my pickup soccer group to check field permit statuses. In New York City most public parks' fields can be reserved or have recurring permits, so we have to check if fields are going to be in use before we try to organize games. The city parks website has this information, but it's a little awkward to use. They also have all permit information available in downloadable CSV files, which got me thinking I could just write my own little app. The rest of this post is notes about the process, things I used, things I learned, and hopefully some helpful references for myself and anyone else doing this in the future.FieldSpottrI wrote the app! It's called Field Spottr, and it's open source. I wrote it with Kotlin Multiplatform, Compose, and Circuit.You can also download it on the App Store or Play Store. Note that this is really only useful for myself and the friends I play soccer with ðŸ˜„. 0:00 /0:08 Video walk through of the app The app technically supports Desktop too, but I'm omitting those details for brevity in this post and focusing on iOS and Android. At a high level, it's pretty simple.Fetches CSVs from the city parks site for the relevant areas we play in using Ktor.Reads them with Okio into a local database using SqlDelight. This is refreshed either manually or after one week.Presents a simple calendar-esque Compose UI with a date picker, \"group\" picker (one park can have multiple fields), and permit events for that date and group.The UI is material3 on Android and mostly Cupertino on iOS. There are a few compose widgets that look out of place on iOS, but for a toy app that very few people will use this is a fine trade off.VersioningAndroid has some baked-in patterns for versioning with BuildConfig, but to make this multiplatform friendly I use a 3rd party gradle-build-config Gradle plugin. This supports generating in KMP projects, generating Kotlin, and other more advanced uses.Version code â€” the app version number. Incremented for every release.Version name â€” the semantic version name, i.e. 1.0.0. Honestly? More just here for show, version code is what really matters.IS_RELEASE â€” a boolean indicating if this is a release build or not. Essentially just to gate crash reporting or debug tools.One important note is that the plugin needs to be configured to generate public symbols, as its default of internal will prevent them from being visible from Swift. This is important later in the iOS section.Platform-specific ComponentsThere are a few platform-specific components in the app.FSAppDirs â€” a simple abstraction API on top of Okio that exposes directories for common locations like user cache, user data, etc.ContextFSAppDirs is an Android implementation that derives these locations from Context.NSFileManagerFSAppDirs is an iOS implementation that derives these locations from NSFileManager.SqlDriverFactory â€” A factory abstraction over creating SqlDelight SqlDriver instances.AndroidSqlDriverFactory is an Android implementation that works on top of Context and returns AndroidSqliteDriver instances.NativeSqlDriverFactory is a native implementation that works on top of SQLiter and returns NativeSqliteDriver instances.Ktor â€” the networking layer. There's no expect/actual needed for this case however, as just adding the appropriate engine dependencies (i.e. OkHttp for Android and Darwin for iOS) is enough for it to automatically init.FSTheme â€” the expect/actual theme entry point. This is only expect/actual'd because Android supports dynamic theming and needs the extra indirection.All of these live in a hand-written FSComponent that acts as a dependency injection component. It's hand-written for now because it's simple. Platform-specific implementations live in an encapsulated SharedPlatformFSComponent that each supply.Compose as an AppThe primary entry point of the app itself is FieldSpottrApp.kt, which is a composable entry point. Unlike your typical Compose samples though, this isn't just UI! This is actually a Circuit app, which means the whole app (including presentation business logic) is also using the compose runtime. This allows for encapsulation of the entire app within a single composable entry point.@Composable fun FieldSpottrApp(component: FSComponent, onRootPop: () -\u003e Unit) { FSTheme { Surface(color = MaterialTheme.colorScheme.background) { val backStack = rememberSaveableBackStack(HomeScreen) val navigator = rememberCircuitNavigator(backStack) { onRootPop() } CircuitCompositionLocals(component.circuit) { ContentWithOverlays { NavigableCircuitContent(navigator = navigator, backStack = backStack) } } } } }This in turn is called into at each platform's canonical entry-point. Each platform is responsible for creating the FSComponent before-hand.// Android class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { // ... val component = (application as FieldSpottrApplication).fsComponent setContent { FieldSpottrApp(component, onRootPop = ::finish) } } }// Kotlin helper in src/iosMain/kotlin // fun makeUiViewController(component: FSComponent): UIViewController = ComposeUIViewController { // FieldSpottrApp(component, onRootPop = {}) // } struct ContentView: View { private let component: FSComponent init() { self.component = FSComponent(shared: IosSharedPlatformFSComponent()) } var body: some View { ComposeView(component: self.component) .ignoresSafeArea(.all, edges: .all) } } struct ComposeView: UIViewControllerRepresentable { private let component: FSComponent init(component: FSComponent) { self.component = component } func makeUIViewController(context _: Context) -\u003e UIViewController { return FSUiViewControllerKt.makeUiViewController(component: component) } }Crash ReportingI've always used Bugsnag in side projects. Big fan, lots of drop-in SDKs. They have SDKs for Android and iOS too. You can create one \"Other Mobile\" type project and publish events from any platform to it, no need for separate projects unless you want to.Privacy PolicyThe Play Store requires this. I generated one using https://app-privacy-policy-generator.firebaseapp.com/ and modifying it as needed. IANAL.PublishingNow the actual hard part â€” publishing. Honestly, most of the reason this blog post exists is for my own reference in the future if I ever have to do this again.AndroidThe developer tooling side of this process isn't too complicated.SigningCreate a signing keyEncrypt it with gpg. You can borrow from the scripts under the release directory in the project, which in turn are based on Chris Banes' scripts in Tivi.Check in the encrypted signing key to the repo. Decrypt it as-necessary for releases.Wire this key into your signing and release configuration.signingConfigs { if (rootProject.file(\"release/app-release.jks\").exists()) { create(\"release\") { storeFile = rootProject.file(\"release/app-release.jks\") storePassword = providers.gradleProperty(\"fs_release_keystore_pwd\").orNull keyAlias = ... keyPassword = providers.gradleProperty(\"fs_release_key_pwd\").orNull } } } buildTypes { maybeCreate(\"release\").apply { // ... signingConfig = signingConfigs.findByName(\"release\") ?: signingConfigs[\"debug\"] } }PackagingEnable app bundles by adding bundle {} to your android configuration block. Surprisingly this isn't enabled by default.Crash ReportingThe Bugsnag Android SDK only works in Android, so you have to configure it manually in androidMain code. In this case - in the app's Application class.Their Gradle plugin (important for uploading R8 mapping files, etc) is easy enough to drop in, but I recommend setting it up to be disabled unless you're cutting a release build. It adds UUIDs to every build that invalidate certain packaging tasks, and the plugin itself appears to be in maintenance mode while they build a new plugin.Play StoreThis is the worst part of the process. The play store's publishing docs are all over the place. Some are several years old, some are buried, some are clearly written by Google APIs people, some are clearly written by Play Store product managers. The console page is overwhelming at best, littered with product up-sells. But, in short, the path looked like this.Make a separate Google account for this. Don't use your personal account, or any other account you care about losing if Google strikes ya.Set up your new app project and go through its preliminary onboarding flows + anything you need to do in the \"Publishing overview\" section.Start a testing track, you can start publishing to this immediately. Under Testing \u003e Internal Testing. There you can create a new release and manually upload .aab files to it.Eventually, you probably want to automate this step with something like Fastlane or the play-publisher Gradle plugin. Here's a helpful link for setting up API access to do so (just skip the parts that involve connecting to PushPay).iOSiOS is a fairly new space to me. I've known basic swift and xcode use for awhile, but never gone seriously through things like KMP apps (not from a shared library like all the KMP docs focus around), crash reporting, publishing, signing, etc.Swift InteropI've found this area of KMP to be surprisingly limited. You can hit platform APIs from Kotlin sources and you can call Kotlin code from Swift, but anything that isn't covered by those two is essentially a dead end.I'm hopeful that Circuit can, at some point, offer APIs that make it easy to use SwiftUI views with shared Circuit presenters. We have a basic sample that does this but it currently requires SwiftUI views to manually instantiate Circuit presenters, sort of breaking the convenience of Circuit's more automatic infra. The lack of bidirectional Swift interop support in KMP at the moment makes doing anything beyond this pretty challenging.Star this: https://youtrack.jetbrains.com/issue/KT-49521Crash ReportingOnce again, Bugsnag comes in here. However, there's an added spin for KMP. Note: I was actually unable to get their iOS SDK working with SPM, so YMMV. The below is what I attempted to do.The short answer is to use CrashKiOS from Touchlab, which nicely papers over all this with tools to help. Their docs are a good runbook for integration with Bugsnag. My configuration ended up like this:// build.gradle.kts plugins { // ... alias(libs.plugins.crashKiosBugsnag) } kotlin { listOf(iosX64(), iosArm64(), iosSimulatorArm64()).forEach { it.binaries.framework { baseName = \"FieldSpottrKt\" // crashKios -\u003e \"co.touchlab.crashkios:bugsnag\" dependency // Important for it to be visible in Swift export(libs.crashKios) } } }// in FieldSpottrApp.swift import SwiftUI import Bugsnag import FieldSpottrKt @main struct FieldSpottrApp: App { init() { // Gate init on our build config if BuildConfig.shared.IS_RELEASE { if let key = BuildConfig.shared.BUGSNAG_NOTIFIER_KEY { // Create a bugsnag config from Bugsnag's framework let config = BugsnagConfiguration(_: key) // Plug it into CrashKiOS's Bugsnag wrapper. This // will start bugsnag under the hood too. BugsnagConfigKt.startBugsnag(config: config) // This is, surprisingly, also necessary and not // implicitly done by the start call above. BugsnagKotlinKt.enableBugsnag() } } } // ... }BuildingBuilding in regular development is usually done through Xcode. As long as you do the usual setup from the KMP docs, you should be set up. It is a fairly opaque system though, so debugging build issues can be tedious. Especially as Xcode seems fairly reluctant to make this button actually do anything.Compose Multiplatform UITo make the iOS app look a little more native, I opted to use the compose-cupertino project to adaptively render UIs per-platform and Calf to bridge to native components like bottom sheets as needed. They work well enough for a simple app like this, though I'm not sure they're mature enough yet to recommend for a serious project as they has no tests. The calf maintainer is very responsive though, the compose-cupertino issue tracker sees acknowledgement though and multiple components are broken. My hope is that JetBrains tries to fill this space long term with first party APIs.Native DatePicker and bottom sheet components on each platform (Android left, iOS right)In some cases, Skiko components that came with Compose UI on iOS were just bad and unstable for use. Namely â€” modals like dialogs or bottom sheets were inconsistent at best and crashed at worst. For these cases, I found myself opting for just simple navigation instead (Circuit lends itself well to this!), but I'd love to see more attention in Compose UI to making these components' inner UIs more reusable without the cruft of the popup/window/dialog system.PublishingJust use Fastlane + match. An interesting pattern I noticed when talking to iOS friends is that they always mention adding things to Info.plist, a file that is no longer generated in newer Xcode projects and appears to act similarly to AndroidManifest.xml.Set up match. This helps set up all your certificates and signing.Note when using GitHub for storage, it appears to hardcode the branch to master and you should handle this.How to setup Fastlane and Match to release iOS apps automatically on CI/CD serverIn this article Iâ€™ll be telling how this workflow should work both locally and on a CD server and what variables you should keep securetech.reveloDouglas IacovelliHow to setup Fastlane and Match to release iOS apps automatically on CI/CD serverIn this article Iâ€™ll be telling how this workflow should work both locally and on a CD server and what variables you should keep securetech.reveloDouglas Iacovellimatch - fastlane docsfastlane docsfastlane teamBig thank you to Ben Pious and Alan Zeino for humoring a million questions about Xcode. Big thanks also to Chris Banes for helping me with all the Fastlane/match/iOS publishing madness.",
  "image": "https://www.zacsweers.dev/content/images/2024/07/play_store_feature_graphic.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eI recently wrote a little toy app for my pickup soccer group to check field permit statuses. In New York City most public parks\u0026#39; fields can be reserved or have recurring permits, so we have to check if fields are going to be in use before we try to organize games. The city parks website has this information, but it\u0026#39;s a little awkward to use. They also have all permit information available in downloadable CSV files, which got me thinking I could just write my own little app. The rest of this post is notes about the process, things I used, things I learned, and hopefully some helpful references for myself and anyone else doing this in the future.\u003c/p\u003e\u003ch2 id=\"fieldspottr\"\u003eFieldSpottr\u003c/h2\u003e\u003cp\u003eI wrote the app! It\u0026#39;s called \u003cstrong\u003eField Spottr\u003c/strong\u003e, and it\u0026#39;s \u003ca href=\"https://github.com/zacsweers/fieldspottr?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eopen source\u003c/a\u003e. I wrote it with Kotlin Multiplatform, Compose, and \u003ca href=\"https://github.com/slackhq/circuit?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eCircuit\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eYou can also download it on the \u003ca href=\"https://apps.apple.com/us/app/field-spottr/id6505042655?ref=zacsweers.dev\"\u003eApp Store\u003c/a\u003e or \u003ca href=\"https://play.google.com/store/apps/details?id=dev.zacsweers.fieldspottr\u0026amp;ref=zacsweers.dev\"\u003ePlay Store\u003c/a\u003e. Note that this is really only useful for myself and the friends I play soccer with ðŸ˜„.\u003c/p\u003e\u003cfigure data-kg-thumbnail=\"https://www.zacsweers.dev/content/media/2024/08/output_thumb.jpg\" data-kg-custom-thumbnail=\"\"\u003e\n            \u003cdiv\u003e\n                \u003cvideo src=\"https://www.zacsweers.dev/content/media/2024/08/output.mp4\" poster=\"https://img.spacergif.org/v1/1178x2556/0a/spacer.png\" width=\"1178\" height=\"2556\" loop=\"\" autoplay=\"\" muted=\"\" playsinline=\"\" preload=\"metadata\"\u003e\u003c/video\u003e\n                \n                \u003cdiv\u003e\n                        \u003cp\u003e\n                        \n                        \u003cspan\u003e0:00\u003c/span\u003e\u003c/p\u003e\u003cp\u003e\n                            /\u003cspan\u003e0:08\u003c/span\u003e\n                        \u003c/p\u003e\n                        \u003c/div\u003e\n            \u003c/div\u003e\n            \u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eVideo walk through of the app\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\n        \u003cimg src=\"https://www.zacsweers.dev/content/media/2024/08/output_thumb.jpg\"/\u003e\u003c/figure\u003e\u003cp\u003eThe app technically supports Desktop too, but I\u0026#39;m omitting those details for brevity in this post and focusing on iOS and Android. At a high level, it\u0026#39;s pretty simple.\u003c/p\u003e\u003cul\u003e\u003cli\u003eFetches CSVs from the city parks site for the relevant areas we play in using Ktor.\u003c/li\u003e\u003cli\u003eReads them with Okio into a local database using SqlDelight. This is refreshed either manually or after one week.\u003c/li\u003e\u003cli\u003ePresents a simple calendar-esque Compose UI with a date picker, \u0026#34;group\u0026#34; picker (one park can have multiple fields), and permit events for that date and group.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe UI is material3 on Android and \u003cem\u003emostly\u003c/em\u003e Cupertino on iOS. There are a few compose widgets that look out of place on iOS, but for a toy app that very few people will use this is a fine trade off.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eVersioning\u003c/strong\u003e\u003cbr/\u003eAndroid has some baked-in patterns for versioning with BuildConfig, but to make this multiplatform friendly I use a 3rd party \u003ca href=\"https://github.com/gmazzo/gradle-buildconfig-plugin?ref=zacsweers.dev\"\u003egradle-build-config\u003c/a\u003e Gradle plugin. This supports generating in KMP projects, generating Kotlin, and other more advanced uses.\u003c/p\u003e\u003cul\u003e\u003cli\u003eVersion code â€” the app version number. Incremented for every release.\u003c/li\u003e\u003cli\u003eVersion name â€” the semantic version name, i.e. \u003ccode\u003e1.0.0\u003c/code\u003e. Honestly? More just here for show, version code is what really matters.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eIS_RELEASE\u003c/code\u003e â€” a boolean indicating if this is a release build or not. Essentially just to gate crash reporting or debug tools.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOne important note is that the plugin needs to be configured to generate \u003ccode\u003epublic\u003c/code\u003e symbols, as its default of \u003ccode\u003einternal\u003c/code\u003e will prevent them from being visible from Swift. This is important later in the iOS section.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePlatform-specific Components\u003c/strong\u003e\u003cbr/\u003eThere are a few platform-specific components in the app.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eFSAppDirs\u003c/code\u003e â€” a simple abstraction API on top of Okio that exposes directories for common locations like user cache, user data, etc.\u003cul\u003e\u003cli\u003e\u003ccode\u003eContextFSAppDirs\u003c/code\u003e is an Android implementation that derives these locations from \u003ccode\u003eContext\u003c/code\u003e.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eNSFileManagerFSAppDirs\u003c/code\u003e is an iOS implementation that derives these locations from \u003ccode\u003eNSFileManager\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003eSqlDriverFactory\u003c/code\u003e â€” A factory abstraction over creating SqlDelight \u003ccode\u003eSqlDriver\u003c/code\u003e instances.\u003cul\u003e\u003cli\u003e\u003ccode\u003eAndroidSqlDriverFactory\u003c/code\u003e is an Android implementation that works on top of \u003ccode\u003eContext\u003c/code\u003e and returns \u003ccode\u003eAndroidSqliteDriver\u003c/code\u003e instances.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eNativeSqlDriverFactory\u003c/code\u003e is a \u003ccode\u003enative\u003c/code\u003e implementation that works on top of \u003ca href=\"https://github.com/touchlab/SQLiter?ref=zacsweers.dev\"\u003eSQLiter\u003c/a\u003e and returns \u003ccode\u003eNativeSqliteDriver\u003c/code\u003e instances.\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eKtor â€” the networking layer. There\u0026#39;s no expect/actual needed for this case however, as just adding the appropriate engine dependencies (i.e. OkHttp for Android and Darwin for iOS) is enough for it to automatically init.\u003c/li\u003e\u003cli\u003e\u003ccode\u003eFSTheme\u003c/code\u003e â€” the expect/actual theme entry point. This is only expect/actual\u0026#39;d because Android supports dynamic theming and needs the extra indirection.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAll of these live in a hand-written \u003ccode\u003eFSComponent\u003c/code\u003e that acts as a dependency injection component. It\u0026#39;s hand-written for now because it\u0026#39;s simple. Platform-specific implementations live in an encapsulated \u003ccode\u003eSharedPlatformFSComponent\u003c/code\u003e that each supply.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCompose as an App\u003c/strong\u003e\u003cbr/\u003eThe primary entry point of the app itself is \u003ccode\u003eFieldSpottrApp.kt\u003c/code\u003e, which is a composable entry point. Unlike your typical Compose samples though, this isn\u0026#39;t \u003cem\u003ejust\u003c/em\u003e UI! This is actually a Circuit app, which means the whole app (including presentation business logic) is also using the compose runtime. This allows for encapsulation of the entire app within a single composable entry point.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Composable\nfun FieldSpottrApp(component: FSComponent, onRootPop: () -\u0026gt; Unit) {\n  FSTheme {\n    Surface(color = MaterialTheme.colorScheme.background) {\n      val backStack = rememberSaveableBackStack(HomeScreen)\n      val navigator = rememberCircuitNavigator(backStack) { onRootPop() }\n      CircuitCompositionLocals(component.circuit) {\n        ContentWithOverlays {\n          NavigableCircuitContent(navigator = navigator, backStack = backStack)\n        }\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis in turn is called into at each platform\u0026#39;s canonical entry-point. Each platform is responsible for creating the \u003ccode\u003eFSComponent\u003c/code\u003e before-hand.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Android\nclass MainActivity : AppCompatActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    // ...\n    val component = (application as FieldSpottrApplication).fsComponent\n    setContent { FieldSpottrApp(component, onRootPop = ::finish) }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e// Kotlin helper in src/iosMain/kotlin\n// fun makeUiViewController(component: FSComponent): UIViewController = ComposeUIViewController {\n//   FieldSpottrApp(component, onRootPop = {})\n// }\n\nstruct ContentView: View {\n    private let component: FSComponent\n\n    init() {\n        self.component = FSComponent(shared: IosSharedPlatformFSComponent())\n    }\n\n    var body: some View {\n        ComposeView(component: self.component)\n            .ignoresSafeArea(.all, edges: .all)\n    }\n}\n\nstruct ComposeView: UIViewControllerRepresentable {\n    private let component: FSComponent\n\n    init(component: FSComponent) {\n        self.component = component\n    }\n\n    func makeUIViewController(context _: Context) -\u0026gt; UIViewController {\n        return FSUiViewControllerKt.makeUiViewController(component: component)\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eCrash Reporting\u003c/strong\u003e\u003cbr/\u003eI\u0026#39;ve always used Bugsnag in side projects. Big fan, lots of drop-in SDKs. They have SDKs for Android and iOS too. You can create one \u0026#34;Other Mobile\u0026#34; type project and publish events from any platform to it, no need for separate projects unless you want to.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePrivacy Policy\u003c/strong\u003e\u003cbr/\u003eThe Play Store requires this. I generated one using \u003ca href=\"https://app-privacy-policy-generator.firebaseapp.com/?ref=zacsweers.dev\"\u003ehttps://app-privacy-policy-generator.firebaseapp.com/\u003c/a\u003e and modifying it as needed. IANAL.\u003c/p\u003e\u003ch2 id=\"publishing\"\u003ePublishing\u003c/h2\u003e\u003cp\u003eNow the actual hard part â€” publishing. Honestly, most of the reason this blog post exists is for my own reference in the future if I ever have to do this again.\u003c/p\u003e\u003ch2 id=\"android\"\u003eAndroid\u003c/h2\u003e\u003cp\u003eThe developer tooling side of this process isn\u0026#39;t too complicated.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSigning\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003eCreate a signing key\u003c/li\u003e\u003cli\u003eEncrypt it with gpg. You can borrow from the scripts under the \u003ccode\u003erelease\u003c/code\u003e directory in the project, which in turn are based on Chris Banes\u0026#39; scripts in \u003ca href=\"https://github.com/chrisbanes/tivi?ref=zacsweers.dev\" rel=\"noreferrer\"\u003eTivi\u003c/a\u003e.\u003c/li\u003e\u003cli\u003eCheck in the \u003cstrong\u003eencrypted\u003c/strong\u003e signing key to the repo. Decrypt it as-necessary for releases.\u003c/li\u003e\u003cli\u003eWire this key into your signing and release configuration.\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003esigningConfigs {\n  if (rootProject.file(\u0026#34;release/app-release.jks\u0026#34;).exists()) {\n    create(\u0026#34;release\u0026#34;) {\n      storeFile = rootProject.file(\u0026#34;release/app-release.jks\u0026#34;)\n      storePassword = providers.gradleProperty(\u0026#34;fs_release_keystore_pwd\u0026#34;).orNull\n      keyAlias = ...\n      keyPassword = providers.gradleProperty(\u0026#34;fs_release_key_pwd\u0026#34;).orNull\n    }\n  }\n}\n\nbuildTypes {\n  maybeCreate(\u0026#34;release\u0026#34;).apply {\n    // ...\n    signingConfig = signingConfigs.findByName(\u0026#34;release\u0026#34;) ?: signingConfigs[\u0026#34;debug\u0026#34;]\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003ePackaging\u003c/strong\u003e\u003cbr/\u003eEnable app bundles by adding \u003ccode\u003ebundle {}\u003c/code\u003e to your android configuration block. Surprisingly this isn\u0026#39;t enabled by default.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCrash Reporting\u003c/strong\u003e\u003cbr/\u003eThe Bugsnag Android SDK only works in Android, so you have to configure it manually in \u003ccode\u003eandroidMain\u003c/code\u003e code. In this case - in the app\u0026#39;s \u003ccode\u003eApplication\u003c/code\u003e class.\u003c/p\u003e\u003cp\u003eTheir Gradle plugin (important for uploading R8 mapping files, etc) is easy enough to drop in, but I recommend setting it up to be disabled unless you\u0026#39;re cutting a release build. It adds UUIDs to every build that invalidate certain packaging tasks, and the plugin itself appears to be in maintenance mode while they build a new plugin.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePlay Store\u003c/strong\u003e\u003cbr/\u003eThis is the worst part of the process. The play store\u0026#39;s publishing docs are all over the place. Some are several years old, some are buried, some are clearly written by Google APIs people, some are clearly written by Play Store product managers. The console page is overwhelming at best, littered with product up-sells. But, in short, the path looked like this.\u003c/p\u003e\u003cul\u003e\u003cli\u003eMake a separate Google account for this. Don\u0026#39;t use your personal account, or any other account you care about losing if Google strikes ya.\u003c/li\u003e\u003cli\u003eSet up your new app project and go through its preliminary onboarding flows + anything you need to do in the \u0026#34;Publishing overview\u0026#34; section.\u003c/li\u003e\u003cli\u003eStart a testing track, you can start publishing to this immediately. Under Testing \u0026gt; Internal Testing. There you can create a new release and manually upload .aab files to it.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eEventually, you probably want to automate this step with something like Fastlane or the play-publisher Gradle plugin. Here\u0026#39;s a \u003ca href=\"https://support.pushpay.com/s/article/Setting-up-your-Google-Publishing-API?ref=zacsweers.dev\"\u003ehelpful link\u003c/a\u003e for setting up API access to do so (just skip the parts that involve connecting to PushPay).\u003c/p\u003e\u003ch2 id=\"ios\"\u003eiOS\u003c/h2\u003e\u003cp\u003eiOS is a fairly new space to me. I\u0026#39;ve known basic swift and xcode use for awhile, but never gone seriously through things like KMP apps (not from a \u003ccode\u003eshared\u003c/code\u003e library like all the KMP docs focus around), crash reporting, publishing, signing, etc.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSwift Interop\u003c/strong\u003e\u003cbr/\u003eI\u0026#39;ve found this area of KMP to be surprisingly limited. You can hit platform APIs from Kotlin sources and you can call Kotlin code from Swift, but anything that isn\u0026#39;t covered by those two is essentially a dead end.\u003c/p\u003e\u003cp\u003eI\u0026#39;m hopeful that Circuit can, at some point, offer APIs that make it easy to use SwiftUI views with shared Circuit presenters. We have a basic sample that does this but it currently requires SwiftUI views to manually instantiate Circuit presenters, sort of breaking the convenience of Circuit\u0026#39;s more automatic infra. The lack of bidirectional Swift interop support in KMP at the moment makes doing anything beyond this pretty challenging.\u003c/p\u003e\u003cp\u003eStar this: \u003ca href=\"https://youtrack.jetbrains.com/issue/KT-49521/?ref=zacsweers.dev\"\u003ehttps://youtrack.jetbrains.com/issue/KT-49521\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCrash Reporting\u003c/strong\u003e\u003cbr/\u003eOnce again, Bugsnag comes in here. However, there\u0026#39;s an added spin for KMP. \u003c/p\u003e\u003cblockquote\u003e\u003cem\u003eNote: I was actually unable to get their iOS SDK working with SPM, so YMMV. The below is what I attempted to do.\u003c/em\u003e\u003c/blockquote\u003e\u003cp\u003eThe short answer is to use CrashKiOS from Touchlab, which nicely papers over all this with tools to help. Their \u003ca href=\"https://crashkios.touchlab.co/docs/bugsnag?ref=zacsweers.dev\"\u003edocs\u003c/a\u003e are a good runbook for integration with Bugsnag. My configuration ended up like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// build.gradle.kts\nplugins {\n  // ...\n  alias(libs.plugins.crashKiosBugsnag)\n}\n\nkotlin {\n  listOf(iosX64(), iosArm64(), iosSimulatorArm64()).forEach {\n    it.binaries.framework {\n      baseName = \u0026#34;FieldSpottrKt\u0026#34;\n      // crashKios -\u0026gt; \u0026#34;co.touchlab.crashkios:bugsnag\u0026#34; dependency\n      // Important for it to be visible in Swift\n      export(libs.crashKios)\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e// in FieldSpottrApp.swift\nimport SwiftUI\nimport Bugsnag\nimport FieldSpottrKt\n\n@main\nstruct FieldSpottrApp: App {\n    init() {\n        // Gate init on our build config\n        if BuildConfig.shared.IS_RELEASE {\n            if let key = BuildConfig.shared.BUGSNAG_NOTIFIER_KEY {\n                // Create a bugsnag config from Bugsnag\u0026#39;s framework\n                let config = BugsnagConfiguration(_: key)\n\n                // Plug it into CrashKiOS\u0026#39;s Bugsnag wrapper. This\n                // will start bugsnag under the hood too.\n                BugsnagConfigKt.startBugsnag(config: config)\n                // This is, surprisingly, also necessary and not \n                // implicitly done by the start call above.\n                BugsnagKotlinKt.enableBugsnag()\n            }\n        }\n    }\n    // ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eBuilding\u003c/strong\u003e\u003cbr/\u003eBuilding in regular development is usually done through Xcode. As long as you do the usual setup from the KMP docs, you should be set up. It is a fairly opaque system though, so debugging build issues can be tedious. Especially as Xcode seems fairly reluctant to make this button actually do anything.\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/07/image.png\" alt=\"A screenshot from Xcode of a dropdown menu highlighting \u0026#34;Reveal in Log\u0026#34;\" loading=\"lazy\" width=\"742\" height=\"716\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/07/image.png 600w, https://www.zacsweers.dev/content/images/2024/07/image.png 742w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eCompose Multiplatform UI\u003c/strong\u003e\u003cbr/\u003eTo make the iOS app look a little more native, I opted to use the \u003ca href=\"https://github.com/alexzhirkevich/compose-cupertino?ref=zacsweers.dev\"\u003ecompose-cupertino\u003c/a\u003e project to adaptively render UIs per-platform and \u003ca href=\"https://github.com/MohamedRejeb/Calf?ref=zacsweers.dev\"\u003eCalf\u003c/a\u003e to bridge to native components like bottom sheets as needed. They work well enough for a simple app like this, though I\u0026#39;m not sure they\u0026#39;re mature enough yet to recommend for a serious project as they has no tests. The calf maintainer is very responsive though, the compose-cupertino issue tracker sees acknowledgement though and multiple components are broken. My hope is that JetBrains tries to fill this space long term with first party APIs.\u003c/p\u003e\u003cfigure\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/08/Screenshot_20240825_163406.png\" width=\"1469\" height=\"3104\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/08/Screenshot_20240825_163406.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2024/08/Screenshot_20240825_163406.png 1000w, https://www.zacsweers.dev/content/images/2024/08/Screenshot_20240825_163406.png 1469w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/08/image-2.png\" width=\"1179\" height=\"2556\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/08/image-2.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2024/08/image-2.png 1000w, https://www.zacsweers.dev/content/images/2024/08/image-2.png 1179w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/08/Screenshot_20240825_163334-1.png\" width=\"1469\" height=\"3104\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/08/Screenshot_20240825_163334-1.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2024/08/Screenshot_20240825_163334-1.png 1000w, https://www.zacsweers.dev/content/images/2024/08/Screenshot_20240825_163334-1.png 1469w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.zacsweers.dev/content/images/2024/08/Simulator-Screenshot---iPhone-15-Pro---2024-08-25-at-16.40.00-1.png\" width=\"1179\" height=\"2556\" loading=\"lazy\" alt=\"\" srcset=\"https://www.zacsweers.dev/content/images/size/w600/2024/08/Simulator-Screenshot---iPhone-15-Pro---2024-08-25-at-16.40.00-1.png 600w, https://www.zacsweers.dev/content/images/size/w1000/2024/08/Simulator-Screenshot---iPhone-15-Pro---2024-08-25-at-16.40.00-1.png 1000w, https://www.zacsweers.dev/content/images/2024/08/Simulator-Screenshot---iPhone-15-Pro---2024-08-25-at-16.40.00-1.png 1179w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigcaption\u003e\u003cp\u003e\u003cspan\u003eNative DatePicker and bottom sheet components on each platform (Android left, iOS right)\u003c/span\u003e\u003c/p\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIn some cases, Skiko components that came with Compose UI on iOS were just bad and unstable for use. Namely â€” modals like dialogs or bottom sheets were inconsistent at best and crashed at worst. For these cases, I found myself opting for just simple navigation instead (Circuit lends itself well to this!), but I\u0026#39;d love to see more attention in Compose UI to making these components\u0026#39; inner UIs more reusable without the cruft of the popup/window/dialog system.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePublishing\u003c/strong\u003e\u003cbr/\u003eJust use Fastlane + match. An interesting pattern I noticed when talking to iOS friends is that they always mention adding things to \u003ccode\u003eInfo.plist\u003c/code\u003e, a file that is no longer generated in newer Xcode projects and appears to act similarly to \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eSet up \u003ccode\u003ematch\u003c/code\u003e. This helps set up all your certificates and signing.\u003c/p\u003e\u003cblockquote\u003eNote when using GitHub for storage, it appears to hardcode the branch to \u003ccode\u003emaster\u003c/code\u003e and you should handle this.\u003c/blockquote\u003e\u003cfigure\u003e\u003ca href=\"https://medium.com/revelo-tech/setting-up-automatic-ios-release-with-fastlane-and-match-on-ci-cd-server-16c3f1d79bc5?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003eHow to setup Fastlane and Match to release iOS apps automatically on CI/CD server\u003c/p\u003e\u003cp\u003eIn this article Iâ€™ll be telling how this workflow should work both locally and on a CD server and what variables you should keep secure\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://cdn-static-1.medium.com/_/fp/icons/Medium-Avatar-500x500.svg\" alt=\"\"/\u003e\u003cspan\u003etech.revelo\u003c/span\u003e\u003cspan\u003eDouglas Iacovelli\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*rIKqod2aGEjiRsytPR3OLQ.jpeg\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cfigure\u003e\u003ca href=\"https://medium.com/revelo-tech/setting-up-automatic-ios-release-with-fastlane-and-match-on-ci-cd-server-16c3f1d79bc5?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003eHow to setup Fastlane and Match to release iOS apps automatically on CI/CD server\u003c/p\u003e\u003cp\u003eIn this article Iâ€™ll be telling how this workflow should work both locally and on a CD server and what variables you should keep secure\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://cdn-static-1.medium.com/_/fp/icons/Medium-Avatar-500x500.svg\" alt=\"\"/\u003e\u003cspan\u003etech.revelo\u003c/span\u003e\u003cspan\u003eDouglas Iacovelli\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*rIKqod2aGEjiRsytPR3OLQ.jpeg\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003cfigure\u003e\u003ca href=\"https://docs.fastlane.tools/actions/match/?ref=zacsweers.dev\"\u003e\u003cdiv\u003e\u003cp\u003ematch - fastlane docs\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://docs.fastlane.tools/img/favicon.ico\" alt=\"\"/\u003e\u003cspan\u003efastlane docs\u003c/span\u003e\u003cspan\u003efastlane team\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003cimg src=\"https://docs.fastlane.tools/img/actions/match.png\" alt=\"\" onerror=\"this.style.display = \u0026#39;none\u0026#39;\"/\u003e\u003c/p\u003e\u003c/a\u003e\u003c/figure\u003e\u003chr/\u003e\u003cp\u003e\u003cem\u003eBig thank you to Ben Pious and Alan Zeino for humoring a million questions about Xcode. Big thanks also to Chris Banes for helping me with all the Fastlane/match/iOS publishing madness.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2024-08-25T20:57:51Z",
  "modifiedTime": "2024-09-09T15:48:14Z"
}
