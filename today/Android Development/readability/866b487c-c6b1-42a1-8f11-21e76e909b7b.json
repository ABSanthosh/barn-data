{
  "id": "866b487c-c6b1-42a1-8f11-21e76e909b7b",
  "title": "Optimizing UUID Storage in SQLDelight: Text vs. Two Longs and a Look Ahead at UUID v7",
  "link": "https://proandroiddev.com/optimizing-uuid-storage-in-sqldelight-text-vs-two-longs-and-a-look-ahead-at-uuid-v7-59c24986a866?source=rss----c72404660798---4",
  "description": "",
  "author": "Kerry Bisset",
  "published": "Sun, 08 Dec 2024 03:48:55 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "sql",
    "software-development",
    "kotlin",
    "kotlin-multiplatform"
  ],
  "byline": "Kerry Bisset",
  "length": 18426,
  "excerpt": "Primary keys are fundamental to maintaining data integrity and enabling efficient data retrieval. They uniquely identify each record in a table, ensuring no duplicate entries exist and that…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Primary keys are fundamental to maintaining data integrity and enabling efficient data retrieval. They uniquely identify each record in a table, ensuring no duplicate entries exist and that relationships between tables can be accurately established. Traditionally, primary keys have been simple numerical identifiers. However, as systems have evolved — especially distributed systems — the need for more robust and globally unique identifiers has emerged.Universally Unique Identifiers (UUIDs) address this need. UUIDs are 128-bit values designed to be unique across different systems and times, making them ideal for distributed environments where multiple nodes might generate identifiers independently. Version 4 UUIDs (UUID v4), in particular, are randomly generated, providing a high degree of uniqueness without relying on a central authority or coordination between nodes.Using UUIDs as primary keys in Kotlin applications that interact with databases presents certain challenges, especially when utilizing libraries like SQLDelight. SQLDelight is a powerful tool that generates type-safe Kotlin APIs from SQL queries but does not natively support a UUID column type. This limitation forces developers to decide on the most effective way to store UUIDs in their SQLDelight schemas.This article examines two primary methods of storing UUID v4 values in a SQLDelight-managed database:Storing UUIDs as Text: This straightforward approach involves saving the UUID as a string in a TEXT column. It leverages the human-readable format of UUIDs, simplifying debugging and logging processes.Storing UUIDs as Two Longs: A more space-efficient method involves splitting the UUID into its most significant bits (MSB) and least significant bits (LSB), each stored in separate BIGINT (Long) columns. This approach can offer performance benefits but introduces additional complexity in handling the UUID data.The following sections explore each method's implementation details, advantages, and disadvantages. A performance comparison is included to assist in making an informed decision based on specific application needs. While UUID v7 promises to address some of these challenges with time-based ordering and improved performance, it has yet to be widely supported, making UUID v4 the current standard in many applications.Understanding UUID v4 and Kotlin.UUIDWhat Is UUID v4?A Universally Unique Identifier (UUID) is a 128-bit number used to identify information in computer systems uniquely. Standardized by the Open Software Foundation (OSF) as part of the Distributed Computing Environment (DCE), UUIDs are essential for ensuring that identifiers are unique within a single system and across multiple systems worldwide.Version 4 UUIDs (UUID v4) are generated using random numbers. This randomness provides a very low probability of generating duplicate UUIDs, making them ideal for applications that require unique identifiers without central coordination. A typical UUID v4 is represented as a string of five groups of hexadecimal digits separated by hyphens, following the pattern 8–4–4–4–12. For example:f47ac10b-58cc-4372-a567-0e02b2c3d479The structure of a UUID v4 is as follows:Time Low (8 hexadecimal digits): Randomly generated.Time Mid (4 hexadecimal digits): Randomly generated.Time High and Version (4 hexadecimal digits): The first 12 bits are random, and the next 4 bits represent the version (0100 for version 4).Clock Sequence (4 hexadecimal digits): The first 2 bits are variant bits, and the remaining 14 bits are random.Node (12 hexadecimal digits): Randomly generated.UUIDs allow systems to generate unique identifiers independently, reducing the need for centralized ID generation mechanisms and minimizing the risk of identifier collisions in distributed environments.Generating a UUID v4 in Kotlin (Since Kotlin 2.0)val uuid = Uuid.random()Accessing UUID ComponentsEach UUID consists of two 64-bit numbers:Most Significant Bits (MSB): The first 64 bits of the UUID.Least Significant Bits (LSB): The last 64 bits of the UUID.In Kotlin, these can be accessed as follows:val key = uuid.toLongs { msb, lsb -\u003e // Do something with the components }These components are crucial when considering alternative storage methods, such as storing the UUID as two BIGINT (Long) values in a database.Reconstructing a UUID from MSB and LSBTo reconstruct a UUID from its most and least significant bits: Uuid.fromLongs(msb, lsb)Challenges with UUIDs in Kotlin and SQLDelightWhile Kotlin’s interoperability with Java provides robust UUID handling, integrating UUIDs with SQLDelight requires additional considerations:No Native UUID Type in SQLDelight: SQLDelight does not support a UUID column type out of the box, necessitating alternative storage solutions.Data Type Mapping: Deciding whether to store UUIDs as TEXT strings or split them into numeric types affects performance and complexity.Serialization and Deserialization: Converting UUIDs to and from the chosen storage format adds overhead and potential points of failure if not handled correctly.Option 1: Storing UUIDs as TextSQLDelight SchemaThe SQLDelight schema defines the player table, where the id the column is of type TEXT and serves as the primary key. The schema also includes several queries for interacting with the data:CREATE TABLE IF NOT EXISTS player ( id TEXT NOT NULL PRIMARY KEY, name TEXT NOT NULL, age INTEGER AS Int NOT NULL);Here:id is a TEXT field that stores the UUID as a string.name and age are additional fields to store player data.The schema also provides queries for inserting, retrieving, and managing players.RepositoryThe PlayerRepository the class provides functions to interact with the player table.class PlayerRepository(private val queries: PlayerQueries) { suspend fun insertPlayer(players: Players) { queries.storePlayer(players.uuid.toString(), players.name, players.age) } suspend fun getPlayer(id: Uuid): Players? { return queries.getPlayers(id.toString()).executeAsOneOrNull()?.let { Players(id, it.name, it.age) } } suspend fun getAllPlayers(): List\u003cPlayers\u003e { return queries.getAllPlayers().executeAsList().map { Players(Uuid.parse(it.id), it.name, it.age) } } suspend fun getRandomPlayer(): Players? { return queries.getRandomPlayer().executeAsOneOrNull()?.let { Players(Uuid.parse(it.id), it.name, it.age) } }}AdvantagesEase of Implementation:Directly storing UUIDs as strings is straightforward and does not require additional complexity in the schema or repository.Human-Readable:UUIDs stored as text are easy to debug and analyze directly in the database.Compatibility:Most databases and tools natively support string-based fields, making this method universally compatible.DrawbacksStorage Overhead:A UUID stored as text uses 36 characters, consuming more space compared to numeric representations like two BIGINT columns.Performance Impact:String-based queries, indexing, and comparisons are slower than operations on numeric fields.Conversion Overhead:The repository must handle conversions between UUID and TEXT For every database operation, additional processing overhead is introduced.However, for applications requiring high performance or handling large datasets, alternative methods like storing UUIDs as two LONG columns may be more appropriate.Option 2: Storing UUIDs as Two LongsStoring UUIDs as two LONG columns involves splitting the UUID into its Most Significant Bits (MSB) and Least Significant Bits (LSB). This approach is designed to optimize storage and query performance while maintaining the uniqueness and functionality of UUIDs.SQLDelight SchemaThe schema for the playerTwo table uses two INTEGER columns to store the MSB and LSB, with the combination of these columns serving as the primary key:CREATE TABLE IF NOT EXISTS playerTwo ( msBit INTEGER NOT NULL, lsBit INTEGER NOT NULL, name TEXT NOT NULL, age INTEGER AS Int NOT NULL, PRIMARY KEY (msBit, lsBit));Here:msBit and lsBit store the 64-bit parts of the UUID.name and age hold additional player data.The combination of msBit and lsBit ensures uniqueness.RepositoryThe Player2Repository class facilitates interaction with the playerTwo table and handles the conversion between UUID objects and their split components (msb and lsb).class Player2Repository(private val queries: Player2Queries) { suspend fun insertPlayer(players: Players) { val key = players.uuid.toLongs { msb, lsb -\u003e UuidKey(msb, lsb) } queries.storePlayerTwo(key.msb, key.lsb, players.name, players.age) } suspend fun getPlayer(id: Uuid): Players? { val key = id.toLongs { msb, lsb -\u003e UuidKey(msb, lsb) } return queries.getPlayersTwo(key.msb, key.lsb).executeAsOneOrNull()?.let { Players(id, it.name, it.age) } } suspend fun getAllPlayers(): List\u003cPlayers\u003e { return queries.getAllPlayersTwo().executeAsList().map { Players(UuidKey(it.msBit, it.lsBit).toUuid(), it.name, it.age) } } data class UuidKey(val msb: Long, val lsb: Long) { fun toUuid(): Uuid { return Uuid.fromLongs(msb, lsb) } }}AdvantagesStorage Efficiency:UUIDs stored as two BIGINT columns use less space compared to their string representation (TEXT), reducing overall database size.Improved Query Performance:Numeric fields are faster to compare and index than text fields, leading to better query performance, especially in large datasets.Compatibility with Numeric Indexing:Leveraging indexes on msBit and lsBit improves the speed of lookups and range-based queries.DrawbacksIncreased Complexity:Splitting and reconstructing UUIDs adds complexity to the application code and repository layer.Debugging Challenges:MSB and LSB values are less intuitive for debugging than human-readable UUID strings.Potential for Errors:Incorrect handling of MSB and LSB during storage or retrieval could lead to invalid UUID reconstruction.Hypothesis Results: Performance ComparisonThe hypothesis tests aim to evaluate the performance of two different UUID storage methods in SQLDelight: storing UUIDs as TEXT and storing them as two BIGINT columns (MSB and LSB). The tests measure retrieval speed and assess the overhead of each approach.Experimental SetupData Insertion:Insert a large dataset of 25,000 player records into both repositories (playerRepository using TEXT storage and player2Repository using two BIGINT columns).Each record includes:A randomly generated UUID.A randomly generated name composed of two random first names.A random age between 18 and 99. init { viewModelScope.launch(Dispatchers.IO + CoroutineExceptionHandler { _, throwable -\u003e println(\"An error occurred: ${throwable.localizedMessage}\") }) { if (playerRepository.getPlayer(initialUuid) == null) { println(\"Player not found, inserting dummy data.\") playerRepository.insertPlayer(Players(initialUuid, \"John Doe\", 25)) player2Repository.insertPlayer(Players(initialUuid, \"John Doe\", 25)) for (i in 0..25000) { val uuid = Uuid.random() val age = Random(11) val players = Players( uuid, \"${CommonFirstNames.getRandom()} ${CommonFirstNames.getRandom()}\", age.nextInt(18, 99) ) playerRepository.insertPlayer(players) player2Repository.insertPlayer(players) } println(\"Data insertion completed.\") withContext(Dispatchers.Main) { speedTestReady.value = true } } else { println(\"Player already exists, skipping insertion.\") withContext(Dispatchers.Main) { speedTestReady.value = true } } } }Speed Test:Retrieve players randomly 1,000 times in a loop for each repository.Measure retrieval time in nanoseconds for each query and convert it to milliseconds for readability.Average the results across 500 runs.MainInteraction.RunSpeedTest -\u003e { viewModelScope.launch(Dispatchers.Default) { for (i in 0..500) { var playerOneTimeInMillis = 0.0 var playerTwoTimeInMillis = 0.0 for (i in 0..1000) { val values = playerRepository.getRandomPlayer()?.uuid ?: initialUuid //Measure the time it takes to get a player from the first repository in nanoseconds // and convert it to milliseconds playerOneTimeInMillis += measureNanoTime { playerRepository.getPlayer(values) } / 1_000_000.0 playerTwoTimeInMillis += measureNanoTime { player2Repository.getPlayer(values) } / 1_000_000.0 } withContext(Dispatchers.Main) { playerOneRepoTime.value = playerOneTimeInMillis playerTwoRepoTime.value = playerTwoTimeInMillis println(\"Time 1, $playerOneTimeInMillis , Time 2, $playerTwoTimeInMillis\") } } } } }Metrics Captured:Average retrieval time for playerRepository.Average retrieval time for player2Repository.Expected ResultsQuery Performance:player2Repository (storing UUIDs as MSB and LSB) is expected to outperform playerRepository (storing UUIDs as TEXT) in retrieval times.Preliminary ObservationsData Insertion:Inserting 25,000 records into both repositories completed successfully.Periodic logs (e.g., at every 1,000 records) confirm the progress of the data insertion process.Speed Test Execution:Each repository retrieves a random player and logs the time taken.The total time for 1,000 retrievals is recorded and averaged across 500 runs.25,000 Items in Database, sum of time for 1000 random retrivalsAnalysis of ResultsAverage Retrieval Time:Storing UUIDs as two BIGINT columns resulted in an average retrieval time of 95.26 ms, which is approximately 15.7% faster than the TEXT storage method (112.96 ms).This demonstrates the expected performance advantage of numeric comparisons over string comparisons in database queries.Standard Deviation:The standard deviation for the Two Key method (6.02) is smaller compared to the String method (9.06), indicating that the retrieval times for the Two Key the method was more consistent.This suggests better overall reliability and predictability in query performance when using numeric storage.Another study was performed with a more extensive database size, and the results indicated the same pattern. Storing UUIDs as two BIGINT columns resulted in an average retrieval time of 259.65 ms, approximately 27.2% faster than the TEXT storage method (356.50 ms).250,000 Items in Database, sum of time for 1000 random retrivalsConsidering UUID v7UUID v7 significantly improves use cases where time-based ordering and indexing are critical. Unlike UUID v4, which is entirely random, UUID v7 incorporates a timestamp component, making it partially sequential. This design aligns with modern database indexing strategies, offering potential performance benefits when querying large datasets.Advantages of UUID v7Time-Based Ordering:UUID v7 ensures that newly generated IDs are sequential, optimizing database indexing and range queries.This property reduces the likelihood of index fragmentation compared to UUID v4, which is fully random.Compatibility with UUID Standards:UUID v7 adheres to the same 128-bit structure as other UUID versions, ensuring compatibility with existing systems.Improved Performance:Time-based IDs allow databases to organize records more efficiently, potentially improving query performance for time-sensitive operations.Challenges with UUID v7Lack of Native Support:UUID v7 is not widely supported in Kotlin’s library or SQLDelight. Developers would need to rely on third-party libraries or custom implementations.Implementation Complexity:Custom implementations or libraries may require additional maintenance and validation to ensure correctness.Potential Use CasesApplications that require chronological ordering of records, such as logging systems or event trackers.Efficient indexing is crucial for scalability in databases with high write and read operations.Future ProspectsAs UUID v7 becomes more standardized and supported in frameworks like Kotlin and SQLDelight, it will likely emerge as the preferred choice for UUID storage in scenarios demanding time-based indexing. Its adoption could simplify storage strategies while maintaining the benefits of UUIDs for distributed systems.Wrap UpThe choice of how to store UUIDs in a SQLDelight database is an important decision that balances performance, simplicity, and future scalability. By comparing two approaches — storing UUIDs as TEXT versus splitting them into two BIGINT columns—we’ve highlighted the trade-offs involved:Storing UUIDs as TEXT:Offers simplicity and ease of implementation.Ideal for debugging and human-readable outputs.Comes with a performance cost due to larger storage size and slower string comparisons.Storing UUIDs as Two BIGINT Columns:Reduces storage requirements and improves query performance.Numeric comparisons and indexing provide consistent and faster results.Introduces additional complexity for splitting and reconstructing UUIDs.The performance results confirmed that using two BIGINT columns is approximately 15.7% faster on average than storing UUIDs as TEXT. This makes the two-key method an excellent choice for applications with large datasets or high-performance requirements. On the other hand, the simplicity of TEXT storage makes it more appealing for smaller projects or scenarios where developer convenience is prioritized.We also briefly explored the emerging UUID v7 standard, which promises to combine the benefits of time-based ordering with the unique properties of UUIDs. While it has yet to be widely supported in Kotlin or SQLDelight, its potential for optimizing database performance and scalability is exciting.",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*jy52R5bsDkIzf-_scGFQ5g.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@kerry.bisset?source=post_page---byline--59c24986a866--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Kerry Bisset\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*LvLdjsaNud3J4otKLrXe3Q.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--59c24986a866--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"d572\"\u003ePrimary keys are fundamental to maintaining data integrity and enabling efficient data retrieval. They uniquely identify each record in a table, ensuring no duplicate entries exist and that relationships between tables can be accurately established. Traditionally, primary keys have been simple numerical identifiers. However, as systems have evolved — especially distributed systems — the need for more robust and globally unique identifiers has emerged.\u003c/p\u003e\u003cp id=\"1b52\"\u003eUniversally Unique Identifiers (UUIDs) address this need. UUIDs are 128-bit values designed to be unique across different systems and times, making them ideal for distributed environments where multiple nodes might generate identifiers independently. Version 4 UUIDs (UUID v4), in particular, are randomly generated, providing a high degree of uniqueness without relying on a central authority or coordination between nodes.\u003c/p\u003e\u003cp id=\"5ed0\"\u003eUsing UUIDs as primary keys in Kotlin applications that interact with databases presents certain challenges, especially when utilizing libraries like SQLDelight. SQLDelight is a powerful tool that generates type-safe Kotlin APIs from SQL queries but does not natively support a UUID column type. This limitation forces developers to decide on the most effective way to store UUIDs in their SQLDelight schemas.\u003c/p\u003e\u003cp id=\"4c3e\"\u003eThis article examines two primary methods of storing UUID v4 values in a SQLDelight-managed database:\u003c/p\u003e\u003col\u003e\u003cli id=\"60a2\"\u003e\u003cstrong\u003eStoring UUIDs as Text\u003c/strong\u003e: This straightforward approach involves saving the UUID as a string in a \u003ccode\u003eTEXT\u003c/code\u003e column. It leverages the human-readable format of UUIDs, simplifying debugging and logging processes.\u003c/li\u003e\u003cli id=\"eb48\"\u003e\u003cstrong\u003eStoring UUIDs as Two Longs\u003c/strong\u003e: A more space-efficient method involves splitting the UUID into its most significant bits (MSB) and least significant bits (LSB), each stored in separate \u003ccode\u003eBIGINT\u003c/code\u003e (\u003ccode\u003eLong\u003c/code\u003e) columns. This approach can offer performance benefits but introduces additional complexity in handling the UUID data.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"5577\"\u003eThe following sections explore each method\u0026#39;s implementation details, advantages, and disadvantages. A performance comparison is included to assist in making an informed decision based on specific application needs. While UUID v7 promises to address some of these challenges with time-based ordering and improved performance, it has yet to be widely supported, making UUID v4 the current standard in many applications.\u003c/p\u003e\u003ch2 id=\"ddc9\"\u003eUnderstanding UUID v4 and Kotlin.UUID\u003c/h2\u003e\u003ch2 id=\"4771\"\u003eWhat Is UUID v4?\u003c/h2\u003e\u003cp id=\"c85a\"\u003eA Universally Unique Identifier (UUID) is a 128-bit number used to identify information in computer systems uniquely. Standardized by the Open Software Foundation (OSF) as part of the Distributed Computing Environment (DCE), UUIDs are essential for ensuring that identifiers are unique within a single system and across multiple systems worldwide.\u003c/p\u003e\u003cp id=\"4a80\"\u003eVersion 4 UUIDs (UUID v4) are generated using random numbers. This randomness provides a very low probability of generating duplicate UUIDs, making them ideal for applications that require unique identifiers without central coordination. A typical UUID v4 is represented as a string of five groups of hexadecimal digits separated by hyphens, following the pattern 8–4–4–4–12. For example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5e6c\"\u003ef47ac10b-58cc-4372-a567-0e02b2c3d479\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8a63\"\u003eThe structure of a UUID v4 is as follows:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9caa\"\u003e\u003cstrong\u003eTime Low (8 hexadecimal digits):\u003c/strong\u003e Randomly generated.\u003c/li\u003e\u003cli id=\"0776\"\u003e\u003cstrong\u003eTime Mid (4 hexadecimal digits):\u003c/strong\u003e Randomly generated.\u003c/li\u003e\u003cli id=\"3a06\"\u003e\u003cstrong\u003eTime High and Version (4 hexadecimal digits):\u003c/strong\u003e The first 12 bits are random, and the next 4 bits represent the version (0100 for version 4).\u003c/li\u003e\u003cli id=\"1772\"\u003e\u003cstrong\u003eClock Sequence (4 hexadecimal digits):\u003c/strong\u003e The first 2 bits are variant bits, and the remaining 14 bits are random.\u003c/li\u003e\u003cli id=\"1e24\"\u003e\u003cstrong\u003eNode (12 hexadecimal digits):\u003c/strong\u003e Randomly generated.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4653\"\u003eUUIDs allow systems to generate unique identifiers independently, reducing the need for centralized ID generation mechanisms and minimizing the risk of identifier collisions in distributed environments.\u003c/p\u003e\u003cp id=\"2c69\"\u003e\u003cstrong\u003eGenerating a UUID v4 in Kotlin (Since Kotlin 2.0)\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a16f\"\u003eval uuid = Uuid.random()\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"1677\"\u003eAccessing UUID Components\u003c/h2\u003e\u003cp id=\"8c8a\"\u003eEach UUID consists of two 64-bit numbers:\u003c/p\u003e\u003cul\u003e\u003cli id=\"56df\"\u003e\u003cstrong\u003eMost Significant Bits (MSB):\u003c/strong\u003e The first 64 bits of the UUID.\u003c/li\u003e\u003cli id=\"4d34\"\u003e\u003cstrong\u003eLeast Significant Bits (LSB):\u003c/strong\u003e The last 64 bits of the UUID.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1343\"\u003eIn Kotlin, these can be accessed as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1839\"\u003eval key = uuid.toLongs { msb, lsb -\u0026gt; // Do something with the components }\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"014f\"\u003eThese components are crucial when considering alternative storage methods, such as storing the UUID as two \u003ccode\u003eBIGINT\u003c/code\u003e (\u003ccode\u003eLong\u003c/code\u003e) values in a database.\u003c/p\u003e\u003cp id=\"5132\"\u003e\u003cstrong\u003eReconstructing a UUID from MSB and LSB\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"9d45\"\u003eTo reconstruct a UUID from its most and least significant bits:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"eb39\"\u003e Uuid.fromLongs(msb, lsb)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"de39\"\u003eChallenges with UUIDs in Kotlin and SQLDelight\u003c/h2\u003e\u003cp id=\"3f49\"\u003eWhile Kotlin’s interoperability with Java provides robust UUID handling, integrating UUIDs with SQLDelight requires additional considerations:\u003c/p\u003e\u003cul\u003e\u003cli id=\"1c83\"\u003e\u003cstrong\u003eNo Native UUID Type in SQLDelight:\u003c/strong\u003e SQLDelight does not support a UUID column type out of the box, necessitating alternative storage solutions.\u003c/li\u003e\u003cli id=\"18f2\"\u003e\u003cstrong\u003eData Type Mapping:\u003c/strong\u003e Deciding whether to store UUIDs as \u003ccode\u003eTEXT\u003c/code\u003e strings or split them into numeric types affects performance and complexity.\u003c/li\u003e\u003cli id=\"d97f\"\u003e\u003cstrong\u003eSerialization and Deserialization:\u003c/strong\u003e Converting UUIDs to and from the chosen storage format adds overhead and potential points of failure if not handled correctly.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"e55f\"\u003eOption 1: Storing UUIDs as Text\u003c/h2\u003e\u003ch2 id=\"4a03\"\u003eSQLDelight Schema\u003c/h2\u003e\u003cp id=\"e0f6\"\u003eThe SQLDelight schema defines the \u003ccode\u003eplayer\u003c/code\u003e table, where the \u003ccode\u003eid\u003c/code\u003e the column is of type \u003ccode\u003eTEXT\u003c/code\u003e and serves as the primary key. The schema also includes several queries for interacting with the data:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f088\"\u003eCREATE TABLE IF NOT EXISTS player (\u003cbr/\u003e    id TEXT NOT NULL PRIMARY KEY,\u003cbr/\u003e    name TEXT NOT NULL,\u003cbr/\u003e    age INTEGER AS Int NOT NULL\u003cbr/\u003e);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5f57\"\u003eHere:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9faa\"\u003e\u003ccode\u003eid\u003c/code\u003e is a \u003ccode\u003eTEXT\u003c/code\u003e field that stores the UUID as a string.\u003c/li\u003e\u003cli id=\"15df\"\u003e\u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eage\u003c/code\u003e are additional fields to store player data.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1ca3\"\u003eThe schema also provides queries for inserting, retrieving, and managing players.\u003c/p\u003e\u003ch2 id=\"a787\"\u003eRepository\u003c/h2\u003e\u003cp id=\"326d\"\u003eThe \u003ccode\u003ePlayerRepository\u003c/code\u003e the class provides functions to interact with the \u003ccode\u003eplayer\u003c/code\u003e table.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"87ef\"\u003eclass PlayerRepository(private val queries: PlayerQueries) {\u003cp\u003e    suspend fun insertPlayer(players: Players) {\u003cbr/\u003e        queries.storePlayer(players.uuid.toString(), players.name, players.age)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getPlayer(id: Uuid): Players? {\u003cbr/\u003e        return queries.getPlayers(id.toString()).executeAsOneOrNull()?.let {\u003cbr/\u003e            Players(id, it.name, it.age)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getAllPlayers(): List\u0026lt;Players\u0026gt; {\u003cbr/\u003e        return queries.getAllPlayers().executeAsList().map {\u003cbr/\u003e            Players(Uuid.parse(it.id), it.name, it.age)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getRandomPlayer(): Players? {\u003cbr/\u003e        return queries.getRandomPlayer().executeAsOneOrNull()?.let {\u003cbr/\u003e            Players(Uuid.parse(it.id), it.name, it.age)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"6d66\"\u003eAdvantages\u003c/h2\u003e\u003cp id=\"6744\"\u003e\u003cstrong\u003eEase of Implementation:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e77c\"\u003eDirectly storing UUIDs as strings is straightforward and does not require additional complexity in the schema or repository.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2044\"\u003e\u003cstrong\u003eHuman-Readable:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5c43\"\u003eUUIDs stored as text are easy to debug and analyze directly in the database.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9be8\"\u003e\u003cstrong\u003eCompatibility:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"473e\"\u003eMost databases and tools natively support string-based fields, making this method universally compatible.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f5a2\"\u003eDrawbacks\u003c/h2\u003e\u003col\u003e\u003cli id=\"55f0\"\u003e\u003cstrong\u003eStorage Overhead:\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli id=\"918e\"\u003eA \u003ccode\u003eUUID\u003c/code\u003e stored as text uses 36 characters, consuming more space compared to numeric representations like two \u003ccode\u003eBIGINT\u003c/code\u003e columns.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"db45\"\u003e\u003cstrong\u003ePerformance Impact:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"48d1\"\u003eString-based queries, indexing, and comparisons are slower than operations on numeric fields.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"a4b8\"\u003e\u003cstrong\u003eConversion Overhead:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"59bd\"\u003eThe repository must handle conversions between \u003ccode\u003eUUID\u003c/code\u003e and \u003ccode\u003eTEXT\u003c/code\u003e For every database operation, additional processing overhead is introduced.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3864\"\u003eHowever, for applications requiring high performance or handling large datasets, alternative methods like storing UUIDs as two \u003ccode\u003eLONG\u003c/code\u003e columns may be more appropriate.\u003c/p\u003e\u003ch2 id=\"2f54\"\u003eOption 2: Storing UUIDs as Two Longs\u003c/h2\u003e\u003cp id=\"b03e\"\u003eStoring UUIDs as two \u003ccode\u003eLONG\u003c/code\u003e columns involves splitting the UUID into its Most Significant Bits (MSB) and Least Significant Bits (LSB). This approach is designed to optimize storage and query performance while maintaining the uniqueness and functionality of UUIDs.\u003c/p\u003e\u003ch2 id=\"f1fa\"\u003eSQLDelight Schema\u003c/h2\u003e\u003cp id=\"6bad\"\u003eThe schema for the \u003ccode\u003eplayerTwo\u003c/code\u003e table uses two \u003ccode\u003eINTEGER\u003c/code\u003e columns to store the MSB and LSB, with the combination of these columns serving as the primary key:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e894\"\u003eCREATE TABLE IF NOT EXISTS playerTwo (\u003cbr/\u003e    msBit INTEGER NOT NULL,\u003cbr/\u003e    lsBit INTEGER NOT NULL,\u003cbr/\u003e    name TEXT NOT NULL,\u003cbr/\u003e    age INTEGER AS Int NOT NULL,\u003cbr/\u003e    PRIMARY KEY (msBit, lsBit)\u003cbr/\u003e);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ae93\"\u003eHere:\u003c/p\u003e\u003cul\u003e\u003cli id=\"d111\"\u003e\u003ccode\u003emsBit\u003c/code\u003e and \u003ccode\u003elsBit\u003c/code\u003e store the 64-bit parts of the UUID.\u003c/li\u003e\u003cli id=\"5a39\"\u003e\u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eage\u003c/code\u003e hold additional player data.\u003c/li\u003e\u003cli id=\"6fe0\"\u003eThe combination of \u003ccode\u003emsBit\u003c/code\u003e and \u003ccode\u003elsBit\u003c/code\u003e ensures uniqueness.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"489b\"\u003eRepository\u003c/h2\u003e\u003cp id=\"b62f\"\u003eThe \u003ccode\u003ePlayer2Repository\u003c/code\u003e class facilitates interaction with the \u003ccode\u003eplayerTwo\u003c/code\u003e table and handles the conversion between UUID objects and their split components (\u003ccode\u003emsb\u003c/code\u003e and \u003ccode\u003elsb\u003c/code\u003e).\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"65be\"\u003eclass Player2Repository(private val queries: Player2Queries) {\u003cp\u003e    suspend fun insertPlayer(players: Players) {\u003cbr/\u003e        val key = players.uuid.toLongs { msb, lsb -\u0026gt; UuidKey(msb, lsb) }\u003c/p\u003e\u003cp\u003e        queries.storePlayerTwo(key.msb, key.lsb, players.name, players.age)\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getPlayer(id: Uuid): Players? {\u003cbr/\u003e        val key = id.toLongs { msb, lsb -\u0026gt; UuidKey(msb, lsb) }\u003c/p\u003e\u003cp\u003e        return queries.getPlayersTwo(key.msb, key.lsb).executeAsOneOrNull()?.let {\u003cbr/\u003e            Players(id, it.name, it.age)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    suspend fun getAllPlayers(): List\u0026lt;Players\u0026gt; {\u003cbr/\u003e        return queries.getAllPlayersTwo().executeAsList().map {\u003cbr/\u003e            Players(UuidKey(it.msBit, it.lsBit).toUuid(), it.name, it.age)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    data class UuidKey(val msb: Long, val lsb: Long) {\u003cbr/\u003e        fun toUuid(): Uuid {\u003cbr/\u003e            return Uuid.fromLongs(msb, lsb)\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"84f2\"\u003eAdvantages\u003c/h2\u003e\u003cp id=\"2ca0\"\u003e\u003cstrong\u003eStorage Efficiency:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6466\"\u003eUUIDs stored as two \u003ccode\u003eBIGINT\u003c/code\u003e columns use less space compared to their string representation (\u003ccode\u003eTEXT\u003c/code\u003e), reducing overall database size.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8bbc\"\u003e\u003cstrong\u003eImproved Query Performance:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"c57f\"\u003eNumeric fields are faster to compare and index than text fields, leading to better query performance, especially in large datasets.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"458a\"\u003e\u003cstrong\u003eCompatibility with Numeric Indexing:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"ffd4\"\u003eLeveraging indexes on \u003ccode\u003emsBit\u003c/code\u003e and \u003ccode\u003elsBit\u003c/code\u003e improves the speed of lookups and range-based queries.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"a3d7\"\u003eDrawbacks\u003c/h2\u003e\u003cp id=\"6f4f\"\u003e\u003cstrong\u003eIncreased Complexity:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b00d\"\u003eSplitting and reconstructing UUIDs adds complexity to the application code and repository layer.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fca0\"\u003e\u003cstrong\u003eDebugging Challenges:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9dad\"\u003eMSB and LSB values are less intuitive for debugging than human-readable UUID strings.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b299\"\u003e\u003cstrong\u003ePotential for Errors:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"2be2\"\u003eIncorrect handling of MSB and LSB during storage or retrieval could lead to invalid UUID reconstruction.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"2e2f\"\u003eHypothesis Results: Performance Comparison\u003c/h2\u003e\u003cp id=\"763f\"\u003eThe hypothesis tests aim to evaluate the performance of two different UUID storage methods in SQLDelight: storing UUIDs as \u003ccode\u003eTEXT\u003c/code\u003e and storing them as two \u003ccode\u003eBIGINT\u003c/code\u003e columns (MSB and LSB). The tests measure retrieval speed and assess the overhead of each approach.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"64ba\"\u003eExperimental Setup\u003c/h2\u003e\u003cp id=\"651c\"\u003e\u003cstrong\u003eData Insertion:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"741d\"\u003eInsert a large dataset of 25,000 player records into both repositories (\u003ccode\u003eplayerRepository\u003c/code\u003e using \u003ccode\u003eTEXT\u003c/code\u003e storage and \u003ccode\u003eplayer2Repository\u003c/code\u003e using two \u003ccode\u003eBIGINT\u003c/code\u003e columns).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"16fa\"\u003e\u003cstrong\u003eEach record includes:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8cc9\"\u003eA randomly generated UUID.\u003c/li\u003e\u003cli id=\"a3b1\"\u003eA randomly generated name composed of two random first names.\u003c/li\u003e\u003cli id=\"814a\"\u003eA random age between 18 and 99.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"1dd0\"\u003e init {\u003cbr/\u003e        viewModelScope.launch(Dispatchers.IO + CoroutineExceptionHandler { _, throwable -\u0026gt;\u003cbr/\u003e            println(\u0026#34;An error occurred: ${throwable.localizedMessage}\u0026#34;)\u003cbr/\u003e        }) {\u003cbr/\u003e            if (playerRepository.getPlayer(initialUuid) == null) {\u003cbr/\u003e                println(\u0026#34;Player not found, inserting dummy data.\u0026#34;)\u003cbr/\u003e                playerRepository.insertPlayer(Players(initialUuid, \u0026#34;John Doe\u0026#34;, 25))\u003cbr/\u003e                player2Repository.insertPlayer(Players(initialUuid, \u0026#34;John Doe\u0026#34;, 25))\u003cp\u003e                for (i in 0..25000) {\u003cbr/\u003e                    val uuid = Uuid.random()\u003cbr/\u003e                    val age = Random(11)\u003c/p\u003e\u003cp\u003e                    val players = Players(\u003cbr/\u003e                        uuid,\u003cbr/\u003e                        \u0026#34;${CommonFirstNames.getRandom()} ${CommonFirstNames.getRandom()}\u0026#34;,\u003cbr/\u003e                        age.nextInt(18, 99)\u003cbr/\u003e                    )\u003cbr/\u003e                    playerRepository.insertPlayer(players)\u003cbr/\u003e                    player2Repository.insertPlayer(players)\u003cbr/\u003e                }\u003cbr/\u003e                println(\u0026#34;Data insertion completed.\u0026#34;)\u003cbr/\u003e                withContext(Dispatchers.Main) {\u003cbr/\u003e                    speedTestReady.value = true\u003cbr/\u003e                }\u003cbr/\u003e            } else {\u003cbr/\u003e                println(\u0026#34;Player already exists, skipping insertion.\u0026#34;)\u003cbr/\u003e                withContext(Dispatchers.Main) {\u003cbr/\u003e                    speedTestReady.value = true\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"f083\"\u003e\u003cstrong\u003eSpeed Test:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"cada\"\u003eRetrieve players randomly 1,000 times in a loop for each repository.\u003c/li\u003e\u003cli id=\"d3c6\"\u003eMeasure retrieval time in nanoseconds for each query and convert it to milliseconds for readability.\u003c/li\u003e\u003cli id=\"8967\"\u003eAverage the results across 500 runs.\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"794c\"\u003eMainInteraction.RunSpeedTest -\u0026gt; {\u003cbr/\u003e                viewModelScope.launch(Dispatchers.Default) {\u003cbr/\u003e                    for (i in 0..500) {\u003cbr/\u003e                        var playerOneTimeInMillis = 0.0\u003cbr/\u003e                        var playerTwoTimeInMillis = 0.0\u003cp\u003e                        for (i in 0..1000) {\u003cbr/\u003e                            val values = playerRepository.getRandomPlayer()?.uuid ?: initialUuid\u003c/p\u003e\u003cp\u003e                            //Measure the time it takes to get a player from the first repository in nanoseconds\u003cbr/\u003e                            // and convert it to milliseconds\u003cbr/\u003e                            playerOneTimeInMillis += measureNanoTime {\u003cbr/\u003e                                playerRepository.getPlayer(values)\u003cbr/\u003e                            } / 1_000_000.0\u003c/p\u003e\u003cp\u003e                            playerTwoTimeInMillis += measureNanoTime {\u003cbr/\u003e                                player2Repository.getPlayer(values)\u003cbr/\u003e                            } / 1_000_000.0\u003cbr/\u003e                        }\u003c/p\u003e\u003cp\u003e                        withContext(Dispatchers.Main) {\u003cbr/\u003e                            playerOneRepoTime.value = playerOneTimeInMillis\u003cbr/\u003e                            playerTwoRepoTime.value = playerTwoTimeInMillis\u003c/p\u003e\u003cp\u003e                            println(\u0026#34;Time 1, $playerOneTimeInMillis , Time 2, $playerTwoTimeInMillis\u0026#34;)\u003cbr/\u003e                        }\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f8ed\"\u003e\u003cstrong\u003eMetrics Captured:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b2d8\"\u003eAverage retrieval time for \u003ccode\u003eplayerRepository\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"f624\"\u003eAverage retrieval time for \u003ccode\u003eplayer2Repository\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"0c95\"\u003eExpected Results\u003c/h2\u003e\u003cp id=\"314e\"\u003e\u003cstrong\u003eQuery Performance:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0648\"\u003e\u003ccode\u003eplayer2Repository\u003c/code\u003e (storing UUIDs as MSB and LSB) is expected to outperform \u003ccode\u003eplayerRepository\u003c/code\u003e (storing UUIDs as \u003ccode\u003eTEXT\u003c/code\u003e) in retrieval times.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"3a8e\"\u003ePreliminary Observations\u003c/h2\u003e\u003cp id=\"f16c\"\u003e\u003cstrong\u003eData Insertion:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d17a\"\u003eInserting 25,000 records into both repositories completed successfully.\u003c/li\u003e\u003cli id=\"1dda\"\u003ePeriodic logs (e.g., at every 1,000 records) confirm the progress of the data insertion process.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6f15\"\u003e\u003cstrong\u003eSpeed Test Execution:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"f36e\"\u003eEach repository retrieves a random player and logs the time taken.\u003c/li\u003e\u003cli id=\"6fcb\"\u003eThe total time for 1,000 retrievals is recorded and averaged across 500 runs.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003e25,000 Items in Database, sum of time for 1000 random retrivals\u003c/figcaption\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"2642\"\u003eAnalysis of Results\u003c/h2\u003e\u003cp id=\"339c\"\u003e\u003cstrong\u003eAverage Retrieval Time:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"71df\"\u003eStoring UUIDs as two \u003ccode\u003eBIGINT\u003c/code\u003e columns resulted in an average retrieval time of \u003cstrong\u003e95.26 ms\u003c/strong\u003e, which is approximately \u003cstrong\u003e15.7% faster\u003c/strong\u003e than the \u003ccode\u003eTEXT\u003c/code\u003e storage method (112.96 ms).\u003c/li\u003e\u003cli id=\"94bb\"\u003eThis demonstrates the expected performance advantage of numeric comparisons over string comparisons in database queries.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3458\"\u003e\u003cstrong\u003eStandard Deviation:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"dbcc\"\u003eThe standard deviation for the \u003ccode\u003eTwo Key\u003c/code\u003e method (6.02) is smaller compared to the \u003ccode\u003eString\u003c/code\u003e method (9.06), indicating that the retrieval times for the \u003ccode\u003eTwo Key\u003c/code\u003e the method was more consistent.\u003c/li\u003e\u003cli id=\"5943\"\u003eThis suggests better overall reliability and predictability in query performance when using numeric storage.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7336\"\u003eAnother study was performed with a more extensive database size, and the results indicated the same pattern. Storing UUIDs as two \u003ccode\u003eBIGINT\u003c/code\u003e columns resulted in an average retrieval time of \u003cstrong\u003e259.65 ms\u003c/strong\u003e, approximately \u003cstrong\u003e27.2% faster\u003c/strong\u003e than the \u003ccode\u003eTEXT\u003c/code\u003e storage method (356.50 ms).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003e250,000\u003c/strong\u003e Items in Database, sum of time for 1000 random retrivals\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"a113\"\u003eConsidering UUID v7\u003c/h2\u003e\u003cp id=\"b7f8\"\u003eUUID v7 significantly improves use cases where time-based ordering and indexing are critical. Unlike UUID v4, which is entirely random, UUID v7 incorporates a timestamp component, making it partially sequential. This design aligns with modern database indexing strategies, offering potential performance benefits when querying large datasets.\u003c/p\u003e\u003ch2 id=\"98aa\"\u003eAdvantages of UUID v7\u003c/h2\u003e\u003cp id=\"f435\"\u003e\u003cstrong\u003eTime-Based Ordering:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0f35\"\u003eUUID v7 ensures that newly generated IDs are sequential, optimizing database indexing and range queries.\u003c/li\u003e\u003cli id=\"f250\"\u003eThis property reduces the likelihood of index fragmentation compared to UUID v4, which is fully random.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ddda\"\u003e\u003cstrong\u003eCompatibility with UUID Standards:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"d597\"\u003eUUID v7 adheres to the same 128-bit structure as other UUID versions, ensuring compatibility with existing systems.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6625\"\u003e\u003cstrong\u003eImproved Performance:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"38b5\"\u003eTime-based IDs allow databases to organize records more efficiently, potentially improving query performance for time-sensitive operations.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b469\"\u003eChallenges with UUID v7\u003c/h2\u003e\u003cp id=\"6314\"\u003e\u003cstrong\u003eLack of Native Support:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"3dae\"\u003eUUID v7 is not widely supported in Kotlin’s library or SQLDelight. Developers would need to rely on third-party libraries or custom implementations.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"198e\"\u003e\u003cstrong\u003eImplementation Complexity:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8e79\"\u003eCustom implementations or libraries may require additional maintenance and validation to ensure correctness.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5f50\"\u003ePotential Use Cases\u003c/h2\u003e\u003cul\u003e\u003cli id=\"b446\"\u003eApplications that require chronological ordering of records, such as logging systems or event trackers.\u003c/li\u003e\u003cli id=\"ab85\"\u003eEfficient indexing is crucial for scalability in databases with high write and read operations.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"b60f\"\u003eFuture Prospects\u003c/h2\u003e\u003cp id=\"82ed\"\u003eAs UUID v7 becomes more standardized and supported in frameworks like Kotlin and SQLDelight, it will likely emerge as the preferred choice for UUID storage in scenarios demanding time-based indexing. Its adoption could simplify storage strategies while maintaining the benefits of UUIDs for distributed systems.\u003c/p\u003e\u003ch2 id=\"232b\"\u003eWrap Up\u003c/h2\u003e\u003cp id=\"4258\"\u003eThe choice of how to store UUIDs in a SQLDelight database is an important decision that balances performance, simplicity, and future scalability. By comparing two approaches — storing UUIDs as \u003ccode\u003eTEXT\u003c/code\u003e versus splitting them into two \u003ccode\u003eBIGINT\u003c/code\u003e columns—we’ve highlighted the trade-offs involved:\u003c/p\u003e\u003cp id=\"bfbd\"\u003e\u003cstrong\u003eStoring UUIDs as \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eTEXT\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"6749\"\u003eOffers simplicity and ease of implementation.\u003c/li\u003e\u003cli id=\"002c\"\u003eIdeal for debugging and human-readable outputs.\u003c/li\u003e\u003cli id=\"32ed\"\u003eComes with a performance cost due to larger storage size and slower string comparisons.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ef79\"\u003e\u003cstrong\u003eStoring UUIDs as Two \u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eBIGINT\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e Columns:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4eaa\"\u003eReduces storage requirements and improves query performance.\u003c/li\u003e\u003cli id=\"9851\"\u003eNumeric comparisons and indexing provide consistent and faster results.\u003c/li\u003e\u003cli id=\"8148\"\u003eIntroduces additional complexity for splitting and reconstructing UUIDs.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"06a3\"\u003eThe performance results confirmed that using two \u003ccode\u003eBIGINT\u003c/code\u003e columns is approximately 15.7% faster on average than storing UUIDs as \u003ccode\u003eTEXT\u003c/code\u003e. This makes the two-key method an excellent choice for applications with large datasets or high-performance requirements. On the other hand, the simplicity of \u003ccode\u003eTEXT\u003c/code\u003e storage makes it more appealing for smaller projects or scenarios where developer convenience is prioritized.\u003c/p\u003e\u003cp id=\"2df0\"\u003eWe also briefly explored the emerging UUID v7 standard, which promises to combine the benefits of time-based ordering with the unique properties of UUIDs. While it has yet to be widely supported in Kotlin or SQLDelight, its potential for optimizing database performance and scalability is exciting.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-12-02T11:49:54.102Z",
  "modifiedTime": null
}
