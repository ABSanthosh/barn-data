{
  "id": "0f084d53-bcc8-44d7-8781-3b4ab4a29715",
  "title": "Prime Table Generator in Jetpack Compose",
  "link": "https://zsmb.co/prime-table-generator-jetpack-compose/",
  "description": "I've dusted off one of my oldest (and favourite) coding projects, and rewrote it in Jetpack Compose as a nice little practice exercise.",
  "author": "Márton Braun",
  "published": "Thu, 25 Mar 2021 16:00:00 +0000",
  "source": "https://zsmb.co/index.xml",
  "categories": null,
  "byline": "Márton Braun",
  "length": 7268,
  "excerpt": "I've dusted off one of my oldest (and favourite) coding projects, and rewrote it in Jetpack Compose as a nice little practice exercise.",
  "siteName": "zsmb.co",
  "favicon": "",
  "text": "It’s been more than 6 years since I wrote an original version of this prime table generator. That was back at the very beginning of my coding career, after learning C and SDL in the first semester of university. An archived version of that original project is available here, including the sources, 120 lines of excellent C code. Premise Recapping from the article linked above briefly: the point of this project is to create a visually pleasing and concise representation of prime numbers. The original, on-paper version contained prime numbers up to 4000, and looked like this: How does it work? Each square represents a block of ten numbers. Since primes (above 2) may only end on the digits 1, 3, 7, or 9, each corner of the square can indicate whether or not a given ending digit is a prime within the 10 number wide block. As an example, the third block of the table corresponds to the numbers 21-30, and the two connected corners indicate that only 23 and 29 are primes within this range. Now, let’s get to coding this for Android! You can find the code for the completed project on GitHub. Creating a grid In the previous Jetpack Compose article on this blog, we created an animated clock with a bottom-up approach. This time, we’ll design things top-down, and start with rendering a grid in Compose. For this, we’ll use the experimental LazyVerticalGrid APIs. @OptIn(ExperimentalFoundationApi::class) @Composable fun Primes() { LazyVerticalGrid( modifier = Modifier // 1 .fillMaxSize() .background(Color(0xFFE53935)) .padding(8.dp), cells = GridCells.Fixed(10), // 2 ) { items(count = 100) { // 3 Box( Modifier // 4 .aspectRatio(1f) .padding(1.dp) .background(Color.DarkGray) ) } } } Breaking down the code above: The LazyVerticalGrid composable fills the entire screen, has a red background, and a small bit of padding. It displays a grid with a fixed number of columns. The grid contains 100 items. Each item is a simple Box for a start, which is constrained to be a square shape, has a bit of padding, and a dark background colour. Note how we had to opt-in to using the experimental API with the @OptIn annotation, which also requires some additional project-level configuration to enable it. You can read more about this language feature in Mastering API Visibility in Kotlin. Running the code above renders the (scrollable) grid of squares: A single square Let’s refactor this a bit, and create a PrimeSquare composable for each item of the grid. This will receive the current offset that it should render prime numbers for. @OptIn(ExperimentalFoundationApi::class) @Composable fun Primes() { LazyVerticalGrid(...) { items(count = 100) { index -\u003e PrimeSquare(offset = index * 10) } } } @Composable fun PrimeSquare(offset: Int) { Box( Modifier .aspectRatio(1f) .padding(1.dp) .background(Color.DarkGray) ) { CornerLine() } } For the content of a single PrimeSquare, we’ll render just one line from the top left corner to the center, with our own CornerLine composable. We can do this in Compose using the Canvas API: @Composable fun CornerLine() { Canvas(Modifier.fillMaxSize()) { drawLine( color = Color.White, start = Offset.Zero, end = Offset(size.width / 2, size.height / 2), strokeWidth = 2.dp.toPx(), ) } } This gives us the following look - a good start! Rotating and stacking squares To get this line into the correct corner, we can rotate the canvas while drawing on it. A simple rotate function call takes care of this for us. We’ll take the rotation amount as a parameter to CornerLine. @Composable fun CornerLine(degrees: Float) { Canvas(Modifier.fillMaxSize()) { rotate(degrees) { drawLine( color = Color.White, start = Offset.Zero, end = Offset(size.width / 2, size.height / 2), strokeWidth = 2.dp.toPx(), ) } } } To make things super easy, we’ll create a named composable for each corner, with the appropriate rotation: @Composable fun One() = CornerLine(degrees = 0f) @Composable fun Three() = CornerLine(degrees = -90f) @Composable fun Seven() = CornerLine(degrees = -180f) @Composable fun Nine() = CornerLine(degrees = -270f) We’ll have to know which number is a prime, for this we’ll go with a very basic implementation. fun Int.isPrime(): Boolean { if (this \u003c 2) return false return (2 until this).none { this % it == 0 } } Have a shorter implementation for this that’s at least as correct for checking primes? Tweet it at me! Now that we can check whether a number’s a prime and can draw lines into each corner, we can implement PrimeSquare trivially: @Composable fun PrimeSquare(offset: Int) { Box( Modifier .aspectRatio(1f) .padding(1.dp) .background(Color.DarkGray) ) { if ((offset + 1).isPrime()) One() if ((offset + 3).isPrime()) Three() if ((offset + 7).isPrime()) Seven() if ((offset + 9).isPrime()) Nine() } } Of course, the way we’re stacking Canvases here is not exactly optimal, but it’s a good demonstration of how a Box works as a container. If we moved the prime calculations a level lower, we could draw all our lines on a single Canvas for better performance - try doing this as a practice exercise. Still, our non-optimal implementation works well: Final touches There are two issues left here in our rendering, which you can spot if you look closely at the image above. The ends of the lines drawn extend beyond the grey boxes. The lines meeting in the middle don’t meet as expected. For the first issue, we can make the Box in the PrimeSquare composable clip to its bounds: Box( Modifier .aspectRatio(1f) .padding(1.dp) .background(Color.DarkGray) .clipToBounds() ) { ... } To make the lines overlap more in the middle, we can draw them just ever so slightly longer - 2f seems to do the trick: end = Offset(size.width / 2 + 2f, size.height / 2 + 2f), Running the app again gives us our final result. Conclusion Again, the completed source for this project is available on GitHub. If you’re looking for more similar Compose content, check out these articles: Compose O’Clock Jetpack Compose: First Impressions and Learning Resources Build an Android Chat app with Jetpack Compose In another detailed Jetpack Compose walkthrough, we'll look at implementing a simple app for practicing the digits of pi!StateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.I started learning Jetpack Compose this week. Two days into that adventure, here's a quick look at how a neat clock design can be built up in Compose, step-by-step.Another year over, a new one's almost begun. Here's a brief summary of what I've done in this one.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \u003cp\u003eIt’s been more than 6 years since I wrote an original version of this prime table generator. That was back at the very beginning of my coding career, after learning C and SDL in the first semester of university. An archived version of that original project \u003ca href=\"https://zsmbprogsite.netlify.app/projects/primetable/\"\u003eis available here\u003c/a\u003e, including the sources, \u003ca href=\"https://zsmbprogsite.netlify.app/projects/primetable/primetable.c\"\u003e120 lines of excellent C code\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"premise\"\u003ePremise\u003c/h3\u003e\n\u003cp\u003eRecapping from the article linked above briefly: the point of this project is to create a visually pleasing and concise representation of prime numbers. The original, on-paper version contained prime numbers up to 4000, and looked like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/original.jpg\" alt=\"The full table\"/\u003e\u003c/p\u003e\n\u003cp\u003eHow does it work? Each square represents a block of ten numbers. Since primes (above 2) may only end on the digits 1, 3, 7, or 9, each corner of the square can indicate whether or not a given ending digit is a prime within the 10 number wide block.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/primetable_example.png\" alt=\"Example of the first few squares of the table\"/\u003e\u003c/p\u003e\n\u003cp\u003eAs an example, the third block of the table corresponds to the numbers 21-30, and the two connected corners indicate that only 23 and 29 are primes within this range.\u003c/p\u003e\n\u003cp\u003eNow, let’s get to coding this for Android!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou can find the code for the completed project \u003ca href=\"https://github.com/zsmb13/PrimeTableGenerator\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"creating-a-grid\"\u003eCreating a grid\u003c/h3\u003e\n\u003cp\u003eIn \u003ca href=\"https://zsmb.co/compose-o-clock/\"\u003ethe previous Jetpack Compose article on this blog\u003c/a\u003e, we created an animated clock with a bottom-up approach. This time, we’ll design things top-down, and start with rendering a grid in Compose. For this, we’ll use the experimental \u003ca href=\"https://developer.android.com/jetpack/compose/lists#grids\"\u003e\u003ccode\u003eLazyVerticalGrid\u003c/code\u003e\u003c/a\u003e APIs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun Primes() {\n    LazyVerticalGrid(\n        modifier = Modifier // 1\n            .fillMaxSize()\n            .background(Color(0xFFE53935))\n            .padding(8.dp),\n        cells = GridCells.Fixed(10), // 2\n    ) {\n        items(count = 100) { // 3\n            Box( \n                Modifier // 4\n                    .aspectRatio(1f)\n                    .padding(1.dp)\n                    .background(Color.DarkGray)\n            )\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBreaking down the code above:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe \u003ccode\u003eLazyVerticalGrid\u003c/code\u003e composable fills the entire screen, has a red background, and a small bit of padding.\u003c/li\u003e\n\u003cli\u003eIt displays a grid with a fixed number of columns.\u003c/li\u003e\n\u003cli\u003eThe grid contains 100 items.\u003c/li\u003e\n\u003cli\u003eEach item is a simple \u003ccode\u003eBox\u003c/code\u003e for a start, which is constrained to be a square shape, has a bit of padding, and a dark background colour.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote how we had to opt-in to using the experimental API with the \u003ccode\u003e@OptIn\u003c/code\u003e annotation, which also requires some additional project-level configuration to enable it. You can read more about this language feature in \u003ca href=\"https://zsmb.co/mastering-api-visibility-in-kotlin/#opt-in-apis\"\u003eMastering API Visibility in Kotlin\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eRunning the code above renders the (scrollable) grid of squares:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/basic_grid.png\" alt=\"A grid of dark squares\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"a-single-square\"\u003eA single square\u003c/h3\u003e\n\u003cp\u003eLet’s refactor this a bit, and create a \u003ccode\u003ePrimeSquare\u003c/code\u003e composable for each item of the grid. This will receive the current offset that it should render prime numbers for.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun Primes() {\n    LazyVerticalGrid(...) {\n        items(count = 100) { index -\u0026gt;\n            PrimeSquare(offset = index * 10)\n        }\n    }\n}\n\n@Composable\nfun PrimeSquare(offset: Int) {\n    Box(\n        Modifier\n            .aspectRatio(1f)\n            .padding(1.dp)\n            .background(Color.DarkGray)\n    ) {\n        CornerLine()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor the content of a single \u003ccode\u003ePrimeSquare\u003c/code\u003e, we’ll render just one line from the top left corner to the center, with our own \u003ccode\u003eCornerLine\u003c/code\u003e composable. We can do this in Compose using the \u003ccode\u003eCanvas\u003c/code\u003e API:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun CornerLine() {\n    Canvas(Modifier.fillMaxSize()) {\n        drawLine(\n            color = Color.White,\n            start = Offset.Zero,\n            end = Offset(size.width / 2, size.height / 2),\n            strokeWidth = 2.dp.toPx(),\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis gives us the following look - a good start!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/grid_with_fixed_corner_lines.png\" alt=\"Prime squares with lines all in the top left corner\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"rotating-and-stacking-squares\"\u003eRotating and stacking squares\u003c/h3\u003e\n\u003cp\u003eTo get this line into the correct corner, we can rotate the canvas while drawing on it. A simple \u003ccode\u003erotate\u003c/code\u003e function call takes care of this for us. We’ll take the rotation amount as a parameter to \u003ccode\u003eCornerLine\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun CornerLine(degrees: Float) {\n    Canvas(Modifier.fillMaxSize()) {\n        rotate(degrees) {\n            drawLine(\n                color = Color.White,\n                start = Offset.Zero,\n                end = Offset(size.width / 2, size.height / 2),\n                strokeWidth = 2.dp.toPx(),\n            )\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make things super easy, we’ll create a named composable for each corner, with the appropriate rotation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable fun One() = CornerLine(degrees = 0f)\n@Composable fun Three() = CornerLine(degrees = -90f)\n@Composable fun Seven() = CornerLine(degrees = -180f)\n@Composable fun Nine() = CornerLine(degrees = -270f)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ll have to know which number is a prime, for this we’ll go with a very basic implementation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efun Int.isPrime(): Boolean {\n    if (this \u0026lt; 2) return false\n    return (2 until this).none { this % it == 0 }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHave a shorter implementation for this that’s at least as correct for checking primes? \u003ca href=\"https://twitter.com/zsmb13\"\u003eTweet it at me!\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNow that we can check whether a number’s a prime and can draw lines into each corner, we can implement \u003ccode\u003ePrimeSquare\u003c/code\u003e trivially:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Composable\nfun PrimeSquare(offset: Int) {\n    Box(\n        Modifier\n            .aspectRatio(1f)\n            .padding(1.dp)\n            .background(Color.DarkGray)\n    ) {\n        if ((offset + 1).isPrime()) One()\n        if ((offset + 3).isPrime()) Three()\n        if ((offset + 7).isPrime()) Seven()\n        if ((offset + 9).isPrime()) Nine()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOf course, the way we’re stacking Canvases here is not exactly optimal, but it’s a good demonstration of how a \u003ccode\u003eBox\u003c/code\u003e works as a container. If we moved the prime calculations a level lower, we could draw all our lines on a single Canvas for better performance - try doing this as a practice exercise.\u003c/p\u003e\n\u003cp\u003eStill, our non-optimal implementation works well:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/stacked_canvases.png\" alt=\"A working implementation of the prime table\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"final-touches\"\u003eFinal touches\u003c/h3\u003e\n\u003cp\u003eThere are two issues left here in our rendering, which you can spot if you look closely at the image above.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe ends of the lines drawn extend beyond the grey boxes.\u003c/li\u003e\n\u003cli\u003eThe lines meeting in the middle don’t meet as expected.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor the first issue, we can make the \u003ccode\u003eBox\u003c/code\u003e in the \u003ccode\u003ePrimeSquare\u003c/code\u003e composable \u003cem\u003eclip\u003c/em\u003e to its bounds:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBox(\n    Modifier\n        .aspectRatio(1f)\n        .padding(1.dp)\n        .background(Color.DarkGray)\n        .clipToBounds()\n) { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make the lines overlap more in the middle, we can draw them just ever so slightly longer - \u003ccode\u003e2f\u003c/code\u003e seems to do the trick:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eend = Offset(size.width / 2 + 2f, size.height / 2 + 2f),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning the app again gives us our final result.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://zsmb.co/images/prime-table-generator-jetpack-compose/fixed_corners.png\" alt=\"The final version of the prime table\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"conclusion\"\u003eConclusion\u003c/h3\u003e\n\u003cp\u003eAgain, the completed source for this project is available \u003ca href=\"https://github.com/zsmb13/PrimeTableGenerator\"\u003eon GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIf you’re looking for more similar Compose content, check out these articles:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zsmb.co/compose-o-clock/\"\u003eCompose O’Clock\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dev.to/zsmb13/jetpack-compose-first-impressions-and-learning-resources-3ghp\"\u003eJetpack Compose: First Impressions and Learning Resources\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://proandroiddev.com/android-chat-app-jetpack-compose-dec472140ff1\"\u003eBuild an Android Chat app with Jetpack Compose\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e\u003cp\u003eIn another detailed Jetpack Compose walkthrough, we\u0026#39;ll look at implementing a simple app for practicing the digits of pi!\u003c/p\u003e\u003cp\u003eStateFlow behaves as a state holder and a Flow of values at the same time. Due to conflation, a collector of a StateFlow might not receive all values that it holds over time. This article covers what that means for your tests.\u003c/p\u003e\u003cp\u003eI started learning Jetpack Compose this week. Two days into that adventure, here\u0026#39;s a quick look at how a neat clock design can be built up in Compose, step-by-step.\u003c/p\u003e\u003cp\u003eAnother year over, a new one\u0026#39;s almost begun. Here\u0026#39;s a brief summary of what I\u0026#39;ve done in this one.\u003c/p\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
