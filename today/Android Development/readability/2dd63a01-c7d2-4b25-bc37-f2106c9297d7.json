{
  "id": "2dd63a01-c7d2-4b25-bc37-f2106c9297d7",
  "title": "How SMRT Reduced the WINK+ Android App to Less Than 10MB",
  "link": "https://proandroiddev.com/how-smrt-reduced-the-wink-android-app-to-less-than-10mb-00318f3e7d51?source=rss----c72404660798---4",
  "description": "",
  "author": "Julius Uy",
  "published": "Sun, 29 Dec 2024 17:27:10 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "apk-size",
    "androiddev",
    "android-app-development",
    "android",
    "app-size"
  ],
  "byline": "Julius Uy",
  "length": 9273,
  "excerpt": "One of the major challenges developers face in Android app development is optimizing app size without sacrificing functionality. Our team consists of only one Android Engineer working on the WINK+…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Photo by Matt Artz on UnsplashOne of the major challenges developers face in Android app development is optimizing app size without sacrificing functionality. Our team consists of only one Android Engineer working on the WINK+ app. Despite this resource constraint, we set an ambitious goal: to reduce our APK size to under 10 MB. A best-in-class product should look as good as it can be on the outside and the inside. Working with tremendous constraints forces us to think creatively to solve this. This is especially challenging when competing apps in the same category tend to be over 20 MB, and WINK+ offers much more complex features than them. One of the key bottlenecks we had was that reducing app size for the sake of reducing offers little to no value. Especially since we do not operate with abundant resources, we have to be very careful how we allocate them.1. Understand Your App’s ComponentsThe first step in any app size optimization process is to gain a deep understanding of the components that contribute to the app size. For WINK+, this included resources like images, libraries, and redundant code. Tools like Android Studio’s APK Analyzer help break down the app’s APK file and identify the largest contributors to its size. Unsurprisingly, the main culprits were large image files and unused third-party libraries.2. Remove Unused Resources and LibrariesThe most immediate win came from eliminating unused resources and libraries. Many apps include libraries that aren’t being fully utilized, either due to leftover features from earlier versions or third-party libraries that do more than required. We used Proguard, a tool built into Android Studio, to shrink and optimize the code. Proguard’s code shrinker helped remove unused classes, methods, and fields, reducing the overall size. Additionally, we conducted an audit to identify libraries that were too bulky for our use case.One example is the QR Code Scanner, which we use for collecting WINK+ points all around Singapore. This is operated by MLKit under the hood. However, the MLKit library behind this takes up a healthy 2.4 MB of file size. However, because we only offer our app on Google Play and not on other third-party stores (which means all phones theoretically should have Google Play Services installed), we can unbundle the library and rely on Google Play Services. This effectively shaved 2 MB of size for us.WINK+ users can scan QR codes all around Singapore to earn points in exchange for rewards3. Removing Unnecessary Fonts to Reduce App SizeFonts are another often overlooked aspect of app optimization. While they may seem small individually, fonts can add up quickly, especially when multiple font families or weights are included in the app. For the WINK+ app, we noticed that several unused font families and weights were being bundled into the final APK, contributing to unnecessary bloat. Removing these unused fonts helped us make a significant reduction in the app size without sacrificing the design or user experience.We made sure to only include the essential fonts and weights that were required. Android allows you to define specific font weights and styles in XML using the font resource method, meaning that we didn’t need to bundle an entire font family with multiple weights and styles. By reducing the number of font variants and only keeping the ones actively used, we reduced the font asset size considerably.Also, to avoid the need for downloading font assets from external servers (a process that can slow down app launch times), we embedded the fonts directly within the app, ensuring that the necessary font files were available offline. By carefully managing the fonts and removing the unnecessary ones, we were able to significantly reduce the size of the APK, and this optimization played a key role in keeping the app size under 8 MB.4. Opt for VectorDrawables Over Bitmap ImagesOne major change that contributed to the reduced app size was switching from bitmap images to vector drawables. Bitmap images, especially those used for icons and other scalable elements, can add significant size to an app. Vector images, on the other hand, are scalable and typically much smaller in file size. By generally replacing PNGs with SVGs and other vector formats, we were able to dramatically reduce the amount of storage space dedicated to image assets.However, one of the issues we had was that a lot of the PNG files never was on Figma, as we inherited the app from elsewhere, and working files were already lost. As a result, we relied on online resources to help convert PNG to SVG. Despite Adobe offering a free service, We found this to be the most effective. (Adobe ends up keeping a lot of strange artifacts)We also took advantage of Avocado, which allows us to further optimize the VectorDrawables by removing unnecessary points between lines, for example. However, some of the assets we migrated from PNGs had jagged edges, primarily because that’s generally how rasterized images end up being. We felt it was too much effort to clean that up, for a measly… few hundred bytes of savings, so we left them there.5. Optimize Dependencies and Modularize the CodeNext, we took a close look at the third-party dependencies we were using. Many of these dependencies were large, adding unnecessary bloat to the app. One example was the Facebook Libraries.We initially used this particular library, which loads up everything Facebook has:// Facebook Android SDK (everything)implementation 'com.facebook.android:facebook-android-sdk:latest.release'However, since we do not use everything Facebook have to offer, we opted for a lesser variant, thus saving us a tremendous amount of space as well.// Facebook Core only (Analytics)implementation 'com.facebook.android:facebook-core:latest.release' // Facebook Marketing onlyimplementation 'com.facebook.android:facebook-marketing:latest.release'By making sure that we only use dependencies that were strictly needed, we significantly reduced the app’s size. Techniques like “gradle dependency management” allowed us to strip down these libraries to their essentials, further optimizing the app’s build configuration.6. Compress Assets Without Losing QualityAsset compression was another vital step in reducing the app size. Tools like ImageOptim allowed us to reduce a significant amount of image file size by repurposing images with better compression.Android Studio of course allows one to automatically convert images to WebP, whenever ideal:7. Optimizing Lottie Files for Faster Load Times and Smaller SizeOn WINK+, we use Lottie animations to enhance the user experience. Lottie files, which are JSON-based animations, have become a popular choice for app developers due to their lightweight nature and ability to scale without losing quality. They allow for smooth, high-quality animations that are much smaller in size compared to traditional video or GIF animations. However, even Lottie files can contribute to an app’s size if not optimized properly, especially if they include unnecessary layers or are too complex.To reduce the overall size of Lottie animations used in WINK+, we employed several optimization strategies. First, we ensured that the animations themselves were as simple as possible. Lottie animations can sometimes include superfluous data, like extraneous keyframes or unnecessary assets embedded in the JSON file. Using the LottieFiles web-based asset optimizer, we were able to trim down these animations and remove unnecessary properties and redundant elements, making our Lottie files smaller and faster to load. We were, surprisingly, able to reduce around 1MB of file size just with this.8. Test, Iterate, and MonitorOnce the app was optimized and its size reduced to below 10MB, we conducted extensive testing. It was crucial to ensure that the app’s performance, features, and overall user experience were not affected. We continuously monitored app performance on different devices. In our case, we use NewRelic for APM.Yay! 7.85MB!ConclusionReducing app size can significantly boost download rates, as users often prefer smaller apps due to concerns about data usage, download times, and device storage. Research indicates that for every 6 MB increase in an Android app’s size, the install conversion rate decreases by 1%.This trend is even more pronounced in emerging markets, where data costs and limited storage are major considerations. In countries like India and Brazil, a 10 MB reduction in app size can lead to a 2.5% increase in install conversion rates.Install conversion rate increase per 10MB decrease in APK size by select market (source)In conclusion, reducing the size of the WINK+ app to less than 10MB while maintaining a wider range of feature sets compared to similar apps was a challenging but rewarding process. By leveraging strategies such as optimizing resources, modularizing the code, using App Bundles, and focusing on efficient compression techniques, we were able to deliver a lean, fast, and efficient app. As app sizes continue to grow across the Android ecosystem, this experience has reinforced the importance of size optimization — not just for user convenience but also for improving app performance and engagement.Happy coding!",
  "image": "https://miro.medium.com/v2/resize:fit:1024/0*1pEPl9Ss5VuQaVp_.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@julius.uy?source=post_page---byline--00318f3e7d51--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Julius Uy\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*VEqMvkX8ZEto5DK-vGaeYg.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--00318f3e7d51--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@mattartz?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMatt Artz\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"97f5\"\u003eOne of the major challenges developers face in Android app development is optimizing app size without sacrificing functionality. Our team consists of only one Android Engineer working on the \u003ca href=\"https://play.google.com/store/apps/details?id=smrt.media.wink\u0026amp;hl=en_SG\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWINK+ app\u003c/a\u003e. Despite this resource constraint, we set an ambitious goal: to reduce our APK size to under 10 MB. A best-in-class product should look as good as it can be on the outside and the inside. Working with tremendous constraints forces us to think creatively to solve this. This is especially challenging when competing apps in the same category tend to be over 20 MB, and WINK+ offers much more complex features than them. One of the key bottlenecks we had was that reducing app size for the sake of reducing offers little to no value. Especially since we do not operate with abundant resources, we have to be very careful how we allocate them.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"fcc2\"\u003e1. Understand Your App’s Components\u003c/h2\u003e\u003cp id=\"4029\"\u003eThe first step in any app size optimization process is to gain a deep understanding of the components that contribute to the app size. For WINK+, this included resources like images, libraries, and redundant code. Tools like Android Studio’s APK Analyzer help break down the app’s APK file and identify the largest contributors to its size. Unsurprisingly, the main culprits were large image files and unused third-party libraries.\u003c/p\u003e\u003ch2 id=\"252f\"\u003e2. Remove Unused Resources and Libraries\u003c/h2\u003e\u003cp id=\"eece\"\u003eThe most immediate win came from eliminating unused resources and libraries. Many apps include libraries that aren’t being fully utilized, either due to leftover features from earlier versions or third-party libraries that do more than required. We used Proguard, a tool built into Android Studio, to shrink and optimize the code. Proguard’s code shrinker helped remove unused classes, methods, and fields, reducing the overall size. Additionally, we conducted an audit to identify libraries that were too bulky for our use case.\u003c/p\u003e\u003cp id=\"129f\"\u003eOne example is the QR Code Scanner, which we use for collecting WINK+ points all around Singapore. This is operated by MLKit under the hood. However, the MLKit library behind this takes up a healthy 2.4 MB of file size. However, because we only offer our app on Google Play and not on other third-party stores (which means all phones theoretically should have Google Play Services installed), we can \u003ca href=\"https://developers.google.com/ml-kit/vision/barcode-scanning/android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eunbundle\u003c/a\u003e the library and rely on Google Play Services. This effectively shaved 2 MB of size for us.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eWINK+ users can scan QR codes all around Singapore to earn points in exchange for rewards\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"a4c1\"\u003e3. Removing Unnecessary Fonts to Reduce App Size\u003c/h2\u003e\u003cp id=\"27a8\"\u003eFonts are another often overlooked aspect of app optimization. While they may seem small individually, fonts can add up quickly, especially when multiple font families or weights are included in the app. For the WINK+ app, we noticed that several unused font families and weights were being bundled into the final APK, contributing to unnecessary bloat. Removing these unused fonts helped us make a significant reduction in the app size without sacrificing the design or user experience.\u003c/p\u003e\u003cp id=\"b2a7\"\u003eWe made sure to \u003cstrong\u003eonly include the essential fonts and weights\u003c/strong\u003e that were required. Android allows you to define specific font weights and styles in XML using the \u003cstrong\u003efont resource\u003c/strong\u003e method, meaning that we didn’t need to bundle an entire font family with multiple weights and styles. By reducing the number of font variants and only keeping the ones actively used, we reduced the font asset size considerably.\u003c/p\u003e\u003cp id=\"fec1\"\u003eAlso, to avoid the need for downloading font assets from external servers (a process that can slow down app launch times), we embedded the fonts directly within the app, ensuring that the necessary font files were available offline. By carefully managing the fonts and removing the unnecessary ones, we were able to significantly reduce the size of the APK, and this optimization played a key role in keeping the app size under 8 MB.\u003c/p\u003e\u003ch2 id=\"2b8e\"\u003e4. Opt for VectorDrawables Over Bitmap Images\u003c/h2\u003e\u003cp id=\"740e\"\u003eOne major change that contributed to the reduced app size was switching from bitmap images to vector drawables. Bitmap images, especially those used for icons and other scalable elements, can add significant size to an app. Vector images, on the other hand, are scalable and typically much smaller in file size. By generally replacing PNGs with SVGs and other vector formats, we were able to dramatically reduce the amount of storage space dedicated to image assets.\u003c/p\u003e\u003cp id=\"37fd\"\u003eHowever, one of the issues we had was that a lot of the PNG files never was on Figma, as we inherited the app from elsewhere, and working files were already lost. As a result, we relied on online resources to help convert PNG to SVG. Despite Adobe offering a \u003ca href=\"https://www.adobe.com/express/feature/image/convert/png-to-svg\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efree service\u003c/a\u003e, We found \u003ca href=\"https://www.freeconvert.com/png-to-svg\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethis\u003c/a\u003e to be the most effective. (Adobe ends up keeping a lot of strange artifacts)\u003c/p\u003e\u003cp id=\"9f05\"\u003eWe also took advantage of \u003ca href=\"https://github.com/alexjlockwood/avocado\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eAvocado\u003c/a\u003e, which allows us to further optimize the VectorDrawables by removing unnecessary points between lines, for example. However, some of the assets we migrated from PNGs had jagged edges, primarily because that’s generally how rasterized images end up being. We felt it was too much effort to clean that up, for a measly… few hundred bytes of savings, so we left them there.\u003c/p\u003e\u003ch2 id=\"cb79\"\u003e5. Optimize Dependencies and Modularize the Code\u003c/h2\u003e\u003cp id=\"9a69\"\u003eNext, we took a close look at the third-party dependencies we were using. Many of these dependencies were large, adding unnecessary bloat to the app. One example was the Facebook Libraries.\u003c/p\u003e\u003cp id=\"1dc4\"\u003eWe initially used this particular library, which loads up everything Facebook has:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1dee\"\u003e// Facebook Android SDK (everything)\u003cbr/\u003eimplementation \u0026#39;com.facebook.android:facebook-android-sdk:latest.release\u0026#39;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f016\"\u003eHowever, since we do not use everything Facebook have to offer, we opted for a lesser variant, thus saving us a tremendous amount of space as well.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"50ec\"\u003e// Facebook Core only (Analytics)\u003cbr/\u003eimplementation \u0026#39;com.facebook.android:facebook-core:latest.release\u0026#39;\u003cp\u003e    // Facebook Marketing only\u003cbr/\u003eimplementation \u0026#39;com.facebook.android:facebook-marketing:latest.release\u0026#39;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c938\"\u003eBy making sure that we only use dependencies that were strictly needed, we significantly reduced the app’s size. Techniques like “gradle dependency management” allowed us to strip down these libraries to their essentials, further optimizing the app’s build configuration.\u003c/p\u003e\u003ch2 id=\"b90d\"\u003e6. Compress Assets Without Losing Quality\u003c/h2\u003e\u003cp id=\"5a9b\"\u003eAsset compression was another vital step in reducing the app size. Tools like \u003ca href=\"https://imageoptim.com/mac\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eImageOptim\u003c/a\u003e allowed us to reduce a significant amount of image file size by repurposing images with better compression.\u003c/p\u003e\u003cp id=\"73a2\"\u003eAndroid Studio of course allows one to automatically convert images to WebP, whenever ideal:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"aa25\"\u003e7. Optimizing Lottie Files for Faster Load Times and Smaller Size\u003c/h2\u003e\u003cp id=\"937a\"\u003eOn WINK+, we use Lottie animations to enhance the user experience. Lottie files, which are JSON-based animations, have become a popular choice for app developers due to their lightweight nature and ability to scale without losing quality. They allow for smooth, high-quality animations that are much smaller in size compared to traditional video or GIF animations. However, even Lottie files can contribute to an app’s size if not optimized properly, especially if they include unnecessary layers or are too complex.\u003c/p\u003e\u003cp id=\"2321\"\u003eTo reduce the overall size of Lottie animations used in WINK+, we employed several optimization strategies. First, we ensured that the animations themselves were as simple as possible. Lottie animations can sometimes include superfluous data, like extraneous keyframes or unnecessary assets embedded in the JSON file. Using the \u003cstrong\u003eLottieFiles\u003c/strong\u003e web-based asset optimizer, we were able to trim down these animations and remove unnecessary properties and redundant elements, making our Lottie files smaller and faster to load. We were, surprisingly, able to reduce around 1MB of file size just with this.\u003c/p\u003e\u003ch2 id=\"7c41\"\u003e8. Test, Iterate, and Monitor\u003c/h2\u003e\u003cp id=\"0e28\"\u003eOnce the app was optimized and its size reduced to below 10MB, we conducted extensive testing. It was crucial to ensure that the app’s performance, features, and overall user experience were not affected. We continuously monitored app performance on different devices. In our case, we use \u003ca href=\"https://newrelic.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eNewRelic\u003c/a\u003e for APM.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eYay! 7.85MB!\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"f15f\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"217a\"\u003eReducing app size can significantly boost download rates, as users often prefer smaller apps due to concerns about data usage, download times, and device storage. Research indicates that for every 6 MB increase in an Android app’s size, the install conversion rate decreases by 1%.\u003c/p\u003e\u003cp id=\"8458\"\u003eThis trend is even more pronounced in emerging markets, where data costs and limited storage are major considerations. In countries like India and Brazil, a 10 MB reduction in app size can lead to a 2.5% increase in install conversion rates.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eInstall conversion rate increase per 10MB decrease in APK size by select market (\u003ca href=\"https://medium.com/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2\" rel=\"noopener\"\u003esource\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2dd7\"\u003eIn conclusion, reducing the size of the WINK+ app to less than 10MB while maintaining a wider range of feature sets compared to similar apps was a challenging but rewarding process. By leveraging strategies such as optimizing resources, modularizing the code, using App Bundles, and focusing on efficient compression techniques, we were able to deliver a lean, fast, and efficient app. As app sizes continue to grow across the Android ecosystem, this experience has reinforced the importance of size optimization — not just for user convenience but also for improving app performance and engagement.\u003c/p\u003e\u003cp id=\"5741\"\u003eHappy coding!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-12-29T17:27:10.634Z",
  "modifiedTime": null
}
