{
  "id": "a3d889b2-4531-4c42-9465-f3c983d9d531",
  "title": "5 steps to implement MVI architecture with Jetpack Compose",
  "link": "https://blog.kotlin-academy.com/5-steps-to-implement-mvi-architecture-with-jetpack-compose-383c4f72406f?source=rss----e57b304801ef---4",
  "description": "",
  "author": "Anitaa Murthy",
  "published": "Tue, 03 Dec 2024 07:16:12 GMT",
  "source": "https://blog.kotlin-academy.com/feed",
  "categories": [
    "android",
    "androiddev",
    "kotlin",
    "android-app-development",
    "mvi"
  ],
  "byline": "Anitaa Murthy",
  "length": 4380,
  "excerpt": "I worked on a simple Notes app recently to get to understand MVI architecture a bit more and I thought I’d share my learnings here. MVI (Model-View-Intent) is an architectural pattern used in Android…",
  "siteName": "Kt. Academy",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*2grDGjzH0tfX8XiaF4Izaw.png",
  "text": "I worked on a simple Notes app recently to get to understand MVI architecture a bit more and I thought I’d share my learnings here. MVI (Model-View-Intent) is an architectural pattern used in Android development for building user interfaces in a way that is predictable, testable, and maintainable. MVI is built on three main concepts:The Model: represents the state of the UI at any given time. It serves as the single source of truth for the View. The state of the model is immutable, meaning each state change creates a new instance of the model. This immutability ensures the state is predictable and prevents unintended side effects.The View: is responsible for displaying the UI based on the current state (Model). MVI typically uses a declarative approach, allowing the View to automatically refresh when the state changes.The Intent: represents a user action or event that can alter the app’s state. Intents trigger business logic in the ViewModel to compute a new state and update the Model.How MVI WorksUser Interaction: the user interacts with the UI (e.g., clicks a button), triggering an Intent.Intent Handling: the View sends the Intent to the ViewModel.Business Logic: the ViewModel processes the Intent, interacts with the data layer (if needed), and computes the new Model (state).State Update: the ViewModel emits the updated state back to the View.UI Update: the View observes the state changes and updates the UI accordingly.To practically learn about how MVI works, I worked on a Notes app. It has two screens. The Notes list screen displays a list of notes from the local db. Clicking on the note redirects to a detail screen where users can update or add a new note.For those of you interested in skipping the article, this is the GitHub link.So let’s begin!Step 1: Add dependenciesI have used Hilt and KSP (Kotlin Symbol Processing — similar to KAPT) for injecting our data layer with our UI layer. The other libraries used here are Room library for storing and retrieving the notes from the local db and gson converter for serialisation.I have also used Gradle’s version catalogs to declare dependencies in the app. You can checkout my other articles on version catalogs and Hilt to get a deeper understanding of what is required here. For now, I’ll just share the relevant files used to add these dependencies.We also need to create a custom Application class and annotate it with @HiltAndroidApp and add it to our Manifest file.Step 2: Define Model layerNow that we have our dependencies, we need to create a model class that holds our Note data.We should be able to create our Dao and Database class using Room.We also create a Repository class that interacts with the NoteDao class to fetch/add/update/delete notes from the db.Step 3: Define ViewState \u0026 IntentThe NoteUiViewState class is the single source of truth for the UI in the notes list screen. It holds all the necessary data required to represent the current state of the UI.The NoteIntent sealed class encapsulates all the possible actions a user can take on the app. Each intent is a specific user interaction that leads to a change in the application state.Step 4: Define ViewModel \u0026 EventManagerThe NotesViewModel class plays a crucial role in managing the UI’s state and handling user interactions in an MVI-based architecture. It inherits from the ViewModel class, which provides lifecycle awareness and makes it possible to manage UI-related data efficiently, especially during configuration changes like screen rotations.In addition to managing the state, the ViewModel handles one-time events (or side effects) such as displaying a snackbar message or redirecting to the detail screen, using a Channel. Since these one-time events will be application wide, we are creating an EventManager class.Step 5: Add UI layerThe MainApp composable is the central piece of the notes app UI. It is responsible for rendering the entire UI and interacting with the ViewModel to reflect the application’s current state. This composable follows MVI principles, ensuring a unidirectional data flow and handling state management and effects (like snackbar notifications) in a reactive manner.The NotesScreen composable observes the state changes from the ViewModel and updates the UI reactively.The NoteItem composable implementation can be found here and the entire implementation can be found here.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*xRZ-Ptjiae6KXNk0fJA1vA.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp id=\"0d9b\"\u003eI worked on a simple Notes app recently to get to understand MVI architecture a bit more and I thought I’d share my learnings here. MVI (Model-View-Intent) is an architectural pattern used in Android development for building user interfaces in a way that is predictable, testable, and maintainable. MVI is built on three main concepts:\u003c/p\u003e\u003cul\u003e\u003cli id=\"3ba0\"\u003eThe \u003cstrong\u003eModel\u003c/strong\u003e: represents the \u003cstrong\u003estate of the UI\u003c/strong\u003e at any given time. It serves as the \u003cstrong\u003esingle source of truth\u003c/strong\u003e for the View. The state of the model is \u003cstrong\u003eimmutable\u003c/strong\u003e, meaning each state change creates a new instance of the model. This immutability ensures the state is predictable and prevents unintended side effects.\u003c/li\u003e\u003cli id=\"e27d\"\u003eThe \u003cstrong\u003eView\u003c/strong\u003e: is responsible for \u003cstrong\u003edisplaying the UI\u003c/strong\u003e based on the current state (Model). MVI typically uses a declarative approach, allowing the View to automatically refresh when the state changes.\u003c/li\u003e\u003cli id=\"0fef\"\u003eThe \u003cstrong\u003eIntent\u003c/strong\u003e: represents a \u003cstrong\u003euser action\u003c/strong\u003e or \u003cstrong\u003eevent\u003c/strong\u003e that can alter the app’s state. Intents trigger business logic in the ViewModel to compute a new state and update the Model.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"03fb\"\u003eHow MVI Works\u003c/h2\u003e\u003cul\u003e\u003cli id=\"fd05\"\u003e\u003cstrong\u003eUser Interaction\u003c/strong\u003e: the user interacts with the UI (e.g., clicks a button), triggering an \u003ccode\u003eIntent\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7211\"\u003e\u003cstrong\u003eIntent Handling\u003c/strong\u003e: the View sends the \u003ccode\u003eIntent\u003c/code\u003e to the ViewModel.\u003c/li\u003e\u003cli id=\"e2e1\"\u003e\u003cstrong\u003eBusiness Logic\u003c/strong\u003e: the ViewModel processes the Intent, interacts with the data layer (if needed), and computes the new \u003ccode\u003eModel\u003c/code\u003e (state).\u003c/li\u003e\u003cli id=\"0ad8\"\u003e\u003cstrong\u003eState Update\u003c/strong\u003e: the ViewModel emits the updated state back to the View.\u003c/li\u003e\u003cli id=\"75e5\"\u003e\u003cstrong\u003eUI Update\u003c/strong\u003e: the View observes the state changes and updates the UI accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"548e\"\u003eTo practically learn about how MVI works, I worked on a Notes app. It has two screens. The Notes list screen displays a list of notes from the local db. Clicking on the note redirects to a detail screen where users can update or add a new note.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"30cb\"\u003eFor those of you interested in skipping the article, this is the GitHub link.\u003c/p\u003e\u003cp id=\"1c99\"\u003eSo let’s begin!\u003c/p\u003e\u003ch2 id=\"5fd5\"\u003eStep 1: Add dependencies\u003c/h2\u003e\u003cp id=\"3653\"\u003eI have used \u003ca href=\"https://developer.android.com/training/dependency-injection/hilt-android\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eHilt\u003c/a\u003e and \u003ca href=\"https://github.com/google/ksp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eKSP\u003c/a\u003e (Kotlin Symbol Processing — similar to \u003cstrong\u003eKAPT\u003c/strong\u003e) for injecting our data layer with our UI layer. The other libraries used here are \u003cstrong\u003eRoom library\u003c/strong\u003e for storing and retrieving the notes from the local db and \u003ca href=\"https://github.com/google/gson\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egson converter\u003c/a\u003e for serialisation.\u003c/p\u003e\u003cp id=\"9839\"\u003eI have also used Gradle’s \u003ca href=\"https://docs.gradle.org/current/userguide/platforms.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eversion catalogs\u003c/a\u003e to declare dependencies in the app. You can checkout my other articles on \u003ca href=\"https://medium.com/@anitaa_1990/4-minute-guide-on-adding-dependencies-using-version-catalogs-f68cced04fcd\" rel=\"noopener\"\u003eversion catalogs\u003c/a\u003e and \u003ca href=\"https://medium.com/@anitaa_1990/5-minute-guide-on-understanding-hilt-annotations-50fe33b1919b\" rel=\"noopener\"\u003eHilt\u003c/a\u003e to get a deeper understanding of what is required here. For now, I’ll just share the relevant files used to add these dependencies.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"2458\"\u003eWe also need to create a custom \u003ccode\u003eApplication\u003c/code\u003e class and annotate it with \u003ccode\u003e@HiltAndroidApp\u003c/code\u003e and add it to our Manifest file.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"bd1e\"\u003eStep 2: Define Model layer\u003c/h2\u003e\u003cp id=\"71b9\"\u003eNow that we have our dependencies, we need to create a model class that holds our \u003ccode\u003eNote\u003c/code\u003e data.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"d642\"\u003eWe should be able to create our \u003ccode\u003eDao\u003c/code\u003e and \u003ccode\u003eDatabase\u003c/code\u003e class using Room.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"fa59\"\u003eWe also create a \u003ccode\u003eRepository\u003c/code\u003e class that interacts with the \u003ccode\u003eNoteDao\u003c/code\u003e class to fetch/add/update/delete notes from the db.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"3d04\"\u003eStep 3: Define ViewState \u0026amp; Intent\u003c/h2\u003e\u003cp id=\"5ce5\"\u003eThe \u003ccode\u003eNoteUiViewState\u003c/code\u003e class is the single source of truth for the UI in the notes list screen. It holds all the necessary data required to represent the current state of the UI.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"cc71\"\u003eThe \u003ccode\u003eNoteIntent\u003c/code\u003e sealed class encapsulates all the possible actions a user can take on the app. Each intent is a specific user interaction that leads to a change in the application state.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"c83c\"\u003eStep 4: Define ViewModel \u0026amp; EventManager\u003c/h2\u003e\u003cp id=\"5601\"\u003eThe \u003ccode\u003eNotesViewModel\u003c/code\u003e class plays a crucial role in managing the UI’s state and handling user interactions in an MVI-based architecture. It inherits from the \u003ccode\u003eViewModel\u003c/code\u003e class, which provides lifecycle awareness and makes it possible to manage UI-related data efficiently, especially during configuration changes like screen rotations.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f58f\"\u003eIn addition to managing the state, the ViewModel handles one-time events (or side effects) such as displaying a snackbar message or redirecting to the detail screen, using a \u003ccode\u003eChannel\u003c/code\u003e. Since these one-time events will be application wide, we are creating an \u003ccode\u003eEventManager\u003c/code\u003e class.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"9048\"\u003eStep 5: Add UI layer\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c491\"\u003eThe \u003ccode\u003eMainApp\u003c/code\u003e composable is the central piece of the notes app UI. It is responsible for rendering the entire UI and interacting with the ViewModel to reflect the application’s current state. This composable follows MVI principles, ensuring a unidirectional data flow and handling state management and effects (like snackbar notifications) in a reactive manner.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9f03\"\u003eThe \u003ccode\u003eNotesScreen\u003c/code\u003e composable observes the state changes from the \u003ccode\u003eViewModel\u003c/code\u003e and updates the UI reactively.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"36fb\"\u003eThe \u003ccode\u003eNoteItem\u003c/code\u003e composable implementation can be found \u003ca href=\"https://github.com/anitaa1990/NotesApp/blob/main/app/src/main/java/com/an/notesapp/view/ui/screen/NotesScreen.kt\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e and the entire implementation can be found \u003ca href=\"https://github.com/anitaa1990/NotesApp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-11-30T19:13:26.29Z",
  "modifiedTime": null
}
