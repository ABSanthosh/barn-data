{
  "id": "bca12f46-2873-4b1b-ad07-a6dd308511dc",
  "title": "A stable, multiplatform Molecule 1.0",
  "link": "https://code.cash.app/molecule-1-0",
  "description": "",
  "author": "",
  "published": "2023-07-19T00:00:00+00:00",
  "source": "https://jakewharton.com/atom.xml",
  "categories": null,
  "byline": "Jake Wharton",
  "length": 3325,
  "excerpt": "Molecule is a Compose-based library which we announced two years ago for managing application state. I’m excited to announce that today we are releasing version 1.0, its first stable version!",
  "siteName": "Cash App Code Blog",
  "favicon": "https://code.cash.app/assets/icon-196.png",
  "text": "Posted by Jake Wharton on July 19, 2023 Molecule is a Compose-based library which we announced two years ago for managing application state. I’m excited to announce that today we are releasing version 1.0, its first stable version! In the time since the original post, Molecule has gained two major features: Support for Kotlin multiplatform targets (JVM, JS, and native) in addition to just Android. An immediate recomposition mode saving you from needing to supply a frame clock. How are these useful? Let’s look at an example! A pure Compose UI app may separate state-producing composables from UI-rendering composables. @Composable fun counter(start: Int = 0): Int { var count by remember { mutableStateOf(start) } LaunchedEffect(Unit) { while (true) { delay(1.seconds) count++ } } return count } @Composable fun CounterText(value: Int) { Text(\"$value\", fontSize = 20.sp) } Now CounterText() can easily be used with @Preview and/or Paparazzi snapshot testing. The state-producing counter() can be even more powerful as used alongside features of Molecule. Increasing reuse Migrating a large, View-based Android app to Compose UI takes a very long time. Instead of keeping state logic written in libraries like RxJava during the UI rewrite, logic can be migrated to Compose early and exposed to Views as a StateFlow. fun CoroutineScope.launchCounter(start: Int = 0): StateFlow\u003cInt\u003e { return launchMolecule(mode = ContextClock) { counter(start) } } With Compose running outside the context of Compose UI and producing plain data, other destinations like notifications, widgets, and more can become the target of your output. Separating the clock It doesn’t always make sense to recompose counter() at the rate of the UI framework when using it more like a presenter. Molecule’s “immediate” recomposition mode triggers whenever there are new changes to produce. fun countFlow(start: Int = 0): Flow\u003cInt\u003e { return moleculeFlow(mode = Immediate) { counter(start) } } This Flow will produce a new value every second, since that’s when the internal timer updates the internal count and notifies Compose of pending state change. Simplifying testing The logic of counter() exposed as a Flow can now be unit tested with Turbine. @Test fun counts() = runTest { countFlow().test { assertEquals(0, awaitItem()) assertEquals(1, awaitItem()) assertEquals(2, awaitItem()) } } @Test fun countStart() = runTest { countFlow(start = 3).test { assertEquals(3, awaitItem()) assertEquals(4, awaitItem()) } } And these unit tests will run on the JVM, because… Multiplatform usage Molecule runs on every Kotlin multiplatform target supported by the JetBrains Compose runtime. So in addition to enabling unit tests on the JVM, your counter() can now be run on platforms like iOS targeting SwiftUI or the web targeting the DOM. suspend fun main() { val count = document.getElementById(\"count\") countFlow().collect { value -\u003e count.innerText = \"$value\" } } Whether it’s a 100% Compose UI Android app, a Kotlin multiplatform project with many targets, or something in-between, Molecule is here to help you manage state using Compose. This post is part of Cash App’s Summer of Kotlin Multiplatform series.",
  "image": "https://code.cash.app/assets/social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n  \n\n  \u003cdiv\u003e\u003cp\u003e\n    Posted by\n    \u003ca href=\"https://jakewharton.com/\"\u003eJake Wharton\u003c/a\u003e\n    \n      \u003cspan\u003eon \u003c/span\u003e\u003ctime datetime=\"2023-07-19 00:00:00 +0000\"\u003eJuly 19, 2023\u003c/time\u003e\n    \n  \u003c/p\u003e\u003c/div\u003e\n\n  \u003cp\u003eMolecule is a Compose-based library which we \u003ca href=\"https://code.cash.app/the-state-of-managing-state-with-compose\"\u003eannounced two years ago\u003c/a\u003e for managing application state. I’m excited to announce that today we are releasing version 1.0, its first stable version!\u003c/p\u003e\n\n\u003cp\u003eIn the time since the original post, Molecule has gained two major features:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eSupport for Kotlin multiplatform targets (JVM, JS, and native) in addition to just Android.\u003c/li\u003e\n  \u003cli\u003eAn immediate recomposition mode saving you from needing to supply a frame clock.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eHow are these useful? Let’s look at an example!\u003c/p\u003e\n\n\u003cp\u003eA pure Compose UI app may separate state-producing composables from UI-rendering composables.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@Composable\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003eby\u003c/span\u003e \u003cspan\u003eremember\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003emutableStateOf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003eLaunchedEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eUnit\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003edelay\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eseconds\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e@Composable\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eCounterText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;$value\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efontSize\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e20\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esp\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNow \u003ccode\u003eCounterText()\u003c/code\u003e can easily be used with \u003ccode\u003e@Preview\u003c/code\u003e and/or \u003ca href=\"https://cashapp.github.io/paparazzi/\"\u003ePaparazzi\u003c/a\u003e snapshot testing. The state-producing \u003ccode\u003ecounter()\u003c/code\u003e can be even more powerful as used alongside features of Molecule.\u003c/p\u003e\n\u003ch3 id=\"increasing-reuse\"\u003eIncreasing reuse\u003c/h3\u003e\n\u003cp\u003eMigrating a large, \u003ccode\u003eView\u003c/code\u003e-based Android app to Compose UI takes a very long time. Instead of keeping state logic written in libraries like RxJava during the UI rewrite, logic can be migrated to Compose early and exposed to \u003ccode\u003eView\u003c/code\u003es as a \u003ccode\u003eStateFlow\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003eCoroutineScope\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elaunchCounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e \u003cspan\u003eStateFlow\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003elaunchMolecule\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emode\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eContextClock\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ecounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith Compose running outside the context of Compose UI and producing plain data, other destinations like notifications, widgets, and more can become the target of your output.\u003c/p\u003e\n\n\u003ch3 id=\"separating-the-clock\"\u003eSeparating the clock\u003c/h3\u003e\n\n\u003cp\u003eIt doesn’t always make sense to recompose \u003ccode\u003ecounter()\u003c/code\u003e at the rate of the UI framework when using it more like a presenter. Molecule’s “immediate” recomposition mode triggers whenever there are new changes to produce.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecountFlow\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e \u003cspan\u003eFlow\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003emoleculeFlow\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emode\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eImmediate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ecounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis \u003ccode\u003eFlow\u003c/code\u003e will produce a new value every second, since that’s when the internal timer updates the internal \u003ccode\u003ecount\u003c/code\u003e and notifies Compose of pending state change.\u003c/p\u003e\n\n\u003ch3 id=\"simplifying-testing\"\u003eSimplifying testing\u003c/h3\u003e\n\n\u003cp\u003eThe logic of \u003ccode\u003ecounter()\u003c/code\u003e exposed as a \u003ccode\u003eFlow\u003c/code\u003e can now be unit tested with \u003ca href=\"https://github.com/cashapp/turbine/\"\u003eTurbine\u003c/a\u003e.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@Test\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecounts\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erunTest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ecountFlow\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003etest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eassertEquals\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eawaitItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n    \u003cspan\u003eassertEquals\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eawaitItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n    \u003cspan\u003eassertEquals\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eawaitItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e@Test\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003ecountStart\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erunTest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ecountFlow\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estart\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003etest\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eassertEquals\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eawaitItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n    \u003cspan\u003eassertEquals\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eawaitItem\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd these unit tests will run on the JVM, because…\u003c/p\u003e\n\n\u003ch3 id=\"multiplatform-usage\"\u003eMultiplatform usage\u003c/h3\u003e\n\n\u003cp\u003eMolecule runs on every Kotlin multiplatform target supported by the JetBrains Compose runtime. So in addition to enabling unit tests on the JVM, your \u003ccode\u003ecounter()\u003c/code\u003e can now be run on platforms like iOS targeting SwiftUI or the web targeting the DOM.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003esuspend\u003c/span\u003e \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eval\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edocument\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetElementById\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;count\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003ecountFlow\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003ecollect\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e\n    \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einnerText\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;$value\u0026#34;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003eWhether it’s a 100% Compose UI Android app, a Kotlin multiplatform project with many targets, or something in-between, \u003ca href=\"https://github.com/cashapp/molecule/\"\u003eMolecule\u003c/a\u003e is here to help you manage state using Compose.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eThis post is part of Cash App’s \u003ca href=\"https://code.cash.app/kotlin-multiplatform-summer\"\u003eSummer of Kotlin Multiplatform\u003c/a\u003e series.\u003c/em\u003e\u003c/p\u003e\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2023-07-19T00:00:00Z",
  "modifiedTime": null
}
