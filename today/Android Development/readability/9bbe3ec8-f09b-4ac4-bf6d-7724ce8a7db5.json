{
  "id": "9bbe3ec8-f09b-4ac4-bf6d-7724ce8a7db5",
  "title": "New ways of optimizing stability in Jetpack Compose",
  "link": "https://medium.com/androiddevelopers/new-ways-of-optimizing-stability-in-jetpack-compose-038106c283cc?source=rss----95b274b437c2---4",
  "description": "",
  "author": "Tomáš Mlynarič",
  "published": "Mon, 08 Jul 2024 16:45:50 GMT",
  "source": "https://medium.com/feed/androiddevelopers",
  "categories": [
    "performance",
    "android-development",
    "jetpack-compose",
    "optimization"
  ],
  "byline": "Tomáš Mlynarič",
  "length": 10081,
  "excerpt": "Master stability optimization in Jetpack Compose with strong skipping mode. Learn what to control manually and why immutable collections aren't needed.",
  "siteName": "Android Developers",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "The new strong skipping mode for controlling class stability in Jetpack Compose changes how to optimize recompositions in your app. In this blog post, we’ll cover what cases it solves for you and what needs to be manually controlled. We’ll also cover common questions you’ve had, such as whether remembering lambda functions is still needed, if kotlinx immutable collections are needed, or even how to stabilize all your domain model classes. If you’re not sure what stability is, see our documentation to learn the concepts.Stability before strong skipping modeThere are several reasons why the Compose compiler might treat a class as unstable:It’s a mutable class. For example, it contains a mutable property (not backed by snapshot state).It’s a class defined in a Gradle module that doesn’t use Compose (doesn’t have a dependency on the Compose compiler).It’s a class that contains an unstable property (instability nesting).Let’s consider the following class:data class Subscription( // class is unstable val id: Int, // stable val planName: String, // stable val renewalOn: LocalDate // unstable)The id and planName properties are stable, because they are of a primitive type, which is immutable. However, the renewalOn property is unstable, because java.time.LocalDate comes from the Java standard library, which doesn’t have a dependency on the Compose compiler. Because of that, the whole Subscription class is unstable.Consider the following example with a state property using the Subscription class, which is passed to a SubscriptionComposable:// create in a state holder (for example, ViewModel)var state by mutableStateOf(Subscription( id = 1, planName = \"30 days\", renewalOn = LocalDate.now().plusDays(30)))@Composablefun SubscriptionComposable(input: Subscription) { // always recomposed regardless if input changed or not}Historically, a composable with the input parameter of this unstable class would not be determined as skippable, and it would always be recomposed regardless if the inputs changed or not.Stability with strong skipping modeJetpack Compose compiler 1.5.4 and higher comes with an option to enable strong skipping mode, which always generates the skipping logic regardless of the stability of the input parameters. This mode allows composables with unstable classes to be skipped. You can read more about strong skipping mode and how to enable it in our documentation or in the blog post by Ben Trengrove.Strong skipping mode has two ways of determining if the input parameter changed from the previous composition:If the class is stable, it uses the structural equality (.equals()).If the class is unstable, it uses the referential equality (===).After you enable strong skipping mode in your project, composables that use the unstable Subscription class won’t recompose if the instance is the same as in the previous composition.So let’s say you have the SubscriptionComposable used in a different composable Screen that takes a parameter inputText. If that inputText parameter changes and the subscription parameter doesn’t, the SubscriptionComposable doesn’t recompose and is skipped:@Composablefun Screen(inputText: String, subscription: Subscription) { Text(inputText) // It's skipped when subscription parameter didn't change SubscriptionComposable(subscription)}But let’s say you have a function renewSubscription that updates the state variable with the current day to keep track of latest day when a change occurred:fun renewSubscription() { state = state.copy(renewalOn = LocalDate.now().plusDays(30))}The copy function creates a new instance of the class with the same structural properties (if it occurs during the same day), which means that the SubscriptionComposable would recompose again, because strong skipping mode compares unstable classes with referential equality (===) and copy is creating a new instance of our subscription. Even though the date is the same, because referential equality is being used, the Subscription composable is still recomposed.Control stability with annotationsIf you want to prevent the SubscriptionComposable from recomposing when the structural data doesn’t change (equals() returns the same outcome), you need to manually mark the Subscription class as stable.In this case, it’s a simple fix by annotating the class with @Immutable, because the class represented here can’t be mutated:+@Immutable -data class Subscription( // unstable+data class Subscription( // stable val id: Int, // stable val planName: String, // stable val renewalOn: LocalDate // unstable)In this example, when the renewSubscription is called, the SubscriptionComposable will be skipped again, because now it uses the equals() function instead of ===, which will return true compared to the previous state.When can this occur?A realistic example of when you’ll still need to annotate your classes as @Immutable is when you use entities coming from the peripherals of your system, such as database entities, API entities, Firestore changes, or others.Because these entities are parsed every time from the underlying data, they create new instances every time. Therefore, without the annotation, they would recompose.Note: Recomposing can be faster than calling equals() on every parameter. You should always measure the effect of your changes when optimizing stability.Control stability with stability configuration fileFor classes that aren’t part of your codebase, our guidance used to be that the only way to stabilize them is wrapping the class with a class that is part of your codebase and annotate that class as @Immutable instead.Consider an example, where you’d have a composable that directly accepts the java.time.LocalDate parameter:@Composablefun LatestChangeOn(updated: LocalDate) { // present the day parameter on screen}If you call the renewSubscription function to update the latest change, you’ll end up in a similar situation as before — the LatestChangeOn composable keeps recomposing, regardless if it’s the same day or not. However, there’s no possibility of annotating that class in this situation, because it’s part of the standard library.To fix this, you can enable a stability configuration file, which can contain classes or patterns of classes that will be considered stable by the Compose compiler.To enable it, add stabilityConfigurationFile to the composeCompiler configuration:composeCompiler { ... // Set path of the config file stabilityConfigurationFile = rootProject.file(\"stability_config.conf\")}And create the stability_config.conf file in the root folder of your project, in which you add the LocalDate class:// add the immutable classes outside of your codebasejava.time.LocalDate// alternatively you can stabilize all java.time classes with *java.time.*Stabilize your domain model classesIn addition to classes that aren’t part of your codebase, the stability configuration file can be helpful for stabilizing all your data or domain model classes (assuming they’re immutable). This way, the domain module can be a Java Gradle module and doesn’t need dependency on the Compose compiler.// stabilize all classes in model packagecom.example.app.domain.model.*Be aware of breaking the rulesBe aware that annotating a mutable class with the @Immutable annotation, or adding the class to the stability configuration file, can be a source of bugs in your codebase, because the Compose compiler isn't capable of verifying the contract and it might show up as something isn't recomposing when you think it should.Forget the need to remember() lambdasOne other benefit of strong skipping is that it “remembers” all lambdas used in composition, even the ones with unstable captures. Previously, lambdas that were using an unstable class, for example a ViewModel, might’ve been the cause of recomposition. One of the common workarounds was remembering the lambda functions.So, if you have lambdas wrapped with remember in your codebase, you can safely remove the remember call, because it is done automatically by the Compose compiler:Screen(-removeItem = remember(viewModel){ { id -\u003e viewModel.removeItem(id) } }+removeItem = { id -\u003e viewModel.removeItem(id) })Are immutable collections still needed?The kotlinx.collections.immutable collections like ImmutableList could’ve been used in the past to make a List of items stable and thus preventing a composable from recomposing. If you have them in your codebase purely for the purpose of preventing recompositions of composables with List parameters, you could consider refactoring them to a regular List and add java.util.List into the stability configuration file.But!If you do that, your composable might be slower than if the List parameter was unstable!Adding List to the stability configuration file means the List parameter is compared with the equals call, which eventually leads to calling equals on every single item of that list. In the context of a lazy list, the same equals check is then called again from the perspective of the item composable, which results in calculating the equals() call twice for many of the visible items, and possibly needlessly for all the items that aren’t visible!If the composable containing the List parameter doesn’t have many other UI components, recomposing it can be faster than calculating the equals() check.However, there’s no one size fits all approach here, so you should verify your choice with benchmarks!SummaryBy enabling strong skipping mode in your code base, you can reduce the need to manually craft classes to be stable. Be aware that in some cases, they still need manual crafting, but this can now be simplified with the stability configuration file!We hope all of these changes will simplify the mental load of thinking about stability in Compose.Want more? See our codelab on practical performance problem solving in Compose.The code snippets in this blog have the following license:// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*aNUdBFqWyx66yIVqt7mBWQ.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@mlykotom?source=post_page-----038106c283cc--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Tomáš Mlynarič\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Bzp4PQR1hKYu1RFShfKF9A.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/androiddevelopers?source=post_page-----038106c283cc--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Android Developers\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*4Tg6pPzer7cIarYaszIKaQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"5826\"\u003eThe new \u003ca href=\"https://developer.android.com/develop/ui/compose/performance/stability/strongskipping\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003estrong skipping mode\u003c/a\u003e for controlling class stability in Jetpack Compose changes how to optimize recompositions in your app. In this blog post, we’ll cover what cases it solves for you and what needs to be manually controlled. We’ll also cover common questions you’ve had, such as whether remembering lambda functions is still needed, if \u003ccode\u003ekotlinx\u003c/code\u003e immutable collections are needed, or even how to stabilize all your domain model classes. If you’re not sure what stability is, see our \u003ca href=\"https://developer.android.com/develop/ui/compose/performance/stability\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e to learn the concepts.\u003c/p\u003e\u003ch2 id=\"3b79\"\u003eStability before strong skipping mode\u003c/h2\u003e\u003cp id=\"2a16\"\u003eThere are several reasons why the Compose compiler might treat a class as unstable:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f387\"\u003eIt’s a mutable class. For example, it contains a mutable property (not backed by snapshot state).\u003c/li\u003e\u003cli id=\"2a25\"\u003eIt’s a class defined in a Gradle module that doesn’t use Compose (doesn’t have a dependency on the Compose compiler).\u003c/li\u003e\u003cli id=\"6228\"\u003eIt’s a class that contains an unstable property (instability nesting).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0cae\"\u003eLet’s consider the following class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ae52\"\u003edata class Subscription(          // class is unstable\u003cbr/\u003e    val id: Int,                  // stable\u003cbr/\u003e    val planName: String,         // stable\u003cbr/\u003e    val renewalOn: LocalDate      // unstable\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"892f\"\u003eThe \u003ccode\u003eid\u003c/code\u003e and \u003ccode\u003eplanName\u003c/code\u003e properties are stable, because they are of a primitive type, which is immutable. However, the \u003ccode\u003erenewalOn\u003c/code\u003e property is unstable, because \u003ccode\u003ejava.time.LocalDate\u003c/code\u003e comes from the Java standard library, which doesn’t have a dependency on the Compose compiler. Because of that, the whole \u003ccode\u003eSubscription\u003c/code\u003e class is unstable.\u003c/p\u003e\u003cp id=\"40d3\"\u003eConsider the following example with a \u003ccode\u003estate\u003c/code\u003e property using the \u003ccode\u003eSubscription\u003c/code\u003e class, which is passed to a \u003ccode\u003eSubscriptionComposable\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2181\"\u003e// create in a state holder (for example, ViewModel)\u003cbr/\u003evar state by mutableStateOf(Subscription(\u003cbr/\u003e  id = 1,\u003cbr/\u003e  planName = \u0026#34;30 days\u0026#34;,\u003cbr/\u003e  renewalOn = LocalDate.now().plusDays(30)\u003cbr/\u003e))\u003cp\u003e@Composable\u003cbr/\u003efun SubscriptionComposable(input: Subscription) {\u003cbr/\u003e    // always recomposed regardless if input changed or not\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8319\"\u003eHistorically, a composable with the \u003ccode\u003einput\u003c/code\u003e parameter of this unstable class would not be determined as skippable, and it would always be recomposed regardless if the inputs changed or not.\u003c/p\u003e\u003ch2 id=\"781e\"\u003eStability with strong skipping mode\u003c/h2\u003e\u003cp id=\"6cf2\"\u003eJetpack Compose compiler 1.5.4 and higher comes with an option to enable strong skipping mode, which \u003cstrong\u003ealways\u003c/strong\u003e generates the skipping logic regardless of the stability of the input parameters. This mode allows composables with unstable classes to be skipped. You can read more about strong skipping mode and how to enable it in our \u003ca href=\"https://developer.android.com/develop/ui/compose/performance/stability/strongskipping\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edocumentation\u003c/a\u003e or in the \u003ca rel=\"noopener\" href=\"https://medium.com/androiddevelopers/jetpack-compose-strong-skipping-mode-explained-cbdb2aa4b900\"\u003eblog post\u003c/a\u003e by \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/84718b19bc40?source=post_page-----038106c283cc--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eBen Trengrove\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e.\u003c/p\u003e\u003cp id=\"6f6c\"\u003eStrong skipping mode has two ways of determining if the input parameter changed from the previous composition:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0443\"\u003eIf the class is stable, it uses the structural equality (\u003ccode\u003e.equals()\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"8205\"\u003eIf the class is unstable, it uses the referential equality (\u003ccode\u003e===\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f27d\"\u003eAfter you enable strong skipping mode in your project, composables that use the unstable \u003ccode\u003eSubscription\u003c/code\u003e class won’t recompose if \u003cstrong\u003ethe instance is the same as in the previous composition\u003c/strong\u003e.\u003c/p\u003e\u003cp id=\"15c4\"\u003eSo let’s say you have the \u003ccode\u003eSubscriptionComposable\u003c/code\u003e used in a different composable \u003ccode\u003eScreen\u003c/code\u003e that takes a parameter \u003ccode\u003einputText\u003c/code\u003e. If that \u003ccode\u003einputText\u003c/code\u003e parameter changes and the \u003ccode\u003esubscription\u003c/code\u003e parameter doesn’t, the \u003ccode\u003eSubscriptionComposable\u003c/code\u003e doesn’t recompose and is skipped:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d884\"\u003e@Composable\u003cbr/\u003efun Screen(inputText: String, subscription: Subscription) {\u003cbr/\u003e    Text(inputText)\u003cp\u003e    // It\u0026#39;s skipped when subscription parameter didn\u0026#39;t change\u003cbr/\u003e    SubscriptionComposable(subscription)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"324c\"\u003eBut let’s say you have a function \u003ccode\u003erenewSubscription\u003c/code\u003e that updates the \u003ccode\u003estate\u003c/code\u003e variable with the current day to keep track of latest day when a change occurred:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e621\"\u003efun renewSubscription() {\u003cbr/\u003e   state = state.copy(renewalOn = LocalDate.now().plusDays(30))\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c66b\"\u003eThe \u003ccode\u003ecopy\u003c/code\u003e function creates a \u003cstrong\u003enew instance\u003c/strong\u003e of the class with the same structural properties (if it occurs during the same day), which means that the \u003ccode\u003eSubscriptionComposable\u003c/code\u003e would recompose again, because strong skipping mode compares unstable classes with referential equality (\u003ccode\u003e===\u003c/code\u003e) and copy is creating a new instance of our subscription. Even though the date is the same, because referential equality is being used, the \u003ccode\u003eSubscription\u003c/code\u003e composable is still recomposed.\u003c/p\u003e\u003ch2 id=\"f8a4\"\u003eControl stability with annotations\u003c/h2\u003e\u003cp id=\"3e82\"\u003eIf you want to prevent the \u003ccode\u003eSubscriptionComposable\u003c/code\u003e from recomposing when the structural data doesn’t change (\u003ccode\u003eequals()\u003c/code\u003e returns the same outcome), you need to manually mark the \u003ccode\u003eSubscription\u003c/code\u003e class as stable.\u003c/p\u003e\u003cp id=\"d785\"\u003eIn this case, it’s a simple fix by annotating the class with \u003ccode\u003e@Immutable\u003c/code\u003e, because the class represented here can’t be mutated:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"214d\"\u003e+@Immutable           \u003cbr/\u003e-data class Subscription(       // unstable\u003cbr/\u003e+data class Subscription(       // stable\u003cbr/\u003e    val id: Int,                // stable\u003cbr/\u003e    val planName: String,       // stable\u003cbr/\u003e    val renewalOn: LocalDate    // unstable\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"da31\"\u003eIn this example, when the \u003ccode\u003erenewSubscription\u003c/code\u003e is called, the \u003ccode\u003eSubscriptionComposable\u003c/code\u003e will be skipped again, because now it uses the \u003ccode\u003eequals()\u003c/code\u003e function instead of \u003ccode\u003e===\u003c/code\u003e, which will return \u003ccode\u003etrue\u003c/code\u003e compared to the previous state.\u003c/p\u003e\u003ch2 id=\"cbb0\"\u003eWhen can this occur?\u003c/h2\u003e\u003cp id=\"b4ab\"\u003eA realistic example of when you’ll still need to annotate your classes as \u003ccode\u003e@Immutable\u003c/code\u003e is when you use entities coming from the peripherals of your system, such as database entities, API entities, \u003ca href=\"https://firebase.google.com/docs/firestore\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eFirestore\u003c/a\u003e changes, or others.\u003c/p\u003e\u003cp id=\"5c8d\"\u003eBecause these entities are parsed every time from the underlying data, they create \u003cstrong\u003enew instances\u003c/strong\u003e every time. Therefore, without the annotation, they would recompose.\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c444\"\u003eNote: Recomposing can be faster than calling \u003ccode\u003eequals()\u003c/code\u003e on every parameter. You should always measure the effect of your changes when optimizing stability.\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"6ac8\"\u003eControl stability with stability configuration file\u003c/h2\u003e\u003cp id=\"da3e\"\u003eFor classes that aren’t part of your codebase, our guidance used to be that the only way to stabilize them is wrapping the class with a class that is part of your codebase and annotate that class as \u003ccode\u003e@Immutable\u003c/code\u003e instead.\u003c/p\u003e\u003cp id=\"51e7\"\u003eConsider an example, where you’d have a composable that directly accepts the \u003ccode\u003ejava.time.LocalDate\u003c/code\u003e parameter:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8fe8\"\u003e@Composable\u003cbr/\u003efun LatestChangeOn(updated: LocalDate) {\u003cbr/\u003e  // present the day parameter on screen\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"258f\"\u003eIf you call the \u003ccode\u003erenewSubscription\u003c/code\u003e function to update the latest change, you’ll end up in a similar situation as before — the \u003ccode\u003eLatestChangeOn\u003c/code\u003e composable keeps recomposing, regardless if it’s the same day or not. However, there’s no possibility of annotating that class in this situation, because it’s part of the standard library.\u003c/p\u003e\u003cp id=\"172b\"\u003eTo fix this, you can enable a \u003ca href=\"https://developer.android.com/develop/ui/compose/performance/stability/fix#configuration-file\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003estability configuration file\u003c/a\u003e, which can contain classes or patterns of classes that \u003cstrong\u003ewill be considered stable\u003c/strong\u003e by the Compose compiler.\u003c/p\u003e\u003cp id=\"70d8\"\u003eTo enable it, add \u003ccode\u003estabilityConfigurationFile\u003c/code\u003e to the \u003ccode\u003ecomposeCompiler\u003c/code\u003e configuration:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1da7\"\u003ecomposeCompiler {\u003cbr/\u003e  ...\u003cp\u003e  // Set path of the config file\u003cbr/\u003e  stabilityConfigurationFile = rootProject.file(\u0026#34;stability_config.conf\u0026#34;)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"bdd5\"\u003eAnd create the \u003ccode\u003estability_config.conf\u003c/code\u003e file in the root folder of your project, in which you add the \u003ccode\u003eLocalDate\u003c/code\u003e class:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7761\"\u003e// add the immutable classes outside of your codebase\u003cbr/\u003ejava.time.LocalDate\u003cp\u003e// alternatively you can stabilize all java.time classes with *\u003cbr/\u003ejava.time.*\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"87c5\"\u003eStabilize your domain model classes\u003c/h2\u003e\u003cp id=\"6825\"\u003eIn addition to classes that aren’t part of your codebase, the stability configuration file can be helpful for stabilizing all your data or domain model classes (assuming they’re immutable). This way, the domain module can be a Java Gradle module and doesn’t need dependency on the Compose compiler.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d8c8\"\u003e// stabilize all classes in model package\u003cbr/\u003ecom.example.app.domain.model.*\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2c9a\"\u003eBe aware of breaking the rules\u003c/h2\u003e\u003cp id=\"eb91\"\u003eBe aware that annotating a \u003cstrong\u003emutable\u003c/strong\u003e class with the \u003ccode\u003e@Immutable\u003c/code\u003e annotation, or adding the class to the stability configuration file, can be a source of bugs in your codebase, because the Compose compiler isn\u0026#39;t capable of verifying the contract and it might show up as something isn\u0026#39;t recomposing when you think it should.\u003c/p\u003e\u003ch2 id=\"3c60\"\u003eForget the need to remember() lambdas\u003c/h2\u003e\u003cp id=\"63e4\"\u003eOne other benefit of strong skipping is that it “remembers” all lambdas used in composition, even the ones with unstable captures. Previously, lambdas that were using an unstable class, for example a \u003ccode\u003eViewModel\u003c/code\u003e, might’ve been the cause of recomposition. One of the common workarounds was remembering the lambda functions.\u003c/p\u003e\u003cp id=\"261d\"\u003eSo, if you have lambdas wrapped with \u003ccode\u003eremember\u003c/code\u003e in your codebase, you can safely remove the \u003ccode\u003eremember\u003c/code\u003e call, because it is done automatically by the Compose compiler:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5266\"\u003eScreen(\u003cbr/\u003e-removeItem = remember(viewModel){ { id -\u0026gt; viewModel.removeItem(id) } }\u003cbr/\u003e+removeItem = { id -\u0026gt; viewModel.removeItem(id) }\u003cbr/\u003e)\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"d17f\"\u003eAre immutable collections still needed?\u003c/h2\u003e\u003cp id=\"9ce8\"\u003eThe \u003ccode\u003ekotlinx.collections.immutable\u003c/code\u003e collections like \u003ccode\u003eImmutableList\u003c/code\u003e could’ve been used in the past to make a \u003ccode\u003eList\u003c/code\u003e of items stable and thus preventing a composable from recomposing. If you have them in your codebase purely for the purpose of preventing recompositions of composables with \u003ccode\u003eList\u003c/code\u003e parameters, you could consider refactoring them to a regular \u003ccode\u003eList\u003c/code\u003e and add \u003ccode\u003ejava.util.List\u003c/code\u003e into the stability configuration file.\u003c/p\u003e\u003ch2 id=\"8826\"\u003eBut!\u003c/h2\u003e\u003cp id=\"f6ea\"\u003eIf you do that, your composable might be slower than if the \u003ccode\u003eList\u003c/code\u003e parameter was unstable!\u003c/p\u003e\u003cp id=\"be5d\"\u003eAdding \u003ccode\u003eList\u003c/code\u003e to the stability configuration file means the \u003ccode\u003eList\u003c/code\u003e parameter is compared with the \u003ccode\u003eequals\u003c/code\u003e call, which eventually leads to calling \u003ccode\u003eequals\u003c/code\u003e \u003cstrong\u003eon every single item\u003c/strong\u003e of that list. In the context of a lazy list, the same \u003ccode\u003eequals\u003c/code\u003e check is then called again from the perspective of the item composable, which results in calculating the \u003ccode\u003eequals()\u003c/code\u003e call \u003cstrong\u003etwice\u003c/strong\u003e for many of the visible items, and possibly needlessly for all the items that aren’t visible!\u003c/p\u003e\u003cp id=\"6742\"\u003eIf the composable containing the \u003ccode\u003eList\u003c/code\u003e parameter doesn’t have many other UI components, recomposing it can be faster than calculating the \u003ccode\u003eequals()\u003c/code\u003e check.\u003c/p\u003e\u003cp id=\"14a1\"\u003eHowever, there’s no one size fits all approach here, so you should verify your choice with \u003ca href=\"https://d.android.com/macrobenchmark\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebenchmarks\u003c/a\u003e!\u003c/p\u003e\u003ch2 id=\"6cf6\"\u003eSummary\u003c/h2\u003e\u003cp id=\"dac3\"\u003eBy enabling strong skipping mode in your code base, you can reduce the need to manually craft classes to be stable. Be aware that in some cases, they still need manual crafting, but this can now be simplified with the stability configuration file!\u003c/p\u003e\u003cp id=\"1ddc\"\u003eWe hope all of these changes will simplify the mental load of thinking about stability in Compose.\u003c/p\u003e\u003cp id=\"7215\"\u003eWant more? See our \u003ca href=\"https://goo.gle/compose-performance-codelab\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecodelab\u003c/a\u003e on practical performance problem solving in Compose.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2b96\"\u003eThe code snippets in this blog have the following license:\u003cbr/\u003e// Copyright 2024 Google LLC. SPDX-License-Identifier: Apache-2.0\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-07-08T16:45:50.55Z",
  "modifiedTime": null
}
