{
  "id": "31de1f23-6b7d-4b49-a7a5-ed8fdd7a9b30",
  "title": "String resources in Kotlin Multi-platform",
  "link": "https://chrynan.codes/string-resources-in-kotlin-multiplatform/",
  "description": "Multiple approaches to abstracting String resources for use in a Kotlin Multi-platform module.",
  "author": "Christopher Keenan",
  "published": "Tue, 12 Nov 2019 17:34:56 GMT",
  "source": "https://chrynan.codes/rss/",
  "categories": [
    "string resources",
    "kotlin",
    "strings",
    "kotlin multi-platform",
    "kotlin multiplatform",
    "module",
    "platform agnostic",
    "resources",
    "programming",
    "development",
    "chrynan codes",
    "clean-architecture",
    "clean-code",
    "android",
    "abstract"
  ],
  "byline": "Christopher Keenan",
  "length": 5648,
  "excerpt": "Multiple approaches to abstracting String resources for use in a Kotlin Multi-platform module.",
  "siteName": "Chris Keenan Codes",
  "favicon": "https://cdn.getmidnight.com/26ffcef53c44522efbfe7fef964a4058/2023/02/code_FILL0_wght400_GRAD0_opsz48.svg",
  "text": "Kotlin Multi-platform is a great feature that gives the ability to share code between the different parts of an application (mobile clients, web clients, and even the server). Using this feature often leads to the creation of a core module which contains the reusable code, such as, models and business logic. But most of the presentation layer can be written as Kotlin common code as well, barring the View implementations (Framework components, such as, Activities and Fragments in Android), including Presenters, Mappers, ViewModels, and View interfaces. Instead of redundantly writing this code for each client, this code could be abstracted into another Kotlin Multi-platform module (e.g., presentation). But abstracting some of these components isn't so trivial. For instance, the Mappers, which are responsible for converting Models to ViewModels, usually need access to the system resources. Unfortunately, the accessing of resources for each system varies. So, an abstraction layer will have to be created for accessing resources. This article discusses abstraction approaches for accessing one of the most common resources: Strings.TL;DRThere are multiple approaches to abstracting String resources for use in a Kotlin Multi-platform module.Access by identifierCreating an interface containing a function that retrieves a String by a provided identifier is one simple way to accessing String resources in a Kotlin common module. For instance: interface StringRetriever { fun string(resourceId: Int): Lazy\u003cString\u003e } The implementation for the above interface on Android might look like this:class StringProvider(private val context: Context) : StringRetriever { override fun string(resourceId: Int) = lazy { context.getString(resourceId) } } Then the Strings could be retrieved in a Kotlin common module Mapper:class SomeMapper(providedStringRetriever: StringRetriever) : Mapper, StringRetriever by providedStringRetriever { private val myString by string(R.string.my_string) } One thing that should stand out with the above approach is that even though the retrieval of the String resource is abstracted, the identifier is not. The Android generated R class will not be available in a Kotlin common module.Access by common identifierMaking an Enum Class whose properties represent the identifiers would allow the abstraction to work in a common module. But there would need to be some means of getting the actual identifier in each client module.enum class ResourceIds { MY_STRING, ANOTHER_STRING } Which could be used like so:class SomeMapper(providedStringRetriever: StringRetriever) : Mapper, StringRetriever by providedStringRetriever { private val myString by string(ResourceIds.MY_STRING) } Another class would have to be created, for each client, to map the ResourceIds values to the appropriate platform specific identifiers. Then the StringProvider implementation would have to be updated to reflect these changes:class ResourceIdMapper { fun map(resourceId: ResourceIds): Int = when(resourceId) { MY_STRING -\u003e R.string.my_string ANOTHER_STRING -\u003e R.string.another_string } } interface StringRetriever { fun string(resourceId: ResourceIds): Lazy\u003cString\u003e } class StringProvider( private val context: Context, private val mapper: ResourceIdMapper ) : StringRetriever { override fun string(resourceId: ResourceIds) = lazy { context.getString(mapper.map(resourceId)) } } Access by interfaceAnother approach to abstracting the retrieval of String resources in a Kotlin Multi-platform module would be to define an interface with properties representing the available Strings. Then each implementation of the interface would provide the platform specific means of getting the Strings. For instance:interface Strings { val myString: String val anotherString: String } Then an implementation of this on Android might look like this:class StringsProvider(private val context: Context) : Strings { override val myString: String by lazy { context.getString(R.string.my_string) } override val anotherString: String by lazy { context.getString(R.string.another_string) } } Then the Strings could be retrieved like this:class SomeMapper(providedStrings: Strings) : Mapper, Strings by providedStrings { fun map(someObject: SomeObject) = OtherObject(stringValue = myString) } Access with interface with abstracted implementation retrievalIn the preceeding approach, the StringsProvider could become rather verbose, especially, when there are a large quantity of Strings. This issue could be mitigated by using the retrieval mechanism from the first approach in the implementation:class StringsProvider(private val stringRetriever: StringRetriever) : Strings, StringAccessor by stringRetriever { override val myString by string(R.string.my_string) override val anotherString by string(R.string.my_string) } EndThere are numerous approaches which can be used to abstract the retrieval of String resources in Kotlin Multi-platform modules. The abstraction of String resources allows components dependent on those resources to be used in a platform agnostic manner which removes redundancy, improves consistency and testability, and provides flexibility for the implementation. This article discussed multiple approaches to retrieving a single String value with no arguments, but in a real world scenario, there might be a String which can be formatted, or represent a quantity value, by provided arguments. The approaches mentioned could be easily adapted to accommodate those scenarios as well.",
  "image": "https://images.unsplash.com/photo-1550376026-7375b92bb318?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=2000\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjExNzczfQ",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n        \u003cp\u003eKotlin Multi-platform is a great feature that gives the ability to share code between the different parts of an application (mobile clients, web clients, and even the server). Using this feature often leads to the creation of a \u003ccode\u003ecore\u003c/code\u003e module which contains the reusable code, such as, models and business logic. But most of the presentation layer can be written as Kotlin common code as well, barring the View implementations (Framework components, such as, Activities and Fragments in Android), including Presenters, Mappers, ViewModels, and View interfaces. \u003c/p\u003e\u003cp\u003eInstead of redundantly writing this code for each client, this code could be abstracted into another Kotlin Multi-platform module (e.g., \u003ccode\u003epresentation\u003c/code\u003e). But abstracting some of these components isn\u0026#39;t so trivial. For instance, the Mappers, which are responsible for converting Models to ViewModels, usually need access to the system resources. Unfortunately, the accessing of resources for each system varies. So, an abstraction layer will have to be created for accessing resources. This article discusses abstraction approaches for accessing one of the most common resources: Strings.\u003c/p\u003e\u003ch3 id=\"tl-dr\"\u003eTL;DR\u003c/h3\u003e\u003cp\u003eThere are multiple approaches to abstracting String resources for use in a Kotlin Multi-platform module.\u003c/p\u003e\u003ch3 id=\"access-by-identifier\"\u003eAccess by identifier\u003c/h3\u003e\u003cp\u003eCreating an interface containing a function that retrieves a String by a provided identifier is one simple way to accessing String resources in a Kotlin common module. For instance: \u003c/p\u003e\u003cpre\u003e\u003ccode\u003einterface StringRetriever {\n\n    fun string(resourceId: Int): Lazy\u0026lt;String\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe implementation for the above interface on Android might look like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass StringProvider(private val context: Context) : StringRetriever {\n\n    override fun string(resourceId: Int) = lazy { context.getString(resourceId) }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen the Strings could be retrieved in a Kotlin common module Mapper:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass SomeMapper(providedStringRetriever: StringRetriever) : Mapper,\n    StringRetriever by providedStringRetriever {\n    \n    private val myString by string(R.string.my_string)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne thing that should stand out with the above approach is that even though the retrieval of the String resource is abstracted, the identifier is not. The Android generated \u003ccode\u003eR\u003c/code\u003e class will not be available in a Kotlin common module.\u003c/p\u003e\u003ch3 id=\"access-by-common-identifier\"\u003eAccess by common identifier\u003c/h3\u003e\u003cp\u003eMaking an Enum Class whose properties represent the identifiers would allow the abstraction to work in a common module. But there would need to be some means of getting the actual identifier in each client module.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eenum class ResourceIds {\n\n    MY_STRING,\n    ANOTHER_STRING\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhich could be used like so:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass SomeMapper(providedStringRetriever: StringRetriever) : Mapper,\n    StringRetriever by providedStringRetriever {\n    \n    private val myString by string(ResourceIds.MY_STRING)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother class would have to be created, for each client, to map the \u003ccode\u003eResourceIds\u003c/code\u003e values to the appropriate platform specific identifiers. Then the \u003ccode\u003eStringProvider\u003c/code\u003e implementation would have to be updated to reflect these changes:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass ResourceIdMapper {\n\n    fun map(resourceId: ResourceIds): Int = when(resourceId) {\n        MY_STRING -\u0026gt; R.string.my_string\n        ANOTHER_STRING -\u0026gt; R.string.another_string\n    }\n}\n\ninterface StringRetriever {\n\n    fun string(resourceId: ResourceIds): Lazy\u0026lt;String\u0026gt;\n}\n\nclass StringProvider(\n    private val context: Context,\n    private val mapper: ResourceIdMapper\n) : StringRetriever {\n\n    override fun string(resourceId: ResourceIds) = lazy { context.getString(mapper.map(resourceId)) }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"access-by-interface\"\u003eAccess by interface\u003c/h3\u003e\u003cp\u003eAnother approach to abstracting the retrieval of String resources in a Kotlin Multi-platform module would be to define an interface with properties representing the available Strings. Then each implementation of the interface would provide the platform specific means of getting the Strings. For instance:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003einterface Strings {\n\n    val myString: String\n    val anotherString: String\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen an implementation of this on Android might look like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass StringsProvider(private val context: Context) : Strings {\n\n    override val myString: String by lazy { context.getString(R.string.my_string) }\n    \n    override val anotherString: String by lazy { context.getString(R.string.another_string) }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen the Strings could be retrieved like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass SomeMapper(providedStrings: Strings) : Mapper,\n    Strings by providedStrings {\n    \n    fun map(someObject: SomeObject) = OtherObject(stringValue = myString)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"access-with-interface-with-abstracted-implementation-retrieval\"\u003eAccess with interface with abstracted implementation retrieval\u003c/h3\u003e\u003cp\u003eIn the preceeding approach, the \u003ccode\u003eStringsProvider\u003c/code\u003e could become rather verbose, especially, when there are a large quantity of Strings. This issue could be mitigated by using the retrieval mechanism from the first approach in the implementation:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass StringsProvider(private val stringRetriever: StringRetriever) : Strings,\n    StringAccessor by stringRetriever {\n\n    override val myString by string(R.string.my_string)\n    \n    override val anotherString by string(R.string.my_string)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"end\"\u003eEnd\u003c/h3\u003e\u003cp\u003eThere are numerous approaches which can be used to abstract the retrieval of String resources in Kotlin Multi-platform modules. The abstraction of String resources allows components dependent on those resources to be used in a platform agnostic manner which removes redundancy, improves consistency and testability, and provides flexibility for the implementation. This article discussed multiple approaches to retrieving a single String value with no arguments, but in a real world scenario, there might be a String which can be formatted, or represent a quantity value, by provided arguments. The approaches mentioned could be easily adapted to accommodate those scenarios as well.\u003c/p\u003e\n    \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2019-11-12T17:34:56Z",
  "modifiedTime": "2019-11-12T17:34:56Z"
}
