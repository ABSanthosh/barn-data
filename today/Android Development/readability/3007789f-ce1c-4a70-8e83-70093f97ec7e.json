{
  "id": "3007789f-ce1c-4a70-8e83-70093f97ec7e",
  "title": "Enhancing Dropdown Menus in Jetpack Compose: Implementing Searchable Selection",
  "link": "https://proandroiddev.com/enhancing-dropdown-menus-in-jetpack-compose-implementing-searchable-selection-f9ee040b08fc?source=rss----c72404660798---4",
  "description": "",
  "author": "Kerry Bisset",
  "published": "Fri, 14 Mar 2025 01:38:24 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "ui",
    "software-development",
    "jetpack-compose"
  ],
  "byline": "Kerry Bisset",
  "length": 20099,
  "excerpt": "Have you ever struggled to find a specific item in a lengthy dropdown menu using Jetpack Compose? While Compose simplifies many aspects of UI development, handling extensive lists in dropdowns can…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "Have you ever struggled to find a specific item in a lengthy dropdown menu using Jetpack Compose? While Compose simplifies many aspects of UI development, handling extensive lists in dropdowns can still be quite tedious. Standard dropdown components, although straightforward, fall short in efficiently managing large datasets, negatively affecting user experience.This article addresses these shortcomings by demonstrating how to build a searchable dropdown menu. We’ll explore adding intuitive search functionality directly into your Compose dropdowns, enhancing usability and overall interaction.Defining the Structure of a Dropdown ComposableA well-designed dropdown composable typically consists of three essential parts:Display Field: This is usually a non-editable text field or label clearly showing the currently selected item. The primary purpose is to represent the current selection accurately — what we call the “truth.” Allowing direct editing of this field can confuse users and blur the distinction between selection and search, especially in cases where the dropdown supports dynamic or filtered content.Dropdown Items: Dropdown items are traditionally represented by components such as DropdownMenuItem in Jetpack Compose. The selectable entries are presented to the user upon interaction with the dropdown. Each item in this list should clearly communicate its selectable state and reflect the available options.Search Field (New Addition): The innovation here is introducing an editable search field, distinct from the display field, dedicated solely to filtering dropdown items based on user input. This search field dynamically updates the visible dropdown items, significantly enhancing the usability of the dropdown in scenarios with many possible selections.One might wonder, “Why not simply make the display field itself editable to handle searching?” The distinction lies in clarity and accuracy. An editable display field might inadvertently lead to users changing or mistaking their actual selection, which is confusing. Separating the selection display from the filtering input ensures that users always clearly understand their current selection versus their search query.Breaking Down the Searchable Dropdown API in Jetpack ComposeTo build a searchable dropdown menu in Jetpack Compose, we need a structured API that separates different responsibilities while allowing flexibility. The ExposedSearchMenu composable is the primary entry point, providing hooks for customization while maintaining a smooth user experience.Key Components of ExposedSearchMenuThe API is designed with flexibility in mind, consisting of several key parts:Expansion State ManagementThe dropdown visibility is controlled by an expanded state.A callback onExpandedChange handles changes to this state.Item List HandlingThe items parameter accepts a list of generic type \u003cT\u003e, allowing for flexibility with different data models.itemContent is a composable lambda that dictates how each dropdown item is rendered.Handling Empty StatesnoItemsContent provides a customizable composable for displaying when no items match the search query.Search FunctionalitysearchContent defines how the search input field is presented inside the dropdown.This is distinct from the display field to maintain clarity between selection and filtering.Display Field IntegrationdisplayContent defines how the currently selected item is shown.This is scoped within ExposedDropdownMenuBoxScope, ensuring it integrates seamlessly into the dropdown system.Entry Point: ExposedSearchMenuBelow is the core structure of the ExposedSearchMenu, which brings together these elements:@OptIn(ExperimentalMaterialApi::class)@Composablefun \u003cT\u003e ExposedSearchMenu( expanded: Boolean, onExpandedChange: (Boolean) -\u003e Unit, items: List\u003cT\u003e, itemContent: @Composable (T) -\u003e Unit, searchContent: @Composable () -\u003e Unit, displayContent: @Composable ExposedDropdownMenuBoxScope.(Modifier) -\u003e Unit, modifier: Modifier = Modifier, noItemsContent: @Composable () -\u003e Unit = { Text(\"No items\", modifier = Modifier.padding(8.dp).fillMaxWidth(), textAlign = TextAlign.Center) },) { ExposedDropdownMenuBox( expanded = expanded, onExpandedChange = onExpandedChange, modifier = modifier ) { displayContent(Modifier) ExposedSearchableDropDownMenu( expanded = expanded, onDismissRequest = { onExpandedChange.invoke(false) }, ) { searchContent() if (items.isEmpty()) { noItemsContent() } else { items.forEach { item -\u003e itemContent(item) } } } }}Internal Mechanism: ExposedSearchableDropDownMenuThe ExposedSearchableDropDownMenu composable is responsible for:Managing popup behavior and positioning.Controlling the expansion state through animations.Integrating scroll support for large lists.The implementation ensures that the dropdown appears in a natural position relative to its anchor element:@Composableinternal fun ExposedDropdownMenuBoxScope.ExposedSearchableDropDownMenu( expanded: Boolean, onDismissRequest: () -\u003e Unit, modifier: Modifier = Modifier, scrollState: ScrollState = rememberScrollState(), content: @Composable ColumnScope.() -\u003e Unit) { val expandedStates = remember { MutableTransitionState(false) } expandedStates.targetState = expanded if (expandedStates.currentState || expandedStates.targetState) { val transformOriginState = remember { mutableStateOf(TransformOrigin.Center) } val density = LocalDensity.current val popupPositionProvider = DropdownMenuPositionProvider(DpOffset.Zero, density) { parentBounds, menuBounds -\u003e transformOriginState.value = calculateTransformOrigin(parentBounds, menuBounds) } ExposedDropdownMenuPopup( onDismissRequest = onDismissRequest, popupPositionProvider = popupPositionProvider ) { DropdownMenuContent( expandedStates = expandedStates, transformOriginState = transformOriginState, scrollState = scrollState, modifier = modifier.exposedDropdownSize(), content = content ) } }}@Immutableinternal data class DropdownMenuPositionProvider( val contentOffset: DpOffset, val density: Density, val onPositionCalculated: (IntRect, IntRect) -\u003e Unit = { _, _ -\u003e }) : PopupPositionProvider { override fun calculatePosition( anchorBounds: IntRect, windowSize: IntSize, layoutDirection: LayoutDirection, popupContentSize: IntSize ): IntOffset { // The min margin above and below the menu, relative to the screen. val verticalMargin = with(density) { MenuVerticalMargin.roundToPx() } // The content offset specified using the dropdown offset parameter. val contentOffsetX = with(density) { contentOffset.x.roundToPx() * (if (layoutDirection == LayoutDirection.Ltr) 1 else -1) } val contentOffsetY = with(density) { contentOffset.y.roundToPx() } // Compute horizontal position. val leftToAnchorLeft = anchorBounds.left + contentOffsetX val rightToAnchorRight = anchorBounds.right - popupContentSize.width + contentOffsetX val rightToWindowRight = windowSize.width - popupContentSize.width val leftToWindowLeft = 0 val x = if (layoutDirection == LayoutDirection.Ltr) { sequenceOf( leftToAnchorLeft, rightToAnchorRight, // If the anchor gets outside of the window on the left, we want to position // toDisplayLeft for proximity to the anchor. Otherwise, toDisplayRight. if (anchorBounds.left \u003e= 0) rightToWindowRight else leftToWindowLeft ) } else { sequenceOf( rightToAnchorRight, leftToAnchorLeft, // If the anchor gets outside of the window on the right, we want to // position // toDisplayRight for proximity to the anchor. Otherwise, toDisplayLeft. if (anchorBounds.right \u003c= windowSize.width) leftToWindowLeft else rightToWindowRight ) } .firstOrNull { it \u003e= 0 \u0026\u0026 it + popupContentSize.width \u003c= windowSize.width } ?: rightToAnchorRight // Compute vertical position. val topToAnchorBottom = maxOf(anchorBounds.bottom + contentOffsetY, verticalMargin) val bottomToAnchorTop = anchorBounds.top - popupContentSize.height + contentOffsetY val centerToAnchorTop = anchorBounds.top - popupContentSize.height / 2 + contentOffsetY val bottomToWindowBottom = windowSize.height - popupContentSize.height - verticalMargin val y = sequenceOf( topToAnchorBottom, bottomToAnchorTop, centerToAnchorTop, bottomToWindowBottom ) .firstOrNull { it \u003e= verticalMargin \u0026\u0026 it + popupContentSize.height \u003c= windowSize.height - verticalMargin } ?: bottomToAnchorTop onPositionCalculated( anchorBounds, IntRect(x, y, x + popupContentSize.width, y + popupContentSize.height) ) return IntOffset(x, y) }}internal fun calculateTransformOrigin(parentBounds: IntRect, menuBounds: IntRect): TransformOrigin { val pivotX = when { menuBounds.left \u003e= parentBounds.right -\u003e 0f menuBounds.right \u003c= parentBounds.left -\u003e 1f menuBounds.width == 0 -\u003e 0f else -\u003e { val intersectionCenter = (max(parentBounds.left, menuBounds.left) + min(parentBounds.right, menuBounds.right)) / 2 (intersectionCenter - menuBounds.left).toFloat() / menuBounds.width } } val pivotY = when { menuBounds.top \u003e= parentBounds.bottom -\u003e 0f menuBounds.bottom \u003c= parentBounds.top -\u003e 1f menuBounds.height == 0 -\u003e 0f else -\u003e { val intersectionCenter = (max(parentBounds.top, menuBounds.top) + min(parentBounds.bottom, menuBounds.bottom)) / 2 (intersectionCenter - menuBounds.top).toFloat() / menuBounds.height } } return TransformOrigin(pivotX, pivotY)}@Composableinternal fun ExposedDropdownMenuPopup( onDismissRequest: (() -\u003e Unit)?, popupPositionProvider: PopupPositionProvider, content: @Composable () -\u003e Unit) { var focusManager: FocusManager? by mutableStateOf(null) var inputModeManager: InputModeManager? by mutableStateOf(null) Popup( popupPositionProvider = popupPositionProvider, onDismissRequest = onDismissRequest, /* LOOK HERE This is the most important thing for allowing text entry. */ properties = PopupProperties(focusable = true), onKeyEvent = null ) { focusManager = LocalFocusManager.current inputModeManager = LocalInputModeManager.current content() }}@Composableinternal fun DropdownMenuContent( expandedStates: MutableTransitionState\u003cBoolean\u003e, transformOriginState: MutableState\u003cTransformOrigin\u003e, scrollState: ScrollState, modifier: Modifier = Modifier, content: @Composable ColumnScope.() -\u003e Unit) { // Menu open/close animation. val transition = rememberTransition(expandedStates, \"DropDownMenu\") val scale by transition.animateFloat( transitionSpec = { if (false isTransitioningTo true) { // Dismissed to expanded tween(durationMillis = InTransitionDuration, easing = LinearOutSlowInEasing) } else { // Expanded to dismissed. tween(durationMillis = 1, delayMillis = OutTransitionDuration - 1) } } ) { if (it) { // Menu is expanded. 1f } else { // Menu is dismissed. 0.8f } } val alpha by transition.animateFloat( transitionSpec = { if (false isTransitioningTo true) { // Dismissed to expanded tween(durationMillis = 30) } else { // Expanded to dismissed. tween(durationMillis = OutTransitionDuration) } } ) { if (it) { // Menu is expanded. 1f } else { // Menu is dismissed. 0f } } Card( modifier = Modifier.graphicsLayer { scaleX = scale scaleY = scale this.alpha = alpha transformOrigin = transformOriginState.value }, ) { Column( modifier = modifier .padding(vertical = DropdownMenuVerticalPadding) .width(IntrinsicSize.Max) .verticalScroll(scrollState), content = content ) }}Implementing a Searchable Dropdown in Jetpack ComposeTo implement a searchable dropdown in Jetpack Compose, we need to extend the standard dropdown functionality by integrating a search field that dynamically filters available options. This approach enhances user experience by making it easier to find specific items in long lists.Breaking Down the ImplementationThe implementation consists of several key elements:State Management: We use remember to manage UI states such as the search query, selection, and expansion state of the dropdown.Filtering Mechanism: The list of dropdown items is filtered using derivedStateOf, ensuring that the displayed options react efficiently to user input without unnecessary recomputation.Composable Structure:displayContent: An OutlinedTextField that shows the currently selected item. It should be read-only to prevent accidental modification.searchContent: A TextField placed inside the dropdown for real-time filtering. While I intended it for text filtering, it can be used for other types of filtering, such as chips.itemContent: A list of DropdownMenuItem components representing the selectable options.Code ImplementationBelow is the structured implementation of a searchable dropdown using an ExposedSearchMenu:@Composablefun SearchableDropdownMenu() { var searchText by remember { mutableStateOf(\"\") } val testItems = listOf(\"Test\", \"Test2\", \"Test3\", \"Example\", \"Sample\", \"Demo\") val filteredList by remember { derivedStateOf { testItems.filter { it.contains(searchText, ignoreCase = true) } } } var selection by remember { mutableStateOf(\"\") } var expanded by remember { mutableStateOf(false) } ExposedSearchMenu( expanded = expanded, onExpandedChange = { expanded = it }, items = filteredList, itemContent = { item -\u003e DropdownMenuItem( text = { Text(item) }, onClick = { selection = item expanded = false } ) }, searchContent = { TextField( value = searchText, onValueChange = { searchText = it }, label = { Text(\"Search\") }, modifier = Modifier.fillMaxWidth() ) }, displayContent = { OutlinedTextField( value = selection, onValueChange = { }, label = { Text(\"Selection\") }, modifier = Modifier.menuAnchor(ExposedDropdownMenuAnchorType.PrimaryEditable), readOnly = true, trailingIcon = { IconButton(onClick = { expanded = !expanded }) { Icon( imageVector = if (expanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown, contentDescription = null ) } } ) } )}Why This Approach WorksEfficient Filtering: The derivedStateOf ensures that filtering is recomputed only when searchText changes.Clear Selection and Search Separation: Users can search freely without modifying their selected item.Better UX: The dropdown remains user-friendly for large datasets, preventing excessive scrolling.By structuring the dropdown in this way, we enhance usability while maintaining clarity in selection and search functionalities. This approach ensures an intuitive and responsive dropdown experience, making data selection easy for users.Leveraging ViewModel and MVI for State ManagementWhile the previous implementation effectively manages state locally within the composable, a more scalable approach for real-world applications is to separate UI state from business logic using Model-View-Intent (MVI) architecture.Why Use ViewModel?Searching through a list might involve querying a database or making a remote API call.UI state should be persisted across configuration changes, avoiding unnecessary recomputations.Decoupling logic from UI ensures cleaner, testable, and maintainable code.Refactoring with ViewModelInstead of keeping searchText, filteredList, and selection inside the composable, we can move them to a ViewModel:class DropdownViewModel : ViewModel() { private val _searchText = MutableStateFlow(\"\") val searchText: StateFlow\u003cString\u003e = _searchText.asStateFlow() private val _items = MutableStateFlow(listOf(\"Test\", \"Test2\", \"Test3\", \"Example\", \"Sample\", \"Demo\")) val filteredList: StateFlow\u003cList\u003cString\u003e\u003e = _searchText .combine(_items) { search, items -\u003e items.filter { it.contains(search, ignoreCase = true) } } .stateIn(viewModelScope, SharingStarted.Lazily, emptyList()) private val _selection = MutableStateFlow(\"\") val selection: StateFlow\u003cString\u003e = _selection.asStateFlow() fun onSearchTextChanged(text: String) { _searchText.value = text } fun onItemSelected(item: String) { _selection.value = item }}Updating the ComposableThen we modify our SearchableDropdownMenu to rely on the ViewModel:@Composablefun SearchableDropdownMenu(viewModel: DropdownViewModel = viewModel()) { val searchText by viewModel.searchText.collectAsState() val filteredList by viewModel.filteredList.collectAsState() val selection by viewModel.selection.collectAsState() var expanded by remember { mutableStateOf(false) } ExposedSearchMenu( expanded = expanded, onExpandedChange = { expanded = it }, items = filteredList, itemContent = { item -\u003e DropdownMenuItem( text = { Text(item) }, onClick = { viewModel.onItemSelected(item) expanded = false } ) }, searchContent = { TextField( value = searchText, onValueChange = { viewModel.onSearchTextChanged(it) }, label = { Text(\"Search\") }, modifier = Modifier.fillMaxWidth() ) }, displayContent = { OutlinedTextField( value = selection, onValueChange = { }, label = { Text(\"Selection\") }, modifier = Modifier.menuAnchor(ExposedDropdownMenuAnchorType.PrimaryEditable), readOnly = true, trailingIcon = { IconButton(onClick = { expanded = !expanded }) { Icon( imageVector = if (expanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown, contentDescription = null ) } } ) } )}",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*jUAT1f8bobyiKSUlbdl6Ow.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/@kerry.bisset?source=post_page---byline--f9ee040b08fc---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Kerry Bisset\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*LvLdjsaNud3J4otKLrXe3Q.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://proandroiddev.com/?source=post_page---byline--f9ee040b08fc---------------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"ProAndroidDev\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*XVtdl45m8YaYrPI4buJ5yQ.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"293e\"\u003eHave you ever struggled to find a specific item in a lengthy dropdown menu using Jetpack Compose? While Compose simplifies many aspects of UI development, handling extensive lists in dropdowns can still be quite tedious. Standard dropdown components, although straightforward, fall short in efficiently managing large datasets, negatively affecting user experience.\u003c/p\u003e\u003cp id=\"4e6d\"\u003eThis article addresses these shortcomings by demonstrating how to build a searchable dropdown menu. We’ll explore adding intuitive search functionality directly into your Compose dropdowns, enhancing usability and overall interaction.\u003c/p\u003e\u003ch2 id=\"64da\"\u003e\u003cstrong\u003e\u003cem\u003eDefining the Structure \u003c/em\u003eof a Dropdown Composable\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"0e8f\"\u003eA well-designed dropdown composable typically consists of three essential parts:\u003c/p\u003e\u003col\u003e\u003cli id=\"decd\"\u003e\u003cstrong\u003eDisplay Field:\u003c/strong\u003e This is usually a non-editable text field or label clearly showing the currently selected item. The primary purpose is to represent the current selection accurately — what we call the “truth.” Allowing direct editing of this field can confuse users and blur the distinction between selection and search, especially in cases where the dropdown supports dynamic or filtered content.\u003c/li\u003e\u003cli id=\"b7e8\"\u003e\u003cstrong\u003eDropdown Items:\u003c/strong\u003e Dropdown items are traditionally represented by components such as \u003ccode\u003eDropdownMenuItem\u003c/code\u003e in Jetpack Compose. The selectable entries are presented to the user upon interaction with the dropdown. Each item in this list should clearly communicate its selectable state and reflect the available options.\u003c/li\u003e\u003cli id=\"91a3\"\u003e\u003cstrong\u003eSearch Field (New Addition):\u003c/strong\u003e The innovation here is introducing an editable search field, distinct from the display field, dedicated solely to filtering dropdown items based on user input. This search field dynamically updates the visible dropdown items, significantly enhancing the usability of the dropdown in scenarios with many possible selections.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"379a\"\u003eOne might wonder, “Why not simply make the display field itself editable to handle searching?” The distinction lies in clarity and accuracy. An editable display field might inadvertently lead to users changing or mistaking their actual selection, which is confusing. Separating the selection display from the filtering input ensures that users always clearly understand their current selection versus their search query.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"be4c\"\u003eBreaking Down the Searchable Dropdown API in Jetpack Compose\u003c/h2\u003e\u003cp id=\"c54f\"\u003eTo build a \u003cstrong\u003esearchable dropdown menu\u003c/strong\u003e in Jetpack Compose, we need a structured API that separates different responsibilities while allowing flexibility. The \u003ccode\u003e\u003cstrong\u003eExposedSearchMenu\u003c/strong\u003e\u003c/code\u003e composable is the primary entry point, providing hooks for customization while maintaining a smooth user experience.\u003c/p\u003e\u003ch2 id=\"18b5\"\u003eKey Components of \u003ccode\u003eExposedSearchMenu\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"5613\"\u003eThe API is designed with flexibility in mind, consisting of several key parts:\u003c/p\u003e\u003cp id=\"734d\"\u003e\u003cstrong\u003eExpansion State Management\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"5aec\"\u003eThe dropdown visibility is controlled by an \u003ccode\u003eexpanded\u003c/code\u003e state.\u003c/li\u003e\u003cli id=\"6d5b\"\u003eA callback \u003ccode\u003eonExpandedChange\u003c/code\u003e handles changes to this state.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"db19\"\u003e\u003cstrong\u003eItem List Handling\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"af71\"\u003eThe \u003ccode\u003eitems\u003c/code\u003e parameter accepts a list of generic type \u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e, allowing for flexibility with different data models.\u003c/li\u003e\u003cli id=\"7499\"\u003e\u003ccode\u003eitemContent\u003c/code\u003e is a composable lambda that dictates how each dropdown item is rendered.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9235\"\u003e\u003cstrong\u003eHandling Empty States\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e2d2\"\u003e\u003ccode\u003enoItemsContent\u003c/code\u003e provides a customizable composable for displaying when no items match the search query.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"866b\"\u003e\u003cstrong\u003eSearch Functionality\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"cc71\"\u003e\u003ccode\u003esearchContent\u003c/code\u003e defines how the search input field is presented inside the dropdown.\u003c/li\u003e\u003cli id=\"a77b\"\u003eThis is distinct from the display field to maintain clarity between selection and filtering.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"002b\"\u003e\u003cstrong\u003eDisplay Field Integration\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"4d0a\"\u003e\u003ccode\u003edisplayContent\u003c/code\u003e defines how the currently selected item is shown.\u003c/li\u003e\u003cli id=\"6712\"\u003eThis is scoped within \u003ccode\u003eExposedDropdownMenuBoxScope\u003c/code\u003e, ensuring it integrates seamlessly into the dropdown system.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"192d\"\u003eEntry Point: \u003ccode\u003eExposedSearchMenu\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"db7b\"\u003eBelow is the core structure of the \u003ccode\u003e\u003cstrong\u003eExposedSearchMenu\u003c/strong\u003e\u003c/code\u003e, which brings together these elements:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"9039\"\u003e@OptIn(ExperimentalMaterialApi::class)\u003cbr/\u003e@Composable\u003cbr/\u003efun \u0026lt;T\u0026gt; ExposedSearchMenu(\u003cbr/\u003e    expanded: Boolean,\u003cbr/\u003e    onExpandedChange: (Boolean) -\u0026gt; Unit,\u003cbr/\u003e    items: List\u0026lt;T\u0026gt;,\u003cbr/\u003e    itemContent: @Composable (T) -\u0026gt; Unit,\u003cbr/\u003e    searchContent: @Composable () -\u0026gt; Unit,\u003cbr/\u003e    displayContent: @Composable ExposedDropdownMenuBoxScope.(Modifier) -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    noItemsContent: @Composable () -\u0026gt; Unit = {\u003cbr/\u003e        Text(\u0026#34;No items\u0026#34;, modifier = Modifier.padding(8.dp).fillMaxWidth(), textAlign = TextAlign.Center)\u003cbr/\u003e    },\u003cbr/\u003e) {\u003cbr/\u003e    ExposedDropdownMenuBox(\u003cbr/\u003e        expanded = expanded, onExpandedChange = onExpandedChange,\u003cbr/\u003e        modifier = modifier\u003cbr/\u003e    ) {\u003cbr/\u003e        displayContent(Modifier)\u003cbr/\u003e        ExposedSearchableDropDownMenu(\u003cbr/\u003e            expanded = expanded,\u003cbr/\u003e            onDismissRequest = { onExpandedChange.invoke(false) },\u003cbr/\u003e        ) {\u003cbr/\u003e            searchContent()\u003cbr/\u003e            if (items.isEmpty()) {\u003cbr/\u003e                noItemsContent()\u003cbr/\u003e            } else {\u003cbr/\u003e                items.forEach { item -\u0026gt;\u003cbr/\u003e                    itemContent(item)\u003cbr/\u003e                }\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003cbr/\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"269e\"\u003eInternal Mechanism: \u003ccode\u003eExposedSearchableDropDownMenu\u003c/code\u003e\u003c/h2\u003e\u003cp id=\"3d2d\"\u003eThe \u003ccode\u003eExposedSearchableDropDownMenu\u003c/code\u003e composable is responsible for:\u003c/p\u003e\u003cul\u003e\u003cli id=\"9fae\"\u003eManaging \u003cstrong\u003epopup behavior\u003c/strong\u003e and positioning.\u003c/li\u003e\u003cli id=\"5bb7\"\u003eControlling the \u003cstrong\u003eexpansion state\u003c/strong\u003e through animations.\u003c/li\u003e\u003cli id=\"3a10\"\u003eIntegrating \u003cstrong\u003escroll support\u003c/strong\u003e for large lists.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"82b5\"\u003eThe implementation ensures that the dropdown appears in a \u003cstrong\u003enatural position\u003c/strong\u003e relative to its anchor element:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"f416\"\u003e@Composable\u003cbr/\u003einternal fun ExposedDropdownMenuBoxScope.ExposedSearchableDropDownMenu(\u003cbr/\u003e    expanded: Boolean,\u003cbr/\u003e    onDismissRequest: () -\u0026gt; Unit,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    scrollState: ScrollState = rememberScrollState(),\u003cbr/\u003e    content: @Composable ColumnScope.() -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    val expandedStates = remember { MutableTransitionState(false) }\u003cbr/\u003e    expandedStates.targetState = expanded\u003cp\u003e    if (expandedStates.currentState || expandedStates.targetState) {\u003cbr/\u003e        val transformOriginState = remember { mutableStateOf(TransformOrigin.Center) }\u003cbr/\u003e        val density = LocalDensity.current\u003cbr/\u003e        val popupPositionProvider =\u003cbr/\u003e            DropdownMenuPositionProvider(DpOffset.Zero, density) { parentBounds, menuBounds -\u0026gt;\u003cbr/\u003e                transformOriginState.value = calculateTransformOrigin(parentBounds, menuBounds)\u003cbr/\u003e            }\u003c/p\u003e\u003cp\u003e        ExposedDropdownMenuPopup(\u003cbr/\u003e            onDismissRequest = onDismissRequest,\u003cbr/\u003e            popupPositionProvider = popupPositionProvider\u003cbr/\u003e        ) {\u003cbr/\u003e            DropdownMenuContent(\u003cbr/\u003e                expandedStates = expandedStates,\u003cbr/\u003e                transformOriginState = transformOriginState,\u003cbr/\u003e                scrollState = scrollState,\u003cbr/\u003e                modifier = modifier.exposedDropdownSize(),\u003cbr/\u003e                content = content\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Immutable\u003cbr/\u003einternal data class DropdownMenuPositionProvider(\u003cbr/\u003e    val contentOffset: DpOffset,\u003cbr/\u003e    val density: Density,\u003cbr/\u003e    val onPositionCalculated: (IntRect, IntRect) -\u0026gt; Unit = { _, _ -\u0026gt; }\u003cbr/\u003e) : PopupPositionProvider {\u003cbr/\u003e    override fun calculatePosition(\u003cbr/\u003e        anchorBounds: IntRect,\u003cbr/\u003e        windowSize: IntSize,\u003cbr/\u003e        layoutDirection: LayoutDirection,\u003cbr/\u003e        popupContentSize: IntSize\u003cbr/\u003e    ): IntOffset {\u003cbr/\u003e        // The min margin above and below the menu, relative to the screen.\u003cbr/\u003e        val verticalMargin = with(density) { MenuVerticalMargin.roundToPx() }\u003cbr/\u003e        // The content offset specified using the dropdown offset parameter.\u003cbr/\u003e        val contentOffsetX =\u003cbr/\u003e            with(density) {\u003cbr/\u003e                contentOffset.x.roundToPx() *\u003cbr/\u003e                        (if (layoutDirection == LayoutDirection.Ltr) 1 else -1)\u003cbr/\u003e            }\u003cbr/\u003e        val contentOffsetY = with(density) { contentOffset.y.roundToPx() }\u003c/p\u003e\u003cp\u003e        // Compute horizontal position.\u003cbr/\u003e        val leftToAnchorLeft = anchorBounds.left + contentOffsetX\u003cbr/\u003e        val rightToAnchorRight = anchorBounds.right - popupContentSize.width + contentOffsetX\u003cbr/\u003e        val rightToWindowRight = windowSize.width - popupContentSize.width\u003cbr/\u003e        val leftToWindowLeft = 0\u003cbr/\u003e        val x =\u003cbr/\u003e            if (layoutDirection == LayoutDirection.Ltr) {\u003cbr/\u003e                sequenceOf(\u003cbr/\u003e                    leftToAnchorLeft,\u003cbr/\u003e                    rightToAnchorRight,\u003cbr/\u003e                    // If the anchor gets outside of the window on the left, we want to position\u003cbr/\u003e                    // toDisplayLeft for proximity to the anchor. Otherwise, toDisplayRight.\u003cbr/\u003e                    if (anchorBounds.left \u0026gt;= 0) rightToWindowRight else leftToWindowLeft\u003cbr/\u003e                )\u003cbr/\u003e            } else {\u003cbr/\u003e                sequenceOf(\u003cbr/\u003e                    rightToAnchorRight,\u003cbr/\u003e                    leftToAnchorLeft,\u003cbr/\u003e                    // If the anchor gets outside of the window on the right, we want to\u003cbr/\u003e                    // position\u003cbr/\u003e                    // toDisplayRight for proximity to the anchor. Otherwise, toDisplayLeft.\u003cbr/\u003e                    if (anchorBounds.right \u0026lt;= windowSize.width) leftToWindowLeft\u003cbr/\u003e                    else rightToWindowRight\u003cbr/\u003e                )\u003cbr/\u003e            }\u003cbr/\u003e                .firstOrNull { it \u0026gt;= 0 \u0026amp;\u0026amp; it + popupContentSize.width \u0026lt;= windowSize.width }\u003cbr/\u003e                ?: rightToAnchorRight\u003c/p\u003e\u003cp\u003e        // Compute vertical position.\u003cbr/\u003e        val topToAnchorBottom = maxOf(anchorBounds.bottom + contentOffsetY, verticalMargin)\u003cbr/\u003e        val bottomToAnchorTop = anchorBounds.top - popupContentSize.height + contentOffsetY\u003cbr/\u003e        val centerToAnchorTop = anchorBounds.top - popupContentSize.height / 2 + contentOffsetY\u003cbr/\u003e        val bottomToWindowBottom = windowSize.height - popupContentSize.height - verticalMargin\u003cbr/\u003e        val y =\u003cbr/\u003e            sequenceOf(\u003cbr/\u003e                topToAnchorBottom,\u003cbr/\u003e                bottomToAnchorTop,\u003cbr/\u003e                centerToAnchorTop,\u003cbr/\u003e                bottomToWindowBottom\u003cbr/\u003e            )\u003cbr/\u003e                .firstOrNull {\u003cbr/\u003e                    it \u0026gt;= verticalMargin \u0026amp;\u0026amp;\u003cbr/\u003e                            it + popupContentSize.height \u0026lt;= windowSize.height - verticalMargin\u003cbr/\u003e                } ?: bottomToAnchorTop\u003c/p\u003e\u003cp\u003e        onPositionCalculated(\u003cbr/\u003e            anchorBounds,\u003cbr/\u003e            IntRect(x, y, x + popupContentSize.width, y + popupContentSize.height)\u003cbr/\u003e        )\u003cbr/\u003e        return IntOffset(x, y)\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003einternal fun calculateTransformOrigin(parentBounds: IntRect, menuBounds: IntRect): TransformOrigin {\u003cbr/\u003e    val pivotX =\u003cbr/\u003e        when {\u003cbr/\u003e            menuBounds.left \u0026gt;= parentBounds.right -\u0026gt; 0f\u003cbr/\u003e            menuBounds.right \u0026lt;= parentBounds.left -\u0026gt; 1f\u003cbr/\u003e            menuBounds.width == 0 -\u0026gt; 0f\u003cbr/\u003e            else -\u0026gt; {\u003cbr/\u003e                val intersectionCenter =\u003cbr/\u003e                    (max(parentBounds.left, menuBounds.left) +\u003cbr/\u003e                            min(parentBounds.right, menuBounds.right)) / 2\u003cbr/\u003e                (intersectionCenter - menuBounds.left).toFloat() / menuBounds.width\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    val pivotY =\u003cbr/\u003e        when {\u003cbr/\u003e            menuBounds.top \u0026gt;= parentBounds.bottom -\u0026gt; 0f\u003cbr/\u003e            menuBounds.bottom \u0026lt;= parentBounds.top -\u0026gt; 1f\u003cbr/\u003e            menuBounds.height == 0 -\u0026gt; 0f\u003cbr/\u003e            else -\u0026gt; {\u003cbr/\u003e                val intersectionCenter =\u003cbr/\u003e                    (max(parentBounds.top, menuBounds.top) +\u003cbr/\u003e                            min(parentBounds.bottom, menuBounds.bottom)) / 2\u003cbr/\u003e                (intersectionCenter - menuBounds.top).toFloat() / menuBounds.height\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    return TransformOrigin(pivotX, pivotY)\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003einternal fun ExposedDropdownMenuPopup(\u003cbr/\u003e    onDismissRequest: (() -\u0026gt; Unit)?,\u003cbr/\u003e    popupPositionProvider: PopupPositionProvider,\u003cbr/\u003e    content: @Composable () -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    var focusManager: FocusManager? by mutableStateOf(null)\u003cbr/\u003e    var inputModeManager: InputModeManager? by mutableStateOf(null)\u003cbr/\u003e    Popup(\u003cbr/\u003e        popupPositionProvider = popupPositionProvider,\u003cbr/\u003e        onDismissRequest = onDismissRequest,\u003c/p\u003e\u003cp\u003e                /*\u003cbr/\u003e          LOOK HERE\u003cbr/\u003e          This is the most important thing for allowing text entry.\u003cbr/\u003e        */\u003c/p\u003e\u003cp\u003e        properties = PopupProperties(focusable = true),\u003cbr/\u003e        onKeyEvent = null\u003cbr/\u003e    ) {\u003cbr/\u003e        focusManager = LocalFocusManager.current\u003cbr/\u003e        inputModeManager = LocalInputModeManager.current\u003cbr/\u003e        content()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e@Composable\u003cbr/\u003einternal fun DropdownMenuContent(\u003cbr/\u003e    expandedStates: MutableTransitionState\u0026lt;Boolean\u0026gt;,\u003cbr/\u003e    transformOriginState: MutableState\u0026lt;TransformOrigin\u0026gt;,\u003cbr/\u003e    scrollState: ScrollState,\u003cbr/\u003e    modifier: Modifier = Modifier,\u003cbr/\u003e    content: @Composable ColumnScope.() -\u0026gt; Unit\u003cbr/\u003e) {\u003cbr/\u003e    // Menu open/close animation.\u003cbr/\u003e    val transition = rememberTransition(expandedStates, \u0026#34;DropDownMenu\u0026#34;)\u003c/p\u003e\u003cp\u003e    val scale by\u003cbr/\u003e    transition.animateFloat(\u003cbr/\u003e        transitionSpec = {\u003cbr/\u003e            if (false isTransitioningTo true) {\u003cbr/\u003e                // Dismissed to expanded\u003cbr/\u003e                tween(durationMillis = InTransitionDuration, easing = LinearOutSlowInEasing)\u003cbr/\u003e            } else {\u003cbr/\u003e                // Expanded to dismissed.\u003cbr/\u003e                tween(durationMillis = 1, delayMillis = OutTransitionDuration - 1)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    ) {\u003cbr/\u003e        if (it) {\u003cbr/\u003e            // Menu is expanded.\u003cbr/\u003e            1f\u003cbr/\u003e        } else {\u003cbr/\u003e            // Menu is dismissed.\u003cbr/\u003e            0.8f\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    val alpha by\u003cbr/\u003e    transition.animateFloat(\u003cbr/\u003e        transitionSpec = {\u003cbr/\u003e            if (false isTransitioningTo true) {\u003cbr/\u003e                // Dismissed to expanded\u003cbr/\u003e                tween(durationMillis = 30)\u003cbr/\u003e            } else {\u003cbr/\u003e                // Expanded to dismissed.\u003cbr/\u003e                tween(durationMillis = OutTransitionDuration)\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e    ) {\u003cbr/\u003e        if (it) {\u003cbr/\u003e            // Menu is expanded.\u003cbr/\u003e            1f\u003cbr/\u003e        } else {\u003cbr/\u003e            // Menu is dismissed.\u003cbr/\u003e            0f\u003cbr/\u003e        }\u003cbr/\u003e    }\u003cbr/\u003e    Card(\u003cbr/\u003e        modifier =\u003cbr/\u003e            Modifier.graphicsLayer {\u003cbr/\u003e                scaleX = scale\u003cbr/\u003e                scaleY = scale\u003cbr/\u003e                this.alpha = alpha\u003cbr/\u003e                transformOrigin = transformOriginState.value\u003cbr/\u003e            },\u003cbr/\u003e    ) {\u003cbr/\u003e        Column(\u003cbr/\u003e            modifier =\u003cbr/\u003e                modifier\u003cbr/\u003e                    .padding(vertical = DropdownMenuVerticalPadding)\u003cbr/\u003e                    .width(IntrinsicSize.Max)\u003cbr/\u003e                    .verticalScroll(scrollState),\u003cbr/\u003e            content = content\u003cbr/\u003e        )\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"e605\"\u003eImplementing a Searchable Dropdown in Jetpack Compose\u003c/h2\u003e\u003cp id=\"64cc\"\u003eTo implement a searchable dropdown in Jetpack Compose, we need to extend the standard dropdown functionality by integrating a search field that dynamically filters available options. This approach enhances user experience by making it easier to find specific items in long lists.\u003c/p\u003e\u003ch2 id=\"aa34\"\u003eBreaking Down the Implementation\u003c/h2\u003e\u003cp id=\"dfce\"\u003eThe implementation consists of several key elements:\u003c/p\u003e\u003cp id=\"8395\"\u003e\u003cstrong\u003eState Management:\u003c/strong\u003e\u003cbr/\u003e We use \u003ccode\u003eremember\u003c/code\u003e to manage UI states such as the search query, selection, and expansion state of the dropdown.\u003c/p\u003e\u003cp id=\"febd\"\u003e\u003cstrong\u003eFiltering Mechanism:\u003c/strong\u003e\u003cbr/\u003e The list of dropdown items is filtered using \u003ccode\u003ederivedStateOf\u003c/code\u003e, ensuring that the displayed options react efficiently to user input without unnecessary recomputation.\u003c/p\u003e\u003cp id=\"8f76\"\u003e\u003cstrong\u003eComposable Structure:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"f07f\"\u003e\u003ccode\u003edisplayContent\u003c/code\u003e: An \u003ccode\u003eOutlinedTextField\u003c/code\u003e that shows the currently selected item. It \u003cstrong\u003eshould be\u003c/strong\u003e read-only to prevent accidental modification.\u003c/li\u003e\u003cli id=\"31ed\"\u003e\u003ccode\u003esearchContent\u003c/code\u003e: A \u003ccode\u003eTextField\u003c/code\u003e placed inside the dropdown for real-time filtering. While I intended it for text filtering, it can be used for other types of filtering, such as chips.\u003c/li\u003e\u003cli id=\"a696\"\u003e\u003ccode\u003eitemContent\u003c/code\u003e: A list of \u003ccode\u003eDropdownMenuItem\u003c/code\u003e components representing the selectable options.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"cd04\"\u003eCode Implementation\u003c/h2\u003e\u003cp id=\"7852\"\u003eBelow is the structured implementation of a searchable dropdown using an \u003ccode\u003eExposedSearchMenu\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a59a\"\u003e@Composable\u003cbr/\u003efun SearchableDropdownMenu() {\u003cbr/\u003e    var searchText by remember { mutableStateOf(\u0026#34;\u0026#34;) }\u003cbr/\u003e    val testItems = listOf(\u0026#34;Test\u0026#34;, \u0026#34;Test2\u0026#34;, \u0026#34;Test3\u0026#34;, \u0026#34;Example\u0026#34;, \u0026#34;Sample\u0026#34;, \u0026#34;Demo\u0026#34;)\u003cp\u003e        val filteredList by remember {\u003cbr/\u003e        derivedStateOf {\u003cbr/\u003e            testItems.filter { it.contains(searchText, ignoreCase = true) }\u003cbr/\u003e        }\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    var selection by remember { mutableStateOf(\u0026#34;\u0026#34;) }\u003cbr/\u003e    var expanded by remember { mutableStateOf(false) }\u003c/p\u003e\u003cp\u003e    ExposedSearchMenu(\u003cbr/\u003e        expanded = expanded,\u003cbr/\u003e        onExpandedChange = { expanded = it },\u003cbr/\u003e        items = filteredList,\u003cbr/\u003e        itemContent = { item -\u0026gt;\u003cbr/\u003e            DropdownMenuItem(\u003cbr/\u003e                text = { Text(item) },\u003cbr/\u003e                onClick = {\u003cbr/\u003e                    selection = item\u003cbr/\u003e                    expanded = false\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        searchContent = {\u003cbr/\u003e            TextField(\u003cbr/\u003e                value = searchText,\u003cbr/\u003e                onValueChange = { searchText = it },\u003cbr/\u003e                label = { Text(\u0026#34;Search\u0026#34;) },\u003cbr/\u003e                modifier = Modifier.fillMaxWidth()\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        displayContent = {\u003cbr/\u003e            OutlinedTextField(\u003cbr/\u003e                value = selection,\u003cbr/\u003e                onValueChange = { },\u003cbr/\u003e                label = { Text(\u0026#34;Selection\u0026#34;) },\u003cbr/\u003e                modifier = Modifier.menuAnchor(ExposedDropdownMenuAnchorType.PrimaryEditable),\u003cbr/\u003e                readOnly = true,\u003cbr/\u003e                trailingIcon = {\u003cbr/\u003e                    IconButton(onClick = { expanded = !expanded }) {\u003cbr/\u003e                        Icon(\u003cbr/\u003e                            imageVector = if (expanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown,\u003cbr/\u003e                            contentDescription = null\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"4ccc\"\u003eWhy This Approach Works\u003c/h2\u003e\u003cul\u003e\u003cli id=\"a92a\"\u003e\u003cstrong\u003eEfficient Filtering:\u003c/strong\u003e The \u003ccode\u003ederivedStateOf\u003c/code\u003e ensures that filtering is recomputed only when \u003ccode\u003esearchText\u003c/code\u003e changes.\u003c/li\u003e\u003cli id=\"0fe5\"\u003e\u003cstrong\u003eClear Selection and Search Separation:\u003c/strong\u003e Users can search freely without modifying their selected item.\u003c/li\u003e\u003cli id=\"55e4\"\u003e\u003cstrong\u003eBetter UX:\u003c/strong\u003e The dropdown remains user-friendly for large datasets, preventing excessive scrolling.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9971\"\u003eBy structuring the dropdown in this way, we enhance usability while maintaining clarity in selection and search functionalities. This approach ensures an intuitive and responsive dropdown experience, making data selection easy for users.\u003c/p\u003e\u003ch2 id=\"2f55\"\u003eLeveraging ViewModel and MVI for State Management\u003c/h2\u003e\u003cp id=\"d6b5\"\u003eWhile the previous implementation effectively manages state locally within the composable, a more scalable approach for real-world applications is to \u003cstrong\u003eseparate UI state from business logic\u003c/strong\u003e using \u003cstrong\u003eModel-View-Intent (MVI) architecture\u003c/strong\u003e.\u003c/p\u003e\u003ch2 id=\"b71b\"\u003eWhy Use ViewModel?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"c6e2\"\u003eSearching through a list might involve querying a \u003cstrong\u003edatabase\u003c/strong\u003e or making a \u003cstrong\u003eremote API call\u003c/strong\u003e.\u003c/li\u003e\u003cli id=\"97ab\"\u003eUI state should be \u003cstrong\u003epersisted across configuration changes\u003c/strong\u003e, avoiding unnecessary recomputations.\u003c/li\u003e\u003cli id=\"7ae0\"\u003e\u003cstrong\u003eDecoupling logic from UI\u003c/strong\u003e ensures cleaner, testable, and maintainable code.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"24b6\"\u003eRefactoring with ViewModel\u003c/h2\u003e\u003cp id=\"e787\"\u003eInstead of keeping \u003ccode\u003esearchText\u003c/code\u003e, \u003ccode\u003efilteredList\u003c/code\u003e, and \u003ccode\u003eselection\u003c/code\u003e inside the composable, we can move them to a \u003cstrong\u003eViewModel\u003c/strong\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dc52\"\u003eclass DropdownViewModel : ViewModel() {\u003cbr/\u003e    private val _searchText = MutableStateFlow(\u0026#34;\u0026#34;)\u003cbr/\u003e    val searchText: StateFlow\u0026lt;String\u0026gt; = _searchText.asStateFlow()\u003cp\u003e    private val _items = MutableStateFlow(listOf(\u0026#34;Test\u0026#34;, \u0026#34;Test2\u0026#34;, \u0026#34;Test3\u0026#34;, \u0026#34;Example\u0026#34;, \u0026#34;Sample\u0026#34;, \u0026#34;Demo\u0026#34;))\u003cbr/\u003e    val filteredList: StateFlow\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; = _searchText\u003cbr/\u003e        .combine(_items) { search, items -\u0026gt;\u003cbr/\u003e            items.filter { it.contains(search, ignoreCase = true) }\u003cbr/\u003e        }\u003cbr/\u003e        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList())\u003c/p\u003e\u003cp\u003e    private val _selection = MutableStateFlow(\u0026#34;\u0026#34;)\u003cbr/\u003e    val selection: StateFlow\u0026lt;String\u0026gt; = _selection.asStateFlow()\u003c/p\u003e\u003cp\u003e    fun onSearchTextChanged(text: String) {\u003cbr/\u003e        _searchText.value = text\u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    fun onItemSelected(item: String) {\u003cbr/\u003e        _selection.value = item\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"11f3\"\u003eUpdating the Composable\u003c/h2\u003e\u003cp id=\"28fe\"\u003eThen we modify our \u003ccode\u003e\u003cstrong\u003eSearchableDropdownMenu\u003c/strong\u003e\u003c/code\u003e to rely on the ViewModel:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5072\"\u003e@Composable\u003cbr/\u003efun SearchableDropdownMenu(viewModel: DropdownViewModel = viewModel()) {\u003cbr/\u003e    val searchText by viewModel.searchText.collectAsState()\u003cbr/\u003e    val filteredList by viewModel.filteredList.collectAsState()\u003cbr/\u003e    val selection by viewModel.selection.collectAsState()\u003cbr/\u003e    var expanded by remember { mutableStateOf(false) }\u003cp\u003e    ExposedSearchMenu(\u003cbr/\u003e        expanded = expanded,\u003cbr/\u003e        onExpandedChange = { expanded = it },\u003cbr/\u003e        items = filteredList,\u003cbr/\u003e        itemContent = { item -\u0026gt;\u003cbr/\u003e            DropdownMenuItem(\u003cbr/\u003e                text = { Text(item) },\u003cbr/\u003e                onClick = {\u003cbr/\u003e                    viewModel.onItemSelected(item)\u003cbr/\u003e                    expanded = false\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        searchContent = {\u003cbr/\u003e            TextField(\u003cbr/\u003e                value = searchText,\u003cbr/\u003e                onValueChange = { viewModel.onSearchTextChanged(it) },\u003cbr/\u003e                label = { Text(\u0026#34;Search\u0026#34;) },\u003cbr/\u003e                modifier = Modifier.fillMaxWidth()\u003cbr/\u003e            )\u003cbr/\u003e        },\u003cbr/\u003e        displayContent = {\u003cbr/\u003e            OutlinedTextField(\u003cbr/\u003e                value = selection,\u003cbr/\u003e                onValueChange = { },\u003cbr/\u003e                label = { Text(\u0026#34;Selection\u0026#34;) },\u003cbr/\u003e                modifier = Modifier.menuAnchor(ExposedDropdownMenuAnchorType.PrimaryEditable),\u003cbr/\u003e                readOnly = true,\u003cbr/\u003e                trailingIcon = {\u003cbr/\u003e                    IconButton(onClick = { expanded = !expanded }) {\u003cbr/\u003e                        Icon(\u003cbr/\u003e                            imageVector = if (expanded) Icons.Filled.ArrowDropUp else Icons.Filled.ArrowDropDown,\u003cbr/\u003e                            contentDescription = null\u003cbr/\u003e                        )\u003cbr/\u003e                    }\u003cbr/\u003e                }\u003cbr/\u003e            )\u003cbr/\u003e        }\u003cbr/\u003e    )\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": "2025-03-09T20:45:17.258Z",
  "modifiedTime": null
}
