{
  "id": "3c42ee21-2b92-4ebc-9cc4-74ca4edb6cb0",
  "title": "Testing safe area insets on iOS",
  "link": "https://publicobject.com/2024/11/20/testing-safe-area-insets-on-ios/",
  "description": "I’m adding edge-to-edge UI support in Redwood. My code asks the host platform how much of the screen is consumed by system bars and notches and things, and it returns us a measurement like ‘40 pixels at the top + 10 pixels at the bottom’.The iOS code to handle",
  "author": "Jesse Wilson",
  "published": "Wed, 20 Nov 2024 20:04:48 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 3286,
  "excerpt": "I’m adding edge-to-edge UI support in Redwood. My code asks the host platform how much of the screen is consumed by system bars and notches and things, and it returns us a measurement like ‘40 pixels at the top + 10 pixels at the bottom’. The iOS code to handle this is simple: class RedwoodUIView : UIStackView(cValue { CGRectZero }) { init { this.setInsetsLayoutMarginsFromSafeArea(false) // Handle insets manually. } override fun safeAreaInsetsDidChange() { super.safeAreaInsetsDi",
  "siteName": "Public Object",
  "favicon": "",
  "text": "I’m adding edge-to-edge UI support in Redwood. My code asks the host platform how much of the screen is consumed by system bars and notches and things, and it returns us a measurement like ‘40 pixels at the top + 10 pixels at the bottom’.The iOS code to handle this is simple:class RedwoodUIView : UIStackView(cValue { CGRectZero }) { init { this.setInsetsLayoutMarginsFromSafeArea(false) // Handle insets manually. } override fun safeAreaInsetsDidChange() { super.safeAreaInsetsDidChange() handleNewInsets(safeAreaInsets) } private fun handleNewInsets(safeAreaInsets: CValue\u003cUIEdgeInsets\u003e) { ... } }But writing the test was difficult. It took me two days to figure this out. @Test fun testSafeArea() { val redwoodUIView = RedwoodUIView() val viewController = object : UIViewController(null, null) { override fun loadView() { view = redwoodUIView } } val window = UIWindow( CGRectMake(0.0, 0.0, 390.0, 844.0), // iPhone 14. ) window.setHidden(false) // Necessary to propagate additionalSafeAreaInsets. window.rootViewController = viewController viewController.additionalSafeAreaInsets = UIEdgeInsetsMake(10.0, 20.0, 30.0, 40.0) }To populate safeAreaInsets on a UIView:The UIView must be in a UIViewController. There isn’t a direct way to manipulate its safeAreaInsets.That ViewController must also be in a visible UIWindow. The UIViewController won’t propagate insets unless it’s in a view hierarchy with a visible window.I spent so long trying and failing to get it working with a standalone UIViewController. That was so frustrating! Eventually I found this StackOverflow sample that happened to have a UIWindow, and I tried that and it worked.func test_presentationOfViewController() { let window = UIWindow(frame: CGRect(x: 0, y: 0, width: 300, height: 300)) window.rootViewController = sut window.makeKeyAndVisible() ... }Well, it kind of worked. It worked locally. But when I pushed my test to run on GitHub actions, it failed hard::sample:iosSimulatorArm64Test: Test running process exited unexpectedly. Current test: testSafeArea Process output: Child process terminated with signal 5: Trace/BPT trapWhat the heck is a Trace/BPT trap?! I couldn’t find more details on what broke.With more grinding and experimentation I found that my tests pass on CI once I replaced window.makeKeyAndVisible() with window.setHidden(false).The whole exercise reminds me that I value testability, and that the iOS platform engineers... don’t.UPDATE, A FEW HOURS LATERTyler Bell, a colleague who knows iOS better than I do, read this post and shared a simpler solution. Override the superview’s safeAreaInsets() function and request a layout: class InsetsContainer : UIView(cValue { CGRectZero }) { var subviewSafeAreaInsets = cValue { UIEdgeInsetsZero } set(value) { field = value setNeedsLayout() layoutIfNeeded() } override fun safeAreaInsets() = subviewSafeAreaInsets } @Test fun testSafeArea() { val insetsContainer = InsetsContainer() val redwoodUIView = RedwoodUIView() insetsContainer.addSubview(redwoodUIView) insetsContainer.subviewSafeAreaInsets = UIEdgeInsetsMake(10.0, 20.0, 30.0, 40.0) }Yay!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003eI’m adding edge-to-edge UI support in Redwood. My code asks the host platform how much of the screen is consumed by system bars and notches and things, and it returns us a measurement like ‘40 pixels at the top + 10 pixels at the bottom’.\u003c/p\u003e\u003cp\u003eThe iOS code to handle this is simple:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass RedwoodUIView : UIStackView(cValue { CGRectZero }) {\n  init {\n    this.setInsetsLayoutMarginsFromSafeArea(false) // Handle insets manually.\n  }\n\n  override fun safeAreaInsetsDidChange() {\n    super.safeAreaInsetsDidChange()\n    handleNewInsets(safeAreaInsets)\n  }\n  \n  private fun handleNewInsets(safeAreaInsets: CValue\u0026lt;UIEdgeInsets\u0026gt;) {\n    ...\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut writing the test was difficult. It took me two days to figure this out.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  @Test\n  fun testSafeArea() {\n    val redwoodUIView = RedwoodUIView()\n    val viewController = object : UIViewController(null, null) {\n      override fun loadView() {\n        view = redwoodUIView\n      }\n    }\n\n    val window = UIWindow(\n      CGRectMake(0.0, 0.0, 390.0, 844.0), // iPhone 14.\n    )\n    window.setHidden(false) // Necessary to propagate additionalSafeAreaInsets.\n    window.rootViewController = viewController\n\n    viewController.additionalSafeAreaInsets =\n      UIEdgeInsetsMake(10.0, 20.0, 30.0, 40.0)\n  }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo populate \u003ccode\u003esafeAreaInsets\u003c/code\u003e on a \u003ccode\u003eUIView\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eThe \u003ccode\u003eUIView\u003c/code\u003e must be in a \u003ccode\u003eUIViewController\u003c/code\u003e. There isn’t a direct way to manipulate its \u003ccode\u003esafeAreaInsets\u003c/code\u003e.\u003c/li\u003e\u003cli\u003eThat \u003ccode\u003eViewController\u003c/code\u003e must also be in a visible \u003ccode\u003eUIWindow\u003c/code\u003e. The \u003ccode\u003eUIViewController\u003c/code\u003e won’t propagate insets unless it’s in a view hierarchy with a visible window.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eI spent so long trying and failing to get it working with a standalone \u003ccode\u003eUIViewController\u003c/code\u003e. That was so frustrating! Eventually I found \u003ca href=\"https://stackoverflow.com/a/55620009\"\u003ethis StackOverflow sample\u003c/a\u003e that happened to have a \u003ccode\u003eUIWindow\u003c/code\u003e, and I tried that and it worked.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc test_presentationOfViewController() {\n  let window = UIWindow(frame: CGRect(x: 0, y: 0, width: 300, height: 300))\n  window.rootViewController = sut\n  window.makeKeyAndVisible()\n\n  ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWell, it \u003cem\u003ekind of\u003c/em\u003e worked. It worked locally. But when I pushed my test to run on GitHub actions, it failed hard:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e:sample:iosSimulatorArm64Test: Test running process exited unexpectedly.\nCurrent test: testSafeArea\nProcess output:\n  Child process terminated with signal 5: Trace/BPT trap\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat the heck is a \u003ccode\u003eTrace/BPT trap\u003c/code\u003e?! I couldn’t find more details on what broke.\u003c/p\u003e\u003cp\u003eWith more grinding and experimentation I found that my tests pass on CI once I replaced \u003ccode\u003ewindow.makeKeyAndVisible()\u003c/code\u003e with \u003ccode\u003ewindow.setHidden(false)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eThe whole exercise reminds me that I value testability, and that the iOS platform engineers... don’t.\u003c/p\u003e\u003ch3 id=\"update-a-few-hours-later\"\u003eUPDATE, A FEW HOURS LATER\u003c/h3\u003e\u003cp\u003e\u003ca href=\"https://github.com/tylerwbell\"\u003eTyler Bell\u003c/a\u003e, a colleague who knows iOS better than I do, read this post and shared a simpler solution. Override the superview’s \u003ccode\u003esafeAreaInsets()\u003c/code\u003e function and request a layout:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e  class InsetsContainer : UIView(cValue { CGRectZero }) {\n    var subviewSafeAreaInsets = cValue { UIEdgeInsetsZero }\n      set(value) {\n        field = value\n        setNeedsLayout()\n        layoutIfNeeded()\n      }\n\n    override fun safeAreaInsets() = subviewSafeAreaInsets\n  }\n\n  @Test\n  fun testSafeArea() {\n    val insetsContainer = InsetsContainer()\n    val redwoodUIView = RedwoodUIView()\n    insetsContainer.addSubview(redwoodUIView)\n\n    insetsContainer.subviewSafeAreaInsets =\n      UIEdgeInsetsMake(10.0, 20.0, 30.0, 40.0)\n  }\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYay!\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-11-20T20:04:48Z",
  "modifiedTime": "2024-11-21T15:24:19Z"
}
