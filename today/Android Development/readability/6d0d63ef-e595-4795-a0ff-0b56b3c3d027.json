{
  "id": "6d0d63ef-e595-4795-a0ff-0b56b3c3d027",
  "title": "Writing clean models using extensions",
  "link": "https://okkotlin.com/clean-models/",
  "description": "Models in Kotlin with data classes are already leaner and cleaner than their Java counterparts. Abstracting away all those getters, setters…",
  "author": "",
  "published": "Sun, 01 Dec 2019 00:00:00 GMT",
  "source": "https://okkotlin.com/rss.xml",
  "categories": null,
  "byline": "",
  "length": 4291,
  "excerpt": "Logic inside model classes? This week we will see how to maintain visual boundaries between logic and data in model classes.",
  "siteName": "",
  "favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAQKADAAQAAAABAAAAQAAAAABlmWCKAAAFGUlEQVR4Ae1Zb2wURRT/zc5eqxQM2BZIJQEKUk1D/BewBg0otIAiwcAXEb4ZP0hsAkbUiCQYY4wmajBGiZiYmPiBWEMNH6SUaIEoJhA0Go1FW62FRNuKkYtpe7szvtm73e7e7rW0t6Xc3Uyy2Tdv/r3fb9+8ebsL6KIZ0AxoBjQDmgHNgGZAM6AZ0AyUIgNsvKCH96+5Q1pyEw28T4LdxJiskRLTxzvPVPYv33Xcw21eqSHWm01bbNgvE/g6NUY6AyUIfEGXMQmQbzctTKXEx7a0GwoaaQ7jRyUgtb9xZcoSLfScK3OML3h1TgIUeGmLY+TiiYJHOQoAI6pNub20ZUuxg1fYIz1A7flidnv/Qw95gIr2BL4oA54fuCuHCFBHndtYCvcAASrJoQPeOedLAbzCGCBAZXilAtzFGQiC6fTWbZqCu0HmVNyYXjg1CAz+O+lGBAhQub2b5MaxMpt9M9jcW+laAja9GrK/C/LPTogLPwDJvtASrGoBEo+95+jtn9phf/5qqE/cigABmReb/NcorwB/oBn8ltXBuebf5dSlNQz71EGIc58G26egFowBMbzVscr5SGw/GAIvlUtnCjPLYK56EuYjr1AU4q56Su4BD8jbAmaAN+0Gm1HtTCX/uwT7i3cgfj8LDF0GZs0DX/oQjDu3gDEGY8FykjdDnDmU99ITnSDgAROdxB2ngBlz06eoTA4g9dETEJ1fpsGrTpd6YZ84ALvtdXcIeMN2YMZsrx4pELEoqxi5VD2mEt9MZBBfut4zy+54FyAPiCrixzaIP751mljiehhLVkZ1S+sIrLlhL8p2tDqXuf554JokgIBg5jzHaGmnIH45mRsUtYjODq+dVdV6crbAG5+GsfheRy1+OwPryD4abGV3m3A9Ng9g1Yucfa0skeTqEPaoRsm/e7x2VrXQk/0CX7UDvH6to1IeY322FyBy4yzxBUHLF+XLpo1to7/PUDLU36i9B4yOU1VE7/ewDu8h8MOhfvkqYvMAOdBD3weFYw+7YQ6QMT6Xgcpj3CL/Ou+K3t0FrxSy/1fAR7DXKQYhNgLU05H93Z5JfNmjnhwSKKLz2zZ6apUdRhWZ2Ub89k0wspOqqAET0MVHAC1uf/WhZ4Jz1i9a4dU9gYKlufYZsEzOL/q6IM6f8JpdQfR+B6tlNzwS1uxErljhjpnIPVYCZNfXED3nHDsYN5HYuA/8wRdg1K8DU0nP8q1IbDvgRXUFzskJIgKmvNwHSSTYpz5Iz5e4DubDdAKMsbXGS0J8QTCzsnXkJZjrnoVR2+BoeN39gLqyihxMwj7+FqL2v7+rOHsIoqaeSFsBNrOG5n4OVuuL/i55ybF6gGMJpbxW6x5YJ9+HTPaHjFNPXXR/Q1ni4+ksMdQjrLCOvgb5z0WnQZ0Oxt3bwp2uUMMAyslHCtVHytAbq+P/zzNtFticOnodroSk/S77KKJPwnE2gmIsiXWW72r3vnrFvgVCy1M6LLtPZ36lhVqvuoJBXvAvGv8W8M9+Dcrk4oEcveQIYCY77H8upUUAw89lze3pczrDQkkRwMHphSJYSoYABnba3Nn2SRB+jn+D2Z0KvU6f3wYSprE1CkfRewB9ekwxzjazp9pG3tR8TBQ1AerJM240JpqPdfgwB8SiJUDteXL7ZaOBV0xMfiYY4PsqVOioU9E+KuBFrV7QBND+TkrJLqr0VmV4KsnJPuejQGudZkAzoBnQDGgGNAOaAc2AZkAzoBn4H3WFe3QRC8LrAAAAAElFTkSuQmCC",
  "text": "Models in Kotlin with data classes are already leaner and cleaner than their Java counterparts. Abstracting away all those getters, setters, toString() and copy() method with a single keyword makes our models reflect the only thing they should be concerned about — holding data. As I was exploring Swift for a project, I came across a lovely concept of separating business or transformation logic from models with the help of extensions. This week, we will apply this concept to our Kotlin data classes. When requirements outgrow a pure data class A simple data class in our project is the purest form of a model we can have. I mean, look at this: data class Podcast( val name: String, val description: String, val category: String, val publisher: String, val website: String ) One quick peek and we know it's a Podcast model and what data we need to provide to get an instance of this class. The data keyword indicates that we have access to all those fancy methods like, copy() and toString() without any extra line of code. In reality, however, our model classes might have to do a bit of extra work than just being data containers. Having convenience methods to format data from model class properties is a known practice. From a bird's eye view, the following class will probably seem fine: data class Podcast( val name: String, val description: String, val category: String, val publisher: String, val website: String ) { fun getPublisherMeta(): String = \"$publisher: $website\" fun getQualifiedUrl(): String = \"https://$website\" } After all, there's nothing wrong in having two convenience methods to print out podcast meta data. They are strongly related to the model we are working with. However, adding utility methods inside our models tank their readability level. Our model is no longer a simple container for data. It has logic mixed up with data. Throw in a few more methods, and we will no longer have that \"one quick peek to know the data\" readability. Should we put logic inside our model classes? Having logic inside a model class is fine. But imagine: What if we could have some boundary between the data and logic in our models? That would make our models stay true to their name. One separate block of code depicting a pure data entity and nothing more. // Pure data part data class Podcast( val name: String, val description: String, val category: String, val publisher: String, val website: String ) Now, the question that comes is where exactly to put any added functionality if not within the class itself. There's a Kotlin way to this problem. Added functionalities as extensions We can use Kotlin's extension functions to cut-paste logic from our data classes to top-level functions. With this approach, our previously bloated data class breaks down into two separate units: // Pure data part data class Podcast( val name: String, val description: String, val category: String, val publisher: String, val website: String ) // Business logic part fun Podcast.getPublisherMeta(): String = \"$publisher: $website\" fun Podcast.getQualifiedUrl(): String = \"https://$website\" Even if we add a hundred extension functions, from a readability standpoint, our Podcast model is still lean and a separate block of code. Also, functionality wise, this approach is essentially the same as that we had before. That means, we can still call getPublisherMeta() on a Podcast instance, and it will return the correct value depending on which instance we are calling the method on. The only difference is, our model classes read better now. We can go a step further here and extract out the extension functions in a separate file. However, that kind of separation is often unnecessary. Your mileage may vary There's no one way to achieve something. Programming is a significant proof of this concept. Programmers have their particular coding style preferences. I would suggest you take this approach out for a spin and see if it makes sense for your projects. It's a small refactor with a decent treat for your and your teammates' eyes. Here's a sketch note on the topic",
  "image": "https://okkotlin.com/images/clean-models-featured.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eModels in Kotlin with data classes are already leaner and cleaner than their Java counterparts. Abstracting away all those getters, setters, \u003ccode\u003etoString()\u003c/code\u003e and \u003ccode\u003ecopy()\u003c/code\u003e method with a single keyword makes our models reflect the only thing they should be concerned about — holding data.\u003c/p\u003e\n\u003cp\u003eAs I was exploring Swift for a project, I came across a lovely concept of separating business or transformation logic from models with the help of extensions. This week, we will apply this concept to our Kotlin data classes.\u003c/p\u003e\n\u003ch2 id=\"when-requirements-outgrow-a-pure-data-class\"\u003eWhen requirements outgrow a pure data class\u003c/h2\u003e\n\u003cp\u003eA simple data class in our project is the purest form of a model we can have. I mean, look at this:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePodcast\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e name\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e description\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e category\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e publisher\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e website\u003cspan\u003e:\u003c/span\u003e String\n\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eOne quick peek and we know it\u0026#39;s a \u003ccode\u003ePodcast\u003c/code\u003e model and what data we need to provide to get an instance of this class. \u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003edata\u003c/code\u003e keyword indicates that we have access to all those fancy methods like, \u003ccode\u003ecopy()\u003c/code\u003e and \u003ccode\u003etoString()\u003c/code\u003e without any extra line of code.\u003c/p\u003e\n\u003cp\u003eIn reality, however, our model classes might have to do a bit of extra work than just being data containers. Having convenience methods to format data from model class properties is a known practice.\u003c/p\u003e\n\u003cp\u003eFrom a bird\u0026#39;s eye view, the following class will probably seem fine:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePodcast\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e name\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e description\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e category\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e publisher\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e website\u003cspan\u003e:\u003c/span\u003e String\n\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e    \n        \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003egetPublisherMeta\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$publisher\u003c/span\u003e: \u003cspan\u003e$website\u003c/span\u003e\u0026#34;\u003c/span\u003e    \n        \u003cspan\u003efun\u003c/span\u003e \u003cspan\u003egetQualifiedUrl\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;https://\u003cspan\u003e$website\u003c/span\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAfter all, there\u0026#39;s nothing wrong in having two convenience methods to print out podcast meta data. They are strongly related to the model we are working with.\u003c/p\u003e\n\u003cp\u003eHowever, adding utility methods inside our models tank their readability level. Our model is no longer a simple container for data. It has logic mixed up with data.\u003c/p\u003e\n\u003cp\u003eThrow in a few more methods, and we will no longer have that \u0026#34;one quick peek to know the data\u0026#34; readability.\u003c/p\u003e\n\u003ch2 id=\"should-we-put-logic-inside-our-model-classes\"\u003eShould we put logic inside our model classes?\u003c/h2\u003e\n\u003cp\u003eHaving logic inside a model class is fine. But imagine:\u003c/p\u003e\n\u003cp\u003eWhat if we could have some boundary between the data and logic in our models?\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/ca3a1/clean-models-boundary.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Boundary between logic and data\" title=\"Boundary between logic and data\" src=\"https://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/dbb61/clean-models-boundary.png\" srcset=\"https://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/19bd1/clean-models-boundary.png 163w,\nhttps://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/d3bcb/clean-models-boundary.png 325w,\nhttps://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/dbb61/clean-models-boundary.png 650w,\nhttps://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/6b691/clean-models-boundary.png 975w,\nhttps://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/91670/clean-models-boundary.png 1300w,\nhttps://okkotlin.com/static/3153a4d0945cd0bec4ae78169f26be38/ca3a1/clean-models-boundary.png 2128w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eThat would make our models stay true to their name. One separate block of code depicting a pure data entity and nothing more.\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Pure data part\u003c/span\u003e\n\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePodcast\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e name\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e description\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e category\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e publisher\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e website\u003cspan\u003e:\u003c/span\u003e String\n\u003cspan\u003e)\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow, the question that comes is where exactly to put any added functionality if not within the class itself. There\u0026#39;s a Kotlin way to this problem.\u003c/p\u003e\n\u003ch2 id=\"added-functionalities-as-extensions\"\u003eAdded functionalities as extensions\u003c/h2\u003e\n\u003cp\u003eWe can use Kotlin\u0026#39;s extension functions to cut-paste logic from our data classes to top-level functions.\u003c/p\u003e\n\u003cp\u003eWith this approach, our previously bloated data class breaks down into two separate units:\u003c/p\u003e\n\u003cdiv data-language=\"kotlin\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e// Pure data part\u003c/span\u003e\n\u003cspan\u003edata\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePodcast\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e name\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e description\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e category\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e publisher\u003cspan\u003e:\u003c/span\u003e String\u003cspan\u003e,\u003c/span\u003e    \n    \u003cspan\u003eval\u003c/span\u003e website\u003cspan\u003e:\u003c/span\u003e String\n\u003cspan\u003e)\u003c/span\u003e\n    \n\u003cspan\u003e// Business logic part\u003c/span\u003e\n\u003cspan\u003efun\u003c/span\u003e Podcast\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetPublisherMeta\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003cspan\u003e$publisher\u003c/span\u003e: \u003cspan\u003e$website\u003c/span\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003efun\u003c/span\u003e Podcast\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetQualifiedUrl\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e String \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;https://\u003cspan\u003e$website\u003c/span\u003e\u0026#34;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eEven if we add a hundred extension functions, from a readability standpoint, our \u003ccode\u003ePodcast\u003c/code\u003e model is still lean and a separate block of code. Also, functionality wise, this approach is essentially the same as that we had before.\u003c/p\u003e\n\u003cp\u003eThat means, we can still call \u003ccode\u003egetPublisherMeta()\u003c/code\u003e on a \u003ccode\u003ePodcast\u003c/code\u003e instance, and it will return the correct value depending on which instance we are calling the method on.\u003c/p\u003e\n\u003cp\u003eThe only difference is, our model classes read better now.\u003c/p\u003e\n\u003cp\u003eWe can go a step further here and extract out the extension functions in a separate file. However, that kind of separation is often unnecessary.\u003c/p\u003e\n\u003ch2 id=\"your-mileage-may-vary\"\u003eYour mileage may vary\u003c/h2\u003e\n\u003cp\u003eThere\u0026#39;s no one way to achieve something. Programming is a significant proof of this concept. Programmers have their particular coding style preferences.\u003c/p\u003e\n\u003cp\u003eI would suggest you take this approach out for a spin and see if it makes sense for your projects. It\u0026#39;s a small refactor with a decent treat for your and your teammates\u0026#39; eyes.\u003c/p\u003e\n\u003ch2 id=\"heres-a-sketch-note-on-the-topic\"\u003eHere\u0026#39;s a sketch note on the topic\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/d40c8/clean-models-sketch-note.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Clean models sketch note\" title=\"Clean models sketch note\" src=\"https://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/dbb61/clean-models-sketch-note.png\" srcset=\"https://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/19bd1/clean-models-sketch-note.png 163w,\nhttps://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/d3bcb/clean-models-sketch-note.png 325w,\nhttps://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/dbb61/clean-models-sketch-note.png 650w,\nhttps://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/6b691/clean-models-sketch-note.png 975w,\nhttps://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/91670/clean-models-sketch-note.png 1300w,\nhttps://okkotlin.com/static/8427908f97d098c8c669675c10a4dcf5/d40c8/clean-models-sketch-note.png 2000w\" sizes=\"(max-width: 650px) 100vw, 650px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
