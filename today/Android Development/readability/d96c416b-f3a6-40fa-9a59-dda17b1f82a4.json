{
  "id": "d96c416b-f3a6-40fa-9a59-dda17b1f82a4",
  "title": "Compose Multi Platform + Custom Camera With Common Capture Design",
  "link": "https://proandroiddev.com/compose-multi-platform-custom-camera-with-common-capture-design-386dbc2aa03e?source=rss----c72404660798---4",
  "description": "",
  "author": "Arul mani",
  "published": "Mon, 21 Jul 2025 00:54:03 GMT",
  "source": "https://proandroiddev.com/feed",
  "categories": [
    "kotlin",
    "jetpack-compose",
    "compose-multiplatform",
    "kotlin-multiplatform"
  ],
  "byline": "Arul mani",
  "length": 5366,
  "excerpt": "In this article, we’ll dive into how to build a custom camera module in a Compose Multiplatform (CMP) project using a shared design pattern. We’ll leverage expect/actual to abstract platform-specific…",
  "siteName": "ProAndroidDev",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*A8VytPZQhvUf_MG6hm_Dlw.png",
  "text": "In this article, we’ll dive into how to build a custom camera module in a Compose Multiplatform (CMP) project using a shared design pattern. We’ll leverage expect/actual to abstract platform-specific camera logic, while keeping the UI and interaction layer common across Android and iOS.Why a Custom Camera in CMP?Native camera APIs are platform-specificCompose Multiplatform enables shared UI but needs abstraction for platform accessA common capture interface improves testability, reuse, and architectural cleanlinessDoes not depend on 3rd party librariesLike above mentioned diagram we implement CameraView in separate platform and controls \u0026 control designs are in commonMain.Lets get startedAdd following in commonMain/commonMain/common/Camera.ktExplanation:Platform-Agnostic Structure CameraView is defined as an expect composable, which allows you to implement platform-specific camera UIs separately for Android, iOS, etc., using Kotlin Multiplatform.Event-Driven Camera Control CameraEvent is a sealed class that represents user actions (like capturing or switching camera). These events are dispatched through a coroutine-based Channel to the UI layer.Reactive State Handling via Flow CameraCallback collects camera events using eventFlow, making the UI respond dynamically to user-triggered actions outside the composable.Abstracted Capture Result Handling onCaptureImage() is an abstract function that handles image results uniformly across platforms, providing a clean contract for success or error callbacks.We used CameraCallback to observer user event on each platform. And received onCaptureImage in common UI to get the image path.ExplanationPreview SetupPreviewView: A view that displays the camera preview.Preview.Builder(): Creates a preview use case.Binds the preview to the lifecycle of the activity using cameraProvider.bindToLifecycle.Capture Photo (takePicture)Creates a file in the app’s internal or external storage.Uses ImageCapture.takePicture() to capture the photo.Handles success and error via OnImageSavedCallback.Switch Camera Lens (switchLens)Toggles between front (CameraSelector.LENS_FACING_FRONT) and back (LENS_FACING_BACK) cameras.Rebinds the camera with the updated lens configuration.Camera Binding (LaunchedEffect)Waits for the camera to be ready (cameraProviderFuture).Builds and binds the camera use cases (preview and image capture).Reacts to lens changes to rebind camera.Composable Lifecycle HooksDisposableEffect: Unbinds camera use cases when CameraView is disposed, preventing resource leaks.LaunchedEffect: Observes camera events (CameraEvent) and triggers actions accordingly.File StoragegetOutputDirectory(): Ensures the image is saved in either a custom external media directory (bms) or fallback to internal storage.No special permissions are required for internal storage.Event Observercallback.eventFlow.collect { when (it) { CameraEvent.CaptureImage -\u003e takePicture() CameraEvent.SwitchCamera -\u003e switchLens() }}Listens for camera-related events.Makes the composable reactive to user actions outside the view (like a button click elsewhere that triggers CameraEvent).And Finally iOS Implementation,ExplanationCamera SetupInitializes AVCaptureSession with photo preset for high-resolution image capture.Adds AVCaptureStillImageOutput with JPEG codec configuration to the session.Camera Devices \u0026 SwitchingRetrieves front and back cameras using AVCaptureDevice and determines which one to activate.Switches between front/back cameras by removing and re-adding the appropriate AVCaptureDeviceInput.Preview RenderingCreates a UIView container and inserts an AVCaptureVideoPreviewLayer to show live camera feed.Uses UIKitView from Compose to embed the native preview into the Compose UI with full size and dynamic resizing.Event Handling via FlowCollects camera-related events from CameraCallback.eventFlow:CameraEvent.CaptureImage captures a photo asynchronously and saves it to a temporary location.CameraEvent.SwitchCamera reconfigures session inputs to switch between cameras.The result is passed back via callback.onCaptureImage(imagePath).So basically same implementation like android with iosComponent in it. Dont forget the callback!!!How to Consume?Lets see how we consume inside commonMainCreate ImageCaptureView Composable Component, below approach will be useful when we reuse the ImageCaptureView on different screens.And wherever we want to implement in application we can do like following.var showCamera by remember { mutableStateOf(false) }var imagePath by remember { mutableStateOf\u003cPath?\u003e(null) }if (showCamera) { ImageCaptureView(onImageCaptured = { scope.launch { showCamera = false imagePath = it } }, onClose = { showCamera = false })}ConclusionOur implementation successfully combines shared business logic with powerful native features, delivering a consistent UI across platforms. It’s scalable for additional capabilities like video recording, zoom, and filters. You’ve achieved a modern, maintainable solution that aligns with best practices for MultiPlatform development.There are libraries that make this easier, but if we truly want a custom camera solution, this thread will be helpful. :-)Let me know if you’d like to extend this with extra functionality or refactor pieces for even better performance or testing. ;-)—",
  "image": "https://miro.medium.com/v2/resize:fit:717/1*lccxXjATwY75uhtbtN18tA.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca href=\"https://codingwitharul.medium.com/?source=post_page---byline--386dbc2aa03e---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Arul mani\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*WAWacks2vBwwnY7zP0V3YQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"6b75\"\u003eIn this article, we’ll dive into how to build a \u003cstrong\u003ecustom camera module\u003c/strong\u003e in a \u003cstrong\u003eCompose Multiplatform (CMP)\u003c/strong\u003e project using a shared design pattern. We’ll leverage \u003ccode\u003eexpect/actual\u003c/code\u003e to abstract platform-specific camera logic, while keeping the \u003cstrong\u003eUI \u003c/strong\u003eand \u003cstrong\u003einteraction layer \u003c/strong\u003ecommon across Android and iOS.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"ed67\"\u003eWhy a Custom Camera in CMP?\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d17b\"\u003eNative camera APIs are platform-specific\u003c/li\u003e\u003cli id=\"0c5d\"\u003eCompose Multiplatform enables shared UI but needs abstraction for platform access\u003c/li\u003e\u003cli id=\"b5a4\"\u003eA common capture interface improves testability, reuse, and architectural cleanliness\u003c/li\u003e\u003cli id=\"caeb\"\u003eDoes not depend on 3rd party libraries\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5cd8\"\u003eLike above mentioned diagram we implement \u003cstrong\u003eCameraView\u003c/strong\u003e in separate platform and controls \u0026amp; control designs are in \u003cem\u003ecommonMain\u003c/em\u003e.\u003c/p\u003e\u003ch2 id=\"391d\"\u003eLets get started\u003c/h2\u003e\u003cp id=\"facf\"\u003eAdd following in commonMain\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e/commonMain/common/Camera.kt\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"5975\"\u003e\u003cstrong\u003eExplanation:\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli id=\"1a97\"\u003e\u003cstrong\u003ePlatform-Agnostic Structure\u003c/strong\u003e \u003ccode\u003eCameraView\u003c/code\u003e is defined as an \u003ccode\u003eexpect\u003c/code\u003e composable, which allows you to implement platform-specific camera UIs separately for Android, iOS, etc., using Kotlin Multiplatform.\u003c/li\u003e\u003cli id=\"9d4b\"\u003e\u003cstrong\u003eEvent-Driven Camera Control\u003c/strong\u003e \u003ccode\u003eCameraEvent\u003c/code\u003e is a sealed class that represents user actions (like capturing or switching camera). These events are dispatched through a coroutine-based \u003ccode\u003eChannel\u003c/code\u003e to the UI layer.\u003c/li\u003e\u003cli id=\"9af7\"\u003e\u003cstrong\u003eReactive State Handling via Flow\u003c/strong\u003e \u003ccode\u003eCameraCallback\u003c/code\u003e collects camera events using \u003ccode\u003eeventFlow\u003c/code\u003e, making the UI respond dynamically to user-triggered actions outside the composable.\u003c/li\u003e\u003cli id=\"323a\"\u003e\u003cstrong\u003eAbstracted Capture Result Handling\u003c/strong\u003e \u003ccode\u003eonCaptureImage()\u003c/code\u003e is an abstract function that handles image results uniformly across platforms, providing a clean contract for success or error callbacks.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"e523\"\u003eWe used \u003cstrong\u003eCameraCallback\u003c/strong\u003e to observer user event on each platform. And received \u003cstrong\u003eonCaptureImage\u003c/strong\u003e in common UI to get the image path.\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"34fa\"\u003eExplanation\u003c/h2\u003e\u003cp id=\"7bb0\"\u003e\u003cstrong\u003ePreview Setup\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"9fee\"\u003e\u003ccode\u003ePreviewView\u003c/code\u003e: A view that displays the camera preview.\u003c/li\u003e\u003cli id=\"0545\"\u003e\u003ccode\u003ePreview.Builder()\u003c/code\u003e: Creates a preview use case.\u003c/li\u003e\u003cli id=\"47e6\"\u003eBinds the preview to the lifecycle of the activity using \u003ccode\u003ecameraProvider.bindToLifecycle\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5a48\"\u003e\u003cstrong\u003eCapture Photo (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003etakePicture\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8806\"\u003eCreates a file in the app’s internal or external storage.\u003c/li\u003e\u003cli id=\"7a28\"\u003eUses \u003ccode\u003eImageCapture.takePicture()\u003c/code\u003e to capture the photo.\u003c/li\u003e\u003cli id=\"fa6b\"\u003eHandles success and error via \u003ccode\u003eOnImageSavedCallback\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5ef6\"\u003e\u003cstrong\u003eSwitch Camera Lens (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eswitchLens\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"8fa7\"\u003eToggles between front (\u003ccode\u003eCameraSelector.LENS_FACING_FRONT\u003c/code\u003e) and back (\u003ccode\u003eLENS_FACING_BACK\u003c/code\u003e) cameras.\u003c/li\u003e\u003cli id=\"095f\"\u003eRebinds the camera with the updated lens configuration.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6bcc\"\u003e\u003cstrong\u003eCamera Binding (\u003c/strong\u003e\u003ccode\u003e\u003cstrong\u003eLaunchedEffect\u003c/strong\u003e\u003c/code\u003e\u003cstrong\u003e)\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"e578\"\u003eWaits for the camera to be ready (\u003ccode\u003ecameraProviderFuture\u003c/code\u003e).\u003c/li\u003e\u003cli id=\"76a5\"\u003eBuilds and binds the camera use cases (preview and image capture).\u003c/li\u003e\u003cli id=\"9988\"\u003eReacts to lens changes to rebind camera.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d12c\"\u003e\u003cstrong\u003eComposable Lifecycle Hooks\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"1066\"\u003e\u003ccode\u003eDisposableEffect\u003c/code\u003e: Unbinds camera use cases when \u003ccode\u003eCameraView\u003c/code\u003e is disposed, preventing resource leaks.\u003c/li\u003e\u003cli id=\"b6e6\"\u003e\u003ccode\u003eLaunchedEffect\u003c/code\u003e: Observes camera events (\u003ccode\u003eCameraEvent\u003c/code\u003e) and triggers actions accordingly.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"ae77\"\u003e\u003cstrong\u003eFile Storage\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"b20a\"\u003e\u003ccode\u003egetOutputDirectory()\u003c/code\u003e: Ensures the image is saved in either a custom external media directory (\u003ccode\u003ebms\u003c/code\u003e) or fallback to internal storage.\u003c/li\u003e\u003cli id=\"5e55\"\u003eNo special permissions are required for internal storage.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e4c6\"\u003e\u003cstrong\u003eEvent Observer\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5707\"\u003ecallback.eventFlow.collect {\u003cbr/\u003e    when (it) {\u003cbr/\u003e        CameraEvent.CaptureImage -\u0026gt; takePicture()\u003cbr/\u003e        CameraEvent.SwitchCamera -\u0026gt; switchLens()\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"e406\"\u003eListens for camera-related events.\u003c/li\u003e\u003cli id=\"4caf\"\u003eMakes the composable reactive to user actions outside the view (like a button click elsewhere that triggers \u003ccode\u003eCameraEvent\u003c/code\u003e).\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"40db\"\u003eAnd \u003cstrong\u003eFinally\u003c/strong\u003e \u003cstrong\u003eiOS\u003c/strong\u003e Implementation,\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"98b0\"\u003eExplanation\u003c/h2\u003e\u003cp id=\"420b\"\u003e\u003cstrong\u003eCamera Setup\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7f68\"\u003eInitializes \u003ccode\u003eAVCaptureSession\u003c/code\u003e with photo preset for high-resolution image capture.\u003c/li\u003e\u003cli id=\"2fe0\"\u003eAdds \u003ccode\u003eAVCaptureStillImageOutput\u003c/code\u003e with JPEG codec configuration to the session.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8c38\"\u003e\u003cstrong\u003eCamera Devices \u0026amp; Switching\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"efeb\"\u003eRetrieves \u003cstrong\u003efront and back cameras\u003c/strong\u003e using \u003ccode\u003eAVCaptureDevice\u003c/code\u003e and determines which one to activate.\u003c/li\u003e\u003cli id=\"140b\"\u003eSwitches between front/back cameras by removing and re-adding the appropriate \u003ccode\u003eAVCaptureDeviceInput\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"03ea\"\u003e\u003cstrong\u003ePreview Rendering\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"827d\"\u003eCreates a \u003ccode\u003eUIView\u003c/code\u003e container and inserts an \u003ccode\u003eAVCaptureVideoPreviewLayer\u003c/code\u003e to show live camera feed.\u003c/li\u003e\u003cli id=\"14b8\"\u003eUses \u003ccode\u003eUIKitView\u003c/code\u003e from Compose to embed the native preview into the Compose UI with full size and dynamic resizing.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"7cdf\"\u003e\u003cstrong\u003eEvent Handling via Flow\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"0eba\"\u003eCollects camera-related events from \u003ccode\u003eCameraCallback.eventFlow\u003c/code\u003e:\u003c/li\u003e\u003cli id=\"0be6\"\u003e\u003ccode\u003eCameraEvent.CaptureImage\u003c/code\u003e captures a photo asynchronously and saves it to a temporary location.\u003c/li\u003e\u003cli id=\"066c\"\u003e\u003ccode\u003eCameraEvent.SwitchCamera\u003c/code\u003e reconfigures session inputs to switch between cameras.\u003c/li\u003e\u003cli id=\"99d0\"\u003eThe result is passed back via \u003ccode\u003ecallback.onCaptureImage(imagePath)\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"36af\"\u003e\u003cspan\u003eSo\u003c/span\u003e basically same implementation like android with \u003cstrong\u003eiosComponent\u003c/strong\u003e in it. Dont forget the callback!!!\u003c/p\u003e\u003ch2 id=\"8f7a\"\u003eHow to Consume?\u003c/h2\u003e\u003cp id=\"5abc\"\u003eLets see how we consume inside commonMain\u003c/p\u003e\u003cp id=\"1480\"\u003eCreate \u003cstrong\u003eImageCaptureView\u003c/strong\u003e \u003cem\u003eComposable\u003c/em\u003e \u003cem\u003eComponent, \u003c/em\u003ebelow approach will be useful when we reuse the \u003cstrong\u003eImageCaptureView\u003c/strong\u003e on different screens.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a312\"\u003eAnd wherever we want to implement in application we can do like following.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0276\"\u003evar showCamera by remember { mutableStateOf(false) }\u003cbr/\u003evar imagePath by remember { mutableStateOf\u0026lt;Path?\u0026gt;(null) }\u003cbr/\u003eif (showCamera) {\u003cbr/\u003e    ImageCaptureView(onImageCaptured = {\u003cbr/\u003e        scope.launch {\u003cbr/\u003e            showCamera = false\u003cbr/\u003e            imagePath = it\u003cbr/\u003e        }\u003cbr/\u003e    }, onClose = { showCamera = false })\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"c38a\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"518f\"\u003eOur implementation successfully combines shared business logic with powerful native features, delivering a consistent UI across platforms. It’s scalable for additional capabilities like video recording, zoom, and filters. You’ve achieved a modern, maintainable solution that aligns with best practices for \u003cstrong\u003eMultiPlatform\u003c/strong\u003e development.\u003c/p\u003e\u003cp id=\"55e4\"\u003eThere are libraries that make this easier, but if we truly want a custom camera solution, this thread will be helpful. :-)\u003c/p\u003e\u003cp id=\"4544\"\u003eLet me know if you’d like to extend this with extra functionality or refactor pieces for even better performance or testing. ;-)\u003c/p\u003e\u003cp id=\"2b2a\"\u003e—\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-07-21T00:54:03.328Z",
  "modifiedTime": null
}
