{
  "id": "b1e2ec34-8bc3-4a6c-a3aa-2e7ab845e24b",
  "title": "Identifiers aren’t Services",
  "link": "https://publicobject.com/2024/07/09/identifiers-arent-services/",
  "description": "Originally published on May 23, 2024 in fun code().The programs I write frequently involve strings that identify things: emailaddresses, file paths, URLs, time zones... even credit card numbers and drivers’license numbers.For many years I followed the patterns of the Java standard library whencreating my own",
  "author": "Jesse Wilson",
  "published": "Tue, 09 Jul 2024 22:28:14 GMT",
  "source": "https://publicobject.com/rss/",
  "categories": null,
  "byline": "Jesse Wilson",
  "length": 4874,
  "excerpt": "Originally published on May 23, 2024 in fun code() [https://github.com/kotlin-magazine/kotlin-magazine]. The programs I write frequently involve strings that identify things: email addresses, file paths, URLs, time zones... even credit card numbers and drivers’ license numbers. For many years I followed the patterns of the Java standard library when creating my own identifiers. I’ve grown to dislike these patterns! java.net.URL I’ll start by complaining about Java’s URL class, again [https:/",
  "siteName": "Public Object",
  "favicon": "",
  "text": "Originally published on May 23, 2024 in fun code().The programs I write frequently involve strings that identify things: emailaddresses, file paths, URLs, time zones... even credit card numbers and drivers’license numbers.For many years I followed the patterns of the Java standard library whencreating my own identifiers.I’ve grown to dislike these patterns!java.net.URLI’ll start by complaining about Java’s URL class, again:val url = URL(\"https://publicobject.com/helloworld.txt\") val content = url.openStream().use { it.readBytes() } println(content.decodeToString()) This does a lot in 3 lines of Kotlin! We identify a URL, fetch its contents, andprint them to the console. But despite its compactness, this code is bad.There's an HTTP client hiding in the URL class. When I call openStream(), thatclient is prepared and put to work. I don’t like being cut out of that setup! Ican't dependency-inject my own configured instance for production or a fake in atest.java.net.URL is serving two competing purposes: as an identifier and as aservice.Identifiers are values that we do value-like things with:Accept as input from a personValidate for structureWrite to a database, file, or remote processAssert equality in a test caseNothing is lost when we send an identifier from one program to another.ServicesWhile it's easy to pass a URL string from one computer to another, we can’t passthe InputStream that reads the response body.Symmetrically, we can send a timestamp from one computer to another, but wecan’t send the Clock that produced it. That's because it's a softwareabstraction over a specific quartz crystal that’s bound to the physical world!java.io.FileJava's original file class both identifies a location on the file system andalso operates on that location.I might write an Android app that sends its collection of cached images to theserver as a List\u003cFile\u003e. My server could call File.delete() to free up spaceon that Android device, but that's not what would happen!Subclassing File is another thing you could do, but shouldn’t:class ImmortalFile(delegate: File) : File(delegate.path) { override fun delete() = false } If you want to write testable code that operates on files, considerOkio!java.nio.PathThe new (2011) file system APIs are on the right track, but you have to becareful to use it in a testable way. Each Path has both a path string (theidentifier) and a file system (the service).This code is implicitly coupled to the default file system:class HelloReader() { fun readHello(): String { val helloPath = Paths.get(\"hello.txt\") return Files.readString(helloPath) } } By changing every call to Paths.get(...) with FileSystem.getPath(...), I canmake this testable (such as with [Jimfs]):class HelloReader( val fileSystem: FileSystem, ) { fun readHello(): String { val helloPath = fileSystem.getPath(\"hello.txt\") return Files.readString(helloPath) } } java.net.InetSocketAddressI get myself into trouble whenever I use Java's Internet address API:// Wrong! This eagerly looks an IP address for publicobject.com. val connectAddress = InetSocketAddress(\"publicobject.com\", 443) The method to use is createUnresolved():val connectAddress = InetSocketAddress.createUnresolved(\"publicobject.com\", 443) Even though I used the same host and port to create these two instances, theydon't .equals() each other. Unless I’m offline, in which case they do.kotlinx.datetime.TimeZoneI need to build a report that summarizes the emails that our service sends eachday. The input is a set of SentEmail records:data class SentEmail( val customerId: Id, val timeZone: TimeZone, val locale: Locale, val emailAddressId: Id, val templateId: TemplateId, val enqueuedAt: Instant, val deliveredAt: Instant, ) The TimeZone class looks like an innocuous way to track a string like\"America/New_York\" in a type-safe way.Unfortunately, Kotlin’s time zone class throws when it's given a time zone thatisn't in its host JVM's time zone database. My report will crash ifany customer uses Europe/Kyiv (renamed from Europe/Kiev in 2022).java.time.zone.ZoneRulesException: Unknown time-zone ID: Europe/Kyiv at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java) at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java) at java.time.ZoneRegion.ofId(ZoneRegion.java) at java.time.ZoneId.of(ZoneId.java) at kotlinx.datetime.TimeZone$Companion.of(TimeZoneJvm.kt) I can fix this crash by updating my JVM to one with more up-to-date time zonedata. Even when I only need an identifier, TimeZone always loads the offsetrules.AdviceWhen using an identifier type like File, InetSocketAddress, or TimeZone,pay careful attention to what side effects your identifier is triggering.When writing your own identifier code, please use a data class for the valuepart and a separate interface for its related services.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\t\t\t\u003cp\u003e\u003cem\u003eOriginally published on May 23, 2024 in \u003ca href=\"https://github.com/kotlin-magazine/kotlin-magazine\"\u003efun code()\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eThe programs I write frequently involve strings that identify things: email\u003cbr/\u003eaddresses, file paths, URLs, time zones... even credit card numbers and drivers’\u003cbr/\u003elicense numbers.\u003c/p\u003e\u003cp\u003eFor many years I followed the patterns of the Java standard library when\u003cbr/\u003ecreating my own identifiers.\u003c/p\u003e\u003cp\u003eI’ve grown to dislike these patterns!\u003c/p\u003e\u003ch3 id=\"java-net-url\"\u003ejava.net.URL\u003c/h3\u003e\u003cp\u003eI’ll start by complaining about Java’s URL class, \u003ca href=\"https://developer.squareup.com/blog/okhttps-new-url-class/\"\u003eagain\u003c/a\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval url = URL(\u0026#34;https://publicobject.com/helloworld.txt\u0026#34;)\nval content = url.openStream().use { it.readBytes() }\nprintln(content.decodeToString())\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis does a lot in 3 lines of Kotlin! We identify a URL, fetch its contents, and\u003cbr/\u003eprint them to the console. But despite its compactness, this code is bad.\u003c/p\u003e\u003cp\u003eThere\u0026#39;s an HTTP client hiding in the URL class. When I call \u003ccode\u003eopenStream()\u003c/code\u003e, that\u003cbr/\u003eclient is prepared and put to work. I don’t like being cut out of that setup! I\u003cbr/\u003ecan\u0026#39;t dependency-inject my own configured instance for production or a fake in a\u003cbr/\u003etest.\u003c/p\u003e\u003cp\u003e\u003ccode\u003ejava.net.URL\u003c/code\u003e is serving two competing purposes: as an identifier and as a\u003cbr/\u003eservice.\u003c/p\u003e\u003cp\u003eIdentifiers are values that we do value-like things with:\u003c/p\u003e\u003cul\u003e\u003cli\u003eAccept as input from a person\u003c/li\u003e\u003cli\u003eValidate for structure\u003c/li\u003e\u003cli\u003eWrite to a database, file, or remote process\u003c/li\u003e\u003cli\u003eAssert equality in a test case\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNothing is lost when we send an identifier from one program to another.\u003c/p\u003e\u003ch2 id=\"services\"\u003eServices\u003c/h2\u003e\u003cp\u003eWhile it\u0026#39;s easy to pass a URL string from one computer to another, we can’t pass\u003cbr/\u003ethe \u003ccode\u003eInputStream\u003c/code\u003e that reads the response body.\u003c/p\u003e\u003cp\u003eSymmetrically, we can send a timestamp from one computer to another, but we\u003cbr/\u003ecan’t send the \u003ccode\u003eClock\u003c/code\u003e that produced it. That\u0026#39;s because it\u0026#39;s a software\u003cbr/\u003eabstraction over a specific quartz crystal that’s bound to the physical world!\u003c/p\u003e\u003ch3 id=\"java-io-file\"\u003ejava.io.File\u003c/h3\u003e\u003cp\u003eJava\u0026#39;s original file class both \u003cem\u003eidentifies\u003c/em\u003e a location on the file system and\u003cbr/\u003ealso \u003cem\u003eoperates\u003c/em\u003e on that location.\u003c/p\u003e\u003cp\u003eI might write an Android app that sends its collection of cached images to the\u003cbr/\u003eserver as a \u003ccode\u003eList\u0026lt;File\u0026gt;\u003c/code\u003e. My server could call \u003ccode\u003eFile.delete()\u003c/code\u003e to free up space\u003cbr/\u003eon that Android device, but that\u0026#39;s not what would happen!\u003c/p\u003e\u003cp\u003eSubclassing \u003ccode\u003eFile\u003c/code\u003e is another thing you could do, but shouldn’t:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass ImmortalFile(delegate: File) : File(delegate.path) {\n  override fun delete() = false\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you want to write testable code that operates on files, consider\u003cbr/\u003e\u003ca href=\"https://square.github.io/okio/\"\u003eOkio\u003c/a\u003e!\u003c/p\u003e\u003ch3 id=\"java-nio-path\"\u003ejava.nio.Path\u003c/h3\u003e\u003cp\u003eThe new (2011) file system APIs are on the right track, but you have to be\u003cbr/\u003ecareful to use it in a testable way. Each \u003ccode\u003ePath\u003c/code\u003e has both a path string (the\u003cbr/\u003eidentifier) and a file system (the service).\u003c/p\u003e\u003cp\u003eThis code is implicitly coupled to the default file system:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass HelloReader() {\n  fun readHello(): String {\n    val helloPath = Paths.get(\u0026#34;hello.txt\u0026#34;)\n    return Files.readString(helloPath)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBy changing every call to \u003ccode\u003ePaths.get(...)\u003c/code\u003e with \u003ccode\u003eFileSystem.getPath(...)\u003c/code\u003e, I can\u003cbr/\u003emake this testable (such as with [Jimfs]):\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass HelloReader(\n  val fileSystem: FileSystem,\n) {\n  fun readHello(): String {\n    val helloPath = fileSystem.getPath(\u0026#34;hello.txt\u0026#34;)\n    return Files.readString(helloPath)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"java-net-inetsocketaddress\"\u003ejava.net.InetSocketAddress\u003c/h3\u003e\u003cp\u003eI get myself into trouble whenever I use Java\u0026#39;s Internet address API:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Wrong! This eagerly looks an IP address for publicobject.com.\nval connectAddress = InetSocketAddress(\u0026#34;publicobject.com\u0026#34;, 443)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe method to use is \u003ccode\u003ecreateUnresolved()\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eval connectAddress = InetSocketAddress.createUnresolved(\u0026#34;publicobject.com\u0026#34;, 443)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEven though I used the same host and port to create these two instances, they\u003cbr/\u003edon\u0026#39;t \u003ccode\u003e.equals()\u003c/code\u003e each other. Unless I’m offline, in which case they do.\u003c/p\u003e\u003ch3 id=\"kotlinx-datetime-timezone\"\u003ekotlinx.datetime.TimeZone\u003c/h3\u003e\u003cp\u003eI need to build a report that summarizes the emails that our service sends each\u003cbr/\u003eday. The input is a set of \u003ccode\u003eSentEmail\u003c/code\u003e records:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edata class SentEmail(\n  val customerId: Id,\n  val timeZone: TimeZone,\n  val locale: Locale,\n  val emailAddressId: Id,\n  val templateId: TemplateId,\n  val enqueuedAt: Instant,\n  val deliveredAt: Instant,\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eTimeZone\u003c/code\u003e class looks like an innocuous way to track a string like\u003cbr/\u003e\u0026#34;America/New_York\u0026#34; in a type-safe way.\u003c/p\u003e\u003cp\u003eUnfortunately, Kotlin’s time zone class throws when it\u0026#39;s given a time zone that\u003cbr/\u003eisn\u0026#39;t in its host \u003ca href=\"https://www.oracle.com/java/technologies/tzdata-versions.html\"\u003eJVM\u0026#39;s time zone database\u003c/a\u003e. My report will crash if\u003cbr/\u003eany customer uses \u003ccode\u003eEurope/Kyiv\u003c/code\u003e (renamed from \u003ccode\u003eEurope/Kiev\u003c/code\u003e in 2022).\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ejava.time.zone.ZoneRulesException: Unknown time-zone ID: Europe/Kyiv\n  at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java)\n  at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java)\n  at java.time.ZoneRegion.ofId(ZoneRegion.java)\n  at java.time.ZoneId.of(ZoneId.java)\n  at kotlinx.datetime.TimeZone$Companion.of(TimeZoneJvm.kt)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI can fix this crash by updating my JVM to one with more up-to-date time zone\u003cbr/\u003edata. Even when I only need an identifier, \u003ccode\u003eTimeZone\u003c/code\u003e always loads the offset\u003cbr/\u003erules.\u003c/p\u003e\u003ch2 id=\"advice\"\u003eAdvice\u003c/h2\u003e\u003cp\u003eWhen using an identifier type like \u003ccode\u003eFile\u003c/code\u003e, \u003ccode\u003eInetSocketAddress\u003c/code\u003e, or \u003ccode\u003eTimeZone\u003c/code\u003e,\u003cbr/\u003epay careful attention to what side effects your identifier is triggering.\u003c/p\u003e\u003cp\u003eWhen writing your own identifier code, please use a data class for the value\u003cbr/\u003epart and a separate interface for its related services.\u003c/p\u003e\n\t\t\t\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-07-09T22:28:14Z",
  "modifiedTime": "2024-07-09T22:28:14Z"
}
