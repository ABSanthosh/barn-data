{
  "id": "07eb5b97-92d3-4db5-8e46-18cbd1c17d7a",
  "title": "Kotlin Sealed Interfaces with KotlinX Serialization JSON",
  "link": "https://handstandsam.com/2023/01/23/kotlin-sealed-interfaces-with-kotlinx-serialization-json/",
  "description": "I heavily use sealed interfaces to model result objects in Kotlin as they allow me to create a type of classes that can be handled using exhaustive when statements, similar to an enum, but also each type can contain its own properties. I wanted to serialize these sealed interface Kotlin models to/from JSON over HTTP. […]",
  "author": "Sam Edwards",
  "published": "Tue, 24 Jan 2023 02:51:19 +0000",
  "source": "https://handstandsam.com/feed/",
  "categories": [
    "Android",
    "Kotlin",
    "Kotlin Multiplatform",
    "Networking"
  ],
  "byline": "Sam Edwards Published January 23, 2023",
  "length": 4530,
  "excerpt": "I heavily use sealed interfaces to model result objects in Kotlin as they allow me to create a type of classes that can be handled using exhaustive when statements, similar to an enum, but also each type can contain its own properties.",
  "siteName": "",
  "favicon": "",
  "text": "I heavily use sealed interfaces to model result objects in Kotlin as they allow me to create a type of classes that can be handled using exhaustive when statements, similar to an enum, but also each type can contain its own properties. I wanted to serialize these sealed interface Kotlin models to/from JSON over HTTP. There are a bunch of options for serializing JSON in Java like Moshi, Gson and Jackson. While all of those libraries are great, I had a requirement of creating a multi-platform library, and went with KotlinX Serialization. In this post I’ll walk you through an example of how I configured KotlinX Serialization to work for my use case. Example: Marketing Campaigns API Result This endpoint returns a strongly typed campaign, and I wanted to represent this in JSON. public sealed interface CampaignContent { public data class PopupModal( public val imageUrl: String, public val text: String, public val subtext: String, ) : CampaignContent public data class Link( public val linkText: String, public val url: String, public val linkIcon: String? = null, ) : CampaignContent } { \"type\": \"popup_modal\", \"image_url\": \"https://...\", \"text\": \"Text\", \"subtext\": \"Subtext\" } { \"type\": \"link\", \"link_icon\": \"https://...\", \"url\": \"https://...\" } We need to deserialize a JSON response into a strongly typed object that implements the CampaignContent sealed interface. fun getCampaignContentFromServer() : CampaignContent KotlinX Serialization has Polymorphism support allows us to do this. You need to register polymorphic definitions in a SerializersModule that you provide to your Json object that is used to encode and decode objects to/from JSON. val jsonSerializer = Json { serializersModule = SerializersModule { polymorphic( CampaignContent::class, CampaignContent.PopupModal::class, CampaignContent.PopupModal.serializer(), ) polymorphic( CampaignContent::class, CampaignContent.Link::class, CampaignContent.Link.serializer(), ) } } val campaignContent : CampaignContent = jsonSerializer.decodeFromString( CampaignContent.serializer(), jsonString, ) In order to support polymorphism, a type property is used in the JSON string representation {\"type\": \"...\"}. By default this \"type\" field is a fully qualified classname. This allows KotlinX Serialization know what type to deserialize. You have control over what the name of this classDiscriminator field is, as well as other configuration options when configuring your Json {} serializer. If you don’t want to use the fully qualified class name as the class type, then you can put a @SerializedName(\"...\") annotation to the class and it will use that name instead of the fully qualified class name. This is helpful for me as the backend did not use fully qualified names, and I had set them explicitly. In the example below I added the @SerializedName(\"popup_modal\") data class. Final Models after adding @Serializable and @SerializedName public sealed interface CampaignContent { @Serializable @SerializedName(\"popup_model\") public data class PopupModal( @SerializedName(\"image_url\") public val imageUrl: String, @SerializedName(\"text\") public val text: String, @SerializedName(\"subtext\") public val subtext: String, ) : CampaignContent @Serializable @SerializedName(\"link\") public data class Link( @SerializedName(\"link_text\") public val linkText: String, @SerializedName(\"url\") public val url: String, @SerializedName(\"link_icon\") public val linkIcon: String? = null, ) : CampaignContent } Considerations At first I made my models match the JSON values as I didn’t have to specify @SerializedName since KotlinX Serialization will just match the field name. After a bit of usage, link.link_text just didn’t feel as correct as link.linkText, so I chose to specify a @SerializedName annotation instead. The resulting Java bytecode is the same as the KotlinX Serialization plugin does code generation that writes out the serializer anyways. This does make your data class look not as pretty, but from the general building and usage perspective of these models, the user will not know. Conclusion That was a whirlwind intro, but I had to really dig through deep into the documentation to figure it out and am hoping this helps someone do this faster than I did it originally.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n\t\t\u003cmain id=\"content\" role=\"main\"\u003e\n\n\t\t\t\n\t\t\t\t\n\u003carticle id=\"post-1935\" itemscope=\"itemscope\" itemtype=\"http://schema.org/BlogPosting\" itemprop=\"blogPost\"\u003e\n\t\t\n\t\n\t\u003cdiv itemprop=\"mainContentOfPage\"\u003e\n\t\t\n\u003cp\u003eI heavily use \u003ca href=\"https://jorgecastillo.dev/sealed-interfaces-kotlin\"\u003esealed interfaces\u003c/a\u003e to model result objects in Kotlin as they allow me to create a type of classes that can be handled using exhaustive \u003ccode\u003ewhen\u003c/code\u003e statements, similar to an \u003ccode\u003eenum\u003c/code\u003e, but also each type can contain its own properties.\u003c/p\u003e\n\n\n\n\u003cp\u003eI wanted to serialize these sealed interface Kotlin models to/from JSON over HTTP.  There are a bunch of options for serializing JSON in Java like \u003ca href=\"https://github.com/square/moshi\"\u003eMoshi\u003c/a\u003e, \u003ca href=\"https://github.com/google/gson\"\u003eGson\u003c/a\u003e and \u003ca href=\"https://github.com/FasterXML/jackson\"\u003eJackson\u003c/a\u003e.  While all of those libraries are great, I had a requirement of creating a multi-platform library, and went with \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization\"\u003eKotlinX Serialization\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this post I’ll walk you through an example of how I configured KotlinX Serialization to work for my use case.\u003c/p\u003e\n\n\n\n\u003ch3\u003eExample: Marketing Campaigns API Result \u003c/h3\u003e\n\n\n\n\u003cp\u003eThis endpoint returns a strongly typed campaign, and I wanted to represent this in JSON.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epublic sealed interface CampaignContent {\n    public data class PopupModal(\n        public val imageUrl: String,\n        public val text: String,\n        public val subtext: String,\n    ) : CampaignContent\n\n    public data class Link(\n        public val linkText: String,\n        public val url: String,\n        public val linkIcon: String? = null,\n    ) : CampaignContent\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre title=\"PopupModal Model JSON Example\"\u003e\u003ccode lang=\"json\"\u003e{\n  \u0026#34;type\u0026#34;: \u0026#34;popup_modal\u0026#34;,\n  \u0026#34;image_url\u0026#34;: \u0026#34;https://...\u0026#34;,\n  \u0026#34;text\u0026#34;: \u0026#34;Text\u0026#34;,\n  \u0026#34;subtext\u0026#34;: \u0026#34;Subtext\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre title=\"Link Model JSON Example\"\u003e\u003ccode lang=\"json\"\u003e{\n  \u0026#34;type\u0026#34;: \u0026#34;link\u0026#34;,\n  \u0026#34;link_icon\u0026#34;: \u0026#34;https://...\u0026#34;,\n  \u0026#34;url\u0026#34;: \u0026#34;https://...\u0026#34;\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe need to deserialize a JSON response into a strongly typed object that implements the \u003ccode\u003eCampaignContent\u003c/code\u003e sealed interface.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003efun getCampaignContentFromServer() : CampaignContent\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/polymorphism.md#sealed-classes\"\u003eKotlinX Serialization has Polymorphism support\u003c/a\u003e allows us to do this.  You need to register polymorphic definitions in a \u003ccode\u003e\u003ca href=\"https://kotlinlang.org/api/kotlinx.serialization/kotlinx-serialization-core/kotlinx.serialization.modules/-serializers-module/\"\u003eSerializersModule\u003c/a\u003e\u003c/code\u003e that you provide to your \u003ccode\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/json/commonMain/src/kotlinx/serialization/json/Json.kt\"\u003eJson\u003c/a\u003e\u003c/code\u003e object that is used to encode and decode objects to/from JSON.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eval jsonSerializer = Json {\n  serializersModule = SerializersModule {\n    polymorphic(\n      CampaignContent::class,\n      CampaignContent.PopupModal::class,\n      CampaignContent.PopupModal.serializer(),\n    )\n    polymorphic(\n      CampaignContent::class,\n      CampaignContent.Link::class,\n      CampaignContent.Link.serializer(),\n    )\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003eval campaignContent : CampaignContent = jsonSerializer.decodeFromString(\n  CampaignContent.serializer(), \n  jsonString,\n)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn order to support polymorphism, a \u003ccode\u003etype\u003c/code\u003e property is used in the JSON string representation \u003ccode\u003e{\u0026#34;type\u0026#34;: \u0026#34;...\u0026#34;}\u003c/code\u003e.  By default this \u003ccode\u003e\u0026#34;type\u0026#34;\u003c/code\u003e field is a fully qualified classname.  This allows KotlinX Serialization know what type to deserialize.  You have control over what the name of this \u003ccode\u003eclassDiscriminator\u003c/code\u003e field is, as well as other \u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/json/commonMain/src/kotlinx/serialization/json/JsonConfiguration.kt\"\u003econfiguration options when configuring your \u003ccode\u003eJson {}\u003c/code\u003e serializer\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you don’t want to use the fully qualified class name as the class type, then you can put a \u003ccode\u003e@SerializedName(\u0026#34;...\u0026#34;)\u003c/code\u003e annotation to the class and it will use that name instead of the fully qualified class name.  This is helpful for me as the backend did not use fully qualified names, and I had set them explicitly.  In the example below I added the \u003ccode\u003e@SerializedName(\u0026#34;popup_modal\u0026#34;)\u003c/code\u003e data class.\u003c/p\u003e\n\n\n\n\u003ch4\u003eFinal Models after adding @Serializable and @SerializedName\u003c/h4\u003e\n\n\n\n\u003cpre\u003e\u003ccode lang=\"kotlin\"\u003epublic sealed interface CampaignContent {\n\n  @Serializable\n  @SerializedName(\u0026#34;popup_model\u0026#34;)\n  public data class PopupModal(\n    @SerializedName(\u0026#34;image_url\u0026#34;)\n    public val imageUrl: String,\n    @SerializedName(\u0026#34;text\u0026#34;)\n    public val text: String,\n    @SerializedName(\u0026#34;subtext\u0026#34;)\n    public val subtext: String,\n  ) : CampaignContent\n\n  @Serializable\n  @SerializedName(\u0026#34;link\u0026#34;)\n  public data class Link(\n      @SerializedName(\u0026#34;link_text\u0026#34;)\n      public val linkText: String,\n      @SerializedName(\u0026#34;url\u0026#34;)\n      public val url: String,\n      @SerializedName(\u0026#34;link_icon\u0026#34;)\n      public val linkIcon: String? = null,\n  ) : CampaignContent\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch4\u003eConsiderations\u003c/h4\u003e\n\n\n\n\u003cp\u003eAt first I made my models match the JSON values as I didn’t have to specify \u003ccode\u003e@SerializedName\u003c/code\u003e since KotlinX Serialization will just match the field name.  After a bit of usage, \u003ccode\u003elink.link_text\u003c/code\u003e just didn’t feel as correct as \u003ccode\u003elink.linkText\u003c/code\u003e, so I chose to specify a \u003ccode\u003e@SerializedName\u003c/code\u003e annotation instead.  The resulting Java bytecode is the same as the KotlinX Serialization plugin does code generation that writes out the serializer anyways.  This does make your \u003ccode\u003edata class\u003c/code\u003e look not as pretty, but from the general building and usage perspective of these models, the user will not know.\u003c/p\u003e\n\n\n\n\u003ch3\u003eConclusion\u003c/h3\u003e\n\n\n\n\u003cp\u003eThat was a whirlwind intro, but I had to really dig through deep into the documentation to figure it out and am hoping this helps someone do this faster than I did it originally.\u003c/p\u003e\n\n\t\t\n\t\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\n\t\t\n\t\n\t\n\n\u003c/article\u003e\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\n\t\t\u003c/main\u003e\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
