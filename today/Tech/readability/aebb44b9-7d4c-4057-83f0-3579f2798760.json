{
  "id": "aebb44b9-7d4c-4057-83f0-3579f2798760",
  "title": "New speculative attacks on Apple CPUs",
  "link": "https://predictors.fail/",
  "description": "Comments",
  "author": "",
  "published": "Tue, 28 Jan 2025 18:31:34 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 14276,
  "excerpt": "The SLAP and FLOP Address and Value Prediction Attacks",
  "siteName": "",
  "favicon": "",
  "text": "Demos Leaking Proton Mail's Inbox Data We train the M3 CPU's LVP via sandboxed JavaScript code running inside WebKit (Safari's browsing engine). When the mouse cursor is over our demo webpage, our proof-of-concept opens Proton Mail's inbox in a new window, but uses the same process to render the inbox. This brings the inbox content into the address space, making it accessible with a sandbox escape. Finally, we use the LVP to craft an arbitrary read primitive to anywhere in this address space, recovering the sender and subject lines shown on the inbox page. Reading The Great Gatsby Using Load Address Prediction We demonstrate an LAP proof-of-concept on the Apple M2 CPU that recovers a secret string. The string holds the first paragraph of The Great Gatsby, but is never architecturally accessed. At the LAP's incorrectly guessed memory address, we place a pointer to the characters of the string. Subsequently, we train and activate the LAP. Reading Harry Potter Using Load Value Prediction On the Apple M3 CPU, we demonstrate an LVP proof-of-concept that recovers the first paragraph of Harry Potter and the Sorcerer's Stone, which is also never architecturally read by the CPU core. We cause the LVP to predict and access an incorrect array index. There, we place the pointer to the string's characters, which the CPU then dereferences. The People Behind SLAP and FLOP Jason Kim Georgia Institute of Technology Jalen Chuang Georgia Institute of Technology Daniel Genkin Georgia Institute of Technology Yuval Yarom Ruhr University Bochum Frequently Asked Questions SLAP and FLOP Basics The affected Apple devices are the following: All Mac laptops from 2022-present (MacBook Air, MacBook Pro) All Mac desktops from 2023-present (Mac Mini, iMac, Mac Studio, Mac Pro) All iPad Pro, Air, and Mini models from September 2021-present (Pro 6th and 7th gen., Air 6th gen., Mini 6th gen.) All iPhones from September 2021-present (All 13, 14, 15, and 16 models, SE 3rd gen.) There are hardware and software measures to ensure that two open webpages are isolated from each other, preventing one of them form (maliciously) reading the other's contents. SLAP and FLOP break these protections, allowing attacker pages to read sensitive login-protected data from target webpages. In our work, we show that this data ranges from location history to credit card information. While FLOP has an actionable mitigation, implementing it requires patches from software vendors and cannot be done by users. Apple has communicated to us that they plan to address these issues in an upcoming security update, hence it is important to enable automatic updates and ensure that your devices are running the latest operating system and applications. We have not yet observed load address prediction or load value prediction in other processor vendors' products, such as Intel, AMD, Qualcomm, or Ampere. We do not know, as we have not tested other browsers such as Firefox. Since SLAP and FLOP are microarchitecture-based attacks, they do not leave any traces in the system's log files. While cached copies of previously visited websites may be present in the web browser, it is difficult to automatically detect malicious code patterns that exploit hardware vulnerabilities. So far, we do not have any evidence that either SLAP or FLOP has been used in the wild. We disclosed SLAP to Apple on May 24, 2024, and FLOP on September 3, 2024. Technical Questions Most computer bugs arise from mistakes in programming, such as missing bounds checks or use-after-frees. However, a side-channel attack exploits the implementation of a computer's hardware to attack it, even if the software it runs is a secure algorithm. Systems can leak sensitive data through sound, electromagnetic radiation, or thermal throttling, just for a few examples. Many side channels, including ones we use for SLAP and FLOP, comes from the CPU's microarchitecture. Whenever an attacker and target run on the physical CPU, they share the CPU's internal resources such as cores, caches, and internal buffers. Sharing resources leads to contention, and contention can be measured indirectly through several variables like timing or power consumption. These measurements leave fingerprints on the target's behavior on the CPU. Accordingly, an attacker can abuse this to make inferences about the target's secrets even if they are isolated at the process level or the hypervisor level. Virtually all modern CPUs use a performance optimization where they predict the control flow the CPU should take (such as branches and returns), should the outcome not be readily available. Once a prediction is made, the CPU will execute instructions along the prediction, a process called speculative execution. If the CPU realizes it had mispredicted, it must revert all changes in the state it performed after the prediction. Nearly all desktop and mobile CPUs exhibit this behavior, regardless of manufacturer (such as Apple, AMD, or Intel). Spectre is a hardware vulnerability in virtually all modern CPUs that occurs when speculative execution backfires. While the CPU should ideally revert all changes in state, speculative execution leaves traces in the CPU's microarchitectural state and especially the cache. A Spectre attack coerces the CPU into speculatively executing the wrong flow of instructions. If this wrong flow has instructions depending on sensitive data, their value can be inferred through a side channel even after the CPU realizes the mistake and reverts its changes. An adversary can abuse this behavior to read data that they cannot normally access through program semantics. Because speculative execution is an important part of CPU performance that is infeasible to simply remove as a countermeasure, Spectre continues to be dangerous to software even years after its discovery. In SLAP and FLOP, we demonstrate that recent Apple CPUs go beyond this, not only predicting the control flow the CPU should take, but also the data flow the CPU should operate on if data are not readily available from the memory subsystem. Unlike Spectre, mispredictions on data flow do not directly result in the CPU speculatively executing the wrong instructions. Instead, they result in the CPU executing arbitrary instructions on the wrong data. However, we show this can be combined with indirection techniques to execute wrong instructions. To orchestrate SLAP, we begin by reverse engineering Apple's implementation of Load Address Prediction (LAP). We discover that if we train the LAP on striding memory addresses, the LAP will access address the next sequence in the striding pattern and compute using the data in that address, even if the program never actually accesses it. Here, we note that this is different from hardware prefetching. While prefetchers may bring the data inside the predicted addresses, they do not speculatively execute downstream instructions based on the prediction. Next, we find an attack surface in Safari. Previously, iLeakage demonstrated a corner case in Safari's isolation scheme where an adversary's webpage can coerce an arbitrary target webpage to be handled by the same process. We find that when this occurs, the two webpages also share internal memory allocation regions for data, such as strings. In turn, this allows the adversary to jump the LAP to the target webpage's string and trick the CPU into operating on it, eventually leaking the string's content over a covert channel. Similarly to SLAP, we reverse engineer the Load Value Prediction (LVP) mechanism in Apple CPUs. We found that if the LVP sees the same data value being repeatedly returned from the memory subsystem for the same load instruction, the LVP will attempt to guess the load's outcome the next time that load instruction executes, even if the memory accessed by the load now contains a completely different value! Therefore, using the LVP, we can trick the CPU into computing on incorrect data values. We first demonstrate the dangers stemming from LVP in Safari, whose JavaScript engine first vets the type information of JavaScript data structures before determining the appropriate computations to run on them. If we train the LVP on the load instruction that retrieves this type information, we can cause code that is only supposed to run for one data structure on another data structure, causing speculative type confusion, and obtaining a read primitive to arbitrary 64-bit addresses. Next, we move to Chrome, where internal table data structures for calling WebAssembly functions also vet the signature of each function before calling them with arguments. Here, we show that the LVP allows us to run a function with the wrong arguments (e.g., pointer instead of integer), again resulting in a type confusion based primitive for reading arbitrary memory addresses. SLAP exploits a phenomenon in Safari where strings that belong to different webpages can be allocated within a close distance to each other, and thus discloses cross-origin strings that are allocated in proximity to the adversary's own strings. On the other hand, FLOP is a speculative type confusion attack that causes the CPU to bypass integrity checks on data structures, resulting in memory read primitives from arbitrary addresses in Safari and Chrome. Furthermore, the underlying CPU microarchitecture that SLAP and FLOP exploit are also different. SLAP uses the Load Address Predictor (LAP), while FLOP uses the Load Value Predictor (LVP). As suggested by their names, the LAP predicts addresses while the LVP predicts values. Consider the following statement: \"The CPU accesses memory at address 0xdeadbeef, which contains the value 0x1234.\" The next time the CPU performs a memory access, the LAP predicts the next address, i.e., what 0xdeadbeef will change to. Meanwhile, the LVP predicts the next value returned from memory, that is, what 0x1234 will change to. Going deeper in detail, we observe their internal structures are also different. For instance, the LAP requires a longer training sequence than the LVP to activate reliably, but only the LAP can observe strides and generate predictions accordingly. JavaScript and WebAssembly are two programming languages that make up the backbone of interactive webpages, such as online games and video streaming services. JavaScript can update the content of the website directly, while WebAssembly is used for high-performance web applications. Ultimately, WebAssembly interfaces with JavaScript to deliver dynamic content to users. Since both are sandboxed in a browser environment, side-channel attacks are notably more difficult to implement in these languages. However, the impact is drastically greater, as browsers execute both types of code automatically and do not require the user to download the malicious program. For leaking secrets, both SLAP and FLOP are confined to the address space they are trained in. As pointed out by iLeakage, Safari lacks Site Isolation, a measure used to enforce that two different webpages not from the same domain can never be handled by the same process. Thus, in Safari it is possible for an adversary's webpage to be handled by the same process (and thus address space) with an arbitrary webpage, increasing the attack surface including LAP- and LVP-based exploits. On the other hand, although Chrome is equipped with Site Isolation, we demonstrate that it is not a perfect mitigation. We show the real-world existence of corner cases, where two subdomains of the same site can be merged into one process, again leading to LAP- and LVP-based attacks. Miscellaneous Yes, with rights waived via CC0. You can right-click each logo, which should list an option to save the image as a file. SLAP and FLOP in the News Acknowledgments This research was supported by the Air Force Office of Scientific Research (AFOSR) under award number FA9550-24-1-0079; the Alfred P Sloan Research Fellowship; an ARC Discovery Project number DP210102670; the Defense Advanced Research Projects Agency (DARPA) under contract numbers W912CG-23-C-0022, the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy - EXC 2092 CASA - 390781972; and gifts from Qualcomm, Cisco (SLAP), and Zama (FLOP). The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the U.S. Government.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\u003csection id=\"demos\"\u003e\n\t\t\t\t\t\u003ch4\u003eDemos\u003c/h4\u003e\n\n\t\t\t\t\t\u003ch5\u003eLeaking Proton Mail\u0026#39;s Inbox Data\u003c/h5\u003e\n\t\t\t\t\t\u003cp\u003eWe train the M3 CPU\u0026#39;s LVP via sandboxed JavaScript code running inside WebKit (Safari\u0026#39;s browsing engine). When the mouse cursor is over our demo webpage, our proof-of-concept opens Proton Mail\u0026#39;s inbox in a new window, but uses the same process to render the inbox. This brings the inbox content into the address space, making it accessible with a sandbox escape. Finally, we use the LVP to craft an arbitrary read primitive to anywhere in this address space, recovering the sender and subject lines shown on the inbox page.\u003c/p\u003e\n\t\t\t\t\t\n\n\t\t\t\t\t\u003ch5\u003eReading The Great Gatsby Using Load Address Prediction\u003c/h5\u003e\n\t\t\t\t\t\u003cp\u003eWe demonstrate an LAP proof-of-concept on the Apple M2 CPU that recovers a secret string. The string holds the first paragraph of The Great Gatsby, but is never architecturally accessed. At the LAP\u0026#39;s incorrectly guessed memory address, we place a pointer to the characters of the string. Subsequently, we train and activate the LAP.\u003c/p\u003e\n\t\t\t\t\t\n\n\t\t\t\t\t\u003ch5\u003eReading Harry Potter Using Load Value Prediction\u003c/h5\u003e\n\t\t\t\t\t\u003cp\u003eOn the Apple M3 CPU, we demonstrate an LVP proof-of-concept that recovers the first paragraph of Harry Potter and the Sorcerer\u0026#39;s Stone, which is also never architecturally read by the CPU core. We cause the LVP to predict and access an incorrect array index. There, we place the pointer to the string\u0026#39;s characters, which the CPU then dereferences.\n\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\n\t\t\t\t\u003c/section\u003e\n\n\t\t\t\t\u003csection id=\"people\"\u003e\n\t\t\t\t\t\u003ch4\u003eThe People Behind\n\t\t\t\t\t\t\u003cspan\u003eSLAP and FLOP\u003c/span\u003e\n\t\t\t\t\t\u003c/h4\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\t\t\u003cli\u003e\u003ca href=\"https://jas0n.kim/\"\u003eJason Kim \u003c/a\u003e\u003cspan\u003e\u003ca href=\"https://www.gatech.edu/\"\u003eGeorgia Institute of\n\t\t\t\t\t\t\t\t\t\t\t\tTechnology\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\u003cli\u003e\u003ca href=\"https://sites.cc.gatech.edu/grads/j/jchuang9/\"\u003eJalen Chuang\u003c/a\u003e \u003cspan\u003e\u003ca href=\"https://www.gatech.edu/\"\u003eGeorgia\n\t\t\t\t\t\t\t\t\t\t\t\tInstitute of\n\t\t\t\t\t\t\t\t\t\t\t\tTechnology\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\u003cli\u003e\u003ca href=\"https://faculty.cc.gatech.edu/~genkin/\"\u003eDaniel Genkin\u003c/a\u003e \u003cspan\u003e\u003ca href=\"https://www.gatech.edu/\"\u003eGeorgia Institute of\n\t\t\t\t\t\t\t\t\t\t\t\tTechnology\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\u003cli\u003e\u003ca href=\"https://yuval.yarom.org/\"\u003eYuval Yarom\u003c/a\u003e \u003cspan\u003e\u003ca href=\"https://www.ruhr-uni-bochum.de/\"\u003eRuhr University\n\t\t\t\t\t\t\t\t\t\t\t\tBochum\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\n\t\t\t\t\t\t\t\t\u003c/ul\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\u003c/section\u003e\n\n\t\t\t\t\u003csection id=\"qa\"\u003e\n\t\t\t\t\t\u003ch4\u003eFrequently Asked \u003cspan\u003eQuestions\u003c/span\u003e\u003c/h4\u003e\n\n\t\t\t\t\t\u003ch5\u003eSLAP and FLOP Basics\u003c/h5\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-1\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eThe affected Apple devices are the following:\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\t\t\t\u003cli\u003eAll Mac laptops from 2022-present (MacBook Air, MacBook Pro)\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\t\u003cli\u003eAll Mac desktops from 2023-present (Mac Mini, iMac, Mac Studio, Mac Pro) \u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\t\u003cli\u003eAll iPad Pro, Air, and Mini models from September 2021-present (Pro 6th and 7th gen., Air 6th gen., Mini 6th gen.)\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\t\u003cli\u003eAll iPhones from September 2021-present (All 13, 14, 15, and 16 models, SE 3rd gen.)\u003c/li\u003e\n\t\t\t\t\t\t\t\t\t\u003c/ul\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-2\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eThere are hardware and software measures to ensure that two open webpages are isolated from each other, \n\t\t\t\t\t\t\t\t\t   preventing one of them form (maliciously) reading the other\u0026#39;s contents. SLAP and FLOP break these protections, \n\t\t\t\t\t\t\t\t\t   allowing attacker pages to read sensitive login-protected data from target webpages. In our work, we show\n\t\t\t\t\t\t\t\t\t\tthat this data ranges from location history to credit card information.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-3\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003e While FLOP has an actionable mitigation, implementing it requires patches from software vendors and cannot be done by users. \n\t\t\t\t\t\t\t\t\tApple has communicated to us that they plan to address these issues in an\n\t\t\t\t\t\t\t\t\t\tupcoming security update, hence it is important to enable automatic updates and\n\t\t\t\t\t\t\t\t\t\tensure that your devices are running the latest operating system and applications.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-4\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eWe have not yet observed load address prediction or load value prediction \n\t\t\t\t\t\t\t\t\t   in other processor vendors\u0026#39; products, such as Intel, AMD, Qualcomm, or Ampere.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-5\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003e We do not know, as we have not tested other browsers such as Firefox. \u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-6\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eSince SLAP and FLOP are microarchitecture-based attacks, they do not leave any traces in\n\t\t\t\t\t\t\t\t\t\tthe system\u0026#39;s log files. While cached copies of previously visited websites may\n\t\t\t\t\t\t\t\t\t\tbe present in the web browser, it is difficult to automatically detect malicious\n\t\t\t\t\t\t\t\t\t\tcode patterns that exploit hardware vulnerabilities.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-7\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eSo far, we do not have any evidence that either SLAP or FLOP has been used in the\n\t\t\t\t\t\t\t\t\t\twild.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"basics-question-8\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eWe disclosed SLAP to Apple on May 24, 2024, and FLOP on September 3, 2024.\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003ch5\u003eTechnical Questions\u003c/h5\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-1\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\tMost computer bugs arise from mistakes in programming, such as missing bounds\n\t\t\t\t\t\t\t\t\t\tchecks \tor use-after-frees. However, a side-channel attack exploits the implementation\n\t\t\t\t\t\t\t\t\t\tof a computer\u0026#39;s hardware to attack it, even if the software it runs is a secure algorithm.\n\t\t\t\t\t\t\t\t\t\tSystems can leak sensitive data through sound, electromagnetic radiation, or\n\t\t\t\t\t\t\t\t\t\tthermal throttling, just for a few examples.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\tMany side channels, including ones we use for SLAP and FLOP, comes from the\n\t\t\t\t\t\t\t\t\t\tCPU\u0026#39;s microarchitecture. Whenever an attacker and target run on the physical CPU, they share the CPU\u0026#39;s\n\t\t\t\t\t\t\t\t\t\tinternal resources such as cores, caches, and internal buffers.\n\t\t\t\t\t\t\t\t\t\tSharing resources leads to contention, and contention can be measured indirectly\n\t\t\t\t\t\t\t\t\t\tthrough several variables like timing or power consumption.\n\t\t\t\t\t\t\t\t\t\tThese measurements leave fingerprints on the target\u0026#39;s behavior on the CPU.\n\t\t\t\t\t\t\t\t\t\tAccordingly, an attacker can abuse this to make inferences about the target\u0026#39;s\n\t\t\t\t\t\t\t\t\t\tsecrets even if they are isolated at the process level or the hypervisor level.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-2\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\tVirtually all modern CPUs use a performance optimization where they predict the\n\t\t\t\t\t\t\t\t\t\tcontrol flow the CPU should take (such as branches and returns), should the\n\t\t\t\t\t\t\t\t\t\toutcome not be readily available. Once a prediction is made, the CPU will execute instructions along\n\t\t\t\t\t\t\t\t\t\tthe prediction, a process called speculative execution. If the CPU realizes it had\n\t\t\t\t\t\t\t\t\t\tmispredicted, it must revert all changes in the state it performed after the\n\t\t\t\t\t\t\t\t\t\tprediction. Nearly all desktop and mobile CPUs exhibit this behavior, regardless of\n\t\t\t\t\t\t\t\t\t\tmanufacturer (such as Apple, AMD, or Intel).\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\t\u003ca href=\"https://spectreattack.com/\"\u003eSpectre\u003c/a\u003e is a hardware vulnerability in\n\t\t\t\t\t\t\t\t\t\tvirtually all modern CPUs that occurs when speculative execution backfires.\n\t\t\t\t\t\t\t\t\t\tWhile the CPU should ideally revert all changes in state, speculative execution leaves\n\t\t\t\t\t\t\t\t\t\ttraces in the CPU\u0026#39;s microarchitectural state and especially the cache. A Spectre\n\t\t\t\t\t\t\t\t\t\tattack coerces the CPU into speculatively executing the wrong flow of\n\t\t\t\t\t\t\t\t\t\tinstructions. If this wrong flow has instructions depending on sensitive data, their value can\n\t\t\t\t\t\t\t\t\t\tbe inferred through a side channel even after the CPU realizes the mistake and\n\t\t\t\t\t\t\t\t\t\treverts its changes. An adversary can abuse this behavior to read data that they cannot\n\t\t\t\t\t\t\t\t\t\tnormally access through program semantics. Because speculative execution is an\n\t\t\t\t\t\t\t\t\t\timportant part of CPU performance that is infeasible to simply remove as a\n\t\t\t\t\t\t\t\t\t\tcountermeasure, Spectre continues to be dangerous to software even years after\n\t\t\t\t\t\t\t\t\t\tits discovery.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\tIn SLAP and FLOP, we demonstrate that recent Apple CPUs go beyond this, not only\n\t\t\t\t\t\t\t\t\t\tpredicting the control flow the CPU should take, but also the data flow the CPU\n\t\t\t\t\t\t\t\t\t\tshould operate on if data are not readily available from the memory subsystem.\n\t\t\t\t\t\t\t\t\t\tUnlike Spectre, mispredictions on data flow do not directly result in the CPU\n\t\t\t\t\t\t\t\t\t\tspeculatively executing the wrong instructions. Instead, they result in the CPU\n\t\t\t\t\t\t\t\t\t\texecuting arbitrary instructions on the wrong data. However, we show this can be combined with\n\t\t\t\t\t\t\t\t\t\tindirection techniques to execute wrong instructions.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-3\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eTo orchestrate SLAP, we begin by reverse engineering Apple\u0026#39;s implementation of Load Address Prediction (LAP). \n\t\t\t\t\t\t\t\t\tWe discover that if we train the LAP on striding memory addresses, the LAP will access address the next sequence \n\t\t\t\t\t\t\t\t\tin the striding pattern and compute using the data in that address, even if the program never actually accesses it.\n\t\t\t\t\t\t\t\t\tHere, we note that this is different from hardware prefetching. While prefetchers may bring the data inside the predicted addresses, \n\t\t\t\t\t\t\t\t\tthey do not speculatively execute downstream instructions based on the prediction. \u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eNext, we find an attack surface in Safari. Previously, \u003ca href=\"https://ileakage.com/\"\u003eiLeakage\u003c/a\u003e demonstrated a corner case \n\t\t\t\t\t\t\t\t\tin Safari\u0026#39;s isolation scheme where an adversary\u0026#39;s webpage can coerce an arbitrary target webpage to be handled by the same process. \n\t\t\t\t\t\t\t\t\tWe find that when this occurs, the two webpages also share internal memory allocation regions for data, such as strings. \n\t\t\t\t\t\t\t\t\tIn turn, this allows the adversary to jump the LAP to the target webpage\u0026#39;s string and trick the CPU into operating on it, eventually leaking the string\u0026#39;s content over a covert channel.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-4\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eSimilarly to SLAP, we reverse engineer the Load Value Prediction (LVP) mechanism in Apple CPUs. \n\t\t\t\t\t\t\t\t\tWe found that if the LVP sees the same data value being repeatedly returned from the memory subsystem for the same load instruction, \n\t\t\t\t\t\t\t\t\tthe LVP will attempt to guess the load\u0026#39;s outcome the next time that load instruction executes, even if the memory accessed by the load now contains a completely different value! \n\t\t\t\t\t\t\t\t\tTherefore, using the LVP, we can trick the CPU into computing on incorrect data values.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eWe first demonstrate the dangers stemming from LVP in Safari, whose JavaScript engine first vets the type information of JavaScript data structures before determining the \n\t\t\t\t\t\t\t\t\tappropriate computations to run on them. If we train the LVP on the load instruction that retrieves this type information, we can cause code that is only supposed to run for \n\t\t\t\t\t\t\t\t\tone data structure on another data structure, causing speculative type confusion, and obtaining a read primitive to arbitrary 64-bit addresses. \u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\u003cp\u003e Next, we move to Chrome, where internal table data structures for calling WebAssembly functions also vet the signature of each function before calling them with arguments. \n\t\t\t\t\t\t\t\t\tHere, we show that the LVP allows us to run a function with the wrong arguments (e.g., pointer instead of integer), again resulting in a type confusion based primitive for reading arbitrary memory addresses.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-5\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eSLAP exploits a phenomenon in Safari where strings that belong to different webpages can be allocated within a close distance to each other, and thus discloses cross-origin strings that are allocated in proximity to the adversary\u0026#39;s own strings. On the other hand, FLOP is a speculative type confusion attack that causes the CPU to bypass integrity checks on data structures, resulting in memory read primitives from arbitrary addresses in Safari and Chrome.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\tFurthermore, the underlying CPU microarchitecture that SLAP and FLOP exploit are also different. SLAP uses the Load Address Predictor (LAP), while FLOP uses the Load Value Predictor (LVP).\n\t\t\t\t\t\t\t\t\tAs suggested by their names, the LAP predicts addresses while the LVP predicts values. \n\t\t\t\t\t\t\t\t\tConsider the following statement: \u0026#34;The CPU accesses memory at address 0xdeadbeef, \n\t\t\t\t\t\t\t\t\twhich contains the value 0x1234.\u0026#34; The next time the CPU performs a memory access, the LAP predicts the next address, i.e., what 0xdeadbeef will change to. Meanwhile, the LVP predicts the next value returned from memory, that is, what 0x1234 will change to. \n\t\t\t\t\t\t\t\t\tGoing deeper in detail, we observe their internal structures are also different. For instance, the LAP requires a longer training sequence than the LVP to activate reliably, but only the LAP can observe strides and generate predictions accordingly.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-6\"\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\t\t\t\t\t\tJavaScript and WebAssembly are two programming languages that make up the\n\t\t\t\t\t\t\t\t\t\tbackbone of interactive webpages, such as online games and video streaming\n\t\t\t\t\t\t\t\t\t\tservices. JavaScript can update the content of the website directly, while\n\t\t\t\t\t\t\t\t\t\tWebAssembly is used for high-performance web applications. Ultimately,\n\t\t\t\t\t\t\t\t\t\tWebAssembly interfaces with JavaScript to deliver dynamic content to users.\n\t\t\t\t\t\t\t\t\t\tSince both are sandboxed in a browser environment, side-channel attacks are\n\t\t\t\t\t\t\t\t\t\tnotably more difficult to implement in these languages. However, the impact is\n\t\t\t\t\t\t\t\t\t\tdrastically greater, as browsers execute both types of code automatically and do\n\t\t\t\t\t\t\t\t\t\tnot require the user to download the malicious program.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\n\t\t\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"tech-question-7\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eFor leaking secrets, both SLAP and FLOP are confined to the address space they are trained in. \n\t\t\t\t\t\t\t\t\tAs pointed out by \u003ca href=\"https://ileakage.com/\"\u003eiLeakage\u003c/a\u003e, Safari lacks Site Isolation, a measure used to enforce that two different webpages not from the same domain can never be handled by the same process.\n\t\t\t\t\t\t\t\t\tThus, in Safari it is possible for an adversary\u0026#39;s webpage to be handled by the same process (and thus address space) with an arbitrary webpage, increasing the attack surface including LAP- and LVP-based exploits.\n\t\t\t\t\t\t\t\t\t \u003c/p\u003e\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\u003cp\u003eOn the other hand, although Chrome is equipped with Site Isolation, we demonstrate that it is not a perfect mitigation. We show the real-world existence of corner cases, where two subdomains of the same site can be merged into one process, again leading to LAP- and LVP-based attacks.\u003c/p\u003e\n\t\t\t\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003ch5\u003eMiscellaneous\u003c/h5\u003e\n\t\t\t\t\t\u003cdiv id=\"accordion\" aria-labelledby=\"misc-question-1\"\u003e\n\t\t\t\t\t\t\t\t\t\u003cp\u003eYes, with rights waived via \u003ca href=\"https://creativecommons.org/publicdomain/zero/1.0/\"\u003eCC0\u003c/a\u003e. You can\n\t\t\t\t\t\t\t\t\t\tright-click each logo, which should list an option to save the image as a file.\n\t\t\t\t\t\t\t\t\t\u003c/p\u003e\u003c/div\u003e\n\t\t\t\t\t\n\t\t\t\t\t\n\n\t\t\t\t\u003c/section\u003e\n\t\t\t\t\u003csection id=\"news\"\u003e\n\t\t\t\t\t\u003ch4\u003eSLAP and FLOP in the News\u003c/h4\u003e\n\t\t\t\t\t\n\t\t\t\t\u003c/section\u003e\n\t\t\t\t\u003csection id=\"acknowledgments\"\u003e\n\t\t\t\t\t\u003ch4\u003eAcknowledgments\u003c/h4\u003e\n\t\t\t\t\t\u003cdiv\u003e\u003cp\u003e\n\t\t\t\t\t\t\tThis research was supported by\n\t\t\t\t\t\t\tthe Air Force Office of Scientific Research (AFOSR) under award number FA9550-24-1-0079;\n\t\t\t\t\t\t\tthe Alfred P Sloan Research Fellowship;\n\t\t\t\t\t\t\tan ARC Discovery Project number DP210102670;\n\t\t\t\t\t\t\tthe Defense Advanced Research Projects Agency (DARPA) under contract numbers\n\t\t\t\t\t\t\tW912CG-23-C-0022,\n\t\t\t\t\t\t\tthe Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany\u0026#39;s\n\t\t\t\t\t\t\tExcellence Strategy - EXC 2092 CASA - 390781972;\n\t\t\t\t\t\t\tand gifts from Qualcomm, Cisco (SLAP), and Zama (FLOP).\n\t\t\t\t\t\t\t\u003c/p\u003e\u003cp\u003e\n\t\t\t\t\t\t\tThe views and conclusions contained in this document are those of the authors and should not\n\t\t\t\t\t\t\tbe interpreted as representing the official policies, either expressed or implied, of the\n\t\t\t\t\t\t\tU.S. Government.\n\t\t\t\t\t\t\u003c/p\u003e\u003c/div\u003e\n\t\t\t\t\u003c/section\u003e\n\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
