{
  "id": "f614dcf2-3220-45c5-9644-7f6731003d13",
  "title": "Bypassing Google's big anti-adblock update",
  "link": "https://0x44.xyz/blog/web-request-blocking/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 12 Jul 2025 19:06:09 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 6430,
  "excerpt": "Or, why you shouldn't write parts of your browser in JavaScript",
  "siteName": "",
  "favicon": "https://0x44.xyz/icon.png",
  "text": "About MV3 If you know anything about browsers, you've probably heard that Google Chrome is phasing out MV2 in favor of MV3. You've probably also heard that this hurts adblockers. A quick explainer: \"MV\" stands for \"manifest version.\" MV3 introduces a new type of runtime for Chrome extensions that, among other things, gets rid of webRequestBlocking, a permission that allows extensions to block requests dynamically based on their content (which its replacement does not support). Adblockers heavily rely on webRequestBlocking to function properly. Pretty convenient (cough cough) for a company that makes most of its revenue from ads to be removing that. Anyway, with the phasing-out of MV2 pretty much done, now seems like a good time to talk about a bug in Chrome that I found and reported to Google in 2023. The bug let webRequestBlocking (and yes, adblockers) work in MV3. I still consider it probably the funniest bug I've ever found. Stop writing browsers in JavaScript Yes, Chrome is written in C++. However, extensions are written in JavaScript, and the API functions they call look just like JavaScript functions, at least from the extension's point of view. But they aren't normal functions: they're special and do browsery C++ stuff through bindings. In theory, this should be safe. But in the old days, Google decided it'd be a good idea to inject a bunch of JS files into pages that used Chrome APIs. These \"extension binding modules\" would initialize API functions and validate arguments before passing them to the browser. (Note: here's the codebase of those files in 2016.) Turns out running privileged JavaScript in user-controlled websites was not a good idea, because JS can often be manipulated by overriding global functions and prototypes. Since certain APIs like chrome.runtime exist on normal websites too, the extension bindings system led to multiple Universal XSS bugs back in 2015 and 2016. Here's one that allows any website to inject code into any other website. Truly crazy stuff. If only I weren't 8 years old back then... maybe I could have cashed in. Anyway, Google learned from their mistake and moved most API bindings to pure C++. However, a couple of JS binding files still exist and are used today. For example, if a Chrome extension runs the following code, it'll hit a JS loop and hang infinitely: (as of July 2025) chrome.permissions.contains({ permissions: { length: Infinity }}) Maybe you are wondering what this has to do with adblockers. Remember how I said only a few APIs still use JavaScript bindings? chrome.webRequest is one of them. The bug This is how an MV2 extension would block requests to example.com: chrome.webRequest.onBeforeRequest.addListener(() =\u003e { return { cancel: true } }, { urls: ['*://*.example.com/*'] }, ['blocking']) It's the 'blocking' part at the end that requires the webRequestBlocking permission, and therefore isn't allowed in MV3. Without it, the cancel: true does nothing. So clearly adding a blocking listener to the chrome.webRequest.onBeforeRequest event does not work anymore. But we can do something crazy. We can make our own event. Now, this should not be possible; it's not even a concept that makes sense. But, because of how the JS bindings work, you can do it. For some reason, there is a wrapper class for webRequest events that contains some extra state. (A note on the security of the above code.) Instead of doing pure bindings between JS and C++, the browser creates one of these classes for every chrome.webRequest event: onBeforeRequest, onCompleted, etc. Surprisingly, the .constructor of these events is still public. It points to yet another wrapper class, which internally calls WebRequestEventImpl (from the code above). You can use this to can create a new event with your own properties: let WebRequestEvent = chrome.webRequest.onBeforeRequest.constructor let fooEvent = new WebRequestEvent(\"foo\") There is still a lot of validation going on in the backend when you try to actually do things with these fake events. For example, trying to add a listener to fooEvent kills the extension's process, because the event name is invalid. So how do you manipulate the properties of WebRequestEventImpl to do anything interesting? After a lot of time looking into the C++ code, I found exactly one vulnerable thing: the opt_webViewInstanceId parameter. This was set for Chrome platform apps, in order to let them manage their embedded websites (WebViews). Among other things, it let them use web request blocking to control navigation. Basically, if an event had a WebView ID, the permission check for webRequestBlocking would be skipped. The issue was that the browser never verified that an event with a WebView ID actually belonged to a platform app. So an extension could spoof it, skip the check, and use the blocking feature. let WebRequestEvent = chrome.webRequest.onBeforeRequest.constructor // opt_webViewInstanceId is the 5th argument let fakeEvent = new WebRequestEvent(\"webRequest.onBeforeRequest\", 0, 0, 0, 1337) fakeEvent.addListener(() =\u003e { return { cancel: true } }, { urls: ['*://*.example.com/*'] }, ['blocking']) Maybe I should note that platform apps were deprecated in 2020. I found this bug in 2023, and the code to handle opt_webViewInstanceId still exists in 2025. Goes to show how ancient code leads to bugs. What could have happened, and what happened Technically, someone could have used this bug to make a perfectly working adblocker in MV3 by simply replacing all instances of chrome.webRequest.onBeforeRequest with fakeEvent. This would have been very funny, after all the hype about how adblockers were being killed. But I don't know how to make an adblocker, so I decided to report the issue to Google in August 2023. It was patched in Chrome 118 by checking whether extensions using opt_webViewInstanceId actually had WebView permissions. For the report, I netted a massive reward of $0. They decided it wasn't a security issue, and honestly, I agree, because it didn't give extensions access to data they didn't already have. (Shown above: my earnings from this bug.) Anyway, it was a fun one, and it really shows how a few lines of code can sometimes bypass a big update by a big company. I hope you found it interesting! If you want to read another post about a bug in Chrome extensions, try this one I found in the same year, which got a CVE number and a $10,000 reward.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n            \u003ch2\u003eAbout MV3\u003c/h2\u003e\n\u003cp\u003eIf you know anything about browsers, you\u0026#39;ve probably heard that Google Chrome is phasing out MV2 in favor of MV3. You\u0026#39;ve probably also heard that this hurts adblockers.\u003c/p\u003e\n\u003cp\u003eA quick explainer: \u0026#34;MV\u0026#34; stands for \u0026#34;manifest version.\u0026#34; MV3 introduces a new type of runtime for Chrome extensions that, among other things, gets rid of \u003ccode\u003ewebRequestBlocking\u003c/code\u003e, a permission that allows extensions to block requests dynamically based on their content (which \u003ca href=\"https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest\"\u003eits replacement\u003c/a\u003e does not support). Adblockers heavily rely on \u003ccode\u003ewebRequestBlocking\u003c/code\u003e to function properly. Pretty convenient (cough cough) for a company that makes most of its revenue from ads to be removing that.\u003c/p\u003e\n\u003cp\u003eAnyway, with the phasing-out of MV2 pretty much done, now seems like a good time to talk about a bug in Chrome that I found and reported to Google in 2023. \u003ca href=\"https://issues.chromium.org/issues/40926777\"\u003eThe bug\u003c/a\u003e let \u003ccode\u003ewebRequestBlocking\u003c/code\u003e (and yes, adblockers) work in MV3.\u003c/p\u003e\n\u003cp\u003eI still consider it probably the funniest bug I\u0026#39;ve ever found.\u003c/p\u003e\n\u003ch2\u003eStop writing browsers in JavaScript\u003c/h2\u003e\n\u003cp\u003eYes, Chrome is written in C++. However, extensions are written in JavaScript, and the API functions they call look just like JavaScript functions, at least from the extension\u0026#39;s point of view. But they aren\u0026#39;t normal functions: they\u0026#39;re special and do browsery C++ stuff through bindings. In theory, this should be safe.\u003c/p\u003e\n\u003cp\u003eBut in the old days, Google decided it\u0026#39;d be a good idea to inject a bunch of JS files into pages that used Chrome APIs. These \u0026#34;extension binding modules\u0026#34; would initialize API functions and validate arguments before passing them to the browser.\u003c/p\u003e\n\u003cp\u003e(Note: \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/dc42ae208c2744f7fb144b2e396358a1fc34db87:extensions/renderer/resources/\"\u003ehere\u0026#39;s the codebase\u003c/a\u003e of those files in 2016.)\u003c/p\u003e\n\u003cp\u003eTurns out running privileged JavaScript in user-controlled websites was not a good idea, because JS can often be manipulated by overriding global functions and prototypes. Since certain APIs like \u003ccode\u003echrome.runtime\u003c/code\u003e exist on normal websites too, the extension bindings system led to multiple Universal XSS bugs back in 2015 and 2016. \u003ca href=\"https://issues.chromium.org/issues/40083765\"\u003eHere\u0026#39;s one\u003c/a\u003e that allows any website to inject code into any other website. Truly crazy stuff. If only I weren\u0026#39;t 8 years old back then... maybe I could have cashed in.\u003c/p\u003e\n\u003cp\u003eAnyway, Google learned from their mistake and moved most API bindings to pure C++. However, a couple of JS binding files still exist and are used today. For example, if a Chrome extension runs the following code, it\u0026#39;ll hit a \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/60039d4d4bd70512e21a2dfe586602aca1d9d35e:extensions/renderer/resources/permissions_custom_bindings.js;l=46;bpv=0;bpt=0\"\u003eJS loop\u003c/a\u003e and hang infinitely: (as of July 2025)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003echrome.permissions.contains({ permissions: { length: Infinity }})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMaybe you are wondering what this has to do with adblockers.\u003c/p\u003e\n\u003cp\u003eRemember how I said only a few APIs still use JavaScript bindings? \u003ccode\u003echrome.webRequest\u003c/code\u003e is one of them.\u003c/p\u003e\n\u003ch2\u003eThe bug\u003c/h2\u003e\n\u003cp\u003eThis is how an MV2 extension would block requests to example.com:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003echrome.webRequest.onBeforeRequest.addListener(() =\u0026gt; {  \n    return { cancel: true }  \n}, { urls: [\u0026#39;*://*.example.com/*\u0026#39;] }, [\u0026#39;blocking\u0026#39;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt\u0026#39;s the \u003ccode\u003e\u0026#39;blocking\u0026#39;\u003c/code\u003e part at the end that requires the \u003ccode\u003ewebRequestBlocking\u003c/code\u003e permission, and therefore isn\u0026#39;t allowed in MV3. Without it, the \u003ccode\u003ecancel: true\u003c/code\u003e does nothing.\u003c/p\u003e\n\u003cp\u003eSo clearly adding a blocking listener to the \u003ccode\u003echrome.webRequest.onBeforeRequest\u003c/code\u003e event does not work anymore. But we can do something crazy. We can make \u003cstrong\u003eour own event.\u003c/strong\u003e Now, this should not be possible; it\u0026#39;s not even a concept that makes sense. But, because of how the JS bindings work, you can do it. For some reason, there is a \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/main:extensions/renderer/resources/web_request_event.js;l=52;drc=f52b068efda528bf42d0b7d245674deb99ee58ba\"\u003ewrapper class\u003c/a\u003e for \u003ccode\u003ewebRequest\u003c/code\u003e events that contains some extra state.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://0x44.xyz/blog/web-request-blocking/wrei-code.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e(A \u003ca href=\"https://0x44.xyz/blog/web-request-blocking/wrei-note.txt\"\u003enote on the security\u003c/a\u003e of the above code.)\u003c/p\u003e\n\u003cp\u003eInstead of doing pure bindings between JS and C++, the browser creates one of these classes for every \u003ccode\u003echrome.webRequest\u003c/code\u003e event: \u003ccode\u003eonBeforeRequest\u003c/code\u003e, \u003ccode\u003eonCompleted\u003c/code\u003e, etc. Surprisingly, the \u003ccode\u003e.constructor\u003c/code\u003e of these events is still public. It points to yet another wrapper class, which internally calls \u003ccode\u003eWebRequestEventImpl\u003c/code\u003e (from the code above). You can use this to can create a new event with your own properties:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet WebRequestEvent = chrome.webRequest.onBeforeRequest.constructor\nlet fooEvent = new WebRequestEvent(\u0026#34;foo\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is still a lot of validation going on in the backend when you try to actually do things with these fake events. For example, trying to add a listener to \u003ccode\u003efooEvent\u003c/code\u003e kills the extension\u0026#39;s process, because the event name is invalid. So how do you manipulate the properties of \u003ccode\u003eWebRequestEventImpl\u003c/code\u003e to do anything interesting?\u003c/p\u003e\n\u003cp\u003eAfter a lot of time looking into the C++ code, I found exactly one vulnerable thing: the \u003ccode\u003eopt_webViewInstanceId\u003c/code\u003e parameter. This was set for Chrome platform apps, in order to let them manage their embedded websites (WebViews). Among other things, it let them use web request blocking to control navigation. Basically, if an event had a WebView ID, the permission check for \u003ccode\u003ewebRequestBlocking\u003c/code\u003e \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/api/web_request/web_request_api.cc;drc=3d26531172e5deb179e524cc9d7035153d3eb4b3;l=722\"\u003ewould be skipped\u003c/a\u003e. The issue was that the browser never verified that an event with a WebView ID actually belonged to a platform app. So an extension could spoof it, skip the check, and use the blocking feature.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet WebRequestEvent = chrome.webRequest.onBeforeRequest.constructor\n\n// opt_webViewInstanceId is the 5th argument\nlet fakeEvent = new WebRequestEvent(\u0026#34;webRequest.onBeforeRequest\u0026#34;, 0, 0, 0, 1337)\n\nfakeEvent.addListener(() =\u0026gt; {  \n    return { cancel: true }  \n}, { urls: [\u0026#39;*://*.example.com/*\u0026#39;] }, [\u0026#39;blocking\u0026#39;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMaybe I should note that platform apps were \u003cstrong\u003edeprecated in 2020.\u003c/strong\u003e I found this bug in 2023, and the code to handle \u003ccode\u003eopt_webViewInstanceId\u003c/code\u003e still exists in 2025. Goes to show how ancient code leads to bugs.\u003c/p\u003e\n\u003ch2\u003eWhat could have happened, and what happened\u003c/h2\u003e\n\u003cp\u003eTechnically, someone could have used this bug to make a perfectly working adblocker in MV3 by simply replacing all instances of \u003ccode\u003echrome.webRequest.onBeforeRequest\u003c/code\u003e with \u003ccode\u003efakeEvent\u003c/code\u003e. This would have been very funny, after all the hype about how adblockers were being killed.\u003c/p\u003e\n\u003cp\u003eBut I don\u0026#39;t know how to make an adblocker, so I decided to \u003ca href=\"https://issues.chromium.org/issues/40926777\"\u003ereport the issue to Google\u003c/a\u003e in August 2023. It was patched in Chrome 118 by \u003ca href=\"https://source.chromium.org/chromium/chromium/src/+/main:extensions/browser/api/web_request/web_request_api.cc;l=722;bpv=1;bpt=0;drc=40cc134ade29c59e86399520db9d252e79058a3c;dlc=ccbf0af81b332209d276725c17e381a76acb9b1c\"\u003echecking whether\u003c/a\u003e extensions using \u003ccode\u003eopt_webViewInstanceId\u003c/code\u003e actually had WebView permissions. For the report, I netted a massive reward of $0. They decided it wasn\u0026#39;t a security issue, and honestly, I agree, because it didn\u0026#39;t give extensions access to data they didn\u0026#39;t already have.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://0x44.xyz/blog/web-request-blocking/no-money.png\" alt=\"No money\"/\u003e\u003c/p\u003e\n\u003cp\u003e(Shown above: my earnings from this bug.)\u003c/p\u003e\n\u003cp\u003eAnyway, it was a fun one, and it really shows how a few lines of code can sometimes bypass a big update by a big company. I hope you found it interesting! If you want to read another post about a bug in Chrome extensions, try \u003ca href=\"https://0x44.xyz/blog/cve-2023-4369/\"\u003ethis one I found in the same year\u003c/a\u003e, which got a CVE number and a $10,000 reward.\u003c/p\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
