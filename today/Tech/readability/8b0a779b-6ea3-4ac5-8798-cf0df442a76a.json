{
  "id": "8b0a779b-6ea3-4ac5-8798-cf0df442a76a",
  "title": "It's time for modern CSS to kill the SPA",
  "link": "https://www.jonoalderson.com/conjecture/its-time-for-modern-css-to-kill-the-spa/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 25 Jul 2025 21:08:00 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Jono Alderson",
  "length": 9955,
  "excerpt": "Native CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites.",
  "siteName": "Jono Alderson",
  "favicon": "",
  "text": "24th July, 2025 Native CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites. The app-like fallacy â€œMake it feel like an app.â€ At some point during the scoping process, someone says the words. AÂ CMO. AÂ digital lead. AÂ brand manager. And with that single phrase, the architecture is locked in: itâ€™ll be an SPA. Probably React. Maybe Vue. Almost certainly deployed on Vercel or Netlify, bundled with aÂ headless CMS and aÂ GraphQL API for good measure. But the decision wasnâ€™t really about architecture. It wasnâ€™t even about performance, scalability, or content management. It was about interactions. About how the site would feel when you click around.Â  The assumption was simple: Seamless navigation requires us to build anÂ app. That assumption is now obsolete. The false promise ofÂ SPAs The reason SPAs became the default wasnâ€™t because they were better. It was because, for aÂ while, they were the only way to deliver something that felt fluid â€“ something that didnâ€™t flash white between pages or jank the scroll position. But hereâ€™s the uncomfortable truth: most SPAs donâ€™t actually deliver the polish they promise. What you usually getÂ is: A page transition that looks smooth, until you realise itâ€™s just fading between two loading states Broken scroll restoration Inconsistent focus behaviour Delayed navigation while scripts rehydrate components Layout shift, content popping, or full-page skeletons A performance hit thatâ€™s entirely disproportionate to the effect This isnâ€™t theoretical. Look at most sites built with Next.js, Gatsby, or Nuxt. Theyâ€™re shipping kilobytes (often megabytes) of JavaScript just to fake native navigation. Routing logic, hydration code, loading spinners â€“ all just to stitch together something that browsers already knew how to do natively. Instead of smoothness, you get simulation. And instead of aÂ fast, stable, SEO-friendly experience, you get aÂ heavy JavaScript machine trying to recreate the native behaviour we threwÂ away. Weâ€™ve been adding mountains of JS to â€œfeelâ€ fast, while making everything slower. An aside â€“ IÂ went deeper on this in JavaScript broke the web, where IÂ outlined how our obsession with JS-first development is actively eroding the webâ€™s foundations. The web grewÂ up While we were busy reinventing navigation in JavaScript, the platform quietly solved the problem. Modern browsers â€“ specifically Chromium-based ones like Chrome and Edge â€“ now support native, declarative page transitions. With the View Transitions API, you can animate between two documents â€“ including full page navigations â€“ without needing aÂ single line of JavaScript. Yes, really. What weâ€™re calling â€œmodern CSSâ€ here is shorthand for View Transitions, Speculation Rules, and aÂ return to native browser features that were always designed to handle navigation, interaction, and layout. These capabilities let us build rich, seamless experiences â€“ without rewriting the browser in JavaScript. An aside â€“ CSS is also declarative, resilient, expressive, scalable, and increasingly intuitive. Itâ€™s accessible to anyone who can write plain HTML. And that structural clarity reinforces everything IÂ argued in Why semantic HTML still matters â€“ that clean, meaningful markup is the bedrock of performance, maintainability, and machine readability. That means youÂ can: Fade between pages Animate shared elements (e.g. thumbnails â†’ product detail) Maintain persistent elements like headers or navbars Do it all with real URLs, real page loads, and no JS routing hacks Letâ€™s make this concrete. ğŸ”„ Basic cross-page fade transition With just aÂ few lines of CSS, you can trigger smooth visual transitions between pages. On both the current and destination page,Â add: @view-transition { navigation: auto; } ::view-transition-old(root), ::view-transition-new(root) { animation: fade 0.3s ease both; } @keyframes fade { from { opacity: 0; } to { opacity: 1; } } Thatâ€™s it. The browser handles the transition â€“ no client-side routing, no hydration, no loading spinners. ğŸ” Shared element transitions Want to animate aÂ thumbnail image into its full-size product counterpart on the nextÂ page? No JavaScript needed â€“ just assign the same view-transition-name to the element on bothÂ pages: On the product listing page: \u003ca href=\"/product/red-shoes\"\u003e \u003cimg src=\"/images/red-shoes-thumb.jpg\" style=\"view-transition-name: product-image;\" /\u003e \u003c/a\u003e On the product detail page: \u003cimg src=\"/images/red-shoes-large.jpg\" style=\"view-transition-name: product-image;\" /\u003e The browser matches and animates the elements between navigations. You can animate position, scale, opacity, layout â€“ all withÂ CSS. ğŸ¤– But what if IÂ need JS-driven transitions? You can manually trigger transitions inside aÂ page too: document.startViewTransition(() =\u003e { document.body.classList.toggle('dark-mode'); }); Perfect for things like tab toggles or theme switchesâ€Šâ€”â€Šwithout needing aÂ framework or hydration layer. ğŸ”® Speculation rules: instant navigation without JS View Transitions make things smooth. But what about fast? Thatâ€™s where Speculation Rules come in. This lets the browser preload or prerender full pages based on user behaviour â€“ like hovering or touching aÂ link â€“ before theyÂ click. \u003cscript type=\"speculationrules\"\u003e { \"prerender\": [ { \"where\": { \"selector_matches\": \"a\" } } ] } \u003c/script\u003e The result? Navigation thatâ€™s instant. No waiting. No loading. No spinners. âš ï¸ AÂ Note of Caution Speculation Rules are aÂ performance multiplier. On aÂ lean site, they make things feel instant. But if your pages are slow, bloated, or JS-heavy, speculation just front-loads thoseÂ costs. If your site is bloated, speculation will still speculate â€“ and the user pays theÂ price. That means wasted CPU, network bandwidth, and mobile battery â€“ often for pages the user never even visits. Use them carefully. On aÂ fast site, theyâ€™re magic. On aÂ slow one, theyâ€™re aÂ trap. Browsers want to help â€“ if we letÂ them Modern browsers are smarter than ever. Theyâ€™re constantly looking for ways to improve speed, responsiveness, and efficiency â€“ but only if we letÂ them. One of the clearest examples is the Back/Forward Cache (bfcache), which allows entire pages to be snapshotted and restored instantly when users navigate back or forward. Itâ€™s effectively free performance â€“ but only for pages that behave. That means no rogue JavaScript, no intercepted navigation, no lifecycle chaos. Just clean, declarative architecture. Just HTML andÂ CSS. Unsurprisingly, this plays beautifully with aÂ well-structured, multi-page site. But for most SPAs, itâ€™s aÂ non-starter. The very design patterns that define them â€“ hijacked routing, client-side rendering, complex state management â€“ break the assumptions that bfcache relies on. This is aÂ microcosm of aÂ much bigger theme: browsers are evolving to reward simplicity and resilience. Theyâ€™re building for the kind of web we should have been embracing all along. And SPAs are increasingly the odd onesÂ out. ğŸ“Š SPA vs MPA: aÂ performance reality check Average Next.js marketing site JS bundle: 1â€Šâ€“â€Š3MB TTI: ~3.5â€Šâ€“â€Š5s (depending on hydration strategy) Route transitions: simulated SEO: complex, fragile Scroll/anchor behaviour: unreliable Modern MPA + View Transitions + Speculation Rules JS bundle: 0KB (optional enhancements only) TTI: ~1s Route transitions: real, native SEO: trivial Scroll/focus/history: browser-default and perfect Modern CSS doesnâ€™t just replace SPA behaviour â€“ it outperforms it. Donâ€™t build aÂ website like itâ€™s anÂ app Most websites arenâ€™t apps. They donâ€™t need shared state. They donâ€™t need client-side routing. They donâ€™t need interactive components on every screen. But somewhere along the way, we stopped making the distinction. Now weâ€™re building ecommerce stores, documentation portals, marketing sites, and blogs using stacks designed for real-time collaborative UIs. Itâ€™s madness. A homepage with six content blocks and aÂ contact form doesnâ€™t need hydration, suspense boundaries, and aÂ rendering strategy. It needs fast markup, clean URLs, and maybe â€“ maybe â€“ aÂ bit of interactivity layered onÂ top. And yet, on every project: A stakeholder says, â€œmake it feel like anÂ app.â€ A dev team reaches for Next.js orÂ Nuxt. Routing goes client-side. Performance falls off aÂ cliff. Now you need edge functions, streaming, ISR, loading strategies, and aÂ debugging plan. And somehowâ€¦ it still feels slower than aÂ regular link click and aÂ CSS animation. This isnâ€™t about being anti-framework. Itâ€™s about being intentional. Use React if you want. Use Tailwind, Vite, whatever. Just donâ€™t ship it all to the browser unless you need to. Build aÂ site like aÂ site. Use HTML. Use navigation. Use the platform. Itâ€™s faster, simpler, and better for everyone. Build for the web weÂ have SPAs were aÂ clever solution to aÂ temporary limitation. But that limitation no longer exists. We nowÂ have: Native, declarative transitions between realÂ pages Instantaneous prerendered navigation via Speculation Rules Graceful degradation Clean markup, fast loads, and realÂ URLs A platform that wants to help â€“ if we letÂ it If youâ€™re still building your site as an SPA for the sake of â€œsmoothness,â€ youâ€™re solving aÂ problem the browser already fixed â€“ and youâ€™re paying for it in complexity, performance, and maintainability. Use modern server rendering. Use actual pages. Animate with CSS. Preload with intent. Ship less JavaScript. Build like itâ€™s 2025 â€“ not like youâ€™re trapped in aÂ 2018 demo of Gatsby. Youâ€™ll end up with faster sites, happier users, and fewer regrets.",
  "image": "https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026f=auto\u0026fit=cover\u0026height=675\u0026q=85\u0026sharpen=1\u0026width=1200",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n\t\t\t\t\n\t\t\t\t\u003cdiv\u003e\u003cp\u003e24th July, 2025\u003c/p\u003e\u003cdiv\u003e\u003cpicture\u003e\u003cimg sizes=\"(max-width: 96px) 100vw, 96px\" alt=\"\" src=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=96\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=96\" srcset=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=96\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=96 96w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=144\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=144 144w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/gravatars/32defd3f59a05a4eab3c33ade0e4e00d4dd992485f1e82758244d248636cd16e?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=192\u0026amp;q=85\u0026amp;sharpen=1\u0026amp;width=192 192w\" height=\"96\" width=\"96\" decoding=\"async\" loading=\"eager\" acd-lazy-load=\"true\" fetchpriority=\"high\"/\u003e\u003c/picture\u003e\u003c/div\u003e\u003cpicture\u003e\u003cimg alt=\"\" decoding=\"async\" fetchpriority=\"high\" height=\"350\" sizes=\"(max-width: 760px) calc(100vw - 2.5rem), 760px\" src=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=350\u0026amp;q=85\u0026amp;width=760\" srcset=\"https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=350\u0026amp;q=85\u0026amp;width=760 760w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=525\u0026amp;q=85\u0026amp;width=1140 1140w, https://www.jonoalderson.com/acd-cgi/img/v1/wp-content/uploads/file_00000000be4861f49d1f8af54cec64de.png?dpr=1\u0026amp;f=auto\u0026amp;fit=cover\u0026amp;height=700\u0026amp;q=85\u0026amp;width=1520 1520w\" width=\"760\" loading=\"lazy\" acd-lazy-load=\"true\"/\u003e\u003c/picture\u003e\u003c/div\u003e\n\u003cp\u003eNative CSS transitions have quietly killed the strongest argument for client-side routing. Yet people keep building terrible apps instead of performant websites.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-the-app-like-fallacy\"\u003eThe app-like fallacy\u003c/h2\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eâ€œ\u003cem\u003eMake it feel like an app\u003c/em\u003e.â€\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eAt some point during the scoping process, someone says the words. AÂ CMO. AÂ digital lead. AÂ brand manager. And with that single phrase, the architecture is locked in: itâ€™ll be an SPA. Probably React. Maybe Vue. Almost certainly deployed on Vercel or Netlify, bundled with aÂ headless CMS and aÂ GraphQL API for good measure.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut the decision wasnâ€™t really about architecture. It wasnâ€™t even about performance, scalability, or content management. It was about \u003cem\u003einteractions\u003c/em\u003e. About how the site would feel when you click around.Â \u003c/p\u003e\n\n\n\n\u003cp\u003eThe assumption was simple: Seamless navigation requires us to build anÂ app.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat assumption is now obsolete.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-the-false-promise-of-spas\"\u003eThe false promise ofÂ SPAs\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe reason SPAs became the default wasnâ€™t because they were \u003cem\u003ebetter\u003c/em\u003e. It was because, for aÂ while, they were the only way to deliver something that felt fluid â€“ something that didnâ€™t flash white between pages or jank the scroll position.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut hereâ€™s the uncomfortable truth: most SPAs donâ€™t actually deliver the polish they promise.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat you usually getÂ is:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA page transition that \u003cem\u003elooks\u003c/em\u003e smooth, until you realise itâ€™s just fading between two loading states\u003c/li\u003e\n\n\n\n\u003cli\u003eBroken scroll restoration\u003c/li\u003e\n\n\n\n\u003cli\u003eInconsistent focus behaviour\u003c/li\u003e\n\n\n\n\u003cli\u003eDelayed navigation while scripts rehydrate components\u003c/li\u003e\n\n\n\n\u003cli\u003eLayout shift, content popping, or full-page skeletons\u003c/li\u003e\n\n\n\n\u003cli\u003eA performance hit thatâ€™s entirely disproportionate to the effect\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis isnâ€™t theoretical. Look at most sites built with Next.js, Gatsby, or Nuxt. Theyâ€™re shipping \u003cem\u003ekilobytes\u003c/em\u003e (often \u003cem\u003emegabytes\u003c/em\u003e) of JavaScript just to \u003cem\u003efake\u003c/em\u003e native navigation. Routing logic, hydration code, loading spinners â€“ all just to stitch together something that browsers already knew how to do natively.\u003c/p\u003e\n\n\n\n\u003cp\u003eInstead of smoothness, you get simulation. And instead of aÂ fast, stable, SEO-friendly experience, you get aÂ heavy JavaScript machine trying to recreate the native behaviour we threwÂ away.\u003c/p\u003e\n\n\n\n\u003cp\u003eWeâ€™ve been adding mountains of JS to â€œfeelâ€ fast, while making everything slower.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAn aside â€“ IÂ went deeper on this in \u003ca href=\"https://www.jonoalderson.com/conjecture/javascript-broke-the-web-and-called-it-progress/\"\u003eJavaScript broke the web\u003c/a\u003e, where IÂ outlined how our obsession with JS-first development is actively eroding the webâ€™s foundations.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003ch2 id=\"h-the-web-grew-up\"\u003eThe web grewÂ up\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile we were busy reinventing navigation in JavaScript, the platform quietly solved the problem.\u003c/p\u003e\n\n\n\n\u003cp\u003eModern browsers â€“ specifically Chromium-based ones like Chrome and Edge â€“ now support native, declarative page transitions. With the \u003ca href=\"https://developer.chrome.com/docs/web-platform/view-transitions/\"\u003eView Transitions API\u003c/a\u003e, you can animate between two documents â€“ including full page navigations â€“ without needing aÂ single line of JavaScript.\u003c/p\u003e\n\n\n\n\u003cp\u003eYes, really.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat weâ€™re calling â€œmodern CSSâ€ here is shorthand for \u003cstrong\u003eView Transitions\u003c/strong\u003e, \u003cstrong\u003eSpeculation Rules\u003c/strong\u003e, and aÂ return to native browser features that were always designed to handle navigation, interaction, and layout. These capabilities let us build rich, seamless experiences â€“ without rewriting the browser in JavaScript.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eAn aside â€“ CSS is also declarative, resilient, expressive, scalable, and increasingly intuitive. Itâ€™s accessible to anyone who can write plain HTML. And that structural clarity reinforces everything IÂ argued in \u003ca href=\"https://www.jonoalderson.com/conjecture/why-semantic-html-still-matters/\"\u003eWhy semantic HTML still matters\u003c/a\u003e â€“ that clean, meaningful markup is the bedrock of performance, maintainability, and machine readability.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThat means youÂ can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFade between pages\u003c/li\u003e\n\n\n\n\u003cli\u003eAnimate shared elements (e.g. thumbnails â†’ product detail)\u003c/li\u003e\n\n\n\n\u003cli\u003eMaintain persistent elements like headers or navbars\u003c/li\u003e\n\n\n\n\u003cli\u003eDo it all with real URLs, real page loads, and no JS routing hacks\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eLetâ€™s make this concrete.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-basic-cross-page-fade-transition\"\u003eğŸ”„ Basic cross-page fade transition\u003c/h3\u003e\n\n\n\n\u003cp\u003eWith just aÂ few lines of CSS, you can trigger smooth visual transitions between pages.\u003c/p\u003e\n\n\n\n\u003cp\u003eOn both the current and destination page,Â add:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e@view-transition {\n  navigation: auto;\n}\n\n::view-transition-old(root),\n::view-transition-new(root) {\n  animation: fade 0.3s ease both;\n}\n\n@keyframes fade {\n  from { opacity: 0; }\n  to   { opacity: 1; }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThatâ€™s it. The browser handles the transition â€“ no client-side routing, no hydration, no loading spinners.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-shared-element-transitions\"\u003eğŸ” Shared element transitions\u003c/h3\u003e\n\n\n\n\u003cp\u003eWant to animate aÂ thumbnail image into its full-size product counterpart on the nextÂ page?\u003c/p\u003e\n\n\n\n\u003cp\u003eNo JavaScript needed â€“ just assign the same \u003ccode\u003eview-transition-name\u003c/code\u003e to the element on bothÂ pages:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eOn the product listing page:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;a href=\u0026#34;/product/red-shoes\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;/images/red-shoes-thumb.jpg\u0026#34; style=\u0026#34;view-transition-name: product-image;\u0026#34; /\u0026gt;\n\u0026lt;/a\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eOn the product detail page:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;img src=\u0026#34;/images/red-shoes-large.jpg\u0026#34; style=\u0026#34;view-transition-name: product-image;\u0026#34; /\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe browser matches and animates the elements between navigations. You can animate position, scale, opacity, layout â€“ all withÂ CSS.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-but-what-if-i-need-js-driven-transitions\"\u003eğŸ¤– But what if IÂ need JS-driven transitions?\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou can manually trigger transitions inside aÂ page too:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003edocument.startViewTransition(() =\u0026gt; {\n  document.body.classList.toggle(\u0026#39;dark-mode\u0026#39;);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003ePerfect for things like tab toggles or theme switchesâ€Šâ€”â€Šwithout needing aÂ framework or hydration layer.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"h-speculation-rules-instant-navigation-without-js\"\u003eğŸ”® Speculation rules: instant navigation without JS\u003c/h3\u003e\n\n\n\n\u003cp\u003eView Transitions make things smooth. But what about \u003cem\u003efast\u003c/em\u003e?\u003c/p\u003e\n\n\n\n\u003cp\u003eThatâ€™s where \u003ca href=\"https://developer.chrome.com/docs/web-platform/implementing-speculation-rules/\"\u003eSpeculation Rules\u003c/a\u003e come in. This lets the browser preload or prerender full pages based on user behaviour â€“ like hovering or touching aÂ link â€“ before theyÂ click.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;script type=\u0026#34;speculationrules\u0026#34;\u0026gt;\n{\n  \u0026#34;prerender\u0026#34;: [\n    {\n      \u0026#34;where\u0026#34;: {\n        \u0026#34;selector_matches\u0026#34;: \u0026#34;a\u0026#34;\n      }\n    }\n  ]\n}\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe result? Navigation thatâ€™s \u003cem\u003einstant\u003c/em\u003e. No waiting. No loading. No spinners.\u003c/p\u003e\n\n\n\n\u003ch4 id=\"h-a-note-of-caution\"\u003eâš ï¸ AÂ Note of Caution\u003c/h4\u003e\n\n\n\n\u003cp\u003eSpeculation Rules are aÂ performance multiplier. On aÂ lean site, they make things feel instant. But if your pages are slow, bloated, or JS-heavy, speculation just front-loads thoseÂ costs.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf your site is bloated, speculation will still speculate â€“ and the user pays theÂ price.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat means wasted CPU, network bandwidth, and mobile battery â€“ often for pages the user never even visits.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse them carefully. On aÂ fast site, theyâ€™re magic. On aÂ slow one, theyâ€™re aÂ trap.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-browsers-want-to-help-if-we-let-them\"\u003eBrowsers want to help â€“ if we letÂ them\u003c/h2\u003e\n\n\n\n\u003cp\u003eModern browsers are smarter than ever. Theyâ€™re constantly looking for ways to improve speed, responsiveness, and efficiency â€“ but only if we letÂ them.\u003c/p\u003e\n\n\n\n\u003cp\u003eOne of the clearest examples is the \u003ca href=\"https://web.dev/articles/bfcache\"\u003eBack/Forward Cache (bfcache)\u003c/a\u003e, which allows entire pages to be snapshotted and restored instantly when users navigate back or forward.\u003c/p\u003e\n\n\n\n\u003cp\u003eItâ€™s effectively free performance â€“ but only for pages that behave. That means no rogue JavaScript, no intercepted navigation, no lifecycle chaos. Just clean, declarative architecture. Just HTML andÂ CSS.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnsurprisingly, this plays beautifully with aÂ well-structured, multi-page site. But for most SPAs, itâ€™s aÂ non-starter. The very design patterns that define them â€“ hijacked routing, client-side rendering, complex state management â€“ break the assumptions that bfcache relies on.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is aÂ microcosm of aÂ much bigger theme: browsers are evolving to reward simplicity and resilience. Theyâ€™re building for the kind of web we should have been embracing all along. And SPAs are increasingly the odd onesÂ out.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-spa-vs-mpa-a-performance-reality-check\"\u003eğŸ“Š SPA vs MPA: aÂ performance reality check\u003c/h2\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eAverage Next.js marketing site\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJS bundle: 1â€Šâ€“â€Š3MB\u003c/li\u003e\n\n\n\n\u003cli\u003eTTI: ~3.5â€Šâ€“â€Š5s (depending on hydration strategy)\u003c/li\u003e\n\n\n\n\u003cli\u003eRoute transitions: simulated\u003c/li\u003e\n\n\n\n\u003cli\u003eSEO: complex, fragile\u003c/li\u003e\n\n\n\n\u003cli\u003eScroll/anchor behaviour: unreliable\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eModern MPA + View Transitions + Speculation Rules\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJS bundle: 0KB (optional enhancements only)\u003c/li\u003e\n\n\n\n\u003cli\u003eTTI: ~1s\u003c/li\u003e\n\n\n\n\u003cli\u003eRoute transitions: real, native\u003c/li\u003e\n\n\n\n\u003cli\u003eSEO: trivial\u003c/li\u003e\n\n\n\n\u003cli\u003eScroll/focus/history: browser-default and perfect\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eModern CSS doesnâ€™t just replace SPA behaviour â€“ it \u003cem\u003eoutperforms\u003c/em\u003e it.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-don-t-build-a-website-like-it-s-an-app\"\u003eDonâ€™t build aÂ website like itâ€™s anÂ app\u003c/h2\u003e\n\n\n\n\u003cp\u003eMost websites arenâ€™t apps.\u003c/p\u003e\n\n\n\n\u003cp\u003eThey donâ€™t need shared state. They donâ€™t need client-side routing. They donâ€™t need interactive components on every screen. But somewhere along the way, we stopped making the distinction.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow weâ€™re building ecommerce stores, documentation portals, marketing sites, and blogs using stacks designed for real-time collaborative UIs. Itâ€™s madness.\u003c/p\u003e\n\n\n\n\u003cp\u003eA homepage with six content blocks and aÂ contact form doesnâ€™t need hydration, suspense boundaries, and aÂ rendering strategy.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt needs fast markup, clean URLs, and maybe â€“ maybe â€“ aÂ bit of interactivity layered onÂ top.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd yet, on every project:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eA stakeholder says, â€œmake it feel like anÂ app.â€\u003c/li\u003e\n\n\n\n\u003cli\u003eA dev team reaches for Next.js orÂ Nuxt.\u003c/li\u003e\n\n\n\n\u003cli\u003eRouting goes client-side.\u003c/li\u003e\n\n\n\n\u003cli\u003ePerformance falls off aÂ cliff.\u003c/li\u003e\n\n\n\n\u003cli\u003eNow you need edge functions, streaming, ISR, loading strategies, and aÂ debugging plan.\u003c/li\u003e\n\n\n\n\u003cli\u003eAnd somehowâ€¦ it \u003cem\u003estill\u003c/em\u003e feels slower than aÂ regular link click and aÂ CSS animation.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThis isnâ€™t about being anti-framework. Itâ€™s about being intentional.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse React if you want. Use Tailwind, Vite, whatever. Just donâ€™t ship it all to the browser unless you \u003cem\u003eneed\u003c/em\u003e to.\u003c/p\u003e\n\n\n\n\u003cp\u003eBuild aÂ site like aÂ site. Use HTML. Use navigation. Use the platform.\u003c/p\u003e\n\n\n\n\u003cp\u003eItâ€™s faster, simpler, and better for everyone.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-build-for-the-web-we-have\"\u003eBuild for the web weÂ have\u003c/h2\u003e\n\n\n\n\u003cp\u003eSPAs were aÂ clever solution to aÂ temporary limitation. But that limitation no longer exists.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe nowÂ have:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eNative, declarative transitions between realÂ pages\u003c/li\u003e\n\n\n\n\u003cli\u003eInstantaneous prerendered navigation via Speculation Rules\u003c/li\u003e\n\n\n\n\u003cli\u003eGraceful degradation\u003c/li\u003e\n\n\n\n\u003cli\u003eClean markup, fast loads, and realÂ URLs\u003c/li\u003e\n\n\n\n\u003cli\u003eA platform that \u003cem\u003ewants\u003c/em\u003e to help â€“ if we letÂ it\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf youâ€™re still building your site as an SPA for the sake of â€œsmoothness,â€ youâ€™re solving aÂ problem the browser already fixed â€“ and youâ€™re paying for it in complexity, performance, and maintainability.\u003c/p\u003e\n\n\n\n\u003cp\u003eUse modern server rendering. Use actual pages. Animate with CSS. Preload with intent. Ship less JavaScript.\u003c/p\u003e\n\n\n\n\u003cp\u003eBuild like itâ€™s 2025 â€“ not like youâ€™re trapped in aÂ 2018 demo of Gatsby.\u003c/p\u003e\n\n\n\n\u003cp\u003eYouâ€™ll end up with faster sites, happier users, and fewer regrets.\u003c/p\u003e\n    \n    \n    \n    \n    \t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-07-24T21:07:49Z",
  "modifiedTime": "2025-07-25T09:37:56Z"
}
