{
  "id": "68a92bd9-5e07-447f-800b-86000e0197da",
  "title": "Phoenix.new – Remote AI Runtime for Phoenix",
  "link": "https://fly.io/blog/phoenix-new-the-remote-ai-runtime/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 20 Jun 2025 14:57:04 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 8023,
  "excerpt": "Documentation and guides from the team at Fly.io.",
  "siteName": "Fly",
  "favicon": "https://fly.io/static/images/favicon/apple-touch-icon.png",
  "text": "Author Name Chris McCord @chris_mccord @chris_mccord I’m Chris McCord, the creator of Elixir’s Phoenix framework. For the past several months, I’ve been working on a skunkworks project at Fly.io, and it’s time to show it off. I wanted LLM agents to work just as well with Elixir as they do with Python and JavaScript. Last December, in order to figure out what that was going to take, I started a little weekend project to find out how difficult it would be to build a coding agent in Elixir. A few weeks later, I had it spitting out working Phoenix applications and driving a full in-browser IDE. I knew this wasn’t going to stay a weekend project. If you follow me on Twitter, you’ve probably seen me teasing this work as it picked up steam. We’re at a point where we’re pretty serious about this thing, and so it’s time to make a formal introduction. World, meet Phoenix.new, a batteries-included fully-online coding agent tailored to Elixir and Phoenix. I think it’s going to be the fastest way to build collaborative, real-time applications. Let’s see it in action: What’s Interesting About Phoenix.new First, even though it runs entirely in your browser, Phoenix.new gives both you and your agent a root shell, in an ephemeral virtual machine (a Fly Machine) that gives our agent loop free rein to install things and run programs — without any risk of messing up your local machine. You don’t think about any of this; you just open up the VSCode interface, push the shell button, and there you are, on the isolated machine you share with the Phoenix.new agent. Second, it’s an agent system I built specifically for Phoenix. Phoenix is about real-time collaborative applications, and Phoenix.new knows what that means. To that end, Phoenix.new includes, in both its UI and its agent tools, a full browser. The Phoenix.new agent uses that browser “headlessly” to check its own front-end changes and interact with the app. Because it’s a full browser, instead of trying to iterate on screenshots, the agent sees real page content and JavaScript state – with or without a human present. What Root Access Gets Us Agents build software the way you did when you first got started, the way you still do today when you prototype things. They don’t carefully design Docker container layers and they don’t really do release cycles. An agent wants to pop a shell and get its fingernails dirty. A fully isolated virtual machine means Phoenix.new’s fingernails can get arbitrarily dirty. If it wants to add a package to mix.exs, it can do that and then run mix phx.server or mix test and check the output. Sure. Every agent can do that. But if it wants to add an APT package to the base operating system, it can do that too, and make sure it worked. It owns the whole environment. This offloads a huge amount of tedious, repetitive work. At his AI Startup School talk last week, Andrej Karpathy related his experience of building a restaurant menu visualizer, which takes camera pictures of text menus and transforms all the menu items into pictures. The code, which he vibe-coded with an LLM agent, was the easy part; he had it working in an afternoon. But getting the app online took him a whole week. With Phoenix.new, I’m taking dead aim at this problem. The apps we produce live in the cloud from the minute they launch. They have private, shareable URLs (we detect anything the agent generates with a bound port and give it a preview URL underneath phx.run, with integrated port-forwarding), they integrate with Github, and they inherit all the infrastructure guardrails of Fly.io: hardware virtualization, WireGuard, and isolated networks. Github’s gh CLI is installed by default. So the agent knows how to clone any repo, or browse issues, and you can even authorize it for internal repositories to get it working with your team’s existing projects and dependencies. Full control of the environment also closes the loop between the agent and deployment. When Phoenix.new boots an app, it watches the logs, and tests the application. When an action triggers an error, Phoenix.new notices and gets to work. Watch It Build In Real Time Phoenix.new can interact with web applications the way users do: with a real browser. The Phoenix.new environment includes a headless Chrome browser that our agent knows how to drive. Prompt it to add a front-end feature to your application, and it won’t just sketch the code out and make sure it compiles and lints. It’ll pull the app up itself and poke at the UI, simultaneously looking at the page content, JavaScript state, and server-side logs. Phoenix is all about “live” real-time interactivity, and gives us seamless live reload. The user interface for Phoenix.new itself includes a live preview of the app being worked on, so you can kick back and watch it build front-end features incrementally. Any other .phx.run tabs you have open also update as it goes. It’s wild. Not Just For Vibe Coding Phoenix.new can already build real, full-stack applications with WebSockets, Phoenix’s Presence features, and real databases. I’m seeing it succeed at business and collaborative applications right now. But there’s no fixed bound on the tasks you can reasonably ask it to accomplish. If you can do it with a shell and a browser, I want Phoenix.new to do it too. And it can do these tasks with or without you present. For example: set a $DATABASE_URL and tell the agent about it. The agent knows enough to go explore it with psql, and it’ll propose apps based on the schemas it finds. It can model Ecto schemas off the database. And if MySQL is your thing, the agent will just apt install a MySQL client and go to town. Frontier model LLMs have vast world knowledge. They generalize extremely well. At ElixirConfEU, I did a demo vibe-coding Tetris on stage. Phoenix.new nailed it, first try, first prompt. It’s not like there’s gobs of Phoenix LiveView Tetris examples floating around the Internet! But lots of people have published Tetris code, and lots of people have written LiveView stuff, and 2025 LLMs can connect those dots. At this point you might be wondering – can I just ask it to build a Rails app? Or an Expo React Native app? Or Svelte? Or Go? Yes, you can. Our system prompt is tuned for Phoenix today, but all languages you care about are already installed. We’re still figuring out where to take this, but adding new languages and frameworks definitely ranks highly in my plans. Our Async Agent Future We’re at a massive step-change in developer workflows. Agents can do real work, today, with or without a human present. Buckle up: the future of development, at least in the common case, probably looks less like cracking open a shell and finding a file to edit, and more like popping into a CI environment with agents working away around the clock. Local development isn’t going away. But there’s going to be a shift in where the majority of our iterations take place. I’m already using Phoenix.new to triage phoenix-core Github issues and pick problems to solve. I close my laptop, grab a cup of coffee, and wait for a PR to arrive — Phoenix.new knows how PRs work, too. We’re already here, and this space is just getting started. This isn’t where I thought I’d end up when I started poking around. The Phoenix and LiveView journey was much the same. Something special was there and the projects took on a life of their own. I’m excited to share this work now, and see where it might take us. I can’t wait to see what folks build. Previous post ↓ What are MCP Servers?",
  "image": "https://fly.io/blog/phoenix-new-the-remote-ai-runtime/assets/phoenixnew.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\n         \u003cdl\u003e\n             \u003cdt\u003eAuthor\u003c/dt\u003e\n             \u003cdd\u003e\n                 \u003cimg alt=\"Chris McCord\" src=\"https://fly.io/static/images/chris-m.webp\"/\u003e\n               \u003cdl\u003e\n                 \u003cdt\u003eName\u003c/dt\u003e\n                 \u003cdd\u003e\n                   Chris McCord\n                 \u003c/dd\u003e\n                  \u003cdt\u003e@chris_mccord\u003c/dt\u003e\n                  \u003cdd\u003e\n                    \u003ca href=\"https://twitter.com/chris_mccord\" target=\"_blank\"\u003e\n                      @chris_mccord\n                    \u003c/a\u003e\n                  \u003c/dd\u003e\n               \u003c/dl\u003e\n             \u003c/dd\u003e\n         \u003c/dl\u003e\n\n        \u003csection\u003e\n            \u003cfigure\u003e\n                \u003cimg src=\"https://fly.io/blog/phoenix-new-the-remote-ai-runtime/assets/phoenixnew.png\" alt=\"phoenix.new orb\"/\u003e\n            \u003c/figure\u003e\n          \u003cp\u003eI’m Chris McCord, the creator of Elixir’s Phoenix framework. For the past several months, I’ve been working on a skunkworks project at Fly.io, and it’s time to show it off.\u003c/p\u003e\n\u003cp\u003eI wanted LLM agents to work just as well with Elixir as they do with Python and JavaScript. Last December, in order to figure out what that was going to take, I started a little weekend project to find out how difficult it would be to build a coding agent in Elixir.\u003c/p\u003e\n\n\u003cp\u003eA few weeks later, I had it spitting out working Phoenix applications and driving a full in-browser IDE. I knew this wasn’t going to stay a weekend project.\u003c/p\u003e\n\n\u003cp\u003eIf you follow me on Twitter, you’ve probably seen me teasing this work as it picked up steam. We’re at a point where we’re pretty serious about this thing, and so it’s time to make a formal introduction.\u003c/p\u003e\n\n\u003cp\u003eWorld, meet \u003ca href=\"https://phoenix.new\" title=\"\"\u003ePhoenix.new\u003c/a\u003e, a batteries-included fully-online coding agent tailored to Elixir and Phoenix. I think it’s going to be the fastest way to build collaborative, real-time applications.\u003c/p\u003e\n\n\u003cp\u003eLet’s see it in action:\u003c/p\u003e\n\u003cdiv data-exclude-render=\"\"\u003e\n  \u003cp\u003e\n    \u003ciframe width=\"100%\" height=\"100%\" src=\"https://www.youtube.com/embed/du7GmWGUM5Y\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"\u003e\n    \u003c/iframe\u003e\n  \u003c/p\u003e\n\u003c/div\u003e\n\n\u003ch2 id=\"whats-interesting-about-phoenix-new\"\u003e\u003ca href=\"#whats-interesting-about-phoenix-new\" aria-label=\"Anchor\"\u003e\u003c/a\u003e\u003cspan\u003eWhat’s Interesting About Phoenix.new\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eFirst, even though it runs entirely in your browser, Phoenix.new gives both you and your agent a root shell, in an ephemeral virtual machine (a \u003ca href=\"https://fly.io/docs/machines/overview/\" title=\"\"\u003eFly Machine\u003c/a\u003e) that gives our agent loop free rein to install things and run programs  — without any risk of messing up your local machine. You don’t think about any of this; you just open up the VSCode interface, push the shell button, and there you are, on the isolated machine you share with the Phoenix.new agent.\u003c/p\u003e\n\n\u003cp\u003eSecond, it’s an agent system I built specifically for Phoenix. Phoenix is about real-time collaborative applications, and Phoenix.new knows what that means. To that end, Phoenix.new includes, in both its UI and its agent tools, a full browser. The Phoenix.new agent uses that browser “headlessly” to check its own front-end changes and interact with the app. Because it’s a full browser, instead of trying to iterate on screenshots, the agent sees real page content and JavaScript state – with or without a human present.\u003c/p\u003e\n\u003ch2 id=\"what-root-access-gets-us\"\u003e\u003ca href=\"#what-root-access-gets-us\" aria-label=\"Anchor\"\u003e\u003c/a\u003e\u003cspan\u003eWhat Root Access Gets Us\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003eAgents build software the way you did when you first got started, the way you still do today when you prototype things. They don’t carefully design Docker container layers and they don’t really do release cycles. An agent wants to pop a shell and get its fingernails dirty.\u003c/p\u003e\n\n\u003cp\u003eA fully isolated virtual machine means Phoenix.new’s fingernails can get \u003cem\u003earbitrarily dirty.\u003c/em\u003e If it wants to add a package to \u003ccode\u003emix.exs\u003c/code\u003e, it can do that and then run \u003ccode\u003emix phx.server\u003c/code\u003e or \u003ccode\u003emix test\u003c/code\u003e and check the output. Sure. Every agent can do that. But if it wants to add an APT package to the base operating system, it can do that too, and make sure it worked. It owns the whole environment.\u003c/p\u003e\n\n\u003cp\u003eThis offloads a huge amount of tedious, repetitive work.\u003c/p\u003e\n\n\u003cp\u003eAt his \u003ca href=\"https://youtu.be/LCEmiRjPEtQ?si=sR_bdu6-AqPXSNmY\u0026amp;t=1902\" title=\"\"\u003eAI Startup School talk last week\u003c/a\u003e, Andrej Karpathy related his experience of building a restaurant menu visualizer, which takes camera pictures of text menus and transforms all the menu items into pictures. The code, which he vibe-coded with an LLM agent, was the easy part; he had it working in an afternoon. But getting the app online took him a whole week.\u003c/p\u003e\n\n\u003cp\u003eWith Phoenix.new, I’m taking dead aim at this problem. The apps we produce live in the cloud from the minute they launch. They have private, shareable URLs (we detect anything the agent generates with a bound port and give it a preview URL underneath \u003ccode\u003ephx.run\u003c/code\u003e, with integrated port-forwarding), they integrate with Github, and they inherit all the infrastructure guardrails of Fly.io: hardware virtualization, WireGuard, and isolated networks.\u003c/p\u003e\n\u003cp\u003eGithub’s \u003ccode\u003egh\u003c/code\u003e CLI is installed by default. So the agent knows how to clone any repo, or browse issues, and you can even authorize it for internal repositories to get it working with your team’s existing projects and dependencies.\u003c/p\u003e\n\u003cp\u003eFull control of the environment also closes the loop between the agent and deployment. When Phoenix.new boots an app, it watches the logs, and tests the application. When an action triggers an error, Phoenix.new notices and gets to work.\u003c/p\u003e\n\u003ch2 id=\"watch-it-build-in-real-time\"\u003e\u003ca href=\"#watch-it-build-in-real-time\" aria-label=\"Anchor\"\u003e\u003c/a\u003e\u003cspan\u003eWatch It Build In Real Time\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://phoenix.new\" title=\"\"\u003ePhoenix.new\u003c/a\u003e can interact with web applications the way users do: with a real browser.\u003c/p\u003e\n\n\u003cp\u003eThe Phoenix.new environment includes a headless Chrome browser that our agent knows how to drive. Prompt it to add a front-end feature to your application, and it won’t just sketch the code out and make sure it compiles and lints. It’ll pull the app up itself and poke at the UI, simultaneously looking at the page content, JavaScript state, and server-side logs.\u003c/p\u003e\n\n\u003cp\u003ePhoenix is all about \u003ca href=\"https://fly.io/blog/how-we-got-to-liveview/\" title=\"\"\u003e“live” real-time\u003c/a\u003e interactivity, and gives us seamless live reload. The user interface for Phoenix.new itself includes a live preview of the app being worked on, so you can kick back and watch it build front-end features incrementally. Any other \u003ccode\u003e.phx.run\u003c/code\u003e tabs you have open also update as it goes. It’s wild.\u003c/p\u003e\n\u003cvideo title=\"agent interacting with web\" autoplay=\"autoplay\" loop=\"loop\" muted=\"muted\" playsinline=\"playsinline\" disablepictureinpicture=\"true\" src=\"https://fly.io/blog/phoenix-new-the-remote-ai-runtime/assets/webjs.mp4\"\u003e\u003c/video\u003e\n\n\u003ch2 id=\"not-just-for-vibe-coding\"\u003e\u003ca href=\"#not-just-for-vibe-coding\" aria-label=\"Anchor\"\u003e\u003c/a\u003e\u003cspan\u003eNot Just For Vibe Coding\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003ePhoenix.new can already build real, full-stack applications with WebSockets, Phoenix’s Presence features, and real databases. I’m seeing it succeed at business and collaborative applications right now.\u003c/p\u003e\n\n\u003cp\u003eBut there’s no fixed bound on the tasks you can reasonably ask it to accomplish. If you can do it with a shell and a browser, I want Phoenix.new to do it too. And it can do these tasks with or without you present.\u003c/p\u003e\n\n\u003cp\u003eFor example: set a \u003ccode\u003e$DATABASE_URL\u003c/code\u003e and tell the agent about it. The agent knows enough to go explore it with \u003ccode\u003epsql\u003c/code\u003e, and it’ll propose apps based on the schemas it finds. It can model Ecto schemas off the database. And if MySQL is your thing, the agent will just \u003ccode\u003eapt install\u003c/code\u003e a MySQL client and go to town.\u003c/p\u003e\n\n\u003cp\u003eFrontier model LLMs have vast world knowledge. They generalize extremely well. At ElixirConfEU, I did a \u003ca href=\"https://www.youtube.com/watch?v=ojL_VHc4gLk\u0026amp;t=3923s\" title=\"\"\u003edemo vibe-coding Tetris\u003c/a\u003e on stage. Phoenix.new nailed it, first try, first prompt. It’s not like there’s gobs of Phoenix LiveView Tetris examples floating around the Internet! But lots of people have published Tetris code, and lots of people have written LiveView stuff, and 2025 LLMs can connect those dots.\u003c/p\u003e\n\n\u003cp\u003eAt this point you might be wondering – can I just ask it to build a Rails app? Or an Expo React Native app? Or Svelte? Or Go?\u003c/p\u003e\n\n\u003cp\u003eYes, you can.\u003c/p\u003e\n\n\u003cp\u003eOur system prompt is tuned for Phoenix today, but all languages you care about are already installed. We’re still figuring out where to take this, but adding new languages and frameworks definitely ranks highly in my plans.\u003c/p\u003e\n\u003ch2 id=\"our-async-agent-future\"\u003e\u003ca href=\"#our-async-agent-future\" aria-label=\"Anchor\"\u003e\u003c/a\u003e\u003cspan\u003eOur Async Agent Future\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://fly.io/blog/youre-all-nuts/\" title=\"\"\u003eWe’re at a massive step-change in developer workflows\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAgents can do real work, today, with or without a human present. Buckle up: the future of development, at least in the common case, probably looks less like cracking open a shell and finding a file to edit, and more like popping into a CI environment with agents working away around the clock.\u003c/p\u003e\n\n\u003cp\u003eLocal development isn’t going away. But there’s going to be a shift in where the majority of our iterations take place. I’m already using Phoenix.new to triage \u003ccode\u003ephoenix-core\u003c/code\u003e Github issues and pick problems to solve. I close my laptop, grab a cup of coffee, and wait for a PR to arrive — Phoenix.new knows how PRs work, too. We’re already here, and this space is just getting started.\u003c/p\u003e\n\n\u003cp\u003eThis isn’t where I thought I’d end up when I started poking around. The Phoenix and LiveView journey was much the same. Something special was there and the projects took on a life of their own. I’m excited to share this work now, and see where it might take us. I can’t wait to see what folks build.\u003c/p\u003e\n\n          \n        \u003c/section\u003e\n        \u003cdl\u003e\n            \u003cdt\u003e\n              Previous post  ↓\n            \u003c/dt\u003e\n            \u003cdd\u003e\n              \u003ca href=\"https://fly.io/blog/mcps-everywhere/\"\u003e\n                What are MCP Servers?\n              \u003c/a\u003e\n            \u003c/dd\u003e\n        \u003c/dl\u003e\n      \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
