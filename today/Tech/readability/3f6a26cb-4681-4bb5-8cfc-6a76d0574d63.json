{
  "id": "3f6a26cb-4681-4bb5-8cfc-6a76d0574d63",
  "title": "First Report on the Pre-Scheme Restoration",
  "link": "https://prescheme.org/posts/first-report-on-the-pre-scheme-restoration.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 10 Oct 2024 11:47:01 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 9608,
  "excerpt": "It's been over 3 months since kicking off the Pre-Scheme Restoration project, so it's well and truly time for a progress update! I'm pleased to report that the bulk of the port to R7RS has been completed, with approximately 75% of the codebase successfully loading in 3 different R7RS-compatible Scheme implementations (Chibi, Sagittarius, and Guile) and 100% of the codebase running via a new R7RS compatibility layer for Scheme 48. The libraries which haven't yet been ported all directly interface with the Scheme expander front-end, and replacing that with a portable expander is the next major focus of the project. In the rest of this article I'll discuss the work that's been done to get to this point, and briefly outline the upcoming work.",
  "siteName": "",
  "favicon": "",
  "text": "It's been over 3 months since kicking off the Pre-Scheme Restoration project, so it's well and truly time for a progress update! I'm pleased to report that the bulk of the port to R7RS has been completed, with approximately 75% of the codebase successfully loading in 3 different R7RS-compatible Scheme implementations (Chibi, Sagittarius, and Guile) and 100% of the codebase running via a new R7RS compatibility layer for Scheme 48. The libraries which haven't yet been ported all directly interface with the Scheme expander front-end, and replacing that with a portable expander is the next major focus of the project. In the rest of this article I'll discuss the work that's been done to get to this point, and briefly outline the upcoming work.Retaining compatibility with Scheme 48One challenge with porting software is ensuring that errors aren't introduced during the porting process. The original Pre-Scheme compiler doesn't have an established test suite, so the only real test (aside from just loading the code) is to check that it continues to translate the Scheme 48 VM to identical C code. Being an end-to-end test, this requires the entire compiler to remain functioning throughout the porting process to verify that errors haven't been introduced. Any change breaking compatibility with the original platform would prevent the test from being run, and leave us in the painful situation of only being able to detect and debug errors after everything has been ported.To avoid this situation, I've developed \"The Incomplete Scheme48 R7RS Compatibility Library\" (s48-r7rs). While not a fully compliant R7RS implementation, it's compatible enough to allow Scheme 48 to load R7RS library definitions from the filesystem, and use cond-expand to paper over implementation differences. This has allowed me to keep the end-to-end test passing throughout the porting process, and debug any errors as they're introduced. The compatibility layer also includes an implementation of SRFI 64, forming the basis of a portable test suite which will continue to be expanded as the project progresses.Using Scsh as a tooling platformWhile Scheme 48 includes a lot of functionality, it lacks some conveniences for \"scripting\" work, so I adopted Scsh as the platform for the tooling used during the port (ps-workbench). Scsh is built on top of Scheme 48, so is capable of loading the original Pre-Scheme compiler and performing introspection, while also providing better support for dealing with the filesystem and external processes. The R7RS compatibility layer also works with Scsh, and might be useful for any future efforts porting Scsh functionality to other Scheme implementations. I don't intend for Scsh (or Scheme 48) to be a hard dependency of Pre-Scheme, so much of this tooling is temporary, but might still be of some interest.Implementing R7RS-small for Scheme 48Scheme 48 is a complete R5RS implementation, so already includes the majority of functionality needed for R7RS-small. Implementing the initial compatibility layer was mainly a matter of implementing a loader for R7RS library definitions, and defining the core libraries as Scheme 48 modules which re-export these existing procedures. The Scheme 48 module system was in fact an inspiration for the design of R7RS libraries; the systems are similar enough that R7RS libraries can be implemented as a syntactic layer over the procedural module interface. To aid in generating the core library definitions I implemented a parser for the Scheme Index data-set, allowing the lists of exported identifiers to be generated at an Scsh REPL.Porting the Pre-Scheme compiler to s48-r7rsThe bulk of the Pre-Scheme compiler depends on Scheme 48's big-scheme structure, which provides an extended Scheme environment with useful functionality not covered by the standard, such as hash-tables, list-queues, and a format routine. Porting to R7RS was a matter of replacing big-scheme imports with r7rs-base (aka. (scheme base)), and adding missing dependencies as indicated by compiler diagnostics and test failures. Non-standard dependencies have been factored out as separate libraries in the (ps-compiler util) namespace where they can be implemented using whatever equivalents are available in the target Scheme implementations. For example, the (ps-compiler util queues) library exports the Scheme 48 queues interface, using (ice-9 q) on Guile and SRFI 117 on Chibi and Sagittarius. These utility libraries separate the core of the Pre-Scheme compiler from the differences of the target Scheme implementations, and provide a convenient point for test coverage.Porting Pre-Scheme compiler macrosScheme 48 provides an \"explicit renaming\" procedural macro system with the ability to break hygiene, and the Pre-Scheme compiler makes use of this for some of its internal macros. This presents a portability issue because R7RS-small (as with R5RS) only standardizes hygienic syntax-rules macros. In practice, most R7RS implementations offer procedural macros via either er-macro-transformer (ie. explicit renaming macros) or syntax-case (standardized in R6RS). My solution has been to re-implement all of these internal macros with syntax-case, and ship both versions along with SRFI 211 stubs which can be used to select the appropriate implementation for the target Scheme. An example of this is the (ps-compiler util enums) library, which provides a define-enumeration macro used internally in the compiler, and also exposed as part of the Pre-Scheme language.Porting Pre-Scheme library definitionsScheme 48 structures and R7RS libraries are similar enough that we can generate the equivalent library definition for a structure using the procedural module interface. This is a matter of loading the Pre-Scheme codebase into Scsh, iterating through the loaded modules to identify the Pre-Scheme modules, using introspection to build export/import/include lists, and pretty-printing a library definition file. A subtle difference between Scheme 48 structures and R7RS libraries is that a structure is a view into a package (an environment), and multiple structures can be backed by the same package. I've simulated this architecture by making \"view\" libraries which simply re-export a subset of an underlying \"impl\" library, as can be seen with the parameters and set-parameters interfaces to the parameters-impl library, replicating the structure definitions here.Initial target implementationsThe current target implementations for this port (aside from s48-r7rs) are Chibi Scheme, Sagittarius Scheme, and Guile. These implementations all support the de-facto standard filesystem layout for R7RS libraries, with directories matching namespaces and library definitions in .sld files, which makes them easy to support from the same source tree. They also offer a mix of er-macro-transformer (Chibi \u0026 Sagittarius) and syntax-case (Guile \u0026 Sagittarius) macro systems, and some variety in the set of supported SRFIs and implementation-specific libraries. I believe this selection gives \"just enough\" difference to ensure that the project architecture is flexible enough to support a variety of implementations, without getting overwhelmed by platform-specific concerns. Support for more implementations will be added as the project matures and a test-suite coalesces.Next steps: Portable expander, tests, and documentationWith the bulk of the libraries converted, my immediate focus is now on integrating Unsyntax as the portable expander for Pre-Scheme, replacing the current integration with Scheme 48's expander as the front-end for the Pre-Scheme compiler. Unsyntax is particularly interesting as it's a modern and compliant Scheme implementation which is itself implemented in Scheme, and designed to run on top of other Scheme implementations. It works by expanding/compiling R7RS Scheme with syntax-case macros to a simpler Scheme subset that can run on a less sophisticated host implementation. This is exactly what's required for the front-end of the Pre-Scheme compiler, which will take that subset, translate it into the compiler's AST, perform type inference and static type checking, and ultimately compile the resulting program to C.Unsyntax currently only supports Chibi Scheme as a host implementation, however an initial analysis suggests that it's only reliant on a handful of SRFIs (boxes, hash-tables, comparators, and generators) and a single non-portable feature (Chibi's type-printers, known as \"disclosers\" in Scheme 48). This should be fairly easy to port to s48-r7rs, where I can experiment with how best to wrap up its expander for use with the Pre-Scheme compiler. There is community interest in using Unsyntax with other Scheme implementations outside of this project, so I'll be documenting my efforts and contributing upstream as appropriate.Aside from the expander, I'll continue to expand the Pre-Scheme compiler's test coverage and begin work on documenting its internal architecture. Having a decent test-suite and documentation in-place will be essential for the later stages of this project involving modifications to the type system and extensions to the core language.If you are interested in following this project, you can follow me or #prescheme on the fediverse, subscribe to the Atom feed or RSS feed, or join us in the #guile-steel channel on IRC. Repositories for the port, this website, and related projects can be found on Codeberg. Please feel free to get in touch via any of these channels with any questions about this project or related projects, I'll be happy to help.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eIt\u0026#39;s been over 3 months since kicking off the Pre-Scheme Restoration\nproject, so it\u0026#39;s well and truly time for a progress update!  I\u0026#39;m pleased\nto report that the bulk of the port to R7RS has been completed, with\napproximately 75% of the codebase successfully loading in 3 different\nR7RS-compatible Scheme implementations (Chibi, Sagittarius, and Guile)\nand 100% of the codebase running via a new R7RS compatibility layer for\nScheme 48.  The libraries which haven\u0026#39;t yet been ported all directly\ninterface with the Scheme expander front-end, and replacing that with a\nportable expander is the next major focus of the project.  In the rest\nof this article I\u0026#39;ll discuss the work that\u0026#39;s been done to get to this\npoint, and briefly outline the upcoming work.\u003c/p\u003e\u003ch2\u003eRetaining compatibility with Scheme 48\u003c/h2\u003e\u003cp\u003eOne challenge with porting software is ensuring that errors aren\u0026#39;t\nintroduced during the porting process.  The original Pre-Scheme compiler\ndoesn\u0026#39;t have an established test suite, so the only real test (aside\nfrom just loading the code) is to check that it continues to translate\nthe Scheme 48 VM to identical C code.  Being an end-to-end test, this\nrequires the entire compiler to remain functioning throughout the\nporting process to verify that errors haven\u0026#39;t been introduced.  Any\nchange breaking compatibility with the original platform would prevent\nthe test from being run, and leave us in the painful situation of only\nbeing able to detect and debug errors after everything has been ported.\u003c/p\u003e\u003cp\u003eTo avoid this situation, I\u0026#39;ve developed \u003cem\u003e\u0026#34;The Incomplete Scheme48 R7RS\nCompatibility Library\u0026#34;\u003c/em\u003e (\u003ca href=\"https://codeberg.org/prescheme/s48-r7rs\"\u003es48-r7rs\u003c/a\u003e).  While not a fully\ncompliant R7RS implementation, it\u0026#39;s compatible enough to allow Scheme 48\nto load R7RS library definitions from the filesystem, and use\n\u003ccode\u003econd-expand\u003c/code\u003e to paper over implementation differences.  This has\nallowed me to keep the \u003ca href=\"https://codeberg.org/prescheme/ps-workbench/src/branch/main/scripts/s48-compile-vm.scm\"\u003eend-to-end test\u003c/a\u003e passing\nthroughout the porting process, and debug any errors as they\u0026#39;re\nintroduced.  The compatibility layer also includes an implementation of\n\u003ca href=\"https://srfi.schemers.org/srfi-64/srfi-64.html\"\u003eSRFI 64\u003c/a\u003e, forming the basis of a portable test suite which\nwill continue to be expanded as the project progresses.\u003c/p\u003e\u003ch2\u003eUsing Scsh as a tooling platform\u003c/h2\u003e\u003cp\u003eWhile Scheme 48 includes a lot of functionality, it lacks some\nconveniences for \u0026#34;scripting\u0026#34; work, so I adopted \u003ca href=\"https://scsh.net/\"\u003eScsh\u003c/a\u003e as the\nplatform for the tooling used during the port\n(\u003ca href=\"https://codeberg.org/prescheme/ps-workbench\"\u003eps-workbench\u003c/a\u003e).  Scsh is built on top of Scheme 48, so\nis capable of loading the original Pre-Scheme compiler and performing\nintrospection, while also providing better support for dealing with the\nfilesystem and external processes.  The R7RS compatibility layer also\nworks with Scsh, and might be useful for any future efforts porting Scsh\nfunctionality to other Scheme implementations.  I don\u0026#39;t intend for Scsh\n(or Scheme 48) to be a hard dependency of Pre-Scheme, so much of this\ntooling is temporary, but might still be of some interest.\u003c/p\u003e\u003ch2\u003eImplementing R7RS-small for Scheme 48\u003c/h2\u003e\u003cp\u003eScheme 48 is a complete R5RS implementation, so already includes the\nmajority of functionality needed for R7RS-small.  Implementing the\ninitial compatibility layer was mainly a matter of implementing a\n\u003ca href=\"https://codeberg.org/prescheme/s48-r7rs/src/branch/main/scheme/r7rs/libraries.scm\"\u003eloader\u003c/a\u003e for R7RS library definitions, and defining the\n\u003ca href=\"https://codeberg.org/prescheme/s48-r7rs/src/branch/main/scheme/r7rs/packages.scm\"\u003ecore libraries\u003c/a\u003e as Scheme 48 modules which re-export\nthese existing procedures.  The \u003ca href=\"https://prescheme.org/papers/s48-modules.pdf\"\u003eScheme 48 module system\u003c/a\u003e\nwas in fact an inspiration for the \u003ca href=\"https://github.com/johnwcowan/r7rs-work/blob/master/ModulesShinn.md\"\u003edesign of R7RS\nlibraries\u003c/a\u003e; the systems are similar enough that R7RS\nlibraries can be implemented as a syntactic layer over the procedural\nmodule interface.  To aid in generating the core library definitions I\nimplemented a \u003ca href=\"https://codeberg.org/prescheme/ps-workbench/src/branch/main/scsh-lib/scm-index.scm\"\u003eparser\u003c/a\u003e for the \u003ca href=\"https://index.scheme.org/\"\u003eScheme\nIndex\u003c/a\u003e data-set, allowing the lists of exported identifiers\nto be generated at an Scsh REPL.\u003c/p\u003e\u003ch2\u003ePorting the Pre-Scheme compiler to s48-r7rs\u003c/h2\u003e\u003cp\u003eThe bulk of the Pre-Scheme compiler depends on Scheme 48\u0026#39;s \u003cem\u003ebig-scheme\u003c/em\u003e\nstructure, which provides an extended Scheme environment with useful\nfunctionality not covered by the standard, such as hash-tables,\nlist-queues, and a format routine.  Porting to R7RS was a matter of\nreplacing \u003cem\u003ebig-scheme\u003c/em\u003e imports with \u003cem\u003er7rs-base\u003c/em\u003e (aka. \u003cem\u003e(scheme base)\u003c/em\u003e),\nand adding missing dependencies as indicated by compiler diagnostics and\ntest failures.  Non-standard dependencies have been factored out as\nseparate libraries in the \u003cem\u003e(ps-compiler util)\u003c/em\u003e namespace where they can\nbe implemented using whatever equivalents are available in the target\nScheme implementations.  For example, the \u003ca href=\"https://codeberg.org/prescheme/prescheme/src/branch/main/ps-compiler/util/queues.sld\"\u003e(ps-compiler util\nqueues)\u003c/a\u003e library exports the Scheme 48 \u003cem\u003equeues\u003c/em\u003e\ninterface, using \u003ca href=\"https://www.gnu.org/software/guile/manual/html_node/Queues.html\"\u003e(ice-9 q)\u003c/a\u003e on Guile and \u003ca href=\"https://srfi.schemers.org/srfi-117/srfi-117.html\"\u003eSRFI\n117\u003c/a\u003e on Chibi and Sagittarius.  These utility libraries\nseparate the core of the Pre-Scheme compiler from the differences of the\ntarget Scheme implementations, and provide a convenient point for test\ncoverage.\u003c/p\u003e\u003ch2\u003ePorting Pre-Scheme compiler macros\u003c/h2\u003e\u003cp\u003eScheme 48 provides an \u0026#34;explicit renaming\u0026#34; procedural macro system with\nthe ability to break hygiene, and the Pre-Scheme compiler makes use of\nthis for some of its internal macros.  This presents a portability issue\nbecause R7RS-small (as with R5RS) only standardizes hygienic\n\u003ccode\u003esyntax-rules\u003c/code\u003e macros.  In practice, most R7RS implementations offer\nprocedural macros via either \u003ccode\u003eer-macro-transformer\u003c/code\u003e (ie. explicit\nrenaming macros) or \u003ccode\u003esyntax-case\u003c/code\u003e (standardized in R6RS).  My solution\nhas been to re-implement all of these internal macros with\n\u003ccode\u003esyntax-case\u003c/code\u003e, and ship both versions along with \u003ca href=\"https://srfi.schemers.org/srfi-211/srfi-211.html\"\u003eSRFI 211\u003c/a\u003e\nstubs which can be used to select the appropriate implementation for the\ntarget Scheme.  An example of this is the \u003ca href=\"https://codeberg.org/prescheme/prescheme/src/branch/main/ps-compiler/util/enums.sld\"\u003e(ps-compiler util\nenums)\u003c/a\u003e library, which provides a\n\u003ccode\u003edefine-enumeration\u003c/code\u003e macro used internally in the compiler, and also\nexposed as part of the Pre-Scheme language.\u003c/p\u003e\u003ch2\u003ePorting Pre-Scheme library definitions\u003c/h2\u003e\u003cp\u003eScheme 48 structures and R7RS libraries are similar enough that we can\n\u003ca href=\"https://codeberg.org/prescheme/ps-workbench/src/branch/main/scripts/ps-library-definitions.scm\"\u003egenerate\u003c/a\u003e the equivalent library definition for a\nstructure using the procedural module interface.  This is a matter of\nloading the Pre-Scheme codebase into Scsh, iterating through the loaded\nmodules to identify the Pre-Scheme modules, using introspection to build\nexport/import/include lists, and pretty-printing a library definition\nfile.  A subtle difference between Scheme 48 structures and R7RS\nlibraries is that a structure is a view into a package (an environment),\nand multiple structures can be backed by the same package.  I\u0026#39;ve\nsimulated this architecture by making \u0026#34;view\u0026#34; libraries which simply\nre-export a subset of an underlying \u0026#34;impl\u0026#34; library, as can be seen with\nthe \u003ca href=\"https://codeberg.org/prescheme/prescheme/src/branch/main/ps-compiler/parameters.sld\"\u003eparameters\u003c/a\u003e and\n\u003ca href=\"https://codeberg.org/prescheme/prescheme/src/branch/main/ps-compiler/set-parameters.sld\"\u003eset-parameters\u003c/a\u003e interfaces to the\n\u003ca href=\"https://codeberg.org/prescheme/prescheme/src/branch/main/ps-compiler/parameters-impl.sld\"\u003eparameters-impl\u003c/a\u003e library, replicating the\nstructure definitions \u003ca href=\"https://codeberg.org/prescheme/prescheme/src/commit/701e61e922c7dd63232d268d600e339d706b0212/ps-compiler/package-defs.scm#L121\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eInitial target implementations\u003c/h2\u003e\u003cp\u003eThe current target implementations for this port (aside from s48-r7rs)\nare \u003ca href=\"https://github.com/ashinn/chibi-scheme\"\u003eChibi Scheme\u003c/a\u003e, \u003ca href=\"https://bitbucket.org/ktakashi/sagittarius-scheme/wiki/Home\"\u003eSagittarius Scheme\u003c/a\u003e, and\n\u003ca href=\"https://www.gnu.org/software/guile/\"\u003eGuile\u003c/a\u003e.  These implementations all support the de-facto standard\nfilesystem layout for R7RS libraries, with directories matching\nnamespaces and library definitions in \u003ccode\u003e.sld\u003c/code\u003e files, which makes them\neasy to support from the same source tree.  They also offer a mix of\n\u003ccode\u003eer-macro-transformer\u003c/code\u003e (Chibi \u0026amp; Sagittarius) and \u003ccode\u003esyntax-case\u003c/code\u003e (Guile \u0026amp;\nSagittarius) macro systems, and some variety in the set of supported\nSRFIs and implementation-specific libraries.  I believe this selection\ngives \u0026#34;just enough\u0026#34; difference to ensure that the project architecture\nis flexible enough to support a variety of implementations, without\ngetting overwhelmed by platform-specific concerns.  Support for more\nimplementations will be added as the project matures and a test-suite\ncoalesces.\u003c/p\u003e\u003ch2\u003eNext steps: Portable expander, tests, and documentation\u003c/h2\u003e\u003cp\u003eWith the bulk of the libraries converted, my immediate focus is now on\nintegrating \u003ca href=\"https://www.unsyntax.org/\"\u003eUnsyntax\u003c/a\u003e as the portable expander for\nPre-Scheme, replacing the current integration with Scheme 48\u0026#39;s expander\nas the front-end for the Pre-Scheme compiler.  Unsyntax is particularly\ninteresting as it\u0026#39;s a modern and compliant Scheme implementation which\nis itself implemented in Scheme, and designed to run on top of other\nScheme implementations.  It works by expanding/compiling R7RS Scheme\nwith \u003ccode\u003esyntax-case\u003c/code\u003e macros to a simpler Scheme subset that can run on a\nless sophisticated host implementation.  This is exactly what\u0026#39;s required\nfor the front-end of the Pre-Scheme compiler, which will take that\nsubset, translate it into the compiler\u0026#39;s AST, perform type inference and\nstatic type checking, and ultimately compile the resulting program to C.\u003c/p\u003e\u003cp\u003eUnsyntax currently only supports Chibi Scheme as a host implementation,\nhowever an initial analysis suggests that it\u0026#39;s only reliant on a handful\nof SRFIs (boxes, hash-tables, comparators, and generators) and a single\nnon-portable feature (Chibi\u0026#39;s type-printers, known as \u0026#34;disclosers\u0026#34; in\nScheme 48).  This should be fairly easy to port to s48-r7rs, where I can\nexperiment with how best to wrap up its expander for use with the\nPre-Scheme compiler.  There is community interest in using Unsyntax with\nother Scheme implementations outside of this project, so I\u0026#39;ll be\ndocumenting my efforts and contributing upstream as appropriate.\u003c/p\u003e\u003cp\u003eAside from the expander, I\u0026#39;ll continue to expand the Pre-Scheme\ncompiler\u0026#39;s test coverage and begin work on documenting its internal\narchitecture.  Having a decent test-suite and documentation in-place\nwill be essential for the later stages of this project involving\nmodifications to the type system and extensions to the core language.\u003c/p\u003e\u003cp\u003eIf you are interested in following this project, you can \u003ca href=\"https://functional.cafe/@flatwhatson\"\u003efollow\nme\u003c/a\u003e or \u003ca href=\"https://fosstodon.org/tags/prescheme\"\u003e#prescheme\u003c/a\u003e on the fediverse,\nsubscribe to the \u003ca href=\"https://prescheme.org/atom.xml\"\u003eAtom feed\u003c/a\u003e or \u003ca href=\"https://prescheme.org/rss.xml\"\u003eRSS\nfeed\u003c/a\u003e, or join us in the \u003ca href=\"https://web.libera.chat/#guile-steel\"\u003e#guile-steel\u003c/a\u003e\nchannel on IRC.  Repositories for the port, this website, and related\nprojects can be found \u003ca href=\"https://codeberg.org/prescheme/\"\u003eon Codeberg\u003c/a\u003e.  Please feel free to\nget in touch via any of these channels with any questions about this\nproject or related projects, I\u0026#39;ll be happy to help.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
