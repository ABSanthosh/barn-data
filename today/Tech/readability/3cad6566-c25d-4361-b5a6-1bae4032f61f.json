{
  "id": "3cad6566-c25d-4361-b5a6-1bae4032f61f",
  "title": "Let's Learn x86-64 Assembly Part 0 â€“ Setup and First Steps",
  "link": "https://gpfault.net/posts/asm-tut-0.txt.html",
  "description": "Comments",
  "author": "",
  "published": "Sun, 13 Jul 2025 22:22:15 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 25143,
  "excerpt": "published on Apr 18 2020",
  "siteName": "",
  "favicon": "https://gpfault.net/apple-touch-icon.png",
  "text": "Let's Learn x86-64 Assembly! Part 0 - Setup and First Steps published on Apr 18 2020 The way I was taught x86 assembly at the university had been completely outdated for many years by the time I had my first class. It was around 2008 or 2009, and 64-bit processors had already started becoming a thing even in my neck of the woods. Meanwhile, we were doing DOS, real-mode, memory segmentation and all the other stuff from the bad old days. Nevertheless, I picked up enough of it during the classes (and over the subsequent years) to be able to understand the stuff coming out of the other end of a compiler, and that has helped me a few times. However, I've never manually written any substantial amount of x86 assembly for something non-trivial. Due to being locked up inside (on account of a global pandemic), I decided to change that situation, to pass the time. I wanted to focus on x86-64 specifically, and completely forget/skip any and all legacy crap that is no longer relevant for this architecture. After getting a bit deeper into it, I also decided to publish my notes in the form of tutorials on this blog since there seems to be a desire for this type of content. Everything I write in these posts will be a normal, 64-bit, Windows program. We'll be using Windows because that is the OS I'm running on all of my non-work machines, and when you drop down to the level of writing assembly it starts becoming incresingly impossible to ignore the operating system you're running on. I will also try to go as \"from scratch\" as possible - no libraries, we're only allowed to call out to the operating system and that's it. In this first, introductory part (yeah, I'm planning a series and I know I will regret this later), I will talk about the tools we will need, show how to use them, explain how I generally think about programming in assembly and show how to write what is perhaps the smallest viable Windows program. Getting the Tools There are two main tools that we will use throughout this series. Assembler CPUs execute machine code - an efficient representation of instructions for the processor that is almost completely impenetrable to humans. The assembly language is a human-readable representation of it. A program that converts this symbolic representation into machine code ready to be executed by a CPU is called an assembler. There is no single, agreed-upon standard for x86-64 assembly language. There are many assemblers out there, and even though some of them share a great deal of similarities, each has its own set of features and quirks. It is therefore important which assembler you choose. In this series, we will be using Flat Assembler (or FASM for short). I like it because it's small, easy to obtain and use, has a nice macro system and comes with a handy little editor. Debugger Another important tool is the debugger. We'll use it to examine the state of our programs. While I'm pretty sure it's possible to use Visual Studio's integrated debugger for this, I think a standalone debugger is better when all you want to do is look at the disassembly, memory and registers. I've always used OllyDbg for stuff like that, but unfortunately it does not have a 64-bit version. Therefore we will be using WinDbg. The version linked here is a revamp of this venerable tool with a slightly nicer interface. Alternatively, you can get the non-Windows-store version here as part of the Windows 10 SDK. Just make sure you deselect everything else besides WinDbg during installation. For our purposes, the two versions are mostly interchangeable. Thinking in Assembly Now that we have our tools, I want to spend a bit of time to discuss some basics. For the purpose of these tutorials I'm assuming some knowledge of languages like C or C++, but little or no previous exposure to assembly, therefore many readers will find this stuff familiar. A 10000-foot view CPUs only \"know\" how to do a fixed number of certain things. When you hear someone talk about an \"instruction set\", they're referring to the set of things a particular CPU has been designed to do, and the term \"instruction\" just means \"one of the things a CPU can do\". Most instructions are parameterized in one way or another, and they're generally really simple. Usually an instruction is somthing along the lines of \"write a given 8-bit value to a given location in memory\", or \"interpreting the values from registers A and B as 16-bit signed integers, multiply them and record the result into register A\". Below is a simple mental model of the architecture that we'll start with. This skips a ton of things (there can be more than one core executing instructions and reading/writing memory, there's different levels of cache, etc. etc.), but should serve as a good starting point. To be effective at low-level programming or debugging you need to understand that every high-level concept eventually maps to this low-level model, and learning how the mapping works will help you. Registers You can think of registers as a special kind of memory built right into the CPU that is very small, but extremely fast to access. There are many different kinds of registers in x86-64, and for now we'll concern ourselves only with the so-called general-purpose registers, of which there are sixteen. Each of them is 64 bits wide, and for each of them the lower byte, word and double-word can be addressed individually (incidentally, 1 \"word\" = 2 bytes, 1 \"double-word\" = 4 bytes, in case you haven't heard this terminology before). Register Lower byte Lower word Lower dword rax al ax eax rbx bl bx ebx rcx cl cx ecx rdx dl dx edx rsp spl sp esp rsi sil si esi rdi dil di edi rbp bpl bp ebp r8 r8b r8w r8d r9 r9b r9w r9d r10 r10b r10w r10d r11 r11b r11w r11d r12 r12b r12w r12d r13 r13b r13w r13d r14 r14b r14w r14d r15 r15b r15w r15d Additionally, the higher 8 bits of rax, rbx, rcx and rdx can be referred to as ah, bh, ch and dh. Note that even though I said those were \"general-purpose\" registers, some instructions can only be used with certain registers, and some registers have special meaning for certain instructions. In particular, rsp holds the stack pointer (which is used by instructions like push, pop, call and ret), and rsi and rdi serve as source and destination index for \"string manipulation\" instructions. Another example where certain registers get \"special treatment\" are the multiplication instructions, which require one of the multiplier values to be in the register rax, and write the result into the pair of registers rax and rdx. In addition to these registers, we will also consider the special registers rip and rflags. rip holds the address of the next instruction to execute. It is modified by control flow instructions like call or jmp. rflags holds a bunch of binary flags indicating various aspects of the program's state, such as whether the result of the last arithmetic operation was less, equal or greater than zero. The behavior of many instructions depends on those flags, and many instructions update certain flags as part of their execution. The flags register can also be read and written \"wholesale\" using special instructions. There are a lot more registers on x86-64. Most of them are used for SIMD or floating-point instructions, and we'll not be considering them in this series. Memory and Addresses You can think of memory as a large array of byte-sized \"cells\", numbered starting at 0. We'll call these numbers \"memory addresses\". Simple, right? Well... addressing memory used to be rather annoying back in the old days. You see, registers in old x86 processors used to be only 16-bit wide. Sixteen bits is enough to address 64 kilobytes worth of memory, but not more. The hardware was actually capable of using addresses as wide as 20 bits, but you had put a \"base\" address into a special segment register, and instructions that read or wrote memory would use a 16-bit offset into that segment to obtain the final 20-bit \"linear\" address. There were separate segment registers for code, data and stack portions (and a few more \"extra\" ones), and segments could overlap. In x86-64 these concerns are non-existant. The segment registers for code, data and stack are still present, and they're loaded with some special values, but as a user-space programmer you needn't concern yourself with them. For all intents and purposes you can assume that all segments start at 0 and extend for the entire addressable length of memory. So, as far as we're concerned, on x86-64 our programs see memory as a \"flat\" contiguous array of bytes, with sequential addresses, starting at 0, just like we said in the beginning of this section... Okay, I may have distorted the truth a little bit. Things aren't quite as simple. While it is true that on 64-bit Windows your programs see memory as a flat contiguous array of bytes with addresses starting at 0, it is actually an elaborate illusion maintained by the OS and CPU working together. The truth is, if you were really able to read and write any byte in memory willy-nilly, you'd stomp all over other programs' code and data (something that indeed could happen in the Bad Old Days). To prevent that, special protection mechanisms exist. I won't get too deep into their inner workings here because this stuff matters mostly for OS developers. Nevertheless, here's a very short overview: Each process gets a \"flat\" address space as described above (we'll call it the \"virtual address space\"). For each process, the OS sets up a mapping between its virtual addresses and actual physical addresses in memory. This mapping is respected by the hardware: the \"virtual\" addresses get translated to physical addresses dynamically at runtime. Thus, the same address (e.g. 0x410F119C) can map to two different locations in physical memory for two different processes. This, in a nutshell, is how the separation between processes in enforced. The final thing I want to invite your attention to here is how the instructions and data which they operate on are held in the same memory. While it may seem an obvious choice, it's not how computers necessarily have to work. This is a property characteristic of the von Neumann model - as opposed to the Harvard model, where instructions and data are held in separate memories. A real-world example of a Harvard computer is the AVR microcontroller on your Arduino. Our First Program Hopefully by this point you have downloaded FASM and are ready to write some code. Our first program will be really simple: it will load and then immediately exit. We mostly want it just to get acquainted with the tools. Here's the code for our first program in x86-64 assembly: format PE64 NX GUI 6.0 entry start section '.text' code readable executable start: int3 ret Analyzing the Code We'll go through this line-by-line. format PE64 NX GUI 6.0 - this is a directive telling FASM the format of the binary we expect it to produce - in our case, Portable Executable Format (which is what most Windows programs use). We'll talk about it in a bit more detail later. entry start - this defines the entry point into our program. The entry directive requires a label, which in this case is \"start\". A label can be thought of as a name for an address within our program, so in this case we're saying \"the entry point to the program is at whatever address the 'start' label is\". Note that you're allowed to refer to labels even if they're defined later in the program code (as is the case here). section '.text' code readable executable - this directive indicates the beginning of a new section in a Portable Executable file, in this case a section containing executable code. More on this later. start: - this is the label that denotes the entry point to our program. We referred to it earlier in the \"entry\" directive. Note that labels themselves don't produce any executable machine code: they're just a way for the programmer to mark locations within the executable's address space. int3 - this is a special instruction that causes the program to call the debug exception handler - when running under a debugger, this will pause the program and allow us to examine its state or proceed with the execution step-by-step. This is how breakpoints are actually implemented - the debugger replaces a single byte in the executable with the opcode corresponding to int3, and when the program hits it, the debugger takes over (obviously, the original content of the memory at breakpoint address has to be remembered and restored before proceeding with execution or single-stepping). In our case, we are hard-coding a breakpoint immediately at the entry point for convenience, so that we don't have to set it manually via the debugger every time. ret - this instruction pops off an address from the top of the stack, and transfers execution to that address. In our case, we'll return into the OS code that initially invoked our entry point. Fire up FASMW.EXE, paste the code above into the editor, save the file and press Ctrl+F9. Your first assembly program is now complete! Let's now load it up in a debugger and single-step through it to see it actually working. Using the Debugger Open up WinDbg. Go to the View tab and make sure the following windows are visible: Disassembly, Registers, Stack, Memory and Command. Go to File \u003e Launch Executable and select the executable you just built with FASM. At this point your workspace should resemble something like this: In the disassembly window you can see the code that is currently being executed. Right now it's not our program's code, but some OS loader code - this stuff will load our program into memory and eventually transfer execution to our entry point. WinDbg ensures a breakpoint is triggered before any of that happens. In the registers window, you can see the contents of x86-64 registers that we discussed earlier. The memory window shows the raw content of the program's memory around a given virtual address. We'll use it later. The stack window shows the current call stack (as you can see, it's all inside ntdll.dll right now). Finally, the command window allows entering text commands and shows log messages. If you press F5 at this time, it will cause the program to continue running until it hits another breakpoint. The next breakpoint it will hit is the one we hardcoded. Try pressing F5, and you'll see something like this: You should be able to recognize the two instructions we wrote - int3 and ret. To advance to the next instruction, press F8. When you do that, pay attention to the registers window - you should see the rip register being updated as you advance (WinDbg highlights the registers that change in red). Right after the ret instruction is executed, you will return to the code that invoked our program's entry point. As you can see from the image above, the next thing that will happen is a call to RtlExitUserThread (a pretty self-explanatory name). If you press F5 now, your program's main thread will clean up and end, and so will the program. Or will it?... The truth is, by using ret, I took a bit of a shortcut. On Windows a process will terminate if any of the following conditions are met: Any thread calls the WinAPI function ExitProcess explicitly All threads have exited But, we're exiting the main thread here so we should be good, right? Well, sort of. There's no guarantee that Windows hasn't started any other background threads (for example, to load DLLs or something like that) within our process. It seems that at least in this example, the main thread is the only one (I've checked and the process doesn't stick around), but this may change. A well-behaved Windows program should always call ExitProcess at the appropriate time. In order to be able to call WinAPI functions, we need to learn a few things about the Portable Executable file format, how DLLs are loaded and calling conventions. The PE Format and DLL Imports The ExitProcess function lives in KERNEL32.DLL (yes, that's not a typo, KERNEL32 is the name of the 64-bit library. The 32-bit versions of those libs provided for back-compat pueporses, live in a folder names SysWOW64. I'm not joking.). In order to be able to call it, we first need to import it. We won't cover the Portable Executable format in its entirety here. It is documented extensively on the Microsoft docs website. Here are a couple of basic facts we'll need to know: PE files are comprised of sections. We have already seen a section containing executable code in our program, but sections may contain other types of data. Information about what symbols are imported from what DLLs is stored in a special section called '.idata'. Let's have a look at the .idata section. As per the docs, the .idata section begins with an import directory table (IDT). Each entry in the IDT corresponds to one DLL, is 20 bytes in length and consists of the following fields: A 4-byte relative virtual address (RVA) of the Import Lookup Table (ILT), which contains the names of functions to import. More on that later A 4-byte timestamp field (usually 0) Forwarder chain index (usually 0) A 4-byte RVA of a null-terminated string containing the name of the DLL A 4-byte RVA of the Import Address Table (IAT). The structure of the IAT is the same as ILT, the only difference is that the content of IAT is modified at runtime by the loader - it overwrites each entry with the address of the corresponding imported function. So theoretically, you can have both ILT and IAT fields point to the same exact piece of memory. Moreover, I've found that setting the ILT pointer to zero also works, although I am not sure if this behavior is officially supported. The Import Directory Table is terminated by an entry where all fields are equal zero. The ILT/IAT is an array of 64-bit values terminated by a null value. The bottom 31 bits of each entry contain the RVA of an entry in a hint/name table (containing the name of the imported function). During runtime, the entries of the IAT are replaced with the actual addresses of the imported functions. The hint/name table mentioned above consists of entries, each of which needs to be aligned on an even boundary. Each entry begins by a 2-byte hint (which we'll ignore for now) and a null-terminated string containing the imported function name, and a null byte (if necessary), to align the next entry on an even boundary. With that out of the way, let's see how we would define our executable's .idata section in FASM section '.idata' import readable writeable idt: ; import directory table starts here ; entry for KERNEL32.DLL dd rva kernel32_iat dd 0 dd 0 dd rva kernel32_name dd rva kernel32_iat ; NULL entry - end of IDT dd 5 dup(0) name_table: ; hint/name table _ExitProcess_Name dw 0 db \"ExitProcess\", 0, 0 kernel32_name: db \"KERNEL32.DLL\", 0 kernel32_iat: ; import address table for KERNEL32.DLL ExitProcess dq rva _ExitProcess_Name dq 0 ; end of KERNEL32's IAT The directive for a new PE section is already familiar to us. In this case, we're communicating that the section we're about to introduce contains the imports data and needs to be made writeable when loaded into memory (since addresses of the imported functions will be written in there). The directives db, dw, dd and dq all cause FASM to emit a raw byte/word/double-word/quad-word value respectively. The rva operator, unsurprisingly, yields the relative virtual address of its argument. So, dd rva kernel32_iat will cause FASM to emit a 4-byte binary value equal to the RVA of kernel32_iat label. Here we've just made use of fasm's db/dw/etc. directives to precisely describe the contents of our .idata section. The 64-bit Windows Calling Convention We're now almost ready to finally call ExitProcess. One thing we have to answer though, is - how does a function call work? Think about it. There is a call instruction, which pushes the current value of rip onto the stack, and transfers execution to the address specified by its parameter. There is also the ret instruction, which pops off an address from the stack and transfers execution there. Nowhere is it specified how arguments should be passed to a function, or how to handle the return values. The hardware simply doesn't care about that. It is the job of the caller and the callee to establish a contract between themselves. These rules might look along the lines of: The caller shall push the arguments onto the stack (starting from the last one) The callee shall remove the parameters from the stack before returning. The callee shall place return values in the register eax ... A set of rules like that is referred to as the calling convention, and there are many different calling conventions in use. When you try to call a function from assembly, you must know what type of calling convention it expects. The good news is that on 64-bit Windows there's pretty much only one calling convention that you need to be aware of - the Microsoft x64 calling convention. The bad news is that it's a tricky one - unlike many of the older conventions, it requires the first few parameters to be passed via registers (as opposed to being passed on the stack), which can be good for performance. You may read the full docs if you're interested in details, I will cover only the parts of the calling convention relevant to us here: The stack pointer has to be aligned to a 16-byte boundary The first four integer or pointer arguments are passed in the registers rcx, rdx, r8 and r9; the first four floating point arguments are passed in registers xmm0 to xmm3. Any additional args are passed on the stack. Even though the first 4 arguments aren't passed on the stack, the caller is still required to allocate 32 bytes of space for them on the stack. This has to be done even if the function has less than 4 arguments. The caller is responsible for cleaning up the stack. Armed with this knowledge, we can finally call ExitProcess: format PE64 NX GUI 6.0 entry start section '.text' code readable executable start: int3 sub rsp, 8 * 5 ; adjust stack ptr and allocate shadow space. xor rcx, rcx ; The first and only argument is the return code - passed in rcx. call [ExitProcess] section '.idata' import readable writeable idt: ; import directory table starts here ; entry for KERNEL32.DLL dd rva kernel32_iat dd 0 dd 0 dd rva kernel32_name dd rva kernel32_iat ; NULL entry - end of IDT dd 5 dup(0) name_table: ; hint/name table _ExitProcess_Name dw 0 db \"ExitProcess\", 0, 0 kernel32_name db \"KERNEL32.DLL\", 0 kernel32_iat: ; import address table for KERNEL32.DLL ExitProcess dq rva _ExitProcess_Name dq 0 ; end of KERNEL32's IAT Let's go through the new lines one-by-one. sub rsp, 8 * 5 - the sub instruction subtracts its second operand from its first operand and stores the result in the first operand. In this case, we're subtracting 40 from the current value of the stack pointer (note that somewhat counterintuitively, the stack \"grows\" downward, i.e. pushing onto the stack or allocating space on it diminishes the value of the stack pointer). Thus, we're aligning the stack to a 16-byte boundary, and allocating a \"shadow space\" for the first 4 arguments in one fell swoop. How does this work? Well, before our entry point was invoked, the stack pointer was aligned to a 16-byte boundary. As a result of the call, a return address was pushed onto the stack, diminishing the stack pointer value by 8 and throwing it out of alignment. We need to subtract another 8 bytes to bring it into alignment again, and another 32 bytes to account for the shadow space, hence the value 40. xor rcx, rcx - recall that the first integer argument should be passed in the rcx register. Here, we're setting the value of that register to zero by performing a bitwise exclusive-or operation with itself. call [ExitProcess] - this is what finally calls ExitProcess. The square brackets around the label name denote indirection - rather than calling the address referred to by the label, the value recorded in memory at that address is used as the target address for the call. Of course, the label we're using is pointing to the location within the import table where the loader has written the address of the required function! Fire it up in WinDbg again, run until our hardcoded breakpoint, then single-step to see how we eventually call ExitProcess, making note of how the rsp and rcx registers change. That's it for this first part. Next time, we'll try to do something more interesting than just exiting the process :) Like this post? Follow me on bluesky for more!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content\"\u003e\n    \u003cmain role=\"main\"\u003e\n        \u003ch2\u003eLet\u0026#39;s Learn x86-64 Assembly! Part 0 - Setup and First Steps\u003c/h2\u003e\n        \u003cp\u003e\u003csmall\u003epublished on Apr 18 2020\u003c/small\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/header.png\"/\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\nThe way I was taught x86 assembly at the university had been completely outdated for many years by the time I had my first class. It was around 2008 or 2009, and 64-bit processors had already started becoming a thing even in my neck of the woods. Meanwhile, we were doing DOS, real-mode, memory segmentation and all the other stuff from the bad old days.\n\u003c/p\u003e\n\n\u003cp\u003e\nNevertheless, I picked up enough of it during the classes (and over the subsequent years) to be able to understand the stuff coming out of the other end of a compiler, and that has helped me a few times. However, I\u0026#39;ve never manually written any substantial amount of x86 assembly for something non-trivial. Due to being locked up inside (on account of a global pandemic), I decided to change that situation, to pass the time.\n\u003c/p\u003e\n\n\u003cp\u003e\nI wanted to focus on x86-64 specifically, and completely forget/skip any and all legacy crap that is no longer relevant for this architecture. After getting a bit deeper into it, I also decided to publish my notes in the form of tutorials on this blog since there seems to be a desire for this type of content.\n\u003c/p\u003e\n\n\u003cp\u003e\nEverything I write in these posts will be a normal, 64-bit, Windows program. We\u0026#39;ll be using Windows because that is the OS I\u0026#39;m running on all of my non-work machines, and when you drop down to the level of writing assembly it starts becoming incresingly impossible to ignore the operating system you\u0026#39;re running on. I will also try to go as \u0026#34;from scratch\u0026#34; as possible - no libraries, we\u0026#39;re only allowed to call out to the operating system and that\u0026#39;s it.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn this first, introductory part (yeah, I\u0026#39;m planning a series and I know I will regret this later), I will talk about the tools we will need, show how to use them, explain how I generally think about programming in assembly and show how to write what is perhaps the smallest viable Windows program.\n\u003c/p\u003e\n\n\u003ch2\u003eGetting the Tools\u003c/h2\u003e\n\u003cp\u003eThere are two main tools that we will use throughout this series.\u003c/p\u003e\n\n\u003ch3\u003eAssembler\u003c/h3\u003e\n\n\u003cp\u003e\nCPUs execute machine code - an efficient representation of instructions for the processor that is almost completely impenetrable to humans. The assembly language is a human-readable representation of it. A program that converts this symbolic representation into machine code ready to be executed by a CPU is called an \u003cb\u003eassembler\u003c/b\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere is no single, agreed-upon standard for x86-64 assembly language. There are many assemblers out there, and even though some of them share a great deal of similarities, each has its own set of features and quirks. It is therefore important which assembler you choose. In this series, we will be using \n\u003ca href=\"http://flatassembler.net\"\u003eFlat Assembler\u003c/a\u003e (or FASM for short). I like it because it\u0026#39;s small, easy to obtain and use, has a nice macro system and comes with a handy little editor.\u003c/p\u003e\n\n\u003ch3\u003eDebugger\u003c/h3\u003e\n\n\u003cp\u003e\nAnother important tool is the debugger. We\u0026#39;ll use it to examine the state of our programs. While I\u0026#39;m pretty sure it\u0026#39;s possible to use Visual Studio\u0026#39;s integrated debugger for this, I think a standalone debugger is better when all you want to do is look at the disassembly, memory and registers. I\u0026#39;ve always used \u003ca href=\"http://ollydbg.de/\"\u003eOllyDbg\u003c/a\u003e for stuff like that, but unfortunately it does not have a 64-bit version. Therefore we will be using \u003ca href=\"https://www.microsoft.com/en-us/p/windbg-preview/9pgjgd53tn86?activetab=pivot:overviewtab\"\u003eWinDbg\u003c/a\u003e. The version linked here is a revamp of this venerable tool with a slightly nicer interface. Alternatively, you can get the non-Windows-store version \u003ca href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools\"\u003ehere\u003c/a\u003e as part of the Windows 10 SDK. Just make sure you deselect everything else besides WinDbg during installation. For our purposes, the two versions are mostly interchangeable.\n\u003c/p\u003e\n\n\u003ch2\u003eThinking in Assembly\u003c/h2\u003e\n\n\u003cp\u003e\nNow that we have our tools, I want to spend a bit of time to discuss some basics. For the purpose of these tutorials I\u0026#39;m assuming some knowledge of languages like C or C++, but little or no previous exposure to assembly, therefore many readers will find this stuff familiar.\n\u003c/p\u003e\n\u003ch3\u003eA 10000-foot view\u003c/h3\u003e\n\u003cp\u003e\nCPUs only \u0026#34;know\u0026#34; how to do a fixed number of certain things. When you hear someone talk about an \u0026#34;instruction set\u0026#34;, they\u0026#39;re referring to the set of things a particular CPU has been designed to do, and the term \u0026#34;instruction\u0026#34; just means \u0026#34;one of the things a CPU can do\u0026#34;. Most instructions are parameterized in one way or another, and they\u0026#39;re generally really simple. Usually an instruction is somthing along the lines of \u0026#34;write a given 8-bit value to a given location in memory\u0026#34;, or \u0026#34;interpreting the values from registers A and B as 16-bit signed integers, multiply them and record the result into register A\u0026#34;.\n\u003c/p\u003e\n\n\u003cp\u003e\nBelow is a simple mental model of the architecture that we\u0026#39;ll start with.\n\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/diag0.png\"/\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\n This skips a \u003ci\u003eton\u003c/i\u003e of things (there can be more than one core executing instructions and reading/writing memory, there\u0026#39;s different levels of cache, etc. etc.), but should serve as a good starting point.\n\u003c/p\u003e\n\n\u003cp\u003e\n To be effective at low-level programming or debugging you need to understand that every high-level concept eventually maps to this low-level model, and learning how the mapping works will help you.\n\u003c/p\u003e\n\n\u003ch3\u003eRegisters\u003c/h3\u003e\n\u003cp\u003e\n You can think of \u003cb\u003eregisters\u003c/b\u003e as a special kind of memory built right into the CPU that is very small, but extremely fast to access. There are many different kinds of registers in x86-64, and for now we\u0026#39;ll concern ourselves only with the so-called \u003ci\u003egeneral-purpose\u003c/i\u003e registers, of which there are sixteen. Each of them is 64 bits wide, and for each of them the lower byte, word and double-word can be addressed individually (incidentally, 1 \u0026#34;word\u0026#34; = 2 bytes, 1 \u0026#34;double-word\u0026#34; = 4 bytes, in case you haven\u0026#39;t heard this terminology before).\n \u003c/p\u003e\n \n \u003ctable\u003e\n \u003ctbody\u003e\u003ctr\u003e\n  \u003ctd\u003e\u003cb\u003eRegister\u003c/b\u003e\u003c/td\u003e\n  \u003ctd\u003e\u003cb\u003eLower byte\u003c/b\u003e\u003c/td\u003e\n  \u003ctd\u003e\u003cb\u003eLower word\u003c/b\u003e\u003c/td\u003e\n  \u003ctd\u003e\u003cb\u003eLower dword\u003c/b\u003e\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003erax\u003c/td\u003e \u003ctd\u003eal\u003c/td\u003e \u003ctd\u003eax\u003c/td\u003e \u003ctd\u003eeax\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003erbx\u003c/td\u003e \u003ctd\u003ebl\u003c/td\u003e \u003ctd\u003ebx\u003c/td\u003e \u003ctd\u003eebx\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003ercx\u003c/td\u003e \u003ctd\u003ecl\u003c/td\u003e \u003ctd\u003ecx\u003c/td\u003e \u003ctd\u003eecx\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003erdx\u003c/td\u003e \u003ctd\u003edl\u003c/td\u003e \u003ctd\u003edx\u003c/td\u003e \u003ctd\u003eedx\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003ersp\u003c/td\u003e \u003ctd\u003espl\u003c/td\u003e \u003ctd\u003esp\u003c/td\u003e \u003ctd\u003eesp\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003ersi\u003c/td\u003e \u003ctd\u003esil\u003c/td\u003e \u003ctd\u003esi\u003c/td\u003e \u003ctd\u003eesi\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003erdi\u003c/td\u003e \u003ctd\u003edil\u003c/td\u003e \u003ctd\u003edi\u003c/td\u003e \u003ctd\u003eedi\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003erbp\u003c/td\u003e \u003ctd\u003ebpl\u003c/td\u003e \u003ctd\u003ebp\u003c/td\u003e \u003ctd\u003eebp\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003er8\u003c/td\u003e \u003ctd\u003er8b\u003c/td\u003e \u003ctd\u003er8w\u003c/td\u003e \u003ctd\u003er8d\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003er9\u003c/td\u003e \u003ctd\u003er9b\u003c/td\u003e \u003ctd\u003er9w\u003c/td\u003e \u003ctd\u003er9d\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003er10\u003c/td\u003e \u003ctd\u003er10b\u003c/td\u003e \u003ctd\u003er10w\u003c/td\u003e \u003ctd\u003er10d\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003er11\u003c/td\u003e \u003ctd\u003er11b\u003c/td\u003e \u003ctd\u003er11w\u003c/td\u003e \u003ctd\u003er11d\u003c/td\u003e\n \u003c/tr\u003e\n \u003ctr\u003e\n  \u003ctd\u003er12\u003c/td\u003e \u003ctd\u003er12b\u003c/td\u003e \u003ctd\u003er12w\u003c/td\u003e \u003ctd\u003er12d\u003c/td\u003e\n \u003c/tr\u003e \n \u003ctr\u003e\n  \u003ctd\u003er13\u003c/td\u003e \u003ctd\u003er13b\u003c/td\u003e \u003ctd\u003er13w\u003c/td\u003e \u003ctd\u003er13d\u003c/td\u003e\n \u003c/tr\u003e \n \u003ctr\u003e\n  \u003ctd\u003er14\u003c/td\u003e \u003ctd\u003er14b\u003c/td\u003e \u003ctd\u003er14w\u003c/td\u003e \u003ctd\u003er14d\u003c/td\u003e\n \u003c/tr\u003e \n \u003ctr\u003e\n  \u003ctd\u003er15\u003c/td\u003e \u003ctd\u003er15b\u003c/td\u003e \u003ctd\u003er15w\u003c/td\u003e \u003ctd\u003er15d\u003c/td\u003e\n \u003c/tr\u003e   \n\u003c/tbody\u003e\u003c/table\u003e  \n\n\u003cp\u003eAdditionally, the higher 8 bits of \u003ccode\u003erax\u003c/code\u003e, \u003ccode\u003erbx\u003c/code\u003e, \u003ccode\u003ercx\u003c/code\u003e and \u003ccode\u003erdx\u003c/code\u003e can be referred to as \u003ccode\u003eah\u003c/code\u003e, \u003ccode\u003ebh\u003c/code\u003e, \u003ccode\u003ech\u003c/code\u003e and \u003ccode\u003edh\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\nNote that even though I said those were \u0026#34;general-purpose\u0026#34; registers, some instructions can only be used with certain registers, and some registers have special meaning for certain instructions. In particular, \u003ccode\u003ersp\u003c/code\u003e holds the stack pointer (which is used by instructions like \u003ccode\u003epush\u003c/code\u003e, \u003ccode\u003epop\u003c/code\u003e, \u003ccode\u003ecall\u003c/code\u003e and \u003ccode\u003eret\u003c/code\u003e), and \u003ccode\u003ersi\u003c/code\u003e and \u003ccode\u003erdi\u003c/code\u003e serve as source and destination index for \u0026#34;string manipulation\u0026#34; instructions. Another example where certain registers get \u0026#34;special treatment\u0026#34; are the multiplication instructions, which require one of the multiplier values to be in the register \u003ccode\u003erax\u003c/code\u003e, and write the result into the pair of registers \u003ccode\u003erax\u003c/code\u003e and \u003ccode\u003erdx\u003c/code\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn addition to these registers, we will also consider the special registers \u003ccode\u003erip\u003c/code\u003e and \u003ccode\u003erflags\u003c/code\u003e. \u003ccode\u003erip\u003c/code\u003e holds the address of the next instruction to execute. It is modified by control flow instructions like \u003ccode\u003ecall\u003c/code\u003e or \u003ccode\u003ejmp\u003c/code\u003e. \u003ccode\u003erflags\u003c/code\u003e holds a bunch of binary flags indicating various aspects of the program\u0026#39;s state, such as whether the result of the last arithmetic operation was less, equal or greater than zero. The behavior of many instructions depends on those flags, and many instructions update certain flags as part of their execution. The flags register can also be read and written \u0026#34;wholesale\u0026#34; using special instructions.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere are a lot more registers on x86-64. Most of them are used for SIMD or floating-point instructions, and we\u0026#39;ll not be considering them in this series.\n\u003c/p\u003e\n\n\u003ch3\u003eMemory and Addresses\u003c/h3\u003e\n\n\u003cp\u003e\nYou can think of memory as a large array of byte-sized \u0026#34;cells\u0026#34;, numbered starting at 0. We\u0026#39;ll call these numbers \u0026#34;memory addresses\u0026#34;. Simple, right?\n\u003c/p\u003e\n\u003cp\u003e\nWell... addressing memory used to be rather annoying back in the old days. You see, registers in old x86 processors used to be only 16-bit wide. Sixteen bits is enough to address 64 kilobytes worth of memory, but not more. The hardware was actually capable of using addresses as wide as 20 bits, but you had put a \u0026#34;base\u0026#34; address into a special segment register, and instructions that read or wrote memory would use a 16-bit offset into that segment to obtain the final 20-bit \u0026#34;linear\u0026#34; address. There were separate segment registers for code, data and stack portions (and a few more \u0026#34;extra\u0026#34; ones), and segments could overlap. \n\u003c/p\u003e\n\u003cp\u003e\nIn x86-64 these concerns are non-existant. The segment registers for code, data and stack are still present, and they\u0026#39;re loaded with some special values, but as a user-space programmer you needn\u0026#39;t concern yourself with them. For all intents and purposes you can assume that all segments start at 0 and extend for the entire addressable length of memory. So, as far as we\u0026#39;re concerned, on x86-64 our programs see memory as a \u0026#34;flat\u0026#34; contiguous array of bytes, with sequential addresses, starting at 0, just like we said in the beginning of this section...\n\u003c/p\u003e\n\u003cp\u003e\nOkay, I may have distorted the truth a little bit. Things aren\u0026#39;t quite as simple. While it is true that on 64-bit Windows your programs see memory as a flat contiguous array of bytes with addresses starting at 0, it is actually an elaborate illusion maintained by the OS and CPU working together.\n\u003c/p\u003e\n\u003cp\u003e\nThe truth is, if you were really able to read and write any byte in memory willy-nilly, you\u0026#39;d stomp all over other programs\u0026#39; code and data (something that indeed could happen in the Bad Old Days). To prevent that, special protection mechanisms exist. I won\u0026#39;t get too deep into their inner workings here because this stuff matters mostly for OS developers. Nevertheless, here\u0026#39;s a very short overview:\n\u003c/p\u003e\n\u003cp\u003e\nEach process gets a \u0026#34;flat\u0026#34; address space as described above (we\u0026#39;ll call it the \u0026#34;virtual address space\u0026#34;). For each process, the OS sets up a \u003ca href=\"https://wiki.osdev.org/Paging\"\u003emapping\u003c/a\u003e between its virtual addresses and actual physical addresses in memory. This mapping is respected by the hardware: the \u0026#34;virtual\u0026#34; addresses get translated to physical addresses dynamically at runtime. Thus, the same address (e.g. 0x410F119C) can map to two different locations in physical memory for two different processes. This, in a nutshell, is how the separation between processes in enforced.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe final thing I want to invite your attention to here is how the instructions and data which they operate on are held in the same memory. While it may seem an obvious choice, it\u0026#39;s not how computers necessarily \u003ci\u003ehave\u003c/i\u003e to work. This is a property characteristic of the von Neumann model - as opposed to the Harvard model, where instructions and data are held in separate memories. A real-world example of a Harvard computer is the AVR microcontroller on your Arduino.\n\u003c/p\u003e\n\n\u003ch2\u003eOur First Program\u003c/h2\u003e\n\u003cp\u003e\nHopefully by this point you have downloaded FASM and are ready to write some code. Our first program will be really simple: it will load and then immediately exit. We mostly want it just to get acquainted with the tools.\n\u003c/p\u003e\n\u003cp\u003e\nHere\u0026#39;s the code for our first program in x86-64 assembly:\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nformat PE64 NX GUI 6.0\nentry start\n\nsection \u0026#39;.text\u0026#39; code readable executable\nstart:\n        int3\n        ret\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003ch3\u003eAnalyzing the Code\u003c/h3\u003e\n\u003cp\u003e\nWe\u0026#39;ll go through this line-by-line.\n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eformat PE64 NX GUI 6.0\u003c/code\u003e - this is a directive telling FASM the format of the binary we expect it to produce - in our case, Portable Executable Format (which is what most Windows programs use). We\u0026#39;ll talk about it in a bit more detail later.\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eentry start\u003c/code\u003e - this defines the \u003ci\u003eentry point\u003c/i\u003e into our program. The entry directive requires a label, which in this case is \u0026#34;start\u0026#34;. A label can be thought of as a name for an address within our program, so in this case we\u0026#39;re saying \u0026#34;the entry point to the program is at whatever address the \u0026#39;start\u0026#39; label is\u0026#34;. Note that you\u0026#39;re allowed to refer to labels even if they\u0026#39;re defined later in the program code (as is the case here).\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003esection \u0026#39;.text\u0026#39; code readable executable\u003c/code\u003e - this directive indicates the beginning of a new section in a Portable Executable file, in this case a section containing executable code. More on this later.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003estart:\u003c/code\u003e - this is the label that denotes the entry point to our program. We referred to it earlier in the \u0026#34;entry\u0026#34; directive. Note that labels themselves don\u0026#39;t produce any executable machine code: they\u0026#39;re just a way for the programmer to mark locations within the executable\u0026#39;s address space.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eint3\u003c/code\u003e - this is a special instruction that causes the program to call the debug exception handler - when running under a debugger, this will pause the program and allow us to examine its state or proceed with the execution step-by-step. This is how breakpoints are actually implemented - the debugger replaces a single byte in the executable with the opcode corresponding to int3, and when the program hits it, the debugger takes over (obviously, the original content of the memory at breakpoint address has to be remembered and restored before proceeding with execution or single-stepping). In our case, we are hard-coding a breakpoint immediately at the entry point for convenience, so that we don\u0026#39;t have to set it manually via the debugger every time.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eret\u003c/code\u003e - this instruction pops off an address from the top of the stack, and transfers execution to that address. In our case, we\u0026#39;ll return into the OS code that initially invoked our entry point.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nFire up FASMW.EXE, paste the code above into the editor, save the file and press \u003ccode\u003eCtrl+F9\u003c/code\u003e. Your first assembly program is now complete! Let\u0026#39;s now load it up in a debugger and single-step through it to see it actually working.\n\u003c/p\u003e\n\n\u003ch3\u003eUsing the Debugger\u003c/h3\u003e\n\u003cp\u003e\nOpen up WinDbg. Go to the View tab and make sure the following windows are visible: Disassembly, Registers, Stack, Memory and Command. Go to File \u0026gt; Launch Executable and select the executable you just built with FASM. At this point your workspace should resemble something like this:\n\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/windbg0.png\"/\u003e\n\u003c/p\u003e\n\u003cp\u003e\nIn the \u003cb\u003edisassembly\u003c/b\u003e window you can see the code that is currently being executed. Right now it\u0026#39;s not our program\u0026#39;s code, but some OS loader code - this stuff will load our program into memory and eventually transfer execution to our entry point. WinDbg ensures a breakpoint is triggered before any of that happens.\n\u003c/p\u003e\n\u003cp\u003e\nIn the \u003cb\u003eregisters\u003c/b\u003e window, you can see the contents of x86-64 registers that we discussed earlier.\n\u003c/p\u003e\n\u003cp\u003e\nThe \u003cb\u003ememory\u003c/b\u003e window shows the raw content of the program\u0026#39;s memory around a given virtual address. We\u0026#39;ll use it later.\n\u003c/p\u003e\n\u003cp\u003e\nThe \u003cb\u003estack\u003c/b\u003e window shows the current call stack (as you can see, it\u0026#39;s all inside ntdll.dll right now).\n\u003c/p\u003e\n\u003cp\u003e\nFinally, the \u003cb\u003ecommand\u003c/b\u003e window allows entering text commands and shows log messages.\n\u003c/p\u003e\n\u003cp\u003e\nIf you press F5 at this time, it will cause the program to continue running until it hits another breakpoint. The next breakpoint it will hit is the one we hardcoded. Try pressing F5, and you\u0026#39;ll see something like this:\n\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/windbg1.png\"/\u003e\n\u003c/p\u003e\n\u003cp\u003eYou should be able to recognize the two instructions we wrote - int3 and ret. To advance to the next instruction, press F8. When you do that, pay attention to the \u003cb\u003eregisters\u003c/b\u003e window - you should see the \u003ccode\u003erip\u003c/code\u003e register being updated as you advance (WinDbg highlights the registers that change in red).\u003c/p\u003e\n\u003cp\u003eRight after the \u003ccode\u003eret\u003c/code\u003e instruction is executed, you will return to the code that invoked our program\u0026#39;s entry point.\n\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/windbg2.png\"/\u003e\n\u003c/p\u003e\n\u003cp\u003e\nAs you can see from the image above, the next thing that will happen is a call to RtlExitUserThread (a pretty self-explanatory name). If you press F5 now, your program\u0026#39;s main thread will clean up and end, and so will the program. Or will it?...\n\u003c/p\u003e\n\u003cp\u003e\nThe truth is, by using \u003ccode\u003eret\u003c/code\u003e, I took a bit of a shortcut. On Windows a process will terminate if any of the following conditions are met:\n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003eAny thread calls the WinAPI function \u003ccode\u003eExitProcess\u003c/code\u003e explicitly\u003c/li\u003e\n  \u003cli\u003eAll threads have exited\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nBut, we\u0026#39;re exiting the main thread here so we should be good, right? Well, sort of. There\u0026#39;s no guarantee that Windows hasn\u0026#39;t started any \u003ci\u003eother\u003c/i\u003e background threads (for example, to load DLLs or something like that) within our process. It seems that at least in this example, the main thread is the only one (I\u0026#39;ve checked and the process doesn\u0026#39;t stick around), but this may change. A well-behaved Windows program should always call \u003ccode\u003eExitProcess\u003c/code\u003e at the appropriate time.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn order to be able to call WinAPI functions, we need to learn a few things about the Portable Executable file format, how DLLs are loaded and calling conventions.\n\u003c/p\u003e\n\n\u003ch2\u003eThe PE Format and DLL Imports\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eExitProcess\u003c/code\u003e function lives in KERNEL32.DLL (yes, that\u0026#39;s not a typo, KERNEL32 is the name of the 64-bit library. The 32-bit versions of those libs provided for back-compat pueporses, live in a folder names SysWOW64. I\u0026#39;m not joking.). In order to be able to call it, we first need to \u003ci\u003eimport\u003c/i\u003e it.\n\u003c/p\u003e\n\u003cp\u003eWe won\u0026#39;t cover the Portable Executable format in its entirety here. It is \u003ca href=\"https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\"\u003edocumented extensively\u003c/a\u003e on the Microsoft docs website. Here are a couple of basic facts we\u0026#39;ll need to know:\n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003ePE files are comprised of \u003ci\u003esections\u003c/i\u003e. We have already seen a section containing executable code in our program, but sections may contain other types of data.\u003c/li\u003e\n  \u003cli\u003eInformation about what symbols are imported from what DLLs is stored in a special section called \u0026#39;.idata\u0026#39;.\u003c/li\u003e\n\u003c/ul\u003e\nLet\u0026#39;s have a look at the .idata section.\n\n\u003cp\u003e\nAs per the \u003ca href=\"https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-idata-section\"\u003edocs\u003c/a\u003e, the .idata section begins with an \u003cb\u003eimport directory table\u003c/b\u003e (IDT). Each entry in the IDT corresponds to one DLL, is 20 bytes in length and consists of the following fields: \n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003eA 4-byte \u003ci\u003e\u003ca href=\"https://en.wikipedia.org/wiki/COFF#Relative_virtual_address\"\u003erelative virtual address\u003c/a\u003e\u003c/i\u003e (RVA) of the Import Lookup Table (ILT), which contains the names of functions to import. More on that later\u003c/li\u003e\n  \u003cli\u003eA 4-byte timestamp field (usually 0)\u003c/li\u003e\n  \u003cli\u003eForwarder chain index (usually 0)\u003c/li\u003e\n  \u003cli\u003eA 4-byte RVA of a null-terminated string containing the name of the DLL\u003c/li\u003e\n  \u003cli\u003eA 4-byte RVA of the Import Address Table (IAT). The structure of the IAT is the same as ILT, the only difference is that the content of IAT is modified at runtime by the loader - it overwrites each entry with the address of the corresponding imported function. So theoretically, you can have both ILT and IAT fields point to the same exact piece of memory. Moreover, I\u0026#39;ve found that setting the ILT pointer to zero also works, although I am not sure if this behavior is officially supported.\u003c/li\u003e\n\u003c/ul\u003e\nThe Import Directory Table is terminated by an entry where all fields are equal zero.\n\n\u003cp\u003e\nThe ILT/IAT is an array of 64-bit values terminated by a null value. The bottom 31 bits of each entry contain the RVA of an entry in a hint/name table (containing the name of the imported function). During runtime, the entries of the IAT are replaced with the actual addresses of the imported functions.\n\u003c/p\u003e\n\u003cp\u003e\nThe hint/name table mentioned above consists of entries, each of which needs to be aligned on an even boundary. Each entry begins by a 2-byte hint (which we\u0026#39;ll ignore for now) and a null-terminated string containing the imported function name, and a null byte (if necessary), to align the next entry on an even boundary.\n\u003c/p\u003e\n\u003cp\u003e\nWith that out of the way, let\u0026#39;s see how we would define our executable\u0026#39;s .idata section in FASM\n\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\nsection \u0026#39;.idata\u0026#39; import readable writeable\nidt: ; import directory table starts here\n     ; entry for KERNEL32.DLL\n     dd rva kernel32_iat\n     dd 0\n     dd 0\n     dd rva kernel32_name\n     dd rva kernel32_iat\n     ; NULL entry - end of IDT\n     dd 5 dup(0)\nname_table: ; hint/name table\n        _ExitProcess_Name dw 0\n                          db \u0026#34;ExitProcess\u0026#34;, 0, 0\n\nkernel32_name: db \u0026#34;KERNEL32.DLL\u0026#34;, 0\nkernel32_iat: ; import address table for KERNEL32.DLL\n        ExitProcess dq rva _ExitProcess_Name\n        dq 0 ; end of KERNEL32\u0026#39;s IAT\n\u003c/code\u003e\n\u003c/pre\u003e\n\u003cp\u003e\nThe directive for a new PE section is already familiar to us. In this case, we\u0026#39;re communicating that the section we\u0026#39;re about to introduce contains the imports data and needs to be made writeable when loaded into memory (since addresses of the imported functions will be written in there).\n\u003c/p\u003e\n\u003cp\u003e\nThe directives db, dw, dd and dq all cause FASM to emit a raw byte/word/double-word/quad-word value respectively. The \u003ccode\u003erva\u003c/code\u003e operator, unsurprisingly, yields the relative virtual address of its argument. So, \u003ccode\u003edd rva kernel32_iat\u003c/code\u003e will cause FASM to emit a 4-byte binary value equal to the RVA of \u003ccode\u003ekernel32_iat\u003c/code\u003e label.\n\u003c/p\u003e\n\u003cp\u003e\n  Here we\u0026#39;ve just made use of fasm\u0026#39;s db/dw/etc. directives to precisely describe the contents of our .idata section. \n\u003c/p\u003e\n\u003ch2\u003eThe 64-bit Windows Calling Convention\u003c/h2\u003e\n\u003cp\u003e\nWe\u0026#39;re now almost ready to finally call ExitProcess. One thing we have to answer though, is - how does a function call work? Think about it. There is a \u003ccode\u003ecall\u003c/code\u003e instruction, which pushes the current value of \u003ccode\u003erip\u003c/code\u003e onto the stack, and transfers execution to the address specified by its parameter. There is also the \u003ccode\u003eret\u003c/code\u003e instruction, which pops off an address from the stack and transfers execution there. Nowhere is it specified how arguments should be passed to a function, or how to handle the return values. The hardware simply doesn\u0026#39;t care about that. It is the job of the caller and the callee to establish a contract between themselves. These rules might look along the lines of:\n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003eThe caller shall push the arguments onto the stack (starting from the last one)\u003c/li\u003e\n  \u003cli\u003eThe callee shall remove the parameters from the stack before returning.\u003c/li\u003e\n  \u003cli\u003eThe callee shall place return values in the register \u003ccode\u003eeax\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e...\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nA set of rules like that is referred to as the \u003ci\u003ecalling convention\u003c/i\u003e, and there are many different calling conventions in use. When you try to call a function from assembly, you must know what type of calling convention it expects.\n\u003c/p\u003e\n\u003cp\u003e\nThe good news is that on 64-bit Windows there\u0026#39;s pretty much only one calling convention that you need to be aware of - the \u003ca href=\"https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019\"\u003eMicrosoft x64 calling convention\u003c/a\u003e. The bad news is that it\u0026#39;s a tricky one - unlike many of the older conventions, it requires the first few parameters to be passed via registers (as opposed to being passed on the stack), which can be good for performance.\n\u003c/p\u003e\n\u003cp\u003e\nYou may read the full docs if you\u0026#39;re interested in details, I will cover only the parts of the calling convention relevant to us here:\n\u003c/p\u003e\u003cul\u003e\n \u003cli\u003eThe stack pointer has to be aligned to a 16-byte boundary\u003c/li\u003e\n \u003cli\u003eThe first four integer or pointer arguments are passed in the registers rcx, rdx, r8 and r9; the first four floating point arguments are passed in registers xmm0 to xmm3. Any additional args are passed on the stack.\u003c/li\u003e\n \u003cli\u003eEven though the first 4 arguments aren\u0026#39;t passed on the stack, the caller is still required to allocate 32 bytes of space for them on the stack. This has to be done even if the function has less than 4 arguments.\u003c/li\u003e\n \u003cli\u003eThe caller is responsible for cleaning up the stack.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nArmed with this knowledge, we can finally call ExitProcess:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nformat PE64 NX GUI 6.0\nentry start\n\nsection \u0026#39;.text\u0026#39; code readable executable\nstart:\n        int3\n        sub rsp, 8 * 5  ; adjust stack ptr and allocate shadow space.\n        xor rcx, rcx    ; The first and only argument is the return code - passed in rcx.\n        call [ExitProcess]\n\n\nsection \u0026#39;.idata\u0026#39; import readable writeable\nidt: ; import directory table starts here\n     ; entry for KERNEL32.DLL\n     dd rva kernel32_iat\n     dd 0\n     dd 0\n     dd rva kernel32_name\n     dd rva kernel32_iat\n     ; NULL entry - end of IDT\n     dd 5 dup(0)\nname_table: ; hint/name table\n        _ExitProcess_Name dw 0\n                          db \u0026#34;ExitProcess\u0026#34;, 0, 0\n\nkernel32_name db \u0026#34;KERNEL32.DLL\u0026#34;, 0\nkernel32_iat: ; import address table for KERNEL32.DLL\n        ExitProcess dq rva _ExitProcess_Name\n        dq 0 ; end of KERNEL32\u0026#39;s IAT\n\u003c/code\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\nLet\u0026#39;s go through the new lines one-by-one.\n\u003c/p\u003e\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003esub rsp, 8 * 5\u003c/code\u003e - the \u003ccode\u003esub\u003c/code\u003e instruction subtracts its second operand from its first operand and stores the result in the first operand. In this case, we\u0026#39;re subtracting 40 from the current value of the stack pointer (note that somewhat counterintuitively, the stack \u0026#34;grows\u0026#34; downward, i.e. pushing onto the stack or allocating space on it diminishes the value of the stack pointer). Thus, we\u0026#39;re aligning the stack to a 16-byte boundary, and allocating a \u0026#34;shadow space\u0026#34; for the first 4 arguments in one fell swoop. How does this work? Well, before our entry point was invoked, the stack pointer was aligned to a 16-byte boundary. As a result of the call, a return address was pushed onto the stack, diminishing the stack pointer value by 8 and throwing it out of alignment. We need to subtract another 8 bytes to bring it into alignment again, and another 32 bytes to account for the shadow space, hence the value 40.\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003exor rcx, rcx\u003c/code\u003e - recall that the first integer argument should be passed in the rcx register. Here, we\u0026#39;re setting the value of that register to zero by performing a bitwise exclusive-or operation with itself.\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ecall [ExitProcess]\u003c/code\u003e - this is what finally calls ExitProcess. The square brackets around the label name denote indirection - rather than calling the address referred to by the label, the value recorded in memory at that address is used as the target address for the call. Of course, the label we\u0026#39;re using is pointing to the location within the import table where the loader has written the address of the required function!\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\nFire it up in WinDbg again, run until our hardcoded breakpoint, then single-step to see how we eventually call ExitProcess, making note of how the rsp and rcx registers change.\n\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gpfault.net/assets/post-img/asm-tut-0/windbg3.png\"/\u003e\n\u003c/p\u003e\n\u003cp\u003e\nThat\u0026#39;s it for this first part. Next time, we\u0026#39;ll try to do something more interesting than just exiting the process :)\n\u003c/p\u003e\n  \n        \u003chr/\u003e\n        \u003cp\u003e\u003ci\u003eLike this post? \u003ca href=\"https://bsky.app/profile/nicebyte.bsky.social\"\u003eFollow\u003c/a\u003e me on bluesky for more!\u003c/i\u003e\u003c/p\u003e\n      \u003c/main\u003e\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "26 min read",
  "publishedTime": null,
  "modifiedTime": null
}
