{
  "id": "4092cc1f-9a01-40be-b4eb-0466dead599d",
  "title": "SICP: The only computer science book worth reading twice? (2010)",
  "link": "https://simondobson.org/2010/05/14/cs-book-worth-reading-twice/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 16 Nov 2024 17:23:39 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 5816,
  "excerpt": "I was talking to one of my students earlier, and lent him a book to read over summer. It was only after he’d left that I realised that — for me at any rate — the book I’d given him is probably the most seminal work in the whole of computer science, and certainly the book that’s most influenced my career and research interests.",
  "siteName": "",
  "favicon": "https://simondobson.org/images/favicon.png",
  "text": "I was talking to one of my students earlier, and lent him a book to read over summer. It was only after he’d left that I realised that — for me at any rate — the book I’d given him is probably the most seminal work in the whole of computer science, and certainly the book that’s most influenced my career and research interests. So what’s the book? Structure and interpretation of computer programs by Hal Abelson and Jerry Sussman (MIT Press. 1984. ISBN 0-262-01077-1), also known as SICP. The book’s still in print, but — even better — is available online in its entirety. OK, everyone has their favourite book: why’s this one so special to me? The first reason is the time I first encountered it: in Newcastle upon Tyne in the second year of my first degree. I was still finding my way in computer science, and this book was a recommended text after you’d finished the first programming courses. It’s the book that introduced me to programming as it could be (rather than programming as it was, in Pascal at the time). What I mean by that is that SICP starts out by introducing the elements of programming — values, names, binding, control and so on — and then runs with them to explore a quite dazzling breadth of issues including: lambda-abstraction and higher-order computation complex data structures, including structures with embedded computational content modularity and mutability streams lazy evaluation interpreter and compiler construction storage management, garbage collection and virtual memory machine code domain-specific languages …and so forth. The list of concepts is bewildering, and only stays coherent because the authors are skilled writers devoted to their craft. But it’s also a remarkable achievement to handle all these concepts within a single language framework — Scheme — in such a way that each builds on what’s gone before. The second reason is the way in which Hal and Jerry view everything as an exercise in language design: We have also obtained a glimpse of another crucial idea about languages and program design. This is the approach of stratified design, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages. Each level is constructed by combining parts that are regarded as primitive at that level, and the parts constructed at each level are used as primitives at the next level. The language used at each level of a stratified design has primitives, means of combination, and means of abstraction appropriate to that level of detail. Layered abstraction of course is second nature to all computer scientists. What’s novel in this view is that each level should be programmable: that the layers are all about computation and transformation, and not simply about hiding information. We don’t see that in the mainstream of programming languages, because layering doesn’t extend the language at all: Java is Java from top to bottom, with class and libraries but no new control structures. If a particular domain has concepts that would benefit from dedicated language constructs, that’s just tough. Conversely (and this is something that very much interests me) if there are constructs it’d be desirable not to have in some domain, they can’t be removed. (Within the language, anyway: Java-ME dumps some capabilities in the interests of running on small devices, but that’s not something you can do without re-writing the compiler.) The third influential feature is the clear-sighted view of what computer science is actually about: The computer revolution is a revolution in the way we think and in the way we express what we think. The essence of this change is the emergence of what might best be called procedural epistemology — the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of “what is.” Computation provides a framework for dealing precisely with notions of “how to.” I’ve taken a view before about computers being the new microscopes, opening-up new science on their own as well as facilitating existing approaches. The “how to” aspect of computer science re-appears everywhere in this: in describing the behaviours of sensor networks that can adapt while continuing the reflect the phenomena they’ve been deployed to sense; in the interpretation of large-scale data mined and mashed-up across the web; in capturing scientific methods and processes for automation; and so forth. The richness of these domains mitigates against packaged software and encourages integration through programming languages like R, so that the interfaces and structures remain “soft” and open to experimentation. When I looked at my copy, the date I’d written on the inside was September 1988. So a book I bought nearly 22 years ago is still relevant. In fact, I’d go further and say that it’s the only computer science book of that age that I’d happily and usefully read again without it being just for historical interest: the content has barely aged at all. That’s not all that unusual for mathematics books, but it’s almost unheard of in computer science, where the ideas move so quickly and where much of what’s written about is ephemeral rather than foundational. It goes to show how well SICP nailed the core concepts. In this sense, it’s certainly one of the very few  books on computer science that it’s worth reading twice (or more). SICP is to computer science what Feynman’s Lectures on Physics are to physics: an accessible distillation of the essence of the subject that’s stood the test of time. UPDATED 27Jan2024: This book also appears in my annotated Lisp bibliography",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv role=\"main\"\u003e\n\t\u003carticle\u003e\u003cdiv\u003e\n\t\t\u003cp\u003eI was talking to one of my students earlier, and lent him a book to\nread over summer. It was only after he’d left that I realised that —\nfor me at any rate — the book I’d given him is probably the most\nseminal work in the whole of computer science, and certainly the book\nthat’s most influenced my career and research interests.\u003c/p\u003e\n\n\n\u003cp\u003eSo what’s the book? \u003cem\u003eStructure and interpretation of computer\nprograms\u003c/em\u003e by Hal Abelson and Jerry Sussman \u003cspan\u003e (\u003cspan\u003eMIT\u003c/span\u003e\nPress. 1984. \u003cspan\u003eISBN\u003c/span\u003e 0-262-01077-1), also known as \u003cem\u003e\u003cspan\u003eSICP\u003c/span\u003e\u003c/em\u003e.\n\u003c/span\u003eThe book’s still in print, but — even better — is \u003ca href=\"http://mitpress.mit.edu/sicp/\"\u003eavailable online in its\nentirety\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOK\u003c/span\u003e, everyone has their favourite book: why’s this one so special to\nme? The first reason is the time I first encountered it: in \u003ca href=\"http://www.cs.newcastle.ac.uk/\"\u003eNewcastle upon Tyne\u003c/a\u003e in\n\u003cspan\u003ethe second year of my first degree. I was still finding my way\nin computer science, and this book was a recommended text after you’d\nfinished the first programming courses. It’s the book that introduced\nme to programming \u003cem\u003eas it could be\u003c/em\u003e (rather than programming\n\u003cem\u003eas it was\u003c/em\u003e, in Pascal at the time). What I mean by that is\nthat \u003cspan\u003eSICP\u003c/span\u003e starts out by introducing the elements of programming —\nvalues, names, binding, control and so on — and then runs with them\nto explore a quite dazzling breadth of issues including:\u003c/span\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003elambda-abstraction and higher-order computation\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003ecomplex data structures, including structures with embedded computational content\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003emodularity and mutability\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003estreams\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003elazy evaluation\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003einterpreter and compiler construction\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003estorage management, garbage collection and virtual memory\n\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003emachine code\n\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003edomain-specific languages\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e…and so forth. The list of concepts is bewildering, and only stays coherent because the authors are skilled writers devoted to their craft. But it’s also a remarkable achievement to handle all these concepts within a single language framework — Scheme — in such a way that each builds on what’s gone before.\u003c/p\u003e\n\u003cp\u003eThe second reason is the way in which Hal and Jerry view everything as\nan exercise in language design:\u003c/p\u003e\n\u003cblockquote\u003eWe have also obtained a glimpse of another crucial idea\nabout languages and program design. This is the approach of stratified\ndesign, the notion that a complex system should be structured as a\nsequence of levels that are described using a sequence of languages.\nEach level is constructed by combining parts that are regarded as\nprimitive at that level, and the parts constructed at each level are\nused as primitives at the next level. The language used at each level\nof a stratified design has primitives, means of combination, and means\nof abstraction appropriate to that level of detail.\u003c/blockquote\u003e\n\n\u003cp\u003eLayered abstraction of course is second nature to all computer\nscientists. What’s novel in this view is that each level should be\n\u003cem\u003eprogrammable\u003c/em\u003e: that the layers are all about computation and\ntransformation, and not simply about hiding information. We don’t see\nthat in the mainstream of programming languages, because layering\ndoesn’t extend the language at all: Java is Java from top to bottom,\nwith class and libraries but no new control structures. If a\nparticular domain has concepts that would benefit from dedicated\nlanguage constructs, that’s just tough. Conversely (and this is\nsomething that very much interests me) if there are constructs it’d be\ndesirable \u003cem\u003enot\u003c/em\u003e to have in some domain, they can’t be removed.\n(Within the language, anyway: Java-\u003cspan\u003eME\u003c/span\u003e dumps some capabilities in the\ninterests of running on small devices, but that’s not something you\ncan do without re-writing the compiler.)\u003c/p\u003e\n\u003cp\u003eThe third influential feature is the clear-sighted view of what\ncomputer science is actually about:\u003c/p\u003e\n\u003cblockquote\u003eThe computer revolution is a revolution in the way we\nthink and in the way we express what we think. The essence of this\nchange is the emergence of what might best be called \u003cem\u003eprocedural\nepistemology\u003c/em\u003e — the study of the structure of knowledge from an\nimperative point of view, as opposed to the more declarative point of\nview taken by classical mathematical subjects. Mathematics provides a\nframework for dealing precisely with notions of “what is.” Computation\nprovides a framework for dealing precisely with notions of “how\nto.”\u003c/blockquote\u003e\n\n\u003cp\u003eI’ve taken a view before about \u003ca href=\"https://simondobson.org/2010/04/01/computer-microscope/\"\u003ecomputers being the new\nmicroscopes\u003c/a\u003e, opening-up new science on their own as well as\nfacilitating existing approaches. The “how to” aspect of computer\nscience re-appears everywhere in this: in describing the behaviours of\nsensor networks that can adapt while continuing the reflect the\nphenomena they’ve been deployed to sense; in the interpretation of\nlarge-scale data mined and mashed-up across the web; in capturing\nscientific methods and processes for automation; and so forth. The\nrichness of these domains mitigates against packaged software and\nencourages integration through programming languages like \u003ca href=\"http://www.r-project.org\"\u003eR\u003c/a\u003e, so that the interfaces and\nstructures remain “soft” and open to experimentation.\u003c/p\u003e\n\u003cp\u003eWhen I looked at my copy, the date I’d written on the inside was\nSeptember 1988. So a book I bought nearly 22 years ago is still\nrelevant. \u003cem\u003e \u003c/em\u003eIn fact, I’d go further and say that it’s the only\ncomputer science book of that age that I’d happily and usefully read\nagain without it being just for historical interest: the content has\nbarely aged at all. That’s not all that unusual for mathematics books,\nbut it’s almost unheard of in computer science, where the ideas move\nso quickly and where much of what’s written about is ephemeral rather\nthan foundational. It goes to show how well \u003cspan\u003eSICP\u003c/span\u003e nailed the core\nconcepts. In this sense, it’s certainly one of the very few  books on\ncomputer science that it’s worth reading twice (or more). \u003cspan\u003eSICP\u003c/span\u003e is to\ncomputer science what Feynman’s \u003cem\u003eLectures on Physics\u003c/em\u003e are to\nphysics: an accessible distillation of the essence of the subject\nthat’s stood the test of time.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eUPDATED\u003c/span\u003e 27Jan2024: This book also \u003ca href=\"https://simondobson.org/2024/01/27/structure-and-interpretation-of-computer-programs/\"\u003eappears\u003c/a\u003e\nin my \u003ca href=\"https://simondobson.org/development/annotated-lisp-bibliography/\"\u003eannotated\nLisp bibliography\u003c/a\u003e\u003c/p\u003e\n\t    \u003c/div\u003e\n\n\n\t\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
