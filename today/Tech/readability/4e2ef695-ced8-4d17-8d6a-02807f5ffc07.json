{
  "id": "4e2ef695-ced8-4d17-8d6a-02807f5ffc07",
  "title": "Notes on Zero-latency SQLite storage in every Durable Object",
  "link": "https://simonwillison.net/2024/Oct/13/zero-latency-sqlite-storage-in-every-durable-object/",
  "description": "Comments",
  "author": "",
  "published": "Sun, 13 Oct 2024 23:07:03 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 3764,
  "excerpt": "Kenton Varda introduces the next iteration of Cloudflare's [Durable Object](https://developers.cloudflare.com/durable-objects/) platform, which recently upgraded from a key/value store to a full relational system based on SQLite. For useful background on …",
  "siteName": "",
  "favicon": "",
  "text": "Zero-latency SQLite storage in every Durable Object (via) Kenton Varda introduces the next iteration of Cloudflare's Durable Object platform, which recently upgraded from a key/value store to a full relational system based on SQLite. For useful background on the first version of Durable Objects take a look at Cloudflare's durable multiplayer moat by Paul Butler, who digs into its popularity for building WebSocket-based realtime collaborative applications. The new SQLite-backed Durable Objects is a fascinating piece of distributed system design, which advocates for a really interesting way to architect a large scale application. The key idea behind Durable Objects is to colocate application logic with the data it operates on. A Durable Object comprises code that executes on the same physical host as the SQLite database that it uses, resulting in blazingly fast read and write performance. How could this work at scale? A single object is inherently limited in throughput since it runs on a single thread of a single machine. To handle more traffic, you create more objects. This is easiest when different objects can handle different logical units of state (like different documents, different users, or different \"shards\" of a database), where each unit of state has low enough traffic to be handled by a single object Kenton presents the example of a flight booking system, where each flight can map to a dedicated Durable Object with its own SQLite database - thousands of fresh databases per airline per day. Each DO has a unique name, and Cloudflare's network then handles routing requests to that object wherever it might live on their global network. The technical details are fascinating. Inspired by Litestream, each DO constantly streams a sequence of WAL entries to object storage - batched every 16MB or every ten seconds. This also enables point-in-time recovery for up to 30 days through replaying those logged transactions. To ensure durability within that ten second window, writes are also forwarded to five replicas in separate nearby data centers as soon as they commit, and the write is only acknowledged once three of them have confirmed it. The JavaScript API design is interesting too: it's blocking rather than async, because the whole point of the design is to provide fast single threaded persistence operations: let docs = sql.exec(` SELECT title, authorId FROM documents ORDER BY lastModified DESC LIMIT 100 `).toArray(); for (let doc of docs) { doc.authorName = sql.exec( \"SELECT name FROM users WHERE id = ?\", doc.authorId).one().name; } This one of their examples deliberately exhibits the N+1 query pattern, because that's something SQLite is uniquely well suited to handling. The system underlying Durable Objects is called Storage Relay Service, and it's been powering Cloudflare's existing-but-different D1 SQLite system for over a year. I was curious as to where the objects are created. According to this (via Hacker News): Durable Objects do not currently change locations after they are created. By default, a Durable Object is instantiated in a data center close to where the initial get() request is made. [...] To manually create Durable Objects in another location, provide an optional locationHint parameter to get(). And in a footnote: Dynamic relocation of existing Durable Objects is planned for the future. where.durableobjects.live is a neat site that tracks where in the Cloudflare network DOs are created - I just visited it and it said: This page tracks where new Durable Objects are created; for example, when you loaded this page from Half Moon Bay, a worker in San Jose, California, United States (SJC) created a durable object in San Jose, California, United States (SJC).",
  "image": "https://static.simonwillison.net/static/2024/where-durable-objects.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://blog.cloudflare.com/sqlite-in-durable-objects/\"\u003eZero-latency SQLite storage in every Durable Object\u003c/a\u003e\u003c/strong\u003e (\u003ca href=\"https://lobste.rs/s/kjx2vk/zero_latency_sqlite_storage_every\" title=\"lobste.rs\"\u003evia\u003c/a\u003e) Kenton Varda introduces the next iteration of Cloudflare\u0026#39;s \u003ca href=\"https://developers.cloudflare.com/durable-objects/\"\u003eDurable Object\u003c/a\u003e platform, which recently upgraded from a key/value store to a full relational system based on SQLite.\u003c/p\u003e\n\u003cp\u003eFor useful background on the first version of Durable Objects take a look at \u003ca href=\"https://digest.browsertech.com/archive/browsertech-digest-cloudflares-durable/\"\u003eCloudflare\u0026#39;s durable multiplayer moat\u003c/a\u003e by Paul Butler, who digs into its popularity for building WebSocket-based realtime collaborative applications.\u003c/p\u003e\n\u003cp\u003eThe new SQLite-backed Durable Objects is a fascinating piece of distributed system design, which advocates for a really interesting way to architect a large scale application.\u003c/p\u003e\n\u003cp\u003eThe key idea behind Durable Objects is to colocate application logic with the data it operates on. A Durable Object comprises code that executes on the same physical host as the SQLite database that it uses, resulting in blazingly fast read and write performance.\u003c/p\u003e\n\u003cp\u003eHow could this work at scale?\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA single object is inherently limited in throughput since it runs on a single thread of a single machine. To handle more traffic, you create more objects. This is easiest when different objects can handle different logical units of state (like different documents, different users, or different \u0026#34;shards\u0026#34; of a database), where each unit of state has low enough traffic to be handled by a single object\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eKenton presents the example of a flight booking system, where each flight can map to a dedicated Durable Object with its own SQLite database - thousands of fresh databases per airline per day.\u003c/p\u003e\n\u003cp\u003eEach DO has a unique name, and Cloudflare\u0026#39;s network then handles routing requests to that object wherever it might live on their global network.\u003c/p\u003e\n\u003cp\u003eThe technical details are fascinating. Inspired by \u003ca href=\"https://litestream.io/\"\u003eLitestream\u003c/a\u003e, each DO constantly streams a sequence of WAL entries to object storage - batched every 16MB or every ten seconds. This also enables point-in-time recovery for up to 30 days through replaying those logged transactions.\u003c/p\u003e\n\u003cp\u003eTo ensure durability within that ten second window, writes are also forwarded to five replicas in separate nearby data centers as soon as they commit, and the write is only acknowledged once three of them have confirmed it.\u003c/p\u003e\n\u003cp\u003eThe JavaScript API design is interesting too: it\u0026#39;s blocking rather than async, because the whole point of the design is to provide fast single threaded persistence operations:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003edocs\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esql\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexec\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\n\u003cspan\u003e  SELECT title, authorId FROM documents\u003c/span\u003e\n\u003cspan\u003e  ORDER BY lastModified DESC\u003c/span\u003e\n\u003cspan\u003e  LIMIT 100\u003c/span\u003e\n\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etoArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003edoc\u003c/span\u003e \u003cspan\u003eof\u003c/span\u003e \u003cspan\u003edocs\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003edoc\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eauthorName\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esql\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexec\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;SELECT name FROM users WHERE id = ?\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003edoc\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eauthorId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eone\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis one of their examples deliberately exhibits the N+1 query pattern, because that\u0026#39;s something SQLite is \u003ca href=\"https://www.sqlite.org/np1queryprob.html\"\u003euniquely well suited to handling\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe system underlying Durable Objects is called Storage Relay Service, and it\u0026#39;s been powering Cloudflare\u0026#39;s existing-but-different \u003ca href=\"https://developers.cloudflare.com/d1/\"\u003eD1 SQLite system\u003c/a\u003e for over a year.\u003c/p\u003e\n\u003cp\u003eI was curious as to where the objects are created. \u003ca href=\"https://developers.cloudflare.com/durable-objects/reference/data-location/#provide-a-location-hint\"\u003eAccording to this\u003c/a\u003e (via \u003ca href=\"https://news.ycombinator.com/item?id=41832547#41832812\"\u003eHacker News\u003c/a\u003e):\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDurable Objects do not currently change locations after they are created. By default, a Durable Object is instantiated in a data center close to where the initial \u003ccode\u003eget()\u003c/code\u003e request is made. [...] To manually create Durable Objects in another location, provide an optional \u003ccode\u003elocationHint\u003c/code\u003e parameter to \u003ccode\u003eget()\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAnd in a footnote:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDynamic relocation of existing Durable Objects is planned for the future.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://where.durableobjects.live/\"\u003ewhere.durableobjects.live\u003c/a\u003e is a neat site that tracks where in the Cloudflare network DOs are created - I just visited it and it said:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis page tracks where new Durable Objects are created; for example, when you loaded this page from \u003cstrong\u003eHalf Moon Bay\u003c/strong\u003e, a worker in \u003cstrong\u003eSan Jose, California, United States (SJC)\u003c/strong\u003e created a durable object in \u003cstrong\u003eSan Jose, California, United States (SJC)\u003c/strong\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"Where Durable Objects Live.    Created by the wonderful Jed Schmidt, and now maintained with ❤️ by Alastair. Source code available on Github.    Cloudflare Durable Objects are a novel approach to stateful compute based on Cloudflare Workers. They aim to locate both compute and state closest to end users.    This page tracks where new Durable Objects are created; for example, when you loaded this page from Half Moon Bay, a worker in San Jose, California, United States (SJC) created a durable object in Los Angeles, California, United States (LAX).    Currently, Durable Objects are available in 11.35% of Cloudflare PoPs.    To keep data fresh, this application is constantly creating/destroying new Durable Objects around the world. In the last hour, 394,046 Durable Objects have been created(and subsequently destroyed), FOR SCIENCE!    And a map of the world showing lots of dots.\" src=\"https://static.simonwillison.net/static/2024/where-durable-objects.jpg\"/\u003e\u003c/p\u003e\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
