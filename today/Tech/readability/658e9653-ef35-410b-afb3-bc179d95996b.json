{
  "id": "658e9653-ef35-410b-afb3-bc179d95996b",
  "title": "Running WolfSSL and Curl on Windows 2000",
  "link": "http://datagirl.xyz/posts/wolfssl_curl_w2k.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 10 Oct 2024 23:18:19 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 16651,
  "excerpt": "If you wish to share pictures with friends, you must first start with the universe.",
  "siteName": "datagirl.xyz",
  "favicon": "",
  "text": "Created on 2024-03-03 at 14:04 As part of my current series of projects, I've been working on a screenshot tool intended for older Windows versions. The goal is to have something similar to ShareX, a tool that lets you take a screenshot and post it online. These days, file sharing is done via the Hypertext Transfer Protocol (HTTP)[1], often using Transport Layer Security (TLS).[2] Built into every version of Windows since Windows 95 is WinINet, which provides HTTP, FTP, and (in XP/2003 and earlier) Gopher. Obviously for older Windows versions, this library won't include support for recent technologies like TLS 1.3 or HTTP/2. cURL still supports Visual C++ 6, but that only provides the HTTP/FTP part. We'll need a TLS library to get connected to most modern systems. Note: All patches and documentation here are experimental, and should not be considered secure. My focus was on running something compliant with modern Web protocols, not improving the security posture of the system. Even if my patches haven't compromised the code's security, the versions of Visual C++ runtime and Windows involved have documented vulnerabilities that can affect libcurl and WolfSSL. Don't do your banking on Windows 2000, whether via IE6 or cURL 8.6.0. Prerequisites While I'm currently getting things running on Windows 2000 Professional SP4, I'd like to get this working on Windows 95 and 98 too. To that end, I'll be using Visual Studio.NET 2003, which was the last version to support Windows 95. I'm also building everything in Windows 2000, but that part's optional. You'll also need a copy of the Platform SDK from the era. I'm using the February 2003 MSDN release, for no other reason than it sounded like a good fit for VS2003. And some general advice if you want to develop for old Windows versions: the MSDN Library that comes with VS2003 is so much more useful than the version on the Internet. Today's MSDN docs are a minefield of incorrect version information, and while I'm sure modern-day search engines are far better than WinHelp, the built-in search function is surprisingly useful. WolfSSL and Visual C++ Before we think about compiling cURL, we need a TLS library. In the past I've made hacks to OpenSSL to get it to build on pre-Vista Win32, but I'd really rather avoid that for something I share with others. Inspired by the post on Dialup.net about building WolfSSL for Windows 3.11 for Workgroups, I decided that would be a better place to start. At first glance, I noticed a file named wolfssl.vcproj, indicating a pre-Visual C++ 2010 project. Good start, except the project was made in Visual Studio 2008.[3] \u003c?xml version=\"1.0\" encoding=\"Windows-1252\"?\u003e \u003cVisualStudioProject ProjectType=\"Visual C++\" Version=\"9.00\"To make matters worse, the project was woefully outdated. It was missing several files required to link, meaning I had to cherry-pick files as I got errors. Unfortunately, there's not a great way to automate this. So began the process of painstakingly adding files to the project until it compiled, using the CMakeLists.txt and VC2010+ .vcxproj files as references. Configuring WolfSSL As is common with software written in C, configuration is handled via #define statements. WolfSSL helpfully allows you to override the usual configuration process by defining WOLFSSL_USER_SETTINGS. This allows us to use the configuration already used by the .vcproj: IDE/WIN/user_settings.h. Figuring out the right defines took more troubleshooting than I care to describe, so here's a lightning round: First, force C89 by defining WOLF_C89 and NO_WOLF_C99. More on this in a bit. Disable WOLFSSL_SP_X86_64,since we won't be running this on an x86_64 CPU. We don't have strntok or strtok_s, so define USE_WOLF_STRTOK. We also have to define a few functions, so add them: #define XSTRTOK wc_strtok #define XVSNPRINTF _vsnprintfWe also need to define strcpy_s. My workaround was to use StringCchCopy, which is close enough? Probably? You need to #include \u003cWinerror.h\u003e first though, so later #include \u003cWindows.h\u003e lines don't try to re-define the SUCCEEDED and FAILED macros. Win32 headers are annoying like that. Aside: What is a C standard, really? A quick and inaccurate history: some guy at a phone company made a language named C.[4] His coworkers were working on a bunch of different programs with it and thought it was useful, so a couple of them wrote a book about it. Without a standard, companies decided to make fifty different versions with their own features. To combat that, the American National Standards Institute (ANSI) decided they should make a standard about it, and took half a decade hashing out C89, or C90 if you're more of an ISO person.[5] Those guys from the phone company rewrote their book for that, too. The companies decided to follow at least those rules when making their fifty different versions. Then, C99 arrived a decade later, with a ton of great features that everyone loved.[citation needed] Boolean types, variadic macros, the ability to declare variables wherever you want; all the classics. VC2003 doesn't support any of those though, so. Oops. Out with the new As mentioned previously, WolfSSL helps us avoid most of the C99 stuff with the WOLF_C89 and NO_WOLF_C99 defines. Unfortunately, this doesn't seem to account for variadic macros. They were first supported with VC2005, so we'll have to work around it. They're all used as a way to NOP functions, so we can either patch simpler functions like so: // from ... #define X509_check_purpose(...) 0 // ... to #define X509_check_purpose(x) 0Or for more complex functions where I don't feel like faking ten parameters, we can define an __inline variadic function: // from... #define SSL_CTX_add_server_custom_ext(...) 0 // ... to __inline int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx, ...) { (void)(ctx); // avoid compiler complaints about unused parameters return 0; // return 0 }Lastly, although not a C99 feature, we need to stop wc_port.h from including \u003cintrin.h\u003e, since VC2003 doesn't include that. My understanding is VC2005 does, so we just change: #elif defined(_MSC_VER) /* Use MSVC compiler intrinsics for atomic ops */ #include \u003cintrin.h\u003eto: #elif _MSC_VER \u003e= 1400 /* Use MSVC compiler intrinsics for atomic ops */ #include \u003cintrin.h\u003eAnd now we're good. All done, ready to build. Just kidding, I forgot about WinSock There's one last function I couldn't just stub out: inet_pton. The prototype is pretty simple: INT WSAAPI inet_pton( [in] INT Family, [in] PCSTR pszAddrString, [out] PVOID pAddrBuf );In this case, Family can be either AF_INET or AF_INET6. You feed in a string representing the address (e.g., \"198.18.0.1\") and it writes either an IN_ADDR or IN6_ADDR struct, both more machine-readable than a C string. It's pretty convenient! It's also not a thing on old Windows versions. Windows 2000 only supports IPv6 as part of a technology preview. And on older versions of Windows, you definitely aren't gonna see that turtle dance. From what I can find, inet_pton was first supported in Windows Vista. So we'll have to write our own. That's pretty easy with inet_addr, which takes a C string and gives you an unsigned long. So, let's just build our own: #ifndef InetPton int __stdcall InetPton(int Family, const char *pszAddrString, void *pAddrBuf) { IN_ADDR *addr = pAddrBuf; unsigned long ulTmp; if (Family != AF_INET) { // Oops! We don't support that addr family WSASetLastError(WSAEAFNOSUPPORT); return -1; } if (!pAddrBuf || !pszAddrString || pszAddrString[0] == '\\0') { WSASetLastError(WSAEFAULT); return -1; } // Technically we could just put the return val directly // into addr-\u003eS_un.S_addr, but I don't like writing bad // data unless absolutely necessary. So store it in a temp // variable, first. ulTmp = inet_addr(pszAddrString); if (ulTmp == INADDR_NONE) { // Not an IP address WSASetLastError(WSAEFAULT); return -1; } // S_un.S_addr is an unsigned long. Easy! addr-\u003eS_un.S_addr = ulTmp; return 0; } #endif /* !InetPton */Now, this does throw a warning during compilation (\"incompatible types - from 'PCWSTR' to 'const char *'\"), but WolfSSL is already casting an ASCII string to PCWSTR. So I think it's fine. Probably. Deployment Visual Studio doesn't provide a great way of deploying to a random prefix along the lines of your standard make DESTDIR=whatever install. So I tried to replicate that with a script called install.js. It performs the following steps: Copies the include files in wolfssl to %DESTDIR%\\include\\wolfssl, excluding the files referenced by CMakeLists.txt; Writes a hardcoded set of options to %DESTDIR%\\include\\wolfssl\\options.h, similar to how it would be handled by CMake; and Copies the wolfssl.lib file to %DESTDIR%\\include\\wolfssl\\lib. From the repository root, it should be as simple as running: cscript install.js X:\\whatever Releaseto \"install\" the Release build. Step 2: cURL Now that we're done with the gauntlet of WolfSSL, installing cURL should be pretty straightforward! I mean, they provide a Makefile that they call out as compatible with Visual C++ 6.0. The README has no reference to WolfSSL—just MbedTLS or OpenSSL—but we'll come back to that later. For now, I want to see if this builds without TLS support. If you're following along, definitely read winbuild\\README.md first. I'm only going to talk about the switches I used, and you need to set up the dependencies in a certain way for the build system to find them. According to the README, we'll need the following switches set in the command line: I'm setting mode=static to make a static library, just to arbitrarily pick something. VC=7 is more for our reference, since it sets the \"full name\" of the library. It doesn't affect anything else that we care about.[6] ENABLE_IDN=no and ENABLE_IPV6=no, since our Windows versions don't support those. USE_SSPI=no, because some of the features used require higher than Windows 2000. So with that, we run the build: \u003e nmake /f Makefile.vc mode=static VC=7 ENABLE_IDN=no ENABLE_IPV6=no USE_SSPI=no Microsoft (R) Program Maintenance Utility Version 7.10.3077 Copyright (C) Microsoft Corporation. All rights reserved. configuration name: libcurl-vc7-x86-release-static The input line is too long. NMAKE : fatal error U1077: 'CALL' : return code '0xff' Stop. Ah. A Quick Aside About Batch Files no wait before you skip this, i promise it'll be quick The Windows NT Command Prompt (cmd.exe) has a maximum amount of characters per command you can write. UNIX-y shells have this limitation too, and you can see it by running getconf ARG_MAX. Per some old Microsoft docs, the maximum in Windows 2000 (and NT 4.0) is 2047 characters. When you surpass this limit, you get The input line is too long. In modern technical terms, this is called an \"annoyingly small limitation.\" So, why are we hitting this limit? Makefile.vc is calling out to gen_resp_file.bat, which takes a bunch of files as input and dumps them out as an NMake .inc file to be imported later on. For example: !INCLUDE \"../lib/Makefile.inc\" LIBCURL_OBJS=$(CSOURCES:.c=.obj) [...] @SET DIROBJ=$(LIBCURL_DIROBJ) @SET MACRO_NAME=LIBCURL_OBJS @SET OUTFILE=LIBCURL_OBJS.inc @CALL gen_resp_file.bat $(LIBCURL_OBJS)I won't copy the contents of \"../lib/Makefile.inc\", but there's a lot of files in there. Enough that we run up against this limit, but not when the batch file is run. The culprit is this loop in the batch file: for %%i in (%*) do echo %DIROBJ%/%%i \\\u003e\u003e %OUTFILE%%* is a variable representing all the arguments passed to the batch file. Unlike shells like bash, for loops don't get special treatment—the variables get expanded before the command line is run, and we trip over the 2047 character limit before we can even get to looping. So I'll make my own for loop, with SHIFT and GOTO: :loop IF [%1] == [] GOTO done echo %DIROBJ%/%1 \\\u003e\u003e %OUTFILE% SHIFT GOTO loop :doneIn this case, we only need to expand one parameter at a time, avoiding the command line limitation altogether. It might be slower, but on my Pentium II @ 400MHz, I couldn't tell. (Re)Configuring cURL Of course, \"compatible with Visual C++ 6.0\" doesn't necessarily mean \"compatible with wildly outdated operating systems.\" So there are a few extra changes to make. All of these changes can be made in lib\\config-win32.h in the source tree. Starting off: I cannot for the life of me figure out why __fseeki64 is defined in some versions of Visual C++ 6.0 and above, but not in others. It seems like it's probably not supported in Windows 9x anyway? So, sorry if you wanted to upload files larger than 2GiB, but I'm enforcing USE_WIN32_SMALL_FILES, which reverts to the old fseek function. cURL wants a type named ADDRESS_FAMILY, but it never gets defined. I think this is also defined in later WinSock versions, but it also doesn't really matter since we can just #define ADDRESS_FAMILY USHORT. Bonus Round: SMB cURL has SMB support using your TLS library of choice, which I'd like to keep. It does throw a couple errors that can be fixed, but the easiest workaround is defining CURL_DISABLE_SMB somewhere. If you, like me, care to stare into this abyss, you'll first have to return to WolfSSL and add the WOLFSSL_DES_ECB define to user_settings and the DEFINES array in install.js. Rebuild and reinstall, and you shouldn't see compile errors. For some reason, lib/smb.c defines getpid to GetCurrentProcessId, despite there already being a function in MSVC. This leads to a confusing error where GetCurrentProcessId gets \"re-declared\" in \u003cprocess.h\u003e. You can just remove this #define to resolve the issue. Supporting WolfSSL While we're already messing with build files, this seems like a good time to add WolfSSL support into the Makefile. You can already include MbedTLS with WITH_MBEDTLS=\u003cdll/static\u003e, so that seems like a good starting point. In MakefileBuild.vc: !IFDEF MBEDTLS_PATH MBEDTLS_INC_DIR = $(MBEDTLS_PATH)\\include MBEDTLS_LIB_DIR = $(MBEDTLS_PATH)\\lib MBEDTLS_LFLAGS = $(MBEDTLS_LFLAGS) \"/LIBPATH:$(MBEDTLS_LIB_DIR)\" !ELSE MBEDTLS_INC_DIR = $(DEVEL_INCLUDE) MBEDTLS_LIB_DIR = $(DEVEL_LIB) !ENDIF [...] !IF \"$(WITH_MBEDTLS)\"==\"dll\" || \"$(WITH_MBEDTLS)\"==\"static\" USE_MBEDTLS = true MBEDTLS = $(WITH_MBEDTLS) MBEDTLS_CFLAGS = /DUSE_MBEDTLS /I\"$(MBEDTLS_INC_DIR)\" MBEDTLS_LIBS = mbedtls.lib mbedcrypto.lib mbedx509.lib !ENDIF !IF \"$(USE_MBEDTLS)\"==\"true\" CFLAGS = $(CFLAGS) $(MBEDTLS_CFLAGS) LFLAGS = $(LFLAGS) $(MBEDTLS_LFLAGS) $(MBEDTLS_LIBS) !ENDIFFor the most part, we can just copy and paste these lines, changing MBEDTLS to WOLFSSL. The only other line to worry about is updating the library files to be... well, wolfssl.lib: WOLFSSL_LIBS = wolfssl.libAlso, now that we set USE_WOLFSSL, cURL will try to #include \u003cstdint.h\u003e. VC2003 doesn't provide that, so copy this public domain version that I patched into your deps/include folder. It's the same one that's been floating around the Internet for years, but I removed the WCHAR_MIN and WCHAR_MAX defines because they conflict with the ones in \u003cWindows.h\u003e. Compiling cURL \u003e nmake /f mode=static VC=7 ENABLE_IDN=no ENABLE_IPV6=no WITH_WOLFSSL=static USE_SSPI=noAssuming no errors occur, the completed curl.exe should be in builds\\libcurl-vc7-x86-release-static\\bin. But does it work? \u003e curl -kv https://bell.2ki.xyz * Host bell.2ki.xyz:443 was resolved. * IPv4: 209.251.245.54 * Trying 209.251.245.54:443... * Connected to bell.2ki.xyz (209.251.245.54) port 443 * SSL connection using TLSv1.3 / TLS13-AES128-GCM-SHA256 * using HTTP/1.x \u003e GET / HTTP/1.1 \u003e Host: bell.2ki.xyz \u003e User-Agent: curl/8.6.0 \u003e Accept: */* \u003e \u003c HTTP/1.1 200 OK \u003c Server: nginx/1.24.0 \u003c Date: Sat, 02 Mar 2024 00:52:43 GMT \u003c Content-Type: application/octet-stream \u003c Content-Length: 16 \u003c Connection: keep-alive \u003c It works! (TLS) * Connection #0 to host bell.2ki.xyz left intactAt least on my system, it seems so! What now? There are a few projects other than the aforementioned screenshot project that I think could be useful. Providing a WinHTTP.dll shim library is my first thought, although I imagine most services using that library are already dead. As you'll see in the build files for both projects, my next plan is to try for Windows 9x support. I don't currently have a 95/98 workstation readily available, but I'll update this post when I do. If you give it a try before then, please let me know!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv role=\"group\"\u003e\n                \u003ctd role=\"presentation\"\u003e\u003c/td\u003e\n                \n                                \n\n                \n                \u003ctd role=\"main\" colspan=\"2\"\u003e\n                \n\n            \u003cdiv id=\"post-body\"\u003e\n                \n                \u003cp\u003eCreated on 2024-03-03 at 14:04\u003c/p\u003e\n                \u003cp\u003eAs part of my current series of projects, I\u0026#39;ve been working on a screenshot tool intended for older Windows versions. The goal is to have something similar to \u003ca href=\"https://getsharex.com/\"\u003eShareX\u003c/a\u003e, a tool that lets you take a screenshot and post it online.\n\u003c/p\u003e\u003cp\u003eThese days, file sharing is done via the Hypertext Transfer Protocol (HTTP)\u003csup\u003e[\u003ca href=\"#fn:http\" id=\"fnref:http\"\u003e1\u003c/a\u003e]\u003c/sup\u003e, often using Transport Layer Security (TLS).\u003csup\u003e[\u003ca href=\"#fn:tls\" id=\"fnref:tls\"\u003e2\u003c/a\u003e]\u003c/sup\u003e Built into every version of Windows since Windows 95 is WinINet, which provides HTTP, FTP, and (in XP/2003 and earlier) Gopher. Obviously for older Windows versions, this library won\u0026#39;t include support for recent technologies like TLS 1.3 or HTTP/2. cURL still \u003ca href=\"https://github.com/curl/curl/tree/master/winbuild#readme\"\u003esupports Visual C++ 6\u003c/a\u003e, but that only provides the HTTP/FTP part. We\u0026#39;ll need a TLS library to get connected to most modern systems.\n\u003c/p\u003e\u003cdiv\u003e\u003cp\u003eNote: \u003cstrong\u003eAll patches and documentation here are experimental, and should not be considered secure.\u003c/strong\u003e My focus was on running something compliant with modern Web protocols, not improving the security posture of the system. Even if my patches haven\u0026#39;t compromised the code\u0026#39;s security, the versions of Visual C++ runtime and Windows involved have documented vulnerabilities that can affect libcurl and WolfSSL.\n\u003c/p\u003e\u003cp\u003eDon\u0026#39;t do your banking on Windows 2000, whether via IE6 or cURL 8.6.0.\n\u003c/p\u003e\u003c/div\u003e\u003ch2\u003ePrerequisites\n\u003c/h2\u003e\u003cp\u003eWhile I\u0026#39;m currently getting things running on Windows 2000 Professional SP4, I\u0026#39;d like to get this working on Windows 95 and 98 too. To that end, I\u0026#39;ll be using Visual Studio.NET 2003, which was the last version to support Windows 95. I\u0026#39;m also building everything \u003cem\u003ein\u003c/em\u003e Windows 2000, but that part\u0026#39;s optional.\n\u003c/p\u003e\u003cp\u003eYou\u0026#39;ll also need a copy of the Platform SDK from the era. I\u0026#39;m using the February 2003 MSDN release, for no other reason than it sounded like a good fit for VS2003.\n\u003c/p\u003e\u003cp\u003eAnd some general advice if you want to develop for old Windows versions: the MSDN Library that comes with VS2003 is \u003cem\u003eso\u003c/em\u003e much more useful than the version on the Internet. Today\u0026#39;s MSDN docs are a minefield of incorrect version information, and while I\u0026#39;m sure modern-day search engines are far better than WinHelp, the built-in search function is surprisingly useful.\n\u003c/p\u003e\u003ch2\u003eWolfSSL and Visual C++\n\u003c/h2\u003e\u003cp\u003eBefore we think about compiling cURL, we need a TLS library. In the past I\u0026#39;ve made hacks to OpenSSL to get it to build on pre-Vista Win32, but I\u0026#39;d really rather avoid that for something I share with others.\n\u003c/p\u003e\u003cp\u003eInspired by \u003ca href=\"https://www.dialup.net/wingpt/tls.html\"\u003ethe post on Dialup.net\u003c/a\u003e about building WolfSSL for Windows 3.11 for Workgroups, I decided that would be a better place to start.\n\u003c/p\u003e\u003cp\u003eAt first glance, I noticed a file named \u003ccode\u003ewolfssl.vcproj\u003c/code\u003e, indicating a pre-Visual C++ 2010 project. Good start, except the project was made in Visual Studio 2008.\u003csup\u003e[\u003ca href=\"#fn:vcvers\" id=\"fnref:vcvers\"\u003e3\u003c/a\u003e]\u003c/sup\u003e\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;Windows-1252\u0026#34;?\u0026gt;\n\u0026lt;VisualStudioProject\n        ProjectType=\u0026#34;Visual C++\u0026#34;\n        Version=\u0026#34;9.00\u0026#34;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eTo make matters worse, the project was woefully outdated. It was missing several files required to link, meaning I had to cherry-pick files as I got errors.\n\u003c/p\u003e\u003cp\u003eUnfortunately, there\u0026#39;s not a great way to automate this. So began the process of painstakingly adding files to the project until it compiled, using the CMakeLists.txt and  VC2010+ .vcxproj files as references.\n\u003c/p\u003e\u003ch3\u003eConfiguring WolfSSL\n\u003c/h3\u003e\u003cp\u003eAs is common with software written in C, configuration is handled via \u003ccode\u003e#define\u003c/code\u003e statements. WolfSSL helpfully allows you to override the usual configuration process by defining \u003ccode\u003eWOLFSSL_USER_SETTINGS\u003c/code\u003e. This allows us to use the configuration already used by the .vcproj: \u003ccode\u003eIDE/WIN/user_settings.h\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFiguring out the right defines took more troubleshooting than I care to describe, so here\u0026#39;s a lightning round:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003eFirst, force C89 by defining \u003ccode\u003eWOLF_C89\u003c/code\u003e and \u003ccode\u003eNO_WOLF_C99\u003c/code\u003e. More on this in a bit.\n\u003c/li\u003e\u003cli\u003eDisable \u003ccode\u003eWOLFSSL_SP_X86_64\u003c/code\u003e,since we won\u0026#39;t be running this on an x86_64 CPU.\n\u003c/li\u003e\u003cli\u003eWe don\u0026#39;t have \u003ccode\u003estrntok\u003c/code\u003e or \u003ccode\u003estrtok_s\u003c/code\u003e, so define \u003ccode\u003eUSE_WOLF_STRTOK\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe also have to define a few functions, so add them:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#define XSTRTOK wc_strtok\n#define XVSNPRINTF _vsnprintf\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe also need to define \u003ccode\u003estrcpy_s\u003c/code\u003e. My workaround was to use \u003ccode\u003eStringCchCopy\u003c/code\u003e, which is close enough? Probably? You need to \u003ccode\u003e#include \u0026lt;Winerror.h\u0026gt;\u003c/code\u003e first though, so later \u003ccode\u003e#include \u0026lt;Windows.h\u0026gt;\u003c/code\u003e lines don\u0026#39;t try to re-define the \u003ccode\u003eSUCCEEDED\u003c/code\u003e and \u003ccode\u003eFAILED\u003c/code\u003e macros. Win32 headers are annoying like that.\n\u003c/p\u003e\u003cdiv\u003e\u003ch3\u003eAside: What \u003cem\u003eis\u003c/em\u003e a C standard, really?\n\u003c/h3\u003e\u003cp\u003eA quick and inaccurate history: some guy at a phone company made a language named C.\u003csup\u003e[\u003ca href=\"#fn:chist\" id=\"fnref:chist\"\u003e4\u003c/a\u003e]\u003c/sup\u003e His coworkers were working on a bunch of different programs with it and thought it was useful, so a couple of them \u003ca href=\"https://openlibrary.org/books/OL4558528M/The_C_programming_language\"\u003ewrote a book\u003c/a\u003e about it.\n\u003c/p\u003e\u003cp\u003eWithout a standard, companies decided to make fifty different versions with their own features. To combat that, the American National Standards Institute (ANSI) decided they should make a standard about it, and took half a decade hashing out C89, or C90 if you\u0026#39;re more of an ISO person.\u003csup\u003e[\u003ca href=\"#fn:ansi1\" id=\"fnref:ansi1\"\u003e5\u003c/a\u003e]\u003c/sup\u003e Those guys from the phone company \u003ca href=\"http://s3-us-west-2.amazonaws.com/belllabs-microsite-dritchie/cbook/index.html\"\u003erewrote their book\u003c/a\u003e for that, too. The companies decided to follow at least those rules when making their fifty different versions.\n\u003c/p\u003e\u003cp\u003eThen, C99 arrived a decade later, with a ton of great features that everyone loved.\u003csup\u003e[\u003ci\u003ecitation needed\u003c/i\u003e]\u003c/sup\u003e Boolean types, variadic macros, the ability to declare variables wherever you want; all the classics.\n\u003c/p\u003e\u003cp\u003eVC2003 doesn\u0026#39;t support any of those though, so. Oops.\n\u003c/p\u003e\u003c/div\u003e\u003ch3\u003eOut with the new\n\u003c/h3\u003e\u003cp\u003eAs mentioned previously, WolfSSL helps us avoid most of the C99 stuff with the \u003ccode\u003eWOLF_C89\u003c/code\u003e and \u003ccode\u003eNO_WOLF_C99\u003c/code\u003e defines. Unfortunately, this doesn\u0026#39;t seem to account for variadic macros. They were first supported with VC2005, so we\u0026#39;ll have to work around it. They\u0026#39;re all used as a way to NOP functions, so we can either patch simpler functions like so:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// from ...\n#define X509_check_purpose(...)     0\n// ... to\n#define X509_check_purpose(x)       0\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOr for more complex functions where I don\u0026#39;t feel like faking ten parameters, we can define an \u003ccode\u003e__inline\u003c/code\u003e variadic function:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// from...\n#define SSL_CTX_add_server_custom_ext(...) 0\n// ... to\n__inline int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx, ...) {\n\t(void)(ctx); // avoid compiler complaints about unused parameters\n\treturn 0; // return 0\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLastly, although not a C99 feature, we need to stop \u003ccode\u003ewc_port.h\u003c/code\u003e from including \u003ccode\u003e\u0026lt;intrin.h\u0026gt;\u003c/code\u003e, since VC2003 doesn\u0026#39;t include that. My understanding is VC2005 does, so we just change:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#elif defined(_MSC_VER)\n     /* Use MSVC compiler intrinsics for atomic ops */\n     #include \u0026lt;intrin.h\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eto:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#elif _MSC_VER \u0026gt;= 1400\n     /* Use MSVC compiler intrinsics for atomic ops */\n     #include \u0026lt;intrin.h\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd \u003cem\u003enow\u003c/em\u003e we\u0026#39;re good. All done, ready to build.\n\u003c/p\u003e\u003ch3\u003eJust kidding, I forgot about WinSock\n\u003c/h3\u003e\u003cp\u003eThere\u0026#39;s one last function I couldn\u0026#39;t just stub out: \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton\"\u003e\u003ccode\u003einet_pton\u003c/code\u003e\u003c/a\u003e. The prototype is pretty simple:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eINT WSAAPI inet_pton(\n  [in]  INT   Family,\n  [in]  PCSTR pszAddrString,\n  [out] PVOID pAddrBuf\n);\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this case, \u003ccode\u003eFamily\u003c/code\u003e can be either \u003ccode\u003eAF_INET\u003c/code\u003e or \u003ccode\u003eAF_INET6\u003c/code\u003e. You feed in a string representing the address (e.g., \u003ccode\u003e\u0026#34;198.18.0.1\u0026#34;\u003c/code\u003e) and it writes either an \u003ccode\u003eIN_ADDR\u003c/code\u003e or \u003ccode\u003eIN6_ADDR\u003c/code\u003e struct, both more machine-readable than a C string. It\u0026#39;s pretty convenient!\n\u003c/p\u003e\u003cp\u003eIt\u0026#39;s also not a thing on old Windows versions. Windows 2000 only supports IPv6 as part of a \u003ca href=\"https://web.archive.org/web/20030410212855/http://msdn.microsoft.com/downloads/sdks/platform/tpipv6.asp\"\u003etechnology preview\u003c/a\u003e. And on older versions of Windows, you definitely aren\u0026#39;t gonna \u003ca href=\"https://www.kame.net/\"\u003esee that turtle dance\u003c/a\u003e. From what I can find, \u003ccode\u003einet_pton\u003c/code\u003e was first supported in \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/winsock/what-s-new-for-windows-sockets-2#updated-for-windows-vista\"\u003eWindows Vista\u003c/a\u003e. So we\u0026#39;ll have to write our own.\n\u003c/p\u003e\u003cp\u003eThat\u0026#39;s pretty easy with \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-inet_addr\"\u003e\u003ccode\u003einet_addr\u003c/code\u003e\u003c/a\u003e, which takes a C string and gives you an \u003ccode\u003eunsigned long\u003c/code\u003e.  So, let\u0026#39;s just build our own:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#ifndef InetPton\n\nint __stdcall\nInetPton(int Family,\n         const char *pszAddrString,\n         void *pAddrBuf)\n{\n        IN_ADDR *addr = pAddrBuf;\n        unsigned long ulTmp;\n        \n        if (Family != AF_INET) {\n\t\t        // Oops! We don\u0026#39;t support that addr family\n                WSASetLastError(WSAEAFNOSUPPORT);\n                return -1;\n        }\n\n        if (!pAddrBuf || !pszAddrString ||\n\t        pszAddrString[0] == \u0026#39;\\0\u0026#39;) {\n                WSASetLastError(WSAEFAULT);\n                return -1;\n        }\n\n\t\t// Technically we could just put the return val directly\n\t\t// into addr-\u0026gt;S_un.S_addr, but I don\u0026#39;t like writing bad\n\t\t// data unless absolutely necessary. So store it in a temp\n\t\t// variable, first.\n        ulTmp = inet_addr(pszAddrString);\n        if (ulTmp == INADDR_NONE) {\n\t\t        // Not an IP address\n                WSASetLastError(WSAEFAULT);\n                return -1;\n        }\n\n\t\t// S_un.S_addr is an unsigned long. Easy!\n        addr-\u0026gt;S_un.S_addr = ulTmp;\n        return 0;\n}\n\n#endif /* !InetPton */\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, this does throw a warning during compilation (\u0026#34;incompatible types - from \u0026#39;PCWSTR\u0026#39; to \u0026#39;const char *\u0026#39;\u0026#34;), but WolfSSL is already casting an ASCII string to PCWSTR. So I think it\u0026#39;s fine.\n\u003c/p\u003e\u003cp\u003eProbably.\n\u003c/p\u003e\u003ch3\u003eDeployment\n\u003c/h3\u003e\u003cp\u003eVisual Studio doesn\u0026#39;t provide a great way of deploying to a random prefix along the lines of your standard \u003ccode\u003emake DESTDIR=whatever install\u003c/code\u003e. So I tried to replicate that with a script called \u003ccode\u003einstall.js\u003c/code\u003e. It performs the following steps:\n\u003c/p\u003e\u003col\u003e\u003cli\u003eCopies the include files in \u003ccode\u003ewolfssl\u003c/code\u003e to \u003ccode\u003e%DESTDIR%\\include\\wolfssl\u003c/code\u003e, excluding the files referenced by CMakeLists.txt;\n\u003c/li\u003e\u003cli\u003eWrites a hardcoded set of options to \u003ccode\u003e%DESTDIR%\\include\\wolfssl\\options.h\u003c/code\u003e, similar to how it would be handled by CMake; and\n\u003c/li\u003e\u003cli\u003eCopies the wolfssl.lib file to \u003ccode\u003e%DESTDIR%\\include\\wolfssl\\lib\u003c/code\u003e.\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eFrom the repository root, it should be as simple as running:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecscript install.js X:\\whatever Release\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eto \u0026#34;install\u0026#34; the Release build.\n\u003c/p\u003e\u003ch2\u003eStep 2: cURL\n\u003c/h2\u003e\u003cp\u003eNow that we\u0026#39;re done with the gauntlet of WolfSSL, installing cURL should be pretty straightforward! I mean, they provide a Makefile that they call out as compatible with Visual C++ 6.0. The README has no reference to WolfSSL—just MbedTLS or OpenSSL—but we\u0026#39;ll come back to that later. For now, I want to see if this builds without TLS support.\n\u003c/p\u003e\u003cp\u003eIf you\u0026#39;re following along, definitely read \u003ccode\u003ewinbuild\\README.md\u003c/code\u003e first. I\u0026#39;m only going to talk about the switches I used, and you need to set up the dependencies in a certain way for the build system to find them.\n\u003c/p\u003e\u003cp\u003eAccording to the README, we\u0026#39;ll need the following switches set in the command line:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003eI\u0026#39;m setting \u003ccode\u003emode=static\u003c/code\u003e to make a static library, just to arbitrarily pick something.\n\u003c/li\u003e\u003cli\u003e\u003ccode\u003eVC=7\u003c/code\u003e is more for our reference, since it sets the \u0026#34;full name\u0026#34; of the library. It doesn\u0026#39;t affect anything else that we care about.\u003csup\u003e[\u003ca href=\"#fn:vc6\" id=\"fnref:vc6\"\u003e6\u003c/a\u003e]\u003c/sup\u003e\n\u003c/li\u003e\u003cli\u003e\u003ccode\u003eENABLE_IDN=no\u003c/code\u003e and \u003ccode\u003eENABLE_IPV6=no\u003c/code\u003e, since our Windows versions don\u0026#39;t support those.\n\u003c/li\u003e\u003cli\u003e\u003ccode\u003eUSE_SSPI=no\u003c/code\u003e, because some of the features used require higher than Windows 2000.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSo with that, we run the build:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; nmake /f Makefile.vc mode=static VC=7 ENABLE_IDN=no ENABLE_IPV6=no USE_SSPI=no\n\nMicrosoft (R) Program Maintenance Utility Version 7.10.3077\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nconfiguration name: libcurl-vc7-x86-release-static\nThe input line is too long.\nNMAKE : fatal error U1077: \u0026#39;CALL\u0026#39; : return code \u0026#39;0xff\u0026#39;\nStop.\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAh.\n\u003c/p\u003e\u003ch3\u003eA Quick Aside About Batch Files\n\u003c/h3\u003e\u003cp\u003eno wait before you skip this, i promise it\u0026#39;ll be quick\n\u003c/p\u003e\u003cp\u003eThe Windows NT Command Prompt (cmd.exe) has a maximum amount of characters per command you can write. UNIX-y shells have this limitation too, and you can see it by running \u003ccode\u003egetconf ARG_MAX\u003c/code\u003e. Per \u003ca href=\"https://web.archive.org/web/20070422141150/http://support.microsoft.com/kb/830473\"\u003esome old Microsoft docs\u003c/a\u003e, the maximum in Windows 2000 (and NT 4.0) is 2047 characters. When you surpass this limit, you get \u003ccode\u003eThe input line is too long.\u003c/code\u003e In modern technical terms, this is called an \u0026#34;annoyingly small limitation.\u0026#34;\n\u003c/p\u003e\u003cp\u003eSo, why are we hitting this limit? Makefile.vc is calling out to \u003ccode\u003egen_resp_file.bat\u003c/code\u003e, which takes a bunch of files as input and dumps them out as an NMake \u003ccode\u003e.inc\u003c/code\u003e file to be imported later on. For example:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e!INCLUDE \u0026#34;../lib/Makefile.inc\u0026#34;\nLIBCURL_OBJS=$(CSOURCES:.c=.obj)\n\n[...]\n\t@SET DIROBJ=$(LIBCURL_DIROBJ)\n\t@SET MACRO_NAME=LIBCURL_OBJS\n\t@SET OUTFILE=LIBCURL_OBJS.inc\n\t@CALL gen_resp_file.bat $(LIBCURL_OBJS)\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI won\u0026#39;t copy the contents of \u003ccode\u003e\u0026#34;../lib/Makefile.inc\u0026#34;\u003c/code\u003e, but there\u0026#39;s a lot of files in there. Enough that we run up against this limit, but not when the batch file is run. The culprit is this loop in the batch file:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efor %%i in (%*) do echo         %DIROBJ%/%%i \\\u0026gt;\u0026gt; %OUTFILE%\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e%*\u003c/code\u003e is a variable representing all the arguments passed to the batch file. Unlike shells like bash, for loops don\u0026#39;t get special treatment—the variables get expanded before the command line is run, and we trip over the 2047 character limit before we can even get to looping.\n\u003c/p\u003e\u003cp\u003eSo I\u0026#39;ll make my own for loop, with \u003ccode\u003eSHIFT\u003c/code\u003e and \u003ccode\u003eGOTO\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e:loop\nIF [%1] == [] GOTO done\necho            %DIROBJ%/%1 \\\u0026gt;\u0026gt; %OUTFILE%\nSHIFT\nGOTO loop\n:done\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this case, we only need to expand one parameter at a time, avoiding the command line limitation altogether. It might be slower, but on my Pentium II @ 400MHz, I couldn\u0026#39;t tell.\n\u003c/p\u003e\u003ch3\u003e(Re)Configuring cURL\n\u003c/h3\u003e\u003cp\u003eOf course, \u0026#34;compatible with Visual C++ 6.0\u0026#34; doesn\u0026#39;t necessarily mean \u0026#34;compatible with wildly outdated operating systems.\u0026#34; So there are a few extra changes to make. All of these changes can be made in \u003ccode\u003elib\\config-win32.h\u003c/code\u003e in the source tree.\n\u003c/p\u003e\u003cp\u003eStarting off: I cannot for the life of me figure out why \u003ccode\u003e__fseeki64\u003c/code\u003e is defined in some versions of Visual C++ 6.0 and above, but not in others. It seems like it\u0026#39;s probably not supported in Windows 9x anyway? So, sorry if you wanted to upload files larger than 2GiB, but I\u0026#39;m enforcing \u003ccode\u003eUSE_WIN32_SMALL_FILES\u003c/code\u003e, which reverts to the old \u003ccode\u003efseek\u003c/code\u003e function.\n\u003c/p\u003e\u003cp\u003ecURL wants a type named \u003ccode\u003eADDRESS_FAMILY\u003c/code\u003e, but it never gets defined. I think this is also defined in later WinSock versions, but it also doesn\u0026#39;t really matter since we can just \u003ccode\u003e#define ADDRESS_FAMILY USHORT\u003c/code\u003e.\n\u003c/p\u003e\u003cdiv\u003e\u003ch3\u003eBonus Round: SMB\n\u003c/h3\u003e\u003cp\u003ecURL has SMB support using your TLS library of choice, which I\u0026#39;d like to keep. It does throw a couple errors that can be fixed, but the easiest workaround is defining \u003ccode\u003eCURL_DISABLE_SMB\u003c/code\u003e somewhere.\n\u003c/p\u003e\u003cp\u003eIf you, like me, care to stare into this abyss, you\u0026#39;ll first have to return to WolfSSL and add the \u003ccode\u003eWOLFSSL_DES_ECB\u003c/code\u003e define to \u003ccode\u003euser_settings\u003c/code\u003e and the \u003ccode\u003eDEFINES\u003c/code\u003e array in \u003ccode\u003einstall.js\u003c/code\u003e. Rebuild and reinstall, and you shouldn\u0026#39;t see compile errors.\n\u003c/p\u003e\u003cp\u003eFor some reason, \u003ccode\u003elib/smb.c\u003c/code\u003e defines \u003ccode\u003egetpid\u003c/code\u003e to \u003ccode\u003eGetCurrentProcessId\u003c/code\u003e, despite there already being a function in MSVC. This leads to a confusing error where \u003ccode\u003eGetCurrentProcessId\u003c/code\u003e gets \u0026#34;re-declared\u0026#34; in \u003ccode\u003e\u0026lt;process.h\u0026gt;\u003c/code\u003e. You can just remove this \u003ccode\u003e#define\u003c/code\u003e to resolve the issue.\n\u003c/p\u003e\u003c/div\u003e\u003ch3\u003eSupporting WolfSSL\n\u003c/h3\u003e\u003cp\u003eWhile we\u0026#39;re already messing with build files, this seems like a good time to add WolfSSL support into the Makefile. You can already include MbedTLS with \u003ccode\u003eWITH_MBEDTLS=\u0026lt;dll/static\u0026gt;\u003c/code\u003e, so that seems like a good starting point. In \u003ccode\u003eMakefileBuild.vc\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e!IFDEF MBEDTLS_PATH\nMBEDTLS_INC_DIR  = $(MBEDTLS_PATH)\\include\nMBEDTLS_LIB_DIR  = $(MBEDTLS_PATH)\\lib\nMBEDTLS_LFLAGS   = $(MBEDTLS_LFLAGS) \u0026#34;/LIBPATH:$(MBEDTLS_LIB_DIR)\u0026#34;\n!ELSE\nMBEDTLS_INC_DIR  = $(DEVEL_INCLUDE)\nMBEDTLS_LIB_DIR  = $(DEVEL_LIB)\n!ENDIF\n\n[...]\n\n!IF \u0026#34;$(WITH_MBEDTLS)\u0026#34;==\u0026#34;dll\u0026#34; || \u0026#34;$(WITH_MBEDTLS)\u0026#34;==\u0026#34;static\u0026#34;\nUSE_MBEDTLS    = true\nMBEDTLS        = $(WITH_MBEDTLS)\nMBEDTLS_CFLAGS = /DUSE_MBEDTLS /I\u0026#34;$(MBEDTLS_INC_DIR)\u0026#34;\nMBEDTLS_LIBS   = mbedtls.lib mbedcrypto.lib mbedx509.lib\n!ENDIF\n\n!IF \u0026#34;$(USE_MBEDTLS)\u0026#34;==\u0026#34;true\u0026#34;\nCFLAGS = $(CFLAGS) $(MBEDTLS_CFLAGS)\nLFLAGS = $(LFLAGS) $(MBEDTLS_LFLAGS) $(MBEDTLS_LIBS)\n!ENDIF\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor the most part, we can just copy and paste these lines, changing \u003ccode\u003eMBEDTLS\u003c/code\u003e to \u003ccode\u003eWOLFSSL\u003c/code\u003e. The only other line to worry about is updating the library files to be... well, \u003ccode\u003ewolfssl.lib\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eWOLFSSL_LIBS    = wolfssl.lib\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAlso, now that we set \u003ccode\u003eUSE_WOLFSSL\u003c/code\u003e, cURL will try to \u003ccode\u003e#include \u0026lt;stdint.h\u0026gt;\u003c/code\u003e. VC2003 doesn\u0026#39;t provide that, so copy \u003ca href=\"https://git.2ki.xyz/snow/curl32-build/raw/branch/trunk/stdint.h\"\u003ethis public domain version that I patched\u003c/a\u003e into your \u003ccode\u003edeps/include\u003c/code\u003e folder. It\u0026#39;s the same one that\u0026#39;s been floating around the Internet for years, but I removed the \u003ccode\u003eWCHAR_MIN\u003c/code\u003e and \u003ccode\u003eWCHAR_MAX\u003c/code\u003e defines because they conflict with the ones in \u003ccode\u003e\u0026lt;Windows.h\u0026gt;\u003c/code\u003e.\n\u003c/p\u003e\u003ch3\u003eCompiling cURL\n\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; nmake /f mode=static VC=7 ENABLE_IDN=no ENABLE_IPV6=no WITH_WOLFSSL=static USE_SSPI=no\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAssuming no errors occur, the completed \u003ccode\u003ecurl.exe\u003c/code\u003e should be in \u003ccode\u003ebuilds\\libcurl-vc7-x86-release-static\\bin\u003c/code\u003e. But does it work?\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026gt; curl -kv https://bell.2ki.xyz\n* Host bell.2ki.xyz:443 was resolved.\n* IPv4: 209.251.245.54\n*   Trying 209.251.245.54:443...\n* Connected to bell.2ki.xyz (209.251.245.54) port 443\n* SSL connection using TLSv1.3 / TLS13-AES128-GCM-SHA256\n* using HTTP/1.x\n\u0026gt; GET / HTTP/1.1\n\u0026gt; Host: bell.2ki.xyz\n\u0026gt; User-Agent: curl/8.6.0\n\u0026gt; Accept: */*\n\u0026gt;\n\u0026lt; HTTP/1.1 200 OK\n\u0026lt; Server: nginx/1.24.0\n\u0026lt; Date: Sat, 02 Mar 2024 00:52:43 GMT\n\u0026lt; Content-Type: application/octet-stream\n\u0026lt; Content-Length: 16\n\u0026lt; Connection: keep-alive\n\u0026lt;\nIt works! (TLS)\n* Connection #0 to host bell.2ki.xyz left intact\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt least on my system, it seems so!\n\u003c/p\u003e\u003ch2\u003eWhat now?\n\u003c/h2\u003e\u003cp\u003eThere are a few projects other than the aforementioned screenshot project that I think could be useful. Providing a WinHTTP.dll shim library is my first thought, although I imagine most services using that library are already dead.\n\u003c/p\u003e\u003cp\u003eAs you\u0026#39;ll see in the build files for both projects, my next plan is to try for Windows 9x support. I don\u0026#39;t currently have a 95/98 workstation readily available, but I\u0026#39;ll update this post when I do. If you give it a try before then, please let me know!\n\u003c/p\u003e\n            \u003c/div\u003e\n            \n            \n                \n                \u003c/td\u003e\n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": null,
  "modifiedTime": null
}
