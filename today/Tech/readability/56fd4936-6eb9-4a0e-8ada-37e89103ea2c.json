{
  "id": "56fd4936-6eb9-4a0e-8ada-37e89103ea2c",
  "title": "Why Safety Profiles Failed",
  "link": "https://www.circle-lang.org/draft-profiles.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 24 Oct 2024 21:26:09 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 37206,
  "excerpt": "As for dangling pointers and for ownership, this model detects all possible errors. This means that we can guarantee that a program is free of uses of invalidated pointers.",
  "siteName": "",
  "favicon": "",
  "text": "Contents 1 Abstract 2 C++ is under-specified 2.1 Inferring aliasing 2.2 Inferring lifetimes 2.3 Inferring safeness 3 Lifetime safety is static typing 4 Lifetime parameters don’t cause soundness bugs 5 C++ is too irregular for Profiles 5.1 C++ cannot enforce exclusivity 6 Carcinization 7 C++ in the future 8 References Abstract As for dangling pointers and for ownership, this model detects all possible errors. This means that we can guarantee that a program is free of uses of invalidated pointers. – A brief introduction to C++’s model for type- and resource- safety[type-and-resource-safety-2015] Safety Profiles were introduced in 2015 with the promise to detect all lifetime safety defects in existing C++ code. It was a bold claim. But after a decade of effort, Profiles failed to produce a specification, reliable implementation or any tangible benefit for C++ safety. The cause of this failure involves a number of mistaken premises at the core of its design: “Zero annotation is required by default, because existing C++ source code already contains sufficient information”[P3465R0] “We should not require a safe function annotation”[P3446R0] “Do not add a feature that requires viral annotation”[P3466R0] “Do not add a feature that requires heavy annotation”[P3466R0] The parameters of the problem make success impossible. This paper examines the contradictions in these premises, explains why the design didn’t improve safety in the past and why it won’t improve safety in the future. C++ is under-specified Zero annotation is required by default, because existing C++ source code already contains sufficient information. – Pursue [P1179R1] as a Lifetime Safety TS[P3465R0] C++ source code does not have sufficient information for achieving memory safety. A C++ function declaration lacks three things that are critical for lifetime safety: Aliasing information. Lifetime information. Safeness information. Functions involving parameter types with pointer or reference semantics have implicit aliasing, lifetime and safeness requirements. Safety Profiles cannot recover these properties from C++ code, because there are no language facilities to describe them. These requirements are only specified in documentation, if they are specified at all. Inferring aliasing A C++ compiler can infer nothing about aliasing from a function declaration. A function parameter with a mutable reference might always alias other parameters, it might never alias other parameters, or it might not care about aliasing other parameters. // i and j must always alias. They must refer to the same container. void f1(std::vector\u003cint\u003e::iterator i, std::vector\u003cint\u003e::iterator j) { // If i and j point into different vectors, you have real problems. std::sort(i, j); } // vec must not alias x. void f2(std::vector\u003cint\u003e\u0026 vec, int\u0026 x) { // Resizing vec may invalidate x if x is a member of vec. vec.push_back(5); // Potential use-after-free. x = 6; } // vec may or may not alias x. It doesn't matter. void f3(std::vector\u003cint\u003e\u0026 vec, const int\u0026 x) { vec.push_back(x); } f1 and f2 have aliasing requirements. In f1, both iterators must point into the same container. In f2, x must not come from the container vec. These requirements are only visible as documentation. The compiler cannot infer a function’s aliasing requirements from its declaration or even from its definition. If the safety profile enforces no mutable aliasing, then the definitions of f1 and f3 will fail to compile, breaking your program. int main() { std::vector\u003cint\u003e vec1, vec2; // *Incorrectly* permits call. // UB, because the iterators point into different containers. f1(vec1.begin(), vec2.end()); // *Incorrectly* rejects call. // This is the correct usage, but mutable aliasing prevents compilation. f1(vec1.begin(), vec1.end()); // *Correctly* rejects call. f2(vec1, vec1[2]); // *Incorrectly* rejects call. f3(vec1, vec1[2]); } Profiles chose the wrong convention for several uses. It permits the incorrect call to f1 to compile, but rejects a correct usage of f1 on the grounds of mutable aliasing. An unsound call to f2 is correctly rejected, but a sound call to f3 is also rejected. Rejecting or permitting code (rightly or wrongly) is a matter of coincidence, not intelligence. Without language-level aliasing information, compile-time memory safety is not possible. This requirement is the motivation for Rust’s borrow type. A mutable borrow cannot alias other borrows. That’s enforced by the borrow checker. Raw pointers have no aliasing requirements, but are unsafe to dereference. In general, things that can be checked by the compiler are checked, and things that can’t be checked are unsafe to use. (Compiler Explorer) #include \u003cvector\u003e #include \u003ciostream\u003e void func(std::vector\u003cint\u003e\u0026 vec, int\u0026 x) { vec.push_back(1); x = 2; // A write-after-free when x is a member of vec! } int main() { std::vector\u003cint\u003e vec; vec.push_back(1); func(vec, vec[0]); std::cout\u003c\u003c vec[0]\u003c\u003c \"\\n\"; std::cout\u003c\u003c vec[1]\u003c\u003c \"\\n\"; } The Safety Profiles partial reference implementation can’t prevent aliasing-related undefined behavior because C++ doesn’t provide aliasing information. Inferring lifetimes A C++ compiler can infer nothing about lifetimes from a function declaration. A reference return type may be constrained by the lifetimes of any number of reference parameters, by none of the reference parameters, or by some other lifetime. // The returned reference is only constrained by the lifetime of the map // parameter. // It is not constrained by the lifetime of the key parameter. const int\u0026 f4(std::map\u003cint, int\u003e\u0026 map, const int\u0026 key) { return map[key]; } // The returned reference is constrained by the lifetime of both x and y // parameters. const int\u0026 f5(const int\u0026 x, const int\u0026 y) { return std::min(x, y); } // The returned reference is not constrained by the lifetime of any // reference parameter. const int\u0026 f6(const int\u0026 key) { static std::map\u003cint, int\u003e map; return map[key]; } These three functions have different lifetime requirements, which are indicated by comments. This information is available to developers but not to the compiler. What’s the strategy to uphold these lifetime requirements? Read the documentation, read the code, and don’t make mistakes. int main() { std::map\u003cint, int\u003e map; // r4 is constrained by lifetimes of map and 40. int\u0026 r4 = f4(map, 40); // *Incorrectly* rejects usage of r4. r4 is constrained to the lifetime // of the temporary 40, which expired at the end of the above statement. int x = r4; // r5 is constrained by lifetimes of 50 and 51. const int\u0026 r5 = f5(50, 51); // *Correctly* rejects usage of r5. The reference refers to one of the // two expired temporaries. This use would be a use-after-free. int y = r5; // r6 is constrained by the lifetime of 60. const int\u0026 r6 = f6(60); // *Incorrectly* rejects usage of r6. // The return reference r6 should not be constrained by the lifetime of 60. int z = r6; } Profiles take a similarly conservative approach to lifetimes as they do with aliasing. The lifetime of a returned reference is constrained by the lifetimes of all of its arguments. This is fortuitous for a function like std::min, which returns a reference to either of its function parameters. It’s bad for a function like std::map\u003cT\u003e::operator[], which takes a key argument by reference but returns a reference that’s only constrained by the lifetime of this. Since the compiler has no information about function parameter lifetimes, it can’t accurately flag out-of-contract function calls. f4 and f6 take references to temporary objects but return references that should not be constrained to that temporary. In both cases, the safety profile rejects a subsequent use of the reference as a use-after-free, because it applies a too-conservative convention. The need for explicit lifetime information in function types is the motivation for Rust’s lifetime arguments. A returned reference must be annotated with a lifetime parameter that is constrained by a function parameter on the same function, or it must be static. The alternative is to be deluged with an impossible quantity of use-after-free false positives. (Compiler Explorer) #include \u003cmap\u003e #include \u003cutility\u003e const int\u0026 f4(std::map\u003cint, int\u003e\u0026 map, const int\u0026 key) { return map[key]; } int main() { std::map\u003cint, int\u003e map; const int\u0026 ref = f4(map, 200); int x = ref; } \u003csource\u003e:11:11: warning: dereferencing a dangling pointer [-Wlifetime] int x = ref; ^~~ \u003csource\u003e:10:32: note: temporary was destroyed at the end of the full expression const int\u0026 ref = f4(map, 200); ^ The Safety Profiles reference implementation can’t accurately deal with lifetimes because C++ doesn’t provide lifetime information. The tool doesn’t test for correctness, it only tests if your code conforms to a pre-chosen convention. Inferring safeness We should not require a safe function annotation that has the semantics that a safe function can only call other safe functions. – (Re)affirm design principles for future C++ evolution[P3446R0] Recall what “safe” actually means: A safe function has defined behavior for all valid inputs. An unsafe function has soundness preconditions. Calling an unsafe function with out-of-contract inputs may result in undefined behavior. A C++ compiler can infer nothing about safeness from a function declaration. It can’t by tell by looking what constitutes an out-of-contract call and what doesn’t. A safe-specifier indicates the presence of soundness preconditions. An unsafe-block permits the user to escape the safe context, prove the preconditions, and call the unsafe function. template\u003ctypename T\u003e class vector { public: size_t size() const noexcept safe { return _len; } T\u0026 operator[](size_t index) noexcept safe { // Can call size() because it's a safe function. if(index \u003e= size()) panic(\"Out-of-bounds vector::operator[]\"); unsafe { // Pointer operations only allowed in unsafe context. // Safety proof: // The allocation has size() valid elements and index \u003c size(). return _data[index]; } } private: T* _data; size_t _len, _cap; }; Let’s take a really simple case: vector::operator[]. Profiles have to reject pointer arithmetic, because there’s no static analysis protection against indexing past the end of the allocation. How is the compiler told to permit the raw pointer subscript in the return-statement in vector::operator[]? In Rust and Safe C++, enter an unsafe-block. This design distinguishes safe functions, which have no soundness preconditions and can be called from other safe functions, and unsafe functions, which require an unsafe-block escape to use, just like pointer operations. Separation of safe and unsafe functions is common in memory-safe languages. Rust and C#[csharp] include an unsafe function specifier and an unsafe-block construct. This is a human- and tooling-readable tag for auditing potential origins of soundness defects. Aliasing and lifetimes are transitive properties that must be recoverable from a function declaration in order to be upheld. Safeness (the lack of soundness preconditions) is another transitive property that must be marked in a function declaration. The way to do that is with a safe-specifier. template\u003c class RandomIt \u003e void sort( RandomIt first, RandomIt last ); Let’s consider another example: the std::sort API that takes two random-access iterators. This is an unsafe function because it exhibits undefined behavior if called with the wrong arguments. But there’s nothing in the type system to indicate that it has soundness preconditions, so the compiler doesn’t know to reject calls in safe contexts. What are sort’s preconditions? The first and last iterators must point at elements from the same container. first must not indicate an element that appears after last. first and last may not be dangling iterators. In the absence of a enforced safeness information, it’s up to the user to follow the documentation and satisfy the requirements. Guidance for calling unsafe functions is essentially “don’t write bugs.” void func(std::vector\u003cint\u003e vec1, std::vector\u003cint\u003e vec2) { // #1 - *Incorrectly* rejects correct call for mutable aliasing sort(vec1.begin(), vec1.end()); // #2 - *Incorrectly* permits out-of-contract call. sort(vec1.begin(), vec2.end()); } In the Profiles model, the correct call to sort #1 is rejected due to mutable aliasing. That’s bad, but permitting the out-of-contract call #2 is worse, because it’s a soundness bug. There’s no realistic static analysis technology to verify that a call to sort meets its preconditions. Even the safety profile with the most conservative aliasing setting lets this call through. This is where safe and unsafe specifiers play an important role. From the caller’s perspective, sort is unsafe because it has preconditions that must be upheld without the compiler’s help. From the callee’s perspective, sort is unsafe because it’s written with unsafe operations. Pointer differencing computes a pivot for the sort, and pointer differencing is undefined when its operands point to different allocations. // No safe-specifier means unsafe. void sort(vector\u003cint\u003e::iterator begin, vector\u003cint\u003e::iterator end); // A safe-specifier means it can only call safe functions. void func(vector\u003cint\u003e vec1, vector\u003cint\u003e vec2) safe { // Ill-formed: sort is an unsafe function. // Averts potential undefined behavior. sort(vec1.begin(), vec2.end()); unsafe { // Well-formed: call unsafe function from unsafe context. // Safety proof: // sort requires both iterators point into the same container. // Here, they both point into vec1. sort(vec1.begin(), vec1.end()); } } The only way to enforce memory safety is to separate safe and unsafe functions with a safe-specifier. In this example, func is safe because it’s defined for all valid inputs. It cannot call sort, because that has soundness preconditions: the two iterators must point into the same container. A call to sort in a safe context leaves the program ill-formed, because the compiler cannot guarantee that the preconditions are satisfied. But by entering an unsafe-block, the user can prove the preconditions and make the unsafe call without the compiler’s soundness guarantees. [P3081R0] does float a [[suppress(profile)]] attribute to turn off certain Profiles checkes. It looks like the equivalent of an unsafe-block. It may permit pointer operations in a definition, but it doesn’t address the other side of the call: without a safe-specifier, how does the Profiles design deal with functions like sort that are inherently unsafe? They must be separated from provably safe functions. User intervention, wrapped up in unsafe-blocks, is needed to satisfy their preconditions. Without this bump of impedance the language cannot guarantee safety, as the property that a safe functions contains no undefined behavior is not transitively upheld. (Compiler Explorer) #include \u003cmemory\u003e #include \u003cvector\u003e #include \u003calgorithm\u003e int main() { std::vector\u003cint\u003e v1, v2; v1.push_back(1); v2.push_back(2); // UB! std::sort(v1.end(), v2.end()); } Program returned: 139 double free or corruption (out) Program terminated with signal: SIGSEGV The Safety Profiles reference implementation can’t deal with unsafe functions, because C++ doesn’t know which functions are unsafe. This out-of-contract call produces a heap double-free and then segfaults. Lifetime safety is static typing Do not add a feature that requires viral annotation. – (Re)affirm design principles for future C++ evolution[P3446R0] Rust’s safety model incorporates lifetime arguments on every reference (or struct with reference semantics) that occurs in a function type. The authors of Profiles disparagingly call these “viral annotations.” Don’t be scared. C++ has always been full of viral annotations: types are viral annotations. Types establish type safety properties that are enforced by both the caller and callee. These properties are transitive (i.e. viral) because they’re enforced through any number of function calls, creating a network of reasoning from the point where an object is created to all of its uses. Languages that treat types as viral annotations are statically-typed languages. Languages that don’t are dynamically-typed languages. These have well-known trade-offs. Statically-typed languages exhibit higher performance and provide more information to developers; programs in a statically-typed language may be easier to reason about. Dynamically-typed languages are much simpler and can be more productive. Lifetime parameters, which provide crucial information to the compiler to enable rigorous safety analysis, defines another axis of typing. Rust has static lifetimes, which is a high-performance, high-information approach to memory safety. Users can reason about lifetimes and aliasing because those concepts are built into the language. The compiler has sufficient information to rigorously enforce lifetime safety with borrow checking. Most other memory-safe languages use dynamic lifetimes, of which garbage collection is an implementation. Instead of enforcing lifetimes and exclusivity at compile time, the garbage collector manages objects on the heap and extends their scope as long as there are live references to them. This has the same basic trade-off as dynamic typing: simplicity at the cost of performance. Static lifetimes Dynamic lifetimes Static types Rust Java, Go Dynamic types - Javascript, Python The static types/static lifetimes quadrant is a new area of language design, at least for languages widely used in production. The principles may be unfamiliar. Lifetime annotations feel different than type annotations because they establish relationships between parameters and return types rather than on individual parameters and objects. Instead of answering the question “What are the properties of this entity?” they answer “How does this entity relate to other entities?”. Profiles fail because they reject, as a design principle, the specific language improvements that provide necessary lifetime information for compile-time safety. Lifetime parameters don’t cause soundness bugs Annotations are distracting, add verbosity, and some can be wrong (introducing the kind of errors they are assumed to help eliminate). – Profile invalidation - eliminating dangling pointers[P3446R0] This is not right. In a memory-safe language you can’t introduce undefined behavior with mere coding mistakes. That’s the whole point of memory safety. If you put the wrong lifetime annotation on a parameter, your program becomes ill-formed, not undefined. A mistaken use of lifetime parameters can be an ergonomics bug, or it can mask undefined behavior when wrapping an unsafe function in a safe interface, but it can’t cause undefined behavior. (Compiler Explorer) fn f1\u003c'a, 'b\u003e(x:\u0026'a i32, y:\u0026'b i32) -\u003e \u0026'b i32 { return x; } error: lifetime may not live long enough --\u003e lifetime1.rs:5:10 | 4 | fn f1\u003c'a, 'b\u003e(x:\u0026'a i32, y:\u0026'b i32) -\u003e \u0026'b i32 { | -- -- lifetime `'b` defined here | | | lifetime `'a` defined here 5 | return x; | ^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a` | = help: consider adding the following bound: `'a: 'b` Lifetime constraints are a contract between the caller and callee. If either side violates the contract, the program is ill-formed. In the code above, the lifetime constraints are violated by the callee. The lifetime of the x parameter does not outlive the lifetime of the returned reference. We used the wrong annotation, but instead of leading to undefined behavior, the compiler produces a detailed message that explains how the lifetime contract was not met. (Compiler Explorer) fn f2\u003c'a, 'b\u003e(x:\u0026'a i32, y:\u0026'b i32) -\u003e \u0026'b i32 { // Well-formed. The lifetime on y outlives the lifetime on // the return reference. return y; } fn f3() { let x = 1; let r:\u0026i32; { let y = 2; r = f2(\u0026x, \u0026y); } // Ill-formed: r depends on y, which is out of scope. let z = *r; } error[E0597]: `y` does not live long enough --\u003e lifetime2.rs:15:16 | 14 | let y = 2; | - binding `y` declared here 15 | r = f2(\u0026x, \u0026y); | ^^ borrowed value does not live long enough 16 | } | - `y` dropped here while still borrowed ... 19 | let z = *r; | -- borrow later used here Let’s fix the implementation of the callee and test a broken version of the caller. The returned reference depends on y, but it’s used after y goes out of scope. The compiler rejects the program and tells us “y does not live long enough.” The use of lifetime annotations on parameters is the same as the use of type annotations on parameters: it turns an intractable whole-program analysis problem into an easy-to-enforce local-analysis problem. Lifetime annotations, which exist to guarantee safety, do not jeopardize safety. C++ is too irregular for Profiles Do not add a feature that requires heavy annotation. “Heavy” means something like “more than 1 annotation per 1,000 lines of code.” – (Re)affirm design principles for future C++ evolution[P3446R0] We have an implemented approach that requires near-zero annotation of existing source code. – Pursue [P1179R1] as a Lifetime TS[P3465R0] Central to Safety Profiles is the claim that annotations are exceptional rather than the norm. For this to be true, the great bulk of C++ would need to be written according to some preferred convention. [P1179R1] chooses “no mutable aliasing” and constrains reference return types to all reference parameters. Let’s consider a number of Standard Library functions and compare their aliasing and exclusivity requirements to those conventions. Functions that don’t adhere to these conventions must be annotated, and those annotations must be virally propagated up the stack to all callers, as aliasing and lifetime requirements are transitive. Only functions that have no soundness preconditions can be considered safe. Let’s start in \u003calgorithm\u003e and work through alphabetically, indicating how functions deviate from the Safety Profile’s aliasing and lifetime conventions: // Unsafe! // Precondition: `first` and `last` must alias. template\u003c class InputIt, class UnaryPred \u003e bool all_of( InputIt first, InputIt last, UnaryPred p ); template\u003c class InputIt, class UnaryPred \u003e bool any_of( InputIt first, InputIt last, UnaryPred p ); template\u003c class InputIt, class UnaryPred \u003e bool none_of( InputIt first, InputIt last, UnaryPred p ); // Unsafe! // Precondition 1: `first` and `last` must alias. // Lifetime: The return type is not constrained by the lifetime of `value` template\u003c class InputIt, class T \u003e InputIt find( InputIt first, InputIt last, const T\u0026 value ); template\u003c class InputIt, class UnaryPred \u003e InputIt find_if( InputIt first, InputIt last, UnaryPred p ); template\u003c class InputIt, class UnaryPred \u003e InputIt find_if_not( InputIt first, InputIt last, UnaryPred q ); // Unsafe! // Precondition 1: `first` and `last` must alias. // Precondition 2: `s_first` and `s_last` must alias. // Lifetime: The return type is not constrained by the lifetime of `s_first` // or `s_last`. template\u003c class InputIt, class ForwardIt \u003e InputIt find_first_of( InputIt first, InputIt last, ForwardIt s_first, ForwardIt s_last ); // Unsafe! // Precondition 1: `first` and `last` must alias. template\u003c class ForwardIt \u003e ForwardIt adjacent_find( ForwardIt first, ForwardIt last ); // Unsafe! // Precondition 1: `first1` and `last2` must alias. // Lifetime: The returned Input1 is constrained only by `first1` and `last1` // Lifetime: The returned Input2 is constrained only by `first2`. template\u003c class InputIt1, class InputIt2 \u003e std::pair\u003cInputIt1, InputIt2\u003e mismatch( InputIt1 first1, InputIt1 last1, InputIt2 first2 ); // Unsafe! // Precondition 1: `first` and `last` must alias. // Precondition 2: `s_first` and `s_last` must alias. // Lifetime: The returned ForwardIt1 is constrained only by `first` and `last` template\u003c class ForwardIt1, class ForwardIt2 \u003e ForwardIt1 search( ForwardIt1 first, ForwardIt1 last, ForwardIt2 s_first, ForwardIt2 s_last ); The functions in \u003calgorithms\u003e mostly involve iterators which are inherently unsafe. Additionally, the lifetime convention chosen by Profiles is frequently wrong: the lifetime of a returned reference rarely is constrained by the lifetimes of all its parameters. You’d need annotations in all of these cases. Consider these conventions against the API for a container. Let’s look at \u003cmap\u003e: // Aliasing: the `key` parameter may alias `*this`. // Lifetimes: the returned T\u0026 is only constrained by `*this` and not by `key`. T\u0026 map\u003cKey, T\u003e::at( const Key\u0026 key ); T\u0026 map\u003cKey, T\u003e::operator[]( const Key\u0026 key ); // Aliasing: the `key` parameter may alias `*this`. // Lifetimes: the returned iterator is only constrained by `*this` and not by // `value`. iterator map\u003cKey, T\u003e::find( const Key\u0026 key ); iterator map\u003cKey, T\u003e::lower_bound( const Key\u0026 key ); iterator map\u003cKey, T\u003e::upper_bound( const Key\u0026 key ); // Aliasing: the `value` parameter may alias `*this`. // Lifetimes: the returned iterator is only constrained by `*this` and not by // `value`. std::pair\u003citerator, bool\u003e map\u003cKey, T\u003e::insert( const value_type\u0026 value ); // Unsafe! // Precondition 1: `pos` must point into `*this` // Aliasing: the `value` parameter may alias `*this` or `pos` // Lifetimes: The returned iterator is only constrained by `*this` and not by // `value`. iterator map\u003cKey, T\u003e::insert( iterator pos, const value_type\u0026 value ); // Aliasing: The `k` and `obj` parameters may alias `*this`. // Lifetimes: The returned iterator is only constrained by `*this` and not by // `k` or `value`. template\u003c class M \u003e std::pair\u003citerator, bool\u003e map\u003cKey, T\u003e::insert_or_assign( const Key\u0026 k, M\u0026\u0026 obj ) // Unsafe! // Precondition 1: `hint` must point into `*this` // Aliasing: The `k` and `obj` parameters may alias `*this` and `hint`. // Lifetimes: The returned iterator is only constrained by `*this` and not by // `k` or `value`. template\u003c class M \u003e iterator insert_or_assign( const_iterator hint, const Key\u0026 k, M\u0026\u0026 obj ); This is only a few of the map APIs which would either be unsafe or require annotations in the Profiles model. The conservative aliasing rules gets most member functions wrong: a reference returned from a member function is typically constrained only by the *this/self parameter. That’s what Rust’s lifetime elision rules do. Regardless of the convention chosen, expect annotations every time the function does something different. With C++ code, it does something different very often. #include \u003cmap\u003e int main() { std::map\u003cint, int\u003e m; m[1] = 2; // Temporary 1 expires. Profiles considers `value` a dangling reference. int\u0026 value = m[1]; // Profiles should flag this apparent use-after-free. value = 2; } Profile’s inability to deal accurately with lifetimes means that an implementation would reject much valid code. In this example the subscript to map::operator[] is a temporary. It goes out of scope at the end of the statement. Under the Profile’s conservative lifetime convention, the returned reference (stored in value) would be considered a dangling reference and the subsequent use would make the program ill-formed. I do not believe that C++ code, with its countless unstated soundness preconditions and inconsistent aliasing and lifetime requirements, can be made memory safe with fewer than “1 annotation per 1,000 lines of code.” In fact, legacy C++ code will have many more annotations than equivalent Rust code. Rust often chooses object relocation to pass parameters by value rather than pass them by reference. This reduces the number of lifetime constraints that the system deals with. Additionally, it has simpler, safe versions of facilities which are unsafe in C++: the Rust iterator, for example, keeps both the data pointer and length in the same struct to completely alleviate the aliasing concerns that prevent safety analysis in C++. C++ cannot enforce exclusivity The density of annotations required to vet existing code is not the biggest problem facing Profiles. C++ overload resolution has created a knot that cannot be untangled. Its standard conversion rules are one reason why C++ is considered inherently unsafe. For many accessor-style C++ APIs, there are two overloads: A candidate that binds a const object and a returns a const reference (or pointer or iterator). A candidate that binds a mutable object and returns a mutable reference (or pointer or iterator). If the mutable candidate can be chosen, it is chosen, no matter what the result object is used for. void f1(const int\u0026 x, const int\u0026 y); void f2(std::vector\u003cint\u003e vec) { // The mutable overload of operator[] is called here. f1(vec[0], vec[1]); } This code will not pass an exclusivity test. vec is a mutable object, so vec[0] calls the mutable version of operator[] and produces a mutable reference result object. While that mutable loan is in scope (it remains in scope until f1 returns), vec[1] calls the mutable version of operator[] to produce its mutable reference result object. But you’re not allowed more than one mutable reference to the same place. This is an exclusivity error! Rust avoids this problem in two ways: In general there is no function overloading. As a convention, if there are mutable and const versions of a function, the mutable one is named with a _mut suffix. There is syntax sugar which maps subscript operations to either index or index_mut. The latter is chosen in a mutable context, which is the left-hand side of an assignment. We can’t ditch function overloading and remain C++. But we can change how overload resolution evaluates candidates. The standard conversion is responsible for binding references to expressions. C++ chooses the wrong (for safety purposes) subscript candidate because the standard conversion is able to bind mutable references to lvalue expressions. (Compiler Explorer) void f3(const int^ x, const int^ y) safe; int main() safe { std2::vector\u003cint\u003e vec { }; // Okay. f3(vec[0], vec[1]); // Ill-formed: mutable borrow of vec between its mutable borrow and its use. f3(mut vec[0], mut vec[1]); } safety: during safety checking of int main() safe borrow checking: example.cpp:13:22 f3(mut vec[0], mut vec[1]); ^ mutable borrow of vec between its mutable borrow and its use loan created at example.cpp:13:10 f3(mut vec[0], mut vec[1]); ^ Safe C++ changes the standard conversion to work around this language defect. In this extension, standard conversions do not bind mutable references. vec[0] chooses the const candidate, which permits aliasing, and mut vec[0] chooses the mutable candidate, which does not. By opting in to mutation, you get aliasing by default. (Compiler Explorer) #feature on safety int main() safe { int x = 1; int^ ref = x; // Ill-formed! Can't bind mutable reference to lvalue. } error: example.cpp:5:14 int^ ref = x; ^ cannot implicitly bind borrow int^ to lvalue int The mut keyword[mutation] puts the subexpression into the mutable context and restores the restricted functionality. In the mutable context, the compiler will bind mutable references to expression: (Compiler Explorer) #feature on safety int main() safe { int x = 1; int^ ref = mut x; // Ok. Can bind mutable references in mutable context. } Now, the const overload of a function is chosen unless the user escapes with the mut keyword. This addresses a language defect head-on. What option does Profiles have? In its full generality, the mutable binding default makes for an exceptionally thorny analysis problem. Does Profiles replace calls to mutable candidates with calls to similarly-named const candidates? That’s a presumption. Does it retroactively classify mutable loans as shared loans depending on usage? I’m not a soundness maverick. This is getting close to touching a live wire. Legacy C++ errs on the side of mutability, making it too unconstrained to test for soundness. Old code is what it is. Carcinization The development of new product lines for use in service of critical infrastructure or NCFs (national critical functions) in a memory-unsafe language (e.g., C or C++) … is dangerous and significantly elevates risk to national security, national economic security, and national public health and safety. – CISA, Product Security Bad Practices[cisa] [P3466R0] insists that “we want to make sure C++ evolution … hews to C++’s core principles.” But these are bad principles. They make C++ extra vulnerable to memory safety defects that are prevented in memory-safe languages. The US Government implicates C++’s core principles as a danger to national security and public health. Static lifetimes Dynamic lifetimes Static types Rust Java, Go Dynamic types - Javascript, Python Reconsider this table. We want to evolve C++ to live in the static types/static lifetimes quadrant. Since Rust is the only species in that design family (at least among production languages), a new entry is necessarily going to resemble Rust (at least in its memory safety treatment) more than it does other languages. An earnest effort to pursue [P1179R1] as a Lifetime TS[P3465R0] will compromise on C++’s outdated and unworkable core principles and adopt mechanisms more like Rust’s. In the compiler business this is called carcinization: a tendency of non-crab organisms to evolve crab-like features. Standard C++ doesn’t have aliasing information. We need a new reference type that upholds the “mutation XOR aliasing” rule as a program-wide invariant. Standard C++ doesn’t have lifetime information. We need lifetime parameters to indicate constraint relationships between function parameters and return references. Safety is a transitive property. It has to be upheld with a safe-specifier on functions to establish the absence of soundness preconditions and an unsafe-block to call unsafe operations. Lifetime constraints are a transitive property. They must be upheld by both caller and callee as viral annotations. Lifetime constraints on functions do not follow any particular convention. Constraints that deviate from a default (such as the lifetime elision rules) require annotation, even heavy annotations that may exceed 1 per 1,000 lines of code. The standard conversion rules make exclusivity enforcement impossible. We have to change the language default, establishing no implicit mutation in order to support aliasing in functions that take const references. C++ in the future I think it is worth pursuing this compatible path first before, or at least at the same time as, trying to graft another foreign language’s semantics onto C++ which turns C++ into “something else” and/or build an off-ramp from C++. – Pursue [P1179R1] as a Lifetime TS[P3465R0] Who does this provincialism serve? The latest Android security study “prioritizes transitioning to memory-safe languages.”[android-security] The off-ramp from C++ is an increasingly viable and attractive strategy for projects looking to reduce CVE exposure. The off-ramp is happening and its benefits are measurable. As the Android study observes, “once we turn off the tap of new vulnerabilities, they decrease exponentially, making all of our code safer.” All focus should be on turning off the tap of new vulnerabilities. Incorporating Rust’s safety model into C++ helps in two ways: It provides an off-ramp from unsafe C++ to Safe C++ within a single toolchain. Projects can follow best practices for Safe Coding[safe-coding] without retraining the whole engineering staff in a new programming language. It can hasten the migration to Rust by improving C++/Rust interop. By extending C++ with representations of all Rust constructs that can appear in function declarations (such as Rust enums, borrows and lifetimes, ZSTs, traits, etc) the number of common vocabulary types is greatly increased. This allows interop tooling to map between C++ and Rust declarations at a more expressive level than the current C-level API. C++ can be made memory safe, but not by dismissing everything that works, which is what the authors of Safety Profiles do. The language must evolve to be more explicit in how it expresses aliasing, lifetime and safeness properties. C++ can meet the security needs of its users, both in a principal role, and, for those projects determined to take the off-ramp, in an important supporting role. References [P1179R1] Herb Sutter. 2019-11-22. Lifetime safety: Preventing common dangling. https://wg21.link/p1179r1 [P3081R0] Core safety Profiles\" Specification, adoptability, and impact. https://isocpp.org/files/papers/P3081R0.pdf [type-and-resource-safety-2015] A brief introduction to C++\"s model for type- and resource- safety. https://www.stroustrup.com/resource-model.pdf",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv id=\"TOC\" role=\"doc-toc\"\u003e\n\u003ch2 id=\"toctitle\"\u003eContents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#abstract\" id=\"toc-abstract\"\u003e\u003cspan\u003e1\u003c/span\u003e Abstract\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#c-is-under-specified\" id=\"toc-c-is-under-specified\"\u003e\u003cspan\u003e2\u003c/span\u003e C++ is\nunder-specified\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#inferring-aliasing\" id=\"toc-inferring-aliasing\"\u003e\u003cspan\u003e2.1\u003c/span\u003e Inferring\naliasing\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#inferring-lifetimes\" id=\"toc-inferring-lifetimes\"\u003e\u003cspan\u003e2.2\u003c/span\u003e Inferring\nlifetimes\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#inferring-safeness\" id=\"toc-inferring-safeness\"\u003e\u003cspan\u003e2.3\u003c/span\u003e Inferring\nsafeness\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#lifetime-safety-is-static-typing\" id=\"toc-lifetime-safety-is-static-typing\"\u003e\u003cspan\u003e3\u003c/span\u003e Lifetime safety is static\ntyping\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#lifetime-parameters-dont-cause-soundness-bugs\" id=\"toc-lifetime-parameters-dont-cause-soundness-bugs\"\u003e\u003cspan\u003e4\u003c/span\u003e Lifetime parameters don’t cause\nsoundness bugs\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#c-is-too-irregular-for-profiles\" id=\"toc-c-is-too-irregular-for-profiles\"\u003e\u003cspan\u003e5\u003c/span\u003e C++ is too irregular for\nProfiles\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#c-cannot-enforce-exclusivity\" id=\"toc-c-cannot-enforce-exclusivity\"\u003e\u003cspan\u003e5.1\u003c/span\u003e C++ cannot enforce\nexclusivity\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#carcinization\" id=\"toc-carcinization\"\u003e\u003cspan\u003e6\u003c/span\u003e Carcinization\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#c-in-the-future\" id=\"toc-c-in-the-future\"\u003e\u003cspan\u003e7\u003c/span\u003e C++ in the\nfuture\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#bibliography\" id=\"toc-bibliography\"\u003e\u003cspan\u003e8\u003c/span\u003e References\u003cspan\u003e\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003ch2 data-number=\"1\" id=\"abstract\"\u003e Abstract\u003ca href=\"#abstract\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eAs for dangling pointers and for ownership, \u003cstrong\u003ethis model\ndetects all possible errors\u003c/strong\u003e. This means that we can guarantee\nthat a program is free of uses of invalidated pointers.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– A brief introduction to C++’s model for type- and resource-\nsafety\u003cspan data-cites=\"type-and-resource-safety-2015\"\u003e[\u003ca href=\"https://www.stroustrup.com/resource-model.pdf\" role=\"doc-biblioref\"\u003etype-and-resource-safety-2015\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eSafety Profiles were introduced in 2015 with the promise to detect\nall lifetime safety defects in existing C++ code. It was a bold claim.\nBut after a decade of effort, Profiles failed to produce a\nspecification, reliable implementation or any tangible benefit for C++\nsafety. The cause of this failure involves a number of mistaken premises\nat the core of its design:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003e“Zero annotation is required by default, because existing C++ source\ncode already contains sufficient information”\u003cspan data-cites=\"P3465R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf\" role=\"doc-biblioref\"\u003eP3465R0\u003c/a\u003e]\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e“We should not require a \u003ccode\u003esafe\u003c/code\u003e\nfunction annotation”\u003cspan data-cites=\"P3446R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf\" role=\"doc-biblioref\"\u003eP3446R0\u003c/a\u003e]\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e“Do not add a feature that requires viral annotation”\u003cspan data-cites=\"P3466R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf\" role=\"doc-biblioref\"\u003eP3466R0\u003c/a\u003e]\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e“Do not add a feature that requires heavy annotation”\u003cspan data-cites=\"P3466R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf\" role=\"doc-biblioref\"\u003eP3466R0\u003c/a\u003e]\u003c/span\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe parameters of the problem make success impossible. This paper\nexamines the contradictions in these premises, explains why the design\ndidn’t improve safety in the past and why it won’t improve safety in the\nfuture.\u003c/p\u003e\n\u003ch2 data-number=\"2\" id=\"c-is-under-specified\"\u003e C++ is under-specified\u003ca href=\"#c-is-under-specified\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eZero annotation is required by default, because existing C++\nsource code already contains sufficient information.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– Pursue \u003cspan data-cites=\"P1179R1\"\u003e[\u003ca href=\"https://wg21.link/p1179r1\" role=\"doc-biblioref\"\u003eP1179R1\u003c/a\u003e]\u003c/span\u003e as a Lifetime Safety TS\u003cspan data-cites=\"P3465R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf\" role=\"doc-biblioref\"\u003eP3465R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eC++ source code \u003cem\u003edoes not\u003c/em\u003e have sufficient information for\nachieving memory safety. A C++ function declaration lacks three things\nthat are critical for lifetime safety:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003e\u003ca href=\"#inferring-aliasing\"\u003eAliasing information\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#inferring-lifetimes\"\u003eLifetime information\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#inferring-safeness\"\u003eSafeness information\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFunctions involving parameter types with pointer or reference\nsemantics have \u003cem\u003eimplicit\u003c/em\u003e aliasing, lifetime and safeness\nrequirements. Safety Profiles cannot recover these properties from C++\ncode, because there are no language facilities to describe them. These\nrequirements are only specified in documentation, if they are specified\nat all.\u003c/p\u003e\n\u003ch2 data-number=\"2.1\" id=\"inferring-aliasing\"\u003e Inferring aliasing\u003ca href=\"#inferring-aliasing\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA C++ compiler can infer nothing about aliasing from a function\ndeclaration. A function parameter with a mutable reference \u003cem\u003emight\nalways\u003c/em\u003e alias other parameters, it \u003cem\u003emight never\u003c/em\u003e alias other\nparameters, or \u003cem\u003eit might not care\u003c/em\u003e about aliasing other\nparameters.\u003c/p\u003e\n\u003cdiv id=\"cb1\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb1-1\"\u003e\u003cspan\u003e// i and j must always alias. They must refer to the same container.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-2\"\u003e\u003cspan\u003evoid\u003c/span\u003e f1\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;::\u003c/span\u003eiterator i, std\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;::\u003c/span\u003eiterator j\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-3\"\u003e  \u003cspan\u003e// If i and j point into different vectors, you have real problems.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-4\"\u003e  std\u003cspan\u003e::\u003c/span\u003esort\u003cspan\u003e(\u003c/span\u003ei, j\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb1-5\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-6\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-7\"\u003e\u003cspan\u003e// vec must not alias x.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-8\"\u003e\u003cspan\u003evoid\u003c/span\u003e f2\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026amp;\u003c/span\u003e vec, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e x\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-9\"\u003e  \u003cspan\u003e// Resizing vec may invalidate x if x is a member of vec.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-10\"\u003e  vec\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb1-11\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-12\"\u003e  \u003cspan\u003e// Potential use-after-free.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-13\"\u003e  x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb1-14\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-15\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-16\"\u003e\u003cspan\u003e// vec may or may not alias x. It doesn\u0026#39;t matter.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-17\"\u003e\u003cspan\u003evoid\u003c/span\u003e f3\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026amp;\u003c/span\u003e vec, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e x\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-18\"\u003e  vec\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003ex\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb1-19\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003ef1\u003c/code\u003e and\n\u003ccode\u003ef2\u003c/code\u003e have aliasing requirements. In\n\u003ccode\u003ef1\u003c/code\u003e, both iterators must point into\nthe same container. In \u003ccode\u003ef2\u003c/code\u003e,\n\u003ccode\u003ex\u003c/code\u003e must not come from the container\n\u003ccode\u003evec\u003c/code\u003e. These requirements are only\nvisible as documentation. The compiler cannot infer a function’s\naliasing requirements from its declaration or even from its definition.\nIf the safety profile enforces \u003cem\u003eno mutable aliasing\u003c/em\u003e, then the\ndefinitions of \u003ccode\u003ef1\u003c/code\u003e and\n\u003ccode\u003ef3\u003c/code\u003e will fail to compile, breaking\nyour program.\u003c/p\u003e\n\u003cdiv id=\"cb2\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb2-1\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-2\"\u003e  std\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec1, vec2;\u003c/span\u003e\n\u003cspan id=\"cb2-3\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-4\"\u003e  \u003cspan\u003e// *Incorrectly* permits call.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-5\"\u003e  \u003cspan\u003e// UB, because the iterators point into different containers.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-6\"\u003e  f1\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec2\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb2-7\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-8\"\u003e  \u003cspan\u003e// *Incorrectly* rejects call.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-9\"\u003e  \u003cspan\u003e// This is the correct usage, but mutable aliasing prevents compilation.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-10\"\u003e  f1\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec1\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb2-11\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-12\"\u003e  \u003cspan\u003e// *Correctly* rejects call.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-13\"\u003e  f2\u003cspan\u003e(\u003c/span\u003evec1, vec1\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb2-14\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-15\"\u003e  \u003cspan\u003e// *Incorrectly* rejects call.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-16\"\u003e  f3\u003cspan\u003e(\u003c/span\u003evec1, vec1\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb2-17\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eProfiles chose the wrong convention for several uses. It permits the\nincorrect call to \u003ccode\u003ef1\u003c/code\u003e to compile, but\nrejects a correct usage of \u003ccode\u003ef1\u003c/code\u003e on the\ngrounds of mutable aliasing. An unsound call to\n\u003ccode\u003ef2\u003c/code\u003e is correctly rejected, but a\nsound call to \u003ccode\u003ef3\u003c/code\u003e is also rejected.\nRejecting or permitting code (rightly or wrongly) is a matter of\ncoincidence, not intelligence.\u003c/p\u003e\n\u003cp\u003eWithout language-level aliasing information, compile-time memory\nsafety is not possible. This requirement is the motivation for Rust’s\nborrow type. A mutable borrow cannot alias other borrows. That’s\nenforced by the borrow checker. Raw pointers have no aliasing\nrequirements, but are unsafe to dereference. In general, things that can\nbe checked by the compiler are checked, and things that can’t be checked\nare unsafe to use.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/WWera863E\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb3\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb3-1\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-2\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-3\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-4\"\u003e\u003cspan\u003evoid\u003c/span\u003e func\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026amp;\u003c/span\u003e vec, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e x\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-5\"\u003e  vec\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb3-6\"\u003e  x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e;  \u003cspan\u003e// A write-after-free when x is a member of vec!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-7\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-8\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-9\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-10\"\u003e  std\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec;\u003c/span\u003e\n\u003cspan id=\"cb3-11\"\u003e  vec\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb3-12\"\u003e  func\u003cspan\u003e(\u003c/span\u003evec, vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb3-13\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb3-14\"\u003e  std\u003cspan\u003e::\u003c/span\u003ecout\u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb3-15\"\u003e  std\u003cspan\u003e::\u003c/span\u003ecout\u003cspan\u003e\u0026lt;\u0026lt;\u003c/span\u003e vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb3-16\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe Safety Profiles partial reference implementation can’t prevent\naliasing-related undefined behavior because C++ doesn’t provide aliasing\ninformation.\u003c/p\u003e\n\u003ch2 data-number=\"2.2\" id=\"inferring-lifetimes\"\u003e Inferring lifetimes\u003ca href=\"#inferring-lifetimes\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA C++ compiler can infer nothing about lifetimes from a function\ndeclaration. A reference return type may be constrained by the lifetimes\nof any number of reference parameters, by none of the reference\nparameters, or by some other lifetime.\u003c/p\u003e\n\u003cdiv id=\"cb5\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb5-1\"\u003e\u003cspan\u003e// The returned reference is only constrained by the lifetime of the map\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-2\"\u003e\u003cspan\u003e// parameter.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-3\"\u003e\u003cspan\u003e// It is not constrained by the lifetime of the key parameter.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-4\"\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e f4\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026amp;\u003c/span\u003e map, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e key\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-5\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e map\u003cspan\u003e[\u003c/span\u003ekey\u003cspan\u003e]\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb5-6\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-7\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-8\"\u003e\u003cspan\u003e// The returned reference is constrained by the lifetime of both x and y\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-9\"\u003e\u003cspan\u003e// parameters.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-10\"\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e f5\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e x, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e y\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-11\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e std\u003cspan\u003e::\u003c/span\u003emin\u003cspan\u003e(\u003c/span\u003ex, y\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb5-12\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-13\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-14\"\u003e\u003cspan\u003e// The returned reference is not constrained by the lifetime of any\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-15\"\u003e\u003cspan\u003e// reference parameter.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-16\"\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e f6\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e key\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb5-17\"\u003e  \u003cspan\u003estatic\u003c/span\u003e std\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e map;\u003c/span\u003e\n\u003cspan id=\"cb5-18\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e map\u003cspan\u003e[\u003c/span\u003ekey\u003cspan\u003e]\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb5-19\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThese three functions have different lifetime requirements, which are\nindicated by comments. This information is available to developers but\nnot to the compiler. What’s the strategy to uphold these lifetime\nrequirements? Read the documentation, read the code, and \u003cem\u003edon’t make\nmistakes\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv id=\"cb6\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb6-1\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-2\"\u003e  std\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e map;\u003c/span\u003e\n\u003cspan id=\"cb6-3\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-4\"\u003e  \u003cspan\u003e// r4 is constrained by lifetimes of map and 40.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-5\"\u003e  \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e r4 \u003cspan\u003e=\u003c/span\u003e f4\u003cspan\u003e(\u003c/span\u003emap, \u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb6-6\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-7\"\u003e  \u003cspan\u003e// *Incorrectly* rejects usage of r4. r4 is constrained to the lifetime\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-8\"\u003e  \u003cspan\u003e// of the temporary 40, which expired at the end of the above statement.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-9\"\u003e  \u003cspan\u003eint\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e r4;\u003c/span\u003e\n\u003cspan id=\"cb6-10\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-11\"\u003e  \u003cspan\u003e// r5 is constrained by lifetimes of 50 and 51.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-12\"\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e r5 \u003cspan\u003e=\u003c/span\u003e f5\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e50\u003c/span\u003e, \u003cspan\u003e51\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb6-13\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-14\"\u003e  \u003cspan\u003e// *Correctly* rejects usage of r5. The reference refers to one of the\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-15\"\u003e  \u003cspan\u003e// two expired temporaries. This use would be a use-after-free.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-16\"\u003e  \u003cspan\u003eint\u003c/span\u003e y \u003cspan\u003e=\u003c/span\u003e r5;\u003c/span\u003e\n\u003cspan id=\"cb6-17\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-18\"\u003e  \u003cspan\u003e// r6 is constrained by the lifetime of 60.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-19\"\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e r6 \u003cspan\u003e=\u003c/span\u003e f6\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e60\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb6-20\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-21\"\u003e  \u003cspan\u003e// *Incorrectly* rejects usage of r6.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-22\"\u003e  \u003cspan\u003e// The return reference r6 should not be constrained by the lifetime of 60.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb6-23\"\u003e  \u003cspan\u003eint\u003c/span\u003e z \u003cspan\u003e=\u003c/span\u003e r6;\u003c/span\u003e\n\u003cspan id=\"cb6-24\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eProfiles take a similarly conservative approach to lifetimes as they\ndo with aliasing. The lifetime of a returned reference is constrained by\nthe lifetimes of \u003cem\u003eall of its arguments\u003c/em\u003e. This is fortuitous for a\nfunction like\n\u003ccode\u003estd\u003cspan\u003e::\u003c/span\u003emin\u003c/code\u003e,\nwhich returns a reference to either of its function parameters. It’s bad\nfor a function like \u003ccode\u003estd\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003eT\u003cspan\u003e\u0026gt;::\u003c/span\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e,\nwhich takes a key argument by reference but returns a reference that’s\nonly constrained by the lifetime of\n\u003ccode\u003e\u003cspan\u003ethis\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSince the compiler has no information about function parameter\nlifetimes, it can’t accurately flag out-of-contract function calls.\n\u003ccode\u003ef4\u003c/code\u003e and\n\u003ccode\u003ef6\u003c/code\u003e take references to temporary\nobjects but return references that should not be constrained to that\ntemporary. In both cases, the safety profile rejects a subsequent use of\nthe reference as a use-after-free, because it applies a too-conservative\nconvention.\u003c/p\u003e\n\u003cp\u003eThe need for explicit lifetime information in function types is the\nmotivation for Rust’s lifetime arguments. A returned reference must be\nannotated with a lifetime parameter that is constrained by a function\nparameter on the same function, or it must be static. The alternative is\nto be deluged with an impossible quantity of use-after-free false\npositives.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/4c84ofavY\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb7\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb7-1\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-2\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;utility\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-3\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-4\"\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e f4\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026amp;\u003c/span\u003e map, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e key\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-5\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e map\u003cspan\u003e[\u003c/span\u003ekey\u003cspan\u003e]\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb7-6\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-7\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-8\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb7-9\"\u003e  std\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e map;\u003c/span\u003e\n\u003cspan id=\"cb7-10\"\u003e  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e ref \u003cspan\u003e=\u003c/span\u003e f4\u003cspan\u003e(\u003c/span\u003emap, \u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb7-11\"\u003e  \u003cspan\u003eint\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e ref;\u003c/span\u003e\n\u003cspan id=\"cb7-12\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb8\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb8-1\"\u003e\u0026lt;source\u0026gt;:11:11: warning: dereferencing a dangling pointer [-Wlifetime]\u003c/span\u003e\n\u003cspan id=\"cb8-2\"\u003e  int x = ref;\u003c/span\u003e\n\u003cspan id=\"cb8-3\"\u003e          ^~~\u003c/span\u003e\n\u003cspan id=\"cb8-4\"\u003e\u0026lt;source\u0026gt;:10:32: note: temporary was destroyed at the end of the full expression\u003c/span\u003e\n\u003cspan id=\"cb8-5\"\u003e  const int\u0026amp; ref = f4(map, 200);\u003c/span\u003e\n\u003cspan id=\"cb8-6\"\u003e                               ^\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe Safety Profiles reference implementation can’t accurately deal\nwith lifetimes because C++ doesn’t provide lifetime information. The\ntool doesn’t test for correctness, it only tests if your code conforms\nto a pre-chosen convention.\u003c/p\u003e\n\u003ch2 data-number=\"2.3\" id=\"inferring-safeness\"\u003e Inferring safeness\u003ca href=\"#inferring-safeness\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eWe should not require a \u003ccode\u003esafe\u003c/code\u003e\nfunction annotation that has the semantics that a\n\u003ccode\u003esafe\u003c/code\u003e function can only call other\n\u003ccode\u003esafe\u003c/code\u003e functions.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– (Re)affirm design principles for future C++ evolution\u003cspan data-cites=\"P3446R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf\" role=\"doc-biblioref\"\u003eP3446R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eRecall what “safe” actually means:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003cem\u003esafe function\u003c/em\u003e has defined behavior for all valid\ninputs.\u003c/li\u003e\n\u003cli\u003eAn \u003cem\u003eunsafe function\u003c/em\u003e has soundness preconditions. Calling an\nunsafe function with out-of-contract inputs may result in undefined\nbehavior.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA C++ compiler can infer nothing about safeness from a function\ndeclaration. It can’t by tell by looking what constitutes an\nout-of-contract call and what doesn’t. A \u003cem\u003esafe-specifier\u003c/em\u003e\nindicates the presence of soundness preconditions. An\n\u003cem\u003eunsafe-block\u003c/em\u003e permits the user to escape the safe context, prove\nthe preconditions, and call the unsafe function.\u003c/p\u003e\n\u003cdiv id=\"cb9\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb9-1\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003etypename\u003c/span\u003e T\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-2\"\u003e\u003cspan\u003eclass\u003c/span\u003e vector \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-3\"\u003e\u003cspan\u003epublic\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-4\"\u003e  \u003cspan\u003esize_t\u003c/span\u003e size\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003enoexcept\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-5\"\u003e    \u003cspan\u003ereturn\u003c/span\u003e _len;\u003c/span\u003e\n\u003cspan id=\"cb9-6\"\u003e  \u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-7\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-8\"\u003e  T\u003cspan\u003e\u0026amp;\u003c/span\u003e \u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[](\u003c/span\u003e\u003cspan\u003esize_t\u003c/span\u003e index\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003enoexcept\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-9\"\u003e    \u003cspan\u003e// Can call size() because it\u0026#39;s a safe function.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-10\"\u003e    \u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eindex \u003cspan\u003e\u0026gt;=\u003c/span\u003e size\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-11\"\u003e      panic\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Out-of-bounds vector::operator[]\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb9-12\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-13\"\u003e    unsafe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-14\"\u003e      \u003cspan\u003e// Pointer operations only allowed in unsafe context.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-15\"\u003e      \u003cspan\u003e// Safety proof:\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-16\"\u003e      \u003cspan\u003e// The allocation has size() valid elements and index \u0026lt; size().\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-17\"\u003e      \u003cspan\u003ereturn\u003c/span\u003e _data\u003cspan\u003e[\u003c/span\u003eindex\u003cspan\u003e]\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb9-18\"\u003e    \u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-19\"\u003e  \u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-20\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-21\"\u003e\u003cspan\u003eprivate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb9-22\"\u003e  T\u003cspan\u003e*\u003c/span\u003e _data;\u003c/span\u003e\n\u003cspan id=\"cb9-23\"\u003e  \u003cspan\u003esize_t\u003c/span\u003e _len, _cap;\u003c/span\u003e\n\u003cspan id=\"cb9-24\"\u003e\u003cspan\u003e}\u003c/span\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLet’s take a really simple case: \u003ccode\u003evector\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e.\nProfiles have to reject pointer arithmetic, because there’s no static\nanalysis protection against indexing past the end of the allocation. How\nis the compiler told to permit the raw pointer subscript in the\n\u003cem\u003ereturn-statement\u003c/em\u003e in \u003ccode\u003evector\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e?\nIn Rust and Safe C++, enter an \u003cem\u003eunsafe-block\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis design distinguishes safe functions, which have no soundness\npreconditions and can be called from other safe functions, and unsafe\nfunctions, which require an \u003cem\u003eunsafe-block\u003c/em\u003e escape to use, just\nlike pointer operations.\u003c/p\u003e\n\u003cp\u003eSeparation of safe and unsafe functions is common in memory-safe\nlanguages. Rust and C#\u003cspan data-cites=\"csharp\"\u003e[\u003ca href=\"https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/unsafe\" role=\"doc-biblioref\"\u003ecsharp\u003c/a\u003e]\u003c/span\u003e include an\n\u003ccode\u003eunsafe\u003c/code\u003e function specifier and an\n\u003cem\u003eunsafe-block\u003c/em\u003e construct. This is a human- and tooling-readable\ntag for auditing potential origins of soundness defects. Aliasing and\nlifetimes are transitive properties that must be recoverable from a\nfunction declaration in order to be upheld. Safeness (the lack of\nsoundness preconditions) is another transitive property that must be\nmarked in a function declaration. The way to do that is with a\n\u003cem\u003esafe-specifier\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv id=\"cb10\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb10-1\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e RandomIt \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb10-2\"\u003e\u003cspan\u003evoid\u003c/span\u003e sort\u003cspan\u003e(\u003c/span\u003e RandomIt first, RandomIt last \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLet’s consider another example: the\n\u003ccode\u003estd\u003cspan\u003e::\u003c/span\u003esort\u003c/code\u003e\nAPI that takes two random-access iterators. This is an \u003cem\u003eunsafe\u003c/em\u003e\nfunction because it exhibits undefined behavior if called with the wrong\narguments. But there’s nothing in the type system to indicate that it\nhas soundness preconditions, so the compiler doesn’t know to reject\ncalls in safe contexts.\u003c/p\u003e\n\u003cp\u003eWhat are \u003ccode\u003esort\u003c/code\u003e’s\npreconditions?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe \u003ccode\u003efirst\u003c/code\u003e and\n\u003ccode\u003elast\u003c/code\u003e iterators must point at\nelements from the same container.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efirst\u003c/code\u003e must not indicate an\nelement that appears after\n\u003ccode\u003elast\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efirst\u003c/code\u003e and\n\u003ccode\u003elast\u003c/code\u003e may not be dangling\niterators.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the absence of a enforced safeness information, it’s up to the\nuser to follow the documentation and satisfy the requirements. Guidance\nfor calling unsafe functions is essentially “don’t write bugs.”\u003c/p\u003e\n\u003cdiv id=\"cb11\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb11-1\"\u003e\u003cspan\u003evoid\u003c/span\u003e func\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec1, std\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec2\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb11-2\"\u003e  \u003cspan\u003e// #1 - *Incorrectly* rejects correct call for mutable aliasing\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb11-3\"\u003e  sort\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec1\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb11-4\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb11-5\"\u003e  \u003cspan\u003e// #2 - *Incorrectly* permits out-of-contract call.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb11-6\"\u003e  sort\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec2\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb11-7\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn the Profiles model, the correct call to\n\u003ccode\u003esort\u003c/code\u003e #1 is rejected due to mutable\naliasing. That’s bad, but permitting the out-of-contract call #2 is\nworse, because it’s a soundness bug. There’s no realistic static\nanalysis technology to verify that a call to\n\u003ccode\u003esort\u003c/code\u003e meets its preconditions. Even\nthe safety profile with the most conservative aliasing setting lets this\ncall through.\u003c/p\u003e\n\u003cp\u003eThis is where \u003ccode\u003esafe\u003c/code\u003e and\n\u003ccode\u003eunsafe\u003c/code\u003e specifiers play an important\nrole. From the caller’s perspective,\n\u003ccode\u003esort\u003c/code\u003e is unsafe because it has\npreconditions that must be upheld without the compiler’s help. From the\ncallee’s perspective, \u003ccode\u003esort\u003c/code\u003e is unsafe\nbecause it’s written with \u003cem\u003eunsafe operations\u003c/em\u003e. Pointer\ndifferencing computes a pivot for the sort, and pointer differencing is\nundefined when its operands point to different allocations.\u003c/p\u003e\n\u003cdiv id=\"cb12\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb12-1\"\u003e\u003cspan\u003e// No safe-specifier means unsafe.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-2\"\u003e\u003cspan\u003evoid\u003c/span\u003e sort\u003cspan\u003e(\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;::\u003c/span\u003eiterator begin, vector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;::\u003c/span\u003eiterator end\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb12-3\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-4\"\u003e\u003cspan\u003e// A safe-specifier means it can only call safe functions.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-5\"\u003e\u003cspan\u003evoid\u003c/span\u003e func\u003cspan\u003e(\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec1, vector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec2\u003cspan\u003e)\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-6\"\u003e  \u003cspan\u003e// Ill-formed: sort is an unsafe function.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-7\"\u003e  \u003cspan\u003e// Averts potential undefined behavior.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-8\"\u003e  sort\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec2\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb12-9\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-10\"\u003e  unsafe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-11\"\u003e    \u003cspan\u003e// Well-formed: call unsafe function from unsafe context.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-12\"\u003e    \u003cspan\u003e// Safety proof:\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-13\"\u003e    \u003cspan\u003e// sort requires both iterators point into the same container.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-14\"\u003e    \u003cspan\u003e// Here, they both point into vec1.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-15\"\u003e    sort\u003cspan\u003e(\u003c/span\u003evec1\u003cspan\u003e.\u003c/span\u003ebegin\u003cspan\u003e()\u003c/span\u003e, vec1\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb12-16\"\u003e  \u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb12-17\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe only way to enforce memory safety is to separate safe and unsafe\nfunctions with a \u003cem\u003esafe-specifier\u003c/em\u003e. In this example,\n\u003ccode\u003efunc\u003c/code\u003e is \u003cem\u003esafe\u003c/em\u003e because it’s\ndefined for all valid inputs. It cannot call\n\u003ccode\u003esort\u003c/code\u003e, because that has soundness\npreconditions: the two iterators must point into the same container. A\ncall to \u003ccode\u003esort\u003c/code\u003e in a safe context\nleaves the program ill-formed, because the compiler cannot guarantee\nthat the preconditions are satisfied. But by entering an\n\u003cem\u003eunsafe-block\u003c/em\u003e, the user can prove the preconditions and make the\nunsafe call \u003cem\u003ewithout the compiler’s soundness guarantees\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cspan data-cites=\"P3081R0\"\u003e[\u003ca href=\"https://isocpp.org/files/papers/P3081R0.pdf\" role=\"doc-biblioref\"\u003eP3081R0\u003c/a\u003e]\u003c/span\u003e does float a \u003ccode\u003e\u003cspan\u003e[[\u003c/span\u003e\u003cspan\u003esuppress\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eprofile\u003c/span\u003e\u003cspan\u003e)]]\u003c/span\u003e\u003c/code\u003e\nattribute to turn off certain Profiles checkes. It looks like the\nequivalent of an \u003cem\u003eunsafe-block\u003c/em\u003e. It may permit pointer operations\nin a definition, but it doesn’t address the other side of the call:\nwithout a \u003cem\u003esafe-specifier\u003c/em\u003e, how does the Profiles design deal\nwith functions like \u003ccode\u003esort\u003c/code\u003e that are\n\u003cem\u003einherently unsafe\u003c/em\u003e? They must be separated from provably safe\nfunctions. User intervention, wrapped up in \u003cem\u003eunsafe-blocks\u003c/em\u003e, is\nneeded to satisfy their preconditions. Without this bump of impedance\nthe language cannot guarantee safety, as the property that a safe\nfunctions contains no undefined behavior is not transitively upheld.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/c7Ko3bnG8\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb13\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb13-1\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;memory\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-2\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-3\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-4\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-5\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-6\"\u003e  std\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e v1, v2;\u003c/span\u003e\n\u003cspan id=\"cb13-7\"\u003e  v1\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb13-8\"\u003e  v2\u003cspan\u003e.\u003c/span\u003epush_back\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb13-9\"\u003e  \u003c/span\u003e\n\u003cspan id=\"cb13-10\"\u003e  \u003cspan\u003e// UB!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb13-11\"\u003e  std\u003cspan\u003e::\u003c/span\u003esort\u003cspan\u003e(\u003c/span\u003ev1\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e()\u003c/span\u003e, v2\u003cspan\u003e.\u003c/span\u003eend\u003cspan\u003e())\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb13-12\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb14\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb14-1\"\u003eProgram returned: 139\u003c/span\u003e\n\u003cspan id=\"cb14-2\"\u003edouble free or corruption (out)\u003c/span\u003e\n\u003cspan id=\"cb14-3\"\u003eProgram terminated with signal: SIGSEGV\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe Safety Profiles reference implementation can’t deal with unsafe\nfunctions, because C++ doesn’t know which functions are unsafe. This\nout-of-contract call produces a heap double-free and then segfaults.\u003c/p\u003e\n\u003ch2 data-number=\"3\" id=\"lifetime-safety-is-static-typing\"\u003e Lifetime safety is static\ntyping\u003ca href=\"#lifetime-safety-is-static-typing\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDo not add a feature that requires viral annotation.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– (Re)affirm design principles for future C++ evolution\u003cspan data-cites=\"P3446R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf\" role=\"doc-biblioref\"\u003eP3446R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eRust’s safety model incorporates lifetime arguments on every\nreference (or struct with reference semantics) that occurs in a function\ntype. The authors of Profiles disparagingly call these “viral\nannotations.” Don’t be scared. C++ has always been full of viral\nannotations: \u003cstrong\u003etypes are viral annotations\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTypes establish type safety properties that are enforced by both the\ncaller and callee. These properties are \u003cem\u003etransitive\u003c/em\u003e\n(i.e. \u003cem\u003eviral\u003c/em\u003e) because they’re enforced through any number of\nfunction calls, creating a \u003cem\u003enetwork of reasoning\u003c/em\u003e from the point\nwhere an object is created to all of its uses.\u003c/p\u003e\n\u003cp\u003eLanguages that treat types as viral annotations are\n\u003cem\u003estatically-typed languages\u003c/em\u003e. Languages that don’t are\n\u003cem\u003edynamically-typed languages\u003c/em\u003e. These have well-known trade-offs.\nStatically-typed languages exhibit higher performance and provide more\ninformation to developers; programs in a statically-typed language may\nbe easier to reason about. Dynamically-typed languages are much simpler\nand can be more productive.\u003c/p\u003e\n\u003cp\u003eLifetime parameters, which provide crucial information to the\ncompiler to enable rigorous safety analysis, defines another axis of\n\u003cem\u003etyping\u003c/em\u003e. Rust has \u003cem\u003estatic lifetimes\u003c/em\u003e, which is a\nhigh-performance, high-information approach to memory safety. Users can\nreason about lifetimes and aliasing because those concepts are built\ninto the language. The compiler has sufficient information to rigorously\nenforce lifetime safety with \u003cem\u003eborrow checking\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eMost other memory-safe languages use \u003cem\u003edynamic lifetimes\u003c/em\u003e, of\nwhich \u003cem\u003egarbage collection\u003c/em\u003e is an implementation. Instead of\nenforcing lifetimes and exclusivity at compile time, the garbage\ncollector manages objects on the heap and extends their scope as long as\nthere are live references to them. This has the same basic trade-off as\n\u003cem\u003edynamic typing\u003c/em\u003e: simplicity at the cost of performance.\u003c/p\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\u003ctr\u003e\u003cth\u003e\n\u003c/th\u003e\n\u003cth\u003e\nStatic lifetimes\n\u003c/th\u003e\n\u003cth\u003e\nDynamic lifetimes\n\u003c/th\u003e\n\u003c/tr\u003e\u003ctr\u003e\n\u003cth\u003e\nStatic types\n\u003c/th\u003e\n\u003ctd\u003e\nRust\n\u003c/td\u003e\n\u003ctd\u003e\nJava, Go\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth\u003e\nDynamic types\n\u003c/th\u003e\n\u003ctd\u003e\n-\n\u003c/td\u003e\n\u003ctd\u003e\nJavascript, Python\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eThe static types/static lifetimes quadrant is a new area of language\ndesign, at least for languages widely used in production. The principles\nmay be unfamiliar. Lifetime annotations feel different than type\nannotations because they establish relationships \u003cem\u003ebetween\u003c/em\u003e\nparameters and return types rather than on individual parameters and\nobjects. Instead of answering the question “What are the properties of\nthis entity?” they answer “How does this entity relate to other\nentities?”.\u003c/p\u003e\n\u003cp\u003eProfiles fail because they reject, as a design principle, the\nspecific language improvements that provide necessary lifetime\ninformation for compile-time safety.\u003c/p\u003e\n\u003ch2 data-number=\"4\" id=\"lifetime-parameters-dont-cause-soundness-bugs\"\u003e Lifetime parameters don’t cause\nsoundness bugs\u003ca href=\"#lifetime-parameters-dont-cause-soundness-bugs\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eAnnotations are distracting, add verbosity, and some can be wrong\n(introducing the kind of errors they are assumed to help\neliminate).\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– Profile invalidation - eliminating dangling pointers\u003cspan data-cites=\"P3446R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf\" role=\"doc-biblioref\"\u003eP3446R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis is not right. In a memory-safe language you can’t introduce\nundefined behavior with mere coding mistakes. That’s the whole point of\nmemory safety. If you put the wrong lifetime annotation on a parameter,\nyour program becomes ill-formed, not undefined. A mistaken use of\nlifetime parameters can be an ergonomics bug, or it can mask undefined\nbehavior when wrapping an unsafe function in a safe interface, but it\ncan’t cause undefined behavior.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/MYW6x693P\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb1\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb1-1\"\u003e\u003cspan\u003efn\u003c/span\u003e f1\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#39;a\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;b\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e(x\u003cspan\u003e:\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;a\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e y\u003cspan\u003e:\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;b\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e) \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;b\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-2\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e x\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb1-3\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb15\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb15-1\"\u003eerror: lifetime may not live long enough\u003c/span\u003e\n\u003cspan id=\"cb15-2\"\u003e --\u0026gt; lifetime1.rs:5:10\u003c/span\u003e\n\u003cspan id=\"cb15-3\"\u003e  |\u003c/span\u003e\n\u003cspan id=\"cb15-4\"\u003e4 | fn f1\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt;(x:\u0026amp;\u0026#39;a i32, y:\u0026amp;\u0026#39;b i32) -\u0026gt; \u0026amp;\u0026#39;b i32 {\u003c/span\u003e\n\u003cspan id=\"cb15-5\"\u003e  |       --  -- lifetime `\u0026#39;b` defined here\u003c/span\u003e\n\u003cspan id=\"cb15-6\"\u003e  |       |\u003c/span\u003e\n\u003cspan id=\"cb15-7\"\u003e  |       lifetime `\u0026#39;a` defined here\u003c/span\u003e\n\u003cspan id=\"cb15-8\"\u003e5 |   return x;\u003c/span\u003e\n\u003cspan id=\"cb15-9\"\u003e  |          ^ function was supposed to return data with lifetime `\u0026#39;b` but it is returning data with lifetime `\u0026#39;a`\u003c/span\u003e\n\u003cspan id=\"cb15-10\"\u003e  |\u003c/span\u003e\n\u003cspan id=\"cb15-11\"\u003e  = help: consider adding the following bound: `\u0026#39;a: \u0026#39;b`\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLifetime constraints are a contract between the caller and callee. If\neither side violates the contract, the program is ill-formed. In the\ncode above, the lifetime constraints are violated by the callee. The\nlifetime of the \u003ccode\u003ex\u003c/code\u003e parameter does not\noutlive the lifetime of the returned reference. We used the wrong\nannotation, but instead of leading to undefined behavior, the compiler\nproduces a detailed message that explains how the lifetime contract was\nnot met.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/3YWvT7ce4\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb2\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb2-1\"\u003e\u003cspan\u003efn\u003c/span\u003e f2\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e\u0026#39;a\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#39;b\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e(x\u003cspan\u003e:\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;a\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e y\u003cspan\u003e:\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;b\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e) \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003e\u003cspan\u003e\u0026#39;b\u003c/span\u003e \u003cspan\u003ei32\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-2\"\u003e  \u003cspan\u003e// Well-formed. The lifetime on y outlives the lifetime on\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-3\"\u003e  \u003cspan\u003e// the return reference.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-4\"\u003e  \u003cspan\u003ereturn\u003c/span\u003e y\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-5\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-6\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-7\"\u003e\u003cspan\u003efn\u003c/span\u003e f3() \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-8\"\u003e  \u003cspan\u003elet\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-9\"\u003e  \u003cspan\u003elet\u003c/span\u003e r\u003cspan\u003e:\u0026amp;\u003c/span\u003e\u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-10\"\u003e  \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-11\"\u003e    \u003cspan\u003elet\u003c/span\u003e y \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-12\"\u003e    r \u003cspan\u003e=\u003c/span\u003e f2(\u003cspan\u003e\u0026amp;\u003c/span\u003ex\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026amp;\u003c/span\u003ey)\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-13\"\u003e  \u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-14\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-15\"\u003e  \u003cspan\u003e// Ill-formed: r depends on y, which is out of scope.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-16\"\u003e  \u003cspan\u003elet\u003c/span\u003e z \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003er\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb2-17\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb16\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb16-1\"\u003eerror[E0597]: `y` does not live long enough\u003c/span\u003e\n\u003cspan id=\"cb16-2\"\u003e  --\u0026gt; lifetime2.rs:15:16\u003c/span\u003e\n\u003cspan id=\"cb16-3\"\u003e   |\u003c/span\u003e\n\u003cspan id=\"cb16-4\"\u003e14 |     let y = 2;\u003c/span\u003e\n\u003cspan id=\"cb16-5\"\u003e   |         - binding `y` declared here\u003c/span\u003e\n\u003cspan id=\"cb16-6\"\u003e15 |     r = f2(\u0026amp;x, \u0026amp;y);\u003c/span\u003e\n\u003cspan id=\"cb16-7\"\u003e   |                ^^ borrowed value does not live long enough\u003c/span\u003e\n\u003cspan id=\"cb16-8\"\u003e16 |   }\u003c/span\u003e\n\u003cspan id=\"cb16-9\"\u003e   |   - `y` dropped here while still borrowed\u003c/span\u003e\n\u003cspan id=\"cb16-10\"\u003e...\u003c/span\u003e\n\u003cspan id=\"cb16-11\"\u003e19 |   let z = *r;\u003c/span\u003e\n\u003cspan id=\"cb16-12\"\u003e   |           -- borrow later used here\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLet’s fix the implementation of the callee and test a broken version\nof the caller. The returned reference depends on\n\u003ccode\u003ey\u003c/code\u003e, but it’s used after\n\u003ccode\u003ey\u003c/code\u003e goes out of scope. The compiler\nrejects the program and tells us “\u003ccode\u003ey\u003c/code\u003e\ndoes not live long enough.”\u003c/p\u003e\n\u003cp\u003eThe use of lifetime annotations on parameters is the same as the use\nof type annotations on parameters: it turns an intractable whole-program\nanalysis problem into an easy-to-enforce local-analysis problem.\nLifetime annotations, which exist to \u003cem\u003eguarantee\u003c/em\u003e safety, do not\n\u003cem\u003ejeopardize\u003c/em\u003e safety.\u003c/p\u003e\n\u003ch2 data-number=\"5\" id=\"c-is-too-irregular-for-profiles\"\u003e C++ is too irregular for\nProfiles\u003ca href=\"#c-is-too-irregular-for-profiles\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDo not add a feature that requires heavy annotation. “Heavy”\nmeans something like “more than 1 annotation per 1,000 lines of\ncode.”\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– (Re)affirm design principles for future C++ evolution\u003cspan data-cites=\"P3446R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf\" role=\"doc-biblioref\"\u003eP3446R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eWe have an implemented approach that requires near-zero\nannotation of existing source code.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– Pursue \u003cspan data-cites=\"P1179R1\"\u003e[\u003ca href=\"https://wg21.link/p1179r1\" role=\"doc-biblioref\"\u003eP1179R1\u003c/a\u003e]\u003c/span\u003e as a Lifetime TS\u003cspan data-cites=\"P3465R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf\" role=\"doc-biblioref\"\u003eP3465R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCentral to Safety Profiles is the claim that annotations are\nexceptional rather than the norm. For this to be true, the great bulk of\nC++ would need to be written according to some preferred convention.\n\u003cspan data-cites=\"P1179R1\"\u003e[\u003ca href=\"https://wg21.link/p1179r1\" role=\"doc-biblioref\"\u003eP1179R1\u003c/a\u003e]\u003c/span\u003e chooses “no mutable aliasing”\nand constrains reference return types to all reference parameters. Let’s\nconsider a number of Standard Library functions and compare their\naliasing and exclusivity requirements to those conventions. Functions\nthat don’t adhere to these conventions must be annotated, and those\nannotations must be virally propagated up the stack to all callers, as\naliasing and lifetime requirements are transitive. Only functions that\nhave no soundness preconditions can be considered safe.\u003c/p\u003e\n\u003cp\u003eLet’s start in \u003ccode\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ealgorithm\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\nand work through alphabetically, indicating how functions deviate from\nthe Safety Profile’s aliasing and lifetime conventions:\u003c/p\u003e\n\u003cdiv id=\"cb17\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb17-1\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-2\"\u003e\u003cspan\u003e// Precondition: `first` and `last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-3\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e UnaryPred \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-4\"\u003e\u003cspan\u003ebool\u003c/span\u003e all_of\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, UnaryPred p \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-5\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-6\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e UnaryPred \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-7\"\u003e\u003cspan\u003ebool\u003c/span\u003e any_of\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, UnaryPred p \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-8\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-9\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e UnaryPred \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-10\"\u003e\u003cspan\u003ebool\u003c/span\u003e none_of\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, UnaryPred p \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-11\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-12\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-13\"\u003e\u003cspan\u003e// Precondition 1: `first` and `last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-14\"\u003e\u003cspan\u003e// Lifetime: The return type is not constrained by the lifetime of `value`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-15\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e T \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-16\"\u003eInputIt find\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, \u003cspan\u003econst\u003c/span\u003e T\u003cspan\u003e\u0026amp;\u003c/span\u003e value \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-17\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-18\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e UnaryPred \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-19\"\u003eInputIt find_if\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, UnaryPred p \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-20\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-21\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e UnaryPred \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-22\"\u003eInputIt find_if_not\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last, UnaryPred q \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-23\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-24\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-25\"\u003e\u003cspan\u003e// Precondition 1: `first` and `last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-26\"\u003e\u003cspan\u003e// Precondition 2: `s_first` and `s_last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-27\"\u003e\u003cspan\u003e// Lifetime: The return type is not constrained by the lifetime of `s_first`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-28\"\u003e\u003cspan\u003e//   or `s_last`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-29\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt, \u003cspan\u003eclass\u003c/span\u003e ForwardIt \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-30\"\u003eInputIt find_first_of\u003cspan\u003e(\u003c/span\u003e InputIt first, InputIt last,\u003c/span\u003e\n\u003cspan id=\"cb17-31\"\u003e  ForwardIt s_first, ForwardIt s_last \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-32\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-33\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-34\"\u003e\u003cspan\u003e// Precondition 1: `first` and `last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-35\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e ForwardIt \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-36\"\u003eForwardIt adjacent_find\u003cspan\u003e(\u003c/span\u003e ForwardIt first, ForwardIt last \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-37\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-38\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-39\"\u003e\u003cspan\u003e// Precondition 1: `first1` and `last2` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-40\"\u003e\u003cspan\u003e// Lifetime: The returned Input1 is constrained only by `first1` and `last1`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-41\"\u003e\u003cspan\u003e// Lifetime: The returned Input2 is constrained only by `first2`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-42\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e InputIt1, \u003cspan\u003eclass\u003c/span\u003e InputIt2 \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-43\"\u003estd\u003cspan\u003e::\u003c/span\u003epair\u003cspan\u003e\u0026lt;\u003c/span\u003eInputIt1, InputIt2\u003cspan\u003e\u0026gt;\u003c/span\u003e mismatch\u003cspan\u003e(\u003c/span\u003e InputIt1 first1, InputIt1 last1,\u003c/span\u003e\n\u003cspan id=\"cb17-44\"\u003e  InputIt2 first2 \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb17-45\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-46\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-47\"\u003e\u003cspan\u003e// Precondition 1: `first` and `last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-48\"\u003e\u003cspan\u003e// Precondition 2: `s_first` and `s_last` must alias.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-49\"\u003e\u003cspan\u003e// Lifetime: The returned ForwardIt1 is constrained only by `first` and `last`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-50\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e ForwardIt1, \u003cspan\u003eclass\u003c/span\u003e ForwardIt2 \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb17-51\"\u003eForwardIt1 search\u003cspan\u003e(\u003c/span\u003e ForwardIt1 first, ForwardIt1 last, ForwardIt2 s_first, \u003c/span\u003e\n\u003cspan id=\"cb17-52\"\u003e  ForwardIt2 s_last \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe functions in \u003ccode\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003ealgorithms\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e\nmostly involve iterators which are inherently unsafe. Additionally, the\nlifetime convention chosen by Profiles is frequently wrong: the lifetime\nof a returned reference rarely is constrained by the lifetimes of all\nits parameters. You’d need annotations in all of these cases.\u003c/p\u003e\n\u003cp\u003eConsider these conventions against the API for a container. Let’s\nlook at \u003ccode\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003emap\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv id=\"cb18\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb18-1\"\u003e\u003cspan\u003e// Aliasing: the `key` parameter may alias `*this`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-2\"\u003e\u003cspan\u003e// Lifetimes: the returned T\u0026amp; is only constrained by `*this` and not by `key`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-3\"\u003eT\u003cspan\u003e\u0026amp;\u003c/span\u003e map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003eat\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e key \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-4\"\u003eT\u003cspan\u003e\u0026amp;\u003c/span\u003e map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[](\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e key \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-5\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-6\"\u003e\u003cspan\u003e// Aliasing: the `key` parameter may alias `*this`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-7\"\u003e\u003cspan\u003e// Lifetimes: the returned iterator is only constrained by `*this` and not by\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-8\"\u003e\u003cspan\u003e//   `value`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-9\"\u003eiterator map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003efind\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e key \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-10\"\u003eiterator map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003elower_bound\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e key \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-11\"\u003eiterator map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003eupper_bound\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e key \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-12\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-13\"\u003e\u003cspan\u003e// Aliasing: the `value` parameter may alias `*this`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-14\"\u003e\u003cspan\u003e// Lifetimes: the returned iterator is only constrained by `*this` and not by\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-15\"\u003e\u003cspan\u003e//   `value`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-16\"\u003estd\u003cspan\u003e::\u003c/span\u003epair\u003cspan\u003e\u0026lt;\u003c/span\u003eiterator, \u003cspan\u003ebool\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003einsert\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e value_type\u003cspan\u003e\u0026amp;\u003c/span\u003e value \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-17\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-18\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-19\"\u003e\u003cspan\u003e// Precondition 1: `pos` must point into `*this`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-20\"\u003e\u003cspan\u003e// Aliasing: the `value` parameter may alias `*this` or `pos`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-21\"\u003e\u003cspan\u003e// Lifetimes: The returned iterator is only constrained by `*this` and not by\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-22\"\u003e\u003cspan\u003e//   `value`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-23\"\u003eiterator map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003einsert\u003cspan\u003e(\u003c/span\u003e iterator pos, \u003cspan\u003econst\u003c/span\u003e value_type\u003cspan\u003e\u0026amp;\u003c/span\u003e value \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb18-24\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-25\"\u003e\u003cspan\u003e// Aliasing: The `k` and `obj` parameters may alias `*this`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-26\"\u003e\u003cspan\u003e// Lifetimes: The returned iterator is only constrained by `*this` and not by \u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-27\"\u003e\u003cspan\u003e//   `k` or `value`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-28\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e M \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-29\"\u003estd\u003cspan\u003e::\u003c/span\u003epair\u003cspan\u003e\u0026lt;\u003c/span\u003eiterator, \u003cspan\u003ebool\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e map\u003cspan\u003e\u0026lt;\u003c/span\u003eKey, T\u003cspan\u003e\u0026gt;::\u003c/span\u003einsert_or_assign\u003cspan\u003e(\u003c/span\u003e \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e k, M\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e obj \u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-30\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-31\"\u003e\u003cspan\u003e// Unsafe!\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-32\"\u003e\u003cspan\u003e// Precondition 1: `hint` must point into `*this`\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-33\"\u003e\u003cspan\u003e// Aliasing: The `k` and `obj` parameters may alias `*this` and `hint`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-34\"\u003e\u003cspan\u003e// Lifetimes: The returned iterator is only constrained by `*this` and not by\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-35\"\u003e\u003cspan\u003e//   `k` or `value`.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-36\"\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e M \u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb18-37\"\u003eiterator insert_or_assign\u003cspan\u003e(\u003c/span\u003e const_iterator hint, \u003cspan\u003econst\u003c/span\u003e Key\u003cspan\u003e\u0026amp;\u003c/span\u003e k, M\u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e obj \u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is only a few of the \u003ccode\u003emap\u003c/code\u003e\nAPIs which would either be unsafe or require annotations in the Profiles\nmodel. The conservative aliasing rules gets most member functions wrong:\na reference returned from a member function is typically constrained\nonly by the \u003ccode\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ethis\u003c/span\u003e\u003c/code\u003e/\u003ccode\u003eself\u003c/code\u003e\nparameter. That’s what Rust’s lifetime elision rules do. Regardless of\nthe convention chosen, expect annotations every time the function does\nsomething different. With C++ code, it does something different \u003cem\u003every\noften\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv id=\"cb19\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb19-1\"\u003e\u003cspan\u003e#include \u003c/span\u003e\u003cspan\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-2\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-3\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-4\"\u003e  std\u003cspan\u003e::\u003c/span\u003emap\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e, \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e m;\u003c/span\u003e\n\u003cspan id=\"cb19-5\"\u003e  m\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb19-6\"\u003e  \u003c/span\u003e\n\u003cspan id=\"cb19-7\"\u003e  \u003cspan\u003e// Temporary 1 expires. Profiles considers `value` a dangling reference.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-8\"\u003e  \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e value \u003cspan\u003e=\u003c/span\u003e m\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb19-9\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-10\"\u003e  \u003cspan\u003e// Profiles should flag this apparent use-after-free.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb19-11\"\u003e  value \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb19-12\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eProfile’s inability to deal accurately with lifetimes means that an\nimplementation would reject much valid code. In this example the\nsubscript to \u003ccode\u003emap\u003cspan\u003e::\u003c/span\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e\nis a temporary. It goes out of scope at the end of the statement. Under\nthe Profile’s conservative lifetime convention, the returned reference\n(stored in \u003ccode\u003evalue\u003c/code\u003e) would be\nconsidered a dangling reference and the subsequent use would make the\nprogram ill-formed.\u003c/p\u003e\n\u003cp\u003eI do not believe that C++ code, with its countless unstated soundness\npreconditions and inconsistent aliasing and lifetime requirements, can\nbe made memory safe with fewer than “1 annotation per 1,000 lines of\ncode.” In fact, legacy C++ code will have \u003cem\u003emany more\u003c/em\u003e annotations\nthan equivalent Rust code. Rust often chooses object relocation to pass\nparameters by value rather than pass them by reference. This reduces the\nnumber of lifetime constraints that the system deals with. Additionally,\nit has simpler, \u003cem\u003esafe versions\u003c/em\u003e of facilities which are unsafe in\nC++: the Rust iterator, for example, keeps both the data pointer and\nlength in the same struct to completely alleviate the aliasing concerns\nthat prevent safety analysis in C++.\u003c/p\u003e\n\u003ch2 data-number=\"5.1\" id=\"c-cannot-enforce-exclusivity\"\u003e C++ cannot enforce\nexclusivity\u003ca href=\"#c-cannot-enforce-exclusivity\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe density of annotations required to vet existing code is not the\nbiggest problem facing Profiles. C++ overload resolution has created a\nknot that cannot be untangled. Its standard conversion rules are one\nreason why C++ is considered \u003cem\u003einherently unsafe\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFor many accessor-style C++ APIs, there are two overloads:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003eA candidate that binds a \u003cem\u003econst\u003c/em\u003e object and a returns a\n\u003cem\u003econst\u003c/em\u003e reference (or pointer or iterator).\u003c/li\u003e\n\u003cli\u003eA candidate that binds a \u003cem\u003emutable\u003c/em\u003e object and returns a\n\u003cem\u003emutable\u003c/em\u003e reference (or pointer or iterator).\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf the mutable candidate \u003cem\u003ecan\u003c/em\u003e be chosen, \u003cem\u003eit is\u003c/em\u003e\nchosen, no matter what the result object is used for.\u003c/p\u003e\n\u003cdiv id=\"cb20\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb20-1\"\u003e\u003cspan\u003evoid\u003c/span\u003e f1\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e x, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026amp;\u003c/span\u003e y\u003cspan\u003e)\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb20-2\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb20-3\"\u003e\u003cspan\u003evoid\u003c/span\u003e f2\u003cspan\u003e(\u003c/span\u003estd\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb20-4\"\u003e  \u003cspan\u003e// The mutable overload of operator[] is called here.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb20-5\"\u003e  f1\u003cspan\u003e(\u003c/span\u003evec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e, vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb20-6\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis code will not pass an exclusivity test.\n\u003ccode\u003evec\u003c/code\u003e is a mutable object, so \u003ccode\u003evec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/code\u003e\ncalls the mutable version of \u003ccode\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e\nand produces a mutable reference result object. \u003cem\u003eWhile that mutable\nloan is in scope\u003c/em\u003e (it remains in scope until\n\u003ccode\u003ef1\u003c/code\u003e returns), \u003ccode\u003evec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/code\u003e\ncalls the mutable version of \u003ccode\u003e\u003cspan\u003eoperator\u003c/span\u003e\u003cspan\u003e[]\u003c/span\u003e\u003c/code\u003e\nto produce its mutable reference result object. But you’re not allowed\nmore than one mutable reference to the same place. \u003cem\u003eThis is an\nexclusivity error!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eRust avoids this problem in two ways:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIn general there is no function overloading. As a convention, if\nthere are mutable and const versions of a function, the mutable one is\nnamed with a \u003ccode\u003e_mut\u003c/code\u003e suffix.\u003c/li\u003e\n\u003cli\u003eThere is syntax sugar which maps subscript operations to either\n\u003ccode\u003eindex\u003c/code\u003e or\n\u003ccode\u003eindex_mut\u003c/code\u003e. The latter is chosen in a\n\u003cem\u003emutable context\u003c/em\u003e, which is the left-hand side of an\nassignment.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe can’t ditch function overloading and remain C++. But we can change\nhow overload resolution evaluates candidates. The standard conversion is\nresponsible for binding references to expressions. C++ chooses the wrong\n(for safety purposes) subscript candidate because the standard\nconversion is able to bind mutable references to lvalue expressions.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/K3b8hP1W5\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb21\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb21-1\"\u003e\u003cspan\u003evoid\u003c/span\u003e f3\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e x, \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e y\u003cspan\u003e)\u003c/span\u003e safe;\u003c/span\u003e\n\u003cspan id=\"cb21-2\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-3\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-4\"\u003e  std2\u003cspan\u003e::\u003c/span\u003evector\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e vec \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb21-5\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-6\"\u003e  \u003cspan\u003e// Okay.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-7\"\u003e  f3\u003cspan\u003e(\u003c/span\u003evec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e, vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb21-8\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-9\"\u003e  \u003cspan\u003e// Ill-formed: mutable borrow of vec between its mutable borrow and its use.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb21-10\"\u003e  f3\u003cspan\u003e(\u003c/span\u003emut vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e, mut vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb21-11\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb22\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb22-1\"\u003esafety: during safety checking of int main() safe\u003c/span\u003e\n\u003cspan id=\"cb22-2\"\u003e  borrow checking: example.cpp:13:22\u003c/span\u003e\n\u003cspan id=\"cb22-3\"\u003e    f3(mut vec[0], mut vec[1]); \u003c/span\u003e\n\u003cspan id=\"cb22-4\"\u003e                       ^\u003c/span\u003e\n\u003cspan id=\"cb22-5\"\u003e  mutable borrow of vec between its mutable borrow and its use\u003c/span\u003e\n\u003cspan id=\"cb22-6\"\u003e  loan created at example.cpp:13:10\u003c/span\u003e\n\u003cspan id=\"cb22-7\"\u003e    f3(mut vec[0], mut vec[1]); \u003c/span\u003e\n\u003cspan id=\"cb22-8\"\u003e           ^\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSafe C++ changes the standard conversion to work around this language\ndefect. In this extension, \u003cem\u003estandard conversions do not bind mutable\nreferences\u003c/em\u003e. \u003ccode\u003evec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/code\u003e\nchooses the \u003cem\u003econst\u003c/em\u003e candidate, which permits aliasing, and \u003ccode\u003emut vec\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003c/code\u003e\nchooses the \u003cem\u003emutable\u003c/em\u003e candidate, which does not. By opting in to\nmutation, you get aliasing by default.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/9G9oj68Yx\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb23\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb23-1\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003efeature on safety\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb23-2\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb23-3\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb23-4\"\u003e  \u003cspan\u003eint\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb23-5\"\u003e  \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e ref \u003cspan\u003e=\u003c/span\u003e x;  \u003cspan\u003e// Ill-formed! Can\u0026#39;t bind mutable reference to lvalue.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb23-6\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv id=\"cb24\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb24-1\"\u003eerror: example.cpp:5:14\u003c/span\u003e\n\u003cspan id=\"cb24-2\"\u003e  int^ ref = x; \u003c/span\u003e\n\u003cspan id=\"cb24-3\"\u003e             ^\u003c/span\u003e\n\u003cspan id=\"cb24-4\"\u003ecannot implicitly bind borrow int^ to lvalue int\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003emut\u003c/code\u003e keyword\u003cspan data-cites=\"mutation\"\u003e[\u003ca href=\"https://safecpp.org/draft.html#explicit-mutation\" role=\"doc-biblioref\"\u003emutation\u003c/a\u003e]\u003c/span\u003e puts the subexpression into\n\u003cem\u003ethe mutable context\u003c/em\u003e and restores the restricted functionality.\nIn the mutable context, the compiler will bind mutable references to\nexpression:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://godbolt.org/z/xYcW3hYrf\"\u003e(Compiler Explorer)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv id=\"cb25\"\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan id=\"cb25-1\"\u003e\u003cspan\u003e#\u003c/span\u003e\u003cspan\u003efeature on safety\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb25-2\"\u003e\u003c/span\u003e\n\u003cspan id=\"cb25-3\"\u003e\u003cspan\u003eint\u003c/span\u003e main\u003cspan\u003e()\u003c/span\u003e safe \u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb25-4\"\u003e  \u003cspan\u003eint\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e;\u003c/span\u003e\n\u003cspan id=\"cb25-5\"\u003e  \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e^\u003c/span\u003e ref \u003cspan\u003e=\u003c/span\u003e mut x;  \u003cspan\u003e// Ok. Can bind mutable references in mutable context.\u003c/span\u003e\u003c/span\u003e\n\u003cspan id=\"cb25-6\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNow, the const overload of a function is chosen unless the user\nescapes with the \u003ccode\u003emut\u003c/code\u003e keyword. This\naddresses a language defect head-on.\u003c/p\u003e\n\u003cp\u003eWhat option does Profiles have? In its full generality, the mutable\nbinding default makes for an exceptionally thorny analysis problem. Does\nProfiles replace calls to mutable candidates with calls to\nsimilarly-named const candidates? That’s a presumption. Does it\nretroactively classify mutable loans as shared loans depending on usage?\nI’m not a soundness maverick. This is getting close to touching a live\nwire.\u003c/p\u003e\n\u003cp\u003eLegacy C++ errs on the side of mutability, making it too\nunconstrained to test for soundness. Old code is what it is.\u003c/p\u003e\n\u003ch2 data-number=\"6\" id=\"carcinization\"\u003e Carcinization\u003ca href=\"#carcinization\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eThe development of new product lines for use in service of\ncritical infrastructure or NCFs (national critical functions) in a\nmemory-unsafe language (e.g., C or C++) … is dangerous and significantly\nelevates risk to national security, national economic security, and\nnational public health and safety.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– CISA, Product Security Bad Practices\u003cspan data-cites=\"cisa\"\u003e[\u003ca href=\"https://www.cisa.gov/resources-tools/resources/product-security-bad-practices\" role=\"doc-biblioref\"\u003ecisa\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cspan data-cites=\"P3466R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf\" role=\"doc-biblioref\"\u003eP3466R0\u003c/a\u003e]\u003c/span\u003e insists that “we want to make\nsure C++ evolution … hews to C++’s core principles.” But these are\n\u003cem\u003ebad principles\u003c/em\u003e. They make C++ extra vulnerable to memory safety\ndefects that are prevented in memory-safe languages. The US Government\nimplicates C++’s core principles as a danger to national security and\npublic health.\u003c/p\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\u003ctr\u003e\u003cth\u003e\n\u003c/th\u003e\n\u003cth\u003e\nStatic lifetimes\n\u003c/th\u003e\n\u003cth\u003e\nDynamic lifetimes\n\u003c/th\u003e\n\u003c/tr\u003e\u003ctr\u003e\n\u003cth\u003e\nStatic types\n\u003c/th\u003e\n\u003ctd\u003e\nRust\n\u003c/td\u003e\n\u003ctd\u003e\nJava, Go\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth\u003e\nDynamic types\n\u003c/th\u003e\n\u003ctd\u003e\n-\n\u003c/td\u003e\n\u003ctd\u003e\nJavascript, Python\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eReconsider this table. We want to evolve C++ to live in the static\ntypes/static lifetimes quadrant. Since Rust is the only species in that\ndesign family (at least among production languages), a new entry is\nnecessarily going to resemble Rust (at least in its memory safety\ntreatment) more than it does other languages. An earnest effort to\npursue \u003cspan data-cites=\"P1179R1\"\u003e[\u003ca href=\"https://wg21.link/p1179r1\" role=\"doc-biblioref\"\u003eP1179R1\u003c/a\u003e]\u003c/span\u003e as a Lifetime TS\u003cspan data-cites=\"P3465R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf\" role=\"doc-biblioref\"\u003eP3465R0\u003c/a\u003e]\u003c/span\u003e will compromise on C++’s\noutdated and unworkable core principles and adopt mechanisms more like\nRust’s. In the compiler business this is called \u003cem\u003ecarcinization\u003c/em\u003e:\na tendency of non-crab organisms to evolve crab-like features.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStandard C++ doesn’t have aliasing information. We need \u003cstrong\u003ea\nnew reference type\u003c/strong\u003e that upholds the “mutation XOR aliasing”\nrule as a program-wide invariant.\u003c/li\u003e\n\u003cli\u003eStandard C++ doesn’t have lifetime information. We need\n\u003cstrong\u003elifetime parameters\u003c/strong\u003e to indicate constraint\nrelationships between function parameters and return references.\u003c/li\u003e\n\u003cli\u003eSafety is a transitive property. It has to be upheld with a\n\u003cem\u003e\u003cstrong\u003esafe-specifier\u003c/strong\u003e\u003c/em\u003e on functions to establish the\nabsence of soundness preconditions and an\n\u003cem\u003e\u003cstrong\u003eunsafe-block\u003c/strong\u003e\u003c/em\u003e to call unsafe operations.\u003c/li\u003e\n\u003cli\u003eLifetime constraints are a transitive property. They must be upheld\nby both caller and callee as \u003cstrong\u003eviral annotations\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eLifetime constraints on functions do not follow any particular\nconvention. Constraints that deviate from a default (such as the\nlifetime elision rules) require annotation, even \u003cstrong\u003eheavy\nannotations\u003c/strong\u003e that may exceed 1 per 1,000 lines of code.\u003c/li\u003e\n\u003cli\u003eThe standard conversion rules make exclusivity enforcement\nimpossible. We have to change the language default, establishing\n\u003cstrong\u003eno implicit mutation\u003c/strong\u003e in order to support aliasing in\nfunctions that take const references.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 data-number=\"7\" id=\"c-in-the-future\"\u003e C++ in the future\u003ca href=\"#c-in-the-future\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eI think it is worth pursuing this compatible path first before,\nor at least at the same time as, trying to graft another foreign\nlanguage’s semantics onto C++ which turns C++ into “something else”\nand/or build an off-ramp from C++.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e– Pursue \u003cspan data-cites=\"P1179R1\"\u003e[\u003ca href=\"https://wg21.link/p1179r1\" role=\"doc-biblioref\"\u003eP1179R1\u003c/a\u003e]\u003c/span\u003e as a Lifetime TS\u003cspan data-cites=\"P3465R0\"\u003e[\u003ca href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf\" role=\"doc-biblioref\"\u003eP3465R0\u003c/a\u003e]\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWho does this provincialism serve? The latest Android security study\n“prioritizes transitioning to memory-safe languages.”\u003cspan data-cites=\"android-security\"\u003e[\u003ca href=\"https://security.googleblog.com/2024/09/eliminating-memory-safety-vulnerabilities-Android.html?m=1\" role=\"doc-biblioref\"\u003eandroid-security\u003c/a\u003e]\u003c/span\u003e The off-ramp from C++\nis an increasingly viable and attractive strategy for projects looking\nto reduce CVE exposure. The off-ramp is happening and its benefits are\nmeasurable. As the Android study observes, “once we turn off the tap of\nnew vulnerabilities, they decrease exponentially, making all of our code\nsafer.”\u003c/p\u003e\n\u003cp\u003eAll focus should be on turning off the tap of new vulnerabilities.\nIncorporating Rust’s safety model into C++ helps in two ways:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003eIt provides an off-ramp from unsafe C++ to Safe C++ within a single\ntoolchain. Projects can follow best practices for Safe Coding\u003cspan data-cites=\"safe-coding\"\u003e[\u003ca href=\"https://storage.googleapis.com/gweb-research2023-media/pubtools/7665.pdf\" role=\"doc-biblioref\"\u003esafe-coding\u003c/a\u003e]\u003c/span\u003e without retraining the\nwhole engineering staff in a new programming language.\u003c/li\u003e\n\u003cli\u003eIt can hasten the migration to Rust by improving C++/Rust interop.\nBy extending C++ with representations of all Rust constructs that can\nappear in function declarations (such as Rust enums, borrows and\nlifetimes, ZSTs, traits, etc) the number of common vocabulary types is\ngreatly increased. This allows interop tooling to map between C++ and\nRust declarations at a more expressive level than the current C-level\nAPI.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eC++ can be made memory safe, but not by dismissing everything that\nworks, which is what the authors of Safety Profiles do. The language\nmust evolve to be more explicit in how it expresses aliasing, lifetime\nand safeness properties. C++ can meet the security needs of its users,\nboth in a principal role, and, for those projects determined to take the\noff-ramp, in an important supporting role.\u003c/p\u003e\n\u003ch2 data-number=\"8\" id=\"bibliography\"\u003e References\u003ca href=\"#bibliography\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cdiv id=\"refs\" data-entry-spacing=\"1\" role=\"doc-bibliography\"\u003e\n\n\n\n\n\u003cdiv id=\"ref-P1179R1\" role=\"doc-biblioentry\"\u003e\u003cp\u003e\n[P1179R1] Herb Sutter. 2019-11-22. Lifetime safety: Preventing common\ndangling. \u003c/p\u003e\u003ca href=\"https://wg21.link/p1179r1\"\u003e\u003cp\u003ehttps://wg21.link/p1179r1\u003c/p\u003e\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv id=\"ref-P3081R0\" role=\"doc-biblioentry\"\u003e\u003cp\u003e\n[P3081R0] Core safety Profiles\u0026#34; Specification, adoptability, and impact.\n\u003c/p\u003e\u003ca href=\"https://isocpp.org/files/papers/P3081R0.pdf\"\u003e\u003cp\u003ehttps://isocpp.org/files/papers/P3081R0.pdf\u003c/p\u003e\u003c/a\u003e\n\u003c/div\u003e\n\n\n\n\n\u003cdiv id=\"ref-type-and-resource-safety-2015\" role=\"doc-biblioentry\"\u003e\u003cp\u003e\n[type-and-resource-safety-2015] A brief introduction to C++\u0026#34;s model for\ntype- and resource- safety. \u003c/p\u003e\u003ca href=\"https://www.stroustrup.com/resource-model.pdf\"\u003e\u003cp\u003ehttps://www.stroustrup.com/resource-model.pdf\u003c/p\u003e\u003c/a\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "39 min read",
  "publishedTime": null,
  "modifiedTime": null
}
