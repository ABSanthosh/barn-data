{
  "id": "54184ee1-088f-4d40-96f7-506c0647718b",
  "title": "TypedDicts are better than you think",
  "link": "https://blog.changs.co.uk/typeddicts-are-better-than-you-think.html",
  "description": "Comments",
  "author": "",
  "published": "Thu, 10 Oct 2024 17:56:11 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "By Jamie Chang",
  "length": 7850,
  "excerpt": "TypedDict was introduced in PEP-589 which landed in Python 3.8. The primary use case was to create type annotations for dictionaries. For example,...",
  "siteName": "",
  "favicon": "",
  "text": "TypedDict was introduced in PEP-589 which landed in Python 3.8. The primary use case was to create type annotations for dictionaries. For example, class Movie(TypedDict): title: str movie: Movie = {\"title\": \"Avatar\"} I remember thinking at the time that this was pretty neat, but I tend to use dataclass or pydantic to represent 'record' type data. Instead I use dictionaries more as a collection, so the standard dict[KT, VT] annotation is enough. Non-totality I revisited typeddicts when I looked at implementing a HTTP patch endpoint. Let's suppose I have a data structure represented by the following dataclass: @dataclass class User: id: UUID name: str subscription: str | None = None Where subscription = None means no subscription. Let's say we want to option to patch name, subscription. You might define the patch body using dataclass: @dataclass class PatchUser: name: str | None = None subscription: str | None = None Here we have a problem, for subscription does None mean don't change or remove subscription. We can fix this a number of ways, for example, we can take the string 'none' to mean no subscription instead, or make a new sentinel value called NoChange to indicate no changes. These solutions all feel a little awkward, this is because dataclasses don't have a concept of a field being missing. But this is where dictionaries shine. Dictionaries are not general expected to have all the fields available. We get a KeyError if a field is missing and there are convenience methods such as .get(key, [default]) to fetch a key that is not guaranteed to be present. This makes TypedDict the ideal data structure in this scenario: class PatchUser(TypedDict, total=False): name: str | None subscription: str | None = None Since total is False here (by default it is set to True), name or subscription can be absent from the dictionary. Which represents the PATCH operation much better than a dataclass or Pydantic model. Further additions in PEP-655 allows us to mark individual fields as Required or NotRequired which further increases its flexibility. If you're wondering about FastAPI support for TypedDict, Pydantic supports it out of the box. So your TypedDict can be used in a FastAPI endpoint. Using TypedDict as **kwargs PEP-692 introduced the ability to type variadic keyword arguments using TypedDict. So the following two snippets are equivalent. Without TypedDict: def my_function(*, option1: int, option2: str) -\u003e None: ... Using TypedDict: from typing import TypedDict, Unpack class Options(TypedDict): option1: int option2: str def my_function(**options: Unpack[Options]) -\u003e None: ... At a glance I can say that the TypedDict option is rather verbose. Though it does become more useful if Options were used in multiple function definitions. def my_function2(**options) -\u003e None: ... def my_function3(*, other_option: str, **options) -\u003e None: ... Where it truely shines is once again with non-totality. Suppose we have the following scenario, where we want to create a custom version of pytest.fixture, but still pass through some arguments. def fixture(scope: str = \"module\", autouse: bool = False): return pytest.fixture(scope, autouse) Here to get the typing right I not only have to find the type of each argument but also the default value. It would be better if we use **kwargs so we can just avoid passing the arguments through. And to keep type information we just need to use our trusty TypedDict once more: class FixtureOptions(TypedDict, total=False): scope: str autouse: bool def fixture(**options: Unpack[FixtureOptions]): # Some custom implementations ... return pytest.fixture(**options) Non-totallity means that we don't have to pass in scope and autouse. We can just have the default. Sentinels We can achieve similar behaviour with sentinels: UNSPECIFIED: Any = object() # Has to be Any type so it could be set as default for other types. def my_func(option1: bool = UNSPECIFIED, ...) -\u003e ...: if option1 is UNSPECIFIED: ... ... Sentinels work well enough here, but we have to remember to handle them. Additionally type annotations for sentinels can be a bit awkward, here we made UNSPECIFIED an Any type, but it means that inside the function option1 is only typed as bool. There are options to expose the sentinel type but they may add even more confusion. Using TypedDict to pass in dependencies We can do even more with PEP-692! When I first learned about the PEP, I thought it was only about function signature. But reading through it more thoroughly, I discovered that another consequence of the PEP is that type checkers can now check for function invocation when using TypedDicts: def purge(queue: str, timeout: float) -\u003e ...: ... class Options(TypedDict): queue: str timeout: float class WrongOptions(TypedDict): queue: str timeout: timedelta options: Options = ... purge(**options) # ✅ wrong_options: WrongOptions = ... purge(**wrong_options) # ❌ This feature is necessary in many situations such as cases where we pass through the kwargs. For example, in the fixture example, when we invoke pytest.fixture(**options) the type checker will perform proper type checking. But we can use it in more creative ways. Dependency Injection Let's consider a situation where we have many resources that share some dependencies. class UserClient: def __init__(self, db: Engine, user_service: APIClient) -\u003e None: ... class ProjectClient: def __init__(self, db: Engine, user_service: APIClient, project_service: APIClient) -\u003e None: ... We want a way to create all the dependencies in one place and pass in the dependencies. Essentially we need something that is the union of all kwargs of the resources. That suddernly sounds a lot like a TypedDict: class Dependencies(TypedDict): db: Engine user_service: APIClient project_service: APIClient def create_deps(...) -\u003e Dependencies: ... Unfortunately this won't work since UserClient can't take project_service as a kwarg. To fix this, we need to rewrite the resources such that we accept arbitrary arguments. class UserClient: def __init__(self, ..., **_) -\u003e None: ... ... And then we can do the injection like this: class ResourceWithMissing: def __init__(self, other: Any, **_) -\u003e None: ... def inject(deps: Dependencies): UserClient(**deps) # ✅ ProjectClient(**deps) # ✅ ResourceWithMissing(**deps) # ❌ ... inject(create_deps(...)) With the solution complete, we can now rely on the type system to check the dependency injection to see if any arguments are incorrect or missing. I will admit that changing resource signature with **_ is not ideal, but this is a smaller change than most dependency injection frameworks. And we get static type checking which a lot of the frameworks won't support. Upcoming Features PEP-728 will allow types of extra items to be defined, and a typed dict to be closed meaning no extra items can be defined. This new change looks like it'll help us define record types more precisely. I personally haven't thought of many other use cases for it, but as I've demonstrated above it's always worth reading through the PEP and experimenting with the new change. PEP-705 might already be out by the time you read this. This will allow for read only items to be specified. This is primarily intended for situations where different typed dicts intuitively should be compatible but potential mutations (deletions) can create problems. Proudly powered by Pelican, which takes great advantage of Python. The theme is by Smashing Magazine, thanks!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection id=\"content\"\u003e\n    \u003carticle\u003e\n      \u003cheader\u003e\n        \n      \u003c/header\u003e\n\n      \u003cdiv\u003e\n        \u003cp\u003e\u003ccode\u003eTypedDict\u003c/code\u003e was introduced in \u003ca href=\"https://peps.python.org/pep-0589/\"\u003ePEP-589\u003c/a\u003e which landed in Python 3.8.\u003c/p\u003e\n\u003cp\u003eThe primary use case was to create type annotations for dictionaries. For example,\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMovie\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n\n\n\u003cspan\u003emovie\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eMovie\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\u0026#34;title\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;Avatar\u0026#34;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eI remember thinking at the time that this was pretty neat, but I tend to use \u003ccode\u003edataclass\u003c/code\u003e or \u003ccode\u003epydantic\u003c/code\u003e to represent \u0026#39;record\u0026#39; type data. Instead I use dictionaries more as a collection, so the standard \u003ccode\u003edict[KT, VT]\u003c/code\u003e annotation is enough.\u003c/p\u003e\n\u003ch3\u003eNon-totality\u003c/h3\u003e\n\u003cp\u003eI revisited typeddicts when I looked at implementing a HTTP patch endpoint.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s suppose I have a data structure represented by the following dataclass:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003e@dataclass\u003c/span\u003e\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eUser\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUUID\u003c/span\u003e\n    \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003esubscription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhere \u003ccode\u003esubscription = None\u003c/code\u003e means no subscription.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s say we want to option to patch name, subscription. You might define the patch body using dataclass:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003e@dataclass\u003c/span\u003e\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePatchUser\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n    \u003cspan\u003esubscription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHere we have a problem, for subscription does \u003ccode\u003eNone\u003c/code\u003e mean don\u0026#39;t change or remove subscription. \u003c/p\u003e\n\u003cp\u003eWe can fix this a number of ways, for example, we can take the string \u003ccode\u003e\u0026#39;none\u0026#39;\u003c/code\u003e to mean no subscription instead, or make a new sentinel value called \u003ccode\u003eNoChange\u003c/code\u003e to indicate no changes.\u003c/p\u003e\n\u003cp\u003eThese solutions all feel a little awkward, this is because dataclasses don\u0026#39;t have a concept of a field being missing. But this is where dictionaries shine. Dictionaries are not general expected to have all the fields available. We get a \u003ccode\u003eKeyError\u003c/code\u003e if a field is missing and there are convenience methods such as \u003ccode\u003e.get(key, [default])\u003c/code\u003e to fetch a key that is not guaranteed to be present.\u003c/p\u003e\n\u003cp\u003eThis makes \u003ccode\u003eTypedDict\u003c/code\u003e the ideal data structure in this scenario:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003ePatchUser\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etotal\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n    \u003cspan\u003esubscription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSince \u003ccode\u003etotal\u003c/code\u003e is False here (by default it is set to True), \u003ccode\u003ename\u003c/code\u003e or \u003ccode\u003esubscription\u003c/code\u003e can be absent from the dictionary. Which represents the PATCH operation much better than a \u003ccode\u003edataclass\u003c/code\u003e or Pydantic model.\u003c/p\u003e\n\u003cp\u003eFurther additions in \u003ca href=\"https://peps.python.org/pep-0655/\"\u003ePEP-655\u003c/a\u003e allows us to mark individual fields as \u003ccode\u003eRequired\u003c/code\u003e or \u003ccode\u003eNotRequired\u003c/code\u003e which further increases its flexibility.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you\u0026#39;re wondering about FastAPI support for TypedDict, \u003ca href=\"https://docs.pydantic.dev/2.3/usage/types/dicts_mapping/#typeddict\"\u003ePydantic supports it out of the box\u003c/a\u003e. So your TypedDict can be used in a FastAPI endpoint.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eUsing \u003ccode\u003eTypedDict\u003c/code\u003e as \u003ccode\u003e**kwargs\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0692/\"\u003ePEP-692\u003c/a\u003e introduced the ability to type variadic keyword arguments using \u003ccode\u003eTypedDict\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo the following two snippets are equivalent.\nWithout \u003ccode\u003eTypedDict\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_function\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eoption1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eoption2\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eUsing \u003ccode\u003eTypedDict\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003efrom\u003c/span\u003e \u003cspan\u003etyping\u003c/span\u003e \u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eUnpack\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eOptions\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003eoption1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e\n    \u003cspan\u003eoption2\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_function\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnpack\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eOptions\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAt a glance I can say that the TypedDict option is rather verbose. Though it does become more useful if Options were used in multiple function definitions.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_function2\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_function3\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eother_option\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhere it truely shines is once again with non-totality.\u003c/p\u003e\n\u003cp\u003eSuppose we have the following scenario, where we want to create a custom version of pytest.fixture, but still pass through some arguments.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003efixture\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003escope\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;module\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eautouse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003epytest\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efixture\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003escope\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eautouse\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHere to get the typing right I not only have to find the type of each argument but also the default value. It would be better if we use \u003ccode\u003e**kwargs\u003c/code\u003e so we can just avoid passing the arguments through. And to keep type information we just need to use our trusty \u003ccode\u003eTypedDict\u003c/code\u003e once more:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eFixtureOptions\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etotal\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eFalse\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003escope\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003eautouse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003efixture\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnpack\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eFixtureOptions\u003c/span\u003e\u003cspan\u003e]):\u003c/span\u003e\n    \u003cspan\u003e# Some custom implementations\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003epytest\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efixture\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNon-totallity means that we don\u0026#39;t have to pass in scope and autouse. We can just have the default.\u003c/p\u003e\n\u003ch4\u003eSentinels\u003c/h4\u003e\n\u003cp\u003eWe can achieve similar behaviour with sentinels:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eUNSPECIFIED\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e  \u003cspan\u003e# Has to be Any type so it could be set as default for other types.\u003c/span\u003e\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003emy_func\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eoption1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eUNSPECIFIED\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eoption1\u003c/span\u003e \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003eUNSPECIFIED\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSentinels work well enough here, but we have to remember to handle them. Additionally type annotations for sentinels can be a bit awkward, here we made \u003ccode\u003eUNSPECIFIED\u003c/code\u003e an \u003ccode\u003eAny\u003c/code\u003e type, but it means that inside the function \u003ccode\u003eoption1\u003c/code\u003e is only typed as \u003ccode\u003ebool\u003c/code\u003e. There are options to expose the sentinel type but they may add even more confusion.\u003c/p\u003e\n\u003ch3\u003eUsing \u003ccode\u003eTypedDict\u003c/code\u003e to pass in dependencies\u003c/h3\u003e\n\u003cp\u003eWe can do even more with \u003ca href=\"https://peps.python.org/pep-0692/\"\u003ePEP-692\u003c/a\u003e! When I first learned about the PEP, I thought it was only about function signature. But reading through it more thoroughly, I discovered that another consequence of the PEP is that type checkers can now check for function invocation when using TypedDicts:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003epurge\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003equeue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etimeout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efloat\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eOptions\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003equeue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003etimeout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efloat\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eWrongOptions\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003equeue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003etimeout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etimedelta\u003c/span\u003e\n\n\n\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eOptions\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\n\u003cspan\u003epurge\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003eoptions\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e# ✅\u003c/span\u003e\n\n\u003cspan\u003ewrong_options\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eWrongOptions\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\n\u003cspan\u003epurge\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003ewrong_options\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e# ❌\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThis feature is necessary in many situations such as cases where we pass through the kwargs. For example, in the \u003ccode\u003efixture\u003c/code\u003e example, when we invoke \u003ccode\u003epytest.fixture(**options)\u003c/code\u003e the type checker will perform proper type checking.\u003c/p\u003e\n\u003cp\u003eBut we can use it in more creative ways.\u003c/p\u003e\n\u003ch4\u003eDependency Injection\u003c/h4\u003e\n\u003cp\u003eLet\u0026#39;s consider a situation where we have many resources that share some dependencies. \u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eUserClient\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edb\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eEngine\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003euser_service\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAPIClient\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eProjectClient\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003edb\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eEngine\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003euser_service\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAPIClient\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eproject_service\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAPIClient\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWe want a way to create all the dependencies in one place and pass in the dependencies.\u003c/p\u003e\n\u003cp\u003eEssentially we need something that is the union of all kwargs of the resources. That suddernly sounds a lot like a TypedDict:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eDependencies\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eTypedDict\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003edb\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eEngine\u003c/span\u003e\n    \u003cspan\u003euser_service\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAPIClient\u003c/span\u003e\n    \u003cspan\u003eproject_service\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAPIClient\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ecreate_deps\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eDependencies\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eUnfortunately this won\u0026#39;t work since \u003ccode\u003eUserClient\u003c/code\u003e can\u0026#39;t take \u003ccode\u003eproject_service\u003c/code\u003e as a kwarg.\u003c/p\u003e\n\u003cp\u003eTo fix this, we need to rewrite the resources such that we accept arbitrary arguments.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eUserClient\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\u003cspan\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd then we can do the injection like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eResourceWithMissing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eother\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003einject\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edeps\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDependencies\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003eUserClient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003edeps\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e# ✅\u003c/span\u003e\n    \u003cspan\u003eProjectClient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003edeps\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e# ✅\u003c/span\u003e\n    \u003cspan\u003eResourceWithMissing\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e**\u003c/span\u003e\u003cspan\u003edeps\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e# ❌\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003einject\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecreate_deps\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWith the solution complete, we can now rely on the type system to check the dependency injection to see if any arguments are incorrect or missing. \u003c/p\u003e\n\u003cp\u003eI will admit that changing resource signature with \u003ccode\u003e**_\u003c/code\u003e is not ideal, but this is a smaller change than most dependency injection frameworks. And we get static type checking which a lot of the frameworks won\u0026#39;t support.\u003c/p\u003e\n\u003ch3\u003eUpcoming Features\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0728/\"\u003ePEP-728\u003c/a\u003e will allow types of extra items to be defined, and a typed dict to be closed meaning no extra items can be defined.\u003c/p\u003e\n\u003cp\u003eThis new change looks like it\u0026#39;ll help us define record types more precisely.\u003c/p\u003e\n\u003cp\u003eI personally haven\u0026#39;t thought of many other use cases for it, but as I\u0026#39;ve demonstrated above it\u0026#39;s always worth reading through the PEP and experimenting with the new change. \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://peps.python.org/pep-0705/\"\u003ePEP-705\u003c/a\u003e might already be out by the time you read this. This will allow for read only items to be specified.\u003c/p\u003e\n\u003cp\u003eThis is primarily intended for situations where different typed dicts intuitively should be compatible but potential mutations (deletions) can create problems.\u003c/p\u003e\n      \u003c/div\u003e\n\n    \u003c/article\u003e\n  \u003c/section\u003e\u003cdiv id=\"contentinfo\"\u003e\n                        \u003caddress id=\"about\"\u003e\n                                Proudly powered by \u003ca rel=\"nofollow\" href=\"https://getpelican.com/\"\u003ePelican\u003c/a\u003e, which takes great advantage of \u003ca rel=\"nofollow\" href=\"https://www.python.org/\"\u003ePython\u003c/a\u003e.\n                        \u003c/address\u003e\n\n                        \u003cp\u003eThe theme is by \u003ca rel=\"nofollow\" href=\"https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/\"\u003eSmashing Magazine\u003c/a\u003e, thanks!\u003c/p\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": null,
  "modifiedTime": null
}
