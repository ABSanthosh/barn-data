{
  "id": "ab03ef5d-da8e-4f3c-86cd-1cd264e7c2a1",
  "title": "PEP 750 – Template Strings",
  "link": "https://peps.python.org/pep-0750/",
  "description": "Comments",
  "author": "",
  "published": "Thu, 10 Apr 2025 20:24:01 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 48898,
  "excerpt": "This PEP introduces template strings for custom string processing.",
  "siteName": "Python Enhancement Proposals (PEPs)",
  "favicon": "https://peps.python.org/_static/py.png",
  "text": "Author: Jim Baker \u003cjim.baker at python.org\u003e, Guido van Rossum \u003cguido at python.org\u003e, Paul Everitt \u003cpauleveritt at me.com\u003e, Koudai Aono \u003ckoxudaxi at gmail.com\u003e, Lysandros Nikolaou \u003clisandrosnik at gmail.com\u003e, Dave Peck \u003cdavepeck at davepeck.org\u003e Discussions-To: Discourse thread Status: Accepted Type: Standards Track Created: 08-Jul-2024 Python-Version: 3.14 Post-History: 09-Aug-2024, 17-Oct-2024, 21-Oct-2024, 18-Nov-2024 Resolution: 10-Apr-2025 Table of Contents Abstract Relationship With Other PEPs Motivation Specification Template String Literals The Template Type The Interpolation Type The Template.values Property Iterating Template Contents Processing Template Strings Template String Concatenation Template and Interpolation Equality No Support for Ordering Support for the debug specifier (=) Raw Template Strings Interpolation Expression Evaluation Exceptions No Template.__str__() Implementation The string.templatelib Module Examples Example: Implementing f-strings with t-strings Example: Structured Logging Approach 1: Custom Log Messages Approach 2: Custom Formatters Example: HTML Templating Backwards Compatibility Security Implications How To Teach This Why another templating approach? Common Patterns Seen in Processing Templates Structural Pattern Matching Memoizing Parsing to Intermediate Representations Context-sensitive Processing of Interpolations Nested Template Strings Approaches to Lazy Evaluation Approaches to Asynchronous Evaluation Approaches to Template Reuse Relation to Format Strings Reference Implementation Rejected Ideas Arbitrary String Literal Prefixes Delayed Evaluation of Interpolations Making Template and Interpolation Into Protocols Overridden __eq__ and __hash__ for Template and Interpolation An Additional Decoded Type The Final Home for Template and Interpolation Enable Full Reconstruction of Original Template Literal Disallowing String Concatenation Arbitrary Conversion Values Removing conversion From Interpolation Alternate Interpolation Symbols Alternate Layouts for Template Mechanism to Describe the “Kind” of Template Binary Template Strings Acknowledgements Copyright Abstract This PEP introduces template strings for custom string processing. Template strings are a generalization of f-strings, using a t in place of the f prefix. Instead of evaluating to str, t-strings evaluate to a new type, Template: template: Template = t\"Hello {name}\" Templates provide developers with access to the string and its interpolated values before they are combined. This brings native flexible string processing to the Python language and enables safety checks, web templating, domain-specific languages, and more. Relationship With Other PEPs Python introduced f-strings in Python 3.6 with PEP 498. The grammar was then formalized in PEP 701 which also lifted some restrictions. This PEP is based on PEP 701. At nearly the same time PEP 498 arrived, PEP 501 was written to provide “i-strings” – that is, “interpolation template strings”. The PEP was deferred pending further experience with f-strings. Work on this PEP was resumed by a different author in March 2023, introducing “t-strings” as template literal strings, and built atop PEP 701. The authors of this PEP consider it to be a generalization and simplification of the updated work in PEP 501. (That PEP has also recently been updated to reflect the new ideas in this PEP.) Motivation Python f-strings are easy to use and very popular. Over time, however, developers have encountered limitations that make them unsuitable for certain use cases. In particular, f-strings provide no way to intercept and transform interpolated values before they are combined into a final string. As a result, incautious use of f-strings can lead to security vulnerabilities. For example, a user executing a SQL query with sqlite3 may be tempted to use an f-string to embed values into their SQL expression, which could lead to a SQL injection attack. Or, a developer building HTML may include unescaped user input in the string, leading to a cross-site scripting (XSS) vulnerability. More broadly, the inability to transform interpolated values before they are combined into a final string limits the utility of f-strings in more complex string processing tasks. Template strings address these problems by providing developers with access to the string and its interpolated values. For example, imagine we want to generate some HTML. Using template strings, we can define an html() function that allows us to automatically sanitize content: evil = \"\u003cscript\u003ealert('evil')\u003c/script\u003e\" template = t\"\u003cp\u003e{evil}\u003c/p\u003e\" assert html(template) == \"\u003cp\u003e\u0026lt;script\u0026gt;alert('evil')\u0026lt;/script\u0026gt;\u003c/p\u003e\" Likewise, our hypothetical html() function can make it easy for developers to add attributes to HTML elements using a dictionary: attributes = {\"src\": \"shrubbery.jpg\", \"alt\": \"looks nice\"} template = t\"\u003cimg {attributes} /\u003e\" assert html(template) == '\u003cimg src=\"shrubbery.jpg\" alt=\"looks nice\" /\u003e' Neither of these examples is possible with f-strings. By providing a mechanism to intercept and transform interpolated values, template strings enable a wide range of string processing use cases. Specification Template String Literals This PEP introduces a new string prefix, t, to define template string literals. These literals resolve to a new type, Template, found in the standard library module string.templatelib. The following code creates a Template instance: from string.templatelib import Template template = t\"This is a template string.\" assert isinstance(template, Template) Template string literals support the full syntax of PEP 701. This includes the ability to nest template strings within interpolations, as well as the ability to use all valid quote marks (', \", ''', and \"\"\"). Like other string prefixes, the t prefix must immediately precede the quote. Like f-strings, both lowercase t and uppercase T prefixes are supported. Like f-strings, t-strings may not be combined with u or the b prefix. Additionally, f-strings and t-strings cannot be combined, so the ft prefix is invalid. t-strings may be combined with the r prefix; see the Raw Template Strings section below for more information. The Template Type Template strings evaluate to an instance of a new immutable type, string.templatelib.Template: class Template: strings: tuple[str, ...] \"\"\" A non-empty tuple of the string parts of the template, with N+1 items, where N is the number of interpolations in the template. \"\"\" interpolations: tuple[Interpolation, ...] \"\"\" A tuple of the interpolation parts of the template. This will be an empty tuple if there are no interpolations. \"\"\" def __new__(cls, *args: str | Interpolation): \"\"\" Create a new Template instance. Arguments can be provided in any order. \"\"\" ... @property def values(self) -\u003e tuple[object, ...]: \"\"\" Return a tuple of the `value` attributes of each Interpolation in the template. This will be an empty tuple if there are no interpolations. \"\"\" ... def __iter__(self) -\u003e Iterator[str | Interpolation]: \"\"\" Iterate over the string parts and interpolations in the template. These may appear in any order. Empty strings will not be included. \"\"\" ... The strings and interpolations attributes provide access to the string parts and any interpolations in the literal: name = \"World\" template = t\"Hello {name}\" assert template.strings[0] == \"Hello \" assert template.interpolations[0].value == \"World\" The Interpolation Type The Interpolation type represents an expression inside a template string. Like Template, it is a new class found in the string.templatelib module: class Interpolation: value: object expression: str conversion: Literal[\"a\", \"r\", \"s\"] | None format_spec: str __match_args__ = (\"value\", \"expression\", \"conversion\", \"format_spec\") def __new__( cls, value: object, expression: str, conversion: Literal[\"a\", \"r\", \"s\"] | None = None, format_spec: str = \"\", ): ... The Interpolation type is shallow immutable. Its attributes cannot be reassigned. The value attribute is the evaluated result of the interpolation: name = \"World\" template = t\"Hello {name}\" assert template.interpolations[0].value == \"World\" The expression attribute is the original text of the interpolation: name = \"World\" template = t\"Hello {name}\" assert template.interpolations[0].expression == \"name\" We expect that the expression attribute will not be used in most template processing code. It is provided for completeness and for use in debugging and introspection. See both the Common Patterns Seen in Processing Templates section and the Examples section for more information on how to process template strings. The conversion attribute is the optional conversion to be used, one of r, s, and a, corresponding to repr(), str(), and ascii() conversions. As with f-strings, no other conversions are supported: name = \"World\" template = t\"Hello {name!r}\" assert template.interpolations[0].conversion == \"r\" If no conversion is provided, conversion is None. The format_spec attribute is the format specification. As with f-strings, this is an arbitrary string that defines how to present the value: value = 42 template = t\"Value: {value:.2f}\" assert template.interpolations[0].format_spec == \".2f\" Format specifications in f-strings can themselves contain interpolations. This is permitted in template strings as well; format_spec is set to the eagerly evaluated result: value = 42 precision = 2 template = t\"Value: {value:.{precision}f}\" assert template.interpolations[0].format_spec == \".2f\" If no format specification is provided, format_spec defaults to an empty string (\"\"). This matches the format_spec parameter of Python’s format() built-in. Unlike f-strings, it is up to code that processes the template to determine how to interpret the conversion and format_spec attributes. Such code is not required to use these attributes, but when present they should be respected, and to the extent possible match the behavior of f-strings. It would be surprising if, for example, a template string that uses {value:.2f} did not round the value to two decimal places when processed. The Template.values Property The Template.values property is a shortcut for accessing the value attribute of each Interpolation in the template and is equivalent to: @property def values(self) -\u003e tuple[object, ...]: return tuple(i.value for i in self.interpolations) Iterating Template Contents The Template.__iter__() method provides a simple way to access the full contents of a template. It yields the string parts and interpolations in the order they appear, with empty strings omitted. The __iter__() method is equivalent to: def __iter__(self) -\u003e Iterator[str | Interpolation]: for s, i in zip_longest(self.strings, self.interpolations): if s: yield s if i: yield i The following examples show the __iter__() method in action: assert list(t\"\") == [] assert list(t\"Hello\") == [\"Hello\"] name = \"World\" template = t\"Hello {name}!\" contents = list(template) assert len(contents) == 3 assert contents[0] == \"Hello \" assert contents[1].value == \"World\" assert contents[1].expression == \"name\" assert contents[2] == \"!\" Empty strings, which may be present in Template.strings, are not included in the output of the __iter__() method: first = \"Eat\" second = \"Red Leicester\" template = t\"{first}{second}\" contents = list(template) assert len(contents) == 2 assert contents[0].value == \"Eat\" assert contents[0].expression == \"first\" assert contents[1].value == \"Red Leicester\" assert contents[1].expression == \"second\" # However, the strings attribute contains empty strings: assert template.strings == (\"\", \"\", \"\") Template processing code can choose to work with any combination of strings, interpolations, values, and __iter__() based on requirements and convenience. Processing Template Strings Developers can write arbitrary code to process template strings. For example, the following function renders static parts of the template in lowercase and interpolations in uppercase: from string.templatelib import Template, Interpolation def lower_upper(template: Template) -\u003e str: \"\"\"Render static parts lowercased and interpolations uppercased.\"\"\" parts: list[str] = [] for item in template: if isinstance(item, Interpolation): parts.append(str(item.value).upper()) else: parts.append(item.lower()) return \"\".join(parts) name = \"world\" assert lower_upper(t\"HELLO {name}\") == \"hello WORLD\" There is no requirement that template strings are processed in any particular way. Code that processes templates has no obligation to return a string. Template strings are a flexible, general-purpose feature. See the Common Patterns Seen in Processing Templates section for more information on how to process template strings. See the Examples section for detailed working examples. Template String Concatenation Template strings support explicit concatenation using +. Concatenation is supported for two Template instances as well as for a Template instance and a str: name = \"World\" template = t\"{name}\" assert isinstance(t\"Hello \" + template, Template) assert (t\"Hello \" + template).strings == (\"Hello \", \"\") assert (t\"Hello \" + template).interpolations[0].value == \"World\" assert isinstance(\"Hello \" + template, Template) assert (\"Hello \" + template).strings == (\"Hello \", \"\") assert (\"Hello \" + template).interpolations[0].value == \"World\" Concatenation of templates is “viral”: the concatenation of a Template and a str always results in a Template instance. Python’s implicit concatenation syntax is also supported. The following code will work as expected: name = \"World\" assert (t\"Hello \" t\"World\").strings == (\"Hello World\",) assert (\"Hello \" t\"World\").strings == (\"Hello World\",) The Template type supports the __add__() and __radd__() methods between two Template instances and between a Template instance and a str. Template and Interpolation Equality Template and Interpolation instances compare with object identity (is). Template instances are intended to be used by template processing code, which may return a string or any other type. Those types can provide their own equality semantics as needed. No Support for Ordering The Template and Interpolation types do not support ordering. This is unlike all other string literal types in Python, which support lexicographic ordering. Because interpolations can contain arbitrary values, there is no natural ordering for them. As a result, neither the Template nor the Interpolation type implements the standard comparison methods. Support for the debug specifier (=) The debug specifier, =, is supported in template strings and behaves similarly to how it behaves in f-strings, though due to limitations of the implementation there is a slight difference. In particular, t'{value=}' is treated as t'value={value!r}': name = \"World\" template = t\"Hello {name=}\" assert template.strings[0] == \"Hello name=\" assert template.interpolations[0].value == \"World\" assert template.interpolations[0].conversion == \"r\" If a separate format string is also provided, t'{value=:fmt} is treated instead as t'value={value!s:fmt}'. Whitespace is preserved in the debug specifier, so t'{value = }' is treated as t'value = {value!r}'. Raw Template Strings Raw template strings are supported using the rt (or tr) prefix: trade = 'shrubberies' template = rt'Did you say \"{trade}\"?\\n' assert template.strings[0] == r'Did you say \"' assert template.strings[1] == r'\"?\\n' In this example, the \\n is treated as two separate characters (a backslash followed by ‘n’) rather than a newline character. This is consistent with Python’s raw string behavior. As with regular template strings, interpolations in raw template strings are processed normally, allowing for the combination of raw string behavior and dynamic content. Interpolation Expression Evaluation Expression evaluation for interpolations is the same as in PEP 498: The expressions that are extracted from the string are evaluated in the context where the template string appeared. This means the expression has full access to its lexical scope, including local and global variables. Any valid Python expression can be used, including function and method calls. Template strings are evaluated eagerly from left to right, just like f-strings. This means that interpolations are evaluated immediately when the template string is processed, not deferred or wrapped in lambdas. Exceptions Exceptions raised in t-string literals are the same as those raised in f-string literals. No Template.__str__() Implementation The Template type does not provide a specialized __str__() implementation. This is because Template instances are intended to be used by template processing code, which may return a string or any other type. There is no canonical way to convert a Template to a string. The Template and Interpolation types both provide useful __repr__() implementations. The string.templatelib Module The string module will be converted into a package, with a new templatelib submodule containing the Template and Interpolation types. Following the implementation of this PEP, this new module may be used for related functions, such as convert(), or potential future template processing code, such as shell script helpers. Examples All examples in this section of the PEP have fully tested reference implementations available in the public pep750-examples git repository. Example: Implementing f-strings with t-strings It is easy to “implement” f-strings using t-strings. That is, we can write a function f(template: Template) -\u003e str that processes a Template in much the same way as an f-string literal, returning the same result: name = \"World\" value = 42 templated = t\"Hello {name!r}, value: {value:.2f}\" formatted = f\"Hello {name!r}, value: {value:.2f}\" assert f(templated) == formatted The f() function supports both conversion specifiers like !r and format specifiers like :.2f. The full code is fairly simple: from string.templatelib import Template, Interpolation def convert(value: object, conversion: Literal[\"a\", \"r\", \"s\"] | None) -\u003e object: if conversion == \"a\": return ascii(value) elif conversion == \"r\": return repr(value) elif conversion == \"s\": return str(value) return value def f(template: Template) -\u003e str: parts = [] for item in template: match item: case str() as s: parts.append(s) case Interpolation(value, _, conversion, format_spec): value = convert(value, conversion) value = format(value, format_spec) parts.append(value) return \"\".join(parts) Example: Structured Logging Structured logging allows developers to log data in machine-readable formats like JSON. With t-strings, developers can easily log structured data alongside human-readable messages using just a single log statement. We present two different approaches to implementing structured logging with template strings. Approach 1: Custom Log Messages The Python Logging Cookbook has a short section on how to implement structured logging. The logging cookbook suggests creating a new “message” class, StructuredMessage, that is constructed with a simple text message and a separate dictionary of values: message = StructuredMessage(\"user action\", { \"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\" }) logging.info(message) # Outputs: # user action \u003e\u003e\u003e {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"} The StructuredMessage.__str__() method formats both the human-readable message and the values, combining them into a final string. (See the logging cookbook for its full example.) We can implement an improved version of StructuredMessage using template strings: import json from string.templatelib import Interpolation, Template from typing import Mapping class TemplateMessage: def __init__(self, template: Template) -\u003e None: self.template = template @property def message(self) -\u003e str: # Use the f() function from the previous example return f(self.template) @property def values(self) -\u003e Mapping[str, object]: return { item.expression: item.value for item in self.template if isinstance(item, Interpolation) } def __str__(self) -\u003e str: return f\"{self.message} \u003e\u003e\u003e {json.dumps(self.values)}\" _ = TemplateMessage # optional, to improve readability action, amount, item = \"traded\", 42, \"shrubs\" logging.info(_(t\"User {action}: {amount:.2f} {item}\")) # Outputs: # User traded: 42.00 shrubs \u003e\u003e\u003e {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"} Template strings give us a more elegant way to define the custom message class. With template strings it is no longer necessary for developers to make sure that their format string and values dictionary are kept in sync; a single template string literal is all that is needed. The TemplateMessage implementation can automatically extract structured keys and values from the Interpolation.expression and Interpolation.value attributes, respectively. Approach 2: Custom Formatters Custom messages are a reasonable approach to structured logging but can be a little awkward. To use them, developers must wrap every log message they write in a custom class. This can be easy to forget. An alternative approach is to define custom logging.Formatter classes. This approach is more flexible and allows for more control over the final output. In particular, it’s possible to take a single template string and output it in multiple formats (human-readable and JSON) to separate log streams. We define two simple formatters, a MessageFormatter for human-readable output and a ValuesFormatter for JSON output: import json from logging import Formatter, LogRecord from string.templatelib import Interpolation, Template from typing import Any, Mapping class MessageFormatter(Formatter): def message(self, template: Template) -\u003e str: # Use the f() function from the previous example return f(template) def format(self, record: LogRecord) -\u003e str: msg = record.msg if not isinstance(msg, Template): return super().format(record) return self.message(msg) class ValuesFormatter(Formatter): def values(self, template: Template) -\u003e Mapping[str, Any]: return { item.expression: item.value for item in template if isinstance(item, Interpolation) } def format(self, record: LogRecord) -\u003e str: msg = record.msg if not isinstance(msg, Template): return super().format(record) return json.dumps(self.values(msg)) We can then use these formatters when configuring our logger: import logging import sys logger = logging.getLogger(__name__) message_handler = logging.StreamHandler(sys.stdout) message_handler.setFormatter(MessageFormatter()) logger.addHandler(message_handler) values_handler = logging.StreamHandler(sys.stderr) values_handler.setFormatter(ValuesFormatter()) logger.addHandler(values_handler) action, amount, item = \"traded\", 42, \"shrubs\" logger.info(t\"User {action}: {amount:.2f} {item}\") # Outputs to sys.stdout: # User traded: 42.00 shrubs # At the same time, outputs to sys.stderr: # {\"action\": \"traded\", \"amount\": 42, \"item\": \"shrubs\"} This approach has a couple advantages over the custom message approach to structured logging: Developers can log a t-string directly without wrapping it in a custom class. Human-readable and structured output can be sent to separate log streams. This is useful for log aggregation systems that process structured data independently from human-readable data. Example: HTML Templating This PEP contains several short HTML templating examples. It turns out that the “hypothetical” html() function mentioned in the Motivation section (and a few other places in this PEP) exists and is available in the pep750-examples repository. If you’re thinking about parsing a complex grammar with template strings, we hope you’ll find it useful. Backwards Compatibility Like f-strings, use of template strings will be a syntactic backwards incompatibility with previous versions. Security Implications The security implications of working with template strings, with respect to interpolations, are as follows: Scope lookup is the same as f-strings (lexical scope). This model has been shown to work well in practice. Code that processes Template instances can ensure that any interpolations are processed in a safe fashion, including respecting the context in which they appear. How To Teach This Template strings have several audiences: Developers using template strings and processing functions Authors of template processing code Framework authors who build interesting machinery with template strings We hope that teaching developers will be straightforward. At a glance, template strings look just like f-strings. Their syntax is familiar and the scoping rules remain the same. The first thing developers must learn is that template string literals don’t evaluate to strings; instead, they evaluate to a new type, Template. This is a simple type intended to be used by template processing code. It’s not until developers call a processing function that they get the result they want: typically, a string, although processing code can of course return any arbitrary type. Developers will also want to understand how template strings relate to other string formatting methods like f-strings and str.format(). They will need to decide when to use each method. If a simple string is all that is needed, and there are no security implications, f-strings are likely the best choice. For most cases where a format string is used, it can be replaced with a function wrapping the creation of a template string. In cases where the format string is obtained from user input, the filesystem, or databases, it is possible to write code to convert it into a Template instance if desired. Because developers will learn that t-strings are nearly always used in tandem with processing functions, they don’t necessarily need to understand the details of the Template type. As with descriptors and decorators, we expect many more developers will use t-strings than write t-string processing functions. Over time, a small number of more advanced developers will wish to author their own template processing code. Writing processing code often requires thinking in terms of formal grammars. Developers will need to learn how to work with the strings and interpolation attributes of a Template instance and how to process interpolations in a context-sensitive fashion. More sophisticated grammars will likely require parsing to intermediate representations like an abstract syntax tree (AST). Great template processing code will handle format specifiers and conversions when appropriate. Writing production-grade template processing code – for instance, to support HTML templates – can be a large undertaking. We expect that template strings will provide framework authors with a powerful new tool in their toolbox. While the functionality of template strings overlaps with existing tools like template engines, t-strings move that logic into the language itself. Bringing the full power and generality of Python to bear on string processing tasks opens new possibilities for framework authors. Why another templating approach? The world of Python already has mature templating languages with wide adoption, such as Jinja. Why build support for creating new templating systems? Projects such as Jinja are still needed in cases where the template is less part of the software by the developers, and more part of customization by designers or even content created by users, for example in a CMS. The trends in frontend development have treated templating as part of the software and written by developers. They want modern language features and a good tooling experience. PEP 750 envisions DSLs where the non-static parts are Python: same scope rules, typing, expression syntax, and the like. Common Patterns Seen in Processing Templates Structural Pattern Matching Iterating over the Template with structural pattern matching is the expected best practice for many template function implementations: from string.templatelib import Template, Interpolation def process(template: Template) -\u003e Any: for item in template: match item: case str() as s: ... # handle each string part case Interpolation() as interpolation: ... # handle each interpolation Processing code may also commonly sub-match on attributes of the Interpolation type: match arg: case Interpolation(int()): ... # handle interpolations with integer values case Interpolation(value=str() as s): ... # handle interpolations with string values # etc. Memoizing Template functions can efficiently process both static and dynamic parts of templates. The structure of Template objects allows for effective memoization: strings = template.strings # Static string parts values = template.values # Dynamic interpolated values This separation enables caching of processed static parts while dynamic parts can be inserted as needed. Authors of template processing code can use the static strings as cache keys, leading to significant performance improvements when similar templates are used repeatedly. Parsing to Intermediate Representations Code that processes templates can parse the template string into intermediate representations, like an AST. We expect that many template processing libraries will use this approach. For instance, rather than returning a str, our theoretical html() function (see the Motivation section) could return an HTML Element defined in the same package: @dataclass(frozen=True) class Element: tag: str attributes: Mapping[str, str | bool] children: Sequence[str | Element] def __str__(self) -\u003e str: ... def html(template: Template) -\u003e Element: ... Calling str(element) would then render the HTML but, in the meantime, the Element could be manipulated in a variety of ways. Context-sensitive Processing of Interpolations Continuing with our hypothetical html() function, it could be made context-sensitive. Interpolations could be processed differently depending on where they appear in the template. For example, our html() function could support multiple kinds of interpolations: attributes = {\"id\": \"main\"} attribute_value = \"shrubbery\" content = \"hello\" template = t\"\u003cdiv {attributes} data-value={attribute_value}\u003e{content}\u003c/div\u003e\" element = html(template) assert str(element) == '\u003cdiv id=\"main\" data-value=\"shrubbery\"\u003ehello\u003c/div\u003e' Because the {attributes} interpolation occurs in the context of an HTML tag, and because there is no corresponding attribute name, it is treated as a dictionary of attributes. The {attribute_value} interpolation is treated as a simple string value and is quoted before inclusion in the final string. The {content} interpolation is treated as potentially unsafe content and is escaped before inclusion in the final string. Nested Template Strings Going a step further with our html() function, we could support nested template strings. This would allow for more complex HTML structures to be built up from simpler templates: name = \"World\" content = html(t\"\u003cp\u003eHello {name}\u003c/p\u003e\") template = t\"\u003cdiv\u003e{content}\u003c/div\u003e\" element = html(template) assert str(element) == '\u003cdiv\u003e\u003cp\u003eHello World\u003c/p\u003e\u003c/div\u003e' Because the {content} interpolation is an Element instance, it does not need to be escaped before inclusion in the final string. One could imagine a nice simplification: if the html() function is passed a Template instance, it could automatically convert it to an Element by recursively calling itself on the nested template. We expect that nesting and composition of templates will be a common pattern in template processing code and, where appropriate, used in preference to simple string concatenation. Approaches to Lazy Evaluation Like f-strings, interpolations in t-string literals are eagerly evaluated. However, there are cases where lazy evaluation may be desirable. If a single interpolation is expensive to evaluate, it can be explicitly wrapped in a lambda in the template string literal: name = \"World\" template = t\"Hello {(lambda: name)}\" assert callable(template.interpolations[0].value) assert template.interpolations[0].value() == \"World\" This assumes, of course, that template processing code anticipates and handles callable interpolation values. (One could imagine also supporting iterators, awaitables, etc.) This is not a requirement of the PEP, but it is a common pattern in template processing code. In general, we hope that the community will develop best practices for lazy evaluation of interpolations in template strings and that, when it makes sense, common libraries will provide support for callable or awaitable values in their template processing code. Approaches to Asynchronous Evaluation Closely related to lazy evaluation is asynchronous evaluation. As with f-strings, the await keyword is allowed in interpolations: async def example(): async def get_name() -\u003e str: await asyncio.sleep(1) return \"Sleepy\" template = t\"Hello {await get_name()}\" # Use the f() function from the f-string example, above assert f(template) == \"Hello Sleepy\" More sophisticated template processing code can take advantage of this to perform asynchronous operations in interpolations. For example, a “smart” processing function could anticipate that an interpolation is an awaitable and await it before processing the template string: async def example(): async def get_name() -\u003e str: await asyncio.sleep(1) return \"Sleepy\" template = t\"Hello {get_name}\" assert await async_f(template) == \"Hello Sleepy\" This assumes that the template processing code in async_f() is asynchronous and is able to await an interpolation’s value. Approaches to Template Reuse If developers wish to reuse template strings multiple times with different values, they can write a function to return a Template instance: def reusable(name: str, question: str) -\u003e Template: return t\"Hello {name}, {question}?\" template = reusable(\"friend\", \"how are you\") template = reusable(\"King Arthur\", \"what is your quest\") This is, of course, no different from how f-strings can be reused. Relation to Format Strings The venerable str.format() method accepts format strings that can later be used to format values: alas_fmt = \"We're all out of {cheese}.\" assert alas_fmt.format(cheese=\"Red Leicester\") == \"We're all out of Red Leicester.\" If one squints, one can think of format strings as a kind of function definition. The call to str.format() can be seen as a kind of function call. The t-string equivalent is to simply define a standard Python function that returns a Template instance: def make_template(*, cheese: str) -\u003e Template: return t\"We're all out of {cheese}.\" template = make_template(cheese=\"Red Leicester\") # Using the f() function from the f-string example, above assert f(template) == \"We're all out of Red Leicester.\" The make_template() function itself can be thought of as analogous to the format string. The call to make_template() is analogous to the call to str.format(). Of course, it is common to load format strings from external sources like a filesystem or database. Thankfully, because Template and Interpolation are simple Python types, it is possible to write a function that takes an old-style format string and returns an equivalent Template instance: def from_format(fmt: str, /, *args: object, **kwargs: object) -\u003e Template: \"\"\"Parse `fmt` and return a `Template` instance.\"\"\" ... # Load this from a file, database, etc. fmt = \"We're all out of {cheese}.\" template = from_format(fmt, cheese=\"Red Leicester\") # Using the f() function from the f-string example, above assert f(template) == \"We're all out of Red Leicester.\" This is a powerful pattern that allows developers to use template strings in places where they might have previously used format strings. A full implementation of from_format() is available in the examples repository, which supports the full grammar of format strings. Reference Implementation A CPython implementation of PEP 750 is available. There is also a public repository of examples and tests built around the reference implementation. If you’re interested in playing with template strings, this repository is a great place to start. Rejected Ideas This PEP has been through several significant revisions. In addition, quite a few interesting ideas were considered both in revisions of PEP 501 and in the Discourse discussion. We attempt to document the most significant ideas that were considered and rejected. Arbitrary String Literal Prefixes Inspired by JavaScript tagged template literals, an earlier version of this PEP allowed for arbitrary “tag” prefixes in front of literal strings: The prefix was a special callable called a “tag function”. Tag functions received the parts of the template string in an argument list. They could then process the string and return an arbitrary value: def my_tag(*args: str | Interpolation) -\u003e Any: ... This approach was rejected for several reasons: It was deemed too complex to build in full generality. JavaScript allows for arbitrary expressions to precede a template string, which is a significant challenge to implement in Python. It precluded future introduction of new string prefixes. It seemed to needlessly pollute the namespace. Use of a single t prefix was chosen as a simpler, more Pythonic approach and more in keeping with template strings’ role as a generalization of f-strings. Delayed Evaluation of Interpolations An early version of this PEP proposed that interpolations should be lazily evaluated. All interpolations were “wrapped” in implicit lambdas. Instead of having an eagerly evaluated value attribute, interpolations had a getvalue() method that would resolve the value of the interpolation: class Interpolation: ... _value: Callable[[], object] def getvalue(self) -\u003e object: return self._value() This was rejected for several reasons: The overwhelming majority of use cases for template strings naturally call for immediate evaluation. Delayed evaluation would be a significant departure from the behavior of f-strings. Implicit lambda wrapping leads to difficulties with type hints and static analysis. Most importantly, there are viable (if imperfect) alternatives to implicit lambda wrapping in many cases where lazy evaluation is desired. See the section on Approaches to Lazy Evaluation, above, for more information. While delayed evaluation was rejected for this PEP, we hope that the community continues to explore the idea. Making Template and Interpolation Into Protocols An early version of this PEP proposed that the Template and Interpolation types be runtime checkable protocols rather than classes. In the end, we felt that using classes was more straightforward. Overridden __eq__ and __hash__ for Template and Interpolation Earlier versions of this PEP proposed that the Template and Interpolation types should have their own implementations of __eq__ and __hash__. Templates were considered equal if their strings and interpolations were equal; Interpolations were considered equal if their value, expression, conversion, and format_spec were equal. Interpolation hashing was similar to tuple hashing: an Interpolation was hashable if and only if its value was hashable. This was rejected because Template.__hash__ so defined was not useful as a cache key in template processing code; we were concerned that it would be confusing to developers. By dropping these implementations of __eq__ and __hash__, we lose the ability to write asserts such as: name = \"World\" assert t\"Hello \" + t\"{name}\" == t\"Hello {name}\" Because Template instances are intended to be quickly processed by further code, we felt that the utility of these asserts was limited. An Additional Decoded Type An early version of this PEP proposed an additional type, Decoded, to represent the “static string” parts of a template string. This type derived from str and had a single extra raw attribute that provided the original text of the string. We rejected this in favor of the simpler approach of using plain str and allowing combination of r and t prefixes. The Final Home for Template and Interpolation Previous versions of this PEP proposed placing the Template and Interpolation types in: types, collections, collections.abc, and even in a new top-level module, templatelib. The final decision was to place them in string.templatelib. Enable Full Reconstruction of Original Template Literal Earlier versions of this PEP attempted to make it possible to fully reconstruct the text of the original template string from a Template instance. This was rejected as being overly complex. The mapping between template literal source and the underlying AST is not one-to-one and there are several limitations with respect to round-tripping to the original source text. First, Interpolation.format_spec defaults to \"\" if not provided: value = 42 template1 = t\"{value}\" template2 = t\"{value:}\" assert template1.interpolations[0].format_spec == \"\" assert template2.interpolations[0].format_spec == \"\" Next, the debug specifier, =, is treated as a special case and is processed before the AST is created. It is therefore not possible to distinguish t\"{value=}\" from t\"value={value!r}\": value = 42 template1 = t\"{value=}\" template2 = t\"value={value!r}\" assert template1.strings[0] == \"value=\" assert template1.interpolations[0].expression == \"value\" assert template1.interpolations[0].conversion == \"r\" assert template2.strings[0] == \"value=\" assert template2.interpolations[0].expression == \"value\" assert template2.interpolations[0].conversion == \"r\" Finally, format specifiers in f-strings allow arbitrary nesting. In this PEP and in the reference implementation, the specifier is eagerly evaluated to set the format_spec in the Interpolation, thereby losing the original expressions. For example: value = 42 precision = 2 template1 = t\"{value:.2f}\" template2 = t\"{value:.{precision}f}\" assert template1.interpolations[0].format_spec == \".2f\" assert template2.interpolations[0].format_spec == \".2f\" We do not anticipate that these limitations will be a significant issue in practice. Developers who need to obtain the original template string literal can always use inspect.getsource() or similar tools. Disallowing String Concatenation Earlier versions of this PEP proposed that template strings should not support concatenation. This was rejected in favor of allowing concatenation. There are reasonable arguments in favor of rejecting one or all forms of concatenation: namely, that it cuts off a class of potential bugs, particularly when one takes the view that template strings will often contain complex grammars for which concatenation doesn’t always have the same meaning (or any meaning). Moreover, the earliest versions of this PEP proposed a syntax closer to JavaScript’s tagged template literals, where an arbitrary callable could be used as a prefix to a string literal. There was no guarantee that the callable would return a type that supported concatenation. In the end, we decided that the surprise to developers of a new string type not supporting concatenation was likely to be greater than the theoretical harm caused by supporting it. (Developers concatenate f-strings all the time, after all, and while we are sure there are cases where this introduces bugs, it’s not clear that those bugs outweigh the benefits of supporting concatenation.) While concatenation is supported, we expect that code that uses template strings will more commonly build up larger templates through nesting and composition rather than concatenation. Arbitrary Conversion Values Python allows only r, s, or a as possible conversion type values. Trying to assign a different value results in SyntaxError. In theory, template functions could choose to handle other conversion types. But this PEP adheres closely to PEP 701. Any changes to allowed values should be in a separate PEP. Removing conversion From Interpolation While drafting this PEP, we considered removing the conversion attribute from Interpolation and specifying that the conversion should be performed eagerly, before Interpolation.value is set. This was done to simplify the work of writing template processing code. The conversion attribute is of limited extensibility (it is typed as Literal[\"r\", \"s\", \"a\"] | None). It is not clear that it adds significant value or flexibility to template strings that couldn’t better be achieved with custom format specifiers. Unlike with format specifiers, there is no equivalent to Python’s format() built-in. (Instead, we include a sample implementation of convert() in the Examples section.) Ultimately we decided to keep the conversion attribute in the Interpolation type to maintain compatibility with f-strings and to allow for future extensibility. Alternate Interpolation Symbols In the early stages of this PEP, we considered allowing alternate symbols for interpolations in template strings. For example, we considered allowing ${name} as an alternative to {name} with the idea that it might be useful for i18n or other purposes. See the Discourse thread for more information. This was rejected in favor of keeping t-string syntax as close to f-string syntax as possible. Alternate Layouts for Template During the development of this PEP, we considered several alternate layouts for the Template type. Many focused on a single args tuple that contained both strings and interpolations. Variants included: args was a tuple[str | Interpolation, ...]` with the promise that its first and last items were strings and that strings and interpolations always alternated. This implied that args was always non-empty and that empty strings would be inserted between neighboring interpolations. This was rejected because alternation could not be captured by the type system and was not a guarantee we wished to make. args remained a tuple[str | Interpolation, ...] but did not support interleaving. As a result, empty strings were not added to the sequence. It was no longer possible to obtain static strings with args[::2]; instead, instance checks or structural pattern matching had to be used to distinguish between strings and interpolations. This approach was rejected as offering less future opportunity for performance optimization. args was typed as a Sequence[tuple[str, Interpolation | None]]. Each static string was paired with is neighboring interpolation. The final string part had no corresponding interpolation. This was rejected as being overly complex. Mechanism to Describe the “Kind” of Template If t-strings prove popular, it may be useful to have a way to describe the “kind” of content found in a template string: “sql”, “html”, “css”, etc. This could enable powerful new features in tools such as linters, formatters, type checkers, and IDEs. (Imagine, for example, black formatting HTML in t-strings, or mypy checking whether a given attribute is valid for an HTML tag.) While exciting, this PEP does not propose any specific mechanism. It is our hope that, over time, the community will develop conventions for this purpose. Binary Template Strings The combination of t-strings and bytes (tb) is considered out of scope for this PEP. However, unlike f-strings, there is no fundamental reason why t-strings and bytes cannot be combined. Support could be considered in a future PEP. Acknowledgements Thanks to Ryan Morshead for contributions during development of the ideas leading to template strings. Special mention also to Dropbox’s pyxl for tackling similar ideas years ago. Andrea Giammarchi provided thoughtful feedback on the early drafts of this PEP. Finally, thanks to Joachim Viide for his pioneering work on the tagged library. Tagged was not just the precursor to template strings, but the place where the whole effort started via a GitHub issue comment! Copyright This document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.",
  "image": "https://peps.python.org/_static/og-image.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection id=\"pep-content\"\u003e\n\n\u003cdl\u003e\n\u003cdt\u003eAuthor\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003eJim Baker \u0026lt;jim.baker at python.org\u0026gt;,\nGuido van Rossum \u0026lt;guido at python.org\u0026gt;,\nPaul Everitt \u0026lt;pauleveritt at me.com\u0026gt;,\nKoudai Aono \u0026lt;koxudaxi at gmail.com\u0026gt;,\nLysandros Nikolaou \u0026lt;lisandrosnik at gmail.com\u0026gt;,\nDave Peck \u0026lt;davepeck at davepeck.org\u0026gt;\u003c/dd\u003e\n\u003cdt\u003eDiscussions-To\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e\u003ca href=\"https://discuss.python.org/t/71594\"\u003eDiscourse thread\u003c/a\u003e\u003c/dd\u003e\n\u003cdt\u003eStatus\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e\u003cabbr title=\"Normative proposal accepted for implementation\"\u003eAccepted\u003c/abbr\u003e\u003c/dd\u003e\n\u003cdt\u003eType\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e\u003cabbr title=\"Normative PEP with a new feature for Python, implementation change for CPython or interoperability standard for the ecosystem\"\u003eStandards Track\u003c/abbr\u003e\u003c/dd\u003e\n\u003cdt\u003eCreated\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e08-Jul-2024\u003c/dd\u003e\n\u003cdt\u003ePython-Version\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e3.14\u003c/dd\u003e\n\u003cdt\u003ePost-History\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e\u003ca href=\"https://discuss.python.org/t/60408\" title=\"Discourse thread\"\u003e09-Aug-2024\u003c/a\u003e,\n\u003ca href=\"https://discuss.python.org/t/60408/201\" title=\"Discourse message\"\u003e17-Oct-2024\u003c/a\u003e,\n\u003ca href=\"https://discuss.python.org/t/60408/226\" title=\"Discourse message\"\u003e21-Oct-2024\u003c/a\u003e,\n\u003ca href=\"https://discuss.python.org/t/71594\" title=\"Discourse thread\"\u003e18-Nov-2024\u003c/a\u003e\u003c/dd\u003e\n\u003cdt\u003eResolution\u003cspan\u003e:\u003c/span\u003e\u003c/dt\u003e\n\u003cdd\u003e\u003ca href=\"https://discuss.python.org/t/71594/130\"\u003e10-Apr-2025\u003c/a\u003e\u003c/dd\u003e\n\u003c/dl\u003e\n\u003chr/\u003e\n\u003csection id=\"contents\"\u003e\n\u003cdetails\u003e\u003csummary\u003eTable of Contents\u003c/summary\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#abstract\"\u003eAbstract\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#relationship-with-other-peps\"\u003eRelationship With Other PEPs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#motivation\"\u003eMotivation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#specification\"\u003eSpecification\u003c/a\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#template-string-literals\"\u003eTemplate String Literals\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-template-type\"\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-interpolation-type\"\u003eThe \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-template-values-property\"\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate.values\u003c/span\u003e\u003c/code\u003e Property\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#iterating-template-contents\"\u003eIterating \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e Contents\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#processing-template-strings\"\u003eProcessing Template Strings\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#template-string-concatenation\"\u003eTemplate String Concatenation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#template-and-interpolation-equality\"\u003eTemplate and Interpolation Equality\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#no-support-for-ordering\"\u003eNo Support for Ordering\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#support-for-the-debug-specifier\"\u003eSupport for the debug specifier (\u003ccode\u003e\u003cspan\u003e=\u003c/span\u003e\u003c/code\u003e)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#raw-template-strings\"\u003eRaw Template Strings\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#interpolation-expression-evaluation\"\u003eInterpolation Expression Evaluation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#exceptions\"\u003eExceptions\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#no-template-str-implementation\"\u003eNo \u003ccode\u003e\u003cspan\u003eTemplate.__str__()\u003c/span\u003e\u003c/code\u003e Implementation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-string-templatelib-module\"\u003eThe \u003ccode\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003c/code\u003e Module\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#examples\"\u003eExamples\u003c/a\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#example-implementing-f-strings-with-t-strings\"\u003eExample: Implementing f-strings with t-strings\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#example-structured-logging\"\u003eExample: Structured Logging\u003c/a\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#approach-1-custom-log-messages\"\u003eApproach 1: Custom Log Messages\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#approach-2-custom-formatters\"\u003eApproach 2: Custom Formatters\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#example-html-templating\"\u003eExample: HTML Templating\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#backwards-compatibility\"\u003eBackwards Compatibility\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#security-implications\"\u003eSecurity Implications\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-to-teach-this\"\u003eHow To Teach This\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#why-another-templating-approach\"\u003eWhy another templating approach?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#common-patterns-seen-in-processing-templates\"\u003eCommon Patterns Seen in Processing Templates\u003c/a\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#structural-pattern-matching\"\u003eStructural Pattern Matching\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#memoizing\"\u003eMemoizing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#parsing-to-intermediate-representations\"\u003eParsing to Intermediate Representations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#context-sensitive-processing-of-interpolations\"\u003eContext-sensitive Processing of Interpolations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#nested-template-strings\"\u003eNested Template Strings\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#approaches-to-lazy-evaluation\"\u003eApproaches to Lazy Evaluation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#approaches-to-asynchronous-evaluation\"\u003eApproaches to Asynchronous Evaluation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#approaches-to-template-reuse\"\u003eApproaches to Template Reuse\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#relation-to-format-strings\"\u003eRelation to Format Strings\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#reference-implementation\"\u003eReference Implementation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#rejected-ideas\"\u003eRejected Ideas\u003c/a\u003e\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#arbitrary-string-literal-prefixes\"\u003eArbitrary String Literal Prefixes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#delayed-evaluation-of-interpolations\"\u003eDelayed Evaluation of Interpolations\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#making-template-and-interpolation-into-protocols\"\u003eMaking \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e Into Protocols\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#overridden-eq-and-hash-for-template-and-interpolation\"\u003eOverridden \u003ccode\u003e\u003cspan\u003e__eq__\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003e__hash__\u003c/span\u003e\u003c/code\u003e for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#an-additional-decoded-type\"\u003eAn Additional \u003ccode\u003e\u003cspan\u003eDecoded\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-final-home-for-template-and-interpolation\"\u003eThe Final Home for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#enable-full-reconstruction-of-original-template-literal\"\u003eEnable Full Reconstruction of Original Template Literal\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#disallowing-string-concatenation\"\u003eDisallowing String Concatenation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#arbitrary-conversion-values\"\u003eArbitrary Conversion Values\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#removing-conversion-from-interpolation\"\u003eRemoving \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e From \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#alternate-interpolation-symbols\"\u003eAlternate Interpolation Symbols\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#alternate-layouts-for-template\"\u003eAlternate Layouts for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mechanism-to-describe-the-kind-of-template\"\u003eMechanism to Describe the “Kind” of Template\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#binary-template-strings\"\u003eBinary Template Strings\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#acknowledgements\"\u003eAcknowledgements\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#copyright\"\u003eCopyright\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/details\u003e\u003c/section\u003e\n\u003csection id=\"abstract\"\u003e\n\u003ch2\u003e\u003ca href=\"#abstract\" role=\"doc-backlink\"\u003eAbstract\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis PEP introduces template strings for custom string processing.\u003c/p\u003e\n\u003cp\u003eTemplate strings are a generalization of f-strings, using a \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e in place of\nthe \u003ccode\u003e\u003cspan\u003ef\u003c/span\u003e\u003c/code\u003e prefix. Instead of evaluating to \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e, t-strings evaluate to a new\ntype, \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplates provide developers with access to the string and its interpolated\nvalues \u003cem\u003ebefore\u003c/em\u003e they are combined. This brings native flexible string\nprocessing to the Python language and enables safety checks, web templating,\ndomain-specific languages, and more.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"relationship-with-other-peps\"\u003e\n\u003ch2\u003e\u003ca href=\"#relationship-with-other-peps\" role=\"doc-backlink\"\u003eRelationship With Other PEPs\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePython introduced f-strings in Python 3.6 with \u003ca href=\"https://peps.python.org/pep-0498/\" title=\"PEP 498 – Literal String Interpolation\"\u003ePEP 498\u003c/a\u003e. The grammar was\nthen formalized in \u003ca href=\"https://peps.python.org/pep-0701/\" title=\"PEP 701 – Syntactic formalization of f-strings\"\u003ePEP 701\u003c/a\u003e which also lifted some restrictions. This PEP\nis based on PEP 701.\u003c/p\u003e\n\u003cp\u003eAt nearly the same time PEP 498 arrived, \u003ca href=\"https://peps.python.org/pep-0501/\" title=\"PEP 501 – General purpose template literal strings\"\u003ePEP 501\u003c/a\u003e was written to provide\n“i-strings” – that is, “interpolation template strings”. The PEP was\ndeferred pending further experience with f-strings. Work on this PEP was\nresumed by a different author in March 2023, introducing “t-strings” as template\nliteral strings, and built atop PEP 701.\u003c/p\u003e\n\u003cp\u003eThe authors of this PEP consider it to be a generalization and simplification\nof the updated work in PEP 501. (That PEP has also recently been updated to\nreflect the new ideas in this PEP.)\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"motivation\"\u003e\n\u003ch2\u003e\u003ca href=\"#motivation\" role=\"doc-backlink\"\u003eMotivation\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePython f-strings are easy to use and very popular. Over time, however, developers\nhave encountered limitations that make them\n\u003ca href=\"https://docs.djangoproject.com/en/5.1/ref/utils/#django.utils.html.format_html\"\u003eunsuitable for certain use cases\u003c/a\u003e.\nIn particular, f-strings provide no way to intercept and transform interpolated\nvalues before they are combined into a final string.\u003c/p\u003e\n\u003cp\u003eAs a result, incautious use of f-strings can lead to security vulnerabilities.\nFor example, a user executing a SQL query with \u003ca href=\"https://docs.python.org/3/library/sqlite3.html#module-sqlite3\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003esqlite3\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\nmay be tempted to use an f-string to embed values into their SQL expression,\nwhich could lead to a \u003ca href=\"https://en.wikipedia.org/wiki/SQL_injection\"\u003eSQL injection attack\u003c/a\u003e.\nOr, a developer building HTML may include unescaped user input in the string,\nleading to a \u003ca href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\"\u003ecross-site scripting (XSS)\u003c/a\u003e\nvulnerability.\u003c/p\u003e\n\u003cp\u003eMore broadly, the inability to transform interpolated values before they are\ncombined into a final string limits the utility of f-strings in more complex\nstring processing tasks.\u003c/p\u003e\n\u003cp\u003eTemplate strings address these problems by providing\ndevelopers with access to the string and its interpolated values.\u003c/p\u003e\n\u003cp\u003eFor example, imagine we want to generate some HTML. Using template strings,\nwe can define an \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function that allows us to automatically sanitize\ncontent:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eevil\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;evil\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026lt;p\u0026gt;\u003c/span\u003e\u003cspan\u003e{evil}\u003c/span\u003e\u003cspan\u003e\u0026lt;/p\u0026gt;\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026lt;p\u0026gt;\u0026amp;lt;script\u0026amp;gt;alert(\u0026#39;evil\u0026#39;)\u0026amp;lt;/script\u0026amp;gt;\u0026lt;/p\u0026gt;\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eLikewise, our hypothetical \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function can make it easy for developers\nto add attributes to HTML elements using a dictionary:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eattributes\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\u0026#34;src\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;shrubbery.jpg\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;alt\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;looks nice\u0026#34;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026lt;img \u003c/span\u003e\u003cspan\u003e{attributes}\u003c/span\u003e\u003cspan\u003e /\u0026gt;\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;\u0026lt;img src=\u0026#34;shrubbery.jpg\u0026#34; alt=\u0026#34;looks nice\u0026#34; /\u0026gt;\u0026#39;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNeither of these examples is possible with f-strings. By providing a\nmechanism to intercept and transform interpolated values, template strings\nenable a wide range of string processing use cases.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"specification\"\u003e\n\u003ch2\u003e\u003ca href=\"#specification\" role=\"doc-backlink\"\u003eSpecification\u003c/a\u003e\u003c/h2\u003e\n\u003csection id=\"template-string-literals\"\u003e\n\u003ch3\u003e\u003ca href=\"#template-string-literals\" role=\"doc-backlink\"\u003eTemplate String Literals\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThis PEP introduces a new string prefix, \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e, to define template string literals.\nThese literals resolve to a new type, \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e, found in the standard library\nmodule \u003ccode\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe following code creates a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;This is a template string.\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplate string literals support the full syntax of \u003ca href=\"https://peps.python.org/pep-0701/\" title=\"PEP 701 – Syntactic formalization of f-strings\"\u003ePEP 701\u003c/a\u003e. This includes\nthe ability to nest template strings within interpolations, as well as the ability\nto use all valid quote marks (\u003ccode\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003c/code\u003e). Like other string\nprefixes, the \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e prefix must immediately precede the quote. Like f-strings,\nboth lowercase \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e and uppercase \u003ccode\u003e\u003cspan\u003eT\u003c/span\u003e\u003c/code\u003e prefixes are supported. Like\nf-strings, t-strings may not be combined with \u003ccode\u003e\u003cspan\u003eu\u003c/span\u003e\u003c/code\u003e or the \u003ccode\u003e\u003cspan\u003eb\u003c/span\u003e\u003c/code\u003e prefix.\u003c/p\u003e\n\u003cp\u003eAdditionally, f-strings and t-strings cannot be combined, so the \u003ccode\u003e\u003cspan\u003eft\u003c/span\u003e\u003c/code\u003e\nprefix is invalid. t-strings \u003cem\u003emay\u003c/em\u003e be combined with the \u003ccode\u003e\u003cspan\u003er\u003c/span\u003e\u003c/code\u003e prefix;\nsee the \u003ca href=\"#raw-template-strings\"\u003eRaw Template Strings\u003c/a\u003e section below for more information.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"the-template-type\"\u003e\n\u003ch3\u003e\u003ca href=\"#the-template-type\" role=\"doc-backlink\"\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTemplate strings evaluate to an instance of a new immutable type,\n\u003ccode\u003e\u003cspan\u003estring.templatelib.Template\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etuple\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003e    A non-empty tuple of the string parts of the template,\u003c/span\u003e\n\u003cspan\u003e    with N+1 items, where N is the number of interpolations\u003c/span\u003e\n\u003cspan\u003e    in the template.\u003c/span\u003e\n\u003cspan\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\n    \u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etuple\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003e    A tuple of the interpolation parts of the template.\u003c/span\u003e\n\u003cspan\u003e    This will be an empty tuple if there are no interpolations.\u003c/span\u003e\n\u003cspan\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__new__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecls\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003e        Create a new Template instance.\u003c/span\u003e\n\n\u003cspan\u003e        Arguments can be provided in any order.\u003c/span\u003e\n\u003cspan\u003e        \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\n    \u003cspan\u003e@property\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003etuple\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003e        Return a tuple of the `value` attributes of each Interpolation\u003c/span\u003e\n\u003cspan\u003e        in the template.\u003c/span\u003e\n\u003cspan\u003e        This will be an empty tuple if there are no interpolations.\u003c/span\u003e\n\u003cspan\u003e        \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__iter__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eIterator\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003e        Iterate over the string parts and interpolations in the template.\u003c/span\u003e\n\n\u003cspan\u003e        These may appear in any order. Empty strings will not be included.\u003c/span\u003e\n\u003cspan\u003e        \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003estrings\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003c/code\u003e attributes provide access to the string\nparts and any interpolations in the literal:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"the-interpolation-type\"\u003e\n\u003ch3\u003e\u003ca href=\"#the-interpolation-type\" role=\"doc-backlink\"\u003eThe \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e type represents an expression inside a template string.\nLike \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e, it is a new class found in the \u003ccode\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003c/code\u003e module:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\n    \u003cspan\u003eexpression\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003econversion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLiteral\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;s\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\n    \u003cspan\u003eformat_spec\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n\n    \u003cspan\u003e__match_args__\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;expression\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;conversion\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;format_spec\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__new__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003ecls\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eexpression\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003econversion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLiteral\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;s\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eformat_spec\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e):\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e type is shallow immutable. Its attributes\ncannot be reassigned.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003evalue\u003c/span\u003e\u003c/code\u003e attribute is the evaluated result of the interpolation:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eexpression\u003c/span\u003e\u003c/code\u003e attribute is the \u003cem\u003eoriginal text\u003c/em\u003e of the interpolation:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe expect that the \u003ccode\u003e\u003cspan\u003eexpression\u003c/span\u003e\u003c/code\u003e attribute will not be used in most template\nprocessing code. It is provided for completeness and for use in debugging and\nintrospection. See both the \u003ca href=\"#common-patterns-seen-in-processing-templates\"\u003eCommon Patterns Seen in Processing Templates\u003c/a\u003e\nsection and the \u003ca href=\"#examples\"\u003eExamples\u003c/a\u003e section for more information on how to process\ntemplate strings.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e attribute is the \u003ca href=\"https://docs.python.org/3/library/string.html#formatstrings\" title=\"(in Python v3.13)\"\u003e\u003cspan\u003eoptional conversion\u003c/span\u003e\u003c/a\u003e\nto be used, one of \u003ccode\u003e\u003cspan\u003er\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003es\u003c/span\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cspan\u003ea\u003c/span\u003e\u003c/code\u003e, corresponding to \u003ccode\u003e\u003cspan\u003erepr()\u003c/span\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003cspan\u003estr()\u003c/span\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cspan\u003eascii()\u003c/span\u003e\u003c/code\u003e conversions. As with f-strings, no other conversions\nare supported:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name!r}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf no conversion is provided, \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e is \u003ccode\u003e\u003cspan\u003eNone\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e attribute is the \u003ca href=\"https://docs.python.org/3/library/string.html#formatspec\" title=\"(in Python v3.13)\"\u003e\u003cspan\u003eformat specification\u003c/span\u003e\u003c/a\u003e.\nAs with f-strings, this is an arbitrary string that defines how to present the value:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Value: \u003c/span\u003e\u003cspan\u003e{value:.2f}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;.2f\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFormat specifications in f-strings can themselves contain interpolations. This\nis permitted in template strings as well; \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e is set to the eagerly\nevaluated result:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003eprecision\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Value: {value:.\u003c/span\u003e\u003cspan\u003e{precision}\u003c/span\u003e\u003cspan\u003ef}\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;.2f\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf no format specification is provided, \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e defaults to an empty\nstring (\u003ccode\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003c/code\u003e). This matches the \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e parameter of Python’s\n\u003ca href=\"https://docs.python.org/3/library/functions.html#format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003eformat()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e built-in.\u003c/p\u003e\n\u003cp\u003eUnlike f-strings, it is up to code that processes the template to determine how to\ninterpret the \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e attributes.\nSuch code is not required to use these attributes, but when present they should\nbe respected, and to the extent possible match the behavior of f-strings.\nIt would be surprising if, for example, a template string that uses \u003ccode\u003e\u003cspan\u003e{value:.2f}\u003c/span\u003e\u003c/code\u003e\ndid not round the value to two decimal places when processed.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"the-template-values-property\"\u003e\n\u003ch3\u003e\u003ca href=\"#the-template-values-property\" role=\"doc-backlink\"\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate.values\u003c/span\u003e\u003c/code\u003e Property\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate.values\u003c/span\u003e\u003c/code\u003e property is a shortcut for accessing the \u003ccode\u003e\u003cspan\u003evalue\u003c/span\u003e\u003c/code\u003e\nattribute of each \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e in the template and is equivalent to:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e@property\u003c/span\u003e\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003etuple\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003etuple\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"iterating-template-contents\"\u003e\n\u003ch3\u003e\u003ca href=\"#iterating-template-contents\" role=\"doc-backlink\"\u003eIterating \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e Contents\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate.__iter__()\u003c/span\u003e\u003c/code\u003e method provides a simple way to access the full\ncontents of a template. It yields the string parts and interpolations in\nthe order they appear, with empty strings omitted.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003e__iter__()\u003c/span\u003e\u003c/code\u003e method is equivalent to:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__iter__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eIterator\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003ezip_longest\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n            \u003cspan\u003eyield\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n            \u003cspan\u003eyield\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe following examples show the \u003ccode\u003e\u003cspan\u003e__iter__()\u003c/span\u003e\u003c/code\u003e method in action:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e[]\u003c/span\u003e\n\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\n\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e!\u0026#34;\u003c/span\u003e\n\u003cspan\u003econtents\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003elen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;name\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;!\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eEmpty strings, which may be present in \u003ccode\u003e\u003cspan\u003eTemplate.strings\u003c/span\u003e\u003c/code\u003e, are not included\nin the output of the \u003ccode\u003e\u003cspan\u003e__iter__()\u003c/span\u003e\u003c/code\u003e method:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efirst\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Eat\u0026#34;\u003c/span\u003e\n\u003cspan\u003esecond\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;Red Leicester\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{first}{second}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003econtents\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003elen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Eat\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;first\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Red Leicester\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003econtents\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;second\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003e# However, the strings attribute contains empty strings:\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplate processing code can choose to work with any combination of\n\u003ccode\u003e\u003cspan\u003estrings\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003evalues\u003c/span\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cspan\u003e__iter__()\u003c/span\u003e\u003c/code\u003e based on\nrequirements and convenience.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"processing-template-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#processing-template-strings\" role=\"doc-backlink\"\u003eProcessing Template Strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eDevelopers can write arbitrary code to process template strings. For example,\nthe following function renders static parts of the template in lowercase and\ninterpolations in uppercase:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\n\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elower_upper\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Render static parts lowercased and interpolations uppercased.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003elist\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[]\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n            \u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eupper\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n        \u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n            \u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elower\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejoin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003elower_upper\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;HELLO \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;hello WORLD\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThere is no requirement that template strings are processed in any particular\nway. Code that processes templates has no obligation to return a string.\nTemplate strings are a flexible, general-purpose feature.\u003c/p\u003e\n\u003cp\u003eSee the \u003ca href=\"#common-patterns-seen-in-processing-templates\"\u003eCommon Patterns Seen in Processing Templates\u003c/a\u003e section for more\ninformation on how to process template strings. See the \u003ca href=\"#examples\"\u003eExamples\u003c/a\u003e section\nfor detailed working examples.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"template-string-concatenation\"\u003e\n\u003ch3\u003e\u003ca href=\"#template-string-concatenation\" role=\"doc-backlink\"\u003eTemplate String Concatenation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTemplate strings support explicit concatenation using \u003ccode\u003e\u003cspan\u003e+\u003c/span\u003e\u003c/code\u003e. Concatenation is\nsupported for two \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances as well as for a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance\nand a \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eConcatenation of templates is “viral”: the concatenation of a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and\na \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e always results in a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance.\u003c/p\u003e\n\u003cp\u003ePython’s implicit concatenation syntax is also supported. The following code\nwill work as expected:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello World\u0026#34;\u003c/span\u003e\u003cspan\u003e,)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello World\u0026#34;\u003c/span\u003e\u003cspan\u003e,)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e type supports the \u003ccode\u003e\u003cspan\u003e__add__()\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003e__radd__()\u003c/span\u003e\u003c/code\u003e methods\nbetween two \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances and between a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance and a\n\u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"template-and-interpolation-equality\"\u003e\n\u003ch3\u003e\u003ca href=\"#template-and-interpolation-equality\" role=\"doc-backlink\"\u003eTemplate and Interpolation Equality\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e instances compare with object identity\n(\u003ccode\u003e\u003cspan\u003eis\u003c/span\u003e\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances are intended to be used by template processing code,\nwhich may return a string or any other type. Those types can provide their\nown equality semantics as needed.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"no-support-for-ordering\"\u003e\n\u003ch3\u003e\u003ca href=\"#no-support-for-ordering\" role=\"doc-backlink\"\u003eNo Support for Ordering\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e types do not support ordering. This is\nunlike all other string literal types in Python, which support lexicographic\nordering. Because interpolations can contain arbitrary values, there is no\nnatural ordering for them. As a result, neither the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e nor the\n\u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e type implements the standard comparison methods.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"support-for-the-debug-specifier\"\u003e\n\u003ch3\u003e\u003ca href=\"#support-for-the-debug-specifier\" role=\"doc-backlink\"\u003eSupport for the debug specifier (\u003ccode\u003e\u003cspan\u003e=\u003c/span\u003e\u003c/code\u003e)\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe debug specifier, \u003ccode\u003e\u003cspan\u003e=\u003c/span\u003e\u003c/code\u003e, is supported in template strings and behaves similarly\nto how it behaves in f-strings, though due to limitations of the implementation\nthere is a slight difference.\u003c/p\u003e\n\u003cp\u003eIn particular, \u003ccode\u003e\u003cspan\u003et\u0026#39;{value=}\u0026#39;\u003c/span\u003e\u003c/code\u003e is treated as \u003ccode\u003e\u003cspan\u003et\u0026#39;value={value!r}\u0026#39;\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello {name=}\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Hello name=\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf a separate format string is also provided, \u003ccode\u003e\u003cspan\u003et\u0026#39;{value=:fmt}\u003c/span\u003e\u003c/code\u003e is treated\ninstead as \u003ccode\u003e\u003cspan\u003et\u0026#39;value={value!s:fmt}\u0026#39;\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhitespace is preserved in the debug specifier, so \u003ccode\u003e\u003cspan\u003et\u0026#39;{value\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e}\u0026#39;\u003c/span\u003e\u003c/code\u003e is\ntreated as \u003ccode\u003e\u003cspan\u003et\u0026#39;value\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{value!r}\u0026#39;\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"raw-template-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#raw-template-strings\" role=\"doc-backlink\"\u003eRaw Template Strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRaw template strings are supported using the \u003ccode\u003e\u003cspan\u003ert\u003c/span\u003e\u003c/code\u003e (or \u003ccode\u003e\u003cspan\u003etr\u003c/span\u003e\u003c/code\u003e) prefix:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003etrade\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;shrubberies\u0026#39;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ert\u003c/span\u003e\u003cspan\u003e\u0026#39;Did you say \u0026#34;\u003c/span\u003e\u003cspan\u003e{trade}\u003c/span\u003e\u003cspan\u003e\u0026#34;?\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003er\u003c/span\u003e\u003cspan\u003e\u0026#39;Did you say \u0026#34;\u0026#39;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003er\u003c/span\u003e\u003cspan\u003e\u0026#39;\u0026#34;?\\n\u0026#39;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn this example, the \u003ccode\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003c/code\u003e is treated as two separate characters\n(a backslash followed by ‘n’) rather than a newline character. This is\nconsistent with Python’s raw string behavior.\u003c/p\u003e\n\u003cp\u003eAs with regular template strings, interpolations in raw template strings are\nprocessed normally, allowing for the combination of raw string behavior and\ndynamic content.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"interpolation-expression-evaluation\"\u003e\n\u003ch3\u003e\u003ca href=\"#interpolation-expression-evaluation\" role=\"doc-backlink\"\u003eInterpolation Expression Evaluation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eExpression evaluation for interpolations is the same as in \u003ca href=\"https://peps.python.org/pep-0498/#expression-evaluation\" title=\"PEP 498 – Literal String Interpolation § Expression evaluation\"\u003ePEP 498\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe expressions that are extracted from the string are evaluated in the context\nwhere the template string appeared. This means the expression has full access to its\nlexical scope, including local and global variables. Any valid Python expression\ncan be used, including function and method calls.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eTemplate strings are evaluated eagerly from left to right, just like f-strings. This means that\ninterpolations are evaluated immediately when the template string is processed, not deferred\nor wrapped in lambdas.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"exceptions\"\u003e\n\u003ch3\u003e\u003ca href=\"#exceptions\" role=\"doc-backlink\"\u003eExceptions\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eExceptions raised in t-string literals are the same as those raised in f-string\nliterals.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"no-template-str-implementation\"\u003e\n\u003ch3\u003e\u003ca href=\"#no-template-str-implementation\" role=\"doc-backlink\"\u003eNo \u003ccode\u003e\u003cspan\u003eTemplate.__str__()\u003c/span\u003e\u003c/code\u003e Implementation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e type does not provide a specialized \u003ccode\u003e\u003cspan\u003e__str__()\u003c/span\u003e\u003c/code\u003e implementation.\u003c/p\u003e\n\u003cp\u003eThis is because \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances are intended to be used by template processing\ncode, which may return a string or any other type. There is no canonical way to\nconvert a Template to a string.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e types both provide useful \u003ccode\u003e\u003cspan\u003e__repr__()\u003c/span\u003e\u003c/code\u003e\nimplementations.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"the-string-templatelib-module\"\u003e\n\u003ch3\u003e\u003ca href=\"#the-string-templatelib-module\" role=\"doc-backlink\"\u003eThe \u003ccode\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003c/code\u003e Module\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"https://docs.python.org/3/library/string.html#module-string\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003estring\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e module will be converted into a package, with a new\n\u003ccode\u003e\u003cspan\u003etemplatelib\u003c/span\u003e\u003c/code\u003e submodule containing the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\ntypes. Following the implementation of this PEP, this new module may be used\nfor related functions, such as \u003ccode\u003e\u003cspan\u003econvert()\u003c/span\u003e\u003c/code\u003e, or potential future template\nprocessing code, such as shell script helpers.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\u003csection id=\"examples\"\u003e\n\u003ch2\u003e\u003ca href=\"#examples\" role=\"doc-backlink\"\u003eExamples\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAll examples in this section of the PEP have fully tested reference implementations\navailable in the public \u003ca href=\"https://github.com/davepeck/pep750-examples\"\u003epep750-examples\u003c/a\u003e\ngit repository.\u003c/p\u003e\n\u003csection id=\"example-implementing-f-strings-with-t-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#example-implementing-f-strings-with-t-strings\" role=\"doc-backlink\"\u003eExample: Implementing f-strings with t-strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIt is easy to “implement” f-strings using t-strings. That is, we can\nwrite a function \u003ccode\u003e\u003cspan\u003ef(template:\u003c/span\u003e \u003cspan\u003eTemplate)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e that processes a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e\nin much the same way as an f-string literal, returning the same result:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003etemplated\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name!r}\u003c/span\u003e\u003cspan\u003e, value: \u003c/span\u003e\u003cspan\u003e{value:.2f}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eformatted\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e!r}\u003c/span\u003e\u003cspan\u003e, value: \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e.2f\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplated\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003eformatted\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003ef()\u003c/span\u003e\u003c/code\u003e function supports both conversion specifiers like \u003ccode\u003e\u003cspan\u003e!r\u003c/span\u003e\u003c/code\u003e and format\nspecifiers like \u003ccode\u003e\u003cspan\u003e:.2f\u003c/span\u003e\u003c/code\u003e. The full code is fairly simple:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\n\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econvert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLiteral\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;s\u0026#34;\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;a\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eascii\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003eelif\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003erepr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003eelif\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;s\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\n\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003eparts\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[]\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ematch\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n            \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n                \u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003es\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003ecase\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eformat_spec\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n                \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003econvert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003econversion\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eformat_spec\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejoin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eparts\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003c/section\u003e\n\u003csection id=\"example-structured-logging\"\u003e\n\u003ch3\u003e\u003ca href=\"#example-structured-logging\" role=\"doc-backlink\"\u003eExample: Structured Logging\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eStructured logging allows developers to log data in machine-readable\nformats like JSON. With t-strings, developers can easily log structured data\nalongside human-readable messages using just a single log statement.\u003c/p\u003e\n\u003cp\u003eWe present two different approaches to implementing structured logging with\ntemplate strings.\u003c/p\u003e\n\u003csection id=\"approach-1-custom-log-messages\"\u003e\n\u003ch4\u003e\u003ca href=\"#approach-1-custom-log-messages\" role=\"doc-backlink\"\u003eApproach 1: Custom Log Messages\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eThe \u003ca href=\"https://docs.python.org/3/howto/logging-cookbook.html#logging-cookbook\" title=\"(in Python v3.13)\"\u003e\u003cspan\u003ePython Logging Cookbook\u003c/span\u003e\u003c/a\u003e\nhas a short section on \u003ca href=\"https://docs.python.org/3/howto/logging-cookbook.html#implementing-structured-logging\"\u003ehow to implement structured logging\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe logging cookbook suggests creating a new “message” class, \u003ccode\u003e\u003cspan\u003eStructuredMessage\u003c/span\u003e\u003c/code\u003e,\nthat is constructed with a simple text message and a separate dictionary of values:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eStructuredMessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;user action\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;action\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;traded\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;amount\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;item\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;shrubs\u0026#34;\u003c/span\u003e\n\u003cspan\u003e})\u003c/span\u003e\n\u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e# Outputs:\u003c/span\u003e\n\u003cspan\u003e# user action \u0026gt;\u0026gt;\u0026gt; {\u0026#34;action\u0026#34;: \u0026#34;traded\u0026#34;, \u0026#34;amount\u0026#34;: 42, \u0026#34;item\u0026#34;: \u0026#34;shrubs\u0026#34;}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003eStructuredMessage.__str__()\u003c/span\u003e\u003c/code\u003e method formats both the human-readable\nmessage \u003cem\u003eand\u003c/em\u003e the values, combining them into a final string. (See the\n\u003ca href=\"https://docs.python.org/3/howto/logging-cookbook.html#implementing-structured-logging\"\u003elogging cookbook\u003c/a\u003e\nfor its full example.)\u003c/p\u003e\n\u003cp\u003eWe can implement an improved version of \u003ccode\u003e\u003cspan\u003eStructuredMessage\u003c/span\u003e\u003c/code\u003e using template strings:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\n\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\n\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003etyping\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eMapping\u003c/span\u003e\n\n\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eTemplateMessage\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__init__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\n\n    \u003cspan\u003e@property\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e# Use the f() function from the previous example\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n    \u003cspan\u003e@property\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eMapping\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\n            \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__str__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u0026gt;\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edumps\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eTemplateMessage\u003c/span\u003e  \u003cspan\u003e# optional, to improve readability\u003c/span\u003e\n\u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;traded\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;shrubs\u0026#34;\u003c/span\u003e\n\u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;User \u003c/span\u003e\u003cspan\u003e{action}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{amount:.2f}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{item}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\n\u003cspan\u003e# Outputs:\u003c/span\u003e\n\u003cspan\u003e# User traded: 42.00 shrubs \u0026gt;\u0026gt;\u0026gt; {\u0026#34;action\u0026#34;: \u0026#34;traded\u0026#34;, \u0026#34;amount\u0026#34;: 42, \u0026#34;item\u0026#34;: \u0026#34;shrubs\u0026#34;}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplate strings give us a more elegant way to define the custom message\nclass. With template strings it is no longer necessary for developers to make\nsure that their format string and values dictionary are kept in sync; a single\ntemplate string literal is all that is needed. The \u003ccode\u003e\u003cspan\u003eTemplateMessage\u003c/span\u003e\u003c/code\u003e\nimplementation can automatically extract structured keys and values from\nthe \u003ccode\u003e\u003cspan\u003eInterpolation.expression\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation.value\u003c/span\u003e\u003c/code\u003e attributes,\nrespectively.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"approach-2-custom-formatters\"\u003e\n\u003ch4\u003e\u003ca href=\"#approach-2-custom-formatters\" role=\"doc-backlink\"\u003eApproach 2: Custom Formatters\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eCustom messages are a reasonable approach to structured logging but can be a\nlittle awkward. To use them, developers must wrap every log message they write\nin a custom class. This can be easy to forget.\u003c/p\u003e\n\u003cp\u003eAn alternative approach is to define custom \u003ccode\u003e\u003cspan\u003elogging.Formatter\u003c/span\u003e\u003c/code\u003e classes. This\napproach is more flexible and allows for more control over the final output. In\nparticular, it’s possible to take a single template string and output it in\nmultiple formats (human-readable and JSON) to separate log streams.\u003c/p\u003e\n\u003cp\u003eWe define two simple formatters, a \u003ccode\u003e\u003cspan\u003eMessageFormatter\u003c/span\u003e\u003c/code\u003e for human-readable output\nand a \u003ccode\u003e\u003cspan\u003eValuesFormatter\u003c/span\u003e\u003c/code\u003e for JSON output:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\n\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eFormatter\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eLogRecord\u003c/span\u003e\n\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\n\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003etyping\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eMapping\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eMessageFormatter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eFormatter\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e# Use the f() function from the previous example\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLogRecord\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003emsg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n            \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\n\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eValuesFormatter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eFormatter\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eMapping\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e]:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\n            \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eLogRecord\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003emsg\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\n        \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eisinstance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n            \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erecord\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edumps\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emsg\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe can then use these formatters when configuring our logger:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003elogging\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esys\u003c/span\u003e\n\n\u003cspan\u003elogger\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetLogger\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__name__\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003emessage_handler\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eStreamHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esys\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estdout\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003emessage_handler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetFormatter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMessageFormatter\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emessage_handler\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003evalues_handler\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003elogging\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eStreamHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esys\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estderr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003evalues_handler\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esetFormatter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eValuesFormatter\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n\u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddHandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalues_handler\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003eaction\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;traded\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;shrubs\u0026#34;\u003c/span\u003e\n\u003cspan\u003elogger\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfo\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;User \u003c/span\u003e\u003cspan\u003e{action}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{amount:.2f}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{item}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003e# Outputs to sys.stdout:\u003c/span\u003e\n\u003cspan\u003e# User traded: 42.00 shrubs\u003c/span\u003e\n\n\u003cspan\u003e# At the same time, outputs to sys.stderr:\u003c/span\u003e\n\u003cspan\u003e# {\u0026#34;action\u0026#34;: \u0026#34;traded\u0026#34;, \u0026#34;amount\u0026#34;: 42, \u0026#34;item\u0026#34;: \u0026#34;shrubs\u0026#34;}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis approach has a couple advantages over the custom message approach to structured\nlogging:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDevelopers can log a t-string directly without wrapping it in a custom class.\u003c/li\u003e\n\u003cli\u003eHuman-readable and structured output can be sent to separate log streams. This\nis useful for log aggregation systems that process structured data independently\nfrom human-readable data.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/section\u003e\n\u003c/section\u003e\n\u003csection id=\"example-html-templating\"\u003e\n\u003ch3\u003e\u003ca href=\"#example-html-templating\" role=\"doc-backlink\"\u003eExample: HTML Templating\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThis PEP contains several short HTML templating examples. It turns out that the\n“hypothetical” \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function mentioned in the  \u003ca href=\"#motivation\"\u003eMotivation\u003c/a\u003e section\n(and a few other places in this PEP) exists and is available in the\n\u003ca href=\"https://github.com/davepeck/pep750-examples/\"\u003epep750-examples repository\u003c/a\u003e.\nIf you’re thinking about parsing a complex grammar with template strings, we\nhope you’ll find it useful.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\u003csection id=\"backwards-compatibility\"\u003e\n\u003ch2\u003e\u003ca href=\"#backwards-compatibility\" role=\"doc-backlink\"\u003eBackwards Compatibility\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLike f-strings, use of template strings will be a syntactic backwards incompatibility\nwith previous versions.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"security-implications\"\u003e\n\u003ch2\u003e\u003ca href=\"#security-implications\" role=\"doc-backlink\"\u003eSecurity Implications\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe security implications of working with template strings, with respect to\ninterpolations, are as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eScope lookup is the same as f-strings (lexical scope). This model has been\nshown to work well in practice.\u003c/li\u003e\n\u003cli\u003eCode that processes \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances can ensure that any interpolations\nare processed in a safe fashion, including respecting the context in which\nthey appear.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003csection id=\"how-to-teach-this\"\u003e\n\u003ch2\u003e\u003ca href=\"#how-to-teach-this\" role=\"doc-backlink\"\u003eHow To Teach This\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTemplate strings have several audiences:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDevelopers using template strings and processing functions\u003c/li\u003e\n\u003cli\u003eAuthors of template processing code\u003c/li\u003e\n\u003cli\u003eFramework authors who build interesting machinery with template strings\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe hope that teaching developers will be straightforward. At a glance,\ntemplate strings look just like f-strings. Their syntax is familiar and the\nscoping rules remain the same.\u003c/p\u003e\n\u003cp\u003eThe first thing developers must learn is that template string literals don’t\nevaluate to strings; instead, they evaluate to a new type, \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e. This\nis a simple type intended to be used by template processing code. It’s not until\ndevelopers call a processing function that they get the result they want:\ntypically, a string, although processing code can of course return any arbitrary\ntype.\u003c/p\u003e\n\u003cp\u003eDevelopers will also want to understand how template strings relate to other\nstring formatting methods like f-strings and \u003ca href=\"https://docs.python.org/3/library/stdtypes.html#str.format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003estr.format()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e. They will need\nto decide when to use each method. If a simple string is all that is needed, and\nthere are no security implications, f-strings are likely the best choice. For\nmost cases where a format string is used, it can be replaced with a function\nwrapping the creation of a template string. In cases where the format string is\nobtained from user input, the filesystem, or databases, it is possible to write\ncode to convert it into a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance if desired.\u003c/p\u003e\n\u003cp\u003eBecause developers will learn that t-strings are nearly always used in tandem\nwith processing functions, they don’t necessarily need to understand the details\nof the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e type. As with descriptors and decorators, we expect many more\ndevelopers will use t-strings than write t-string processing functions.\u003c/p\u003e\n\u003cp\u003eOver time, a small number of more advanced developers \u003cem\u003ewill\u003c/em\u003e wish to author their\nown template processing code. Writing processing code often requires thinking\nin terms of formal grammars. Developers will need to learn how to work with the\n\u003ccode\u003e\u003cspan\u003estrings\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003einterpolation\u003c/span\u003e\u003c/code\u003e attributes of a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance and how\nto process interpolations in a context-sensitive fashion. More sophisticated\ngrammars will likely require parsing to intermediate representations like an\nabstract syntax tree (AST). Great template processing code will handle format\nspecifiers and conversions when appropriate. Writing production-grade template\nprocessing code – for instance, to support HTML templates – can be a large\nundertaking.\u003c/p\u003e\n\u003cp\u003eWe expect that template strings will provide framework authors with a powerful\nnew tool in their toolbox. While the functionality of template strings overlaps\nwith existing tools like template engines, t-strings move that logic into\nthe language itself. Bringing the full power and generality of Python to bear on\nstring processing tasks opens new possibilities for framework authors.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"why-another-templating-approach\"\u003e\n\u003ch2\u003e\u003ca href=\"#why-another-templating-approach\" role=\"doc-backlink\"\u003eWhy another templating approach?\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe world of Python already has mature templating languages with wide adoption,\nsuch as Jinja. Why build support for creating new templating systems?\u003c/p\u003e\n\u003cp\u003eProjects such as Jinja are still needed in cases where the template is less part\nof the software by the developers, and more part of customization by designers\nor even content created by users, for example in a CMS.\u003c/p\u003e\n\u003cp\u003eThe trends in frontend development have treated templating as part of the\nsoftware and written by developers. They want modern language features and a\ngood tooling experience. PEP 750 envisions DSLs where the non-static parts are\nPython: same scope rules, typing, expression syntax, and the like.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"common-patterns-seen-in-processing-templates\"\u003e\n\u003ch2\u003e\u003ca href=\"#common-patterns-seen-in-processing-templates\" role=\"doc-backlink\"\u003eCommon Patterns Seen in Processing Templates\u003c/a\u003e\u003c/h2\u003e\n\u003csection id=\"structural-pattern-matching\"\u003e\n\u003ch3\u003e\u003ca href=\"#structural-pattern-matching\" role=\"doc-backlink\"\u003eStructural Pattern Matching\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIterating over the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e with structural pattern matching is the expected\nbest practice for many template function implementations:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\n\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eprocess\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ematch\u003c/span\u003e \u003cspan\u003eitem\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n            \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n                \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e# handle each string part\u003c/span\u003e\n            \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003einterpolation\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n                \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e# handle each interpolation\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eProcessing code may also commonly sub-match on attributes of the \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e type:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ematch\u003c/span\u003e \u003cspan\u003earg\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e()):\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e# handle interpolations with integer values\u003c/span\u003e\n    \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003es\u003c/span\u003e\u003cspan\u003e):\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e \u003cspan\u003e# handle interpolations with string values\u003c/span\u003e\n    \u003cspan\u003e# etc.\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"memoizing\"\u003e\n\u003ch3\u003e\u003ca href=\"#memoizing\" role=\"doc-backlink\"\u003eMemoizing\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTemplate functions can efficiently process both static and dynamic parts of templates.\nThe structure of \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e objects allows for effective memoization:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e  \u003cspan\u003e# Static string parts\u003c/span\u003e\n\u003cspan\u003evalues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e  \u003cspan\u003e# Dynamic interpolated values\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis separation enables caching of processed static parts while dynamic parts\ncan be inserted as needed. Authors of template processing code can use the static\n\u003ccode\u003e\u003cspan\u003estrings\u003c/span\u003e\u003c/code\u003e as cache keys, leading to significant performance improvements when\nsimilar templates are used repeatedly.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"parsing-to-intermediate-representations\"\u003e\n\u003ch3\u003e\u003ca href=\"#parsing-to-intermediate-representations\" role=\"doc-backlink\"\u003eParsing to Intermediate Representations\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCode that processes templates can parse the template string into intermediate\nrepresentations, like an AST. We expect that many template processing libraries\nwill use this approach.\u003c/p\u003e\n\u003cp\u003eFor instance, rather than returning a \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e, our theoretical \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function\n(see the \u003ca href=\"#motivation\"\u003eMotivation\u003c/a\u003e section) could return an HTML \u003ccode\u003e\u003cspan\u003eElement\u003c/span\u003e\u003c/code\u003e defined in the\nsame package:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e@dataclass\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efrozen\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eTrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eElement\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003etag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\n    \u003cspan\u003eattributes\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eMapping\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003echildren\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSequence\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eElement\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e__str__\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003e...\u003c/span\u003e\n\n\n\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eElement\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eCalling \u003ccode\u003e\u003cspan\u003estr(element)\u003c/span\u003e\u003c/code\u003e would then render the HTML but, in the meantime, the\n\u003ccode\u003e\u003cspan\u003eElement\u003c/span\u003e\u003c/code\u003e could be manipulated in a variety of ways.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"context-sensitive-processing-of-interpolations\"\u003e\n\u003ch3\u003e\u003ca href=\"#context-sensitive-processing-of-interpolations\" role=\"doc-backlink\"\u003eContext-sensitive Processing of Interpolations\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eContinuing with our hypothetical \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function, it could be made\ncontext-sensitive. Interpolations could be processed differently depending\non where they appear in the template.\u003c/p\u003e\n\u003cp\u003eFor example, our \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function could support multiple kinds of\ninterpolations:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eattributes\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e\u0026#34;id\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;main\u0026#34;\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003eattribute_value\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;shrubbery\u0026#34;\u003c/span\u003e\n\u003cspan\u003econtent\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026lt;div \u003c/span\u003e\u003cspan\u003e{attributes}\u003c/span\u003e\u003cspan\u003e data-value=\u003c/span\u003e\u003cspan\u003e{attribute_value}\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e{content}\u003c/span\u003e\u003cspan\u003e\u0026lt;/div\u0026gt;\u0026#34;\u003c/span\u003e\n\u003cspan\u003eelement\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eelement\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;\u0026lt;div id=\u0026#34;main\u0026#34; data-value=\u0026#34;shrubbery\u0026#34;\u0026gt;hello\u0026lt;/div\u0026gt;\u0026#39;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBecause the \u003ccode\u003e\u003cspan\u003e{attributes}\u003c/span\u003e\u003c/code\u003e interpolation occurs in the context of an HTML tag,\nand because there is no corresponding attribute name, it is treated as a dictionary\nof attributes. The \u003ccode\u003e\u003cspan\u003e{attribute_value}\u003c/span\u003e\u003c/code\u003e interpolation is treated as a simple\nstring value and is quoted before inclusion in the final string. The\n\u003ccode\u003e\u003cspan\u003e{content}\u003c/span\u003e\u003c/code\u003e interpolation is treated as potentially unsafe content and is\nescaped before inclusion in the final string.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"nested-template-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#nested-template-strings\" role=\"doc-backlink\"\u003eNested Template Strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eGoing a step further with our \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function, we could support nested\ntemplate strings. This would allow for more complex HTML structures to be\nbuilt up from simpler templates:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003econtent\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026lt;p\u0026gt;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026lt;/p\u0026gt;\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026lt;div\u0026gt;\u003c/span\u003e\u003cspan\u003e{content}\u003c/span\u003e\u003cspan\u003e\u0026lt;/div\u0026gt;\u0026#34;\u003c/span\u003e\n\u003cspan\u003eelement\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ehtml\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eelement\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#39;\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;Hello World\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBecause the \u003ccode\u003e\u003cspan\u003e{content}\u003c/span\u003e\u003c/code\u003e interpolation is an \u003ccode\u003e\u003cspan\u003eElement\u003c/span\u003e\u003c/code\u003e instance, it does\nnot need to be escaped before inclusion in the final string.\u003c/p\u003e\n\u003cp\u003eOne could imagine a nice simplification: if the \u003ccode\u003e\u003cspan\u003ehtml()\u003c/span\u003e\u003c/code\u003e function is passed\na \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance, it could automatically convert it to an \u003ccode\u003e\u003cspan\u003eElement\u003c/span\u003e\u003c/code\u003e\nby recursively calling itself on the nested template.\u003c/p\u003e\n\u003cp\u003eWe expect that nesting and composition of templates will be a common pattern\nin template processing code and, where appropriate, used in preference to\nsimple string concatenation.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"approaches-to-lazy-evaluation\"\u003e\n\u003ch3\u003e\u003ca href=\"#approaches-to-lazy-evaluation\" role=\"doc-backlink\"\u003eApproaches to Lazy Evaluation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLike f-strings, interpolations in t-string literals are eagerly evaluated. However,\nthere are cases where lazy evaluation may be desirable.\u003c/p\u003e\n\u003cp\u003eIf a single interpolation is expensive to evaluate, it can be explicitly wrapped\nin a \u003ccode\u003e\u003cspan\u003elambda\u003c/span\u003e\u003c/code\u003e in the template string literal:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello {(lambda: name)}\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ecallable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis assumes, of course, that template processing code anticipates and handles\ncallable interpolation values. (One could imagine also supporting iterators,\nawaitables, etc.) This is not a requirement of the PEP, but it is a common\npattern in template processing code.\u003c/p\u003e\n\u003cp\u003eIn general, we hope that the community will develop best practices for lazy\nevaluation of interpolations in template strings and that, when it makes sense,\ncommon libraries will provide support for callable or awaitable values in\ntheir template processing code.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"approaches-to-asynchronous-evaluation\"\u003e\n\u003ch3\u003e\u003ca href=\"#approaches-to-asynchronous-evaluation\" role=\"doc-backlink\"\u003eApproaches to Asynchronous Evaluation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eClosely related to lazy evaluation is asynchronous evaluation.\u003c/p\u003e\n\u003cp\u003eAs with f-strings, the \u003ccode\u003e\u003cspan\u003eawait\u003c/span\u003e\u003c/code\u003e keyword is allowed in interpolations:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eexample\u003c/span\u003e\u003cspan\u003e():\u003c/span\u003e\n    \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eget_name\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003easyncio\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esleep\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;Sleepy\u0026#34;\u003c/span\u003e\n\n    \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello {await get_name()}\u0026#34;\u003c/span\u003e\n    \u003cspan\u003e# Use the f() function from the f-string example, above\u003c/span\u003e\n    \u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Hello Sleepy\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eMore sophisticated template processing code can take advantage of this to\nperform asynchronous operations in interpolations. For example, a “smart”\nprocessing function could anticipate that an interpolation is an awaitable\nand await it before processing the template string:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eexample\u003c/span\u003e\u003cspan\u003e():\u003c/span\u003e\n    \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eget_name\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003easyncio\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esleep\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;Sleepy\u0026#34;\u003c/span\u003e\n\n    \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{get_name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003easync_f\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;Hello Sleepy\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis assumes that the template processing code in \u003ccode\u003e\u003cspan\u003easync_f()\u003c/span\u003e\u003c/code\u003e is asynchronous\nand is able to \u003ccode\u003e\u003cspan\u003eawait\u003c/span\u003e\u003c/code\u003e an interpolation’s value.\u003c/p\u003e\n\n\u003c/section\u003e\n\u003csection id=\"approaches-to-template-reuse\"\u003e\n\u003ch3\u003e\u003ca href=\"#approaches-to-template-reuse\" role=\"doc-backlink\"\u003eApproaches to Template Reuse\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIf developers wish to reuse template strings multiple times with different\nvalues, they can write a function to return a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ereusable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003equestion\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e{question}\u003c/span\u003e\u003cspan\u003e?\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereusable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;friend\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;how are you\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ereusable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;King Arthur\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;what is your quest\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is, of course, no different from how f-strings can be reused.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"relation-to-format-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#relation-to-format-strings\" role=\"doc-backlink\"\u003eRelation to Format Strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe venerable \u003ca href=\"https://docs.python.org/3/library/stdtypes.html#str.format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003estr.format()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e method accepts format strings that can later\nbe used to format values:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ealas_fmt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;We\u0026#39;re all out of \u003c/span\u003e\u003cspan\u003e{cheese}\u003c/span\u003e\u003cspan\u003e.\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ealas_fmt\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echeese\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;Red Leicester\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;We\u0026#39;re all out of Red Leicester.\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf one squints, one can think of format strings as a kind of function definition.\nThe \u003cem\u003ecall\u003c/em\u003e to \u003ca href=\"https://docs.python.org/3/library/stdtypes.html#str.format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003estr.format()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e can be seen as a kind of function call. The\nt-string equivalent is to simply define a standard Python function that returns\na \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emake_template\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003echeese\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;We\u0026#39;re all out of \u003c/span\u003e\u003cspan\u003e{cheese}\u003c/span\u003e\u003cspan\u003e.\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003emake_template\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echeese\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;Red Leicester\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003e# Using the f() function from the f-string example, above\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;We\u0026#39;re all out of Red Leicester.\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003e\u003cspan\u003emake_template()\u003c/span\u003e\u003c/code\u003e function itself can be thought of as analogous to the\nformat string. The call to \u003ccode\u003e\u003cspan\u003emake_template()\u003c/span\u003e\u003c/code\u003e is analogous to the call to\n\u003ca href=\"https://docs.python.org/3/library/stdtypes.html#str.format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003estr.format()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOf course, it is common to load format strings from external sources like a\nfilesystem or database. Thankfully, because \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\nare simple Python types, it is possible to write a function that takes an\nold-style format string and returns an equivalent \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efrom_format\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e\u003cspan\u003ekwargs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eTemplate\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n\u003cspan\u003e     \u003c/span\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u0026#34;Parse `fmt` and return a `Template` instance.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n     \u003cspan\u003e...\u003c/span\u003e\n\n \u003cspan\u003e# Load this from a file, database, etc.\u003c/span\u003e\n \u003cspan\u003efmt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;We\u0026#39;re all out of \u003c/span\u003e\u003cspan\u003e{cheese}\u003c/span\u003e\u003cspan\u003e.\u0026#34;\u003c/span\u003e\n \u003cspan\u003etemplate\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efrom_format\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efmt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003echeese\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#34;Red Leicester\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n \u003cspan\u003e# Using the f() function from the f-string example, above\u003c/span\u003e\n \u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003ef\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etemplate\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;We\u0026#39;re all out of Red Leicester.\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis is a powerful pattern that allows developers to use template strings in\nplaces where they might have previously used format strings. A full implementation\nof \u003ccode\u003e\u003cspan\u003efrom_format()\u003c/span\u003e\u003c/code\u003e is available in the examples repository,\nwhich supports the full grammar of format strings.\u003c/p\u003e\n\n\u003c/section\u003e\n\u003c/section\u003e\n\u003csection id=\"reference-implementation\"\u003e\n\u003ch2\u003e\u003ca href=\"#reference-implementation\" role=\"doc-backlink\"\u003eReference Implementation\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA CPython implementation of PEP 750 is \u003ca href=\"https://github.com/lysnikolaou/cpython/tree/tstrings\"\u003eavailable\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThere is also a public repository of \u003ca href=\"https://github.com/davepeck/pep750-examples\"\u003eexamples and tests\u003c/a\u003e\nbuilt around the reference implementation. If you’re interested in playing with\ntemplate strings, this repository is a great place to start.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"rejected-ideas\"\u003e\n\u003ch2\u003e\u003ca href=\"#rejected-ideas\" role=\"doc-backlink\"\u003eRejected Ideas\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis PEP has been through several significant revisions. In addition, quite a few interesting\nideas were considered both in revisions of \u003ca href=\"https://peps.python.org/pep-0501/\" title=\"PEP 501 – General purpose template literal strings\"\u003ePEP 501\u003c/a\u003e and in the \u003ca href=\"https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408/196\"\u003eDiscourse discussion\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe attempt to document the most significant ideas that were considered and rejected.\u003c/p\u003e\n\u003csection id=\"arbitrary-string-literal-prefixes\"\u003e\n\u003ch3\u003e\u003ca href=\"#arbitrary-string-literal-prefixes\" role=\"doc-backlink\"\u003eArbitrary String Literal Prefixes\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eInspired by \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates\"\u003eJavaScript tagged template literals\u003c/a\u003e,\nan earlier version of this PEP allowed for arbitrary “tag” prefixes in front\nof literal strings:\u003c/p\u003e\n\n\u003cp\u003eThe prefix was a special callable called a “tag function”. Tag functions\nreceived the parts of the template string in an argument list. They could then\nprocess the string and return an arbitrary value:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emy_tag\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estr\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eAny\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis approach was rejected for several reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt was deemed too complex to build in full generality. JavaScript allows for\narbitrary expressions to precede a template string, which is a significant\nchallenge to implement in Python.\u003c/li\u003e\n\u003cli\u003eIt precluded future introduction of new string prefixes.\u003c/li\u003e\n\u003cli\u003eIt seemed to needlessly pollute the namespace.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUse of a single \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e prefix was chosen as a simpler, more Pythonic approach and\nmore in keeping with template strings’ role as a generalization of f-strings.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"delayed-evaluation-of-interpolations\"\u003e\n\u003ch3\u003e\u003ca href=\"#delayed-evaluation-of-interpolations\" role=\"doc-backlink\"\u003eDelayed Evaluation of Interpolations\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAn early version of this PEP proposed that interpolations should be lazily\nevaluated. All interpolations were “wrapped” in implicit lambdas. Instead of\nhaving an eagerly evaluated \u003ccode\u003e\u003cspan\u003evalue\u003c/span\u003e\u003c/code\u003e attribute, interpolations had a\n\u003ccode\u003e\u003cspan\u003egetvalue()\u003c/span\u003e\u003c/code\u003e method that would resolve the value of the interpolation:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eclass\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n    \u003cspan\u003e...\u003c/span\u003e\n    \u003cspan\u003e_value\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCallable\u003c/span\u003e\u003cspan\u003e[[],\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\n    \u003cspan\u003edef\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egetvalue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eobject\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e_value\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis was rejected for several reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe overwhelming majority of use cases for template strings naturally call\nfor immediate evaluation.\u003c/li\u003e\n\u003cli\u003eDelayed evaluation would be a significant departure from the behavior of\nf-strings.\u003c/li\u003e\n\u003cli\u003eImplicit lambda wrapping leads to difficulties with type hints and\nstatic analysis.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMost importantly, there are viable (if imperfect) alternatives to implicit\nlambda wrapping in many cases where lazy evaluation is desired. See the section\non \u003ca href=\"#approaches-to-lazy-evaluation\"\u003eApproaches to Lazy Evaluation\u003c/a\u003e, above, for more information.\u003c/p\u003e\n\u003cp\u003eWhile delayed evaluation was rejected for \u003cem\u003ethis\u003c/em\u003e PEP, we hope that the community\ncontinues to explore the idea.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"making-template-and-interpolation-into-protocols\"\u003e\n\u003ch3\u003e\u003ca href=\"#making-template-and-interpolation-into-protocols\" role=\"doc-backlink\"\u003eMaking \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e Into Protocols\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAn early version of this PEP proposed that the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\ntypes be runtime checkable protocols rather than classes.\u003c/p\u003e\n\u003cp\u003eIn the end, we felt that using classes was more straightforward.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"overridden-eq-and-hash-for-template-and-interpolation\"\u003e\n\u003ch3\u003e\u003ca href=\"#overridden-eq-and-hash-for-template-and-interpolation\" role=\"doc-backlink\"\u003eOverridden \u003ccode\u003e\u003cspan\u003e__eq__\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003e__hash__\u003c/span\u003e\u003c/code\u003e for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eEarlier versions of this PEP proposed that the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\ntypes should have their own implementations of \u003ccode\u003e\u003cspan\u003e__eq__\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003e__hash__\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u003cspan\u003eTemplates\u003c/span\u003e\u003c/code\u003e were considered equal if their \u003ccode\u003e\u003cspan\u003estrings\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003c/code\u003e\nwere equal; \u003ccode\u003e\u003cspan\u003eInterpolations\u003c/span\u003e\u003c/code\u003e were considered equal if their \u003ccode\u003e\u003cspan\u003evalue\u003c/span\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003cspan\u003eexpression\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e, and \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e were equal. Interpolation\nhashing was similar to tuple hashing: an \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e was hashable if and\nonly if its \u003ccode\u003e\u003cspan\u003evalue\u003c/span\u003e\u003c/code\u003e was hashable.\u003c/p\u003e\n\u003cp\u003eThis was rejected because \u003ccode\u003e\u003cspan\u003eTemplate.__hash__\u003c/span\u003e\u003c/code\u003e so defined was not useful as a\ncache key in template processing code; we were concerned that it would be\nconfusing to developers.\u003c/p\u003e\n\u003cp\u003eBy dropping these implementations of \u003ccode\u003e\u003cspan\u003e__eq__\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003e__hash__\u003c/span\u003e\u003c/code\u003e, we lose the\nability to write asserts such as:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;World\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u0026#34;\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello \u003c/span\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBecause \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instances are intended to be quickly processed by further\ncode, we felt that the utility of these asserts was limited.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"an-additional-decoded-type\"\u003e\n\u003ch3\u003e\u003ca href=\"#an-additional-decoded-type\" role=\"doc-backlink\"\u003eAn Additional \u003ccode\u003e\u003cspan\u003eDecoded\u003c/span\u003e\u003c/code\u003e Type\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAn early version of this PEP proposed an additional type, \u003ccode\u003e\u003cspan\u003eDecoded\u003c/span\u003e\u003c/code\u003e, to represent\nthe “static string” parts of a template string. This type derived from \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e and\nhad a single extra \u003ccode\u003e\u003cspan\u003eraw\u003c/span\u003e\u003c/code\u003e attribute that provided the original text of the string.\nWe rejected this in favor of the simpler approach of using plain \u003ccode\u003e\u003cspan\u003estr\u003c/span\u003e\u003c/code\u003e and\nallowing combination of \u003ccode\u003e\u003cspan\u003er\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003et\u003c/span\u003e\u003c/code\u003e prefixes.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"the-final-home-for-template-and-interpolation\"\u003e\n\u003ch3\u003e\u003ca href=\"#the-final-home-for-template-and-interpolation\" role=\"doc-backlink\"\u003eThe Final Home for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePrevious versions of this PEP proposed placing the \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e and\n\u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e types in: \u003ccode\u003e\u003cspan\u003etypes\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003ecollections\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003ecollections.abc\u003c/span\u003e\u003c/code\u003e,\nand even in a new top-level module, \u003ccode\u003e\u003cspan\u003etemplatelib\u003c/span\u003e\u003c/code\u003e. The final decision was to\nplace them in \u003ccode\u003e\u003cspan\u003estring.templatelib\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"enable-full-reconstruction-of-original-template-literal\"\u003e\n\u003ch3\u003e\u003ca href=\"#enable-full-reconstruction-of-original-template-literal\" role=\"doc-backlink\"\u003eEnable Full Reconstruction of Original Template Literal\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eEarlier versions of this PEP attempted to make it possible to fully reconstruct\nthe text of the original template string from a \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e instance. This was\nrejected as being overly complex. The mapping between template literal source\nand the underlying AST is not one-to-one and there are several limitations with\nrespect to round-tripping to the original source text.\u003c/p\u003e\n\u003cp\u003eFirst, \u003ccode\u003e\u003cspan\u003eInterpolation.format_spec\u003c/span\u003e\u003c/code\u003e defaults to \u003ccode\u003e\u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\u003c/code\u003e if not provided:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003etemplate1\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{value}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate2\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{value:}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eNext, the debug specifier, \u003ccode\u003e\u003cspan\u003e=\u003c/span\u003e\u003c/code\u003e, is treated as a special case and is processed\nbefore the AST is created. It is therefore not possible to distinguish\n\u003ccode\u003e\u003cspan\u003et\u0026#34;{value=}\u0026#34;\u003c/span\u003e\u003c/code\u003e from \u003ccode\u003e\u003cspan\u003et\u0026#34;value={value!r}\u0026#34;\u003c/span\u003e\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003etemplate1\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;{value=}\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate2\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;value=\u003c/span\u003e\u003cspan\u003e{value!r}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;value=\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estrings\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;value=\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpression\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econversion\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFinally, format specifiers in f-strings allow arbitrary nesting. In this PEP\nand in the reference implementation, the specifier is eagerly evaluated to\nset the \u003ccode\u003e\u003cspan\u003eformat_spec\u003c/span\u003e\u003c/code\u003e in the \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e, thereby losing the original\nexpressions. For example:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\n\u003cspan\u003eprecision\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\n\u003cspan\u003etemplate1\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{value:.2f}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\n\u003cspan\u003etemplate2\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003et\u003c/span\u003e\u003cspan\u003e\u0026#34;{value:.\u003c/span\u003e\u003cspan\u003e{precision}\u003c/span\u003e\u003cspan\u003ef}\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate1\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;.2f\u0026#34;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e \u003cspan\u003etemplate2\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einterpolations\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eformat_spec\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e\u0026#34;.2f\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe do not anticipate that these limitations will be a significant issue in practice.\nDevelopers who need to obtain the original template string literal can always\nuse \u003ccode\u003e\u003cspan\u003einspect.getsource()\u003c/span\u003e\u003c/code\u003e or similar tools.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"disallowing-string-concatenation\"\u003e\n\u003ch3\u003e\u003ca href=\"#disallowing-string-concatenation\" role=\"doc-backlink\"\u003eDisallowing String Concatenation\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eEarlier versions of this PEP proposed that template strings should not support\nconcatenation. This was rejected in favor of allowing concatenation.\u003c/p\u003e\n\u003cp\u003eThere are reasonable arguments in favor of rejecting one or all forms of\nconcatenation: namely, that it cuts off a class of potential bugs, particularly\nwhen one takes the view that template strings will often contain complex grammars\nfor which concatenation doesn’t always have the same meaning (or any meaning).\u003c/p\u003e\n\u003cp\u003eMoreover, the earliest versions of this PEP proposed a syntax closer to\nJavaScript’s tagged template literals, where an arbitrary callable could be used\nas a prefix to a string literal. There was no guarantee that the callable would\nreturn a type that supported concatenation.\u003c/p\u003e\n\u003cp\u003eIn the end, we decided that the surprise to developers of a new string type\n\u003cem\u003enot\u003c/em\u003e supporting concatenation was likely to be greater than the theoretical\nharm caused by supporting it. (Developers concatenate f-strings all the time,\nafter all, and while we are sure there are cases where this introduces bugs,\nit’s not clear that those bugs outweigh the benefits of supporting concatenation.)\u003c/p\u003e\n\u003cp\u003eWhile concatenation is supported, we expect that code that uses template strings\nwill more commonly build up larger templates through nesting and composition\nrather than concatenation.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"arbitrary-conversion-values\"\u003e\n\u003ch3\u003e\u003ca href=\"#arbitrary-conversion-values\" role=\"doc-backlink\"\u003eArbitrary Conversion Values\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003ePython allows only \u003ccode\u003e\u003cspan\u003er\u003c/span\u003e\u003c/code\u003e, \u003ccode\u003e\u003cspan\u003es\u003c/span\u003e\u003c/code\u003e, or \u003ccode\u003e\u003cspan\u003ea\u003c/span\u003e\u003c/code\u003e as possible conversion type values.\nTrying to assign a different value results in \u003ccode\u003e\u003cspan\u003eSyntaxError\u003c/span\u003e\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn theory, template functions could choose to handle other conversion types. But this\nPEP adheres closely to \u003ca href=\"https://peps.python.org/pep-0701/\" title=\"PEP 701 – Syntactic formalization of f-strings\"\u003ePEP 701\u003c/a\u003e. Any changes to allowed values should be in a\nseparate PEP.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"removing-conversion-from-interpolation\"\u003e\n\u003ch3\u003e\u003ca href=\"#removing-conversion-from-interpolation\" role=\"doc-backlink\"\u003eRemoving \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e From \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhile drafting this PEP, we considered removing the \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e\nattribute from \u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e and specifying that the conversion should be\nperformed eagerly, before \u003ccode\u003e\u003cspan\u003eInterpolation.value\u003c/span\u003e\u003c/code\u003e is set.\u003c/p\u003e\n\u003cp\u003eThis was done to simplify the work of writing template processing code. The\n\u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e attribute is of limited extensibility (it is typed as\n\u003ccode\u003e\u003cspan\u003eLiteral[\u0026#34;r\u0026#34;,\u003c/span\u003e \u003cspan\u003e\u0026#34;s\u0026#34;,\u003c/span\u003e \u003cspan\u003e\u0026#34;a\u0026#34;]\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e\u003c/code\u003e). It is not clear that it adds significant\nvalue or flexibility to template strings that couldn’t better be achieved with\ncustom format specifiers. Unlike with format specifiers, there is no\nequivalent to Python’s \u003ca href=\"https://docs.python.org/3/library/functions.html#format\" title=\"(in Python v3.13)\"\u003e\u003ccode\u003e\u003cspan\u003eformat()\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e built-in. (Instead, we include a\nsample implementation of \u003ccode\u003e\u003cspan\u003econvert()\u003c/span\u003e\u003c/code\u003e in the \u003ca href=\"#examples\"\u003eExamples\u003c/a\u003e section.)\u003c/p\u003e\n\u003cp\u003eUltimately we decided to keep the \u003ccode\u003e\u003cspan\u003econversion\u003c/span\u003e\u003c/code\u003e attribute in the\n\u003ccode\u003e\u003cspan\u003eInterpolation\u003c/span\u003e\u003c/code\u003e type to maintain compatibility with f-strings and to allow\nfor future extensibility.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"alternate-interpolation-symbols\"\u003e\n\u003ch3\u003e\u003ca href=\"#alternate-interpolation-symbols\" role=\"doc-backlink\"\u003eAlternate Interpolation Symbols\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn the early stages of this PEP, we considered allowing alternate symbols for\ninterpolations in template strings. For example, we considered allowing\n\u003ccode\u003e\u003cspan\u003e${name}\u003c/span\u003e\u003c/code\u003e as an alternative to \u003ccode\u003e\u003cspan\u003e{name}\u003c/span\u003e\u003c/code\u003e with the idea that it might be useful\nfor i18n or other purposes. See the\n\u003ca href=\"https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408/122\"\u003eDiscourse thread\u003c/a\u003e\nfor more information.\u003c/p\u003e\n\u003cp\u003eThis was rejected in favor of keeping t-string syntax as close to f-string syntax\nas possible.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"alternate-layouts-for-template\"\u003e\n\u003ch3\u003e\u003ca href=\"#alternate-layouts-for-template\" role=\"doc-backlink\"\u003eAlternate Layouts for \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eDuring the development of this PEP, we considered several alternate layouts for\nthe \u003ccode\u003e\u003cspan\u003eTemplate\u003c/span\u003e\u003c/code\u003e type. Many focused on a single \u003ccode\u003e\u003cspan\u003eargs\u003c/span\u003e\u003c/code\u003e tuple that contained\nboth strings and interpolations. Variants included:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u003cspan\u003eargs\u003c/span\u003e\u003c/code\u003e was a \u003ccode\u003e\u003cspan\u003etuple[str\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation,\u003c/span\u003e \u003cspan\u003e...]`\u003c/span\u003e\u003c/code\u003e with the promise that\nits first and last items were strings and that strings and interpolations\nalways alternated. This implied that \u003ccode\u003e\u003cspan\u003eargs\u003c/span\u003e\u003c/code\u003e was always non-empty and that\nempty strings would be inserted between neighboring interpolations. This was\nrejected because alternation could not be captured by the type system and was\nnot a guarantee we wished to make.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u003cspan\u003eargs\u003c/span\u003e\u003c/code\u003e remained a \u003ccode\u003e\u003cspan\u003etuple[str\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eInterpolation,\u003c/span\u003e \u003cspan\u003e...]\u003c/span\u003e\u003c/code\u003e but did not support\ninterleaving. As a result, empty strings were not added to the sequence. It\nwas no longer possible to obtain static strings with \u003ccode\u003e\u003cspan\u003eargs[::2]\u003c/span\u003e\u003c/code\u003e; instead,\ninstance checks or structural pattern matching had to be used to distinguish\nbetween strings and interpolations. This approach was rejected as offering\nless future opportunity for performance optimization.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u003cspan\u003eargs\u003c/span\u003e\u003c/code\u003e was typed as a \u003ccode\u003e\u003cspan\u003eSequence[tuple[str,\u003c/span\u003e \u003cspan\u003eInterpolation\u003c/span\u003e \u003cspan\u003e|\u003c/span\u003e \u003cspan\u003eNone]]\u003c/span\u003e\u003c/code\u003e. Each\nstatic string was paired with is neighboring interpolation. The final\nstring part had no corresponding interpolation. This was rejected as being\noverly complex.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/section\u003e\n\u003csection id=\"mechanism-to-describe-the-kind-of-template\"\u003e\n\u003ch3\u003e\u003ca href=\"#mechanism-to-describe-the-kind-of-template\" role=\"doc-backlink\"\u003eMechanism to Describe the “Kind” of Template\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIf t-strings prove popular, it may be useful to have a way to describe the\n“kind” of content found in a template string: “sql”, “html”, “css”, etc.\nThis could enable powerful new features in tools such as linters, formatters,\ntype checkers, and IDEs. (Imagine, for example, \u003ccode\u003e\u003cspan\u003eblack\u003c/span\u003e\u003c/code\u003e formatting HTML in\nt-strings, or \u003ccode\u003e\u003cspan\u003emypy\u003c/span\u003e\u003c/code\u003e checking whether a given attribute is valid for an HTML\ntag.) While exciting, this PEP does not propose any specific mechanism. It is\nour hope that, over time, the community will develop conventions for this purpose.\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"binary-template-strings\"\u003e\n\u003ch3\u003e\u003ca href=\"#binary-template-strings\" role=\"doc-backlink\"\u003eBinary Template Strings\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe combination of t-strings and bytes (\u003ccode\u003e\u003cspan\u003etb\u003c/span\u003e\u003c/code\u003e) is considered out of scope for\nthis PEP. However, unlike f-strings, there is no fundamental reason why t-strings\nand bytes cannot be combined. Support could be considered in a future PEP.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\u003csection id=\"acknowledgements\"\u003e\n\u003ch2\u003e\u003ca href=\"#acknowledgements\" role=\"doc-backlink\"\u003eAcknowledgements\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThanks to Ryan Morshead for contributions during development of the ideas leading\nto template strings. Special mention also to Dropbox’s\n\u003ca href=\"https://github.com/dropbox/pyxl\"\u003epyxl\u003c/a\u003e for tackling similar ideas years ago.\nAndrea Giammarchi provided thoughtful feedback on the early drafts of this PEP.\nFinally, thanks to Joachim Viide for his pioneering work on the \u003ca href=\"https://github.com/jviide/tagged\"\u003etagged library\u003c/a\u003e. Tagged was not just the precursor to\ntemplate strings, but the place where the whole effort started via a GitHub issue\ncomment!\u003c/p\u003e\n\u003c/section\u003e\n\u003csection id=\"copyright\"\u003e\n\u003ch2\u003e\u003ca href=\"#copyright\" role=\"doc-backlink\"\u003eCopyright\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis document is placed in the public domain or under the CC0-1.0-Universal\nlicense, whichever is more permissive.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "51 min read",
  "publishedTime": null,
  "modifiedTime": null
}
