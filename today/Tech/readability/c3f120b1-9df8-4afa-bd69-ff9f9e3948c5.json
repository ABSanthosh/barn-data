{
  "id": "c3f120b1-9df8-4afa-bd69-ff9f9e3948c5",
  "title": "Go Protobuf: The New Opaque API",
  "link": "https://go.dev/blog/protobuf-opaque",
  "description": "Comments",
  "author": "",
  "published": "Mon, 16 Dec 2024 20:18:01 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Michael Stapelberg 16 December 2024",
  "length": 16133,
  "excerpt": "We are adding a new generated code API to Go Protobuf.",
  "siteName": "",
  "favicon": "https://go.dev/images/favicon-gopher.png",
  "text": "The Go Blog [Protocol Buffers (Protobuf) is Google’s language-neutral data interchange format. See protobuf.dev.] Back in March 2020, we released the google.golang.org/protobuf module, a major overhaul of the Go Protobuf API. This package introduced first-class support for reflection, a dynamicpb implementation and the protocmp package for easier testing. That release introduced a new protobuf module with a new API. Today, we are releasing an additional API for generated code, meaning the Go code in the .pb.go files created by the protocol compiler (protoc). This blog post explains our motivation for creating a new API and shows you how to use it in your projects. To be clear: We are not removing anything. We will continue to support the existing API for generated code, just like we still support the older protobuf module (by wrapping the google.golang.org/protobuf implementation). Go is committed to backwards compatibility and this applies to Go Protobuf, too! Background: the (existing) Open Struct API We now call the existing API the Open Struct API, because generated struct types are open to direct access. In the next section, we will see how it differs from the new Opaque API. To work with protocol buffers, you first create a .proto definition file like this one: edition = \"2023\"; // successor to proto2 and proto3 package log; message LogEntry { string backend_server = 1; uint32 request_size = 2; string ip_address = 3; } Then, you run the protocol compiler (protoc) to generate code like the following (in a .pb.go file): package logpb type LogEntry struct { BackendServer *string RequestSize *uint32 IPAddress *string // …internal fields elided… } func (l *LogEntry) GetBackendServer() string { … } func (l *LogEntry) GetRequestSize() uint32 { … } func (l *LogEntry) GetIPAddress() string { … } Now you can import the generated logpb package from your Go code and call functions like proto.Marshal to encode logpb.LogEntry messages into protobuf wire format. You can find more details in the Generated Code API documentation. (Existing) Open Struct API: Field Presence An important aspect of this generated code is how field presence (whether a field is set or not) is modeled. For instance, the above example models presence using pointers, so you could set the BackendServer field to: proto.String(\"zrh01.prod\"): the field is set and contains “zrh01.prod” proto.String(\"\"): the field is set (non-nil pointer) but contains an empty value nil pointer: the field is not set If you are used to generated code not having pointers, you are probably using .proto files that start with syntax = \"proto3\". The field presence behavior changed over the years: syntax = \"proto2\" uses explicit presence by default syntax = \"proto3\" used implicit presence by default (where cases 2 and 3 cannot be distinguished and are both represented by an empty string), but was later extended to allow opting into explicit presence with the optional keyword edition = \"2023\", the successor to both proto2 and proto3, uses explicit presence by default The new Opaque API We created the new Opaque API to uncouple the Generated Code API from the underlying in-memory representation. The (existing) Open Struct API has no such separation: it allows programs direct access to the protobuf message memory. For example, one could use the flag package to parse command-line flag values into protobuf message fields: var req logpb.LogEntry flag.StringVar(\u0026req.BackendServer, \"backend\", os.Getenv(\"HOST\"), \"…\") flag.Parse() // fills the BackendServer field from -backend flag The problem with such a tight coupling is that we can never change how we lay out protobuf messages in memory. Lifting this restriction enables many implementation improvements, which we’ll see below. What changes with the new Opaque API? Here is how the generated code from the above example would change: package logpb type LogEntry struct { xxx_hidden_BackendServer *string // no longer exported xxx_hidden_RequestSize uint32 // no longer exported xxx_hidden_IPAddress *string // no longer exported // …internal fields elided… } func (l *LogEntry) GetBackendServer() string { … } func (l *LogEntry) HasBackendServer() bool { … } func (l *LogEntry) SetBackendServer(string) { … } func (l *LogEntry) ClearBackendServer() { … } // … With the Opaque API, the struct fields are hidden and can no longer be directly accessed. Instead, the new accessor methods allow for getting, setting, or clearing a field. Opaque structs use less memory One change we made to the memory layout is to model field presence for elementary fields more efficiently: The (existing) Open Struct API uses pointers, which adds a 64-bit word to the space cost of the field. The Opaque API uses bit fields, which require one bit per field (ignoring padding overhead). Using fewer variables and pointers also lowers load on the allocator and on the garbage collector. The performance improvement depends heavily on the shapes of your protocol messages: The change only affects elementary fields like integers, bools, enums, and floats, but not strings, repeated fields, or submessages (because it is less profitable for those types). Our benchmark results show that messages with few elementary fields exhibit performance that is as good as before, whereas messages with more elementary fields are decoded with significantly fewer allocations: │ Open Struct API │ Opaque API │ │ allocs/op │ allocs/op vs base │ Prod#1 360.3k ± 0% 360.3k ± 0% +0.00% (p=0.002 n=6) Search#1 1413.7k ± 0% 762.3k ± 0% -46.08% (p=0.002 n=6) Search#2 314.8k ± 0% 132.4k ± 0% -57.95% (p=0.002 n=6) Reducing allocations also makes decoding protobuf messages more efficient: │ Open Struct API │ Opaque API │ │ user-sec/op │ user-sec/op vs base │ Prod#1 55.55m ± 6% 55.28m ± 4% ~ (p=0.180 n=6) Search#1 324.3m ± 22% 292.0m ± 6% -9.97% (p=0.015 n=6) Search#2 67.53m ± 10% 45.04m ± 8% -33.29% (p=0.002 n=6) (All measurements done on an AMD Castle Peak Zen 2. Results on ARM and Intel CPUs are similar.) Note: proto3 with implicit presence similarly does not use pointers, so you will not see a performance improvement if you are coming from proto3. If you were using implicit presence for performance reasons, forgoing the convenience of being able to distinguish empty fields from unset ones, then the Opaque API now makes it possible to use explicit presence without a performance penalty. Motivation: Lazy Decoding Lazy decoding is a performance optimization where the contents of a submessage are decoded when first accessed instead of during proto.Unmarshal. Lazy decoding can improve performance by avoiding unnecessarily decoding fields which are never accessed. Lazy decoding can’t be supported safely by the (existing) Open Struct API. While the Open Struct API provides getters, leaving the (un-decoded) struct fields exposed would be extremely error-prone. To ensure that the decoding logic runs immediately before the field is first accessed, we must make the field private and mediate all accesses to it through getter and setter functions. This approach made it possible to implement lazy decoding with the Opaque API. Of course, not every workload will benefit from this optimization, but for those that do benefit, the results can be spectacular: We have seen logs analysis pipelines that discard messages based on a top-level message condition (e.g. whether backend_server is one of the machines running a new Linux kernel version) and can skip decoding deeply nested subtrees of messages. As an example, here are the results of the micro-benchmark we included, demonstrating how lazy decoding saves over 50% of the work and over 87% of allocations! │ nolazy │ lazy │ │ sec/op │ sec/op vs base │ Unmarshal/lazy-24 6.742µ ± 0% 2.816µ ± 0% -58.23% (p=0.002 n=6) │ nolazy │ lazy │ │ B/op │ B/op vs base │ Unmarshal/lazy-24 3.666Ki ± 0% 1.814Ki ± 0% -50.51% (p=0.002 n=6) │ nolazy │ lazy │ │ allocs/op │ allocs/op vs base │ Unmarshal/lazy-24 64.000 ± 0% 8.000 ± 0% -87.50% (p=0.002 n=6) Motivation: reduce pointer comparison mistakes Modeling field presence with pointers invites pointer-related bugs. Consider an enum, declared within the LogEntry message: message LogEntry { enum DeviceType { DESKTOP = 0; MOBILE = 1; VR = 2; }; DeviceType device_type = 1; } A simple mistake is to compare the device_type enum field like so: if cv.DeviceType == logpb.LogEntry_DESKTOP.Enum() { // incorrect! Did you spot the bug? The condition compares the memory address instead of the value. Because the Enum() accessor allocates a new variable on each call, the condition can never be true. The check should have read: if cv.GetDeviceType() == logpb.LogEntry_DESKTOP { The new Opaque API prevents this mistake: Because fields are hidden, all access must go through the getter. Motivation: reduce accidental sharing mistakes Let’s consider a slightly more involved pointer-related bug. Assume you are trying to stabilize an RPC service that fails under high load. The following part of the request middleware looks correct, but still the entire service goes down whenever just one customer sends a high volume of requests: logEntry.IPAddress = req.IPAddress logEntry.BackendServer = proto.String(hostname) // The redactIP() function redacts IPAddress to 127.0.0.1, // unexpectedly not just in logEntry *but also* in req! go auditlog(redactIP(logEntry)) if quotaExceeded(req) { // BUG: All requests end up here, regardless of their source. return fmt.Errorf(\"server overloaded\") } Did you spot the bug? The first line accidentally copied the pointer (thereby sharing the pointed-to variable between the logEntry and req messages) instead of its value. It should have read: logEntry.IPAddress = proto.String(req.GetIPAddress()) The new Opaque API prevents this problem as the setter takes a value (string) instead of a pointer: logEntry.SetIPAddress(req.GetIPAddress()) Motivation: Fix Sharp Edges: reflection To write code that works not only with a specific message type (e.g. logpb.LogEntry), but with any message type, one needs some kind of reflection. The previous example used a function to redact IP addresses. To work with any type of message, it could have been defined as func redactIP(proto.Message) proto.Message { … }. Many years ago, your only option to implement a function like redactIP was to reach for Go’s reflect package, which resulted in very tight coupling: you had only the generator output and had to reverse-engineer what the input protobuf message definition might have looked like. The google.golang.org/protobuf module release (from March 2020) introduced Protobuf reflection, which should always be preferred: Go’s reflect package traverses the data structure’s representation, which should be an implementation detail. Protobuf reflection traverses the logical tree of protocol messages without regard to its representation. Unfortunately, merely providing protobuf reflection is not sufficient and still leaves some sharp edges exposed: In some cases, users might accidentally use Go reflection instead of protobuf reflection. For example, encoding a protobuf message with the encoding/json package (which uses Go reflection) was technically possible, but the result is not canonical Protobuf JSON encoding. Use the protojson package instead. The new Opaque API prevents this problem because the message struct fields are hidden: accidental usage of Go reflection will see an empty message. This is clear enough to steer developers towards protobuf reflection. Motivation: Making the ideal memory layout possible The benchmark results from the More Efficient Memory Representation section have already shown that protobuf performance heavily depends on the specific usage: How are the messages defined? Which fields are set? To keep Go Protobuf as fast as possible for everyone, we cannot implement optimizations that help only one program, but hurt the performance of other programs. The Go compiler used to be in a similar situation, up until Go 1.20 introduced Profile-Guided Optimization (PGO). By recording the production behavior (through profiling) and feeding that profile back to the compiler, we allow the compiler to make better trade-offs for a specific program or workload. We think using profiles to optimize for specific workloads is a promising approach for further Go Protobuf optimizations. The Opaque API makes those possible: Program code uses accessors and does not need to be updated when the memory representation changes, so we could, for example, move rarely set fields into an overflow struct. Migration You can migrate on your own schedule, or even not at all—the (existing) Open Struct API will not be removed. But, if you’re not on the new Opaque API, you won’t benefit from its improved performance, or future optimizations that target it. We recommend you select the Opaque API for new development. Protobuf Edition 2024 (see Protobuf Editions Overview if you are not yet familiar) will make the Opaque API the default. The Hybrid API Aside from the Open Struct API and Opaque API, there is also the Hybrid API, which keeps existing code working by keeping struct fields exported, but also enabling migration to the Opaque API by adding the new accessor methods. With the Hybrid API, the protobuf compiler will generate code on two API levels: the .pb.go is on the Hybrid API, whereas the _protoopaque.pb.go version is on the Opaque API and can be selected by building with the protoopaque build tag. Rewriting Code to the Opaque API See the migration guide for detailed instructions. The high-level steps are: Enable the Hybrid API. Update existing code using the open2opaque migration tool. Switch to the Opaque API. Advice for published generated code: Use Hybrid API Small usages of protobuf can live entirely within the same repository, but usually, .proto files are shared between different projects that are owned by different teams. An obvious example is when different companies are involved: To call Google APIs (with protobuf), use the Google Cloud Client Libraries for Go from your project. Switching the Cloud Client Libraries to the Opaque API is not an option, as that would be a breaking API change, but switching to the Hybrid API is safe. Our advice for such packages that publish generated code (.pb.go files) is to switch to the Hybrid API please! Publish both the .pb.go and the _protoopaque.pb.go files, please. The protoopaque version allows your consumers to migrate on their own schedule. Enabling Lazy Decoding Lazy decoding is available (but not enabled) once you migrate to the Opaque API! 🎉 To enable: in your .proto file, annotate your message-typed fields with the [lazy = true] annotation. To opt out of lazy decoding (despite .proto annotations), the protolazy package documentation describes the available opt-outs, which affect either an individual Unmarshal operation or the entire program. Next Steps By using the open2opaque tool in an automated fashion over the last few years, we have converted the vast majority of Google’s .proto files and Go code to the Opaque API. We continuously improved the Opaque API implementation as we moved more and more production workloads to it. Therefore, we expect you should not encounter problems when trying the Opaque API. In case you do encounter any issues after all, please let us know on the Go Protobuf issue tracker. Reference documentation for Go Protobuf can be found on protobuf.dev → Go Reference.",
  "image": "https://go.dev/doc/gopher/gopher5logo.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-slug=\"/blog/protobuf-opaque\"\u003e\n    \n    \u003ch2\u003e\u003ca href=\"https://go.dev/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h2\u003e\n    \n\n    \n      \n      \n      \n      \u003cp\u003e[\u003ca href=\"https://en.wikipedia.org/wiki/Protocol_Buffers\" rel=\"noreferrer\" target=\"_blank\"\u003eProtocol Buffers (Protobuf)\u003c/a\u003e\nis Google’s language-neutral data interchange format. See\n\u003ca href=\"https://protobuf.dev/\" rel=\"noreferrer\" target=\"_blank\"\u003eprotobuf.dev\u003c/a\u003e.]\u003c/p\u003e\n\u003cp\u003eBack in March 2020, we released the \u003ccode\u003egoogle.golang.org/protobuf\u003c/code\u003e module, \u003ca href=\"https://go.dev/blog/protobuf-apiv2\"\u003ea\nmajor overhaul of the Go Protobuf API\u003c/a\u003e. This\npackage introduced first-class \u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\" rel=\"noreferrer\" target=\"_blank\"\u003esupport for\nreflection\u003c/a\u003e,\na \u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003edynamicpb\u003c/code\u003e\u003c/a\u003e\nimplementation and the\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotocmp\u003c/code\u003e\u003c/a\u003e\npackage for easier testing.\u003c/p\u003e\n\u003cp\u003eThat release introduced a new protobuf module with a new API. Today, we are\nreleasing an additional API for generated code, meaning the Go code in the\n\u003ccode\u003e.pb.go\u003c/code\u003e files created by the protocol compiler (\u003ccode\u003eprotoc\u003c/code\u003e). This blog post\nexplains our motivation for creating a new API and shows you how to use it in\nyour projects.\u003c/p\u003e\n\u003cp\u003eTo be clear: We are not removing anything. We will continue to support the\nexisting API for generated code, just like we still support the older protobuf\nmodule (by wrapping the \u003ccode\u003egoogle.golang.org/protobuf\u003c/code\u003e implementation). Go is\n\u003ca href=\"https://go.dev/blog/compat\"\u003ecommitted to backwards compatibility\u003c/a\u003e and this\napplies to Go Protobuf, too!\u003c/p\u003e\n\u003ch2 id=\"background\"\u003eBackground: the (existing) Open Struct API\u003c/h2\u003e\n\u003cp\u003eWe now call the existing API the Open Struct API, because generated struct types\nare open to direct access. In the next section, we will see how it differs from\nthe new Opaque API.\u003c/p\u003e\n\u003cp\u003eTo work with protocol buffers, you first create a \u003ccode\u003e.proto\u003c/code\u003e definition file like\nthis one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eedition = \u0026#34;2023\u0026#34;;  // successor to proto2 and proto3\n\npackage log;\n\nmessage LogEntry {\n  string backend_server = 1;\n  uint32 request_size = 2;\n  string ip_address = 3;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, you \u003ca href=\"https://protobuf.dev/getting-started/gotutorial/\" rel=\"noreferrer\" target=\"_blank\"\u003erun the protocol compiler\n(\u003ccode\u003eprotoc\u003c/code\u003e)\u003c/a\u003e to generate code\nlike the following (in a \u003ccode\u003e.pb.go\u003c/code\u003e file):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage logpb\n\ntype LogEntry struct {\n  BackendServer *string\n  RequestSize   *uint32\n  IPAddress     *string\n  // …internal fields elided…\n}\n\nfunc (l *LogEntry) GetBackendServer() string { … }\nfunc (l *LogEntry) GetRequestSize() uint32   { … }\nfunc (l *LogEntry) GetIPAddress() string     { … }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow you can import the generated \u003ccode\u003elogpb\u003c/code\u003e package from your Go code and call\nfunctions like\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Marshal\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.Marshal\u003c/code\u003e\u003c/a\u003e\nto encode \u003ccode\u003elogpb.LogEntry\u003c/code\u003e messages into protobuf wire format.\u003c/p\u003e\n\u003cp\u003eYou can find more details in the \u003ca href=\"https://protobuf.dev/reference/go/go-generated/\" rel=\"noreferrer\" target=\"_blank\"\u003eGenerated Code API\ndocumentation\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"presence\"\u003e(Existing) Open Struct API: Field Presence\u003c/h3\u003e\n\u003cp\u003eAn important aspect of this generated code is how \u003cem\u003efield presence\u003c/em\u003e (whether a\nfield is set or not) is modeled. For instance, the above example models presence\nusing pointers, so you could set the \u003ccode\u003eBackendServer\u003c/code\u003e field to:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eproto.String(\u0026#34;zrh01.prod\u0026#34;)\u003c/code\u003e: the field is set and contains “zrh01.prod”\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eproto.String(\u0026#34;\u0026#34;)\u003c/code\u003e: the field is set (non-\u003ccode\u003enil\u003c/code\u003e pointer) but contains an\nempty value\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enil\u003c/code\u003e pointer: the field is not set\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf you are used to generated code not having pointers, you are probably using\n\u003ccode\u003e.proto\u003c/code\u003e files that start with \u003ccode\u003esyntax = \u0026#34;proto3\u0026#34;\u003c/code\u003e. The field presence behavior\nchanged over the years:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esyntax = \u0026#34;proto2\u0026#34;\u003c/code\u003e uses \u003cem\u003eexplicit presence\u003c/em\u003e by default\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esyntax = \u0026#34;proto3\u0026#34;\u003c/code\u003e used \u003cem\u003eimplicit presence\u003c/em\u003e by default (where cases 2 and 3\ncannot be distinguished and are both represented by an empty string), but was\nlater extended to allow \u003ca href=\"https://protobuf.dev/programming-guides/proto3/#field-labels\" rel=\"noreferrer\" target=\"_blank\"\u003eopting into explicit presence with the \u003ccode\u003eoptional\u003c/code\u003e\nkeyword\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eedition = \u0026#34;2023\u0026#34;\u003c/code\u003e, the \u003ca href=\"https://protobuf.dev/editions/overview/\" rel=\"noreferrer\" target=\"_blank\"\u003esuccessor to both proto2 and\nproto3\u003c/a\u003e, uses \u003ca href=\"https://protobuf.dev/programming-guides/field_presence/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eexplicit\npresence\u003c/em\u003e\u003c/a\u003e by default\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"opaqueapi\"\u003eThe new Opaque API\u003c/h2\u003e\n\u003cp\u003eWe created the new \u003cem\u003eOpaque API\u003c/em\u003e to uncouple the \u003ca href=\"https://protobuf.dev/reference/go/go-generated/\" rel=\"noreferrer\" target=\"_blank\"\u003eGenerated Code\nAPI\u003c/a\u003e from the underlying\nin-memory representation. The (existing) Open Struct API has no such separation:\nit allows programs direct access to the protobuf message memory. For example,\none could use the \u003ccode\u003eflag\u003c/code\u003e package to parse command-line flag values into protobuf\nmessage fields:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar req logpb.LogEntry\nflag.StringVar(\u0026amp;req.BackendServer, \u0026#34;backend\u0026#34;, os.Getenv(\u0026#34;HOST\u0026#34;), \u0026#34;…\u0026#34;)\nflag.Parse() // fills the BackendServer field from -backend flag\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe problem with such a tight coupling is that we can never change how we lay\nout protobuf messages in memory. Lifting this restriction enables many\nimplementation improvements, which we’ll see below.\u003c/p\u003e\n\u003cp\u003eWhat changes with the new Opaque API? Here is how the generated code from the\nabove example would change:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage logpb\n\ntype LogEntry struct {\n  xxx_hidden_BackendServer *string // no longer exported\n  xxx_hidden_RequestSize   uint32  // no longer exported\n  xxx_hidden_IPAddress     *string // no longer exported\n  // …internal fields elided…\n}\n\nfunc (l *LogEntry) GetBackendServer() string { … }\nfunc (l *LogEntry) HasBackendServer() bool   { … }\nfunc (l *LogEntry) SetBackendServer(string)  { … }\nfunc (l *LogEntry) ClearBackendServer()      { … }\n// …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the Opaque API, the struct fields are hidden and can no longer be\ndirectly accessed. Instead, the new accessor methods allow for getting, setting,\nor clearing a field.\u003c/p\u003e\n\u003ch3 id=\"lessmemory\"\u003eOpaque structs use less memory\u003c/h3\u003e\n\u003cp\u003eOne change we made to the memory layout is to model field presence for\nelementary fields more efficiently:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe (existing) Open Struct API uses pointers, which adds a 64-bit word to the\nspace cost of the field.\u003c/li\u003e\n\u003cli\u003eThe Opaque API uses \u003ca href=\"https://en.wikipedia.org/wiki/Bit_field\" rel=\"noreferrer\" target=\"_blank\"\u003ebit\nfields\u003c/a\u003e, which require one bit per\nfield (ignoring padding overhead).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing fewer variables and pointers also lowers load on the allocator and on the\ngarbage collector.\u003c/p\u003e\n\u003cp\u003eThe performance improvement depends heavily on the shapes of your protocol\nmessages: The change only affects elementary fields like integers, bools, enums,\nand floats, but not strings, repeated fields, or submessages (because it is\n\u003ca href=\"https://protobuf.dev/reference/go/opaque-faq/#memorylayout\" rel=\"noreferrer\" target=\"_blank\"\u003eless\nprofitable\u003c/a\u003e\nfor those types).\u003c/p\u003e\n\u003cp\u003eOur benchmark results show that messages with few elementary fields exhibit\nperformance that is as good as before, whereas messages with more elementary\nfields are decoded with significantly fewer allocations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e             │ Open Struct API │             Opaque API             │\n             │    allocs/op    │  allocs/op   vs base               │\nProd#1          360.3k ± 0%       360.3k ± 0%  +0.00% (p=0.002 n=6)\nSearch#1       1413.7k ± 0%       762.3k ± 0%  -46.08% (p=0.002 n=6)\nSearch#2        314.8k ± 0%       132.4k ± 0%  -57.95% (p=0.002 n=6)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReducing allocations also makes decoding protobuf messages more efficient:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e             │ Open Struct API │             Opaque API            │\n             │   user-sec/op   │ user-sec/op  vs base              │\nProd#1         55.55m ± 6%        55.28m ± 4%  ~ (p=0.180 n=6)\nSearch#1       324.3m ± 22%       292.0m ± 6%  -9.97% (p=0.015 n=6)\nSearch#2       67.53m ± 10%       45.04m ± 8%  -33.29% (p=0.002 n=6)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(All measurements done on an AMD Castle Peak Zen 2. Results on ARM and Intel\nCPUs are similar.)\u003c/p\u003e\n\u003cp\u003eNote: proto3 with implicit presence similarly does not use pointers, so you will\nnot see a performance improvement if you are coming from proto3. If you were\nusing implicit presence for performance reasons, forgoing the convenience of\nbeing able to distinguish empty fields from unset ones, then the Opaque API now\nmakes it possible to use explicit presence without a performance penalty.\u003c/p\u003e\n\u003ch3 id=\"lazydecoding\"\u003eMotivation: Lazy Decoding\u003c/h3\u003e\n\u003cp\u003eLazy decoding is a performance optimization where the contents of a submessage\nare decoded when first accessed instead of during\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Unmarshal\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.Unmarshal\u003c/code\u003e\u003c/a\u003e. Lazy\ndecoding can improve performance by avoiding unnecessarily decoding fields which\nare never accessed.\u003c/p\u003e\n\u003cp\u003eLazy decoding can’t be supported safely by the (existing) Open Struct API. While\nthe Open Struct API provides getters, leaving the (un-decoded) struct fields\nexposed would be extremely error-prone. To ensure that the decoding logic runs\nimmediately before the field is first accessed, we must make the field private\nand mediate all accesses to it through getter and setter functions.\u003c/p\u003e\n\u003cp\u003eThis approach made it possible to implement lazy decoding with the Opaque\nAPI. Of course, not every workload will benefit from this optimization, but for\nthose that do benefit, the results can be spectacular: We have seen logs\nanalysis pipelines that discard messages based on a top-level message condition\n(e.g. whether \u003ccode\u003ebackend_server\u003c/code\u003e is one of the machines running a new Linux kernel\nversion) and can skip decoding deeply nested subtrees of messages.\u003c/p\u003e\n\u003cp\u003eAs an example, here are the results of the micro-benchmark we included,\ndemonstrating how lazy decoding saves over 50% of the work and over 87% of\nallocations!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                  │   nolazy    │                lazy                │\n                  │   sec/op    │   sec/op     vs base               │\nUnmarshal/lazy-24   6.742µ ± 0%   2.816µ ± 0%  -58.23% (p=0.002 n=6)\n\n                  │    nolazy    │                lazy                 │\n                  │     B/op     │     B/op      vs base               │\nUnmarshal/lazy-24   3.666Ki ± 0%   1.814Ki ± 0%  -50.51% (p=0.002 n=6)\n\n                  │   nolazy    │               lazy                │\n                  │  allocs/op  │ allocs/op   vs base               │\nUnmarshal/lazy-24   64.000 ± 0%   8.000 ± 0%  -87.50% (p=0.002 n=6)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"pointercomparison\"\u003eMotivation: reduce pointer comparison mistakes\u003c/h3\u003e\n\u003cp\u003eModeling field presence with pointers invites pointer-related bugs.\u003c/p\u003e\n\u003cp\u003eConsider an enum, declared within the \u003ccode\u003eLogEntry\u003c/code\u003e message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emessage LogEntry {\n  enum DeviceType {\n    DESKTOP = 0;\n    MOBILE = 1;\n    VR = 2;\n  };\n  DeviceType device_type = 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA simple mistake is to compare the \u003ccode\u003edevice_type\u003c/code\u003e enum field like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif cv.DeviceType == logpb.LogEntry_DESKTOP.Enum() { // incorrect!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDid you spot the bug? The condition compares the memory address instead of the\nvalue. Because the \u003ccode\u003eEnum()\u003c/code\u003e accessor allocates a new variable on each call, the\ncondition can never be true. The check should have read:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif cv.GetDeviceType() == logpb.LogEntry_DESKTOP {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe new Opaque API prevents this mistake: Because fields are hidden, all access\nmust go through the getter.\u003c/p\u003e\n\u003ch3 id=\"accidentalsharing\"\u003eMotivation: reduce accidental sharing mistakes\u003c/h3\u003e\n\u003cp\u003eLet’s consider a slightly more involved pointer-related bug. Assume you are\ntrying to stabilize an RPC service that fails under high load. The following\npart of the request middleware looks correct, but still the entire service goes\ndown whenever just one customer sends a high volume of requests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogEntry.IPAddress = req.IPAddress\nlogEntry.BackendServer = proto.String(hostname)\n// The redactIP() function redacts IPAddress to 127.0.0.1,\n// unexpectedly not just in logEntry *but also* in req!\ngo auditlog(redactIP(logEntry))\nif quotaExceeded(req) {\n    // BUG: All requests end up here, regardless of their source.\n    return fmt.Errorf(\u0026#34;server overloaded\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDid you spot the bug? The first line accidentally copied the pointer (thereby\nsharing the pointed-to variable between the \u003ccode\u003elogEntry\u003c/code\u003e and \u003ccode\u003ereq\u003c/code\u003e messages)\ninstead of its value. It should have read:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogEntry.IPAddress = proto.String(req.GetIPAddress())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe new Opaque API prevents this problem as the setter takes a value\n(\u003ccode\u003estring\u003c/code\u003e) instead of a pointer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogEntry.SetIPAddress(req.GetIPAddress())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"reflection\"\u003eMotivation: Fix Sharp Edges: reflection\u003c/h3\u003e\n\u003cp\u003eTo write code that works not only with a specific message type\n(e.g. \u003ccode\u003elogpb.LogEntry\u003c/code\u003e), but with any message type, one needs some kind of\nreflection. The previous example used a function to redact IP addresses. To work\nwith any type of message, it could have been defined as \u003ccode\u003efunc redactIP(proto.Message) proto.Message { … }\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMany years ago, your only option to implement a function like \u003ccode\u003eredactIP\u003c/code\u003e was to\nreach for \u003ca href=\"https://go.dev/blog/laws-of-reflection\"\u003eGo’s \u003ccode\u003ereflect\u003c/code\u003e package\u003c/a\u003e,\nwhich resulted in very tight coupling: you had only the generator output and had\nto reverse-engineer what the input protobuf message definition might have looked\nlike. The \u003ca href=\"https://go.dev/blog/protobuf-apiv2\"\u003e\u003ccode\u003egoogle.golang.org/protobuf\u003c/code\u003e module\nrelease\u003c/a\u003e (from March 2020) introduced\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\" rel=\"noreferrer\" target=\"_blank\"\u003eProtobuf\nreflection\u003c/a\u003e,\nwhich should always be preferred: Go’s \u003ccode\u003ereflect\u003c/code\u003e package traverses the data\nstructure’s representation, which should be an implementation detail. Protobuf\nreflection traverses the logical tree of protocol messages without regard to its\nrepresentation.\u003c/p\u003e\n\u003cp\u003eUnfortunately, merely \u003cem\u003eproviding\u003c/em\u003e protobuf reflection is not sufficient and\nstill leaves some sharp edges exposed: In some cases, users might accidentally\nuse Go reflection instead of protobuf reflection.\u003c/p\u003e\n\u003cp\u003eFor example, encoding a protobuf message with the \u003ccode\u003eencoding/json\u003c/code\u003e package (which\nuses Go reflection) was technically possible, but the result is not \u003ca href=\"https://protobuf.dev/programming-guides/proto3/#json\" rel=\"noreferrer\" target=\"_blank\"\u003ecanonical\nProtobuf JSON\nencoding\u003c/a\u003e. Use the\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotojson\u003c/code\u003e\u003c/a\u003e\npackage instead.\u003c/p\u003e\n\u003cp\u003eThe new Opaque API prevents this problem because the message struct fields are\nhidden: accidental usage of Go reflection will see an empty message. This is\nclear enough to steer developers towards protobuf reflection.\u003c/p\u003e\n\u003ch3 id=\"idealmemory\"\u003eMotivation: Making the ideal memory layout possible\u003c/h3\u003e\n\u003cp\u003eThe benchmark results from the \u003ca href=\"#efficientmemory\"\u003eMore Efficient Memory\nRepresentation\u003c/a\u003e section have already shown that protobuf\nperformance heavily depends on the specific usage: How are the messages defined?\nWhich fields are set?\u003c/p\u003e\n\u003cp\u003eTo keep Go Protobuf as fast as possible for \u003cem\u003eeveryone\u003c/em\u003e, we cannot implement\noptimizations that help only one program, but hurt the performance of other\nprograms.\u003c/p\u003e\n\u003cp\u003eThe Go compiler used to be in a similar situation, up until \u003ca href=\"https://go.dev/blog/go1.20\"\u003eGo 1.20 introduced\nProfile-Guided Optimization (PGO)\u003c/a\u003e. By recording the\nproduction behavior (through \u003ca href=\"https://go.dev/blog/pprof\"\u003eprofiling\u003c/a\u003e) and feeding\nthat profile back to the compiler, we allow the compiler to make better\ntrade-offs \u003cem\u003efor a specific program or workload\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWe think using profiles to optimize for specific workloads is a promising\napproach for further Go Protobuf optimizations. The Opaque API makes those\npossible: Program code uses accessors and does not need to be updated when the\nmemory representation changes, so we could, for example, move rarely set fields\ninto an overflow struct.\u003c/p\u003e\n\u003ch2 id=\"migration\"\u003eMigration\u003c/h2\u003e\n\u003cp\u003eYou can migrate on your own schedule, or even not at all—the (existing) Open\nStruct API will not be removed. But, if you’re not on the new Opaque API, you\nwon’t benefit from its improved performance, or future optimizations that target\nit.\u003c/p\u003e\n\u003cp\u003eWe recommend you select the Opaque API for new development. Protobuf Edition\n2024 (see \u003ca href=\"https://protobuf.dev/editions/overview/\" rel=\"noreferrer\" target=\"_blank\"\u003eProtobuf Editions Overview\u003c/a\u003e\nif you are not yet familiar) will make the Opaque API the default.\u003c/p\u003e\n\u003ch3 id=\"hybridapi\"\u003eThe Hybrid API\u003c/h3\u003e\n\u003cp\u003eAside from the Open Struct API and Opaque API, there is also the Hybrid API,\nwhich keeps existing code working by keeping struct fields exported, but also\nenabling migration to the Opaque API by adding the new accessor methods.\u003c/p\u003e\n\u003cp\u003eWith the Hybrid API, the protobuf compiler will generate code on two API levels:\nthe \u003ccode\u003e.pb.go\u003c/code\u003e is on the Hybrid API, whereas the \u003ccode\u003e_protoopaque.pb.go\u003c/code\u003e version is\non the Opaque API and can be selected by building with the \u003ccode\u003eprotoopaque\u003c/code\u003e build\ntag.\u003c/p\u003e\n\u003ch3 id=\"rewriting\"\u003eRewriting Code to the Opaque API\u003c/h3\u003e\n\u003cp\u003eSee the \u003ca href=\"https://protobuf.dev/reference/go/opaque-migration/\" rel=\"noreferrer\" target=\"_blank\"\u003emigration\nguide\u003c/a\u003e\nfor detailed instructions. The high-level steps are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEnable the Hybrid API.\u003c/li\u003e\n\u003cli\u003eUpdate existing code using the \u003ccode\u003eopen2opaque\u003c/code\u003e migration tool.\u003c/li\u003e\n\u003cli\u003eSwitch to the Opaque API.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"publishing\"\u003eAdvice for published generated code: Use Hybrid API\u003c/h3\u003e\n\u003cp\u003eSmall usages of protobuf can live entirely within the same repository, but\nusually, \u003ccode\u003e.proto\u003c/code\u003e files are shared between different projects that are owned by\ndifferent teams. An obvious example is when different companies are involved: To\ncall Google APIs (with protobuf), use the \u003ca href=\"https://github.com/googleapis/google-cloud-go\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle Cloud Client Libraries for\nGo\u003c/a\u003e from your project. Switching\nthe Cloud Client Libraries to the Opaque API is not an option, as that would be\na breaking API change, but switching to the Hybrid API is safe.\u003c/p\u003e\n\u003cp\u003eOur advice for such packages that publish generated code (\u003ccode\u003e.pb.go\u003c/code\u003e files) is to\nswitch to the Hybrid API please! Publish both the \u003ccode\u003e.pb.go\u003c/code\u003e and the\n\u003ccode\u003e_protoopaque.pb.go\u003c/code\u003e files, please. The \u003ccode\u003eprotoopaque\u003c/code\u003e version allows your\nconsumers to migrate on their own schedule.\u003c/p\u003e\n\u003ch3 id=\"enablelazy\"\u003eEnabling Lazy Decoding\u003c/h3\u003e\n\u003cp\u003eLazy decoding is available (but not enabled) once you migrate to the Opaque API!\n🎉\u003c/p\u003e\n\u003cp\u003eTo enable: in your \u003ccode\u003e.proto\u003c/code\u003e file, annotate your message-typed fields with the\n\u003ccode\u003e[lazy = true]\u003c/code\u003e annotation.\u003c/p\u003e\n\u003cp\u003eTo opt out of lazy decoding (despite \u003ccode\u003e.proto\u003c/code\u003e annotations), the \u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/runtime/protolazy\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotolazy\u003c/code\u003e\npackage\ndocumentation\u003c/a\u003e\ndescribes the available opt-outs, which affect either an individual Unmarshal\noperation or the entire program.\u003c/p\u003e\n\u003ch2 id=\"nextsteps\"\u003eNext Steps\u003c/h2\u003e\n\u003cp\u003eBy using the open2opaque tool in an automated fashion over the last few years,\nwe have converted the vast majority of Google’s \u003ccode\u003e.proto\u003c/code\u003e files and Go code to\nthe Opaque API. We continuously improved the Opaque API implementation as we\nmoved more and more production workloads to it.\u003c/p\u003e\n\u003cp\u003eTherefore, we expect you should not encounter problems when trying the Opaque\nAPI. In case you do encounter any issues after all, please \u003ca href=\"https://github.com/golang/protobuf/issues/\" rel=\"noreferrer\" target=\"_blank\"\u003elet us know on the\nGo Protobuf issue tracker\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eReference documentation for Go Protobuf can be found on \u003ca href=\"https://protobuf.dev/reference/go/\" rel=\"noreferrer\" target=\"_blank\"\u003eprotobuf.dev → Go\nReference\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": null,
  "modifiedTime": null
}
