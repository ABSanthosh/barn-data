{
  "id": "be5b7edb-7b2b-4e9c-81d7-ab086808ab7b",
  "title": "Jepsen: Amazon RDS for PostgreSQL 17.4",
  "link": "https://jepsen.io/analyses/amazon-rds-for-postgresql-17.4",
  "description": "Comments",
  "author": "",
  "published": "Tue, 29 Apr 2025 14:30:11 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Kyle Kingsbury",
  "length": 6786,
  "excerpt": "Amazon RDS for PostgreSQL is an Amazon Web Services (AWS) service which provides managed instances of the PostgreSQL database. We show that Amazon RDS for PostgreSQL multi-AZ clusters violate Snapshot Isolation, the strongest consistency model supported across all endpoints. Healthy clusters occasionally allow Long Fork and other G-nonadjacent cycles. These phenomena occurred in every version tested, from 13.15 to 17.4. Amazon RDS for PostgreSQL may instead provide Parallel Snapshot Isolation. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the Jepsen ethics policy.",
  "siteName": "",
  "favicon": "",
  "text": "Amazon RDS for PostgreSQL is an Amazon Web Services (AWS) service which provides managed instances of the PostgreSQL database. We show that Amazon RDS for PostgreSQL multi-AZ clusters violate Snapshot Isolation, the strongest consistency model supported across all endpoints. Healthy clusters occasionally allow Long Fork and other G-nonadjacent cycles. These phenomena occurred in every version tested, from 13.15 to 17.4. Amazon RDS for PostgreSQL may instead provide Parallel Snapshot Isolation. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the Jepsen ethics policy. Background PostgreSQL is a popular open source general-purpose SQL database. It uses multiversion concurrency control (MVCC) to provide three levels of transaction isolation. PostgreSQL’s “Read Uncommitted” and “Read Committed” are both Read Committed. The “Repeatable Read” level actually provides Snapshot Isolation, not Repeatable Read. “Serializable” provides Serializability. Amazon RDS for PostgreSQL is an AWS service which provides managed PostgreSQL clusters. RDS automates provisioning, storage management, replication, backups, upgrades, and more. Multi-AZ deployments distribute database nodes across multiple availability zones, reducing the probability of correlated failure. RDS uses synchronous replication to ensure that transactions are durable both on primary and (at least one) secondary instances before acknowledging. From a user perspective, Amazon RDS for PostgreSQL provides a pair of URLs which speak the PostgreSQL wire protocol: a primary endpoint for read-write transactions, and a reader endpoint for read-only transactions. The primary endpoint supports all PostgreSQL isolation levels, while secondaries do not support Serializable. The strongest level supported across all nodes is therefore Snapshot Isolation (which PostgreSQL terms “Repeatable Read”). Test Design We adapted Jepsen’s test library for PostgreSQL for use with Amazon RDS for PostgreSQL with a small wrapper program. For each round of tests, we provisioned an RDS cluster using AWS’s CreateDBCluster API, using gp3 storage and db.m6id.large instances. We then launched a single EC2 node to run our tests, and provided it with the main and read-only endpoints of the RDS cluster. We performed no fault injection, and triggered no failovers. As in our previous work on PostgreSQL, our primary workload consisted of transactions over lists of unique integers. We stored each list in a single row, encoded as a TEXT field of comma-separated values. Transactions could either read a list by primary key, or append a unique integer to a list using CONCAT. This workload allowed our Elle checker to verify a variety of isolation levels, mainly by inferring dataflow dependencies between transactions and finding cycles in the resulting graph. Results Under healthy conditions, with moderate concurrency, Amazon RDS for PostgreSQL 17.4 exhibited G-nonadjacent cycles every few minutes. Consider this two-minute test run, which performed approximately 150 write transactions per second, along with 1600 read-only transactions per second. It contains the following cycle of four transactions: From top to bottom, call these transactions T1, T2, T3, and T4. T1 appended 9 to row 89, resulting in the list [4 9], which T2 observed. T3 appended 11 to row 90, resulting in the list [11]. That version was overwritten by T4, which appended 3 to row 90, and read the resulting list [11, 3]. While T2 observed T1’s append to row 89, it failed to observe T3’s append to row 90. Symmetrically, T4 observed T3’s append to row 90, but failed to observe T1’s append to 89. Since this cycle includes read-write dependencies which are not adjacent to each other, this cycle is G-nonadjacent, a violation of Snapshot Isolation. This behavior should not occur in standard PostgreSQL at “Repeatable Read” and we have not observed it there. To understand why this cycle is illegal, recall that in Snapshot Isolation, every transaction (apparently) operates on a snapshot of the database taken at some start timestamp s. That transaction’s effects are made visible to others at some later commit timestamp c. In order for T2 to read T1’s append, its start timestamp must have followed T1’s commit timestamp: c1 \u003c s2. Since T2 did not observe T3’s append, s2 \u003c c3. Since T4 overwrote (and observed) T3, c3 \u003c s4. But T4 did not observe T1’s append, so s4 \u003c c1. We have a contradiction! There is no way these timestamps can each precede each other. This cycle is also an example of Long Fork. The first and second transactions compose one logical fork of the state. The third and fourth comprise a second. Each fork updates a different row, but neither fork observes the other’s effects. Curiously, we did not observe Short Fork, also known as Write Skew. This suggests that Amazon RDS for PostgreSQL might provide Parallel Snapshot Isolation, a slightly weaker consistency model. We observed a variety of G-nonadjacent anomalies, including those linked only by write-read edges, as well as several with more than four transactions. They occurred in every PostgreSQL version we tested, from 13.15 (the oldest version which AWS supported) to 17.4 (the newest). Discussion From the presence of Long Fork and other G-nonadjacent cycles, we conclude that Amazon RDS for PostgreSQL multi-AZ clusters do not ensure Snapshot Isolation. Instead, they may provide Parallel Snapshot Isolation, a slightly weaker model. In this respect Amazon RDS for PostgreSQL multi-AZ clusters offer weaker safety semantics than a single-node PostgreSQL system, which, in our previous testing, appeared to provide Strong Snapshot Isolation. Users of Amazon RDS for PostgreSQL may wish to examine their transaction structures with an eye towards Long Fork, or design experiments to verify whether their intended invariants are preserved. A read transactions may disagree with other transactions as to the order in which transactions were executed. Since these anomalies appear to involve queries against read-only secondaries, it may be possible to recover Snapshot Isolation by only using the writer endpoint, or ensuring that every safety-critical transaction includes at least one write. This report is the product of a cursory exploration—we have not investigated Amazon RDS for PostgreSQL behavior in detail. As always, Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove correctness. Our thanks to Irene Kannyo for her editorial support. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the Jepsen ethics policy.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cp\u003e\u003ca href=\"https://aws.amazon.com/rds/postgresql/\"\u003eAmazon RDS for PostgreSQL\u003c/a\u003e is an Amazon Web Services (AWS) service which provides managed instances of the \u003ca href=\"https://www.postgresql.org/\"\u003ePostgreSQL\u003c/a\u003e database. We show that Amazon RDS for PostgreSQL multi-AZ clusters violate \u003ca href=\"https://jepsen.io/consistency/models/snapshot-isolation\"\u003eSnapshot Isolation\u003c/a\u003e, the strongest consistency model supported across all endpoints. Healthy clusters occasionally allow \u003ca href=\"https://jepsen.io/consistency/phenomena/long-fork\"\u003eLong Fork\u003c/a\u003e and other \u003ca href=\"https://jepsen.io/consistency/phenomena/g-nonadjacent\"\u003eG-nonadjacent\u003c/a\u003e cycles. These phenomena occurred in every version tested, from 13.15 to 17.4. Amazon RDS for PostgreSQL may instead provide \u003ca href=\"https://scispace.com/pdf/transactional-storage-for-geo-replicated-systems-2j5mhrj29h.pdf\"\u003eParallel Snapshot Isolation\u003c/a\u003e. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the \u003ca href=\"https://jepsen.io/analyses/ethics\"\u003eJepsen ethics policy\u003c/a\u003e.\u003c/p\u003e\u003carticle\u003e\n  \u003cdiv\u003e\n\u003ch2 data-number=\"1\" id=\"background\"\u003e Background\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.postgresql.org/\"\u003ePostgreSQL\u003c/a\u003e is a popular open source general-purpose SQL database. It uses multiversion concurrency control (MVCC) to provide \u003ca href=\"https://www.postgresql.org/docs/17/transaction-iso.html\"\u003ethree levels of transaction isolation\u003c/a\u003e. PostgreSQL’s “Read Uncommitted” and “Read Committed” are both \u003ca href=\"https://jepsen.io/consistency/models/read-committed\"\u003eRead Committed\u003c/a\u003e. The “Repeatable Read” level actually provides \u003ca href=\"https://jepsen.io/consistency/models/snapshot-isolation\"\u003eSnapshot Isolation\u003c/a\u003e, not \u003ca href=\"https://jepsen.io/consistency/models/repeatable-read\"\u003eRepeatable Read\u003c/a\u003e. “Serializable” provides \u003ca href=\"https://jepsen.io/consistency/models/serializable\"\u003eSerializability\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://aws.amazon.com/rds/postgresql/\"\u003eAmazon RDS for PostgreSQL\u003c/a\u003e is an AWS service which provides managed PostgreSQL clusters. RDS automates provisioning, storage management, replication, backups, upgrades, and more. \u003ca href=\"https://aws.amazon.com/rds/features/multi-az/\"\u003eMulti-AZ deployments\u003c/a\u003e distribute database nodes across multiple availability zones, reducing the probability of correlated failure. RDS uses synchronous replication to ensure that transactions are durable both on primary and (at least one) secondary instances before acknowledging.\u003c/p\u003e\n\u003cp\u003eFrom a user perspective, Amazon RDS for PostgreSQL provides a pair of URLs which speak the PostgreSQL wire protocol: a primary endpoint for read-write transactions, and a reader endpoint for read-only transactions. The primary endpoint supports all PostgreSQL isolation levels, while secondaries do not support Serializable. The strongest level supported across all nodes is therefore Snapshot Isolation (which PostgreSQL terms “Repeatable Read”).\u003c/p\u003e\n\u003ch2 data-number=\"2\" id=\"test-design\"\u003e Test Design\u003c/h2\u003e\n\u003cp\u003eWe adapted Jepsen’s \u003ca href=\"https://github.com/jepsen-io/postgres/tree/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/postgres\"\u003etest library for PostgreSQL\u003c/a\u003e for use with Amazon RDS for PostgreSQL with a \u003ca href=\"https://github.com/jepsen-io/postgres/tree/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/rds\"\u003esmall wrapper program\u003c/a\u003e. For each round of tests, we \u003ca href=\"https://github.com/jepsen-io/rds/blob/13cada8381b7cde00bca3adfb005a66613656039/src/jepsen/rds.clj#L284-L377\"\u003eprovisioned an RDS cluster\u003c/a\u003e using AWS’s \u003ca href=\"https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_CreateDBCluster.html\"\u003e\u003ccode\u003eCreateDBCluster\u003c/code\u003e\u003c/a\u003e API, using \u003ccode\u003egp3\u003c/code\u003e storage and \u003ccode\u003edb.m6id.large\u003c/code\u003e instances. We then launched a single EC2 node to run our tests, and provided it with the main and read-only endpoints of the RDS cluster. We performed no fault injection, and triggered no failovers.\u003c/p\u003e\n\u003cp\u003eAs in \u003ca href=\"https://jepsen.io/analyses/postgresql-12.3#test-design\"\u003eour previous work on PostgreSQL\u003c/a\u003e, our \u003ca href=\"https://github.com/jepsen-io/postgres/blob/225203dd64ad5e5e4fe481ccb8b180b7d0d99f9d/postgres/src/jepsen/postgres/workload/append.clj\"\u003eprimary workload\u003c/a\u003e consisted of transactions over lists of unique integers. We stored each list in a single row, encoded as a \u003ccode\u003eTEXT\u003c/code\u003e field of comma-separated values. Transactions could either read a list by primary key, or append a unique integer to a list using \u003ccode\u003eCONCAT\u003c/code\u003e. This workload allowed our \u003ca href=\"https://github.com/jepsen-io/elle\"\u003eElle checker\u003c/a\u003e to verify a variety of isolation levels, mainly by inferring dataflow dependencies between transactions and finding cycles in the resulting graph.\u003c/p\u003e\n\u003ch2 data-number=\"3\" id=\"results\"\u003e Results\u003c/h2\u003e\n\u003cp\u003eUnder healthy conditions, with moderate concurrency, Amazon RDS for PostgreSQL 17.4 exhibited \u003ca href=\"https://jepsen.io/consistency/phenomena/g-nonadjacent\"\u003eG-nonadjacent\u003c/a\u003e cycles every few minutes. Consider \u003ca href=\"https://s3.amazonaws.com/jepsen.io/analyses/amazon-rds-for-postgresql-17.4/20250406T172435-long-fork.zip\"\u003ethis two-minute test run\u003c/a\u003e, which performed approximately 150 write transactions per second, along with 1600 read-only transactions per second. It contains the following cycle of four transactions:\u003c/p\u003e\n\n\u003cp\u003eFrom top to bottom, call these transactions \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e, \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e, \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e, and \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e. \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e appended 9 to row 89, resulting in the list \u003ccode\u003e[4 9]\u003c/code\u003e, which \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e observed. \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e appended 11 to row 90, resulting in the list \u003ccode\u003e[11]\u003c/code\u003e. That version was overwritten by \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e, which appended \u003ccode\u003e3\u003c/code\u003e to row \u003ccode\u003e90\u003c/code\u003e, and read the resulting list \u003ccode\u003e[11, 3]\u003c/code\u003e. While \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e observed \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e’s append to row 89, it failed to observe \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e’s append to row 90. Symmetrically, \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e observed \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e’s append to row 90, but failed to observe \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e’s append to 89.\u003c/p\u003e\n\u003cp\u003eSince this cycle includes \u003ca href=\"https://jepsen.io/consistency/dependencies\"\u003eread-write dependencies\u003c/a\u003e which are not adjacent to each other, this cycle is G-nonadjacent, a violation of Snapshot Isolation. This behavior should not occur in standard PostgreSQL at “Repeatable Read” and we have not observed it there.\u003c/p\u003e\n\u003cp\u003eTo understand why this cycle is illegal, recall that in \u003ca href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf\"\u003eSnapshot Isolation\u003c/a\u003e, every transaction (apparently) operates on a snapshot of the database taken at some start timestamp \u003cspan\u003e\u003cem\u003es\u003c/em\u003e\u003c/span\u003e. That transaction’s effects are made visible to others at some later commit timestamp \u003cspan\u003e\u003cem\u003ec\u003c/em\u003e\u003c/span\u003e. In order for \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e to read \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e’s append, its start timestamp must have followed \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e’s commit timestamp: \u003cspan\u003e\u003cem\u003ec\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e \u0026lt; \u003cem\u003es\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e. Since \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e did not observe \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e’s append, \u003cspan\u003e\u003cem\u003es\u003c/em\u003e\u003csub\u003e2\u003c/sub\u003e\u003c/span\u003e \u0026lt; \u003cspan\u003e\u003cem\u003ec\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e. Since \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e overwrote (and observed) \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e\u003c/span\u003e, \u003cspan\u003e\u003cem\u003ec\u003c/em\u003e\u003csub\u003e3\u003c/sub\u003e \u0026lt; \u003cem\u003es\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e. But \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e did not observe \u003cspan\u003e\u003cem\u003eT\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e’s append, so \u003cspan\u003e\u003cem\u003es\u003c/em\u003e\u003csub\u003e4\u003c/sub\u003e\u003c/span\u003e \u0026lt; \u003cspan\u003e\u003cem\u003ec\u003c/em\u003e\u003csub\u003e1\u003c/sub\u003e\u003c/span\u003e. We have a contradiction! There is no way these timestamps can each precede each other.\u003c/p\u003e\n\u003cp\u003eThis cycle is also an example of \u003ca href=\"https://jepsen.io/consistency/phenomena/long-fork\"\u003eLong Fork\u003c/a\u003e. The first and second transactions compose one logical fork of the state. The third and fourth comprise a second. Each fork updates a different row, but neither fork observes the other’s effects. Curiously, we did \u003cem\u003enot\u003c/em\u003e observe \u003ca href=\"https://jepsen.io/consistency/phenomena/a5b\"\u003eShort Fork\u003c/a\u003e, also known as Write Skew. This suggests that Amazon RDS for PostgreSQL might provide \u003ca href=\"https://www.cs.princeton.edu/courses/archive/fall13/cos518/papers/walter.pdf\"\u003eParallel Snapshot Isolation\u003c/a\u003e, a slightly weaker consistency model.\u003c/p\u003e\n\u003cp\u003eWe observed a variety of G-nonadjacent anomalies, including those linked only by write-read edges, as well as several with more than four transactions. They occurred in every PostgreSQL version we tested, from 13.15 (the oldest version which AWS supported) to 17.4 (the newest).\u003c/p\u003e\n\u003ch2 data-number=\"4\" id=\"discussion\"\u003e Discussion\u003c/h2\u003e\n\u003cp\u003eFrom the presence of Long Fork and other G-nonadjacent cycles, we conclude that Amazon RDS for PostgreSQL multi-AZ clusters do not ensure Snapshot Isolation. Instead, they may provide Parallel Snapshot Isolation, a slightly weaker model. In this respect Amazon RDS for PostgreSQL multi-AZ clusters offer weaker safety semantics than a single-node PostgreSQL system, which, \u003ca href=\"https://jepsen.io/analyses/postgresql-12.3\"\u003ein our previous testing\u003c/a\u003e, appeared to provide Strong Snapshot Isolation.\u003c/p\u003e\n\u003cp\u003eUsers of Amazon RDS for PostgreSQL may wish to examine their transaction structures with an eye towards Long Fork, or design experiments to verify whether their intended invariants are preserved. A read transactions may disagree with other transactions as to the order in which transactions were executed. Since these anomalies appear to involve queries against read-only secondaries, it may be possible to recover Snapshot Isolation by only using the writer endpoint, or ensuring that every safety-critical transaction includes at least one write.\u003c/p\u003e\n\u003cp\u003eThis report is the product of a cursory exploration—we have not investigated Amazon RDS for PostgreSQL behavior in detail. As always, Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we make extensive efforts to find problems, we cannot prove correctness.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOur thanks to \u003ca href=\"https://www.irenekannyo.com/\"\u003eIrene Kannyo\u003c/a\u003e for her editorial support. This work was performed independently by Jepsen, without compensation, and conducted in accordance with the \u003ca href=\"https://jepsen.io/analyses/ethics\"\u003eJepsen ethics policy\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\n  \u003c/div\u003e\n\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
