{
  "id": "6186e753-8ca3-4613-b722-332a70045ef5",
  "title": "Show HN: A portable hash map in C",
  "link": "https://github.com/e-dant/salmagundi",
  "description": "Comments",
  "author": "",
  "published": "Sun, 08 Dec 2024 20:05:25 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "e-dant",
  "length": 412,
  "excerpt": "A small, portable, linear probing hash map. Contribute to e-dant/salmagundi development by creating an account on GitHub.",
  "siteName": "GitHub",
  "favicon": "https://github.githubassets.com/assets/apple-touch-icon-180x180-a80b8e11abe2.png",
  "text": "Salmagundi A small, portable, linear-probing hash map in C. #include \"salmagundi.h\" #include \u003cstring.h\u003e void do_stuff(void) { hm_t* map = hm_open(hm_hash_rapidhash, hm_cmp_str); char* k = \"k\"; char* v = \"v\"; hm_put(map, k, strlen(k), v, strlen(v)); hm_item_t stored = hm_get(map, k, k_sz); assert(memcmp(stored.k, k, strlen(k)) == 0); assert(memcmp(stored.v, v, strlen(v)) == 0); hm_close(map); }",
  "image": "https://opengraph.githubassets.com/579aee2843e04d8fad57be4e58c82dd02829d5400f6f19b334931c70ca0246fd/e-dant/salmagundi",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eSalmagundi\u003c/h2\u003e\u003ca id=\"user-content-salmagundi\" aria-label=\"Permalink: Salmagundi\" href=\"#salmagundi\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eA small, portable, linear-probing hash map in C.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"#include \u0026#34;salmagundi.h\u0026#34;\n#include \u0026lt;string.h\u0026gt;\nvoid do_stuff(void) {\n  hm_t* map = hm_open(hm_hash_rapidhash, hm_cmp_str);\n  char* k = \u0026#34;k\u0026#34;;\n  char* v = \u0026#34;v\u0026#34;;\n  hm_put(map, k, strlen(k), v, strlen(v));\n  hm_item_t stored = hm_get(map, k, k_sz);\n  assert(memcmp(stored.k, k, strlen(k)) == 0);\n  assert(memcmp(stored.v, v, strlen(v)) == 0);\n  hm_close(map);\n}\"\u003e\u003cpre\u003e\u003cspan\u003e#include\u003c/span\u003e \u003cspan\u003e\u0026#34;salmagundi.h\u0026#34;\u003c/span\u003e\n\u003cspan\u003e#include\u003c/span\u003e \u003cspan\u003e\u0026lt;string.h\u0026gt;\u003c/span\u003e\n\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003edo_stuff\u003c/span\u003e(\u003cspan\u003evoid\u003c/span\u003e) {\n  \u003cspan\u003ehm_t\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003emap\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ehm_open\u003c/span\u003e(\u003cspan\u003ehm_hash_rapidhash\u003c/span\u003e, \u003cspan\u003ehm_cmp_str\u003c/span\u003e);\n  \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ek\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;k\u0026#34;\u003c/span\u003e;\n  \u003cspan\u003echar\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e \u003cspan\u003ev\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;v\u0026#34;\u003c/span\u003e;\n  \u003cspan\u003ehm_put\u003c/span\u003e(\u003cspan\u003emap\u003c/span\u003e, \u003cspan\u003ek\u003c/span\u003e, \u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003ek\u003c/span\u003e), \u003cspan\u003ev\u003c/span\u003e, \u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003ev\u003c/span\u003e));\n  \u003cspan\u003ehm_item_t\u003c/span\u003e \u003cspan\u003estored\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ehm_get\u003c/span\u003e(\u003cspan\u003emap\u003c/span\u003e, \u003cspan\u003ek\u003c/span\u003e, \u003cspan\u003ek_sz\u003c/span\u003e);\n  \u003cspan\u003eassert\u003c/span\u003e(\u003cspan\u003ememcmp\u003c/span\u003e(\u003cspan\u003estored\u003c/span\u003e.\u003cspan\u003ek\u003c/span\u003e, \u003cspan\u003ek\u003c/span\u003e, \u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003ek\u003c/span\u003e)) \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e);\n  \u003cspan\u003eassert\u003c/span\u003e(\u003cspan\u003ememcmp\u003c/span\u003e(\u003cspan\u003estored\u003c/span\u003e.\u003cspan\u003ev\u003c/span\u003e, \u003cspan\u003ev\u003c/span\u003e, \u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003ev\u003c/span\u003e)) \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e);\n  \u003cspan\u003ehm_close\u003c/span\u003e(\u003cspan\u003emap\u003c/span\u003e);\n}\u003c/pre\u003e\u003c/div\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "Less than 1 min",
  "publishedTime": null,
  "modifiedTime": null
}
