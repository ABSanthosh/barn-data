{
  "id": "bc04ec36-98d3-4d21-9552-0125abeef5bd",
  "title": "Luon programming language combines concepts from Oberon and Lua",
  "link": "https://github.com/rochus-keller/Luon/blob/master/Readme.md",
  "description": "Comments",
  "author": "",
  "published": "Fri, 13 Dec 2024 23:37:45 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 13013,
  "excerpt": "A compiler and IDE for the Luon programming language - a liaison beween Lua and Oberon+ - targeting LuaJIT - rochus-keller/Luon",
  "siteName": "GitHub",
  "favicon": "https://github.githubassets.com/assets/apple-touch-icon-180x180-a80b8e11abe2.png",
  "text": "Welcome to the Luon Programming Language Luon is a high-level programming language with a syntax similar to Oberon+, Oberon-07 and Oberon-2, integrating concepts from Lua, and targeting the LuaJIT VM. Luon can be regarded as a statically typed version of Lua. The name is thus a combination of \"Lua\" and \"Oberon\". Luon procedures can be declared \"external\" and be implemented in Lua. This allows the re-use of libraries written in Lua, and also C libraries via the LuaJIT foreign function interface. The language specification can be found in the specification subdirectory. See also the code examples below. The project is the result of the author's experience with the Smalltalk-80 and SOM VM implementation, and the prospect to build a LuaJIT based Interlisp VM. In contrast to Oberon+, Luon doesn't have pointers, but instead all structured datatypes have reference semantics and are dynamically created. In addition to the ARRAY type, there is also a HASHMAP type for compatibility with Lua. There is also a STRING data type which - like Lua - is immutable and follows a value semantics. In particular, Luon solves the following Lua shortcomings recognized during the aforementioned projects: conditional compilation to enable or disable statements only used for debugging and to avoid wasting calculation time constants not requiring local slots or hashed element access explicit inline declaration, so the code can be better structured without additional context switches and slot consumption no implicit global declarations, and other means to detect as many errors as possible during compile time locals can no longer be used before declaration switch/case control statement to avoid writing the relation expression all over again This project implements a compiler and IDE for the Luon programming language. Representative example projects demonstrating the capabilities of the language and the IDE can be found in the testcases subdirectory. Here is a screenshot of the IDE: And here is the source-level debugger of the IDE: Code examples Procedural Programming module Fibonacci proc calc*(n : integer): integer var a, b, i, next: integer // comma is optional begin \u003c* if use_recursion then *\u003e if n \u003e 1 then a := calc(n - 1) b := calc(n - 2) return a + b elsif n = 0 then return 0 else return 1 end \u003c* else *\u003e b := 1 for i := 0 to n-1 do next := a + b a := b b := next end return a \u003c* end *\u003e end calc var res: integer begin res := calc(21) assert(res = 10946) print(\"Fibonaccy result: \") println(res) end Fibonacci Generic Programming module Collections(T) type Deque* = record data: array of T size: integer end proc createDeque*(): Deque const initial_len = 1_000 // separators var this: Deque // this is initialized to nil begin new(this); new(this.data,initial_len) return this // this and data will be garbage collected end createDeque proc (this: Deque) append*(element: T) begin if this.size = len(this.data) then assert(false) end this.data[this.size] := element inc(this.size) end append type Iterator* = record end proc (this: Iterator) apply*(element: T) end proc (this: Deque) forEach*(iter: Iterator) var i: integer; val: T begin for i := 0 to this.size-1 do iter.apply(this.data[i]) end end forEach end Collections Object Oriented Programming module Drawing import F := Fibonacci C := Collections(Figure) type Figure* = record position: record x,y: integer end end proc (this: Figure) draw*() end type Circle* = record (Figure) diameter: integer end Square* = record (Figure) width: integer end proc (this: Circle) draw*() end proc (this: Square) draw*() end var figures: C.Deque circle: Circle square: Square proc drawAll() type I = record(C.Iterator) count: integer end proc (this: I) apply( figure: Figure ) begin figure.draw(); inc(this.count) end apply var i: I // count is initialized to zero begin new(i) figures.forEach(i) assert(i.count = 2) println(\"drawing done\") end drawAll begin figures := C.createDeque() // use constructors instead of new: circle := { { F.calc(3), F.calc(4) }, diameter: 3 } figures.append(circle) square := { { x: F.calc(5), y: F.calc(6) }, 4 } figures.append(square) drawAll() end Drawing Planned features Implement lexer with directive support Implement parser and AST Implement semantic validator Implement a LuaJIT backend based on LjTools Implement an IDE similar to the Oberon+ IDE Document the language (specification is available) Migrate the Smalltalk-80 VM to Luon as a proof-of-concept and to optimize the language BUSY build and precompiled versions for some platforms Migrate PAL2 from C to Lua, fix BitBlt, separate deployment Complete the language implementation according to the specification (inline, invar, pcall, visibility, etc.) Development history Status on October 14, 2024 Derived the syntax from Oberon+ and Micron and generated a parser using the grammar and adopted the lexer from the Micron project. The parser is able to successfully read the ongoing Luon migration of the Are-we-fast-yet benchmark suite (not yet commited). Status on October 15, 2024 Adopted the AST infrastructure from Micron and extended the AST for full program coverage. Implemented a recursive descent parser (modified the one generated by EbnfStudio) which generates the AST. Status on October 16, 2024 Improved language: constructors generate object, extended for arrays and hashmaps; extra set constructor no longer needed. Can generate AST for ongoing AWFY with no memory leaks. Status on October 25, 2024 The semantic validator is complete and tested. I developed it in parallel with the Luon version of the Are-we-fast-yet benchmark suite. Some refactorings and language changes were necessary. As in Oberon-07, there is now only one INTEGER and REAL type, the former with 53 bits of precision. The validator was feature complete on October 22, so development took six, and testing and debugging three calendar days. Status on October 27, 2024 The IDE is ready for testing and debugging. I derived it from the LuaJIT version of the Oberon IDE, but many changes were necessary because the AST and code model are completely different. This included an optional cross-referencing infrastructure integrated with the validator. Also the import logic had to be extended for compatibility with the project file concept, which required refactoring of AST, parser and validator. Status on November 05, 2024 The LuaJIT bytecode generator including most built-in procedures is complete and ready for testing and debugging. All functions of the LuonFfi.c file were migrated to LUON.lua to avoid C dependencies. Added Oakwood implementations in Lua (Files is no longer Oakwood compatible). Status on November 09, 2024 After a lot of testing, debugging and fixes the generated code seems to be sufficiently correct for the moment to continue with other stuff. The testcases in the all.lnpro project, which I migrated from Oberon+ (\"features\" subfolder), work, which covers most aspect of the language. I also implemented delegates and the copy() builtin, and made some other language changes (e.g. := no longer copies char arrays by value). Next goal is to run the Luon Awfy suite. Status on November 13, 2024 The Luon Are-we-fast-yet suite works up to Json; a significant refactoring of the code generator was necessary for this to properly intitialize all class objects up-front; the performance is currently slightly (1%) better than Lua, and there is room for improvement. Now after a calendar month in the project, the compiler and IDE seem ready for implementing a Smalltalk VM, so let's go for it. Status on November 26, 2024 All benchmarks of the Luon Are-we-fast-yet suite now work and show a performance equal to the Lua on LuaJIT version of the benchmark. The debugger has been significantly improved. The BYTE type and TOSTRING builtin have been added to the language. The Project Oberon System has been migrated to Luon; the code works so far, but for correct display output many changes would be required (maybe in future). The Smalltalk VM is work in progress and expected to be complete in a week. Both compiler and IDE are used to implement the Smalltalk VM and have proved to be useful so far. Status on December 1. 2024 The migration of the Luon implementation of the Smalltalk VM (see for *.luon and *.lnpro) is complete. I migrated the C++ version with a few architectural changes. In contrast to the C++ version which uses Qt, this version uses SDL2 via LuaJIT FFI. It is also an example how the EXTERN keyword works, i.e. how the external implementations are provided. Now the debugging starts; wish me luck ;-) Meanwhile also the Luon specification is available, though not all features are yet implemented. Status on December 8. 2024 The ST-80 display representation works, but only with the C version of the BitBlt so far. Also added a Qt version of the PAL to ease debugging. Extended the language (KEYS function) and made other hasmap fixes. The ST VM requires still more debugging. Status on December 10. 2024 The Smalltalk-80 VM implemented in Luon works (with a few issues WIP), with both the SDL2 and Qt based PAL. Added the source code of the VM as a local testcase and demonstration to the Luon repository (as a copy of the corresponding files in the Smalltalk repository). The same applies to the Are-we-fast-yet implementation. The project is close to an MVP release. Status on December 12. 2024 With only a few changes, the IDE and demo projects also work on Windows. Provided precompiled packages for a few platforms. LuaJIT is statically linked on all platforms. MVP release. Precompiled versions The following precompiled versions are available at this time: Linux x86 Linux x86_64 Windows x86 Just download and unpack the compressed file to a directory. Start the IDE by double clicking on the LuonIDE executable. The specification and some demonstration projects are included. How to build Follow these steps if you want to build the Luon IDE yourself. The build is using LeanQt and the BUSY build system. Note that compiling on Linux requires the build essentials, xcb, libxcb1-dev and libx11-dev packages. On Mac and Windows there are no additional requirements than a toolchain. Create a new directory; we call it the root directory here Download https://github.com/rochus-keller/Luon/archive/refs/heads/master.zip and unpack it to the root directory; rename the resulting directory to \"Oberon\". Download https://github.com/rochus-keller/LuaJIT/archive/refs/heads/LjTools.zip and unpack it to the root directory; rename the resulting directory to \"LuaJIT\". Download https://github.com/rochus-keller/LjTools/archive/refs/heads/master.zip and unpack it to the root directory; rename the resulting directory to \"MonoTools\". Download https://github.com/rochus-keller/GuiTools/archive/refs/heads/master.zip and unpack it to the root directory; rename the resulting directory to \"GuiTools\". Download https://github.com/rochus-keller/LeanQt/archive/refs/heads/master.zip and unpack it to the root directory; rename the resulting directory to \"LeanQt\". Download https://github.com/rochus-keller/BUSY/archive/refs/heads/master.zip and unpack it to the root directory; rename the resulting directory to \"build\". Open a command line in the \"LuaJIT\" directory and follow the instructions there to build LuaJIT for your platform. Open a command line in the \"build\" directory and type cc *.c -O2 -lm -o lua or cl /O2 /MD /Fe:lua.exe *.c depending on whether you are on a Unix or Windows machine; wait a few seconds until the Lua executable is built. Now type ./lua build.lua ../Luon (or lua build.lua ../Luon on Windows); wait until the LuonIDE executable is built; you find it in the output subdirectory. Instead of the command line you can run the build using LeanCreator which uses multiple cores and thus builds faster. It is still possible to build the IDE using Qt 5 with qmake; use LnIde.pro for this purpose and proceed as usual when building with Qt. Support If you need support or would like to post issues or feature requests please use the Github issue list at https://github.com/rochus-keller/Luon/issues or send an email to the author. License Luon is available under GPL 2 or 3. The runtime libraries in the runtime subfolder, in addition, are available under MPL or LGPL. Additional Credits LuaJIT is Copyright © 2005-2023 Mike Pall, released under the MIT open source license. LeanQt is based on Qt, which is Copyright (C) 2016 by The Qt Company Ltd, 2008 by Nokia Corporation and/or its subsidiary(-ies), 1992-2005 by Trolltech AS, and many individual contributors around the world.",
  "image": "https://repository-images.githubusercontent.com/872714042/df053d93-d242-45d9-a310-f7b088e9e62a",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\" aria-labelledby=\"file-name-id-wide file-name-id-mobile\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://camo.githubusercontent.com/a23297ec362f4920d47ecc5869aee3773ca25ff3ee2cf7c07be4f6bf0b90f8e9/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e5f6c6f676f5f323030783133302e706e67\"\u003e\u003cimg src=\"https://camo.githubusercontent.com/a23297ec362f4920d47ecc5869aee3773ca25ff3ee2cf7c07be4f6bf0b90f8e9/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e5f6c6f676f5f323030783133302e706e67\" alt=\"Logo\" data-canonical-src=\"http://software.rochus-keller.ch/luon_logo_200x130.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eWelcome to the Luon Programming Language\u003c/h2\u003e\u003ca id=\"user-content-welcome-to-the-luon-programming-language\" aria-label=\"Permalink: Welcome to the Luon Programming Language\" href=\"#welcome-to-the-luon-programming-language\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLuon is a high-level programming language with a syntax similar to \u003ca href=\"https://github.com/rochus-keller/oberon/\"\u003eOberon+\u003c/a\u003e, Oberon-07 and Oberon-2, integrating concepts from Lua, and targeting the LuaJIT VM. Luon can be regarded as a statically typed version of Lua. The name is thus a combination of \u0026#34;Lua\u0026#34; and \u0026#34;Oberon\u0026#34;.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLuon procedures can be declared \u0026#34;external\u0026#34; and be implemented in Lua. This allows the re-use of libraries written in Lua, and also C libraries via\nthe LuaJIT foreign function interface.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe language specification can be found in the \u003ca href=\"https://github.com/rochus-keller/Luon/tree/master/specification\"\u003especification subdirectory\u003c/a\u003e.\nSee also the code examples below.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe project is the result of the author\u0026#39;s experience with the \u003ca href=\"https://github.com/rochus-keller/Smalltalk/\"\u003eSmalltalk-80\u003c/a\u003e and \u003ca href=\"https://github.com/rochus-keller/Som/\"\u003eSOM VM\u003c/a\u003e implementation, and the prospect to build a \u003ca href=\"https://github.com/rochus-keller/Gingko/\"\u003eLuaJIT based Interlisp VM\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIn contrast to Oberon+, Luon doesn\u0026#39;t have pointers, but instead all structured datatypes have reference semantics and are dynamically created. In addition to the ARRAY type, there is also a HASHMAP type for compatibility with Lua. There is also a STRING data type which - like Lua - is immutable and follows a value semantics.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIn particular, Luon solves the following Lua shortcomings recognized during the aforementioned projects:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003econditional compilation to enable or disable statements only used for debugging and to avoid wasting calculation time\u003c/li\u003e\n\u003cli\u003econstants not requiring local slots or hashed element access\u003c/li\u003e\n\u003cli\u003eexplicit inline declaration, so the code can be better structured without additional context\nswitches and slot consumption\u003c/li\u003e\n\u003cli\u003eno implicit global declarations, and other means to detect as many errors as possible during compile time\u003c/li\u003e\n\u003cli\u003elocals can no longer be used before declaration\u003c/li\u003e\n\u003cli\u003eswitch/case control statement to avoid writing the relation expression all over again\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eThis project implements a compiler and IDE for the Luon programming language. Representative example projects demonstrating the\ncapabilities of the language and the IDE can be found in the \u003ca href=\"https://github.com/rochus-keller/Luon/tree/master/testcases/\"\u003etestcases subdirectory\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eHere is a screenshot of the IDE:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://camo.githubusercontent.com/b36d0d0e54171fe3534c92f705581ba3dbd79da18a812e2e71bd78aac4080ef9/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e2d6964652d73637265656e73686f742d302e372e302d312e706e67\"\u003e\u003cimg src=\"https://camo.githubusercontent.com/b36d0d0e54171fe3534c92f705581ba3dbd79da18a812e2e71bd78aac4080ef9/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e2d6964652d73637265656e73686f742d302e372e302d312e706e67\" alt=\"IDE Screenshot 1\" data-canonical-src=\"http://software.rochus-keller.ch/luon-ide-screenshot-0.7.0-1.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAnd here is the source-level debugger of the IDE:\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer nofollow\" href=\"https://camo.githubusercontent.com/0f2996c7901d0807b60a9d66738643c8b36ffaf67d9025da37d2d7e130a09507/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e2d6964652d73637265656e73686f742d302e372e302d322e706e67\"\u003e\u003cimg src=\"https://camo.githubusercontent.com/0f2996c7901d0807b60a9d66738643c8b36ffaf67d9025da37d2d7e130a09507/687474703a2f2f736f6674776172652e726f636875732d6b656c6c65722e63682f6c756f6e2d6964652d73637265656e73686f742d302e372e302d322e706e67\" alt=\"IDE Screenshot 2\" data-canonical-src=\"http://software.rochus-keller.ch/luon-ide-screenshot-0.7.0-2.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eCode examples\u003c/h3\u003e\u003ca id=\"user-content-code-examples\" aria-label=\"Permalink: Code examples\" href=\"#code-examples\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eProcedural Programming\u003c/h5\u003e\u003ca id=\"user-content-procedural-programming\" aria-label=\"Permalink: Procedural Programming\" href=\"#procedural-programming\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv data-snippet-clipboard-copy-content=\"module Fibonacci\n  proc calc*(n : integer): integer\n    var a, b, i, next: integer // comma is optional\n  begin\n   \u0026lt;* if use_recursion then *\u0026gt;\n    if n \u0026gt; 1 then \n      a := calc(n - 1)\n      b := calc(n - 2)\n      return a + b\n    elsif n = 0 then return 0\n    else return 1\n    end\n   \u0026lt;* else *\u0026gt;\n    b := 1\n    for i := 0 to n-1 do\n      next := a + b\n      a := b\n      b := next\n    end\n    return a\n   \u0026lt;* end *\u0026gt;\n  end calc\n  var res: integer\nbegin\n  res := calc(21)\n  assert(res = 10946)\n  print(\u0026#34;Fibonaccy result: \u0026#34;)\n  println(res)\nend Fibonacci\n\"\u003e\u003cpre\u003e\u003ccode\u003emodule Fibonacci\n  proc calc*(n : integer): integer\n    var a, b, i, next: integer // comma is optional\n  begin\n   \u0026lt;* if use_recursion then *\u0026gt;\n    if n \u0026gt; 1 then \n      a := calc(n - 1)\n      b := calc(n - 2)\n      return a + b\n    elsif n = 0 then return 0\n    else return 1\n    end\n   \u0026lt;* else *\u0026gt;\n    b := 1\n    for i := 0 to n-1 do\n      next := a + b\n      a := b\n      b := next\n    end\n    return a\n   \u0026lt;* end *\u0026gt;\n  end calc\n  var res: integer\nbegin\n  res := calc(21)\n  assert(res = 10946)\n  print(\u0026#34;Fibonaccy result: \u0026#34;)\n  println(res)\nend Fibonacci\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eGeneric Programming\u003c/h5\u003e\u003ca id=\"user-content-generic-programming\" aria-label=\"Permalink: Generic Programming\" href=\"#generic-programming\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv data-snippet-clipboard-copy-content=\"module Collections(T) \n  type Deque* = record data: array of T\n                      size: integer end\n                      \n  proc createDeque*(): Deque \n    const initial_len = 1_000 // separators\n    var this: Deque  // this is initialized to nil\n  begin \n    new(this); \n    new(this.data,initial_len) \n    return this \n    // this and data will be garbage collected\n  end createDeque\n  \n  proc (this: Deque) append*(element: T)\n  begin \n    if this.size = len(this.data) then assert(false) end\n    this.data[this.size] := element inc(this.size) \n  end append\n  \n  type Iterator* = record end\n  proc (this: Iterator) apply*(element: T) end\n  \n  proc (this: Deque) forEach*(iter: Iterator)\n    var i: integer; val: T\n  begin \n    for i := 0 to this.size-1 do \n      iter.apply(this.data[i]) \n    end\n  end forEach\nend Collections\"\u003e\u003cpre\u003e\u003ccode\u003emodule Collections(T) \n  type Deque* = record data: array of T\n                      size: integer end\n                      \n  proc createDeque*(): Deque \n    const initial_len = 1_000 // separators\n    var this: Deque  // this is initialized to nil\n  begin \n    new(this); \n    new(this.data,initial_len) \n    return this \n    // this and data will be garbage collected\n  end createDeque\n  \n  proc (this: Deque) append*(element: T)\n  begin \n    if this.size = len(this.data) then assert(false) end\n    this.data[this.size] := element inc(this.size) \n  end append\n  \n  type Iterator* = record end\n  proc (this: Iterator) apply*(element: T) end\n  \n  proc (this: Deque) forEach*(iter: Iterator)\n    var i: integer; val: T\n  begin \n    for i := 0 to this.size-1 do \n      iter.apply(this.data[i]) \n    end\n  end forEach\nend Collections\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eObject Oriented Programming\u003c/h5\u003e\u003ca id=\"user-content-object-oriented-programming\" aria-label=\"Permalink: Object Oriented Programming\" href=\"#object-oriented-programming\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv data-snippet-clipboard-copy-content=\"module Drawing\n  import F := Fibonacci\n         C := Collections(Figure)\n  \n  type Figure* = record position: record \n                     x,y: integer end end  \n  proc (this: Figure) draw*() end\n    \n  type\n    Circle* = record (Figure) diameter: integer end\n    Square* = record (Figure) width: integer end \n    proc (this: Circle) draw*() end\n    proc (this: Square) draw*() end\n        \n  var figures: C.Deque\n      circle: Circle\n      square: Square\n    \n  proc drawAll()\n    type I = record(C.Iterator) count: integer end\n    proc (this: I) apply( figure: Figure ) \n    begin \n      figure.draw(); inc(this.count) \n    end apply\n    var i: I // count is initialized to zero\n  begin\n    new(i)\n    figures.forEach(i)\n    assert(i.count = 2)\n    println(\u0026#34;drawing done\u0026#34;)\n  end drawAll\n  \nbegin \n  figures := C.createDeque()\n  // use constructors instead of new:\n  circle := { { F.calc(3), F.calc(4) }, diameter: 3 }\n  figures.append(circle)\n  square := { { x: F.calc(5), y: F.calc(6) }, 4 }\n  figures.append(square)\n  drawAll()\nend Drawing  \"\u003e\u003cpre\u003e\u003ccode\u003emodule Drawing\n  import F := Fibonacci\n         C := Collections(Figure)\n  \n  type Figure* = record position: record \n                     x,y: integer end end  \n  proc (this: Figure) draw*() end\n    \n  type\n    Circle* = record (Figure) diameter: integer end\n    Square* = record (Figure) width: integer end \n    proc (this: Circle) draw*() end\n    proc (this: Square) draw*() end\n        \n  var figures: C.Deque\n      circle: Circle\n      square: Square\n    \n  proc drawAll()\n    type I = record(C.Iterator) count: integer end\n    proc (this: I) apply( figure: Figure ) \n    begin \n      figure.draw(); inc(this.count) \n    end apply\n    var i: I // count is initialized to zero\n  begin\n    new(i)\n    figures.forEach(i)\n    assert(i.count = 2)\n    println(\u0026#34;drawing done\u0026#34;)\n  end drawAll\n  \nbegin \n  figures := C.createDeque()\n  // use constructors instead of new:\n  circle := { { F.calc(3), F.calc(4) }, diameter: 3 }\n  figures.append(circle)\n  square := { { x: F.calc(5), y: F.calc(6) }, 4 }\n  figures.append(square)\n  drawAll()\nend Drawing  \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003ePlanned features\u003c/h3\u003e\u003ca id=\"user-content-planned-features\" aria-label=\"Permalink: Planned features\" href=\"#planned-features\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e Implement lexer with directive support\u003c/li\u003e\n\u003cli\u003e Implement parser and AST\u003c/li\u003e\n\u003cli\u003e Implement semantic validator\u003c/li\u003e\n\u003cli\u003e Implement a LuaJIT backend based on LjTools\u003c/li\u003e\n\u003cli\u003e Implement an IDE similar to the Oberon+ IDE\u003c/li\u003e\n\u003cli\u003e Document the language (specification is available)\u003c/li\u003e\n\u003cli\u003e Migrate the Smalltalk-80 VM to Luon as a proof-of-concept and to optimize the language\u003c/li\u003e\n\u003cli\u003e BUSY build and precompiled versions for some platforms\u003c/li\u003e\n\u003cli\u003e Migrate PAL2 from C to Lua, fix BitBlt, separate deployment\u003c/li\u003e\n\u003cli\u003e Complete the language implementation according to the specification (inline, invar, pcall, visibility, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eDevelopment history\u003c/h3\u003e\u003ca id=\"user-content-development-history\" aria-label=\"Permalink: Development history\" href=\"#development-history\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on October 14, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-october-14-2024\" aria-label=\"Permalink: Status on October 14, 2024\" href=\"#status-on-october-14-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eDerived the syntax from Oberon+ and Micron and generated a parser using \u003ca href=\"https://github.com/micron-language/specification/blob/master/Micron_Programming_Language.ebnf\"\u003ethe grammar\u003c/a\u003e and adopted the lexer from \u003ca href=\"https://github.com/rochus-keller/Micron\"\u003ethe Micron project\u003c/a\u003e. The parser is able to successfully read the ongoing Luon migration of the\n\u003ca href=\"https://github.com/rochus-keller/Are-we-fast-yet/tree/main/Luon\"\u003eAre-we-fast-yet benchmark suite\u003c/a\u003e (not yet commited).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on October 15, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-october-15-2024\" aria-label=\"Permalink: Status on October 15, 2024\" href=\"#status-on-october-15-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAdopted the AST infrastructure from Micron and extended the AST for full program coverage.\nImplemented a recursive descent parser (modified the one generated  by \u003ca href=\"https://github.com/rochus-keller/EbnfStudio\"\u003eEbnfStudio\u003c/a\u003e) which generates the AST.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on October 16, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-october-16-2024\" aria-label=\"Permalink: Status on October 16, 2024\" href=\"#status-on-october-16-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eImproved language: constructors generate object, extended for arrays and hashmaps; extra set constructor no longer needed. Can generate AST for ongoing AWFY with no memory leaks.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on October 25, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-october-25-2024\" aria-label=\"Permalink: Status on October 25, 2024\" href=\"#status-on-october-25-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe semantic validator is complete and tested. I developed it in parallel with \u003ca href=\"https://github.com/rochus-keller/Are-we-fast-yet/tree/main/Luon\"\u003ethe Luon version of the Are-we-fast-yet benchmark suite\u003c/a\u003e. Some refactorings and language changes were necessary. As in Oberon-07, there is now only one INTEGER and REAL type, the former with 53 bits of precision. The validator was feature complete on October 22, so development took six, and testing and debugging three calendar days.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on October 27, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-october-27-2024\" aria-label=\"Permalink: Status on October 27, 2024\" href=\"#status-on-october-27-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe IDE is ready for testing and debugging. I derived it from the LuaJIT version of the Oberon IDE, but many changes were necessary because the AST and code model are completely different. This included an optional cross-referencing infrastructure integrated with the validator. Also the import logic had to be extended for compatibility with the project file concept, which required refactoring of AST, parser and validator.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on November 05, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-november-05-2024\" aria-label=\"Permalink: Status on November 05, 2024\" href=\"#status-on-november-05-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe LuaJIT bytecode generator including most built-in procedures is complete and ready for testing and debugging. All functions of the LuonFfi.c file\nwere migrated to LUON.lua to avoid C dependencies. Added Oakwood implementations in Lua (Files is no longer Oakwood compatible).\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on November 09, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-november-09-2024\" aria-label=\"Permalink: Status on November 09, 2024\" href=\"#status-on-november-09-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAfter a lot of testing, debugging and fixes the generated code seems to be sufficiently correct for the moment to continue with other stuff. The testcases\nin the all.lnpro project, which I migrated from Oberon+ (\u0026#34;features\u0026#34; subfolder), work, which covers most aspect of the language. I also\nimplemented delegates and the copy() builtin, and made some other language changes (e.g. := no longer copies char arrays by value). Next goal is\nto run the Luon Awfy suite.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on November 13, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-november-13-2024\" aria-label=\"Permalink: Status on November 13, 2024\" href=\"#status-on-november-13-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe Luon Are-we-fast-yet suite works up to Json; a significant refactoring of the code generator was necessary for this to properly intitialize all\nclass objects up-front; the performance is currently slightly (1%) better than Lua, and there is room for improvement. Now after a calendar month\nin the project, the compiler and IDE seem ready for implementing a Smalltalk VM, so let\u0026#39;s go for it.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on November 26, 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-november-26-2024\" aria-label=\"Permalink: Status on November 26, 2024\" href=\"#status-on-november-26-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAll benchmarks of the Luon Are-we-fast-yet suite now work and show a performance equal to the Lua on LuaJIT version of the benchmark. The debugger has been significantly improved. The BYTE type and TOSTRING builtin have been added to the language.\nThe Project Oberon System has been migrated to Luon; the code works so far, but for correct display output many changes would be required (maybe in future).\nThe Smalltalk VM is work in progress and expected to be complete in a week. Both compiler and IDE are used to implement the Smalltalk VM and have proved to be useful so far.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on December 1. 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-december-1-2024\" aria-label=\"Permalink: Status on December 1. 2024\" href=\"#status-on-december-1-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe migration of \u003ca href=\"https://github.com/rochus-keller/Smalltalk/blob/master/Smalltalk.lnpro\"\u003ethe Luon implementation of the Smalltalk VM\u003c/a\u003e (see for *.luon and *.lnpro) is complete. I migrated the C++ version with a few architectural changes. In contrast to the C++ version which uses Qt, this version uses SDL2 via LuaJIT FFI. It is also an example how the EXTERN keyword works, i.e. how the external implementations are provided. Now the debugging starts; wish me luck ;-)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eMeanwhile also \u003ca href=\"https://github.com/rochus-keller/Luon/tree/master/specification\"\u003ethe Luon specification\u003c/a\u003e is available, though not all features are yet implemented.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on December 8. 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-december-8-2024\" aria-label=\"Permalink: Status on December 8. 2024\" href=\"#status-on-december-8-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe ST-80 display representation works, but only with the C version of the BitBlt so far. Also added a Qt version of the PAL to ease debugging. Extended the language (KEYS function) and made other hasmap fixes. The ST VM requires still more debugging.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on December 10. 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-december-10-2024\" aria-label=\"Permalink: Status on December 10. 2024\" href=\"#status-on-december-10-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe Smalltalk-80 VM implemented in Luon works (with a few issues WIP), with both the SDL2 and Qt based PAL. Added the source code of the VM as\na local testcase and demonstration to the Luon repository (as a copy of the corresponding files in the Smalltalk repository).\nThe same applies to the Are-we-fast-yet implementation. The project is close to an MVP release.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch5 tabindex=\"-1\" dir=\"auto\"\u003eStatus on December 12. 2024\u003c/h5\u003e\u003ca id=\"user-content-status-on-december-12-2024\" aria-label=\"Permalink: Status on December 12. 2024\" href=\"#status-on-december-12-2024\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWith only a few changes, the IDE and demo projects also work on Windows. Provided precompiled packages for a few platforms. LuaJIT is statically linked\non all platforms. MVP release.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003ePrecompiled versions\u003c/h3\u003e\u003ca id=\"user-content-precompiled-versions\" aria-label=\"Permalink: Precompiled versions\" href=\"#precompiled-versions\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe following precompiled versions are available at this time:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"http://software.rochus-keller.ch/LuonIDE_linux_i386.tar.gz\" rel=\"nofollow\"\u003eLinux x86\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://software.rochus-keller.ch/LuonIDE_linux_x64.tar.gz\" rel=\"nofollow\"\u003eLinux x86_64\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://software.rochus-keller.ch/LuonIDE_win32.zip\" rel=\"nofollow\"\u003eWindows x86\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eJust download and unpack the compressed file to a directory. Start the IDE by double clicking on the LuonIDE executable. The specification and some demonstration projects are included.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eHow to build\u003c/h3\u003e\u003ca id=\"user-content-how-to-build\" aria-label=\"Permalink: How to build\" href=\"#how-to-build\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eFollow these steps if you want to build the Luon IDE yourself. The build is using LeanQt and the BUSY build system. Note that compiling on Linux requires the build essentials, xcb, libxcb1-dev and libx11-dev packages. On Mac and Windows there are no additional requirements than a toolchain.\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eCreate a new directory; we call it the root directory here\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/Luon/archive/refs/heads/master.zip\"\u003ehttps://github.com/rochus-keller/Luon/archive/refs/heads/master.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;Oberon\u0026#34;.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/LuaJIT/archive/refs/heads/LjTools.zip\"\u003ehttps://github.com/rochus-keller/LuaJIT/archive/refs/heads/LjTools.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;LuaJIT\u0026#34;.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/LjTools/archive/refs/heads/master.zip\"\u003ehttps://github.com/rochus-keller/LjTools/archive/refs/heads/master.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;MonoTools\u0026#34;.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/GuiTools/archive/refs/heads/master.zip\"\u003ehttps://github.com/rochus-keller/GuiTools/archive/refs/heads/master.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;GuiTools\u0026#34;.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/LeanQt/archive/refs/heads/master.zip\"\u003ehttps://github.com/rochus-keller/LeanQt/archive/refs/heads/master.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;LeanQt\u0026#34;.\u003c/li\u003e\n\u003cli\u003eDownload \u003ca href=\"https://github.com/rochus-keller/BUSY/archive/refs/heads/master.zip\"\u003ehttps://github.com/rochus-keller/BUSY/archive/refs/heads/master.zip\u003c/a\u003e and unpack it to the root directory; rename the resulting directory to \u0026#34;build\u0026#34;.\u003c/li\u003e\n\u003cli\u003eOpen a command line in the \u0026#34;LuaJIT\u0026#34; directory and follow the instructions there to build LuaJIT for your platform.\u003c/li\u003e\n\u003cli\u003eOpen a command line in the \u0026#34;build\u0026#34; directory and type \u003ccode\u003ecc *.c -O2 -lm -o lua\u003c/code\u003e or \u003ccode\u003ecl /O2 /MD /Fe:lua.exe *.c\u003c/code\u003e depending on whether you are on a Unix or Windows machine; wait a few seconds until the Lua executable is built.\u003c/li\u003e\n\u003cli\u003eNow type \u003ccode\u003e./lua build.lua ../Luon\u003c/code\u003e (or \u003ccode\u003elua build.lua ../Luon\u003c/code\u003e on Windows); wait until the LuonIDE executable is built; you find it in the output subdirectory.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003eInstead of the command line you can run the build using \u003ca href=\"https://github.com/rochus-keller/LeanCreator\"\u003eLeanCreator\u003c/a\u003e which uses multiple cores and thus builds faster.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt is still possible to build the IDE using Qt 5 with qmake; use LnIde.pro for this purpose and proceed as usual when building with Qt.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eSupport\u003c/h3\u003e\u003ca id=\"user-content-support\" aria-label=\"Permalink: Support\" href=\"#support\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIf you need support or would like to post issues or feature requests please use the Github issue list at \u003ca href=\"https://github.com/rochus-keller/Luon/issues\"\u003ehttps://github.com/rochus-keller/Luon/issues\u003c/a\u003e or send an email to the author.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eLicense\u003c/h3\u003e\u003ca id=\"user-content-license\" aria-label=\"Permalink: License\" href=\"#license\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eLuon is available under GPL 2 or 3. The runtime libraries in the runtime subfolder, in addition, are available under MPL or LGPL.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eAdditional Credits\u003c/h3\u003e\u003ca id=\"user-content-additional-credits\" aria-label=\"Permalink: Additional Credits\" href=\"#additional-credits\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"http://luajit.org\" rel=\"nofollow\"\u003eLuaJIT\u003c/a\u003e is Copyright © 2005-2023 Mike Pall, released under the MIT open source license.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rochus-keller/LeanQt\"\u003eLeanQt\u003c/a\u003e is based on Qt, which is Copyright (C) 2016 by The Qt Company Ltd, 2008 by Nokia Corporation and/or its subsidiary(-ies), 1992-2005 by Trolltech AS, and many individual contributors around the world.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
