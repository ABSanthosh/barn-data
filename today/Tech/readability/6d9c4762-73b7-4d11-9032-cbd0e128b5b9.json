{
  "id": "6d9c4762-73b7-4d11-9032-cbd0e128b5b9",
  "title": "You might not need WebSockets",
  "link": "https://hntrl.io/posts/you-dont-need-websockets/",
  "description": "Comments",
  "author": "",
  "published": "Fri, 11 Apr 2025 22:27:16 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Hunter Lovell",
  "length": 14415,
  "excerpt": "Websockets are powerful tools that have become a fan-favorite for building realtime applications, but you might be using them for all the wrong reasons. Let's explore the pitfalls of websockets and how we can use plain old HTTP to get the same job done.",
  "siteName": "",
  "favicon": "",
  "text": "What’s a WebSocket? If you’re new to web development or you haven’t heard of a WebSocket before, they’re a way to open a two-way communication channel between the client and server using HTTP as the transport protocol. In less nerdy terms, it’s a way to keep an open line of communication between the client and server so that both can send and receive messages at any time. (MDN Reference) Because of how it’s advertised on the tin, it’s natural to think of a WebSocket as the best (and sometimes only) way to orchestrate a long-living stream of data between client and server, like for instance a real time application. In practice though, it turns out there are a few reasons why you might not want to use them: WebSocket messages aren’t transactional I see a lot of instances where WebSockets are used as the way of maintaining consistency for some kind of state object. For instance, you use the transmitting side of the socket to represent mutations to some object, and the receiving side of the socket to represent state as it gets changed by those mutations. That way if you have multiple clients listening to the same object, they’ll all see the same state changes without having to refresh the page. # Client 1 \u003e\u003e\u003e { command: \"increment\", amount: 5 } \u003c\u003c\u003c { event: \"count\", value: 5 } \u003e\u003e\u003e { command: \"decrement\", amount: 2 } \u003c\u003c\u003c { event: \"count\", value: 3 } # Client 2 \u003c\u003c\u003c { event: \"count\", value: 5 } \u003c\u003c\u003c { event: \"count\", value: 3 } But what if you placed some kind of invariant condition on the state object? For instance, you want to make sure that the count is never negative: \u003c\u003c\u003c { event: \"count\", amount: 5 } \u003e\u003e\u003e { command: \"decrement\", amount: 6 } \u003c\u003c\u003c { error: \"count cannot be negative\" } The issue here is that there’s no association between the mutation and error message since the error message will be received on the same stream as every other message. We can’t reliably say “the next message” received on the stream is the result of the previous command since the server could have sent any number of messages in between now and then. If we wanted to update the UI to show the error, we’d have to link the error event somehow (like providing an associative request id in the command and the error message): \u003e\u003e\u003e { command: \"decrement\", amount: 6, requestId: \"123\" } \u003c\u003c\u003c { error: \"count cannot be negative\", requestId: \"123\" } This becomes even more awkward because now you have to keep track of every message you send, and you have to find some way to bubble the error event back to the UI in an idempotent way. The same goes if you wanted to have some kind of indication that the command was received by the server. In that case, now you’re also dealing with certain hard-to-track edge cases: What if the socket closes before the server can process the command? What if you never receive a response message on the socket for some reason? What if you’re dealing with a huge number of concurrent requests? It creates too many unknowns and complexity for something that should be simple. If you’re dealing with messages where you need to know if they were received or not, you’re better off with using a more transactional protocol like HTTP to represent the sending side of the socket. ( \u003c \u003e ) = HTTP ( \u003c\u003c\u003c \u003e\u003e\u003e ) = WebSocket # Success \u003e POST /increment '{ value: 5 }' \u003c 200 OK \u003c\u003c\u003c { event: \"count\", value: 5 } #- (the update message still gets sent to all connected clients) # Failure \u003e POST /decrement '{ value: 6 }' \u003c 400 Bad Request #- (no update gets sent because the request failed) We’ve effectively ditched the transmitting side of the socket altogether and replaced it with HTTP, which means we’re now leaning on WebSockets to represent only one stream of data (the receiving side). As it turns out there’s other ways to do that don’t require the overhead of a full duplex connection. (we’ll get into this later) If you’re sending messages that don’t necessarily need to be acknowledged (like a heartbeat or keyboard inputs), then Websockets make a great fit. Hence the title of this post, you might not need Websockets. You have to manage the socket lifecycle When you use WebSockets, you’re not just sending and receiving messages at will—your application also has to respond to the opening and closing of the connection. This means handling events like “open” and “close” (or “error”), deciding what to do during reconnect attempts, and cleaning up resources when the connection is no longer needed. For example, a basic lifecycle for a WebSocket in the browser might look like this: const socket = new WebSocket(\"wss://example.com/socket\"); socket.addEventListener(\"open\", () =\u003e { console.log(\"Socket opened\"); }); socket.addEventListener(\"message\", (event) =\u003e { console.log(\"Received message:\", event.data); }); socket.addEventListener(\"error\", (err) =\u003e { console.error(\"Socket error:\", err); }); socket.addEventListener(\"close\", () =\u003e { console.log(\"Socket closed. Attempting to reconnect…\"); // Potentially restart or schedule a new socket connection here }); In a typical application, you might need to restart a closed connection, buffer messages while the socket is down, and handle retries with exponential backoff. Ignoring any of these steps can lead to lost messages, clumsy user experiences, or lingering connections. By contrast, with a simpler request/response model like HTTP, the lifecycle is more straightforward: each request starts, completes (or fails), and then you move on. The extra complexity of a WebSocket’s lifecycle is one of the main reasons you might not need it—unless there’s absolutely no alternative to socket based messaging (partially demonstrated in the previous section), then you’re better off with a simpler communication pattern. It makes your server code more complex When a new WebSocket connection is initiated, your server has to handle the HTTP “upgrade” request handshake. Instead of completing an ordinary request, the server checks for the special headers indicating a WebSocket handshake and then upgrades the connection from HTTP to a persistent socket. That means for every initial connection, the server must parse and validate WebSocket headers like “Sec-WebSocket-Key” and respond with the correct “Sec-WebSocket-Accept” header. (MDN Reference) The upgrade mechanism itself requires additional plumbing: you need to create a listener for the upgrade event on your server, confirm the request is valid, finalize the handshake, and then start broadcasting or receiving data. This not only adds more moving parts (compared to standard request/response flows) but also means comprehension of HTTP alone isn’t enough for debugging or troubleshooting—now you’re dealing with a specialized connection protocol. If you’re also dealing with similar request/response semantics as we’ve detailed above, it can introduce even more complexity since now your server code is written with the durable nature of sockets in mind, not the ephemeral nature of HTTP. Additionally, your application will need to manage all the edge cases: what if the client tries upgrading in an unsupported way? What if the handshake fails mid-stream or times out? What about partial data frames that need to be reassembled? While libraries and frameworks do a really good job of hiding some of these details under the hood, all these potential points of failure point back to a single truth: if you don’t truly need the power of a bidirectional, always-on socket, the handshake cost and the expanded error states can overshadow any performance or real-time benefits. So what’s the alternative? We touched on it very briefly in the previous sections, but if we can abstract away the transmitting side of the socket and only be left with a one-way stream of data on the receiving side, we can use a much simpler communication pattern. HTTP Streaming If you look deeper into how HTTP works, you’ll find that it’s actually a protocol designed for streaming data. If it wasn’t, we couldn’t stream video without loading the entire file first, or load huge websites without downloading the whole page. As it turns out that data stream doesn’t have to be split up chunks of some large blob of data. We can use the same principle to represent any arbitrary stream of data, like the real time updates that we were leaning on WebSockets for. Here’s an example in server-side JavaScript of how this would look using our counter example from before: let counter = 0; let resolvers = new Set(); // this returns a promise that resolves when the next // value is available. async function nextValue() { return new Promise((resolve) =\u003e resolvers.add(resolve)); } // look up what an `async generator` is if you're lost // looking at this syntax. explaining it is out of scope // for this post. async function* valueGenerator() { // (this loop gets broken when the response stream is closed.) while (true) { // every time we get the next value from the iterator, // we yield the return from an awaited promise that resolves // when the next value is available. yield await nextValue(); } } async function processCommand(command) { // this is what handles our \"state updates\" counter = nextCounterValue(command); // for each iterator (i.e. client that called `/stream`) // that's waiting on a value, we resolve the promise with // the new value for (const resolver of resolvers) { resolver(counter); resolvers.delete(resolver); } } // this is the function that computes the next state // based on the command, and enforces any invariants // that we want to have on the state. function nextCounterValue(command) { let next = counter; if (command.type === \"increment\") { next += command.amount; } else if (command.type === \"decrement\") { next -= command.amount; } if (next \u003c 0) { throw new Error(\"count cannot be negative\"); } return next; } // we use hono/express like syntax here, but you can // use any server framework you want. app.post(\"/increment\", async (req, res) =\u003e { try { const { value } = await req.json(); processCommand({ type: \"increment\", amount: value }); return new Response(\"OK\", 200); } catch (error) { return new Response(error.message, 400); } }); app.post(\"/decrement\", async (req, res) =\u003e { try { const { value } = await req.json(); processCommand({ type: \"decrement\", amount: value }); return new Response(\"OK\", 200); } catch (error) { return new Response(error.message, 400); } }); app.get(\"/stream\", (req, res) =\u003e { // We can create a stream from any async iterator, so // we can pass the generator function that yields counter // updates as they become available. const stream = ReadableStream.from(valueGenerator()); return new Response(stream); }); We can then use the Stream API on the browser side to read the data as it comes in, and update our UI according to whatever the server sends. const response = await fetch(\"/stream\"); const reader = response.body.getReader(); const decoder = new TextDecoder(); while (true) { // wait for the next chunk of data // (will only come when a state update is made) const { done, value } = await reader.read(); // when the server is done sending data, we break out of the loop if (done) break; // decode the chunk since data gets encoded over the network const chunk = decoder.decode(value); // update the UI with the new state updateUI(chunk); } With this setup we’ve completely eliminated the need for WebSockets while still maintaining real-time updates between multiple clients! Bonus: Making it easy with eventkit This is a little bit of a shameless plug, but it’s my post so you’re just going to have to live with it. I’ve been working on a library called eventkit that makes it easy to compose and observe asynchronous streams of data. If you’re familiar with the observable pattern or RxJS, it’s very similar but with better side effect management and built with generators. To harp on the counter example a little bit more, here’s how you could use eventkit to implement the same functionality: // server.ts import { Stream, AsyncObservable } from \"eventkit\"; let counter = 0; const stateUpdates$ = new Stream(); // when a new value is pushed into the stream, // we update the counter stateUpdates$.subscribe((value) =\u003e { counter = value; }); function nextCounterValue(command) { let next = counter; if (command.type === \"increment\") { next += command.amount; } else if (command.type === \"decrement\") { next -= command.amount; } if (next \u003c 0) { throw new Error(\"count cannot be negative\"); } return next; } app.post(\"/increment\", async (req, res) =\u003e { try { const { value } = await req.json(); const next = nextCounterValue( { type: \"increment\", amount: value } ); stateUpdates$.push(next); return new Response(\"OK\", 200); } catch (error) { return new Response(error.message, 400); } }); app.post(\"/decrement\", async (req, res) =\u003e { try { const { value } = await req.json(); const next = nextCounterValue( { type: \"decrement\", amount: value } ); stateUpdates$.push(next); return new Response(\"OK\", 200); } catch (error) { return new Response(error.message, 400); } }); app.get(\"/stream\", (req, res) =\u003e { // We can use the `Stream` class as an async iterator // to create a stream from it in the exact same way. const stream = ReadableSteam.from(stateUpdates$); return new Response(stream); }); // client.ts import { AsyncObservable, map } from \"eventkit\"; const response = await fetch(\"/stream\"); const decoder = new TextDecoder(); const counter$ = AsyncObservable.from(response.body); counter$ .pipe(map((value) =\u003e decoder.decode(value))) .subscribe(updateUI); I learned about the capabilities of the Stream API while building it and think it’s a really good candidate for your next real-time/event-based application. If you say otherwise, please open an issue and tell me why. I wouldn’t be a good project maintainer if I didn’t tell you to at least go check it out. We also wrote a separate HTTP Streaming guide that goes a little bit deeper into this topic in case you’re interested. Thanks for reading this wall of text! If you have any questions/comments, I’m around on X/Twitter. I also post more schizo ramblings on there, so I would appreciate the follow if that’s the sort of thing you’re into. (END)",
  "image": "https://hntrl.io//assets/blog/websocket-hero.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e  \u003ch2 id=\"whats-a-websocket\"\u003eWhat’s a WebSocket?\u003c/h2\u003e\n\u003cp\u003eIf you’re new to web development or you haven’t heard of a WebSocket before, they’re a way to open a two-way communication channel between the client and server using HTTP as the transport protocol. In less nerdy terms, it’s a way to keep an open line of communication between the client and server so that both can send and receive messages at any time. (\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\"\u003eMDN Reference\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eBecause of how it’s advertised on the tin, it’s natural to think of a WebSocket as the best (and sometimes only) way to orchestrate a long-living stream of data between client and server, like for instance a real time application. In practice though, it turns out there are a few reasons why you might not want to use them:\u003c/p\u003e\n\u003ch3 id=\"websocket-messages-arent-transactional\"\u003eWebSocket messages aren’t transactional\u003c/h3\u003e\n\u003cp\u003eI see a lot of instances where WebSockets are used as the way of maintaining consistency for some kind of state object. For instance, you use the transmitting side of the socket to represent mutations to some object, and the receiving side of the socket to represent state as it gets changed by those mutations. That way if you have multiple clients listening to the same object, they’ll all see the same state changes without having to refresh the page.\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e# Client 1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; { command: \u0026#34;increment\u0026#34;, amount: 5 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, value: 5 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; { command: \u0026#34;decrement\u0026#34;, amount: 2 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, value: 3 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# Client 2\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, value: 5 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, value: 3 }\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut what if you placed some kind of invariant condition on the state object? For instance, you want to make sure that the count is never negative:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, amount: 5 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; { command: \u0026#34;decrement\u0026#34;, amount: 6 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { error: \u0026#34;count cannot be negative\u0026#34; }\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe issue here is that there’s no association between the mutation and error message since the error message will be received on the same stream as every other message. We can’t reliably say “the next message” received on the stream is the result of the previous command since the server could have sent any number of messages in between now and then.\u003c/p\u003e\n\u003cp\u003eIf we wanted to update the UI to show the error, we’d have to link the error event somehow (like providing an associative request id in the command and the error message):\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt; { command: \u0026#34;decrement\u0026#34;, amount: 6, requestId: \u0026#34;123\u0026#34; }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { error: \u0026#34;count cannot be negative\u0026#34;, requestId: \u0026#34;123\u0026#34; }\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis becomes even more awkward because now you have to keep track of every message you send, and you have to find some way to bubble the error event back to the UI in an idempotent way. The same goes if you wanted to have some kind of indication that the command was received by the server. In that case, now you’re also dealing with certain hard-to-track edge cases:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhat if the socket closes before the server can process the command?\u003c/li\u003e\n\u003cli\u003eWhat if you never receive a response message on the socket for some reason?\u003c/li\u003e\n\u003cli\u003eWhat if you’re dealing with a huge number of concurrent requests?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt creates too many unknowns and complexity for something that should be simple. If you’re dealing with messages where you need to know if they were received or not, you’re better off with using a more transactional protocol like HTTP to represent the sending side of the socket.\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"plaintext\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e( \u0026lt; \u0026gt; ) = HTTP\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e( \u0026lt;\u0026lt;\u0026lt; \u0026gt;\u0026gt;\u0026gt; ) = WebSocket\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# Success\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026gt; POST /increment \u0026#39;{ value: 5 }\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt; 200 OK\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt;\u0026lt;\u0026lt; { event: \u0026#34;count\u0026#34;, value: 5 }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#- (the update message still gets sent to all connected clients)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e# Failure\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026gt; POST /decrement \u0026#39;{ value: 6 }\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026lt; 400 Bad Request\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e#- (no update gets sent because the request failed)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ve effectively ditched the transmitting side of the socket altogether and replaced it with HTTP, which means we’re now leaning on WebSockets to represent only one stream of data (the receiving side). As it turns out there’s other ways to do that don’t require the overhead of a full duplex connection. \u003cem\u003e(we’ll get into this later)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eIf you’re sending messages that don’t necessarily need to be acknowledged (like a heartbeat or keyboard inputs), then Websockets make a great fit. Hence the title of this post, you \u003cstrong\u003emight\u003c/strong\u003e not need Websockets.\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"you-have-to-manage-the-socket-lifecycle\"\u003eYou have to manage the socket lifecycle\u003c/h3\u003e\n\u003cp\u003eWhen you use WebSockets, you’re not just sending and receiving messages at will—your application also has to respond to the opening and closing of the connection. This means handling events like “open” and “close” (or “error”), deciding what to do during reconnect attempts, and cleaning up resources when the connection is no longer needed.\u003c/p\u003e\n\u003cp\u003eFor example, a basic lifecycle for a WebSocket in the browser might look like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"js\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e socket\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e WebSocket\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ewss://example.com/socket\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003esocket\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddEventListener\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eopen\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, () \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  console\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eSocket opened\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003esocket\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddEventListener\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, (\u003c/span\u003e\u003cspan\u003eevent\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  console\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eReceived message:\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eevent\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003esocket\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddEventListener\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, (\u003c/span\u003e\u003cspan\u003eerr\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  console\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eSocket error:\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eerr\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003esocket\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddEventListener\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eclose\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, () \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  console\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eSocket closed. Attempting to reconnect…\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // Potentially restart or schedule a new socket connection here\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn a typical application, you might need to restart a closed connection, buffer messages while the socket is down, and handle retries with exponential backoff. Ignoring any of these steps can lead to lost messages, clumsy user experiences, or lingering connections. By contrast, with a simpler request/response model like HTTP, the lifecycle is more straightforward: each request starts, completes (or fails), and then you move on.\u003c/p\u003e\n\u003cp\u003eThe extra complexity of a WebSocket’s lifecycle is one of the main reasons you might not need it—unless there’s absolutely no alternative to socket based messaging (partially demonstrated in the previous section), then you’re better off with a simpler communication pattern.\u003c/p\u003e\n\u003ch3 id=\"it-makes-your-server-code-more-complex\"\u003eIt makes your server code more complex\u003c/h3\u003e\n\u003cp\u003eWhen a new WebSocket connection is initiated, your server has to handle the HTTP “upgrade” request handshake. Instead of completing an ordinary request, the server checks for the special headers indicating a WebSocket handshake and then upgrades the connection from HTTP to a persistent socket. That means for every initial connection, the server must parse and validate WebSocket headers like “Sec-WebSocket-Key” and respond with the correct “Sec-WebSocket-Accept” header. (\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Sec-WebSocket-Key#websocket_opening_handshake\"\u003eMDN Reference\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eThe upgrade mechanism itself requires additional plumbing: you need to create a listener for the upgrade event on your server, confirm the request is valid, finalize the handshake, and then start broadcasting or receiving data. This not only adds more moving parts (compared to standard request/response flows) but also means comprehension of HTTP alone isn’t enough for debugging or troubleshooting—now you’re dealing with a specialized connection protocol.\u003c/p\u003e\n\u003cp\u003eIf you’re also dealing with similar request/response semantics as we’ve detailed above, it can introduce even more complexity since now your server code is written with the durable nature of sockets in mind, not the ephemeral nature of HTTP. Additionally, your application will need to manage all the edge cases: what if the client tries upgrading in an unsupported way? What if the handshake fails mid-stream or times out? What about partial data frames that need to be reassembled?\u003c/p\u003e\n\u003cp\u003eWhile libraries and frameworks do a really good job of hiding some of these details under the hood, all these potential points of failure point back to a single truth: if you don’t truly need the power of a bidirectional, always-on socket, the handshake cost and the expanded error states can overshadow any performance or real-time benefits.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eSo what’s the alternative?\u003c/p\u003e\n\u003cp\u003eWe touched on it very briefly in the previous sections, but if we can abstract away the transmitting side of the socket and only be left with a one-way stream of data on the receiving side, we can use a much simpler communication pattern.\u003c/p\u003e\n\u003ch2 id=\"http-streaming\"\u003eHTTP Streaming\u003c/h2\u003e\n\u003cp\u003eIf you look deeper into how HTTP works, you’ll find that it’s actually a protocol designed for streaming data. If it wasn’t, we couldn’t stream video without loading the entire file first, or load huge websites without downloading the whole page.\u003c/p\u003e\n\u003cp\u003eAs it turns out that data stream doesn’t have to be split up chunks of some large blob of data. We can use the same principle to represent any arbitrary stream of data, like the real time updates that we were leaning on WebSockets for.\u003c/p\u003e\n\u003cp\u003eHere’s an example in server-side JavaScript of how this would look using our counter example from before:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"js\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e counter\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e 0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e resolvers\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Set\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// this returns a promise that resolves when the next\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// value is available.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e nextValue\u003c/span\u003e\u003cspan\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Promise\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eresolve\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e resolvers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresolve\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// look up what an `async generator` is if you\u0026#39;re lost\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// looking at this syntax. explaining it is out of scope\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// for this post.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e valueGenerator\u003c/span\u003e\u003cspan\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // (this loop gets broken when the response stream is closed.)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  while\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    // every time we get the next value from the iterator,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    // we yield the return from an awaited promise that resolves\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    // when the next value is available.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    yield\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e nextValue\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e processCommand\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // this is what handles our \u0026#34;state updates\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  counter\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e nextCounterValue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // for each iterator (i.e. client that called `/stream`)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // that\u0026#39;s waiting on a value, we resolve the promise with\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // the new value\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  for\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e resolver\u003c/span\u003e\u003cspan\u003e of\u003c/span\u003e\u003cspan\u003e resolvers\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    resolver\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecounter\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    resolvers\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edelete\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresolver\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// this is the function that computes the next state\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// based on the command, and enforces any invariants\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// that we want to have on the state.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e nextCounterValue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  let\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e counter\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e ===\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    next\u003c/span\u003e\u003cspan\u003e +=\u003c/span\u003e\u003cspan\u003e command\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e ===\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003edecrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    next\u003c/span\u003e\u003cspan\u003e -=\u003c/span\u003e\u003cspan\u003e command\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003enext\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003e 0\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    throw\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Error\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecount cannot be negative\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// we use hono/express like syntax here, but you can\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// use any server framework you want.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/increment\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  try\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e req\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    processCommand\u003c/span\u003e\u003cspan\u003e({ type: \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, amount: \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e });\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eOK\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e400\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/decrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  try\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e req\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    processCommand\u003c/span\u003e\u003cspan\u003e({ type: \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003edecrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, amount: \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e });\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eOK\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e400\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/stream\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // We can create a stream from any async iterator, so\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // we can pass the generator function that yields counter\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // updates as they become available.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  const\u003c/span\u003e\u003cspan\u003e stream\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e ReadableStream\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalueGenerator\u003c/span\u003e\u003cspan\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estream\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can then use the Stream API on the browser side to read the data as it comes in, and update our UI according to whatever the server sends.\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"js\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e response\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/stream\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e reader\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e response\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egetReader\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e decoder\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e TextDecoder\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ewhile\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // wait for the next chunk of data\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // (will only come when a state update is made)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  const\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e reader\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eread\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // when the server is done sending data, we break out of the loop\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // decode the chunk since data gets encoded over the network\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  const\u003c/span\u003e\u003cspan\u003e chunk\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e decoder\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edecode\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // update the UI with the new state\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  updateUI\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003echunk\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this setup we’ve completely eliminated the need for WebSockets while still maintaining real-time updates between multiple clients!\u003c/p\u003e\n\u003ch3 id=\"bonus-making-it-easy-with-eventkit\"\u003eBonus: Making it easy with eventkit\u003c/h3\u003e\n\u003cp\u003eThis is a little bit of a shameless plug, but it’s my post so you’re just going to have to live with it.\u003c/p\u003e\n\u003cp\u003eI’ve been working on a library called \u003ca href=\"https://github.com/hntrl/eventkit\"\u003eeventkit\u003c/a\u003e that makes it easy to compose and observe asynchronous streams of data. If you’re familiar with the observable pattern or RxJS, it’s very similar but with better side effect management and built with generators.\u003c/p\u003e\n\u003cp\u003eTo harp on the counter example a little bit more, here’s how you could use eventkit to implement the same functionality:\u003c/p\u003e\n\u003cpre tabindex=\"0\" data-language=\"ts\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e// server.ts\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003eStream\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eAsyncObservable\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003eeventkit\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e counter\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e 0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e stateUpdates$\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Stream\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// when a new value is pushed into the stream,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// we update the counter\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003estateUpdates$\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esubscribe\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  counter\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e value\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e nextCounterValue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  let\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e counter\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e ===\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    next\u003c/span\u003e\u003cspan\u003e +=\u003c/span\u003e\u003cspan\u003e command\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ecommand\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e ===\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003edecrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    next\u003c/span\u003e\u003cspan\u003e -=\u003c/span\u003e\u003cspan\u003e command\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eamount\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003enext\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003e 0\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    throw\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Error\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecount cannot be negative\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/increment\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  try\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e req\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e nextCounterValue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      { type: \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, amount: \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    );\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    stateUpdates$\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enext\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eOK\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e400\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/decrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  try\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e req\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    const\u003c/span\u003e\u003cspan\u003e next\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e nextCounterValue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      { type: \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003edecrement\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, amount: \u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    );\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    stateUpdates$\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epush\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003enext\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003eOK\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e200\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  } \u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emessage\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e400\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eapp\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/stream\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, (\u003c/span\u003e\u003cspan\u003ereq\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eres\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // We can use the `Stream` class as an async iterator\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  // to create a stream from it in the exact same way.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  const\u003c/span\u003e\u003cspan\u003e stream\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e ReadableSteam\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estateUpdates$\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e Response\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estream\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e});\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre tabindex=\"0\" data-language=\"ts\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e// client.ts\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e { \u003c/span\u003e\u003cspan\u003eAsyncObservable\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u0026#34;\u003c/span\u003e\u003cspan\u003eeventkit\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e response\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await\u003c/span\u003e\u003cspan\u003e fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e/stream\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e decoder\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e new\u003c/span\u003e\u003cspan\u003e TextDecoder\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e counter$\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e AsyncObservable\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresponse\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ecounter$\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .\u003c/span\u003e\u003cspan\u003epipe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e decoder\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edecode\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)))\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  .\u003c/span\u003e\u003cspan\u003esubscribe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eupdateUI\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI learned about the capabilities of the Stream API while building it and think it’s a really good candidate for your next real-time/event-based application. If you say otherwise, please \u003ca href=\"https://github.com/hntrl/eventkit/issues\"\u003eopen an issue\u003c/a\u003e and tell me why.\u003c/p\u003e\n\u003cp\u003eI wouldn’t be a good project maintainer if I didn’t tell you to at least go \u003ca href=\"https://github.com/hntrl/eventkit?utm_source=hntrl\u0026amp;utm_campaign=ydnw\"\u003echeck it out\u003c/a\u003e. We also wrote a separate \u003ca href=\"https://hntrl.github.io/eventkit/guide/examples/http-streaming?utm_source=hntrl\u0026amp;utm_campaign=ydnw\"\u003eHTTP Streaming\u003c/a\u003e guide that goes a little bit deeper into this topic in case you’re interested.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eThanks for reading this wall of text! If you have any questions/comments, I’m around on \u003ca href=\"https://x.com/huntlovell\"\u003eX/Twitter\u003c/a\u003e. I also post more schizo ramblings on there, so I would appreciate the follow if that’s the sort of thing you’re into.\u003c/p\u003e  \u003cp\u003e(END)\u003c/p\u003e \u003c/article\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-04-11T00:00:00Z",
  "modifiedTime": null
}
