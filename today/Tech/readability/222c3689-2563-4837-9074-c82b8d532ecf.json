{
  "id": "222c3689-2563-4837-9074-c82b8d532ecf",
  "title": "Resizable Structs in Zig",
  "link": "https://tristanpemble.com/resizable-structs-in-zig/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 26 Jul 2025 21:43:57 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 10212,
  "excerpt": "July 26, 2025",
  "siteName": "",
  "favicon": "https://tristanpemble.com/apple-touch-icon.png",
  "text": "July 26, 2025In this post I will make the case for the concept of a “runtime resizable struct” in Zig. I will then design an API by exploiting Zig’s powerful comptime functionality.If you want to skip straight to the implementation, a minimal proof of concept is available as a package on GitHub.Arrays and many-item pointersZig has support for many kinds of collection types in its standard library. All of them can broadly be broken down to two primitive backing types for contiguous data storage:[N]T – arrays, when you always know the length at compile time.[*]T – many-item pointers, when you may not know the length at compile time.You may be wondering about slices. Slices can be thought of as syntax sugar around a many-item pointer and a length:// A desugared slice type const PersonSlice = struct { ptr: [*]Person, len: usize, }; Once you allocate the slice, you can’t grow or shrink its memory without reallocating. That’s why we have std.ArrayList, which is just a wrapper around a slice (itself sugar for many-item pointers) that provides helpers to manage reallocating that slice:// A naive ArrayList implementation const PersonList = struct { items: []Person, pub fn append(self: PersonArrayList, allocator: Allocator, person: Person) !void { self.items = try allocator.realloc(self.items, self.items.len + 1); self.items[self.items.len] = person; } }; We can build up lots of interesting collection types with these primitives, but at the end of the day, we have arrays, many-item pointers, and slices (which are just many-item pointers!). If the size is fixed at compile time, you’ll probably be working with arrays. If the size may be influenced by runtime values, you’ll probably be working with many-item pointers.StructsArrays/pointers work well for contiguous storage of the same type, but a struct can be thought of as contiguous collection of different types:const City = struct { name: []const u8, population: u32, area: f32, }; It has a compile time known number of values, they have a compile time known size, and as a result, the size of the struct is known at compile time.The problemLet’s break down the three tools I outlined above for contiguous storage:ToolElementsSizeArraysSameComptimeMany-item pointersSameRuntimeStructsDifferentComptime???DifferentRuntimeAt this point, you’ll notice a missing piece – what if we want to access contiguously stored data, with differing types, but the size/length of that data is only known at runtime?A use-caseIt’s fun to design tools for imaginary problems, but before we continue, is this really something that people need? I believe that it is. Here is a snippet of code in Zig’s standard library where such a thing might be useful.The status quoTo do this today, you essentially have to take the following steps:Calculate the size of the data you need to storeAllocate a []u8 to store it inBreak up that byte slice into pieces for each field using a lot of @ptrCast/@alignCastInitialize the data in each field, making sure to keep track of all runtime lengthsHere I have done so using a simplified version of the use-case from the standard library:// A known-size data structure const Connection = struct { client: Client, host_len: usize, read_buffer_len: usize, write_buffer_len: usize, }; // First, calculate the size of, and then allocate, a byte slice for the data const length = calculateSizeAtRuntime(input); const bytes = try gpa.alignedAlloc(u8, @alignOf(Connection), length); // Then break up that byte slice into its components const conn: *Connection = @ptrCast(bytes); const host_offset = @sizeOf(Connection); const host = bytes[host_offset..][0..input.host_len]; const read_buffer_offset = host_offset + input.host_len; const read_buffer = bytes[read_buffer_offset..][0..input.read_buffer_len]; const write_buffer_offset = read_buffer_offset + input.read_buffer_len; const write_buffer = bytes[write_buffer_offset..][0..input.write_buffer_len]; // Initialize the known-size data, storing runtime sizes conn.* = .{ .client = input.client, .host_len = input.host_len, .read_buffer_len = input.read_buffer_len, .write_buffer_len = input.write_buffer_len, }; // Initialize the runtime sized data @memcpy(host, input.host); Doing all of this correctly can be tricky. Even just the first step is more complex than you might think. In our example, the host and buffer fields are both arrays of u8s, but what if the elements have an alignment requirement? If your fields are not ordered correctly, subsequent fields may become unaligned if you don’t pad correctly. If you don’t track all of the lengths, you can accidentally introduce undefined behavior, and as a result, possible security vulnerabilities. Let alone resizing the thing if the lengths change later!We can do better!Variable Length ArraysAs an aside, some programming languages have a concept of variable length arrays (VLA). The idea is to have an array (stack allocated contiguous data) with a length that is known at runtime (it is variable).Zig does not, and will not, have VLAs in the language spec. Instead, you can allocate a slice on the heap. If you want to have the data on the stack, use an array as a bounded backing store, and work with a slice into it:// We have an upper limit of 32 values const my_buffer: [32]u64 = undefined; const my_vla: []u64 = my_buffer[0..runtime_length]; Dreaming up an APIVariable length arrays don’t, and won’t, exist in Zig, but what if they did? We might have defined our Connection type something like this:const Connection = struct { client: Client, host: VariableLengthArray(u8) read_buffer: VariableLengthArray(u8), write_buffer: VariableLengthArray(u8) }; Working with it would be a little easier, because we can just initialize the VLAs at runtime:const conn = Connection{ .client = input.client, .host = .initWithSlice(input.host), .read_buffer = .initWithCapacity(input.read_buffer_len), .write_buffer = .initWithCapacity(input.write_buffer_len), }; The VariableLengthArray type could handle the alignment of our data, and we can just focus on the data itself, accessing the fields directly:std.debug.print(\"Host: {s}\\n\", .{conn.host}); const reader = stream.reader(conn.read_buffer); const writer = stream.writer(conn.write_buffer); And yet, all of this data is stored contiguously in memory, without having to allocate each individual field separately!An implementationWe can actually achieve something sort of like this with some good ’ole Zig flavored comptime meta programming.We’ll define two structs: a ResizableArray(T), and a ResizableStruct(Layout) that uses them. The ResizableArray(T) will just be a marker type - such a thing, as far as I know, can’t actually exist in Zig. It’s used by the comptime code in ResizableStruct(Layout) to know which fields have runtime known lengths.The ResizableStruct(Layout) will act as a utility type that makes working with pointers to each field easier. We’d use it like this:const Connection = ResizableStruct(struct { client: Client, host: ResizableArray(u8) read_buffer: ResizableArray(u8), write_buffer: ResizableArray(u8) }); const conn = try Connection.init(allocator, .{ .host = input.host_len, .read_buffer = input.read_buffer_len, .write_buffer = input.write_buffer_len, }); defer conn.deinit(allocator); const client = conn.get(.client); client.* = input.client; const host = conn.get(.host); @memcpy(host, input.host); const reader = stream.reader(conn.get(.read_buffer)); const writer = stream.writer(conn.get(.write_buffer)); // We can resize the arrays later; this invalidates the above pointers. conn.resize(.{ .host = 123, .read_buffer = 456, .write_buffer = 789, }); The Connection becomes a utility type. It’s kind of like a Slice, or an ArrayList. It can be passed around, stored in arrays, and can be resized at runtime. The only information it needs to store is a pointer to the start of the data, and the lengths of each array. The backing implementation looks like this:const Connection = struct { ptr: [*]u8, lens: struct { host: usize, read_buffer: usize, write_buffer: usize, } } The only cost is four usizes! This works because we are able to use comptime magic to get the size of each field. Let’s take a look at the current implementation of the get method:pub fn get(self: Self, comptime field: FieldEnum(Layout)) blk: { const Field = @FieldType(Layout, @tagName(field)); break :blk if (isResizableArray(Field)) []Field.Element else *Field; } { const offset = offsetOf(self.lens, @tagName(field)); const size = sizeOf(self.lens, @tagName(field)); const bytes = self.ptr[offset..][0..size]; return @ptrCast(@alignCast(bytes)); } Look familiar? This is the same basic pattern used in the example use-case when we broke up the byte array. The comptime magic comes in by examining ResizableArray. First, we can easily check if a field is resizable with a little helper function:pub fn ResizableArray(comptime T: type) type { return struct { pub const Element = T; }; } fn isResizableArray(comptime T: type) bool { return @typeInfo(T) == .@\"struct\" and @hasDecl(T, \"Element\") and T == ResizableArray(T.Element); } Once we know FieldType is a ResizableArray(T), we can then safely access FieldType.Element. With the array element types and the self.lens struct, we now have everything we need to calculate the size, offset and alignment of every field, regardless of their positioning in the struct.I have published a minimal implementation of this API as a package on GitHub, and you can use it today. The API docs are on GitHub pages as well, but they can be boiled down to four methods:init to allocate the memoryget to get a pointer to a fieldresize to resize the arraysdeinit to free the memoryRequest for feedbackI think this, or something like it, would be a valuable addition to Zig’s standard library, but it needs scrutiny. If you have a real world use-case for this type, I would love to hear about it. If you can think of enhancements to the API, feel free to open an issue on GitHub.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ctime datetime=\"2025-07-26T00:00:00+00:00\"\u003eJuly 26, 2025\u003c/time\u003e\u003c/p\u003e\u003cp\u003eIn this post I will make the case for the concept of a “runtime resizable struct” in Zig. I will then design an API by exploiting Zig’s powerful comptime functionality.\u003c/p\u003e\u003cp\u003eIf you want to skip straight to the implementation, a minimal proof of concept is \u003ca href=\"https://github.com/tristanpemble/resizable-struct\"\u003eavailable as a package on GitHub\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"arrays-and-many-item-pointers\"\u003e\u003ca aria-label=\"Anchor link for: arrays-and-many-item-pointers\" href=\"#arrays-and-many-item-pointers\"\u003eArrays and many-item pointers\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eZig has support for many kinds of collection types in its standard library. All of them can broadly be broken down to two primitive backing types for contiguous data storage:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e[N]T\u003c/code\u003e – \u003ca href=\"https://ziglang.org/documentation/master/#Arrays\"\u003earrays\u003c/a\u003e, when you \u003cem\u003ealways\u003c/em\u003e know the length at compile time.\u003c/li\u003e\u003cli\u003e\u003ccode\u003e[*]T\u003c/code\u003e – \u003ca href=\"https://ziglang.org/documentation/master/#toc-Pointers\"\u003emany-item pointers\u003c/a\u003e, when you \u003cem\u003emay not\u003c/em\u003e know the length at compile time.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYou may be wondering about slices. \u003ca href=\"https://ziglang.org/documentation/master/#Slices\"\u003eSlices\u003c/a\u003e can be thought of as syntax sugar around a many-item pointer and a length:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003e// A desugared slice type\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003ePersonSlice \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eptr\u003c/span\u003e\u003cspan\u003e: [\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elen\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce you allocate the slice, you can’t grow or shrink its memory without reallocating. That’s why we have \u003ca href=\"https://ziglang.org/documentation/master/#std.ArrayList\"\u003e\u003ccode\u003estd.ArrayList\u003c/code\u003e\u003c/a\u003e, which is just a wrapper around a slice (itself sugar for many-item pointers) that provides helpers to manage reallocating that slice:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003e// A naive ArrayList implementation\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003ePersonList \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eitems\u003c/span\u003e\u003cspan\u003e: []\u003c/span\u003e\u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003epub fn \u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ePersonArrayList\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eallocator\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eAllocator\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eperson\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003e!void \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e        self.items \u003c/span\u003e\u003cspan\u003e= try\u003c/span\u003e\u003cspan\u003e allocator.\u003c/span\u003e\u003cspan\u003erealloc\u003c/span\u003e\u003cspan\u003e(self.items, self.items.len \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e);\n\u003c/span\u003e\u003cspan\u003e        self.items[self.items.len] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e person;\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe can build up lots of interesting collection types with these primitives, but at the end of the day, we have \u003cstrong\u003earrays\u003c/strong\u003e, \u003cstrong\u003emany-item pointers\u003c/strong\u003e, and \u003cstrong\u003eslices\u003c/strong\u003e (which are just many-item pointers!). If the size is fixed at compile time, you’ll probably be working with arrays. If the size may be influenced by runtime values, you’ll probably be working with many-item pointers.\u003c/p\u003e\u003ch2 id=\"structs\"\u003e\u003ca aria-label=\"Anchor link for: structs\" href=\"#structs\"\u003eStructs\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eArrays/pointers work well for contiguous storage of the \u003cstrong\u003esame\u003c/strong\u003e type, but a \u003ca href=\"https://ziglang.org/documentation/master/#struct\"\u003estruct\u003c/a\u003e can be thought of as contiguous collection of \u003cstrong\u003edifferent\u003c/strong\u003e types:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eCity \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ename\u003c/span\u003e\u003cspan\u003e: []\u003c/span\u003e\u003cspan\u003econst u8\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003epopulation\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eu32\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003earea\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ef32\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt has a compile time known number of values, they have a compile time known size, and as a result, the size of the struct is known at compile time.\u003c/p\u003e\u003ch2 id=\"the-problem\"\u003e\u003ca aria-label=\"Anchor link for: the-problem\" href=\"#the-problem\"\u003eThe problem\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eLet’s break down the three tools I outlined above for contiguous storage:\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eTool\u003c/th\u003e\u003cth\u003eElements\u003c/th\u003e\u003cth\u003eSize\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eArrays\u003c/td\u003e\u003ctd\u003eSame\u003c/td\u003e\u003ctd\u003eComptime\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eMany-item pointers\u003c/td\u003e\u003ctd\u003eSame\u003c/td\u003e\u003ctd\u003eRuntime\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eStructs\u003c/td\u003e\u003ctd\u003eDifferent\u003c/td\u003e\u003ctd\u003eComptime\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e???\u003c/td\u003e\u003ctd\u003eDifferent\u003c/td\u003e\u003ctd\u003eRuntime\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eAt this point, you’ll notice a missing piece – what if we want to access contiguously stored data, with differing types, but the size/length of that data is only known at runtime?\u003c/p\u003e\u003ch2 id=\"a-use-case\"\u003e\u003ca aria-label=\"Anchor link for: a-use-case\" href=\"#a-use-case\"\u003eA use-case\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eIt’s fun to design tools for imaginary problems, but before we continue, is this really something that people need? I believe that it is. \u003ca href=\"https://github.com/ziglang/zig/blob/8c4482ed78fb651c0288f0cd2bdaf328564c6a49/lib/std/http/Client.zig#L240-L359\"\u003eHere is a snippet of code\u003c/a\u003e in Zig’s standard library where such a thing might be useful.\u003c/p\u003e\u003ch2 id=\"the-status-quo\"\u003e\u003ca aria-label=\"Anchor link for: the-status-quo\" href=\"#the-status-quo\"\u003eThe status quo\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eTo do this today, you essentially have to take the following steps:\u003c/p\u003e\u003col\u003e\u003cli\u003eCalculate the size of the data you need to store\u003c/li\u003e\u003cli\u003eAllocate a \u003ccode\u003e[]u8\u003c/code\u003e to store it in\u003c/li\u003e\u003cli\u003eBreak up that byte slice into pieces for each field using a lot of \u003ccode\u003e@ptrCast\u003c/code\u003e/\u003ccode\u003e@alignCast\u003c/code\u003e\u003c/li\u003e\u003cli\u003eInitialize the data in each field, making sure to keep track of all runtime lengths\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eHere I have done so using a simplified version of the use-case from the standard library:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003e// A known-size data structure\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eConnection \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eClient\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ehost_len\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eread_buffer_len\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewrite_buffer_len\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e// First, calculate the size of, and then allocate, a byte slice for the data\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e length \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003ecalculateSizeAtRuntime\u003c/span\u003e\u003cspan\u003e(input);\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e bytes \u003c/span\u003e\u003cspan\u003e= try\u003c/span\u003e\u003cspan\u003e gpa.\u003c/span\u003e\u003cspan\u003ealignedAlloc\u003c/span\u003e\u003cspan\u003e(u8, \u003c/span\u003e\u003cspan\u003e@alignOf\u003c/span\u003e\u003cspan\u003e(Connection), length);\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e// Then break up that byte slice into its components\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003econn\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e*Connection = \u003c/span\u003e\u003cspan\u003e@ptrCast\u003c/span\u003e\u003cspan\u003e(bytes);\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e host_offset \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e@sizeOf\u003c/span\u003e\u003cspan\u003e(Connection);\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e host \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e bytes[host_offset\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e][0\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003einput.host_len];\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e read_buffer_offset \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e host_offset \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e input.host_len;\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e read_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e bytes[read_buffer_offset\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e][0\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003einput.read_buffer_len];\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e write_buffer_offset \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e read_buffer_offset \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e input.read_buffer_len;\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e write_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e bytes[write_buffer_offset\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e][0\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003einput.write_buffer_len];\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e// Initialize the known-size data, storing runtime sizes\n\u003c/span\u003e\u003cspan\u003econn\u003c/span\u003e\u003cspan\u003e.* =\u003c/span\u003e\u003cspan\u003e .{\n\u003c/span\u003e\u003cspan\u003e    .client \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.client,\n\u003c/span\u003e\u003cspan\u003e    .host_len \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.host_len,\n\u003c/span\u003e\u003cspan\u003e    .read_buffer_len \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.read_buffer_len,\n\u003c/span\u003e\u003cspan\u003e    .write_buffer_len \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.write_buffer_len,\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e// Initialize the runtime sized data\n\u003c/span\u003e\u003cspan\u003e@memcpy\u003c/span\u003e\u003cspan\u003e(host, input.host);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eDoing all of this correctly can be tricky. Even just the first step is more complex than you might think. In our example, the host and buffer fields are both arrays of \u003ccode\u003eu8\u003c/code\u003es, but what if the elements have an alignment requirement? If your fields are not ordered correctly, subsequent fields may become unaligned if you don’t pad correctly. If you don’t track all of the lengths, you can accidentally introduce undefined behavior, and as a result, possible security vulnerabilities. Let alone resizing the thing if the lengths change later!\u003c/p\u003e\u003cp\u003eWe can do better!\u003c/p\u003e\u003ch2 id=\"variable-length-arrays\"\u003e\u003ca aria-label=\"Anchor link for: variable-length-arrays\" href=\"#variable-length-arrays\"\u003eVariable Length Arrays\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eAs an aside, some programming languages have a concept of \u003cstrong\u003evariable length arrays\u003c/strong\u003e (VLA). The idea is to have an array (stack allocated contiguous data) with a length that is known at runtime (it is variable).\u003c/p\u003e\u003cp\u003eZig does not, \u003ca href=\"https://github.com/ziglang/zig/issues/3952#issuecomment-568074491\"\u003eand will not\u003c/a\u003e, have VLAs in the language spec. Instead, you can allocate a slice on the heap. If you want to have the data on the stack, use an array as a bounded backing store, and work with a slice into it:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003e// We have an upper limit of 32 values\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003emy_buffer\u003c/span\u003e\u003cspan\u003e: [\u003c/span\u003e\u003cspan\u003e32\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003eu64 = \u003c/span\u003e\u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e;\n\u003c/span\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003emy_vla\u003c/span\u003e\u003cspan\u003e: []\u003c/span\u003e\u003cspan\u003eu64 =\u003c/span\u003e\u003cspan\u003e my_buffer[0\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003eruntime_length];\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"dreaming-up-an-api\"\u003e\u003ca aria-label=\"Anchor link for: dreaming-up-an-api\" href=\"#dreaming-up-an-api\"\u003eDreaming up an API\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eVariable length arrays don’t, and won’t, exist in Zig, but what if they did? We might have defined our \u003ccode\u003eConnection\u003c/code\u003e type something like this:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eConnection \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eClient\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ehost\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eVariableLengthArray\u003c/span\u003e\u003cspan\u003e(u8)\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eread_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eVariableLengthArray\u003c/span\u003e\u003cspan\u003e(u8),\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewrite_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eVariableLengthArray\u003c/span\u003e\u003cspan\u003e(u8)\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWorking with it would be a little easier, because we can just initialize the VLAs at runtime:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e conn \u003c/span\u003e\u003cspan\u003e= Connection\u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    .client \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.client,\n\u003c/span\u003e\u003cspan\u003e    .host \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e .\u003c/span\u003e\u003cspan\u003einitWithSlice\u003c/span\u003e\u003cspan\u003e(input.host),\n\u003c/span\u003e\u003cspan\u003e    .read_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e .\u003c/span\u003e\u003cspan\u003einitWithCapacity\u003c/span\u003e\u003cspan\u003e(input.read_buffer_len),\n\u003c/span\u003e\u003cspan\u003e    .write_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e .\u003c/span\u003e\u003cspan\u003einitWithCapacity\u003c/span\u003e\u003cspan\u003e(input.write_buffer_len),\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe VariableLengthArray type could handle the alignment of our data, and we can just focus on the data itself, accessing the fields directly:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003estd.debug.\u003c/span\u003e\u003cspan\u003eprint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Host: {s}\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e, .{conn.host});\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e reader \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e stream.\u003c/span\u003e\u003cspan\u003ereader\u003c/span\u003e\u003cspan\u003e(conn.read_buffer);\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e writer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e stream.\u003c/span\u003e\u003cspan\u003ewriter\u003c/span\u003e\u003cspan\u003e(conn.write_buffer);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd yet, all of this data is stored contiguously in memory, without having to allocate each individual field separately!\u003c/p\u003e\u003ch2 id=\"an-implementation\"\u003e\u003ca aria-label=\"Anchor link for: an-implementation\" href=\"#an-implementation\"\u003eAn implementation\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eWe can actually achieve something sort of like this with some good ’ole Zig flavored comptime meta programming.\u003c/p\u003e\u003cp\u003eWe’ll define two structs: a \u003ccode\u003eResizableArray(T)\u003c/code\u003e, and a \u003ccode\u003eResizableStruct(Layout)\u003c/code\u003e that uses them. The \u003ccode\u003eResizableArray(T)\u003c/code\u003e will just be a marker type - such a thing, as far as I know, can’t actually exist in Zig. It’s used by the comptime code in \u003ccode\u003eResizableStruct(Layout)\u003c/code\u003e to know which fields have runtime known lengths.\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eResizableStruct(Layout)\u003c/code\u003e will act as a utility type that makes working with pointers to each field easier. We’d use it like this:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e Connection \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eResizableStruct\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eClient\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ehost\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eResizableArray\u003c/span\u003e\u003cspan\u003e(u8)\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eread_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eResizableArray\u003c/span\u003e\u003cspan\u003e(u8),\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewrite_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eResizableArray\u003c/span\u003e\u003cspan\u003e(u8)\n\u003c/span\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e conn \u003c/span\u003e\u003cspan\u003e= try\u003c/span\u003e\u003cspan\u003e Connection.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(allocator, .{\n\u003c/span\u003e\u003cspan\u003e    .host \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.host_len,\n\u003c/span\u003e\u003cspan\u003e    .read_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.read_buffer_len,\n\u003c/span\u003e\u003cspan\u003e    .write_buffer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e input.write_buffer_len,\n\u003c/span\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003cspan\u003edefer\u003c/span\u003e\u003cspan\u003e conn.\u003c/span\u003e\u003cspan\u003edeinit\u003c/span\u003e\u003cspan\u003e(allocator);\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e client \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e conn.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(.client);\n\u003c/span\u003e\u003cspan\u003eclient\u003c/span\u003e\u003cspan\u003e.* =\u003c/span\u003e\u003cspan\u003e input.client;\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e host \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e conn.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(.host);\n\u003c/span\u003e\u003cspan\u003e@memcpy\u003c/span\u003e\u003cspan\u003e(host, input.host);\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e reader \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e stream.\u003c/span\u003e\u003cspan\u003ereader\u003c/span\u003e\u003cspan\u003e(conn.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(.read_buffer));\n\u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e writer \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e stream.\u003c/span\u003e\u003cspan\u003ewriter\u003c/span\u003e\u003cspan\u003e(conn.\u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(.write_buffer));\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e// We can resize the arrays later; this invalidates the above pointers.\n\u003c/span\u003e\u003cspan\u003econn.\u003c/span\u003e\u003cspan\u003eresize\u003c/span\u003e\u003cspan\u003e(.{\n\u003c/span\u003e\u003cspan\u003e    .host \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e123\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    .read_buffer \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e456\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    .write_buffer \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e789\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e});\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe \u003ccode\u003eConnection\u003c/code\u003e becomes a utility type. It’s kind of like a \u003ccode\u003eSlice\u003c/code\u003e, or an \u003ccode\u003eArrayList\u003c/code\u003e. It can be passed around, stored in arrays, and can be resized at runtime. The only information it needs to store is a pointer to the start of the data, and the lengths of each array. The backing implementation looks like this:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003econst \u003c/span\u003e\u003cspan\u003eConnection \u003c/span\u003e\u003cspan\u003e= struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eptr\u003c/span\u003e\u003cspan\u003e: [\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003eu8\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003elens\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ehost\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eread_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ewrite_buffer\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eusize\u003c/span\u003e\u003cspan\u003e,\n\u003c/span\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe only cost is four \u003ccode\u003eusize\u003c/code\u003es! This works because we are able to use comptime magic to get the size of each field. Let’s take a look at the current implementation of the \u003ccode\u003eget\u003c/code\u003e method:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003epub fn \u003c/span\u003e\u003cspan\u003eget\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eSelf\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003ecomptime \u003c/span\u003e\u003cspan\u003efield\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003eFieldEnum\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eLayout\u003c/span\u003e\u003cspan\u003e)) blk: {\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e Field \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e@FieldType\u003c/span\u003e\u003cspan\u003e(Layout, \u003c/span\u003e\u003cspan\u003e@tagName\u003c/span\u003e\u003cspan\u003e(field));\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ebreak\u003c/span\u003e\u003cspan\u003e :blk \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eisResizableArray\u003c/span\u003e\u003cspan\u003e(Field)) []Field.Element \u003c/span\u003e\u003cspan\u003eelse *\u003c/span\u003e\u003cspan\u003eField;\n\u003c/span\u003e\u003cspan\u003e} {\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e offset \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003eoffsetOf\u003c/span\u003e\u003cspan\u003e(self.lens, \u003c/span\u003e\u003cspan\u003e@tagName\u003c/span\u003e\u003cspan\u003e(field));\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e size \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003esizeOf\u003c/span\u003e\u003cspan\u003e(self.lens, \u003c/span\u003e\u003cspan\u003e@tagName\u003c/span\u003e\u003cspan\u003e(field));\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003econst\u003c/span\u003e\u003cspan\u003e bytes \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e self.ptr[offset\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003e][0\u003c/span\u003e\u003cspan\u003e..\u003c/span\u003e\u003cspan\u003esize];\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e@ptrCast\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e@alignCast\u003c/span\u003e\u003cspan\u003e(bytes));\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLook familiar? This is the same basic pattern used in the example use-case when we broke up the byte array. The comptime magic comes in by examining \u003ccode\u003eResizableArray\u003c/code\u003e. First, we can easily check if a field is resizable with a little helper function:\u003c/p\u003e\u003cpre data-lang=\"zig\"\u003e\u003ccode data-lang=\"zig\"\u003e\u003cspan\u003epub fn \u003c/span\u003e\u003cspan\u003eResizableArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomptime \u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003etype \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn struct \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003epub const\u003c/span\u003e\u003cspan\u003e Element \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e T;\n\u003c/span\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003efn \u003c/span\u003e\u003cspan\u003eisResizableArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomptime \u003c/span\u003e\u003cspan\u003eT\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003etype\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003ebool \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ereturn \u003c/span\u003e\u003cspan\u003e@typeInfo\u003c/span\u003e\u003cspan\u003e(T) \u003c/span\u003e\u003cspan\u003e==\u003c/span\u003e\u003cspan\u003e .@\u0026#34;struct\u0026#34; \u003c/span\u003e\u003cspan\u003eand\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e@hasDecl\u003c/span\u003e\u003cspan\u003e(T, \u003c/span\u003e\u003cspan\u003e\u0026#34;Element\u0026#34;\u003c/span\u003e\u003cspan\u003e) \u003c/span\u003e\u003cspan\u003eand\n\u003c/span\u003e\u003cspan\u003e        T \u003c/span\u003e\u003cspan\u003e== \u003c/span\u003e\u003cspan\u003eResizableArray\u003c/span\u003e\u003cspan\u003e(T.Element);\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce we know \u003ccode\u003eFieldType\u003c/code\u003e is a \u003ccode\u003eResizableArray(T)\u003c/code\u003e, we can then safely access \u003ccode\u003eFieldType.Element\u003c/code\u003e. With the array element types and the \u003ccode\u003eself.lens\u003c/code\u003e struct, we now have everything we need to calculate the size, offset and alignment of every field, regardless of their positioning in the struct.\u003c/p\u003e\u003cp\u003eI have published a minimal implementation of this API as a package \u003ca href=\"https://github.com/tristanpemble/resizable-struct\"\u003eon GitHub\u003c/a\u003e, and you can use it today. The API docs are on \u003ca href=\"https://tristanpemble.github.io/resizable-struct/\"\u003eGitHub pages\u003c/a\u003e as well, but they can be boiled down to four methods:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003einit\u003c/code\u003e to allocate the memory\u003c/li\u003e\u003cli\u003e\u003ccode\u003eget\u003c/code\u003e to get a pointer to a field\u003c/li\u003e\u003cli\u003e\u003ccode\u003eresize\u003c/code\u003e to resize the arrays\u003c/li\u003e\u003cli\u003e\u003ccode\u003edeinit\u003c/code\u003e to free the memory\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"request-for-feedback\"\u003e\u003ca aria-label=\"Anchor link for: request-for-feedback\" href=\"#request-for-feedback\"\u003eRequest for feedback\u003c/a\u003e\u003c/h2\u003e\u003cp\u003eI think this, or something like it, would be a valuable addition to Zig’s standard library, but it needs scrutiny. If you have a real world use-case for this type, I would love to hear about it. If you can think of enhancements to the API, feel free to open an issue on GitHub.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": null,
  "modifiedTime": null
}
