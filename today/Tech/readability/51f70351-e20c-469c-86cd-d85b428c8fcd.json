{
  "id": "51f70351-e20c-469c-86cd-d85b428c8fcd",
  "title": "The borrowchecker is what I like the least about Rust",
  "link": "https://viralinstruction.com/posts/borrowchecker/",
  "description": "Comments",
  "author": "",
  "published": "Sat, 19 Jul 2025 19:27:50 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 20868,
  "excerpt": "Written 2025-07-18",
  "siteName": "",
  "favicon": "",
  "text": "Written 2025-07-18 Among the 2010's cohort of programming languages, Rust is probably the most widely lauded. The main selling point of Rust is that it manages to combine speed and low-level control with a high level of bug-resistance, more commonly referred to as safety. The main innovation of Rust - really, its claim to fame - is its borrowchecker: the part of its compiler that enforces Rust's ownership rules and thereby allows Rust to achieve all the memory safety that garbage collected language enjoy, but with zero runtime cost. The evangelists proponents of Rust have made memory safety the central selling point of Rust, to the extent that the borrowchecker has become the defining feature of Rust's identity. I think the conflation of Rust's safety with the borrowchecker's guarantees is somewhat misguided. In this post, I want to make two arguments: That the borrowchecker causes serious ergonomic problems for Rust. That the role of the borrowchecker in Rust's safety is overstated. The fundamental problem of the borrowchecker In a nutshell, the problem with Rust's borrowchecker is that it makes references a pain in the ass. On an abstract level, the reason for the pain is that the borrowchecker needs to know the lifetimes of all references at compile time, and this is simply an unrealistic proposal. Lifetimes are often an inherently runtime property. On an algorithmic level, the borrowchecker enforces a specific model, or set of rules around ownership, but this model is overly restrictive, and degrade Rust's ergonomics by rejecting far too many well-behaving programs. At the implementation level, the borrowchecker's current instantiation is incomplete, and often rejects programs that adhere to the model of ownership, even as that model is too restrictive in the first place. Borrowchecker frustration is like being brokenhearted - you can't easily demonstrate it, you have to suffer it yourself to understand what people are talking about. Real borrowchecker pain is not felt when your small, 20-line demonstration snippet fails to compile. It's when your existing project requires a small modification to ownership structure, and the borrowchecker then refuses to compile your code. Then, once you pull at the tiny loose fiber in your code's fabric, you find you have to unspool half your code before the borrowchecker is satisfied. Nonetheless, tiny examples can still serve to demonstrate the borrowchecker's propensity to reject perfectly fine code. Examples where the borrowchecker fails The most clear examples are when the borrowchecker simply doesn't do what it's supposed to, because it rejects code that doesn't even violate the spirit of Rust's ownership rules. For example, consider this code I got from a blog post: struct Point { x: f64, y: f64, } impl Point { fn x_mut(\u0026mut self) -\u003e \u0026mut f64 { \u0026mut self.x } fn y_mut(\u0026mut self) -\u003e \u0026mut f64 { \u0026mut self.y } } fn main() { let mut point = Point { x: 1.0, y: 2.0 }; let x_ref = point.x_mut(); let y_ref = point.y_mut(); *x_ref *= 2.0; *y_ref *= 2.0; } This code won't compile, because the two mutable references x_ref and y_ref needs to exist simultaenously, which violates Rust's principle that a mutable reference to some data needs to unique at any point. Of course, this case is a false positive, since the references point to distinct fields of the same struct, and therefore don't refer to the same data. The borrowchecker rejects this code because the underlying rule of of the borrowchecker - namely: \"Mutation requires exclusivity\" is implemented imprecisely, such that the naunce between a reference to a field and a reference to a struct is lost. A similar, but slightly different example occurs in the code below struct Collection { counter: u32, items: Vec\u003cu32\u003e, } impl Collection { fn increment_counter(\u0026mut self) { self.counter += 1; } pub fn count_items(\u0026mut self) { for _ in \u0026self.items { self.increment_counter(); } } } To the human reader, it's clear that increment_counter doesn't mutate self.items, and therefore cannot interfere with looping over the vector. Therefore, the of the borrowchecker: \"Mutation requires exclusivity\" is not violated, and the code should compile fine. Unfortunately, the borrowchecker can't reason across functions, and therefore incorrectly rejects the function. The borrowchecker is not only overly conservative when checking loans across functions; it can't even reason well about control flow within a function. The following example is a famous illustration of how it can't properly reason across branches, either: fn get_default\u003c'r, K: Hash + Eq + Copy, V: Default\u003e( map: \u0026'r mut HashMap\u003cK, V\u003e, key: K, ) -\u003e \u0026'r mut V { match map.get_mut(\u0026key) { Some(value) =\u003e value, None =\u003e { map.insert(key, V::default()); map.get_mut(\u0026key).unwrap() } } } This is rejected due to the two mutable references, despite the program logic guaranteeing that the second reference is only created in the None branch, where the first reference is no longer live. There are more such unnecessary limitations of the borrowchecker. A 'sufficiently smart borrowchecker' At this point, an Rust apologist might point out that, precisely because the above examples are implementation limitations, they are not fundamental, and might be lifted in the future as the implementation improves. There is some merit to the hope: Rust adopted so called non-lexical lifetimes in 2022, which did improve the borrowchecker's accuracy. Similarly, a new formulation of the borrowchecker, called Polonius is in the works, which will improve accuracy still further. I remain sceptical. Polonius has been in the works for seven years now, and doesn't seem to be close to completion. More fundamentally, the borrowchecker will never be 'complete', because its job is to reason about your code, and programs just can't do that on level that is sufficiently deep. There is an obvious parallel with the mythical 'sufficiently smart compiler' - just like compilers continuously improve, and yet never seem to really understand your code, and rarely are able to rewrite it on an algoritmic level, the borrowchecker will probably always reject seemingly obviously correct code. The rules themselves are unergonomical Above, I demonstrated limitations in the implementation of the abstract ownership model. However, sometimes the model itself is just wrong for your program. Consider: struct Id(u32); fn main() { let id = Id(5); let mut v = vec![id]; println!(\"{}\", id.0); } This is a clear-cut violation of the ownership rules: After v is constructed, id is moved into v, which prevents the function main from using id on the last line. There is a sense, then, in which the borrowchecker - in any implementation - ought to reject the program. It does fail the ownership rules. But what's the point of the rules in this case, though? Here, the ownership rules does not prevent use after free, or double free, or data races, or any other bug. It's perfectly clear to a human that this code is fine and doesn't have any actual ownership issues. But the borrowchecker, being a program, is very hard to negotiate with and dissuade from overly pedantic enforcement of a rigid, though in this case, pointless, set of rules. In the above case, the pedanticness doesn't matter much because the workaround is easy. But my experience has been regularly hitting these fundamental problems where the ownership model does not correspond to the needs of my program. For example: References to temporary values, e.g. values created in a closure, are forbidden even though it's obvious to a human that the solution is simply to extend the lifetime of the value to its use outside the closure. Struct withs mixed ownership: You can't have a struct with a field that contains a Vec\u003cThing\u003e of things, which then also stores groups of the same things in another field in a Vec\u003cVec\u003c\u0026Thing\u003e\u003e. Phylogenetic trees are a massive pain to implement, because each node having bidirectional references is fundamentally in conflict with Rust's concept that data has exactly one owner. It's hard to overstate how much these problems just are not a thing in garbage collected languages, but purely self-inflicted by Rust's borrowchecker. You want to build a tree with bidirectional references in Python? Just do the obvious thing, and it works perfectly. It's possible to do in Rust, but it's terribly complicated[1]. A common defense of Rust are that the pain Rust's borrowchecker inflicts on you is not excess pain, but rather upfront pain. The talking point goes: You have a program with a complicated ownership structure, and Rust merely forces you to be explicit about this. In doing so, it guarantees memory safety - and wouldn't you rather deal with compiler errors than production crashes? But that hasn't been my experience. My experience has been that borrowchecker problems are mostly just bullshit - invented problems without real grounding. For every time I experience a bug in Python that would have been prevented in Rust by its borrowchecker, I experience maybe twenty borrowchecker issues. Another common claim is that this kind of borrowchecker frustration is merely a beginner's struggle. Once you internalize the ownership model of Rust, you will automatically structure your code to conform to the borrowchecker, making all the problems go away. Unfortunately, after using Rust intermittently for a few years, this hasn't been my experience yet, and it seems I'm not alone. Why don't you just... My examples code above may not be persuasive to experienced Rustaceans. They might argue that the snippets don't show there is any real ergonomic problem, because the solutions to make the snippets compile are completely trivial. In the last example, I could just derive Clone + Copy for Id. I know. The commonality of these stumbling blocks is that you can jump over them. You can, indeed, do extra work to fix whatever borrowchecker problems you have. The issue is that there was never a problem to begin with to warrant this extra work. Rust gates your perfectly functional code behind a lifetime puzzle, and forces you to refactor until you've solved it. Rust insists your program's structure is a house of cards - touch one tiny thing, and large parts of it has to scrapped and rebuilt. The more Rust experience I gain, the more I suspect that is usually plain wrong. For most borrowchecker issues I face, the problem is not my program's structure, but the largely arbitrary restrictions of Rust. And sure, in the snippets above, the solution to the borrowchecker problems are trivial, but in larger-scale, real life code, they can be a real challenge. Perversely, because Rust's lifetime riddles are challenging, they are sort of fun. I believe that partly explains why so many people don't seem to mind them. Instead of thinking about how to write my code to solve the scientific problems I'm being paid to solve, I have to think about how to write it to please the borrowchecker. The latter is usually more tractable, limited in scope, have clearer requirements and is more 'puzzle-like'. In that sense, Rust enables escapism: When writing Rust, you get to solve lots of 'problems' - not real problems, mind you, but fun problems. The usual way of obeying the borrowchecker is to refactor your code. Which is already unwelcome extra work, but sometimes even that is not enough. Let's look at some other ways people usually recommend me solving borrowchecker problems: Use fewer references and copy data. Or: \"Just clone\". This is generally good advice. Usually, extra allocations are fine, and the resulting performance degradation is not an issue. But it is a little strange that it allocations are encouraged in an otherwise performance-forcused language, not because the program logic demands it, but because the borrowchecker does. Of course, sometimes cloning doesn't solve the issue, because you really do need to mutate shared objects. Rc / Arc / RefCell / Box spam Rust's Arc type disables some of Rust's ownership rules of the object it wraps, and instead reference counts that specific object. That means sometimes, the borrowchecker can be appeased by slapping Arc on a bunch of data throughout your program. Or, as I also like to call it \"managing the world's worst garbage collector, but with none of the convenience or performance\". To be fair, adding a few selective Arcs or RefCells are not a performance problem. It becomes a problem when these are used extensively to skirt around the borrowchecker, e.g. for every single node in a big graph. Use indices instead of references When I first tried implementing a bidirected graph in Rust, I was suggested this pattern. A bidirected graph's edges can be represented by referencing the vertices by an integer ID, instead of an actual reference. Since you don't use references this way, you don't get any issues with the borrowchecker. The first time someone gave be this advice, I had to do a double take. The Rust community's whole thing is commitment to compiler-enforced correctness, and they built the borrowchecker on the premise that humans can't be trusted to handle references manually. When the same borrowchecker makes references unworkable, their solution is to... recommend that I manually manage them, with zero safety and zero language support?!? The irony is unreal. Asking people to manually manage references is so hilariously unsafe and unergonomic, the suggestion would be funny if it wasn't mostly sad. Rust's safety is only partly due to the borrowchecker In online discourse, Rust's safety is sometimes equated with its memory safety in particular, which is attributed to the borrowchecker. Rust's reputation for bug-resistance is deserved, I think, but I believe it's due to Rust's broadly good taste and solid design. Like performance, correctness dies by a thousand cuts, and Rust is notable for being consistently correctness-focused: Its widespread use of enums plus exhaustive pattern matches, including for error states, makes it hard to ignore potential errors and edge cases. Its heavy use of custom types to encode information in the type system, where the compiler can statically prevent mistakes. Forced use of keyword arguments to construct structs, making it hard to switch up fields. A consistent focus on, and documentation of, edge cases in function APIs. Good tooling, e.g. cargo-semver-checks, and a good built-in linter. More amorphous, but not less important is Rust's strong cultural affinity for correctness. For example, go to YouTube and click on some Rust conference channel. You'll see that a large fraction of the talks are on correctness, in some way or another. That's not something I see in Julia or Python conference talks. One way this materializes is that its standard library is packed with hard-to-misuse APIs. For example, compare Pythons int.from_bytes and Julia's analogous reinterpret(::Int, ::AbstractArray) with Rust's i64::from_le_bytes. All these functions' results is determined by endianness, but only the Rust function makes the endianness explicit - in the two other languages, the onus is on the user to remember this potential correctness issue. I'm certain that a language with the above features, but with a garbage collector instead of a borrowchecker would have the majority of Rust's correctness. OCaml and Haskell are like that, and they, too, have a strong reputation for safety and correctness. Okay, the borrowchecker isn't all bad As you might have noted by now, I don't like the borrowchecker, but even I have to grudgingly admit it has some use cases. Without a borrowchecker, you're left with either manual memory management, which is annoying and error-prone, or garbage collection (GC)[2]. GC also has its downsides: Marking and sweeping cause latency spikes which may be unacceptable if your program must have millisecond responsiveness. GC happens intermittently, which means garbage accumulates until each collection, and so your program is overall less memory efficient. Those two drawbacks alone could make GC a non-starter for some applications. Since Rust aims to be usable for low-level applications, such as bare-metal software operating system kernels, GC is not really a viable choice. Those constrains are entirely valid, but it's not constrains that most software, and certainly not most scientific software, are under. If you, like me, aren't building operating systems or programming microcontrollers, those drawbacks of GC doesn't apply. When comparing the borrowchecker to GC, there is also the issue of performance, which is not straightforward. GC has a reputation for poor performance because most GC languages like Java and Python are otherwise not performance oriented. When non-GC languages are compared to performance oriented GC languages like Julia and Go, the gap narrows. And even Julia and Go are decidedly higher level and offer the programmer less control than non-GC languages like Rust or C, making the comparison somewhat confounded. It's not entirely clear to me GC is slower than deterministic destruction. Certainly, there are situations where the GC causes slowdown. One such situation is when the program's object graph is large, and it needs to be traversed at every collection. In that situation, I've heard a programmer deride a GC by calling it a \"heap scanner\". Or, when the program's allocation pattern means it blows the CPU cache between garbage collections, whereas deterministic destruction would reuse memory in hot cache. I've seen demonstration Julia code showing this behaviour, where manually invoking malloc / free was six times faster than Julia's GC. On the other hand, a straightforward implementation of the binary-trees benchmark[3] is several times faster in Julia than in Rust, because Julia's GC has higher throughput when run in bulk, compared to Rust's deterministic destruction which is invoked individually for each object. And okay, the borrowchecker does prevent some bugs A garbage collector will prevent dangling pointers, use after free, and double free bugs. Buffer overflows are prevented by bounds checking. These are the main memory safety issues that Rust prevents, and it wouldn't need a borrowchecker to do so. But there are some bugs that a borrowchecker is uniquely suited to prevent: Data races in multithreaded code are elegantly and statically prevented by Rust. I have never written a large concurrent Rust program, and I'll grant the possibility that the borrowchecker is miraculous for that use case and easily pays for its own clunkiness. However, async Rust doesn't exacty have a great reputation. In single-threaded code, statically preventing mutation of externally held references sounds like it would prevent a lot of bugs, but my experience in Julia and Python is that I rarely encounter these bugs. Your mileage may vary. There are also some unexpected minor benefits of the borrowchecker that deserves mention: Guaranteeing the compiler that data is immutable unlocks optimisations, and likewise, guaranteeing that mutable data is not aliased enables other optimisations. The borrowchecker's mechanism can be leveraged for some nice, seemingly unrelated tricks, such as lock-free mutation of locks, and locks that take up 1 byte of memory. Conclusion When coding in my day job, I switch between Julia, Python and Rust. I persistently experience the grass is greener on the other side of the fence: When I switch from Julia to Rust, I miss Julia's strengths. When I don't program in Rust, I miss the many good things that Rust offers: I miss Rust's concise enums and their exhaustive matches. I miss traits, and the strong guarantees they come with. I miss the great tooling, such as rust-analyser. I absolutely don't miss the borrowchecker. [1] A famous Rust resource teaches people to write a doubly linked list in Rust, and in doing so demonstrates tonnes of Rust's features, because those are the wild hoops Rust programmers have to jump through: https://rust-unofficial.github.io/too-many-lists/. [2] I suppose you could also have reference counting like Swift, which, although it's technically garbage collection, is not what most people mean by that term. And you could have syntactic sugar coating manual memory management, like Zig. [3] The benchmark page lists Rust as being 7x faster than Julia. Amazingly, this is because there are different rules for GC versus non-GC languages. Only the latter are allowed to use custom memory management, and Rust only achieves its performance by using a custom bump allocator. This is perfectly doable in Julia, but arbitrarily banned in the competition.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e \u003cp\u003e\u003cem\u003eWritten 2025-07-18\u003c/em\u003e\u003c/p\u003e \u003cp\u003eAmong the 2010\u0026#39;s cohort of programming languages, Rust is probably the most widely lauded.\u003c/p\u003e \u003cp\u003eThe main selling point of Rust is that it manages to combine speed and low-level control with a high level of bug-resistance, more commonly referred to as \u003cem\u003esafety\u003c/em\u003e. The main innovation of Rust - really, its claim to fame - is its borrowchecker: the part of its compiler that enforces Rust\u0026#39;s ownership rules and thereby allows Rust to achieve all the memory safety that garbage collected language enjoy, but with zero runtime cost. \u003c/p\u003e \u003cp\u003e The \u003cs\u003eevangelists\u003c/s\u003e proponents of Rust have made memory safety the central selling point of Rust, to the extent that the borrowchecker has become the defining feature of Rust\u0026#39;s identity. I think the conflation of Rust\u0026#39;s safety with the borrowchecker\u0026#39;s guarantees is somewhat misguided. In this post, I want to make two arguments:\u003c/p\u003e \u003col\u003e \u003cli\u003e\u003cp\u003eThat the borrowchecker causes \u003cem\u003eserious\u003c/em\u003e ergonomic problems for Rust.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eThat the role of the borrowchecker in Rust\u0026#39;s safety is overstated.\u003c/p\u003e \u003c/li\u003e\u003c/ol\u003e \u003ch3 id=\"the_fundamental_problem_of_the_borrowchecker\"\u003e\u003ca href=\"#the_fundamental_problem_of_the_borrowchecker\"\u003eThe fundamental problem of the borrowchecker\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eIn a nutshell, the problem with Rust\u0026#39;s borrowchecker is that it makes references a pain in the ass.\u003c/p\u003e \u003cp\u003eOn an abstract level, the reason for the pain is that the borrowchecker needs to know the lifetimes of all references \u003cem\u003eat compile time\u003c/em\u003e, and this is simply an unrealistic proposal. Lifetimes are often an inherently runtime property.\u003c/p\u003e \u003cp\u003eOn an algorithmic level, the borrowchecker enforces a specific model, or set of rules around ownership, but this model is overly restrictive, and degrade Rust\u0026#39;s ergonomics by rejecting far too many well-behaving programs.\u003c/p\u003e \u003cp\u003eAt the implementation level, the borrowchecker\u0026#39;s current instantiation is incomplete, and often rejects programs that \u003cem\u003eadhere\u003c/em\u003e to the model of ownership, even as that model is too restrictive in the first place. \u003c/p\u003e \u003cp\u003eBorrowchecker frustration is like being brokenhearted - you can\u0026#39;t easily demonstrate it, you have to suffer it yourself to understand what people are talking about. Real borrowchecker pain is not felt when your small, 20-line demonstration snippet fails to compile. It\u0026#39;s when your existing project requires a small modification to ownership structure, and the borrowchecker then refuses to compile your code. Then, once you pull at the tiny loose fiber in your code\u0026#39;s fabric, you find you have to unspool half your code before the borrowchecker is satisfied.\u003c/p\u003e \u003cp\u003eNonetheless, tiny examples can still serve to demonstrate the borrowchecker\u0026#39;s propensity to reject perfectly fine code.\u003c/p\u003e \u003ch3 id=\"examples_where_the_borrowchecker_fails\"\u003e\u003ca href=\"#examples_where_the_borrowchecker_fails\"\u003eExamples where the borrowchecker fails\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eThe most clear examples are when the borrowchecker simply doesn\u0026#39;t do what it\u0026#39;s supposed to, because it rejects code that doesn\u0026#39;t even violate the spirit of Rust\u0026#39;s ownership rules.\u003c/p\u003e \u003cp\u003eFor example, consider this code I got from \u003ca href=\"https://medium.com/@lordmoma/partial-borrowing-in-rust-the-struggle-is-real-17db9ed9be1a\"\u003ea blog post\u003c/a\u003e:\u003c/p\u003e \u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Point {\n    x: f64,\n    y: f64,\n}\n\nimpl Point {\n    fn x_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut f64 {\n        \u0026amp;mut self.x\n    }\n\n    fn y_mut(\u0026amp;mut self) -\u0026gt; \u0026amp;mut f64 {\n        \u0026amp;mut self.y\n    }\n}\n\nfn main() {\n    \u003cspan\u003elet\u003c/span\u003e mut point = Point { x: \u003cspan\u003e1.0\u003c/span\u003e, y: \u003cspan\u003e2.0\u003c/span\u003e };\n    \u003cspan\u003elet\u003c/span\u003e x_ref = point.x_mut();\n    \u003cspan\u003elet\u003c/span\u003e y_ref = point.y_mut();\n    *x_ref *= \u003cspan\u003e2.0\u003c/span\u003e;\n    *y_ref *= \u003cspan\u003e2.0\u003c/span\u003e;\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003cp\u003eThis code won\u0026#39;t compile, because the two mutable references \u003ccode\u003ex_ref\u003c/code\u003e and \u003ccode\u003ey_ref\u003c/code\u003e needs to exist simultaenously, which violates Rust\u0026#39;s principle that a mutable reference to some data needs to unique at any point.\u003c/p\u003e \u003cp\u003eOf course, this case is a false positive, since the references point to distinct fields of the same struct, and therefore \u003cem\u003edon\u0026#39;t\u003c/em\u003e refer to the same data. The borrowchecker rejects this code because the underlying rule of of the borrowchecker - namely: \u0026#34;Mutation requires exclusivity\u0026#34; is implemented \u003cem\u003eimprecisely\u003c/em\u003e, such that the naunce between a reference to a field and a reference to a struct is lost.\u003c/p\u003e \u003cp\u003eA similar, but slightly different example occurs in the code below\u003c/p\u003e \u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Collection {\n    counter: u32,\n    items: Vec\u0026lt;u32\u0026gt;,\n}\n\nimpl Collection {\n    fn increment_counter(\u0026amp;mut self) {\n        self.counter += \u003cspan\u003e1\u003c/span\u003e;\n    }\n    \n    pub fn count_items(\u0026amp;mut self) {\n        \u003cspan\u003efor\u003c/span\u003e _ \u003cspan\u003ein\u003c/span\u003e \u0026amp;self.items {\n            self.increment_counter();\n        }    \n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003cp\u003eTo the human reader, it\u0026#39;s clear that \u003ccode\u003eincrement_counter\u003c/code\u003e doesn\u0026#39;t mutate \u003ccode\u003eself.items\u003c/code\u003e, and therefore cannot interfere with looping over the vector. Therefore, the of the borrowchecker: \u0026#34;Mutation requires exclusivity\u0026#34; is not violated, and the code should compile fine.\u003c/p\u003e \u003cp\u003eUnfortunately, the borrowchecker can\u0026#39;t reason across functions, and therefore incorrectly rejects the function.\u003c/p\u003e \u003cp\u003eThe borrowchecker is not only overly conservative when checking loans across functions; it can\u0026#39;t even reason well about control flow \u003cem\u003ewithin\u003c/em\u003e a function. The following example is a famous illustration of how it can\u0026#39;t properly reason across \u003cem\u003ebranches\u003c/em\u003e, either:\u003c/p\u003e \u003cdiv\u003e\u003cpre\u003e\u003ccode\u003efn get_default\u0026lt;\u0026#39;r, K: Hash + Eq + Copy, V: Default\u0026gt;(\n    map: \u0026amp;\u0026#39;r mut HashMap\u0026lt;K, V\u0026gt;,\n    key: K,\n) -\u0026gt; \u0026amp;\u0026#39;r mut V {\n    match map.get_mut(\u0026amp;key) {\n        \u003cspan\u003eSome\u003c/span\u003e(value) =\u0026gt; value,\n        None =\u0026gt; {\n            map.insert(key, V::default());\n            map.get_mut(\u0026amp;key).unwrap()\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003cp\u003eThis is rejected due to the two mutable references, despite the program logic guaranteeing that the second reference is only created in the \u003ccode\u003eNone\u003c/code\u003e branch, where the first reference is no longer live.\u003c/p\u003e \u003cp\u003eThere are more such \u003ca href=\"https://blog.polybdenum.com/2024/12/21/four-limitations-of-rust-s-borrow-checker.html\"\u003eunnecessary limitations of the borrowchecker\u003c/a\u003e.\u003c/p\u003e \u003ch2 id=\"a_sufficiently_smart_borrowchecker\"\u003e\u003ca href=\"#a_sufficiently_smart_borrowchecker\"\u003eA \u0026#39;sufficiently smart borrowchecker\u0026#39;\u003c/a\u003e\u003c/h2\u003e \u003cp\u003eAt this point, an Rust apologist might point out that, precisely because the above examples are implementation limitations, they are not fundamental, and might be lifted in the future as the implementation improves. There is some merit to the hope: Rust adopted so called \u003ca href=\"https://blog.rust-lang.org/2022/08/05/nll-by-default/\"\u003enon-lexical lifetimes\u003c/a\u003e in 2022, which did improve the borrowchecker\u0026#39;s accuracy. Similarly, a new formulation of the borrowchecker, called \u003ca href=\"https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/\"\u003ePolonius\u003c/a\u003e is in the works, which will improve accuracy still further.\u003c/p\u003e \u003cp\u003eI remain sceptical. Polonius has been in the works for seven years now, and doesn\u0026#39;t seem to be close to completion. More fundamentally, the borrowchecker will never be \u0026#39;complete\u0026#39;, because its job is to \u003cem\u003ereason\u003c/em\u003e about your code, and programs just can\u0026#39;t do that on level that is sufficiently deep. There is an obvious parallel with the mythical \u0026#39;sufficiently smart compiler\u0026#39; - just like compilers continuously improve, and yet never seem to really \u003cem\u003eunderstand\u003c/em\u003e your code, and rarely are able to rewrite it on an algoritmic level, the borrowchecker will probably always reject seemingly obviously correct code.\u003c/p\u003e \u003ch3 id=\"the_rules_themselves_are_unergonomical\"\u003e\u003ca href=\"#the_rules_themselves_are_unergonomical\"\u003eThe rules themselves are unergonomical\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eAbove, I demonstrated limitations in the \u003cem\u003eimplementation\u003c/em\u003e of the abstract ownership model. However, sometimes the model itself is just wrong for your program.\u003c/p\u003e \u003cp\u003eConsider: \u003c/p\u003e \u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e Id(u32);\n\nfn main() {\n    \u003cspan\u003elet\u003c/span\u003e id = Id(\u003cspan\u003e5\u003c/span\u003e);\n    \u003cspan\u003elet\u003c/span\u003e mut v = vec![id];\n    println!(\u003cspan\u003e\u0026#34;{}\u0026#34;\u003c/span\u003e, id\u003cspan\u003e.0\u003c/span\u003e);\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e \u003cp\u003eThis is a clear-cut violation of the ownership rules: After \u003ccode\u003ev\u003c/code\u003e is constructed, \u003ccode\u003eid\u003c/code\u003e is moved into \u003ccode\u003ev\u003c/code\u003e, which prevents the function \u003ccode\u003emain\u003c/code\u003e from using \u003ccode\u003eid\u003c/code\u003e on the last line. There is a sense, then, in which the borrowchecker - in \u003cem\u003eany\u003c/em\u003e implementation - ought to reject the program. It does fail the ownership rules.\u003c/p\u003e \u003cp\u003eBut what\u0026#39;s the point of the rules in this case, though? Here, the ownership rules does not prevent use after free, or double free, or data races, or \u003cem\u003eany other bug\u003c/em\u003e. It\u0026#39;s perfectly clear to a human that this code is fine and doesn\u0026#39;t have any \u003cem\u003eactual\u003c/em\u003e ownership issues. But the borrowchecker, being a program, is very hard to negotiate with and dissuade from overly pedantic enforcement of a rigid, though in this case, pointless, set of rules.\u003c/p\u003e \u003cp\u003eIn the above case, the pedanticness doesn\u0026#39;t matter much because the workaround is easy. But my experience has been \u003cem\u003eregularly\u003c/em\u003e hitting these fundamental problems where the ownership model does not correspond to the needs of my program. For example: \u003c/p\u003e \u003cul\u003e \u003cli\u003e\u003cp\u003eReferences to temporary values, e.g. values created in a closure, are forbidden even though it\u0026#39;s obvious to a human that the solution is simply to extend the lifetime of the value to its use outside the closure.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eStruct withs mixed ownership: You can\u0026#39;t have a struct with a field that contains a \u003ccode\u003eVec\u0026lt;Thing\u0026gt;\u003c/code\u003e of things, which then also stores groups of the same things in another field in a \u003ccode\u003eVec\u0026lt;Vec\u0026lt;\u0026amp;Thing\u0026gt;\u0026gt;\u003c/code\u003e.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003ePhylogenetic trees are a \u003cem\u003emassive pain\u003c/em\u003e to implement, because each node having bidirectional references is fundamentally in conflict with Rust\u0026#39;s concept that data has exactly one owner.\u003c/p\u003e \u003c/li\u003e\u003c/ul\u003e \u003cp\u003eIt\u0026#39;s hard to overstate how much these problems just \u003cem\u003eare not a thing\u003c/em\u003e in garbage collected languages, but purely self-inflicted by Rust\u0026#39;s borrowchecker. You want to build a tree with bidirectional references in Python? Just do the obvious thing, and it works perfectly. It\u0026#39;s \u003cem\u003epossible\u003c/em\u003e to do in Rust, but it\u0026#39;s terribly complicated\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fndef:1\"\u003e[1]\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e \u003cp\u003eA common defense of Rust are that the pain Rust\u0026#39;s borrowchecker inflicts on you is not \u003cem\u003eexcess pain\u003c/em\u003e, but rather \u003cem\u003eupfront pain\u003c/em\u003e. The talking point goes: You have a program with a complicated ownership structure, and Rust merely forces you to be explicit about this. In doing so, it guarantees memory safety - and wouldn\u0026#39;t you rather deal with compiler errors than production crashes?\u003c/p\u003e \u003cp\u003eBut that hasn\u0026#39;t been my experience. My experience has been that borrowchecker problems are \u003cem\u003emostly\u003c/em\u003e just bullshit - invented problems without real grounding. For every time I experience a bug in Python that would have been prevented in Rust by its borrowchecker, I experience maybe twenty borrowchecker issues.\u003c/p\u003e \u003cp\u003eAnother common claim is that this kind of borrowchecker frustration is merely a beginner\u0026#39;s struggle. Once you internalize the ownership model of Rust, you will automatically structure your code to conform to the borrowchecker, making all the problems go away. Unfortunately, after using Rust intermittently for a few years, this hasn\u0026#39;t been my experience yet, and \u003ca href=\"https://loglog.games/blog/leaving-rust-gamedev/#once-you-get-good-at-rust-all-of-these-problems-will-go-away\"\u003eit seems I\u0026#39;m not alone\u003c/a\u003e.\u003c/p\u003e \u003ch3 id=\"why_dont_you_just\"\u003e\u003ca href=\"#why_dont_you_just\"\u003eWhy don\u0026#39;t you just...\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eMy examples code above may not be persuasive to experienced Rustaceans. They might argue that the snippets don\u0026#39;t show there is any real ergonomic problem, because the solutions to make the snippets compile are completely trivial. In the last example, I could \u003cem\u003ejust\u003c/em\u003e derive \u003ccode\u003eClone + Copy\u003c/code\u003e for \u003ccode\u003eId\u003c/code\u003e.\u003c/p\u003e \u003cp\u003eI know. The commonality of these stumbling blocks is that you \u003cem\u003ecan\u003c/em\u003e jump over them. You can, indeed, do extra work to fix whatever borrowchecker problems you have.\u003c/p\u003e \u003cp\u003eThe issue is that there was never a problem to begin with to warrant this extra work. Rust gates your \u003cem\u003eperfectly functional code\u003c/em\u003e behind a lifetime puzzle, and forces you to refactor until you\u0026#39;ve solved it. Rust insists your program\u0026#39;s structure is a house of cards - touch one tiny thing, and large parts of it has to scrapped and rebuilt. The more Rust experience I gain, the more I suspect that is usually plain wrong. For \u003cem\u003emost\u003c/em\u003e borrowchecker issues I face, the problem is not my program\u0026#39;s structure, but the largely arbitrary restrictions of Rust.\u003c/p\u003e \u003cp\u003eAnd sure, in the snippets above, the solution to the borrowchecker problems are trivial, but in larger-scale, real life code, they can be a real challenge. Perversely, \u003cem\u003ebecause\u003c/em\u003e Rust\u0026#39;s lifetime riddles are challenging, they are sort of \u003cem\u003efun\u003c/em\u003e. I believe that partly explains why so many people don\u0026#39;t seem to mind them. Instead of thinking about how to write my code to solve the scientific problems I\u0026#39;m being paid to solve, I have to think about how to write it to please the borrowchecker. The latter is usually more tractable, limited in scope, have clearer requirements and is more \u0026#39;puzzle-like\u0026#39;. In that sense, Rust enables \u003cem\u003eescapism\u003c/em\u003e: When writing Rust, you get to solve lots of \u0026#39;problems\u0026#39; - not \u003cem\u003ereal\u003c/em\u003e problems, mind you, but \u003cem\u003efun\u003c/em\u003e problems.\u003c/p\u003e \u003cp\u003eThe usual way of obeying the borrowchecker is to refactor your code. Which is already unwelcome extra work, but sometimes even that is not enough. Let\u0026#39;s look at some other ways people usually recommend me solving borrowchecker problems:\u003c/p\u003e \u003ch4 id=\"use_fewer_references_and_copy_data_or_just_clone\"\u003e\u003ca href=\"#use_fewer_references_and_copy_data_or_just_clone\"\u003eUse fewer references and copy data. Or: \u0026#34;Just clone\u0026#34;.\u003c/a\u003e\u003c/h4\u003e \u003cp\u003eThis is generally good advice. Usually, extra allocations are fine, and the resulting performance degradation is not an issue. But it is a little strange that it allocations are encouraged in an otherwise performance-forcused language, not because the program logic demands it, but because the borrowchecker does.\u003c/p\u003e \u003cp\u003eOf course, sometimes cloning doesn\u0026#39;t solve the issue, because you really do need to mutate shared objects.\u003c/p\u003e \u003ch4 id=\"rc_arc_refcell_box_spam\"\u003e\u003ca href=\"#rc_arc_refcell_box_spam\"\u003e\u003ccode\u003eRc / Arc / RefCell / Box\u003c/code\u003e spam\u003c/a\u003e\u003c/h4\u003e \u003cp\u003eRust\u0026#39;s \u003ccode\u003eArc\u003c/code\u003e type disables some of Rust\u0026#39;s ownership rules of the object it wraps, and instead reference counts that specific object. That means sometimes, the borrowchecker can be appeased by slapping \u003ccode\u003eArc\u003c/code\u003e on a bunch of data throughout your program. Or, as I also like to call it \u0026#34;managing the world\u0026#39;s worst garbage collector, but with none of the convenience or performance\u0026#34;.\u003c/p\u003e \u003cp\u003eTo be fair, adding a few selective \u003ccode\u003eArc\u003c/code\u003es or \u003ccode\u003eRefCell\u003c/code\u003es are not a performance problem. It becomes a problem when these are used extensively to skirt around the borrowchecker, e.g. for every single node in a big graph.\u003c/p\u003e \u003ch4 id=\"use_indices_instead_of_references\"\u003e\u003ca href=\"#use_indices_instead_of_references\"\u003eUse indices instead of references\u003c/a\u003e\u003c/h4\u003e \u003cp\u003eWhen I first tried implementing a bidirected graph in Rust, I was suggested this pattern. A bidirected graph\u0026#39;s edges can be represented by referencing the vertices by an integer ID, instead of an actual reference. Since you don\u0026#39;t use references this way, you don\u0026#39;t get any issues with the borrowchecker.\u003c/p\u003e \u003cp\u003eThe first time someone gave be this advice, I had to do a double take. The Rust community\u0026#39;s \u003cem\u003ewhole thing\u003c/em\u003e is commitment to compiler-enforced correctness, and they built the borrowchecker on the premise that humans can\u0026#39;t be trusted to handle references manually. When the same borrowchecker makes references unworkable, their solution is to... recommend that I manually manage them, with \u003cem\u003ezero\u003c/em\u003e safety and \u003cem\u003ezero\u003c/em\u003e language support?!? The irony is unreal. Asking people to manually manage references is so hilariously unsafe and unergonomic, the suggestion would be funny if it wasn\u0026#39;t mostly sad.\u003c/p\u003e \u003ch2 id=\"rusts_safety_is_only_partly_due_to_the_borrowchecker\"\u003e\u003ca href=\"#rusts_safety_is_only_partly_due_to_the_borrowchecker\"\u003eRust\u0026#39;s safety is only partly due to the borrowchecker\u003c/a\u003e\u003c/h2\u003e \u003cp\u003eIn online discourse, Rust\u0026#39;s safety is sometimes equated with its memory safety in particular, which is attributed to the borrowchecker. Rust\u0026#39;s reputation for bug-resistance is deserved, I think, but I believe it\u0026#39;s due to Rust\u0026#39;s \u003cem\u003ebroadly\u003c/em\u003e good taste and solid design. Like performance, correctness dies by a thousand cuts, and Rust is notable for being \u003cem\u003econsistently\u003c/em\u003e correctness-focused:\u003c/p\u003e \u003cul\u003e \u003cli\u003e\u003cp\u003eIts widespread use of enums plus exhaustive pattern matches, including for error states, makes it hard to ignore potential errors and edge cases.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eIts heavy use of custom types to encode information in the type system, where the compiler can statically prevent mistakes.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eForced use of keyword arguments to construct structs, making it hard to switch up fields.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eA consistent focus on, and documentation of, edge cases in function APIs.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eGood tooling, e.g. \u003ca href=\"https://crates.io/crates/cargo-semver-checks\"\u003ecargo-semver-checks\u003c/a\u003e, and a good built-in linter.\u003c/p\u003e \u003c/li\u003e\u003c/ul\u003e \u003cp\u003eMore amorphous, but not less important is Rust\u0026#39;s strong \u003cem\u003ecultural affinity\u003c/em\u003e for correctness. For example, go to YouTube and click on some Rust conference channel. You\u0026#39;ll see that a large fraction of the talks are on correctness, in some way or another. That\u0026#39;s not something I see in Julia or Python conference talks.\u003c/p\u003e \u003cp\u003eOne way this materializes is that its standard library is packed with hard-to-misuse APIs. For example, compare Pythons \u003ccode\u003eint.from_bytes\u003c/code\u003e and Julia\u0026#39;s analogous \u003ccode\u003ereinterpret(::Int, ::AbstractArray)\u003c/code\u003e with Rust\u0026#39;s \u003ccode\u003ei64::from_le_bytes\u003c/code\u003e. All these functions\u0026#39; results is determined by \u003ca href=\"https://en.wikipedia.org/wiki/Endianness\"\u003eendianness\u003c/a\u003e, but \u003cem\u003eonly\u003c/em\u003e the Rust function makes the endianness explicit - in the two other languages, the onus is on the user to remember this potential correctness issue.\u003c/p\u003e \u003cp\u003eI\u0026#39;m certain that a language with the above features, but with a garbage collector instead of a borrowchecker would have the majority of Rust\u0026#39;s correctness. OCaml and Haskell are like that, and they, too, have a strong reputation for safety and correctness. \u003c/p\u003e \u003ch2 id=\"okay_the_borrowchecker_isnt_all_bad\"\u003e\u003ca href=\"#okay_the_borrowchecker_isnt_all_bad\"\u003eOkay, the borrowchecker isn\u0026#39;t \u003cem\u003eall bad\u003c/em\u003e\u003c/a\u003e\u003c/h2\u003e \u003cp\u003eAs you might have noted by now, \u003cem\u003eI don\u0026#39;t like the borrowchecker\u003c/em\u003e, but even I have to grudgingly admit it has some use cases.\u003c/p\u003e \u003cp\u003eWithout a borrowchecker, you\u0026#39;re left with either manual memory management, which is annoying and error-prone, or garbage collection (GC)\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fndef:2\"\u003e[2]\u003c/a\u003e\u003c/sup\u003e. GC also has its downsides:\u003c/p\u003e \u003cul\u003e \u003cli\u003e\u003cp\u003eMarking and sweeping cause latency spikes which may be unacceptable if your program must have millisecond responsiveness.\u003c/p\u003e \u003c/li\u003e\u003cli\u003e\u003cp\u003eGC happens intermittently, which means garbage accumulates until each collection, and so your program is overall less memory efficient.\u003c/p\u003e \u003c/li\u003e\u003c/ul\u003e \u003cp\u003eThose two drawbacks alone could make GC a non-starter for some applications. Since Rust aims to be usable for low-level applications, such as bare-metal software operating system kernels, GC is not really a viable choice. Those constrains are entirely valid, but it\u0026#39;s not constrains that most software, and certainly not most \u003cem\u003escientific\u003c/em\u003e software, are under. If you, like me, aren\u0026#39;t building operating systems or programming microcontrollers, those drawbacks of GC doesn\u0026#39;t apply.\u003c/p\u003e \u003cp\u003eWhen comparing the borrowchecker to GC, there is also the issue of performance, which is not straightforward. GC has a reputation for poor performance because most GC languages like Java and Python are \u003cem\u003eotherwise\u003c/em\u003e not performance oriented. When non-GC languages are compared to performance oriented GC languages like Julia and Go, the gap narrows. And even Julia and Go are decidedly higher level and offer the programmer less control than non-GC languages like Rust or C, making the comparison somewhat confounded.\u003c/p\u003e \u003cp\u003eIt\u0026#39;s \u003ca href=\"https://bitbashing.io/gc-for-systems-programmers.html\"\u003enot entirely clear to me GC is slower than deterministic destruction\u003c/a\u003e. Certainly, there are situations where the GC causes slowdown. One such situation is when the program\u0026#39;s object graph is large, and it needs to be traversed at every collection. In that situation, I\u0026#39;ve heard a programmer deride a GC by calling it a \u0026#34;heap scanner\u0026#34;. Or, when the program\u0026#39;s allocation pattern means it blows the CPU cache between garbage collections, whereas deterministic destruction would reuse memory in hot cache. I\u0026#39;ve seen demonstration Julia code showing this behaviour, where manually invoking \u003ccode\u003emalloc\u003c/code\u003e / \u003ccode\u003efree\u003c/code\u003e was \u003cem\u003esix times\u003c/em\u003e faster than Julia\u0026#39;s GC.\u003c/p\u003e \u003cp\u003eOn the other hand, a straightforward implementation of the \u003ca href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/performance/binarytrees.html\"\u003ebinary-trees benchmark\u003c/a\u003e\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fndef:3\"\u003e[3]\u003c/a\u003e\u003c/sup\u003e is several times faster in Julia than in Rust, because Julia\u0026#39;s GC has higher throughput when run in bulk, compared to Rust\u0026#39;s deterministic destruction which is invoked individually for each object.\u003c/p\u003e \u003ch3 id=\"and_okay_the_borrowchecker_does_prevent_some_bugs\"\u003e\u003ca href=\"#and_okay_the_borrowchecker_does_prevent_some_bugs\"\u003eAnd okay, the borrowchecker \u003cem\u003edoes\u003c/em\u003e prevent some bugs\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eA garbage collector will prevent dangling pointers, use after free, and double free bugs. Buffer overflows are prevented by bounds checking. These are the main memory safety issues that Rust prevents, and it wouldn\u0026#39;t need a borrowchecker to do so.\u003c/p\u003e \u003cp\u003eBut there \u003cem\u003eare\u003c/em\u003e some bugs that a borrowchecker is uniquely suited to prevent: Data races in multithreaded code are elegantly and statically prevented by Rust. I have never written a large concurrent Rust program, and I\u0026#39;ll grant the possibility that the borrowchecker is miraculous for that use case and easily pays for its own clunkiness. However, async Rust doesn\u0026#39;t exacty \u003ca href=\"https://bitbashing.io/async-rust.html\"\u003ehave a great reputation\u003c/a\u003e.\u003c/p\u003e \u003cp\u003eIn single-threaded code, statically preventing mutation of externally held references \u003cem\u003esounds\u003c/em\u003e like it would prevent a lot of bugs, but my experience in Julia and Python is that I rarely encounter these bugs. Your mileage may vary.\u003c/p\u003e \u003cp\u003eThere are also some unexpected minor benefits of the borrowchecker that deserves mention: Guaranteeing the compiler that data is immutable unlocks optimisations, and likewise, guaranteeing that mutable data is not aliased enables other optimisations. The borrowchecker\u0026#39;s mechanism can be leveraged for some nice, seemingly unrelated tricks, such as \u003ca href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.get_mut\"\u003elock-free mutation of locks\u003c/a\u003e, and \u003ca href=\"https://crates.io/crates/parking_lot\"\u003elocks that take up 1 byte of memory\u003c/a\u003e.\u003c/p\u003e \u003ch3 id=\"conclusion\"\u003e\u003ca href=\"#conclusion\"\u003eConclusion\u003c/a\u003e\u003c/h3\u003e \u003cp\u003eWhen coding in my day job, I switch between Julia, Python and Rust. I persistently experience the grass is greener on the other side of the fence: When I switch from Julia to Rust, I miss Julia\u0026#39;s strengths. When I don\u0026#39;t program in Rust, I miss the many good things that Rust offers: I miss Rust\u0026#39;s concise enums and their exhaustive matches. I miss traits, and the strong guarantees they come with. I miss the great tooling, such as rust-analyser.\u003c/p\u003e \u003cp\u003eI \u003cem\u003eabsolutely\u003c/em\u003e don\u0026#39;t miss the borrowchecker.\u003c/p\u003e \u003ctable id=\"fndef:1\"\u003e \u003ctbody\u003e\u003ctr\u003e \u003ctd\u003e\u003ca href=\"#fnref:1\"\u003e[1]\u003c/a\u003e \u003c/td\u003e\u003ctd\u003eA famous Rust resource teaches people to write a doubly linked list in Rust, and in doing so demonstrates tonnes of Rust\u0026#39;s features, because those are the wild hoops Rust programmers have to jump through: https://rust-unofficial.github.io/too-many-lists/. \u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e \u003ctable id=\"fndef:2\"\u003e \u003ctbody\u003e\u003ctr\u003e \u003ctd\u003e\u003ca href=\"#fnref:2\"\u003e[2]\u003c/a\u003e \u003c/td\u003e\u003ctd\u003eI suppose you could also have reference counting like Swift, which, although it\u0026#39;s technically garbage collection, is not what most people mean by that term. And you could have syntactic sugar coating manual memory management, like Zig. \u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e \u003ctable id=\"fndef:3\"\u003e \u003ctbody\u003e\u003ctr\u003e \u003ctd\u003e\u003ca href=\"#fnref:3\"\u003e[3]\u003c/a\u003e \u003c/td\u003e\u003ctd\u003eThe benchmark page lists Rust as being 7x faster than Julia. Amazingly, this is because there are different rules for GC versus non-GC languages. Only the latter are allowed to use custom memory management, and Rust only achieves its performance by using a custom bump allocator. This is perfectly doable in Julia, but arbitrarily banned in the competition. \u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e   \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": null,
  "modifiedTime": null
}
