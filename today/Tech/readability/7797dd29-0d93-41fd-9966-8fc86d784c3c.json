{
  "id": "7797dd29-0d93-41fd-9966-8fc86d784c3c",
  "title": "Fastplotlib: GPU-accelerated, fast, and interactive plotting library",
  "link": "https://medium.com/@caitlin9165/fastplotlib-driving-scientific-discovery-through-data-visualization-418f8bff094c",
  "description": "Comments",
  "author": "",
  "published": "Tue, 11 Mar 2025 16:33:24 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "Caitlin Lewis",
  "length": 10555,
  "excerpt": "fastplotlib is a new GPU-accelerated fast and interactive scientific plotting library that leverages WGPU",
  "siteName": "Medium",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "fastplotlib is a new GPU-accelerated fast and interactive scientific plotting library that leverages WGPUIntroductionScientific visualization is hard — but it doesn’t have to be.Visualization examples using fastplotlibWhat makes scientific visualization so challenging?High-dimensional, massive datasets — often spanning terabytes of informationComputational bottlenecks — efficiently utilizing resources is non-trivialLimited interactive tools — most are designed for static plotting or do not scale to large dataReal-time analysis barriers — visualization lags behind modern data generation speedsEnter fastplotlib, which is built for high-performance, interactive scientific visualization.fastplotlibhttps://github.com/fastplotlib/fastplotlibfastplotlib is a very new open source Python-based GPU-accelerated scientific plotting library.Large-scale calcium imaging dataset with corresponding behavior and down-stream analysisWhat can you do with fastplotlib?GPU-accelerated visualization (a modern integrated GPU is sufficient for most use cases)Rapid prototyping and algorithm designExploration and fast rendering of large-scale dataCreation of real-time acquisition systems for instrumentsNote: this is by no means an exhaustive list, merely just the highlights :)AgendaIn the remainder of this article, I am going to cover the following topics that highlight why fastplotlib is a powerful tool that can be used to drive scientific discovery through data visualization:Scientific visualization is more than just static plotsAPI design mattersLeveraging new hardware is criticalScientific visualization is more than just static plotsWhile scientific visualization has traditionally relied on static plots, dynamic and interactive visualizations are the key to enhancing data exploration and analysis.For example, consider the interactive plot depicted below.Interactive covariance matrix of Olivetti faces datasetThis plot shows a simple interactive visualization of a covariance matrix in fastplotlib. As a formal definition, a covariance matrix gives a measure of how pairs of random variables change together.In the left subplot, the covariance matrix for the Olivetti faces dataset is shown. In this case, each entry in the covariance matrix indicates how the intensity of any two pixels varies. In the right subplot is the reconstructed row image from the currently selected row of the covariance matrix. We can easily change what row of the covariance matrix we are looking at by simply moving the selector.It is very clear visually that looking at the reconstructed image for each row of the covariance matrix is much more informative than having a static plot of just the covariance matrix by itself. By looking at the reconstructed row image, we can get a sense of how the pixel intensity is changing across faces in the dataset.The purpose of displaying this plot is not to conduct a detailed analysis of the covariance matrix but to demonstrate how even a small degree of interactivity can enhance our understanding of the data, ultimately transforming the types of analysis we may pursue in the future.The goal of fastplotlib is to expand the field of scientific visualization by providing a mechanism that allows the creation of high-level interactive plots, ultimately driving scientific discovery.API design mattersThe ecosystem for scientific visualization has come a long way since the early 2000s.Scientific Python visualization ecosystem timelineThese days, there are many open-source Python visualization tools available. However, one limiting factor for scientists and other users is the high barrier to entry in learning how to use some of these libraries. Often, users are forced to learn complicated APIs that make it difficult to focus on their data or research questions.In fastplotlib, we aim to provide fast interactive visualization via an easy-to-use and intuitive API.1) Data interactionThe premise behind our API design is that you should never have to think of your data as anything but an array.If the data in our visualization maintains an array-like structure we are familiar with, interacting with the visualization becomes much easier.Consider the following example:Suppose we want to plot a simple sine wave.import fastplotlib as fplimport numpy as np# generate some data xs = np.linspace(-10, 10, 100)ys = np.sin(xs)data = np.dstack([xs, ys])[0]# create a figurefigure = fpl.Figure()# add the data to the figuresine_wave = figure[0, 0].add_line(data=data, thickness=10)figure.show()simple sine waveNow, say we wanted to change every third point of our sine wave to have the color red. If the data in our visualization can be thought of as an array, then doing this kind of fancy indexing isn’t any different than usual NumPy array manipulation.sine_wave.colors[::3] = \"red\"fancy index sine wave colorsWith this framework, we can perform all sorts of dynamic manipulations to different features of our graphic (e.g., color maps, colors, data, etc.) after we have initially plotted something.The goal of taking this approach to the API design is to limit the amount of mental overhead required to use fastplotlib, ultimately making the library flexible, intuitive, and easy to use.2) EventsAnother area of our API that we have tried to simplify for users is our events system. Using simple callback functions, we can define events between graphics or plots, which allows for the generation and build-up of interactive visualizations.For example, suppose we wanted to define a simple click event. Let’s first generate some data.import fastplotlib as fplimport numpy as np# generate some circlesdef make_circle(center, radius: float, n_points: int = 75) -\u003e np.ndarray: theta = np.linspace(0, 2 * np.pi, n_points) xs = radius * np.sin(theta) ys = radius * np.cos(theta) return np.column_stack([xs, ys]) + centercircles = list()for x in range(0, 50, 10): circles.append(make_circle(center=(x, 0), radius=4, n_points=100))# create figurefig = fpl.Figure()# add circles to plotcircles_graphic = fig[0,0].add_line_collection(data=circles, cmap=\"tab10\", thickness=10)fig.show()simple plot of circlesNow that we have generated our data, we can define a click event so that when we click on the plot, we get the closest circle and “highlight” it.# get the nearest graphic that is clicked and change the color@fig.renderer.add_event_handler(\"click\")def click_event(ev): # reset colors circles_graphic.cmap = \"tab10\" # map the click position to world coordinates xy = fig[0, 0].map_screen_to_world(ev)[:-1] # get the nearest graphic to the position nearest = fpl.utils.get_nearest_graphics(xy, circles_graphic)[0] # change the closest graphic color to white nearest.colors = \"w\"simple click eventIn fastplotlib, specifying an event is as simple as defining how we want to handle the event and then adding our handler to the appropriate graphic or plot the event corresponds to. The beauty of this approach is that it doesn’t require users to learn new, complicated, library-specific API features (knowing how to define functions is sufficient).The streamlined design of our API for data interaction and event handling is a key strength of the library, making fastplotlib both intuitive and easy to master.Leveraging new hardware is criticalThese days, having a GPU is practically a prerequisite to doing science, and visualization is no exception.Maximizing the computational resources on the GPU is a key factor in making high-resolution performant visualizations.Depicted below is an example of plotting 3 million points using fastplotlib. Not only are we plotting the lines, but we are also easily zooming in and out, changing the color map of the lines, and even further, individually changing the color of specific points.fastpotlib 3 million points line examplePlotting this many points at once and having fine-grained control over the colors of the points is impossible in many other Python scientific visualization libraries.What makes the performance capabilities of fastplotlib so powerful is the underlying graphics technology on which it is built.The nitty gritty detailsfastplotlib is abstracted on top of the pygfx rendering engine. pygfx, in turn, is powered by WGPU, a cross-platform graphics API that targets Vulkan (Linux), Metal (Mac), and DX12 (Windows).fastplotlib software stackIn essence, these new graphics APIs (Vulkan, Metal, and DX12) are very fast, efficient, and leverage GPU hardware better than OpenGL, the old graphics standard.The reason we built fastplotlib on top of pygfx is to abstract away some of the lower-level rendering engine details (e.g., the camera, renderer, scene, etc.) that are boilerplate code for many visualizations. This allows users to focus primarily on their data!ConclusionIt is one thing for it to be easy to see your data and explore different dimensions, but being able to interact with your data after it is initially plotted, we believe, is the key to driving scientific discovery. However, the ability to create these interactive plots that allow you to explore and analyze your data easily and intuitively is not trivial.Many prominent Python visualization libraries force you to learn complicated APIs, making the barrier to entry high. Furthermore, many of these libraries are built on OpenGL, an older graphics API that Vulkan, Metal, and DX12 are slowly replacing. These new graphics APIs leverage the GPU better, allowing for more powerful and expressive visualizations.fastplotlib seeks to address current challenges in Python scientific visualization by providing an easy-to-use array-like API that leverages modern graphics hardware to provide GPU-accelerated fast interactive visualization.Documentation \u0026 ExamplesOur documentation and examples can be found here. This includes a user guide and how-to on getting started using fastplotlib. We also have an extensive examples gallery that we are always expanding.Lastly, we are always happy to help you visualize your data, and we would love to add more examples to our library for your use case!Contact UsWe love to interact with our community ❤️If you have questions or would like to chat, feel free to contact us by posting a GitHub Issue or Discussion!Future articlesWe plan on this being the first in a series of articles. In the future, we would like to add articles walking through examples using fastplotlib and potentially some in-depth articles on the underlying graphics technology.If this is something you would be interested in, please let us know :D",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1060/1*8uzCRfgah3FNc3Li97NhjA.gif",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle\u003e\u003cdiv\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@caitlin9165?source=post_page---byline--418f8bff094c---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Caitlin Lewis\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*BT5qbDPGGFvpvkUr1jmHUA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cblockquote\u003e\u003cp id=\"10f2\"\u003e\u003ca href=\"https://github.com/fastplotlib/fastplotlib\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003efastplotlib\u003c/a\u003e is a new GPU-accelerated fast and interactive scientific plotting library that leverages WGPU\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"ee07\"\u003e\u003cstrong\u003eIntroduction\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"69bd\"\u003eScientific visualization is hard — but it doesn’t have to be.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eVisualization examples using fastplotlib\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ec06\"\u003e\u003cstrong\u003eWhat makes scientific visualization so challenging?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"7a7c\"\u003e\u003cstrong\u003eHigh-dimensional, massive datasets\u003c/strong\u003e — often spanning terabytes of information\u003c/li\u003e\u003cli id=\"7fbb\"\u003e\u003cstrong\u003eComputational bottlenecks\u003c/strong\u003e — efficiently utilizing resources is non-trivial\u003c/li\u003e\u003cli id=\"56f7\"\u003e\u003cstrong\u003eLimited interactive tools\u003c/strong\u003e — most are designed for static plotting or do not scale to large data\u003c/li\u003e\u003cli id=\"d126\"\u003e\u003cstrong\u003eReal-time analysis barriers\u003c/strong\u003e — visualization lags behind modern data generation speeds\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"28c4\"\u003eEnter \u003cstrong\u003efastplotlib, \u003c/strong\u003ewhich is\u003cstrong\u003e \u003c/strong\u003ebuilt for high-performance, interactive scientific visualization.\u003c/p\u003e\u003ch2 id=\"c3ae\"\u003e\u003cstrong\u003efastplotlib\u003c/strong\u003e\u003c/h2\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003ca href=\"https://github.com/fastplotlib/fastplotlib\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/fastplotlib/fastplotlib\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"fc6c\"\u003e\u003ccode\u003efastplotlib\u003c/code\u003e is a very new open source Python-based GPU-accelerated scientific plotting library.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eLarge-scale calcium imaging dataset with corresponding behavior and down-stream analysis\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"a00d\"\u003e\u003cstrong\u003eWhat can you do with \u003cem\u003efastplotlib\u003c/em\u003e?\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli id=\"ce7c\"\u003eGPU-accelerated visualization (a modern integrated GPU is sufficient for most use cases)\u003c/li\u003e\u003cli id=\"01c4\"\u003eRapid prototyping and algorithm design\u003c/li\u003e\u003cli id=\"c239\"\u003eExploration and fast rendering of large-scale data\u003c/li\u003e\u003cli id=\"5be7\"\u003eCreation of real-time acquisition systems for instruments\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp id=\"d575\"\u003eNote: this is by no means an exhaustive list, merely just the highlights :)\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a412\"\u003eAgenda\u003c/h2\u003e\u003cp id=\"e2ec\"\u003eIn the remainder of this article, I am going to cover the following topics that highlight why \u003ccode\u003efastplotlib\u003c/code\u003e is a powerful tool that can be used to drive scientific discovery through data visualization:\u003c/p\u003e\u003cul\u003e\u003cli id=\"cb40\"\u003eScientific visualization is more than just \u003cem\u003estatic\u003c/em\u003e plots\u003c/li\u003e\u003cli id=\"8daa\"\u003eAPI design matters\u003c/li\u003e\u003cli id=\"8363\"\u003eLeveraging new hardware is critical\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c3f9\"\u003eScientific visualization is more than just \u003cem\u003estatic\u003c/em\u003e plots\u003c/h2\u003e\u003cp id=\"4cbe\"\u003eWhile scientific visualization has traditionally relied on static plots, dynamic and interactive visualizations are the key to enhancing data exploration and analysis.\u003c/p\u003e\u003cp id=\"6164\"\u003eFor example, consider the interactive plot depicted below.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eInteractive covariance matrix of Olivetti faces dataset\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"6ef2\"\u003eThis plot shows a simple interactive visualization of a covariance matrix in \u003ccode\u003efastplotlib\u003c/code\u003e. As a formal definition, a covariance matrix gives a measure of how pairs of random variables change together.\u003c/p\u003e\u003cp id=\"f860\"\u003eIn the left subplot, the covariance matrix for the \u003ca href=\"https://scikit-learn.org/0.19/datasets/olivetti_faces.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eOlivetti faces dataset\u003c/a\u003e is shown. In this case, each entry in the covariance matrix indicates how the intensity of any two pixels varies. In the right subplot is the reconstructed row image from the currently selected row of the covariance matrix. We can easily change what row of the covariance matrix we are looking at by simply moving the selector.\u003c/p\u003e\u003cp id=\"6bdf\"\u003eIt is very clear visually that looking at the reconstructed image for each row of the covariance matrix is much more informative than having a static plot of just the covariance matrix by itself. By looking at the reconstructed row image, we can get a sense of how the pixel intensity is changing across faces in the dataset.\u003c/p\u003e\u003cp id=\"832b\"\u003eThe purpose of displaying this plot is not to conduct a detailed analysis of the covariance matrix but to demonstrate how even a small degree of interactivity can enhance our understanding of the data, ultimately transforming the types of analysis we may pursue in the future.\u003c/p\u003e\u003cp id=\"ca66\"\u003eThe goal of \u003ccode\u003efastplotlib\u003c/code\u003e is to expand the field of scientific visualization by providing a mechanism that allows the creation of high-level interactive plots, ultimately driving scientific discovery.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"9405\"\u003eAPI design matters\u003c/h2\u003e\u003cp id=\"d229\"\u003eThe ecosystem for scientific visualization has come a long way since the early 2000s.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eScientific Python visualization ecosystem timeline\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c471\"\u003eThese days, there are many open-source Python visualization tools available. However, one limiting factor for scientists and other users is the high barrier to entry in learning how to use some of these libraries. Often, users are forced to learn complicated APIs that make it difficult to focus on their data or research questions.\u003c/p\u003e\u003cp id=\"93fa\"\u003eIn \u003ccode\u003efastplotlib\u003c/code\u003e, we aim to provide fast interactive visualization via an easy-to-use and intuitive API.\u003c/p\u003e\u003cp id=\"e288\"\u003e\u003cstrong\u003e1) Data interaction\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"a621\"\u003eThe premise behind our API design is that you should never have to think of your data as anything but an array.\u003c/p\u003e\u003cp id=\"4d5c\"\u003eIf the data in our visualization maintains an array-like structure we are familiar with, interacting with the visualization becomes much easier.\u003c/p\u003e\u003cp id=\"c5e7\"\u003eConsider the following example:\u003c/p\u003e\u003cp id=\"871b\"\u003eSuppose we want to plot a simple sine wave.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0360\"\u003eimport fastplotlib as fpl\u003cbr/\u003eimport numpy as np\u003cp\u003e# generate some data \u003cbr/\u003exs = np.linspace(-10, 10, 100)\u003cbr/\u003eys = np.sin(xs)\u003cbr/\u003edata = np.dstack([xs, ys])[0]\u003c/p\u003e\u003cp\u003e# create a figure\u003cbr/\u003efigure = fpl.Figure()\u003c/p\u003e\u003cp\u003e# add the data to the figure\u003cbr/\u003esine_wave = figure[0, 0].add_line(data=data, thickness=10)\u003c/p\u003e\u003cp\u003efigure.show()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003esimple sine wave\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"af07\"\u003eNow, say we wanted to change every third point of our sine wave to have the color red. If the data in our visualization can be thought of as an array, then doing this kind of fancy indexing isn’t any different than usual NumPy array manipulation.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"3d06\"\u003esine_wave.colors[::3] = \u0026#34;red\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003efancy index sine wave colors\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"09c1\"\u003eWith this framework, we can perform all sorts of dynamic manipulations to different features of our graphic (e.g., color maps, colors, data, etc.) after we have initially plotted something.\u003c/p\u003e\u003cp id=\"2463\"\u003eThe goal of taking this approach to the API design is to limit the amount of mental overhead required to use \u003ccode\u003efastplotlib\u003c/code\u003e, ultimately making the library flexible, intuitive, and easy to use.\u003c/p\u003e\u003cp id=\"bafe\"\u003e\u003cstrong\u003e2) Events\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"6261\"\u003eAnother area of our API that we have tried to simplify for users is our events system. Using simple callback functions, we can define events between graphics or plots, which allows for the generation and build-up of interactive visualizations.\u003c/p\u003e\u003cp id=\"ace9\"\u003eFor example, suppose we wanted to define a simple click event. Let’s first generate some data.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8946\"\u003eimport fastplotlib as fpl\u003cbr/\u003eimport numpy as np\u003cp\u003e# generate some circles\u003cbr/\u003edef make_circle(center, radius: float, n_points: int = 75) -\u0026gt; np.ndarray:\u003cbr/\u003e    theta = np.linspace(0, 2 * np.pi, n_points)\u003cbr/\u003e    xs = radius * np.sin(theta)\u003cbr/\u003e    ys = radius * np.cos(theta)\u003c/p\u003e\u003cp\u003e    return np.column_stack([xs, ys]) + center\u003c/p\u003e\u003cp\u003ecircles = list()\u003cbr/\u003efor x in range(0, 50, 10):\u003cbr/\u003e    circles.append(make_circle(center=(x, 0), radius=4, n_points=100))\u003c/p\u003e\u003cp\u003e# create figure\u003cbr/\u003efig = fpl.Figure()\u003c/p\u003e\u003cp\u003e# add circles to plot\u003cbr/\u003ecircles_graphic = fig[0,0].add_line_collection(data=circles, cmap=\u0026#34;tab10\u0026#34;, thickness=10)\u003c/p\u003e\u003cp\u003efig.show()\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003esimple plot of circles\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"dd71\"\u003eNow that we have generated our data, we can define a click event so that when we click on the plot, we get the closest circle and “highlight” it.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"71ef\"\u003e# get the nearest graphic that is clicked and change the color\u003cbr/\u003e@fig.renderer.add_event_handler(\u0026#34;click\u0026#34;)\u003cbr/\u003edef click_event(ev):\u003cbr/\u003e    # reset colors\u003cbr/\u003e    circles_graphic.cmap = \u0026#34;tab10\u0026#34;\u003cp\u003e    # map the click position to world coordinates\u003cbr/\u003e    xy = fig[0, 0].map_screen_to_world(ev)[:-1]\u003c/p\u003e\u003cp\u003e    # get the nearest graphic to the position\u003cbr/\u003e    nearest = fpl.utils.get_nearest_graphics(xy, circles_graphic)[0]\u003c/p\u003e\u003cp\u003e    # change the closest graphic color to white\u003cbr/\u003e    nearest.colors = \u0026#34;w\u0026#34;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003cfigcaption\u003esimple click event\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f29e\"\u003eIn \u003ccode\u003efastplotlib\u003c/code\u003e, specifying an event is as simple as defining how we want to handle the event and then adding our handler to the appropriate graphic or plot the event corresponds to. The beauty of this approach is that it doesn’t require users to learn new, complicated, library-specific API features (knowing how to define functions is sufficient).\u003c/p\u003e\u003cp id=\"21ed\"\u003eThe streamlined design of our API for data interaction and event handling is a key strength of the library, making \u003ccode\u003efastplotlib\u003c/code\u003e both intuitive and easy to master.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"006b\"\u003eLeveraging new hardware is critical\u003c/h2\u003e\u003cp id=\"fdb8\"\u003eThese days, having a GPU is practically a prerequisite to doing science, and visualization is no exception.\u003c/p\u003e\u003cp id=\"f57a\"\u003eMaximizing the computational resources on the GPU is a key factor in making high-resolution performant visualizations.\u003c/p\u003e\u003cp id=\"58f1\"\u003eDepicted below is an example of plotting 3 million points using \u003ccode\u003efastplotlib\u003c/code\u003e. Not only are we plotting the lines, but we are also easily zooming in and out, changing the color map of the lines, and even further, individually changing the color of specific points.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003efastpotlib 3 million points line example\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e690\"\u003ePlotting this many points at once and having fine-grained control over the colors of the points is impossible in many other Python scientific visualization libraries.\u003c/p\u003e\u003cp id=\"b921\"\u003eWhat makes the performance capabilities of \u003cem\u003efastplotlib\u003c/em\u003e so powerful is the underlying graphics technology on which it is built.\u003c/p\u003e\u003cp id=\"ba6a\"\u003e\u003cstrong\u003eThe nitty gritty details\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"24e5\"\u003e\u003ccode\u003efastplotlib\u003c/code\u003e is abstracted on top of the \u003ca href=\"https://github.com/pygfx/pygfx\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003epygfx\u003c/a\u003e rendering engine. \u003ccode\u003epygfx\u003c/code\u003e, in turn, is powered by \u003ca href=\"https://github.com/pygfx/wgpu-py/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWGPU\u003c/a\u003e, a cross-platform graphics API that targets Vulkan (Linux), Metal (Mac), and DX12 (Windows).\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003efastplotlib software stack\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"dfb3\"\u003eIn essence, these new graphics APIs (Vulkan, Metal, and DX12) are very \u003cstrong\u003efast\u003c/strong\u003e, \u003cstrong\u003eefficient\u003c/strong\u003e, and \u003cstrong\u003eleverage GPU hardware better than OpenGL\u003c/strong\u003e, the old graphics standard.\u003c/p\u003e\u003cp id=\"178c\"\u003eThe reason we built \u003ccode\u003efastplotlib\u003c/code\u003e on top of \u003ccode\u003epygfx\u003c/code\u003e is to abstract away some of the lower-level rendering engine details (e.g., the camera, renderer, scene, etc.) that are boilerplate code for many visualizations. This allows users to focus primarily on their data!\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8c7f\"\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"dad0\"\u003eIt is one thing for it to be easy to see your data and explore different dimensions, but being able to interact with your data after it is initially plotted, we believe, is the key to driving scientific discovery. However, the ability to create these interactive plots that allow you to explore and analyze your data easily and intuitively is not trivial.\u003c/p\u003e\u003cp id=\"254f\"\u003eMany prominent Python visualization libraries force you to learn complicated APIs, making the barrier to entry high. Furthermore, many of these libraries are built on \u003ca href=\"https://www.opengl.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eOpenGL\u003c/a\u003e, an older graphics API that \u003ca href=\"https://www.vulkan.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eVulkan\u003c/a\u003e, \u003ca href=\"https://developer.apple.com/documentation/metal/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMetal\u003c/a\u003e, and \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eDX12\u003c/a\u003e are slowly replacing. These new graphics APIs leverage the GPU better, allowing for more powerful and expressive visualizations.\u003c/p\u003e\u003cp id=\"ff35\"\u003e\u003ccode\u003efastplotlib\u003c/code\u003e seeks to address current challenges in Python scientific visualization by providing an easy-to-use array-like API that leverages modern graphics hardware to provide GPU-accelerated fast interactive visualization.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"b0f9\"\u003e\u003cstrong\u003eDocumentation \u0026amp; Examples\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"03f9\"\u003eOur documentation and examples can be found \u003ca href=\"https://www.fastplotlib.org/ver/dev/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehere\u003c/a\u003e. This includes a user guide and how-to on getting started using \u003ccode\u003efastplotlib\u003c/code\u003e. We also have an extensive examples gallery that we are always expanding.\u003c/p\u003e\u003cp id=\"57b4\"\u003eLastly, we are always happy to help you visualize your data, and we would love to add more examples to our library for your use case!\u003c/p\u003e\u003ch2 id=\"076e\"\u003e\u003cstrong\u003eContact Us\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"367b\"\u003eWe love to interact with our community ❤️\u003c/p\u003e\u003cp id=\"1d21\"\u003eIf you have questions or would like to chat, feel free to contact us by posting a GitHub Issue or Discussion!\u003c/p\u003e\u003ch2 id=\"e064\"\u003e\u003cstrong\u003eFuture articles\u003c/strong\u003e\u003c/h2\u003e\u003cp id=\"845d\"\u003eWe plan on this being the first in a series of articles. In the future, we would like to add articles walking through examples using \u003ccode\u003efastplotlib \u003c/code\u003eand potentially some in-depth articles on the underlying graphics technology.\u003c/p\u003e\u003cp id=\"e81c\"\u003eIf this is something you would be interested in, please let us know :D\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-03-11T13:40:12.48Z",
  "modifiedTime": null
}
