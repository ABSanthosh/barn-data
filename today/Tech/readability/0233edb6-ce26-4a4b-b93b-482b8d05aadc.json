{
  "id": "0233edb6-ce26-4a4b-b93b-482b8d05aadc",
  "title": "NixOS and reproducible builds could have detected the xz backdoor",
  "link": "https://luj.fr/blog/how-nixos-could-have-detected-xz.html",
  "description": "Comments",
  "author": "",
  "published": "Sat, 22 Mar 2025 19:39:59 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "",
  "length": 32808,
  "excerpt": "Julien Malka homepage",
  "siteName": "",
  "favicon": "",
  "text": "Introduction In March 2024, a backdoor was discovered in xz, a (de)-compression software that is regularly used at the core of Linux distributions to unpack source tarballs of packaged software. The backdoor had been covertly inserted by a malicious maintainer under the pseudonym of Jia Tan over a period of three years. This event deeply stunned the open source community as the attack was both of massive impact (it allowed remote code execution on all affected machines that had ssh installed) and extremely difficult to detect. In fact, it was only thanks to the diligence (and maybe luck) of Andres Freund – a Postgres developer working at Microsoft – that the catastrophe was avoided: while investigating a seemingly unrelated 500ms performance regression in ssh that he was experiencing on several Debian unstable machines, he was able to trace it back to the liblzma library, identify the backdoor and document it. While it was already established that the open source supply chain was often the target of malicious actors, what is stunning is the amount of energy invested by Jia Tan to gain the trust of the maintainer of the xz project, acquire push access to the repository and then among other perfectly legitimate contributions insert – piece by piece – the code for a very sophisticated and obfuscated backdoor. This should be a wake up call for the OSS community. We should consider the open source supply chain a high value target for powerful threat actors, and to collectively find countermeasures against such attacks. In this article, I’ll discuss the inner workings of the xz backdoor and how I think we could have mechanically detected it thanks to build reproducibility. How does the attack work? The main intent of the backdoor is to allow for remote code execution on the target by hijacking the ssh program. To do that, it replaces the behavior of some of ssh’s functions (most importantly the RSA_public_decrypt one) in order to allow an attacker to execute arbitrary commands on a victim’s machine when some specific RSA key is used to log in. Two main pieces are combined to put together to install and activate the backdoor: A script to de-obfuscate and install a malicious object file as part of the xz build process. Interestingly the backdoor was not comprehensively contained in the source code for xz. Instead, the malicious components were only contained in tarballs built and signed by the malicious maintainer Jia Tan and published alongside releases 5.6.0 and 5.6.1 of xz. This time the additional release tarball contained slight and disguised modifications to extract a malicious object file from the .xz files used as data for some test contained in the repository. A procedure to hook the RSA_public_decrypt function. The backdoor uses the ifunc mechanism of glibc to modify the address of the RSA_public_function when ssh is loaded, in case ssh links against liblzma through libsystemd. 1. A script to de-obfuscate and install a malicious object file as part of the xz build process As explained above, the malicious object file is stored directly in the xz git repository, hidden in some test files. The project being a decompression software, test cases include .xz files to be decompressed, making it possible to hide some machine code into fake test files; The backdoor is not active in the code contained in the git repository, it is only included by building xz from the tarball released by the project, which has a few differences with the actual contents of the repository, most importantly in the m4/build-to-host.m4 file. diff --git a/m4/build-to-host.m4 b/m4/build-to-host.m4 index f928e9ab..d5ec3153 100644 --- a/m4/build-to-host.m4 +++ b/m4/build-to-host.m4 @@ -1,4 +1,4 @@ -# build-to-host.m4 serial 3 +# build-to-host.m4 serial 30 dnl Copyright (C) 2023-2024 Free Software Foundation, Inc. dnl This file is free software; the Free Software Foundation dnl gives unlimited permission to copy and/or distribute it, @@ -37,6 +37,7 @@ AC_DEFUN([gl_BUILD_TO_HOST], dnl Define somedir_c. gl_final_[$1]=\"$[$1]\" + gl_[$1]_prefix=`echo $gl_am_configmake | sed \"s/.*\\.//g\"` dnl Translate it from build syntax to host syntax. case \"$build_os\" in cygwin*) @@ -58,14 +59,40 @@ AC_DEFUN([gl_BUILD_TO_HOST], if test \"$[$1]_c_make\" = '\\\"'\"${gl_final_[$1]}\"'\\\"'; then [$1]_c_make='\\\"$([$1])\\\"' fi + if test \"x$gl_am_configmake\" != \"x\"; then + gl_[$1]_config='sed \\\"r\\n\\\" $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2\u003e/dev/null' + else + gl_[$1]_config='' + fi + _LT_TAGDECL([], [gl_path_map], [2])dnl + _LT_TAGDECL([], [gl_[$1]_prefix], [2])dnl + _LT_TAGDECL([], [gl_am_configmake], [2])dnl + _LT_TAGDECL([], [[$1]_c_make], [2])dnl + _LT_TAGDECL([], [gl_[$1]_config], [2])dnl AC_SUBST([$1_c_make]) + + dnl If the host conversion code has been placed in $gl_config_gt, + dnl instead of duplicating it all over again into config.status, + dnl then we will have config.status run $gl_config_gt later, so it + dnl needs to know what name is stored there: + AC_CONFIG_COMMANDS([build-to-host], [eval $gl_config_gt | $SHELL 2\u003e/dev/null], [gl_config_gt=\"eval \\$gl_[$1]_config\"]) ]) dnl Some initializations for gl_BUILD_TO_HOST. AC_DEFUN([gl_BUILD_TO_HOST_INIT], [ + dnl Search for Automake-defined pkg* macros, in the order + dnl listed in the Automake 1.10a+ documentation. + gl_am_configmake=`grep -aErls \"#{4}[[:alnum:]]{5}#{4}$\" $srcdir/ 2\u003e/dev/null` + if test -n \"$gl_am_configmake\"; then + HAVE_PKG_CONFIGMAKE=1 + else + HAVE_PKG_CONFIGMAKE=0 + fi + gl_sed_double_backslashes='s/\\\\/\\\\\\\\/g' gl_sed_escape_doublequotes='s/\"/\\\\\"/g' + gl_path_map='tr \"\\t \\-_\" \" \\t_\\-\"' changequote(,)dnl gl_sed_escape_for_make_1=\"s,\\\\([ \\\"\u0026'();\u003c\u003e\\\\\\\\\\`|]\\\\),\\\\\\\\\\\\1,g\" changequote([,])dnl While these changes may look benign to the naive eyes and well commented, they are actually hiding a chain of commands that decrypts/deobfuscates several fake .xz test files to ultimately produce two files: a shell script that is run during the build of xz ; a malicious binary object file. There is an excellent analysis from Russ Cox that explains in detail how these two malicious resources are produced during the build process, and I advise any interested reader to find all relevant details there. The shell script run during the build has two main purposes: Verifying that the conditions to execute the backdoor are met on the builder (the backdoor targets specific Linux distributions, needs specific features of the glibc activated, needs ssh installed, etc) ; Modifying the (legitimate) liblzma_la-crc64_fast.o to use the _get_cpuid symbol defined in the backdoor object file. 2. A procedure to hook the RSA_public_decrypt function So how does a backdoor in the xz executable have any effect on ssh? To understand that, we have to take a little detour in the realm of dynamic loaders and dynamically linked programs. Whenever a program depends on a library, there are two ways that library can be linked into the final executable: statically, in that case the library is embedded into the final executable, hence increasing its size ; dynamically, in which case it is the role of the dynamic loader (ld-linux.so in Linux) to find that shared library when the program starts and load it in memory. When a program is compiled using dynamic linking, the addresses of the symbols belonging to dynamically linked libraries cannot be provided at compilation time: their position in memory is not know ahead of time! Instead, a reference to the Global Offset Table (or GOT) is inserted. When the program is started, the actual addresses are filled in the GOT by the dynamic linker. The xz backdoor uses a functionality of the glibc called ifunc to force execution of code during dynamic loading time: ifunc is designed to allow selection between several implementations of the same function at dynamic loading time. #include \u003cstdio.h\u003e // Declaration of ifunc resolver function int (*resolve_add(void))(int, int); // First version of the add function int add_v1(int a, int b) { printf(\"Using add_v1\\n\"); return a + b; } // Second version of the add function int add_v2(int a, int b) { printf(\"Using add_v2\\n\"); return a + b; } // Resolver function that chooses the correct version of the function int (*resolve_add(void))(int, int) { // You can implement any runtime check here. // In that case we check if the system is 64bit if (sizeof(void*) == 8) { return add_v2; } else { return add_v1; } } // Define the ifunc attribute for the add function int add(int a, int b) __attribute__((ifunc(\"resolve_add\"))); int main() { int result = add(10, 20); printf(\"Result: %d\\n\", result); return 0; } In the above example, the ifunc attribute surrounding the add function indicates that the version that will be executed will be determined at dynamic loading time by running the resolve_add function. In that case, the resolve_add function returns add_v1 or add_v2 depending if the running system is a 64 bit system or not – and as such is completely harmless – but this technique is used by the xz backdoor to run some malicious code at dynamic loading time. But dynamic loading of which program? Well, of ssh! In some Linux distributions (Debian and Fedora for example), ssh is patched to support systemd notifications and for this purpose, links with libsystemd, that in turn links with liblzma. In those distribution sshd hence has a transitive dependency on liblzma. Dependency chain between sshd and liblzma This is how the backdoor works: whenever sshd is executed, the dynamic loader loads libsystemd and then liblzma. With the backdoor installed, and leveraging the ifunc functionality as explained above, the backdoor is able to run arbitrary code when liblzma is being loaded. Indeed, as you remember from the previous section, the backdoor script modifies one of the legitimate xz object files: it actually modifies the resolver of one of the functions that uses ifunc to call its own malicious _get_cpuid symbol. When called, this function meddles with the GOT (that is not yet read-only at this time of execution) to modify the address of the RSA_public_decrypt function, replacing it by a malicious one! That’s it, at this point sshd uses the malicious RSA_public_decrypt function that gives RCE privileges to the attacker. Once again, there exist more precise reports on exactly how the hooking happens that a curious reader might read, like this one for example. There is also a research article summarizing the attack vector and possible mitigations that I recommend reading. Avoiding the xz catastrophe in the future What should our takeaways be from this near-miss and what should we do to minimize the risks of such an attack happening again in the future? Obviously, there is a lot to be said about the social issues at play here1 and how we can build better resilience in the OSS ecosystem against malicious entities taking over really fundamental OSS projects, but in this piece I’ll only address the technical aspects of the question. People are often convinced that OSS is more trustworthy than closed-source software because the code can be audited by practitioners and security professionals in order to detect vulnerabilities or backdoors. In this instance, this procedure has been made difficult by the fact that part of the code activating the backdoor was not included in the sources available within the git repository but was instead present in the maintainer-provided tarball. While this was used to hide the backdoor out of sight of most investigating eyes, this is also an opportunity for us to improve our software supply chain security processes. Building software from trusted sources One immediate observation that we can make in reaction to this supply chain incident is that it was only effective because a lot of distributions were using the maintainer provided tarball to build xz instead of the raw source code supplied by the git forge (in this case, GitHub). This reliance on release tarballs has plenty of historical and practical reasons: the tarball workflow predates the existence of git and was used in the earliest Linux distributions; tarballs are self-contained archives that encapsulate the exact state of the source code intended for release while git repositories can be altered, creating the need for a snapshot of the code; tarballs can contain intermediary artifacts (for example manpages) used to lighten the build process, or configure scripts to target specific hardware, etc; tarballs allow the source code to be compressed which is useful for space efficiency. This being said, these reasons do not weigh enough in my opinion to justify the security risks they create. In all places where it is technically feasible, we should build software from sources authenticated by the most trustworthy party. For example, if a project is developed on GitHub, an archive is automatically generated by GitHub for each release. The risk of a compromise of that release archive is far lower than the risk of a malicious maintainer distributing unfaithful tarballs, as it would require compromising the GitHub infrastructure (and at this point the problem is much more serious). This reasoning can be extended in all cases where the development is happening on a platform operated by a trusted third party like Codeberg/SourceHut/Gitlab, etc. When the situation allows it… NixOS is a distribution built on the functional package management model, that is to say every package is encoded as an expression written in Nix, a functional programming language. A Nix expression for a software project is usually a function mapping all the project dependencies to a “build recipe” that can be later executed to build the package. I am a NixOS developer and I was surprised when the backdoor was revealed to see that the malicious version of xz had ended up being distributed to our users2. While there is no policy about this, there is a culture among NixOS maintainers of using the source archive automatically generated by GitHub (that are simply snapshots of the source code) when available through the fetchFromGitHub function. In the simplified example of the xz package below, you can see that the sources for the package are actually extracted from the manually uploaded malicious maintainer provided tarball through another source fetcher: fetchurl. { lib, stdenv, fetchurl , enableStatic ? stdenv.hostPlatform.isStatic }: stdenv.mkDerivation rec { pname = \"xz\"; version = \"5.6.0\"; src = fetchurl { url = \"https://github.com/tukaani-project/xz/releases/download/v${version}/xz-${version}.tar.xz\"; hash = \"sha256-AWGCxwu1x8nrNGUDDjp/a6ol4XsOjAr+kncuYCGEPOI=\"; }; ... } To understand why, we must first talk about the bootstrap of nixpkgs. The concept of a bootstrap is the idea that one could rebuild all of the packages in nixpkgs from a small set of seed binaries. This is an important security property because it means that there are no other external tools that one must trust in order to trust the toolchain that is used to build the software distribution. What we call the “bootstrap” in the context of a software distribution like nixpkgs, is all the steps needed to build the basic compilation environment to be used by other packages, called stdenv in nixpkgs. Building stdenv is not an easy task; how does one build gcc when one doesn’t even have a C compiler? The answer is that you start from a very small binary that does nothing fancy but is enough to build hex, a minimalist assembler, which in turn can build a more complex assembler, and this until we are able to build more complex software and finally a modern C compiler. The bootstraping story of Nix/Guix is an incredibly interesting topic, that I will not cover extensively here, but I strongly advise reading blog posts from the Guix community, that are on the bleeding edge (they have introduced a 357-byte bootstrap that is being adapted for nixpkgs). What does all that has to do with xz though? Well, xz is included in the nixpkgs bootstrap! $ nix-build -A stdenv /nix/store/91d27rjqlhkzx7mhzxrir1jcr40nyc7p-stdenv-linux $ nix-store --query --graph result We can see now that stdenv depends at runtime on xz, so it is indeed built during the bootstrap stage. To understand a bit more why this is the case, I’ll also generate a graph of the software in stdenv that depends on xz at buildtime. $ nix-store --query --graph $(nix-eval --raw -f default stdenv.drvPath) We can see that several packages depend on xz. Let’s take coreutils for example and try to understand why it depends on xz by reading its derivation file, which is the intermediary representation of the build process obtained by evaluating the Nix expression for coreutils: { \"/nix/store/57hlz5fnvfgljivf7p18fmcl1yp6d29z-coreutils-9.5.drv\": { \"args\": [ \"-e\", \"/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh\" ], \"builder\": \"/nix/store/razasrvdg7ckplfmvdxv4ia3wbayr94s-bootstrap-tools/bin/bash\", ... \"inputDrvs\": { ... \"/nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv\": { \"dynamicOutputs\": {}, \"outputs\": [ \"bin\" ] }, \"/nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv\": { \"dynamicOutputs\": {}, \"outputs\": [ \"out\" ] } }, ... \"system\": \"x86_64-linux\" } } The inputDrvs field here correspond to all the other packages or expressions that the coreutils build process depends on. We see that in particular it depends on two components: /nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv, which is xz itself; /nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv which is a source archive for coreutils! As it is a .xz archive, we need xz to unpack it and that is where the dependency comes from! The same reasoning applies to the other three direct dependencies that we could see in the graph earlier. xz being built as part of the bootstrap means it doesn’t have access to all the facilities normal packages in nixpkgs can rely on. In particular it can only access packages that are built before in bootstrap. For example, to build xz from sources, we need autoconf to generate the configure script. But autoconf has a dependency on xz! Using the maintainer tarball allows us to break this dependency cycle. $ nix why-depends --derivation nixpkgs#autoconf nixpkgs#xz /nix/store/2rajzdx3wkivlc38fyhj0avyp10k2vjj-autoconf-2.72.drv └───/nix/store/jnnb5ihdh6r3idmqrj2ha95ir42icafq-stdenv-linux.drv └───/nix/store/sqwqnilfwkw6p2f5gaj6n1xlsy054fnw-xz-5.6.4.drv In conclusion, at the point in the nixpkgs graph where the xz package is built, the GitHub source archive cannot be used and we have to rely on the maintainer provided tarball, and hence, trust it. That does not mean that further verification cannot be implemented in nixpkgs, though… Building trust into untrusted release tarballs To recap, the main reason that made NixOS vulnerable to the xz attack is that it is built as part of the bootstrap phase, at a point where we rely on maintainer-provided tarballs instead of the ones generated by GitHub. This incident shows that we should have specific protections in place, to ensure software built as part of our bootstrap is trustworthy. 1. By comparing sources One idea that comes to mind is that it should be easy, as a distribution, to verify that the sources tarballs we are using are indeed identical to the GitHub ones. There was even a pull request opened to introduce such a protection scheme. While this seem like a natural idea, it doesn’t really work in practice: it’s not that rare that the maintainer provided tarball differs from the sources, and it’s often nothing to worry about. Post by @bagder@mastodon.social View on Mastodon As Daniel Stenberg (the maintainer of curl) explains, the release tarball being different than the source is a feature: it allows the maintainer to include intermediary artifacts like manpages or configure scripts for example (this is especially useful for distributions that want to get rid of the dependency on autoconf to build the program). Of course when we care about software supply chain security, this flexibility that project maintainers have in the way they provide the release assets is actually a liability because it forces us to trust them to do it honestly. 2. Leveraging bitwise reproducibility Reproducible builds is a property of a software project that is verified if building it twice in the same conditions yields the exact same (bitwise identical) artifacts. Build reproducibility is not something easy to obtain, as there are all kinds of nondeterminisms that can happen in build processes, and making as many packages as possible reproducible is the purpose of the reproducible-builds group. It is also a property recognized as instrumental to increase the trust in the distribution of binary artifacts (see Reproducible Builds: Increasing the Integrity of Software Supply Chains for a detailed report). There are several ways bitwise reproducibility could be used to build up trust in untrusted maintainer provided tarballs: Reproducibly building the tarball A first approach that has been adopted by the postgresql project is to make the tarball generation process reproducible. This allows any user (or a linux distribution) to independently verify that the maintainer provided tarball was honestly generated from the original source code. With this method, you can keep some advantages of building from tarballs (including the tarball containing some intermediary build artifacts like manpages or configure scripts). However, the drawback of this approach for software supply chain security is that it has to be implemented by upstream project maintainers. This means that adoption of this kind of security feature will probably be slow in the FOSS community, and while it is a good practice to make everything reproducible, including the tarball generation process, this is not the most effective way to increase software supply chain security today. Checking for build convergence between various starting assets Assuming xz is bitwise reproducible (and that is indeed the case), and that the maintainer provided tarball doesn’t contain any modification that impacts the build process, building it from the GitHub tarball or from the maintainer provided tarball should produce the same artifacts, right? Based on this idea, my proposal is to build xz a second time after the bootstrap, this time using the GitHub tarball (which is only possible after the bootstrap). If both builds differ we can suspect that there a suspicion of a supply chain compromise. Summary of the method I propose to detect vulnerable xz source tarballs Let’s see how this could be implemented: First, we rewrite the xz package, this time using the fetchFromGitHub function. I create a after-boostrap.nix file alongside the original xz expression in the pkgs/tools/compression/xz directory of nixpkgs: { lib, stdenv, fetchurl, enableStatic ? false, writeScript, fetchFromGitHub, testers, gettext, autoconf, libtool, automake, perl538Packages, doxygen, xz, }: stdenv.mkDerivation (finalAttrs: { pname = \"xz\"; version = \"5.6.1\"; src = fetchFromGitHub { owner = \"tukaani-project\"; repo = \"xz\"; rev = \"v${finalAttrs.version}\"; hash = \"sha256-alrSXZ0KWVlti6crmdxf/qMdrvZsY5yigcV9j6GIZ6c=\"; }; strictDeps = true; configureFlags = lib.optional enableStatic \"--disable-shared\"; enableParallelBuilding = true; doCheck = true; nativeBuildInputs = [ gettext autoconf libtool automake perl538Packages.Po4a doxygen perl ]; preConfigure = '' ./autogen.sh ''; }) I removed details here to focus on the most important: the Nix expression is very similar to the actual derivation for xz, the only difference (apart from the method to fetch the source) is that we need to use autoconf to generate configure scripts. When using the maintainer provided tarball these are already pre-generated for us (as Daniel Stenberg was explaining in the toot above) – which is very handy particularly when you are building xz in the bootstrap phase of a distribution and you don’t want a dependency on autoconf / automake – but in this instance we have to do it ourselves. Now that we can build xz from the code archive provided by GitHub, we have to write Nix code to compare both outputs. For that purpose, we register a new phase called compareArtifacts, that runs at the very end of the build process. To make my point, I’ll first only compare the liblzma.so file (the one that was modified by the backdoor), but we could easily generalize this phase to all binaries and libraries outputs: postPhases = [ \"compareArtifacts\" ]; compareArtifacts = '' diff $out/lib/liblzma.so ${xz.out}/lib/liblzma.so ''; After this change, building xz-after-bootstrap on master3 still works, showing that in a normal setting, both artifacts are indeed identical. $ nix-build -A xz-after-bootstrap /nix/store/h23rfcjxbp1vqmmbvxkv0f69r579kfc1-xz-5.6.1 Let’s now try our detection method on the backdoored xz and see what happens! We checkout revision c53bbe3 that contains the said version4, and build xz-after-bootstrap. $ git checkout c53bbe3 $ nix-build -A xz-after-boostrap /nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1 Again, identical artifacts? Remember that the backdoor was not active in NixOS, partly because there is a check that the RPM_ARCH variable is set in the script that installs the backdoor. So let’s set it in pkgs/tools/compression/xz/default.nix to activate the backdoor5. env.RPM_ARCH = true; $ nix-build -A xz-after-boostrap /nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1 ... ... Running phase: compareBins Binary files /nix/store/cxz8iq3hx65krsyraill6figp03dk54n-xz-5.6.1/lib/liblzma.so and /nix/store/4qp2khyb22hg6a3jiy4hqmasjinfkp2g-xz-5.6.1/lib/liblzma.so differ That’s it, binary artifacts are different now! Let’s try to understand a bit more what makes them different by keeping them as part of the output. For that, we modify the compareArtifacts phase: compareArtifacts = '' cp ${xz.out}/lib/liblzma.so $out/xzBootstrap cp $out/lib/liblzma.so $out/xzAfterBootstrap diff $out/lib/liblzma.so ${xz.out}/lib/liblzma.so || true ''; This time the diff doesn’t make the build fail and we store both versions of the liblzma.so to be able to compare them afterwards. $ ls -lah result total 69M dr-xr-xr-x 6 root root 99 Jan 1 1970 . drwxrwxr-t 365666 root nixbld 85M Dec 10 14:27 .. dr-xr-xr-x 2 root root 4.0K Jan 1 1970 bin dr-xr-xr-x 3 root root 32 Jan 1 1970 include dr-xr-xr-x 3 root root 103 Jan 1 1970 lib dr-xr-xr-x 4 root root 31 Jan 1 1970 share -r-xr-xr-x 1 root root 210K Jan 1 1970 xzAfterBootstrap -r-xr-xr-x 1 root root 258K Jan 1 1970 xzBootstrap We can notice that there is even a significant size difference between the two artifacts with an increase of 48Kb for the backdoored one. Let’s try to understand where this difference comes from. We can use the nm command from binutils to list the symbols in an artifact: $ nm result/xzAfterBootstrap 000000000000d3b0 t alone_decode 000000000000d380 t alone_decoder_end 000000000000d240 t alone_decoder_memconfig 0000000000008cc0 t alone_encode 0000000000008c90 t alone_encoder_end 0000000000008db0 t alone_encoder_init 0000000000020a80 t arm64_code 0000000000020810 t arm_code 0000000000020910 t armthumb_code 000000000000d8d0 t auto_decode 000000000000d8a0 t auto_decoder_end 000000000000d730 t auto_decoder_get_check 000000000000d7a0 t auto_decoder_init 000000000000d750 t auto_decoder_memconfig 0000000000022850 r available_checks.1 00000000000225f0 r bcj_optmap 0000000000008fb0 t block_buffer_encode ... Now we can diff the symbols between the two artifacts: $ diff -u0 \u003c(nm --format=just-symbols xzAfterBootstrap) \u003c(nm --format=just-symbols xzBootstrap) --- /dev/fd/63 2024-12-10 15:27:11.477332683 +0000 +++ /dev/fd/62 2024-12-10 15:27:11.478332717 +0000 @@ -31,0 +32 @@ +_cpuid @@ -65,0 +67 @@ +_get_cpuid @@ -448,0 +451 @@ +__tls_get_addr@GLIBC_2.3 TADA! We see the added _get_cpuid symbol, documented in numerous technical report about the xz backdoor, confirming our method works! Addendum 1: How to implement this safeguard in nixpkgs? I think nixpkgs should implement this kind of safeguard for every package built as part of the bootstrap phase that is not using a trusted source archive. The *-after-bootstrap packages could then be added to the channel blockers to ensure that there is big red alarm that requires intervention from the maintainers if ever one of those would not build. As a proof of concept, and to gather the feedback of the community I opened a pull request in the nixpkgs repository for the xz case, but if the method is adopted we should then implement it for the other candidate packages in nixpkgs’s bootstrap. Addendum 2: Evaluation: reproducibility of stdenv over time As discussed above, the method I propose assumes the packages we want to build trust in are bitwise reproducible. In order to help validate the approach, let’s verify that the packages belonging to the stdenv runtime are indeed reproducible. To do that, I have (as part of a bigger research project whose findings are summarized in another blog post) sampled 17 nixpkgs-unstable revisions from 2017 to 2023 and rebuilt every non-fixed-output-derivation (FOD) composing stdenv from these revisions using the nix-build --check command to check for bitwise reproducibility. Here are my findings: In every revision xz was bitwise reproducible ; In 12 of the 17 revisions there was either one or two packages that were buildable but not reproducible, but those packages are consistent over time: for example gcc has consistently been non reproducible from 2017 to 2021 and bash until 2019. These findings, while showing that this method cannot be applied to every package in stdenv, are encouraging: even if some packages are not bitwise reproducible, they are consistently so, which means that it should be possible to selectively activate it on packages that exhibit good reproducibility in the long term. Addendum 3: Limitations: the trusting trust issue The trusting trust issue is a famous thought experiment initiated by Ken Thomson during his Turing award acceptance lecture. The idea is the following: assume there is a backdoor in compilers we use to build our software such that the compiler propagates the backdoor to all new version of itself that it builds, but behaves normally for any other build until some point in time where it backdoors all executables it produces. Moderns compilers often need a previous version of themselves to be compiled so there must be an initial executable that we have to trust to build our software, making this kind of sophisticated attack theoretically possible and completely undetectable. Similarly, the method I am proposing here requires to make the assumption that the untrusted xz (the one built during the bootstrap phase) can’t indirectly corrupt the build of xz-after-bootstrap to make it look like the produced artifacts are identical. Again, such an attack would probably be extremely complex to craft so the assumption here seems sane. Thanks I would like to thank Théo Zimmermann, Pol Dellaiera, Martin Schwaighofer, and Stefano Zacchiroli for their valuable feedback and insightful discussions during the writing of this blog post. Their contributions significantly helped me organize and refine my ideas on this topic. Jia Tan essentially (through multiple identities) pressured the main xz maintainer into accepting new maintainers for the project, claiming that the project was receiving sub-par maintenance.↩︎ Fortunately, even though the malicious version was available to users, the backdoor was not active on NixOS has it was specifically made to target Debian and Fedora systems.↩︎ Tested at the time of writing on revision 1426c51↩︎ For obvious reasons, the backdoored tarball has been deleted from GitHub and the project’s website but it is still available in the NixOS cache!↩︎ This illustrates the power and limitation of this method: it only detects modifications of the tarball that have an impact on the final result. In the case of the xz backdoor, NixOS executables did not contain the backdoor and as such without any modification we would not have discovered the backdoor. So yes, the title is a little bit catchy, but illustrates the idea.↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n            \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn March 2024, a backdoor was discovered in \u003ccode\u003exz\u003c/code\u003e, a (de)-compression software that is regularly used at the core of Linux distributions to unpack source tarballs of packaged software. The backdoor had been covertly inserted by a malicious maintainer under the pseudonym of \u003cem\u003eJia Tan\u003c/em\u003e over a period of three years. This event deeply stunned the open source community as the attack was both of \u003cstrong\u003emassive impact\u003c/strong\u003e (it allowed \u003cem\u003eremote code execution\u003c/em\u003e on all affected machines that had \u003ccode\u003essh\u003c/code\u003e installed) and \u003cstrong\u003eextremely difficult to detect\u003c/strong\u003e. In fact, it was only thanks to the diligence (and maybe luck) of Andres Freund – a Postgres developer working at Microsoft – that the catastrophe was avoided: while investigating a seemingly unrelated 500ms performance regression in \u003ccode\u003essh\u003c/code\u003e that he was experiencing on several \u003cem\u003eDebian unstable\u003c/em\u003e machines, he was able to trace it back to the \u003ccode\u003eliblzma\u003c/code\u003e library, identify the backdoor and document it.\u003c/p\u003e\n\u003cp\u003eWhile it was already established that the open source supply chain was often the target of malicious actors, what is stunning is the amount of energy invested by \u003cem\u003eJia Tan\u003c/em\u003e to gain the trust of the maintainer of the \u003ccode\u003exz\u003c/code\u003e project, acquire push access to the repository and then among other perfectly legitimate contributions insert – piece by piece – the code for a very sophisticated and obfuscated backdoor. This should be a wake up call for the OSS community. We should consider the open source supply chain a high value target for powerful threat actors, and to collectively find countermeasures against such attacks.\u003c/p\u003e\n\u003cp\u003eIn this article, I’ll discuss the inner workings of the \u003ccode\u003exz\u003c/code\u003e backdoor and how I think we could have mechanically detected it thanks to build reproducibility.\u003c/p\u003e\n\u003ch2 id=\"how-does-the-attack-work\"\u003eHow does the attack work?\u003c/h2\u003e\n\u003cp\u003eThe main intent of the backdoor is to allow for \u003cem\u003eremote code execution\u003c/em\u003e on the target by hijacking the \u003ccode\u003essh\u003c/code\u003e program. To do that, it replaces the behavior of some of \u003ccode\u003essh\u003c/code\u003e’s functions (most importantly the \u003ccode\u003eRSA_public_decrypt\u003c/code\u003e one) in order to allow an attacker to execute arbitrary commands on a victim’s machine when some specific RSA key is used to log in. Two main pieces are combined to put together to install and activate the backdoor:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eA script to de-obfuscate and install a malicious object file as part of the \u003ccode\u003exz\u003c/code\u003e build process.\u003c/strong\u003e\nInterestingly the backdoor was not comprehensively contained in the source code for \u003ccode\u003exz\u003c/code\u003e. Instead, the malicious components were only contained in tarballs built and signed by the malicious maintainer \u003cem\u003eJia Tan\u003c/em\u003e and published alongside releases \u003ccode\u003e5.6.0\u003c/code\u003e and \u003ccode\u003e5.6.1\u003c/code\u003e of \u003ccode\u003exz\u003c/code\u003e. This time the additional release tarball contained slight and disguised modifications to extract a malicious object file from the \u003ccode\u003e.xz\u003c/code\u003e files used as data for some test contained in the repository.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eA procedure to hook the \u003ccode\u003eRSA_public_decrypt\u003c/code\u003e function.\u003c/strong\u003e The backdoor uses the \u003cem\u003eifunc\u003c/em\u003e mechanism of \u003ccode\u003eglibc\u003c/code\u003e to modify the address of the \u003ccode\u003eRSA_public_function\u003c/code\u003e when \u003ccode\u003essh\u003c/code\u003e is loaded, in case \u003ccode\u003essh\u003c/code\u003e links against \u003ccode\u003eliblzma\u003c/code\u003e through \u003ccode\u003elibsystemd\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003ch2 id=\"a-script-to-de-obfuscate-and-install-a-malicious-object-file-as-part-of-the-xz-build-process\"\u003e1. A script to de-obfuscate and install a malicious object file as part of the \u003ccode\u003exz\u003c/code\u003e build process\u003c/h2\u003e\n\u003cp\u003eAs explained above, the malicious object file is stored directly in the \u003ccode\u003exz\u003c/code\u003e git repository, hidden in some test files. The project being a decompression software, test cases include \u003ccode\u003e.xz\u003c/code\u003e files to be decompressed, making it possible to hide some machine code into fake test files;\n\u003cstrong\u003eThe backdoor is not active in the code contained in the git repository, it is only included by building \u003ccode\u003exz\u003c/code\u003e from the tarball released by the project\u003c/strong\u003e, which has a few differences with the actual contents of the repository, most importantly in the \u003ccode\u003em4/build-to-host.m4\u003c/code\u003e file.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003ediff --git a/m4/build-to-host.m4 b/m4/build-to-host.m4\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eindex f928e9ab..d5ec3153 100644\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e--- a/m4/build-to-host.m4\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+++ b/m4/build-to-host.m4\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -1,4 +1,4 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e# build-to-host.m4 serial 3\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e# build-to-host.m4 serial 30\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e dnl Copyright (C) 2023-2024 Free Software Foundation, Inc.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e dnl This file is free software; the Free Software Foundation\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e dnl gives unlimited permission to copy and/or distribute it,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -37,6 +37,7 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e AC_DEFUN([gl_BUILD_TO_HOST],\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   dnl Define somedir_c.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   gl_final_[$1]=\u0026#34;$[$1]\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  gl_[$1]_prefix=`echo $gl_am_configmake | sed \u0026#34;s/.*\\.//g\u0026#34;`\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   dnl Translate it from build syntax to host syntax.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   case \u0026#34;$build_os\u0026#34; in\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e     cygwin*)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -58,14 +59,40 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e AC_DEFUN([gl_BUILD_TO_HOST],\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   if test \u0026#34;$[$1]_c_make\u0026#34; = \u0026#39;\\\u0026#34;\u0026#39;\u0026#34;${gl_final_[$1]}\u0026#34;\u0026#39;\\\u0026#34;\u0026#39;; then\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e     [$1]_c_make=\u0026#39;\\\u0026#34;$([$1])\\\u0026#34;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   fi\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  if test \u0026#34;x$gl_am_configmake\u0026#34; != \u0026#34;x\u0026#34;; then\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e    gl_[$1]_config=\u0026#39;sed \\\u0026#34;r\\n\\\u0026#34; $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2\u0026gt;/dev/null\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  else\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e    gl_[$1]_config=\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  fi\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  _LT_TAGDECL([], [gl_path_map], [2])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  _LT_TAGDECL([], [gl_[$1]_prefix], [2])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  _LT_TAGDECL([], [gl_am_configmake], [2])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  _LT_TAGDECL([], [[$1]_c_make], [2])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  _LT_TAGDECL([], [gl_[$1]_config], [2])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   AC_SUBST([$1_c_make])\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl If the host conversion code has been placed in $gl_config_gt,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl instead of duplicating it all over again into config.status,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl then we will have config.status run $gl_config_gt later, so it\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl needs to know what name is stored there:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  AC_CONFIG_COMMANDS([build-to-host], [eval $gl_config_gt | $SHELL 2\u0026gt;/dev/null], [gl_config_gt=\u0026#34;eval \\$gl_[$1]_config\u0026#34;])\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e ])\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e dnl Some initializations for gl_BUILD_TO_HOST.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e AC_DEFUN([gl_BUILD_TO_HOST_INIT],\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl Search for Automake-defined pkg* macros, in the order\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  dnl listed in the Automake 1.10a+ documentation.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  gl_am_configmake=`grep -aErls \u0026#34;#{4}[[:alnum:]]{5}#{4}$\u0026#34; $srcdir/ 2\u0026gt;/dev/null`\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  if test -n \u0026#34;$gl_am_configmake\u0026#34;; then\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e    HAVE_PKG_CONFIGMAKE=1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  else\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e    HAVE_PKG_CONFIGMAKE=0\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  fi\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   gl_sed_double_backslashes=\u0026#39;s/\\\\/\\\\\\\\/g\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   gl_sed_escape_doublequotes=\u0026#39;s/\u0026#34;/\\\\\u0026#34;/g\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e  gl_path_map=\u0026#39;tr \u0026#34;\\t \\-_\u0026#34; \u0026#34; \\t_\\-\u0026#34;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e changequote(,)dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e   gl_sed_escape_for_make_1=\u0026#34;s,\\\\([ \\\u0026#34;\u0026amp;\u0026#39;();\u0026lt;\u0026gt;\\\\\\\\\\`|]\\\\),\\\\\\\\\\\\1,g\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e changequote([,])dnl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhile these changes may look benign to the naive eyes and well commented, they are actually hiding a chain of commands that decrypts/deobfuscates several fake \u003ccode\u003e.xz\u003c/code\u003e test files to ultimately produce two files:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea shell script that is run during the build of \u003ccode\u003exz\u003c/code\u003e ;\u003c/li\u003e\n\u003cli\u003ea malicious binary object file.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is an \u003ca href=\"https://research.swtch.com/xz-script\"\u003eexcellent analysis from Russ Cox\u003c/a\u003e that explains in detail how these two malicious resources are produced during the build process, and I advise any interested reader to find all relevant details there.\u003c/p\u003e\n\u003cp\u003eThe shell script run during the build has two main purposes:\u003c/p\u003e\n\u003col type=\"1\"\u003e\n\u003cli\u003eVerifying that the conditions to execute the backdoor are met on the builder (the backdoor targets specific Linux distributions, needs specific features of the \u003ccode\u003eglibc\u003c/code\u003e activated, needs \u003ccode\u003essh\u003c/code\u003e installed, etc) ;\u003c/li\u003e\n\u003cli\u003eModifying the (legitimate) \u003ccode\u003eliblzma_la-crc64_fast.o\u003c/code\u003e to use the \u003ccode\u003e_get_cpuid\u003c/code\u003e symbol defined in the backdoor object file.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"a-procedure-to-hook-the-rsa_public_decrypt-function\"\u003e2. A procedure to hook the \u003ccode\u003eRSA_public_decrypt\u003c/code\u003e function\u003c/h2\u003e\n\u003cp\u003eSo how does a backdoor in the \u003ccode\u003exz\u003c/code\u003e executable have any effect on \u003ccode\u003essh\u003c/code\u003e?\nTo understand that, we have to take a little detour in the realm of dynamic loaders and dynamically linked programs. Whenever a program depends on a library, there are two ways that library can be linked into the final executable:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003estatically, in that case the library is embedded into the final executable, hence increasing its size ;\u003c/li\u003e\n\u003cli\u003edynamically, in which case it is the role of the dynamic loader (\u003ccode\u003eld-linux.so\u003c/code\u003e in Linux) to find that shared library when the program starts and load it in memory.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen a program is compiled using dynamic linking, the addresses of the symbols belonging to dynamically linked libraries cannot be provided at compilation time: their position in memory is not know ahead of time! Instead, a reference to the \u003cem\u003eGlobal Offset Table\u003c/em\u003e (or \u003cem\u003eGOT\u003c/em\u003e) is inserted. When the program is started, the actual addresses are filled in the GOT by the dynamic linker.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003exz\u003c/code\u003e backdoor uses a functionality of the \u003ccode\u003eglibc\u003c/code\u003e called \u003cem\u003eifunc\u003c/em\u003e to force execution of code during dynamic loading time: \u003cem\u003eifunc\u003c/em\u003e is designed to allow selection between several implementations of the same function at dynamic loading time.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e#include\u003c/span\u003e\u003cspan\u003e \u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// Declaration of ifunc resolver function\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eresolve_add\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e))(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e int\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// First version of the add function\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e add_v1\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e a\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e int\u003c/span\u003e\u003cspan\u003e b\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    printf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Using add_v1\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e a \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e b\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// Second version of the add function\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e add_v2\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e a\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e int\u003c/span\u003e\u003cspan\u003e b\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    printf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Using add_v2\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e a \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e b\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// Resolver function that chooses the correct version of the function\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eresolve_add\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e))(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e int\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    // You can implement any runtime check here.\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    // In that case we check if the system is 64bit\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    if\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003cspan\u003esizeof\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e ==\u003c/span\u003e\u003cspan\u003e 8\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        return\u003c/span\u003e\u003cspan\u003e add_v2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    }\u003c/span\u003e\u003cspan\u003e else\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        return\u003c/span\u003e\u003cspan\u003e add_v1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e// Define the ifunc attribute for the add function\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e add\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e a\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e int\u003c/span\u003e\u003cspan\u003e b\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e __attribute__\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003eifunc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;resolve_add\u0026#34;\u003c/span\u003e\u003cspan\u003e)));\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eint\u003c/span\u003e\u003cspan\u003e main\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    int\u003c/span\u003e\u003cspan\u003e result \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e add\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e10\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e 20\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    printf\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Result: %d\u003c/span\u003e\u003cspan\u003e\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e result\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e 0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn the above example, the \u003cem\u003eifunc\u003c/em\u003e attribute surrounding the \u003ccode\u003eadd\u003c/code\u003e function indicates that the version that will be executed will be determined at dynamic loading time by running the \u003ccode\u003eresolve_add\u003c/code\u003e function. In that case, the \u003ccode\u003eresolve_add\u003c/code\u003e function returns \u003ccode\u003eadd_v1\u003c/code\u003e or \u003ccode\u003eadd_v2\u003c/code\u003e depending if the running system is a 64 bit system or not – and as such is completely harmless – but this technique is used by the \u003ccode\u003exz\u003c/code\u003e backdoor to run some malicious code at dynamic loading time.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eBut dynamic loading of which program?\u003c/em\u003e Well, of \u003ccode\u003essh\u003c/code\u003e! In some Linux distributions (Debian and Fedora for example), \u003ccode\u003essh\u003c/code\u003e is patched to support \u003ccode\u003esystemd\u003c/code\u003e notifications and for this purpose, links with \u003ccode\u003elibsystemd\u003c/code\u003e, that in turn links with \u003ccode\u003eliblzma\u003c/code\u003e. In those distribution \u003ccode\u003esshd\u003c/code\u003e hence has a transitive dependency on \u003ccode\u003eliblzma\u003c/code\u003e.\u003c/p\u003e\n\u003cfigure id=\"fig:SED-HR4049\"\u003e\n\u003cimg src=\"https://luj.fr/assets/links.png\"/\u003e\n\u003cfigcaption\u003eDependency chain between \u003ccode\u003esshd\u003c/code\u003e and \u003ccode\u003eliblzma\u003c/code\u003e\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThis is how the backdoor works: whenever \u003ccode\u003esshd\u003c/code\u003e is executed, the dynamic loader loads \u003ccode\u003elibsystemd\u003c/code\u003e and then \u003ccode\u003eliblzma\u003c/code\u003e. With the backdoor installed, and leveraging the \u003cem\u003eifunc\u003c/em\u003e functionality as explained above, the backdoor is able to run arbitrary code when \u003ccode\u003eliblzma\u003c/code\u003e is being loaded. Indeed, as you remember from the previous section, the backdoor script modifies one of the legitimate \u003ccode\u003exz\u003c/code\u003e object files: it actually modifies the resolver of one of the functions that uses \u003cem\u003eifunc\u003c/em\u003e to call its own malicious \u003ccode\u003e_get_cpuid\u003c/code\u003e symbol. When called, this function meddles with the GOT (that is not yet read-only at this time of execution) to modify the address of the \u003ccode\u003eRSA_public_decrypt\u003c/code\u003e function, replacing it by a malicious one! That’s it, at this point \u003ccode\u003esshd\u003c/code\u003e uses the malicious \u003ccode\u003eRSA_public_decrypt\u003c/code\u003e function that gives RCE privileges to the attacker.\u003c/p\u003e\n\u003cp\u003eOnce again, there exist more precise reports on exactly how the hooking happens that a curious reader might read, like \u003ca href=\"https://securelist.com/xz-backdoor-story-part-1/112354/\"\u003ethis one\u003c/a\u003e for example. There is also \u003ca href=\"https://arxiv.org/pdf/2404.08987\"\u003ea research article\u003c/a\u003e summarizing the attack vector and possible mitigations that I recommend reading.\u003c/p\u003e\n\u003ch2 id=\"avoiding-the-xz-catastrophe-in-the-future\"\u003eAvoiding the \u003ccode\u003exz\u003c/code\u003e catastrophe in the future\u003c/h2\u003e\n\u003cp\u003eWhat should our takeaways be from this near-miss and what should we do to minimize the risks of such an attack happening again in the future? Obviously, there is a lot to be said about the social issues at play here\u003ca href=\"#fn1\" id=\"fnref1\" role=\"doc-noteref\"\u003e\u003csup\u003e1\u003c/sup\u003e\u003c/a\u003e and how we can build better resilience in the OSS ecosystem against malicious entities taking over really fundamental OSS projects, but in this piece I’ll only address the technical aspects of the question.\u003c/p\u003e\n\u003cp\u003ePeople are often convinced that OSS is more trustworthy than closed-source software because the code can be audited by practitioners and security professionals in order to detect vulnerabilities or backdoors. In this instance, this procedure has been made difficult by the fact that part of the code activating the backdoor was not included in the sources available within the git repository but was instead present in the maintainer-provided tarball. While this was used to hide the backdoor out of sight of most investigating eyes, this is also an opportunity for us to improve our software supply chain security processes.\u003c/p\u003e\n\u003ch2 id=\"building-software-from-trusted-sources\"\u003eBuilding software from trusted sources\u003c/h2\u003e\n\u003cp\u003eOne immediate observation that we can make in reaction to this supply chain incident is that it was only effective because a lot of distributions were using the maintainer provided tarball to build \u003ccode\u003exz\u003c/code\u003e instead of the raw source code supplied by the git forge (in this case, GitHub). This reliance on release tarballs has plenty of historical and practical reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe tarball workflow predates the existence of \u003ccode\u003egit\u003c/code\u003e and was used in the earliest Linux distributions;\u003c/li\u003e\n\u003cli\u003etarballs are self-contained archives that encapsulate the exact state of the source code intended for release while git repositories can be altered, creating the need for a snapshot of the code;\u003c/li\u003e\n\u003cli\u003etarballs can contain intermediary artifacts (for example manpages) used to lighten the build process, or configure scripts to target specific hardware, etc;\u003c/li\u003e\n\u003cli\u003etarballs allow the source code to be compressed which is useful for space efficiency.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis being said, these reasons do not weigh enough in my opinion to justify the security risks they create. In all places where it is technically feasible, we should build software from sources authenticated by the most trustworthy party. For example, if a project is developed on GitHub, an archive is automatically generated by GitHub for each release. The risk of a compromise of that release archive is far lower than the risk of a malicious maintainer distributing unfaithful tarballs, as it would require compromising the GitHub infrastructure (and at this point the problem is much more serious). This reasoning can be extended in all cases where the development is happening on a platform operated by a trusted third party like Codeberg/SourceHut/Gitlab, etc.\u003c/p\u003e\n\u003ch3 id=\"when-the-situation-allows-it\"\u003eWhen the situation allows it…\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eNixOS\u003c/strong\u003e is a distribution built on the functional package management model, that is to say every package is encoded as an expression written in Nix, a functional programming language. A Nix expression for a software project is usually a function mapping all the project dependencies to a “build recipe” that can be later executed to build the package. I am a NixOS developer and I was surprised when the backdoor was revealed to see that the malicious version of \u003ccode\u003exz\u003c/code\u003e had ended up being distributed to our users\u003ca href=\"#fn2\" id=\"fnref2\" role=\"doc-noteref\"\u003e\u003csup\u003e2\u003c/sup\u003e\u003c/a\u003e. While there is no policy about this, there is a culture among NixOS maintainers of using the source archive automatically generated by GitHub (that are simply snapshots of the source code) when available through the \u003ccode\u003efetchFromGitHub\u003c/code\u003e function. In the simplified example of the \u003ccode\u003exz\u003c/code\u003e package below, you can see that the sources for the package are actually extracted from the manually uploaded \u003cem\u003emalicious\u003c/em\u003e maintainer provided tarball through another source fetcher: \u003ccode\u003efetchurl\u003c/code\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e lib\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e stdenv\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e fetchurl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e enableStatic\u003c/span\u003e\u003cspan\u003e ?\u003c/span\u003e\u003cspan\u003e stdenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ehostPlatform\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisStatic\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003estdenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emkDerivation \u003c/span\u003e\u003cspan\u003erec\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  pname\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;xz\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  version\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;5.6.0\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  src\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e fetchurl \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    url\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;https://github.com/tukaani-project/xz/releases/download/v\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003eversion\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/xz-\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003eversion\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e.tar.xz\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    hash\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;sha256-AWGCxwu1x8nrNGUDDjp/a6ol4XsOjAr+kncuYCGEPOI=\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  };\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTo understand why, we must first talk about the bootstrap of \u003ccode\u003enixpkgs\u003c/code\u003e. The concept of a bootstrap is the idea that one could rebuild all of the packages in \u003ccode\u003enixpkgs\u003c/code\u003e from a small set of seed binaries. This is an important security property because it means that there are no other external tools that one must trust in order to trust the toolchain that is used to build the software distribution. What we call the “bootstrap” in the context of a software distribution like \u003ccode\u003enixpkgs\u003c/code\u003e, is all the steps needed to build the basic compilation environment to be used by other packages, called \u003ccode\u003estdenv\u003c/code\u003e in nixpkgs. Building \u003ccode\u003estdenv\u003c/code\u003e is not an easy task; how does one build \u003ccode\u003egcc\u003c/code\u003e when one doesn’t even have a C compiler? The answer is that you start from a very small binary that does nothing fancy but is enough to build \u003ccode\u003ehex\u003c/code\u003e, a minimalist assembler, which in turn can build a more complex assembler, and this until we are able to build more complex software and finally a modern C compiler. The bootstraping story of Nix/Guix is an incredibly interesting topic, that I will not cover extensively here, but I strongly advise reading blog posts from the Guix community, that are on the bleeding edge (they have \u003ca href=\"https://guix.gnu.org/en/blog/2023/the-full-source-bootstrap-building-from-source-all-the-way-down/\"\u003eintroduced a 357-byte bootstrap\u003c/a\u003e that is being adapted for nixpkgs).\u003c/p\u003e\n\u003cp\u003eWhat does all that has to do with \u003ccode\u003exz\u003c/code\u003e though? Well, \u003ccode\u003exz\u003c/code\u003e is included in the nixpkgs bootstrap!\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-build -A stdenv\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/nix/store/91d27rjqlhkzx7mhzxrir1jcr40nyc7p-stdenv-linux\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-store --query --graph result\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cimg src=\"https://luj.fr/assets/runtime.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe can see now that \u003ccode\u003estdenv\u003c/code\u003e depends at runtime on \u003ccode\u003exz\u003c/code\u003e, so it is indeed built during the bootstrap stage. To understand a bit more why this is the case, I’ll also generate a graph of the software in \u003ccode\u003estdenv\u003c/code\u003e that depends on \u003ccode\u003exz\u003c/code\u003e at buildtime.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-store --query --graph \u003c/span\u003e\u003cspan\u003e$(\u003c/span\u003e\u003cspan\u003enix-eval\u003c/span\u003e\u003cspan\u003e --raw\u003c/span\u003e\u003cspan\u003e -f\u003c/span\u003e\u003cspan\u003e default\u003c/span\u003e\u003cspan\u003e stdenv.drvPath\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cimg src=\"https://luj.fr/assets/buildtime.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe can see that several packages depend on \u003ccode\u003exz\u003c/code\u003e. Let’s take \u003ccode\u003ecoreutils\u003c/code\u003e for example and try to understand why it depends on \u003ccode\u003exz\u003c/code\u003e by reading its derivation file, which is the intermediary representation of the build process obtained by evaluating the Nix expression for \u003ccode\u003ecoreutils\u003c/code\u003e:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  \u0026#34;\u003c/span\u003e\u003cspan\u003e/nix/store/57hlz5fnvfgljivf7p18fmcl1yp6d29z-coreutils-9.5.drv\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u0026#34;\u003c/span\u003e\u003cspan\u003eargs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      \u0026#34;-e\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      \u0026#34;/nix/store/v6x3cs394jgqfbi0a42pam708flxaphh-default-builder.sh\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    ],\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u0026#34;\u003c/span\u003e\u003cspan\u003ebuilder\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u0026#34;/nix/store/razasrvdg7ckplfmvdxv4ia3wbayr94s-bootstrap-tools/bin/bash\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u0026#34;\u003c/span\u003e\u003cspan\u003einputDrvs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      \u0026#34;\u003c/span\u003e\u003cspan\u003e/nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u0026#34;\u003c/span\u003e\u003cspan\u003edynamicOutputs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {},\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u0026#34;\u003c/span\u003e\u003cspan\u003eoutputs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          \u0026#34;bin\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      },\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      \u0026#34;\u003c/span\u003e\u003cspan\u003e/nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u0026#34;\u003c/span\u003e\u003cspan\u003edynamicOutputs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {},\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        \u0026#34;\u003c/span\u003e\u003cspan\u003eoutputs\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e          \u0026#34;out\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e        ]\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    },\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    \u0026#34;\u003c/span\u003e\u003cspan\u003esystem\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u0026#34;x86_64-linux\u0026#34;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003einputDrvs\u003c/code\u003e field here correspond to all the other packages or expressions that the \u003ccode\u003ecoreutils\u003c/code\u003e build process depends on. We see that in particular it depends on two components:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/nix/store/c0wk92pcxbxi7579xws6bj12mrim1av6-xz-5.6.2.drv\u003c/code\u003e, which is \u003ccode\u003exz\u003c/code\u003e itself;\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/nix/store/xv4333kfggq3zn065a3pwrj7ddbs4vzg-coreutils-9.5.tar.xz.drv\u003c/code\u003e which is a source archive for \u003ccode\u003ecoreutils\u003c/code\u003e! As it is a \u003ccode\u003e.xz\u003c/code\u003e archive, we need \u003ccode\u003exz\u003c/code\u003e to unpack it and that is where the dependency comes from!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe same reasoning applies to the other three direct dependencies that we could see in the graph earlier.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003exz\u003c/code\u003e being built as part of the bootstrap means it doesn’t have access to all the facilities normal packages in nixpkgs can rely on. In particular it can only access packages that are built \u003cem\u003ebefore\u003c/em\u003e in bootstrap. For example, to build \u003ccode\u003exz\u003c/code\u003e from sources, we need \u003ccode\u003eautoconf\u003c/code\u003e to generate the configure script. But \u003ccode\u003eautoconf\u003c/code\u003e has a dependency on \u003ccode\u003exz\u003c/code\u003e! Using the maintainer tarball allows us to break this dependency cycle.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix why-depends --derivation nixpkgs#autoconf nixpkgs#xz\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/nix/store/2rajzdx3wkivlc38fyhj0avyp10k2vjj-autoconf-2.72.drv\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e└───/nix/store/jnnb5ihdh6r3idmqrj2ha95ir42icafq-stdenv-linux.drv\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    └───/nix/store/sqwqnilfwkw6p2f5gaj6n1xlsy054fnw-xz-5.6.4.drv\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn conclusion, at the point in the \u003ccode\u003enixpkgs\u003c/code\u003e graph where the \u003ccode\u003exz\u003c/code\u003e package is built, the GitHub source archive cannot be used and we have to rely on the maintainer provided tarball, and hence, trust it. That does not mean that further verification cannot be implemented in \u003ccode\u003enixpkgs\u003c/code\u003e, though…\u003c/p\u003e\n\u003ch2 id=\"building-trust-into-untrusted-release-tarballs\"\u003eBuilding trust into untrusted release tarballs\u003c/h2\u003e\n\u003cp\u003eTo recap, the main reason that made NixOS vulnerable to the \u003ccode\u003exz\u003c/code\u003e attack is that it is built as part of the bootstrap phase, at a point where we rely on maintainer-provided tarballs instead of the ones generated by GitHub. This incident shows that we should have specific protections in place, to ensure software built as part of our bootstrap is trustworthy.\u003c/p\u003e\n\u003ch3 id=\"by-comparing-sources\"\u003e1. By comparing sources\u003c/h3\u003e\n\u003cp\u003eOne idea that comes to mind is that it should be easy, as a distribution, to verify that the sources tarballs we are using are indeed identical to the GitHub ones. There was even \u003ca href=\"https://github.com/NixOS/nixpkgs/pull/300542\"\u003ea pull request opened to introduce such a protection scheme\u003c/a\u003e. While this seem like a natural idea, it doesn’t really work in practice: it’s not that rare that the maintainer provided tarball differs from the sources, and it’s often nothing to worry about.\u003c/p\u003e\n\u003cblockquote data-embed-url=\"https://mastodon.social/@bagder/112181123475212554/embed\"\u003e \u003ca href=\"https://mastodon.social/@bagder/112181123475212554\" target=\"_blank\"\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"32\" height=\"32\" viewBox=\"0 0 79 75\"\u003e\u003cpath d=\"M74.7135 16.6043C73.6199 8.54587 66.5351 2.19527 58.1366 0.964691C56.7196 0.756754 51.351 0 38.9148 0H38.822C26.3824 0 23.7135 0.756754 22.2966 0.964691C14.1319 2.16118 6.67571 7.86752 4.86669 16.0214C3.99657 20.0369 3.90371 24.4888 4.06535 28.5726C4.29578 34.4289 4.34049 40.275 4.877 46.1075C5.24791 49.9817 5.89495 53.8251 6.81328 57.6088C8.53288 64.5968 15.4938 70.4122 22.3138 72.7848C29.6155 75.259 37.468 75.6697 44.9919 73.971C45.8196 73.7801 46.6381 73.5586 47.4475 73.3063C49.2737 72.7302 51.4164 72.086 52.9915 70.9542C53.0131 70.9384 53.0308 70.9178 53.0433 70.8942C53.0558 70.8706 53.0628 70.8445 53.0637 70.8179V65.1661C53.0634 65.1412 53.0574 65.1167 53.0462 65.0944C53.035 65.0721 53.0189 65.0525 52.9992 65.0371C52.9794 65.0218 52.9564 65.011 52.9318 65.0056C52.9073 65.0002 52.8819 65.0003 52.8574 65.0059C48.0369 66.1472 43.0971 66.7193 38.141 66.7103C29.6118 66.7103 27.3178 62.6981 26.6609 61.0278C26.1329 59.5842 25.7976 58.0784 25.6636 56.5486C25.6622 56.5229 25.667 56.4973 25.6775 56.4738C25.688 56.4502 25.7039 56.4295 25.724 56.4132C25.7441 56.397 25.7678 56.3856 25.7931 56.3801C25.8185 56.3746 25.8448 56.3751 25.8699 56.3816C30.6101 57.5151 35.4693 58.0873 40.3455 58.086C41.5183 58.086 42.6876 58.086 43.8604 58.0553C48.7647 57.919 53.9339 57.6701 58.7591 56.7361C58.8794 56.7123 58.9998 56.6918 59.103 56.6611C66.7139 55.2124 73.9569 50.665 74.6929 39.1501C74.7204 38.6967 74.7892 34.4016 74.7892 33.9312C74.7926 32.3325 75.3085 22.5901 74.7135 16.6043ZM62.9996 45.3371H54.9966V25.9069C54.9966 21.8163 53.277 19.7302 49.7793 19.7302C45.9343 19.7302 44.0083 22.1981 44.0083 27.0727V37.7082H36.0534V27.0727C36.0534 22.1981 34.124 19.7302 30.279 19.7302C26.8019 19.7302 25.0651 21.8163 25.0617 25.9069V45.3371H17.0656V25.3172C17.0656 21.2266 18.1191 17.9769 20.2262 15.568C22.3998 13.1648 25.2509 11.9308 28.7898 11.9308C32.8859 11.9308 35.9812 13.492 38.0447 16.6111L40.036 19.9245L42.0308 16.6111C44.0943 13.492 47.1896 11.9308 51.2788 11.9308C54.8143 11.9308 57.6654 13.1648 59.8459 15.568C61.9529 17.9746 63.0065 21.2243 63.0065 25.3172L62.9996 45.3371Z\" fill=\"currentColor\"\u003e\u003c/path\u003e\u003c/svg\u003e \u003cp\u003ePost by @bagder@mastodon.social\u003c/p\u003e \u003cp\u003eView on Mastodon\u003c/p\u003e \u003c/a\u003e \u003c/blockquote\u003e \n\n\u003cp\u003eAs Daniel Stenberg (the maintainer of \u003ccode\u003ecurl\u003c/code\u003e) explains, the release tarball being different than the source is a \u003cem\u003efeature\u003c/em\u003e: it allows the maintainer to include intermediary artifacts like manpages or configure scripts for example (this is especially useful for distributions that want to get rid of the dependency on \u003ccode\u003eautoconf\u003c/code\u003e to build the program). Of course when we care about software supply chain security, this flexibility that project maintainers have in the way they provide the release assets is actually a liability because it forces us to trust them to do it honestly.\u003c/p\u003e\n\u003ch3 id=\"leveraging-bitwise-reproducibility\"\u003e2. Leveraging bitwise reproducibility\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eReproducible builds\u003c/strong\u003e is a property of a software project that is verified if building it twice in the same conditions yields the exact same (bitwise identical) artifacts. Build reproducibility is not something easy to obtain, as there are all kinds of nondeterminisms that can happen in build processes, and making as many packages as possible reproducible is the purpose of the \u003ca href=\"https://reproducible-builds.org/\"\u003ereproducible-builds\u003c/a\u003e group. It is also a property recognized as instrumental to increase the trust in the distribution of binary artifacts (see \u003ca href=\"https://arxiv.org/abs/2104.06020\"\u003eReproducible Builds: Increasing the Integrity of Software Supply Chains\u003c/a\u003e for a detailed report).\u003c/p\u003e\n\u003cp\u003eThere are several ways bitwise reproducibility could be used to build up trust in untrusted maintainer provided tarballs:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eReproducibly building the tarball\u003c/p\u003e\n\u003cp\u003eA first approach that has been \u003ca href=\"https://peter.eisentraut.org/blog/2024/08/13/the-new-postgresql-17-make-dist\"\u003eadopted by the postgresql project\u003c/a\u003e is to make the tarball generation process reproducible. This allows any user (or a linux distribution) to independently verify that the maintainer provided tarball was honestly generated from the original source code.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://luj.fr/assets/reproducible-tarball.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eWith this method, you can keep some advantages of building from tarballs (including the tarball containing some intermediary build artifacts like manpages or configure scripts). However, the drawback of this approach for software supply chain security is that it has to be implemented by upstream project maintainers. This means that adoption of this kind of security feature will probably be slow in the FOSS community, and while it is a good practice to make \u003cem\u003eeverything\u003c/em\u003e reproducible, including the tarball generation process, this is not the most effective way to increase software supply chain security \u003cem\u003etoday\u003c/em\u003e.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eChecking for build convergence between various starting assets\u003c/p\u003e\n\n\n\n\u003cp\u003eAssuming \u003ccode\u003exz\u003c/code\u003e is bitwise reproducible (and that is indeed the case), and that the maintainer provided tarball doesn’t contain any modification that impacts the build process, building it from the GitHub tarball or from the maintainer provided tarball \u003cem\u003eshould\u003c/em\u003e produce the same artifacts, right? Based on this idea, my proposal is to build \u003ccode\u003exz\u003c/code\u003e a second time \u003cem\u003eafter\u003c/em\u003e the bootstrap, this time using the GitHub tarball (which is only possible after the bootstrap). If both builds differ we can suspect that there a suspicion of a supply chain compromise.\u003c/p\u003e\n\u003cfigure id=\"fig:SED-HR4049\"\u003e\n\u003cimg src=\"https://luj.fr/assets/sumary-method.png\"/\u003e\n\u003cfigcaption\u003eSummary of the method I propose to detect vulnerable \u003ccode\u003exz\u003c/code\u003e source tarballs\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eLet’s see how this could be implemented:\u003c/p\u003e\n\u003cp\u003eFirst, we rewrite the \u003ccode\u003exz\u003c/code\u003e package, this time using the \u003ccode\u003efetchFromGitHub\u003c/code\u003e function. I create a \u003ccode\u003eafter-boostrap.nix\u003c/code\u003e file alongside the original \u003ccode\u003exz\u003c/code\u003e expression in the \u003ccode\u003epkgs/tools/compression/xz\u003c/code\u003e directory of \u003ccode\u003enixpkgs\u003c/code\u003e:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e  {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  lib\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  stdenv\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  fetchurl\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  enableStatic\u003c/span\u003e\u003cspan\u003e ?\u003c/span\u003e\u003cspan\u003e false\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  writeScript\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  fetchFromGitHub\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  testers\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  gettext\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  autoconf\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  libtool\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  automake\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  perl538Packages\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  doxygen\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  xz\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e}:\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003estdenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emkDerivation \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efinalAttrs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  pname\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;xz\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  version\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;5.6.1\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  src\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e fetchFromGitHub \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    owner\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;tukaani-project\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    repo\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;xz\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    rev\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;v\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003efinalAttrs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eversion\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    hash\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#34;sha256-alrSXZ0KWVlti6crmdxf/qMdrvZsY5yigcV9j6GIZ6c=\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  };\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  strictDeps\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e true\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  configureFlags\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e lib\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoptional enableStatic \u003c/span\u003e\u003cspan\u003e\u0026#34;--disable-shared\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  enableParallelBuilding\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e true\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  doCheck\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e true\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  nativeBuildInputs\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e [\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    gettext\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    autoconf\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    libtool\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    automake\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    perl538Packages\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ePo4a\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    doxygen\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    perl\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  ];\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  preConfigure\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e \u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e    ./autogen.sh\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  \u0026#39;\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e})\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI removed details here to focus on the most important: the Nix expression is very similar to the actual derivation for \u003ccode\u003exz\u003c/code\u003e, the only difference (apart from the method to fetch the source) is that we need to use \u003ccode\u003eautoconf\u003c/code\u003e to generate configure scripts. When using the maintainer provided tarball these are already pre-generated for us (as Daniel Stenberg was explaining in the toot above) – which is very handy particularly when you are building \u003ccode\u003exz\u003c/code\u003e in the bootstrap phase of a distribution and you don’t want a dependency on \u003ccode\u003eautoconf\u003c/code\u003e / \u003ccode\u003eautomake\u003c/code\u003e – but in this instance we have to do it ourselves.\u003c/p\u003e\n\u003cp\u003eNow that we can build \u003ccode\u003exz\u003c/code\u003e from the code archive provided by GitHub, we have to write Nix code to compare both outputs. For that purpose, we register a new phase called \u003ccode\u003ecompareArtifacts\u003c/code\u003e, that runs at the very end of the build process. To make my point, I’ll first only compare the \u003ccode\u003eliblzma.so\u003c/code\u003e file (the one that was modified by the backdoor), but we could easily generalize this phase to all binaries and libraries outputs:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epostPhases = \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e \u0026#34;compareArtifacts\u0026#34;\u003c/span\u003e\u003cspan\u003e ]\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003ecompareArtifacts = \u003c/span\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  diff $out/lib/liblzma.so \u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003exz\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/lib/liblzma.so\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAfter this change, building \u003ccode\u003exz-after-bootstrap\u003c/code\u003e on master\u003ca href=\"#fn3\" id=\"fnref3\" role=\"doc-noteref\"\u003e\u003csup\u003e3\u003c/sup\u003e\u003c/a\u003e still works, showing that in a normal setting, both artifacts are indeed identical.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-build -A xz-after-bootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/nix/store/h23rfcjxbp1vqmmbvxkv0f69r579kfc1-xz-5.6.1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet’s now try our detection method on the backdoored \u003ccode\u003exz\u003c/code\u003e and see what happens! We checkout revision \u003ccode\u003ec53bbe3\u003c/code\u003e that contains the said version\u003ca href=\"#fn4\" id=\"fnref4\" role=\"doc-noteref\"\u003e\u003csup\u003e4\u003c/sup\u003e\u003c/a\u003e, and build \u003ccode\u003exz-after-bootstrap\u003c/code\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e git checkout c53bbe3\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-build -A xz-after-boostrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAgain, identical artifacts? Remember that the backdoor was not active in NixOS, partly because there is a check that the \u003ccode\u003eRPM_ARCH\u003c/code\u003e variable is set in the script that installs the backdoor. So let’s set it in \u003ccode\u003epkgs/tools/compression/xz/default.nix\u003c/code\u003e to activate the backdoor\u003ca href=\"#fn5\" id=\"fnref5\" role=\"doc-noteref\"\u003e\u003csup\u003e5\u003c/sup\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eRPM_ARCH = \u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nix-build -A xz-after-boostrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e/nix/store/57p62d3m98s2bgma5hcz12b4vv6nhijn-xz-5.6.1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eRunning phase: compareBins\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003eBinary files /nix/store/cxz8iq3hx65krsyraill6figp03dk54n-xz-5.6.1/lib/liblzma.so and /nix/store/4qp2khyb22hg6a3jiy4hqmasjinfkp2g-xz-5.6.1/lib/liblzma.so differ\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat’s it, binary artifacts are different now! Let’s try to understand a bit more what makes them different by keeping them as part of the output. For that, we modify the \u003ccode\u003ecompareArtifacts\u003c/code\u003e phase:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003ecompareArtifacts = \u003c/span\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  cp \u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003exz\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/lib/liblzma.so $out/xzBootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  cp $out/lib/liblzma.so $out/xzAfterBootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e  diff $out/lib/liblzma.so \u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003exz\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eout\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/lib/liblzma.so || true\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis time the diff doesn’t make the build fail and we store both versions of the \u003ccode\u003eliblzma.so\u003c/code\u003e to be able to compare them afterwards.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e ls -lah result\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003etotal 69M\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edr-xr-xr-x      6 root root     99 Jan  1  1970 .\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edrwxrwxr-t 365666 root nixbld  85M Dec 10 14:27 ..\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edr-xr-xr-x      2 root root   4.0K Jan  1  1970 bin\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edr-xr-xr-x      3 root root     32 Jan  1  1970 include\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edr-xr-xr-x      3 root root    103 Jan  1  1970 lib\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003edr-xr-xr-x      4 root root     31 Jan  1  1970 share\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e-r-xr-xr-x      1 root root   210K Jan  1  1970 xzAfterBootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e-r-xr-xr-x      1 root root   258K Jan  1  1970 xzBootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can notice that there is even a significant size difference between the two artifacts with an increase of 48Kb for the backdoored one. Let’s try to understand where this difference comes from. We can use the \u003ccode\u003enm\u003c/code\u003e command from \u003ccode\u003ebinutils\u003c/code\u003e to list the symbols in an artifact:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e nm result/xzAfterBootstrap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d3b0 t alone_decode\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d380 t alone_decoder_end\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d240 t alone_decoder_memconfig\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000008cc0 t alone_encode\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000008c90 t alone_encoder_end\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000008db0 t alone_encoder_init\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000020a80 t arm64_code\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000020810 t arm_code\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000020910 t armthumb_code\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d8d0 t auto_decode\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d8a0 t auto_decoder_end\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d730 t auto_decoder_get_check\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d7a0 t auto_decoder_init\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e000000000000d750 t auto_decoder_memconfig\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000022850 r available_checks.1\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e00000000000225f0 r bcj_optmap\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e0000000000008fb0 t block_buffer_encode\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e...\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow we can diff the symbols between the two artifacts:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003e$ diff -u0 \u0026lt;(nm --format=just-symbols xzAfterBootstrap) \u0026lt;(nm --format=just-symbols xzBootstrap)\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e--- /dev/fd/63\t2024-12-10 15:27:11.477332683 +0000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+++ /dev/fd/62\t2024-12-10 15:27:11.478332717 +0000\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -31,0 +32 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e_cpuid\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -65,0 +67 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e_get_cpuid\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e@@\u003c/span\u003e\u003cspan\u003e -448,0 +451 \u003c/span\u003e\u003cspan\u003e@@\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e__tls_get_addr@GLIBC_2.3\u003c/span\u003e\u003c/span\u003e\n\u003cspan\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTADA! We see the added \u003ccode\u003e_get_cpuid\u003c/code\u003e symbol, documented in numerous technical report about the \u003ccode\u003exz\u003c/code\u003e backdoor, confirming our method works!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAddendum 1: How to implement this safeguard in \u003ccode\u003enixpkgs\u003c/code\u003e?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think \u003ccode\u003enixpkgs\u003c/code\u003e should implement this kind of safeguard for every package built as part of the bootstrap phase that is not using a trusted source archive. The \u003ccode\u003e*-after-bootstrap\u003c/code\u003e packages could then be added to the channel blockers to ensure that there is big red alarm that requires intervention from the maintainers if ever one of those would not build.\u003c/p\u003e\n\u003cp\u003eAs a proof of concept, and to gather the feedback of the community I opened \u003ca href=\"https://github.com/NixOS/nixpkgs/pull/391569\"\u003ea pull request\u003c/a\u003e in the \u003ccode\u003enixpkgs\u003c/code\u003e repository for the \u003ccode\u003exz\u003c/code\u003e case, but if the method is adopted we should then implement it for the other candidate packages in \u003ccode\u003enixpkgs\u003c/code\u003e’s bootstrap.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAddendum 2: Evaluation: reproducibility of \u003ccode\u003estdenv\u003c/code\u003e over time\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAs discussed above, the method I propose assumes the packages we want to build trust in are \u003cem\u003ebitwise reproducible\u003c/em\u003e. In order to help validate the approach, let’s verify that the packages belonging to the \u003ccode\u003estdenv\u003c/code\u003e runtime are indeed reproducible.\nTo do that, I have (as part of a bigger research project whose findings are summarized in \u003ca href=\"https://luj.fr/blog/is-nixos-truly-reproducible.html\"\u003eanother blog post\u003c/a\u003e) sampled 17 \u003ccode\u003enixpkgs-unstable\u003c/code\u003e revisions from 2017 to 2023 and rebuilt every \u003cem\u003enon-fixed-output-derivation\u003c/em\u003e (FOD) composing \u003ccode\u003estdenv\u003c/code\u003e from these revisions using the \u003ccode\u003enix-build --check\u003c/code\u003e command to check for bitwise reproducibility.\nHere are my findings:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIn every revision \u003ccode\u003exz\u003c/code\u003e was bitwise reproducible ;\u003c/li\u003e\n\u003cli\u003eIn 12 of the 17 revisions there was either one or two packages that were buildable but not reproducible, but those packages are consistent over time: for example \u003ccode\u003egcc\u003c/code\u003e has consistently been non reproducible from 2017 to 2021 and \u003ccode\u003ebash\u003c/code\u003e until 2019.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese findings, while showing that this method cannot be applied to \u003cem\u003eevery\u003c/em\u003e package in \u003ccode\u003estdenv\u003c/code\u003e, are encouraging: even if some packages are not bitwise reproducible, they are consistently so, which means that it should be possible to selectively activate it on packages that exhibit good reproducibility in the long term.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAddendum 3: Limitations: the trusting trust issue\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe trusting trust issue is a famous \u003ca href=\"https://www.cs.cmu.edu/~rdriley/487/papers/Thompson_1984_ReflectionsonTrustingTrust.pdf\"\u003ethought experiment initiated by Ken Thomson\u003c/a\u003e during his Turing award acceptance lecture. The idea is the following: assume there is a backdoor in compilers we use to build our software such that the compiler propagates the backdoor to all new version of itself that it builds, but behaves normally for any other build until some point in time where it backdoors all executables it produces. Moderns compilers often need a previous version of themselves to be compiled so there must be an initial executable that we have to trust to build our software, making this kind of sophisticated attack \u003cem\u003etheoretically\u003c/em\u003e possible and completely undetectable.\nSimilarly, the method I am proposing here requires to make the assumption that the untrusted \u003ccode\u003exz\u003c/code\u003e (the one built during the bootstrap phase) can’t indirectly corrupt the build of \u003ccode\u003exz-after-bootstrap\u003c/code\u003e to make it look like the produced artifacts are identical. Again, such an attack would probably be extremely complex to craft so the assumption here seems sane.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"thanks\"\u003eThanks\u003c/h3\u003e\n\u003cp\u003eI would like to thank \u003ca href=\"https://www.theozimmermann.net/\"\u003eThéo Zimmermann\u003c/a\u003e, \u003ca href=\"https://orcid.org/0009-0008-7972-7160\"\u003ePol Dellaiera\u003c/a\u003e, \u003ca href=\"https://groundry.org/\"\u003eMartin Schwaighofer\u003c/a\u003e, and \u003ca href=\"https://upsilon.cc/~zack/\"\u003eStefano Zacchiroli\u003c/a\u003e for their valuable feedback and insightful discussions during the writing of this blog post. Their contributions significantly helped me organize and refine my ideas on this topic.\u003c/p\u003e\n\u003csection id=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn1\"\u003e\u003cp\u003e\u003cem\u003eJia Tan\u003c/em\u003e essentially (through multiple identities) pressured the main \u003ccode\u003exz\u003c/code\u003e maintainer into accepting new maintainers for the project, claiming that the project was receiving sub-par maintenance.\u003ca href=\"#fnref1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli id=\"fn2\"\u003e\u003cp\u003eFortunately, even though the malicious version was available to users, the backdoor was not active on NixOS has it was specifically made to target Debian and Fedora systems.\u003ca href=\"#fnref2\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli id=\"fn3\"\u003e\u003cp\u003eTested at the time of writing on revision \u003ccode\u003e1426c51\u003c/code\u003e\u003ca href=\"#fnref3\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli id=\"fn4\"\u003e\u003cp\u003eFor obvious reasons, the backdoored tarball has been deleted from GitHub and the project’s website but it is still available in the NixOS cache!\u003ca href=\"#fnref4\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli id=\"fn5\"\u003e\u003cp\u003eThis illustrates the power and limitation of this method: it only detects modifications of the tarball that have an impact on the final result. In the case of the \u003ccode\u003exz\u003c/code\u003e backdoor, NixOS executables did not contain the backdoor and as such without any modification we would not have discovered the backdoor. So yes, the title is a little bit catchy, but illustrates the idea.\u003ca href=\"#fnref5\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "34 min read",
  "publishedTime": null,
  "modifiedTime": null
}
