{
  "id": "2180efb5-507e-4791-abfa-c8e81141d9dc",
  "title": "Will the future of software development run on vibes?",
  "link": "https://arstechnica.com/ai/2025/03/is-vibe-coding-with-ai-gnarly-or-reckless-maybe-some-of-both/",
  "description": "Accepting AI-written code without understanding how it works is growing in popularity.",
  "author": "Benj Edwards",
  "published": "Wed, 05 Mar 2025 23:41:59 +0000",
  "source": "http://feeds.arstechnica.com/arstechnica/index",
  "categories": [
    "AI",
    "Biz \u0026 IT",
    "Tech",
    "coding",
    "machine learning",
    "vibe coding",
    "vibecoding"
  ],
  "byline": "Benj Edwards",
  "length": 11559,
  "excerpt": "Accepting AI-written code without understanding how it works is growing in popularity.",
  "siteName": "Ars Technica",
  "favicon": "https://cdn.arstechnica.net/wp-content/uploads/2016/10/cropped-ars-logo-512_480-300x300.png",
  "text": "Accepting AI-written code without understanding how it works is growing in popularity. For many people, coding is about telling a computer what to do and having the computer perform those precise actions repeatedly. With the rise of AI tools like ChatGPT, it's now possible for someone to describe a program in English and have the AI model translate it into working code without ever understanding how the code works. Former OpenAI researcher Andrej Karpathy recently gave this practice a name—\"vibe coding\"—and it's gaining traction in tech circles. The technique, enabled by large language models (LLMs) from companies like OpenAI and Anthropic, has attracted attention for potentially lowering the barrier to entry for software creation. But questions remain about whether the approach can reliably produce code suitable for real-world applications, even as tools like Cursor Composer, GitHub Copilot, and Replit Agent make the process increasingly accessible to non-programmers. Instead of being about control and precision, vibe coding is all about surrendering to the flow. On February 2, Karpathy introduced the term in a post on X, writing, \"There's a new kind of coding I call 'vibe coding,' where you fully give in to the vibes, embrace exponentials, and forget that the code even exists.\" He described the process in deliberately casual terms: \"I just see stuff, say stuff, run stuff, and copy paste stuff, and it mostly works.\" A screenshot of Karpathy's original X post about vibe coding from February 2, 2025. Credit: Andrej Karpathy / X While vibe coding, if an error occurs, you feed it back into the AI model, accept the changes, hope it works, and repeat the process. Karpathy's technique stands in stark contrast to traditional software development best practices, which typically emphasize careful planning, testing, and understanding of implementation details. As Karpathy humorously acknowledged in his original post, the approach is for the ultimate lazy programmer experience: \"I ask for the dumbest things, like 'decrease the padding on the sidebar by half,' because I'm too lazy to find it myself. I 'Accept All' always; I don't read the diffs anymore.\" At its core, the technique transforms anyone with basic communication skills into a new type of natural language programmer—at least for simple projects. With AI models currently being held back by the amount of code an AI model can digest at once (context size), there tends to be an upper-limit to how complex a vibe-coded software project can get before the human at the wheel becomes a high-level project manager, manually assembling slices of AI-generated code into a larger architecture. But as technical limits expand with each generation of AI models, those limits may one day disappear. Who are the vibe coders? There's no way to know exactly how many people are currently vibe coding their way through either hobby projects or development jobs, but Cursor reported 40,000 paying users in August 2024, and GitHub reported 1.3 million Copilot users just over a year ago (February 2024). While we can't find user numbers for Replit Agent, the site claims 30 million users, with an unknown percentage using the site's AI-powered coding agent. One thing we do know: the approach has particularly gained traction online as a fun way of rapidly prototyping games. Microsoft's Peter Yang recently demonstrated vibe coding in an X thread by building a simple 3D first-person shooter zombie game through conversational prompts fed into Cursor and Claude 3.7 Sonnet. Yang even used a speech-to-text app so he could verbally describe what he wanted to see and refine the prototype over time. In August 2024, the author vibe coded his way into a working Q-BASIC utility script for MS-DOS, thanks to Claude Sonnet. Credit: Benj Edwards We've been doing some vibe coding ourselves. Multiple Ars staffers have used AI assistants and coding tools for extracurricular hobby projects such as creating small games, crafting bespoke utilities, writing processing scripts, and more. Having a vibe-based code genie can come in handy in unexpected places: Last year, I asked Anthropic's Claude write a Microsoft Q-BASIC program in MS-DOS that decompressed 200 ZIP files into custom directories, saving me many hours of manual typing work. Debugging the vibes With all this vibe coding going on, we had to turn to an expert for some input. Simon Willison, an independent software developer and AI researcher, offered a nuanced perspective on AI-assisted programming in an interview with Ars Technica. \"I really enjoy vibe coding,\" he said. \"It's a fun way to try out an idea and prove if it can work.\" But there are limits to how far Willison will go. \"Vibe coding your way to a production codebase is clearly risky. Most of the work we do as software engineers involves evolving existing systems, where the quality and understandability of the underlying code is crucial.\" At some point, understanding at least some of the code is important because AI-generated code may include bugs, misunderstandings, and confabulations—for example, instances where the AI model generates references to nonexistent functions or libraries. \"Vibe coding is all fun and games until you have to vibe debug,\" developer Ben South noted wryly on X, highlighting this fundamental issue. Willison recently argued on his blog that encountering hallucinations with AI coding tools isn't as detrimental as embedding false AI-generated information into a written report, because coding tools have built-in fact-checking: If there's a confabulation, the code won't work. This provides a natural boundary for vibe coding's reliability—the code runs or it doesn't. Even so, the risk-reward calculation for vibe coding becomes far more complex in professional settings. While a solo developer might accept the trade-offs of vibe coding for personal projects, enterprise environments typically require code maintainability and reliability standards that vibe-coded solutions may struggle to meet. When code doesn't work as expected, debugging requires understanding what the code is actually doing—precisely the knowledge that vibe coding tends to sidestep. Programming without understanding When it comes to defining what exactly constitutes vibe coding, Willison makes an important distinction: \"If an LLM wrote every line of your code, but you've reviewed, tested, and understood it all, that's not vibe coding in my book—that's using an LLM as a typing assistant.\" Vibe coding, in contrast, involves accepting code without fully understanding how it works. While vibe coding originated with Karpathy as a playful term, it may encapsulate a real shift in how some developers approach programming tasks—prioritizing speed and experimentation over deep technical understanding. And to some people, that may be terrifying. Willison emphasizes that developers need to take accountability for their code: \"I firmly believe that as a developer you have to take accountability for the code you produce—if you're going to put your name to it you need to be confident that you understand how and why it works—ideally to the point that you can explain it to somebody else.\" He also warns about a common path to technical debt: \"For experiments and low-stake projects where you want to explore what's possible and build fun prototypes? Go wild! But stay aware of the very real risk that a good enough prototype often faces pressure to get pushed to production.\" The future of programming jobs So, is all this vibe coding going to cost human programmers their jobs? At its heart, programming has always been about telling a computer how to operate. The method of how we do that has changed over time, but there may always be people who are better at telling a computer precisely what to do than others—even in natural language. In some ways, those people may become the new \"programmers.\" There was a point in the late 1970s to early '80s when many people thought people required programming skills to use a computer effectively because there were very few pre-built applications for all the various computer platforms available. School systems worldwide made educational computer literacy efforts to teach people to code. A brochure for the GE 210 computer from 1964. BASIC's creators used a similar computer four years later to develop the programming language that many children were taught at home and school. Credit: GE / Wikipedia Before too long, people made useful software applications that let non-coders utilize computers easily—no programming required. Even so, programmers didn’t disappear—instead, they used applications to create better and more complex programs. Perhaps that will also happen with AI coding tools. To use an analogy, computer controlled technologies like autopilot made reliable supersonic flight possible because they could handle aspects of flight that were too taxing for all but the most highly trained and capable humans to safely control. AI may do the same for programming, allowing humans to abstract away complexities that would otherwise take too much time to manually code, and that may allow for the creation of more complex and useful software experiences in the future. But at that point, will humans still be able to understand or debug them? Maybe not. We may be completely dependent on AI tools, and some people no doubt find that a little scary or unwise. Whether vibe coding lasts in the programming landscape or remains a prototyping technique will likely depend less on the capabilities of AI models and more on the willingness of organizations to accept risky trade-offs in code quality, maintainability, and technical debt. For now, vibe coding remains an apt descriptor of the messy, experimental relationship between AI and human developers—more collaborative than autonomous, but increasingly blurring the lines of who (or what) is really doing the programming. Benj Edwards is Ars Technica's Senior AI Reporter and founder of the site's dedicated AI beat in 2022. He's also a tech historian with almost two decades of experience. In his free time, he writes and records music, collects vintage computers, and enjoys nature. He lives in Raleigh, NC. 41 Comments",
  "image": "https://cdn.arstechnica.net/wp-content/uploads/2025/03/vibe_coding_1-1152x648.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n            \u003carticle data-id=\"2079900\"\u003e\n  \n  \u003cheader\u003e\n  \u003cdiv\u003e\n      \n\n      \n\n      \u003cp\u003e\n        Accepting AI-written code without understanding how it works is growing in popularity.\n      \u003c/p\u003e\n\n      \n    \u003c/div\u003e\n\u003c/header\u003e\n\n\n  \n\n  \n      \n    \n    \u003cdiv\u003e\n                      \n                      \n          \n\u003cp\u003eFor many people, coding is about telling a computer what to do and having the computer perform those precise actions repeatedly. With the rise of AI tools like \u003ca href=\"https://arstechnica.com/information-technology/2023/11/chatgpt-was-the-spark-that-lit-the-fire-under-generative-ai-one-year-ago-today/\"\u003eChatGPT\u003c/a\u003e, it\u0026#39;s now possible for someone to describe a program in English and have the AI model translate it into working code without ever understanding how the code works. Former OpenAI researcher Andrej Karpathy recently gave this practice a name—\u0026#34;vibe coding\u0026#34;—and it\u0026#39;s gaining traction in tech circles.\u003c/p\u003e\n\u003cp\u003eThe technique, enabled by large language models (LLMs) from companies like OpenAI and Anthropic, has attracted attention for potentially lowering the barrier to entry for software creation. But questions remain about whether the approach can reliably produce code suitable for real-world applications, even as tools like \u003ca href=\"https://docs.cursor.com/composer\"\u003eCursor Composer\u003c/a\u003e, \u003ca href=\"https://github.com/features/copilot\"\u003eGitHub Copilot\u003c/a\u003e, and \u003ca href=\"https://docs.replit.com/replitai/agent\"\u003eReplit Agent\u003c/a\u003e make the process increasingly accessible to non-programmers.\u003c/p\u003e\n\u003cp\u003eInstead of being about control and precision, vibe coding is all about surrendering to the flow. On February 2, Karpathy introduced the term in a post on X, writing, \u0026#34;There\u0026#39;s a new kind of coding I call \u0026#39;vibe coding,\u0026#39; where you fully give in to the vibes, embrace exponentials, and forget that the code even exists.\u0026#34; He described the process in deliberately casual terms: \u0026#34;I just see stuff, say stuff, run stuff, and copy paste stuff, and it mostly works.\u0026#34;\u003c/p\u003e\n\u003cfigure\u003e\n    \u003cp\u003e\u003cimg width=\"750\" height=\"639\" src=\"https://cdn.arstechnica.net/wp-content/uploads/2025/03/karpathy_vibecode_screenshot.png\" alt=\"Karapthy tweet screenshot: There\u0026#39;s a new kind of coding I call \u0026#34;vibe coding\u0026#34;, where you fully give in to the vibes, embrace exponentials, and forget that the code even exists. It\u0026#39;s possible because the LLMs (e.g. Cursor Composer w Sonnet) are getting too good. Also I just talk to Composer with SuperWhisper so I barely even touch the keyboard. I ask for the dumbest things like \u0026#34;decrease the padding on the sidebar by half\u0026#34; because I\u0026#39;m too lazy to find it. I \u0026#34;Accept All\u0026#34; always, I don\u0026#39;t read the diffs anymore. When I get error messages I just copy paste them in with no comment, usually that fixes it. The code grows beyond my usual comprehension, I\u0026#39;d have to really read through it for a while. Sometimes the LLMs can\u0026#39;t fix a bug so I just work around it or ask for random changes until it goes away. It\u0026#39;s not too bad for throwaway weekend projects, but still quite amusing. I\u0026#39;m building a project or webapp, but it\u0026#39;s not really coding - I just see stuff, say stuff, run stuff, and copy paste stuff, and it mostly works.\" decoding=\"async\" loading=\"lazy\" srcset=\"https://cdn.arstechnica.net/wp-content/uploads/2025/03/karpathy_vibecode_screenshot.png 750w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/karpathy_vibecode_screenshot-640x545.png 640w\" sizes=\"auto, (max-width: 750px) 100vw, 750px\"/\u003e\n                  \u003c/p\u003e\n          \u003cfigcaption\u003e\n        \u003cdiv\u003e\n    \n    \u003cp\u003e\n      A screenshot of Karpathy\u0026#39;s original X post about vibe coding from February 2, 2025.\n\n              \u003cspan\u003e\n          Credit:\n\n                      \u003ca href=\"https://x.com/karpathy/status/1886192184808149383\" target=\"_blank\"\u003e\n          \n          Andrej Karpathy / X\n\n                      \u003c/a\u003e\n                  \u003c/span\u003e\n          \u003c/p\u003e\n  \u003c/div\u003e\n      \u003c/figcaption\u003e\n      \u003c/figure\u003e\n\n\u003cp\u003eWhile vibe coding, if an error occurs, you feed it back into the AI model, accept the changes, hope it works, and repeat the process. Karpathy\u0026#39;s technique stands in stark contrast to traditional software development \u003ca href=\"https://en.wikipedia.org/wiki/Coding_best_practices\"\u003ebest practices\u003c/a\u003e, which typically emphasize careful planning, testing, and understanding of implementation details.\u003c/p\u003e\n\u003cp\u003eAs Karpathy humorously acknowledged in his original post, the approach is for the ultimate lazy programmer experience: \u0026#34;I ask for the dumbest things, like \u0026#39;decrease the padding on the sidebar by half,\u0026#39; because I\u0026#39;m too lazy to find it myself. I \u0026#39;Accept All\u0026#39; always; I don\u0026#39;t read the diffs anymore.\u0026#34;\u003c/p\u003e\n\n          \n                      \n                  \u003c/div\u003e\n                    \n        \n          \n    \n    \u003cdiv\u003e\n          \n          \n\u003cp\u003eAt its core, the technique transforms anyone with basic communication skills into a new type of natural language programmer—at least for simple projects. With AI models currently being held back by the amount of code an AI model can digest at once (context size), there tends to be an upper-limit to how complex a vibe-coded software project can get before the human at the wheel becomes a high-level project manager, manually assembling slices of AI-generated code into a larger architecture. But as technical limits expand with each generation of AI models, those limits may one day disappear.\u003c/p\u003e\n\u003ch2\u003eWho are the vibe coders?\u003c/h2\u003e\n\u003cp\u003eThere\u0026#39;s no way to know exactly how many people are currently vibe coding their way through either hobby projects or development jobs, but Cursor \u003ca href=\"https://www.cursor.com/blog/series-a\"\u003ereported\u003c/a\u003e 40,000 paying users in August 2024, and GitHub \u003ca href=\"https://visualstudiomagazine.com/Articles/2024/02/05/copilot-numbers.aspx\"\u003ereported\u003c/a\u003e 1.3 million Copilot users just over a year ago (February 2024). While we can\u0026#39;t find user numbers for Replit Agent, the site \u003ca href=\"https://web.archive.org/web/20250123182359/https://blog.replit.com/teams-ga\"\u003eclaims\u003c/a\u003e 30 million users, with an unknown percentage using the site\u0026#39;s AI-powered coding agent.\u003c/p\u003e\n\u003cp\u003eOne thing we do know: the approach has particularly gained traction online as a fun way of rapidly prototyping games. Microsoft\u0026#39;s Peter Yang \u003ca href=\"https://x.com/petergyang/status/1896793172489155048\"\u003erecently demonstrated\u003c/a\u003e vibe coding in an X thread by building a simple 3D first-person shooter zombie game through conversational prompts fed into Cursor and Claude 3.7 Sonnet. Yang even used a \u003ca href=\"https://superwhisper.com/\"\u003espeech-to-text app\u003c/a\u003e so he could verbally describe what he wanted to see and refine the prototype over time.\u003c/p\u003e\n\u003cfigure\u003e\n    \u003cp\u003e\u003cimg width=\"1024\" height=\"768\" src=\"https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-1024x768.jpeg\" alt=\"A photo of a MS-DOS computer with Q-BASIC code on the screen.\" decoding=\"async\" loading=\"lazy\" srcset=\"https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-1024x768.jpeg 1024w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-640x480.jpeg 640w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-768x576.jpeg 768w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-1536x1152.jpeg 1536w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-980x735.jpeg 980w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD-1440x1080.jpeg 1440w, https://cdn.arstechnica.net/wp-content/uploads/2025/03/GVwbGcaWsAA7ijD.jpeg 2048w\" sizes=\"auto, (max-width: 1024px) 100vw, 1024px\"/\u003e\n                  \u003c/p\u003e\n          \u003cfigcaption\u003e\n        \u003cdiv\u003e\n    \n    \u003cp\u003e\n      In August 2024, the author vibe coded his way into a working Q-BASIC utility script for MS-DOS, thanks to Claude Sonnet.\n\n              \u003cspan\u003e\n          Credit:\n\n                      \u003ca href=\"https://x.com/benjedwards/status/1827365350851178514\" target=\"_blank\"\u003e\n          \n          Benj Edwards\n\n                      \u003c/a\u003e\n                  \u003c/span\u003e\n          \u003c/p\u003e\n  \u003c/div\u003e\n      \u003c/figcaption\u003e\n      \u003c/figure\u003e\n\n\u003cp\u003eWe\u0026#39;ve been doing some vibe coding ourselves. Multiple Ars staffers have used AI assistants and coding tools for extracurricular hobby projects such as creating small games, crafting bespoke utilities, writing processing scripts, and more. Having a vibe-based code genie can come in handy in unexpected places: Last year, I \u003ca href=\"https://x.com/benjedwards/status/1827365350851178514\"\u003easked\u003c/a\u003e Anthropic\u0026#39;s Claude write a Microsoft Q-BASIC program in MS-DOS that decompressed 200 ZIP files into custom directories, saving me many hours of \u003ca href=\"https://x.com/benjedwards/status/1827463110933815366\"\u003emanual typing work\u003c/a\u003e.\u003c/p\u003e\n\n          \n                  \u003c/div\u003e\n                    \n        \n          \n    \n    \u003cdiv\u003e\n          \n          \n\u003ch2\u003eDebugging the vibes\u003c/h2\u003e\n\u003cp\u003eWith all this vibe coding going on, we had to turn to an expert for some input. Simon Willison, an independent software developer and AI researcher, offered a nuanced perspective on AI-assisted programming in an interview with Ars Technica. \u0026#34;I really enjoy vibe coding,\u0026#34; he said. \u0026#34;It\u0026#39;s a fun way to try out an idea and prove if it can work.\u0026#34;\u003c/p\u003e\n\u003cp\u003eBut there are limits to how far Willison will go. \u0026#34;Vibe coding your way to a production codebase is clearly risky. Most of the work we do as software engineers involves evolving existing systems, where the quality and understandability of the underlying code is crucial.\u0026#34;\u003c/p\u003e\n\u003cp\u003eAt some point, understanding at least some of the code is important because AI-generated code may include bugs, misunderstandings, and confabulations—for example, instances where the AI model generates references to nonexistent functions or libraries.\u003c/p\u003e\n\u003cp\u003e\u0026#34;Vibe coding is all fun and games until you have to vibe debug,\u0026#34; developer Ben South \u003ca href=\"https://x.com/bnj/status/1896712960304992302\"\u003enoted wryly\u003c/a\u003e on X, highlighting this fundamental issue.\u003c/p\u003e\n\u003cp\u003eWillison \u003ca href=\"https://simonwillison.net/2025/Mar/2/hallucinations-in-code/\"\u003erecently argued\u003c/a\u003e on his blog that encountering hallucinations with AI coding tools isn\u0026#39;t as detrimental as embedding false AI-generated information into a written report, because coding tools have built-in fact-checking: If there\u0026#39;s a confabulation, the code won\u0026#39;t work. This provides a natural boundary for vibe coding\u0026#39;s reliability—the code runs or it doesn\u0026#39;t.\u003c/p\u003e\n\u003cp\u003eEven so, the risk-reward calculation for vibe coding becomes far more complex in professional settings. While a solo developer might accept the trade-offs of vibe coding for personal projects, enterprise environments typically require code maintainability and reliability standards that vibe-coded solutions may struggle to meet. When code doesn\u0026#39;t work as expected, debugging requires understanding what the code is actually doing—precisely the knowledge that vibe coding tends to sidestep.\u003c/p\u003e\n\n          \n                  \u003c/div\u003e\n                    \n        \n          \n    \n    \u003cdiv\u003e\n          \n          \n\n\u003ch2\u003eProgramming without understanding\u003c/h2\u003e\n\u003cp\u003eWhen it comes to defining what exactly constitutes vibe coding, Willison makes an important distinction: \u0026#34;If an LLM wrote every line of your code, but you\u0026#39;ve reviewed, tested, and understood it all, that\u0026#39;s not vibe coding in my book—that\u0026#39;s using an LLM as a typing assistant.\u0026#34; Vibe coding, in contrast, involves accepting code without fully understanding how it works.\u003c/p\u003e\n\u003cp\u003eWhile vibe coding originated with Karpathy as a playful term, it may encapsulate a real shift in how some developers approach programming tasks—prioritizing speed and experimentation over deep technical understanding. And to some people, that may be terrifying.\u003c/p\u003e\n\u003cp\u003eWillison emphasizes that developers need to take accountability for their code: \u0026#34;I firmly believe that as a developer you have to take accountability for the code you produce—if you\u0026#39;re going to put your name to it you need to be confident that you understand how and why it works—ideally to the point that you can explain it to somebody else.\u0026#34;\u003c/p\u003e\n\u003cp\u003eHe also warns about a common path to technical debt: \u0026#34;For experiments and low-stake projects where you want to explore what\u0026#39;s possible and build fun prototypes? Go wild! But stay aware of the very real risk that a good enough prototype often faces pressure to get pushed to production.\u0026#34;\u003c/p\u003e\n\u003ch2\u003eThe future of programming jobs\u003c/h2\u003e\n\u003cp\u003eSo, is all this vibe coding going to cost human programmers their jobs? At its heart, programming has always been about telling a computer how to operate. The method of how we do that has changed over time, but there may always be people who are better at telling a computer precisely what to do than others—even in natural language. In some ways, those people may become the new \u0026#34;programmers.\u0026#34;\u003c/p\u003e\n\n          \n                  \u003c/div\u003e\n                    \n        \n          \n    \n    \u003cdiv\u003e\n\n        \n        \u003cdiv\u003e\n          \n          \n\u003cp\u003eThere was a point in the late 1970s to early \u0026#39;80s when many people thought people required programming skills to use a computer effectively because there were very few pre-built applications for all the various computer platforms available. School systems worldwide made educational computer literacy efforts to teach people to code.\u003c/p\u003e\n\u003cfigure\u003e\n    \u003cp\u003e\u003cimg width=\"640\" height=\"480\" src=\"https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-640x480.jpg\" alt=\"A brochure for the GE 210 computer from 1964. BASIC\u0026#39;s creators used a similar computer four years later to develop the programming language.\" decoding=\"async\" loading=\"lazy\" srcset=\"https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-640x480.jpg 640w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-300x225.jpg 300w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-768x576.jpg 768w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-1536x1152.jpg 1536w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-980x735.jpg 980w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement-1440x1080.jpg 1440w, https://cdn.arstechnica.net/wp-content/uploads/2024/05/GE_210_advertisement.jpg 1920w\" sizes=\"auto, (max-width: 640px) 100vw, 640px\"/\u003e\n                  \u003c/p\u003e\n          \u003cfigcaption\u003e\n        \u003cdiv\u003e\n    \n    \u003cp\u003e\n      A brochure for the GE 210 computer from 1964. BASIC\u0026#39;s creators used a similar computer four years later to develop the programming language that many children were taught at home and school.\n\n              \u003cspan\u003e\n          Credit:\n\n                      \u003ca href=\"https://en.wikipedia.org/wiki/GE-200_series#/media/File:GE_210_advertisement.jpg\" target=\"_blank\"\u003e\n          \n          GE / Wikipedia\n\n                      \u003c/a\u003e\n                  \u003c/span\u003e\n          \u003c/p\u003e\n  \u003c/div\u003e\n      \u003c/figcaption\u003e\n      \u003c/figure\u003e\n\n\u003cp\u003eBefore too long, people made useful software applications that let non-coders utilize computers easily—no programming required. Even so, programmers didn’t disappear—instead, they used applications to create better and more complex programs. Perhaps that will also happen with AI coding tools.\u003c/p\u003e\n\u003cp\u003eTo use an analogy, computer controlled technologies like autopilot made \u003ca href=\"https://en.wikipedia.org/wiki/Concorde\"\u003ereliable supersonic flight\u003c/a\u003e possible because they could handle aspects of flight that were too taxing for all but the most highly trained and capable humans to safely control. AI may do the same for programming, allowing humans to abstract away complexities that would otherwise take too much time to manually code, and that may allow for the creation of more complex and useful software experiences in the future.\u003c/p\u003e\n\u003cp\u003eBut at that point, will humans still be able to understand or debug them? Maybe not. We may be completely dependent on AI tools, and some people no doubt find that a little scary or unwise.\u003c/p\u003e\n\u003cp\u003eWhether vibe coding lasts in the programming landscape or remains a prototyping technique will likely depend less on the capabilities of AI models and more on the willingness of organizations to accept risky trade-offs in code quality, maintainability, and technical debt. For now, vibe coding remains an apt descriptor of the messy, experimental relationship between AI and human developers—more collaborative than autonomous, but increasingly blurring the lines of who (or what) is really doing the programming.\u003c/p\u003e\n\n\n          \n                  \u003c/div\u003e\n\n                  \n          \n\n\n\n\n\n\n  \u003cdiv\u003e\n  \u003cdiv\u003e\n          \u003cp\u003e\u003ca href=\"https://arstechnica.com/author/benjedwards/\"\u003e\u003cimg src=\"https://arstechnica.com/wp-content/uploads/2022/08/benj_ega.png\" alt=\"Photo of Benj Edwards\"/\u003e\u003c/a\u003e\u003c/p\u003e\n  \u003c/div\u003e\n\n  \u003cdiv\u003e\n    \n\n    \u003cp\u003e\n      Benj Edwards is Ars Technica\u0026#39;s Senior AI Reporter and founder of the site\u0026#39;s dedicated AI beat in 2022. He\u0026#39;s also a tech historian with almost two decades of experience. In his free time, he writes and records music, collects vintage computers, and enjoys nature. He lives in Raleigh, NC.\n    \u003c/p\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\n  \u003cp\u003e\n    \u003ca href=\"https://arstechnica.com/ai/2025/03/is-vibe-coding-with-ai-gnarly-or-reckless-maybe-some-of-both/#comments\" title=\"41 comments\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 80 80\"\u003e\u003cdefs\u003e\u003cclipPath id=\"bubble-zero_svg__a\"\u003e\u003cpath fill=\"none\" stroke-width=\"0\" d=\"M0 0h80v80H0z\"\u003e\u003c/path\u003e\u003c/clipPath\u003e\u003cclipPath id=\"bubble-zero_svg__b\"\u003e\u003cpath fill=\"none\" stroke-width=\"0\" d=\"M0 0h80v80H0z\"\u003e\u003c/path\u003e\u003c/clipPath\u003e\u003c/defs\u003e\u003cg clip-path=\"url(#bubble-zero_svg__a)\"\u003e\u003cg fill=\"currentColor\" clip-path=\"url(#bubble-zero_svg__b)\"\u003e\u003cpath d=\"M80 40c0 22.09-17.91 40-40 40S0 62.09 0 40 17.91 0 40 0s40 17.91 40 40\"\u003e\u003c/path\u003e\u003cpath d=\"M40 40 .59 76.58C-.67 77.84.22 80 2.01 80H40z\"\u003e\u003c/path\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\n    41 Comments\n  \u003c/a\u003e\n      \u003c/p\u003e\n              \u003c/div\u003e\n  \u003c/article\u003e\n\n\n  \n\n\n  \n\n\n  \u003cdiv\u003e\n    \u003cheader\u003e\n      \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 26\"\u003e\u003cdefs\u003e\u003cclipPath id=\"most-read_svg__a\"\u003e\u003cpath fill=\"none\" d=\"M0 0h40v26H0z\"\u003e\u003c/path\u003e\u003c/clipPath\u003e\u003cclipPath id=\"most-read_svg__b\"\u003e\u003cpath fill=\"none\" d=\"M0 0h40v26H0z\"\u003e\u003c/path\u003e\u003c/clipPath\u003e\u003c/defs\u003e\u003cg clip-path=\"url(#most-read_svg__a)\"\u003e\u003cg fill=\"none\" clip-path=\"url(#most-read_svg__b)\"\u003e\u003cpath fill=\"currentColor\" d=\"M20 2h.8q1.5 0 3 .6c.6.2 1.1.4 1.7.6 1.3.5 2.6 1.3 3.9 2.1.6.4 1.2.8 1.8 1.3 2.9 2.3 5.1 4.9 6.3 6.4-1.1 1.5-3.4 4-6.3 6.4-.6.5-1.2.9-1.8 1.3q-1.95 1.35-3.9 2.1c-.6.2-1.1.4-1.7.6q-1.5.45-3 .6h-1.6q-1.5 0-3-.6c-.6-.2-1.1-.4-1.7-.6-1.3-.5-2.6-1.3-3.9-2.1-.6-.4-1.2-.8-1.8-1.3-2.9-2.3-5.1-4.9-6.3-6.4 1.1-1.5 3.4-4 6.3-6.4.6-.5 1.2-.9 1.8-1.3q1.95-1.35 3.9-2.1c.6-.2 1.1-.4 1.7-.6q1.5-.45 3-.6zm0-2h-1c-1.2 0-2.3.3-3.4.6-.6.2-1.3.4-1.9.7-1.5.6-2.9 1.4-4.3 2.3-.7.5-1.3.9-1.9 1.4C2.9 8.7 0 13 0 13s2.9 4.3 7.5 7.9c.6.5 1.3 1 1.9 1.4 1.3.9 2.7 1.7 4.3 2.3.6.3 1.3.5 1.9.7 1.1.3 2.3.6 3.4.6h2c1.2 0 2.3-.3 3.4-.6.6-.2 1.3-.4 1.9-.7 1.5-.6 2.9-1.4 4.3-2.3.7-.5 1.3-.9 1.9-1.4C37.1 17.3 40 13 40 13s-2.9-4.3-7.5-7.9c-.6-.5-1.3-1-1.9-1.4-1.3-.9-2.8-1.7-4.3-2.3-.6-.3-1.3-.5-1.9-.7C23.3.4 22.1.1 21 .1h-1\"\u003e\u003c/path\u003e\u003cpath fill=\"#ff4e00\" d=\"M20 5c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8m0 11c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3\"\u003e\u003c/path\u003e\u003c/g\u003e\u003c/g\u003e\u003c/svg\u003e\n      \n    \u003c/header\u003e\n    \u003col\u003e\n              \u003cli\u003e\n                      \u003ca href=\"https://arstechnica.com/space/2025/03/butch-and-suni-send-mixed-messages-on-whether-politics-delayed-their-return/\"\u003e\n              \u003cimg src=\"https://cdn.arstechnica.net/wp-content/uploads/2024/05/53658451148_fc0227fde6_k-768x432.jpg\" alt=\"Listing image for first story in Most Read: Butch Wilmore says Elon Musk is “absolutely factual” on Dragon’s delayed return\" decoding=\"async\" loading=\"lazy\"/\u003e\n            \u003c/a\u003e\n                    \n        \u003c/li\u003e\n                    \u003cli\u003e\n                    \n        \u003c/li\u003e\n                    \u003cli\u003e\n                    \n        \u003c/li\u003e\n                    \u003cli\u003e\n                    \n        \u003c/li\u003e\n                    \u003cli\u003e\n                    \n        \u003c/li\u003e\n                  \u003c/ol\u003e\n\u003c/div\u003e\n\n\n  \n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-03-05T23:41:59Z",
  "modifiedTime": "2025-03-05T23:52:58Z"
}
