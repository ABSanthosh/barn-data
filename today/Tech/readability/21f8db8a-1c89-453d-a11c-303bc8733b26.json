{
  "id": "21f8db8a-1c89-453d-a11c-303bc8733b26",
  "title": "An Update on Apple M1/M2 GPU Drivers",
  "link": "https://lwn.net/SubscriberLink/995383/34dc5950cab5e739/",
  "description": "Comments",
  "author": "",
  "published": "Thu, 31 Oct 2024 20:36:53 +0000",
  "source": "https://news.ycombinator.com/rss",
  "categories": null,
  "byline": "By Jake EdgeOctober 30, 2024 XDC",
  "length": 10978,
  "excerpt": "The kernel graphics driver for the Apple M1 and M2 GPUs is, rather famously, written in Rust, but it has achieved conformance with various graphics standards, which is also noteworthy. At the X.Org Developers Conference (XDC) 2024, Alyssa Rosenzweig gave an update on the status of the driver, along with some news about the kinds of games it can support (YouTube video, slides). There has been lots of progress since her talk at XDC last year (YouTube video), with, of course, still more to come.",
  "siteName": "",
  "favicon": "https://static.lwn.net/images/favicon.png",
  "text": "The kernel graphics driver for the Apple M1 and M2 GPUs is, rather famously, written in Rust, but it has achieved conformance with various graphics standards, which is also noteworthy. At the X.Org Developers Conference (XDC) 2024, Alyssa Rosenzweig gave an update on the status of the driver, along with some news about the kinds of games it can support (YouTube video, slides). There has been lots of progress since her talk at XDC last year (YouTube video), with, of course, still more to come. It is something of an XDC tradition, since she began it in Montreal in 2019 (YouTube video), for Rosenzweig to give her presentations dressed like a witch. This year's edition was no exception, though this time she started her talk in French, which resulted in some nervous chuckles from attendees. After a few sentences, she switched to English, \"I'm just kidding\", and continued with her talk. Updates and tessellation Last year at XDC, she and Asahi Lina reported that the driver had reached OpenGL ES 3.1 conformance. They also talked about geometry shaders, because \"that was the next step\". Since then, the driver has become OpenGL 4.6 conformant. That meant she was going to turn to talking about tessellation shaders, \"as I threatened to do at the end of last year's talk\". LWN.net is able to bring you articles like this one because of our generous subscribers. If you want to see more like it, consider taking advantage of our special offer: 1 month trial subscription Tessellation, which is a technique that \"allows detail to be dynamically added and subtracted\" from a scene, is required for OpenGL 4.0, and there is a hardware tessellator on the Apple GPU—but, \"we can't use it\". The hardware is too limited to implement any of the standards; \"it is missing features that are hard required for OpenGL, Vulkan, and Direct3D\". That makes it \"pretty much useless to anybody who is not implementing Metal\". Apple supports OpenGL 4.1, though it is not conformant, but if you use any of the features that the hardware does not support, it simply falls back to software; \"we are not going to do that\". As far as Rosenzweig is aware, the hardware lacks point mode, where points are used instead of the usual triangles; it also lacks isoline support, but those two things can be emulated. The real problem comes with transform feedback and geometry shaders, neither of which is supported by the hardware, but the driver emulates them with compute shaders. However, the hardware tessellator cannot be used at all when those are being emulated because minute differences in the tessellation algorithms used by the hardware and the emulation would result in invariance failures. She is not sure whether that is a problem in practice or not, \"but the spec says not to do it\", so she is hoping not to have to go that route. Instead, \"we use software\". In particular, Microsoft released a reference tessellator a decade or more ago, which was meant to show hardware vendors what they were supposed to implement when tessellation was first introduced. It is \"a giant pile of 2000 lines of C++\" that she does not understand, despite trying multiple times; \"it is inscrutable\". The code will tessellate a single patch, which gave the driver developers an idea: \"if we can run that code, we can get the tessellation outputs and then we can just draw the triangles or the lines with this index buffer\". There are some problems with that approach, however, starting with the fact that the developers are writing a GPU driver; \"famously, GPUs do not like running 2000 lines of C++\". But, she announced, \"we have conformant OpenCL 3.0 support\" thanks to Karol Herbst, though it has not yet been released. OpenCL C is \"pretty much the same as regular CPU C\", though it has a few limitations and some extensions for GPUs. So the idea would be to turn the C++ tessellation code into OpenCL C code; \"we don't have to understand any of it, we just need to not break anything when we do the port\". That works, but \"tessellator.cl is the most unhinged file of my career\"; doing things that way was also the most unhinged thing she has done in her career \"and I'm standing up here in a witch hat for the fifth year in a row\". The character debuted in the exact same room in 2019 when she was 17 years old, she recalled. The CPU tessellator only operates on a single patch at a time, but a scene might have 10,000 patches—doing them all serially will be a real problem. GPUs are massively parallel, though, so having multiple threads each doing tessellation is \"pretty easy to arrange\". There is a problem with memory allocation; the CPU tessellator just allocates for each operation sequentially, but that will not work for parallel processing. Instead, the driver uses the GPU atomic instructions to manage the allocation of output buffers. In order to draw the output of the tessellators, though, there is a need to use draw instructions with packed data structures as specified by the GPU. That is normally done from the C driver code using functions that are generated by the GenXML tool. Since the tessellators are simply C code, \"thanks to OpenCL\", the generated functions can be included into the code that runs on the GPU. Rosenzweig went into more detail, which fills in the holes (and likely inaccuracies) of the above description; those interested in the details should look at the presentation video and her slides. \"Does it work? Yes, it does.\" She showed an image of terrain tessellation from a Vulkan demo. It was run on an M2 Mac with \"entirely OpenCL-based tessellation\". There is also the question of \"how is the performance of this abomination?\" The answer is that it is \"okay\". On the system, software-only terrain tessellation runs at less than one frame-per-second (fps), which \"is not very fun for playing games\"; for OpenCL, it runs at 265fps, which is \"pretty good\" and is unlikely to be the bottleneck for real games. The hardware can do 820fps; \"I did wire up the hardware tessellator just to get a number for this talk.\" There is still room for improvement on the driver's numbers, she said. Vulkan and gaming She also announced Vulkan 1.3 conformance for the Honeykrisp M1/M2 GPU driver. It started by copying the NVK Vulkan driver for NVIDIA GPUs, \"smashed against the [Open]GL 4.6 [driver]\", which started passing the conformance test suite \"in about a month\". That was six months ago and, since then, she has added geometry and tessellation shaders, transform feedback, and shader objects. The driver now supports every feature needed for multiple DirectX versions. There are a lot of problems \"if we want to run triple-A (AAA) games on this system\", however. A target game runs on DirectX and Windows on an x86 CPU with 4KB pages, but \"our target hardware is running literally none of those things\". What is needed is to somehow translate DirectX to Vulkan, Windows to Linux, x86 to Arm64, and 4KB pages to 16KB pages. The first two have a well-known solution in the form of the DXVK driver and Wine, which are \"generally packaged into Proton for Steam gaming\". Going from x86 to Arm64 also has off-the-shelf solutions: FEX-Emu or Box64. She has a bias toward FEX-Emu; \"when I am not committing Mesa crimes, I am committing FEX-Emulation crimes\". The big problem, though, is the page-size difference. FEX-Emu requires 4KB pages; Box64 has a \"hack to use 16KB pages, but it doesn't work for Wine, so it doesn't help us here\". MacOS can use 4KB pages for the x86 emulation, but \"this requires very invasive kernel support\"; Asahi Linux already has around 1000 patches that are making their way toward the mainline kernel, but \"every one of those thousand is a challenge\". Making changes like \"rewriting the Linux memory manager\" is not a reasonable path. It turns out that, even though Linux does not support heterogeneous page sizes between different processes, it does support them between different kernels; \"what I mean by that is virtualization\". A KVM guest kernel can have a different page size than the host kernel. So, \"this entire mess\", consisting of FEX-Emu, Wine, DXVK, Honeykrisp, Steam, and the game, \"we are going to throw that into a virtual machine, which is running a 4KB guest kernel\". There is some overhead, of course, but it is hardware virtualization, so that should have low CPU overhead. The problem lies with the peripherals, she said. So, instead of having Honeykrisp in the host kernel, it runs in the guest using virtgpu native contexts; all of the work to create the final GPU command buffer is done in the guest and handed to the host, rather than making all of the Vulkan calls individually traverse the virtual-machine boundary. The VirGL renderer on the host then hands that to the GPU, which \"is not 100% native speed, but definitely well above 90%\", Rosenzweig said. The good news is that the overheads for the CPU and GPU do not stack, since the two run in parallel. \"So all the crap overhead we have in the CPU is actually crap that is running in parallel to the crap overhead on the GPU, so we only pay the cost once.\" \"'Does it work?' is the question you all want to know.\" It does, she said, it runs games like Portal and Portal 2. She also listed a number of others: Castle Crashers, The Witcher 3, Fallout 4, Control, Ghostrunner, and Cyberpunk 2077. All of the different pieces that she mentioned were made available on October 10, the day of the talk. For those running the Fedora Asahi Remix distribution, she suggested immediately updating to pick up the pieces that she had described. Before taking questions, she launched Steam, which took some time to come up, in part because of the virtual machine and the x86 emulation. Once it came up, she launched Control, which ran at 45fps on an M1 MAX system. There was a question about resources from someone who has a Mac with 8GB of RAM. Rosenzweig said that the high-end gaming titles are only likely to work on systems with 16GB or more. She noted that she was playing Castle Crashers on an 8GB system during the conference, so some games will play; Portal will also work on that system. She hopes that the resources required will drop over time. Another question was about ray-tracing support, since Control can use that feature. Rosenzweig suggested that patches were welcome but that she did not see that as a high priority (\"frankly, I think ray tracing is a bit of a gimmick feature\"). Apple hardware only supports it with the M3 and the current driver is for M1 and M2 GPUs, though she plans to start working on M3 before long. The session concluded soon after that, though Rosenzweig played Control, admittedly poorly, as time ran down. [ I would like to thank LWN's travel sponsor, the Linux Foundation, for travel assistance to Montreal for XDC. ] Index entries for this article ConferenceX.Org Developers Conference/2024",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\u003cp\u003e\nThe kernel graphics driver for the Apple M1 and M2 GPUs is, rather\nfamously, written in Rust, but it has achieved conformance with\nvarious graphics standards, which is also noteworthy.  At the \u003ca href=\"https://indico.freedesktop.org/event/6/\"\u003eX.Org Developers Conference\n(XDC) 2024\u003c/a\u003e, Alyssa Rosenzweig gave an update on the status of the\ndriver, along with some news about the kinds of games it can support (\u003ca href=\"https://www.youtube.com/watch?v=TtLP5sAXYKo\"\u003eYouTube video\u003c/a\u003e, \u003ca href=\"https://indico.freedesktop.org/event/6/contributions/284/attachments/230/310/slides.pdf \"\u003eslides\u003c/a\u003e).\nThere has been lots of progress since her talk at XDC last year (\u003ca href=\"https://www.youtube.com/watch?v=O36VFNdQHsE\"\u003eYouTube video\u003c/a\u003e),\nwith, of course, still more to come.\n\u003c/p\u003e\n\n\u003cp\u003e\nIt is something of an XDC tradition, since she began it in Montreal in 2019\n(\u003ca href=\"https://www.youtube.com/watch?v=PqAAWzchHvk\"\u003eYouTube video\u003c/a\u003e),\nfor Rosenzweig to give her presentations dressed like a witch.\nThis year\u0026#39;s edition was no exception, though this time she started her talk in\nFrench, which resulted in some nervous chuckles from attendees. After a few\nsentences, she switched to English, \u0026#34;\u003cq\u003eI\u0026#39;m just kidding\u003c/q\u003e\u0026#34;, and\ncontinued with her talk.\n\u003c/p\u003e\n\n\u003ch4\u003eUpdates and tessellation\u003c/h4\u003e\n\n\u003cp\u003e\nLast year at XDC, she and Asahi Lina reported that the driver had reached\n\u003ca href=\"https://en.wikipedia.org/wiki/OpenGL_ES\"\u003eOpenGL ES\u003c/a\u003e 3.1\nconformance.  They also talked about \u003ca href=\"https://www.khronos.org/opengl/wiki/Geometry_Shader\"\u003egeometry\nshaders\u003c/a\u003e, because \u0026#34;\u003cq\u003ethat was the next step\u003c/q\u003e\u0026#34;.  Since then, the\ndriver has become \u003ca href=\"https://en.wikipedia.org/wiki/OpenGL\"\u003eOpenGL\u003c/a\u003e 4.6\nconformant. That meant she was going to turn to talking about \u003ca href=\"https://www.khronos.org/opengl/wiki/tessellation\"\u003etessellation\u003c/a\u003e\nshaders, \u0026#34;\u003cq\u003eas I threatened to do at the end of last year\u0026#39;s talk\u003c/q\u003e\u0026#34;.\n\u003c/p\u003e\n\n\u003cblockquote\u003e\nLWN.net is able to bring you articles like this one because of our\ngenerous subscribers. If you want to see more like it, consider taking\nadvantage of our special offer: \u003ca href=\"https://lwn.net/Promo/daroc1/claim\"\u003e1 month trial subscription\u003c/a\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\n\u003ca href=\"https://en.wikipedia.org/wiki/Tessellation_(computer_graphics)\"\u003eTessellation\u003c/a\u003e,\nwhich is a technique that \u0026#34;\u003cq\u003eallows detail to be dynamically added and\nsubtracted\u003c/q\u003e\u0026#34; from a scene, is required for OpenGL 4.0, and there is\na hardware tessellator on the Apple GPU—but, \u0026#34;\u003cq\u003ewe can\u0026#39;t use it\u003c/q\u003e\u0026#34;.  The\nhardware is too limited to implement any of the standards; \u0026#34;\u003cq\u003eit is\nmissing features that are hard required for OpenGL, \u003ca href=\"https://www.vulkan.org/\"\u003eVulkan\u003c/a\u003e, and \u003ca href=\"https://en.wikipedia.org/wiki/Direct3D\"\u003eDirect3D\u003c/a\u003e\u003c/q\u003e\u0026#34;.  That\nmakes it \u0026#34;\u003cq\u003epretty much useless to anybody who is not implementing \u003ca href=\"https://en.wikipedia.org/wiki/Metal_(API)\"\u003eMetal\u003c/a\u003e\u003c/q\u003e\u0026#34;.  Apple\nsupports OpenGL 4.1, though it is not conformant, but if you use any\nof the features that the hardware does not support, it simply falls back to\nsoftware; \u0026#34;\u003cq\u003ewe are not going to do that\u003c/q\u003e\u0026#34;.\n\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://lwn.net/Articles/996249/\"\u003e\n\u003cimg src=\"https://static.lwn.net/images/2024/xdc-rosenzweig-sm.png\" alt=\"[Alyssa Rosenzweig]\" title=\"Alyssa Rosenzweig\" width=\"225\" height=\"280\"/\u003e\n\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\nAs far as Rosenzweig is aware, the hardware lacks \u003ca href=\"https://docs.vulkan.org/spec/latest/chapters/tessellation.html#tessellation-point-mode\"\u003epoint mode\u003c/a\u003e, where points\nare used instead of the usual triangles; it also lacks \u003ca href=\"https://docs.vulkan.org/spec/latest/chapters/tessellation.html#tessellation-isoline-tessellation\"\u003eisoline\u003c/a\u003e\nsupport, but those two things can be emulated. The real problem comes\nwith \u003ca href=\"https://www.khronos.org/opengl/wiki/Transform_Feedback\"\u003etransform\nfeedback\u003c/a\u003e and geometry shaders, neither of which is supported by the\nhardware, but the driver emulates them with \u003ca href=\"https://www.khronos.org/opengl/wiki/Compute_Shader\"\u003ecompute\nshaders\u003c/a\u003e.  However, the hardware tessellator cannot be used at all when\nthose are being emulated because minute differences in the tessellation algorithms used\nby the hardware and the emulation would result in \u003ca href=\"https://docs.vulkan.org/spec/latest/appendices/invariance.html\"\u003einvariance\u003c/a\u003e\nfailures.  She is not sure whether that is a problem in practice or not,\n\u0026#34;\u003cq\u003ebut the spec says not to do it\u003c/q\u003e\u0026#34;, so she is hoping not to have to go\nthat route.\n\u003c/p\u003e\n\n\u003cp\u003e\nInstead, \u0026#34;\u003cq\u003ewe use software\u003c/q\u003e\u0026#34;.  In particular, Microsoft released a\nreference tessellator a decade or more ago, which was meant to show\nhardware vendors what they were supposed to implement when tessellation was\nfirst introduced.  It is \u0026#34;\u003cq\u003ea giant pile of 2000 lines of C++\u003c/q\u003e\u0026#34; that\nshe does not understand, despite trying multiple times; \u0026#34;\u003cq\u003eit is\ninscrutable\u003c/q\u003e\u0026#34;. The code will tessellate a single \u003ca href=\"https://www.khronos.org/opengl/wiki/tessellation#Patches\"\u003epatch\u003c/a\u003e, which gave the\ndriver developers an idea: \u0026#34;\u003cq\u003eif we can run that code, we can get the\ntessellation outputs and then we can just draw the triangles or the lines\nwith this \u003ca href=\"https://vulkan-tutorial.com/Vertex_buffers/Index_buffer\"\u003eindex buffer\u003c/a\u003e\u003c/q\u003e\u0026#34;.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere are some problems with that approach, however, starting with the fact\nthat the developers are writing a GPU driver; \u0026#34;\u003cq\u003efamously, GPUs do not like running\n2000 lines of C++\u003c/q\u003e\u0026#34;.  But, she announced, \u0026#34;\u003cq\u003ewe have conformant \u003ca href=\"https://www.khronos.org/opencl/\"\u003eOpenCL\u003c/a\u003e 3.0 support\u003c/q\u003e\u0026#34;\nthanks to Karol Herbst, though it has not yet been released.  OpenCL C is\n\u0026#34;\u003cq\u003epretty much the same as regular CPU C\u003c/q\u003e\u0026#34;, though it has a few\nlimitations and some extensions for GPUs.  So the idea would be to turn the\nC++ tessellation code into OpenCL C code; \u0026#34;\u003cq\u003ewe don\u0026#39;t have to understand\nany of it, we just need to not break anything when we do the port\u003c/q\u003e\u0026#34;.\n\u003c/p\u003e\n\n\u003cp\u003e\nThat works, but \u0026#34;\u003cq\u003e\u003ctt\u003etessellator.cl\u003c/tt\u003e is the most unhinged file of my\ncareer\u003c/q\u003e\u0026#34;; doing things that way was also the most unhinged thing she has done in her career\n\u0026#34;\u003cq\u003eand I\u0026#39;m standing up here in a witch hat for the fifth year in a\nrow\u003c/q\u003e\u0026#34;. The character debuted in the exact same room in 2019 when she\nwas 17 years old, she recalled.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe CPU tessellator only operates on a single patch at a time, but a scene\nmight have 10,000 patches—doing them all serially will be a real problem.\nGPUs are massively parallel, though, so having multiple threads each doing\ntessellation is \u0026#34;\u003cq\u003epretty easy to arrange\u003c/q\u003e\u0026#34;.  There is a problem with\nmemory allocation; the CPU tessellator just allocates for each operation\nsequentially, but that will not work for parallel processing.  Instead, the\ndriver uses the GPU atomic instructions to manage the allocation of output buffers.\n\u003c/p\u003e\n\n\u003cp\u003e\nIn order to draw the output of the tessellators, though, there is a need to\nuse draw instructions with packed data structures as specified by the GPU.\nThat is normally done from the C driver code using functions that are \u003ca href=\"https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/25498\"\u003egenerated\nby the GenXML tool\u003c/a\u003e.  Since the tessellators are simply C code,\n\u0026#34;\u003cq\u003ethanks to OpenCL\u003c/q\u003e\u0026#34;, the generated functions can be included into the\ncode that runs on the GPU.  Rosenzweig went into more detail, which fills\nin the holes (and likely inaccuracies) of the above description; those\ninterested in the details should look at the presentation video and her\nslides.\n\u003c/p\u003e\n\n\u003cp\u003e\n\u0026#34;\u003cq\u003eDoes it work?  Yes, it does.\u003c/q\u003e\u0026#34;\nShe showed an image of terrain tessellation from a Vulkan demo.  It was run\non an M2 Mac with \u0026#34;\u003cq\u003eentirely OpenCL-based tessellation\u003c/q\u003e\u0026#34;. There is also\nthe question of \u0026#34;\u003cq\u003ehow is the performance of this abomination?\u003c/q\u003e\u0026#34;  The\nanswer is that it is \u0026#34;\u003cq\u003eokay\u003c/q\u003e\u0026#34;.  On the system, software-only terrain tessellation runs at\nless than one frame-per-second (fps), which \u0026#34;\u003cq\u003eis not very fun for playing\ngames\u003c/q\u003e\u0026#34;; for OpenCL, it runs at 265fps, which is \u0026#34;\u003cq\u003epretty good\u003c/q\u003e\u0026#34;\nand is unlikely to be the bottleneck for real games.  The hardware\ncan do\n820fps; \u0026#34;\u003cq\u003eI did wire up the hardware tessellator just to get a number for\nthis talk.\u003c/q\u003e\u0026#34;   There is still room for improvement on the driver\u0026#39;s\nnumbers, she said.\n\u003c/p\u003e\n\n\u003ch4\u003eVulkan and gaming\u003c/h4\u003e\n\n\u003cp\u003e\nShe also announced Vulkan 1.3 conformance for the Honeykrisp M1/M2 GPU\ndriver. It \u003ca href=\"https://rosenzweig.io/blog/vk13-on-the-m1-in-1-month.html\"\u003estarted\u003c/a\u003e\nby copying the \u003ca href=\"https://docs.mesa3d.org/drivers/nvk.html\"\u003eNVK\nVulkan driver for NVIDIA GPUs\u003c/a\u003e, \u0026#34;\u003cq\u003esmashed against the [Open]GL 4.6\n[driver]\u003c/q\u003e\u0026#34;, which started passing the conformance test suite\n\u0026#34;\u003cq\u003ein about a month\u003c/q\u003e\u0026#34;.  That was six months ago and, since then, she\nhas added geometry and tessellation shaders, transform feedback, and \u003ca href=\"https://docs.vulkan.org/spec/latest/chapters/shaders.html#shaders-objects\"\u003eshader\nobjects\u003c/a\u003e.  The driver now supports every feature needed for multiple\nDirectX versions.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere are a lot of problems \u0026#34;\u003cq\u003eif we want to run triple-A (AAA) games on\nthis system\u003c/q\u003e\u0026#34;, however.  A target game runs on DirectX and Windows on an x86 CPU with\n4KB pages, but \u0026#34;\u003cq\u003eour target hardware is running literally none of those\nthings\u003c/q\u003e\u0026#34;. What is needed is to somehow translate DirectX to Vulkan,\nWindows to Linux, x86 to Arm64, and 4KB pages to 16KB pages.  The first two\nhave a well-known solution in the form of the \u003ca href=\"https://github.com/doitsujin/dxvk/wiki\"\u003eDXVK driver\u003c/a\u003e and \u003ca href=\"https://www.winehq.org/\"\u003eWine\u003c/a\u003e, which are \u0026#34;\u003cq\u003egenerally packaged\ninto \u003ca href=\"https://en.wikipedia.org/wiki/Proton_(software)\"\u003eProton\u003c/a\u003e\nfor \u003ca href=\"https://en.wikipedia.org/wiki/Steam_(service)\"\u003eSteam\u003c/a\u003e gaming\u003c/q\u003e\u0026#34;.\nGoing from x86 to Arm64 also has off-the-shelf solutions: \u003ca href=\"https://fex-emu.com/\"\u003eFEX-Emu\u003c/a\u003e or \u003ca href=\"https://box86.org/\"\u003eBox64\u003c/a\u003e.  She has a bias toward FEX-Emu;\n\u0026#34;\u003cq\u003ewhen I am not committing \u003ca href=\"https://www.mesa3d.org/\"\u003eMesa\u003c/a\u003e\ncrimes, I am committing FEX-Emulation crimes\u003c/q\u003e\u0026#34;.  The big problem,\nthough, is the page-size difference.\n\u003c/p\u003e\n\n\u003cp\u003e\nFEX-Emu requires 4KB pages; Box64 has a \u0026#34;\u003cq\u003ehack to use 16KB pages, but it\ndoesn\u0026#39;t work for Wine, so it doesn\u0026#39;t help us here\u003c/q\u003e\u0026#34;.  MacOS can use 4KB\npages for the x86 emulation, but \u0026#34;\u003cq\u003ethis requires very invasive kernel\nsupport\u003c/q\u003e\u0026#34;;  \u003ca href=\"https://asahilinux.org/\"\u003eAsahi Linux\u003c/a\u003e already has around 1000 patches that are making\ntheir way toward the mainline kernel, but \u0026#34;\u003cq\u003eevery one of those thousand\nis a challenge\u003c/q\u003e\u0026#34;. Making changes like \u0026#34;\u003cq\u003erewriting the Linux memory\nmanager\u003c/q\u003e\u0026#34; is not a reasonable path.\n\u003c/p\u003e\n\n\u003cp\u003e\nIt turns out that, even though Linux does not support heterogeneous page\nsizes between different processes, it does support them between different\nkernels; \u0026#34;\u003cq\u003ewhat I mean by that is virtualization\u003c/q\u003e\u0026#34;.  A KVM guest\nkernel can have a different page size than the host kernel.  So, \u0026#34;\u003cq\u003ethis\nentire mess\u003c/q\u003e\u0026#34;, consisting of FEX-Emu, Wine, DXVK, Honeykrisp, Steam, and\nthe game, \u0026#34;\u003cq\u003ewe are going to throw that into a virtual machine, which is\nrunning a 4KB guest kernel\u003c/q\u003e\u0026#34;.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere is some overhead, of course, but it is hardware virtualization, so\nthat should have low CPU overhead.  The problem lies with the peripherals,\nshe said.  So, instead of having Honeykrisp in the host kernel, it runs in\nthe guest using \u003ca href=\"https://indico.freedesktop.org/event/2/contributions/53/attachments/76/121/XDC2022_%20virtgpu%20drm%20native%20context.pdf\"\u003evirtgpu\u003c/a\u003e\nnative contexts;  all of the work to create the final GPU command buffer is done\nin the guest and handed to the host, rather than making all of the Vulkan\ncalls individually traverse the virtual-machine boundary.  The \u003ca href=\"https://docs.mesa3d.org/drivers/virgl.html\"\u003eVirGL\u003c/a\u003e renderer on the\nhost then hands that to the GPU, which \u0026#34;\u003cq\u003eis not 100% native speed, but\ndefinitely well above 90%\u003c/q\u003e\u0026#34;, Rosenzweig said.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe good news is that the overheads for the CPU and GPU do not stack, since\nthe two run in parallel. \u0026#34;\u003cq\u003eSo all the crap overhead we have in the CPU is\nactually crap that is running in parallel to the crap overhead on the GPU,\nso we only pay the cost once.\u003c/q\u003e\u0026#34;\n\u003c/p\u003e\n\n\u003cp\u003e\n\u0026#34;\u003cq\u003e\u0026#39;Does it work?\u0026#39; is the question you all want to know.\u003c/q\u003e\u0026#34;  It does,\nshe said, it runs\ngames like \u003ca href=\"https://en.wikipedia.org/wiki/Portal_(video_game)\"\u003ePortal\u003c/a\u003e and \u003ca href=\"https://en.wikipedia.org/wiki/Portal_2\"\u003ePortal 2\u003c/a\u003e. She also listed a number of\nothers: \u003ca href=\"https://en.wikipedia.org/wiki/Castle_Crashers\"\u003eCastle Crashers\u003c/a\u003e,\n\u003ca href=\"https://en.wikipedia.org/wiki/The_Witcher_3:_Wild_Hunt\"\u003eThe\nWitcher 3\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/Fallout_4\"\u003eFallout 4\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/Control_(video_game)\"\u003eControl\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/Ghostrunner\"\u003eGhostrunner\u003c/a\u003e, and \u003ca href=\"https://en.wikipedia.org/wiki/Cyberpunk_2077\"\u003eCyberpunk 2077\u003c/a\u003e.\n\u003c/p\u003e\n\n\u003cp\u003e\nAll of the different pieces that she mentioned were \u003ca href=\"https://rosenzweig.io/blog/aaa-gaming-on-m1.html\"\u003emade available\u003c/a\u003e\non October 10, the day of the talk.  For those running the \u003ca href=\"https://asahilinux.org/fedora/\"\u003eFedora Asahi Remix\u003c/a\u003e distribution,\nshe suggested immediately updating to pick up the pieces that\nshe had described.  Before taking questions, she launched Steam, which took\nsome time to come up, in part because of the virtual machine and the x86\nemulation.  Once it came up, she launched Control, which ran at 45fps on an\nM1 MAX system.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere was a question about resources from someone who has a Mac with 8GB of\nRAM.  Rosenzweig said that the high-end gaming titles are only likely to\nwork on systems with 16GB or more.  She noted that she was playing Castle\nCrashers on an 8GB system during the conference, so some games will play;\nPortal will also work on that system.  She hopes that the resources\nrequired will drop over time.\n\u003c/p\u003e\n\n\u003cp\u003e\nAnother question was about \u003ca href=\"https://en.wikipedia.org/wiki/Ray_tracing_(graphics)\"\u003eray-tracing\u003c/a\u003e\nsupport, since Control can use that \u003ca href=\"https://www.khronos.org/blog/ray-tracing-in-vulkan\"\u003efeature\u003c/a\u003e.\nRosenzweig suggested that patches were welcome but that she did not see\nthat as a high priority (\u0026#34;\u003cq\u003efrankly, I think ray tracing is a bit of a\ngimmick feature\u003c/q\u003e\u0026#34;).  Apple hardware only supports it with the M3 and\nthe current driver is for M1 and M2 GPUs, though she plans to start working\non M3 before long.  The session concluded soon after that, though\nRosenzweig played Control, admittedly poorly, as time ran down.\n\u003c/p\u003e\n\n\u003cp\u003e\n[ I would like to thank LWN\u0026#39;s travel sponsor, the Linux Foundation, for\ntravel assistance to Montreal for XDC. ]\n\u003c/p\u003e\u003cbr clear=\"all\"/\u003e\u003ctable\u003e\n           \u003ctbody\u003e\u003ctr\u003e\u003cth colspan=\"2\"\u003eIndex entries for this article\u003c/th\u003e\u003c/tr\u003e\n           \u003ctr\u003e\u003ctd\u003e\u003ca href=\"https://lwn.net/Archives/ConferenceIndex/\"\u003eConference\u003c/a\u003e\u003c/td\u003e\u003ctd\u003e\u003ca href=\"https://lwn.net/Archives/ConferenceIndex/#X.Org_Developers_Conference-2024\"\u003eX.Org Developers Conference/2024\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\n            \u003c/tbody\u003e\u003c/table\u003e\u003cbr clear=\"all\"/\u003e\n\n               \u003cbr clear=\"all\"/\u003e\n               \u003chr/\u003e\n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
