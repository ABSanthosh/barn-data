{
  "id": "401e1f79-4d8c-42e5-aa39-a8bf5b472827",
  "title": "Read Motor Speed Better By Making The RP2040 PIO Do It",
  "link": "https://hackaday.com/2025/04/29/read-motor-speed-better-by-making-the-rp2040-pio-do-it/",
  "description": "A quadrature encoder provides a way to let hardware read movement (and direction) of a shaft, and they can be simple, effective, and inexpensive devices. But [Paulo Marques] observed that …read more",
  "author": "Donald Papp",
  "published": "Tue, 29 Apr 2025 23:00:19 +0000",
  "source": "https://hackaday.com/blog/feed/",
  "categories": [
    "Microcontrollers",
    "motor speed",
    "PIO",
    "quadrature encoder",
    "rp2040"
  ],
  "byline": "",
  "length": 2819,
  "excerpt": "A quadrature encoder provides a way to let hardware read movement (and direction) of a shaft, and they can be simple, effective, and inexpensive devices. But [Paulo Marques] observed that when it c…",
  "siteName": "Hackaday",
  "favicon": "https://hackaday.com/wp-content/themes/hackaday-2/img/hackaday-logo_1024x1024.png?v=3",
  "text": "Skip to content A quadrature encoder provides a way to let hardware read movement (and direction) of a shaft, and they can be simple, effective, and inexpensive devices. But [Paulo Marques] observed that when it comes to reading motor speeds with them, what works best at high speeds doesn’t work at low speeds, and vice versa. His solution? PicoEncoder is a library providing a lightweight and robust method of using the Programmable I/O (PIO) hardware on the RP2040 to get better results, even (or especially) from cheap encoders, and do it efficiently. The results of the sub-step method (blue) resemble a low-pass filter, but is delivered with no delay or CPU burden. The output of a quadrature encoder is typically two square waves that are out of phase with one another. This data says whether a shaft is moving, and in what direction. When used to measure something like a motor shaft, one can also estimate rotation speed. Count how many steps come from the encoder over a period of time, and use that as the basis to calculate something like revolutions per minute. [Paulo] points out that one issue with this basic method is that the quality depends a lot on how much data one has to work with. But the slower a motor turns, the less data one gets. To work around this, one can use a different calculation optimized for low speeds, but there’s really no single solution that handles high and low speeds well. Another issue is that readings at the “edges” of step transitions can have a lot of noise. This can be ignored and assumed to average out, but it’s a source of inaccuracy that gets worse at slower speeds. Finally, while an ideal encoder has individual phases that are exactly 50% duty cycle and exactly 90 degrees out of phase with one another. This is almost never actually the case with cheaper encoders. Again, a source of inaccuracy. [Paulo]’s solution was to roll his own method with the RP2040’s PIO, using a hybrid approach to effect a “sub-step” quadrature encoder. Compared to simple step counting, PicoEncoder more carefully tracks transitions to avoid problems with noise, and even accounts for phase size differences present in a particular encoder. The result is a much more accurate calculation of motor speed and position without any delays. Most of the work is done by the PIO of the RP2040, which does the low-level work of counting steps and tracking transitions without any CPU time involved. Try it out the next time you need to read a quadrature encoder for a motor! The PIO is one of the more interesting pieces of functionality in the RP2040 and it’s great to see it used in a such a clever way. As our own Elliot Williams put it when he evaluated the RP2040, the PIO promises never having to bit-bang a solution again.",
  "image": "https://hackaday.com/wp-content/uploads/2021/01/RP2040-featured.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"page\"\u003e\n    \n\n    \u003cp\u003e\u003ca href=\"#content\"\u003eSkip to content\u003c/a\u003e\u003c/p\u003e\n\n    \u003cdiv id=\"content\"\u003e\n        \u003cmain id=\"main\" role=\"main\"\u003e\n\n        \n            \n\u003carticle itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"post-773358\"\u003e\n    \n\n    \u003cdiv itemprop=\"articleBody\"\u003e\n        \u003cp\u003eA quadrature encoder provides a way to let hardware read movement (and direction) of a shaft, and they can be simple, effective, and inexpensive devices. But [Paulo Marques] observed that when it comes to reading motor speeds with them, what works best at high speeds doesn’t work at low speeds, and vice versa. His solution? \u003ca href=\"https://github.com/pmarques-dev/PicoEncoder\" target=\"_blank\"\u003ePicoEncoder\u003c/a\u003e is a library providing a lightweight and robust method of using the Programmable I/O (PIO) hardware on the RP2040 to get better results, even (or especially) from cheap encoders, and do it \u003cem\u003eefficiently\u003c/em\u003e.\u003cspan id=\"more-773358\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cfigure id=\"attachment_773368\" aria-describedby=\"caption-attachment-773368\"\u003e\u003ca href=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png\" target=\"_blank\"\u003e\u003cimg decoding=\"async\" data-attachment-id=\"773368\" data-permalink=\"https://hackaday.com/2025/04/29/read-motor-speed-better-by-making-the-rp2040-pio-do-it/substep/\" data-orig-file=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png\" data-orig-size=\"313,313\" data-comments-opened=\"1\" data-image-meta=\"{\u0026#34;aperture\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;credit\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;camera\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;caption\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;created_timestamp\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;copyright\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;focal_length\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;iso\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;shutter_speed\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;title\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;orientation\u0026#34;:\u0026#34;0\u0026#34;}\" data-image-title=\"substep\" data-image-description=\"\" data-image-caption=\"\" data-medium-file=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png?w=313\" data-large-file=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png?w=313\" src=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png?w=250\" alt=\"\" width=\"250\" height=\"250\" srcset=\"https://hackaday.com/wp-content/uploads/2025/04/substep.png 313w, https://hackaday.com/wp-content/uploads/2025/04/substep.png?resize=250,250 250w\" sizes=\"(max-width: 250px) 100vw, 250px\"/\u003e\u003c/a\u003e\u003cfigcaption id=\"caption-attachment-773368\"\u003eThe results of the sub-step method (blue) resemble a low-pass filter, but is delivered with no delay or CPU burden.\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe output of a quadrature encoder is typically two square waves that are out of phase with one another. This data says \u003ca href=\"https://hackaday.com/2013/01/04/estimate-velocity-using-quadrature-encoder-data/\"\u003ewhether a shaft is moving, and in what direction\u003c/a\u003e. When used to measure something like a motor shaft, one can also estimate rotation speed. Count how many steps come from the encoder over a period of time, and use that as the basis to calculate something like revolutions per minute.\u003c/p\u003e\n\u003cp\u003e[Paulo] points out that one issue with this basic method is that the quality depends a lot on how much data one has to work with. But the slower a motor turns, the less data one gets. To work around this, one can use a different calculation optimized for low speeds, but there’s really no single solution that handles high and low speeds well.\u003c/p\u003e\n\u003cp\u003eAnother issue is that readings at the “edges” of step transitions can have a lot of noise. This can be ignored and assumed to average out, but it’s a source of inaccuracy that gets worse at slower speeds. Finally, while an ideal encoder has individual phases that are exactly 50% duty cycle and exactly 90 degrees out of phase with one another. This is almost never actually the case with cheaper encoders. Again, a source of inaccuracy.\u003c/p\u003e\n\u003cp\u003e[Paulo]’s solution was to roll his own method with the RP2040’s PIO, using a hybrid approach to effect a “sub-step” quadrature encoder. Compared to simple step counting, \u003ca href=\"https://github.com/pmarques-dev/PicoEncoder\" target=\"_blank\"\u003ePicoEncoder\u003c/a\u003e more carefully tracks transitions to avoid problems with noise, and even accounts for phase size differences present in a particular encoder. The result is a much more accurate calculation of motor speed and position without any delays. Most of the work is done by the PIO of the RP2040, which does the low-level work of counting steps and tracking transitions without any CPU time involved. Try it out the next time you need to read a quadrature encoder for a motor!\u003c/p\u003e\n\u003cp\u003eThe PIO is one of the more interesting pieces of functionality in the RP2040 and it’s great to see it used in a such a clever way. As our own Elliot Williams put it when he \u003ca href=\"https://hackaday.com/2021/01/20/raspberry-pi-enters-microcontroller-game-with-4-pico/\"\u003eevaluated the RP2040\u003c/a\u003e, the PIO promises never having to bit-bang a solution again.\u003c/p\u003e\n\t            \u003c/div\u003e\n    \u003cul\u003e\n    \t\t\t\t\t\u003cli\u003e\n    \t\t\t\t\u003ca href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fhackaday.com%2F2025%2F04%2F29%2Fread-motor-speed-better-by-making-the-rp2040-pio-do-it%2F\" target=\"_blank\"\u003e\n    \t\t\t\t\t\u003ci\u003e\u003cimg src=\"https://hackaday.com/wp-content/themes/hackaday-2/img/share_face.png\"/\u003e \u003c/i\u003e\n    \t\t\t\t\t\t\t\t\t\u003c/a\u003e\n    \t\t\t\u003c/li\u003e\n    \t\t\t\t\t\u003cli\u003e\n                        \u003ca href=\"https://twitter.com/intent/tweet?text=Read%20Motor%20Speed%20Better%20By%20Making%20The%20RP2040%20PIO%20Do%20It%20via%20@hackaday\u0026amp;url=https://hackaday.com/2025/04/29/read-motor-speed-better-by-making-the-rp2040-pio-do-it/\" target=\"_blank\"\u003e\n    \t\t\t\t\t\u003ci\u003e\u003cimg src=\"https://hackaday.com/wp-content/themes/hackaday-2/img/share_twitter.png\"/\u003e\u003c/i\u003e\n    \t\t\t\t\t\t\t\t\t\u003c/a\u003e\n    \t\t\t\u003c/li\u003e\n    \t\t\t\t\t\u003cli\u003e\n    \t\t\t\t\u003ca href=\"https://www.linkedin.com/shareArticle?url=https%3A%2F%2Fhackaday.com%2F2025%2F04%2F29%2Fread-motor-speed-better-by-making-the-rp2040-pio-do-it%2F\" target=\"_blank\"\u003e\n    \t\t\t\t\t\u003ci\u003e\u003cimg src=\"https://hackaday.com/wp-content/themes/hackaday-2/img/share_in.png\"/\u003e\u003c/i\u003e\n    \t\t\t\t\t\t\t\t\t\u003c/a\u003e\n    \t\t\t\u003c/li\u003e\n    \t\t\t\t\t\u003cli\u003e\n                \u003ca href=\"mailto:?subject=Read+Motor+Speed+Better+By+Making+The+RP2040+PIO+Do+It | Hackaday\u0026amp;body=https%3A%2F%2Fhackaday.com%2F2025%2F04%2F29%2Fread-motor-speed-better-by-making-the-rp2040-pio-do-it%2F\"\u003e\n    \t\t\t\t\t\u003ci\u003e\u003cimg src=\"https://hackaday.com/wp-content/themes/hackaday-2/img/share_mail1.png\"/\u003e\u003c/i\u003e\n    \t\t\t\t\t\t\t\t\t\u003c/a\u003e\n    \t\t\t\u003c/li\u003e\n    \t\t\t\u003c/ul\u003e\n    \n\u003c/article\u003e\n\n            \t\n\t\n            \n\n            \n\n\n        \n        \n\n        \n        \n\n        \n        \u003c/main\u003e\n    \u003c/div\u003e\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-04-29T23:00:19Z",
  "modifiedTime": "2025-04-29T18:51:46Z"
}
