{
  "id": "bb59df00-fbf9-46a8-890f-421b4eda92c6",
  "title": "Making instagram.com faster: Code size and execution optimizations (Part 4)",
  "link": "https://instagram-engineering.com/making-instagram-com-faster-code-size-and-execution-optimizations-part-4-57668be796a8?source=rss----37dc2a3034f2---4",
  "description": "",
  "author": "Glenn Conner",
  "published": "Fri, 01 Nov 2019 13:03:12 GMT",
  "source": "https://instagram-engineering.com/feed/",
  "categories": [
    "instagram",
    "react-native",
    "web-performance",
    "es2017",
    "javascript"
  ],
  "byline": "Glenn Conner",
  "length": 9693,
  "excerpt": "In recent years instagram.com has seen a lot of changes — we’ve launched stories, filters, creation tools, notifications, and direct messaging as well as a myriad of other features and enhancements…",
  "siteName": "Instagram Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "In recent years instagram.com has seen a lot of changes — we’ve launched stories, filters, creation tools, notifications, and direct messaging as well as a myriad of other features and enhancements. However, as the product grew, a side effect was that our web performance began to slow. Over the last year we made a conscious effort to improve this. This ongoing effort has thus far resulted in almost 50% cumulative improvement to our feed page load time. This series of blog posts will outline some of the work we’ve done that led to these improvements. In part 1 we talked about prefetching data, in part 2 we talked about improving performance by pushing data directly to the client rather than waiting for the client to request the data, and in part 3 we talked about cache-first rendering.Code size and execution optimizationsIn parts 1–3 we covered various ways that we optimized the loading patterns of the critical path static resources and data queries. However there is another key area we haven’t covered yet that’s crucial to improving web application performance, particularly on low-end devices — ship less code to the user — in particular, ship less JavaScript. This might seem obvious, but there are a few points to consider here. There’s a common assumption in the industry that the size of the JavaScript that gets downloaded over the network is what’s important (i.e. the size post-compression), however we found that what’s really important is the size pre-compression as this is what has to be parsed and executed on the user’s device, even if it’s cached locally. This becomes particularly true if you have a site with many repeat users (and subsequent high browser cache hit rates) or users accessing your site on mobile devices. In these cases the parsing and execution performance of JavaScript on the CPU becomes the limiting factor rather than the network download time. For example, when we implemented Brotli compression for our JavaScript assets, we saw a nearly 20% reduction of post-compression size across the wire, but NO statistically significant reduction in the overall page load times as seen by end users. On the other hand, we’ve found reductions in pre-compression JavaScript size have consistently led to performance improvements. It’s also worth making a distinction between JavaScript that is executed on the critical path and JavaScript that is dynamically imported after the main page has completed. While ideally it would be nice to reduce the total amount of JavaScript in an application, a key thing to optimize in the short term is the amount of eagerly executed JavaScript on the critical path (we track this with a metric we call Critical Bytes Per Route). Dynamically imported JavaScript that lazy loads is generally not going to have as significant an effect on page load performance, so it’s a valid strategy to move non-visible or interaction dependent UI components out of the initial page bundles and into dynamically imported bundles. Refactoring our UI to reduce the amount of script on the critical path is going to be essential to improving performance in the long term — but this is a significant undertaking which will take time. In the short-term we worked on a number of projects to improve the size and execution efficiency of our existing code in ways that are largely transparent to product developers and require little refactoring of existing product code.Inline requiresWe bundle our frontend web assets using Metro (the same bundler used by React Native) so we get access to inline-requires out of the box. Inline-requires moves the cost of requiring/importing modules to the first time when they are actually used. This means that you can avoid paying execution cost for unused features (though you’ll still pay the cost of downloading and parsing them) and you can better amortize the execution cost over the application startup, rather than having a large amount of upfront computation.Enabling inline requires in React Native \u0026 Instagram WebTo see how this works in practice, lets take the following example code:Using inline requires this would get transformed into something like the following (you’ll find these inline requires by searching for r(d[ in the Instagram JS source in your browser developer tools)As we can see, it essentially works by replacing the local references to a required module with a function call to require that module. This means that unless the code from that module is actually used, the module is never required (and therefore never executed). In most cases this works extremely well, but there are a couple of edge cases to be aware of that can cause problems — namely modules with side effects. For example:Without inline requires, Module C would output {'foo':'bar'}, but when we enable inline-requires, it would output undefined, because B has an implicit dependency on A. This is a contrived example, but there are other real world cases where this can have effects i.e. what if a module does some logging as a part of its initialization - enabling inline-requires could cause this logging to stop happening. This is mostly preventable through linters that check for code that executes immediately at the module scope level, but there were some files we had to blacklist from this optimization such as runtime polyfills that need to execute immediately. After experimenting enabling inline requires across the codebase we saw an improvement in our Feed TTI (time to interactive) by 12% and Display Done by 9.8%, and decided that dealing with some of these minor edge cases was worth it for the performance improvements.Serving ES2017 bundles to modern browsersOne of the primary drivers that drove the adoption of compiler/transpiler tools like Babel was allowing developers to use modern JavaScript coding idioms but still have their applications work in browsers that lacked native support for these latest language features. Since then a number of other important use-cases for these tools arose including compile-to-js languages like Typescript and ReasonML, language extensions such as JSX and Flow type annotations, and build time AST manipulations for things like internationalization. Because of this, it’s unlikely that this extra compilation step is going to go disappear from frontend development workflows any time soon. However, with that said it’s worth revisiting if the original purpose for doing this (cross browser compatibility) is still necessary in 2019. ES2015 and more recent features like async/await are now well supported across recent versions of most major browsers, so directly serving JavaScript containing these newer features is definitely possible — but there are two key questions that we had to answer first:Would enough users be able to take advantage of this to make the extra build complexity worthwhile (as you’d still need to maintain the legacy transpiling step for older browsers),And what (if any) are the performance advantages of shipping ES2015+ featuresTo answer the first question we first had to determine which features we were going to ship without transpiling/polyfilling and how many build variants we wanted to support for the different browsers. We settled on having two builds, one that would require support for ES2017 syntax, and a legacy build that would transpile back to ES5 (in addition we also added an optional polyfill bundle that would only be added for legacy browsers that lacked runtime support for more recent DOM API’s). Detecting support for these groups is done via some basic user-agent sniffing on the server side which ensures there is no runtime cost or extra roundtrip time from doing client-side detection of which bundles to load.With this in mind, we ran the numbers and determined that 56% of users to instagram.com are able to be served the ES2017 build without any transpiling or runtime polyfills, and considering that this percentage is only going to go up over time — it seems like its worth supporting two builds considering the number of users able to utilize it.Percentage of Instagram users with ES2017 supported vs unsupported browsersAs for the second question — what are the performance advantages of shipping ES2017 directly — lets start by looking at what Babel actually does to transpile some common constructs back to ES5. In the left hand column is the ES2017 code, and on the right is the transpiled ES5 compatible version.Class (ES2017 vs ES5)Async/Await (ES2017 vs ES5)Arrow functions (ES2017 vs ES5)Rest parameters (ES2017 vs ES5)Destructuring assignment (ES2017 vs ES5)From this we can see that there is a considerable size overhead in transpiling these constructs (even if you amortize the cost of some of the runtime helper functions over a large codebase). In the case of Instagram, we saw a 5.7% reduction in the size of our core consumer JavaScript bundles when we removed all ES2017 transpiling plugins from our build. In testing we found that the end-to-end load times for the feed page improved by 3% for users who were served the ES2017 bundle compared with those who were not.Still a long way to goWhile the progress that has been made so far is impressive, the work we’ve done so far represents just the beginning. Theres still a huge amount of room left for improvement in areas such as Redux store/reducer modularization, better code splitting, moving more JavaScript execution off the critical path, optimizing scroll performance, adjusting to different bandwidth conditions, and more. If you want to learn more about this work or are interested joining one of our engineering teams, please visit our careers page, follow us on Facebook or on Twitter.",
  "image": "https://miro.medium.com/v2/resize:fit:627/1*HDLCFPZCIfOpVWMSYz4HOg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@mr_sharpoblunto?source=post_page-----57668be796a8--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Glenn Conner\" src=\"https://miro.medium.com/v2/resize:fill:88:88/0*w7Dexcjl8a_rHczk.png\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://instagram-engineering.com/?source=post_page-----57668be796a8--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Instagram Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*CPgwLHR6jno_tOmF0--7eg.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"6301\"\u003eIn recent years \u003ca href=\"http://instagram.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003einstagram.com\u003c/a\u003e has seen a lot of changes — we’ve launched stories, filters, creation tools, notifications, and direct messaging as well as a myriad of other features and enhancements. However, as the product grew, a side effect was that our web performance began to slow. Over the last year we made a conscious effort to improve this. This ongoing effort has thus far resulted in almost 50% cumulative improvement to our feed page load time. This series of blog posts will outline some of the work we’ve done that led to these improvements. In \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://instagram-engineering.com/making-instagram-com-faster-part-1-62cc0c327538\"\u003epart 1\u003c/a\u003e we talked about prefetching data, in \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://instagram-engineering.com/making-instagram-com-faster-part-2-f350c8fba0d4\"\u003epart 2\u003c/a\u003e we talked about improving performance by pushing data directly to the client rather than waiting for the client to request the data, and in \u003ca rel=\"noopener ugc nofollow\" target=\"_blank\" href=\"https://instagram-engineering.com/making-instagram-com-faster-part-3-cache-first-6f3f130b9669\"\u003epart 3\u003c/a\u003e we talked about cache-first rendering.\u003c/p\u003e\u003ch2 id=\"12e3\"\u003eCode size and execution optimizations\u003c/h2\u003e\u003cdiv id=\"d7ee\"\u003e\u003cp\u003eIn parts 1–3 we covered various ways that we optimized the loading patterns of the critical path static resources and data queries. However there is another key area we haven’t covered yet that’s crucial to improving web application performance, particularly on low-end devices — \u003cstrong\u003eship less code to the user \u003c/strong\u003e— in particular, \u003cem\u003eship less JavaScript\u003c/em\u003e. \u003c/p\u003e\u003cp\u003e  This might seem obvious, but there are a few points to consider here. There’s a common assumption in the industry that the size of the JavaScript that gets downloaded over the network is what’s important (i.e. the size \u003cem\u003epost-compression\u003c/em\u003e), however we found that what’s really important is the size \u003cem\u003epre-compression\u003c/em\u003e as this is what has to be parsed and executed on the user’s device, even if it’s cached locally. This becomes particularly true if you have a site with many repeat users (and subsequent high browser cache hit rates) or users accessing your site on mobile devices. In these cases the parsing and execution performance of JavaScript on the CPU becomes the limiting factor rather than the network download time. For example, when we implemented \u003ca href=\"https://en.wikipedia.org/wiki/Brotli\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eBrotli\u003c/a\u003e compression for our JavaScript assets, we saw a nearly 20% reduction of post-compression size across the wire, but \u003cstrong\u003e\u003cem\u003eNO\u003c/em\u003e\u003c/strong\u003e statistically significant reduction in the overall page load times as seen by end users. \u003c/p\u003e\u003cp\u003e  On the other hand, we’ve found reductions in pre-compression JavaScript size have consistently led to performance improvements. It’s also worth making a distinction between JavaScript that is executed on the critical path and JavaScript that is dynamically imported after the main page has completed. While ideally it would be nice to reduce the total amount of JavaScript in an application, a key thing to optimize in the short term is the amount of eagerly executed JavaScript on the critical path (we track this with a metric we call Critical Bytes Per Route). Dynamically imported JavaScript that lazy loads is generally not going to have as significant an effect on page load performance, so it’s a valid strategy to move non-visible or interaction dependent UI components out of the initial page bundles and into dynamically imported bundles. \u003c/p\u003e\u003cp\u003e  Refactoring our UI to reduce the amount of script on the critical path is going to be essential to improving performance in the long term — but this is a significant undertaking which will take time. In the short-term we worked on a number of projects to improve the size and execution efficiency of our existing code in ways that are largely transparent to product developers and require little refactoring of existing product code.\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"7870\"\u003eInline requires\u003c/h2\u003e\u003cp id=\"e200\"\u003eWe bundle our frontend web assets using \u003ca href=\"https://facebook.github.io/metro/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMetro\u003c/a\u003e (the same bundler used by React Native) so we get access to inline-requires out of the box. Inline-requires moves the cost of requiring/importing modules to the first time when they are actually used. This means that you can avoid paying execution cost for unused features (though you’ll still pay the cost of downloading and parsing them) and you can better amortize the execution cost over the application startup, rather than having a large amount of upfront computation.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eEnabling inline requires in React Native \u0026amp; Instagram Web\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"e934\"\u003eTo see how this works in practice, lets take the following example code:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6032\"\u003eUsing inline requires this would get transformed into something like the following (you’ll find these inline requires by searching for \u003ccode\u003er(d[\u003c/code\u003e in the Instagram JS source in your browser developer tools)\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"125c\"\u003eAs we can see, it essentially works by replacing the local references to a required module with a function call to require that module. This means that unless the code from that module is actually used, the module is never required (and therefore never executed). In most cases this works extremely well, but there are a couple of edge cases to be aware of that can cause problems — namely modules with side effects. For example:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5178\"\u003eWithout inline requires, Module C would output \u003ccode\u003e{\u0026#39;foo\u0026#39;:\u0026#39;bar\u0026#39;}\u003c/code\u003e, but when we enable inline-requires, it would output \u003ccode\u003eundefined\u003c/code\u003e, because B has an implicit dependency on A. This is a contrived example, but there are other real world cases where this can have effects i.e. what if a module does some logging as a part of its initialization - enabling inline-requires could cause this logging to stop happening. This is mostly preventable through linters that check for code that executes immediately at the module scope level, but there were some files we had to blacklist from this optimization such as runtime polyfills that need to execute immediately. After experimenting enabling inline requires across the codebase we saw an improvement in our Feed TTI (time to interactive) by 12% and Display Done by 9.8%, and decided that dealing with some of these minor edge cases was worth it for the performance improvements.\u003c/p\u003e\u003ch2 id=\"e90a\"\u003eServing ES2017 bundles to modern browsers\u003c/h2\u003e\u003cdiv id=\"2478\"\u003e\u003cp\u003eOne of the primary drivers that drove the adoption of compiler/transpiler tools like Babel was allowing developers to use modern JavaScript coding idioms but still have their applications work in browsers that lacked native support for these latest language features. Since then a number of other important use-cases for these tools arose including compile-to-js languages like Typescript and ReasonML, language extensions such as JSX and Flow type annotations, and build time AST manipulations for things like internationalization. Because of this, it’s unlikely that this extra compilation step is going to go disappear from frontend development workflows any time soon. However, with that said it’s worth revisiting if the original purpose for doing this (cross browser compatibility) is still necessary in 2019.\u003c/p\u003e\u003cp\u003e  ES2015 and more recent features like async/await are now well supported across recent versions of most major browsers, so directly serving JavaScript containing these newer features is definitely possible — but there are two key questions that we had to answer first:\u003c/p\u003e\u003c/div\u003e\u003cul\u003e\u003cli id=\"589d\"\u003eWould enough users be able to take advantage of this to make the extra build complexity worthwhile (as you’d still need to maintain the legacy transpiling step for older browsers),\u003c/li\u003e\u003cli id=\"5668\"\u003eAnd what (if any) are the performance advantages of shipping ES2015+ features\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d366\"\u003eTo answer the first question we first had to determine which features we were going to ship without transpiling/polyfilling and how many build variants we wanted to support for the different browsers. We settled on having two builds, one that would require support for ES2017 syntax, and a legacy build that would transpile back to ES5 (in addition we also added an optional polyfill bundle that would only be added for legacy browsers that lacked runtime support for more recent DOM API’s). Detecting support for these groups is done via some basic user-agent sniffing on the server side which ensures there is no runtime cost or extra roundtrip time from doing client-side detection of which bundles to load.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"b5c8\"\u003eWith this in mind, we ran the numbers and determined that 56% of users to \u003ca href=\"http://instagram.com\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003einstagram.com\u003c/a\u003e are able to be served the ES2017 build without any transpiling or runtime polyfills, and considering that this percentage is only going to go up over time — it seems like its worth supporting two builds considering the number of users able to utilize it.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003ePercentage of Instagram users with ES2017 supported vs unsupported browsers\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"2a13\"\u003eAs for the second question — what are the performance advantages of shipping ES2017 directly — lets start by looking at what Babel actually does to transpile some common constructs back to ES5. In the left hand column is the ES2017 code, and on the right is the transpiled ES5 compatible version.\u003c/p\u003e\u003ch2 id=\"fdb0\"\u003eClass (ES2017 vs ES5)\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"bad2\"\u003eAsync/Await (ES2017 vs ES5)\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"0f4b\"\u003eArrow functions (ES2017 vs ES5)\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"38d3\"\u003eRest parameters (ES2017 vs ES5)\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"328e\"\u003eDestructuring assignment (ES2017 vs ES5)\u003c/h2\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6c5b\"\u003eFrom this we can see that there is a considerable size overhead in transpiling these constructs (even if you amortize the cost of some of the runtime helper functions over a large codebase). In the case of Instagram, we saw a 5.7% reduction in the size of our core consumer JavaScript bundles when we removed all ES2017 transpiling plugins from our build. In testing we found that the end-to-end load times for the feed page improved by 3% for users who were served the ES2017 bundle compared with those who were not.\u003c/p\u003e\u003ch2 id=\"e14a\"\u003eStill a long way to go\u003c/h2\u003e\u003cdiv id=\"c646\"\u003e\u003cp\u003eWhile the progress that has been made so far is impressive, the work we’ve done so far represents just the beginning. Theres still a huge amount of room left for improvement in areas such as Redux store/reducer modularization, better code splitting, moving more JavaScript execution off the critical path, optimizing scroll performance, adjusting to different bandwidth conditions, and more. \u003c/p\u003e\u003cp\u003e  If you want to learn more about this work or are interested joining one of our engineering teams, please visit our \u003ca href=\"https://www.facebook.com/careers/jobs/?q=instagram\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecareers page\u003c/a\u003e, follow us \u003ca href=\"https://www.facebook.com/instagramengineering/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eon Facebook\u003c/a\u003e or \u003ca href=\"https://twitter.com/instagrameng\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eon Twitter\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2019-11-01T13:03:12.297Z",
  "modifiedTime": null
}
