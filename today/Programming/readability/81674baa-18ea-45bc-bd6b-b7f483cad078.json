{
  "id": "81674baa-18ea-45bc-bd6b-b7f483cad078",
  "title": "How Airbnb Smoothly Upgrades React",
  "link": "https://medium.com/airbnb-engineering/how-airbnb-smoothly-upgrades-react-b1d772a565fd?source=rss----53c7c27702d5---4",
  "description": "",
  "author": "Andre Wiggins",
  "published": "Tue, 23 Jul 2024 17:02:35 GMT",
  "source": "https://medium.com/feed/airbnb-engineering",
  "categories": [
    "front-end-development",
    "engineering",
    "web-development",
    "infrastructure",
    "react"
  ],
  "byline": "Andre Wiggins",
  "length": 13402,
  "excerpt": "Airbnb’s frontend recently reached a major milestone: all of our web surfaces have been upgraded from React 16 to React 18, the current major version of React¹. This was a big project for a product…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Incrementally modernizing our frontend infrastructure to roll out the latest React features without downgradesIntroductionAirbnb’s frontend recently reached a major milestone: all of our web surfaces have been upgraded from React 16 to React 18, the current major version of React¹. This was a big project for a product with many surfaces, including Guest and Host pages as well as many internal tools. To safely perform this upgrade, we created the React Upgrade System: reusable infrastructure that allows us to roll out new versions of React progressively across our monorepo and measure the results of the upgrade. In this blog post, we’ll discuss our upgrade philosophy, the system we created, and what we learned from performing this upgrade.While this post primarily focuses on React, the system and lessons are applicable to many web frameworks and libraries that require regular upgrades.Challenges of upgradingUpgrading dependencies is a common task in any long-lived project. Upgrades fix bugs, improve performance, and unlock new APIs. Some upgrades are simple, but upgrades become more difficult when large amounts of product code rely on changed APIs or subtle assumptions about behavior. In Airbnb’s web monorepo, we only allow one version of each top-level dependency (with some rare exceptions), with one package.json at the root of the repo. This ensures that code within the monorepo is internally compatible and consistent, and that we avoid shipping duplicate packages to users. Before the upgrade system, having a single version of each dependency meant performing an atomic update, which requires a huge amount of up-front migration work, a long-running upgrade branch, and a single milestone when it is finally deployed to users. Such an approach is error-prone and risky, thus requiring a “heroic” engineering effort to ship clean upgrades.Ideally, we’d be shipping small, incremental upgrades that have no issues. Without some way to test and progressively roll out this system to a large monorepo, we often needed to try upgrading multiple times, downgrading whenever any problems were found. Performance regressions were particularly difficult to catch using this upgrade strategy. Because there was no way to collect performance data prior to release, we went straight from 0% to 100% rollout on deployment.Ideal vs Reality graphs of our major and minor versions of React over time.Our goal with the React Upgrade System was to make more seamless upgrading less heroic and more routine. Specifically, our goals were to be able to:Upgrade incrementally so that we get feedback and learn lessons as soon as we can.Upgrade often so that the delta between our version and the upgraded version is as small as possible.Test upgrades so that we can precisely measure the performance impact of upgrades and make informed decisions about upgrade paths using this data.Designing the React Upgrade SystemWorking backwards from these goals, we started to get an idea of what our ideal architecture would look like. We wanted to avoid a long-running upgrade branch so that we could upgrade incrementally, and we wanted to be able to A/B test the upgrade so that we would get feedback from production to inform shipping decisions.Simplified diagram of our ideal upgrade systemThere were a couple of problems to solve with the most naive implementation of this system: we needed to pick a single version of React for rendering, and it was challenging to dynamically switch between the two versions at runtime. Here’s what the code would look like to render a basic application using this naive approach:import React18 from 'react'; import React16 from 'react'; // duplicated import?if (shouldEnableReact18()) { const root = React18.createRoot(container); root.render(\u003cApp /\u003e);} else { React16.render(\u003cApp /\u003e, container);}There are two issues with this:We don’t want to bundle both versions of React in the application, or we’ll double our framework bundle size. Further, we might need to change the JSX transformation being used at build time, making our \u003cApp /\u003e incompatible with one version or the other.It’s not clear where the imports should come from. The ‘react’ dependency will point to either React 16 or React 18, but not to both.To solve these problems, we used module aliasing to split the versions, and environment targeting to build and run the two split versions of React.Module aliasingWe addressed the problem of where these imports are coming from using module aliasing. Using yarn, we added another react dependency to our package.json, e.g.,\"react-18\": \"npm:react@18\"which allowed us to import React from the ‘react-18’ package. This got us part of the way there. Many tools (such as custom resolvers and build systems) need to know which of the two versions to use. To centralize the logic, we wired up all of our custom tooling into a central, “global alias” configuration. This global alias configuration allowed us to alias in one place for all of our different tools. Babel, Jest™, Webpack™, and other custom resolution logic all need to be aware of the conditions under which we want to redirect imports from ‘react’ to ‘react-18’. Aliasing the modules with our “global alias” configuration meant that user code did not need to change at all, and we were able to handle this redirect behind the scenes.TypeScript discrepanciesGiven that any component could be run in React 16 or 18, we wanted to use the types for each component that work across both versions during our upgrade period. Thankfully, the React team has maintained backwards compatibility, even between major versions.We installed the types for React 18, and for newly added APIs in React 18, we created a shim layer for these APIs that worked in both React 16 and 18 (for example, useTransition acted as a no-op in 16). For APIs with no possible shim (for example, useId), we indicated through type augmentation that this hook may be undefined at runtime.For TypeScript-only breaking changes in React 18, we waited until the React 18 upgrade was complete before incrementally fixing these. We augmented the types to patch differences to allow progressively fixing these new Typescript errors in our monorepo.Environment targetingTo solve the problem of duplicated imports, we needed to produce two different build artifacts: one containing React 16 and one containing React 18. Let’s call these the “control” and “treatment” artifacts, respectively. Since Airbnb uses Server-Side Rendering (SSR), we also needed to run these two different artifacts in different node processes on the server. Using Kubernetes®, we set up two different Kubernetes environments that ran these control and treatment artifacts. Let’s call this setup environment targeting.Module aliasing and environment targeting in use together to deploy different versions of the framework together in productionWe also wrote an environment variable (REACT_UPGRADE) to our assets at build time and set this variable at runtime in our node SSR service. This lets us perform conditional logic that might be necessarily on only one or the other side of our upgrade system.This setup also worked for us in local development. Our “local” development environments were also deployed, so we were able to configure the React version for local development in the same way as production using this setup. As each SSR service was upgraded to React 18, we also switched the development environment for that service to React 18 to keep production and local development versions synchronized.Testing the upgradeAirbnb has a comprehensive test suite, which was helpful for building confidence in the safety of this upgrade before exposing the upgrade to users. Our test suite includes visual regression testing, integration testing, and unit testing. Before launching to users, we fixed all new failures in each of these suites.Unit tests were the hardest to abstract from framework internals. Because we use a combination of Enzyme and React Testing Library, we needed to fix assumptions about APIs and framework internals in unit tests, shims, and adapters. To achieve this, we ran all of our unit tests under both React 16 and 18, allowing existing failures in the React 18 test suite as we progressively fixed them. We used this “permitted failures” list to ratchet down the number of test failures over time, which prevented backsliding, as no new failures were allowed on the list. This approach allowed us to fix problems incrementally with components and our test environments.We tracked the work of resolving hundreds of test failures with dashboards, merged fixes incrementally using the upgrade system, and split the work amongst a handful of developers. This made the migration work largely transparent to the broader frontend team and helped us gain confidence in the upgrade before rollout.Progressive rolloutOnce we had module aliasing and environment targeting, we had the capability to author and deliver code for two different versions of React, all from the same codebase. To ensure safety and testability, we also needed a way of rolling out this new environment progressively. To reduce the amount of change happening at once, we wanted to control the roll out across traffic and product surfaces. Our experimentation infrastructure allowed us to direct traffic to each of our two production environments (control and treatment) at will. This setup also allowed us to test the upgrade internally first, and to completely turn off the upgrade if issues were found.Controlling the rollout to different surfaces is more difficult. Within a Single Page App, managing multiple React versions would mean unmounting and mounting React roots. This would lead to poor performance and degrade the user experience.For this reason, we managed the surface rollout upgrade at the app level. Airbnb’s monorepo houses many Single Page Apps, so it was useful to have the react upgrade system in place to be able to turn the upgrade on and off for each of these apps. Using our React Upgrade System, we were able to roll this out to a single app internally first, giving developers a way to opt-in and opt-out of the upgrade for testing, in both development and on our staging sites. This approach let us avoid having a long running feature branch, helping us achieve our goal of incremental upgrades.Feature adoption and future workUsing the system, we completely rolled out React 18 to all web surfaces at Airbnb, with no rollbacks required. After the upgrade, we were able to start testing new APIs such as new root APIs and concurrent rendering features. We intentionally held off for a few weeks on adopting these features until the upgrade had settled. This way we could be confident that we wouldn’t need to downgrade and have to revert code changes.It’s been exciting to see performance improvements from adopting these new features, and we are continuing to experiment with expanding them to key UI surfaces that would benefit.To ensure that our goal of upgrading is often met, we will use the React Upgrade System to test the canary channel of React. Instead of pointing to React 18, we can just point at the canary tag and get a preview of what migration work needs to be happening now for React 19. To make upgrading not require a heroic effort, staying current should be a continual effort spread out over time, rather than a large, one-off change.ConclusionOur goals for the React Upgrade System were to enable us to upgrade incrementally, test upgrades, and upgrade often. Combining environment targeting and our aliasing system has allowed us to upgrade incrementally and test the upgrades. We’re beginning to run our frontend against React 19 beta, getting a head start on React 19.We’d like to acknowledge the React team for putting effort into backwards compatibility between React versions, even major versions. Without that effort, this upgrade approach would not be possible.Using the React Upgrade System, we gained confidence in our rollout of React 18, and will use this approach for future upgrades. We believe investing in an upgrading system is worthwhile, as upgrades will continue to be needed over time. The React Upgrade System has allowed us to test and roll out upgrades incrementally, ensuring that we’re delivering the best user experience and performance possible for our users.If this kind of work sounds appealing to you, check out our open roles — we’re hiring!AcknowledgmentsMany thanks to Joshua Nelson for leading the effort to build the React Upgrade System as well as for drafting this blog post.Additionally, thanks to Kim Nguyen, Callie Riggins Zetino, James Robinson, Dan Beam, Kaeson Ho, Rae Liu, Michael James, Noah Sugarman, Laurie Jin, Brie Bunge, Matt Mulder, Victor Lin for their assistance on this system and the pieces comprising it.[1]: React 17 was released in 2020 as a no-feature “stepping stone” release with minimal breaking changes. By the time we were working on this upgrade, React 18 had been released, so we opted to upgrade directly to 18. As of writing, React 19 is in beta, and we are reusing our React Upgrade System for React 19.All product names, logos, and brands are property of their respective owners. All company, product and service names used in this website are for identification purposes only. Use of these names, logos, and brands does not imply endorsement.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*8jiO3WebwJ4aoyYFYltkOw.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"0ce3\"\u003eIncrementally modernizing our frontend infrastructure to roll out the latest React features without downgrades\u003c/h2\u003e\u003cdiv\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@andrewiggins?source=post_page-----b1d772a565fd--------------------------------\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Andre Wiggins\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*0O3TUiDp5bS-kKBhTsWNUA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://medium.com/airbnb-engineering?source=post_page-----b1d772a565fd--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"The Airbnb Tech Blog\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*MlNQKg-sieBGW5prWoe9HQ.jpeg\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"73a7\"\u003eIntroduction\u003c/h2\u003e\u003cp id=\"e755\"\u003eAirbnb’s frontend recently reached a major milestone: all of our web surfaces have been upgraded from React 16 to React 18, the current major version of React¹. This was a big project for a product with many surfaces, including Guest and Host pages as well as many internal tools. To safely perform this upgrade, we created the React Upgrade System: reusable infrastructure that allows us to roll out new versions of React progressively across our monorepo and measure the results of the upgrade. In this blog post, we’ll discuss our upgrade philosophy, the system we created, and what we learned from performing this upgrade.\u003c/p\u003e\u003cp id=\"c530\"\u003eWhile this post primarily focuses on React, the system and lessons are applicable to many web frameworks and libraries that require regular upgrades.\u003c/p\u003e\u003ch2 id=\"3c6d\"\u003eChallenges of upgrading\u003c/h2\u003e\u003cp id=\"b989\"\u003eUpgrading dependencies is a common task in any long-lived project. Upgrades fix bugs, improve performance, and unlock new APIs. Some upgrades are simple, but upgrades become more difficult when large amounts of product code rely on changed APIs or subtle assumptions about behavior. In Airbnb’s web monorepo, we only allow one version of each top-level dependency (with some rare exceptions), with one package.json at the root of the repo. This ensures that code within the monorepo is internally compatible and consistent, and that we avoid shipping duplicate packages to users. Before the upgrade system, having a \u003cem\u003esingle version \u003c/em\u003eof each dependency meant performing an atomic update, which requires a huge amount of up-front migration work, a long-running upgrade branch, and a single milestone when it is finally deployed to users. Such an approach is error-prone and risky, thus requiring a “heroic” engineering effort to ship clean upgrades.\u003c/p\u003e\u003cp id=\"9ece\"\u003eIdeally, we’d be shipping small, incremental upgrades that have no issues. Without some way to test and progressively roll out this system to a large monorepo, we often needed to try upgrading multiple times, downgrading whenever any problems were found. Performance regressions were particularly difficult to catch using this upgrade strategy. Because there was no way to collect performance data prior to release, we went straight from 0% to 100% rollout on deployment.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eIdeal vs Reality graphs of our major and minor versions of React over time.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"91c5\"\u003eOur goal with the React Upgrade System was to make more seamless upgrading less heroic and more routine. Specifically, our goals were to be able to:\u003c/p\u003e\u003col\u003e\u003cli id=\"1195\"\u003e\u003cstrong\u003eUpgrade incrementally\u003c/strong\u003e so that we get feedback and learn lessons as soon as we can.\u003c/li\u003e\u003cli id=\"5e0b\"\u003e\u003cstrong\u003eUpgrade often\u003c/strong\u003e so that the delta between our version and the upgraded version is as small as possible.\u003c/li\u003e\u003cli id=\"6707\"\u003e\u003cstrong\u003eTest upgrades \u003c/strong\u003eso that we can precisely measure the performance impact of upgrades and make informed decisions about upgrade paths using this data.\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"f9df\"\u003eDesigning the React Upgrade System\u003c/h2\u003e\u003cp id=\"8331\"\u003eWorking backwards from these goals, we started to get an idea of what our ideal architecture would look like. We wanted to avoid a long-running upgrade branch so that we could upgrade incrementally, and we wanted to be able to A/B test the upgrade so that we would get feedback from production to inform shipping decisions.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cem\u003eSimplified diagram of our ideal upgrade system\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"17d3\"\u003eThere were a couple of problems to solve with the most naive implementation of this system: we needed to pick a single version of React for rendering, and it was challenging to dynamically switch between the two versions at runtime. Here’s what the code would look like to render a basic application using this naive approach:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5ebc\"\u003eimport React18 from \u0026#39;react\u0026#39;; \u003cbr/\u003eimport React16 from \u0026#39;react\u0026#39;; // duplicated import?\u003cp\u003eif (shouldEnableReact18()) {\u003cbr/\u003e  const root = React18.createRoot(container);\u003cbr/\u003e  root.render(\u0026lt;App /\u0026gt;);\u003cbr/\u003e} else {\u003cbr/\u003e  React16.render(\u0026lt;App /\u0026gt;, container);\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2f5a\"\u003eThere are two issues with this:\u003c/p\u003e\u003col\u003e\u003cli id=\"3376\"\u003eWe don’t want to bundle both versions of React in the application, or we’ll double our framework bundle size. Further, we might need to change the JSX transformation being used at build time, making our \u003ccode\u003e\u0026lt;App /\u0026gt;\u003c/code\u003e incompatible with one version or the other.\u003c/li\u003e\u003cli id=\"8048\"\u003eIt’s not clear where the imports should come from. The ‘react’ dependency will point to either React 16 or React 18, but not to both.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"8727\"\u003eTo solve these problems, we used \u003cstrong\u003emodule aliasing\u003c/strong\u003e to split the versions, and \u003cstrong\u003eenvironment targeting \u003c/strong\u003eto build and run the two split versions of React.\u003c/p\u003e\u003ch2 id=\"d3e9\"\u003eModule aliasing\u003c/h2\u003e\u003cp id=\"8d2c\"\u003eWe addressed the problem of where these imports are coming from using module aliasing. Using yarn, we added another react dependency to our package.json, e.g.,\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b343\"\u003e\u0026#34;react-18\u0026#34;: \u0026#34;npm:react@18\u0026#34;\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"014c\"\u003ewhich allowed us to import React from the ‘react-18’ package. This got us part of the way there. Many tools (such as custom resolvers and build systems) need to know which of the two versions to use. To centralize the logic, we wired up all of our custom tooling into a central, “global alias” configuration. This global alias configuration allowed us to alias in one place for all of our different tools. Babel, Jest™, Webpack™, and other custom resolution logic all need to be aware of the conditions under which we want to redirect imports from ‘react’ to ‘react-18’. Aliasing the modules with our “global alias” configuration meant that user code did not need to change at all, and we were able to handle this redirect behind the scenes.\u003c/p\u003e\u003ch2 id=\"78f1\"\u003eTypeScript discrepancies\u003c/h2\u003e\u003cp id=\"5f0b\"\u003eGiven that any component could be run in React 16 or 18, we wanted to use the types for each component that work across both versions during our upgrade period. Thankfully, the React team has maintained backwards compatibility, even between major versions.\u003c/p\u003e\u003cp id=\"8f26\"\u003eWe installed the types for React 18, and for newly added APIs in React 18, we created a shim layer for these APIs that worked in both React 16 and 18 (for example, \u003ca href=\"https://react.dev/blog/2022/03/29/react-v18#usetransition\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003euseTransition\u003c/a\u003e acted as a no-op in 16). For APIs with no possible shim (for example, \u003ca href=\"https://react.dev/reference/react/useId\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003euseId\u003c/a\u003e), we indicated through type augmentation that this hook may be undefined at runtime.\u003c/p\u003e\u003cp id=\"0d12\"\u003eFor TypeScript-only \u003ca href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/issues/46691\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebreaking changes in React 18\u003c/a\u003e, we waited until the React 18 upgrade was complete before incrementally fixing these. We augmented the types to patch differences to allow progressively fixing these new Typescript errors in our monorepo.\u003c/p\u003e\u003ch2 id=\"760e\"\u003eEnvironment targeting\u003c/h2\u003e\u003cp id=\"2fda\"\u003eTo solve the problem of duplicated imports, we needed to produce two different build artifacts: one containing React 16 and one containing React 18. Let’s call these the “control” and “treatment” artifacts, respectively. Since Airbnb uses Server-Side Rendering (SSR), we also needed to run these two different artifacts in different node processes on the server. Using Kubernetes®, we set up two different Kubernetes environments that ran these control and treatment artifacts. Let’s call this setup \u003cstrong\u003eenvironment targeting\u003c/strong\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003e\u003cstrong\u003e\u003cem\u003eModule aliasing \u003c/em\u003e\u003c/strong\u003e\u003cem\u003eand \u003c/em\u003e\u003cstrong\u003e\u003cem\u003eenvironment targeting\u003c/em\u003e\u003c/strong\u003e\u003cem\u003e in use together to deploy different versions of the framework together in production\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"644d\"\u003eWe also wrote an environment variable (REACT_UPGRADE) to our assets at build time and set this variable at runtime in our node SSR service. This lets us perform conditional logic that might be necessarily on only one or the other side of our upgrade system.\u003c/p\u003e\u003cp id=\"cf07\"\u003eThis setup also worked for us in local development. Our “local” development environments were also deployed, so we were able to configure the React version for local development in the same way as production using this setup. As each SSR service was upgraded to React 18, we also switched the development environment for that service to React 18 to keep production and local development versions synchronized.\u003c/p\u003e\u003ch2 id=\"98d6\"\u003eTesting the upgrade\u003c/h2\u003e\u003cp id=\"6e63\"\u003eAirbnb has a comprehensive test suite, which was helpful for building confidence in the safety of this upgrade before exposing the upgrade to users. Our test suite includes visual regression testing, integration testing, and unit testing. Before launching to users, we fixed all new failures in each of these suites.\u003c/p\u003e\u003cp id=\"8119\"\u003eUnit tests were the hardest to abstract from framework internals. Because we use a \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/phase-ii-enzyme-d9efa717e297\"\u003ecombination of Enzyme and React Testing Library\u003c/a\u003e, we needed to fix assumptions about APIs and framework internals in unit tests, shims, and adapters. To achieve this, we ran all of our unit tests under both React 16 and 18, allowing existing failures in the React 18 test suite as we progressively fixed them. We used this “permitted failures” list to ratchet down the number of test failures over time, which prevented backsliding, as no new failures were allowed on the list. This approach allowed us to fix problems incrementally with components and our test environments.\u003c/p\u003e\u003cp id=\"8646\"\u003eWe tracked the work of resolving hundreds of test failures with dashboards, merged fixes incrementally using the upgrade system, and split the work amongst a handful of developers. This made the migration work largely transparent to the broader frontend team and helped us gain confidence in the upgrade before rollout.\u003c/p\u003e\u003ch2 id=\"3f6f\"\u003eProgressive rollout\u003c/h2\u003e\u003cp id=\"96e4\"\u003eOnce we had \u003cstrong\u003emodule aliasing \u003c/strong\u003eand \u003cstrong\u003eenvironment targeting\u003c/strong\u003e, we had the capability to author and deliver code for two different versions of React, all from the same codebase. To ensure safety and testability, we also needed a way of rolling out this new environment progressively. To reduce the amount of change happening at once, we wanted to control the roll out across traffic and product surfaces. Our experimentation infrastructure allowed us to direct traffic to each of our two production environments (control and treatment) at will. This setup also allowed us to test the upgrade internally first, and to completely turn off the upgrade if issues were found.\u003c/p\u003e\u003cp id=\"9cf9\"\u003eControlling the rollout to different surfaces is more difficult. Within a Single Page App, managing multiple React versions would mean unmounting and mounting React roots. This would lead to poor performance and degrade the user experience.\u003c/p\u003e\u003cp id=\"c0e1\"\u003eFor this reason, we managed the surface rollout upgrade at the app level. Airbnb’s monorepo houses many Single Page Apps, so it was useful to have the react upgrade system in place to be able to turn the upgrade on and off for each of these apps. Using our React Upgrade System, we were able to roll this out to a single app internally first, giving developers a way to opt-in and opt-out of the upgrade for testing, in both development and on our staging sites. This approach let us avoid having a long running feature branch, helping us achieve our goal of incremental upgrades.\u003c/p\u003e\u003ch2 id=\"3fab\"\u003eFeature adoption and future work\u003c/h2\u003e\u003cp id=\"2ccc\"\u003eUsing the system, we completely rolled out React 18 to all web surfaces at Airbnb, with no rollbacks required. After the upgrade, we were able to start testing new APIs such as \u003ca href=\"https://react.dev/reference/react-dom/client/createRoot\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003enew root APIs\u003c/a\u003e and \u003ca href=\"https://react.dev/reference/react/startTransition\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003econcurrent rendering features\u003c/a\u003e. We intentionally held off for a few weeks on adopting these features until the upgrade had settled. This way we could be confident that we wouldn’t need to downgrade and have to revert code changes.\u003c/p\u003e\u003cp id=\"094b\"\u003eIt’s been exciting to see performance improvements from adopting these new features, and we are continuing to experiment with expanding them to key UI surfaces that would benefit.\u003c/p\u003e\u003cp id=\"0493\"\u003eTo ensure that our goal of upgrading is often met, we will use the React Upgrade System to test the \u003ca href=\"https://react.dev/community/versioning-policy#canary-channel\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecanary channel of React\u003c/a\u003e. Instead of pointing to React 18, we can just point at the canary tag and get a preview of what migration work needs to be happening now for \u003ca href=\"https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024#the-next-major-version-of-react\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eReact 19\u003c/a\u003e. To make upgrading not require a heroic effort, staying current should be a continual effort spread out over time, rather than a large, one-off change.\u003c/p\u003e\u003ch2 id=\"4ee5\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"1121\"\u003eOur goals for the React Upgrade System were to enable us to \u003cstrong\u003eupgrade incrementally, test upgrades\u003c/strong\u003e, and \u003cstrong\u003eupgrade often. \u003c/strong\u003eCombining environment targeting and our aliasing system has allowed us to upgrade incrementally and test the upgrades. We’re beginning to run our frontend against React 19 beta, getting a head start on React 19.\u003c/p\u003e\u003cp id=\"df49\"\u003eWe’d like to acknowledge the React team for putting effort into backwards compatibility between React versions, even major versions. Without that effort, this upgrade approach would not be possible.\u003c/p\u003e\u003cp id=\"e1e6\"\u003eUsing the React Upgrade System, we gained confidence in our rollout of React 18, and will use this approach for future upgrades. We believe investing in an upgrading system is worthwhile, as upgrades will continue to be needed over time. The React Upgrade System has allowed us to test and roll out upgrades incrementally, ensuring that we’re delivering the best user experience and performance possible for our users.\u003c/p\u003e\u003cp id=\"293a\"\u003eIf this kind of work sounds appealing to you, check out our \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eopen roles\u003c/a\u003e — we’re hiring!\u003c/p\u003e\u003ch2 id=\"24af\"\u003eAcknowledgments\u003c/h2\u003e\u003cp id=\"d9fa\"\u003eMany thanks to \u003cspan\u003e\u003cspan aria-hidden=\"false\"\u003e\u003ca href=\"https://medium.com/u/f3ca95278bae?source=post_page-----b1d772a565fd--------------------------------\" rel=\"noopener\" target=\"_blank\"\u003eJoshua Nelson\u003c/a\u003e\u003c/span\u003e\u003c/span\u003e for leading the effort to build the React Upgrade System as well as for drafting this blog post.\u003c/p\u003e\u003cp id=\"4cab\"\u003eAdditionally, thanks to Kim Nguyen, Callie Riggins Zetino, James Robinson, Dan Beam, Kaeson Ho, Rae Liu, Michael James, Noah Sugarman, Laurie Jin, Brie Bunge, Matt Mulder, Victor Lin for their assistance on this system and the pieces comprising it.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"7c76\"\u003e[1]: React 17 was \u003ca href=\"https://legacy.reactjs.org/blog/2020/10/20/react-v17.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ereleased in 2020\u003c/a\u003e as a no-feature “stepping stone” release with minimal breaking changes. By the time we were working on this upgrade, React 18 had been released, so we opted to upgrade directly to 18. As of writing, React 19 is in beta, and we are reusing our React Upgrade System for React 19.\u003c/p\u003e\u003cp id=\"6464\"\u003e\u003cem\u003eAll product names, logos, and brands are property of their respective owners. All company, product and service names used in this website are for identification purposes only. Use of these names, logos, and brands does not imply endorsement.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-07-23T17:02:35.041Z",
  "modifiedTime": null
}
