{
  "id": "3d98e12c-a12d-4adc-8a18-cafcceb1bf54",
  "title": "RSC for LISP Developers",
  "link": "https://overreacted.io/rsc-for-lisp-developers/",
  "description": "Quoting for modules.",
  "author": "",
  "published": "Sun, 01 Jun 2025 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 3691,
  "excerpt": "Quoting for modules.",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "One of the big ideas of LISP is that code is data, and data is code. I mean, that’s kind of generally true, but in LISP it’s both culturally and syntactically emphasized. For example, let’s take this piece of code in LISP: (+ 2 2) This gives us 4. But let’s put a quote before it: '(+ 2 2) Suddenly, the result is… (+ 2 2). Uh, what do I do with that? Well, that’s a piece of LISP code. “Quoting” a piece of LISP code means “don’t actually evaluate it, just give me the code itself”. Of course, I could evaluate it later: (eval '(+ 2 2)) This gives me 4 again. That’s what I mean by “code is data” being very much in the LISP culture. The language has a first-class primitive for “don’t execute this part”. That’s quoting. Now consider web apps. A web server is a program whose job is to generate another program. A server generates the client program (written in HTML and JavaScript) and serves it to the client computer. Generating and sending code sounds an awful lot like quoting. In JavaScript, we don’t have quoting. I can’t put a ' before a function and say “now I want to treat this as data rather than code”. Well, I could wrap it into a string literal, but there would be no syntax highlighting and it would kind of lose too much syntatic power. You really don’t want to be coding inside string literals. We can’t “quote” individual code blocks in JavaScript without losing many benefits of the language. However, what if we could “quote”… an entire module? React Server Components (RSC) is a client-server programming paradigm that uses a similar idea to refer to client code from the server code. The 'use client' directive lets you import code designed for the client—but without running it: 'use client' export function onClick() { alert('Hi.'); } Like quoting, it marks a piece of code to be treated as data. Unlike quoting in LISP, the result you get back is opaque—you can’t transform or introspect that code. This means that whoever imports onClick from the backend code won’t get an actual onClick function—instead, they’ll get '/js/chunk123.js#onClick' or something like that identifying how to load this module. It gives you code-as-data. Unlike with LISP quoting, this is implemented at the compile time using a bundler. Eventually this code will make it to the client (as a \u003cscript\u003e) and be evaluated there. Then, the onClick function will actually exist (and maybe even be called). What this gives us is an ability to write a program that composes behaviors that execute at different stages (on the server and the client) in a very modular way. See here for example. The parts outside the “quote” deal with server-only resources, while the parts inside the “quote” are stateful and exist on the client—but they are composed. The server stuff can wrap the client stuff, the client stuff can wrap the server stuff, as long as you’re doing all composition from the server. And what doing composition on the server enables is a guarantee that all the server stuff runs within a single request/response roundtrip. It’s also progressively streamed. That’s kind of it, really. Of course, this is a lot less powerful than quoting because the evaluation strategies are being prescribed by React, and there’s no kind of metaprogramming like transforming the code itself. So maybe it’s still a stretch. I know LISP has a rich tradition of solutions that compose code across multiple environments, with some newer approaches like Electric picking up steam. I don’t understand LISP well enough to dig deep into them but I would love to see more explanations targeted at JavaScript developers, both about prior art and new ideas. Thank you! I’ll try to learn LISP too, someday.",
  "image": "https://overreacted.io/rsc-for-lisp-developers/opengraph-image?5b0b970dfd19bb8c",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eOne of the big ideas of LISP is that code is data, and data is code. I mean, that’s kind of \u003ca target=\"_blank\" href=\"https://wiki.c2.com/?DataAndCodeAreTheSameThing\"\u003egenerally\u003c/a\u003e true, but in LISP it’s both culturally and syntactically emphasized. For example, let’s take this piece of code in LISP:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThis gives us \u003ccode\u003e4\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBut let’s put a quote before it:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026#39;(\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eSuddenly, the result is… \u003ccode\u003e(+ 2 2)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eUh, what do I do with that? Well, that’s a piece of LISP code. “Quoting” a piece of LISP code means “don’t actually evaluate it, just give me the code itself”.\u003c/p\u003e\n\u003cp\u003eOf course, I \u003cem\u003ecould\u003c/em\u003e evaluate it later:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"lisp\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eeval\u003c/span\u003e\u003cspan\u003e \u0026#39;(\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e 2\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThis gives me \u003ccode\u003e4\u003c/code\u003e again.\u003c/p\u003e\n\u003cp\u003eThat’s what I mean by “code is data” being very much in the LISP culture. The language has a first-class primitive for “don’t execute this part”. That’s quoting.\u003c/p\u003e\n\u003cp\u003eNow consider web apps.\u003c/p\u003e\n\u003cp\u003eA web server is a program whose job is to generate another program. A server generates the client program (written in HTML and JavaScript) and serves it to the client computer. Generating and sending code sounds an awful lot like quoting.\u003c/p\u003e\n\u003cp\u003eIn JavaScript, we don’t have quoting. I can’t put a \u003ccode\u003e\u0026#39;\u003c/code\u003e before a function and say “now I want to treat this as data rather than code”. Well, I could wrap it into a string literal, but there would be no syntax highlighting and it would kind of lose too much syntatic power. You really don’t want to be coding inside string literals.\u003c/p\u003e\n\u003cp\u003eWe can’t “quote” individual code blocks in JavaScript without losing many benefits of the language. However, what if we could “quote”… an entire module?\u003c/p\u003e\n\u003cp\u003eReact Server Components (RSC) is a client-server programming paradigm that uses a similar idea to refer to client code from the server code. The \u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e directive lets you \u003ca href=\"https://overreacted.io/why-does-rsc-integrate-with-a-bundler/#serializing-modules\"\u003eimport code designed for the client—but without running it\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003euse client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e onClick\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  alert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eHi.\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cp\u003eLike quoting, it marks a piece of code to be treated as data. \u003cem\u003eUnlike\u003c/em\u003e quoting in LISP, the result you get back is opaque—you can’t transform or introspect that code.\u003c/p\u003e\n\u003cp\u003eThis means that whoever imports \u003ccode\u003eonClick\u003c/code\u003e from the backend code won’t get an actual \u003ccode\u003eonClick\u003c/code\u003e function—instead, they’ll get \u003ccode\u003e\u0026#39;/js/chunk123.js#onClick\u0026#39;\u003c/code\u003e or something like that identifying \u003cem\u003ehow to load\u003c/em\u003e this module. It gives you code-as-data. Unlike with LISP quoting, this is \u003ca href=\"https://overreacted.io/why-does-rsc-integrate-with-a-bundler/#rsc-bundler-bindings\"\u003eimplemented at the compile time\u003c/a\u003e using a bundler.\u003c/p\u003e\n\u003cp\u003eEventually this code will make it to the client (as a \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e) and be evaluated there. Then, the \u003ccode\u003eonClick\u003c/code\u003e function will actually exist (and maybe even be called).\u003c/p\u003e\n\u003cp\u003eWhat this gives us is an ability to write a program that composes behaviors that execute at different stages (on the server and the client) in a very modular way. \u003ca href=\"https://overreacted.io/impossible-components/#final-code\"\u003eSee here for example.\u003c/a\u003e The parts outside the “quote” deal with server-only resources, while the parts inside the “quote” are stateful and exist on the client—but they are composed. The server stuff can wrap the client stuff, the client stuff can wrap the server stuff, as long as you’re doing all composition from the server. And what doing composition on the server enables is a guarantee that all the server stuff runs \u003ca href=\"https://overreacted.io/one-roundtrip-per-navigation/\"\u003ewithin a single request/response roundtrip\u003c/a\u003e. It’s also \u003ca href=\"https://overreacted.io/progressive-json/\"\u003eprogressively streamed\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThat’s kind of it, really. Of course, this is a lot less powerful than quoting because the evaluation strategies are being prescribed by React, and there’s no kind of metaprogramming like transforming the code itself. So maybe it’s still a stretch.\u003c/p\u003e\n\u003cp\u003eI know LISP has a rich tradition of solutions that compose code across multiple environments, with some newer approaches like \u003ca target=\"_blank\" href=\"https://github.com/hyperfiddle/electric\"\u003eElectric\u003c/a\u003e picking up steam. I don’t understand LISP well enough to dig deep into them but I would love to see more explanations targeted at JavaScript developers, both about prior art and new ideas.\u003c/p\u003e\n\u003cp\u003eThank you!\u003c/p\u003e\n\u003cp\u003eI’ll try to learn LISP too, someday.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
