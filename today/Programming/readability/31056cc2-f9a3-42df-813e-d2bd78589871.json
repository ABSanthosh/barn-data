{
  "id": "31056cc2-f9a3-42df-813e-d2bd78589871",
  "title": "Building and Deploying Microservices With Spring Boot and TeamCity",
  "link": "https://blog.jetbrains.com/teamcity/2025/04/building-and-deploying-microservices-spring-boot-teamcity/",
  "description": "This tutorial was brought to you by Rajkumar Venkatasamy, draft.dev. Microservice architecture has become a cornerstone for building scalable and maintainable applications. Microservices allow individual services to be developed, deployed, and scaled independently, resulting in faster delivery cycles and improved fault isolation.  For example, an e-commerce platform can use independent services to handle product catalogs, […]",
  "author": "Olga Bedrina",
  "published": "Tue, 01 Apr 2025 13:13:04 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "how-tos",
    "java",
    "tutorials",
    "microservices",
    "news",
    "spring-boot",
    "tutorial"
  ],
  "byline": "Olga Bedrina",
  "length": 22771,
  "excerpt": "In this tutorial, you’ll learn how to create a microservice using Spring Boot, set up a CI/CD pipeline with JetBrains TeamCity, and automate deployment using Docker.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Powerful CI/CD for DevOps-centric teams How-To's Java TutorialsBuilding and Deploying Microservices With Spring Boot and TeamCity This tutorial was brought to you by Rajkumar Venkatasamy, draft.dev. Microservice architecture has become a cornerstone for building scalable and maintainable applications. Microservices allow individual services to be developed, deployed, and scaled independently, resulting in faster delivery cycles and improved fault isolation.  For example, an e-commerce platform can use independent services to handle product catalogs, user authentication, and order management. By breaking large applications into smaller, independent services, organizations can address challenges such as long development cycles, difficulty in scaling specific components, and the risk of a single failure affecting the entire application. In enterprise applications, microservices make it easier to quickly update and scale specific parts of the system. This allows teams to improve features without affecting the entire application. Automated testing and deployment of service components increase reliability, catching potential issues early and maintaining system stability.  Microservices also streamline the DevOps workflow, allowing for faster time-to-market by reducing the complexity of deployments and leveraging continuous integration and continuous deployment (CI/CD) pipelines. These pipelines play a critical role in managing the lifecycle of microservices from development to deployment, ensuring consistent and efficient delivery processes. In this tutorial, you’ll learn how to create a microservice using Spring Boot, set up a CI/CD pipeline with JetBrains TeamCity, and automate deployment using Docker. Microservice overview and prerequisites Imagine you’re developing an inventory management system where each microservice handles a specific function, such as managing products, orders, or customers. In this tutorial, you’ll build a “Product Service” microservice that provides RESTful APIs to create and list products. Architecture diagram You’ll need the following to complete this tutorial: Exposure to Java programming and JDK 21 or higher. Familiarity with Spring Boot, particularly using Spring Initializr for generating and working with Spring Boot projects. TeamCity. This tutorial uses the on-premises version of TeamCity running on a Windows machine as a Windows service. However, you can use whichever TeamCity version you prefer. Git. A GitHub account. Docker Desktop. A Docker Hub account and a repository to pull or push the Docker image you’ll build as part of this tutorial. Set up a new GitHub repo Create an empty repository on GitHub and clone it to your local machine using this command: git clone \u003cyour GitHub repository path\u003e You’ll use this GitHub repository later while setting up the build pipeline in TeamCity. Generate a Java Spring Boot project Open a browser and paste the following preconfigured URL to load the Spring Boot project in the browser: https://start.spring.io/#!type=maven-project\u0026language=java\u0026platformVersion=3.4.1\u0026packaging=jar\u0026jvmVersion=21\u0026groupId=com.example\u0026artifactId=demo\u0026name=demo\u0026description=Demo%20project%20for%20Spring%20Boot\u0026packageName=com.example.demo\u0026dependencies=web,data-jpa,h2 You’ll be directed to the Spring Initializr dashboard: Spring Initializr Click GENERATE to download the Spring Boot project. Extract the project in the directory where you cloned your GitHub repository. Then, open the project in your favorite IDE (such as IntelliJ IDEA) and edit the pom.xml file to include the following dependency: \u003cdependency\u003e \u003cgroupId\u003eorg.mockito\u003c/groupId\u003e \u003cartifactId\u003emockito-core\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e Add the following plugin in the same pom.xml file: \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cargLine\u003e-javaagent:${settings.localRepository}/org/mockito/mockito-core/5.14.2/mockito-core-5.14.2.jar\u003c/argLine\u003e \u003c/configuration\u003e \u003c/plugin\u003e The above changes need to be done in your pom.xml file to bring in the Mockito library, which enables you to use mocking in your unit tests. \u003cscope\u003etest\u003c/scope\u003e ensures that Mockito is only used during testing and not included in the final application build, as it’s not required while the application is run. If you want to explore the pom.xml file in its entirety or reference the source code of this tutorial, you can visit this GitHub repository. Implement a RESTful API for the product service When complete, the demo application will have two APIs: one that allows the user to create a product and one that will fetch the created products. Create a product entity class Begin by creating an entity class called product.java inside the com.example.demo package under the src directory. This entity class maps the product information to the underlying table definition: package com.example.demo; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; @Entity public class Product { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private double price; public Product(Long id, String name, double price) { this.id = id; this.name = name; this.price = price; } public Product() { } // Getters and setters public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } } The @Entity annotation indicates that this is an entity class and is referring to a database table. The @Id annotation indicates the primary key of the product entity and @GeneratedValue holds the technique by which the values of the primary keys will be generated. Create a product repository class Next, create a product repository class called ProductRepository.java in the same com.example.demo package. You’ll need the repository class to store, manipulate, and retrieve the persisted product information from the underlying table. The @Repository Spring annotation helps you achieve this: package com.example.demo; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface ProductRepository extends JpaRepository\u003cProduct, Long\u003e {} Create a product controller class Create a ProductController.java class inside the same com.example.demo package. Below is the source code for the controller class file, which includes the @Autowired product repository class and calls the methods that create or fetch product information in their respective APIs: package com.example.demo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(\"/products\") public class ProductController { @Autowired private ProductRepository repository; @GetMapping public List\u003cProduct\u003e getAllProducts() { return repository.findAll(); } @PostMapping public Product createProduct(@RequestBody Product product) { return repository.save(product); } } That’s all for the core application logic. Create a test class The next step is to create a test class to test the API methods defined in the controller class. Create a test class named ProductControllerTest.java under the test directory and within the package com.example.demo. Paste in the following code, which contains the logic to test the product creation and retrieval methods: package com.example.demo; import com.fasterxml.jackson.databind.ObjectMapper; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.mockito.Mockito; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.MediaType; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.web.servlet.MockMvc; import java.util.Arrays; import java.util.List; import static org.mockito.ArgumentMatchers.any; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*; @WebMvcTest(ProductController.class) @ContextConfiguration(classes = {ProductController.class, ProductControllerTest.TestConfig.class}) class ProductControllerTest { @Autowired private MockMvc mockMvc; @Autowired private ProductRepository repository; @Autowired private ObjectMapper objectMapper; @BeforeEach void setUp() { Mockito.reset(repository); } @Test void getAllProducts_ShouldReturnProductList() throws Exception { // Arrange List\u003cProduct\u003e products = Arrays.asList( new Product(1L, \"Product1\", 100.0), new Product(2L, \"Product2\", 200.0) ); Mockito.when(repository.findAll()).thenReturn(products); // Act \u0026 Assert mockMvc.perform(get(\"/products\")) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.length()\").value(2)) .andExpect(jsonPath(\"$[0].name\").value(\"Product1\")) .andExpect(jsonPath(\"$[1].name\").value(\"Product2\")); } @Test void createProduct_ShouldReturnSavedProduct() throws Exception { // Arrange Product product = new Product(1L, \"NewProduct\", 150.0); Mockito.when(repository.save(any(Product.class))).thenReturn(product); // Act \u0026 Assert mockMvc.perform(post(\"/products\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(product))) .andExpect(status().isOk()) .andExpect(jsonPath(\"$.id\").value(1)) .andExpect(jsonPath(\"$.name\").value(\"NewProduct\")) .andExpect(jsonPath(\"$.price\").value(150.0)); } @Configuration static class TestConfig { @Bean public ProductRepository productRepository() { return Mockito.mock(ProductRepository.class); } } } Build the application Now that the application source code is ready, open a terminal and switch to the project directory containing the entire application code. Execute the following command to compile and build the application: mvnw clean install You should see an output similar to the following, indicating that the build has started and completed successfully: [INFO] Scanning for projects... [INFO] [INFO] --------------------------\u003c com.example:demo \u003e-------------------------- [INFO] Building demo 0.0.1-SNAPSHOT [INFO] from pom.xml [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- clean:3.4.0:clean (default-clean) @ demo — … … … [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 9.064 s [INFO] Finished at: 2025-01-05T10:57:04+05:30 [INFO] ------------------------------------------------------------------------ Test the APIs locally You can test the APIs locally using any of your favorite API testing tools. To test the product creation, make a POST request to the products endpoint at http://localhost:8080/products with the following request body: { \"name\": \"product-1\", \"price\": 14.20 } You should get this JSON response: { \"id\": 1, \"name\": \"product-1\", \"price\": 14.2 } You can make another similar POST request with the request body below to create another product: { \"name\": \"product-2\", \"price\": 20 } Next, test the product information retrieval API by making a GET request to the products endpoint at http://localhost:8080/products. You should see a response body with the details of the product information created earlier: [ { \"id\": 1, \"name\": \"product-1\", \"price\": 14.2 }, { \"id\": 2, \"name\": \"product-2\", \"price\": 20.0 } ] Push the project code to your GitHub repository To set up a CI/CD pipeline for your product microservice with TeamCity, you need to push your project source code into a version control repository like GitHub. Commit and push your changes to your GitHub repo by executing the following command from a terminal opened in the project directory: git add . git commit -am \"initial commit\" git push You’ve now tested your application locally and pushed the source code to GitHub. Create a project in TeamCity Let’s move on to integrating your application with TeamCity. First, ensure that both the TeamCity server and agent services are running. If you’re using Windows, you can execute the following command in a PowerShell terminal: Get-Service -Name \"TeamCity\" You should see this output: Status Name DisplayName ------ ---- ----------- Running TeamCity TeamCity Server Execute the following command: Get-Service -Name \"*BuildAgent*\" You should see this output: Status Name DisplayName ------ ---- ----------- Running TCBuildAgent TeamCity Build Agent Then, open a browser and access http://localhost:8111/. Log in to the TeamCity portal with the username and password that you specified when installing TeamCity: TeamCity login page Once you’re logged in, click Create project… to create a new project in TeamCity: Create Project form Once the TeamCity server is able to connect with your GitHub repository, you should see a screen indicating the connection to the repository has been verified: Connection verified message Leave the details as is and click Proceed. Configure build steps After clicking Proceed, you’ll be redirected to a screen where TeamCity will automatically detect certain build steps based on your project files: Auto-detected build steps Select the Docker and Maven build steps as shown below and click Use selected: Use selected build steps The selected build steps will be added and displayed on the next screen: Build steps Click Edit on the “Maven” build step to view its details. Here, you can enter “Build application using Maven” (or anything else you like) as the step name. Leave all other settings as their default values and click Save: Maven build step You should see a message indicating that your build step was successfully updated: Success message for edited Maven build step Next, click Edit for the “Docker” build step. Enter a custom step name (something like “Build Docker Image”) and fill in the Image name:tag field to build the Docker image with the given name and tag. Leave the other default values as they are and click Save: Docker build step You should see a message indicating that your build step was successfully updated: Success message for edited Docker build step Click the drop-down menu to the right of the second build step and select Copy build step… to duplicate the step: Copy build step On the form that appears, accept the default values shown by clicking Copy: Pop-up form You should see a message confirming your action was successful: Success message for copied build step Next, edit the newly copied step. Enter a new step name (something like “Push Docker Image”), then select push as the Docker command option to indicate that the image has to be pushed using the docker push command: Push Docker Image step After clicking Save, you should see a message indicating that your edit was successful: Success message for edited build step Next, copy the “Push Docker Image” step by repeating the instructions from earlier: Success message for copied build step Click Edit next to the newly created step. Enter something like “Deploy Docker Image and Run the App” as the step name, then select other as the Docker command option and enter run in the Command name field. For additional arguments for the command, enter --name demo-app -p 8080:8080 -d \u003cyour_docker_repository_name\u003e/\u003cyour_image_name\u003e:\u003cyour_tag_name\u003e. Deployment step The deployment step defined above will pull the Docker image from the Docker Hub registry to the target machine (your local machine, in this case) and start the application container. After you click Save, you should get confirmation that your last edit action was successful. Now, click the project name displayed at the top to go to the project details screen: Click project name Click Connections on the left: Project details screen Click Add Connection to define a new connection with the details pertaining to your Docker Hub account: Add connection This is a required step to enable the build pipeline to perform Docker-oriented actions that you configured as part of earlier build steps. On the form that appears, select Docker Registry as the connection type, then enter your Docker Hub account credentials: Docker registry credentials Click Save. You should get confirmation that the connection was successfully created. Next, click Go to project page in the top-right hand side of the screen to navigate back to the project page: Go to project page Click Build: Project page Click Edit configuration… at the top: Edit build configuration Click Build Features in the left menu: Click Build Features Click Add build feature: Add build feature Select Docker Support as the build feature, then click Add registry connection: Link registry connection with Docker Support feature Choose the configured Docker Registry connection from the drop-down menu, then click Add to link the registry connection. This informs the pipeline that it has to use the Docker Support feature and the linked registry connection as part of the relevant Docker steps. Add registry connection Finally, click Save to save the added Docker Support build feature: Save Docker Support feature You’ll get a message confirming that the build feature has been added successfully. By default, TeamCity adds another build feature to carry out performance monitoring when the build is executed. As part of this feature, performance statistics (such as CPU, disk, and memory utilization) will be tracked and registered during the build runs. Run the build Everything is now set up, and you can click Run to run the build: Run the build Once the build is completed, you’ll see a screen indicating that the build run was successful. Click Show full log to view the build run log information: Successful build run This is handy for troubleshooting any build failures. You can also click the PerfMon tab to view the performance statistics collected during the build run: Performance statistics In addition to resource utilization statistics, the screen will also show you the elapsed time for each build stage. You can see which of the build stages took the most time to execute and make the necessary adjustments to address the performance issue. You should also see that the published Docker image is now available in the Docker Hub registry: Published Docker image in Docker Hub You can now test the application to ensure the Docker container started via the automated build and deployment pipeline process works as expected. For testing, follow the same steps as before when you tested the APIs locally. Final thoughts In this tutorial, you explored how to build and deploy microservices using Spring Boot and TeamCity. You learned how to create a simple Spring Boot application, implement microservices, and integrate them with a CI/CD pipeline to streamline the deployment process.  By adopting a microservices architecture and leveraging robust tools for automation, you can accelerate development cycles, enhance reliability, and achieve seamless scalability for your applications. These principles and practices are essential for modern software development in enterprise and cloud-native environments. TeamCity helps simplify and enhance CI/CD workflows for microservices. With features like build automation, support for distributed builds, and seamless integration capabilities, TeamCity enables teams to manage complex pipelines with ease. Its scalability ensures it can handle growing workloads, while its robust ecosystem of plugins supports diverse use cases.  If you’re ready to elevate your CI/CD processes, try TeamCity for free and experience its capabilities firsthand. Get started today and unlock the potential of faster, more reliable software delivery. Subscribe to TeamCity Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/spring-boot-microservices-teamcity-featured-social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/teamcity/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/TeamCity-2.svg\" alt=\"Teamcity logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003ePowerful CI/CD for DevOps-centric teams\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/teamcity/category/how-tos/\"\u003eHow-To\u0026#39;s\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/teamcity/category/java/\"\u003eJava\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/teamcity/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eBuilding and Deploying Microservices With Spring Boot and TeamCity\u003c/h2\u003e                    \n                    \n\u003cp\u003e\u003cem\u003eThis tutorial was brought to you by Rajkumar Venkatasamy, draft.dev.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eMicroservice architecture has become a cornerstone for building scalable and maintainable applications. Microservices allow individual services to be developed, deployed, and scaled independently, resulting in faster delivery cycles and improved fault isolation. \u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, an e-commerce platform can use independent services to handle product catalogs, user authentication, and order management. By breaking large applications into smaller, independent services, organizations can address challenges such as long development cycles, difficulty in scaling specific components, and the risk of a single failure affecting the entire application.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn enterprise applications, microservices make it easier to quickly update and scale specific parts of the system. This allows teams to improve features without affecting the entire application. Automated testing and deployment of service components increase reliability, catching potential issues early and maintaining system stability. \u003c/p\u003e\n\n\n\n\n\n\u003cp\u003eMicroservices also streamline the DevOps workflow, allowing for faster time-to-market by reducing the complexity of deployments and leveraging continuous integration and continuous deployment (CI/CD) pipelines. These pipelines play a critical role in managing the lifecycle of microservices from development to deployment, ensuring consistent and efficient delivery processes.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this tutorial, you’ll learn how to create a microservice using Spring Boot, set up a CI/CD pipeline with JetBrains TeamCity, and automate deployment using Docker.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eMicroservice overview and prerequisites\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eImagine you’re developing an inventory management system where each microservice handles a specific function, such as managing products, orders, or customers. In this tutorial, you’ll build a “Product Service” microservice that provides RESTful APIs to create and list products.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1047\" height=\"705\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/microservices-scheme-1.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eArchitecture diagram\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou’ll need the following to complete this tutorial:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eExposure to Java programming and \u003ca href=\"https://docs.aws.amazon.com/corretto/latest/corretto-21-ug/downloads-list.html\" target=\"_blank\" rel=\"noopener\"\u003eJDK 21\u003c/a\u003e or higher.\u003c/li\u003e\n\n\n\n\u003cli\u003eFamiliarity with Spring Boot, particularly using \u003ca href=\"https://start.spring.io/\" target=\"_blank\" rel=\"noopener\"\u003eSpring Initializr\u003c/a\u003e for generating and working with Spring Boot projects.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jetbrains.com/teamcity/download/?shownFormKey=professional#section=server\" target=\"_blank\" rel=\"noopener\"\u003eTeamCity\u003c/a\u003e. This tutorial uses the on-premises version of TeamCity running on a Windows machine as a Windows service. However, you can use whichever TeamCity version you prefer.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\"\u003eGit\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eA \u003ca href=\"https://github.com/signup\" target=\"_blank\" rel=\"noopener\"\u003eGitHub account\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.docker.com/products/docker-desktop/\" target=\"_blank\" rel=\"noopener\"\u003eDocker Desktop\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDocker Hub account\u003c/a\u003e and a \u003ca href=\"https://docs.docker.com/docker-hub/repos/create/\" target=\"_blank\" rel=\"noopener\"\u003erepository\u003c/a\u003e to pull or push the Docker image you’ll build as part of this tutorial.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eSet up a new GitHub repo\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eCreate an empty repository on GitHub and clone it to your local machine using this command:\u003c/p\u003e\n\n\n\n\u003cpre\u003egit clone \u0026lt;your GitHub repository path\u0026gt;\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou’ll use this GitHub repository later while setting up the build pipeline in TeamCity.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eGenerate a Java Spring Boot project\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eOpen a browser and paste the following preconfigured URL to load the Spring Boot project in the browser:\u003c/p\u003e\n\n\n\n\u003cpre\u003ehttps://start.spring.io/#!type=maven-project\u0026amp;language=java\u0026amp;platformVersion=3.4.1\u0026amp;packaging=jar\u0026amp;jvmVersion=21\u0026amp;groupId=com.example\u0026amp;artifactId=demo\u0026amp;name=demo\u0026amp;description=Demo%20project%20for%20Spring%20Boot\u0026amp;packageName=com.example.demo\u0026amp;dependencies=web,data-jpa,h2\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou’ll be directed to the Spring Initializr dashboard:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1792\" height=\"965\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Spring-Initializr.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSpring Initializr\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eGENERATE\u003c/em\u003e to download the Spring Boot project. Extract the project in the directory where you cloned your GitHub repository. Then, open the project in your favorite IDE (such as IntelliJ IDEA) and edit the \u003ccode\u003epom.xml\u003c/code\u003e file to include the following dependency:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u0026lt;dependency\u0026gt;\n   \u0026lt;groupId\u0026gt;org.mockito\u0026lt;/groupId\u0026gt;\n   \u0026lt;artifactId\u0026gt;mockito-core\u0026lt;/artifactId\u0026gt;\n   \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\n\u0026lt;/dependency\u0026gt;\u003c/pre\u003e\n\n\n\n\u003cp\u003eAdd the following plugin in the same \u003ccode\u003epom.xml \u003c/code\u003efile:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u0026lt;plugin\u0026gt;\n   \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n   \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt;\n   \u0026lt;configuration\u0026gt;\n      \u0026lt;argLine\u0026gt;-javaagent:${settings.localRepository}/org/mockito/mockito-core/5.14.2/mockito-core-5.14.2.jar\u0026lt;/argLine\u0026gt;\n   \u0026lt;/configuration\u0026gt;\n\u0026lt;/plugin\u0026gt;\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe above changes need to be done in your \u003ccode\u003epom.xml\u003c/code\u003e file to bring in the \u003ca href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noopener\"\u003eMockito\u003c/a\u003e library, which enables you to use mocking in your unit tests. \u003ccode\u003e\u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt;\u003c/code\u003e ensures that Mockito is only used during testing and not included in the final application build, as it’s not required while the application is run.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you want to explore the \u003ccode\u003epom.xml\u003c/code\u003e file in its entirety or reference the source code of this tutorial, you can visit \u003ca href=\"https://github.com/rajkumarvenkatasamy/demo-spring-microservice-with-teamcity.git\" target=\"_blank\" rel=\"noopener\"\u003ethis GitHub repository\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eImplement a RESTful API for the product service\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen complete, the demo application will have two APIs: one that allows the user to create a product and one that will fetch the created products.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreate a product entity class\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eBegin by creating an entity class called \u003ccode\u003eproduct.java\u003c/code\u003e inside the \u003ccode\u003ecom.example.demo\u003c/code\u003e package under the \u003ccode\u003esrc\u003c/code\u003e directory. This entity class maps the product information to the underlying table definition:\u003c/p\u003e\n\n\n\n\u003cpre\u003epackage com.example.demo;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\n\n@Entity\npublic class Product {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    private double price;\n\n    public Product(Long id, String name, double price) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n    }\n\n    public Product() {\n    }\n\n    // Getters and setters\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(double price) {\n        this.price = price;\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e@Entity\u003c/code\u003e annotation indicates that this is an entity class and is referring to a database table. The \u003ccode\u003e@Id\u003c/code\u003e annotation indicates the primary key of the product entity and \u003ccode\u003e@GeneratedValue\u003c/code\u003e holds the technique by which the values of the primary keys will be generated.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreate a product repository class\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eNext, create a product repository class called \u003ccode\u003eProductRepository.java\u003c/code\u003e in the same \u003ccode\u003ecom.example.demo\u003c/code\u003e package. You’ll need the repository class to store, manipulate, and retrieve the persisted product information from the underlying table. The \u003ccode\u003e@Repository\u003c/code\u003e Spring annotation helps you achieve this:\u003c/p\u003e\n\n\n\n\u003cpre\u003epackage com.example.demo;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface ProductRepository extends JpaRepository\u0026lt;Product, Long\u0026gt; {}\u003c/pre\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreate a product controller class\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eCreate a \u003ccode\u003eProductController.java\u003c/code\u003e class inside the same \u003ccode\u003ecom.example.demo\u003c/code\u003e package. Below is the source code for the controller class file, which includes the \u003ccode\u003e@Autowired\u003c/code\u003e product repository class and calls the methods that create or fetch product information in their respective APIs:\u003c/p\u003e\n\n\n\n\u003cpre\u003epackage com.example.demo;\n\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n@RestController\n@RequestMapping(\u0026#34;/products\u0026#34;)\npublic class ProductController {\n    @Autowired\n    private ProductRepository repository;\n\n    @GetMapping\n    public List\u0026lt;Product\u0026gt; getAllProducts() {\n        return repository.findAll();\n    }\n\n    @PostMapping\n    public Product createProduct(@RequestBody Product product) {\n        return repository.save(product);\n    }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThat’s all for the core application logic.\u003c/p\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eCreate a test class\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe next step is to create a test class to test the API methods defined in the controller class.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a test class named \u003ccode\u003eProductControllerTest.java\u003c/code\u003e under the \u003ccode\u003etest\u003c/code\u003e directory and within the package \u003ccode\u003ecom.example.demo\u003c/code\u003e. Paste in the following code, which contains the logic to test the product creation and retrieval methods:\u003c/p\u003e\n\n\n\n\u003cpre\u003epackage com.example.demo;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;\n\n@WebMvcTest(ProductController.class)\n@ContextConfiguration(classes = {ProductController.class, ProductControllerTest.TestConfig.class})\nclass ProductControllerTest {\n\n        @Autowired\n        private MockMvc mockMvc;\n\n        @Autowired\n        private ProductRepository repository;\n\n        @Autowired\n        private ObjectMapper objectMapper;\n\n        @BeforeEach\n        void setUp() {\n                Mockito.reset(repository);\n        }\n\n        @Test\n        void getAllProducts_ShouldReturnProductList() throws Exception {\n                // Arrange\n                List\u0026lt;Product\u0026gt; products = Arrays.asList(\n                        new Product(1L, \u0026#34;Product1\u0026#34;, 100.0),\n                        new Product(2L, \u0026#34;Product2\u0026#34;, 200.0)\n                );\n                Mockito.when(repository.findAll()).thenReturn(products);\n\n                // Act \u0026amp; Assert\n                mockMvc.perform(get(\u0026#34;/products\u0026#34;))\n                        .andExpect(status().isOk())\n                        .andExpect(jsonPath(\u0026#34;$.length()\u0026#34;).value(2))\n                        .andExpect(jsonPath(\u0026#34;$[0].name\u0026#34;).value(\u0026#34;Product1\u0026#34;))\n                        .andExpect(jsonPath(\u0026#34;$[1].name\u0026#34;).value(\u0026#34;Product2\u0026#34;));\n        }\n\n        @Test\n        void createProduct_ShouldReturnSavedProduct() throws Exception {\n                // Arrange\n                Product product = new Product(1L, \u0026#34;NewProduct\u0026#34;, 150.0);\n                Mockito.when(repository.save(any(Product.class))).thenReturn(product);\n\n                // Act \u0026amp; Assert\n                mockMvc.perform(post(\u0026#34;/products\u0026#34;)\n                                .contentType(MediaType.APPLICATION_JSON)\n                                .content(objectMapper.writeValueAsString(product)))\n                        .andExpect(status().isOk())\n                        .andExpect(jsonPath(\u0026#34;$.id\u0026#34;).value(1))\n                        .andExpect(jsonPath(\u0026#34;$.name\u0026#34;).value(\u0026#34;NewProduct\u0026#34;))\n                        .andExpect(jsonPath(\u0026#34;$.price\u0026#34;).value(150.0));\n        }\n\n        @Configuration\n        static class TestConfig {\n                @Bean\n                public ProductRepository productRepository() {\n                        return Mockito.mock(ProductRepository.class);\n                }\n        }\n}\u003c/pre\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eBuild the application\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that the application source code is ready, open a terminal and switch to the project directory containing the entire application code. Execute the following command to compile and build the application:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003emvnw clean install\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eYou should see an output similar to the following, indicating that the build has started and completed successfully:\u003c/p\u003e\n\n\n\n\u003cpre\u003e[INFO] Scanning for projects...\n[INFO] \n[INFO] --------------------------\u0026lt; com.example:demo \u0026gt;--------------------------\n[INFO] Building demo 0.0.1-SNAPSHOT\n[INFO]   from pom.xml\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO] \n[INFO] --- clean:3.4.0:clean (default-clean) @ demo —\n\n…\n…\n…\n\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time:  9.064 s\n[INFO] Finished at: 2025-01-05T10:57:04+05:30\n[INFO] ------------------------------------------------------------------------\u003c/pre\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eTest the APIs locally\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou can test the APIs locally using any of your favorite API testing tools. To test the product creation, make a \u003ccode\u003ePOST\u003c/code\u003e request to the \u003ccode\u003eproducts\u003c/code\u003e endpoint at \u003ccode\u003ehttp://localhost:8080/products\u003c/code\u003e with the following request body:\u003c/p\u003e\n\n\n\n\u003cpre\u003e{\n    \u0026#34;name\u0026#34;: \u0026#34;product-1\u0026#34;,\n    \u0026#34;price\u0026#34;: 14.20\n}\n\nYou should get this JSON response:\n{\n    \u0026#34;id\u0026#34;: 1,\n    \u0026#34;name\u0026#34;: \u0026#34;product-1\u0026#34;,\n    \u0026#34;price\u0026#34;: 14.2\n}\n\nYou can make another similar POST request with the request body below to create another product:\n{\n    \u0026#34;name\u0026#34;: \u0026#34;product-2\u0026#34;,\n    \u0026#34;price\u0026#34;: 20\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, test the product information retrieval API by making a \u003ccode\u003eGET\u003c/code\u003e request to the \u003ccode\u003eproducts\u003c/code\u003e endpoint at \u003ccode\u003ehttp://localhost:8080/products\u003c/code\u003e. You should see a response body with the details of the product information created earlier:\u003c/p\u003e\n\n\n\n\u003cpre\u003e[\n    {\n        \u0026#34;id\u0026#34;: 1,\n        \u0026#34;name\u0026#34;: \u0026#34;product-1\u0026#34;,\n        \u0026#34;price\u0026#34;: 14.2\n    },\n    {\n        \u0026#34;id\u0026#34;: 2,\n        \u0026#34;name\u0026#34;: \u0026#34;product-2\u0026#34;,\n        \u0026#34;price\u0026#34;: 20.0\n    }\n]\u003c/pre\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003ePush the project code to your GitHub repository\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo set up a CI/CD pipeline for your product microservice with TeamCity, you need to push your project source code into a version control repository like \u003ca href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\"\u003eGitHub\u003c/a\u003e. Commit and push your changes to your GitHub repo by executing the following command from a terminal opened in the project directory:\u003c/p\u003e\n\n\n\n\u003cpre\u003egit add .\ngit commit -am \u0026#34;initial commit\u0026#34;\ngit push\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou’ve now tested your application locally and pushed the source code to GitHub.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eCreate a project in TeamCity\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s move on to integrating your application with TeamCity.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, ensure that both the TeamCity server and agent services are running. If you’re using Windows, you can execute the following command in a PowerShell terminal:\u003c/p\u003e\n\n\n\n\u003cpre\u003eGet-Service -Name \u0026#34;TeamCity\u0026#34;\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou should see this output:\u003c/p\u003e\n\n\n\n\u003cpre\u003eStatus   Name               DisplayName\n------   ----               -----------\nRunning  TeamCity           TeamCity Server\u003c/pre\u003e\n\n\n\n\u003cp\u003eExecute the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003eGet-Service -Name \u0026#34;*BuildAgent*\u0026#34;\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou should see this output:\u003c/p\u003e\n\n\n\n\u003cpre\u003eStatus   Name               DisplayName\n------   ----               -----------\nRunning  TCBuildAgent       TeamCity Build Agent\u003c/pre\u003e\n\n\n\n\u003cp\u003eThen, open a browser and access \u003ca href=\"http://localhost:8111/\" target=\"_blank\" rel=\"noopener\"\u003ehttp://localhost:8111/\u003c/a\u003e. Log in to the TeamCity portal with the username and password that you specified when installing TeamCity:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1462\" height=\"712\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/log-in-to-teamcity.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eTeamCity login page\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce you’re logged in, click \u003cem\u003eCreate project…\u003c/em\u003e to create a new project in TeamCity:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1920\" height=\"975\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/teamcity-dashboard.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eCreate Project form\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the TeamCity server is able to connect with your GitHub repository, you should see a screen indicating the connection to the repository has been verified:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1447\" height=\"637\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Connection-verified-message.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eConnection verified message\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLeave the details as is and click \u003cem\u003eProceed\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eConfigure build steps\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eAfter clicking \u003cem\u003eProceed\u003c/em\u003e, you’ll be redirected to a screen where TeamCity will automatically detect certain build steps based on your project files:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1895\" height=\"651\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Auto-detected-build-steps.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eAuto-detected build steps\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSelect the \u003cem\u003eDocker\u003c/em\u003e and \u003cem\u003eMaven\u003c/em\u003e build steps as shown below and click \u003cem\u003eUse selected\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"987\" height=\"355\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Use-selected-build-steps.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eUse selected build steps\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe selected build steps will be added and displayed on the next screen:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1826\" height=\"675\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Build-steps.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eBuild steps\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eEdit\u003c/em\u003e on the “Maven” build step to view its details. Here, you can enter “Build application using Maven” (or anything else you like) as the step name. Leave all other settings as their default values and click \u003cem\u003eSave\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1817\" height=\"916\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Maven-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eMaven build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou should see a message indicating that your build step was successfully updated:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1821\" height=\"637\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Success-message-for-edited-Maven-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccess message for edited Maven build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNext, click \u003cem\u003eEdit\u003c/em\u003e for the “Docker” build step. Enter a custom step name (something like “Build Docker Image”) and fill in the \u003cem\u003eImage name:tag\u003c/em\u003e field to build the Docker image with the given name and tag. Leave the other default values as they are and click \u003cem\u003eSave\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1812\" height=\"915\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Docker-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eDocker build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou should see a message indicating that your build step was successfully updated:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1536\" height=\"487\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Success-message-for-edited-Docker-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccess message for edited Docker build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick the drop-down menu to the right of the second build step and select \u003cem\u003eCopy build step…\u003c/em\u003e to duplicate the step:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1532\" height=\"485\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Copy-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eCopy build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOn the form that appears, accept the default values shown by clicking \u003cem\u003eCopy\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"662\" height=\"212\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Pop-up-form.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003ePop-up form\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou should see a message confirming your action was successful:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1532\" height=\"536\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Success-message-for-copied-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccess message for copied build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNext, edit the newly copied step. Enter a new step name (something like “Push Docker Image”), then select \u003cem\u003epush\u003c/em\u003e as the \u003cem\u003eDocker command\u003c/em\u003e option to indicate that the image has to be pushed using the \u003ccode\u003edocker push\u003c/code\u003e command:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1496\" height=\"742\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Push-Docker-Image-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003ePush Docker Image step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAfter clicking \u003cem\u003eSave\u003c/em\u003e, you should see a message indicating that your edit was successful:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1530\" height=\"537\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Success-message-for-edited-build-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccess message for edited build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNext, copy the “Push Docker Image” step by repeating the instructions from earlier:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1520\" height=\"615\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Success-message-for-copied-build-step_1.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccess message for copied build step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eEdit\u003c/em\u003e next to the newly created step. Enter something like “Deploy Docker Image and Run the App” as the step name, then select \u003cem\u003eother\u003c/em\u003e as the \u003cem\u003eDocker command\u003c/em\u003e option and enter \u003ccode\u003erun\u003c/code\u003e in the \u003cem\u003eCommand name\u003c/em\u003e field. For additional arguments for the command, enter \u003ccode\u003e--name demo-app -p 8080:8080 -d \u0026lt;your_docker_repository_name\u0026gt;/\u0026lt;your_image_name\u0026gt;:\u0026lt;your_tag_name\u0026gt;.\u003c/code\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1496\" height=\"742\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Deployment-step.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eDeployment step\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe deployment step defined above will pull the Docker image from the Docker Hub registry to the target machine (your local machine, in this case) and start the application container.\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter you click \u003cem\u003eSave\u003c/em\u003e, you should get confirmation that your last edit action was successful.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, click the project name displayed at the top to go to the project details screen:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1822\" height=\"702\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Click-project-name.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eClick project name\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick\u003cstrong\u003e\u003cem\u003e \u003c/em\u003e\u003c/strong\u003e\u003cem\u003eConnections\u003c/em\u003e on the left:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1526\" height=\"525\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Project-details-screen.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eProject details screen\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eAdd Connection\u003c/em\u003e to define a new connection with the details pertaining to your Docker Hub account:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1217\" height=\"377\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Add-connection.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eAdd connection\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis is a required step to enable the build pipeline to perform Docker-oriented actions that you configured as part of earlier build steps.\u003c/p\u003e\n\n\n\n\u003cp\u003eOn the form that appears, select \u003cem\u003eDocker Registry\u003c/em\u003e as the connection type, then enter your Docker Hub account credentials:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"706\" height=\"461\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Docker-registry-credentials.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eDocker registry credentials\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eSave\u003c/em\u003e. You should get confirmation that the connection was successfully created.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, click \u003cem\u003eGo to project page\u003c/em\u003e in the top-right hand side of the screen to navigate back to the project page:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1822\" height=\"318\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Go-to-project-pag.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eGo to project page\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eBuild\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1437\" height=\"341\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Project-page.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eProject page\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eEdit configuration…\u003c/em\u003e at the top:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1440\" height=\"305\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Edit-build-configuration.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eEdit build configuration\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eBuild Features\u003c/em\u003e in the left menu:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1815\" height=\"357\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Click-Build-Features.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eClick Build Features\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eAdd build feature\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1536\" height=\"251\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Add-build-feature.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eAdd build feature\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSelect \u003cem\u003eDocker Support\u003c/em\u003e as the build feature, then click \u003cem\u003eAdd registry connection\u003c/em\u003e:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"947\" height=\"393\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Link-registry-connection-with-Docker-Support-feature.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eLink registry connection with Docker Support feature\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eChoose the configured Docker Registry connection from the drop-down menu, then click \u003cem\u003eAdd\u003c/em\u003e to link the registry connection. This informs the pipeline that it has to use the Docker Support feature and the linked registry connection as part of the relevant Docker steps.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"657\" height=\"226\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Add-registry-connection.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eAdd registry connection\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFinally, click \u003cem\u003eSave\u003c/em\u003e to save the added Docker Support build feature:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"936\" height=\"472\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Save-Docker-Support-feature.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSave Docker Support feature\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou’ll get a message confirming that the build feature has been added successfully. By default, TeamCity adds another build feature to carry out performance monitoring when the build is executed. As part of this feature, performance statistics (such as CPU, disk, and memory utilization) will be tracked and registered during the build runs.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eRun the build\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eEverything is now set up, and you can click \u003cem\u003eRun\u003c/em\u003e to run the build:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1536\" height=\"442\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Run-the-build.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eRun the build\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the build is completed, you’ll see a screen indicating that the build run was successful.\u003c/p\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eShow full log\u003c/em\u003e to view the build run log information:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1447\" height=\"485\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Successful-build-run.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003eSuccessful build run\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis is handy for troubleshooting any build failures. You can also click the \u003cem\u003ePerfMon\u003c/em\u003e tab to view the performance statistics collected during the build run:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1433\" height=\"707\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Performance-statistics.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003ePerformance statistics\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn addition to resource utilization statistics, the screen will also show you the elapsed time for each build stage. You can see which of the build stages took the most time to execute and make the necessary adjustments to address the performance issue.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou should also see that the published Docker image is now available in the Docker Hub registry:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1893\" height=\"585\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/Published-Docker-image-in-Docker-Hub.png\" alt=\"\"/\u003e\u003cfigcaption\u003e\u003cem\u003ePublished Docker image in Docker Hub\u003c/em\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can now test the application to ensure the Docker container started via the automated build and deployment pipeline process works as expected. For testing, follow the same steps as before when you tested the APIs locally.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eFinal thoughts\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn this tutorial, you explored how to build and deploy microservices using Spring Boot and TeamCity. You learned how to create a simple Spring Boot application, implement microservices, and integrate them with a CI/CD pipeline to streamline the deployment process. \u003c/p\u003e\n\n\n\n\u003cp\u003eBy adopting a microservices architecture and leveraging robust tools for automation, you can accelerate development cycles, enhance reliability, and achieve seamless scalability for your applications. These principles and practices are essential for modern software development in enterprise and cloud-native environments.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://www.jetbrains.com/teamcity/\" target=\"_blank\" rel=\"noopener\"\u003eTeamCity\u003c/a\u003e helps simplify and enhance CI/CD workflows for microservices. With features like build automation, support for distributed builds, and seamless integration capabilities, TeamCity enables teams to manage complex pipelines with ease. Its scalability ensures it can handle growing workloads, while its robust ecosystem of plugins supports diverse use cases. \u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’re ready to elevate your CI/CD processes, \u003ca href=\"https://www.jetbrains.com/teamcity/download/\" target=\"_blank\" rel=\"noopener\"\u003etry TeamCity for free\u003c/a\u003e and experience its capabilities firsthand. Get started today and unlock the potential of faster, more reliable software delivery.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to TeamCity Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": null,
  "modifiedTime": null
}
