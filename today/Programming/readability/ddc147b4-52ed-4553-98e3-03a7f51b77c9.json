{
  "id": "ddc147b4-52ed-4553-98e3-03a7f51b77c9",
  "title": "Resisting the Urge to Document Everything Everywhere",
  "link": "https://blog.jooq.org/resisting-the-urge-to-document-everything-everywhere/",
  "description": "Every product manager knows this situation: This is such a common pattern, and while it’s perfectly understandable for such a user to request this, it is so terribly wrong to give in to this user’s request. Why is it wrong? The features are unrelated Most of the time, the two features X1 and X2 are … Continue reading Resisting the Urge to Document Everything Everywhere →",
  "author": "lukaseder",
  "published": "Fri, 28 Feb 2025 10:39:07 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-development",
    "caveat",
    "documentation",
    "jooq",
    "Q\u0026A",
    "quirk",
    "Stack Overflow",
    "xyproblem"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 7451,
  "excerpt": "Users are often inclined to suggest documenting workarounds for quirks using unrelated features on the features themselves, and why I think this is wrong.",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "Every product manager knows this situation: A user works with feature X1. They find a limitation / bug / quirk and want to work around it. The perfect workaround or alternative is feature X2, but without knowing that X2 exists, the user doesn’t find it and spends a lot of time looking for it. The user requests X2 be documented on X1, because that would have saved them a ton of time. This is such a common pattern, and while it’s perfectly understandable for such a user to request this, it is so terribly wrong to give in to this user’s request. Why is it wrong? The features are unrelated Most of the time, the two features X1 and X2 are unrelated and just “happen” to be connected in this specific user’s situation. Let’s take jOOQ, for example. Imagine you work with the SUM(X) aggregate function. For historic reasons, this function (like many other arithmetic functions) returns BigDecimal in jOOQ, so it won’t overflow, irrespective of the input type. The signature of the function is: public static AggregateFunction\u003cBigDecimal\u003e sum( Field\u003c? extends Number\u003e field ) { ... } This may or may not be a good thing. After all, people are used to generics in jOOQ’s API, so they may have preferred this signature instead (which risks overflowing for types like TINYINT / Byte): public static \u003cT extends Number\u003e AggregateFunction\u003cT\u003e sum( Field\u003cT\u003e field ) { ... } So, feature X1 is SUM(X). The “quirk” is that it may return an unexpected type. (The quirk is controversial. The relevant issue to address this isn’t very popular, so it may just as well be fine). Now, for some users who prefer the alternative signature, feature X2 is the coerce() function, a jOOQ function that works like a SQL cast(), but does not impact generated SQL. It’s implemented entirely in the client. Though, cast() would also work here. For example, to get an Integer sum: // Instead of: Record1\u003cBigDecimal\u003e r1 = ctx .select(sum(TABLE.COLUMN)) .from(TABLE) .fetchOne(); // Get this (where SQLDataType.INTEGER is used): Record1\u003cInteger\u003e r2 = ctx .select(sum(TABLE.COLUMN).coerce(INTEGER)) .from(TABLE) .fetchOne(); coerce() is such a useful feature X2 in jOOQ, it’s probably worth knowing about it if you’re a jOOQ power user. It isn’t related to X1 (the SUM(X) aggregate function), although it helps work around a “problem” (or quirk / historic API design choice / etc.) that is specific to SUM(X) (and dozens of other arithmetic functions). The feature is unknown But the problem a user might have is this: Users have no problem finding SUM(X), the X1. Every supported SQL function has a corresponding jOOQ method in DSL, and jOOQ users are quickly trained to look there for anything they already know from SQL. Users do have a problem finding out how to coerce() or cast() a data type, first because 1) they may not know (or have forgotten, or are unable to connect) the concept, and 2) it’s simply not related to the user’s task at hand. So, a lot of time may be spent looking for a solution. Without knowing what the best solution is, alternatives may be explored. In the worst case, those alternatives also cause (unrelated!) issues, and the even more frustrating XY problem ensues. Even without the XY problem, a lot of time may be wasted looking for the solution X2. The urge to document If the user eventually finds out about X2 (the coerce() function), they might request that X2 be documented on X1, because that would have really helped them. And there’s no doubt that this kind of documentation would have helped this particular user. BUT! Most users who work with SUM(X) do not need to know anything about coerce(). They’re perfectly happy with BigDecimal, or alternatively, they may have found an entirely different approach to turning BigDecimal into Integer (e.g. BigDecimal::intValue) and they’re perfectly happy with their solution X3. If X2 was documented on X1, for most users, that would have just been noise. Perhaps it’s not terrible noise but: It’s a first bit of noise on X1 about an unrelated feature X2. The next user will find X2 to be insufficient for their problem and would want to have X3 documented as well. The next user will find an entirely different limitation in X1 and will want to have their workaround X4 documented as well (for example, the fact that SUM(X) returns NULL instead of the identity value 0 for empty input sets, a common SQL “quirk”). The next user will have a limitation on X5 and will want to have X1 and X6 documented there. The set of features X = {X1, X2, ..., Xn} is large, and if a product is designed well and has a lot of highly reusable components, like jOOQ, then in principle, almost every feature can interact with every other feature. This is already hard enough to test, but if every combination also has to be documented along with a list of quirks, caveats, gotchas, workarounds, etc. then we’ll never stop documenting things that 99% of users will never need to know and thus perceive as noise. As an extreme example: Imagine a user who has to pass a List\u003cT\u003e to method(List\u003cT\u003e). But they’re unaware of ArrayList. Not only do they request ArrayList be documented on method(), but also the fact that an ArrayList can be created using new. It’s totally unrelated noise! There would be so much noise that our user who wanted X2 (the coerce() function) to be documented on X1 (the SUM(X) aggregate function) wouldn’t even find this bit of information in the endless list of quirks. Needless to say that moving that particular quirk to the top of the list of quirk isn’t going to be the right solution to finding this bit of information. So, what is the best way to help this user? Personally, I like Stack Overflow. People perceive the moderation as harsh, but the big benefit of this moderation is that good questions are always very specific and thus useful for the next user who finds the question on Google. It’s perfectly fine to ask about the combination of X1 and X2 on Stack Overflow. While the features are unrelated, the combination does help this particular user. So if this user asks: I want to use X1, but I ran into this quirk. How can I work around it? Then I could answer: Use X2 as a workaround. Here’s how: [ … ] This is much much better than documentation on the Javadoc or in the manual: It doesn’t generate noise. 99% of jOOQ users aren’t concerned with this Q\u0026A, so they will never Google it, and thus never encounter this question. So, they’re happy. It’s highly specific. The 1% of jOOQ users who do have the same question will find this answer on Stack Overflow (or ChatGPT \u0026 co, which plagiarise Stack Overflow), so they’re happy as well. Conclusion Documenting quirks is a slippery slope. As a product grows and matures, it accumulates quirks. There are no exceptions to this. Documenting all of these quirks somewhere is important, because users who run into them will want answers. Documenting these quirks on the feature documentation itself isn’t the right choice, however, because most users won’t be concerned with the quirk. The list of documented quirks will quickly become overwhelming. A Q\u0026A of some form is usually the best approach, be it: A question on Stack Overflow An issue on an issue tracker with a related discussion about the quirk and all the possible workarounds",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12895\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eEvery product manager knows this situation:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA user works with feature \u003ccode\u003eX1\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eThey find a limitation / bug / quirk and want to work around it.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe perfect workaround or alternative is feature \u003ccode\u003eX2\u003c/code\u003e, but without knowing that \u003ccode\u003eX2\u003c/code\u003e exists, the user doesn’t find it and spends a lot of time looking for it.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe user requests \u003ccode\u003eX2\u003c/code\u003e be documented on \u003ccode\u003eX1\u003c/code\u003e, because that would have saved them a ton of time.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis is such a common pattern, and while it’s perfectly understandable for such a user to request this, it is so terribly wrong to give in to this user’s request. Why is it wrong?\u003c/p\u003e\n\n\n\n\u003ch3\u003eThe features are unrelated\u003c/h3\u003e\n\n\n\n\u003cp\u003eMost of the time, the two features \u003ccode\u003eX1\u003c/code\u003e and \u003ccode\u003eX2\u003c/code\u003e are unrelated and just “happen” to be connected in this specific user’s situation. Let’s take jOOQ, for example. Imagine you work with the \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/aggregate-functions/sum-function/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/aggregate-functions/sum-function/\"\u003eSUM(X)\u003c/a\u003e\u003c/code\u003e aggregate function. For historic reasons, this function (like many other arithmetic functions) returns \u003ccode\u003eBigDecimal\u003c/code\u003e in jOOQ, so it won’t overflow, irrespective of the input type. The signature of the function is:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003epublic static AggregateFunction\u0026lt;BigDecimal\u0026gt; sum(\n    Field\u0026lt;? extends Number\u0026gt; field\n) { ... }\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis may or may not be a good thing. After all, people are used to generics in jOOQ’s API, so they may have preferred this signature instead (which risks overflowing for types like \u003ccode\u003eTINYINT\u003c/code\u003e / \u003ccode\u003eByte\u003c/code\u003e):\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003epublic static \u0026lt;T extends Number\u0026gt; AggregateFunction\u0026lt;T\u0026gt; sum(\n    Field\u0026lt;T\u0026gt; field\n) { ... }\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSo, feature \u003ccode\u003eX1\u003c/code\u003e is \u003ccode\u003eSUM(X)\u003c/code\u003e. The “quirk” is that it may return an unexpected type. (The quirk is controversial. The relevant issue to address this isn’t very popular, so it may just as well be fine).\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, for some users who prefer the alternative signature, feature \u003ccode\u003eX2\u003c/code\u003e is the \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/datatype-coercions/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/datatype-coercions/\"\u003ecoerce()\u003c/a\u003e\u003c/code\u003e function, a jOOQ function that works like a SQL \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/cast-expressions/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/cast-expressions/\"\u003ecast()\u003c/a\u003e\u003c/code\u003e, but does not impact generated SQL. It’s implemented entirely in the client. Though, \u003ccode\u003ecast()\u003c/code\u003e would also work here.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, to get an \u003ccode\u003eInteger\u003c/code\u003e sum:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// Instead of:\nRecord1\u0026lt;BigDecimal\u0026gt; r1 = ctx\n    .select(sum(TABLE.COLUMN))\n    .from(TABLE)\n    .fetchOne();\n\n// Get this (where SQLDataType.INTEGER is used):\nRecord1\u0026lt;Integer\u0026gt; r2 = ctx\n    .select(sum(TABLE.COLUMN).coerce(INTEGER))\n    .from(TABLE)\n    .fetchOne();    \n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003e\u003ccode\u003ecoerce()\u003c/code\u003e is such a useful feature \u003ccode\u003eX2\u003c/code\u003e in jOOQ, it’s probably worth knowing about it if you’re a jOOQ power user. It isn’t related to \u003ccode\u003eX1\u003c/code\u003e (the \u003ccode\u003eSUM(X)\u003c/code\u003e aggregate function), although it helps work around a “problem” (or quirk / historic API design choice / etc.) that is specific to \u003ccode\u003eSUM(X)\u003c/code\u003e (and dozens of other arithmetic functions).\u003c/p\u003e\n\n\n\n\u003ch3\u003eThe feature is unknown\u003c/h3\u003e\n\n\n\n\u003cp\u003eBut the problem a user might have is this:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eUsers have no problem finding \u003ccode\u003eSUM(X)\u003c/code\u003e, the \u003ccode\u003eX1\u003c/code\u003e. Every supported SQL function has a corresponding jOOQ method in \u003ccode\u003e\u003ca href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/DSL.html\" data-type=\"link\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/DSL.html\"\u003eDSL\u003c/a\u003e\u003c/code\u003e, and jOOQ users are quickly trained to look there for anything they already know from SQL.\u003c/li\u003e\n\n\n\n\u003cli\u003eUsers do have a problem finding out how to \u003ccode\u003ecoerce()\u003c/code\u003e or \u003ccode\u003ecast()\u003c/code\u003e a data type, first because 1) they may not know (or have forgotten, or are unable to connect) the concept, and 2) it’s simply not related to the user’s task at hand.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSo, a lot of time may be spent looking for a solution. Without knowing what the best solution is, alternatives may be explored. In the worst case, those alternatives also cause (unrelated!) issues, and the even more frustrating \u003ca href=\"https://xyproblem.info\" data-type=\"link\" data-id=\"https://xyproblem.info\"\u003eXY problem\u003c/a\u003e ensues.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven without the XY problem, a lot of time may be wasted looking for the solution \u003ccode\u003eX2\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch3\u003eThe urge to document\u003c/h3\u003e\n\n\n\n\u003cp\u003eIf the user eventually finds out about \u003ccode\u003eX2\u003c/code\u003e  (the \u003ccode\u003ecoerce()\u003c/code\u003e function), they might request that \u003ccode\u003eX2\u003c/code\u003e be documented on \u003ccode\u003eX1\u003c/code\u003e, because that would have really helped them. And there’s no doubt that this kind of documentation would have helped this \u003cem\u003eparticular \u003c/em\u003euser.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBUT!\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eMost users who work with \u003ccode\u003eSUM(X)\u003c/code\u003e do not need to know anything about \u003ccode\u003ecoerce()\u003c/code\u003e. They’re perfectly happy with \u003ccode\u003eBigDecimal\u003c/code\u003e, or alternatively, they may have found an entirely different approach to turning \u003ccode\u003eBigDecimal\u003c/code\u003e into \u003ccode\u003eInteger\u003c/code\u003e (e.g. \u003ccode\u003eBigDecimal::intValue\u003c/code\u003e) and they’re perfectly happy with their solution \u003ccode\u003eX3\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf \u003ccode\u003eX2\u003c/code\u003e was documented on \u003ccode\u003eX1\u003c/code\u003e, for most users, that would have just been noise. Perhaps it’s not terrible noise but:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt’s a first bit of noise on \u003ccode\u003eX1\u003c/code\u003e about an unrelated feature \u003ccode\u003eX2\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe next user will find \u003ccode\u003eX2\u003c/code\u003e to be insufficient for their problem and would want to have \u003ccode\u003eX3\u003c/code\u003e documented as well.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe next user will find an entirely different limitation in \u003ccode\u003eX1\u003c/code\u003e and will want to have \u003cem\u003etheir\u003c/em\u003e workaround \u003ccode\u003eX4\u003c/code\u003e documented as well (for example, the fact that \u003ccode\u003eSUM(X)\u003c/code\u003e returns \u003ccode\u003eNULL\u003c/code\u003e instead of the identity value \u003ccode\u003e0\u003c/code\u003e for empty input sets, a common SQL “quirk”).\u003c/li\u003e\n\n\n\n\u003cli\u003eThe next user will have a limitation on \u003ccode\u003eX5\u003c/code\u003e and will want to have \u003ccode\u003eX1\u003c/code\u003e and \u003ccode\u003eX6\u003c/code\u003e documented there.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe set of features \u003ccode\u003eX = {X1, X2, ..., Xn}\u003c/code\u003e is large, and if a product is designed well and has a lot of highly reusable components, like jOOQ, then in principle, almost every feature can interact with every other feature.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is already hard enough to test, but if every combination also has to be documented along with a list of quirks, caveats, gotchas, workarounds, etc. then we’ll never stop documenting things that 99% of users will never need to know and thus perceive as noise.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs an extreme example: Imagine a user who has to pass a \u003ccode\u003eList\u0026lt;T\u0026gt;\u003c/code\u003e to \u003ccode\u003emethod(List\u0026lt;T\u0026gt;)\u003c/code\u003e. But they’re unaware of \u003ccode\u003eArrayList\u003c/code\u003e. Not only do they request \u003ccode\u003eArrayList\u003c/code\u003e be documented on \u003ccode\u003emethod()\u003c/code\u003e, but also the fact that an \u003ccode\u003eArrayList\u003c/code\u003e can be created using \u003ccode\u003enew\u003c/code\u003e. It’s totally unrelated noise!\u003c/p\u003e\n\n\n\n\u003cp\u003eThere would be so much noise that our user who wanted \u003ccode\u003eX2\u003c/code\u003e (the \u003ccode\u003ecoerce()\u003c/code\u003e function) to be documented on \u003ccode\u003eX1\u003c/code\u003e (the \u003ccode\u003eSUM(X)\u003c/code\u003e aggregate function) wouldn’t even find this bit of information in the endless list of quirks. Needless to say that moving that particular quirk to the top of the list of quirk isn’t going to be the right solution to finding this bit of information.\u003c/p\u003e\n\n\n\n\u003ch3\u003eSo, what is the best way to help this user?\u003c/h3\u003e\n\n\n\n\u003cp\u003ePersonally, I like \u003ca href=\"https://stackoverflow.com/questions/tagged/jooq\" data-type=\"link\" data-id=\"https://stackoverflow.com/questions/tagged/jooq\"\u003eStack Overflow\u003c/a\u003e. People perceive the moderation as harsh, but the big benefit of this moderation is that good questions are always \u003cem\u003every specific\u003c/em\u003e and thus useful for the next user who finds the question on Google. It’s perfectly fine to ask about the combination of \u003ccode\u003eX1\u003c/code\u003e and \u003ccode\u003eX2\u003c/code\u003e on Stack Overflow. While the features are unrelated, the combination does help this particular user. So if this user asks:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eI want to use \u003ccode\u003eX1\u003c/code\u003e, but I ran into this quirk. How can I work around it?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThen I could answer:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eUse \u003ccode\u003eX2\u003c/code\u003e as a workaround. Here’s how: [ … ]\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThis is much much better than documentation on the Javadoc or in the manual:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt doesn’t generate noise. 99% of jOOQ users aren’t concerned with this Q\u0026amp;A, so they will never Google it, and thus never encounter this question. So, they’re happy.\u003c/li\u003e\n\n\n\n\u003cli\u003eIt’s highly specific. The 1% of jOOQ users who do have the same question will find this answer on Stack Overflow (or ChatGPT \u0026amp; co, which plagiarise Stack Overflow), so they’re happy as well.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3\u003eConclusion\u003c/h3\u003e\n\n\n\n\u003cp\u003eDocumenting quirks is a slippery slope. As a product grows and matures, it accumulates quirks. There are no exceptions to this. Documenting all of these quirks \u003cem\u003esomewhere \u003c/em\u003eis important, because users who run into them will want answers.\u003c/p\u003e\n\n\n\n\u003cp\u003eDocumenting these quirks on the feature documentation itself isn’t the right choice, however, because most users won’t be concerned with the quirk. The list of documented quirks will quickly become overwhelming.\u003c/p\u003e\n\n\n\n\u003cp\u003eA Q\u0026amp;A of some form is usually the best approach, be it:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA question on Stack Overflow\u003c/li\u003e\n\n\n\n\u003cli\u003eAn issue on an issue tracker with a related discussion about the quirk and all the possible workarounds\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-02-28T10:39:07Z",
  "modifiedTime": "2025-02-28T10:39:07Z"
}
