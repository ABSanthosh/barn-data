{
  "id": "9c229734-9bba-44a0-9e25-15c3a0741299",
  "title": "To DAO or not to DAO",
  "link": "https://blog.jooq.org/to-dao-or-not-to-dao/",
  "description": "jOOQ’s DAO API is one of jOOQ’s most controversial features. When it was first implemented, it was implemented merely: There’s a strong hint about the third bullet given how popular Spring Data’s repository “pattern” is. A lot of developers just want to quickly fetch and store data, without giving individual queries much thought. A fun … Continue reading To DAO or not to DAO →",
  "author": "lukaseder",
  "published": "Wed, 06 Dec 2023 13:41:52 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-in-use",
    "dao",
    "jooq",
    "Repository"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 4659,
  "excerpt": "Most serious data centric applications will quickly find DAOs or repositories insufficient. This is when jOOQ really shines with all its SQL support.",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "jOOQ’s DAO API is one of jOOQ’s most controversial features. When it was first implemented, it was implemented merely: Because it was so easy to implement Because it seemed so useful for simple CRUD tasks Because that’s what many developers want There’s a strong hint about the third bullet given how popular Spring Data’s repository “pattern” is. A lot of developers just want to quickly fetch and store data, without giving individual queries much thought. A fun fact is that most people use Spring Data just for CRUD, despite that the framework has been created with a strong opinion about DDD and the entailing concepts, like aggregates, aggregate roots, etc. The jOOQ DAO was easy to implement because it consists simply of: A generic DAO API with a few common methods A generated class per table that implements the bindings to generated POJOs and some auxiliary query methods In other words, for every table (such as ACCOUNT) you’ll get a “free” Account POJO and a “free” AccountDao DAO, which you can use as follows: // DAOs are often injected in one way or another @Autowired AccountDao dao; // And then: dao.insert(new Account(1, \"name\")); Account account = dao.findById(1); Seems useful enough, no? Why not use SQL, instead? Just like Spring Data is mostly used for quick data access (rather than thorough DDD application), so are DAOs. And both approaches train users to usually favour the quick access over thinking about individual queries in terms of data sets. What a pity! How much code do you see that looks like this, as soon as you start using DAOs or repositories? for (Account account : accountDao.fetchByType(\"Some Type\") ) { for (Transaction transaction : transactionDao.fetchByTransactionId(account.getId() ) { doSomething(transaction); } } The dreaded N+1 problem manifests in the above code snippet, as we run a query fetching transactions for every account! Regrettably, it’s often not even as obvious as above, where two nested loops are located right at the same spot in your code. A lot of times, these loops are hidden inside of “reusable” methods, and called in loops without giving them much thought. When in fact, the following query wouldn’t be so much harder to write: for (Transaction transaction : ctx .selectFrom(TRANSACTION) .where(exists( selectOne() .from(TRANSACTION.account()) .where(TRANSACTION.account().TYPE.eq(\"Some Type\")) )) .fetchInto(Transaction.class) ) { doSomething(transaction); } Looks pretty clear, no? Note the above example is using a jOOQ 3.19 feature called implicit path correlation, where the correlated subquery can be expressed using an implicit join path TRANSACTION.account(), rather than adding a more verbose, but equivalent predicate of the form TRANSACTION.ACCOUNT_ID.eq(ACCOUNT.ID). Taking it one step further, it’s quite likely you can optimise the projection as well as you might not need all the columns from TRANSACTION. More optimisation with writes In fact, let’s look at doSomething(), which might also be using a DAO: void doSomething(Transaction transaction) { transaction.setSomeCounter(transaction.getSomeCounter + 1); transactionDao.update(transaction); } So, not only did we N+1 with our queries, but the entire UPDATE statement could be implemented in bulk (not just batch!) as follows: ctx .update(TRANSACTION) .set(TRANSACTION.SOME_COUNTER, TRANSACTION.SOME_COUNTER.plus(1)) .where(exists( selectOne() .from(TRANSACTION.account()) .where(TRANSACTION.account().TYPE.eq(\"Some Type\")) )) .execute(); Doesn’t that look much more neat, in addition to being much faster? To DAO or not to DAO Remember: The DAO API was added to jOOQ not because it is a good thing, but because it was easy to do and use, and because it’s a popular “pattern.” It’s a very limited API useful only for very primitive CRUD. But jOOQ’s biggest powers aren’t with the DAO. They’re with the large amount of standardised and vendor specific SQL support, the dynamic SQL capabilities, stored procedure support, and so much more. While the DAO may lure in folks used to using repositories, it suffers from the same problem as repositories: The simple fact that it is hardly ever enough for any serious database interaction. So, use the DAO API if you must, but use it sparingly, e.g. as a common base class for your more sophisticated and more specialised DAO subclasses, which implement actual queries, and always keep in mind that SQL is so much more than just CRUD.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12298\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003ejOOQ’s \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/daos/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/daos/\"\u003eDAO\u003c/a\u003e\u003c/code\u003e API is one of jOOQ’s most \u003ca href=\"https://github.com/jOOQ/jOOQ/issues/5984\" data-type=\"link\" data-id=\"https://github.com/jOOQ/jOOQ/issues/5984\"\u003econtroversial features\u003c/a\u003e. When it was first implemented, it was implemented merely:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBecause it was so easy to implement\u003c/li\u003e\n\n\n\n\u003cli\u003eBecause it seemed so useful for simple CRUD tasks\u003c/li\u003e\n\n\n\n\u003cli\u003eBecause that’s what many developers want\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThere’s a strong hint about the third bullet given how popular Spring Data’s repository “pattern” is. A lot of developers just want to quickly fetch and store data, without giving individual queries much thought.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eA fun fact is that most people use Spring Data just for CRUD, despite that the framework has been created with a strong opinion about DDD and the entailing concepts, like aggregates, aggregate roots, etc.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThe jOOQ \u003ccode\u003eDAO\u003c/code\u003e was easy to implement because it consists simply of:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA generic \u003ccode\u003e\u003ca href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/DAO.html\" data-type=\"link\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/DAO.html\"\u003eDAO\u003c/a\u003e\u003c/code\u003e API with a few common methods\u003c/li\u003e\n\n\n\n\u003cli\u003eA generated class per table that implements the bindings to generated POJOs and some auxiliary query methods\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn other words, for every table (such as \u003ccode\u003eACCOUNT\u003c/code\u003e) you’ll get a “free” \u003ccode\u003eAccount\u003c/code\u003e POJO and a “free” \u003ccode\u003eAccountDao\u003c/code\u003e DAO, which you can use as follows:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// DAOs are often injected in one way or another\n@Autowired\nAccountDao dao;\n\n// And then:\ndao.insert(new Account(1, \u0026#34;name\u0026#34;));\nAccount account = dao.findById(1);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSeems useful enough, no?\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy not use SQL, instead?\u003c/h2\u003e\n\n\n\n\u003cp\u003eJust like Spring Data is mostly used for quick data access (rather than thorough DDD application), so are DAOs. And both approaches train users to usually favour the quick access over thinking about individual queries in terms of data sets. What a pity!\u003c/p\u003e\n\n\n\n\u003cp\u003eHow much code do you see that looks like this, as soon as you start using DAOs or repositories?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003efor (Account account : \n    accountDao.fetchByType(\u0026#34;Some Type\u0026#34;)\n) {\n    for (Transaction transaction : \n        transactionDao.fetchByTransactionId(account.getId()\n    ) {\n        doSomething(transaction);\n    }\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe dreaded \u003ca href=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-n-plus-one/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-n-plus-one/\"\u003eN+1 problem\u003c/a\u003e manifests in the above code snippet, as we run a query fetching transactions for \u003cem\u003eevery \u003c/em\u003eaccount!\u003c/p\u003e\n\n\n\n\u003cp\u003eRegrettably, it’s often not even as obvious as above, where two nested loops are located right at the same spot in your code. A lot of times, these loops are hidden inside of “reusable” methods, and called in loops without giving them much thought.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen in fact, the following query wouldn’t be so much harder to write:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003efor (Transaction transaction : ctx\n    .selectFrom(TRANSACTION)\n    .where(exists(\n        selectOne()\n        .from(TRANSACTION.account())\n        .where(TRANSACTION.account().TYPE.eq(\u0026#34;Some Type\u0026#34;))\n    ))\n    .fetchInto(Transaction.class)\n) {\n    doSomething(transaction);\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eLooks pretty clear, no?\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eNote the above example is using a jOOQ 3.19 feature called \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\"\u003eimplicit path correlation\u003c/a\u003e, where the correlated subquery can be expressed using an implicit join path \u003ccode\u003eTRANSACTION.account()\u003c/code\u003e, rather than adding a more verbose, but equivalent predicate of the form \u003ccode\u003eTRANSACTION.ACCOUNT_ID.eq(ACCOUNT.ID)\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eTaking it one step further, \u003ca href=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-sql-select-all/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-sql-select-all/\"\u003eit’s quite likely you can optimise the projection as well\u003c/a\u003e as you might not need all the columns from \u003ccode\u003eTRANSACTION\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eMore optimisation with writes\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn fact, let’s look at \u003ccode\u003edoSomething()\u003c/code\u003e, which might also be using a \u003ccode\u003eDAO\u003c/code\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003evoid doSomething(Transaction transaction) {\n    transaction.setSomeCounter(transaction.getSomeCounter + 1);\n    transactionDao.update(transaction);\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSo, not only did we N+1 with our queries, but the entire \u003ccode\u003eUPDATE\u003c/code\u003e statement could be implemented in bulk (not just batch!) as follows:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx\n    .update(TRANSACTION)\n    .set(TRANSACTION.SOME_COUNTER, TRANSACTION.SOME_COUNTER.plus(1))\n    .where(exists(\n        selectOne()\n        .from(TRANSACTION.account())\n        .where(TRANSACTION.account().TYPE.eq(\u0026#34;Some Type\u0026#34;))\n    ))\n    .execute();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eDoesn’t that look much more neat, in addition to being much faster?\u003c/p\u003e\n\n\n\n\u003ch2\u003eTo DAO or not to DAO\u003c/h2\u003e\n\n\n\n\u003cp\u003eRemember: The \u003ccode\u003eDAO\u003c/code\u003e API was added to jOOQ not because it is a good thing, but because it was easy to do and use, and because it’s a popular “pattern.” It’s a \u003cem\u003every \u003c/em\u003elimited API useful only for \u003cem\u003every \u003c/em\u003eprimitive CRUD.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut jOOQ’s biggest powers aren’t with the \u003ccode\u003eDAO\u003c/code\u003e. They’re with the large amount of standardised and vendor specific SQL support, the dynamic SQL capabilities, stored procedure support, and so much more. While the \u003ccode\u003eDAO\u003c/code\u003e may lure in folks used to using repositories, it suffers from the same problem as repositories:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eThe simple fact that it is hardly ever enough for any serious database interaction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eSo, use the \u003ccode\u003eDAO\u003c/code\u003e API if you must, but use it sparingly, e.g. as a common base class for your more sophisticated and more specialised DAO subclasses, which implement actual queries, and always keep in mind that SQL is so much more than just CRUD.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2023-12-06T13:41:52Z",
  "modifiedTime": "2024-06-28T09:20:39Z"
}
