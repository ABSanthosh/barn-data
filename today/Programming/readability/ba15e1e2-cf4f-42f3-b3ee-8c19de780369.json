{
  "id": "ba15e1e2-cf4f-42f3-b3ee-8c19de780369",
  "title": "Mastering Embedded Linux, Part 5: Platform Daemons",
  "link": "https://www.thirtythreeforty.net/posts/2020/05/mastering-embedded-linux-part-5-platform-daemons/",
  "description": "Table of Contents Platform daemons A GPIO platform daemon GPIO access in Linux Linux GPIO in Rust Embedded web servers in Rust Exercising the code Ideas for improvement Key takeaways Recommended reading Coming up Subscribe and comment This is the fifth part of the Mastering Embedded Linux series, which is designed to help you become an expert at developing low-cost, customized embedded Linux systems. Previously, I provided an overview of the embedded Linux landscape, then dove straight into tutorials for compiling Raspberry Pi firmware using Buildroot. In this article and the next, I’m discussing how to apply these new Buildroot skills to begin packaging custom software into the firmware image. To do this, this article will discuss my concept of a “platform daemon” and implement a simple example of one in Rust. Then in Part 6, I’ll walk through the steps of writing a package to port this software to Buildroot. Platform daemons What’s a platform daemon? Up until now, most of this series has largely used “off the shelf” embedded software, including the Buildroot distribution itself and the individual software packages in it. Independent of this common library of software, every embedded system has its own “secret sauce”—usually software written specifically for that system. One such common pattern is a piece of software that picks up where the kernel leaves off: even if the kernel provides drivers to interact with peripherals, it doesn’t help with getting data moved between peripherals. For example, if you have an analog/digital converter that needs to report its readings over USB, the kernel lets userland talk to both, but it’s up to userland to read from the ADC and write to USB. Such software is target-specific enough that you simply can’t provide a generic solution that’s shipped with Buildroot. This scenario typically results in a piece of software I call the platform daemon.1 This daemon is bespoke software written for a particular target or family of targets—a “platform,” if you will. Often, it even contains device driver code for custom peripherals, even though such code really ought to go in the kernel as a module. Overall, the platform daemon contains intimate knowledge of the embedded system, it manages the state of all peripherals as a holistic unified entity, and it knows how to route and translate data coming and going from the system. In microcontrollers, this would just be “firmware”—a separate RTOS task that waits for events coming from device drivers. But in Linux, this can typically be implemented as low-level userland code. This is great because you can often write and debug the daemon on your computer and then port it to the hardware. (Sound familiar?) It also means that the system is better-behaved, because bugs in userland don’t crash the entire system. A GPIO platform daemon For this article, I’ve written a proof-of-concept platform daemon in Rust. This daemon provides direct HTTP access to GPIO pins. Usually, there are some more abstractions around this, like “system mode” or “peripheral enable,” but since this is a proof of concept, I’ll dispense with the extra work. A quick aside: If you’re a systems programmer who hasn’t yet run across Rust, I encourage you to take a look at it. It is a systems language that eliminates entire classes of bugs at compile time. It’s mature enough to use in production, but the language is still innovating rapidly and cares very deeply about getting it right the first time. Learning Rust will make you a better C/C++ programmer. There, I’m done evangelizing. The source code of the daemon is available on GitHub, or you can follow along below for the salient points. GPIO access in Linux The kernel provides userland programs with direct access to GPIOs via dedicated APIs. As with most kernel topics, you can read all about these interfaces in the excellent kernel documentation, which give a kernel-side view of how GPIOs are handled. This model extends pretty well to the userland API. Here are the Cliff’s notes. Linux provides a GPIO character device in /dev for applications to read/write to control GPIO pins. There is one character device named after each GPIO controller peripheral present in the system; the exact names depend on the system’s device tree. The upshot is that a given physical pin on the SoC is known to userland as a [peripheral, pin number] pair. Userland can use the device file to command the GPIO’s input/output state, read its high/low state, and if it is an “output,” command its high/low drive.2 Under the hood, this is done by sending special ioctl commands to this file, but you don’t have to worry about the gory details. There are lots of command-line tools that help handle this, including the kernel’s own libgpiod. (And yes, this is packaged in Buildroot!) There are also many different language bindings that make this API nice to use directly from custom programs, which is what I’ll be doing here. Note You may have also heard about the older /sys/class/gpio kernel ABI for manipulating GPIOs. This has been deprecated for many years now and will be removed after 2020. However, it is still present in many embedded systems with older kernels, and you’ll likely see it pop up in discussions from time to time. In this system, I’ll be using the modern character device API. Linux GPIO in Rust There is a dedicated Rust wrapper for the Linux GPIO system called gpio-cdev. This library makes it pretty easy to toggle a GPIO pin given a GPIO character device name and a pin number within that device. To use the library, I’ll write a quick wrapper that maps well to REST API calls. I’d like to allow the user to set the mode to “input” or “output.” If the user chooses “output,” they should be able to send the value. Here’s an enum type encapsulating this: #[derive(Serialize,Deserialize,Debug)] enum GpioCmd { In, Out { value: bool, }, } An important detail of the chardev GPIO API is that the file descriptor must be kept open by the program using the GPIO. If it is closed, all the GPIO lines will be released. So, I’ll create a map of [chip, pin] to lines, then cache the GPIO line objects in there. This cache will last as long as the daemon runs. type GpioPath = (String, u32); async fn main() { let active_pins = BTreeMap::\u003cGpioPath, Chip\u003e::new(); let shared_pins_state = Arc::new(RwLock::new(active_pins)); Now, the user specifies a pin using the previously-discussed [peripheral, pin number] pair, plus the state they’d like to command it to. This function needs a copy of the Arc shared pointer we created earlier: type GpioModifyResult = Result\u003c(), gpio_cdev::errors::Error\u003e; fn gpio_modify(chip: String, pin: u32, pins: Arc\u003cRwLock\u003cBTreeMap\u003cGpioPath, Chip\u003e\u003e\u003e, body: GpioCmd) -\u003e GpioModifyResult { // Lock the global map of pins so we can have exclusive access // to the mut methods on it and its Chips. let mut shared_pins = pins.write().unwrap(); let mut our_pin_entry = shared_pins.entry((chip.clone(), pin)); let chipdev = match our_pin_entry { Occupied(ref mut entry) =\u003e entry.get_mut(), Vacant(entry) =\u003e entry.insert(Chip::new(format!(\"/dev/{}\", chip))?) }; let line = chipdev.get_line(pin)?; Now, handle the GpioCmd. This function returns “nothing” () on success, because this is a “set” operation. match body { GpioCmd::Out { value } =\u003e { line.request(LineRequestFlags::OUTPUT, 0, \"http-gpio\")? // set_value returns () on success, which is what we need .set_value(value as u8) } GpioCmd::In =\u003e { line.request(LineRequestFlags::INPUT, 0, \"http-gpio\")?; // Set-to-input successful; we can ignore the returned LineHandle Ok(()) } } } Now I can move on to wrapping this in a web server. Embedded web servers in Rust There are several web server frameworks available for Rust, but the one I settled on is called Warp. There are several reasons I selected Warp: Runs on stable Rust: This rules out the otherwise very nice-looking Rocket (as of this writing in May 2020). Stable Rust is important to me because Rust provides extremely strong stability guarantees that make my life easier as a maintainer. Comparatively lightweight dependency list: Embedded systems don’t have the horsepower of a cloud server—in particular, they’re pretty light on CPU and memory. Selecting a small web framework helps ensure that compile times stay low and that the daemon itself remains lightweight at runtime. Because everything compiles down to native code, I don’t anticipate any speed problems.3 Extremely straightforward setup: When you’re writing a platform daemon, typically you’re more concerned about talking to the hardware and managing the system than you are using the latest whiz-bang web framework. Warp makes it trivial to have the webserver call your code. The only tricky bit is passing in the cache along with the request: let with_pins_state = warp::any().map(move || shared_pins_state.clone()); // POST /gpio/chipname/pinnum -\u003e String let gpio_modify = warp::post() .and(warp::path!(\"gpio\" / String / u32)) .and(with_pins_state) .and(warp::body::json()) .map(gpio_modify) .map(as_reply); My as_reply helper transforms the Result into a reply for Warp: fn as_reply(value: GpioModifyResult) -\u003e Box\u003cdyn warp::Reply\u003e { // Return if success, or stringify the error if not match value { Ok(_) =\u003e Box::new(\"Success\"), Err(err) =\u003e Box::new( warp::reply::with_status(err.to_string(), StatusCode::INTERNAL_SERVER_ERROR)) } } Boom, done. A simple platform daemon in about 70 lines of Rust. Exercising the code Since I’m wearing my “developer hat,” I’ll try to test on my workstation, without cross-compiling just yet. Linux provides lots of “dummy” drivers to simulate actual hardware, and GPIO is no exception. The gpio-mockup kernel module provides the ABI but doesn’t actually use any hardware. Each pair of arguments in gpio_mockup_ranges describes how many pins should be attached to each dummy GPIO peripheral. The new peripherals appear in /dev/ as expected: # modprobe gpio-mockup gpio_mockup_ranges=-1,32,-1,32 # ls -lh /dev/gpio* crw------- 1 root root 254, 0 Apr 7 22:07 /dev/gpiochip0 crw------- 1 root root 254, 1 Apr 7 22:07 /dev/gpiochip1 Here’s how to call the daemon using httpie.4 $ http POST localhost:3030/gpio/gpiochip0/2 Out:='{\"value\": true}' HTTP/1.1 200 OK content-length: 7 content-type: text/plain; charset=utf-8 date: Wed, 08 Apr 2020 03:19:41 GMT Success This POSTs the following JSON to /gpio/gpiochip0/2, where Serde automatically translates it to the Rust type and Warp passes it to the callback: { \"Out\": { \"value\": true } } Malformed requests are rejected automatically by the framework, and if anything goes wrong while setting the pin, as_reply sends back the error message. Overall, I am pleased with the proof of concept—it is concise, but thanks to the underlying libraries, it is largely correct and well-behaved. Again, I encourage you to study the complete source code on GitHub and let me know if you have feedback – either via email, as a GitHub issue, or with the fancy new comments section I’ve added. Ideas for improvement Every platform daemon I’ve dealt with has ended up needing a small configuration file, either because I wanted to target multiple boards at once, or because I wanted to make my own life easier while I wrote the software. To facilitate this, a small YAML or INI-formatted configuration file in /etc could tell the platform daemon which GPIO character device it ought to use, or provide string aliases for some of the pins so clients could just POST /gpio/yellow-led.5 If I were to implement this, I’d make sure to provide a sample config file in the http-gpio README, then provide a suitable configuration file in my target’s overlay directory, just like the configuration files for other software in the last article. Key takeaways If you’re doing anything clever with your embedded system, you’ll eventually wind up with a platform daemon of some kind. Wear multiple hats! Think about what would make the maintainer’s job easier while you’re writing custom software—chances are, you are the maintainer, and you’ll save yourself work down the road. Recommended reading LWN is an extremely well-written news site that regularly delivers in-depth technical articles about the Linux kernel and various free software projects surrounding it. The articles are free to read after a period of time, and you can also buy a subscription to read them as soon as they come out. It’s well worth it—the articles often include code samples, historical notes, and a great comments section about whatever they’re writing about. For example, here’s a pair of LWN articles about Linux GPIO: GPIO in the Kernel: an introduction GPIO in the Kernel: future directions This excellent article gives a good command-line tutorial of character device GPIO control. Hackaday’s Linux-Fu series has in-depth discussion of various technical userland topics, not just GPIOs. Many of these will come in handy when you start to write your own daemon code. Coming up In the next article I’ll finish the ongoing Buildroot theme by packaging http-gpio for the Raspberry Pi I’ve been working with. This will include some “best practices” for your own packages. I’ll also have a deeper discussion of startup scripts and the init system, which I’ll use to start the daemon automatically. Subscribe and comment As always, you can subscribe to my blog for updates. Please also leave a comment below if you have a question or want to point something out that I’ve overlooked. I appreciate all the communication I get. Thanks for reading! I initially called these “system daemons” but that became a non-starter after the proliferation of systemd. ↩︎ This slightly glosses over the pin controller, another peripheral, separate from the GPIO peripheral, which is responsible for steering a pin toward the GPIO, SPI, MMC, or other peripheral. This complication is handled for you when you use the userland GPIO API. Later on, I’ll discuss this in more detail when writing a device tree. ↩︎ Quick war story: at my last job, I foolishly selected Python for a platform daemon that did not need any sort of strong performance guarantees. Other developers began adding functionality using dependencies like Flask. These heavy frameworks combined with Python’s anemic performance slowed the platform daemon’s startup time to nearly 45 seconds—embarrassingly slow, even without hard performance requirements. It took more work to speed up the Python than it would have to have written the daemon in Go or Rust to begin with. I like Python, but don’t use it for platform daemons. ↩︎ httpie is a better curl (pronounced aitch-tee-tee-pie, command named http—go figure). In the very common case of passing JSON values in a POST body, it saves so much typing, and it looks readable in documentation. ↩︎ It’s actually possible to provide GPIO names in the device tree, which is the “hardware definition” for Linux. Doing the naming there would provide the abstraction for all of userland to use. I’d prefer that approach for the specific case of naming GPIOs, but of course in a real platform daemon you’d have more interesting configuration variables. ↩︎",
  "author": "George Hilliard",
  "published": "Sat, 02 May 2020 18:30:00 -0500",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 15454,
  "excerpt": "Writing a custom program that talks to hardware",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "Table of Contents Platform daemons A GPIO platform daemon GPIO access in Linux Linux GPIO in Rust Embedded web servers in Rust Exercising the code Ideas for improvement Key takeaways Recommended reading Coming up Subscribe and comment This is the fifth part of the Mastering Embedded Linux series, which is designed to help you become an expert at developing low-cost, customized embedded Linux systems. Previously, I provided an overview of the embedded Linux landscape, then dove straight into tutorials for compiling Raspberry Pi firmware using Buildroot. In this article and the next, I’m discussing how to apply these new Buildroot skills to begin packaging custom software into the firmware image. To do this, this article will discuss my concept of a “platform daemon” and implement a simple example of one in Rust. Then in Part 6, I’ll walk through the steps of writing a package to port this software to Buildroot. What’s a platform daemon? Up until now, most of this series has largely used “off the shelf” embedded software, including the Buildroot distribution itself and the individual software packages in it. Independent of this common library of software, every embedded system has its own “secret sauce”—usually software written specifically for that system. One such common pattern is a piece of software that picks up where the kernel leaves off: even if the kernel provides drivers to interact with peripherals, it doesn’t help with getting data moved between peripherals. For example, if you have an analog/digital converter that needs to report its readings over USB, the kernel lets userland talk to both, but it’s up to userland to read from the ADC and write to USB. Such software is target-specific enough that you simply can’t provide a generic solution that’s shipped with Buildroot. This scenario typically results in a piece of software I call the platform daemon.1 This daemon is bespoke software written for a particular target or family of targets—a “platform,” if you will. Often, it even contains device driver code for custom peripherals, even though such code really ought to go in the kernel as a module. Overall, the platform daemon contains intimate knowledge of the embedded system, it manages the state of all peripherals as a holistic unified entity, and it knows how to route and translate data coming and going from the system. In microcontrollers, this would just be “firmware”—a separate RTOS task that waits for events coming from device drivers. But in Linux, this can typically be implemented as low-level userland code. This is great because you can often write and debug the daemon on your computer and then port it to the hardware. (Sound familiar?) It also means that the system is better-behaved, because bugs in userland don’t crash the entire system. A GPIO platform daemon For this article, I’ve written a proof-of-concept platform daemon in Rust. This daemon provides direct HTTP access to GPIO pins. Usually, there are some more abstractions around this, like “system mode” or “peripheral enable,” but since this is a proof of concept, I’ll dispense with the extra work. A quick aside: If you’re a systems programmer who hasn’t yet run across Rust, I encourage you to take a look at it. It is a systems language that eliminates entire classes of bugs at compile time. It’s mature enough to use in production, but the language is still innovating rapidly and cares very deeply about getting it right the first time. Learning Rust will make you a better C/C++ programmer. There, I’m done evangelizing. The source code of the daemon is available on GitHub, or you can follow along below for the salient points. GPIO access in Linux The kernel provides userland programs with direct access to GPIOs via dedicated APIs. As with most kernel topics, you can read all about these interfaces in the excellent kernel documentation, which give a kernel-side view of how GPIOs are handled. This model extends pretty well to the userland API. Here are the Cliff’s notes. Linux provides a GPIO character device in /dev for applications to read/write to control GPIO pins. There is one character device named after each GPIO controller peripheral present in the system; the exact names depend on the system’s device tree. The upshot is that a given physical pin on the SoC is known to userland as a [peripheral, pin number] pair. Userland can use the device file to command the GPIO’s input/output state, read its high/low state, and if it is an “output,” command its high/low drive.2 Under the hood, this is done by sending special ioctl commands to this file, but you don’t have to worry about the gory details. There are lots of command-line tools that help handle this, including the kernel’s own libgpiod. (And yes, this is packaged in Buildroot!) There are also many different language bindings that make this API nice to use directly from custom programs, which is what I’ll be doing here. Note You may have also heard about the older /sys/class/gpio kernel ABI for manipulating GPIOs. This has been deprecated for many years now and will be removed after 2020. However, it is still present in many embedded systems with older kernels, and you’ll likely see it pop up in discussions from time to time. In this system, I’ll be using the modern character device API. Linux GPIO in Rust There is a dedicated Rust wrapper for the Linux GPIO system called gpio-cdev. This library makes it pretty easy to toggle a GPIO pin given a GPIO character device name and a pin number within that device. To use the library, I’ll write a quick wrapper that maps well to REST API calls. I’d like to allow the user to set the mode to “input” or “output.” If the user chooses “output,” they should be able to send the value. Here’s an enum type encapsulating this: #[derive(Serialize,Deserialize,Debug)] enum GpioCmd { In, Out { value: bool, }, } An important detail of the chardev GPIO API is that the file descriptor must be kept open by the program using the GPIO. If it is closed, all the GPIO lines will be released. So, I’ll create a map of [chip, pin] to lines, then cache the GPIO line objects in there. This cache will last as long as the daemon runs. type GpioPath = (String, u32); async fn main() { let active_pins = BTreeMap::\u003cGpioPath, Chip\u003e::new(); let shared_pins_state = Arc::new(RwLock::new(active_pins)); Now, the user specifies a pin using the previously-discussed [peripheral, pin number] pair, plus the state they’d like to command it to. This function needs a copy of the Arc shared pointer we created earlier: type GpioModifyResult = Result\u003c(), gpio_cdev::errors::Error\u003e; fn gpio_modify(chip: String, pin: u32, pins: Arc\u003cRwLock\u003cBTreeMap\u003cGpioPath, Chip\u003e\u003e\u003e, body: GpioCmd) -\u003e GpioModifyResult { // Lock the global map of pins so we can have exclusive access // to the mut methods on it and its Chips. let mut shared_pins = pins.write().unwrap(); let mut our_pin_entry = shared_pins.entry((chip.clone(), pin)); let chipdev = match our_pin_entry { Occupied(ref mut entry) =\u003e entry.get_mut(), Vacant(entry) =\u003e entry.insert(Chip::new(format!(\"/dev/{}\", chip))?) }; let line = chipdev.get_line(pin)?; Now, handle the GpioCmd. This function returns “nothing” () on success, because this is a “set” operation. match body { GpioCmd::Out { value } =\u003e { line.request(LineRequestFlags::OUTPUT, 0, \"http-gpio\")? // set_value returns () on success, which is what we need .set_value(value as u8) } GpioCmd::In =\u003e { line.request(LineRequestFlags::INPUT, 0, \"http-gpio\")?; // Set-to-input successful; we can ignore the returned LineHandle Ok(()) } } } Now I can move on to wrapping this in a web server. Embedded web servers in Rust There are several web server frameworks available for Rust, but the one I settled on is called Warp. There are several reasons I selected Warp: Runs on stable Rust: This rules out the otherwise very nice-looking Rocket (as of this writing in May 2020). Stable Rust is important to me because Rust provides extremely strong stability guarantees that make my life easier as a maintainer. Comparatively lightweight dependency list: Embedded systems don’t have the horsepower of a cloud server—in particular, they’re pretty light on CPU and memory. Selecting a small web framework helps ensure that compile times stay low and that the daemon itself remains lightweight at runtime. Because everything compiles down to native code, I don’t anticipate any speed problems.3 Extremely straightforward setup: When you’re writing a platform daemon, typically you’re more concerned about talking to the hardware and managing the system than you are using the latest whiz-bang web framework. Warp makes it trivial to have the webserver call your code. The only tricky bit is passing in the cache along with the request: let with_pins_state = warp::any().map(move || shared_pins_state.clone()); // POST /gpio/chipname/pinnum -\u003e String let gpio_modify = warp::post() .and(warp::path!(\"gpio\" / String / u32)) .and(with_pins_state) .and(warp::body::json()) .map(gpio_modify) .map(as_reply); My as_reply helper transforms the Result into a reply for Warp: fn as_reply(value: GpioModifyResult) -\u003e Box\u003cdyn warp::Reply\u003e { // Return if success, or stringify the error if not match value { Ok(_) =\u003e Box::new(\"Success\"), Err(err) =\u003e Box::new( warp::reply::with_status(err.to_string(), StatusCode::INTERNAL_SERVER_ERROR)) } } Boom, done. A simple platform daemon in about 70 lines of Rust. Exercising the code Since I’m wearing my “developer hat,” I’ll try to test on my workstation, without cross-compiling just yet. Linux provides lots of “dummy” drivers to simulate actual hardware, and GPIO is no exception. The gpio-mockup kernel module provides the ABI but doesn’t actually use any hardware. Each pair of arguments in gpio_mockup_ranges describes how many pins should be attached to each dummy GPIO peripheral. The new peripherals appear in /dev/ as expected: # modprobe gpio-mockup gpio_mockup_ranges=-1,32,-1,32 # ls -lh /dev/gpio* crw------- 1 root root 254, 0 Apr 7 22:07 /dev/gpiochip0 crw------- 1 root root 254, 1 Apr 7 22:07 /dev/gpiochip1 Here’s how to call the daemon using httpie.4 $ http POST localhost:3030/gpio/gpiochip0/2 Out:='{\"value\": true}' HTTP/1.1 200 OK content-length: 7 content-type: text/plain; charset=utf-8 date: Wed, 08 Apr 2020 03:19:41 GMT Success This POSTs the following JSON to /gpio/gpiochip0/2, where Serde automatically translates it to the Rust type and Warp passes it to the callback: { \"Out\": { \"value\": true } } Malformed requests are rejected automatically by the framework, and if anything goes wrong while setting the pin, as_reply sends back the error message. Overall, I am pleased with the proof of concept—it is concise, but thanks to the underlying libraries, it is largely correct and well-behaved. Again, I encourage you to study the complete source code on GitHub and let me know if you have feedback – either via email, as a GitHub issue, or with the fancy new comments section I’ve added. Ideas for improvement Every platform daemon I’ve dealt with has ended up needing a small configuration file, either because I wanted to target multiple boards at once, or because I wanted to make my own life easier while I wrote the software. To facilitate this, a small YAML or INI-formatted configuration file in /etc could tell the platform daemon which GPIO character device it ought to use, or provide string aliases for some of the pins so clients could just POST /gpio/yellow-led.5 If I were to implement this, I’d make sure to provide a sample config file in the http-gpio README, then provide a suitable configuration file in my target’s overlay directory, just like the configuration files for other software in the last article. Key takeaways If you’re doing anything clever with your embedded system, you’ll eventually wind up with a platform daemon of some kind. Wear multiple hats! Think about what would make the maintainer’s job easier while you’re writing custom software—chances are, you are the maintainer, and you’ll save yourself work down the road. Recommended reading LWN is an extremely well-written news site that regularly delivers in-depth technical articles about the Linux kernel and various free software projects surrounding it. The articles are free to read after a period of time, and you can also buy a subscription to read them as soon as they come out. It’s well worth it—the articles often include code samples, historical notes, and a great comments section about whatever they’re writing about. For example, here’s a pair of LWN articles about Linux GPIO: GPIO in the Kernel: an introduction GPIO in the Kernel: future directions This excellent article gives a good command-line tutorial of character device GPIO control. Hackaday’s Linux-Fu series has in-depth discussion of various technical userland topics, not just GPIOs. Many of these will come in handy when you start to write your own daemon code. Coming up In the next article I’ll finish the ongoing Buildroot theme by packaging http-gpio for the Raspberry Pi I’ve been working with. This will include some “best practices” for your own packages. I’ll also have a deeper discussion of startup scripts and the init system, which I’ll use to start the daemon automatically. As always, you can subscribe to my blog for updates. Please also leave a comment below if you have a question or want to point something out that I’ve overlooked. I appreciate all the communication I get. Thanks for reading! I initially called these “system daemons” but that became a non-starter after the proliferation of systemd. ↩︎ This slightly glosses over the pin controller, another peripheral, separate from the GPIO peripheral, which is responsible for steering a pin toward the GPIO, SPI, MMC, or other peripheral. This complication is handled for you when you use the userland GPIO API. Later on, I’ll discuss this in more detail when writing a device tree. ↩︎ Quick war story: at my last job, I foolishly selected Python for a platform daemon that did not need any sort of strong performance guarantees. Other developers began adding functionality using dependencies like Flask. These heavy frameworks combined with Python’s anemic performance slowed the platform daemon’s startup time to nearly 45 seconds—embarrassingly slow, even without hard performance requirements. It took more work to speed up the Python than it would have to have written the daemon in Go or Rust to begin with. I like Python, but don’t use it for platform daemons. ↩︎ httpie is a better curl (pronounced aitch-tee-tee-pie, command named http—go figure). In the very common case of passing JSON values in a POST body, it saves so much typing, and it looks readable in documentation. ↩︎ It’s actually possible to provide GPIO names in the device tree, which is the “hardware definition” for Linux. Doing the naming there would provide the abstraction for all of userland to use. I’d prefer that approach for the specific case of naming GPIOs, but of course in a real platform daemon you’d have more interesting configuration variables. ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n\u003clabel for=\"tocToggle\"\u003eTable of Contents\u003c/label\u003e\u003c/p\u003e\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#platform-daemons\"\u003ePlatform daemons\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#a-gpio-platform-daemon\"\u003eA GPIO platform daemon\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#gpio-access-in-linux\"\u003eGPIO access in Linux\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#linux-gpio-in-rust\"\u003eLinux GPIO in Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#embedded-web-servers-in-rust\"\u003eEmbedded web servers in Rust\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#exercising-the-code\"\u003eExercising the code\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#ideas-for-improvement\"\u003eIdeas for improvement\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#key-takeaways\"\u003eKey takeaways\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#recommended-reading\"\u003eRecommended reading\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#coming-up\"\u003eComing up\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#subscribe-and-comment\"\u003eSubscribe and comment\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e\n\u003c/div\u003e\n\u003cp\u003eThis is the fifth part of the \u003ca href=\"https://www.thirtythreeforty.net/series/mastering-embedded-linux\"\u003eMastering Embedded Linux series\u003c/a\u003e, which is designed to help you become an expert at developing low-cost, customized embedded Linux systems.\nPreviously, I provided an overview of the embedded Linux landscape, then dove straight into tutorials for compiling Raspberry Pi firmware using Buildroot.\u003c/p\u003e\n\u003cp\u003eIn this article and the next, I’m discussing how to apply these new Buildroot skills to begin packaging custom software into the firmware image.\nTo do this, this article will discuss my concept of a “platform daemon” and implement a simple example of one in Rust.\nThen in Part 6, I’ll walk through the steps of writing a package to port this software to Buildroot.\u003c/p\u003e\n\n\u003cp\u003eWhat’s a platform daemon?\u003c/p\u003e\n\u003cp\u003eUp until now, most of this series has largely used “off the shelf” embedded software, including the Buildroot distribution itself and the individual software packages in it.\nIndependent of this common library of software, every embedded system has its own “secret sauce”—usually software written specifically for that system.\u003c/p\u003e\n\u003cp\u003eOne such common pattern is a piece of software that picks up where the kernel leaves off: even if the kernel provides drivers to interact with peripherals, it doesn’t help with getting data moved between peripherals.\nFor example, if you have an \u003ca href=\"https://en.wikipedia.org/wiki/Analog-to-digital_converter\"\u003eanalog/digital converter\u003c/a\u003e that needs to report its readings over USB, the kernel lets userland talk to both, but it’s up to userland to read from the ADC and write to USB.\nSuch software is target-specific enough that you simply \u003cem\u003ecan’t\u003c/em\u003e provide a generic solution that’s shipped with Buildroot.\u003c/p\u003e\n\u003cp\u003eThis scenario typically results in a piece of software I call the \u003cstrong\u003eplatform daemon\u003c/strong\u003e.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\nThis daemon is bespoke software written for a particular target or family of targets—a “platform,” if you will.\nOften, it even contains device driver code for custom peripherals, even though such code really ought to go in the kernel as a module.\nOverall, the platform daemon contains intimate knowledge of the embedded system, it manages the state of all peripherals as a holistic unified entity, and it knows how to route and translate data coming and going from the system.\u003c/p\u003e\n\u003cp\u003eIn microcontrollers, this would just be “firmware”—a separate RTOS task that waits for events coming from device drivers.\nBut in Linux, this can typically be implemented as low-level userland code.\nThis is great because you can often write and debug the daemon on your computer and then port it to the hardware.\n(\u003ca href=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/#write-then-port\"\u003eSound familiar?\u003c/a\u003e)\nIt also means that the system is better-behaved, because bugs in userland don’t crash the entire system.\u003c/p\u003e\n\u003ch2 id=\"a-gpio-platform-daemon\"\u003eA GPIO platform daemon\u003c/h2\u003e\n\u003cp\u003eFor this article, I’ve written a proof-of-concept platform daemon in Rust.\nThis daemon provides direct HTTP access to \u003ca href=\"https://en.wikipedia.org/wiki/General-purpose_input/output\"\u003eGPIO pins\u003c/a\u003e.\nUsually, there are some more abstractions around this, like “system mode” or “peripheral enable,” but since this is a proof of concept, I’ll dispense with the extra work.\u003c/p\u003e\n\u003cp\u003eA quick aside: If you’re a systems programmer who hasn’t yet run across Rust, I encourage you to \u003ca href=\"https://www.rust-lang.org/\"\u003etake a look at it\u003c/a\u003e.\nIt is a systems language that eliminates entire classes of bugs at compile time.\nIt’s mature enough to use in production, but the language is still innovating rapidly and cares very deeply about getting it right the first time.\nLearning Rust will make you a better C/C++ programmer.\u003c/p\u003e\n\u003cp\u003eThere, I’m done evangelizing.\nThe source code of the daemon is \u003ca href=\"https://github.com/thirtythreeforty/http-gpio\"\u003eavailable on GitHub\u003c/a\u003e, or you can follow along below for the salient points.\u003c/p\u003e\n\u003ch3 id=\"gpio-access-in-linux\"\u003eGPIO access in Linux\u003c/h3\u003e\n\u003cp\u003eThe kernel provides userland programs with direct access to GPIOs via dedicated APIs.\nAs with most kernel topics, you can read all about these interfaces in the \u003ca href=\"https://www.kernel.org/doc/html/latest/driver-api/gpio/intro.html\"\u003eexcellent kernel documentation\u003c/a\u003e, which give a kernel-side view of how GPIOs are handled.\nThis model extends pretty well to the userland API.\u003c/p\u003e\n\u003cp\u003eHere are the Cliff’s notes.\nLinux provides a \u003cem\u003eGPIO character device\u003c/em\u003e in \u003ccode\u003e/dev\u003c/code\u003e for applications to read/write to control GPIO pins.\nThere is one character device named after each GPIO controller peripheral present in the system; the exact names depend on the system’s device tree.\nThe upshot is that a given physical pin on the SoC is known to userland as a \u003cspan\u003e[peripheral, pin number]\u003c/span\u003e\npair.\u003c/p\u003e\n\u003cp\u003eUserland can use the device file to command the GPIO’s input/output state, read its high/low state, and if it is an “output,” command its high/low drive.\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e\nUnder the hood, this is done by sending \u003ca href=\"https://github.com/torvalds/linux/blob/master/include/uapi/linux/gpio.h\"\u003especial ioctl commands\u003c/a\u003e to this file, but you don’t have to worry about the gory details.\nThere are lots of command-line tools that help handle this, including the kernel’s own \u003ca href=\"https://git.kernel.org/pub/scm/libs/libgpiod/libgpiod.git\"\u003elibgpiod\u003c/a\u003e.\n(And yes, this \u003cem\u003eis\u003c/em\u003e \u003ca href=\"https://github.com/thirtythreeforty/buildroot-mastering-embedded-linux/tree/master/package/libgpiod\"\u003epackaged in Buildroot\u003c/a\u003e!)\u003c/p\u003e\n\u003cp\u003eThere are also many different language bindings that make this API nice to use directly from custom programs, which is what I’ll be doing here.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e\n\u003cp\u003eYou may have also heard about \u003ca href=\"https://www.emcraft.com/stm32f429discovery/controlling-gpio-from-linux-user-space\"\u003ethe older \u003ccode\u003e/sys/class/gpio\u003c/code\u003e\u003c/a\u003e kernel ABI for manipulating GPIOs.\nThis has been deprecated for many years now and will be removed after 2020.\nHowever, it is still present in many embedded systems with older kernels, and you’ll likely see it pop up in discussions from time to time.\u003c/p\u003e\n\u003cp\u003eIn this system, I’ll be using the modern character device API.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"linux-gpio-in-rust\"\u003eLinux GPIO in Rust\u003c/h3\u003e\n\u003cp\u003eThere is a dedicated Rust wrapper for the Linux GPIO system called \u003ca href=\"https://github.com/rust-embedded/gpio-cdev\"\u003e\u003ccode\u003egpio-cdev\u003c/code\u003e\u003c/a\u003e.\nThis library makes it pretty easy to toggle a GPIO pin given a GPIO character device name and a pin number within that device.\u003c/p\u003e\n\u003cp\u003eTo use the library, I’ll write a quick wrapper that maps well to REST API calls.\nI’d like to allow the user to set the mode to “input” or “output.”\nIf the user chooses “output,” they should be able to send the value.\nHere’s an enum type encapsulating this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e#[derive(Serialize,Deserialize,Debug)]\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003eenum\u003c/span\u003e \u003cspan\u003eGpioCmd\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003eIn,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003eOut\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003evalue: \u003cspan\u003ebool\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e},\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAn important detail of the chardev GPIO API is that the file descriptor must be kept open by the program using the GPIO.\nIf it is closed, all the GPIO lines will be released.\nSo, I’ll create a map of [chip, pin] to lines, then cache the GPIO line objects in there.\nThis cache will last as long as the daemon runs.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003etype\u003c/span\u003e \u003cspan\u003eGpioPath\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e(\u003cspan\u003eString\u003c/span\u003e,\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eu32\u003c/span\u003e);\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003emain\u003c/span\u003e()\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eactive_pins\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eBTreeMap::\u003cspan\u003e\u0026lt;\u003c/span\u003eGpioPath,\u003cspan\u003e \u003c/span\u003eChip\u003cspan\u003e\u0026gt;\u003c/span\u003e::new();\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eshared_pins_state\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eArc::new(RwLock::new(active_pins));\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, the user specifies a pin using the previously-discussed \u003cspan\u003e[peripheral, pin number]\u003c/span\u003e\npair, plus the state they’d like to command it to.\nThis function needs a copy of the \u003ccode\u003eArc\u003c/code\u003e shared pointer we created earlier:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003etype\u003c/span\u003e \u003cspan\u003eGpioModifyResult\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eResult\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e(),\u003cspan\u003e \u003c/span\u003egpio_cdev::errors::Error\u003cspan\u003e\u0026gt;\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003egpio_modify\u003c/span\u003e(chip: \u003cspan\u003eString\u003c/span\u003e,\u003cspan\u003e \u003c/span\u003epin: \u003cspan\u003eu32\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e               \u003c/span\u003epins: \u003cspan\u003eArc\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003eRwLock\u003cspan\u003e\u0026lt;\u003c/span\u003eBTreeMap\u003cspan\u003e\u0026lt;\u003c/span\u003eGpioPath,\u003cspan\u003e \u003c/span\u003eChip\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e,\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e               \u003c/span\u003ebody: \u003cspan\u003eGpioCmd\u003c/span\u003e)\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e-\u0026gt; \u003cspan\u003eGpioModifyResult\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Lock the global map of pins so we can have exclusive access\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// to the mut methods on it and its Chips.\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eshared_pins\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003epins.write().unwrap();\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eour_pin_entry\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eshared_pins.entry((chip.clone(),\u003cspan\u003e \u003c/span\u003epin));\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003echipdev\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ematch\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eour_pin_entry\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eOccupied(\u003cspan\u003eref\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003emut\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eentry)\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eentry.get_mut(),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eVacant(entry)\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eentry.insert(Chip::new(format\u003cspan\u003e!\u003c/span\u003e(\u003cspan\u003e\u0026#34;/dev/{}\u0026#34;\u003c/span\u003e,\u003cspan\u003e \u003c/span\u003echip))\u003cspan\u003e?\u003c/span\u003e)\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e};\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eline\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003echipdev.get_line(pin)\u003cspan\u003e?\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, handle the \u003ccode\u003eGpioCmd\u003c/code\u003e.\nThis function returns “nothing” \u003ccode\u003e()\u003c/code\u003e on success, because this is a “set” operation.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ematch\u003c/span\u003e\u003cspan\u003e \u003c/span\u003ebody\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eGpioCmd::Out\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e \u003c/span\u003evalue\u003cspan\u003e \u003c/span\u003e}\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003eline.request(LineRequestFlags::OUTPUT,\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;http-gpio\u0026#34;\u003c/span\u003e)\u003cspan\u003e?\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e\u003cspan\u003e// set_value returns () on success, which is what we need\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e                \u003c/span\u003e.set_value(value\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eas\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eu8\u003c/span\u003e)\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003eGpioCmd::In\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003eline.request(LineRequestFlags::INPUT,\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;http-gpio\u0026#34;\u003c/span\u003e)\u003cspan\u003e?\u003c/span\u003e;\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003e// Set-to-input successful; we can ignore the returned LineHandle\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003eOk\u003c/span\u003e(())\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow I can move on to wrapping this in a web server.\u003c/p\u003e\n\u003ch3 id=\"embedded-web-servers-in-rust\"\u003eEmbedded web servers in Rust\u003c/h3\u003e\n\u003cp\u003eThere are several web server frameworks available for Rust, but the one I settled on is called \u003ca href=\"https://github.com/seanmonstar/warp\"\u003eWarp\u003c/a\u003e.\nThere are several reasons I selected Warp:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRuns on stable Rust\u003c/strong\u003e: This rules out the otherwise very nice-looking Rocket (as of this writing in May 2020).\nStable Rust is important to me because Rust provides \u003ca href=\"https://blog.rust-lang.org/2014/10/30/Stability.html\"\u003eextremely strong stability guarantees\u003c/a\u003e that make my life easier as a maintainer.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eComparatively lightweight dependency list\u003c/strong\u003e: Embedded systems don’t have the horsepower of a cloud server—in particular, they’re pretty light on CPU and memory.\nSelecting a small web framework helps ensure that compile times stay low and that the daemon itself remains lightweight at runtime.\nBecause everything compiles down to native code, I don’t anticipate any speed problems.\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExtremely straightforward setup\u003c/strong\u003e: When you’re writing a platform daemon, typically you’re more concerned about talking to the hardware and managing the system than you are using the latest whiz-bang web framework.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWarp makes it trivial to have the webserver call your code.\nThe only tricky bit is passing in the cache along with the request:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003ewith_pins_state\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003ewarp::any().map(\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e||\u003c/span\u003e\u003cspan\u003e \u003c/span\u003eshared_pins_state.clone());\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e// POST /gpio/chipname/pinnum -\u0026gt; String\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e \u003c/span\u003egpio_modify\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003ewarp::post()\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e.and(warp::path\u003cspan\u003e!\u003c/span\u003e(\u003cspan\u003e\u0026#34;gpio\u0026#34;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eu32\u003c/span\u003e))\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e.and(with_pins_state)\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e.and(warp::body::json())\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e.map(gpio_modify)\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e.map(as_reply);\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMy \u003ccode\u003eas_reply\u003c/code\u003e helper transforms the \u003ccode\u003eResult\u003c/code\u003e into a reply for Warp:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003efn\u003c/span\u003e \u003cspan\u003eas_reply\u003c/span\u003e(value: \u003cspan\u003eGpioModifyResult\u003c/span\u003e)\u003cspan\u003e \u003c/span\u003e-\u0026gt; \u003cspan\u003eBox\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003edyn\u003cspan\u003e \u003c/span\u003ewarp::Reply\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Return if success, or stringify the error if not\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ematch\u003c/span\u003e\u003cspan\u003e \u003c/span\u003evalue\u003cspan\u003e \u003c/span\u003e{\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eOk\u003c/span\u003e(_)\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eBox\u003c/span\u003e::new(\u003cspan\u003e\u0026#34;Success\u0026#34;\u003c/span\u003e),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003eErr\u003c/span\u003e(err)\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eBox\u003c/span\u003e::new(\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e            \u003c/span\u003ewarp::reply::with_status(err.to_string(),\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e                                     \u003c/span\u003eStatusCode::INTERNAL_SERVER_ERROR))\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e}\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBoom, done.\nA simple platform daemon in about 70 lines of Rust.\u003c/p\u003e\n\u003ch3 id=\"exercising-the-code\"\u003eExercising the code\u003c/h3\u003e\n\u003cp\u003eSince I’m wearing my “developer hat,” I’ll try to test on my workstation, without cross-compiling just yet.\nLinux provides lots of “dummy” drivers to simulate actual hardware, and GPIO is no exception.\nThe \u003ccode\u003egpio-mockup\u003c/code\u003e kernel module provides the ABI but doesn’t actually use any hardware.\nEach pair of arguments in \u003ccode\u003egpio_mockup_ranges\u003c/code\u003e describes how many pins should be attached to each dummy GPIO peripheral.\nThe new peripherals appear in \u003ccode\u003e/dev/\u003c/code\u003e as expected:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e# modprobe gpio-mockup gpio_mockup_ranges=-1,32,-1,32\n# ls -lh /dev/gpio*\ncrw------- 1 root root 254, 0 Apr  7 22:07 /dev/gpiochip0\ncrw------- 1 root root 254, 1 Apr  7 22:07 /dev/gpiochip1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s how to call the daemon using \u003ca href=\"https://httpie.org/\"\u003ehttpie\u003c/a\u003e.\u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ http POST localhost:3030/gpio/gpiochip0/2 Out:=\u0026#39;{\u0026#34;value\u0026#34;: true}\u0026#39;\nHTTP/1.1 200 OK\ncontent-length: 7\ncontent-type: text/plain; charset=utf-8\ndate: Wed, 08 Apr 2020 03:19:41 GMT\n\nSuccess\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis \u003ccode\u003ePOST\u003c/code\u003es the following JSON to \u003ccode\u003e/gpio/gpiochip0/2\u003c/code\u003e, where \u003ca href=\"https://serde.rs/\"\u003eSerde\u003c/a\u003e automatically translates it to the Rust type and Warp passes it to the callback:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"json\"\u003e{ \u003cspan\u003e\u0026#34;Out\u0026#34;\u003c/span\u003e: { \u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e } }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eMalformed requests are rejected automatically by the framework, and if anything goes wrong while setting the pin, \u003ccode\u003eas_reply\u003c/code\u003e sends back the error message.\nOverall, I am pleased with the proof of concept—it is concise, but thanks to the underlying libraries, it is largely correct and well-behaved.\u003c/p\u003e\n\u003cp\u003eAgain, I encourage you to study the complete source code \u003ca href=\"https://github.com/thirtythreeforty/http-gpio\"\u003eon GitHub\u003c/a\u003e and let me know if you have feedback – either \u003ca href=\"mailto:thirtythreeforty@gmail.com\"\u003evia email\u003c/a\u003e, as a GitHub issue, or with the fancy new \u003ca href=\"#commento\"\u003ecomments section\u003c/a\u003e I’ve added.\u003c/p\u003e\n\u003ch3 id=\"ideas-for-improvement\"\u003eIdeas for improvement\u003c/h3\u003e\n\u003cp\u003eEvery platform daemon I’ve dealt with has ended up needing a small configuration file, either because I wanted to target multiple boards at once, or because I wanted to make my own life easier while I wrote the software.\nTo facilitate this, a small YAML or INI-formatted configuration file in \u003ccode\u003e/etc\u003c/code\u003e could tell the platform daemon which GPIO character device it ought to use, or provide string aliases for some of the pins so clients could just \u003ccode\u003ePOST /gpio/yellow-led\u003c/code\u003e.\u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eIf I were to implement this, I’d make sure to provide a sample config file in the http-gpio README, then provide a suitable configuration file in my target’s overlay directory, just like the configuration files for other software in the last article.\u003c/p\u003e\n\u003ch2 id=\"key-takeaways\"\u003eKey takeaways\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIf you’re doing anything clever with your embedded system, you’ll eventually wind up with a platform daemon of some kind.\u003c/li\u003e\n\u003cli\u003eWear multiple hats! Think about what would make the maintainer’s job easier while you’re writing custom software—chances are, \u003cem\u003eyou\u003c/em\u003e are the maintainer, and you’ll save yourself work down the road.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"recommended-reading\"\u003eRecommended reading\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://lwn.net/\"\u003e\u003cstrong\u003eLWN\u003c/strong\u003e\u003c/a\u003e is an extremely well-written news site that regularly delivers in-depth technical articles about the Linux kernel and various free software projects surrounding it.\nThe articles are free to read after a period of time, and you can also buy a subscription to read them as soon as they come out.\nIt’s well worth it—the articles often include code samples, historical notes, and a great comments section about whatever they’re writing about.\nFor example, here’s a pair of LWN articles about Linux GPIO:\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://lwn.net/Articles/532714/\"\u003eGPIO in the Kernel: an introduction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://lwn.net/Articles/533632/\"\u003eGPIO in the Kernel: future directions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.beyondlogic.org/an-introduction-to-chardev-gpio-and-libgpiod-on-the-raspberry-pi/\"\u003e\u003cstrong\u003eThis excellent article\u003c/strong\u003e\u003c/a\u003e gives a good command-line tutorial of character device GPIO control.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hackaday.com/tag/linux-fu/\"\u003e\u003cstrong\u003eHackaday’s Linux-Fu series\u003c/strong\u003e\u003c/a\u003e has in-depth discussion of various technical userland topics, not just GPIOs.\nMany of these will come in handy when you start to write your own daemon code.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"coming-up\"\u003eComing up\u003c/h2\u003e\n\u003cp\u003eIn the next article I’ll finish the ongoing Buildroot theme by packaging http-gpio for the Raspberry Pi I’ve been working with.\nThis will include some “best practices” for your own packages.\nI’ll also have a deeper discussion of startup scripts and the init system, which I’ll use to start the daemon automatically.\u003c/p\u003e\n\n\u003cp\u003eAs always, you can \u003ca href=\"https://www.thirtythreeforty.net/subscribe/\"\u003esubscribe to my blog\u003c/a\u003e for updates.\nPlease also leave a \u003ca href=\"#commento\"\u003ecomment below\u003c/a\u003e if you have a question or want to point something out that I’ve overlooked.\nI appreciate all the communication I get.\nThanks for reading!\u003c/p\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eI initially called these “system daemons” but that became a non-starter after the proliferation of \u003ca href=\"https://en.wikipedia.org/wiki/Systemd\"\u003esystemd\u003c/a\u003e. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis slightly glosses over the \u003ca href=\"https://www.kernel.org/doc/html/v5.6/driver-api/pinctl.html\"\u003e\u003cem\u003epin controller\u003c/em\u003e\u003c/a\u003e, another peripheral, separate from the GPIO peripheral, which is responsible for steering a pin toward the GPIO, SPI, MMC, or other peripheral.\nThis complication is handled for you when you use the userland GPIO API.\nLater on, I’ll discuss this in more detail when writing a device tree. \u003ca href=\"#fnref:2\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\" role=\"doc-endnote\"\u003e\n\u003cp\u003eQuick war story: at my last job, I foolishly selected Python for a platform daemon that did not need any sort of strong performance guarantees.\nOther developers began adding functionality using dependencies like Flask.\nThese heavy frameworks combined with Python’s anemic performance slowed the platform daemon’s startup time to nearly 45 seconds—embarrassingly slow, even without hard performance requirements.\nIt took more work to speed up the Python than it would have to have written the daemon in Go or Rust to begin with.\nI like Python, but don’t use it for platform daemons. \u003ca href=\"#fnref:3\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\" role=\"doc-endnote\"\u003e\n\u003cp\u003ehttpie is a better curl (pronounced \u003cem\u003eaitch-tee-tee-pie\u003c/em\u003e, command named \u003ccode\u003ehttp\u003c/code\u003e—go figure). In the very common case of passing JSON values in a POST body, it saves \u003cem\u003eso much\u003c/em\u003e typing, and it looks readable in documentation. \u003ca href=\"#fnref:4\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\" role=\"doc-endnote\"\u003e\n\u003cp\u003eIt’s actually possible to provide GPIO names in the device tree, which is the “hardware definition” for Linux.\nDoing the naming there would provide the abstraction for all of userland to use.\nI’d prefer that approach for the specific case of naming GPIOs, but of course in a real platform daemon you’d have more interesting configuration variables. \u003ca href=\"#fnref:5\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2020-05-02T18:30:00-05:00",
  "modifiedTime": "2020-05-02T18:30:00-05:00"
}
