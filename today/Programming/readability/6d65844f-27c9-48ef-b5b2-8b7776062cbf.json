{
  "id": "6d65844f-27c9-48ef-b5b2-8b7776062cbf",
  "title": "Gitpod Flex, Cloud Development after Kubernetes",
  "link": "https://www.infoq.com/news/2024/12/gitpod-kubernetes-flex/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Gitpod, a cloud development environment platform, recently decided to move away from Kubernetes after six years of use and experimentation. This decision emerged from their experience of managing development environments for 1.5 million users, while handling numerous environments daily. By Aditya Kulkarni",
  "author": "Aditya Kulkarni",
  "published": "Sun, 29 Dec 2024 06:30:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Remote Development Environment",
    "Kubernetes",
    "DevOps",
    "news"
  ],
  "byline": "Aditya Kulkarni",
  "length": 5286,
  "excerpt": "Gitpod, a cloud development environment platform, recently decided to move away from Kubernetes after six years of use and experimentation. This decision emerged from their experience of managing deve",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20241210082243/apple-touch-icon.png",
  "text": "Gitpod, a cloud development environment platform, recently decided to move away from Kubernetes after six years of use and experimentation. This decision emerged from their experience of managing development environments for 1.5 million users, while handling numerous environments daily. Christian Weichel, CTO and co-founder, and Alejandro de Brito Fontes, staff engineer at Gitpod, elaborated the journey to this decision in a blog post. Gitpod found that while Kubernetes is well-suited for production workloads, it presents significant challenges when used for development environments.  The nature of development environments also contributed to these challenges. Unlike production workloads, development environments are highly stateful and interactive, with developers deeply involved in their source code and changes. They show unpredictable resource usage patterns and require elaborate permissions and capabilities, often needing root access and the ability to install packages. These factors make development environments different from the typical application workloads and inform Gitpod's infrastructure decisions. Initially, Kubernetes was ideal for Gitpod's infrastructure due to its scalability, container orchestration, and rich ecosystem. However, when they scaled, they encountered numerous challenges, particularly in security and state management. Resource management started posing challenges, with CPU and memory allocation per environment being particularly problematic. The spiky nature of CPU requirements in development environments made it difficult to predict when CPU time would be needed, leading to various experiments with CPU scheduling and prioritization. Storage performance optimization was another critical area of focus. Gitpod experimented with various setups, including SSD RAID 0, block storage, and Persistent Volume Claims (PVCs). Each approach had its trade-offs in terms of performance, reliability, and flexibility. Backing up and restoring local disks proved to be an expensive operation, requiring careful balancing of I/O, network bandwidth, and CPU usage. Autoscaling and startup time optimization were important goals for Gitpod. They explored various approaches to scale up and ahead, including \"ghost workspaces,\" ballast pods, and eventually, cluster-autoscaler plugins. Image pull optimization was another crucial aspect, with Gitpod trying numerous strategies to speed up image pulls, including daemonset pre-pull, layer reuse maximization, and pre-baked images. Networking in Kubernetes introduced its own set of complexities, particularly in terms of development environment access control and network bandwidth sharing. Security and isolation posed significant challenges, as Gitpod needed to provide a secure environment while giving users the flexibility they need for development. They implemented a specific user namespace solution to address these challenges, which involved complex components such as filesystem UID shift, mounting masked proc, and custom network capabilities. There was an interesting conversation on Hacker News related to Gitpod’s journey. One of the HN users, datadeft, referenced the original k8s paper in a response and said, the only use case was a low latency and a high latency workflow combination and the resource allocation is based on that. The generic idea is that you can easily move low latency work between nodes and there are no serios repercussions when a high latency job fails. Based on this information, it is hard to justify to even consider k8s for the problem that gitpod has. In search of better solutions, Gitpod experimented with micro-VM technologies like Firecracker, Cloud Hypervisor, and QEMU. While these offered some promising features like enhanced resource isolation and improved security boundaries, they also introduced new challenges in terms of overhead, image conversion, and technology-specific limitations. Ultimately, Gitpod concluded that achieving their goals with Kubernetes was possible but came at a tradeoff in terms of security and operational overhead. This learning led them to develop a new architecture, Gitpod Flex, which carries over important aspects of Kubernetes such as control theory and declarative APIs while simplifying the architecture and improving the security foundation. Gitpod Flex introduces abstraction layers relating to development environments and eliminates much of the unnecessary infrastructure. This new architecture allows for smooth integration of devcontainers and the ability to run development environments on desktop machines. It can be deployed self-hosted quickly and in any number of regions, providing more control over compliance and flexibility in modeling organizational boundaries. In conclusion, Gitpod's journey highlighted the importance of choosing a system based on its ability to improve developer experience, lower down operational burden, and improve the bottom line, rather than simply choosing between Kubernetes and alternatives. To know more about Gitpod Flex architecture, interested readers can watch this deep-dive session. About the Author Aditya Kulkarni",
  "image": "https://res.infoq.com/news/2024/12/gitpod-kubernetes-flex/en/headerimage/generatedHeaderImage-1735448839639.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eGitpod, a cloud development environment platform, recently decided to move away from Kubernetes after six years of use and experimentation. This decision emerged from their experience of managing development environments for 1.5 million users, while handling numerous environments daily.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.linkedin.com/in/christian-weichel-740b4224/\"\u003eChristian Weichel\u003c/a\u003e, CTO and co-founder, and \u003ca href=\"https://www.linkedin.com/in/aledbf/\"\u003eAlejandro de Brito Fontes\u003c/a\u003e, staff engineer at Gitpod, elaborated the journey to this decision \u003ca href=\"https://www.gitpod.io/blog/we-are-leaving-kubernetes\"\u003ein a blog post\u003c/a\u003e. Gitpod found that while Kubernetes is well-suited for production workloads, it presents significant challenges when used for development environments. \u003c/p\u003e\n\n\u003cp\u003eThe nature of development environments also contributed to these challenges. Unlike production workloads, development environments are highly stateful and interactive, with developers deeply involved in their source code and changes. They show unpredictable resource usage patterns and require elaborate permissions and capabilities, often needing root access and the ability to install packages. These factors make development environments different from the typical application workloads and inform Gitpod\u0026#39;s infrastructure decisions.\u003c/p\u003e\n\n\u003cp\u003eInitially, Kubernetes was ideal for Gitpod\u0026#39;s infrastructure due to its scalability, container orchestration, and rich ecosystem. However, when they scaled, they encountered numerous challenges, particularly in security and state management. Resource management started posing challenges, with CPU and memory allocation per environment being particularly problematic. The spiky nature of CPU requirements in development environments made it difficult to predict when CPU time would be needed, leading to various experiments with CPU scheduling and prioritization.\u003c/p\u003e\n\n\u003cp\u003eStorage performance optimization was another critical area of focus. Gitpod experimented with various setups, including SSD RAID 0, block storage, and Persistent Volume Claims (PVCs). Each approach had its trade-offs in terms of performance, reliability, and flexibility. Backing up and restoring local disks proved to be an expensive operation, requiring careful balancing of I/O, network bandwidth, and CPU usage.\u003c/p\u003e\n\n\u003cp\u003eAutoscaling and startup time optimization were important goals for Gitpod. They explored various approaches to scale up and ahead, including \u0026#34;ghost workspaces,\u0026#34; ballast pods, and eventually, cluster-autoscaler plugins. Image pull optimization was another crucial aspect, with Gitpod trying numerous strategies to speed up image pulls, including daemonset pre-pull, layer reuse maximization, and pre-baked images.\u003c/p\u003e\n\n\u003cp\u003eNetworking in Kubernetes introduced its own set of complexities, particularly in terms of development environment access control and network bandwidth sharing. Security and isolation posed significant challenges, as Gitpod needed to provide a secure environment while giving users the flexibility they need for development. They implemented a specific user namespace solution to address these challenges, which involved complex components such as filesystem UID shift, mounting masked proc, and custom network capabilities.\u003c/p\u003e\n\n\u003cp\u003eThere was an \u003ca href=\"https://news.ycombinator.com/item?id=42041917\"\u003einteresting conversation on Hacker News\u003c/a\u003e related to Gitpod’s journey. One of the HN users, \u003ca href=\"https://news.ycombinator.com/user?id=datadeft\"\u003edatadeft\u003c/a\u003e, referenced the \u003ca href=\"https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43438.pdf\"\u003eoriginal k8s paper\u003c/a\u003e \u003ca href=\"https://news.ycombinator.com/item?id=42042478\"\u003ein a response and said\u003c/a\u003e,\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003ethe only use case was a low latency and a high latency workflow combination and the resource allocation is based on that. The generic idea is that you can easily move low latency work between nodes and there are no serios repercussions when a high latency job fails.\u003c/p\u003e\n\n\u003cp\u003eBased on this information, it is hard to justify to even consider k8s for the problem that gitpod has.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIn search of better solutions, Gitpod experimented with micro-VM technologies like \u003ca href=\"https://github.com/firecracker-microvm/firecracker\"\u003eFirecracker\u003c/a\u003e, \u003ca href=\"https://www.cloudhypervisor.org/\"\u003eCloud Hypervisor\u003c/a\u003e, and \u003ca href=\"https://www.qemu.org/\"\u003eQEMU\u003c/a\u003e. While these offered some promising features like enhanced resource isolation and improved security boundaries, they also introduced new challenges in terms of overhead, image conversion, and technology-specific limitations.\u003c/p\u003e\n\n\u003cp\u003eUltimately, Gitpod concluded that achieving their goals with Kubernetes was possible but came at a tradeoff in terms of security and operational overhead. This learning led them to develop a new architecture, \u003ca href=\"https://www.gitpod.io/blog/introducing-gitpod-flex\"\u003eGitpod Flex\u003c/a\u003e, which carries over important aspects of Kubernetes such as control theory and declarative APIs while simplifying the architecture and improving the security foundation.\u003c/p\u003e\n\n\u003cp\u003eGitpod Flex introduces abstraction layers relating to development environments and eliminates much of the unnecessary infrastructure. This new architecture allows for smooth integration of devcontainers and the ability to run development environments on desktop machines. It can be deployed self-hosted quickly and in any number of regions, providing more control over compliance and flexibility in modeling organizational boundaries.\u003c/p\u003e\n\n\u003cp\u003eIn conclusion, Gitpod\u0026#39;s journey highlighted the importance of choosing a system based on its ability to improve developer experience, lower down operational burden, and improve the bottom line, rather than simply choosing between Kubernetes and alternatives. To know more about Gitpod Flex architecture, interested readers can watch this \u003ca href=\"https://www.gitpod.io/webinars/gitpod-flex-demo\"\u003edeep-dive session\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Aditya-Kulkarni\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eAditya Kulkarni\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-12-29T00:00:00Z",
  "modifiedTime": null
}
