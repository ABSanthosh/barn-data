{
  "id": "17ae693c-9e71-4e1d-9fa9-04f092e88a5e",
  "title": "A Practical Guide to Testing Spring Controllers With MockMvcTester",
  "link": "https://blog.jetbrains.com/idea/2025/04/a-practical-guide-to-testing-spring-controllers-with-mockmvctester/",
  "description": "Spring Framework 6.2 introduced MockMvcTester to support writing AssertJ style assertions using AssertJ under the hood. If you’re using Spring Boot, the spring-boot-starter-test dependency transitively adds the most commonly used testing libraries such as mockito, assertj, json-path, jsonassert, etc. So, if you’re using Spring Boot 3.4.0 (which uses Spring framework 6.2) or any later version, […]",
  "author": "Siva Katamreddy",
  "published": "Tue, 22 Apr 2025 13:22:39 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "java",
    "springboot-2",
    "mockmvc",
    "mockmvctester",
    "spring",
    "testing"
  ],
  "byline": "Siva Katamreddy",
  "length": 13334,
  "excerpt": "Spring Framework 6.2 introduced MockMvcTester to support writing AssertJ style assertions using AssertJ under the hood. If you’re using Spring Boot, the spring-boot-starter-test dependency transiti",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the IDE for Professional Development in Java and Kotlin IntelliJ IDEA JavaA Practical Guide to Testing Spring Controllers With MockMvcTester Spring Framework 6.2 introduced MockMvcTester to support writing AssertJ style assertions using AssertJ under the hood. If you’re using Spring Boot, the spring-boot-starter-test dependency transitively adds the most commonly used testing libraries such as mockito, assertj, json-path, jsonassert, etc. So, if you’re using Spring Boot 3.4.0 (which uses Spring framework 6.2) or any later version, you don’t need to add any extra dependencies to use MockMvcTester. In this article, we’ll explore how you can use MockMvcTester for different testing scenarios. Getting started with MockMvcTester MockMvcTester is built on top of MockMvc and provides AssertJ support for writing tests and asserting the result. You can find the sample application code here. Here is an example test written using MockMvc: import org.springframework.test.web.servlet.MockMvc; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; class UserRestControllerTests { @Autowired MockMvc mockMvc; @Test void getUserByIdSuccessful() throws Exception { mockMvc.perform(get(\"/api/users/1\")).andExpect(status().isOk()); } } The same test written using the MockMvcTester fluent API: import org.springframework.test.web.servlet.assertj.MockMvcTester; import static org.assertj.core.api.Assertions.assertThat; class UserRestControllerTests { @Autowired MockMvcTester mockMvcTester; @Test void getUserByIdSuccessful() { assertThat(mockMvcTester.get().uri(\"/api/users/1\")).hasStatusOk(); } } It is much easier to use the MockMvcTester fluent API rather than using the IDE feature to find the static imports for get(), post(), status(), etc. How to configure MockMvcTester? If you’re writing a slice test for a controller using @WebMvcTest, you can simply inject MockMvcTester. The @WebMvcTest annotation is meta-annotated with @AutoConfigureMockMvc, so a MockMvc instance is auto-configured. If AssertJ is available, then a MockMvcTester instance will also be auto-configured. @WebMvcTest(controllers = UserRestController.class) class UserRestControllerTests { @Autowired MockMvcTester mockMvcTester; //... } If you’re writing an integration test using @SpringBootTest, then you need to add the @AutoConfigureMockMvc annotation to the test class, and you can also inject MockMvcTester. @SpringBootTest @AutoConfigureMockMvc class UserRestControllerTests { @Autowired MockMvcTester mockMvcTester; //... } If you’re already using MockMvc, then you can gradually adopt MockMvcTester by creating a MockMvcTester instance from MockMvc: class UserRestControllerTests { @Autowired MockMvc mockMvc; MockMvcTester mockMvcTester; @PostConstruct void setUp() { mockMvcTester = MockMvcTester.create(mockMvc); } //... } Writing tests using MockMvcTester Let’s explore how we can write tests using MockMvcTester in various scenarios. Testing REST API JSON response Assume we have a REST API endpoint for user registration that returns HTTP code 201 when successful, along with the response JSON payload with name, email, and role properties. We can write a test using MockMvcTester: import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.test.web.servlet.assertj.MockMvcTester; import org.springframework.test.web.servlet.assertj.MvcTestResult; import static org.assertj.core.api.Assertions.assertThat; @Test void userRegistrationSuccessful() { String requestBody = \"\"\" { \"email\": \"siva@gmail.com\", \"password\": \"secret\", \"name\": \"Siva\" } \"\"\"; assertThat(mockMvcTester .post() .uri(\"/api/users\") .contentType(MediaType.APPLICATION_JSON) .content(requestBody)) .hasStatus(HttpStatus.CREATED) .bodyJson() .isLenientlyEqualTo(\"\"\" { \"name\": \"Siva\", \"email\": \"siva@gmail.com\", \"role\": \"ROLE_USER\" } \"\"\"); } We have compared the HTTP status code, converted the response body to JSON, and compared it with our expected JSON structure. We can split the code into two parts to execute the request and assert the result: MvcTestResult testResult = mockMvcTester .post() .uri(\"/api/users\") .contentType(MediaType.APPLICATION_JSON) .content(requestBody) .exchange(); assertThat(testResult) .hasStatus(HttpStatus.CREATED) .bodyJson() .isLenientlyEqualTo(\"\"\" { \"name\": \"Siva\", \"email\": \"siva@gmail.com\", \"role\": \"ROLE_USER\" } \"\"\"); So far, we have compared the response JSON with our expected JSON structure using a multiline string. Instead, we can also store the JSON as a classpath resource and compare them: var expected = new ClassPathResource(\"/user-registration-response.json\", UserRestControllerTests.class); assertThat(testResult) .hasStatus(HttpStatus.CREATED) .bodyJson() .isLenientlyEqualTo(expected); If you need more control over the response body assertions, you can map the response into a Java object and assert it: public record RegistrationResponse(String name, String email, String role) {} assertThat(testResult) .hasStatus(HttpStatus.CREATED) .bodyJson() .convertTo(RegistrationResponse.class) .satisfies(response -\u003e { assertThat(response.name()).isEqualTo(\"Siva\"); assertThat(response.email()).isEqualTo(\"siva@gmail.com\"); assertThat(response.role()).isEqualTo(\"ROLE_USER\"); }); Testing REST API exception handling scenarios It is common practice to use @RestControllerAdvice to handle exceptions centrally: import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.RestControllerAdvice; @RestControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(UserAlreadyExistsException.class) public ResponseEntity\u003cObject\u003e handle(UserAlreadyExistsException e) { var error = e.getMessage(); return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error); } // more handler methods } For user registration, we check the existence of the given email in the database and throw UserAlreadyExistsException if the email already exists. The GlobalExceptionHandler will handle this exception and return the appropriate response. We can write a test to handle this scenario using MockMvcTester: @Test void shouldFailToRegisterWithExistingEmail() { String requestBody = \"\"\" { \"email\": \"admin@gmail.com\", \"password\": \"secret\", \"name\": \"Administrator\" } \"\"\"; MvcTestResult testResult = mockMvcTester.post() .uri(\"/api/users\") .contentType(MediaType.APPLICATION_JSON) .content(requestBody) .exchange(); assertThat(testResult) .failure() .isInstanceOf(UserAlreadyExistsException.class) .hasMessage(\"User with email admin@gmail.com already exists\"); } We have asserted that there is a failure with a specific exception type and the expected error message. Testing the Thymeleaf view rendering controllers We can write tests for controllers that handle the request and render a view, such as a Thymeleaf view template. Let’s say we have a controller with two handler methods: import jakarta.validation.Valid; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.servlet.mvc.support.RedirectAttributes; @Controller public class UserController { private final UserRepository userRepository; public UserController(UserRepository userRepository) { this.userRepository = userRepository; } @GetMapping(\"/users/{id}\") public String getUserById(@PathVariable Long id, Model model) { var user = userRepository.findById(id); if (user != null) { model.addAttribute(\"user\", user); return \"user\"; } return \"not-found\"; } @PostMapping(\"/users\") public String createUser(@ModelAttribute(\"user\") @Valid User user, BindingResult bindingResult, RedirectAttributes redirectAttributes) { userRepository.create(user); if (bindingResult.hasErrors()) { return \"create-user\"; } redirectAttributes.addFlashAttribute(\"successMessage\", \"User saved successfully\"); return \"redirect:/users\"; } } Let’s write the first test to invoke GET users/{id} and assert the HTTP status code and the model data: @Test void shouldGetUserById() { var result = mockMvcTester.get().uri(\"/users/1\").exchange(); assertThat(result) .hasStatusOk() .hasViewName(\"user\") .model() .containsKeys(\"user\") .containsEntry(\"user\", new User(1L, \"Siva\", \"siva@gmail.com\", \"siva\")); } Here, we assert the expected view name, model attribute name to be user, and the user object data. Testing URL redirects and flash attributes Let’s write a test to verify the successful scenario of creating a user with valid data: @Test void shouldCreateUserSuccessfully() { var result = mockMvcTester.post().uri(\"/users\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .param(\"name\", \"Test User 4\") .param(\"email\", \"testuser4@gmail.com\") .param(\"password\", \"testuser4\") .exchange(); assertThat(result) .hasStatus(HttpStatus.FOUND) .hasRedirectedUrl(\"/users\") .flash().containsKey(\"successMessage\") .hasEntrySatisfying(\"successMessage\", value -\u003e assertThat(value).isEqualTo(\"User saved successfully\")); } We have submitted the form with valid data and asserted the expected behavior that the user will be redirected to the new URL /users with a successMessage flash attribute. Testing model validation errors When a form is submitted with invalid data, we usually redisplay the form with error messages. Let’s see how we can test the form field validation errors: @Test void shouldGetErrorsWhenUserDataIsInvalid() { var result = mockMvcTester.post().uri(\"/users\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .param(\"name\", \"\") // blank -invalid .param(\"email\", \"testuser4gmail.com\") // invalid email format .param(\"password\", \"pwd\") // valid .exchange(); assertThat(result) .model() .extractingBindingResult(\"user\") .hasErrorsCount(2) .hasFieldErrors(\"name\", \"email\"); } Here, we have submitted the form with invalid values for the name and email fields and asserted the expected error details. Similarly, you can assert the expected headers, cookies, multipart requests, etc. Summary As you have seen in this article, MockMvcTester helps you to write tests using a fluent API and provides many custom assertions to verify the results more expressively. To learn more about MockMvcTester, you can check out the official documentation here. If you’re using Spring Boot 3.4.0 or a later version, you can start using MockMvcTester to write more expressive tests using a fluent API. If you’re using an older version, then MockMvcTester could be a solid reason to consider upgrading! Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/A-Practical-Guide-to-Testing-Spring-Controllers-With-MockMvcTester_social.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/idea/category/java/\"\u003eJava\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eA Practical Guide to Testing Spring Controllers With MockMvcTester\u003c/h2\u003e                    \n                    \n\u003cp\u003eSpring Framework 6.2 introduced \u003ccode\u003eMockMvcTester\u003c/code\u003e to support writing \u003ca href=\"https://assertj.github.io/doc/\" target=\"_blank\" rel=\"noopener\"\u003eAssertJ\u003c/a\u003e style assertions using AssertJ under the hood.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’re using Spring Boot, the \u003ccode\u003espring-boot-starter-test\u003c/code\u003e dependency transitively adds the most commonly used testing libraries such as \u003ccode\u003emockito\u003c/code\u003e, \u003ccode\u003eassertj\u003c/code\u003e, \u003ccode\u003ejson-path\u003c/code\u003e, \u003ccode\u003ejsonassert\u003c/code\u003e, etc. So, if you’re using Spring Boot 3.4.0 (which uses Spring framework 6.2) or any later version, you don’t need to add any extra dependencies to use \u003ccode\u003eMockMvcTester\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this article, we’ll explore how you can use \u003ccode\u003eMockMvcTester\u003c/code\u003e for different testing scenarios.\u003c/p\u003e\n\n\n\n\u003ch2\u003eGetting started with MockMvcTester\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eMockMvcTester\u003c/code\u003e is built on top of \u003ccode\u003eMockMvc\u003c/code\u003e and provides AssertJ support for writing tests and asserting the result.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eYou can find the sample application code \u003c/strong\u003e\u003ca href=\"https://github.com/sivaprasadreddy/spring-mockmvctester-demo\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003ehere\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e.\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is an example test written using \u003ccode\u003eMockMvc\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport org.springframework.test.web.servlet.MockMvc;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\nclass UserRestControllerTests {\n   @Autowired\n   MockMvc mockMvc;\n\n   @Test\n   void getUserByIdSuccessful() throws Exception {\n       mockMvc.perform(get(\u0026#34;/api/users/1\u0026#34;)).andExpect(status().isOk());\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe same test written using the \u003ccode\u003eMockMvcTester\u003c/code\u003e fluent API:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport org.springframework.test.web.servlet.assertj.MockMvcTester;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass UserRestControllerTests {\n   @Autowired\n   MockMvcTester mockMvcTester;\n\n   @Test\n   void getUserByIdSuccessful() {\n      assertThat(mockMvcTester.get().uri(\u0026#34;/api/users/1\u0026#34;)).hasStatusOk();\n   }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eIt is much easier to use the \u003ccode\u003eMockMvcTester\u003c/code\u003e fluent API rather than using the IDE feature to find the static imports for \u003ccode\u003eget()\u003c/code\u003e, \u003ccode\u003epost()\u003c/code\u003e, \u003ccode\u003estatus()\u003c/code\u003e, etc.\u003c/p\u003e\n\n\n\n\u003ch3\u003eHow to configure MockMvcTester?\u003c/h3\u003e\n\n\n\n\u003cp\u003eIf you’re writing a slice test for a controller using \u003ccode\u003e@WebMvcTest\u003c/code\u003e, you can simply inject \u003ccode\u003eMockMvcTester\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e@WebMvcTest\u003c/code\u003e annotation is meta-annotated with \u003ccode\u003e@AutoConfigureMockMvc\u003c/code\u003e, so a \u003ccode\u003eMockMvc\u003c/code\u003e instance is auto-configured. If AssertJ is available, then a \u003ccode\u003eMockMvcTester\u003c/code\u003e instance will also be auto-configured.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@WebMvcTest(controllers = UserRestController.class)\nclass UserRestControllerTests {\n   @Autowired\n   MockMvcTester mockMvcTester;\n\n   //...\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you’re writing an integration test using \u003ccode\u003e@SpringBootTest\u003c/code\u003e, then you need to add the \u003ccode\u003e@AutoConfigureMockMvc\u003c/code\u003e annotation to the test class, and you can also inject \u003ccode\u003eMockMvcTester\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@SpringBootTest\n@AutoConfigureMockMvc\nclass UserRestControllerTests {\n   @Autowired\n   MockMvcTester mockMvcTester;\n\n   //...\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you’re already using \u003ccode\u003eMockMvc\u003c/code\u003e, then you can gradually adopt \u003ccode\u003eMockMvcTester\u003c/code\u003e by creating a \u003ccode\u003eMockMvcTester\u003c/code\u003e instance from \u003ccode\u003eMockMvc\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eclass UserRestControllerTests {\n   @Autowired\n   MockMvc mockMvc;\n\n   MockMvcTester mockMvcTester;\n\n   @PostConstruct\n   void setUp() {\n       mockMvcTester = MockMvcTester.create(mockMvc);\n   }\n\n   //...\n}\u003c/pre\u003e\n\n\n\n\u003ch2\u003eWriting tests using MockMvcTester\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s explore how we can write tests using \u003ccode\u003eMockMvcTester\u003c/code\u003e in various scenarios.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTesting REST API JSON response\u003c/h3\u003e\n\n\n\n\u003cp\u003eAssume we have a REST API endpoint for user registration that returns HTTP code 201 when successful, along with the response JSON payload with \u003ccode\u003ename\u003c/code\u003e, \u003ccode\u003eemail\u003c/code\u003e, and \u003ccode\u003erole\u003c/code\u003e properties.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can write a test using \u003ccode\u003eMockMvcTester\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.assertj.MockMvcTester;\nimport org.springframework.test.web.servlet.assertj.MvcTestResult;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@Test\nvoid userRegistrationSuccessful() {\n   String requestBody = \u0026#34;\u0026#34;\u0026#34;\n           {\n               \u0026#34;email\u0026#34;: \u0026#34;siva@gmail.com\u0026#34;,\n               \u0026#34;password\u0026#34;: \u0026#34;secret\u0026#34;,\n               \u0026#34;name\u0026#34;: \u0026#34;Siva\u0026#34;\n           }\n           \u0026#34;\u0026#34;\u0026#34;;\n\n   assertThat(mockMvcTester\n       \t.post()\n       \t.uri(\u0026#34;/api/users\u0026#34;)\n       \t.contentType(MediaType.APPLICATION_JSON)\n       \t.content(requestBody))\n        .hasStatus(HttpStatus.CREATED)\n        .bodyJson()\n        .isLenientlyEqualTo(\u0026#34;\u0026#34;\u0026#34;\n             {\n               \u0026#34;name\u0026#34;: \u0026#34;Siva\u0026#34;,\n               \u0026#34;email\u0026#34;: \u0026#34;siva@gmail.com\u0026#34;,\n               \u0026#34;role\u0026#34;: \u0026#34;ROLE_USER\u0026#34;\n             }\n          \u0026#34;\u0026#34;\u0026#34;);\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have compared the HTTP status code, converted the response body to JSON, and compared it with our expected JSON structure.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can split the code into two parts to execute the request and assert the result:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eMvcTestResult testResult = mockMvcTester\n       .post()\n       .uri(\u0026#34;/api/users\u0026#34;)\n       .contentType(MediaType.APPLICATION_JSON)\n       .content(requestBody)\n       .exchange();\n\nassertThat(testResult)\n       .hasStatus(HttpStatus.CREATED)\n       .bodyJson()\n       .isLenientlyEqualTo(\u0026#34;\u0026#34;\u0026#34;\n           {\n              \u0026#34;name\u0026#34;: \u0026#34;Siva\u0026#34;,\n              \u0026#34;email\u0026#34;: \u0026#34;siva@gmail.com\u0026#34;,\n              \u0026#34;role\u0026#34;: \u0026#34;ROLE_USER\u0026#34;\n           }\n         \u0026#34;\u0026#34;\u0026#34;);\u003c/pre\u003e\n\n\n\n\u003cp\u003eSo far, we have compared the response JSON with our expected JSON structure using a multiline string. Instead, we can also store the JSON as a classpath resource and compare them:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003evar expected = new ClassPathResource(\u0026#34;/user-registration-response.json\u0026#34;, UserRestControllerTests.class);\n\nassertThat(testResult)\n       .hasStatus(HttpStatus.CREATED)\n       .bodyJson()\n       .isLenientlyEqualTo(expected);\u003c/pre\u003e\n\n\n\n\u003cp\u003eIf you need more control over the response body assertions, you can map the response into a Java object and assert it:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epublic record RegistrationResponse(String name, String email, String role) {}\n\nassertThat(testResult)\n       .hasStatus(HttpStatus.CREATED)\n       .bodyJson()\n       .convertTo(RegistrationResponse.class)\n       .satisfies(response -\u0026gt; {\n           assertThat(response.name()).isEqualTo(\u0026#34;Siva\u0026#34;);\n           assertThat(response.email()).isEqualTo(\u0026#34;siva@gmail.com\u0026#34;);\n           assertThat(response.role()).isEqualTo(\u0026#34;ROLE_USER\u0026#34;);\n       });\u003c/pre\u003e\n\n\n\n\u003ch3\u003eTesting REST API exception handling scenarios\u003c/h3\u003e\n\n\n\n\u003cp\u003eIt is common practice to use \u003ccode\u003e@RestControllerAdvice\u003c/code\u003e to handle exceptions centrally:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n   @ExceptionHandler(UserAlreadyExistsException.class)\n   public ResponseEntity\u0026lt;Object\u0026gt; handle(UserAlreadyExistsException e) {\n       var error = e.getMessage();\n       return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);\n   }\n\n   // more handler methods\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor user registration, we check the existence of the given email in the database and throw \u003ccode\u003eUserAlreadyExistsException\u003c/code\u003e if the email already exists. The \u003ccode\u003eGlobalExceptionHandler\u003c/code\u003e will handle this exception and return the appropriate response.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe can write a test to handle this scenario using \u003ccode\u003eMockMvcTester\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@Test\nvoid shouldFailToRegisterWithExistingEmail() {\n   String requestBody = \u0026#34;\u0026#34;\u0026#34;\n           {\n               \u0026#34;email\u0026#34;: \u0026#34;admin@gmail.com\u0026#34;,\n               \u0026#34;password\u0026#34;: \u0026#34;secret\u0026#34;,\n               \u0026#34;name\u0026#34;: \u0026#34;Administrator\u0026#34;\n           }\n           \u0026#34;\u0026#34;\u0026#34;;\n\n   MvcTestResult testResult = mockMvcTester.post()\n           .uri(\u0026#34;/api/users\u0026#34;)\n           .contentType(MediaType.APPLICATION_JSON)\n           .content(requestBody)\n           .exchange();\n\n   assertThat(testResult)\n           .failure()\n           .isInstanceOf(UserAlreadyExistsException.class)\n           .hasMessage(\u0026#34;User with email admin@gmail.com already exists\u0026#34;);\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have asserted that there is a failure with a specific exception type and the expected error message.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTesting the \u003cem\u003eThymeleaf\u003c/em\u003e view rendering controllers\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe can write tests for controllers that handle the request and render a view, such as a Thymeleaf view template.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s say we have a controller with two handler methods:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport jakarta.validation.Valid;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\n@Controller\npublic class UserController {\n   private final UserRepository userRepository;\n   public UserController(UserRepository userRepository) {\n       this.userRepository = userRepository;\n   }\n\n   @GetMapping(\u0026#34;/users/{id}\u0026#34;)\n   public String getUserById(@PathVariable Long id, Model model) {\n       var user = userRepository.findById(id);\n       if (user != null) {\n           model.addAttribute(\u0026#34;user\u0026#34;, user);\n           return \u0026#34;user\u0026#34;;\n       }\n       return \u0026#34;not-found\u0026#34;;\n   }\n\n   @PostMapping(\u0026#34;/users\u0026#34;)\n   public String createUser(@ModelAttribute(\u0026#34;user\u0026#34;) @Valid User user,\n                            BindingResult bindingResult,\n                            RedirectAttributes redirectAttributes) {\n       userRepository.create(user);\n       if (bindingResult.hasErrors()) {\n           return \u0026#34;create-user\u0026#34;;\n       }\n       redirectAttributes.addFlashAttribute(\u0026#34;successMessage\u0026#34;, \u0026#34;User saved successfully\u0026#34;);\n       return \u0026#34;redirect:/users\u0026#34;;\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eLet’s write the first test to invoke \u003ccode\u003eGET users/{id}\u003c/code\u003e and assert the HTTP status code and the model data:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@Test\nvoid shouldGetUserById() {\n   var result = mockMvcTester.get().uri(\u0026#34;/users/1\u0026#34;).exchange();\n\n   assertThat(result)\n           .hasStatusOk()\n           .hasViewName(\u0026#34;user\u0026#34;)\n           .model()\n           \t.containsKeys(\u0026#34;user\u0026#34;)\n           \t.containsEntry(\u0026#34;user\u0026#34;, new User(1L, \u0026#34;Siva\u0026#34;, \u0026#34;siva@gmail.com\u0026#34;, \u0026#34;siva\u0026#34;));\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere, we assert the expected view name, model attribute name to be \u003ccode\u003euser\u003c/code\u003e, and the user object data.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTesting URL redirects and flash attributes\u003c/h3\u003e\n\n\n\n\u003cp\u003eLet’s write a test to verify the successful scenario of creating a user with valid data:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@Test\nvoid shouldCreateUserSuccessfully() {\n   var result = mockMvcTester.post().uri(\u0026#34;/users\u0026#34;)\n           .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n           .param(\u0026#34;name\u0026#34;, \u0026#34;Test User 4\u0026#34;)\n           .param(\u0026#34;email\u0026#34;, \u0026#34;testuser4@gmail.com\u0026#34;)\n           .param(\u0026#34;password\u0026#34;, \u0026#34;testuser4\u0026#34;)\n           .exchange();\n\n   assertThat(result)\n           .hasStatus(HttpStatus.FOUND)\n           .hasRedirectedUrl(\u0026#34;/users\u0026#34;)\n           .flash().containsKey(\u0026#34;successMessage\u0026#34;)\n           .hasEntrySatisfying(\u0026#34;successMessage\u0026#34;,\n                   value -\u0026gt; assertThat(value).isEqualTo(\u0026#34;User saved successfully\u0026#34;));\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe have submitted the form with valid data and asserted the expected behavior that the user will be redirected to the new URL \u003ccode\u003e/users\u003c/code\u003e with a \u003ccode\u003esuccessMessage\u003c/code\u003e flash attribute.\u003c/p\u003e\n\n\n\n\u003ch3\u003eTesting model validation errors\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhen a form is submitted with invalid data, we usually redisplay the form with error messages.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s see how we can test the form field validation errors:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"java\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@Test\nvoid shouldGetErrorsWhenUserDataIsInvalid() {\n   var result = mockMvcTester.post().uri(\u0026#34;/users\u0026#34;)\n           .contentType(MediaType.APPLICATION_FORM_URLENCODED)\n           .param(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;) // blank -invalid\n           .param(\u0026#34;email\u0026#34;, \u0026#34;testuser4gmail.com\u0026#34;) // invalid email format\n           .param(\u0026#34;password\u0026#34;, \u0026#34;pwd\u0026#34;) // valid\n           .exchange();\n\n   assertThat(result)\n           .model()\n           .extractingBindingResult(\u0026#34;user\u0026#34;)\n           .hasErrorsCount(2)\n           .hasFieldErrors(\u0026#34;name\u0026#34;, \u0026#34;email\u0026#34;);\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere, we have submitted the form with invalid values for the \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eemail\u003c/code\u003e fields and asserted the expected error details.\u003c/p\u003e\n\n\n\n\u003cp\u003eSimilarly, you can assert the expected headers, cookies, multipart requests, etc.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs you have seen in this article, \u003ccode\u003eMockMvcTester\u003c/code\u003e helps you to write tests using a fluent API and provides many custom assertions to verify the results more expressively.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo learn more about \u003ccode\u003eMockMvcTester\u003c/code\u003e, you can check out the official documentation \u003ca href=\"https://docs.spring.io/spring-framework/reference/testing/mockmvc/assertj.html\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’re using Spring Boot 3.4.0 or a later version, you can start using \u003ccode\u003eMockMvcTester\u003c/code\u003e to write more expressive tests using a fluent API. If you’re using an older version, then \u003ccode\u003eMockMvcTester\u003c/code\u003e could be a solid reason to consider upgrading!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": null,
  "modifiedTime": null
}
