{
  "id": "1610e936-57ef-45c3-9903-80fe10b86692",
  "title": "A Hidden Benefit of Implicit Joins: Join Elimination",
  "link": "https://blog.jooq.org/a-hidden-benefit-of-implicit-joins-join-elimination/",
  "description": "One of jOOQ’s key features so far has always been to render pretty much exactly the SQL that users expect, without any surprises – unless some emulation is required to make a query work, of course. This means that while join elimination is a powerful feature of many RDBMS, it isn’t part of jOOQ’s feature … Continue reading A Hidden Benefit of Implicit Joins: Join Elimination →",
  "author": "lukaseder",
  "published": "Wed, 10 Jan 2024 14:19:00 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-in-use",
    "implicit joins",
    "implicit path join",
    "java",
    "JOIN elimination",
    "jooq",
    "many-to-many joins",
    "sql",
    "to-many joins"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 2956,
  "excerpt": "Starting with jOOQ 3.19, implicit path joins may skip unnecessary tables in the join tree, when no columns are referenced from those tables",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "One of jOOQ’s key features so far has always been to render pretty much exactly the SQL that users expect, without any surprises – unless some emulation is required to make a query work, of course. This means that while join elimination is a powerful feature of many RDBMS, it isn’t part of jOOQ’s feature set, so far. This changes, to some extent, with jOOQ 3.19, and #14992, for implicit path joins only. So far, when you write: ctx.select(ACTOR, ACTOR.film().category().NAME) .from(ACTOR) .fetch(); The resulting join tree of this query may look similar to this: FROM actor LEFT JOIN film_actor ON actor.actor_id = film_actor.actor_id LEFT JOIN film ON film_actor.film_id = film.film_id LEFT JOIN film_category ON film.film_id = film_category.film_id LEFT JOIN category ON film_category.category_id = category.category_id But, the FILM table isn’t really needed in this particular query, because no columns from it are being projected, and the presence of primary / foreign keys guarantees equivalence if we just skip the table in the join tree: FROM actor LEFT JOIN film_actor ON actor.actor_id = film_actor.actor_id LEFT JOIN film_category ON film_actor.film_id = film_category.film_id LEFT JOIN category ON film_category.category_id = category.category_id As soon as any column from the FILM table is projected (or referenced, in general), then the table re-appears in the join tree. E.g. for this query: ctx.select(ACTOR, ACTOR.film().category().NAME) .from(ACTOR) // This means we have to add the FILM table again to the join tree: .where(ACTOR.film().TITLE.like(\"A%\")) .fetch(); In many RDBMS, this doesn’t really matter, because the RDBMS may do the same optimisation, but in some, there’s a big difference. This is a great optimisation in particular because with implicit path joins, jOOQ users can’t really hand-write these optimisations as they’re not authoring the join tree in the FROM clause themselves. Why implement this only in jOOQ 3.19 Before jOOQ 3.19, there was no support for to-many path joins, and particularly, not for many-to-many path joins, which skip the relationship table. But now, users can write: // This ACTOR.film().category().NAME // Is short (and equivalent) for this: ACTOR.filmActor().film().filmCategory().category().NAME Note that the above examples assume that the new Settings.renderImplicitJoinToManyType flag is set to LEFT_JOIN. By default, implicit to-many joins aren’t supported because of their weird semantics in terms of query cardinalities as explained in this blog post. By default, such paths have to be declared explicitly in the FROM clause: ctx.select(ACTOR, ACTOR.film().category().NAME) .from( ACTOR, ACTOR.film(), ACTOR.film().category()) .fetch(); Or, just: ctx.select(ACTOR, ACTOR.film().category().NAME) .from( ACTOR, ACTOR.film().category()) .fetch();",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12332\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eOne of jOOQ’s key features so far has always been to render pretty much exactly the SQL that users expect, without any surprises – unless some emulation is required to make a query work, of course. This means that while \u003ca href=\"https://blog.jooq.org/10-cool-sql-optimisations-that-do-not-depend-on-the-cost-model/\" data-type=\"link\" data-id=\"https://blog.jooq.org/10-cool-sql-optimisations-that-do-not-depend-on-the-cost-model/\"\u003ejoin elimination is a powerful feature of many RDBMS\u003c/a\u003e, it isn’t part of jOOQ’s feature set, so far.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis changes, to some extent, with jOOQ 3.19, and \u003ca href=\"https://github.com/jOOQ/jOOQ/issues/14992\" data-type=\"link\" data-id=\"https://github.com/jOOQ/jOOQ/issues/14992\"\u003e#14992\u003c/a\u003e, for \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/select-statement/implicit-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/select-statement/implicit-join/\"\u003eimplicit path joins\u003c/a\u003e only. So far, when you write:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR, ACTOR.film().category().NAME)\n   .from(ACTOR)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe resulting join tree of this query may look similar to this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eFROM\n  actor\n    LEFT JOIN film_actor ON actor.actor_id = film_actor.actor_id\n    LEFT JOIN film ON film_actor.film_id = film.film_id\n    LEFT JOIN film_category ON film.film_id = film_category.film_id\n    LEFT JOIN category ON film_category.category_id = category.category_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBut, the \u003ccode\u003eFILM\u003c/code\u003e table isn’t really needed in this particular query, because no columns from it are being projected, and the presence of primary / foreign keys guarantees equivalence if we just skip the table in the join tree:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eFROM\n  actor\n    LEFT JOIN film_actor ON actor.actor_id = film_actor.actor_id\n    LEFT JOIN film_category ON film_actor.film_id = film_category.film_id\n    LEFT JOIN category ON film_category.category_id = category.category_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAs soon as any column from the \u003ccode\u003eFILM\u003c/code\u003e table is projected (or referenced, in general), then the table re-appears in the join tree. E.g. for this query:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR, ACTOR.film().category().NAME)\n   .from(ACTOR)\n   // This means we have to add the FILM table again to the join tree:\n   .where(ACTOR.film().TITLE.like(\u0026#34;A%\u0026#34;))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIn many RDBMS, this doesn’t really matter, because the RDBMS may do the same optimisation, but in some, there’s a big difference. This is a great optimisation in particular because with implicit path joins, jOOQ users can’t really hand-write these optimisations as they’re not authoring the join tree in the \u003ccode\u003eFROM\u003c/code\u003e clause themselves.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhy implement this only in jOOQ 3.19\u003c/h3\u003e\n\n\n\n\u003cp\u003eBefore jOOQ 3.19, there was no support for \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\"\u003e\u003ccode\u003eto-many\u003c/code\u003e path joins\u003c/a\u003e, and particularly, not for \u003ccode\u003emany-to-many\u003c/code\u003e path joins, which skip the relationship table. \u003ca href=\"https://blog.jooq.org/jooq-3-19s-new-explicit-and-implicit-to-many-path-joins/\" data-type=\"link\" data-id=\"https://blog.jooq.org/jooq-3-19s-new-explicit-and-implicit-to-many-path-joins/\"\u003eBut now, users can write\u003c/a\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// This\nACTOR.film().category().NAME\n\n// Is short (and equivalent) for this:\nACTOR.filmActor().film().filmCategory().category().NAME\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNote that the above examples assume that the new \u003ccode\u003eSettings.renderImplicitJoinToManyType\u003c/code\u003e flag is set to \u003ccode\u003eLEFT_JOIN\u003c/code\u003e. By default, implicit \u003ccode\u003eto-many\u003c/code\u003e joins aren’t supported because of their weird semantics in terms of query cardinalities as explained in this blog post. By default, such paths have to be declared explicitly in the \u003ccode\u003eFROM\u003c/code\u003e clause:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR, ACTOR.film().category().NAME)\n   .from(\n       ACTOR,\n       ACTOR.film(),\n       ACTOR.film().category())\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr, just:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR, ACTOR.film().category().NAME)\n   .from(\n       ACTOR,\n       ACTOR.film().category())\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-01-10T14:19:00Z",
  "modifiedTime": "2023-12-13T15:43:01Z"
}
