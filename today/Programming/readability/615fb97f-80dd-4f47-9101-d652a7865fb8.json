{
  "id": "615fb97f-80dd-4f47-9101-d652a7865fb8",
  "title": "Advancing Our Chef Infrastructure",
  "link": "https://slack.engineering/advancing-our-chef-infrastructure/",
  "description": "At Slack, we manage tens of thousands of EC2 instances that host a variety of services, including our Vitess databases, Kubernetes workers, and various components of the Slack application. The majority of these instances run on some version of Ubuntu, while a portion operates on Amazon Linux. With such a vast infrastructure, the critical question […] The post Advancing Our Chef Infrastructure appeared first on Slack Engineering.",
  "author": "Archie Gunasekara",
  "published": "Tue, 17 Sep 2024 07:00:57 +0000",
  "source": "https://slack.engineering/feed",
  "categories": [
    "Uncategorized",
    "aws",
    "infrastructure"
  ],
  "byline": "Archie Gunasekara Staff Software Engineer, Cloud",
  "length": 18023,
  "excerpt": "At Slack, we manage tens of thousands of EC2 instances that host a variety of services, including our Vitess databases, Kubernetes workers, and various components of the Slack application. The majority of these instances run on some version of Ubuntu, while a portion operates on Amazon Linux. With such a vast infrastructure, the critical question …",
  "siteName": "Slack Engineering",
  "favicon": "https://slack.engineering/wp-content/uploads/sites/7/2020/05/cropped-octothrope-1.png?w=192",
  "text": "At Slack, we manage tens of thousands of EC2 instances that host a variety of services, including our Vitess databases, Kubernetes workers, and various components of the Slack application. The majority of these instances run on some version of Ubuntu, while a portion operates on Amazon Linux. With such a vast infrastructure, the critical question arises: how do we efficiently provision these instances and deploy changes across them? The solution lies in a combination of internally-developed services, with Chef playing a central role. In this blog post, I’ll discuss the evolution of our Chef infrastructure over the years and the challenges we encountered along the way. A journey down memory lane: our previous process In the early days of Slack, we relied on a single Chef stack. Our Chef infrastructure included a set of EC2 instances, an AWS application load balancer, an RDS cluster, and an AWS OpenSearch cluster. As our fleet of instances started to grow, we scaled up and out this stack to match our increasing demand. We had three environments on this Chef stack: Sandbox, Dev, and Prod. Nodes from each environment in our fleet were mapped to one of these environments. Slack has two types of cookbooks: cookbooks we download from the Chef Supermarket and the ones that are internally created. When these cookbooks are modified, we upload them using a process called DishPig. When a change is merged to our repo, we triggered a CI job to look for any changes to the cookbooks or roles and built an artifact with this. Then this artifact gets uploaded to a S3 bucket and then from this S3 bucket, we notify an SQS queue. We triggered the DishPig process on the top of each hour to look for any new messages in the queue. When DishPig detected a new event in the queue, it downloaded the artifact and uploaded the changed cookbooks to the Chef server. We upload the cookbooks we take from the supermarket with their own version, but we will always upload the cookbooks we create with a fixed version number. Therefore we did not have multiple versions of the cookbooks we created and only a single version of them were available on the Chef server. Once the cookbooks were uploaded to the Chef server, all three environments were updated to include the latest versions of the Supermarket cookbooks. Since we are uploading our own cookbooks with the same version, their references in the environments did not need updating. With this approach, all our environments got the changes on the hour. We also provided tooling that allowed developers to create custom Chef environments with specific versions of cookbooks, enabling them to test their changes on a small set of nodes within a temporary environment. Once testing was complete, the tooling would automatically clean up the temporary environment and remove the custom cookbook versions. This approach had a few significant drawbacks: all changes were deployed across all environments simultaneously. This meant that any faulty changes could potentially disrupt all existing Chef runs and new server provisions across our entire infrastructure. Relying on a single Chef stack also meant that any issues with this stack could have widespread effects, potentially impacting our entire infrastructure. Transitioning to a sharded Chef infrastructure As our infrastructure grew rapidly, ensuring guaranteed reliability became a top priority. We recognized that relying on a single Chef stack posed a significant risk, as it was a major single point of failure. To address this, we began redesigning our Chef infrastructure, starting by eliminating our dependence on a single Chef stack. We decided to create multiple Chef stacks to distribute the load more effectively and ensure resilience. This approach also gave us the flexibility to direct new provisions to the remaining operational Chef stacks if one were to fail. However, implementing this new strategy introduced several challenges. Let’s explore the most significant ones. Challenge 1: Assigning a shard to a node Our first step was to find a method for directing new provisions to specific shards. We achieved this using an AWS Route53 Weighted CNAME record. When an instance spins up, it queries the CNAME record and, based on the assigned weight, receives a record from the set. This record then determines which Chef stack the instance will be assigned to. Additionally, as illustrated below, we separated the development and production Chef infrastructure into distinct stacks. This segregation helps strengthen the boundary between our development and production environments. Challenge 2: Neighborhood discovery Historically, Slack lacked a dedicated EC2 inventory management system, and our Chef stack was the closest alternative. As a result, teams began querying the Chef server whenever they needed information about specific instances in the fleet. They would use Chef search to locate nodes based on criteria, such as nodes with a particular Chef role in a specific AWS region. This approach worked well until we moved to a sharded Chef infrastructure. With the new setup, running the same query would only return nodes from the specific Chef stack you queried. Since nodes are now distributed across multiple Chef stacks, this method no longer provides a complete view of all instances. Let’s take a step back and look at how a Chef run operates. A Chef run consists of two phases: compile and converge. During the compile phase, Chef collects information about its run lists, reads all its cookbooks, assigns variables, creates attributes, and maps out the resources it needs to create. In the converge phase, Chef then creates those resources based on the information gathered in the compile phase. Some of our cookbooks were designed to create attributes and variables based on the results from Chef searches. With the transition to sharded Chef stacks, we needed to find an alternative to these node discovery methods. After considering our options, we decided to leverage an existing service at Slack: Consul. We began registering certain services in Consul for service discovery, taking advantage of Consul’s tagging capabilities. By creating and registering services, we could now query Consul for information about other nodes, replacing the need for Chef searches. However, this introduced a new challenge. At Slack, we use an overlay network called Nebula, which transparently handles network encryption between endpoints. To query Consul, instances need to be connected through Nebula. Yet, Nebula is configured by Chef, creating a circular dependency problem. We couldn’t set up attributes or variables using Consul during Chef’s compile phase, leading to a classic chicken-and-egg situation. After some consideration, we devised a solution using Chef’s ruby_block resources. We placed the logic for creating resources and assigning variables within these ruby_block resources. Since ruby_block resources are executed only during the converge phase of the Chef run, we can control the execution order to ensure that Nebula is installed and configured before these resources are processed. However, for values calculated within Ruby blocks that need to be used elsewhere, we utilize the lazy keyword. This ensures that these values are loaded during the Chef converge phase. We also developed a set of Chef library functions to facilitate node lookups based on various tags, service names, and other criteria. This allowed us to replicate the functionality we previously achieved with Chef search. We integrated these helper functions into our cookbooks, enabling us to retrieve the necessary values from Consul efficiently. Example: node.override['some_attribute'] = [] # In Chef, when a resource is defined all its variables are evaluated during # compile time and the execution of the resource takes place in converge phase. # So if the value of a particular attribute is changed in converge # (and not in compile) the resource will be executed with the old value. # Therefore we need to put the following call inside the ruby block because, # We need to make sure Nebula is up so we can connect to Consul (Nebula gets stup during converge time) ruby_block 'lets_set_some_attribute' do block do extend SomeHelper node.override['some_attribute'] = consul_service_lookup_helper_func() end end # Please note that we are not using `lazy` with the `only_if` below for the value that is calculated in the ruby block above # It's because `only_if` is already lazy # https://github.com/chef/chef/issues/10243#issuecomment-668187830 systemd_unit 'some_service' do action [:enable, :start] only_if { node.override['some_attribute'].empty? end Although this approach required adding large Ruby blocks with complex logic to some cookbooks, it allowed us to efficiently roll out multiple Chef stacks. If you’re a Chef expert with suggestions for a better method, we’d love to hear from you. Please don’t hesitate to reach out! Challenge 3: Searching Chef As mentioned earlier, we initially relied on Chef as an inventory management system. This approach was useful for discovering information about nodes and their attributes within our fleet. For instance, we could track the progress of feature rollouts using these attributes. To facilitate Chef searches and reporting for developers, we created an interface called Gaz. This approach worked well with a single Chef stack, but with multiple stacks in play, we needed a new solution. We developed a service called Shearch (Sharded Chef Search) which features an API that accepts Chef queries, runs them across multiple shards, and consolidates the results. This allows us to use Shearch behind Gaz, rather than having Gaz interact directly with a Chef stack. Additionally, we replaced the Knife command on our development boxes with a new tool called Gnife (a nod to “Go Knife,” as it’s written in Go). Gnife offers the same functionality as the Chef Knife command but operates across multiple shards using the Shearch service. We also had to update many of our internally developed tools and libraries to use the Shearch service instead of interacting directly with a Chef stack. As you can imagine, this required considerable effort. Sharding our Chef infrastructure significantly enhanced its resilience. However, we still faced challenges with how we deploy our cookbooks. Currently, we update all our environments simultaneously and upload the same cookbook versions across the board. We needed a more efficient approach to improve this process. Challenge 4: Cookbook uploads To implement this change quickly, we decided to retain our existing DishPig cookbook uploader application. However, since DishPig was designed to work with a single Chef stack, we had to deploy multiple instances of the application, each dedicated to a specific stack. We modified our S3 bucket to send notifications to an SNS topic (instead of directly to SQS), which then fanned out these messages to multiple SQS queues, each corresponding to a different DishPig deployment. This setup allowed changes to be uploaded independently to each Chef stack without any consistency checks between them. For example, we encountered issues where artifacts built close to the top of the hour (when DishPig is triggered) resulted in SQS messages reaching some queues on time but not others. This led to Chef stacks having different versions of cookbooks. While we did create a small monitoring system to check for and alert on consistency errors, it was far from an ideal solution. Cookbook versioning and Chef Librarian We needed a solution that would allow us to version our cookbooks and update environments independently, while also managing multiple Chef stacks and ensuring they remain in sync. Additionally, it was crucial for the application to track what changes are included in each version and where it has been deployed. To address these requirements, we designed a new service called Chef Librarian to replace our previous service, DishPig, as discussed earlier. Our cookbooks are managed within a single Git repository. Internally developed cookbooks are stored in the site-cookbooks directory, while Supermarket cookbooks are kept in the cookbooks directory. . ├── cookbooks │ ├── supermarket-cookbook-1 │ │ ├── files │ │ │ └── default │ │ │ └── file1.txt │ │ └── recipes │ │ └── default.rb │ └── supermarket-cookbook-2 │ ├── files │ │ └── default │ │ └── file1.txt │ └── recipes │ └── default.rb ├── site-cookbooks │ ├── our-cookbook-1 │ │ ├── files │ │ │ └── default │ │ │ └── file1.txt │ │ └── recipes │ │ └── default.rb │ └── our-cookbook-2 │ ├── files │ │ └── default │ │ └── file1.txt │ └── recipes │ └── default.rb └── roles ├── sample-role-1.json └── sample-role-2.json When changes to any of these items are merged, we use GitHub Actions to trigger a build job. This job creates a tarball that includes a complete copy of the repository. For internally developed cookbooks, we update the version number in the site-cookbooks directory to a new version using the standard Chef cookbook versioning format: YYYYMMDD.TIMESTAMP.0 (e.g., 20240809.1723164435.0). The version numbers for Supermarket cookbooks remain unchanged unless we fetch a new version from the upstream source. Once the artifact is built, GitHub Actions uploads it to S3. S3 then generates a notification in an SQS queue, which the Chef Librarian application listens to. Chef Librarian promptly processes the new artifact and uploads the updated versions of cookbooks to all our Chef stacks. Although these new versions are now on the Chef stacks, they won’t be utilized until explicitly specified. With this approach, we upload all cookbooks, regardless of whether they have changed or not, to the Chef stacks with the new version. We have developed two API endpoints for the Chef Librarian application: /update_environment_to_version – This endpoint updates an environment to a specified version. To use it, send a POST request with parameters including the target environment and the version to update to. /update_environment_from_environment – This endpoint updates an environment to match the versions of another environment. We now have the ability to update environments to specific versions independently of each other. This enables us to first update the sandbox and development environments, monitor metrics for any potential issues, and ensure stability before promoting the artifact to production. In practice, this means that any problematic changes deployed to Chef do not impact all environments simultaneously. We can detect and address errors earlier, preventing them from propagating further. Chef Librarian also stores artifact versions, the environments they’re deployed to, and other state-related information in DynamoDB. This makes it much easier for us to track changes and visualize our rollout process. However, Chef roles are a different challenge since they aren’t versioned. When you upload them, they propagate across all environments, making role updates a risky operation. To address this, we’ve stripped most of the logic out of our Chef roles, leaving them with only basic information and a run list. Additionally, because we’ve split our Chef infrastructure into dev and prod environments, we only upload roles to the relevant Chef stacks when their corresponding environments are updated (e.g., roles are uploaded to prod shards only when the prod environment is updated). Currently, we use a Kubernetes CronJob to call the API endpoints discussed earlier on a schedule, promoting versions across our environments. However, this process first checks for a key in a designated S3 bucket to ensure that promotions are not blocked before proceeding. This means that if we detect failures in the sandbox or dev environments, we can place this key in the bucket to prevent further promotion of artifact versions. At present, this is a manual process triggered by a human when they receive alerts about Chef run failures or provisioning issues. Our goal, however, is to replace this Kubernetes CronJob with a more intelligent system that can automatically monitor metrics and impose these blocks without human intervention. We’ve also developed an interface for Chef Librarian, allowing users to view which artifacts have been uploaded with specific commits, as well as when an environment was updated to a particular version in a specific Chef shard. We developed a Slack app for the Chef Librarian application, allowing us to notify users when their changes are being promoted to an environment. The app identifies the user who made the change by examining the Git commit and then uses the Slack API to look up their Slack handle. This enables us to tag the user directly in the notification, ensuring they are promptly informed when the message is posted. What’s next? Although we’ve made significant strides in improving deployment safety, there’s still much more we can do. One avenue we’re exploring is further segmentation of our Chef environments. For example, we’re considering breaking down our production Chef environments by AWS availability zones, allowing us to promote changes independently within each zone and prevent bad changes from being deployed everywhere simultaneously. Another long-term option we’re investigating is the adoption of Chef PolicyFiles and PolicyGroups. While this represents a significant departure from our current setup, it would offer much greater flexibility and safety when deploying changes to specific nodes. Implementing these changes at our scale is a complex undertaking. We’re still conducting research and assessing the potential impacts and benefits. There’s a lot of exciting work happening in this space at Slack, so stay tuned to our blog for more updates on the cool projects we’re working on!",
  "image": "https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_1_9a3875.png?w=640",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content-area\"\u003e\n\t\t\u003cmain id=\"primary\"\u003e\n\t\t\t\u003carticle id=\"post-16966\"\u003e\n\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\t\t\u003cp\u003eAt Slack, we manage tens of thousands of EC2 instances that host a variety of services, including our Vitess databases, Kubernetes workers, and various components of the Slack application. The majority of these instances run on some version of Ubuntu, while a portion operates on Amazon Linux. With such a vast infrastructure, the critical question arises: how do we efficiently provision these instances and deploy changes across them? The solution lies in a combination of internally-developed services, with Chef playing a central role. In this blog post, I’ll discuss the evolution of our Chef infrastructure over the years and the challenges we encountered along the way.\u003c/p\u003e\n\u003ch2\u003eA journey down memory lane: our previous process\u003c/h2\u003e\n\u003cp\u003eIn the early days of Slack, we relied on a single Chef stack. Our Chef infrastructure included a set of EC2 instances, an AWS application load balancer, an RDS cluster, and an AWS OpenSearch cluster. As our fleet of instances started to grow, we scaled up and out this stack to match our increasing demand.\u003c/p\u003e\n\u003cp\u003eWe had three environments on this Chef stack: Sandbox, Dev, and Prod. Nodes from each environment in our fleet were mapped to one of these environments. Slack has two types of cookbooks: cookbooks we download from the Chef Supermarket and the ones that are internally created. When these cookbooks are modified, we upload them using a process called DishPig. When a change is merged to our repo, we triggered a CI job to look for any changes to the cookbooks or roles and built an artifact with this. Then this artifact gets uploaded to a S3 bucket and then from this S3 bucket, we notify an SQS queue. We triggered the DishPig process on the top of each hour to look for any new messages in the queue. When DishPig detected a new event in the queue, it downloaded the artifact and uploaded the changed cookbooks to the Chef server. We upload the cookbooks we take from the supermarket with their own version, but we will always upload the cookbooks we create with a fixed version number. Therefore we did not have multiple versions of the cookbooks we created and only a single version of them were available on the Chef server.\u003c/p\u003e\n\u003cp\u003eOnce the cookbooks were uploaded to the Chef server, all three environments were updated to include the latest versions of the Supermarket cookbooks. Since we are uploading our own cookbooks with the same version, their references in the environments did not need updating.\u003c/p\u003e\n\u003cp\u003eWith this approach, all our environments got the changes on the hour.\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" width=\"884\" height=\"94\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_1_9a3875.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_1_9a3875.png 884w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_1_9a3875.png?resize=640,68 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_1_9a3875.png?resize=768,82 768w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe also provided tooling that allowed developers to create custom Chef environments with specific versions of cookbooks, enabling them to test their changes on a small set of nodes within a temporary environment. Once testing was complete, the tooling would automatically clean up the temporary environment and remove the custom cookbook versions.\u003c/p\u003e\n\u003cp\u003eThis approach had a few significant drawbacks: all changes were deployed across all environments simultaneously. This meant that any faulty changes could potentially disrupt all existing Chef runs and new server provisions across our entire infrastructure.\u003c/p\u003e\n\u003cp\u003eRelying on a single Chef stack also meant that any issues with this stack could have widespread effects, potentially impacting our entire infrastructure.\u003c/p\u003e\n\u003ch2\u003eTransitioning to a sharded Chef infrastructure\u003c/h2\u003e\n\u003cp\u003eAs our infrastructure grew rapidly, ensuring guaranteed reliability became a top priority. We recognized that relying on a single Chef stack posed a significant risk, as it was a major single point of failure. To address this, we began redesigning our Chef infrastructure, starting by eliminating our dependence on a single Chef stack.\u003c/p\u003e\n\u003cp\u003eWe decided to create multiple Chef stacks to distribute the load more effectively and ensure resilience. This approach also gave us the flexibility to direct new provisions to the remaining operational Chef stacks if one were to fail. However, implementing this new strategy introduced several challenges. Let’s explore the most significant ones.\u003c/p\u003e\n\u003ch3\u003eChallenge 1: Assigning a shard to a node\u003c/h3\u003e\n\u003cp\u003eOur first step was to find a method for directing new provisions to specific shards. We achieved this using an AWS Route53 Weighted CNAME record. When an instance spins up, it queries the CNAME record and, based on the assigned weight, receives a record from the set. This record then determines which Chef stack the instance will be assigned to.\u003c/p\u003e\n\u003cp\u003eAdditionally, as illustrated below, we separated the development and production Chef infrastructure into distinct stacks. This segregation helps strengthen the boundary between our development and production environments.\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" width=\"1325\" height=\"209\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/1_cnames.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/1_cnames.png 1325w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/1_cnames.png?resize=640,101 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/1_cnames.png?resize=768,121 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/1_cnames.png?resize=1280,202 1280w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003ch3\u003eChallenge 2: Neighborhood discovery\u003c/h3\u003e\n\u003cp\u003eHistorically, Slack lacked a dedicated EC2 inventory management system, and our Chef stack was the closest alternative. As a result, teams began querying the Chef server whenever they needed information about specific instances in the fleet. They would use Chef search to locate nodes based on criteria, such as nodes with a particular Chef role in a specific AWS region.\u003c/p\u003e\n\u003cp\u003eThis approach worked well until we moved to a sharded Chef infrastructure. With the new setup, running the same query would only return nodes from the specific Chef stack you queried. Since nodes are now distributed across multiple Chef stacks, this method no longer provides a complete view of all instances.\u003c/p\u003e\n\u003cp\u003eLet’s take a step back and look at how a Chef run operates. A Chef run consists of two phases: compile and converge. During the compile phase, Chef collects information about its run lists, reads all its cookbooks, assigns variables, creates attributes, and maps out the resources it needs to create. In the converge phase, Chef then creates those resources based on the information gathered in the compile phase.\u003c/p\u003e\n\u003cp\u003eSome of our cookbooks were designed to create attributes and variables based on the results from Chef searches. With the transition to sharded Chef stacks, we needed to find an alternative to these node discovery methods. After considering our options, we decided to leverage an existing service at Slack: Consul.\u003c/p\u003e\n\u003cp\u003eWe began registering certain services in Consul for service discovery, taking advantage of Consul’s tagging capabilities. By creating and registering services, we could now query Consul for information about other nodes, replacing the need for Chef searches.\u003c/p\u003e\n\u003cp\u003eHowever, this introduced a new challenge. At Slack, we use an overlay network called \u003ca href=\"https://github.com/slackhq/nebula\"\u003eNebula\u003c/a\u003e, which transparently handles network encryption between endpoints. To query Consul, instances need to be connected through Nebula. Yet, Nebula is configured by Chef, creating a circular dependency problem. We couldn’t set up attributes or variables using Consul during Chef’s compile phase, leading to a classic chicken-and-egg situation.\u003c/p\u003e\n\u003cp\u003eAfter some consideration, we devised a solution using Chef’s \u003ca href=\"https://docs.chef.io/resources/ruby_block/\"\u003eruby_block\u003c/a\u003e resources. We placed the logic for creating resources and assigning variables within these \u003ca href=\"https://docs.chef.io/resources/ruby_block/\"\u003eruby_block\u003c/a\u003e resources. Since \u003ca href=\"https://docs.chef.io/resources/ruby_block/\"\u003eruby_block\u003c/a\u003e resources are executed only during the converge phase of the Chef run, we can control the execution order to ensure that Nebula is installed and configured before these resources are processed.\u003c/p\u003e\n\u003cp\u003eHowever, for values calculated within Ruby blocks that need to be used elsewhere, we utilize the lazy keyword. This ensures that these values are loaded during the Chef converge phase.\u003c/p\u003e\n\u003cp\u003eWe also developed a set of Chef library functions to facilitate node lookups based on various tags, service names, and other criteria. This allowed us to replicate the functionality we previously achieved with Chef search. We integrated these helper functions into our cookbooks, enabling us to retrieve the necessary values from Consul efficiently.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eExample:\u003c/span\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enode.override[\u0026#39;some_attribute\u0026#39;] = []\n# In Chef, when a resource is defined all its variables are evaluated during\n# compile time and the execution of the resource takes place in converge phase.\n# So if the value of a particular attribute is changed in converge\n# (and not in compile) the resource will be executed with the old value.\n# Therefore we need to put the following call inside the ruby block because,\n# We need to make sure Nebula is up so we can connect to Consul (Nebula gets stup during converge time)\nruby_block \u0026#39;lets_set_some_attribute\u0026#39; do\n  block do\n    extend SomeHelper\n    node.override[\u0026#39;some_attribute\u0026#39;] = consul_service_lookup_helper_func()\n  end\nend\n\n# Please note that we are not using `lazy` with the `only_if` below for the value that is calculated in the ruby block above\n# It\u0026#39;s because `only_if` is already lazy\n# https://github.com/chef/chef/issues/10243#issuecomment-668187830\nsystemd_unit \u0026#39;some_service\u0026#39; do\n  action [:enable, :start]\n  only_if { node.override[\u0026#39;some_attribute\u0026#39;].empty?\nend\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlthough this approach required adding large Ruby blocks with complex logic to some cookbooks, it allowed us to efficiently roll out multiple Chef stacks. If you’re a Chef expert with suggestions for a better method, we’d love to hear from you. Please don’t hesitate to reach out!\u003c/p\u003e\n\u003ch3\u003eChallenge 3: Searching Chef\u003c/h3\u003e\n\u003cp\u003eAs mentioned earlier, we initially relied on Chef as an inventory management system. This approach was useful for discovering information about nodes and their attributes within our fleet. For instance, we could track the progress of feature rollouts using these attributes. To facilitate Chef searches and reporting for developers, we created an interface called Gaz.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1916\" height=\"412\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png 1916w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png?resize=640,138 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png?resize=768,165 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png?resize=1280,275 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/2_gaz.png?resize=1536,330 1536w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis approach worked well with a single Chef stack, but with multiple stacks in play, we needed a new solution. We developed a service called Shearch (Sharded Chef Search) which features an API that accepts Chef queries, runs them across multiple shards, and consolidates the results. This allows us to use Shearch behind Gaz, rather than having Gaz interact directly with a Chef stack.\u003c/p\u003e\n\u003cp\u003eAdditionally, we replaced the Knife command on our development boxes with a new tool called Gnife (a nod to “Go Knife,” as it’s written in Go). Gnife offers the same functionality as the Chef Knife command but operates across multiple shards using the Shearch service.\u003cbr/\u003e\nWe also had to update many of our internally developed tools and libraries to use the Shearch service instead of interacting directly with a Chef stack. As you can imagine, this required considerable effort.\u003c/p\u003e\n\u003cp\u003eSharding our Chef infrastructure significantly enhanced its resilience. However, we still faced challenges with how we deploy our cookbooks. Currently, we update all our environments simultaneously and upload the same cookbook versions across the board. We needed a more efficient approach to improve this process.\u003c/p\u003e\n\u003ch3\u003eChallenge 4: Cookbook uploads\u003c/h3\u003e\n\u003cp\u003eTo implement this change quickly, we decided to retain our existing DishPig cookbook uploader application. However, since DishPig was designed to work with a single Chef stack, we had to deploy multiple instances of the application, each dedicated to a specific stack.\u003c/p\u003e\n\u003cp\u003eWe modified our S3 bucket to send notifications to an SNS topic (instead of directly to SQS), which then fanned out these messages to multiple SQS queues, each corresponding to a different DishPig deployment. This setup allowed changes to be uploaded independently to each Chef stack without any consistency checks between them.\u003c/p\u003e\n\u003cp\u003eFor example, we encountered issues where artifacts built close to the top of the hour (when DishPig is triggered) resulted in SQS messages reaching some queues on time but not others. This led to Chef stacks having different versions of cookbooks. While we did create a small monitoring system to check for and alert on consistency errors, it was far from an ideal solution.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1084\" height=\"379\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_2_03599a.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_2_03599a.png 1084w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_2_03599a.png?resize=640,224 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/dishpig_2_03599a.png?resize=768,269 768w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003ch2\u003eCookbook versioning and Chef Librarian\u003c/h2\u003e\n\u003cp\u003eWe needed a solution that would allow us to version our cookbooks and update environments independently, while also managing multiple Chef stacks and ensuring they remain in sync. Additionally, it was crucial for the application to track what changes are included in each version and where it has been deployed. To address these requirements, we designed a new service called Chef Librarian to replace our previous service, DishPig, as discussed earlier.\u003c/p\u003e\n\u003cp\u003eOur cookbooks are managed within a single Git repository. Internally developed cookbooks are stored in the site-cookbooks directory, while Supermarket cookbooks are kept in the cookbooks directory.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.\n├── cookbooks\n│   ├── supermarket-cookbook-1\n│   │   ├── files\n│   │   │   └── default\n│   │   │       └── file1.txt\n│   │   └── recipes\n│   │       └── default.rb\n│   └── supermarket-cookbook-2\n│       ├── files\n│       │   └── default\n│       │       └── file1.txt\n│       └── recipes\n│           └── default.rb\n├── site-cookbooks\n│   ├── our-cookbook-1\n│   │   ├── files\n│   │   │   └── default\n│   │   │       └── file1.txt\n│   │   └── recipes\n│   │       └── default.rb\n│   └── our-cookbook-2\n│       ├── files\n│       │   └── default\n│       │       └── file1.txt\n│       └── recipes\n│           └── default.rb\n└── roles\n    ├── sample-role-1.json\n    └── sample-role-2.json\u003c/code\u003e\u003ccode\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen changes to any of these items are merged, we use GitHub Actions to trigger a build job. This job creates a tarball that includes a complete copy of the repository. For internally developed cookbooks, we update the version number in the site-cookbooks directory to a new version using the standard Chef cookbook versioning format: \u003ccode\u003eYYYYMMDD.TIMESTAMP.0\u003c/code\u003e (e.g., \u003ccode\u003e20240809.1723164435.0\u003c/code\u003e). The version numbers for Supermarket cookbooks remain unchanged unless we fetch a new version from the upstream source.\u003c/p\u003e\n\u003cp\u003eOnce the artifact is built, GitHub Actions uploads it to S3. S3 then generates a notification in an SQS queue, which the Chef Librarian application listens to. Chef Librarian promptly processes the new artifact and uploads the updated versions of cookbooks to all our Chef stacks. Although these new versions are now on the Chef stacks, they won’t be utilized until explicitly specified.\u003c/p\u003e\n\u003cp\u003eWith this approach, we upload all cookbooks, regardless of whether they have changed or not, to the Chef stacks with the new version.\u003c/p\u003e\n\u003cp\u003eWe have developed two API endpoints for the Chef Librarian application:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/update_environment_to_version\u003c/code\u003e – This endpoint updates an environment to a specified version. To use it, send a POST request with parameters including the target environment and the version to update to.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/update_environment_from_environment\u003c/code\u003e – This endpoint updates an environment to match the versions of another environment.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe now have the ability to update environments to specific versions independently of each other. This enables us to first update the sandbox and development environments, monitor metrics for any potential issues, and ensure stability before promoting the artifact to production.\u003c/p\u003e\n\u003cp\u003eIn practice, this means that any problematic changes deployed to Chef do not impact all environments simultaneously. We can detect and address errors earlier, preventing them from propagating further.\u003c/p\u003e\n\u003cp\u003eChef Librarian also stores artifact versions, the environments they’re deployed to, and other state-related information in DynamoDB. This makes it much easier for us to track changes and visualize our rollout process.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"971\" height=\"428\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_1_48cfc0.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_1_48cfc0.png 971w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_1_48cfc0.png?resize=640,282 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_1_48cfc0.png?resize=768,339 768w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eHowever, Chef roles are a different challenge since they aren’t versioned. When you upload them, they propagate across all environments, making role updates a risky operation. To address this, we’ve stripped most of the logic out of our Chef roles, leaving them with only basic information and a run list. Additionally, because we’ve split our Chef infrastructure into dev and prod environments, we only upload roles to the relevant Chef stacks when their corresponding environments are updated (e.g., roles are uploaded to prod shards only when the prod environment is updated).\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"812\" height=\"327\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_2.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_2.png 812w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_2.png?resize=640,258 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_2.png?resize=768,309 768w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eCurrently, we use a Kubernetes CronJob to call the API endpoints discussed earlier on a schedule, promoting versions across our environments. However, this process first checks for a key in a designated S3 bucket to ensure that promotions are not blocked before proceeding. This means that if we detect failures in the sandbox or dev environments, we can place this key in the bucket to prevent further promotion of artifact versions.\u003c/p\u003e\n\u003cp\u003eAt present, this is a manual process triggered by a human when they receive alerts about Chef run failures or provisioning issues. Our goal, however, is to replace this Kubernetes CronJob with a more intelligent system that can automatically monitor metrics and impose these blocks without human intervention.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"805\" height=\"315\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_3.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_3.png 805w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_3.png?resize=640,250 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Chef_Librarian_3.png?resize=768,301 768w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe’ve also developed an interface for Chef Librarian, allowing users to view which artifacts have been uploaded with specific commits, as well as when an environment was updated to a particular version in a specific Chef shard.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"2028\" height=\"629\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png 2028w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?resize=640,199 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?resize=768,238 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?resize=1280,397 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?resize=1536,476 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/Librarian_UI_66f25d.png?resize=1920,596 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe developed a Slack app for the Chef Librarian application, allowing us to notify users when their changes are being promoted to an environment. The app identifies the user who made the change by examining the Git commit and then uses the Slack API to look up their Slack handle. This enables us to tag the user directly in the notification, ensuring they are promptly informed when the message is posted.\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"768\" height=\"164\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/slack_message.png?w=640\" alt=\"\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/09/slack_message.png 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/09/slack_message.png?resize=640,137 640w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003ch2\u003eWhat’s next?\u003c/h2\u003e\n\u003cp\u003eAlthough we’ve made significant strides in improving deployment safety, there’s still much more we can do. One avenue we’re exploring is further segmentation of our Chef environments. For example, we’re considering breaking down our production Chef environments by AWS availability zones, allowing us to promote changes independently within each zone and prevent bad changes from being deployed everywhere simultaneously.\u003c/p\u003e\n\u003cp\u003eAnother long-term option we’re investigating is the adoption of Chef PolicyFiles and PolicyGroups. While this represents a significant departure from our current setup, it would offer much greater flexibility and safety when deploying changes to specific nodes.\u003c/p\u003e\n\u003cp\u003eImplementing these changes at our scale is a complex undertaking. We’re still conducting research and assessing the potential impacts and benefits. There’s a lot of exciting work happening in this space at Slack, so stay tuned to our blog for more updates on the cool projects we’re working on!\u003c/p\u003e\n\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\u003c/article\u003e\n\n\t\t\n\t\t\u003c/main\u003e\n\n\t\t\n\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2024-09-17T07:00:57Z",
  "modifiedTime": "2024-09-17T23:02:37Z"
}
