{
  "id": "9b942e43-516f-4c2d-87e9-fbbe78b82fb8",
  "title": "Why You Should Execute jOOQ Queries With jOOQ",
  "link": "https://blog.jooq.org/why-you-should-execute-jooq-queries-with-jooq/",
  "description": "Previously on this blog, I’ve written a post explaining why you should use jOOQ’s code generator, despite the possibility of using jOOQ without it. In a similar fashion, as I’ve answered numerous jOOQ questions on Stack Overflow, where someone used jOOQ to build a query, but then executed it elsewhere, including on: jOOQ itself isn’t … Continue reading Why You Should Execute jOOQ Queries With jOOQ →",
  "author": "lukaseder",
  "published": "Wed, 18 Jan 2023 11:46:25 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-in-use",
    "Code generation",
    "CRUD",
    "CSV",
    "execution",
    "export",
    "identity",
    "import",
    "JDBC",
    "jooq",
    "jpa",
    "JSON",
    "mapping",
    "Multiset",
    "Nested collections",
    "Nested Records",
    "ORM",
    "R2DBC",
    "stored procedures",
    "Type safety",
    "UDT",
    "UpdatableRecord",
    "user defined types",
    "xml"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 13985,
  "excerpt": "Many applications migrating to jOOQ tend to keep \"the old stuff\" around by continuing executing queries with JPA, JDBC, JdbcTemplate, etc. and using jOOQ only as a query builder. This article shows numerous benefits of executing jOOQ that users are missing this way.",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "Previously on this blog, I’ve written a post explaining why you should use jOOQ’s code generator, despite the possibility of using jOOQ without it. In a similar fashion, as I’ve answered numerous jOOQ questions on Stack Overflow, where someone used jOOQ to build a query, but then executed it elsewhere, including on: JPA JDBC / R2DBC JdbcTemplate (by Spring) Etc. jOOQ itself isn’t opinionated and tries to accommodate all possible use-cases. Every jOOQ Query can render its SQL using Query.getSQL(), and produce bind values with Query.getBindValues(), so in principle, executing jOOQ queries elsewhere is totally possible. Some valid use-cases for doing this: You use jOOQ only for 2-3 dynamic queries in an otherwise JPA based application, and you need to fetch entities (not DTOs) with those queries. An example from the manual, here.(If you use jOOQ for tons of queries, you’ll probably start wondering if you still need entities in the first place.) That’s pretty much it. An invalid way overrated use-case is: You want to migrate slowly to using jOOQ, because everything else is still using JdbcTemplate, for example. I’ll explain later why this isn’t a good use-case for extracting SQL from jOOQ. In the following article, I want to show by example the numerous benefits of executing queries with jOOQ, and by consequence, why you should go “all in” on using jOOQ. This article tries to omit all the benefits of building a query with jOOQ, assuming you’ve already made the decision that jOOQ is the right choice for query building. Type safety One of jOOQ’s main benefits is its type safety both when writing SQL as well as when maintaining it. A lot of it is achieved using jOOQ’s DSL and code generation, but that’s not all. You can also profit from type safety when executing queries with jOOQ. For example, here’s a query that type safely fetches a nested SQL collection into a Java Map: // This is the target data type record Film( String title, Map\u003cLocalDate, BigDecimal\u003e revenue ) {} // This query is entirely type safe. Change it, it won't compile anymore List\u003cFilm\u003e result = ctx.select( FILM.TITLE, multiset( select( PAYMENT.PAYMENT_DATE.cast(LOCALDATE), sum(PAYMENT.AMOUNT)) .from(PAYMENT) .where(PAYMENT.rental().inventory().FILM_ID .eq(FILM.FILM_ID)) .groupBy(PAYMENT.PAYMENT_DATE.cast(LOCALDATE)) .orderBy(PAYMENT.PAYMENT_DATE.cast(LOCALDATE)) ) // Convert Field\u003cResult\u003cRecord2\u003cLocalDate, BigDecimal\u003e\u003e\u003e // to Field\u003cMap\u003cLocalDate, BigDecimal\u003e\u003e .convertFrom(r -\u003e r.collect(Records.intoMap()) ) .from(FILM) .orderBy(FILM.TITLE) // Convert Record2\u003cString, Map\u003cLocalDate, BigDecimal\u003e\u003e // to List\u003cFilm\u003e .fetch(Records.mapping(Film::new)) Again, the building of the query is already type safe and that’s great. But much more than that, the final fetch(mapping(Film::new)) call is also type safe! It must produce a value that adheres to the structure (String, Map\u003cLocalDate, BigDecimal\u003e), which is what the query produces. More in the linked blog post. You can’t get this level of type safety (and mapping) from any other execution engine. Once you extract the SQL string and bind values, you’re back to the JDBC level, where the result set isn’t known: In JDBC (including JdbcTemplate), all ResultSet content is super generic. The number of columns isn’t known, their positions aren’t known, their data types aren’t known to the compiler. In JPA’s DTO fetching APIs, you’ll just get an Object[], which isn’t much better than with JDBC. I’d argue it’s a step back from JDBC, because you don’t even get an API anymore. You don’t have to use jOOQ’s type safety all the time, you can always opt out of it, but at least, by default, it’s there! Example: Reactive querying A great example for this type safety is when you work with R2DBC to run a reactive query. I don’t think anyone prefers executing the query on R2DBC directly, given that with jOOQ, a query can just be embedded e.g. in a reactor Flux, for automatic execution and mapping. record Table(String schema, String table) {} Flux.from(ctx .select( INFORMATION_SCHEMA.TABLES.TABLE_SCHEMA, INFORMATION_SCHEMA.TABLES.TABLE_NAME) .from(INFORMATION_SCHEMA.TABLES)) // Type safe mapping from Record2\u003cString, String\u003e to Table::new .map(Records.mapping(Table::new)) .doOnNext(System.out::println) .subscribe(); Mapping The previous example already implied that mapping is available automatically in jOOQ. There are numerous ways to map a jOOQ Record or Record[N] type to some user type. The most popular ways include: The historic DefaultRecordMapper, which is reflection based and uses the Result.into(Class) API The more recently added type safe record mapper that maps Record[N] types onto constructor references (or any other function), as in the above example. But mapping of records is not everything there is, there is also data type conversion! The Converter and Binding SPIs that can be attached to generated code to always auto-convert things for you. JPA has a similar mechanism for entities, but you cannot access these things when you extract the jOOQ SQL query in string form. Automatic type conversion between any database type T and user type U via ConverterProvider. The default implementation can map between things like Integer and Long or LocalDate and String or whatever. This is very useful when mapping SQL/XML to Java objects using JAXB, or SQL/JSON to Java objects using Jackson or Gson automatically! It just works out of the box! Ad-hoc converters can type safely map between a database type (e.g. from generated code) to a user type on a per-query basis. This is super powerful when your database schema can’t have Converter implementations attached to it globally. It also works very well when working with MULTISET or nested ROW expressions Execution emulations Some SQL features are mainly emulated at runtime when executing queries using jOOQ. These include: MULTISET (nested collections) ROW (nested records) These features that numerous jOOQ users have come to love are not usable outside of jOOQ. The generated SQL for these queries encodes the nested collections and records using SQL/XML or SQL/JSON, depending on the dialect. Of course, you could re-implement the unmarshalling of JSON to a Java object again in your own data access layer, but why? jOOQ’s works very well, and as mentioned above, is even type safe. If you reimplemented this yourself, you’d probably not achieve the same type safety level. Another cool execution thing is the: Batched Connection Which emulates batching of consecutive SQL statements automatically, without any API intervention. User defined types If you want to work with user defined types both on the server side as well as on the client side, all the data type bindings are built-in in jOOQ and work out of the box. For example, in PostgreSQL or Oracle (slightly different syntax): CREATE TYPE name AS ( first_name TEXT, last_name TEXT ); CREATE TABLE user ( id BIGINT PRIMARY KEY, name name NOT NULL ); Not only will the code generator pick up these types for you, but you can also fetch them in a type safe way: Result\u003cRecord2\u003cLong, NameRecord\u003e\u003e r = ctx.select(USER.ID, USER.NAME) .from(USER) .fetch(); And then, obviously, apply type safe or reflective mapping on that record, whatever you prefer. I don’t think such UDT support would work as well with other execution modes. You could try it. The generated UDT types implement JDBC’s SQLData, so you should be able to bind them to a JDBC statement out of the box. But there are still edge cases. Stored procedures Binding OUT or IN OUT parameters is a bit of a hassle via the lower level APIs of JDBC, R2DBC, or JPA. Why not just use jOOQ, again, to execute a stored procedure call? Given: CREATE OR REPLACE PROCEDURE my_proc ( i1 NUMBER, io1 IN OUT NUMBER, o1 OUT NUMBER, o2 OUT NUMBER, io2 IN OUT NUMBER, i2 NUMBER ) IS BEGIN o1 := io1; io1 := i1; o2 := io2; io2 := i2; END my_proc; What do you prefer? This (JDBC)? try (CallableStatement s = c.prepareCall( \"{ call my_proc(?, ?, ?, ?, ?, ?) }\" )) { // Set all input values s.setInt(1, 1); // i1 s.setInt(2, 2); // io1 s.setInt(5, 5); // io2 s.setInt(6, 6); // i2 // Register all output values with their types s.registerOutParameter(2, Types.INTEGER); // io1 s.registerOutParameter(3, Types.INTEGER); // o1 s.registerOutParameter(4, Types.INTEGER); // o2 s.registerOutParameter(5, Types.INTEGER); // io2 s.executeUpdate(); System.out.println(\"io1 = \" + s.getInt(2)); System.out.println(\"o1 = \" + s.getInt(3)); System.out.println(\"o2 = \" + s.getInt(4)); System.out.println(\"io2 = \" + s.getInt(5)); } Or this? // Short form, passing arguments by index (type safe): MyProc result = Routines.myProc(configuration, 1, 2, 5, 6); // Explicit form, passing arguments by name (type safe): MyProc call = new MyProc(); call.setI1(1); call.setIo1(2); call.setIo2(5); call.setI2(6); call.execute(configuration); System.out.println(\"io1 = \" + call.getIo1()); System.out.println(\"o1 = \" + call.getO1()); System.out.println(\"o2 = \" + call.getO2()); System.out.println(\"io2 = \" + call.getIo2()); This comparison becomes even more obvious, when you try to call stored procedures that accept / return user defined types. Fetching identity values This is so painful across SQL dialects and JDBC drivers! Some SQL dialects have native support, including: Db2, H2: FINAL TABLE (the data change delta table) Firebird, MariaDB, Oracle, PostgreSQL: RETURNING (though, in Oracle, there are many challenges) SQL Server: OUTPUT But otherwise, often multiple queries need to be executed, or alternative JDBC API needs to be used. If you want to have a glimpse at the painful work jOOQ does for you, look here. Simple CRUD In case you’re using JPA, this is probably not jOOQ’s killer feature, as JPA is a more sophisticated ORM than jOOQ, mapping associations and all. But if you’re not using JPA (e.g. JdbcTemplate or JDBC directly), then you might be very repetitively writing INSERT, UPDATE, DELETE, MERGE statements, questioning life choices, rather than simply using the jOOQ API for CRUD using the UpdatableRecord API. Manual DML has its place, especially for bulk data processing, but other than that, which do you prefer? IF new_record THEN INSERT INTO t (a, b, c) VALUES (1, 2, 3) RETURNING id INTO :id; ELSE UPDATE t SET a = 1, b = 2, c = 3 WHERE id = :id; END IF; Or just: t.setA(1); t.setB(2); t.setC(3); t.store(); By the way, your TRecord is of course generated, and it can be imported from JSON or whatever, see below! Import and export of data jOOQ supports out of the box import/export of data from/to numerous data formats, including: XML CSV JSON HTML (export only) Text (export only) Charts (export only) Better defaults Compared to JDBC, jOOQ implements better defaults for most developers. This doesn’t mean that JDBC got it wrong. JDBC made the right choices for the purpose it was made for: A low level network protocol abstraction SPI. For jOOQ, using JDBC under the hood has been super powerful. But for users, it’s annoying that everything is always: Resourceful Lazy The above leads to a lot of: Resource management with try-with-resources Manual reuse of resources, such as PreparedStatement, which produces hard to maintain stateful code With jOOQ, everything a query produces is fetched into memory eagerly by default, which is the default most users need, allowing for faster closing of resources (including ResultSet, Statement, Connection, behind the scenes). Of course, you can still opt into lazy streaming processing of data if you need that, including reactively using R2DBC! Much more There’s a lot more, which is worth mentioning: You can access database meta data easily, using jOOQ API Mocking is simple with jOOQ (though, use sparingly!) You can use jOOQ’s diagnostics, which will get a lot better, soon Hardly any benefit of executing outside of jOOQ As I promised, I wanted to explain why there is hardly any benefit of executing outside of jOOQ, unless you want to fetch data into a JPA entity, in case of which you need JPA to manage the entity lifecycle for you. But when fetching DTOs, you don’t benefit from using JPA to execute a jOOQ query. It’s very easy to let jOOQ run a query directly on a JPA managed transaction. Flushing is necessary either way, so there’s no benefit. Other than that, JPA, JDBC, JdbcTemplate don’t do anything: That jOOQ can’t do equally well or better That jOOQ doesn’t fit into (transactions, connection lifecycle, mapping, etc.) jOOQ can be used as a drop-in replacement for any other way of executing a value-based SQL query, i.e. whenevery you map data into DTOs rather than entities. It can map data to any target data structure including any form of DTO (classic POJO, Java 16 records, kotlin data classes, scala case classes, etc. etc.) or XML, JSON, CSV as seen before. In fact, chances are you’ll be removing tons of repetitive boilerplate if you’re moving to jOOQ from the previous lower-level fetching and mapping code. Conclusion Just like in the previous article about why you should use jOOQ with code generation, this article should have convinced you to go all in on all of jOOQ’s benefits, not just the query building. A lot of thought (and I mean A LOT) has gone into the design of these features and APIs. I’m positive that you will find them better than the manual plumbing, once you get the hang of it.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-11787\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003ePreviously on this blog, I’ve written a post explaining \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003ewhy you should use jOOQ’s code generator, despite the possibility of using jOOQ without it\u003c/a\u003e. In a similar fashion, as I’ve answered \u003ca rel=\"noreferrer noopener\" href=\"https://stackoverflow.com/q/75110514/521799\" data-type=\"URL\" data-id=\"https://stackoverflow.com/q/75110514/521799\" target=\"_blank\"\u003enumerous jOOQ questions on Stack Overflow\u003c/a\u003e, where someone used jOOQ to build a query, but then executed it elsewhere, including on:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJPA\u003c/li\u003e\n\n\n\n\u003cli\u003eJDBC / R2DBC\u003c/li\u003e\n\n\n\n\u003cli\u003eJdbcTemplate (by Spring)\u003c/li\u003e\n\n\n\n\u003cli\u003eEtc.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003ejOOQ itself isn’t opinionated and tries to accommodate all possible use-cases. Every jOOQ \u003ccode\u003eQuery\u003c/code\u003e can render its SQL using \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/AttachableQueryPart.html#getSQL()\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/AttachableQueryPart.html#getSQL()\" target=\"_blank\"\u003eQuery.getSQL()\u003c/a\u003e\u003c/code\u003e, and produce bind values with \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/AttachableQueryPart.html#getBindValues()\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/AttachableQueryPart.html#getBindValues()\" target=\"_blank\"\u003eQuery.getBindValues()\u003c/a\u003e\u003c/code\u003e, so in principle, executing jOOQ queries elsewhere is totally possible.\u003c/p\u003e\n\n\n\n\u003cp\u003eSome valid use-cases for doing this:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou use jOOQ only for 2-3 dynamic queries in an otherwise JPA based application, and you need to fetch entities (not DTOs) with those queries. \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/alternative-execution-models/using-jooq-with-jpa/using-jooq-with-jpa-entities/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/alternative-execution-models/using-jooq-with-jpa/using-jooq-with-jpa-entities/\" target=\"_blank\"\u003eAn example from the manual, here\u003c/a\u003e.\u003cp\u003e(If you use jOOQ for tons of queries, you’ll probably start wondering if you still need entities in the first place.)\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThat’s pretty much it. An \u003cem\u003e\u003cs\u003einvalid\u003c/s\u003e\u003c/em\u003e \u003cem\u003eway overrated\u003c/em\u003e use-case is:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou want to migrate slowly to using jOOQ, because everything else is still using JdbcTemplate, for example. I’ll explain later why this isn’t a good use-case for extracting SQL from jOOQ.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn the following article, I want to show by example the numerous benefits of executing queries with jOOQ, and by consequence, why you should go “all in” on using jOOQ.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis article tries to omit all the benefits of \u003cem\u003ebuilding \u003c/em\u003ea query with jOOQ, assuming you’ve already made the decision that jOOQ is the right choice for query building.\u003c/p\u003e\n\n\n\n\u003ch2\u003eType safety\u003c/h2\u003e\n\n\n\n\u003cp\u003eOne of jOOQ’s main benefits is its type safety both when writing SQL as well as when maintaining it. A lot of it is achieved using \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/the-java-fluent-api-designer-crash-course/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/the-java-fluent-api-designer-crash-course/\" target=\"_blank\"\u003ejOOQ’s DSL\u003c/a\u003e and \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003ecode generation\u003c/a\u003e, but that’s not all. You can also profit from type safety when executing queries with jOOQ. For example, here’s a query that \u003ca href=\"https://blog.jooq.org/how-to-typesafely-map-a-nested-sql-collection-into-a-nested-java-map-with-jooq/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/how-to-typesafely-map-a-nested-sql-collection-into-a-nested-java-map-with-jooq/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003etype safely fetches a nested SQL collection into a Java \u003ccode\u003eMap\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// This is the target data type\nrecord Film(\n    String title,\n    Map\u0026lt;LocalDate, BigDecimal\u0026gt; revenue\n) {}\n\n// This query is entirely type safe. Change it, it won\u0026#39;t compile anymore\nList\u0026lt;Film\u0026gt; result =\nctx.select(\n        FILM.TITLE,\n        multiset(\n            select(\n                PAYMENT.PAYMENT_DATE.cast(LOCALDATE), \n                sum(PAYMENT.AMOUNT))\n            .from(PAYMENT)\n            .where(PAYMENT.rental().inventory().FILM_ID\n                .eq(FILM.FILM_ID))\n            .groupBy(PAYMENT.PAYMENT_DATE.cast(LOCALDATE))\n            .orderBy(PAYMENT.PAYMENT_DATE.cast(LOCALDATE))\n        )\n        // Convert Field\u0026lt;Result\u0026lt;Record2\u0026lt;LocalDate, BigDecimal\u0026gt;\u0026gt;\u0026gt;\n        // to Field\u0026lt;Map\u0026lt;LocalDate, BigDecimal\u0026gt;\u0026gt;\n        .convertFrom(r -\u0026gt; r.collect(Records.intoMap())\n   )\n   .from(FILM)\n   .orderBy(FILM.TITLE)\n \n   // Convert Record2\u0026lt;String, Map\u0026lt;LocalDate, BigDecimal\u0026gt;\u0026gt;\n   // to List\u0026lt;Film\u0026gt;\n   .fetch(Records.mapping(Film::new))\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAgain, the building of the query is already type safe and that’s great. But much more than that, the final \u003ccode\u003efetch(mapping(Film::new))\u003c/code\u003e call is also type safe! It must produce a value that adheres to the structure \u003ccode\u003e(String, Map\u0026lt;LocalDate, BigDecimal\u0026gt;)\u003c/code\u003e, which is what the query produces. \u003ca href=\"https://blog.jooq.org/how-to-typesafely-map-a-nested-sql-collection-into-a-nested-java-map-with-jooq/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/how-to-typesafely-map-a-nested-sql-collection-into-a-nested-java-map-with-jooq/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eMore in the linked blog post\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can’t get this level of type safety (and mapping) from any other execution engine. Once you extract the SQL string and bind values, you’re back to the JDBC level, where the result set isn’t known:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIn JDBC (including JdbcTemplate), all \u003ccode\u003eResultSet\u003c/code\u003e content is super generic. The number of columns isn’t known, their positions aren’t known, their data types aren’t known to the compiler.\u003c/li\u003e\n\n\n\n\u003cli\u003eIn JPA’s DTO fetching APIs, you’ll just get an \u003ccode\u003eObject[]\u003c/code\u003e, which isn’t much better than with JDBC. I’d argue it’s a step back from JDBC, because you don’t even get an API anymore.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eYou don’t have to use jOOQ’s type safety all the time, you can always opt out of it, but at least, by default, it’s there!\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eExample: Reactive querying\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eA great example for this type safety is \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/reactive-sql-with-jooq-3-15-and-r2dbc/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/reactive-sql-with-jooq-3-15-and-r2dbc/\" target=\"_blank\"\u003ewhen you work with R2DBC to run a reactive query\u003c/a\u003e. I don’t think anyone prefers executing the query on R2DBC directly, given that with jOOQ, a query can just be embedded e.g. in a \u003ca rel=\"noreferrer noopener\" href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\" data-type=\"URL\" data-id=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html\" target=\"_blank\"\u003ereactor \u003ccode\u003eFlux\u003c/code\u003e\u003c/a\u003e, for automatic execution and mapping.\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003erecord Table(String schema, String table) {}\n \nFlux.from(ctx\n        .select(\n            INFORMATION_SCHEMA.TABLES.TABLE_SCHEMA,\n            INFORMATION_SCHEMA.TABLES.TABLE_NAME)\n        .from(INFORMATION_SCHEMA.TABLES))\n \n    // Type safe mapping from Record2\u0026lt;String, String\u0026gt; to Table::new\n    .map(Records.mapping(Table::new))\n    .doOnNext(System.out::println)\n    .subscribe();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eMapping\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe previous example already implied that mapping is available automatically in jOOQ. There are numerous ways to map a jOOQ \u003ccode\u003eRecord\u003c/code\u003e or \u003ccode\u003eRecord[N]\u003c/code\u003e type to some user type. The most popular ways include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe historic \u003ccode\u003e\u003ca href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/DefaultRecordMapper.html\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/impl/DefaultRecordMapper.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eDefaultRecordMapper\u003c/a\u003e\u003c/code\u003e, which is reflection based and uses the \u003ccode\u003e\u003ca href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Result.html#into(java.lang.Class)\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Result.html#into(java.lang.Class)\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eResult.into(Class)\u003c/a\u003e\u003c/code\u003e API\u003c/li\u003e\n\n\n\n\u003cli\u003eThe more recently added type safe record mapper that maps \u003ccode\u003eRecord[N]\u003c/code\u003e types onto constructor references (or any other function), as in the above example.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBut mapping of records is not everything there is, there is also data type conversion!\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/\" target=\"_blank\"\u003e\u003ccode\u003eConverter\u003c/code\u003e and \u003ccode\u003eBinding\u003c/code\u003e SPIs\u003c/a\u003e that can be attached to generated code to always auto-convert things for you. JPA has a similar mechanism for entities, but you cannot access these things when you extract the jOOQ SQL query in string form.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/converter-provider/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/converter-provider/\" target=\"_blank\"\u003eAutomatic type conversion between any database type \u003ccode\u003eT\u003c/code\u003e and user type \u003ccode\u003eU\u003c/code\u003e via \u003ccode\u003eConverterProvider\u003c/code\u003e\u003c/a\u003e. The default implementation can map between things like \u003ccode\u003eInteger\u003c/code\u003e and \u003ccode\u003eLong\u003c/code\u003e or \u003ccode\u003eLocalDate\u003c/code\u003e and \u003ccode\u003eString\u003c/code\u003e or whatever. This is very useful when mapping SQL/XML to Java objects using JAXB, or SQL/JSON to Java objects using Jackson or Gson automatically! It just works out of the box!\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\" target=\"_blank\"\u003eAd-hoc converters can type safely map between a database type (e.g. from generated code) to a user type on a per-query basis\u003c/a\u003e. This is super powerful when your database schema can’t have \u003ccode\u003eConverter\u003c/code\u003e implementations attached to it globally. It also works very well when working with \u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eMULTISET\u003c/a\u003e\u003c/code\u003e or \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/nested-records/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/nested-records/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003enested \u003ccode\u003eROW\u003c/code\u003e expressions\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eExecution emulations\u003c/h2\u003e\n\n\n\n\u003cp\u003eSome SQL features are mainly emulated at runtime when executing queries using jOOQ. These include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/multiset-value-constructor/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003eMULTISET\u003c/code\u003e (nested collections)\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/nested-records/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/nested-records/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003eROW\u003c/code\u003e (nested records)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThese features that numerous jOOQ users have come to love are not usable outside of jOOQ. The generated SQL for these queries encodes the nested collections and records using SQL/XML or SQL/JSON, depending on the dialect. Of course, you could re-implement the unmarshalling of JSON to a Java object again in your own data access layer, but why? jOOQ’s works very well, and as mentioned above, is even type safe. If you reimplemented this yourself, you’d probably not achieve the same type safety level.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnother cool execution thing is the:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/batched-connection/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/batched-connection/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eBatched \u003ccode\u003eConnection\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWhich emulates batching of consecutive SQL statements automatically, without any API intervention.\u003c/p\u003e\n\n\n\n\u003ch2\u003eUser defined types\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you want to work with user defined types both on the server side as well as on the client side, all the data type bindings are built-in in jOOQ and work out of the box. For example, in PostgreSQL or Oracle (slightly different syntax):\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE TYPE name AS (\n  first_name TEXT,\n  last_name TEXT\n);\n\nCREATE TABLE user (\n  id BIGINT PRIMARY KEY,\n  name name NOT NULL\n);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNot only \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003ewill the code generator pick up these types for you\u003c/a\u003e, but you can also fetch them in a type safe way:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eResult\u0026lt;Record2\u0026lt;Long, NameRecord\u0026gt;\u0026gt; r =\nctx.select(USER.ID, USER.NAME)\n   .from(USER)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd then, obviously, apply type safe or reflective mapping on that record, whatever you prefer. I don’t think such UDT support would work as well with other execution modes. You could try it. The generated UDT types implement JDBC’s \u003ccode\u003eSQLData\u003c/code\u003e, so you should be able to bind them to a JDBC statement out of the box. But there are still edge cases.\u003c/p\u003e\n\n\n\n\u003ch2\u003eStored procedures\u003c/h2\u003e\n\n\n\n\u003cp\u003eBinding \u003ccode\u003eOUT\u003c/code\u003e or \u003ccode\u003eIN OUT\u003c/code\u003e parameters is a bit of a hassle via the lower level APIs of JDBC, R2DBC, or JPA. \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/the-best-way-to-call-stored-procedures-from-java-with-jooq/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/the-best-way-to-call-stored-procedures-from-java-with-jooq/\" target=\"_blank\"\u003eWhy not just use jOOQ, again, to execute a stored procedure call\u003c/a\u003e? Given:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE OR REPLACE PROCEDURE my_proc (\n  i1 NUMBER,\n  io1 IN OUT NUMBER,\n  o1 OUT NUMBER,\n  o2 OUT NUMBER,\n  io2 IN OUT NUMBER,\n  i2 NUMBER\n) IS\nBEGIN\n  o1 := io1;\n  io1 := i1;\n \n  o2 := io2;\n  io2 := i2;\nEND my_proc;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWhat do you prefer? This (JDBC)?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003etry (CallableStatement s = c.prepareCall(\n    \u0026#34;{ call my_proc(?, ?, ?, ?, ?, ?) }\u0026#34;\n)) {\n \n    // Set all input values\n    s.setInt(1, 1); // i1\n    s.setInt(2, 2); // io1\n    s.setInt(5, 5); // io2\n    s.setInt(6, 6); // i2\n \n    // Register all output values with their types\n    s.registerOutParameter(2, Types.INTEGER); // io1\n    s.registerOutParameter(3, Types.INTEGER); // o1\n    s.registerOutParameter(4, Types.INTEGER); // o2\n    s.registerOutParameter(5, Types.INTEGER); // io2\n \n    s.executeUpdate();\n \n    System.out.println(\u0026#34;io1 = \u0026#34; + s.getInt(2));\n    System.out.println(\u0026#34;o1 = \u0026#34; + s.getInt(3));\n    System.out.println(\u0026#34;o2 = \u0026#34; + s.getInt(4));\n    System.out.println(\u0026#34;io2 = \u0026#34; + s.getInt(5));\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr this?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// Short form, passing arguments by index (type safe):\nMyProc result = Routines.myProc(configuration, 1, 2, 5, 6);\n\n// Explicit form, passing arguments by name (type safe):\nMyProc call = new MyProc();\ncall.setI1(1);\ncall.setIo1(2);\ncall.setIo2(5);\ncall.setI2(6);\ncall.execute(configuration);\n \nSystem.out.println(\u0026#34;io1 = \u0026#34; + call.getIo1());\nSystem.out.println(\u0026#34;o1 = \u0026#34; + call.getO1());\nSystem.out.println(\u0026#34;o2 = \u0026#34; + call.getO2());\nSystem.out.println(\u0026#34;io2 = \u0026#34; + call.getIo2());\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis comparison becomes even more obvious, when you try to call stored procedures that accept / return user defined types.\u003c/p\u003e\n\n\n\n\u003ch2\u003eFetching identity values\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis is so painful across SQL dialects and JDBC drivers! Some SQL dialects have native support, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDb2, H2: \u003ccode\u003eFINAL TABLE\u003c/code\u003e (the data change delta table)\u003c/li\u003e\n\n\n\n\u003cli\u003eFirebird, MariaDB, Oracle, PostgreSQL: \u003ccode\u003eRETURNING\u003c/code\u003e (though, in Oracle, there are many challenges)\u003c/li\u003e\n\n\n\n\u003cli\u003eSQL Server: \u003ccode\u003eOUTPUT\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBut otherwise, often multiple queries need to be executed, or alternative JDBC API needs to be used. If you want to \u003ca href=\"https://blog.jooq.org/the-many-ways-to-return-data-from-sql-dml/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/the-many-ways-to-return-data-from-sql-dml/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehave a glimpse at the painful work jOOQ does for you, look here\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSimple CRUD\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn case you’re using JPA, this is probably not jOOQ’s killer feature, as JPA is a more sophisticated ORM than jOOQ, mapping associations and all. But if you’re not using JPA (e.g. JdbcTemplate or JDBC directly), then you might be very repetitively writing \u003ccode\u003eINSERT\u003c/code\u003e, \u003ccode\u003eUPDATE\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e, \u003ccode\u003eMERGE\u003c/code\u003e statements, questioning life choices, rather than simply using the \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/crud-with-updatablerecords/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/crud-with-updatablerecords/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ejOOQ API for CRUD using the \u003ccode\u003eUpdatableRecord\u003c/code\u003e API\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eManual DML has its place, especially for bulk data processing, but other than that, which do you prefer?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eIF new_record THEN\n  INSERT INTO t (a, b, c) VALUES (1, 2, 3) RETURNING id INTO :id;\nELSE\n  UPDATE t SET a = 1, b = 2, c = 3 WHERE id = :id;\nEND IF;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr just:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003et.setA(1);\nt.setB(2);\nt.setC(3);\nt.store();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBy the way, your \u003ccode\u003eTRecord\u003c/code\u003e is of course \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003egenerated\u003c/a\u003e, and it can be imported from JSON or whatever, see below!\u003c/p\u003e\n\n\n\n\u003ch2\u003eImport and export of data\u003c/h2\u003e\n\n\n\n\u003cp\u003ejOOQ supports out of the box \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/importing/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/importing/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eimport\u003c/a\u003e/\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eexport\u003c/a\u003e of data from/to numerous data formats, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-xml/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-xml/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eXML\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-csv/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-csv/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCSV\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-json/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-json/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eJSON\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-html/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-html/\" target=\"_blank\"\u003eHTML\u003c/a\u003e (export only)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-text/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-text/\" target=\"_blank\"\u003eText\u003c/a\u003e (export only)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-charts/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/exporting/exporting-charts/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCharts\u003c/a\u003e (export only)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eBetter defaults\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/comparison-with-jdbc/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/comparison-with-jdbc/\" target=\"_blank\"\u003eCompared to JDBC, jOOQ implements better defaults for most developers.\u003c/a\u003e This doesn’t mean that JDBC got it wrong. JDBC made the right choices for the purpose it was made for: A low level network protocol abstraction SPI. For jOOQ, using JDBC under the hood has been super powerful.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut for users, it’s annoying that everything is always:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eResourceful\u003c/li\u003e\n\n\n\n\u003cli\u003eLazy\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe above leads to a lot of:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eResource management with \u003ccode\u003etry-with-resources\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eManual reuse of resources, such as \u003ccode\u003ePreparedStatement\u003c/code\u003e, which produces hard to maintain stateful code\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWith jOOQ, everything a query produces is fetched into memory eagerly by default, which is the default most users need, allowing for faster closing of resources (including \u003ccode\u003eResultSet\u003c/code\u003e, \u003ccode\u003eStatement\u003c/code\u003e, \u003ccode\u003eConnection\u003c/code\u003e, behind the scenes). Of course, you can still opt into lazy streaming processing of data if you need that, \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/reactive-sql-with-jooq-3-15-and-r2dbc/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/reactive-sql-with-jooq-3-15-and-r2dbc/\" target=\"_blank\"\u003eincluding reactively using R2DBC\u003c/a\u003e!\u003c/p\u003e\n\n\n\n\u003ch2\u003eMuch more\u003c/h2\u003e\n\n\n\n\u003cp\u003eThere’s a lot more, which is worth mentioning:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/meta-data/meta-jdbc/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/meta-data/meta-jdbc/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eYou can access database meta data easily\u003c/a\u003e, using jOOQ API\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/mocking-connection/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/mocking-connection/\" target=\"_blank\"\u003eMocking is simple with jOOQ\u003c/a\u003e (though, use sparingly!)\u003c/li\u003e\n\n\n\n\u003cli\u003eYou can use \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/\" target=\"_blank\"\u003ejOOQ’s diagnostics\u003c/a\u003e, which will get a lot better, soon\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eHardly any benefit of executing outside of jOOQ\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs I promised, I wanted to explain why there is hardly any benefit of executing outside of jOOQ, unless you want to fetch data into a JPA entity, in case of which you need JPA to manage the entity lifecycle for you.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut when fetching DTOs, you don’t benefit from using JPA to execute a jOOQ query. It’s very easy to let jOOQ run a query directly on a JPA managed transaction. Flushing is necessary either way, so there’s no benefit. Other than that, JPA, JDBC, JdbcTemplate don’t do anything:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThat jOOQ can’t do equally well or better\u003c/li\u003e\n\n\n\n\u003cli\u003eThat jOOQ doesn’t fit into (transactions, connection lifecycle, mapping, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003ejOOQ can be used as a drop-in replacement for any other way of executing a value-based SQL query, i.e. whenevery you map data into DTOs rather than entities. It can map data to any target data structure including any form of DTO (classic POJO, Java 16 records, kotlin data classes, scala case classes, etc. etc.) or XML, JSON, CSV as seen before.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn fact, chances are you’ll be removing tons of repetitive boilerplate if you’re moving to jOOQ from the previous lower-level fetching and mapping code.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eJust like in the previous article about \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003ewhy you should use jOOQ with code generation\u003c/a\u003e, this article should have convinced you to go all in on all of jOOQ’s benefits, not just the query building. A lot of thought (and I mean \u003cem\u003eA LOT\u003c/em\u003e) has gone into the design of these features and APIs. I’m positive that you will find them better than the manual plumbing, once you get the hang of it.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2023-01-18T11:46:25Z",
  "modifiedTime": "2023-01-18T12:27:13Z"
}
