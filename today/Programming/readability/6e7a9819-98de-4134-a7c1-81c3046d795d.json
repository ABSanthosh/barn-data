{
  "id": "6e7a9819-98de-4134-a7c1-81c3046d795d",
  "title": "Design Token-Based UI Architecture",
  "link": "https://martinfowler.com/articles/design-token-based-ui-architecture.html",
  "description": "",
  "author": "",
  "published": "2024-12-12T10:36:00+01:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": null,
  "byline": "Andreas Kutschmann",
  "length": 24218,
  "excerpt": "Describing established patterns for organizing design tokens and practical approaches for automation",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "Design tokens, or “tokens” are fundamental design decisions represented as data. They are the foundational building blocks of design systems. Since the release of the second editor’s draft of the design token specification in 2022 and the call for tool makers to start implementing and providing feedback, the landscape of design token tools has evolved rapidly. Tools like code generators, documentation systems, and UI design software are now better equipped to support design tokens, underscoring their growing importance in modern UI architecture. In this article, I'll explain what design tokens are, when they are useful and how to apply them effectively. We'll focus on key architectural decisions that are often difficult to change later, including: How to organize design tokens in layers to balance scalability, maintainability and developer experience. Whether all tokens should be made available to product teams or just a subset. How to automate the distribution process of tokens across teams. Role of design tokens Around 2017, I was involved in a large project that used the Micro Frontend Architecture to scale development teams. In this setup, different teams were responsible for different parts of the user interface, which could be even on the same page. Each team could deploy its micro-frontend independently. There were various cases where components would be displayed on top of each other (such as dialogs or toasts appearing on top of content areas), which were not part of the same micro frontend. Teams used the CSS property z-index to control the stacking order, often relying on magic numbers—arbitrary values that weren’t documented or standardized. This approach did not scale as the project grew. It led to issues that took effort to fix, as cross-team collaboration was needed. The issue was eventually addressed with design tokens and I think makes a good example to introduce the concept. The respective token file might have looked similar to this: { \"z-index\": { \"$type\": \"number\", \"default\": { \"$value\": 1 }, \"sticky\": { \"$value\": 100 }, \"navigation\": { \"$value\": 200 }, \"spinner\": { \"$value\": 300 }, \"toast\": { \"$value\": 400 }, \"modal\": { \"$value\": 500 } } } The design tokens above represent the set of z-index values that can be used in the application and the name gives developers a good idea of where to use them. A token file like this can be integrated into the designers’ workflow and also be used to generate code, in a format that each team requires. For example, in this case, the token file might have been used to generate CSS or SCSS variables: css :root { --z-index-default: 1; --z-index-sticky: 100; --z-index-navigation: 200; --z-index-spinner: 300; --z-index-toast: 400; --z-index-modal: 500; } scss $z-index-default: 1; $z-index-sticky: 100; $z-index-navigation: 200; $z-index-spinner: 300; $z-index-toast: 400; $z-index-modal: 500; What are design tokens? Salesforce originally introduced design tokens to streamline design updates to multiple platforms. The Design Tokens Community Group describes design tokens as “a methodology for expressing design decisions in a platform-agnostic way so that they can be shared across different disciplines, tools, and technologies Let’s break this down: Cross-Disciplinary Collaboration: Design tokens act as a common language that aligns designers, developers, product managers, and other disciplines. By offering a single source of truth for design decisions, they ensure that everyone involved in the product life cycle is on the same page, leading to more efficient workflows. Tool integration: Design tokens can be integrated into various design and development tools, including UI design software, token editors, translation tools (code generators), and documentation systems. This enables design updates to be quickly reflected in the code base and are synchronized across teams. Technology adaptability: Design tokens can be translated into different technologies like CSS, SASS, and JavaScript for the web, and even used on native platforms like Android and iOS. This flexibility enables design consistency across a variety of platforms and devices. Establishing a single source of truth A key benefit of design tokens is their ability to serve as a single source of truth for both design and engineering teams. This ensures that multiple products or services maintain visual and functional consistency. A translation tool takes one or more design token files as input and generates platform-specific code as output. Some translation tools can also produce documentation for the design tokens in the form of HTML. At the time of writing, popular translation tools include ﻿Style Dictionary, ﻿Theo, ﻿Diez or ﻿Specify App. Automated design token distribution In this section, we’ll explore how to automate the distribution of design tokens to product teams. Let’s assume our goal is to provide teams with updated, tech-specific design tokens immediately after a designer makes a change. To achieve this, we can automate the translation and distribution process using a deployment pipeline for design tokens. Besides platform-specific code artifacts (like CSS for the web, XML for Android etc.), the pipeline might also deploy the documentation for the design tokens. One crucial requirement is keeping design tokens under version control. Thankfully, plugins for popular design tools like Figma already integrate with Git providers like GitHub. It's considered best practice to use the Git repository as the single source of truth for design tokens—not the design tool itself. However, this requires the plugin to support syncing both ways between the repository and the design tool, which not all plugins do. As of now, Tokens Studio is a plugin that offers this bidirectional syncing. For detailed guidance on integrating Tokens Studio with different Git providers, please refer to their documentation. The tool enables you to configure a target branch and supports a trunk-based as well as a pull-request-based workflow. Once the tokens are under version control, we can set up a deployment pipeline to build and deploy the artifacts needed by the product teams, which include platform-specific source code and documentation. The source code is typically packaged as a library and distributed via an artifact registry. This approach gives product teams control over the upgrade cycle. They can adopt updated styles by simply updating their dependencies. These updates may also be applied indirectly through updates of component libraries that use the token-based styles. Figure 2: Automated design token distribution This overall setup has allowed teams at Thoughtworks to roll out smaller design changes across multiple front-ends and teams in a single day. Fully automated pipeline The most straightforward way to design the pipeline would be a fully automated trunk-based workflow. In this setup, all changes pushed to the main branch will be immediately deployed as long as they pass the automated quality gates. Such a pipeline might consist of the following jobs: Check: Validate the design token files using a design token validator or a JSON validator. Build: Use a translation tool like Style Dictionary to convert design token files into platform-specific formats. This job might also build the docs using the translation tool or by integrating a dedicated documentation tool. Test: This job is highly dependent on the testing strategy. Although some tests can be done using the design token file directly (like checking the color contrast), a common approach is to test the generated code using a documentation tool such as Storybook. Storybook has excellent test support for visual regression tests, accessibility tests, interaction tests, and other test types. Publish: Publish updated tokens to a package manager (for example, npm). The release process and versioning can be fully automated with a package publishing tool that is based on Conventional Commits like semantic-release. semantic-release also allows the deployment of packages to multiple platforms. The publish job might also deploy documentation for the design tokens. Notify: Inform teams of the new token version via email or chat, so that they can update their dependencies. Figure 3: Fully automated deployment pipeline Pipeline including manual approval Sometimes fully automated quality gates are not sufficient. If a manual review is required before publishing, a common approach is to deploy an updated version of the documentation with the latest design token to a preview environment (a temporary environment). If a tool like Storybook is used, this preview might contain not only the design tokens but also show them integrated with the components used in the application. An approval process can be implemented via a pull-request workflow. Or, it can be a manual approval / deployment step in the pipeline. Figure 4: Deployment pipeline with manual approval Organizing tokens in layers As discussed earlier, design tokens represent design decisions as data. However, not all decisions operate at the same level of detail. Instead, ideally, general design decisions guide more specific ones. Organizing tokens (or design decisions) into layers allows designers to make decisions at the right level of abstraction, supporting consistency and scalability. For instance, making individual color choices for every new component isn’t practical. Instead, it’s more efficient to define a foundational color palette and then decide how and where those colors are applied. This approach reduces the number of decisions while maintaining a consistent look and feel. There are three key types of design decisions for which design tokens are used. They build on top of one another: What design options are available to use? How are those styles applied across the user interface? Where exactly are those styles applied (in which components)? There are various names for these three types of tokens (as usual, naming is the hard part). In this article, we’ll use the terms proposed by Samantha Gordashko: option tokens, decision tokens and component tokens. Let’s use our color example to illustrate how design tokens can answer the three questions above. Option tokens: defining what design options are provided Option tokens (also called primitive tokens, base tokens, core tokens, foundation tokens or reference tokens) define what styles can be used in the application. They define things like color palettes, spacing/sizing scales or font families. Not all of them are necessarily used in the application, but they present reasonable options. Using our example, let’s assume we have a color palette with 9 shades for each color, ranging from very light to highly saturated. Below, we define the blue tones and grey tones as option-tokens: { \"color\": { \"$type\": \"color\", \"options\": { \"blue-100\": {\"$value\": \"#e0f2ff\"}, \"blue-200\": {\"$value\": \"#cae8ff\"}, \"blue-300\": {\"$value\": \"#b5deff\"}, \"blue-400\": {\"$value\": \"#96cefd\"}, \"blue-500\": {\"$value\": \"#78bbfa\"}, \"blue-600\": {\"$value\": \"#59a7f6\"}, \"blue-700\": {\"$value\": \"#3892f3\"}, \"blue-800\": {\"$value\": \"#147af3\"}, \"blue-900\": {\"$value\": \"#0265dc\"}, \"grey-100\": {\"$value\": \"#f8f8f8\"}, \"grey-200\": {\"$value\": \"#e6e6e6\"}, \"grey-300\": {\"$value\": \"#d5d5d5\"}, \"grey-400\": {\"$value\": \"#b1b1b1\"}, \"grey-500\": {\"$value\": \"#909090\"}, \"grey-600\": {\"$value\": \"#6d6d6d\"}, \"grey-700\": {\"$value\": \"#464646\"}, \"grey-800\": {\"$value\": \"#222222\"}, \"grey-900\": {\"$value\": \"#000000\"}, \"white\": {\"$value\": \"#ffffff\"} } } } Although it’s highly useful to have reasonable options, option tokens fall short of being sufficient for guiding developers on how and where to apply them. Decision tokens: defining how styles are applied Decision tokens (also called semantic tokens or system tokens) specify how those style options should be applied contextually across the UI. In the context of our color example, they might include decisions like the following: grey-100 is used as a surface color. grey-200 is used for the background of disabled elements. grey-400 is used for the text of disabled elements. grey-900 is used as a default color for text. blue-900 is used as an accent color. white is used for text on accent color backgrounds. The corresponding decision token file would look like this: { \"color\": { \"$type\": \"color\", \"decisions\": { \"surface\": { \"$value\": \"{color.options.grey-100}\", \"description\": \"Used as a surface color.\" }, \"background-disabled\": { \"$value\": \"{color.options.grey-200}\", \"description\":\"Used for the background of disabled elements.\" }, \"text-disabled\": { \"$value\": \"{color.options.grey-400}\", \"description\": \"Used for the text of disabled elements.\" }, \"text\": { \"$value\": \"{color.options.grey-900}\", \"description\": \"Used as default text color.\" }, \"accent\": { \"$value\": \"{color.options.blue-900}\", \"description\": \"Used as an accent color.\" }, \"text-on-accent\": { \"$value\": \"{color.options.white}\", \"description\": \"Used for text on accent color backgrounds.\" } } } } As a developer, I would mostly be interested in the decisions, not the options. For example, color tokens typically contain a long list of options (a color palette), while very few of those options are actually used in the application. The tokens that are actually relevant when deciding which styles to apply, would be usually the decision tokens. Decision tokens use references to the option tokens. I think of organizing tokens this way as a layered architecture. In other articles, I have often seen the term tier being used, but I think layer is the better word, as there is no physical separation implied. The diagram below visualizes the two layers we talked about so far: Figure 5: 2-layer pattern Component tokens: defining where styles are applied Component tokens (or component-specific tokens) map the decision tokens to specific parts of the UI. They show where styles are applied. The term component in the context of design tokens does not always map to the technical term component. For example, a button might be implemented as a UI component in some applications, while other applications just use the button HTML element instead. Component tokens could be used in both cases. Component tokens can be organised in a group referencing multiple decision tokens. In our example, this references might include text- and background-colors for different variants of the button (primary, secondary) as well as disabled buttons. They might also include references to tokens of other types (spacing/sizing, borders etc.) which I'll omit in the following example: { \"button\": { \"primary\": { \"background\": { \"$value\": \"{color.decisions.accent}\" }, \"text\": { \"$value\": \"{color.decisions.text-on-accent}\" } }, \"secondary\": { \"background\": { \"$value\": \"{color.decisions.surface}\" }, \"text\": { \"$value\": \"{color.decisions.text}\" } }, \"background-disabled\": { \"$value\": \"{color.decisions.background-disabled}\" }, \"text-disabled\": { \"$value\": \"{color.decisions.text-disabled}\" } } } To some degree, component tokens are simply the result of applying decisions to specific components. However, as this example shows, this process isn’t always straightforward—especially for developers without design experience. While decision tokens can offer a general sense of which styles to use in a given context, component tokens provide additional clarity. Figure 6: 3-layer pattern Note: there may be “snowflake” situations where layers are skipped. For example, it might not be possible to define a general decision for every single component token, or those decisions might not have been made yet (for example at the beginning of a project). Token scope I already mentioned that while option tokens are very helpful to designers, they might not be relevant for application developers using the platform-specific code artifacts. Application developers will typically be more interested in the decision/component tokens. Although token scope is not yet included in the design token spec, some design systems already separate tokens into private (also called internal) and public (also called global) tokens. For example, the Salesforce Lightning Design System introduced a flag for each token. There are various reasons why this can be a good idea: it guides developers on which tokens to use fewer options provide a better developer experience it reduces the file size as not all tokens need to be included private/internal tokens can be changed or removed without breaking changes A downside of making option tokens private is that developers would rely on designers to always make those styles available as decision or component tokens. This could become an issue in case of limited availability of the designers or if not all decisions are available, for example at the start of a project. Unfortunately, there is no standardized solution yet for implementing scope for design tokens. So the approach depends on the tool-chain of the project and will most likely need some custom code. File-based scope Using Style Dictionary, we can use a filter to expose only public tokens. The most straightforward approach would be to filter on the file ending. If we use different file endings for component, decision and option tokens, we can use a filter on the file path, for example, to make the option tokens layer private. Style Dictionary config const styleDictionary = new StyleDictionary({ \"source\": [\"color.options.json\", \"color.decisions.json\"], \"platforms\": { \"css\": { \"transformGroup\": \"css\", \"files\": [ { \"destination\": \"variables.css\", \"filter\": token =\u003e !token.filePath.endsWith('options.json'), \"format\": \"css/variables\" } ] } } }); The resulting CSS variables would contain only these decision tokens, and not the option tokens. Generated CSS variables :root { --color-decisions-surface: #f8f8f8; --color-decisions-background-disabled: #e6e6e6; --color-decisions-text-disabled: #b1b1b1; --color-decisions-text: #000000; --color-decisions-accent: #0265dc; --color-decisions-text-on-accent: #ffffff; } A more flexible approach If more flexibility is needed, it might be preferable to add a scope flag to each token and to filter based on this flag: Style Dictionary config const styleDictionary = new StyleDictionary({ \"source\": [\"color.options.json\", \"color.decisions.json\"], \"platforms\": { \"css\": { \"transformGroup\": \"css\", \"files\": [ { \"destination\": \"variables.css\", \"filter\": { \"public\": true }, \"format\": \"css/variables\" } ] } } }); If we then add the flag to the decision tokens, the resulting CSS would be the same as above: Tokens with scope flag { \"color\": { \"$type\": \"color\", \"decisions\": { \"surface\": { \"$value\": \"{color.options.grey-100}\", \"description\": \"Used as a surface color.\", \"public\": true }, \"background-disabled\": { \"$value\": \"{color.options.grey-200}\", \"description\":\"Used for the background of disabled elements.\", \"public\": true }, \"text-disabled\": { \"$value\": \"{color.options.grey-400}\", \"description\": \"Used for the text of disabled elements.\", \"public\": true }, \"text\": { \"$value\": \"{color.options.grey-900}\", \"description\": \"Used as default text color.\", \"public\": true }, \"accent\": { \"$value\": \"{color.options.blue-900}\", \"description\": \"Used as an accent color.\", \"public\": true }, \"text-on-accent\": { \"$value\": \"{color.options.white}\", \"description\": \"Used for text on accent color backgrounds.\", \"public\": true } } } } Generated CSS variables :root { --color-decisions-surface: #f8f8f8; --color-decisions-background-disabled: #e6e6e6; --color-decisions-text-disabled: #b1b1b1; --color-decisions-text: #000000; --color-decisions-accent: #0265dc; --color-decisions-text-on-accent: #ffffff; } Such flags can now also be set through the Figma UI (if using Figma variables as a source of truth for design tokens). It is available as hiddenFromPublishing flag via the Plugins API. Should I use design tokens? Design tokens offer significant benefits for modern UI architecture, but they may not be the right fit for every project. Benefits include: Improved lead time for design changes Consistent design language and UI architecture across platforms and technologies Design tokens being relatively lightweight from an implementation point of view Drawbacks include: Initial effort for automation Designers might have to (to some degree) interact with Git Standardization is still in progress Consider the following when deciding whether to adopt design tokens: When to use design tokens Multi-Platform or Multi-Application Environments: When working across multiple platforms (web, iOS, Android…) or maintaining several applications or frontends, design tokens ensure a consistent design language across all of them. Frequent Design Changes: For environments with regular design updates, design tokens provide a structured way to manage and propagate changes efficiently. Large Teams: For teams with many designers and developers, design tokens facilitate collaboration. Automated Workflows: If you’re familiar with CI/CD pipelines, the effort to add a design token pipeline is relatively low. There are also commercial offerings. When design tokens might not be necessary Small projects: For smaller projects with limited scope and minimal design complexity, the overhead of managing design tokens might not be worth the effort. No issue with design changes: If the speed of design changes, consistency and collaboration between design and engineering are not an issue, then you might also not need design tokens.",
  "image": "https://martinfowler.com/articles/design-token-based-ui-architecture/card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eDesign tokens, or “tokens” are fundamental design decisions represented\n    as data. They are the foundational building blocks of design systems.\u003c/p\u003e\n\n\u003cp\u003eSince the release of the \u003ca href=\"https://second-editors-draft.tr.designtokens.org/format/\"\u003esecond editor’s\n    draft\u003c/a\u003e of the\n    design token specification in 2022 and the \u003ca href=\"https://www.w3.org/community/design-tokens/2022/06/14/call-to-implement-the-second-editors-draft-and-share-feedback/\"\u003ecall for tool\n    makers\u003c/a\u003e\n    to start implementing and providing feedback, the landscape of design token\n    tools has evolved rapidly. Tools like code generators, documentation\n    systems, and UI design software are now better equipped to support design\n    tokens, underscoring their growing importance in modern UI architecture.\u003c/p\u003e\n\n\u003cp\u003eIn this article, I\u0026#39;ll explain what design tokens are, when they are useful and how to apply\n    them effectively. We\u0026#39;ll focus on key architectural decisions that are often difficult to change later, including:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eHow to organize design tokens in layers to balance scalability, maintainability and developer experience.\u003c/li\u003e\n\n\u003cli\u003eWhether all tokens should be made available to product teams or just a subset.\u003c/li\u003e\n\n\u003cli\u003eHow to automate the distribution process of tokens across teams.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003csection id=\"RoleOfDesignTokens\"\u003e\n\u003ch2\u003eRole of design tokens\u003c/h2\u003e\n\n\u003cp\u003eAround 2017, I was involved in a large project that used the \u003ca href=\"https://martinfowler.com/articles/micro-frontends.html\"\u003eMicro\n      Frontend\n      Architecture\u003c/a\u003e to\n      scale development teams. In this setup, different teams were responsible\n      for different parts of the user interface, which could be even on the same\n      page. Each team could deploy its micro-frontend independently.\u003c/p\u003e\n\n\u003cp\u003eThere were various cases where components would be displayed on top of\n      each other (such as dialogs or toasts appearing on top of content areas),\n      which were not part of the same micro frontend. Teams used the CSS\n      property \u003ccode\u003ez-index\u003c/code\u003e to control the stacking order, often relying on magic\n      numbers—arbitrary values that weren’t documented or standardized. This approach\n      did not scale as the project grew. It led to issues that took effort to\n      fix, as cross-team collaboration was needed.\u003c/p\u003e\n\n\u003cp\u003eThe issue was eventually addressed with design tokens and I think makes\n      a good example to introduce the concept. The respective token file might\n      have looked similar to this:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;z-index\u0026#34;: {\n    \u0026#34;$type\u0026#34;: \u0026#34;number\u0026#34;,\n    \u0026#34;default\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 1\n    },\n    \u0026#34;sticky\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 100\n    },\n    \u0026#34;navigation\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 200\n    },\n    \u0026#34;spinner\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 300\n    },\n    \u0026#34;toast\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 400\n    },\n    \u0026#34;modal\u0026#34;: {\n      \u0026#34;$value\u0026#34;: 500\n    }\n  }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThe design tokens above represent the set of \u003ccode\u003ez-index\u003c/code\u003e values that can\n      be used in the application and the name gives developers a good idea of\n      where to use them. A token file like this can be integrated into the\n      designers’ workflow and also be used to generate code, in a format that\n      each team requires. For example, in this case, the token file might have\n      been used to generate CSS or SCSS variables:\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003ecss\n\u003c/p\u003e\n\n\u003cpre\u003e  :root {\n    --z-index-default: 1;\n    --z-index-sticky: 100;\n    --z-index-navigation: 200;\n    --z-index-spinner: 300;\n    --z-index-toast: 400;\n    --z-index-modal: 500;\n  }\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cdiv\u003e\n\u003cp\u003escss\n\u003c/p\u003e\n\n\u003cpre\u003e  \n  $z-index-default: 1;\n  $z-index-sticky: 100;\n  $z-index-navigation: 200;\n  $z-index-spinner: 300;\n  $z-index-toast: 400;\n  $z-index-modal: 500;\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003csection id=\"WhatAreDesignTokens\"\u003e\n\u003ch3\u003eWhat are design tokens?\u003c/h3\u003e\n\n\u003cp\u003eSalesforce \u003ca href=\"https://www.smashingmagazine.com/2019/11/smashing-podcast-episode-3/\"\u003eoriginally introduced design tokens\u003c/a\u003e to streamline design\n      updates to multiple\n      platforms.\u003c/p\u003e\n\n\u003cp\u003eThe Design Tokens Community Group \u003ca href=\"https://second-editors-draft.tr.designtokens.org/format/#introduction\"\u003edescribes design tokens\u003c/a\u003e as “a\n      methodology for expressing design decisions in a platform-agnostic way so\n      that they can be shared across different \u003cb\u003edisciplines\u003c/b\u003e, \u003cb\u003etools\u003c/b\u003e, and\n      \u003cb\u003etechnologies\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003eLet’s break this down:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eCross-Disciplinary Collaboration:\u003c/b\u003e Design tokens act as a common language\n        that aligns designers, developers, product managers, and other disciplines. By\n        offering a single source of truth for design decisions, they ensure that\n        everyone involved in the product life cycle is on the same page, leading to more\n        efficient workflows.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eTool integration:\u003c/b\u003e Design tokens can be integrated into various design\n        and development tools, including UI design software, token editors, translation\n        tools (code generators), and documentation systems. This enables design updates\n        to be quickly reflected in the code base and are synchronized across teams.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eTechnology adaptability:\u003c/b\u003e Design tokens can be translated into different\n        technologies like CSS, SASS, and JavaScript for the web, and even used on native\n        platforms like Android and iOS. This flexibility enables design consistency\n        across a variety of platforms and devices.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"EstablishingASingleSourceOfTruth\"\u003e\n\u003ch2\u003eEstablishing a single source of truth\u003c/h2\u003e\n\n\u003cp\u003eA key benefit of design tokens is their ability to serve as a single\n      source of truth for both design and engineering teams. This ensures that\n      multiple products or services maintain visual and functional\n      consistency.\u003c/p\u003e\n\n\u003cp\u003eA \u003ca href=\"https://tr.designtokens.org/format/#translation-tool\"\u003etranslation\n      tool\u003c/a\u003e takes one or\n      more design token files as input and generates platform-specific code as\n      output. Some translation tools can also produce documentation for the\n      design tokens in the form of HTML. At the time of writing, popular\n      translation tools include ﻿\u003ca href=\"https://styledictionary.com/\"\u003eStyle\n      Dictionary\u003c/a\u003e,\n      ﻿\u003ca href=\"https://github.com/salesforce-ux/theo\"\u003eTheo\u003c/a\u003e, ﻿\u003ca href=\"https://diez.org/\"\u003eDiez\u003c/a\u003e\n      or ﻿\u003ca href=\"https://specifyapp.com/\"\u003eSpecify App\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\n\u003c/section\u003e\n\n\u003csection id=\"AutomatedDesignTokenDistribution\"\u003e\n\u003ch2\u003eAutomated design token distribution\u003c/h2\u003e\n\n\u003cp\u003eIn this section, we’ll explore how to automate the distribution of\n      design tokens to product teams.\u003c/p\u003e\n\n\u003cp\u003eLet’s assume our goal is to provide teams with updated, tech-specific\n      design tokens immediately after a designer makes a change. To achieve\n      this, we can automate the translation and distribution process using a\n      deployment pipeline for design tokens. Besides platform-specific code\n      artifacts (like CSS for the web, XML for Android etc.), the pipeline might\n      also deploy the documentation for the design tokens.\u003c/p\u003e\n\n\u003cp\u003eOne crucial requirement is keeping design tokens under version control.\n      Thankfully, plugins for popular design tools like Figma already integrate\n      with Git providers like GitHub. It\u0026#39;s considered best practice to use the\n      Git repository as the single source of truth for design tokens—not the\n      design tool itself. However, this requires the plugin to support syncing\n      both ways between the repository and the design tool, which not all\n      plugins do. As of now, Tokens Studio is a plugin that offers this\n      bidirectional syncing. For detailed guidance on integrating Tokens Studio\n      with different Git providers, please refer to their\n      \u003ca href=\"https://docs.tokens.studio/token-storage-and-sync/sync-provider-overview\"\u003edocumentation\u003c/a\u003e.\n      The tool enables you to configure a target branch and supports a\n      trunk-based as well as a pull-request-based workflow.\u003c/p\u003e\n\n\u003cp\u003eOnce the tokens are under version control, we can set up a deployment\n      pipeline to build and deploy the artifacts needed by the product teams,\n      which include platform-specific source code and documentation. The source\n      code is typically packaged as a library and distributed via an artifact\n      registry. This approach gives product teams control over the upgrade\n      cycle. They can adopt updated styles by simply updating their\n      dependencies. These updates may also be applied indirectly through updates of component\n      libraries that use the token-based styles.\u003c/p\u003e\n\n\u003cdiv id=\"token-distribution.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/design-token-based-ui-architecture/token-distribution.svg\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 2: Automated design token distribution\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis overall setup has allowed teams at Thoughtworks to roll out\n      smaller design changes across multiple front-ends and teams in a single\n      day.\u003c/p\u003e\n\n\u003csection id=\"FullyAutomatedPipeline\"\u003e\n\u003ch3\u003eFully automated pipeline\u003c/h3\u003e\n\n\u003cp\u003eThe most straightforward way to design the pipeline would be a\n          fully automated trunk-based workflow. In this setup, all changes\n          pushed to the main branch will be immediately deployed as long as they\n          pass the automated quality gates.\u003c/p\u003e\n\n\u003cp\u003eSuch a pipeline might consist of the following jobs:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cb\u003eCheck:\u003c/b\u003e Validate the design token files using a design token validator\n            or a JSON validator.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eBuild:\u003c/b\u003e Use a translation tool like \u003ca href=\"https://styledictionary.com/\"\u003eStyle\n            Dictionary\u003c/a\u003e to convert design token files into\n            platform-specific formats. This job might also build the docs using the\n            translation tool or by integrating a dedicated documentation tool.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eTest:\u003c/b\u003e This job is highly dependent on the testing strategy. Although\n            some tests can be done using the design token file directly (like checking the\n            color contrast), a common approach is to test the generated code using a\n            documentation tool such as Storybook. Storybook has excellent \u003ca href=\"https://storybook.js.org/docs/writing-tests\"\u003etest\n            support\u003c/a\u003e for visual regression\n            tests, accessibility tests, interaction tests, and other test types.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003ePublish:\u003c/b\u003e Publish updated tokens to a package manager (for example,\n            npm). The release process and versioning can be fully automated with a package\n            publishing tool that is based on \u003ca href=\"https://www.conventionalcommits.org/\"\u003eConventional\n            Commits\u003c/a\u003e like\n            \u003ca href=\"https://github.com/semantic-release/semantic-release\"\u003esemantic-release\u003c/a\u003e.\n            semantic-release also allows the deployment of packages to multiple platforms.\n            The publish job might also deploy documentation for the design tokens.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eNotify:\u003c/b\u003e Inform teams of the new token version via email or chat, so\n            that they can update their dependencies.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cdiv id=\"pipeline-fully-automated.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/design-token-based-ui-architecture/pipeline-fully-automated.svg\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 3: Fully automated deployment pipeline\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"PipelineIncludingManualApproval\"\u003e\n\u003ch3\u003ePipeline including manual approval\u003c/h3\u003e\n\n\u003cp\u003eSometimes fully automated quality gates are not sufficient. If a\n          manual review is required before publishing, a common approach is to\n          deploy an updated version of the documentation with the latest design\n          token to a preview environment (a temporary environment).\u003c/p\u003e\n\n\u003cp\u003eIf a tool like Storybook is used, this preview might contain not\n          only the design tokens but also show them integrated with the\n          components used in the application.\u003c/p\u003e\n\n\u003cp\u003eAn approval process can be implemented via a pull-request workflow.\n          Or, it can be a manual approval / deployment step in the pipeline.\u003c/p\u003e\n\n\u003cdiv id=\"pipeline-incl-review.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/design-token-based-ui-architecture/pipeline-incl-review.svg\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 4: Deployment pipeline with manual approval\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"OrganizingTokensInLayers\"\u003e\n\u003ch2\u003eOrganizing tokens in layers\u003c/h2\u003e\n\n\u003cp\u003eAs discussed earlier, design tokens represent design decisions as data.\n      However, not all decisions operate at the same level of detail. Instead,\n      ideally, general design decisions guide more specific ones. Organizing\n      tokens (or design decisions) into layers allows designers to make\n      decisions at the right level of abstraction, supporting consistency and\n      scalability.\u003c/p\u003e\n\n\u003cp\u003eFor instance, making individual color choices for every new component isn’t practical.\n      Instead, it’s more efficient to define a foundational color palette and then\n      decide how and where those colors are applied. This approach reduces the\n      number of decisions while maintaining a consistent look and feel.\u003c/p\u003e\n\n\u003cp\u003eThere are three key types of design decisions for which design tokens\n      are used. They build on top of one another:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eWhat\u003c/b\u003e design options are available to use?\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eHow\u003c/b\u003e are those styles applied across the user interface?\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eWhere\u003c/b\u003e exactly are those styles applied (in which components)?\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThere are various names for these three types of tokens (as usual,\n      naming is the hard part). In this article, we’ll use the terms \u003ca href=\"https://samiamdesigns.substack.com/p/a-new-approach-to-naming-design-tokens\"\u003eproposed\n      by Samantha\n      Gordashko\u003c/a\u003e:\n      option tokens, decision tokens and component tokens.\u003c/p\u003e\n\n\u003cp\u003eLet’s use our color example to illustrate how design tokens can\n      answer the three questions above.\u003c/p\u003e\n\n\u003csection id=\"OptionTokensDefiningWhatDesignOptionsAreProvided\"\u003e\n\u003ch3\u003eOption tokens: defining what design options are provided\u003c/h3\u003e\n\n\u003cp\u003e\u003ci\u003eOption tokens\u003c/i\u003e (also called \u003ci\u003eprimitive tokens\u003c/i\u003e, \u003ci\u003ebase tokens\u003c/i\u003e, \u003ci\u003ecore\n      tokens\u003c/i\u003e, \u003ci\u003efoundation tokens\u003c/i\u003e or \u003ci\u003ereference tokens\u003c/i\u003e) define \u003cb\u003ewhat\u003c/b\u003e\n      styles can be used in the application. They define things like color\n      palettes, spacing/sizing scales or font families. Not all of them are\n      necessarily used in the application, but they present reasonable\n      options.\u003c/p\u003e\n\n\u003cp\u003eUsing our example, let’s assume we have a color palette with 9 shades for each color,\n      ranging from very light to highly saturated. Below, we define the blue tones and grey tones as option-tokens:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;color\u0026#34;: {\n    \u0026#34;$type\u0026#34;: \u0026#34;color\u0026#34;,\n    \u0026#34;options\u0026#34;: {\n      \u0026#34;blue-100\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#e0f2ff\u0026#34;},\n      \u0026#34;blue-200\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#cae8ff\u0026#34;},\n      \u0026#34;blue-300\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#b5deff\u0026#34;},\n      \u0026#34;blue-400\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#96cefd\u0026#34;},\n      \u0026#34;blue-500\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#78bbfa\u0026#34;},\n      \u0026#34;blue-600\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#59a7f6\u0026#34;},\n      \u0026#34;blue-700\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#3892f3\u0026#34;},\n      \u0026#34;blue-800\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#147af3\u0026#34;},\n      \u0026#34;blue-900\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#0265dc\u0026#34;},\n      \u0026#34;grey-100\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#f8f8f8\u0026#34;},\n      \u0026#34;grey-200\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#e6e6e6\u0026#34;},\n      \u0026#34;grey-300\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#d5d5d5\u0026#34;},\n      \u0026#34;grey-400\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#b1b1b1\u0026#34;},\n      \u0026#34;grey-500\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#909090\u0026#34;},\n      \u0026#34;grey-600\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#6d6d6d\u0026#34;},\n      \u0026#34;grey-700\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#464646\u0026#34;},\n      \u0026#34;grey-800\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#222222\u0026#34;},\n      \u0026#34;grey-900\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#000000\u0026#34;},\n      \u0026#34;white\u0026#34;: {\u0026#34;$value\u0026#34;: \u0026#34;#ffffff\u0026#34;}\n    }\n  }\n}\u003c/pre\u003e\n\n\u003cp\u003eAlthough it’s highly useful to have reasonable options, option tokens fall short\n      of being sufficient for guiding developers on how and where to apply them.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"DecisionTokensDefiningHowStylesAreApplied\"\u003e\n\u003ch3\u003eDecision tokens: defining how styles are applied\u003c/h3\u003e\n\n\u003cp\u003e\u003ci\u003eDecision tokens\u003c/i\u003e (also called \u003ci\u003esemantic tokens\u003c/i\u003e or \u003ci\u003esystem tokens\u003c/i\u003e)\n      specify \u003cb\u003ehow\u003c/b\u003e those style options should be applied contextually across\n      the UI.\u003c/p\u003e\n\n\u003cp\u003eIn the context of our color example, they might include decisions like the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003egrey-100 is used as a surface color.\u003c/li\u003e\n\n\u003cli\u003egrey-200 is used for the background of disabled elements.\u003c/li\u003e\n\n\u003cli\u003egrey-400 is used for the text of disabled elements.\u003c/li\u003e\n\n\u003cli\u003egrey-900 is used as a default color for text.\u003c/li\u003e\n\n\u003cli\u003eblue-900 is used as an accent color.\u003c/li\u003e\n\n\u003cli\u003ewhite is used for text on accent color backgrounds.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe corresponding decision token file would look like this:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;color\u0026#34;: {\n    \u0026#34;$type\u0026#34;: \u0026#34;color\u0026#34;,\n    \u0026#34;decisions\u0026#34;: {\n      \u0026#34;surface\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-100}\u0026#34;,\n        \u0026#34;description\u0026#34;: \u0026#34;Used as a surface color.\u0026#34;\n      },\n      \u0026#34;background-disabled\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-200}\u0026#34;,\n        \u0026#34;description\u0026#34;:\u0026#34;Used for the background of disabled elements.\u0026#34;\n      },\n      \u0026#34;text-disabled\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-400}\u0026#34;,\n        \u0026#34;description\u0026#34;: \u0026#34;Used for the text of disabled elements.\u0026#34;\n      },\n      \u0026#34;text\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-900}\u0026#34;,\n        \u0026#34;description\u0026#34;: \u0026#34;Used as default text color.\u0026#34;\n      },\n      \u0026#34;accent\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.blue-900}\u0026#34;,\n        \u0026#34;description\u0026#34;: \u0026#34;Used as an accent color.\u0026#34;\n      },\n      \u0026#34;text-on-accent\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.options.white}\u0026#34;,\n        \u0026#34;description\u0026#34;: \u0026#34;Used for text on accent color backgrounds.\u0026#34;\n      }\n    }\n  }\n}\u003c/pre\u003e\n\n\u003cp\u003eAs a developer, I would mostly be interested in the decisions, not the\n      options. For example, color tokens typically contain a long list of options (a\n      color palette), while very few of those options are actually used in\n      the application. The tokens that are actually relevant when deciding which\n      styles to apply, would be usually the decision tokens.\u003c/p\u003e\n\n\u003cp\u003eDecision tokens use\n      \u003ca href=\"https://tr.designtokens.org/format/#alias-reference\"\u003ereferences\u003c/a\u003e to the\n      option tokens. I think of organizing tokens this way as a layered\n      architecture. In other articles, I have often seen the term \u003ci\u003etier\u003c/i\u003e being\n      used, but I think \u003ci\u003elayer\u003c/i\u003e is the better word, as there is no physical\n      separation implied. The diagram below visualizes the two layers we talked\n      about so far:\u003c/p\u003e\n\n\u003cdiv id=\"2-layer.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/design-token-based-ui-architecture/2-layer.svg\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 5: 2-layer pattern\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"ComponentTokensDefiningWhereStylesAreApplied\"\u003e\n\u003ch3\u003eComponent tokens: defining where styles are applied\u003c/h3\u003e\n\n\u003cp\u003e\u003ci\u003eComponent tokens\u003c/i\u003e (or \u003ci\u003ecomponent-specific tokens\u003c/i\u003e) map the \u003ci\u003edecision\n      tokens\u003c/i\u003e to specific parts of the UI. They show \u003cb\u003ewhere\u003c/b\u003e styles are\n      applied.\u003c/p\u003e\n\n\u003cp\u003eThe term \u003ci\u003ecomponent\u003c/i\u003e in the context of design tokens does not always\n      map to the technical term component. For example, a button might be\n      implemented as a UI component in some applications, while other\n      applications just use the \u003ccode\u003ebutton\u003c/code\u003e HTML element instead. \u003ci\u003eComponent\n      tokens\u003c/i\u003e could be used in both cases.\u003c/p\u003e\n\n\u003cp\u003eComponent tokens can be organised in a \u003ca href=\"https://tr.designtokens.org/format/#group\"\u003e\u003ci\u003egroup\u003c/i\u003e\u003c/a\u003e referencing multiple decision tokens. In our example, this references\n      might include text- and background-colors for different variants of the button (primary, secondary) as well as disabled buttons.\n      They might also include references to tokens of other types (spacing/sizing, borders etc.) which I\u0026#39;ll omit in the\n      following example:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;button\u0026#34;: {\n    \u0026#34;primary\u0026#34;: {\n      \u0026#34;background\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.accent}\u0026#34;\n      },\n      \u0026#34;text\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.text-on-accent}\u0026#34;\n      }\n    },\n    \u0026#34;secondary\u0026#34;: {\n      \u0026#34;background\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.surface}\u0026#34;\n      },\n      \u0026#34;text\u0026#34;: {\n        \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.text}\u0026#34;\n      }\n    },\n    \u0026#34;background-disabled\u0026#34;: {\n      \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.background-disabled}\u0026#34;\n    },\n    \u0026#34;text-disabled\u0026#34;: {\n      \u0026#34;$value\u0026#34;: \u0026#34;{color.decisions.text-disabled}\u0026#34;\n    }\n  }\n}\u003c/pre\u003e\n\n\u003cp\u003eTo some degree, component tokens are simply the result of applying\n      decisions to specific components. However, as this\n      example shows, this process isn’t always straightforward—especially for\n      developers without design experience. While decision tokens can offer a\n      general sense of which styles to use in a given context, component tokens\n      provide additional clarity.\u003c/p\u003e\n\n\u003cdiv id=\"3-layer.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/design-token-based-ui-architecture/3-layer.svg\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 6: 3-layer pattern\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e there may be “snowflake” situations where layers are skipped.\n      For example, it might not be possible to define a general decision for\n      every single component token, or those decisions might not have been made\n      yet (for example at the beginning of a project).\u003c/p\u003e\n\u003c/section\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"TokenScope\"\u003e\n\u003ch2\u003eToken scope\u003c/h2\u003e\n\n\u003cp\u003eI already mentioned that while option tokens are very helpful to\n    designers, they might not be relevant for application developers using the\n    platform-specific code artifacts. Application developers will typically be\n    more interested in the decision/component tokens.\u003c/p\u003e\n\n\u003cp\u003eAlthough token scope is not yet included in the design token\n    spec, some design\n    systems already separate tokens into private (also called \u003ci\u003einternal\u003c/i\u003e) and\n    public (also called \u003ci\u003eglobal\u003c/i\u003e) tokens. For example, the Salesforce Lightning\n    Design System introduced \u003ca href=\"https://www.lightningdesignsystem.com/design-tokens/\"\u003ea flag for each\n    token\u003c/a\u003e. There are\n    various reasons why this can be a good idea:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eit guides developers on which tokens to use\u003c/li\u003e\n\n\u003cli\u003efewer options provide a better developer experience\u003c/li\u003e\n\n\u003cli\u003eit reduces the file size as not all tokens need to be included\u003c/li\u003e\n\n\u003cli\u003eprivate/internal tokens can be changed or removed without breaking\n      changes\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA downside of making option tokens private is that developers would rely\n    on designers to always make those styles available as decision or component\n    tokens. This could become an issue in case of limited availability of the\n    designers or if not all decisions are available, for example at the start of\n    a project.\u003c/p\u003e\n\n\u003cp\u003eUnfortunately, there is no standardized solution yet for implementing\n    scope for design tokens. So the approach depends on the tool-chain of the\n    project and will most likely need some custom code.\u003c/p\u003e\n\n\u003csection id=\"File-basedScope\"\u003e\n\u003ch3\u003eFile-based scope\u003c/h3\u003e\n\n\u003cp\u003eUsing Style Dictionary, we can use a\n      \u003ca href=\"https://styledictionary.com/reference/hooks/filters/\"\u003e\u003ci\u003efilter\u003c/i\u003e\u003c/a\u003e to\n      expose only public tokens. The most straightforward approach would be to\n      filter on the file ending. If we use different file endings for component,\n      decision and option tokens, we can use a filter on the file path, for\n      example, to make the option tokens layer private.\u003c/p\u003e\n\n\u003cp\u003eStyle Dictionary config\n\u003c/p\u003e\n\n\u003cpre\u003e  const styleDictionary = new StyleDictionary({\n    \u0026#34;source\u0026#34;: [\u0026#34;color.options.json\u0026#34;, \u0026#34;color.decisions.json\u0026#34;],\n    \u0026#34;platforms\u0026#34;: {\n      \u0026#34;css\u0026#34;: {\n        \u0026#34;transformGroup\u0026#34;: \u0026#34;css\u0026#34;,\n        \u0026#34;files\u0026#34;: [\n          {\n            \u0026#34;destination\u0026#34;: \u0026#34;variables.css\u0026#34;,\n\u003cspan\u003e            \u0026#34;filter\u0026#34;: token =\u0026gt; !token.filePath.endsWith(\u0026#39;options.json\u0026#39;),\u003c/span\u003e\n            \u0026#34;format\u0026#34;: \u0026#34;css/variables\u0026#34;\n          }\n        ]\n      }\n    }\n  });\u003c/pre\u003e\n\n\u003cp\u003eThe resulting CSS variables would contain\n      only these decision tokens, and not the option tokens.\u003c/p\u003e\n\n\u003cp\u003eGenerated CSS variables\n\u003c/p\u003e\n\n\u003cpre\u003e  :root {\n    --color-decisions-surface: #f8f8f8;\n    --color-decisions-background-disabled: #e6e6e6;\n    --color-decisions-text-disabled: #b1b1b1;\n    --color-decisions-text: #000000;\n    --color-decisions-accent: #0265dc;\n    --color-decisions-text-on-accent: #ffffff;\n  }\u003c/pre\u003e\n\u003c/section\u003e\n\n\u003csection id=\"AMoreFlexibleApproach\"\u003e\n\u003ch3\u003eA more flexible approach\u003c/h3\u003e\n\n\u003cp\u003eIf more flexibility is needed, it might be preferable to add a scope\n      flag to each token and to filter based on this flag:\u003c/p\u003e\n\n\u003cp\u003eStyle Dictionary config\n\u003c/p\u003e\n\n\u003cpre\u003e  const styleDictionary = new StyleDictionary({\n    \u0026#34;source\u0026#34;: [\u0026#34;color.options.json\u0026#34;, \u0026#34;color.decisions.json\u0026#34;],\n    \u0026#34;platforms\u0026#34;: {\n      \u0026#34;css\u0026#34;: {\n        \u0026#34;transformGroup\u0026#34;: \u0026#34;css\u0026#34;,\n        \u0026#34;files\u0026#34;: [\n          {\n            \u0026#34;destination\u0026#34;: \u0026#34;variables.css\u0026#34;,\n\u003cspan\u003e            \u0026#34;filter\u0026#34;: {\n              \u0026#34;public\u0026#34;: true\n            },\u003c/span\u003e\n            \u0026#34;format\u0026#34;: \u0026#34;css/variables\u0026#34;\n          }\n        ]\n      }\n    }\n  });\u003c/pre\u003e\n\n\u003cp\u003eIf we then add the flag to the decision tokens, the resulting CSS would\n      be the same as above:\u003c/p\u003e\n\n\u003cp\u003eTokens with scope flag\n\u003c/p\u003e\n\n\u003cpre\u003e  {\n    \u0026#34;color\u0026#34;: {\n      \u0026#34;$type\u0026#34;: \u0026#34;color\u0026#34;,\n      \u0026#34;decisions\u0026#34;: {\n        \u0026#34;surface\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-100}\u0026#34;,\n          \u0026#34;description\u0026#34;: \u0026#34;Used as a surface color.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        },\n        \u0026#34;background-disabled\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-200}\u0026#34;,\n          \u0026#34;description\u0026#34;:\u0026#34;Used for the background of disabled elements.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        },\n        \u0026#34;text-disabled\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-400}\u0026#34;,\n          \u0026#34;description\u0026#34;: \u0026#34;Used for the text of disabled elements.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        },\n        \u0026#34;text\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.grey-900}\u0026#34;,\n          \u0026#34;description\u0026#34;: \u0026#34;Used as default text color.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        },\n        \u0026#34;accent\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.blue-900}\u0026#34;,\n          \u0026#34;description\u0026#34;: \u0026#34;Used as an accent color.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        },\n        \u0026#34;text-on-accent\u0026#34;: {\n          \u0026#34;$value\u0026#34;: \u0026#34;{color.options.white}\u0026#34;,\n          \u0026#34;description\u0026#34;: \u0026#34;Used for text on accent color backgrounds.\u0026#34;,\n\u003cspan\u003e          \u0026#34;public\u0026#34;: true\u003c/span\u003e\n        }\n      }\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003eGenerated CSS variables\n\u003c/p\u003e\n\n\u003cpre\u003e  :root {\n    --color-decisions-surface: #f8f8f8;\n    --color-decisions-background-disabled: #e6e6e6;\n    --color-decisions-text-disabled: #b1b1b1;\n    --color-decisions-text: #000000;\n    --color-decisions-accent: #0265dc;\n    --color-decisions-text-on-accent: #ffffff;\n  }\u003c/pre\u003e\n\n\u003cp\u003eSuch flags can now also be set \u003ca href=\"https://help.figma.com/hc/en-us/articles/360039238193-Hide-styles-components-and-variables-when-publishing#h_01HD20M7HS9044NHB2YBJNE9C2\"\u003ethrough the Figma\n      UI\u003c/a\u003e\n      (if using Figma variables as a source of truth for design tokens). It is\n      available as\n      \u003ca href=\"https://www.figma.com/plugin-docs/api/properties/Variable-hiddenfrompublishing/\"\u003e\u003ccode\u003ehiddenFromPublishing\u003c/code\u003e\u003c/a\u003e\n      flag via the Plugins API.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ShouldIUseDesignTokens\"\u003e\n\u003ch2\u003eShould I use design tokens?\u003c/h2\u003e\n\n\u003cp\u003eDesign tokens offer significant benefits for modern UI architecture,\n      but they may not be the right fit for every project.\u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\u003cb\u003eBenefits\u003c/b\u003e include:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eImproved lead time for design changes\u003c/li\u003e\n\n\u003cli\u003eConsistent design language and UI architecture across platforms and\n            technologies\u003c/li\u003e\n\n\u003cli\u003eDesign tokens being relatively lightweight from an implementation point of\n            view\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cb\u003eDrawbacks\u003c/b\u003e include:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eInitial effort for automation\u003c/li\u003e\n\n\u003cli\u003eDesigners might have to (to some degree) interact with Git\u003c/li\u003e\n\n\u003cli\u003eStandardization is still in progress\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eConsider the following when deciding whether to adopt design\n      tokens:\u003c/p\u003e\n\n\u003csection id=\"WhenToUseDesignTokens\"\u003e\n\u003ch3\u003eWhen to use design tokens\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cb\u003eMulti-Platform or Multi-Application Environments:\u003c/b\u003e When working across\n          multiple platforms (web, iOS, Android…) or maintaining several applications or\n          frontends, design tokens ensure a consistent design language across all of\n          them.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eFrequent Design Changes\u003c/b\u003e: For environments with regular design\n          updates, design tokens provide a structured way to manage and propagate changes\n          efficiently.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eLarge Teams\u003c/b\u003e: For teams with many designers and developers, design\n          tokens facilitate collaboration.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eAutomated Workflows\u003c/b\u003e: If you’re familiar with CI/CD pipelines, the\n          effort to add a design token pipeline is relatively low. There are also\n          commercial offerings.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\n\u003csection id=\"WhenDesignTokensMightNotBeNecessary\"\u003e\n\u003ch3\u003eWhen design tokens might not be necessary\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cb\u003eSmall projects:\u003c/b\u003e For smaller projects with limited scope and minimal\n          design complexity, the overhead of managing design tokens might not be worth the\n          effort.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eNo issue with design changes:\u003c/b\u003e If the speed of design changes,\n          consistency and collaboration between design and engineering are not an issue,\n          then you might also not need design tokens.\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "25 min read",
  "publishedTime": null,
  "modifiedTime": "2024-12-12T00:00:00Z"
}
