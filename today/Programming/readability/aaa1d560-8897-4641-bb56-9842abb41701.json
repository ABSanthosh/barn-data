{
  "id": "aaa1d560-8897-4641-bb56-9842abb41701",
  "title": "Mastering Embedded Linux, Part 4: Adding Features",
  "link": "https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/",
  "description": "Table of Contents Workflow for new features How to implement an access point Configuring the software Startup scripts Porting the configuration to Buildroot Implementing it Side lesson: How to work menuconfig Enable ccache Install the daemons and firmware Create the overlay directory Recompile the image, flash and burn Side lesson: re-doing things in Buildroot Testing Commit that mess How to experiment on the fly Key points Recommended reading Coming up next Subscribe This is the fourth part of the Mastering Embedded Linux series, which is designed to help you become an expert at developing low-cost custom embedded Linux systems. Continuing the ongoing theme of developing customized firmware, I’ll be discussing how to add high-level “features” to your firmware image by taking off-the-shelf open source software, configuring it, and integrating it into your system. As an example of this workflow, we’ll be taking the Raspberry Pi Zero W firmware, which we built from source code in Part 3, and modifying it to implement a wireless access point. To follow along, you’ll need the hardware list from Part 2. The method I explain is broadly applicable to any firmware features you might want to add to your custom embedded system. First, I’ll identify the software we intend to use and paint a broad picture of how the new firmware feature will work. Then, we’ll actually implement it in the firmware. Workflow for new features The full workflow for a new firmware feature looks like the following checklist. You’ll notice that it isn’t so different from other software engineering activities. Plan what the feature looks like to the user and which specific things the system should do. Do you need to handle a new piece of hardware? How does the new feature/subsystem handle errors? Select the software you need to accomplish this list of behaviors. You might need to enable new kernel drivers, new daemons, or even write a couple scripts to tie everything together. Configure the selected software for your specific use case, since good software is almost certainly more general than your exact vision. Test your changes by booting with the new code. Inspect the system. Does it work? If not, debug; lather, rinse, and repeat. If you’re part of a professional engineering team, you might write automated integration tests; if you’re just hacking on the weekend, you might not.1 Finalize your changes by checking them into source control. How to implement an access point The goal is to have the Pi (the “target”) function similarly to a normal Wi-Fi router: on startup, the Pi should automatically create a Wi-Fi access point. It should also automatically assign an IP address to clients using DHCP. This should happen without any user interaction or configuration of the device.2 To accomplish this, this “firmware feature” actually needs two daemons and some additional firmware for the Wi-Fi chip.3 We’ll use the well-respected combination of hostapd and dnsmasq to do the userland work, and install the firmware that’s already packaged. hostapd is responsible for creating the host access point that other devices can join. It talks to the Wi-Fi API provided by the kernel to set the hardware up as a host; it chooses the Wi-Fi channel and sets the security. Then, it manages all the events and network traffic that are associated with being a host—things like connect/disconnect events. To keep things simple, we’ll just use a simple 2.4GHz open access point. dnsmasq will assign IP addresses via DHCP. When client devices connect, they expect to be assigned an IP address by the router. Again keeping things simple, we’ll assign an IPv4 address in the 10.33.40.0/24 range (which I have selected from thin air). The target itself needs to be statically assigned an IP address so that AP clients can route traffic to it; we’ll use 10.33.40.1 for the wlan0 interface. Our current Buildroot defconfig uses /etc/network/interfaces (not systemd’s networkd), so we’ll have to add a couple lines to that file. This configuration will be baked into the image, so you can burn the firmware and the system will start up ready to go, with no manual steps needed. Configuring the software Let’s go ahead and write the configuration files for these programs. I’ve shamelessly cribbed from other howtos and documentation—this isn’t university!4 # dnsmasq.conf interface=wlan0 # Serve addresses in 10.33.40.{10-200}, subnet /24, with a 24-hour lease dhcp-range=10.33.40.10,10.33.40.200,255.255.255.0,24h # hostapd.conf interface=wlan0 # Kernel driver; most modern drivers use nl80211 driver=nl80211 # The AP \"friendly name\"; change to anything you like ssid=MasteringEmbeddedLinux # Use 802.11g, not the glacially-slow b hw_mode=g # Arbitrarily choose radio channel from 1, 6, or 11, the only useful 2.4GHz ones channel=6 Buildroot automatically creates the ifupdown configuration and populates it with a quick configuration to be a DHCP client on eth0. Since the Pi Zero W doesn’t have an Ethernet port, we’ll just overwrite it with our own: # /etc/network/interfaces auto wlan0 iface wlan0 inet static address 10.33.40.1 netmask 255.255.255.0 We are able to write these now because nothing about them is specific to Buildroot. Note At this point, you could actually install these programs on your computer from your distribution and use these configuration files to test everything. This is often a viable approach, because you can iterate faster on your workstation than you can on the target. (Similarly, writing and packaging embedded Linux software should be considered separate tasks; developers iterate much faster with their beefy workstations.) Startup scripts If you log into the firmware image from Part 3, you might notice that ip link doesn’t mention wlan0. That’s because the Wi-Fi isn’t set up by the existing Buildroot firmware. At boot, we’ll need to load the kernel module that serves as the driver for the Wi-Fi chip.5 (Also, for reasons unknown, the Buildroot hostapd package doesn’t include a startup script, so we’ll add one.) The current Buildroot configuration is using init scripts, which I’ll cover in much more detail in Part 5. For now, all you need to know is that executable files placed in /etc/init.d/ are started in alphabetical order. It’s customary to start them with S and a number, to turn alphabetical order into numerical order. Since we want to load the kernel module first and start hostapd last, we’ll call them S02modules and S90hostapd. Here’s the module loader. I’m being really lazy here: #!/bin/sh /sbin/modprobe brcmfmac And here’s the hostapd script. (This is mostly copied from existing scripts. They all look alike.) #!/bin/sh case \"$1\" in start) printf \"Starting hostapd: \" start-stop-daemon -S -x /usr/sbin/hostapd -- -B /etc/hostapd.conf [ $? = 0 ] \u0026\u0026 echo \"OK\" || echo \"FAIL\" ;; stop) printf \"Stopping hostapd: \" start-stop-daemon -K -q -x /usr/sbin/hostapd [ $? = 0 ] \u0026\u0026 echo \"OK\" || echo \"FAIL\" ;; restart|reload) $0 stop $0 start ;; *) echo \"Usage: $0 {start|stop|restart}\" exit 1 esac exit 0 Porting the configuration to Buildroot Configuration files like these only make sense in conjunction with a particular board and firmware configuration. They don’t belong in packages, which are hardware-agnostic. Instead, board-specific configuration files are placed in a directory that Buildroot calls an overlay. Files in such directories are overlaid onto the generated filesystem after all the packages have been compiled. We’ll simply add these configuration files to an overlay, and they’ll appear in the corresponding place in the final image. Implementing it Let’s get started. If you’d like to inspect the finished Buildroot repository, review the companion Mastering repository available on GitHub under the part-4 branch. Side lesson: How to work menuconfig menuconfig is a terminal UI used to change the working configuration. You can invoke it by running make menuconfig. Move up and down with ↑ and ↓, and choose the buttons at the bottom with ← and →. Here’s a quick legend of the various menu item annotations: ---\u003e: A submenu. Descend with the bottom button; ascend with \u003c Exit \u003e. [ ]: A checkbox. Toggle with Space. Some things are both checkboxes and submenus. ***: A comment. Search is invoked with / (the Vim keybinding for search). You can search for a program name such as dnsmasq or configuration variable such as BR2_PACKAGE_DNSMASQ. In the results, menuconfig will display the menu location of the configuration option—in this example, you’d drill to “Target packages” then “Networking applications”. It also displays whether the package is enabled ([=n]) and lists its dependencies. If you can’t see an option in the menu, it’s because its dependencies aren’t enabled. Dependencies can sometimes lead to a wild goose chase where you have to go find three recursive dependencies and turn them on before the desired option appears. To mitigate this, dependencies are typically “big ticket” items like a toolchain with C++ support. Smaller dependencies like libraries are “selected” by a package instead, which means they’re automatically enabled when you enable that package. Enable ccache One of the things you should probably do first in menuconfig is enable ccache. This is a tool that acts as a “proxy” for the compiler: it caches the output of a given compile command. It is very conservative: if the hash of the compiler, input, or command line arguments changes, ccache treats that as a new compilation and doesn’t hit the cache. But since Buildroot runs the very same commands during rebuild, this is a perfect use case. For menuconfig practice, turn on ccache by navigating to its option under “Build Options” → “Enable compiler cache”. Enable it with spacebar; save and exit. Now, subsequent compiles will be captured by ccache. With a warm cache, a rebuild from scratch takes about 20 minutes on my laptop. If you want to warm up the cache, you can run make clean \u0026\u0026 make before you go to sleep for the night. Install the daemons and firmware Now, we need to enable the applications we need, dnsmasq and hostapd. They are both under “Target packages” → “Networking applications”—but if you’re unsure, remember you can search. Additionally, the Wi-Fi chip’s firmware needs to be installed; this is a binary blob (always kept in /lib/firmware) that the kernel pushes to the chip when the module is loaded. Enable the Raspberry Pi Wi-Fi firmware under Target packages → Hardware handling → Firmware (config option BR2_PACKAGE_RPI_WIFI_FIRMWARE). Note There are some people that hate vi. (Philistines.) If you’re one of them, you can enable a different editor at this point under “Target packages” → “Text editors and viewers.” Create the overlay directory Now we need to create the overlay directory that will add additional configuration files to the target’s firmware image. Let’s create a directory called board/raspberrypi/rootfs_overlay/, and subdirectories for the actual files. $ mkdir board/raspberrypi/rootfs_overlay/ $ mkdir board/raspberrypi/rootfs_overlay/etc/ $ mkdir board/raspberrypi/rootfs_overlay/etc/init.d/ $ mkdir board/raspberrypi/rootfs_overlay/etc/network/ Add the five configuration and startup files, given above, to the overlay: File Destination in rootfs_overlay/ dnsmasq config etc/dnsmasq.conf hostapd config etc/hostapd.conf ifupdown config etc/network/interfaces modprobe startup script etc/init.d/S02modprobe hostapd startup script etc/init.d/S90hostapd Ensure the init scripts are marked executable with the following command. If they aren’t executable, init will emit weird “permission denied” errors during boot. chmod +x board/raspberrypi/rootfs_overlay/etc/init.d/* Now, add the new rootfs overlay in menuconfig to the Kconfig option BR2_ROOTFS_OVERLAY; it’s probably empty right now. This is a space-separated list of individual overlay directories, specified relative to the top of the Buildroot tree. (No more training wheels; you can find it in menuconfig!) Recompile the image, flash and burn Now, recompile by running make; this will build the packages you selected and generate a new image. Because of the redo logic discussed below, recompiles only take a few minutes. When it’s finished, inspect output/target/etc/—your new configuration files should be placed! Side lesson: re-doing things in Buildroot Once Buildroot builds a particular package’s make subtarget, such as dnsmasq-install-target, it won’t re-do them when you run make again. If you make changes, such as adding a patch file or changing a configuration option, you need to tell Buildroot to re-do these steps, because they aren’t triggered automatically. Of course, you could run make clean. This “nuclear option” is necessary when you make sweeping changes that affect all packages. Great examples include changing the processor architecture, compiler version, or C library. It’s also a good idea to run a clean build right before you cut a firmware release, to ensure you haven’t accidentally made manual changes that won’t be captured by a rebuild. Clean builds are necessary just often enough that using ccache (explained above) is an excellent idea. However, sometimes you just need to rebuild a single package. If make clean is the nuclear option, then the package’s -dirclean subtarget is a tactical nuke. This erases output/build/, forcing Buildroot to build the package from scratch on subsequent make invocations. If you’ve changed build flags for a package, make -dirclean will ensure that those options are captured. Note, however, that dirclean only erases the build directory for a package, not the files copied into the rootfs in output/target. There is an important distinction between make subtargets, which do not rerun on every build, and post-build scripts, which do. These scripts typically do things like assemble the final firmware image. So if you manually change a file in output/target for testing, a simple make invocation will pick it up into the new image. Testing Burn the firmware using the same steps in Part 3. Here’s the relevant command again: $ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress In the serial console, you should notice the newly compiled daemons starting up at boot: Starting dnsmasq: OK Starting hostapd: OK And if you look on your workstation or phone, you should be able to see the access point displayed:6 Commit that mess It works? Great! Keep it that way: check your changes into Git. In Part 3 I discuss the difference between the working configuration and the saved defconfigs. So far all the changes we’ve made are only in the working configuration, which isn’t supposed to be version controlled. To save the changes back to the defconfig, run: $ make savedefconfig Now you can see that the defconfig is modified, and the overlay directory is not yet tracked. $ git status HEAD detached at 2019.11.1 Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git restore ...\" to discard changes in working directory) modified: configs/raspberrypi0w_defconfig Untracked files: (use \"git add ...\" to include in what will be committed) board/raspberrypi/rootfs_overlay/ no changes added to commit (use \"git add\" and/or \"git commit -a\") Add and commit the changes with: $ git add board/raspberrypi/rootfs_overlay/ $ git add configs/ $ git commit -m \"rpi: implement simple wireless access point\" How to experiment on the fly In this article, the software, configuration files, and steps needed to bundle everything up appeared, perfectly formed, out of the head of Zeus, without any messy compile/test/repeat cycle. I can assure you that when you’re tinkering on the bench, this “works flawlessly first try” scenario might happen once every year or two (when you manage to hit the Ballmer Peak just right). For all the other times, you will likely need a few attempts before you get everything working just right. The fastest way to quickly iterate is to experiment directly on the target using a half-finished firmware image. You can modify configuration files and test the system manually via the serial console. When you get a config file polished, copy it back to your Buildroot overlay. If you need a new program during testing, you’ll have to rebuild the image, and burning the image erases your progress if you don’t copy things off the target. Remember, Buildroot’s power is in the reproducibility of the firmware image; monkeying with it after it’s created removes that advantage. Key points This cycle of plan, select, configure, test, finalize is the backbone of embedded system customization. If you need to test or experiment “on the fly,” you can do that too—just be sure to migrate your changes back to Buildroot. Although this is engineering, nobody wrote any code during this session.7 Much of embedded Linux engineering is taking finished software packages and packaging them into a working, preconfigured system. ccache drastically lowers your rebuild times, which is good because you need to rebuild fairly often. The rootfs overlay is where board-specific customization goes. It’s best for configuration files and other stuff that doesn’t belong in a package’s scripts. All the changes we made have been automated and captured in the Buildroot tree, and the history of changes is visible in Git. You can reproduce another copy of the firmware image by simply running make. Recommended reading The Buildroot user manual’s “redo” sections gives guidance about how to cleanly redo build steps. The accompanying Buildroot repo for this series has all the changes described above in one convenient place for you to review. Coming up next The next installment is Part 5: Packaging Custom Software Part 5: Platform Daemons. Note The packaging discussion has been delayed to part 6 because the combined article was getting unwieldy. We’ll build on the ideas in this article and extend them to do three things: Write a quick-n-dirty embedded webserver that knows how to toggle GPIO pins Package this new, custom software for Buildroot, including automatic startup at boot Add it to our image, just like we did here. Learning the skill of porting your software to embedded Linux lets you build truly customized Linux firmware that does exactly what you want. I’ll close by reiterating a point I made in the last article: you own all the code on this system. If something doesn’t work, or you want a new feature in any of the software, you don’t have to wait for the distribution. You are the distribution, and you can make it happen. Subscribe You can subscribe to my blog via no-spam email or RSS. Thanks for reading! Automated unit tests involving hardware are hard. If you’re familiar with software testing, imagine that every executable, test harness, and dataset is now a physical object at least the size of a box of playing cards. You can’t create new test fixtures with quite the same wily abandon—you must design a physical test harness that has complete control of the embedded system. ↩︎ This philosophy of “no setup needed” is what separates this approach from the many “make your Raspberry Pi do X” tutorials that are available. In this article, the entire functionality of the system is reproducibly captured in the source code and the target configuration, not on one random SD card that is set up just so. ↩︎ This is the quick, glossy explanation of access points. There are many other good tutorials that go into greater depth about Wi-Fi, hostapd, and DHCP. The point of this article is to explain how to add features to your embedded systems, not Wi-Fi in particular. ↩︎ Thanks to this Raspberry Pi article for the configuration scripts, which I adapted and commented. ↩︎ If you enable a couple dependencies, you can use eudev (under the System Configuration menuconfig option) which will automatically handle loading the correct kernel modules. For now, I’ll stick with an explicit load because it’s also a chance to explain init scripts. ↩︎ You may have trouble connecting to it with Android, which implements a “connectivity check” that makes sure the access point has Internet access before it starts routing traffic. (iOS may do something similar; I don’t use iOS to know.) Certainly, your workstation should be able to connect without problems. ↩︎ We do write configuration files, but those don’t count. You’ll find that the more configurable the software is, the less you have to modify its source to get it to do what you want. ↩︎",
  "author": "George Hilliard",
  "published": "Wed, 11 Mar 2020 08:40:00 -0500",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 20832,
  "excerpt": "How to make your embedded system do something useful",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "Table of Contents Workflow for new features How to implement an access point Configuring the software Startup scripts Porting the configuration to Buildroot Implementing it Side lesson: How to work menuconfig Enable ccache Install the daemons and firmware Create the overlay directory Recompile the image, flash and burn Side lesson: re-doing things in Buildroot Testing Commit that mess How to experiment on the fly Key points Recommended reading Coming up next Subscribe This is the fourth part of the Mastering Embedded Linux series, which is designed to help you become an expert at developing low-cost custom embedded Linux systems. Continuing the ongoing theme of developing customized firmware, I’ll be discussing how to add high-level “features” to your firmware image by taking off-the-shelf open source software, configuring it, and integrating it into your system. As an example of this workflow, we’ll be taking the Raspberry Pi Zero W firmware, which we built from source code in Part 3, and modifying it to implement a wireless access point. To follow along, you’ll need the hardware list from Part 2. The method I explain is broadly applicable to any firmware features you might want to add to your custom embedded system. First, I’ll identify the software we intend to use and paint a broad picture of how the new firmware feature will work. Then, we’ll actually implement it in the firmware. Workflow for new features The full workflow for a new firmware feature looks like the following checklist. You’ll notice that it isn’t so different from other software engineering activities. Plan what the feature looks like to the user and which specific things the system should do. Do you need to handle a new piece of hardware? How does the new feature/subsystem handle errors? Select the software you need to accomplish this list of behaviors. You might need to enable new kernel drivers, new daemons, or even write a couple scripts to tie everything together. Configure the selected software for your specific use case, since good software is almost certainly more general than your exact vision. Test your changes by booting with the new code. Inspect the system. Does it work? If not, debug; lather, rinse, and repeat. If you’re part of a professional engineering team, you might write automated integration tests; if you’re just hacking on the weekend, you might not.1 Finalize your changes by checking them into source control. How to implement an access point The goal is to have the Pi (the “target”) function similarly to a normal Wi-Fi router: on startup, the Pi should automatically create a Wi-Fi access point. It should also automatically assign an IP address to clients using DHCP. This should happen without any user interaction or configuration of the device.2 To accomplish this, this “firmware feature” actually needs two daemons and some additional firmware for the Wi-Fi chip.3 We’ll use the well-respected combination of hostapd and dnsmasq to do the userland work, and install the firmware that’s already packaged. hostapd is responsible for creating the host access point that other devices can join. It talks to the Wi-Fi API provided by the kernel to set the hardware up as a host; it chooses the Wi-Fi channel and sets the security. Then, it manages all the events and network traffic that are associated with being a host—things like connect/disconnect events. To keep things simple, we’ll just use a simple 2.4GHz open access point. dnsmasq will assign IP addresses via DHCP. When client devices connect, they expect to be assigned an IP address by the router. Again keeping things simple, we’ll assign an IPv4 address in the 10.33.40.0/24 range (which I have selected from thin air). The target itself needs to be statically assigned an IP address so that AP clients can route traffic to it; we’ll use 10.33.40.1 for the wlan0 interface. Our current Buildroot defconfig uses /etc/network/interfaces (not systemd’s networkd), so we’ll have to add a couple lines to that file. This configuration will be baked into the image, so you can burn the firmware and the system will start up ready to go, with no manual steps needed. Configuring the software Let’s go ahead and write the configuration files for these programs. I’ve shamelessly cribbed from other howtos and documentation—this isn’t university!4 # dnsmasq.conf interface=wlan0 # Serve addresses in 10.33.40.{10-200}, subnet /24, with a 24-hour lease dhcp-range=10.33.40.10,10.33.40.200,255.255.255.0,24h # hostapd.conf interface=wlan0 # Kernel driver; most modern drivers use nl80211 driver=nl80211 # The AP \"friendly name\"; change to anything you like ssid=MasteringEmbeddedLinux # Use 802.11g, not the glacially-slow b hw_mode=g # Arbitrarily choose radio channel from 1, 6, or 11, the only useful 2.4GHz ones channel=6 Buildroot automatically creates the ifupdown configuration and populates it with a quick configuration to be a DHCP client on eth0. Since the Pi Zero W doesn’t have an Ethernet port, we’ll just overwrite it with our own: # /etc/network/interfaces auto wlan0 iface wlan0 inet static address 10.33.40.1 netmask 255.255.255.0 We are able to write these now because nothing about them is specific to Buildroot. Note At this point, you could actually install these programs on your computer from your distribution and use these configuration files to test everything. This is often a viable approach, because you can iterate faster on your workstation than you can on the target. (Similarly, writing and packaging embedded Linux software should be considered separate tasks; developers iterate much faster with their beefy workstations.) Startup scripts If you log into the firmware image from Part 3, you might notice that ip link doesn’t mention wlan0. That’s because the Wi-Fi isn’t set up by the existing Buildroot firmware. At boot, we’ll need to load the kernel module that serves as the driver for the Wi-Fi chip.5 (Also, for reasons unknown, the Buildroot hostapd package doesn’t include a startup script, so we’ll add one.) The current Buildroot configuration is using init scripts, which I’ll cover in much more detail in Part 5. For now, all you need to know is that executable files placed in /etc/init.d/ are started in alphabetical order. It’s customary to start them with S and a number, to turn alphabetical order into numerical order. Since we want to load the kernel module first and start hostapd last, we’ll call them S02modules and S90hostapd. Here’s the module loader. I’m being really lazy here: #!/bin/sh /sbin/modprobe brcmfmac And here’s the hostapd script. (This is mostly copied from existing scripts. They all look alike.) #!/bin/sh case \"$1\" in start) printf \"Starting hostapd: \" start-stop-daemon -S -x /usr/sbin/hostapd -- -B /etc/hostapd.conf [ $? = 0 ] \u0026\u0026 echo \"OK\" || echo \"FAIL\" ;; stop) printf \"Stopping hostapd: \" start-stop-daemon -K -q -x /usr/sbin/hostapd [ $? = 0 ] \u0026\u0026 echo \"OK\" || echo \"FAIL\" ;; restart|reload) $0 stop $0 start ;; *) echo \"Usage: $0 {start|stop|restart}\" exit 1 esac exit 0 Porting the configuration to Buildroot Configuration files like these only make sense in conjunction with a particular board and firmware configuration. They don’t belong in packages, which are hardware-agnostic. Instead, board-specific configuration files are placed in a directory that Buildroot calls an overlay. Files in such directories are overlaid onto the generated filesystem after all the packages have been compiled. We’ll simply add these configuration files to an overlay, and they’ll appear in the corresponding place in the final image. Implementing it Let’s get started. If you’d like to inspect the finished Buildroot repository, review the companion Mastering repository available on GitHub under the part-4 branch. menuconfig is a terminal UI used to change the working configuration. You can invoke it by running make menuconfig. Move up and down with ↑ and ↓, and choose the buttons at the bottom with ← and →. Here’s a quick legend of the various menu item annotations: ---\u003e: A submenu. Descend with the \u003cSelect\u003e bottom button; ascend with \u003c Exit \u003e. [ ]: A checkbox. Toggle with Space. Some things are both checkboxes and submenus. ***: A comment. Search is invoked with / (the Vim keybinding for search). You can search for a program name such as dnsmasq or configuration variable such as BR2_PACKAGE_DNSMASQ. In the results, menuconfig will display the menu location of the configuration option—in this example, you’d drill to “Target packages” then “Networking applications”. It also displays whether the package is enabled ([=n]) and lists its dependencies. If you can’t see an option in the menu, it’s because its dependencies aren’t enabled. Dependencies can sometimes lead to a wild goose chase where you have to go find three recursive dependencies and turn them on before the desired option appears. To mitigate this, dependencies are typically “big ticket” items like a toolchain with C++ support. Smaller dependencies like libraries are “selected” by a package instead, which means they’re automatically enabled when you enable that package. Enable ccache One of the things you should probably do first in menuconfig is enable ccache. This is a tool that acts as a “proxy” for the compiler: it caches the output of a given compile command. It is very conservative: if the hash of the compiler, input, or command line arguments changes, ccache treats that as a new compilation and doesn’t hit the cache. But since Buildroot runs the very same commands during rebuild, this is a perfect use case. For menuconfig practice, turn on ccache by navigating to its option under “Build Options” → “Enable compiler cache”. Enable it with spacebar; save and exit. Now, subsequent compiles will be captured by ccache. With a warm cache, a rebuild from scratch takes about 20 minutes on my laptop. If you want to warm up the cache, you can run make clean \u0026\u0026 make before you go to sleep for the night. Install the daemons and firmware Now, we need to enable the applications we need, dnsmasq and hostapd. They are both under “Target packages” → “Networking applications”—but if you’re unsure, remember you can search. Additionally, the Wi-Fi chip’s firmware needs to be installed; this is a binary blob (always kept in /lib/firmware) that the kernel pushes to the chip when the module is loaded. Enable the Raspberry Pi Wi-Fi firmware under Target packages → Hardware handling → Firmware (config option BR2_PACKAGE_RPI_WIFI_FIRMWARE). Note There are some people that hate vi. (Philistines.) If you’re one of them, you can enable a different editor at this point under “Target packages” → “Text editors and viewers.” Create the overlay directory Now we need to create the overlay directory that will add additional configuration files to the target’s firmware image. Let’s create a directory called board/raspberrypi/rootfs_overlay/, and subdirectories for the actual files. $ mkdir board/raspberrypi/rootfs_overlay/ $ mkdir board/raspberrypi/rootfs_overlay/etc/ $ mkdir board/raspberrypi/rootfs_overlay/etc/init.d/ $ mkdir board/raspberrypi/rootfs_overlay/etc/network/ Add the five configuration and startup files, given above, to the overlay: File Destination in rootfs_overlay/ dnsmasq config etc/dnsmasq.conf hostapd config etc/hostapd.conf ifupdown config etc/network/interfaces modprobe startup script etc/init.d/S02modprobe hostapd startup script etc/init.d/S90hostapd Ensure the init scripts are marked executable with the following command. If they aren’t executable, init will emit weird “permission denied” errors during boot. chmod +x board/raspberrypi/rootfs_overlay/etc/init.d/* Now, add the new rootfs overlay in menuconfig to the Kconfig option BR2_ROOTFS_OVERLAY; it’s probably empty right now. This is a space-separated list of individual overlay directories, specified relative to the top of the Buildroot tree. (No more training wheels; you can find it in menuconfig!) Recompile the image, flash and burn Now, recompile by running make; this will build the packages you selected and generate a new image. Because of the redo logic discussed below, recompiles only take a few minutes. When it’s finished, inspect output/target/etc/—your new configuration files should be placed! Side lesson: re-doing things in Buildroot Once Buildroot builds a particular package’s make subtarget, such as dnsmasq-install-target, it won’t re-do them when you run make again. If you make changes, such as adding a patch file or changing a configuration option, you need to tell Buildroot to re-do these steps, because they aren’t triggered automatically. Of course, you could run make clean. This “nuclear option” is necessary when you make sweeping changes that affect all packages. Great examples include changing the processor architecture, compiler version, or C library. It’s also a good idea to run a clean build right before you cut a firmware release, to ensure you haven’t accidentally made manual changes that won’t be captured by a rebuild. Clean builds are necessary just often enough that using ccache (explained above) is an excellent idea. However, sometimes you just need to rebuild a single package. If make clean is the nuclear option, then the package’s \u003cpackage\u003e-dirclean subtarget is a tactical nuke. This erases output/build/\u003cpackage\u003e, forcing Buildroot to build the package from scratch on subsequent make invocations. If you’ve changed build flags for a package, make \u003cpackage\u003e-dirclean will ensure that those options are captured. Note, however, that dirclean only erases the build directory for a package, not the files copied into the rootfs in output/target. There is an important distinction between make subtargets, which do not rerun on every build, and post-build scripts, which do. These scripts typically do things like assemble the final firmware image. So if you manually change a file in output/target for testing, a simple make invocation will pick it up into the new image. Testing Burn the firmware using the same steps in Part 3. Here’s the relevant command again: $ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress In the serial console, you should notice the newly compiled daemons starting up at boot: Starting dnsmasq: OK Starting hostapd: OK And if you look on your workstation or phone, you should be able to see the access point displayed:6 Commit that mess It works? Great! Keep it that way: check your changes into Git. In Part 3 I discuss the difference between the working configuration and the saved defconfigs. So far all the changes we’ve made are only in the working configuration, which isn’t supposed to be version controlled. To save the changes back to the defconfig, run: Now you can see that the defconfig is modified, and the overlay directory is not yet tracked. $ git status HEAD detached at 2019.11.1 Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: configs/raspberrypi0w_defconfig Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) board/raspberrypi/rootfs_overlay/ no changes added to commit (use \"git add\" and/or \"git commit -a\") Add and commit the changes with: $ git add board/raspberrypi/rootfs_overlay/ $ git add configs/ $ git commit -m \"rpi: implement simple wireless access point\" How to experiment on the fly In this article, the software, configuration files, and steps needed to bundle everything up appeared, perfectly formed, out of the head of Zeus, without any messy compile/test/repeat cycle. I can assure you that when you’re tinkering on the bench, this “works flawlessly first try” scenario might happen once every year or two (when you manage to hit the Ballmer Peak just right). For all the other times, you will likely need a few attempts before you get everything working just right. The fastest way to quickly iterate is to experiment directly on the target using a half-finished firmware image. You can modify configuration files and test the system manually via the serial console. When you get a config file polished, copy it back to your Buildroot overlay. If you need a new program during testing, you’ll have to rebuild the image, and burning the image erases your progress if you don’t copy things off the target. Remember, Buildroot’s power is in the reproducibility of the firmware image; monkeying with it after it’s created removes that advantage. Key points This cycle of plan, select, configure, test, finalize is the backbone of embedded system customization. If you need to test or experiment “on the fly,” you can do that too—just be sure to migrate your changes back to Buildroot. Although this is engineering, nobody wrote any code during this session.7 Much of embedded Linux engineering is taking finished software packages and packaging them into a working, preconfigured system. ccache drastically lowers your rebuild times, which is good because you need to rebuild fairly often. The rootfs overlay is where board-specific customization goes. It’s best for configuration files and other stuff that doesn’t belong in a package’s scripts. All the changes we made have been automated and captured in the Buildroot tree, and the history of changes is visible in Git. You can reproduce another copy of the firmware image by simply running make. Recommended reading The Buildroot user manual’s “redo” sections gives guidance about how to cleanly redo build steps. The accompanying Buildroot repo for this series has all the changes described above in one convenient place for you to review. Coming up next The next installment is Part 5: Packaging Custom Software Part 5: Platform Daemons. Note The packaging discussion has been delayed to part 6 because the combined article was getting unwieldy. We’ll build on the ideas in this article and extend them to do three things: Write a quick-n-dirty embedded webserver that knows how to toggle GPIO pins Package this new, custom software for Buildroot, including automatic startup at boot Add it to our image, just like we did here. Learning the skill of porting your software to embedded Linux lets you build truly customized Linux firmware that does exactly what you want. I’ll close by reiterating a point I made in the last article: you own all the code on this system. If something doesn’t work, or you want a new feature in any of the software, you don’t have to wait for the distribution. You are the distribution, and you can make it happen. Subscribe You can subscribe to my blog via no-spam email or RSS. Thanks for reading! Automated unit tests involving hardware are hard. If you’re familiar with software testing, imagine that every executable, test harness, and dataset is now a physical object at least the size of a box of playing cards. You can’t create new test fixtures with quite the same wily abandon—you must design a physical test harness that has complete control of the embedded system. ↩︎ This philosophy of “no setup needed” is what separates this approach from the many “make your Raspberry Pi do X” tutorials that are available. In this article, the entire functionality of the system is reproducibly captured in the source code and the target configuration, not on one random SD card that is set up just so. ↩︎ This is the quick, glossy explanation of access points. There are many other good tutorials that go into greater depth about Wi-Fi, hostapd, and DHCP. The point of this article is to explain how to add features to your embedded systems, not Wi-Fi in particular. ↩︎ Thanks to this Raspberry Pi article for the configuration scripts, which I adapted and commented. ↩︎ If you enable a couple dependencies, you can use eudev (under the System Configuration menuconfig option) which will automatically handle loading the correct kernel modules. For now, I’ll stick with an explicit load because it’s also a chance to explain init scripts. ↩︎ You may have trouble connecting to it with Android, which implements a “connectivity check” that makes sure the access point has Internet access before it starts routing traffic. (iOS may do something similar; I don’t use iOS to know.) Certainly, your workstation should be able to connect without problems. ↩︎ We do write configuration files, but those don’t count. You’ll find that the more configurable the software is, the less you have to modify its source to get it to do what you want. ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n\u003clabel for=\"tocToggle\"\u003eTable of Contents\u003c/label\u003e\u003c/p\u003e\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#workflow-for-new-features\"\u003eWorkflow for new features\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-to-implement-an-access-point\"\u003eHow to implement an access point\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#configuring-the-software\"\u003eConfiguring the software\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#startup-scripts\"\u003eStartup scripts\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#porting-the-configuration-to-buildroot\"\u003ePorting the configuration to Buildroot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#implementing-it\"\u003eImplementing it\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#side-lesson-how-to-work-menuconfig\"\u003eSide lesson: How to work menuconfig\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#enable-ccache\"\u003eEnable ccache\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#install-the-daemons-and-firmware\"\u003eInstall the daemons and firmware\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#create-the-overlay-directory\"\u003eCreate the overlay directory\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#recompile-the-image-flash-and-burn\"\u003eRecompile the image, flash and burn\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#side-lesson-re-doing-things-in-buildroot\"\u003eSide lesson: re-doing things in Buildroot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#testing\"\u003eTesting\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#commit-that-mess\"\u003eCommit that mess\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-to-experiment-on-the-fly\"\u003eHow to experiment on the fly\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#key-points\"\u003eKey points\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#recommended-reading\"\u003eRecommended reading\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#coming-up-next\"\u003eComing up next\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#subscribe\"\u003eSubscribe\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e\n\u003c/div\u003e\n\u003cp\u003eThis is the fourth part of the \u003ca href=\"https://www.thirtythreeforty.net/series/mastering-embedded-linux\"\u003eMastering Embedded Linux series\u003c/a\u003e, which is designed to help you become an expert at developing low-cost custom embedded Linux systems.\nContinuing the ongoing theme of developing customized firmware, I’ll be discussing how to add high-level “features” to your firmware image by taking off-the-shelf open source software, configuring it, and integrating it into your system.\u003c/p\u003e\n\u003cp\u003eAs an example of this workflow, we’ll be taking the \u003cspan\u003eRaspberry Pi Zero W\u003c/span\u003e\nfirmware, which we built from source code in Part 3, and \u003cstrong\u003emodifying it to implement a wireless access point.\u003c/strong\u003e\nTo follow along, you’ll need the \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/mastering-embedded-linux-part-2-hardware/#needed-hardware\"\u003ehardware list\u003c/a\u003e from Part 2.\u003c/p\u003e\n\u003cp\u003eThe method I explain is broadly applicable to any firmware features you might want to add to your custom embedded system.\nFirst, I’ll identify the software we intend to use and paint a broad picture of how the new firmware feature will work.\nThen, we’ll actually implement it in the firmware.\u003c/p\u003e\n\u003ch2 id=\"workflow-for-new-features\"\u003eWorkflow for new features\u003c/h2\u003e\n\u003cp\u003eThe full workflow for a new firmware feature looks like the following checklist.\nYou’ll notice that it isn’t so different from other software engineering activities.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePlan\u003c/strong\u003e what the feature looks like to the user and which specific things the system should do.\nDo you need to handle a new piece of hardware? How does the new feature/subsystem handle errors?\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSelect\u003c/strong\u003e the software you need to accomplish this list of behaviors.\nYou might need to enable new kernel drivers, new daemons, or even write a couple scripts to tie everything together.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConfigure\u003c/strong\u003e the selected software for your specific use case, since good software is almost certainly more general than your exact vision.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTest\u003c/strong\u003e your changes by booting with the new code.\nInspect the system. Does it work? If not, debug; lather, rinse, and repeat.\nIf you’re part of a professional engineering team, you might write automated integration tests; if you’re just hacking on the weekend, you might not.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFinalize\u003c/strong\u003e your changes by checking them into source control.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"how-to-implement-an-access-point\"\u003eHow to implement an access point\u003c/h2\u003e\n\u003cp\u003eThe goal is to have the Pi (the “target”) function similarly to a normal Wi-Fi router: on startup, the Pi should automatically create a Wi-Fi access point.\nIt should also automatically assign an IP address to clients using DHCP.\nThis should happen without any user interaction or configuration of the device.\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eTo accomplish this, this “firmware feature” actually needs two \u003ca href=\"https://en.wikipedia.org/wiki/Daemon_(computing)\"\u003edaemons\u003c/a\u003e and some additional firmware for the Wi-Fi chip.\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e\nWe’ll use the well-respected combination of \u003ca href=\"https://wiki.gentoo.org/wiki/Hostapd\"\u003ehostapd\u003c/a\u003e and \u003ca href=\"https://wiki.archlinux.org/index.php/dnsmasq\"\u003ednsmasq\u003c/a\u003e to do the userland work, and install the firmware that’s already packaged.\u003c/p\u003e\n\u003cp\u003ehostapd is responsible for creating the \u003cem\u003ehost\u003c/em\u003e \u003cem\u003ea\u003c/em\u003eccess \u003cem\u003ep\u003c/em\u003eoint that other devices can join.\nIt talks to the Wi-Fi API provided by the kernel to set the hardware up as a host; it chooses the Wi-Fi channel and sets the security.\nThen, it manages all the events and network traffic that are associated with being a host—things like connect/disconnect events.\nTo keep things simple, we’ll just use a simple 2.4GHz open access point.\u003c/p\u003e\n\u003cp\u003ednsmasq will assign IP addresses via DHCP.\nWhen client devices connect, they expect to be assigned an IP address by the router.\nAgain keeping things simple, we’ll assign an IPv4 address in the 10.33.40.0/24 range (which I have selected from \u003cem\u003ethin air\u003c/em\u003e).\u003c/p\u003e\n\u003cp\u003eThe target itself needs to be statically assigned an IP address so that AP clients can route traffic to it; we’ll use \u003ccode\u003e10.33.40.1\u003c/code\u003e for the \u003ccode\u003ewlan0\u003c/code\u003e interface.\nOur current Buildroot defconfig uses \u003ca href=\"https://wiki.debian.org/NetworkConfiguration#Configuring_the_interface_manually\"\u003e\u003ccode\u003e/etc/network/interfaces\u003c/code\u003e\u003c/a\u003e (not \u003ca href=\"https://wiki.archlinux.org/index.php/Systemd-networkd#Wired_adapter_using_a_static_IP\"\u003esystemd’s networkd\u003c/a\u003e), so we’ll have to add a couple lines to that file.\u003c/p\u003e\n\u003cp\u003eThis configuration will be baked into the image, so you can burn the firmware and the system will start up ready to go, with no manual steps needed.\u003c/p\u003e\n\u003ch3 id=\"configuring-the-software\"\u003eConfiguring the software\u003c/h3\u003e\n\u003cp\u003eLet’s go ahead and write the configuration files for these programs.\nI’ve shamelessly cribbed from other howtos and documentation—this isn’t university!\u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"ini\"\u003e\u003cspan\u003e# dnsmasq.conf\u003c/span\u003e\n\u003cspan\u003einterface\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ewlan0\u003c/span\u003e\n\n\u003cspan\u003e# Serve addresses in 10.33.40.{10-200}, subnet /24, with a 24-hour lease\u003c/span\u003e\n\u003cspan\u003edhcp-range\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e10.33.40.10,10.33.40.200,255.255.255.0,24h\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"ini\"\u003e\u003cspan\u003e# hostapd.conf\u003c/span\u003e\n\u003cspan\u003einterface\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003ewlan0\u003c/span\u003e\n\n\u003cspan\u003e# Kernel driver; most modern drivers use nl80211\u003c/span\u003e\n\u003cspan\u003edriver\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003enl80211\u003c/span\u003e\n\n\u003cspan\u003e# The AP \u0026#34;friendly name\u0026#34;; change to anything you like\u003c/span\u003e\n\u003cspan\u003essid\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eMasteringEmbeddedLinux\u003c/span\u003e\n\n\u003cspan\u003e# Use 802.11g, not the glacially-slow b\u003c/span\u003e\n\u003cspan\u003ehw_mode\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003eg\u003c/span\u003e\n\n\u003cspan\u003e# Arbitrarily choose radio channel from 1, 6, or 11, the only useful 2.4GHz ones\u003c/span\u003e\n\u003cspan\u003echannel\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e6\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBuildroot automatically creates the ifupdown configuration and populates it with a quick configuration to be a DHCP client on \u003ccode\u003eeth0\u003c/code\u003e.\nSince the Pi Zero W doesn’t \u003cem\u003ehave\u003c/em\u003e an Ethernet port, we’ll just overwrite it with our own:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e# /etc/network/interfaces\nauto wlan0\niface wlan0 inet static\n    address 10.33.40.1\n    netmask 255.255.255.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe are able to write these now because nothing about them is specific to Buildroot.\u003c/p\u003e\n\u003cblockquote id=\"write-then-port\"\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e\u003cbr/\u003e\nAt this point, you could actually install these programs on your computer from your distribution and use these configuration files to test everything.\nThis is often a viable approach, because you can iterate faster on your workstation than you can on the target.\n(Similarly, \u003cem\u003ewriting\u003c/em\u003e and \u003cem\u003epackaging\u003c/em\u003e embedded Linux software should be considered separate tasks; developers iterate much faster with their beefy workstations.)\n\u003c/blockquote\u003e\n\u003ch4 id=\"startup-scripts\"\u003eStartup scripts\u003c/h4\u003e\n\u003cp\u003eIf you log into the firmware image from Part 3, you might notice that \u003ccode\u003eip link\u003c/code\u003e doesn’t mention \u003ccode\u003ewlan0\u003c/code\u003e.\nThat’s because the Wi-Fi isn’t set up by the existing Buildroot firmware.\nAt boot, we’ll need to load the kernel module that serves as the driver for the Wi-Fi chip.\u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003e(Also, for reasons unknown, the Buildroot hostapd package doesn’t include a startup script, so we’ll add one.)\nThe current Buildroot configuration is using \u003ca href=\"https://en.wikipedia.org/wiki/Init#SysV-style\"\u003einit scripts\u003c/a\u003e, which I’ll cover in much more detail in Part 5.\nFor now, all you need to know is that executable files placed in \u003ccode\u003e/etc/init.d/\u003c/code\u003e are started in alphabetical order.\nIt’s customary to start them with \u003ccode\u003eS\u003c/code\u003e and a number, to turn alphabetical order into numerical order.\nSince we want to load the kernel module \u003cem\u003efirst\u003c/em\u003e and start hostapd \u003cem\u003elast\u003c/em\u003e, we’ll call them \u003ccode\u003eS02modules\u003c/code\u003e and \u003ccode\u003eS90hostapd\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere’s the module loader.\nI’m being really lazy here:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"shell\"\u003e\u003cspan\u003e#!/bin/sh\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\n/sbin/modprobe brcmfmac\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAnd here’s the hostapd script.\n(This is mostly copied from existing scripts. They all look alike.)\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"shell\"\u003e\u003cspan\u003e#!/bin/sh\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\n\u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e$1\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e in\n        start\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003eprintf\u003c/span\u003e \u003cspan\u003e\u0026#34;Starting hostapd: \u0026#34;\u003c/span\u003e\n                start-stop-daemon -S -x /usr/sbin/hostapd -- -B /etc/hostapd.conf\n                \u003cspan\u003e[\u003c/span\u003e \u003cspan\u003e$?\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;OK\u0026#34;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;FAIL\u0026#34;\u003c/span\u003e\n                ;;\n        stop\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003eprintf\u003c/span\u003e \u003cspan\u003e\u0026#34;Stopping hostapd: \u0026#34;\u003c/span\u003e\n                start-stop-daemon -K -q -x /usr/sbin/hostapd\n                \u003cspan\u003e[\u003c/span\u003e \u003cspan\u003e$?\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;OK\u0026#34;\u003c/span\u003e \u003cspan\u003e||\u003c/span\u003e \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;FAIL\u0026#34;\u003c/span\u003e\n                ;;\n        restart|reload\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003e$0\u003c/span\u003e stop\n                \u003cspan\u003e$0\u003c/span\u003e start\n                ;;\n        *\u003cspan\u003e)\u003c/span\u003e\n                \u003cspan\u003eecho\u003c/span\u003e \u003cspan\u003e\u0026#34;Usage: \u003c/span\u003e\u003cspan\u003e$0\u003c/span\u003e\u003cspan\u003e {start|stop|restart}\u0026#34;\u003c/span\u003e\n                \u003cspan\u003eexit\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003cspan\u003eesac\u003c/span\u003e\n\n\u003cspan\u003eexit\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"porting-the-configuration-to-buildroot\"\u003ePorting the configuration to Buildroot\u003c/h3\u003e\n\u003cp\u003eConfiguration files like these only make sense in conjunction with a particular board and firmware configuration.\nThey don’t belong in packages, which are hardware-agnostic.\u003c/p\u003e\n\u003cp\u003eInstead, board-specific configuration files are placed in a directory that \u003ca href=\"https://buildroot.org/downloads/manual/manual.html#rootfs-custom\"\u003eBuildroot calls an \u003cem\u003eoverlay\u003c/em\u003e\u003c/a\u003e.\nFiles in such directories are \u003cem\u003eoverlaid\u003c/em\u003e onto the generated filesystem after all the packages have been compiled.\nWe’ll simply add these configuration files to an overlay, and they’ll appear in the corresponding place in the final image.\u003c/p\u003e\n\u003ch2 id=\"implementing-it\"\u003eImplementing it\u003c/h2\u003e\n\u003cp\u003eLet’s get started. If you’d like to inspect the finished Buildroot repository, review the \u003ca href=\"https://github.com/thirtythreeforty/buildroot-mastering-embedded-linux/tree/part-4\"\u003ecompanion Mastering repository\u003c/a\u003e available on GitHub under the \u003ccode\u003epart-4\u003c/code\u003e branch.\u003c/p\u003e\n\n\u003cp\u003emenuconfig is a terminal UI used to change the working configuration.\nYou can invoke it by running \u003ccode\u003emake menuconfig\u003c/code\u003e.\nMove up and down with \u003ckbd\u003e↑\u003c/kbd\u003e and \u003ckbd\u003e↓\u003c/kbd\u003e, and choose the buttons at the bottom with \u003ckbd\u003e←\u003c/kbd\u003e and \u003ckbd\u003e→\u003c/kbd\u003e.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/menuconfig.png\" alt=\"The menuconfig interface\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eHere’s a quick legend of the various menu item annotations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e---\u0026gt;\u003c/code\u003e: A submenu. Descend with the \u003cspan\u003e\u003ccode\u003e\u0026lt;Select\u0026gt;\u003c/code\u003e\u003c/span\u003e\nbottom button; ascend with \u003cspan\u003e\u003ccode\u003e\u0026lt; Exit \u0026gt;\u003c/code\u003e.\u003c/span\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e[ ]\u003c/code\u003e: A checkbox. Toggle with \u003ckbd\u003eSpace\u003c/kbd\u003e. Some things are both checkboxes and submenus.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e***\u003c/code\u003e: A comment.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSearch is invoked with \u003ckbd\u003e/\u003c/kbd\u003e (the Vim keybinding for search).\nYou can search for a program name such as \u003ccode\u003ednsmasq\u003c/code\u003e or configuration variable such as \u003ccode\u003eBR2_PACKAGE_DNSMASQ\u003c/code\u003e.\nIn the results, menuconfig will display the menu location of the configuration option—in this example, you’d drill to “Target packages” then “Networking applications”.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/search-dnsmasq.png\" alt=\"Searching for dnsmasq package\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eIt also displays whether the package is enabled (\u003ccode\u003e[=n]\u003c/code\u003e) and lists its dependencies.\nIf you can’t see an option in the menu, it’s because its dependencies aren’t enabled.\u003c/p\u003e\n\u003cp\u003eDependencies can sometimes lead to a wild goose chase where you have to go find three recursive dependencies and turn them on before the desired option appears.\nTo mitigate this, dependencies are typically “big ticket” items like a toolchain with C++ support.\nSmaller dependencies like libraries are “selected” by a package instead, which means they’re automatically enabled when you enable that package.\u003c/p\u003e\n\u003ch4 id=\"enable-ccache\"\u003eEnable ccache\u003c/h4\u003e\n\u003cp\u003eOne of the things you should probably do first in menuconfig is enable ccache.\nThis is a tool that acts as a “proxy” for the compiler: it caches the output of a given compile command.\nIt is very conservative: if the hash of the compiler, input, or command line arguments changes, ccache treats that as a new compilation and doesn’t hit the cache.\nBut since Buildroot runs the very same commands during rebuild, this is a perfect use case.\u003c/p\u003e\n\u003cp\u003eFor menuconfig practice, \u003cstrong\u003eturn on ccache\u003c/strong\u003e by navigating to its option under “Build Options” → “Enable compiler cache”.\nEnable it with spacebar; save and exit.\u003c/p\u003e\n\u003cp\u003eNow, subsequent compiles will be captured by ccache.\nWith a warm cache, a rebuild from scratch takes about 20 minutes on my laptop.\nIf you want to warm up the cache, you can run \u003ccode\u003emake clean \u0026amp;\u0026amp; make\u003c/code\u003e before you go to sleep for the night.\u003c/p\u003e\n\u003ch3 id=\"install-the-daemons-and-firmware\"\u003eInstall the daemons and firmware\u003c/h3\u003e\n\u003cp\u003eNow, we need to enable the applications we need, dnsmasq and hostapd.\nThey are both under “Target packages” → “Networking applications”—but if you’re unsure, remember you can search.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/enable-dnsmasq.png\" alt=\"Enabling the dnsmasq package in menuconfig\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eAdditionally, the Wi-Fi chip’s firmware needs to be installed; this is a binary blob (always kept in \u003ccode\u003e/lib/firmware\u003c/code\u003e) that the kernel pushes to the chip when the module is loaded.\n\u003cstrong\u003eEnable the Raspberry Pi Wi-Fi firmware\u003c/strong\u003e under Target packages → Hardware handling → Firmware (config option \u003ccode\u003eBR2_PACKAGE_RPI_WIFI_FIRMWARE\u003c/code\u003e).\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e\u003cbr/\u003e\nThere are some people that hate \u003ccode\u003evi\u003c/code\u003e.\n(Philistines.)\nIf you’re one of them, you can enable a different editor at this point under “Target packages” → “Text editors and viewers.”\n\u003c/blockquote\u003e\n\u003ch3 id=\"create-the-overlay-directory\"\u003eCreate the overlay directory\u003c/h3\u003e\n\u003cp\u003eNow we need to create the overlay directory that will add additional configuration files to the target’s firmware image.\nLet’s \u003cstrong\u003ecreate a directory called \u003ccode\u003eboard/raspberrypi/rootfs_overlay/\u003c/code\u003e\u003c/strong\u003e, and subdirectories for the actual files.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ mkdir board/raspberrypi/rootfs_overlay/\n$ mkdir board/raspberrypi/rootfs_overlay/etc/\n$ mkdir board/raspberrypi/rootfs_overlay/etc/init.d/\n$ mkdir board/raspberrypi/rootfs_overlay/etc/network/\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eAdd the five configuration and startup files\u003c/strong\u003e, given above, to the overlay:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eFile\u003c/th\u003e\n\u003cth\u003eDestination in \u003ccode\u003erootfs_overlay/\u003c/code\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003ednsmasq config\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eetc/dnsmasq.conf\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ehostapd config\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eetc/hostapd.conf\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eifupdown config\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eetc/network/interfaces\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emodprobe startup script\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eetc/init.d/S02modprobe\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ehostapd startup script\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eetc/init.d/S90hostapd\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eEnsure the init scripts are marked executable\u003c/strong\u003e with the following command.\nIf they aren’t executable, init will emit weird “permission denied” errors during boot.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003echmod +x board/raspberrypi/rootfs_overlay/etc/init.d/*\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, \u003cstrong\u003eadd the new rootfs overlay in menuconfig\u003c/strong\u003e to the Kconfig option \u003ccode\u003eBR2_ROOTFS_OVERLAY\u003c/code\u003e; it’s probably empty right now.\nThis is a space-separated list of individual overlay directories, specified relative to the top of the Buildroot tree.\n(No more training wheels; you can find it in menuconfig!)\u003c/p\u003e\n\u003ch3 id=\"recompile-the-image-flash-and-burn\"\u003eRecompile the image, flash and burn\u003c/h3\u003e\n\u003cp\u003eNow, \u003cstrong\u003erecompile by running \u003ccode\u003emake\u003c/code\u003e\u003c/strong\u003e; this will build the packages you selected and generate a new image.\nBecause of the redo logic discussed below, recompiles only take a few minutes.\nWhen it’s finished, inspect \u003ccode\u003eoutput/target/etc/\u003c/code\u003e—your new configuration files should be placed!\u003c/p\u003e\n\u003ch4 id=\"side-lesson-re-doing-things-in-buildroot\"\u003eSide lesson: re-doing things in Buildroot\u003c/h4\u003e\n\u003cp\u003eOnce Buildroot builds a particular package’s \u003ccode\u003emake\u003c/code\u003e subtarget, such as \u003ccode\u003ednsmasq-install-target\u003c/code\u003e, it won’t re-do them when you run \u003ccode\u003emake\u003c/code\u003e again.\nIf you make changes, such as adding a patch file or changing a configuration option, you need to tell Buildroot to re-do these steps, because they aren’t triggered automatically.\u003c/p\u003e\n\u003cp\u003eOf course, you could run \u003ccode\u003emake clean\u003c/code\u003e.\nThis “nuclear option” is necessary when you make sweeping changes that affect all packages.\nGreat examples include changing the processor architecture, compiler version, or C library.\nIt’s also a good idea to run a clean build right before you cut a firmware release, to ensure you haven’t accidentally made manual changes that won’t be captured by a rebuild.\nClean builds are necessary \u003cem\u003ejust\u003c/em\u003e often enough that using ccache (explained above) is an excellent idea.\u003c/p\u003e\n\u003cp\u003eHowever, sometimes you just need to rebuild a single package. If \u003ccode\u003emake clean\u003c/code\u003e is the nuclear option, then the package’s \u003ccode\u003e\u0026lt;package\u0026gt;-dirclean\u003c/code\u003e subtarget is a tactical nuke.\nThis erases \u003ccode\u003eoutput/build/\u0026lt;package\u0026gt;\u003c/code\u003e, forcing Buildroot to build the package from scratch on subsequent \u003ccode\u003emake\u003c/code\u003e invocations.\nIf you’ve changed build flags for a package, \u003ccode\u003emake \u0026lt;package\u0026gt;-dirclean\u003c/code\u003e will ensure that those options are captured.\nNote, however, that dirclean only erases the \u003cem\u003ebuild\u003c/em\u003e directory for a package, not the files copied into the rootfs in \u003ccode\u003eoutput/target\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere is an important distinction between \u003ccode\u003emake\u003c/code\u003e subtargets, which do not rerun on every build, and post-build scripts, which do.\nThese scripts typically do things like assemble the final firmware image.\nSo if you manually change a file in \u003ccode\u003eoutput/target\u003c/code\u003e for testing, a simple \u003ccode\u003emake\u003c/code\u003e invocation will pick it up into the new image.\u003c/p\u003e\n\u003ch3 id=\"testing\"\u003eTesting\u003c/h3\u003e\n\u003cp\u003eBurn the firmware using the \u003ca href=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/#burn-the-raspberry-pis-sd-card\"\u003esame steps in Part 3\u003c/a\u003e.\nHere’s the relevant command again:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn the serial console, you should notice the newly compiled daemons starting up at boot:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003eStarting dnsmasq: OK\nStarting hostapd: OK\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAnd if you look on your workstation or phone, you should be able to see the access point displayed:\u003csup id=\"fnref:6\"\u003e\u003ca href=\"#fn:6\" role=\"doc-noteref\"\u003e6\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/yay-wifi.png\" alt=\"The new Wi-Fi AP displayed on my workstation\u0026#39;s chooser\"/\u003e\n\u003c/figure\u003e\n\u003ch3 id=\"commit-that-mess\"\u003eCommit that mess\u003c/h3\u003e\n\u003cp\u003eIt works? Great! Keep it that way: \u003cstrong\u003echeck your changes into Git\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/#build-configurations\"\u003eIn Part 3\u003c/a\u003e I discuss the difference between the working configuration and the saved defconfigs.\nSo far all the changes we’ve made are only in the working configuration, which isn’t supposed to be version controlled.\nTo save the changes back to the defconfig, run:\u003c/p\u003e\n\u003cp\u003eNow you can see that the defconfig is modified, and the overlay directory is not yet tracked.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ git status\nHEAD detached at 2019.11.1\nChanges not staged for commit:\n  (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed)\n  (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory)\n    modified:   configs/raspberrypi0w_defconfig\n\nUntracked files:\n  (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed)\n    board/raspberrypi/rootfs_overlay/\n\nno changes added to commit (use \u0026#34;git add\u0026#34; and/or \u0026#34;git commit -a\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAdd and commit the changes with:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e$ git add board/raspberrypi/rootfs_overlay/\n$ git add configs/\n$ git commit -m \u0026#34;rpi: implement simple wireless access point\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"how-to-experiment-on-the-fly\"\u003eHow to experiment on the fly\u003c/h2\u003e\n\u003cp\u003eIn this article, the software, configuration files, and steps needed to bundle everything up appeared, perfectly formed, out of the head of Zeus, without any messy compile/test/repeat cycle.\u003c/p\u003e\n\u003cp\u003eI can assure you that when you’re tinkering on the bench, this “works flawlessly first try” scenario might happen once every year or two (when you manage to hit the \u003ca href=\"https://xkcd.com/323/\"\u003eBallmer Peak\u003c/a\u003e just right).\u003c/p\u003e\n\u003cp\u003eFor all the other times, you will likely need a few attempts before you get everything working just right.\nThe fastest way to quickly iterate is to experiment directly on the target using a half-finished firmware image.\nYou can modify configuration files and test the system manually via the serial console.\u003c/p\u003e\n\u003cp\u003eWhen you get a config file polished, copy it back to your Buildroot overlay.\nIf you need a new program during testing, you’ll have to rebuild the image, and burning the image erases your progress if you don’t copy things off the target.\nRemember, Buildroot’s power is in the reproducibility of the firmware image; monkeying with it after it’s created removes that advantage.\u003c/p\u003e\n\u003ch2 id=\"key-points\"\u003eKey points\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThis cycle of \u003cem\u003eplan, select, configure, test, finalize\u003c/em\u003e is the backbone of embedded system customization.\nIf you need to test or experiment “on the fly,” you can do that too—just be sure to migrate your changes back to Buildroot.\u003c/li\u003e\n\u003cli\u003eAlthough this is engineering, nobody wrote any \u003cem\u003ecode\u003c/em\u003e during this session.\u003csup id=\"fnref:7\"\u003e\u003ca href=\"#fn:7\" role=\"doc-noteref\"\u003e7\u003c/a\u003e\u003c/sup\u003e\nMuch of embedded Linux engineering is taking finished software packages and packaging them into a working, preconfigured system.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eccache\u003c/code\u003e drastically lowers your rebuild times, which is good because you need to rebuild fairly often.\u003c/li\u003e\n\u003cli\u003eThe \u003cem\u003erootfs overlay\u003c/em\u003e is where board-specific customization goes.\nIt’s best for configuration files and other stuff that doesn’t belong in a package’s scripts.\u003c/li\u003e\n\u003cli\u003eAll the changes we made have been automated and captured in the Buildroot tree, and the history of changes is visible in Git.\nYou can reproduce another copy of the firmware image by simply running \u003ccode\u003emake\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"recommended-reading\"\u003eRecommended reading\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://buildroot.org/downloads/manual/manual.html#full-rebuild\"\u003eThe Buildroot user manual’s “redo” sections\u003c/a\u003e gives guidance about how to cleanly redo build steps.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/thirtythreeforty/buildroot-mastering-embedded-linux/tree/part-4\"\u003eThe accompanying Buildroot repo\u003c/a\u003e for this series has all the changes described above in one convenient place for you to review.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"coming-up-next\"\u003eComing up next\u003c/h2\u003e\n\u003cp\u003eThe next installment is \u003cdel\u003ePart 5: Packaging Custom Software\u003c/del\u003e \u003ca href=\"https://www.thirtythreeforty.net/posts/2020/05/mastering-embedded-linux-part-5-platform-daemons/\"\u003ePart 5: Platform Daemons\u003c/a\u003e.\u003c/p\u003e\n\u003cblockquote id=\"packaging-delayed\"\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e\u003cbr/\u003e\nThe packaging discussion has been delayed to part 6 because the combined article was getting unwieldy.\n\u003c/blockquote\u003e\n\u003cp\u003eWe’ll build on the ideas in this article and extend them to do three things:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWrite a quick-n-dirty embedded webserver that knows how to toggle GPIO pins\u003c/li\u003e\n\u003cli\u003ePackage this new, custom software for Buildroot, including automatic startup at boot\u003c/li\u003e\n\u003cli\u003eAdd it to our image, just like we did here.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLearning the skill of porting \u003cem\u003eyour\u003c/em\u003e software to embedded Linux lets you build truly customized Linux firmware that does exactly what you want.\u003c/p\u003e\n\u003cp\u003eI’ll close by reiterating a point I made in the last article: \u003cstrong\u003eyou own all the code\u003c/strong\u003e on this system.\nIf something doesn’t work, or you want a new feature in any of the software, you don’t have to wait for the distribution.\nYou \u003cem\u003eare\u003c/em\u003e the distribution, and you can make it happen.\u003c/p\u003e\n\u003ch2 id=\"subscribe\"\u003eSubscribe\u003c/h2\u003e\n\u003cp\u003eYou can \u003ca href=\"https://www.thirtythreeforty.net/subscribe/\"\u003esubscribe to my blog\u003c/a\u003e via no-spam email or RSS.\nThanks for reading!\u003c/p\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eAutomated unit tests involving hardware are \u003cem\u003ehard\u003c/em\u003e.\nIf you’re familiar with software testing, imagine that every executable, test harness, and dataset is now a physical object at least the size of a box of playing cards.\nYou can’t create new test fixtures with quite the same wily abandon—you must design a physical test harness that has complete control of the embedded system. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis philosophy of “no setup needed” is what separates this approach from the many “make your Raspberry Pi do X” tutorials that are available.\nIn this article, the entire functionality of the system is reproducibly captured in the source code and the target configuration, not on one random SD card that is set up \u003cem\u003ejust so\u003c/em\u003e. \u003ca href=\"#fnref:2\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis is the quick, glossy explanation of access points. There are many other good tutorials that go into greater depth about Wi-Fi, hostapd, and DHCP. The point of this article is to explain how to add features to your embedded systems, not Wi-Fi in particular. \u003ca href=\"#fnref:3\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThanks to \u003ca href=\"https://www.raspberrypi.org/documentation/configuration/wireless/access-point.md\"\u003ethis Raspberry Pi article\u003c/a\u003e for the configuration scripts, which I adapted and commented. \u003ca href=\"#fnref:4\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\" role=\"doc-endnote\"\u003e\n\u003cp\u003eIf you enable a couple dependencies, you can use \u003ccode\u003eeudev\u003c/code\u003e (under the System Configuration menuconfig option) which will automatically handle loading the correct kernel modules. For now, I’ll stick with an explicit load because it’s also a chance to explain init scripts. \u003ca href=\"#fnref:5\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:6\" role=\"doc-endnote\"\u003e\n\u003cp\u003eYou may have trouble connecting to it with Android, which implements a “connectivity check” that makes sure the access point has Internet access before it starts routing traffic.\n(iOS may do something similar; I don’t use iOS to know.)\nCertainly, your workstation should be able to connect without problems. \u003ca href=\"#fnref:6\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:7\" role=\"doc-endnote\"\u003e\n\u003cp\u003eWe do write configuration files, but those don’t count. You’ll find that the more configurable the software is, the less you have to modify its source to get it to do what you want. \u003ca href=\"#fnref:7\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": "2020-03-11T08:40:00-05:00",
  "modifiedTime": "2020-03-11T08:40:00-05:00"
}
