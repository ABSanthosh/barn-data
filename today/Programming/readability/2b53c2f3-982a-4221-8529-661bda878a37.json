{
  "id": "2b53c2f3-982a-4221-8529-661bda878a37",
  "title": "Mastering Embedded Linux, Part 3: Buildroot",
  "link": "https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/",
  "description": "Table of Contents Prerequisites Kicking off Buildroot Install host tools Download Buildroot Configure Buildroot for your hardware Build How Buildroot works Compilation flow Buildroot packages Build configurations Booting the new image Optional: start the VM Aside: how to use dmesg Burn the Raspberry Pi’s SD card Connect to the Pi’s serial console Open the serial console Boot the firmware Key takeaways Further reading Coming up next Subscribe to updates Notes This Mastering Embedded Linux article is the first where the rubber hits the road. We’re walking through building Linux from source code and booting it on a Raspberry Pi. Whereas the previous articles have been all discussion, this one is equal parts discussion and tutorial. This article will introduce Buildroot, a toolkit for building highly customized embedded Linux images. Buildroot is the right combination of “powerful” and “easy to use.” It provides a lot of automation so that your build process can Just Work, freeing you up for doing the interesting parts of embedded Linux development. In this article: We’ll download Buildroot and start the build using just six commands. While it compiles, we’ll talk about the steps Buildroot is doing automatically, and what the process looks like conceptually. At the end, we’ll walk through booting the freshly built operating system on a Raspberry Pi. It’s easy and fun.1 Let’s get started. Prerequisites To follow along, you will need the things from the shopping list at the end of the last article. The Raspberry Pi will serve as the target hardware, and the FT2232 is the serial adapter that’s needed to communicate with the Pi’s serial console. Or, if you don’t want to buy anything, you don’t have to; you can use a virtual machine as the target instead. I’ll give you the option as I go along. Regardless of what target you pick, you will also need the following: Host workstation running Linux. If you don’t have a favorite distribution, you can install Ubuntu. If you aren’t running Linux, you can use a virtual machine (VM) as the host and that will work okay with some caveats. I am not walking you through this—you’ll need to get Linux on your workstation beforehand. 15GiB free disk space. We are compiling an entire operating system; the final result is small, but it needs lots of space to get there. If you use a VM, make sure you give it enough virtual drive space. 2–4 hours free time. You’ll need time to read this article, do the build, and play with the result. Working knowledge of Linux. You don’t need to be an expert, but it will be good to know how to get around in the shell. Kicking off Buildroot We’ll have Buildroot compiling our image in no time. There’s four main steps: Install host tools Download Buildroot Configure Buildroot Build the target image You only need to run six commands to accomplish all this. I’ll tell you what they are. Install host tools The first step is to install programs that you’ll need that don’t ship with Buildroot. Git: Buildroot provides tar archives, but it’s much easier in the long run to use the Git repository. A compiler: Buildroot needs an initial compiler to build its own compilers. Miscellaneous tools: Various system utilities that help Buildroot download and preprocess code. Buildroot documents these dependencies. screen: A “serial console” utility that will use the FT2232 serial adapter. Install the tools. (The ~$ in all the commands I give is the shell prompt. Don’t type that. Type what comes after it.) ~$ sudo apt install -y git build-essential wget cpio unzip rsync bc libncurses5-dev screen That’s pretty much it. Buildroot includes its own tools and just needs these things to get the process started. (This command is for Ubuntu. It’s the only command in this guide that is distribution-specific. Everything else interacts with Buildroot, not the host operating system.) Download Buildroot Buildroot provides multiple ways to get the source code, but the easiest way to do it is to use Git. Clone the Buildroot tree with Git: ~$ git clone git://git.buildroot.net/buildroot Cloning into 'buildroot'... remote: Enumerating objects: 356009, done. remote: Counting objects: 100% (356009/356009), done. remote: Compressing objects: 100% (116215/116215), done. remote: Total 356009 (delta 248969), reused 342974 (delta 238353) Receiving objects: 100% (356009/356009), 75.76 MiB | 1.36 MiB/s, done. Resolving deltas: 100% (248969/248969), done. ~$ cd buildroot/ Now we’re in the top level of the Buildroot tree. We need to switch to the exact version of Buildroot we want to build with. In this case, it’s the 2019.11.1 (November 2019) release, which is the latest as of this writing in January 2020. Check out the 2019.11.1 tag: ~/buildroot$ git checkout 2019.11.1 Note: checking out '2019.11.1'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b HEAD is now at 57fbebac60 Update for 2019.11.1 Easy enough. Git tells us we aren’t on a branch (“detached HEAD”). That’s okay for now. Configure Buildroot for your hardware Now, you need to configure Buildroot for your target. The exact command to do this depends on which board you’re building for: Target Command Raspberry Pi Zero W make raspberrypi0w_defconfig Raspberry Pi Zero make raspberrypi0_defconfig Virtual machine make qemu_x86_64_defconfig Each of these words after make is a configuration. You can see all these configurations in the configs directory; more on this later. ~/buildroot$ make raspberrypi0w_defconfig Buildroot prints each command that it’s running. It’s a lot of gibberish, but you can ignore all of it except the bottom part—that’s Buildroot saying that the configuration is activated: # # configuration written to /home/georgev/buildroot/.config # Build We’re now ready to compile the entire operating system. Buildroot makes this easy, but it does take some time: probably 2–3 hours, depending on how fast your workstation is. It also needs an active Internet connection to download source code. Ready? Compile the target image:2 ~/buildroot$ make This will start printing lots of text as Buildroot downloads and compiles the various parts of the target operating system image. When it finishes, there will be an SD card image ready to burn onto the Pi’s SD card. If you’d like to watch instead of doing it yourself, you can press Play on this asciicast: How Buildroot works While this compiles, I’ll discuss what each part of Buildroot does. The best part about being an embedded Linux hacker is that your builds take hours! This gives you plenty of time to write blog posts about embedded Linux. (comic via xkcd) Compilation flow From a high level point of view, here is the workflow that Buildroot automates:3 Buildroot builds the toolchain, which is the cross-compilers and other tools that it needs to compile the target system (green boxes). The source code (blue boxes) for each piece of software is downloaded from the Internet. Using Buildroot scripts (grey boxes), source is unpacked, patched, configured, compiled, and installed into the target output directory that forms the root filesystem (“rootfs”) for the target (purple boxes). Extra files, such as on-device configuration files, also get copied into the target output directory. Finally, scripts assemble the final firmware image from this rootfs. There are some exceptions; sometimes the cross-compiler is downloaded without needing to be compiled. Sometimes the manufacturer ships an entire “Board Support Package” (BSP) where all the compilation has already been done for you. But at the end of the day, those just truncate this flowchart; all the steps still have to be accomplished somehow. Here are the most important directories in the top of the Buildroot tree. There are others, but they are boring. You’ll spend most of your time interacting with these: Directory Purpose board/ Files and scripts to support each target board configs/ Build configurations such as raspberrypi0w_defconfig package/ Package definitions output/host/ Build tools that run on the workstation output/target/ Target output directory where target binaries are staged output/images/ Filesystem images and the final firmware image are emitted here So, the next question is: How does the one magic make command know how to build everything? To answer that, first I’ll talk about the structure of a Buildroot package. Buildroot packages Compilation scripts are grouped into packages. Most things in Buildroot are packages. You can see these packages under the package directory in the Buildroot tree. Buildroot 2019.11 ships with 2,289 packages! This is a wonderful library of free, open source software that you can drop into your custom firmware with a few commands. Everything from the Nginx web server to the Chocolate Doom game engine is available. Each package defines its own configuration options, build steps, and dependencies. The dependencies tell Buildroot in what order to build packages, the build steps tell exactly what commands to run to build the package (including how to download its source code), and the configuration options control anything about the package. The package’s list of configuration options is in a file called Config.in4 using a language called Kconfig5. At minimum, the package must supply an option controlling whether or not the package is to be compiled at all. To put the package in the target’s image, you enable this option. There might also be other options controlling whether extra features of the software are compiled in. These extra options are often useful when space is at a premium: you can simply “compile out” features that you don’t need. Armed with an understanding of a package’s configuration, it is easy to understand the entire build configuration. Build configurations Taken together, all the configuration options for all a system’s packages form a build configuration. Applying one of these default build configurations—a “defconfig”—allows you to quickly select all the relevant options. And so this is how make knows how to build everything: all the configuration options, for all the packages, were supplied in the raspberrypi0w_defconfig file that we specified at the beginning of the build.6 (GNU Make calculates the dependency tree and starts building the packages in the correct order.) Selecting the defconfig copies all the config options into the working configuration kept in a file named .config. You can change the working configuration using the menuconfig tool. This provides a graphical interface that lets you find and change various menu options. Here’s an example, using menuconfig to enable the Chocolate Doom package mentioned above. Note that .config is not supposed to be kept in Git version control; it’s specific only to a particular working copy. You can run make savedefconfig to copy the working config back to the defconfig, which is version controlled. Booting the new image Enough theory. Let’s boot Linux. Allow the build process to finish. When it does, you should see some lines that look like this: INFO: vfat(boot.vfat): adding file 'zImage' as 'zImage' ... INFO: vfat(boot.vfat): cmd: \"MTOOLS_SKIP_CHECK=1 mcopy -bsp -i '/home/georgev/Code/buildroot-mel/output/images/boot.vfat' '/home/georgev/Code/buildroot-mel/output/images/zImage' '::'\" (stderr): INFO: hdimage(sdcard.img): adding partition 'boot' (in MBR) from 'boot.vfat' ... INFO: hdimage(sdcard.img): adding partition 'rootfs' (in MBR) from 'rootfs.ext4' ... INFO: hdimage(sdcard.img): writing MBR These lines indicate that the SD card image (sdcard.img) for the Pi has been generated. It built the image from the root filesystem in output/target/, which you can inspect:7 ~/buildroot$ ls -lh output/target/ total 64K drwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 bin drwxr-xr-x 4 georgev georgev 4.0K Jan 13 20:48 dev drwxr-xr-x 5 georgev georgev 4.0K Jan 13 22:01 etc drwxr-xr-x 3 georgev georgev 4.0K Jan 13 22:01 lib lrwxrwxrwx 1 georgev georgev 3 Jan 13 21:08 lib32 -\u003e lib lrwxrwxrwx 1 georgev georgev 11 Jan 13 21:23 linuxrc -\u003e bin/busybox drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 media drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 mnt drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 opt drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 proc drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 root drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 run drwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 sbin drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 sys -rw-r--r-- 1 georgev georgev 1.4K Jan 13 21:08 THIS_IS_NOT_YOUR_ROOT_FILESYSTEM drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 tmp drwxr-xr-x 6 georgev georgev 4.0K Jan 13 22:01 usr drwxr-xr-x 3 georgev georgev 4.0K Jan 13 20:48 var We can verify that the SD card image was emitted by looking in the output/images/ directory: ~/buildroot$ ls -lh output/images/ total 225M -rw-r--r-- 1 georgev georgev 24K Jan 13 22:01 bcm2708-rpi-zero.dtb -rw-r--r-- 1 georgev georgev 32M Jan 13 22:01 boot.vfat -rw-r--r-- 1 georgev georgev 120M Jan 13 22:01 rootfs.ext2 lrwxrwxrwx 1 georgev georgev 11 Jan 13 22:01 rootfs.ext4 -\u003e rootfs.ext2 drwxr-xr-x 3 georgev georgev 4.0K Jan 13 21:28 rpi-firmware -rw-r--r-- 1 georgev georgev 153M Jan 13 22:01 sdcard.img -rw-r--r-- 1 georgev georgev 4.8M Jan 13 22:01 zImage Looks good. Now, let’s burn this image to the Pi’s SD card and start connecting the Pi to the computer. Optional: start the VM If you are using a Raspberry Pi, skip ahead to the section where we’ll start getting it ready. If you instead elected to build for a virtual machine, not a Pi, you can start the VM with a command8: ~/buildroot$ output/host/bin/qemu-system-x86_64 -M pc -kernel output/images/bzImage -drive file=output/images/rootfs.ext2,if=virtio,format=raw -append \"rootwait root=/dev/vda\" -net nic,model=virtio -net user The VM boots really quickly. On my workstation it only takes a couple seconds. Once the VM’s window appears, skip ahead to the “Boot the Firmware” section—it’s the same experience once you start the VM. Aside: how to use dmesg Let’s take a quick detour and learn how to work the Linux utility dmesg. It is a small tool that displays the output of the kernel log. This is useful because the kernel prints the names it assigns to devices that you’ve just plugged in. Reading the kernel log will let you know which device name to use for, say, your SD card. Basic usage is simple; just run: $ dmesg -w The -w flag stands for “watch;” dmesg will continue to monitor for new messages after dumping the kernel’s existing log. You can ignore the existing log; it’s probably pretty verbose. Once dmesg is watching, you can plug in your gadget and you should see a few lines like this: [163513.147002] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [163513.174253] mmcblk0: mmc0:aaaa SP32G 29.7 GiB [163513.189137] mmcblk0: p1 In this example, the SD card has been assigned a name of mmcblk0, and it has a single partition p1 (so the full path of the device is /dev/mmcblk0 and its partition is /dev/mmcblk0p1). Depending on your SD card reader, it might also get assigned an sd prefix. No matter, as long as you know exactly which one it is. Once you’re done with dmesg, you can just hit Ctrl+C to stop it. Burn the Raspberry Pi’s SD card Insert your SD card and use dmesg to learn its block device name. Use dd to copy the image onto the card. Substitute /dev/mmcblkX with the actual path of your SD card. ~/buildroot$ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress Note Be sure you get the of (output file) correct. If you specify your workstation’s hard drive, dd will happily overwrite all your files. If you’re unsure, just go back to dmesg and reinsert your SD card to double check its device name. Here’s what this command does: Option Explanation if= Input File—read from here of= Output File—write to here bs= Block Size—write this many bytes at once status= Show a nice progress bar (sometimes this doesn’t work well) Once this finishes, make sure the kernel’s write buffers have been flushed to the card: ~/buildroot$ sync Once this command returns, you can pull the SD card out and stick it into the Pi. Don’t turn on the Pi yet though (nothing bad will happen, it’s just not ready yet). Connect to the Pi’s serial console Now the FT2232 USB/UART device needs to be connected to the Pi’s serial pins. Here’s the Raspberry Pi header pinout: pinout.xyz is the best Raspberry Pi pinout website Since the FT2232 isn’t just a UART adapter, we need to know which pins should be used when it is being used in UART mode—the pins are named like ADBUS0, BCBUS3, etc. To figure this out, refer to section 3.1.2 of the FT2232’s datasheet, which suggests pin mappings: For “Async Serial,” pin ADBUS0 is TXD, and ADBUS1 is RXD. Easy enough. Connect the Pi’s UART TXD to the FT2232’s RXD, and vice versa. Finally, connect their grounds together. It should look like this: ADBUS0 might be labeled D0 or AD0 depending on your FT2232 adapter. This diagram was made with Fritzing, which is nice for drawing high-level wiring diagrams like these. Now, plug the serial adapter into your workstation. Using dmesg, learn the name of your FT2232 as you plug it in. It will probably be named ttyUSB0 and ttyUSB1—these are the two channels.9 Open the serial console Launch GNU Screen using the device name you just discovered. The extra flags configure the right baud rate and disable flow control—the vast majority of Linux serial consoles use this convention of 115200 baud with no hardware flow control. ~/buildroot$ sudo screen -fn /dev/ttyUSBX 115200 If you want to quit Screen, you need to type the escape sequence Ctrl+a followed by the command \\. Boot the firmware Plug in the Raspberry Pi’s power adapter. The serial console should begin printing boot messages as the operating system boots: [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 4.19.66 (georgev@desertvoice) (gcc version 8.3.0 (Buildroot 2019.11.1)) #1 Tue Jan 14 11:14:59 CST 2020 [ 0.000000] CPU: ARMv6-compatible processor [410fb767] revision 7 (ARMv7), cr=00c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache [ 0.000000] OF: fdt: Machine model: Raspberry Pi Zero Rev 1.3 [ 0.000000] Memory policy: Data cache writeback [ 0.000000] cma: Reserved 8 MiB at 0x19000000 [ 0.000000] random: get_random_bytes called from start_kernel+0x90/0x4a4 with crng_init=0 [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 104545 [ 0.000000] Kernel command line: coherent_pool=1M bcm2708_fb.fbwidth=720 bcm2708_fb.fbheight=480 bcm2708_fb.fbswap=1 smsc95xx.macaddr=B8:27:EB:6C:5F:E1 vc_mem.mem_base=0x1ec00000 vc_mem.mem_size=0x20000000 root=/dev/mmcblk0p2 rootwait console=tty1 console=ttyAMA0,115200 [ 0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes) [ 0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes) [ 0.000000] Memory: 397928K/421888K available (6947K kernel code, 635K rwdata, 2080K rodata, 452K init, 796K bss, 15768K reserved, 8192K cma-reserved) Eventually, it should print a login prompt: Welcome to Buildroot! buildroot login: You can enter root as the username; there isn’t a password. You can look around with commands like ls /usr/bin to see what programs are available on the image. If your board made it to the login prompt, congratulations! You have compiled and booted your first firmware image from source code. The world is your oyster. Key takeaways This has been a high-level introduction to Buildroot. It’s easy to get much further down in the weeds than this article goes. Nevertheless, it’s definitely a lot of info. Here’s the key takeaways from this lesson: You own all the code on the target and all the tools that make it. All the software in this process is completely open source. It is all compiled on your computer when you type make. If anything is broken or doesn’t work like you want, you can simply change it. All the work was automated. Buildroot lets you focus on implementing one thing at a time, starting from a working Linux system. Gradually, you can take the defconfigs provided and craft them into custom firmware that works exactly like you want. The target rootfs is tiny! The default image is only 57 megabytes, and most of that is kernel modules that you can turn off. Buildroot’s “small image” philosophy leaves you plenty of space to add features, or lets you build a firmware image that fits in as little as 4MiB. Further reading A lot of people have emailed me to ask about other reading materials they can get to learn more about embedded Linux systems. I am currently working on building a better list of resources. Here are some of the ones that are most relevant to this chapter: How Linux Works, 2nd Edition10 by Brian Ward is a great book about many topics in Linux. It’s relevant for desktop and server Linux, as well as embedded. It covers basics such as shell commands yet still goes into important, complex topics like the X11 window system and the DBus messaging bus. It’s the right amount of detail to give you a good mental picture of how everything works, while still being approachable. Bootlin’s Buildroot training is maintained by the very prolific team at Bootlin, a French company that does embedded Linux development. You can pay them to come give your entire team training using this material. If you’re willing to read through their slide deck, it’s very thorough, although there’s no lecture accompanying it. The Buildroot user manual is the place to learn about hacking on Buildroot. The various areas of the build system are well-described and the reference manual for writing new packages is superb. The downside is that because it is a user manual, not a tutorial, it’s quite dense. You’ll definitely get familiar with it as you use Buildroot going forward. If you would like to recommend other relevant embedded Linux learning material, please send me an email as I would be glad to learn about it. Coming up next In the next article, we’ll be adding a feature to the Linux system we just compiled. This will involve reading some documentation and customizing the build configuration with menuconfig, like in the demo I showed earlier. I’ll also be discussing the init system and how to integrate your programs into the boot process. (Edit: this has been postponed to Part 6.) We’ll make all the changes and rebuild, testing the new changes right away (rebuilds take only a couple minutes with Buildroot). This is the next step in the iterative process of crafting your own firmware image! Subscribe to updates You can subscribe to all of my blog updates via email or RSS on the Subscribe page. Thanks for reading! Notes A note about troubleshooting: If you are running into problems, I highly recommend that you Google the error message, possibly alongside the keyword “buildroot.” It is likely that someone has had your problem before. At any rate, the world of embedded systems is full of novel bizarre problems, being frustrated is normal, and debugging is a really good skill to build. A note about using a virtual machine as a workstation: If you’re building Buildroot inside a VM (e.g. Ubuntu is in VirtualBox, and your PC is actually running Windows), be sure you pass through the FT2232 and the SD card reader to the guest. You should probably also give the guest multiple CPUs, or the build will take a very, very long time. Your definition of “fun” may vary. I think it’s pretty cool, anyway. ↩︎ If you intend to use your workstation for other things, you can instead run nice make, which will make the build a lower priority so that your workstation is still responsive. ↩︎ Although this guide uses Buildroot, this workflow applies to any embedded Linux distribution. ↩︎ Packages compiled for the host, not the target, have separate options in Config.host.in. ↩︎ Kconfig was originally created by the Linux kernel developers to help manage the Linux kernel’s vast array of features. Buildroot has a similar scope, so Kconfig is useful here too. ↩︎ This isn’t actually quite true. In reality, only non-default options are stored in the defconfigs. But since the default is stored elsewhere, it amounts to about the same thing as “storing all the configuration options.” ↩︎ Buildroot adds a file called THIS_IS_NOT_YOUR_ROOT_FILESYSTEM to the output/target directory. This is the root filesystem, mostly. But there are a few extra steps that happen, like creation of special files, that aren’t reflected in this tree, so that’s why that warning file is there. ↩︎ How did I know this awful command? Simple: I read it in the readme file in boards/qemu/x86_64/readme.txt. ↩︎ If you have an FT232 (not 2232), you’ll only have a single channel. That’s okay; we’re not using the second one right now. ↩︎ Some links on my site, such as this one, are affiliate links. The proceeds help me keep buying and building neat embedded systems. ↩︎",
  "author": "George Hilliard",
  "published": "Tue, 14 Jan 2020 11:45:00 -0600",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 25389,
  "excerpt": "Compiling a Linux OS from source code with the Buildroot distribution",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "Table of Contents Prerequisites Kicking off Buildroot Install host tools Download Buildroot Configure Buildroot for your hardware Build How Buildroot works Compilation flow Buildroot packages Build configurations Booting the new image Optional: start the VM Aside: how to use dmesg Burn the Raspberry Pi’s SD card Connect to the Pi’s serial console Open the serial console Boot the firmware Key takeaways Further reading Coming up next Subscribe to updates Notes This Mastering Embedded Linux article is the first where the rubber hits the road. We’re walking through building Linux from source code and booting it on a Raspberry Pi. Whereas the previous articles have been all discussion, this one is equal parts discussion and tutorial. This article will introduce Buildroot, a toolkit for building highly customized embedded Linux images. Buildroot is the right combination of “powerful” and “easy to use.” It provides a lot of automation so that your build process can Just Work, freeing you up for doing the interesting parts of embedded Linux development. In this article: We’ll download Buildroot and start the build using just six commands. While it compiles, we’ll talk about the steps Buildroot is doing automatically, and what the process looks like conceptually. At the end, we’ll walk through booting the freshly built operating system on a Raspberry Pi. It’s easy and fun.1 Let’s get started. Prerequisites To follow along, you will need the things from the shopping list at the end of the last article. The Raspberry Pi will serve as the target hardware, and the FT2232 is the serial adapter that’s needed to communicate with the Pi’s serial console. Or, if you don’t want to buy anything, you don’t have to; you can use a virtual machine as the target instead. I’ll give you the option as I go along. Regardless of what target you pick, you will also need the following: Host workstation running Linux. If you don’t have a favorite distribution, you can install Ubuntu. If you aren’t running Linux, you can use a virtual machine (VM) as the host and that will work okay with some caveats. I am not walking you through this—you’ll need to get Linux on your workstation beforehand. 15GiB free disk space. We are compiling an entire operating system; the final result is small, but it needs lots of space to get there. If you use a VM, make sure you give it enough virtual drive space. 2–4 hours free time. You’ll need time to read this article, do the build, and play with the result. Working knowledge of Linux. You don’t need to be an expert, but it will be good to know how to get around in the shell. Kicking off Buildroot We’ll have Buildroot compiling our image in no time. There’s four main steps: Install host tools Download Buildroot Configure Buildroot Build the target image You only need to run six commands to accomplish all this. I’ll tell you what they are. Install host tools The first step is to install programs that you’ll need that don’t ship with Buildroot. Git: Buildroot provides tar archives, but it’s much easier in the long run to use the Git repository. A compiler: Buildroot needs an initial compiler to build its own compilers. Miscellaneous tools: Various system utilities that help Buildroot download and preprocess code. Buildroot documents these dependencies. screen: A “serial console” utility that will use the FT2232 serial adapter. Install the tools. (The ~$ in all the commands I give is the shell prompt. Don’t type that. Type what comes after it.) ~$ sudo apt install -y git build-essential wget cpio unzip rsync bc libncurses5-dev screen That’s pretty much it. Buildroot includes its own tools and just needs these things to get the process started. (This command is for Ubuntu. It’s the only command in this guide that is distribution-specific. Everything else interacts with Buildroot, not the host operating system.) Download Buildroot Buildroot provides multiple ways to get the source code, but the easiest way to do it is to use Git. Clone the Buildroot tree with Git: ~$ git clone git://git.buildroot.net/buildroot Cloning into 'buildroot'... remote: Enumerating objects: 356009, done. remote: Counting objects: 100% (356009/356009), done. remote: Compressing objects: 100% (116215/116215), done. remote: Total 356009 (delta 248969), reused 342974 (delta 238353) Receiving objects: 100% (356009/356009), 75.76 MiB | 1.36 MiB/s, done. Resolving deltas: 100% (248969/248969), done. ~$ cd buildroot/ Now we’re in the top level of the Buildroot tree. We need to switch to the exact version of Buildroot we want to build with. In this case, it’s the 2019.11.1 (November 2019) release, which is the latest as of this writing in January 2020. Check out the 2019.11.1 tag: ~/buildroot$ git checkout 2019.11.1 Note: checking out '2019.11.1'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b \u003cnew-branch-name\u003e HEAD is now at 57fbebac60 Update for 2019.11.1 Easy enough. Git tells us we aren’t on a branch (“detached HEAD”). That’s okay for now. Configure Buildroot for your hardware Now, you need to configure Buildroot for your target. The exact command to do this depends on which board you’re building for: Target Command Raspberry Pi Zero W make raspberrypi0w_defconfig Raspberry Pi Zero make raspberrypi0_defconfig Virtual machine make qemu_x86_64_defconfig Each of these words after make is a configuration. You can see all these configurations in the configs directory; more on this later. ~/buildroot$ make raspberrypi0w_defconfig Buildroot prints each command that it’s running. It’s a lot of gibberish, but you can ignore all of it except the bottom part—that’s Buildroot saying that the configuration is activated: # # configuration written to /home/georgev/buildroot/.config # Build We’re now ready to compile the entire operating system. Buildroot makes this easy, but it does take some time: probably 2–3 hours, depending on how fast your workstation is. It also needs an active Internet connection to download source code. Ready? Compile the target image:2 This will start printing lots of text as Buildroot downloads and compiles the various parts of the target operating system image. When it finishes, there will be an SD card image ready to burn onto the Pi’s SD card. If you’d like to watch instead of doing it yourself, you can press Play on this asciicast: How Buildroot works While this compiles, I’ll discuss what each part of Buildroot does. The best part about being an embedded Linux hacker is that your builds take hours! This gives you plenty of time to write blog posts about embedded Linux. (comic via xkcd) Compilation flow From a high level point of view, here is the workflow that Buildroot automates:3 Buildroot builds the toolchain, which is the cross-compilers and other tools that it needs to compile the target system (green boxes). The source code (blue boxes) for each piece of software is downloaded from the Internet. Using Buildroot scripts (grey boxes), source is unpacked, patched, configured, compiled, and installed into the target output directory that forms the root filesystem (“rootfs”) for the target (purple boxes). Extra files, such as on-device configuration files, also get copied into the target output directory. Finally, scripts assemble the final firmware image from this rootfs. There are some exceptions; sometimes the cross-compiler is downloaded without needing to be compiled. Sometimes the manufacturer ships an entire “Board Support Package” (BSP) where all the compilation has already been done for you. But at the end of the day, those just truncate this flowchart; all the steps still have to be accomplished somehow. Here are the most important directories in the top of the Buildroot tree. There are others, but they are boring. You’ll spend most of your time interacting with these: Directory Purpose board/ Files and scripts to support each target board configs/ Build configurations such as raspberrypi0w_defconfig package/ Package definitions output/host/ Build tools that run on the workstation output/target/ Target output directory where target binaries are staged output/images/ Filesystem images and the final firmware image are emitted here So, the next question is: How does the one magic make command know how to build everything? To answer that, first I’ll talk about the structure of a Buildroot package. Buildroot packages Compilation scripts are grouped into packages. Most things in Buildroot are packages. You can see these packages under the package directory in the Buildroot tree. Buildroot 2019.11 ships with 2,289 packages! This is a wonderful library of free, open source software that you can drop into your custom firmware with a few commands. Everything from the Nginx web server to the Chocolate Doom game engine is available. Each package defines its own configuration options, build steps, and dependencies. The dependencies tell Buildroot in what order to build packages, the build steps tell exactly what commands to run to build the package (including how to download its source code), and the configuration options control anything about the package. The package’s list of configuration options is in a file called Config.in4 using a language called Kconfig5. At minimum, the package must supply an option controlling whether or not the package is to be compiled at all. To put the package in the target’s image, you enable this option. There might also be other options controlling whether extra features of the software are compiled in. These extra options are often useful when space is at a premium: you can simply “compile out” features that you don’t need. Armed with an understanding of a package’s configuration, it is easy to understand the entire build configuration. Build configurations Taken together, all the configuration options for all a system’s packages form a build configuration. Applying one of these default build configurations—a “defconfig”—allows you to quickly select all the relevant options. And so this is how make knows how to build everything: all the configuration options, for all the packages, were supplied in the raspberrypi0w_defconfig file that we specified at the beginning of the build.6 (GNU Make calculates the dependency tree and starts building the packages in the correct order.) Selecting the defconfig copies all the config options into the working configuration kept in a file named .config. You can change the working configuration using the menuconfig tool. This provides a graphical interface that lets you find and change various menu options. Here’s an example, using menuconfig to enable the Chocolate Doom package mentioned above. Note that .config is not supposed to be kept in Git version control; it’s specific only to a particular working copy. You can run make savedefconfig to copy the working config back to the defconfig, which is version controlled. Booting the new image Enough theory. Let’s boot Linux. Allow the build process to finish. When it does, you should see some lines that look like this: INFO: vfat(boot.vfat): adding file 'zImage' as 'zImage' ... INFO: vfat(boot.vfat): cmd: \"MTOOLS_SKIP_CHECK=1 mcopy -bsp -i '/home/georgev/Code/buildroot-mel/output/images/boot.vfat' '/home/georgev/Code/buildroot-mel/output/images/zImage' '::'\" (stderr): INFO: hdimage(sdcard.img): adding partition 'boot' (in MBR) from 'boot.vfat' ... INFO: hdimage(sdcard.img): adding partition 'rootfs' (in MBR) from 'rootfs.ext4' ... INFO: hdimage(sdcard.img): writing MBR These lines indicate that the SD card image (sdcard.img) for the Pi has been generated. It built the image from the root filesystem in output/target/, which you can inspect:7 ~/buildroot$ ls -lh output/target/ total 64K drwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 bin drwxr-xr-x 4 georgev georgev 4.0K Jan 13 20:48 dev drwxr-xr-x 5 georgev georgev 4.0K Jan 13 22:01 etc drwxr-xr-x 3 georgev georgev 4.0K Jan 13 22:01 lib lrwxrwxrwx 1 georgev georgev 3 Jan 13 21:08 lib32 -\u003e lib lrwxrwxrwx 1 georgev georgev 11 Jan 13 21:23 linuxrc -\u003e bin/busybox drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 media drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 mnt drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 opt drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 proc drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 root drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 run drwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 sbin drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 sys -rw-r--r-- 1 georgev georgev 1.4K Jan 13 21:08 THIS_IS_NOT_YOUR_ROOT_FILESYSTEM drwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 tmp drwxr-xr-x 6 georgev georgev 4.0K Jan 13 22:01 usr drwxr-xr-x 3 georgev georgev 4.0K Jan 13 20:48 var We can verify that the SD card image was emitted by looking in the output/images/ directory: ~/buildroot$ ls -lh output/images/ total 225M -rw-r--r-- 1 georgev georgev 24K Jan 13 22:01 bcm2708-rpi-zero.dtb -rw-r--r-- 1 georgev georgev 32M Jan 13 22:01 boot.vfat -rw-r--r-- 1 georgev georgev 120M Jan 13 22:01 rootfs.ext2 lrwxrwxrwx 1 georgev georgev 11 Jan 13 22:01 rootfs.ext4 -\u003e rootfs.ext2 drwxr-xr-x 3 georgev georgev 4.0K Jan 13 21:28 rpi-firmware -rw-r--r-- 1 georgev georgev 153M Jan 13 22:01 sdcard.img -rw-r--r-- 1 georgev georgev 4.8M Jan 13 22:01 zImage Looks good. Now, let’s burn this image to the Pi’s SD card and start connecting the Pi to the computer. Optional: start the VM If you are using a Raspberry Pi, skip ahead to the section where we’ll start getting it ready. If you instead elected to build for a virtual machine, not a Pi, you can start the VM with a command8: ~/buildroot$ output/host/bin/qemu-system-x86_64 -M pc -kernel output/images/bzImage -drive file=output/images/rootfs.ext2,if=virtio,format=raw -append \"rootwait root=/dev/vda\" -net nic,model=virtio -net user The VM boots really quickly. On my workstation it only takes a couple seconds. Once the VM’s window appears, skip ahead to the “Boot the Firmware” section—it’s the same experience once you start the VM. Aside: how to use dmesg Let’s take a quick detour and learn how to work the Linux utility dmesg. It is a small tool that displays the output of the kernel log. This is useful because the kernel prints the names it assigns to devices that you’ve just plugged in. Reading the kernel log will let you know which device name to use for, say, your SD card. Basic usage is simple; just run: The -w flag stands for “watch;” dmesg will continue to monitor for new messages after dumping the kernel’s existing log. You can ignore the existing log; it’s probably pretty verbose. Once dmesg is watching, you can plug in your gadget and you should see a few lines like this: [163513.147002] mmc0: new ultra high speed SDR50 SDHC card at address aaaa [163513.174253] mmcblk0: mmc0:aaaa SP32G 29.7 GiB [163513.189137] mmcblk0: p1 In this example, the SD card has been assigned a name of mmcblk0, and it has a single partition p1 (so the full path of the device is /dev/mmcblk0 and its partition is /dev/mmcblk0p1). Depending on your SD card reader, it might also get assigned an sd prefix. No matter, as long as you know exactly which one it is. Once you’re done with dmesg, you can just hit Ctrl+C to stop it. Burn the Raspberry Pi’s SD card Insert your SD card and use dmesg to learn its block device name. Use dd to copy the image onto the card. Substitute /dev/mmcblkX with the actual path of your SD card. ~/buildroot$ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress Note Be sure you get the of (output file) correct. If you specify your workstation’s hard drive, dd will happily overwrite all your files. If you’re unsure, just go back to dmesg and reinsert your SD card to double check its device name. Here’s what this command does: Option Explanation if= Input File—read from here of= Output File—write to here bs= Block Size—write this many bytes at once status= Show a nice progress bar (sometimes this doesn’t work well) Once this finishes, make sure the kernel’s write buffers have been flushed to the card: Once this command returns, you can pull the SD card out and stick it into the Pi. Don’t turn on the Pi yet though (nothing bad will happen, it’s just not ready yet). Connect to the Pi’s serial console Now the FT2232 USB/UART device needs to be connected to the Pi’s serial pins. Here’s the Raspberry Pi header pinout: pinout.xyz is the best Raspberry Pi pinout website Since the FT2232 isn’t just a UART adapter, we need to know which pins should be used when it is being used in UART mode—the pins are named like ADBUS0, BCBUS3, etc. To figure this out, refer to section 3.1.2 of the FT2232’s datasheet, which suggests pin mappings: For “Async Serial,” pin ADBUS0 is TXD, and ADBUS1 is RXD. Easy enough. Connect the Pi’s UART TXD to the FT2232’s RXD, and vice versa. Finally, connect their grounds together. It should look like this: ADBUS0 might be labeled D0 or AD0 depending on your FT2232 adapter. This diagram was made with Fritzing, which is nice for drawing high-level wiring diagrams like these. Now, plug the serial adapter into your workstation. Using dmesg, learn the name of your FT2232 as you plug it in. It will probably be named ttyUSB0 and ttyUSB1—these are the two channels.9 Open the serial console Launch GNU Screen using the device name you just discovered. The extra flags configure the right baud rate and disable flow control—the vast majority of Linux serial consoles use this convention of 115200 baud with no hardware flow control. ~/buildroot$ sudo screen -fn /dev/ttyUSBX 115200 If you want to quit Screen, you need to type the escape sequence Ctrl+a followed by the command \\. Boot the firmware Plug in the Raspberry Pi’s power adapter. The serial console should begin printing boot messages as the operating system boots: [ 0.000000] Booting Linux on physical CPU 0x0 [ 0.000000] Linux version 4.19.66 (georgev@desertvoice) (gcc version 8.3.0 (Buildroot 2019.11.1)) #1 Tue Jan 14 11:14:59 CST 2020 [ 0.000000] CPU: ARMv6-compatible processor [410fb767] revision 7 (ARMv7), cr=00c5387d [ 0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache [ 0.000000] OF: fdt: Machine model: Raspberry Pi Zero Rev 1.3 [ 0.000000] Memory policy: Data cache writeback [ 0.000000] cma: Reserved 8 MiB at 0x19000000 [ 0.000000] random: get_random_bytes called from start_kernel+0x90/0x4a4 with crng_init=0 [ 0.000000] Built 1 zonelists, mobility grouping on. Total pages: 104545 [ 0.000000] Kernel command line: coherent_pool=1M bcm2708_fb.fbwidth=720 bcm2708_fb.fbheight=480 bcm2708_fb.fbswap=1 smsc95xx.macaddr=B8:27:EB:6C:5F:E1 vc_mem.mem_base=0x1ec00000 vc_mem.mem_size=0x20000000 root=/dev/mmcblk0p2 rootwait console=tty1 console=ttyAMA0,115200 [ 0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes) [ 0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes) [ 0.000000] Memory: 397928K/421888K available (6947K kernel code, 635K rwdata, 2080K rodata, 452K init, 796K bss, 15768K reserved, 8192K cma-reserved) Eventually, it should print a login prompt: Welcome to Buildroot! buildroot login: You can enter root as the username; there isn’t a password. You can look around with commands like ls /usr/bin to see what programs are available on the image. If your board made it to the login prompt, congratulations! You have compiled and booted your first firmware image from source code. The world is your oyster. Key takeaways This has been a high-level introduction to Buildroot. It’s easy to get much further down in the weeds than this article goes. Nevertheless, it’s definitely a lot of info. Here’s the key takeaways from this lesson: You own all the code on the target and all the tools that make it. All the software in this process is completely open source. It is all compiled on your computer when you type make. If anything is broken or doesn’t work like you want, you can simply change it. All the work was automated. Buildroot lets you focus on implementing one thing at a time, starting from a working Linux system. Gradually, you can take the defconfigs provided and craft them into custom firmware that works exactly like you want. The target rootfs is tiny! The default image is only 57 megabytes, and most of that is kernel modules that you can turn off. Buildroot’s “small image” philosophy leaves you plenty of space to add features, or lets you build a firmware image that fits in as little as 4MiB. Further reading A lot of people have emailed me to ask about other reading materials they can get to learn more about embedded Linux systems. I am currently working on building a better list of resources. Here are some of the ones that are most relevant to this chapter: How Linux Works, 2nd Edition10 by Brian Ward is a great book about many topics in Linux. It’s relevant for desktop and server Linux, as well as embedded. It covers basics such as shell commands yet still goes into important, complex topics like the X11 window system and the DBus messaging bus. It’s the right amount of detail to give you a good mental picture of how everything works, while still being approachable. Bootlin’s Buildroot training is maintained by the very prolific team at Bootlin, a French company that does embedded Linux development. You can pay them to come give your entire team training using this material. If you’re willing to read through their slide deck, it’s very thorough, although there’s no lecture accompanying it. The Buildroot user manual is the place to learn about hacking on Buildroot. The various areas of the build system are well-described and the reference manual for writing new packages is superb. The downside is that because it is a user manual, not a tutorial, it’s quite dense. You’ll definitely get familiar with it as you use Buildroot going forward. If you would like to recommend other relevant embedded Linux learning material, please send me an email as I would be glad to learn about it. Coming up next In the next article, we’ll be adding a feature to the Linux system we just compiled. This will involve reading some documentation and customizing the build configuration with menuconfig, like in the demo I showed earlier. I’ll also be discussing the init system and how to integrate your programs into the boot process. (Edit: this has been postponed to Part 6.) We’ll make all the changes and rebuild, testing the new changes right away (rebuilds take only a couple minutes with Buildroot). This is the next step in the iterative process of crafting your own firmware image! Subscribe to updates You can subscribe to all of my blog updates via email or RSS on the Subscribe page. Thanks for reading! Notes A note about troubleshooting: If you are running into problems, I highly recommend that you Google the error message, possibly alongside the keyword “buildroot.” It is likely that someone has had your problem before. At any rate, the world of embedded systems is full of novel bizarre problems, being frustrated is normal, and debugging is a really good skill to build. A note about using a virtual machine as a workstation: If you’re building Buildroot inside a VM (e.g. Ubuntu is in VirtualBox, and your PC is actually running Windows), be sure you pass through the FT2232 and the SD card reader to the guest. You should probably also give the guest multiple CPUs, or the build will take a very, very long time. Your definition of “fun” may vary. I think it’s pretty cool, anyway. ↩︎ If you intend to use your workstation for other things, you can instead run nice make, which will make the build a lower priority so that your workstation is still responsive. ↩︎ Although this guide uses Buildroot, this workflow applies to any embedded Linux distribution. ↩︎ Packages compiled for the host, not the target, have separate options in Config.host.in. ↩︎ Kconfig was originally created by the Linux kernel developers to help manage the Linux kernel’s vast array of features. Buildroot has a similar scope, so Kconfig is useful here too. ↩︎ This isn’t actually quite true. In reality, only non-default options are stored in the defconfigs. But since the default is stored elsewhere, it amounts to about the same thing as “storing all the configuration options.” ↩︎ Buildroot adds a file called THIS_IS_NOT_YOUR_ROOT_FILESYSTEM to the output/target directory. This is the root filesystem, mostly. But there are a few extra steps that happen, like creation of special files, that aren’t reflected in this tree, so that’s why that warning file is there. ↩︎ How did I know this awful command? Simple: I read it in the readme file in boards/qemu/x86_64/readme.txt. ↩︎ If you have an FT232 (not 2232), you’ll only have a single channel. That’s okay; we’re not using the second one right now. ↩︎ Some links on my site, such as this one, are affiliate links. The proceeds help me keep buying and building neat embedded systems. ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n\u003clabel for=\"tocToggle\"\u003eTable of Contents\u003c/label\u003e\u003c/p\u003e\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#prerequisites\"\u003ePrerequisites\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#kicking-off-buildroot\"\u003eKicking off Buildroot\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#install-host-tools\"\u003eInstall host tools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#download-buildroot\"\u003eDownload Buildroot\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#configure-buildroot-for-your-hardware\"\u003eConfigure Buildroot for your hardware\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#build\"\u003eBuild\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-buildroot-works\"\u003eHow Buildroot works\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#compilation-flow\"\u003eCompilation flow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#buildroot-packages\"\u003eBuildroot packages\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#build-configurations\"\u003eBuild configurations\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#booting-the-new-image\"\u003eBooting the new image\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#optional-start-the-vm\"\u003eOptional: start the VM\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#how-to-use-dmesg\"\u003eAside: how to use dmesg\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#burn-the-raspberry-pis-sd-card\"\u003eBurn the Raspberry Pi’s SD card\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#connect-to-the-pis-serial-console\"\u003eConnect to the Pi’s serial console\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#open-the-serial-console\"\u003eOpen the serial console\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#boot-the-pi\"\u003eBoot the firmware\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#key-takeaways\"\u003eKey takeaways\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#further-reading\"\u003eFurther reading\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#coming-up-next\"\u003eComing up next\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#subscribe-to-updates\"\u003eSubscribe to updates\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#notes\"\u003eNotes\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e\n\u003c/div\u003e\n\u003cp\u003eThis \u003ca href=\"https://www.thirtythreeforty.net/series/mastering-embedded-linux\"\u003eMastering Embedded Linux\u003c/a\u003e article is the first where the rubber hits the road.\nWe’re walking through building Linux from source code and booting it on a Raspberry Pi.\nWhereas the previous articles have been all discussion, this one is equal parts discussion and tutorial.\u003c/p\u003e\n\u003cp\u003eThis article will introduce \u003ca href=\"https://buildroot.org/\"\u003eBuildroot\u003c/a\u003e, a toolkit for building highly customized embedded Linux images.\nBuildroot is the right combination of “powerful” and “easy to use.”\nIt provides a lot of automation so that your build process can Just Work, freeing you up for doing the interesting parts of embedded Linux development.\u003c/p\u003e\n\u003cp\u003eIn this article:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWe’ll download Buildroot and start the build using just six commands.\u003c/li\u003e\n\u003cli\u003eWhile it compiles, we’ll talk about the steps Buildroot is doing automatically, and what the process looks like conceptually.\u003c/li\u003e\n\u003cli\u003eAt the end, we’ll walk through booting the freshly built operating system on a Raspberry Pi.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIt’s easy and fun.\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\nLet’s get started.\u003c/p\u003e\n\u003ch2 id=\"prerequisites\"\u003ePrerequisites\u003c/h2\u003e\n\u003cp\u003eTo follow along, you will need the things from the \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/mastering-embedded-linux-part-2-hardware/#needed-hardware\"\u003eshopping list at the end of the last article\u003c/a\u003e.\nThe Raspberry Pi will serve as the \u003cem\u003etarget hardware\u003c/em\u003e, and the FT2232 is the \u003cem\u003eserial adapter\u003c/em\u003e that’s needed to communicate with the Pi’s serial console.\nOr, if you don’t want to buy anything, you don’t have to; you can use a virtual machine as the target instead.\nI’ll give you the option as I go along.\u003c/p\u003e\n\u003cp\u003eRegardless of what target you pick, you will also need the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003cem\u003eHost workstation\u003c/em\u003e\u003c/strong\u003e running Linux. If you don’t have a favorite distribution, you can install Ubuntu. If you aren’t running Linux, you can use a virtual machine (VM) as the host and that will work okay with some caveats. I am not walking you through this—you’ll need to get Linux on your workstation beforehand.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e15GiB free disk space\u003c/strong\u003e. We are compiling an entire operating system; the final result is small, but it needs lots of space to get there. If you use a VM, make sure you give it enough virtual drive space.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e2–4 hours free time\u003c/strong\u003e. You’ll need time to read this article, do the build, and play with the result.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWorking knowledge of Linux\u003c/strong\u003e. You don’t need to be an expert, but it will be good to know how to get around in the shell.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"kicking-off-buildroot\"\u003eKicking off Buildroot\u003c/h2\u003e\n\u003cp\u003eWe’ll have Buildroot compiling our image in no time.\nThere’s four main steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eInstall host tools\u003c/li\u003e\n\u003cli\u003eDownload Buildroot\u003c/li\u003e\n\u003cli\u003eConfigure Buildroot\u003c/li\u003e\n\u003cli\u003eBuild the target image\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou only need to run \u003cstrong\u003esix commands\u003c/strong\u003e to accomplish all this.\nI’ll tell you what they are.\u003c/p\u003e\n\u003ch3 id=\"install-host-tools\"\u003eInstall host tools\u003c/h3\u003e\n\u003cp\u003eThe first step is to install programs that you’ll need that don’t ship with Buildroot.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eGit\u003c/strong\u003e: Buildroot provides tar archives, but it’s much easier in the long run to use the Git repository.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eA compiler\u003c/strong\u003e: Buildroot needs an initial compiler to build its own compilers.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMiscellaneous tools\u003c/strong\u003e: Various system utilities that help Buildroot download and preprocess code. Buildroot \u003ca href=\"https://buildroot.org/downloads/manual/manual.html#requirement-mandatory\"\u003edocuments\u003c/a\u003e these dependencies.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003escreen\u003c/strong\u003e: A “serial console” utility that will use the FT2232 serial adapter.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eInstall the tools.\u003c/strong\u003e (The \u003ccode\u003e~$\u003c/code\u003e in all the commands I give is the shell prompt. Don’t type that. Type what comes after it.)\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~$ sudo apt install -y git build-essential wget cpio unzip rsync bc libncurses5-dev screen\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThat’s pretty much it. Buildroot includes its own tools and just needs these things to get the process started.\u003c/p\u003e\n\u003cp\u003e(This command is for Ubuntu. It’s the only command in this guide that is distribution-specific. Everything else interacts with Buildroot, not the host operating system.)\u003c/p\u003e\n\u003ch3 id=\"download-buildroot\"\u003eDownload Buildroot\u003c/h3\u003e\n\u003cp\u003eBuildroot \u003ca href=\"https://buildroot.org/download.html\"\u003eprovides\u003c/a\u003e multiple ways to get the source code, but the easiest way to do it is to use Git.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eClone the Buildroot tree with Git:\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e\u003cspan\u003e~$ git clone git://git.buildroot.net/buildroot\n\u003c/span\u003eCloning into \u0026#39;buildroot\u0026#39;...\nremote: Enumerating objects: 356009, done.\nremote: Counting objects: 100% (356009/356009), done.\nremote: Compressing objects: 100% (116215/116215), done.\nremote: Total 356009 (delta 248969), reused 342974 (delta 238353)\nReceiving objects: 100% (356009/356009), 75.76 MiB | 1.36 MiB/s, done.\nResolving deltas: 100% (248969/248969), done.\n\u003cspan\u003e~$ cd buildroot/\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow we’re in the top level of the \u003cem\u003eBuildroot tree\u003c/em\u003e.\nWe need to switch to the exact version of Buildroot we want to build with.\nIn this case, it’s the 2019.11.1 (November 2019) release, which is the latest as of this writing in January 2020.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCheck out the \u003ccode\u003e2019.11.1\u003c/code\u003e tag\u003c/strong\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e\u003cspan\u003e~/buildroot$ git checkout 2019.11.1\n\u003c/span\u003eNote: checking out \u0026#39;2019.11.1\u0026#39;.\n\nYou are in \u0026#39;detached HEAD\u0026#39; state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b \u0026lt;new-branch-name\u0026gt;\n\nHEAD is now at 57fbebac60 Update for 2019.11.1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eEasy enough.\nGit tells us we aren’t on a branch (“detached HEAD”).\nThat’s okay for now.\u003c/p\u003e\n\u003ch3 id=\"configure-buildroot-for-your-hardware\"\u003eConfigure Buildroot for your hardware\u003c/h3\u003e\n\u003cp\u003eNow, you need to configure Buildroot for your target.\nThe exact command to do this depends on which board you’re building for:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eTarget\u003c/th\u003e\n\u003cth\u003eCommand\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eRaspberry Pi Zero W\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003emake raspberrypi0w_defconfig\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRaspberry Pi Zero\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003emake raspberrypi0_defconfig\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVirtual machine\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003emake qemu_x86_64_defconfig\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eEach of these words after \u003ccode\u003emake\u003c/code\u003e is a \u003cem\u003econfiguration\u003c/em\u003e.\nYou can see all these configurations in the \u003ccode\u003econfigs\u003c/code\u003e directory; more on this later.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ make raspberrypi0w_defconfig\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBuildroot prints each command that it’s running.\nIt’s a lot of gibberish, but you can ignore all of it except the bottom part—that’s Buildroot saying that the configuration is activated:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e#\n# configuration written to /home/georgev/buildroot/.config\n#\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"build\"\u003eBuild\u003c/h3\u003e\n\u003cp\u003eWe’re now ready to compile the entire operating system.\nBuildroot makes this easy, but it does take some time: probably 2–3 hours, depending on how fast your workstation is.\nIt also needs an active Internet connection to download source code.\u003c/p\u003e\n\u003cp\u003eReady?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompile the target image:\u003c/strong\u003e\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eThis will start printing lots of text as Buildroot downloads and compiles the various parts of the target operating system image.\nWhen it finishes, there will be an SD card image ready to burn onto the Pi’s SD card.\u003c/p\u003e\n\u003cp\u003eIf you’d like to watch instead of doing it yourself, you can press Play on this asciicast:\u003c/p\u003e\n\n\n\u003casciinema-player src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/buildroot-compile.cast\"\u003e\u003c/asciinema-player\u003e\n\u003ch2 id=\"how-buildroot-works\"\u003eHow Buildroot works\u003c/h2\u003e\n\u003cp\u003eWhile this compiles, I’ll discuss what each part of Buildroot does.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://imgs.xkcd.com/comics/compiling.png\" alt=\"The best part about being an embedded Linux hacker is that your builds take hours! This gives you plenty of time to write blog posts about embedded Linux.\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eThe best part about being an embedded Linux hacker is that your builds take hours! This gives you plenty of time to write blog posts about embedded Linux.\n\u003ca href=\"https://xkcd.com/303/\"\u003e(comic via xkcd)\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003ch3 id=\"compilation-flow\"\u003eCompilation flow\u003c/h3\u003e\n\u003cp\u003eFrom a high level point of view, here is the workflow that Buildroot automates:\u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/Buildroot%20Compilation%20Flow.svg\" alt=\"Buildroot compilation flow diagram\"/\u003e\n\u003c/figure\u003e\n\u003col\u003e\n\u003cli\u003eBuildroot builds the toolchain, which is the cross-compilers and other tools that it needs to compile the target system (green boxes).\u003c/li\u003e\n\u003cli\u003eThe source code (blue boxes) for each piece of software is downloaded from the Internet.\u003c/li\u003e\n\u003cli\u003eUsing Buildroot scripts (grey boxes), source is unpacked, patched, configured, compiled, and installed into the \u003cem\u003etarget output directory\u003c/em\u003e that forms the root filesystem (“rootfs”) for the target (purple boxes).\u003c/li\u003e\n\u003cli\u003eExtra files, such as on-device configuration files, also get copied into the target output directory.\u003c/li\u003e\n\u003cli\u003eFinally, scripts assemble the final firmware image from this rootfs.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThere are some exceptions; sometimes the cross-compiler is downloaded without needing to be compiled.\nSometimes the manufacturer ships an entire “Board Support Package” (BSP) where all the compilation has already been done for you.\nBut at the end of the day, those just truncate this flowchart; all the steps still have to be accomplished somehow.\u003c/p\u003e\n\u003cp\u003eHere are the most important directories in the top of the Buildroot tree.\nThere are others, but they are boring.\nYou’ll spend most of your time interacting with these:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eDirectory\u003c/th\u003e\n\u003cth\u003ePurpose\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eboard/\u003c/td\u003e\n\u003ctd\u003eFiles and scripts to support each target board\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003econfigs/\u003c/td\u003e\n\u003ctd\u003eBuild configurations such as \u003ccode\u003eraspberrypi0w_defconfig\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003epackage/\u003c/td\u003e\n\u003ctd\u003ePackage definitions\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eoutput/host/\u003c/td\u003e\n\u003ctd\u003eBuild tools that run on the workstation\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eoutput/target/\u003c/td\u003e\n\u003ctd\u003eTarget output directory where target binaries are staged\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eoutput/images/\u003c/td\u003e\n\u003ctd\u003eFilesystem images and the final firmware image are emitted here\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eSo, the next question is: How does the one magic \u003ccode\u003emake\u003c/code\u003e command know how to build everything?\nTo answer that, first I’ll talk about the structure of a Buildroot package.\u003c/p\u003e\n\u003ch3 id=\"buildroot-packages\"\u003eBuildroot packages\u003c/h3\u003e\n\u003cp\u003eCompilation scripts are grouped into \u003cem\u003epackages\u003c/em\u003e.\nMost things in Buildroot are packages.\u003c/p\u003e\n\u003cp\u003eYou can see these packages under the \u003ccode\u003epackage\u003c/code\u003e directory in the Buildroot tree.\nBuildroot 2019.11 ships with 2,289 packages!\nThis is a wonderful library of free, open source software that you can drop into your custom firmware with a few commands.\nEverything from the \u003ca href=\"https://www.nginx.com/\"\u003eNginx\u003c/a\u003e web server to the \u003ca href=\"https://www.chocolate-doom.org/\"\u003eChocolate Doom\u003c/a\u003e game engine is available.\u003c/p\u003e\n\u003cp\u003eEach package defines its own configuration options, build steps, and dependencies.\nThe dependencies tell Buildroot in what order to build packages, the build steps tell exactly what commands to run to build the package (including how to download its source code), and the configuration options control anything about the package.\u003c/p\u003e\n\u003cp\u003eThe package’s list of configuration options is in a file called \u003ccode\u003eConfig.in\u003c/code\u003e\u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e using a language called \u003ca href=\"https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt\"\u003eKconfig\u003c/a\u003e\u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e.\nAt minimum, the package must supply an option controlling whether or not the package is to be compiled at all.\nTo put the package in the target’s image, you enable this option.\nThere might also be other options controlling whether extra features of the software are compiled in.\nThese extra options are often useful when space is at a premium: you can simply “compile out” features that you don’t need.\u003c/p\u003e\n\u003cp\u003eArmed with an understanding of a package’s configuration, it is easy to understand the entire build configuration.\u003c/p\u003e\n\u003ch3 id=\"build-configurations\"\u003eBuild configurations\u003c/h3\u003e\n\u003cp\u003eTaken together, \u003cem\u003eall\u003c/em\u003e the configuration options for \u003cem\u003eall\u003c/em\u003e a system’s packages form a \u003cem\u003ebuild configuration\u003c/em\u003e.\nApplying one of these default build configurations—a “defconfig”—allows you to quickly select all the relevant options.\u003c/p\u003e\n\u003cp\u003eAnd so this is how \u003ccode\u003emake\u003c/code\u003e knows how to build everything: all the configuration options, for all the packages, were supplied in the \u003ccode\u003eraspberrypi0w_defconfig\u003c/code\u003e file that we specified at the beginning of the build.\u003csup id=\"fnref:6\"\u003e\u003ca href=\"#fn:6\" role=\"doc-noteref\"\u003e6\u003c/a\u003e\u003c/sup\u003e\n(GNU Make calculates the dependency tree and starts building the packages in the correct order.)\u003c/p\u003e\n\u003cp\u003eSelecting the defconfig copies all the config options into the \u003cem\u003eworking configuration\u003c/em\u003e kept in a file named \u003ccode\u003e.config\u003c/code\u003e.\nYou can change the working configuration using the \u003cem\u003emenuconfig\u003c/em\u003e tool.\nThis provides a graphical interface that lets you find and change various menu options.\nHere’s an example, using menuconfig to enable the Chocolate Doom package mentioned above.\u003c/p\u003e\n\n\u003casciinema-player src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/menuconfig.cast\"\u003e\u003c/asciinema-player\u003e\n\u003cp\u003eNote that \u003ccode\u003e.config\u003c/code\u003e is not supposed to be kept in Git version control; it’s specific only to a particular working copy.\nYou can run \u003ccode\u003emake savedefconfig\u003c/code\u003e to copy the working config back to the defconfig, which \u003cem\u003eis\u003c/em\u003e version controlled.\u003c/p\u003e\n\u003ch2 id=\"booting-the-new-image\"\u003eBooting the new image\u003c/h2\u003e\n\u003cp\u003eEnough theory. Let’s boot Linux.\u003c/p\u003e\n\u003cp\u003eAllow the build process to finish. When it does, you should see some lines that look like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003eINFO: vfat(boot.vfat): adding file \u0026#39;zImage\u0026#39; as \u0026#39;zImage\u0026#39; ...\nINFO: vfat(boot.vfat): cmd: \u0026#34;MTOOLS_SKIP_CHECK=1 mcopy -bsp -i \u0026#39;/home/georgev/Code/buildroot-mel/output/images/boot.vfat\u0026#39; \u0026#39;/home/georgev/Code/buildroot-mel/output/images/zImage\u0026#39; \u0026#39;::\u0026#39;\u0026#34; (stderr):\nINFO: hdimage(sdcard.img): adding partition \u0026#39;boot\u0026#39; (in MBR) from \u0026#39;boot.vfat\u0026#39; ...\nINFO: hdimage(sdcard.img): adding partition \u0026#39;rootfs\u0026#39; (in MBR) from \u0026#39;rootfs.ext4\u0026#39; ...\nINFO: hdimage(sdcard.img): writing MBR\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThese lines indicate that the SD card image (\u003ccode\u003esdcard.img\u003c/code\u003e) for the Pi has been generated.\nIt built the image from the root filesystem in \u003ccode\u003eoutput/target/\u003c/code\u003e, which you can inspect:\u003csup id=\"fnref:7\"\u003e\u003ca href=\"#fn:7\" role=\"doc-noteref\"\u003e7\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ ls -lh output/target/\ntotal 64K\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 bin\ndrwxr-xr-x 4 georgev georgev 4.0K Jan 13 20:48 dev\ndrwxr-xr-x 5 georgev georgev 4.0K Jan 13 22:01 etc\ndrwxr-xr-x 3 georgev georgev 4.0K Jan 13 22:01 lib\nlrwxrwxrwx 1 georgev georgev    3 Jan 13 21:08 lib32 -\u0026gt; lib\nlrwxrwxrwx 1 georgev georgev   11 Jan 13 21:23 linuxrc -\u0026gt; bin/busybox\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 media\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 mnt\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 opt\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 proc\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 root\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 run\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 22:01 sbin\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 sys\n-rw-r--r-- 1 georgev georgev 1.4K Jan 13 21:08 THIS_IS_NOT_YOUR_ROOT_FILESYSTEM\ndrwxr-xr-x 2 georgev georgev 4.0K Jan 13 20:48 tmp\ndrwxr-xr-x 6 georgev georgev 4.0K Jan 13 22:01 usr\ndrwxr-xr-x 3 georgev georgev 4.0K Jan 13 20:48 var\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can verify that the SD card image was emitted by looking in the \u003ccode\u003eoutput/images/\u003c/code\u003e directory:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ ls -lh output/images/\ntotal 225M\n-rw-r--r-- 1 georgev georgev  24K Jan 13 22:01 bcm2708-rpi-zero.dtb\n-rw-r--r-- 1 georgev georgev  32M Jan 13 22:01 boot.vfat\n-rw-r--r-- 1 georgev georgev 120M Jan 13 22:01 rootfs.ext2\nlrwxrwxrwx 1 georgev georgev   11 Jan 13 22:01 rootfs.ext4 -\u0026gt; rootfs.ext2\ndrwxr-xr-x 3 georgev georgev 4.0K Jan 13 21:28 rpi-firmware\n\u003cspan\u003e-rw-r--r-- 1 georgev georgev 153M Jan 13 22:01 sdcard.img\n\u003c/span\u003e-rw-r--r-- 1 georgev georgev 4.8M Jan 13 22:01 zImage\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLooks good. Now, let’s burn this image to the Pi’s SD card and start connecting the Pi to the computer.\u003c/p\u003e\n\u003ch3 id=\"optional-start-the-vm\"\u003eOptional: start the VM\u003c/h3\u003e\n\u003cp\u003eIf you are \u003cstrong\u003eusing a Raspberry Pi\u003c/strong\u003e, \u003ca href=\"#how-to-use-dmesg\"\u003eskip ahead\u003c/a\u003e to the section where we’ll start getting it ready.\u003c/p\u003e\n\u003cp\u003eIf you instead elected to build for a virtual machine, not a Pi, you can start the VM with a command\u003csup id=\"fnref:8\"\u003e\u003ca href=\"#fn:8\" role=\"doc-noteref\"\u003e8\u003c/a\u003e\u003c/sup\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ output/host/bin/qemu-system-x86_64 -M pc -kernel output/images/bzImage -drive file=output/images/rootfs.ext2,if=virtio,format=raw -append \u0026#34;rootwait root=/dev/vda\u0026#34; -net nic,model=virtio -net user\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/qemu.png\" alt=\"The Qemu VM booting up\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eThe VM boots really quickly. On my workstation it only takes a couple seconds.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eOnce the VM’s window appears, skip ahead to \u003ca href=\"#boot-the-pi\"\u003ethe “Boot the Firmware”\u003c/a\u003e section—it’s the same experience once you start the VM.\u003c/p\u003e\n\u003ch3 id=\"how-to-use-dmesg\"\u003eAside: how to use dmesg\u003c/h3\u003e\n\u003cp\u003eLet’s take a quick detour and learn how to work the Linux utility dmesg.\nIt is a small tool that displays the output of the kernel log.\nThis is useful because the kernel prints the names it assigns to devices that you’ve just plugged in.\nReading the kernel log will let you know which device name to use for, say, your SD card.\u003c/p\u003e\n\u003cp\u003eBasic usage is simple; just run:\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e-w\u003c/code\u003e flag stands for “watch;” dmesg will continue to monitor for new messages after dumping the kernel’s existing log.\nYou can ignore the existing log; it’s probably pretty verbose.\nOnce dmesg is watching, you can plug in your gadget and you should see a few lines like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e[163513.147002] mmc0: new ultra high speed SDR50 SDHC card at address aaaa\n[163513.174253] mmcblk0: mmc0:aaaa SP32G 29.7 GiB\n[163513.189137]  mmcblk0: p1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this example, the SD card has been assigned a name of \u003ccode\u003emmcblk0\u003c/code\u003e, and it has a single partition \u003ccode\u003ep1\u003c/code\u003e (so the full path of the device is \u003ccode\u003e/dev/mmcblk0\u003c/code\u003e and its partition is \u003ccode\u003e/dev/mmcblk0p1\u003c/code\u003e).\nDepending on your SD card reader, it might also get assigned an \u003ccode\u003esd\u003c/code\u003e prefix. No matter, as long as you know exactly which one it is.\u003c/p\u003e\n\u003cp\u003eOnce you’re done with dmesg, you can just hit \u003ckbd\u003eCtrl\u003c/kbd\u003e+\u003ckbd\u003eC\u003c/kbd\u003e to stop it.\u003c/p\u003e\n\u003ch3 id=\"burn-the-raspberry-pis-sd-card\"\u003eBurn the Raspberry Pi’s SD card\u003c/h3\u003e\n\u003cp\u003eInsert your SD card and use dmesg to learn its block device name.\n\u003cstrong\u003eUse \u003ccode\u003edd\u003c/code\u003e to copy the image onto the card.\u003c/strong\u003e Substitute \u003ccode\u003e/dev/mmcblkX\u003c/code\u003e with the actual path of your SD card.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ sudo dd if=output/images/sdcard.img of=/dev/mmcblkX bs=1M status=progress\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cstrong\u003eNote\u003c/strong\u003e\u003cbr/\u003e\nBe sure you get the \u003ccode\u003eof\u003c/code\u003e (output file) correct. If you specify your workstation’s hard drive, \u003ccode\u003edd\u003c/code\u003e will happily overwrite all your files.\nIf you’re unsure, just go back to dmesg and reinsert your SD card to double check its device name.\n\u003c/blockquote\u003e\n\u003cp\u003eHere’s what this command does:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eOption\u003c/th\u003e\n\u003cth\u003eExplanation\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eif=\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eI\u003c/strong\u003enput \u003cstrong\u003eF\u003c/strong\u003eile—read from here\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eof=\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eO\u003c/strong\u003eutput \u003cstrong\u003eF\u003c/strong\u003eile—write to here\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ebs=\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eB\u003c/strong\u003elock \u003cstrong\u003eS\u003c/strong\u003eize—write this many bytes at once\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003estatus=\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eShow a nice progress bar (sometimes this doesn’t work well)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eOnce this finishes, make sure the kernel’s write buffers have been flushed to the card:\u003c/p\u003e\n\u003cp\u003eOnce this command returns, you can pull the SD card out and stick it into the Pi.\nDon’t turn on the Pi yet though (nothing bad will happen, it’s just not ready yet).\u003c/p\u003e\n\u003ch3 id=\"connect-to-the-pis-serial-console\"\u003eConnect to the Pi’s serial console\u003c/h3\u003e\n\u003cp\u003eNow the FT2232 USB/UART device needs to be connected to the Pi’s serial pins.\nHere’s the Raspberry Pi header pinout:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/rpi-uart.png\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003e\n\u003ca href=\"https://pinout.xyz/pinout/uart#\"\u003epinout.xyz is the best Raspberry Pi pinout website\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eSince the FT2232 isn’t \u003cem\u003ejust\u003c/em\u003e a UART adapter, we need to know which pins should be used when it \u003cem\u003eis\u003c/em\u003e being used in UART mode—the pins are named like \u003ccode\u003eADBUS0\u003c/code\u003e, \u003ccode\u003eBCBUS3\u003c/code\u003e, etc.\nTo figure this out, refer to section 3.1.2 of \u003ca href=\"https://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT2232H.pdf\"\u003ethe FT2232’s datasheet\u003c/a\u003e, which suggests pin mappings:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/ft2232-pins.png\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eFor “Async Serial,” pin ADBUS0 is TXD, and ADBUS1 is RXD. Easy enough.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConnect the Pi’s UART TXD to the FT2232’s RXD, and vice versa.\u003c/strong\u003e\nFinally, connect their grounds together.\nIt should look like this:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/mastering-embedded-linux-part-3-buildroot/pi-uart-fritzing.png\" alt=\"Raspberry Pi connection diagram\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003e\u003ccode\u003eADBUS0\u003c/code\u003e might be labeled \u003ccode\u003eD0\u003c/code\u003e or \u003ccode\u003eAD0\u003c/code\u003e depending on your FT2232 adapter. This diagram was made with Fritzing, which is nice for drawing high-level wiring diagrams like these.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eNow, \u003cstrong\u003eplug the serial adapter into your workstation\u003c/strong\u003e.\nUsing dmesg, learn the name of your FT2232 as you plug it in. It will probably be named \u003ccode\u003ettyUSB0\u003c/code\u003e \u003cem\u003eand\u003c/em\u003e \u003ccode\u003ettyUSB1\u003c/code\u003e—these are the two channels.\u003csup id=\"fnref:9\"\u003e\u003ca href=\"#fn:9\" role=\"doc-noteref\"\u003e9\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003ch3 id=\"open-the-serial-console\"\u003eOpen the serial console\u003c/h3\u003e\n\u003cp\u003eLaunch GNU Screen using the device name you just discovered.\nThe extra flags configure the right \u003ca href=\"https://learn.sparkfun.com/tutorials/serial-communication/all#rules-of-serial\"\u003ebaud rate\u003c/a\u003e and disable \u003ca href=\"https://en.wikipedia.org/wiki/Flow_control_(data)#Hardware_flow_control\"\u003eflow control\u003c/a\u003e—the vast majority of Linux serial consoles use this convention of 115200 baud with no hardware flow control.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e~/buildroot$ sudo screen -fn /dev/ttyUSBX 115200\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you want to quit Screen, you need to type the \u003ca href=\"https://www.gnu.org/software/screen/manual/screen.html#Quit\"\u003e\u003cem\u003eescape sequence\u003c/em\u003e\u003c/a\u003e \u003ckbd\u003eCtrl\u003c/kbd\u003e+\u003ckbd\u003ea\u003c/kbd\u003e followed by the command \u003ckbd\u003e\\\u003c/kbd\u003e.\u003c/p\u003e\n\u003ch3 id=\"boot-the-pi\"\u003eBoot the firmware\u003c/h3\u003e\n\u003cp\u003ePlug in the Raspberry Pi’s power adapter.\nThe serial console should begin printing boot messages as the operating system boots:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003e[    0.000000] Booting Linux on physical CPU 0x0\n[    0.000000] Linux version 4.19.66 (georgev@desertvoice) (gcc version 8.3.0 (Buildroot 2019.11.1)) #1 Tue Jan 14 11:14:59 CST 2020\n[    0.000000] CPU: ARMv6-compatible processor [410fb767] revision 7 (ARMv7), cr=00c5387d\n[    0.000000] CPU: PIPT / VIPT nonaliasing data cache, VIPT nonaliasing instruction cache\n[    0.000000] OF: fdt: Machine model: Raspberry Pi Zero Rev 1.3\n[    0.000000] Memory policy: Data cache writeback\n[    0.000000] cma: Reserved 8 MiB at 0x19000000\n[    0.000000] random: get_random_bytes called from start_kernel+0x90/0x4a4 with crng_init=0\n[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 104545\n[    0.000000] Kernel command line: coherent_pool=1M bcm2708_fb.fbwidth=720 bcm2708_fb.fbheight=480 bcm2708_fb.fbswap=1 smsc95xx.macaddr=B8:27:EB:6C:5F:E1 vc_mem.mem_base=0x1ec00000 vc_mem.mem_size=0x20000000  root=/dev/mmcblk0p2 rootwait console=tty1 console=ttyAMA0,115200\n[    0.000000] Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)\n[    0.000000] Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)\n[    0.000000] Memory: 397928K/421888K available (6947K kernel code, 635K rwdata, 2080K rodata, 452K init, 796K bss, 15768K reserved, 8192K cma-reserved)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eEventually, it should print a login prompt:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"text\"\u003eWelcome to Buildroot!\nbuildroot login:\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYou can enter \u003ccode\u003eroot\u003c/code\u003e as the username; there isn’t a password.\nYou can look around with commands like \u003ccode\u003els /usr/bin\u003c/code\u003e to see what programs are available on the image.\u003c/p\u003e\n\u003cp\u003eIf your board made it to the login prompt, congratulations!\nYou have compiled and booted your first firmware image from source code.\nThe world is your oyster.\u003c/p\u003e\n\u003ch2 id=\"key-takeaways\"\u003eKey takeaways\u003c/h2\u003e\n\u003cp\u003eThis has been a high-level introduction to Buildroot.\nIt’s easy to get much further down in the weeds than this article goes.\nNevertheless, it’s definitely a lot of info.\u003c/p\u003e\n\u003cp\u003eHere’s the key takeaways from this lesson:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eYou own all the code on the target and all the tools that make it.\u003c/strong\u003e\u003cbr/\u003e\nAll the software in this process is completely open source.\nIt is all compiled on your computer when you type \u003ccode\u003emake\u003c/code\u003e.\nIf anything is broken or doesn’t work like you want, you can simply change it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAll the work was automated.\u003c/strong\u003e\u003cbr/\u003e\nBuildroot lets you focus on implementing one thing at a time, starting from a working Linux system.\nGradually, you can take the defconfigs provided and craft them into custom firmware that works exactly like you want.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eThe target rootfs is tiny!\u003c/strong\u003e\u003cbr/\u003e\nThe default image is only 57 megabytes, and most of that is kernel modules that you can turn off.\nBuildroot’s “small image” philosophy leaves you plenty of space to add features, or lets you build a firmware image that fits in as little as 4MiB.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"further-reading\"\u003eFurther reading\u003c/h2\u003e\n\u003cp\u003eA lot of people have emailed me to ask about other reading materials they can get to learn more about embedded Linux systems.\nI am currently working on building a better list of resources.\nHere are some of the ones that are most relevant to this chapter:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://amzn.to/2NqMjK1\"\u003e\u003cem\u003eHow Linux Works, 2nd Edition\u003c/em\u003e\u003c/a\u003e\u003c/strong\u003e\u003csup id=\"fnref:10\"\u003e\u003ca href=\"#fn:10\" role=\"doc-noteref\"\u003e10\u003c/a\u003e\u003c/sup\u003e by Brian Ward is a great book about many topics in Linux.\nIt’s relevant for desktop and server Linux, as well as embedded.\nIt covers basics such as shell commands yet still goes into important, complex topics like the X11 window system and the DBus messaging bus.\nIt’s the right amount of detail to give you a good mental picture of how everything works, while still being approachable.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://bootlin.com/training/buildroot/\"\u003eBootlin’s Buildroot training\u003c/a\u003e\u003c/strong\u003e is maintained by the very prolific team at Bootlin, a French company that does embedded Linux development.\nYou can pay them to come give your entire team training using this material. If you’re willing to read through their slide deck, it’s very thorough, although there’s no lecture accompanying it.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://buildroot.org/downloads/manual/manual.html\"\u003eThe Buildroot user manual\u003c/a\u003e\u003c/strong\u003e is the place to learn about hacking on Buildroot.\nThe various areas of the build system are well-described and the reference manual for writing new packages is superb.\nThe downside is that because it is a user manual, not a tutorial, it’s quite dense.\nYou’ll definitely get familiar with it as you use Buildroot going forward.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you would like to recommend other relevant embedded Linux learning material, please \u003ca href=\"mailto:thirtythreeforty@gmail.com\"\u003esend me an email\u003c/a\u003e as I would be glad to learn about it.\u003c/p\u003e\n\u003ch2 id=\"coming-up-next\"\u003eComing up next\u003c/h2\u003e\n\u003cp\u003eIn the \u003ca href=\"https://www.thirtythreeforty.net/posts/2020/03/mastering-embedded-linux-part-4-adding-features/\"\u003enext article\u003c/a\u003e, we’ll be adding a feature to the Linux system we just compiled.\nThis will involve reading some documentation and customizing the build configuration with menuconfig, like in the demo I showed earlier.\n\u003cdel\u003eI’ll also be discussing the \u003cem\u003einit system\u003c/em\u003e and how to integrate your programs into the boot process.\u003c/del\u003e (Edit: this has been postponed to Part 6.)\u003c/p\u003e\n\u003cp\u003eWe’ll make all the changes and rebuild, testing the new changes right away (rebuilds take only a couple minutes with Buildroot).\nThis is the next step in the iterative process of crafting your own firmware image!\u003c/p\u003e\n\u003ch2 id=\"subscribe-to-updates\"\u003eSubscribe to updates\u003c/h2\u003e\n\u003cp\u003eYou can subscribe to all of my blog updates via email or RSS on the \u003ca href=\"https://www.thirtythreeforty.net/subscribe/\"\u003eSubscribe page\u003c/a\u003e.\nThanks for reading!\u003c/p\u003e\n\u003ch2 id=\"notes\"\u003eNotes\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA note about troubleshooting:\u003cbr/\u003e\nIf you are running into problems, I highly recommend that you Google the error message, possibly alongside the keyword “buildroot.”\nIt is likely that someone has had your problem before.\nAt any rate, the world of embedded systems is full of novel bizarre problems, being frustrated is normal, and debugging is a really good skill to build.\u003c/li\u003e\n\u003cli\u003eA note about using a virtual machine as a workstation:\u003cbr/\u003e\nIf you’re building Buildroot \u003cem\u003einside\u003c/em\u003e a VM (e.g. Ubuntu is in VirtualBox, and your PC is actually running Windows), be sure you \u003ca href=\"https://www.smarthomebeginner.com/access-usb-drive-in-virtualbox-guest-os/\"\u003epass through\u003c/a\u003e the FT2232 and the SD card reader to the guest.\nYou should probably also give the guest multiple CPUs, or the build will take a very, very long time.\u003c/li\u003e\n\u003c/ul\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eYour definition of “fun” may vary. \u003cem\u003eI\u003c/em\u003e think it’s pretty cool, anyway. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\" role=\"doc-endnote\"\u003e\n\u003cp\u003eIf you intend to use your workstation for other things, you can instead run \u003ccode\u003enice make\u003c/code\u003e, which will make the build a lower priority so that your workstation is still responsive. \u003ca href=\"#fnref:2\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\" role=\"doc-endnote\"\u003e\n\u003cp\u003eAlthough this guide uses Buildroot, this workflow applies to \u003cem\u003eany\u003c/em\u003e embedded Linux distribution. \u003ca href=\"#fnref:3\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\" role=\"doc-endnote\"\u003e\n\u003cp\u003ePackages compiled for the host, not the target, have separate options in \u003ccode\u003eConfig.host.in\u003c/code\u003e. \u003ca href=\"#fnref:4\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\" role=\"doc-endnote\"\u003e\n\u003cp\u003eKconfig was originally created by the Linux kernel developers to help manage the Linux kernel’s vast array of features. Buildroot has a similar scope, so Kconfig is useful here too. \u003ca href=\"#fnref:5\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:6\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis isn’t actually quite true. In reality, only non-default options are stored in the defconfigs. But since the default is stored elsewhere, it amounts to about the same thing as “storing all the configuration options.” \u003ca href=\"#fnref:6\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:7\" role=\"doc-endnote\"\u003e\n\u003cp\u003eBuildroot adds a file called \u003ccode\u003eTHIS_IS_NOT_YOUR_ROOT_FILESYSTEM\u003c/code\u003e to the \u003ccode\u003eoutput/target\u003c/code\u003e directory. This \u003cem\u003eis\u003c/em\u003e the root filesystem, mostly. But there are a few extra steps that happen, like creation of special files, that aren’t reflected in this tree, so that’s why that warning file is there. \u003ca href=\"#fnref:7\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:8\" role=\"doc-endnote\"\u003e\n\u003cp\u003eHow did I know this awful command? Simple: I read it in \u003ca href=\"https://github.com/buildroot/buildroot/blob/2019.11.1/board/qemu/x86_64/readme.txt\"\u003ethe readme file in \u003ccode\u003eboards/qemu/x86_64/readme.txt\u003c/code\u003e\u003c/a\u003e. \u003ca href=\"#fnref:8\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:9\" role=\"doc-endnote\"\u003e\n\u003cp\u003eIf you have an FT232 (not 2232), you’ll only have a single channel. That’s okay; we’re not using the second one right now. \u003ca href=\"#fnref:9\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:10\" role=\"doc-endnote\"\u003e\n\u003cp\u003eSome links on my site, such as this one, are affiliate links. The proceeds help me keep buying and building neat embedded systems. \u003ca href=\"#fnref:10\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": "2020-01-14T11:45:00-06:00",
  "modifiedTime": "2020-01-14T11:45:00-06:00"
}
