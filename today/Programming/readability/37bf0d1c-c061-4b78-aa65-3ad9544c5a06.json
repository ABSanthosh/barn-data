{
  "id": "37bf0d1c-c061-4b78-aa65-3ad9544c5a06",
  "title": "What's new in Git 2.47.0?",
  "link": "https://about.gitlab.com/blog/2024/10/07/whats-new-in-git-2-47-0",
  "description": "",
  "author": "Justin Tobler",
  "published": "2024-10-07T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Justin Tobler",
  "length": 11194,
  "excerpt": "Learn about the latest version of Git, including new global variables to configure reference and object hash formats. Discover contributions from GitLab's Git team and the wider Git community.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/blog/nuxt-images/ico/favicon-192x192.png?cache=2022041",
  "text": "The Git project recently released Git v2.47.0. Let's look at a few notable highlights from this release, which includes contributions from GitLab's Git team and the wider Git community. New global configuration options If you have been following recent Git releases, you are probably familiar with the new \"reftable\" reference backend that became available with Git version 2.45. Check out our Beginner's guide to the Git reftable format to learn more. Previously, in order to initialize a repository with the \"reftable\" format, the --ref-format option needed to be passed to to git-init(1): $ git init --ref-format reftable With the 2.47 release, Git now has the init.defaultRefFormat configuration option, which tells Git which reference backend to use when initializing a repository. This can be used to override the default \"files\" backend and begin using the \"reftable\" backend. To configure, execute the following: $ git config set --global init.defaultRefFormat reftable As some of you may know, the object hash format used by Git repositories is also configurable. By default, repositories are initialized to use the SHA-1 object format. An alternative is the SHA-256 format, which is more secure and future-proof. You can read more about this in one of our previous blog posts on SHA-256 support in Gitaly. A SHA-256 repository can be created by passing the --object-format option to git-init(1): $ git init --object-format sha256 In this Git release another configuration option, init.defaultObjectFormat, has been added. This option tells Git which object format to use by default when initializing a repository. To configure, execute the following: $ git config set --global init.defaultObjectFormat sha256 Something to note, SHA-256 repositories are not interoperable with SHA-1 repositories and not all forges support hosting SHA-256 repositories. GitLab recently announced experimental support for SHA-256 repositories if you want to try it out. These options provide a useful mechanism to begin using these repository features without having to consciously think about it every time you initialize a new repository. This project was led by Patrick Steinhardt. New subcommand for git-refs(1) In the previous Git release, the git-refs(1) command was introduced to provide low-level access to references in a repository and provided the \"migrate\" subcommand to convert between reference backends. This release adds a new \"verify\" subcommand which allows the user to check the reference database for consistency. To verify the consistency of a repository, we often execute git-fsck(1). Notably, this command does not explicitly verify the reference database of the repository though. With the introduction of the \"reftable\" reference format, which is a binary format and thus harder to inspect manually, it is now even more important that tooling be established to fill this gap. Let's set up a repository with an invalid reference to demonstrate: # The \"files\" backend is used so we can easily create an invalid reference. $ git init --ref-format files $ git commit --allow-empty -m \"init\" # A lone '@' is not a valid reference name. $ cp .git/refs/heads/main .git/refs/heads/@ $ git refs verify error: refs/heads/@: badRefName: invalid refname format We can see the invalid reference was detected and an error message printed to the user. While this tooling is not something the end-user will likely run, it is particularly useful on the server side to ensure repositories remain consistent. Eventually, the goal is to integrate this command as part of git-fsck(1) to provide a unified way to execute repository consistency checks. This project was led by Jialuo She as part of the Google Summer of Code. To learn more, you can read Jialuo's GSoC report. Ongoing reftables work This release also includes fixes for some bugs found in the \"reftable\" backend. One of these bugs is particularly interesting and revolves around how table compaction was being performed. As you may recall, the reftable backend consists of a series of tables containing the state of all the references in the repository. Each atomic set of reference changes results in a new table being written and recorded in the \"tables.list\" file. To reduce the number of tables present, after each reference update, the tables are compacted to follow a geometric sequence by file size. After the tables are compacted, the \"tables.list\" file is updated to reflect the new on-disk state of the reftables. By design, concurrent table writes and compaction is allowed. Synchronization at certain points is controlled through the use of lock files. For example, when compaction is starting the \"tables.list\" file is initially locked so the file can be consistently read and the tables requiring compaction can also be locked. Since the actual table compaction can take a while the lock is released, allowing concurrent writes to proceed. This is safe because concurrent writers know that they must not modify the now-locked tables which are about to be compacted. When the newly compacted tables have finished being written, the \"tables.list\" file is locked again and this time it is updated to reflect the new table state. There is a problem though: What happens if a concurrent reference update writes a new table to the \"tables.list\" in the middle of table compaction after the initial lock was released, but before the new list file was written? If this race were to occur, the compacting process would not know about the new table and consequently rewrite the \"tables.list\" file without the new table. This effectively drops the concurrent update and could result in references not being added, updated, or removed as expected. Luckily, the fix to remediate this problem is rather straightforward. When the compacting process acquires the lock to write to the \"tables.list\" it must first check if any updates to the file have occurred and reload the file. Doing so ensures any concurrent table updates are also reflected appropriately. For more information on this fix, check out the corresponding mailing-list thread. This project was led by Patrick Steinhardt. Fixes for git-maintenance(1) As a repository grows, it is important that it is properly maintained. By default, Git executes git-maintenace(1) after certain operations to keep the repository healthy. To avoid performing unnecessary maintenance, the --auto option is specified which uses defined heuristics to determine whether maintenance tasks should be run. The command can be configured to perform various different maintenance tasks, but by default, it simply executes git-gc(1) in the background and allows the user to carry on with their business. This works as expected until maintenance is configured to perform non-default maintenance tasks. When this happens the configured maintenance tasks are performed in the foreground and the initial maintenance process doesn't exit until all tasks complete. Only the \"gc\" task detaches into the background as expected. It turns out this was because git-gc(1), when run with --auto, was accidentally detaching itself, and other maintenance tasks had no means to do so. This had the potential to slow down certain Git commands as auto-maintenance had to run to completion before they could exit. This release addresses this issue by teaching git-maintenance(1) the --detach option, which allows the whole git-maintenance(1) process to run in the background instead of individual tasks. The auto-maintenance performed by Git was also updated to use this new option. For more information on this fix, check out the mailing-list thread. A little earlier it was mentioned that the auto-maintenance uses a set of heuristics to determine whether or not certain maintenance operations should be performed. Unfortunately for the \"files\" reference backend, when git-pack-refs(1) executes with the --auto option, there is no such heuristic and loose references are unconditionally packed into a \"packed-refs\" file. For repositories with many references, rewriting the \"pack-refs\" file can be quite time-consuming. This release also introduces a heuristic that decides whether it should pack loose references in the \"files\" backend. This heuristic takes into account the size of the existing \"packed-refs\" file and the number of loose references present in the repository. The larger the \"packed-refs\" file gets, the higher the threshold for the number of loose references before reference packing occurs. This effectively makes reference packing in the \"files\" backend less aggressive while still keeping the repository in a maintained state. Check out the mailing-list thread for more info. This project was led by Patrick Steinhardt. Code refactoring and maintainability improvements In addition to functional changes, there is also work being done to refactor and clean up the code. These improvements are also valuable because they help move the project closer toward the longstanding goal of libifying its internal components. To read more, here is a recent update thread regarding libification. One area of improvement has been around resolving memory leaks. The Git project has quite a few memory leaks. For the most part, these leaks don't cause much trouble because usually a Git process only runs for a short amount of time and the system cleans up after, but in the context of libification it becomes something that should be addressed. Tests in the project can be compiled with a leak sanitizer to detect leaks, but due to the presence of existing leaks, it is difficult to validate and enforce that new changes do not introduce new leaks. There has been an ongoing effort to fix all memory leaks surfaced by existing tests in the project. Leak-free tests are subsequently marked with TEST_PASSES_SANITIZE_LEAK=true to indicate that they are expected to be free of leaks going forward. Prior to this release, the project had 223 test files containing memory leaks. This has now been whittled down to just 60 in this release. Another ongoing effort has been to reduce the use of global variables throughout the project. One such notorious global variable is the_repository, which contains the state of the repository being operated on and is referenced all over the project. This release comes with a number of patches that remove uses of the_repository in favor of directly passing the value where needed. Subsystems in the Git project that still depend on the_repository have USE_THE_REPOSITORY_VARIABLE defined allowing the global to be used. Now the refs, config, and path subsystems no longer rely on its use. This project was led by Patrick Steinhardt with the help of John Cai and Jeff King. Read more This blog post highlighted just a few of the contributions made by GitLab and the wider Git community for this latest release. You can learn about these from the official release announcement of the Git project. Also, check out our previous Git release blog posts to see other past highlights of contributions from GitLab team members. What’s new in Git 2.46.0? What's new in Git 2.45.0? A beginner's guide to the Git reftable format Git pull vs. git fetch: What's the difference?",
  "image": "https://images.ctfassets.net/r9o86ar0p03f/269b7NrOV9GlWqgPJGOfn2/39a5cb378b8888ec53dcfdaed47bb957/AdobeStock_752438815.jpeg?fm=webp\u0026w=820\u0026h=500",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-b794d8fe=\"\" data-v-7488832a=\"\" data-v-74bd29c6=\"\"\u003e\u003cp\u003eThe Git project recently released \u003ca href=\"https://lore.kernel.org/git/xmqqa5fg9bsz.fsf@gitster.g/\"\u003eGit v2.47.0\u003c/a\u003e.\nLet\u0026#39;s look at a few notable highlights from this release, which includes\ncontributions from GitLab\u0026#39;s Git team and the wider Git community.\u003c/p\u003e\n\u003ch2 id=\"new-global-configuration-options\" tabindex=\"-1\"\u003eNew global configuration options \u003ca href=\"#new-global-configuration-options\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIf you have been following recent Git releases, you are probably familiar with the new \u0026#34;reftable\u0026#34; reference backend that became available with\n\u003ca href=\"https://about.gitlab.com/blog/2024/04/30/whats-new-in-git-2-45-0/\"\u003eGit version 2.45\u003c/a\u003e. Check out our \u003ca href=\"https://about.gitlab.com/blog/2024/05/30/a-beginners-guide-to-the-git-reftable-format/\"\u003eBeginner\u0026#39;s guide to the Git reftable format\u003c/a\u003e to learn more. Previously, in order to initialize a repository with the \u0026#34;reftable\u0026#34; format, the \u003ccode\u003e--ref-format\u003c/code\u003e option needed to be passed to to git-init(1):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git init --ref-format reftable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the 2.47 release, Git now has the \u003ccode\u003einit.defaultRefFormat\u003c/code\u003e configuration\noption, which tells Git which reference backend to use when initializing a\nrepository. This can be used to override the default \u0026#34;files\u0026#34; backend and begin using the \u0026#34;reftable\u0026#34; backend. To configure, execute the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git config set --global init.defaultRefFormat reftable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs some of you may know, the object hash format used by Git repositories is\nalso configurable. By default, repositories are initialized to use the SHA-1\nobject format. An alternative is the SHA-256 format, which is more secure and future-proof. You can read more about this in one of our\n\u003ca href=\"https://about.gitlab.com/blog/2023/08/28/sha256-support-in-gitaly/#what-is-sha-256%3F\"\u003eprevious blog posts on SHA-256 support in Gitaly\u003c/a\u003e. A SHA-256 repository can be created by passing the \u003ccode\u003e--object-format\u003c/code\u003e option to git-init(1):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git init --object-format sha256\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this Git release another configuration option, \u003ccode\u003einit.defaultObjectFormat\u003c/code\u003e, has been added. This option tells Git which object format to use by default when initializing a repository. To configure, execute the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git config set --global init.defaultObjectFormat sha256\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSomething to note, SHA-256 repositories are not interoperable with SHA-1\nrepositories and not all forges support hosting SHA-256 repositories. GitLab\nrecently announced \u003ca href=\"https://about.gitlab.com/blog/2024/08/19/gitlab-now-supports-sha256-repositories/\"\u003eexperimental support for SHA-256 repositories\u003c/a\u003e if you want to try it out.\u003c/p\u003e\n\u003cp\u003eThese options provide a useful mechanism to begin using these repository\nfeatures without having to consciously think about it every time you initialize a new repository.\u003c/p\u003e\n\u003cp\u003eThis project was led by \u003ca href=\"https://gitlab.com/pks-gitlab\"\u003ePatrick Steinhardt\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"new-subcommand-for-git-refs(1)\" tabindex=\"-1\"\u003eNew subcommand for git-refs(1) \u003ca href=\"#new-subcommand-for-git-refs(1)\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn the previous Git release, the \u003ca href=\"https://git-scm.com/docs/git-refs\"\u003egit-refs(1)\u003c/a\u003e command was introduced to provide low-level access to references in a\nrepository and provided the \u0026#34;migrate\u0026#34; subcommand to convert between reference backends. This release adds a new \u0026#34;verify\u0026#34; subcommand which allows the user to check the reference database for consistency. To verify the consistency of a repository, we often execute \u003ca href=\"https://git-scm.com/docs/git-fsck\"\u003egit-fsck(1)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNotably, this command does not explicitly verify the reference database of the repository though. With the introduction of the \u0026#34;reftable\u0026#34; reference format, which is a binary format and thus harder to inspect manually, it is now even more important that tooling be established to fill this gap. Let\u0026#39;s set up a repository with an invalid reference to demonstrate:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# The \u0026#34;files\u0026#34; backend is used so we can easily create an invalid reference.\n$ git init --ref-format files\n$ git commit --allow-empty -m \u0026#34;init\u0026#34;\n# A lone \u0026#39;@\u0026#39; is not a valid reference name.\n$ cp .git/refs/heads/main .git/refs/heads/@\n$ git refs verify\nerror: refs/heads/@: badRefName: invalid refname format\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see the invalid reference was detected and an error message printed to the user. While this tooling is not something the end-user will likely run, it is particularly useful on the server side to ensure repositories remain consistent. Eventually, the goal is to integrate this command as part of git-fsck(1) to provide a unified way to execute repository consistency checks.\u003c/p\u003e\n\u003cp\u003eThis project was led by Jialuo She as part of the Google Summer of Code. To\nlearn more, you can read Jialuo\u0026#39;s \u003ca href=\"https://luolibrary.com/2024/08/25/GSoC-Final-Report/\"\u003eGSoC report\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"ongoing-reftables-work\" tabindex=\"-1\"\u003eOngoing reftables work \u003ca href=\"#ongoing-reftables-work\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis release also includes fixes for some bugs found in the \u0026#34;reftable\u0026#34; backend. One of these bugs is particularly interesting and revolves around how table compaction was being performed.\u003c/p\u003e\n\u003cp\u003eAs you may recall, the reftable backend consists of a series of tables\ncontaining the state of all the references in the repository. Each atomic set of reference changes results in a new table being written and recorded in the \u0026#34;tables.list\u0026#34; file. To reduce the number of tables present, after each reference update, the tables are compacted to follow a geometric sequence by file size. After the tables are compacted, the \u0026#34;tables.list\u0026#34; file is updated to reflect the new on-disk state of the reftables.\u003c/p\u003e\n\u003cp\u003eBy design, concurrent table writes and compaction is allowed. Synchronization at certain points is controlled through the use of lock files. For example, when compaction is starting the \u0026#34;tables.list\u0026#34; file is initially locked so the file can be consistently read and the tables requiring compaction can also be locked. Since the actual table compaction can take a while the lock is released, allowing concurrent writes to proceed. This is safe because concurrent writers know that they must not modify the now-locked tables which are about to be compacted. When the newly compacted tables have finished being written, the \u0026#34;tables.list\u0026#34; file is locked again and this time it is updated to reflect the new table state.\u003c/p\u003e\n\u003cp\u003eThere is a problem though: What happens if a concurrent reference update writes a new table to the \u0026#34;tables.list\u0026#34; in the middle of table compaction after the initial lock was released, but before the new list file was written? If this race were to occur, the compacting process would not know about the new table and consequently rewrite the \u0026#34;tables.list\u0026#34; file without the new table. This effectively drops the concurrent update and could result in references not being added, updated, or removed as expected.\u003c/p\u003e\n\u003cp\u003eLuckily, the fix to remediate this problem is rather straightforward. When the compacting process acquires the lock to write to the \u0026#34;tables.list\u0026#34; it must first check if any updates to the file have occurred and reload the file. Doing so ensures any concurrent table updates are also reflected appropriately. For more information on this fix, check out the corresponding\n\u003ca href=\"https://lore.kernel.org/git/cover.1722435214.git.ps@pks.im/\"\u003emailing-list thread\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis project was led by \u003ca href=\"https://gitlab.com/pks-gitlab\"\u003ePatrick Steinhardt\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"fixes-for-git-maintenance(1)\" tabindex=\"-1\"\u003eFixes for git-maintenance(1) \u003ca href=\"#fixes-for-git-maintenance(1)\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAs a repository grows, it is important that it is properly maintained. By\ndefault, Git executes\n\u003ca href=\"https://git-scm.com/docs/git-maintenance\"\u003egit-maintenace(1)\u003c/a\u003e after certain\noperations to keep the repository healthy. To avoid performing unnecessary\nmaintenance, the \u003ccode\u003e--auto\u003c/code\u003e option is specified which uses defined heuristics to determine whether maintenance tasks should be run. The command can be\nconfigured to perform various different maintenance tasks, but by default, it simply executes \u003ca href=\"https://git-scm.com/docs/git-gc\"\u003egit-gc(1)\u003c/a\u003e in the background and allows the user to carry on with their business.\u003c/p\u003e\n\u003cp\u003eThis works as expected until maintenance is configured to perform non-default maintenance tasks. When this happens the configured maintenance tasks are performed in the foreground and the initial maintenance process doesn\u0026#39;t exit until all tasks complete. Only the \u0026#34;gc\u0026#34; task detaches into the background as expected. It turns out this was because git-gc(1), when run with \u003ccode\u003e--auto\u003c/code\u003e, was accidentally detaching itself, and other maintenance tasks had no means to do so. This had the potential to slow down certain Git commands as auto-maintenance had to run to completion before they could exit.\u003c/p\u003e\n\u003cp\u003eThis release addresses this issue by teaching git-maintenance(1) the \u003ccode\u003e--detach\u003c/code\u003e option, which allows the whole git-maintenance(1) process to run in the background instead of individual tasks. The auto-maintenance performed by Git was also updated to use this new option. For more information on this fix, check out the \u003ca href=\"https://lore.kernel.org/git/cover.1723533091.git.ps@pks.im/\"\u003emailing-list thread\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eA little earlier it was mentioned that the auto-maintenance uses a set of\nheuristics to determine whether or not certain maintenance operations should be performed. Unfortunately for the \u0026#34;files\u0026#34; reference backend, when\n\u003ca href=\"https://git-scm.com/docs/git-pack-refs\"\u003egit-pack-refs(1)\u003c/a\u003e executes with the\n\u003ccode\u003e--auto\u003c/code\u003e option, there is no such heuristic and loose references are\nunconditionally packed into a \u0026#34;packed-refs\u0026#34; file. For repositories with many\nreferences, rewriting the \u0026#34;pack-refs\u0026#34; file can be quite time-consuming.\u003c/p\u003e\n\u003cp\u003eThis release also introduces a heuristic that decides whether it should pack\nloose references in the \u0026#34;files\u0026#34; backend. This heuristic takes into account the size of the existing \u0026#34;packed-refs\u0026#34; file and the number of loose references present in the repository. The larger the \u0026#34;packed-refs\u0026#34; file gets, the higher the threshold for the number of loose references before reference packing occurs. This effectively makes reference packing in the \u0026#34;files\u0026#34; backend less aggressive while still keeping the repository in a maintained state. Check out the \u003ca href=\"https://lore.kernel.org/git/cover.1725280479.git.ps@pks.im/\"\u003emailing-list thread\u003c/a\u003e\nfor more info.\u003c/p\u003e\n\u003cp\u003eThis project was led by \u003ca href=\"https://gitlab.com/pks-gitlab\"\u003ePatrick Steinhardt\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"code-refactoring-and-maintainability-improvements\" tabindex=\"-1\"\u003eCode refactoring and maintainability improvements \u003ca href=\"#code-refactoring-and-maintainability-improvements\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn addition to functional changes, there is also work being done to refactor\nand clean up the code. These improvements are also valuable because they help move the project closer toward the longstanding goal of libifying its internal components. To read more, here is a recent\n\u003ca href=\"https://lore.kernel.org/git/eoy2sjhnul57g6crprxi3etgeuacjmgxpl4yllstih7woyuebm@bd62ib3fi2ju/\"\u003eupdate thread\u003c/a\u003e regarding libification.\u003c/p\u003e\n\u003cp\u003eOne area of improvement has been around resolving memory leaks. The Git project has quite a few memory leaks. For the most part, these leaks don\u0026#39;t cause much trouble because usually a Git process only runs for a short amount of time and the system cleans up after, but in the context of libification it becomes something that should be addressed. Tests in the project can be compiled with a leak sanitizer to detect leaks, but due to the presence of existing leaks, it is difficult to validate and enforce that new changes do not introduce new leaks. There has been an ongoing effort to fix all memory leaks surfaced by existing tests in the project. Leak-free tests are subsequently marked with \u003ccode\u003eTEST_PASSES_SANITIZE_LEAK=true\u003c/code\u003e to indicate that they are expected to be free of leaks going forward. Prior to this release, the project had 223 test files containing memory leaks. This has now been whittled down to just 60 in this release.\u003c/p\u003e\n\u003cp\u003eAnother ongoing effort has been to reduce the use of global variables\nthroughout the project. One such notorious global variable is \u003ccode\u003ethe_repository\u003c/code\u003e, which contains the state of the repository being operated on and is referenced all over the project. This release comes with a number of patches that remove uses of \u003ccode\u003ethe_repository\u003c/code\u003e in favor of directly passing the value where needed. Subsystems in the Git project that still depend on \u003ccode\u003ethe_repository\u003c/code\u003e have \u003ccode\u003eUSE_THE_REPOSITORY_VARIABLE\u003c/code\u003e defined allowing the global to be used. Now the refs, config, and path subsystems no longer rely on its use.\u003c/p\u003e\n\u003cp\u003eThis project was led by \u003ca href=\"https://gitlab.com/pks-gitlab\"\u003ePatrick Steinhardt\u003c/a\u003e\nwith the help of \u003ca href=\"https://gitlab.com/jcaigitlab\"\u003eJohn Cai\u003c/a\u003e and\n\u003ca href=\"https://github.com/peff\"\u003eJeff King\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"read-more\" tabindex=\"-1\"\u003eRead more \u003ca href=\"#read-more\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis blog post highlighted just a few of the contributions made by GitLab and the wider Git community for this latest release. You can learn about these from the \u003ca href=\"https://lore.kernel.org/git/xmqqa5fg9bsz.fsf@gitster.g/\"\u003eofficial release announcement\u003c/a\u003e\nof the Git project. Also, check out our \u003ca href=\"https://about.gitlab.com/blog/tags/git/\"\u003eprevious Git release blog posts\u003c/a\u003e\nto see other past highlights of contributions from GitLab team members.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/07/29/whats-new-in-git-2-46-0/\"\u003eWhat’s new in Git 2.46.0?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/04/30/whats-new-in-git-2-45-0/\"\u003eWhat\u0026#39;s new in Git 2.45.0?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/05/30/a-beginners-guide-to-the-git-reftable-format/\"\u003eA beginner\u0026#39;s guide to the Git reftable format\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://about.gitlab.com/blog/2024/09/24/git-pull-vs-git-fetch-whats-the-difference/\"\u003eGit pull vs. git fetch: What\u0026#39;s the difference?\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2024-10-07T00:00:00Z",
  "modifiedTime": null
}
