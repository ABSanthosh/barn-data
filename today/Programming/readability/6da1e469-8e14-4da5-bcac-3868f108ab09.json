{
  "id": "6da1e469-8e14-4da5-bcac-3868f108ab09",
  "title": "Linear Search in Python",
  "link": "https://stackabuse.com/linear-search-in-python/",
  "description": "Linear Search, also known as Sequential Search, operates by traversing through the dataset, element by element until the desired item is found or the algorithm reaches the end of the collection. Its simplicity and ease of implementation make it a go-to choice for small datasets and lists where items are",
  "author": "Dimitrije Stamenic",
  "published": "Thu, 26 Oct 2023 15:47:00 GMT",
  "source": "https://stackabuse.com/rss/",
  "categories": [
    "python",
    "algorithms",
    "search"
  ],
  "byline": "Dimitrije Stamenic",
  "length": 8674,
  "excerpt": "Linear Search, also known as Sequential Search, operates by traversing through the dataset, element by element until the desired item is found or the algorithm...",
  "siteName": "Stack Abuse",
  "favicon": "",
  "text": "Linear Search, also known as Sequential Search, operates by traversing through the dataset, element by element until the desired item is found or the algorithm reaches the end of the collection. Its simplicity and ease of implementation make it a go-to choice for small datasets and lists where items are added or removed frequently. While it may not boast the efficiency of its more complex counterparts like Binary Search, Linear Search can be pretty useful in various practical use cases, especially when dealing with unsorted data. In this article, we'll delve deeper into the inner workings of Linear Search, illustrating its mechanism with practical Python examples, and dissecting its performance through complexity analysis. How Does Linear Search Work? Linear Search, as the name suggests, operates in a straightforward, linear manner, systematically examining each element in the dataset until the desired item is located or the end of the dataset is reached. It doesn’t require the data to be in any particular order and works equally well with both sorted and unsorted datasets. Let’s break down its operation into a step-by-step process: Start at the Beginning Linear Search starts at the first element of the dataset. It compares the target value (the value we are searching for) with the first element. Compare and Move If the target value matches the current element, congratulations! The search is successful, and the index (or position) of the current element is returned. If a match is not found, the algorithm moves to the next element in the sequence. Repeat This process of moving from one element to the next and comparing each with the target value continues sequentially through the dataset. Conclusion of Search Item Found: If the algorithm finds an element that matches the target value, it returns the index of that element. Item Not Found: If the algorithm reaches the end of the dataset without finding the target value, it concludes that the item is not present in the dataset and typically returns a value indicating an unsuccessful search (such as -1 or None in Python). Linear Search is particularly useful due to its simplicity and the fact that it can be used on both sorted and unsorted datasets. Note: Its simplicity can be a double-edged sword, especially with large datasets, as it may have to traverse through most of the elements, making it less efficient compared to other search algorithms in certain scenarios. Linear Search - Example Now that we understand how Linear Search works in theory, let’s delve into a tangible example to visualize its operation. Say we are searching the following list of numbers: numbers = [21, 39, 46, 52, 63, 75] And let’s say we want to find the number 52: Step 1: Start with the first number - 21 Compare it with 52 - they are not equal Step 2: Move to the next number -39 Compare it with 52 - still not equal Step 3: Move to the next number - 46 Compare it with 52 - not equal Step 4: Move to the next number - 52 Finally, they are equal! Return the index 3 as the successful search result. The following illustration visually represents the process we've just described: In the upcoming sections, we will dive into the Pythonic world to implement Linear Search and explore its complexity in terms of time and space to understand its efficiency and limitations. How to Implement Linear Search in Python After exploring the conceptual framework and walking through an example of Linear Search, let’s dive into Python to implement this algorithm. First of all, we'll define a function that will wrap the logic of the linear search - let's call it linear_search(). It should take two parameters - arr (the list to search through) and target (the item to search for): def linear_search(arr, target): Now, this function will perform a linear search on a list arr for a target value. It should return the index of target in arr if found, and -1 otherwise. We can finally get to the core of the linear search algorithm - looping through the list and comparing the current element with the target. We'll do so by iterating through each element item and its corresponding index in the list arr using the enumerate function: def linear_search(arr, target): for index, item in enumerate(arr): if item == target: return index # Target found, return the index return -1 # Target not found, return -1 Note: Utilizing for loops without leveraging built-in functions like enumerate can lead to less readable and potentially less efficient code. Let’s utilize our linear_search() function to find an item in a list: books = [\"The Great Gatsby\", \"Moby Dick\", \"1984\", \"To Kill a Mockingbird\", \"The Hobbit\"] target_book = \"1984\" # Using the linear_search function index = linear_search(books, target_book) # Output the result if index != -1: print(f\"'{target_book}' found at index {index}.\") else: print(f\"'{target_book}' not found in the list.\") Check out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually learn it!This will result in: '1984' found at index 2. Note: This Python implementation of Linear Search is straightforward and beginner-friendly, providing a practical tool to search for items in a list. In the upcoming sections, we will delve into the complexity analysis of Linear Search, exploring its efficiency and discussing scenarios where it shines and where other algorithms might be more suitable. Complexity Analysis Understanding the complexity of an algorithm is crucial as it provides insights into its efficiency in terms of time and space, thereby allowing developers to make informed decisions when choosing algorithms for specific contexts. Let’s dissect the complexity of Linear Search: Time Complexity The best-case scenario occurs when the target element is found at the first position of the array. In this case, only one comparison is made, resulting in a time complexity of O(1). The worst-case scenario happens when the target element is at the last position of the array or is not present at all. Here, the algorithm makes n comparisons, where n is the size of the array, resulting in a time complexity of O(n). On average, the algorithm may have to search through half of the elements, resulting in a time complexity of O(n/2). However, in Big O notation, we drop the constant factor, leaving us with O(n). Space Complexity Linear Search is an in-place algorithm, meaning it doesn’t require additional space that grows with the input size. It uses a constant amount of extra space (for variables like index and item), and thus, the space complexity is O(1). In the context of practical applications, Linear Search can be quite useful in scenarios where the simplicity of implementation is a priority, and the datasets involved are not prohibitively large. However, for applications where search operations are frequent or the datasets are large, considering algorithms with lower time complexities might be beneficial. Linear Search vs. Binary Search Linear Search, with its simplicity and ease of implementation, holds a unique position in the world of search algorithms. However, depending on the context, other search algorithms might be more efficient or suitable. Let’s delve into a comparative analysis between Linear Search and its main competitor in the space of search algorithms - Binary Search. Linear Search Binary Search Prerequisites No prerequisites regarding the order of the dataset. Requires the dataset to be sorted. Time Complexity O(n) in the worst and average cases. O(logn) in the worst and average cases. Use-Cases Suitable for smaller and/or unordered datasets. Ideal for larger, sorted datasets, especially where search operations are frequent. Implementation Simpler to implement. Slightly more complex due to the need to manage the high and low pointers during the search.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cem\u003eLinear Search\u003c/em\u003e, also known as \u003cem\u003eSequential Search\u003c/em\u003e, operates by traversing through the dataset, element by element until the desired item is found or the algorithm reaches the end of the collection. Its simplicity and ease of implementation make it a go-to choice for small datasets and lists where items are added or removed frequently.\u003c/p\u003e\n\u003cp\u003eWhile it may not boast the efficiency of its more complex counterparts like Binary Search, Linear Search can be pretty useful in various practical use cases, especially when dealing with unsorted data.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn this article, we\u0026#39;ll delve deeper into the inner workings of Linear Search, illustrating its mechanism with practical Python examples, and dissecting its performance through complexity analysis.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"howdoeslinearsearchwork\"\u003eHow Does Linear Search Work?\u003c/h3\u003e\n\u003cp\u003eLinear Search, as the name suggests, operates in a straightforward, linear manner, systematically examining each element in the dataset until the desired item is located or the end of the dataset is reached. It doesn’t require the data to be in any particular order and works equally well with both sorted and unsorted datasets.\u003c/p\u003e\n\u003cp\u003eLet’s break down its operation into a \u003cstrong\u003estep-by-step process\u003c/strong\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eStart at the Beginning\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinear Search starts at the first element of the dataset. It compares the target value (the value we are searching for) with the first element.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCompare and Move\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf the target value matches the current element, congratulations! The search is successful, and the index (or position) of the current element is returned. If a match is not found, the algorithm moves to the next element in the sequence.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRepeat\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThis process of moving from one element to the next and comparing each with the target value continues sequentially through the dataset.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eConclusion of Search\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eItem Found:\u003c/strong\u003e If the algorithm finds an element that matches the target value, it returns the index of that element.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eItem Not Found:\u003c/strong\u003e If the algorithm reaches the end of the dataset without finding the target value, it concludes that the item is not present in the dataset and typically returns a value indicating an unsuccessful search (such as \u003ccode\u003e-1\u003c/code\u003e or \u003ccode\u003eNone\u003c/code\u003e in Python).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLinear Search is particularly useful due to its simplicity and the fact that it can be used on both sorted and unsorted datasets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Its simplicity can be a \u003cem\u003edouble-edged sword\u003c/em\u003e, especially with large datasets, as it may have to traverse through most of the elements, making it less efficient compared to other search algorithms in certain scenarios.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"linearsearchexample\"\u003eLinear Search - Example\u003c/h3\u003e\n\u003cp\u003eNow that we understand how Linear Search works in theory, let’s delve into a tangible example to visualize its operation. Say we are searching the following list of numbers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enumbers = [\u003cspan\u003e21\u003c/span\u003e, \u003cspan\u003e39\u003c/span\u003e, \u003cspan\u003e46\u003c/span\u003e, \u003cspan\u003e52\u003c/span\u003e, \u003cspan\u003e63\u003c/span\u003e, \u003cspan\u003e75\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd let’s say we want to find the number \u003ccode\u003e52\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStep 1:\u003c/strong\u003e Start with the first number - \u003ccode\u003e21\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eCompare it with \u003ccode\u003e52\u003c/code\u003e - they are \u003cem\u003enot equal\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStep 2:\u003c/strong\u003e  Move to the next number -\u003ccode\u003e39\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eCompare it with \u003ccode\u003e52\u003c/code\u003e - still \u003cem\u003enot equal\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStep 3:\u003c/strong\u003e Move to the next number - \u003ccode\u003e46\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eCompare it with \u003ccode\u003e52\u003c/code\u003e - \u003cem\u003enot equal\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStep 4:\u003c/strong\u003e Move to the next number - \u003ccode\u003e52\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003eFinally, \u003cstrong\u003ethey are equal\u003c/strong\u003e!\u003c/li\u003e\n\u003cli\u003eReturn the index \u003ccode\u003e3\u003c/code\u003e as the successful search result.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe following illustration visually represents the process we\u0026#39;ve just described:\u003c/p\u003e\n\n\u003cp\u003eIn the upcoming sections, we will dive into the Pythonic world to implement Linear Search and explore its complexity in terms of time and space to understand its efficiency and limitations.\u003c/p\u003e\n\u003ch3 id=\"howtoimplementlinearsearchinpython\"\u003eHow to Implement Linear Search in Python\u003c/h3\u003e\n\u003cp\u003eAfter exploring the conceptual framework and walking through an example of Linear Search, let’s dive into Python to implement this algorithm.\u003c/p\u003e\n\u003cp\u003eFirst of all, we\u0026#39;ll define a function that will wrap the logic of the linear search - let\u0026#39;s call it \u003ccode\u003elinear_search()\u003c/code\u003e. It should take two parameters - \u003ccode\u003earr\u003c/code\u003e (the list to search through) and \u003ccode\u003etarget\u003c/code\u003e (the item to search for):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003elinear_search\u003c/span\u003e(\u003cspan\u003earr, target\u003c/span\u003e):\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, this function will perform a linear search on a list \u003ccode\u003earr\u003c/code\u003e for a \u003ccode\u003etarget\u003c/code\u003e value. It should return the index of \u003ccode\u003etarget\u003c/code\u003e in \u003ccode\u003earr\u003c/code\u003e if found, and \u003ccode\u003e-1\u003c/code\u003e otherwise.\u003c/p\u003e\n\u003cp\u003eWe can finally get to the core of the linear search algorithm - looping through the list and comparing the current element with the \u003ccode\u003etarget\u003c/code\u003e. We\u0026#39;ll do so by iterating through each element \u003ccode\u003eitem\u003c/code\u003e and its corresponding \u003ccode\u003eindex\u003c/code\u003e in the list \u003ccode\u003earr\u003c/code\u003e using the \u003ccode\u003eenumerate\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003elinear_search\u003c/span\u003e(\u003cspan\u003earr, target\u003c/span\u003e):\u003c/span\u003e\n    \u003cspan\u003efor\u003c/span\u003e index, item \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eenumerate\u003c/span\u003e(arr):\n        \u003cspan\u003eif\u003c/span\u003e item == target:\n            \u003cspan\u003ereturn\u003c/span\u003e index  \u003cspan\u003e# Target found, return the index\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e -\u003cspan\u003e1\u003c/span\u003e  \u003cspan\u003e# Target not found, return -1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Utilizing \u003ccode\u003efor\u003c/code\u003e loops without leveraging built-in functions like \u003ccode\u003eenumerate\u003c/code\u003e can lead to less readable and potentially less efficient code.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eLet’s utilize our \u003ccode\u003elinear_search()\u003c/code\u003e function to find an item in a list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebooks = [\u003cspan\u003e\u0026#34;The Great Gatsby\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;Moby Dick\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;1984\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;To Kill a Mockingbird\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;The Hobbit\u0026#34;\u003c/span\u003e]\ntarget_book = \u003cspan\u003e\u0026#34;1984\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003e# Using the linear_search function\u003c/span\u003e\nindex = linear_search(books, target_book)\n\n\u003cspan\u003e# Output the result\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e index != -\u003cspan\u003e1\u003c/span\u003e:\n    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003ef\u0026#34;\u0026#39;\u003cspan\u003e{target_book}\u003c/span\u003e\u0026#39; found at index \u003cspan\u003e{index}\u003c/span\u003e.\u0026#34;\u003c/span\u003e)\n\u003cspan\u003eelse\u003c/span\u003e:\n    \u003cspan\u003eprint\u003c/span\u003e(\u003cspan\u003ef\u0026#34;\u0026#39;\u003cspan\u003e{target_book}\u003c/span\u003e\u0026#39; not found in the list.\u0026#34;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv data-nosnippet=\"\" id=\"ad-lead-magnet\"\u003e\u003cp\u003eCheck out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually \u003cem\u003elearn\u003c/em\u003e it!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis will result in:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#39;1984\u0026#39; found at index 2.\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e This Python implementation of Linear Search is straightforward and beginner-friendly, providing a practical tool to search for items in a list.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eIn the upcoming sections, we will delve into the complexity analysis of Linear Search, exploring its efficiency and discussing scenarios where it shines and where other algorithms might be more suitable.\u003c/p\u003e\n\u003ch3 id=\"complexityanalysis\"\u003eComplexity Analysis\u003c/h3\u003e\n\u003cp\u003eUnderstanding the complexity of an algorithm is crucial as it provides insights into its efficiency in terms of time and space, thereby allowing developers to make informed decisions when choosing algorithms for specific contexts. Let’s dissect the complexity of Linear Search:\u003c/p\u003e\n\u003ch4 id=\"timecomplexity\"\u003eTime Complexity\u003c/h4\u003e\n\u003cp\u003eThe \u003cstrong\u003ebest-case scenario\u003c/strong\u003e occurs when the target element is found at the first position of the array. In this case, only one comparison is made, resulting in a time complexity of \u003cem\u003e\u003cstrong\u003eO(1)\u003c/strong\u003e\u003c/em\u003e. The \u003cstrong\u003eworst-case\u003c/strong\u003e scenario happens when the target element is at the last position of the array or is not present at all. Here, the algorithm makes \u003cem\u003en\u003c/em\u003e comparisons, where \u003cem\u003en\u003c/em\u003e is the size of the array, resulting in a time complexity of \u003cem\u003e\u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/em\u003e. \u003cstrong\u003eOn average\u003c/strong\u003e, the algorithm may have to search through half of the elements, resulting in a time complexity of \u003cem\u003e\u003cstrong\u003eO(n/2)\u003c/strong\u003e\u003c/em\u003e. However, in \u003cem\u003eBig O notation\u003c/em\u003e, we drop the constant factor, leaving us with \u003cem\u003eO(n)\u003c/em\u003e.\u003c/p\u003e\n\u003ch4 id=\"spacecomplexity\"\u003eSpace Complexity\u003c/h4\u003e\n\u003cp\u003eLinear Search is an \u003cem\u003e\u003cstrong\u003ein-place algorithm\u003c/strong\u003e\u003c/em\u003e, meaning it doesn’t require additional space that grows with the input size. It uses a constant amount of extra space (for variables like \u003ccode\u003eindex\u003c/code\u003e and \u003ccode\u003eitem\u003c/code\u003e), and thus, the space complexity is \u003cem\u003e\u003cstrong\u003eO(1)\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn the context of \u003cem\u003epractical applications\u003c/em\u003e, Linear Search can be quite useful in scenarios where the \u003cem\u003esimplicity of implementation is a priority\u003c/em\u003e, and the datasets involved are \u003cem\u003enot prohibitively large\u003c/em\u003e. However, for applications where search operations are frequent or the datasets are large, considering algorithms with lower time complexities might be beneficial.\u003c/p\u003e\n\u003ch3 id=\"linearsearchvsbinarysearch\"\u003eLinear Search vs. Binary Search\u003c/h3\u003e\n\u003cp\u003eLinear Search, with its simplicity and ease of implementation, holds a unique position in the world of search algorithms. However, depending on the context, other search algorithms might be more efficient or suitable. Let’s delve into a comparative analysis between Linear Search and its main competitor in the space of search algorithms - Binary Search.\u003c/p\u003e\n\u003ctable\u003e\n    \u003cthead\u003e\n        \u003ctr\u003e\n            \u003cth\u003e\u003c/th\u003e\n            \u003cth\u003eLinear Search\u003c/th\u003e\n            \u003cth\u003eBinary Search\u003c/th\u003e\n        \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n        \u003ctr\u003e\n            \u003ctd\u003ePrerequisites\u003c/td\u003e\n            \u003ctd\u003eNo prerequisites regarding the order of the dataset.\u003c/td\u003e\n            \u003ctd\u003eRequires the dataset to be sorted.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003eTime Complexity\u003c/td\u003e\n            \u003ctd\u003eO(n) in the worst and average cases.\u003c/td\u003e\n            \u003ctd\u003eO(logn) in the worst and average cases.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003eUse-Cases\u003c/td\u003e\n            \u003ctd\u003eSuitable for smaller and/or unordered datasets.\u003c/td\u003e\n            \u003ctd\u003eIdeal for larger, sorted datasets, especially where search operations are frequent.\u003c/td\u003e\n        \u003c/tr\u003e\n        \u003ctr\u003e\n            \u003ctd\u003eImplementation\u003c/td\u003e\n            \u003ctd\u003eSimpler to implement.\u003c/td\u003e\n            \u003ctd\u003eSlightly more complex due to the need to manage the high and low pointers during the search.\u003c/td\u003e\n        \u003c/tr\u003e\n    \u003c/tbody\u003e\n\u003c/table\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2023-10-26T15:47:00Z",
  "modifiedTime": "2024-04-18T14:59:38Z"
}
