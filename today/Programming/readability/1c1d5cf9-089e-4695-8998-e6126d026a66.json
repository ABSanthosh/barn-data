{
  "id": "1c1d5cf9-089e-4695-8998-e6126d026a66",
  "title": "An Efficient Way to Check for Existence of Multiple Values in SQL",
  "link": "https://blog.jooq.org/an-efficient-way-to-check-for-existence-of-multiple-values-in-sql/",
  "description": "In a previous blog post, we’ve advertised the use of SQL EXISTS rather than COUNT(*) to check for existence of a value in SQL. I.e. to check if in the Sakila database, actors called WAHLBERG have played in any films, instead of: Do this: (Depending on your dialect you may require a FROM DUAL clause, … Continue reading An Efficient Way to Check for Existence of Multiple Values in SQL →",
  "author": "lukaseder",
  "published": "Fri, 16 Feb 2024 14:16:45 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "COUNT(*)",
    "exists",
    "LIMIT",
    "mysql",
    "Oracle",
    "performance",
    "PostgreSQL",
    "SQL Performance",
    "SQL Server",
    "TOP"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 18619,
  "excerpt": "We check execution plans and benchmark results to see if using a LIMIT clause is useful when checking for existence of N values in SQL",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "In a previous blog post, we’ve advertised the use of SQL EXISTS rather than COUNT(*) to check for existence of a value in SQL. I.e. to check if in the Sakila database, actors called WAHLBERG have played in any films, instead of: SELECT count(*) FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' Do this: SELECT EXISTS ( SELECT 1 FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' ) (Depending on your dialect you may require a FROM DUAL clause, or a CASE expression if BOOLEAN types aren’t supported). Check for multiple rows But what if you want to check if there are at least 2 (or N) rows? In that case, you cannot use EXISTS, but have to revert to using COUNT(*). However, instead of just counting all matches, why not add a LIMIT clause as well? So, if you want to check if actors called WAHLBERG have played in at least 2 films, instead of this: SELECT ( SELECT count(*) FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' ) \u003e= 2 Write this: SELECT ( SELECT count(*) FROM ( SELECT * FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' LIMIT 2 ) t ) \u003e= 2 In other words: Run the join query with a LIMIT 2 in a derived table Then COUNT(*) the rows (at most 2) from that derived table Finally, check if the count is high enough Does it matter? In principle, the optimiser could have figured this out itself, especially because we used a constant to compare the COUNT(*) value with. But did it really apply the transformation? Let’s check execution plans and benchmark the query on various RDBMS. PostgreSQL 15 No LIMIT Result (cost=14.70..14.71 rows=1 width=1) (actual time=0.039..0.039 rows=1 loops=1) InitPlan 1 (returns $1) -\u003e Aggregate (cost=14.69..14.70 rows=1 width=8) (actual time=0.037..0.037 rows=1 loops=1) -\u003e Nested Loop (cost=0.28..14.55 rows=55 width=0) (actual time=0.009..0.032 rows=56 loops=1) -\u003e Seq Scan on actor a (cost=0.00..4.50 rows=2 width=4) (actual time=0.006..0.018 rows=2 loops=1) Filter: ((last_name)::text = 'WAHLBERG'::text) Rows Removed by Filter: 198 -\u003e Index Only Scan using film_actor_pkey on film_actor fa (cost=0.28..4.75 rows=27 width=4) (actual time=0.003..0.005 rows=28 loops=2) Index Cond: (actor_id = a.actor_id) Heap Fetches: 0 With LIMIT Result (cost=0.84..0.85 rows=1 width=1) (actual time=0.023..0.024 rows=1 loops=1) InitPlan 1 (returns $1) -\u003e Aggregate (cost=0.83..0.84 rows=1 width=8) (actual time=0.021..0.022 rows=1 loops=1) -\u003e Limit (cost=0.28..0.80 rows=2 width=240) (actual time=0.016..0.018 rows=2 loops=1) -\u003e Nested Loop (cost=0.28..14.55 rows=55 width=240) (actual time=0.015..0.016 rows=2 loops=1) -\u003e Seq Scan on actor a (cost=0.00..4.50 rows=2 width=4) (actual time=0.008..0.008 rows=1 loops=1) Filter: ((last_name)::text = 'WAHLBERG'::text) Rows Removed by Filter: 1 -\u003e Index Only Scan using film_actor_pkey on film_actor fa (cost=0.28..4.75 rows=27 width=4) (actual time=0.005..0.005 rows=2 loops=1) Index Cond: (actor_id = a.actor_id) Heap Fetches: 0 To understand the difference, focus on these rows: Before: Nested Loop (cost=0.28..14.55 rows=55 width=0) (actual time=0.009..0.032 rows=56 loops=1) After: Nested Loop (cost=0.28..14.55 rows=55 width=240) (actual time=0.015..0.016 rows=2 loops=1) In both cases, the estimated number of rows produced by the join is 55 (i.e. all WAHLBERGs are expected to have played in a total of 55 films according to statistics). But int he second execution the actual rows value is much lower, because we only needed 2 rows before we could stop execution of the operation, because of the LIMIT above. Benchmark results: Using our recommended SQL benchmarking technique that compares running two queries many times (5 runs x 2000 executions in this case) on the same instance directly from within the RDBMS using procedural languages (to avoid network latency, etc.), we get these results: RUN 1, Statement 1: 2.61927RUN 1, Statement 2: 1.01506RUN 2, Statement 1: 2.47193RUN 2, Statement 2: 1.00614RUN 3, Statement 1: 2.63533RUN 3, Statement 2: 1.14282RUN 4, Statement 1: 2.55228RUN 4, Statement 2: 1.00000 -- Fastest run is 1RUN 5, Statement 1: 2.53801RUN 5, Statement 2: 1.02363 The fastest run is 1 units of time, slower runs run in multiples of that time. The complete COUNT(*) query is consistently and significantly slower than the LIMIT query. Both the plans and benchmark results speak for themselves. Oracle 23c With Oracle 23c, we can finally use BOOLEAN types and omit DUAL, yay! No FETCH FIRST: SQL_ID 40yy0tskvs1zw, child number 0-------------------------------------SELECT /*+GATHER_PLAN_STATISTICS*/ ( SELECT count(*) FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' ) \u003e= 2 Plan hash value: 2539243977 ---------------------------------------------------------------------------------------------------------------------------| Id | Operation | Name | Starts | E-Rows | A-Rows | A-Time | Buffers |---------------------------------------------------------------------------------------------------------------------------| 0 | SELECT STATEMENT | | 1 | | 1 |00:00:00.01 | 0 || 1 | SORT AGGREGATE | | 1 | 1 | 1 |00:00:00.01 | 6 || 2 | NESTED LOOPS | | 1 | 55 | 56 |00:00:00.01 | 6 || 3 | TABLE ACCESS BY INDEX ROWID BATCHED| ACTOR | 1 | 2 | 2 |00:00:00.01 | 2 ||* 4 | INDEX RANGE SCAN | IDX_ACTOR_LAST_NAME | 1 | 2 | 2 |00:00:00.01 | 1 ||* 5 | INDEX RANGE SCAN | IDX_FK_FILM_ACTOR_ACTOR | 2 | 27 | 56 |00:00:00.01 | 4 || 6 | FAST DUAL | | 1 | 1 | 1 |00:00:00.01 | 0 |--------------------------------------------------------------------------------------------------------------------------- Predicate Information (identified by operation id):--------------------------------------------------- 4 - access(\"A\".\"LAST_NAME\"='WAHLBERG') 5 - access(\"A\".\"ACTOR_ID\"=\"FA\".\"ACTOR_ID\") With FETCH FIRST: SQL_ID f88t1r0avnr7b, child number 0-------------------------------------SELECT /*+GATHER_PLAN_STATISTICS*/( SELECT count(*) from ( select * FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' FETCH FIRST 2 ROWS ONLY ) t ) \u003e= 2 Plan hash value: 4019277616 ------------------------------------------------------------------------------------------------------------------------------------------------| Id | Operation | Name | Starts | E-Rows | A-Rows | A-Time | Buffers | OMem | 1Mem | Used-Mem |------------------------------------------------------------------------------------------------------------------------------------------------| 0 | SELECT STATEMENT | | 1 | | 1 |00:00:00.01 | 0 | | | || 1 | SORT AGGREGATE | | 1 | 1 | 1 |00:00:00.01 | 6 | | | ||* 2 | VIEW | | 1 | 2 | 2 |00:00:00.01 | 6 | | | ||* 3 | WINDOW BUFFER PUSHED RANK | | 1 | 55 | 2 |00:00:00.01 | 6 | 2048 | 2048 | 2048 (0)|| 4 | NESTED LOOPS | | 1 | 55 | 56 |00:00:00.01 | 6 | | | || 5 | TABLE ACCESS BY INDEX ROWID| ACTOR | 1 | 2 | 2 |00:00:00.01 | 2 | | | ||* 6 | INDEX RANGE SCAN | IDX_ACTOR_LAST_NAME | 1 | 2 | 2 |00:00:00.01 | 1 | | | ||* 7 | INDEX RANGE SCAN | IDX_FK_FILM_ACTOR_ACTOR | 2 | 27 | 56 |00:00:00.01 | 4 | | | || 8 | FAST DUAL | | 1 | 1 | 1 |00:00:00.01 | 0 | | | |------------------------------------------------------------------------------------------------------------------------------------------------ Predicate Information (identified by operation id):--------------------------------------------------- 2 - filter(\"from$_subquery$_005\".\"rowlimit_$$_rownumber\"\u003c=2) 3 - filter(ROW_NUMBER() OVER ( ORDER BY NULL )\u003c=2) 6 - access(\"A\".\"LAST_NAME\"='WAHLBERG') 7 - access(\"A\".\"ACTOR_ID\"=\"FA\".\"ACTOR_ID\") Uh oh, this doesn’t look better. The NESTED LOOPS operation doesn’t seem to have gotten the memo from the WINDOW BUFFER PUSHED RANK operation about the query being aborted. The E-Rows (estimated) and A-Rows (actual) values still match, so the JOIN seems to be executed completely. For good measure, let’s also try: With ROWNUM: I had hoped that this undead syntax belongs only to distant memories after Oracle 12c introduced the standard SQL FETCH syntax, but let’s try what happens with this alternative: SELECT ( SELECT count(*) FROM ( SELECT * FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' AND ROWNUM \u003c= 2 -- Yuck, but it works ) t ) \u003e= 2 The plan is now: SQL_ID 6r7w9d0425j6c, child number 0-------------------------------------SELECT /*+GATHER_PLAN_STATISTICS*/( SELECT count(*) from ( select * FROM actor a JOIN film_actor fa USING (actor_id) WHERE a.last_name = 'WAHLBERG' AND ROWNUM \u003c= 2 ) t ) \u003e= 2 Plan hash value: 1271700124 -----------------------------------------------------------------------------------------------------------------------------| Id | Operation | Name | Starts | E-Rows | A-Rows | A-Time | Buffers |-----------------------------------------------------------------------------------------------------------------------------| 0 | SELECT STATEMENT | | 1 | | 1 |00:00:00.01 | 0 || 1 | SORT AGGREGATE | | 1 | 1 | 1 |00:00:00.01 | 4 || 2 | VIEW | | 1 | 2 | 2 |00:00:00.01 | 4 ||* 3 | COUNT STOPKEY | | 1 | | 2 |00:00:00.01 | 4 || 4 | NESTED LOOPS | | 1 | 55 | 2 |00:00:00.01 | 4 || 5 | TABLE ACCESS BY INDEX ROWID BATCHED| ACTOR | 1 | 2 | 1 |00:00:00.01 | 2 ||* 6 | INDEX RANGE SCAN | IDX_ACTOR_LAST_NAME | 1 | 2 | 1 |00:00:00.01 | 1 ||* 7 | INDEX RANGE SCAN | IDX_FK_FILM_ACTOR_ACTOR | 1 | 27 | 2 |00:00:00.01 | 2 || 8 | FAST DUAL | | 1 | 1 | 1 |00:00:00.01 | 0 |----------------------------------------------------------------------------------------------------------------------------- Predicate Information (identified by operation id):--------------------------------------------------- 3 - filter(ROWNUM\u003c=2) 6 - access(\"A\".\"LAST_NAME\"='WAHLBERG') 7 - access(\"A\".\"ACTOR_ID\"=\"FA\".\"ACTOR_ID\") Now, that’s what I’m talking about. The NESTED LOOPS operation has a A-Rows value of 2, as it should have. The COUNT STOPKEY operation knows how to tell its successors to behave. Benchmark results: Run 1, Statement 1 : 1.9564Run 1, Statement 2 : 2.98499Run 1, Statement 3 : 1.07291Run 2, Statement 1 : 1.69192Run 2, Statement 2 : 2.66905Run 2, Statement 3 : 1.01144Run 3, Statement 1 : 1.71051Run 3, Statement 2 : 2.63831Run 3, Statement 3 : 1 -- Fastest run is 1Run 4, Statement 1 : 1.61544Run 4, Statement 2 : 2.67334Run 4, Statement 3 : 1.00786Run 5, Statement 1 : 1.72981Run 5, Statement 2 : 2.77913Run 5, Statement 3 : 1.02716 Whoopsies. Indeed, it appears that the FETCH FIRST 2 ROWS ONLY clause is bad in this case. It even made performance worse than if we omit it and count the complete result. However, the ROWNUM filter helped greatly, just like before with PostgreSQL’s LIMIT. I would consider this an optimiser bug in Oracle. FETCH FIRST should be an operation that can be pushed down to various other operations MySQL No LIMIT: -\u003e Rows fetched before execution (cost=0.00..0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=1)-\u003e Select #2 (subquery in projection; run only once) -\u003e Aggregate: count(0) (cost=1.35 rows=1) (actual time=0.479..0.479 rows=1 loops=1) -\u003e Nested loop inner join (cost=1.15 rows=2) (actual time=0.077..0.110 rows=56 loops=1) -\u003e Covering index lookup on a using idx_actor_last_name (last_name='WAHLBERG') (cost=0.45 rows=2) (actual time=0.059..0.061 rows=2 loops=1) -\u003e Covering index lookup on fa using PRIMARY (actor_id=a.actor_id) (cost=0.30 rows=1) (actual time=0.011..0.021 rows=28 loops=2) With LIMIT: -\u003e Rows fetched before execution (cost=0.00..0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=1)-\u003e Select #2 (subquery in projection; run only once) -\u003e Aggregate: count(0) (cost=4.08..4.08 rows=1) (actual time=0.399..0.400 rows=1 loops=1) -\u003e Table scan on t (cost=2.62..3.88 rows=2) (actual time=0.394..0.394 rows=2 loops=1) -\u003e Materialize (cost=1.35..1.35 rows=2) (actual time=0.033..0.033 rows=2 loops=1) -\u003e Limit: 2 row(s) (cost=1.15 rows=2) (actual time=0.024..0.025 rows=2 loops=1) -\u003e Nested loop inner join (cost=1.15 rows=2) (actual time=0.024..0.024 rows=2 loops=1) -\u003e Covering index lookup on a using idx_actor_last_name (last_name='WAHLBERG') (cost=0.45 rows=2) (actual time=0.014..0.014 rows=1 loops=1) -\u003e Covering index lookup on fa using PRIMARY (actor_id=a.actor_id) (cost=0.30 rows=1) (actual time=0.008..0.008 rows=2 loops=1) We again get the Nested loop inner join row with the wanted difference: Before: Nested loop inner join (cost=1.15 rows=2) (actual time=0.077..0.110 rows=56 loops=1) After: Nested loop inner join (cost=1.15 rows=2) (actual time=0.024..0.024 rows=2 loops=1) Benchmark results: Again, the LIMIT is helpful, though the difference is less impressive: 0 1 1.29330 2 1.00891 1 1.24891 2 1.0000 -- Fastest run is 12 1 1.24442 2 1.09333 1 1.21333 2 1.01784 1 1.22674 2 1.0178 SQL Server No LIMIT: |--Compute Scalar(DEFINE:([Expr1006]=CASE WHEN [Expr1004]\u003e=(2) THEN (1) ELSE (0) END)) |--Compute Scalar(DEFINE:([Expr1004]=CONVERT_IMPLICIT(int,[Expr1010],0))) |--Stream Aggregate(DEFINE:([Expr1010]=Count(*))) |--Nested Loops(Inner Join, OUTER REFERENCES:([a].[actor_id])) |--Table Scan(OBJECT:([sakila].[dbo].[actor] AS [a]), WHERE:([sakila].[dbo].[actor].[last_name] as [a].[last_name]='WAHLBERG')) |--Index Seek(OBJECT:([sakila].[dbo].[film_actor].[PK__film_act__086D31FF6BE587FC] AS [fa]), SEEK:([fa].[actor_id]=[sakila].[dbo].[actor].[actor_id] as [a].[actor_id]) ORDERED FORWARD) With LIMIT: |--Compute Scalar(DEFINE:([Expr1007]=CASE WHEN [Expr1005]\u003e=(2) THEN (1) ELSE (0) END)) |--Compute Scalar(DEFINE:([Expr1005]=CONVERT_IMPLICIT(int,[Expr1011],0))) |--Stream Aggregate(DEFINE:([Expr1011]=Count(*))) |--Top(TOP EXPRESSION:((2))) |--Nested Loops(Inner Join, OUTER REFERENCES:([a].[actor_id])) |--Table Scan(OBJECT:([sakila].[dbo].[actor] AS [a]), WHERE:([sakila].[dbo].[actor].[last_name] as [a].[last_name]='WAHLBERG')) |--Index Seek(OBJECT:([sakila].[dbo].[film_actor].[PK__film_act__086D31FF6BE587FC] AS [fa]), SEEK:([fa].[actor_id]=[sakila].[dbo].[actor].[actor_id] as [a].[actor_id]) ORDERED FORWARD) The text version doesn’t indicate actual rows, even with SHOWPLAN_ALL, so let’s just look at what happens in the benchmark: Benchmark results: Run 1, Statement 1: 1.92118Run 1, Statement 2: 1.00000 -- Fastest run is 1Run 2, Statement 1: 1.95567Run 2, Statement 2: 1.01724Run 3, Statement 1: 1.91379Run 3, Statement 2: 1.01724Run 4, Statement 1: 1.93842Run 4, Statement 2: 1.04926Run 5, Statement 1: 1.95567Run 5, Statement 2: 1.03448 And again, an impressive 2x improvement for this particular query Conclusion Just as with our previous blog post about COUNT(*) vs EXISTS, the seemingly obvious is true again in this case where we want to check if N or more rows exist in a query. If we blindly count all the rows, then we’ve seen much worse performance than if we helped the optimiser with a LIMIT or TOP clause, or ROWNUM in Oracle. Technically, an optimiser could have detected this optimisation itself, but as our previous article about optimisations that don’t depend on the cost model has shown, optimisers don’t always do everything they can. Unfortunately, in Oracle’s case, the standard SQL syntax made things slower (in this benchmark). This doesn’t mean it’s generally slower for all cases, but it’s something worth looking out for. There are still cases where ancient ROWNUM clause is better optimised. This is one of those cases. Whether syntax X is faster than syntax Y can be shown by studying execution plans (not just with estimates, but with actual values), or by running a simple SQL benchmark. As always with benchmarks, be careful when interpreting results, double check, try more alternatives.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12478\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eIn a previous blog post, we’ve advertised the \u003ca href=\"https://blog.jooq.org/avoid-using-count-in-sql-when-you-could-use-exists/\" data-type=\"link\" data-id=\"https://blog.jooq.org/avoid-using-count-in-sql-when-you-could-use-exists/\"\u003euse of SQL \u003ccode\u003eEXISTS\u003c/code\u003e rather than \u003ccode\u003eCOUNT(*)\u003c/code\u003e\u003c/a\u003e to check for existence of a value in SQL. \u003c/p\u003e\n\n\n\n\u003cp\u003eI.e. to check if in the \u003ca href=\"https://www.jooq.org/sakila\" data-type=\"link\" data-id=\"https://www.jooq.org/sakila\"\u003eSakila database\u003c/a\u003e, actors called WAHLBERG have played in any films, instead of:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT count(*)\nFROM actor a\nJOIN film_actor fa USING (actor_id)\nWHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eDo this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT EXISTS (\n  SELECT 1 FROM actor a\n  JOIN film_actor fa USING (actor_id)\n  WHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;\n)\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003e(Depending on your dialect you may require a \u003ccode\u003eFROM DUAL\u003c/code\u003e clause, or a \u003ccode\u003eCASE\u003c/code\u003e expression if \u003ccode\u003eBOOLEAN\u003c/code\u003e types aren’t supported).\u003c/p\u003e\n\n\n\n\u003ch2\u003eCheck for multiple rows\u003c/h2\u003e\n\n\n\n\u003cp\u003eBut what if you want to check if there are at least \u003ccode\u003e2\u003c/code\u003e (or \u003ccode\u003eN\u003c/code\u003e) rows? In that case, you cannot use \u003ccode\u003eEXISTS\u003c/code\u003e, but have to revert to using \u003ccode\u003eCOUNT(*)\u003c/code\u003e. However, instead of just counting \u003cem\u003eall\u003c/em\u003e matches, why not add a \u003ccode\u003eLIMIT\u003c/code\u003e clause as well? So, if you want to check if actors called WAHLBERG have played in at least 2 films, instead of this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT (\n  SELECT count(*)\n  FROM actor a\n  JOIN film_actor fa USING (actor_id)\n  WHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;\n) \u0026gt;= 2\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWrite this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT (\n  SELECT count(*)\n  FROM (\n    SELECT *\n    FROM actor a\n    JOIN film_actor fa USING (actor_id)\n    WHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;\n    LIMIT 2\n  ) t\n) \u0026gt;= 2\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIn other words:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eRun the join query with a \u003ccode\u003eLIMIT 2\u003c/code\u003e in a derived table\u003c/li\u003e\n\n\n\n\u003cli\u003eThen \u003ccode\u003eCOUNT(*)\u003c/code\u003e the rows (at most 2) from that derived table\u003c/li\u003e\n\n\n\n\u003cli\u003eFinally, check if the count is high enough\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003ch2\u003eDoes it matter?\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn principle, the optimiser could have figured this out itself, especially because we used a constant to compare the \u003ccode\u003eCOUNT(*)\u003c/code\u003e value with. But did it really apply the transformation?\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s check execution plans and benchmark the query on various RDBMS.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePostgreSQL 15\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNo \u003ccode\u003eLIMIT\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eResult  (cost=14.70..14.71 rows=1 width=1) (actual time=0.039..0.039 rows=1 loops=1)\u003cbr/\u003e  InitPlan 1 (returns $1)\u003cbr/\u003e    -\u0026gt;  Aggregate  (cost=14.69..14.70 rows=1 width=8) (actual time=0.037..0.037 rows=1 loops=1)\u003cbr/\u003e          -\u0026gt;  Nested Loop  (cost=0.28..14.55 rows=55 width=0) (actual time=0.009..0.032 rows=56 loops=1)\u003cbr/\u003e                -\u0026gt;  Seq Scan on actor a  (cost=0.00..4.50 rows=2 width=4) (actual time=0.006..0.018 rows=2 loops=1)\u003cbr/\u003e                      Filter: ((last_name)::text = \u0026#39;WAHLBERG\u0026#39;::text)\u003cbr/\u003e                      Rows Removed by Filter: 198\u003cbr/\u003e                -\u0026gt;  Index Only Scan using film_actor_pkey on film_actor fa  (cost=0.28..4.75 rows=27 width=4) (actual time=0.003..0.005 rows=28 loops=2)\u003cbr/\u003e                      Index Cond: (actor_id = a.actor_id)\u003cbr/\u003e                      Heap Fetches: 0\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWith \u003ccode\u003eLIMIT\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eResult  (cost=0.84..0.85 rows=1 width=1) (actual time=0.023..0.024 rows=1 loops=1)\u003cbr/\u003e  InitPlan 1 (returns $1)\u003cbr/\u003e    -\u0026gt;  Aggregate  (cost=0.83..0.84 rows=1 width=8) (actual time=0.021..0.022 rows=1 loops=1)\u003cbr/\u003e          -\u0026gt;  Limit  (cost=0.28..0.80 rows=2 width=240) (actual time=0.016..0.018 rows=2 loops=1)\u003cbr/\u003e                -\u0026gt;  Nested Loop  (cost=0.28..14.55 rows=55 width=240) (actual time=0.015..0.016 rows=2 loops=1)\u003cbr/\u003e                      -\u0026gt;  Seq Scan on actor a  (cost=0.00..4.50 rows=2 width=4) (actual time=0.008..0.008 rows=1 loops=1)\u003cbr/\u003e                            Filter: ((last_name)::text = \u0026#39;WAHLBERG\u0026#39;::text)\u003cbr/\u003e                            Rows Removed by Filter: 1\u003cbr/\u003e                      -\u0026gt;  Index Only Scan using film_actor_pkey on film_actor fa  (cost=0.28..4.75 rows=27 width=4) (actual time=0.005..0.005 rows=2 loops=1)\u003cbr/\u003e                            Index Cond: (actor_id = a.actor_id)\u003cbr/\u003e                            Heap Fetches: 0\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo understand the difference, focus on these rows:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBefore:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eNested Loop  (cost=0.28..14.55 rows=55 width=0) (actual time=0.009..0.032 rows=56 loops=1)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eAfter:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eNested Loop  (cost=0.28..14.55 rows=55 width=240) (actual time=0.015..0.016 rows=2 loops=1)\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn both cases, the estimated number of rows produced by the join is 55 (i.e. all WAHLBERGs are expected to have played in a total of 55 films according to statistics).\u003c/p\u003e\n\n\n\n\u003cp\u003eBut int he second execution the \u003cem\u003eactual rows\u003c/em\u003e value is much lower, because we only needed 2 rows before we could stop execution of the operation, because of the \u003ccode\u003eLIMIT\u003c/code\u003e above.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBenchmark results:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eUsing our recommended \u003ca href=\"https://www.jooq.org/benchmark\" data-type=\"link\" data-id=\"https://www.jooq.org/benchmark\"\u003eSQL benchmarking technique\u003c/a\u003e that compares running two queries many times (5 runs x 2000 executions in this case) on the same instance directly from within the RDBMS using procedural languages (to avoid network latency, etc.), we get these results:\u003c/p\u003e\n\n\n\n\u003cpre\u003eRUN 1, Statement 1: 2.61927\u003cbr/\u003eRUN 1, Statement 2: 1.01506\u003cbr/\u003eRUN 2, Statement 1: 2.47193\u003cbr/\u003eRUN 2, Statement 2: 1.00614\u003cbr/\u003eRUN 3, Statement 1: 2.63533\u003cbr/\u003eRUN 3, Statement 2: 1.14282\u003cbr/\u003eRUN 4, Statement 1: 2.55228\u003cbr/\u003eRUN 4, Statement 2: 1.00000 -- Fastest run is 1\u003cbr/\u003eRUN 5, Statement 1: 2.53801\u003cbr/\u003eRUN 5, Statement 2: 1.02363\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe fastest run is \u003ccode\u003e1\u003c/code\u003e units of time, slower runs run in multiples of that time. The complete \u003ccode\u003eCOUNT(*)\u003c/code\u003e query is consistently and significantly slower than the \u003ccode\u003eLIMIT\u003c/code\u003e query.\u003c/p\u003e\n\n\n\n\u003cp\u003eBoth the plans and benchmark results speak for themselves.\u003c/p\u003e\n\n\n\n\u003ch3\u003eOracle 23c\u003c/h3\u003e\n\n\n\n\u003cp\u003eWith Oracle 23c, we can finally use \u003ccode\u003eBOOLEAN\u003c/code\u003e types and omit \u003ccode\u003eDUAL\u003c/code\u003e, yay!\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNo \u003ccode\u003eFETCH FIRST\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eSQL_ID  40yy0tskvs1zw, child number 0\u003cbr/\u003e-------------------------------------\u003cbr/\u003eSELECT /*+GATHER_PLAN_STATISTICS*/ (           SELECT count(*)          \u003cbr/\u003e FROM actor a           JOIN film_actor fa USING (actor_id)           \u003cbr/\u003eWHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;         ) \u0026gt;= 2\u003cp\u003e Plan hash value: 2539243977\u003c/p\u003e\u003cp\u003e ---------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e| Id  | Operation                             | Name                    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |\u003cbr/\u003e---------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e|   0 | SELECT STATEMENT                      |                         |      1 |        |      1 |00:00:00.01 |       0 |\u003cbr/\u003e|   1 |  SORT AGGREGATE                       |                         |      1 |      1 |      1 |00:00:00.01 |       6 |\u003cbr/\u003e|   2 |   NESTED LOOPS                        |                         |      1 |     55 |     56 |00:00:00.01 |       6 |\u003cbr/\u003e|   3 |    TABLE ACCESS BY INDEX ROWID BATCHED| ACTOR                   |      1 |      2 |      2 |00:00:00.01 |       2 |\u003cbr/\u003e|*  4 |     INDEX RANGE SCAN                  | IDX_ACTOR_LAST_NAME     |      1 |      2 |      2 |00:00:00.01 |       1 |\u003cbr/\u003e|*  5 |    INDEX RANGE SCAN                   | IDX_FK_FILM_ACTOR_ACTOR |      2 |     27 |     56 |00:00:00.01 |       4 |\u003cbr/\u003e|   6 |  FAST DUAL                            |                         |      1 |      1 |      1 |00:00:00.01 |       0 |\u003cbr/\u003e---------------------------------------------------------------------------------------------------------------------------\u003c/p\u003e\u003cp\u003e Predicate Information (identified by operation id):\u003cbr/\u003e---------------------------------------------------\u003c/p\u003e\u003cp\u003e    4 - access(\u0026#34;A\u0026#34;.\u0026#34;LAST_NAME\u0026#34;=\u0026#39;WAHLBERG\u0026#39;)\u003cbr/\u003e   5 - access(\u0026#34;A\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;=\u0026#34;FA\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;)\u003c/p\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWith \u003ccode\u003eFETCH FIRST\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eSQL_ID  f88t1r0avnr7b, child number 0\u003cbr/\u003e-------------------------------------\u003cbr/\u003eSELECT /*+GATHER_PLAN_STATISTICS*/(           SELECT count(*)           \u003cbr/\u003efrom (             select *             FROM actor a             JOIN \u003cbr/\u003efilm_actor fa USING (actor_id)             WHERE a.last_name = \u003cbr/\u003e\u0026#39;WAHLBERG\u0026#39;             FETCH FIRST 2 ROWS ONLY           ) t         ) \u003cbr/\u003e\u0026gt;= 2\u003cp\u003e Plan hash value: 4019277616\u003c/p\u003e\u003cp\u003e ------------------------------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e| Id  | Operation                       | Name                    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |  OMem |  1Mem | Used-Mem |\u003cbr/\u003e------------------------------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e|   0 | SELECT STATEMENT                |                         |      1 |        |      1 |00:00:00.01 |       0 |       |       |          |\u003cbr/\u003e|   1 |  SORT AGGREGATE                 |                         |      1 |      1 |      1 |00:00:00.01 |       6 |       |       |          |\u003cbr/\u003e|*  2 |   VIEW                          |                         |      1 |      2 |      2 |00:00:00.01 |       6 |       |       |          |\u003cbr/\u003e|*  3 |    WINDOW BUFFER PUSHED RANK    |                         |      1 |     55 |      2 |00:00:00.01 |       6 |  2048 |  2048 | 2048  (0)|\u003cbr/\u003e|   4 |     NESTED LOOPS                |                         |      1 |     55 |     56 |00:00:00.01 |       6 |       |       |          |\u003cbr/\u003e|   5 |      TABLE ACCESS BY INDEX ROWID| ACTOR                   |      1 |      2 |      2 |00:00:00.01 |       2 |       |       |          |\u003cbr/\u003e|*  6 |       INDEX RANGE SCAN          | IDX_ACTOR_LAST_NAME     |      1 |      2 |      2 |00:00:00.01 |       1 |       |       |          |\u003cbr/\u003e|*  7 |      INDEX RANGE SCAN           | IDX_FK_FILM_ACTOR_ACTOR |      2 |     27 |     56 |00:00:00.01 |       4 |       |       |          |\u003cbr/\u003e|   8 |  FAST DUAL                      |                         |      1 |      1 |      1 |00:00:00.01 |       0 |       |       |          |\u003cbr/\u003e------------------------------------------------------------------------------------------------------------------------------------------------\u003c/p\u003e\u003cp\u003e Predicate Information (identified by operation id):\u003cbr/\u003e---------------------------------------------------\u003c/p\u003e\u003cp\u003e    2 - filter(\u0026#34;from$_subquery$_005\u0026#34;.\u0026#34;rowlimit_$$_rownumber\u0026#34;\u0026lt;=2)\u003cbr/\u003e   3 - filter(ROW_NUMBER() OVER ( ORDER BY  NULL )\u0026lt;=2)\u003cbr/\u003e   6 - access(\u0026#34;A\u0026#34;.\u0026#34;LAST_NAME\u0026#34;=\u0026#39;WAHLBERG\u0026#39;)\u003cbr/\u003e   7 - access(\u0026#34;A\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;=\u0026#34;FA\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;)\u003c/p\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eUh oh, this doesn’t look better. The \u003ccode\u003eNESTED LOOPS\u003c/code\u003e operation doesn’t seem to have gotten the memo from the \u003ccode\u003eWINDOW BUFFER PUSHED RANK\u003c/code\u003e operation about the query being aborted. The \u003ccode\u003eE-Rows\u003c/code\u003e (estimated) and \u003ccode\u003eA-Rows\u003c/code\u003e (actual) values still match, so the \u003ccode\u003eJOIN\u003c/code\u003e seems to be executed completely.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor good measure, let’s also try:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWith \u003ccode\u003eROWNUM\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eI had hoped that this undead syntax belongs only to distant memories after Oracle 12c introduced the standard SQL \u003ccode\u003eFETCH\u003c/code\u003e syntax, but let’s try what happens with this alternative:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT (\n  SELECT count(*)\n  FROM (\n    SELECT *\n    FROM actor a\n    JOIN film_actor fa USING (actor_id)\n    WHERE a.last_name = \u0026#39;WAHLBERG\u0026#39;\n    AND ROWNUM \u0026lt;= 2 -- Yuck, but it works\n  ) t\n) \u0026gt;= 2\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe plan is now:\u003c/p\u003e\n\n\n\n\u003cpre\u003eSQL_ID  6r7w9d0425j6c, child number 0\u003cbr/\u003e-------------------------------------\u003cbr/\u003eSELECT /*+GATHER_PLAN_STATISTICS*/(           SELECT count(*)           \u003cbr/\u003efrom (             select *             FROM actor a             JOIN \u003cbr/\u003efilm_actor fa USING (actor_id)             WHERE a.last_name = \u003cbr/\u003e\u0026#39;WAHLBERG\u0026#39;             AND ROWNUM \u0026lt;= 2           ) t         ) \u0026gt;= 2\u003cp\u003e Plan hash value: 1271700124\u003c/p\u003e\u003cp\u003e -----------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e| Id  | Operation                               | Name                    | Starts | E-Rows | A-Rows |   A-Time   | Buffers |\u003cbr/\u003e-----------------------------------------------------------------------------------------------------------------------------\u003cbr/\u003e|   0 | SELECT STATEMENT                        |                         |      1 |        |      1 |00:00:00.01 |       0 |\u003cbr/\u003e|   1 |  SORT AGGREGATE                         |                         |      1 |      1 |      1 |00:00:00.01 |       4 |\u003cbr/\u003e|   2 |   VIEW                                  |                         |      1 |      2 |      2 |00:00:00.01 |       4 |\u003cbr/\u003e|*  3 |    COUNT STOPKEY                        |                         |      1 |        |      2 |00:00:00.01 |       4 |\u003cbr/\u003e|   4 |     NESTED LOOPS                        |                         |      1 |     55 |      2 |00:00:00.01 |       4 |\u003cbr/\u003e|   5 |      TABLE ACCESS BY INDEX ROWID BATCHED| ACTOR                   |      1 |      2 |      1 |00:00:00.01 |       2 |\u003cbr/\u003e|*  6 |       INDEX RANGE SCAN                  | IDX_ACTOR_LAST_NAME     |      1 |      2 |      1 |00:00:00.01 |       1 |\u003cbr/\u003e|*  7 |      INDEX RANGE SCAN                   | IDX_FK_FILM_ACTOR_ACTOR |      1 |     27 |      2 |00:00:00.01 |       2 |\u003cbr/\u003e|   8 |  FAST DUAL                              |                         |      1 |      1 |      1 |00:00:00.01 |       0 |\u003cbr/\u003e-----------------------------------------------------------------------------------------------------------------------------\u003c/p\u003e\u003cp\u003e Predicate Information (identified by operation id):\u003cbr/\u003e---------------------------------------------------\u003c/p\u003e\u003cp\u003e    3 - filter(ROWNUM\u0026lt;=2)\u003cbr/\u003e   6 - access(\u0026#34;A\u0026#34;.\u0026#34;LAST_NAME\u0026#34;=\u0026#39;WAHLBERG\u0026#39;)\u003cbr/\u003e   7 - access(\u0026#34;A\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;=\u0026#34;FA\u0026#34;.\u0026#34;ACTOR_ID\u0026#34;)\u003c/p\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eNow, that’s what I’m talking about. The \u003ccode\u003eNESTED LOOPS\u003c/code\u003e operation has a \u003ccode\u003eA-Rows\u003c/code\u003e value of \u003ccode\u003e2\u003c/code\u003e, as it should have. The \u003ccode\u003eCOUNT STOPKEY\u003c/code\u003e operation knows how to tell its successors to behave.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBenchmark results:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eRun 1, Statement 1 : 1.9564\u003cbr/\u003eRun 1, Statement 2 : 2.98499\u003cbr/\u003eRun 1, Statement 3 : 1.07291\u003cbr/\u003eRun 2, Statement 1 : 1.69192\u003cbr/\u003eRun 2, Statement 2 : 2.66905\u003cbr/\u003eRun 2, Statement 3 : 1.01144\u003cbr/\u003eRun 3, Statement 1 : 1.71051\u003cbr/\u003eRun 3, Statement 2 : 2.63831\u003cbr/\u003eRun 3, Statement 3 : 1       -- Fastest run is 1\u003cbr/\u003eRun 4, Statement 1 : 1.61544\u003cbr/\u003eRun 4, Statement 2 : 2.67334\u003cbr/\u003eRun 4, Statement 3 : 1.00786\u003cbr/\u003eRun 5, Statement 1 : 1.72981\u003cbr/\u003eRun 5, Statement 2 : 2.77913\u003cbr/\u003eRun 5, Statement 3 : 1.02716\u003c/pre\u003e\n\n\n\n\u003cp\u003eWhoopsies. Indeed, it appears that the \u003ccode\u003eFETCH FIRST 2 ROWS ONLY\u003c/code\u003e clause is bad in this case. It even made performance worse than if we omit it and count the complete result. However, the \u003ccode\u003eROWNUM\u003c/code\u003e filter helped greatly, just like before with PostgreSQL’s \u003ccode\u003eLIMIT\u003c/code\u003e. I would consider this an optimiser bug in Oracle. \u003ccode\u003eFETCH FIRST\u003c/code\u003e should be an operation that can be pushed down to various other operations\u003c/p\u003e\n\n\n\n\u003ch3\u003eMySQL\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNo \u003ccode\u003eLIMIT\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e-\u0026gt; Rows fetched before execution  (cost=0.00..0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=1)\u003cbr/\u003e-\u0026gt; Select #2 (subquery in projection; run only once)\u003cbr/\u003e    -\u0026gt; Aggregate: count(0)  (cost=1.35 rows=1) (actual time=0.479..0.479 rows=1 loops=1)\u003cbr/\u003e        -\u0026gt; Nested loop inner join  (cost=1.15 rows=2) (actual time=0.077..0.110 rows=56 loops=1)\u003cbr/\u003e            -\u0026gt; Covering index lookup on a using idx_actor_last_name (last_name=\u0026#39;WAHLBERG\u0026#39;)  (cost=0.45 rows=2) (actual time=0.059..0.061 rows=2 loops=1)\u003cbr/\u003e            -\u0026gt; Covering index lookup on fa using PRIMARY (actor_id=a.actor_id)  (cost=0.30 rows=1) (actual time=0.011..0.021 rows=28 loops=2)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWith \u003ccode\u003eLIMIT\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e-\u0026gt; Rows fetched before execution  (cost=0.00..0.00 rows=1) (actual time=0.000..0.000 rows=1 loops=1)\u003cbr/\u003e-\u0026gt; Select #2 (subquery in projection; run only once)\u003cbr/\u003e    -\u0026gt; Aggregate: count(0)  (cost=4.08..4.08 rows=1) (actual time=0.399..0.400 rows=1 loops=1)\u003cbr/\u003e        -\u0026gt; Table scan on t  (cost=2.62..3.88 rows=2) (actual time=0.394..0.394 rows=2 loops=1)\u003cbr/\u003e            -\u0026gt; Materialize  (cost=1.35..1.35 rows=2) (actual time=0.033..0.033 rows=2 loops=1)\u003cbr/\u003e                -\u0026gt; Limit: 2 row(s)  (cost=1.15 rows=2) (actual time=0.024..0.025 rows=2 loops=1)\u003cbr/\u003e                    -\u0026gt; Nested loop inner join  (cost=1.15 rows=2) (actual time=0.024..0.024 rows=2 loops=1)\u003cbr/\u003e                        -\u0026gt; Covering index lookup on a using idx_actor_last_name (last_name=\u0026#39;WAHLBERG\u0026#39;)  (cost=0.45 rows=2) (actual time=0.014..0.014 rows=1 loops=1)\u003cbr/\u003e                        -\u0026gt; Covering index lookup on fa using PRIMARY (actor_id=a.actor_id)  (cost=0.30 rows=1) (actual time=0.008..0.008 rows=2 loops=1)\u003c/pre\u003e\n\n\n\n\u003cp\u003eWe again get the \u003ccode\u003eNested loop inner join\u003c/code\u003e row with the wanted difference:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBefore:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eNested loop inner join  (cost=1.15 rows=2) (actual time=0.077..0.110 rows=56 loops=1)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eAfter:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eNested loop inner join  (cost=1.15 rows=2) (actual time=0.024..0.024 rows=2 loops=1)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBenchmark results:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eAgain, the \u003ccode\u003eLIMIT\u003c/code\u003e is helpful, though the difference is less impressive:\u003c/p\u003e\n\n\n\n\u003cpre\u003e0\t1\t1.2933\u003cbr/\u003e0\t2\t1.0089\u003cbr/\u003e1\t1\t1.2489\u003cbr/\u003e1\t2\t1.0000 -- Fastest run is 1\u003cbr/\u003e2\t1\t1.2444\u003cbr/\u003e2\t2\t1.0933\u003cbr/\u003e3\t1\t1.2133\u003cbr/\u003e3\t2\t1.0178\u003cbr/\u003e4\t1\t1.2267\u003cbr/\u003e4\t2\t1.0178\u003c/pre\u003e\n\n\n\n\u003ch2\u003eSQL Server\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNo \u003ccode\u003eLIMIT\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e  |--Compute Scalar(DEFINE:([Expr1006]=CASE WHEN [Expr1004]\u0026gt;=(2) THEN (1) ELSE (0) END))\u003cbr/\u003e       |--Compute Scalar(DEFINE:([Expr1004]=CONVERT_IMPLICIT(int,[Expr1010],0)))\u003cbr/\u003e            |--Stream Aggregate(DEFINE:([Expr1010]=Count(*)))\u003cbr/\u003e                 |--Nested Loops(Inner Join, OUTER REFERENCES:([a].[actor_id]))\u003cbr/\u003e                      |--Table Scan(OBJECT:([sakila].[dbo].[actor] AS [a]), WHERE:([sakila].[dbo].[actor].[last_name] as [a].[last_name]=\u0026#39;WAHLBERG\u0026#39;))\u003cbr/\u003e                      |--Index Seek(OBJECT:([sakila].[dbo].[film_actor].[PK__film_act__086D31FF6BE587FC] AS [fa]), SEEK:([fa].[actor_id]=[sakila].[dbo].[actor].[actor_id] as [a].[actor_id]) ORDERED FORWARD)\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWith \u003ccode\u003eLIMIT\u003c/code\u003e:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003e  |--Compute Scalar(DEFINE:([Expr1007]=CASE WHEN [Expr1005]\u0026gt;=(2) THEN (1) ELSE (0) END))\u003cbr/\u003e       |--Compute Scalar(DEFINE:([Expr1005]=CONVERT_IMPLICIT(int,[Expr1011],0)))\u003cbr/\u003e            |--Stream Aggregate(DEFINE:([Expr1011]=Count(*)))\u003cbr/\u003e                 |--Top(TOP EXPRESSION:((2)))\u003cbr/\u003e                      |--Nested Loops(Inner Join, OUTER REFERENCES:([a].[actor_id]))\u003cbr/\u003e                           |--Table Scan(OBJECT:([sakila].[dbo].[actor] AS [a]), WHERE:([sakila].[dbo].[actor].[last_name] as [a].[last_name]=\u0026#39;WAHLBERG\u0026#39;))\u003cbr/\u003e                           |--Index Seek(OBJECT:([sakila].[dbo].[film_actor].[PK__film_act__086D31FF6BE587FC] AS [fa]), SEEK:([fa].[actor_id]=[sakila].[dbo].[actor].[actor_id] as [a].[actor_id]) ORDERED FORWARD)\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe text version doesn’t indicate actual rows, even with \u003ccode\u003e\u003ca href=\"https://learn.microsoft.com/en-us/sql/t-sql/statements/set-showplan-all-transact-sql?view=sql-server-ver16\" data-type=\"link\" data-id=\"https://learn.microsoft.com/en-us/sql/t-sql/statements/set-showplan-all-transact-sql?view=sql-server-ver16\"\u003eSHOWPLAN_ALL\u003c/a\u003e\u003c/code\u003e, so let’s just look at what happens in the benchmark:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBenchmark results:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cpre\u003eRun 1, Statement 1: 1.92118\u003cbr/\u003eRun 1, Statement 2: 1.00000 -- Fastest run is 1\u003cbr/\u003eRun 2, Statement 1: 1.95567\u003cbr/\u003eRun 2, Statement 2: 1.01724\u003cbr/\u003eRun 3, Statement 1: 1.91379\u003cbr/\u003eRun 3, Statement 2: 1.01724\u003cbr/\u003eRun 4, Statement 1: 1.93842\u003cbr/\u003eRun 4, Statement 2: 1.04926\u003cbr/\u003eRun 5, Statement 1: 1.95567\u003cbr/\u003eRun 5, Statement 2: 1.03448\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd again, an impressive 2x improvement for this particular query\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eJust as with our previous blog post about \u003ca href=\"https://blog.jooq.org/avoid-using-count-in-sql-when-you-could-use-exists/\" data-type=\"link\" data-id=\"https://blog.jooq.org/avoid-using-count-in-sql-when-you-could-use-exists/\"\u003e\u003ccode\u003eCOUNT(*)\u003c/code\u003e vs \u003ccode\u003eEXISTS\u003c/code\u003e\u003c/a\u003e, the seemingly obvious is true again in this case where we want to check if \u003ccode\u003eN\u003c/code\u003e or more rows exist in a query. If we blindly count all the rows, then we’ve seen much worse performance than if we helped the optimiser with a \u003ccode\u003eLIMIT\u003c/code\u003e or \u003ccode\u003eTOP\u003c/code\u003e clause, or \u003ccode\u003eROWNUM\u003c/code\u003e in Oracle.\u003c/p\u003e\n\n\n\n\u003cp\u003eTechnically, an optimiser could have detected this optimisation itself, but as \u003ca href=\"https://blog.jooq.org/10-cool-sql-optimisations-that-do-not-depend-on-the-cost-model/\" data-type=\"link\" data-id=\"https://blog.jooq.org/10-cool-sql-optimisations-that-do-not-depend-on-the-cost-model/\"\u003eour previous article about optimisations that don’t depend on the cost model has shown\u003c/a\u003e, optimisers don’t always do everything they can.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnfortunately, in Oracle’s case, the standard SQL syntax made things slower (in this benchmark). This doesn’t mean it’s generally slower for all cases, but it’s something worth looking out for. There are still cases where ancient \u003ccode\u003eROWNUM\u003c/code\u003e clause is better optimised. This is one of those cases.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhether syntax X is faster than syntax Y can be shown by studying execution plans (not just with estimates, but with actual values), or by running a \u003ca href=\"https://www.jooq.org/benchmark\" data-type=\"link\" data-id=\"https://www.jooq.org/benchmark\"\u003esimple SQL benchmark\u003c/a\u003e. As always with benchmarks, be careful when interpreting results, double check, try more alternatives.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2024-02-16T14:16:45Z",
  "modifiedTime": "2024-02-16T14:16:45Z"
}
