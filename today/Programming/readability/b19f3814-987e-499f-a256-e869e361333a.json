{
  "id": "b19f3814-987e-499f-a256-e869e361333a",
  "title": "Localhost dangers: CORS and DNS rebinding",
  "link": "https://github.blog/security/application-security/localhost-dangers-cors-and-dns-rebinding/",
  "description": "What is CORS and how can a CORS misconfiguration lead to security issues? In this blog post, we’ll describe some common CORS issues as well as how you can find and fix them. The post Localhost dangers: CORS and DNS rebinding appeared first on The GitHub Blog.",
  "author": "Kevin Stubbings",
  "published": "Thu, 03 Apr 2025 16:00:24 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Application security",
    "Security",
    "GitHub Security Lab"
  ],
  "byline": "Kevin Stubbings",
  "length": 16601,
  "excerpt": "What is CORS and how can a CORS misconfiguration lead to security issues? Learn about common CORS issues and how you can find and fix them.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "At GitHub Security Lab, one of the most common vulnerability types we find relates to the cross-origin resource sharing (CORS) mechanism. CORS allows a server to instruct a browser to permit loading resources from specified origins other than its own, such as a different domain or port. Many developers change their CORS rules because users want to connect to third party sites, such as payment or social media sites. However, developers often don’t fully understand the dangers of changing the same-origin policy, and they use unnecessarily broad rules or faulty logic to prevent users from filing further issues. In this blog post, we’ll examine some case studies of how a broad or faulty CORS policy led to dangerous vulnerabilities in open source software. We’ll also discuss DNS rebinding, an attack with similar effects to a CORS misconfiguration that’s not as well known among developers. What is CORS and how does it work? CORS is a way to allow websites to communicate with each other directly by bypassing the same-origin policy, a security measure that restricts websites from making requests to a different domain than the one that served the web page. Understanding the Access-Control-Allow-Origin and Access-Control-Allow-Credentials response headers is crucial for correct and secure CORS implementation. Access-Control-Allow-Origin is the list of origins that are allowed to make cross site requests and read the response from the webserver. If the Access-Control-Allow-Credentials header is set, the browser is also allowed to send credentials (cookies, http authentication) if the origin requests it. Some requests are considered simple requests and do not need a CORS header in order to be sent cross-site. This includes the GET, POST, and HEAD requests with content types restricted to application/x-www-form-urlencoded, multipart/form-data, and text/plain. When a third-party website needs access to account data from your website, adding a concise CORS policy is often one of the best ways to facilitate such communication. To implement CORS, developers can either manually set the Access-Control-Allow-Origin header, or they can utilize a CORS framework, such as RSCors, that will do it for them. If you choose to use a framework, make sure to read the documentation—don’t assume the framework is safe by default. For example, if you tell the CORS library you choose to reflect all origins, does it send back the response with a blanket pattern matching star (*) or a response with the actual domain name (e.g., stripe.com)? Alternatively, you can create a custom function or middleware that checks the origin to see whether or not to send the Access-Control-Allow-Origin header. The problem is, you can make some security mistakes when rolling your own code that well-known libraries usually mitigate. Common mistakes when implementing CORS For example, when comparing the origin header with the allowed list of domains, developers may use the string comparison function equivalents of startsWith, exactMatch, and endsWith functions for their language of choice. The safest function is exactMatch where the domain must match the allow list exactly. However, what if payment.stripe.com wants to make a request to our backend instead of stripe.com? To get around this, we’d have to add every subdomain to the allow list. This would inevitably cause users frustration when third-party websites change their APIs. Alternatively, we can use the endsWith function. If we want connections from Stripe, let’s just add stripe.com to the allowlist and use endsWith to validate and call it a day. Not so fast, since the domain attackerstripe.com is now also valid. We can tell the user to only add full urls to the allowlist, such as https://stripe.com, but then we have the same problem as exactMatch. We occasionally see developers using the startsWith function in order to validate domains. This also doesn’t work. If the allowlist includes https://stripe.com then we can just do https://stripe.com.attacker.com. For any origin with subdomains, we must use .stripe.com (notice the extra period) in order to ensure that we are looking at a subdomain. If we combine exactMatch for second level domains and endsWith for subdomains, we can make a secure validator for cross site requests. Lastly, there’s one edge case found in CORS: the null origin should never be added to allowed domains. The null origin can be hardcoded into the code or added by the user to the allowlist, and it’s used when requests come from a file or from a privacy-sensitive context, such as a redirect. However, it can also come from a sandboxed iframe, which an attacker can include in their website. For more practice attacking a website with null origin, check out this CORS vulnerability with trusted null origin exercise in the Portswigger Security Academy. How can attackers exploit a CORS misconfiguration? CORS issues allow an attacker to make actions on behalf of the user when a web application uses cookies (with SameSite None) or HTTP basic authentication, since the browser must send those requests with the required authentication. Fortunately for users, Chrome has defaulted cookies with no Samesite to SameSite Lax, which has made CORS misconfiguration useless in most scenarios. However, Firefox and Safari are still vulnerable to these issues using bypass techniques found by PTSecurity, whose research we highly recommend reading for knowing how someone can exploit CORS issues. What impact can a CORS misconfiguration have? CORS issues can give a user the power of an administrator of a web application, so the usefulness depends on the application. In many cases, administrators have the ability to execute scripts or binaries on the server’s host. These relaxed security restrictions allow attackers to get remote code execution (RCE) capabilities on the server host by convincing administrators to visit an attacker-owned website. CORS issues can also be chained with other vulnerabilities to increase their impact. Since an attacker now has the permissions of an administrator, they are able to access a broader range of services and activities, making it more likely they’ll find something vulnerable. Attackers often focus on vulnerabilities that affect the host system, such as arbitrary file write or RCE. Real-world examples A CORS misconfiguration allows for RCE Cognita is a Python project that allows users to test the retrieval-augmented generation (RAG) ability of LLM models. If we look at how it used to call the FastAPI CORS middleware, we can see it used an unsafe default setting, with allow_origins set to all and allow_credentials set to true. Usually if the browser receives Access-Control-Allow-Origin: * and Access-Control-Allow-Credentials: true, the browser knows not to send credentials with the origin, since the application did not reflect the actual domain, just a wildcard. app.add_middleware( CORSMiddleware, allow_origins=[\"*\"], allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) However, FastAPI CORS middleware is unsafe by default and setting these two headers like this resulted in the origin being reflected along with credentials. Currently, Cognita does not have authentication, but if its developers implemented authentication without fixing the CORS policy, their authentication could be bypassed. As it stands, any website can send arbitrary requests to any endpoint in Cognita, as long as they know how to access it. Due to its lack of authentication, Cognita appears intended to be hosted on intranets or locally. An attacking website can try guessing the local IP of a Cognita instance by sending requests to local addresses such as localhost, or it can enumerate the internal IP address space by continually making requests until it finds the Cognita instance. With this bug alone, our access is limited to just using the RAG endpoints and possibly deleting data. We want to get a foothold in the network. Let’s look for a real primitive. We found a simple arbitrary file write primitive; the developers added an endpoint for Docker without considering file sanitization, and now we can write to any file we want. The file.filename is controlled by the request and os.path.join resolves the “..”, allowing file_path to be fully controlled. @router.post(\"/upload-to-local-directory\") async def upload_to_docker_directory( upload_name: str = Form( default_factory=lambda: str(uuid.uuid4()), regex=r\"^[a-z][a-z0-9-]*$\" ), files: List[UploadFile] = File(...), ): ... for file in files: logger.info(f\"Copying file: {file.filename}, to folder: {folder_path}\") file_path = os.path.join(folder_path, file.filename) with open(file_path, \"wb\") as f: f.write(file.file.read()) Now that we have an arbitrary file write target, what should we target to get RCE? This endpoint is for Docker users and the Cognita documentation only shows how to install via Docker. Let’s take a look at that Dockerfile. command: -c \"set -e; prisma db push --schema ./backend/database/schema.prisma \u0026\u0026 uvicorn --host 0.0.0.0 --port 8000 backend.server.app:app --reload\" Looking carefully, there’s the --reload when starting up the backend server. So we can overwrite any file in the server and uvicorn will automatically restart the server to apply changes. Thanks uvicorn! Let’s target the init.py files that are run on start, and now we have RCE on the Cognita instance. We can use this to read data from Cognita, or use it as a starting point on the network and attempt to connect to other vulnerable devices from there. Logic issues lead to credit card charges and backdoor access Next, let’s look at some additional real life examples of faulty CORS logic. We found the following code was found on the website https://tamagui.dev. Since the source code is found on GitHub, we decided to take a quick look. (Note: The found vulnerability has since been reported by our team and fixed by the developer.) export function setupCors(req: NextApiRequest, res: NextApiResponse) { const origin = req.headers.origin if ( typeof origin === 'string' \u0026\u0026 (origin.endsWith('tamagui.dev') || origin.endsWith('localhost:1421') || origin.endsWith('stripe.com')) ) { res.setHeader('Access-Control-Allow-Origin', origin) res.setHeader('Access-Control-Allow-Credentials', 'true') } } As you can see, the developer added hardcoded endpoints. Taking a guess, the developer most likely used Stripe for payment, localhost for local development and tamagui.dev for subdomain access or to deal with https issues. In short, it looks like the developer added allowed domains as they became needed. As we know, using endsWith is insufficient and an attacker may be able to create a domain that fulfills those qualities. Depending on the tamagui.dev account’s permissions, an attacker could perform a range of actions on behalf of the user, such as potentially buying products on the website by charging their credit card. Lastly, some projects don’t prioritize security and developers are simply writing the code to work. For example, the following project used the HasPrefix and Contains functions to check the origin, which is easily exploitable. Using this vulnerability, we can trick an administrator to click on a specific link (let’s say https://localhost.attacker.com), and use the user-add endpoint to install a backdoor account in the application. func CorsFilter(ctx *context.Context) { origin := ctx.Input.Header(headerOrigin) originConf := conf.GetConfigString(\"origin\") originHostname := getHostname(origin) host := removePort(ctx.Request.Host) if strings.HasPrefix(origin, \"http://localhost\") || strings.HasPrefix(origin, \"https://localhost\") || strings.HasPrefix(origin, \"http://127.0.0.1\") || strings.HasPrefix(origin, \"http://casdoor-app\") || strings.Contains(origin, \".chromiumapp.org\") { setCorsHeaders(ctx, origin) return } func setCorsHeaders(ctx *context.Context, origin string) { ctx.Output.Header(headerAllowOrigin, origin) ctx.Output.Header(headerAllowMethods, \"POST, GET, OPTIONS, DELETE\") ctx.Output.Header(headerAllowHeaders, \"Content-Type, Authorization\") ctx.Output.Header(headerAllowCredentials, \"true\") if ctx.Input.Method() == \"OPTIONS\" { ctx.ResponseWriter.WriteHeader(http.StatusOK) } } DNS rebinding DNS rebinding has the same mechanism as a CORS misconfiguration, but its ability is limited. DNS rebinding does not require a misconfiguration or bug on the part of the developer or user. Rather, it’s an attack on how the DNS system works. Both CORS and DNS rebinding vulnerabilities facilitate requests to API endpoints from unintended origins. First, an attacker lures the victim’s browser to a domain that serves malicious javascript. The malicious javascript makes a request to a host that the attacker controls, and sets the DNS records to redirect the browser to a local address. With control over the resolving DNS server, the attacker can change the IP address of the domain and its subdomains in order to get the browser to connect to various IP addresses. The malicious javascript will scan for open connections and send their malicious payload requests to them. This attack is very easy to set up using NCCGroup’s singularity tool. Under the payloads folder, you can view the scripts that interact with singularity and even add your own script to tell singularity how to send requests and respond. Fortunately, DNS rebinding is very easy to mitigate as it cannot contain cookies, so adding simple authentication for all sensitive and critical endpoints will prevent this attack. Since the browser thinks it is contacting the attacker domain, it would send any cookies from the attacker domain, not those from the actual web application, and authorization would fail. If you don’t want to add authentication for a simple application, then you should check that the host header matches an approved host name or a local name. Unfortunately, many newly created AI projects currently proliferating do not have any of these security protections built in, making any data on those web applications possibly retrievable and any vulnerability remotely exploitable. public boolean isValidHost(String host) { // Allow loopback IPv4 and IPv6 addresses, as well as localhost if (LOOPBACK_PATTERN.matcher(host).find()) { return true; } // Strip port from hostname - for IPv6 addresses, if // they end with a bracket, then there is no port int index = host.lastIndexOf(':'); if (index \u003e 0 \u0026\u0026 !host.endsWith(\"]\")) { host = host.substring(0, index); } // Strip brackets from IPv6 addresses if (host.startsWith(\"[\") \u0026\u0026 host.endsWith(\"]\")) { host = host.substring(1, host.length() - 2); } // Allow only if stripped hostname matches expected hostname return expectedHost.equalsIgnoreCase(host); } Because DNS rebinding requires certain parameters to be effective, it is not caught by security scanners for the fear of many false positives. At GitHub, our DNS rebinding reports to maintainers commonly go unfixed due to the unusual nature of this attack, and we see that only the most popular repos have checks in place. When publishing software that holds security critical information or takes privileged actions, we strongly encourage developers to write code that checks that the origin header matches the host or an allowlist. Conclusion Using CORS to bypass the same-origin policy has always led to common mistakes. Finding and fixing these issues is relatively simple once you understand CORS mechanics. New and improving browser protections have mitigated some of the risk and may eliminate this bug class altogether in the future. Oftentimes, finding CORS issues is as simple as searching for “CORS” or Access-Control-Allow-Origin in the code to see if any insecure presets or logic are used. Check out the Mozilla Developer Network CORS page if you wish to become better acquainted with how CORS works and the config you choose when using a CORS framework. If you’re building an application without authentication that utilizes critical functionality, remember to check the Host header as an extra security measure. Finally, GitHub Code Security can help you secure your project by detecting and suggesting a fix for bugs such as CORS misconfiguration! Written by",
  "image": "https://github.blog/wp-content/uploads/2025/03/github_logo_invertocat_dark_3.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eAt \u003ca href=\"https://securitylab.github.com/\"\u003eGitHub Security Lab\u003c/a\u003e, one of the most common vulnerability types we find relates to the cross-origin resource sharing (CORS) mechanism. CORS allows a server to instruct a browser to permit loading resources from specified origins other than its own, such as a different domain or port.\u003c/p\u003e\n\u003cp\u003eMany developers change their CORS rules because users want to connect to third party sites, such as payment or social media sites. However, developers often don’t fully understand the dangers of changing the same-origin policy, and they use unnecessarily broad rules or faulty logic to prevent users from filing further issues.\u003c/p\u003e\n\u003cp\u003eIn this blog post, we’ll examine some case studies of how a broad or faulty CORS policy led to dangerous vulnerabilities in open source software. We’ll also discuss DNS rebinding, an attack with similar effects to a CORS misconfiguration that’s not as well known among developers.\u003c/p\u003e\n\u003ch2 id=\"what-is-cors-and-how-does-it-work\" id=\"what-is-cors-and-how-does-it-work\"\u003eWhat is CORS and how does it work?\u003ca href=\"#what-is-cors-and-how-does-it-work\" aria-label=\"What is CORS and how does it work?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCORS is a way to allow websites to communicate with each other directly by bypassing the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\"\u003esame-origin policy\u003c/a\u003e, a security measure that restricts websites from making requests to a different domain than the one that served the web page. Understanding the \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e and \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e \u003ca href=\"https://developer.mozilla.org/en-US/docs/Glossary/Response_header\"\u003eresponse headers\u003c/a\u003e is crucial for correct and secure CORS implementation.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e is the list of origins that are allowed to make cross site requests and read the response from the webserver. If the \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e header is set, the browser is also allowed to send credentials (cookies, http authentication) if the origin requests it. Some requests are considered simple requests and do not need a CORS header in order to be sent cross-site. This includes the GET, POST, and HEAD requests with content types restricted to \u003ccode\u003eapplication/x-www-form-urlencoded\u003c/code\u003e, \u003ccode\u003emultipart/form-data\u003c/code\u003e, and \u003ccode\u003etext/plain\u003c/code\u003e. When a third-party website needs access to account data from your website, adding a concise CORS policy is often one of the best ways to facilitate such communication.\u003c/p\u003e\n\u003cp\u003eTo implement CORS, developers can either manually set the \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e header, or they can utilize a CORS framework, such as \u003ca href=\"https://github.com/rs/cors\"\u003e\u003cem\u003eRSCors\u003c/em\u003e\u003c/a\u003e, that will do it for them. If you choose to use a framework, make sure to read the documentation—don’t assume the framework is safe by default. For example, if you tell the CORS library you choose to reflect all origins, does it send back the response with a blanket pattern matching star (*) or a response with the actual domain name (e.g., stripe.com)?\u003c/p\u003e\n\u003cp\u003eAlternatively, you can create a custom function or middleware that checks the origin to see whether or not to send the \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e header. The problem is, you can make some security mistakes when rolling your own code that well-known libraries usually mitigate.\u003c/p\u003e\n\u003ch2 id=\"common-mistakes-when-implementing-cors\" id=\"common-mistakes-when-implementing-cors\"\u003eCommon mistakes when implementing CORS\u003ca href=\"#common-mistakes-when-implementing-cors\" aria-label=\"Common mistakes when implementing CORS\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFor example, when comparing the origin header with the allowed list of domains, developers may use the string comparison function equivalents of \u003ccode\u003estartsWith\u003c/code\u003e, \u003ccode\u003eexactMatch\u003c/code\u003e\u003cem\u003e,\u003c/em\u003e and \u003ccode\u003eendsWith\u003c/code\u003e functions for their language of choice. The safest function is \u003ccode\u003eexactMatch\u003c/code\u003e where the domain must match the allow list exactly. However, what if \u003cem\u003epayment.stripe.com\u003c/em\u003e wants to make a request to our backend instead of \u003cem\u003estripe.com\u003c/em\u003e? To get around this, we’d have to add every subdomain to the allow list. This would inevitably cause users frustration when third-party websites change their APIs.\u003c/p\u003e\n\u003cp\u003eAlternatively, we can use the \u003ccode\u003eendsWith\u003c/code\u003e function. If we want connections from Stripe, let’s just add \u003cem\u003estripe.com\u003c/em\u003e to the allowlist and use \u003ccode\u003eendsWith\u003c/code\u003e to validate and call it a day. Not so fast, since the domain \u003cem\u003eattackerstripe.com\u003c/em\u003e is now \u003cstrong\u003ealso\u003c/strong\u003e valid. We can tell the user to only add full urls to the allowlist, such as \u003ca href=\"https://stripe.com\"\u003e\u003cem\u003ehttps://stripe.com\u003c/em\u003e\u003c/a\u003e, but then we have the same problem as \u003ccode\u003eexactMatch\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe occasionally see developers using the \u003ccode\u003estartsWith\u003c/code\u003e function in order to validate domains. This also doesn’t work. If the allowlist includes \u003cem\u003e\u003ca href=\"https://stripe.com\"\u003ehttps://stripe.com\u003c/a\u003e\u003c/em\u003e then we can just do \u003cem\u003e\u003ca href=\"https://stripe.com.attacker.com\"\u003ehttps://stripe.com.attacker.com\u003c/a\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFor any origin with subdomains, we must use \u003cem\u003e.stripe.com\u003c/em\u003e (notice the extra period) in order to ensure that we are looking at a subdomain. If we combine \u003ccode\u003eexactMatch\u003c/code\u003e for second level domains and \u003ccode\u003eendsWith\u003c/code\u003e for subdomains, we can make a secure validator for cross site requests.\u003c/p\u003e\n\u003cp\u003eLastly, there’s one edge case found in CORS: the null origin should never be added to allowed domains. The null origin can be hardcoded into the code or added by the user to the allowlist, and it’s used when requests come from a file or from a privacy-sensitive context, such as a redirect. However, it can also come from a sandboxed iframe, which an attacker can include in their website. For more practice attacking a website with null  origin, check out this \u003ca href=\"https://portswigger.net/web-security/cors/lab-null-origin-whitelisted-attack\"\u003eCORS vulnerability with trusted null origin exercise\u003c/a\u003e in the Portswigger Security Academy.\u003c/p\u003e\n\u003ch2 id=\"how-can-attackers-exploit-a-cors-misconfiguration\" id=\"how-can-attackers-exploit-a-cors-misconfiguration\"\u003eHow can attackers exploit a CORS misconfiguration?\u003ca href=\"#how-can-attackers-exploit-a-cors-misconfiguration\" aria-label=\"How can attackers exploit a CORS misconfiguration?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCORS issues allow an attacker to make actions on behalf of the user when a web application uses cookies (with \u003ccode\u003eSameSite None\u003c/code\u003e) or HTTP basic authentication, since the browser must send those requests with the required authentication.\u003c/p\u003e\n\u003cp\u003eFortunately for users, Chrome has defaulted cookies with no \u003ccode\u003eSamesite\u003c/code\u003e to \u003ccode\u003eSameSite Lax\u003c/code\u003e, which has made CORS misconfiguration useless in most scenarios. However, Firefox and Safari are still vulnerable to these issues using \u003ca href=\"https://swarm.ptsecurity.com/bypassing-browser-tracking-protection-for-cors-misconfiguration-abuse/\"\u003ebypass techniques found by PTSecurity\u003c/a\u003e, whose research we highly recommend reading for knowing how someone can exploit CORS issues.\u003c/p\u003e\n\u003ch2 id=\"what-impact-can-a-cors-misconfiguration-have\" id=\"what-impact-can-a-cors-misconfiguration-have\"\u003eWhat impact can a CORS misconfiguration have?\u003ca href=\"#what-impact-can-a-cors-misconfiguration-have\" aria-label=\"What impact can a CORS misconfiguration have?\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCORS issues can give a user the power of an administrator of a web application, so the usefulness depends on the application.  In many cases, administrators have the ability to execute scripts or binaries on the server’s host. These relaxed security restrictions allow attackers to get remote code execution (RCE) capabilities on the server host by convincing administrators to visit an attacker-owned website.\u003c/p\u003e\n\u003cp\u003eCORS issues can also be chained with other vulnerabilities to increase their impact. Since an attacker now has the permissions of an administrator, they are able to access a broader range of services and activities, making it more likely they’ll find something  vulnerable. Attackers often focus on vulnerabilities that affect the host system, such as arbitrary file write or RCE.\u003c/p\u003e\n\u003ch2 id=\"real-world-examples\" id=\"real-world-examples\"\u003eReal-world examples\u003ca href=\"#real-world-examples\" aria-label=\"Real-world examples\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"a-cors-misconfiguration-allows-for-rce\" id=\"a-cors-misconfiguration-allows-for-rce\"\u003eA CORS misconfiguration allows for RCE\u003ca href=\"#a-cors-misconfiguration-allows-for-rce\" aria-label=\"A CORS misconfiguration allows for RCE\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCognita is a Python project that allows users to test the retrieval-augmented generation (RAG) ability of LLM models. If we look at how it used to call the FastAPI CORS middleware, we can see it used an unsafe default setting, with \u003ccode\u003eallow_origins\u003c/code\u003e set to \u003ccode\u003eall\u003c/code\u003e and \u003ccode\u003eallow_credentials\u003c/code\u003e set to \u003ccode\u003etrue\u003c/code\u003e. Usually if the browser receives \u003ccode\u003eAccess-Control-Allow-Origin: *\u003c/code\u003e and \u003ccode\u003eAccess-Control-Allow-Credentials: true\u003c/code\u003e, the browser knows not to send credentials with the origin, since the application did not reflect the actual domain, just a wildcard.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\u0026#34;*\u0026#34;],\n    allow_credentials=True,\n    allow_methods=[\u0026#34;*\u0026#34;],\n    allow_headers=[\u0026#34;*\u0026#34;],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, FastAPI CORS middleware is unsafe by default and setting these two headers like this resulted in the origin being reflected along with credentials.\u003c/p\u003e\n\u003cp\u003eCurrently, Cognita does not have authentication, but if its developers implemented authentication without fixing the CORS policy, their authentication could be bypassed. As it stands, any website can send arbitrary requests to any endpoint in Cognita, as long as they know how to access it. Due to its lack of authentication, Cognita appears intended to be hosted on intranets or locally. An attacking website can try guessing the local IP of a Cognita instance by sending requests to local addresses such as localhost, or it can enumerate the internal IP address space by continually making requests until it finds the Cognita instance. With this bug alone, our access is limited to just using the RAG endpoints and possibly deleting data. We want to get a foothold in the network. Let’s look for a real primitive.\u003c/p\u003e\n\u003cp\u003eWe found a simple arbitrary file write primitive; the developers added an endpoint for Docker without considering file sanitization, and now we can write to any file we want. The \u003ccode\u003efile.filename\u003c/code\u003e is controlled by the request and \u003ccode\u003eos.path.join\u003c/code\u003e resolves the “..”, allowing \u003ccode\u003efile_path\u003c/code\u003e to be fully controlled.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@router.post(\u0026#34;/upload-to-local-directory\u0026#34;)\nasync def upload_to_docker_directory(\n    upload_name: str = Form(\n        default_factory=lambda: str(uuid.uuid4()), regex=r\u0026#34;^[a-z][a-z0-9-]*$\u0026#34;\n    ),\n    files: List[UploadFile] = File(...),\n):\n...\n        for file in files:\n            logger.info(f\u0026#34;Copying file: {file.filename}, to folder: {folder_path}\u0026#34;)\n            file_path = os.path.join(folder_path, file.filename)\n            with open(file_path, \u0026#34;wb\u0026#34;) as f:\n                f.write(file.file.read())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have an arbitrary file write target, what should we target to get RCE? This endpoint is for Docker users and the Cognita documentation only shows how to install via Docker. Let’s take a look at that Dockerfile.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecommand: -c \u0026#34;set -e; prisma db push --schema ./backend/database/schema.prisma \u0026amp;\u0026amp; uvicorn --host 0.0.0.0 --port 8000 backend.server.app:app --reload\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLooking carefully, there’s the \u003ccode\u003e--reload\u003c/code\u003e when starting up the backend server. So we can overwrite any file in the server and uvicorn will automatically restart the server to apply changes. Thanks uvicorn! Let’s target the \u003ccode\u003einit.py\u003c/code\u003e files that are run on start, and now we have RCE on the Cognita instance. We can use this to read data from Cognita, or use it as a starting point on the network and attempt to connect to other vulnerable devices from there.\u003c/p\u003e\n\u003ch3 id=\"logic-issues-lead-to-credit-card-charges-and-backdoor-access\" id=\"logic-issues-lead-to-credit-card-charges-and-backdoor-access\"\u003eLogic issues lead to credit card charges and backdoor access\u003ca href=\"#logic-issues-lead-to-credit-card-charges-and-backdoor-access\" aria-label=\"Logic issues lead to credit card charges and backdoor access\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNext, let’s look at some additional real life examples of faulty CORS logic.\u003c/p\u003e\n\u003cp\u003eWe found the following code was found on the website \u003ca href=\"https://tamagui.dev\"\u003e\u003cem\u003ehttps://tamagui.dev\u003c/em\u003e\u003c/a\u003e. Since the source code is found on GitHub, we decided to take a quick look. (Note: The found vulnerability has since been reported by our team and fixed by the developer.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport function setupCors(req: NextApiRequest, res: NextApiResponse) {\n  const origin = req.headers.origin\n\n  if (\n    typeof origin === \u0026#39;string\u0026#39; \u0026amp;\u0026amp;\n    (origin.endsWith(\u0026#39;tamagui.dev\u0026#39;) ||\n      origin.endsWith(\u0026#39;localhost:1421\u0026#39;) ||\n      origin.endsWith(\u0026#39;stripe.com\u0026#39;))\n  ) {\n    res.setHeader(\u0026#39;Access-Control-Allow-Origin\u0026#39;, origin)\n    res.setHeader(\u0026#39;Access-Control-Allow-Credentials\u0026#39;, \u0026#39;true\u0026#39;)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, the developer added hardcoded endpoints. Taking a guess, the developer most likely used Stripe for payment, localhost for local development and \u003cem\u003etamagui.dev\u003c/em\u003e for subdomain access or to deal with https issues. In short, it looks like the developer added allowed domains as they became needed.\u003c/p\u003e\n\u003cp\u003eAs we know, using \u003ccode\u003eendsWith\u003c/code\u003e is insufficient and an attacker may be able to create a domain that fulfills those qualities. Depending on the \u003cem\u003etamagui.dev\u003c/em\u003e account’s permissions, an attacker could perform a range of actions on behalf of the user, such as potentially buying products on the website by charging their credit card.\u003c/p\u003e\n\u003cp\u003eLastly, some projects don’t prioritize security and developers are simply writing the code to work. For example, the following project used the \u003ccode\u003eHasPrefix\u003c/code\u003e and \u003ccode\u003eContains\u003c/code\u003e  functions to check the origin, which is easily exploitable. Using this vulnerability, we can trick an administrator to click on a specific link (let’s say \u003cem\u003e\u003ca href=\"https://localhost.attacker.com\"\u003ehttps://localhost.attacker.com\u003c/a\u003e\u003c/em\u003e), and use the user-add endpoint to install a backdoor account in the application.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc CorsFilter(ctx *context.Context) {\n    origin := ctx.Input.Header(headerOrigin)\n    originConf := conf.GetConfigString(\u0026#34;origin\u0026#34;)\n    originHostname := getHostname(origin)\n    host := removePort(ctx.Request.Host)\n\n    if strings.HasPrefix(origin, \u0026#34;http://localhost\u0026#34;) || strings.HasPrefix(origin, \u0026#34;https://localhost\u0026#34;) || strings.HasPrefix(origin, \u0026#34;http://127.0.0.1\u0026#34;) || strings.HasPrefix(origin, \u0026#34;http://casdoor-app\u0026#34;) || strings.Contains(origin, \u0026#34;.chromiumapp.org\u0026#34;) {\n        setCorsHeaders(ctx, origin)\n        return\n    }\n\nfunc setCorsHeaders(ctx *context.Context, origin string) {\n    ctx.Output.Header(headerAllowOrigin, origin)\n    ctx.Output.Header(headerAllowMethods, \u0026#34;POST, GET, OPTIONS, DELETE\u0026#34;)\n    ctx.Output.Header(headerAllowHeaders, \u0026#34;Content-Type, Authorization\u0026#34;)\n    ctx.Output.Header(headerAllowCredentials, \u0026#34;true\u0026#34;)\n\n    if ctx.Input.Method() == \u0026#34;OPTIONS\u0026#34; {\n        ctx.ResponseWriter.WriteHeader(http.StatusOK)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"dns-rebinding\" id=\"dns-rebinding\"\u003eDNS rebinding\u003ca href=\"#dns-rebinding\" aria-label=\"DNS rebinding\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/04/DNS.png?resize=1024%2C767\" alt=\"Diagram showing how DNS rebinding utilizes the DNS system to exploit vulnerable web applications.\" width=\"1024\" height=\"767\" srcset=\"https://github.blog/wp-content/uploads/2025/04/DNS.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/04/DNS.png?w=300 300w, https://github.blog/wp-content/uploads/2025/04/DNS.png?w=768 768w, https://github.blog/wp-content/uploads/2025/04/DNS.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/04/DNS.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eDNS rebinding has the same mechanism as a CORS misconfiguration, but its ability is limited. DNS rebinding does not require a misconfiguration or bug on the part of the developer or user. Rather, it’s an attack on how the DNS system works.\u003c/p\u003e\n\u003cp\u003eBoth CORS and DNS rebinding vulnerabilities facilitate requests to API endpoints from unintended origins. First, an attacker lures the victim’s browser to a domain that serves malicious javascript. The malicious javascript makes a request to a host that the attacker controls, and sets the DNS records to redirect the browser to a local address. With control over the resolving DNS server, the attacker can change the IP address of the domain and its subdomains in order to get the browser to connect to various IP addresses. The malicious javascript will scan for open connections and send their malicious payload requests to them.\u003c/p\u003e\n\u003cp\u003eThis attack is very easy to set up using NCCGroup’s \u003ca href=\"https://github.com/nccgroup/singularity?tab=readme-ov-file\"\u003esingularity\u003c/a\u003e tool. Under the \u003ca href=\"https://github.com/nccgroup/singularity/tree/master/html/payloads\"\u003epayloads folder\u003c/a\u003e, you can view the scripts that interact with singularity and even add your own script to tell singularity how to send requests and respond.\u003c/p\u003e\n\u003cp\u003eFortunately, DNS rebinding is very easy to mitigate as it cannot contain cookies, so adding simple authentication for all sensitive and critical endpoints will prevent this attack. Since the browser thinks it is contacting the attacker domain, it would send any cookies from the attacker domain, not those from the actual web application, and authorization would fail.\u003c/p\u003e\n\u003cp\u003eIf you don’t want to add authentication for a simple application, then you should \u003ca href=\"https://github.com/OpenRefine/OpenRefine/pull/3212/files#diff-d1306540c0d68d0039bffa2784661857cbf5c11ee56834d059e3f0d586dccf37\"\u003echeck that the host header matches an approved host name or a local name\u003c/a\u003e. Unfortunately, many newly created AI projects currently proliferating do not have any of these security protections built in, making any data on those web applications possibly retrievable and any vulnerability remotely exploitable.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   public boolean isValidHost(String host) {\n\n        // Allow loopback IPv4 and IPv6 addresses, as well as localhost\n        if (LOOPBACK_PATTERN.matcher(host).find()) {\n            return true;\n        }\n\n        // Strip port from hostname - for IPv6 addresses, if\n        // they end with a bracket, then there is no port\n        int index = host.lastIndexOf(\u0026#39;:\u0026#39;);\n        if (index \u0026gt; 0 \u0026amp;\u0026amp; !host.endsWith(\u0026#34;]\u0026#34;)) {\n            host = host.substring(0, index);\n        }\n\n        // Strip brackets from IPv6 addresses\n        if (host.startsWith(\u0026#34;[\u0026#34;) \u0026amp;\u0026amp; host.endsWith(\u0026#34;]\u0026#34;)) {\n            host = host.substring(1, host.length() - 2);\n        }\n\n        // Allow only if stripped hostname matches expected hostname\n        return expectedHost.equalsIgnoreCase(host);\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause DNS rebinding requires certain parameters to be effective, it is not caught by security scanners for the fear of many false positives. At GitHub, our DNS rebinding reports to maintainers commonly go unfixed due to the unusual nature of this attack, and we see that only the most popular repos have checks in place.\u003c/p\u003e\n\u003cp\u003eWhen publishing software that holds security critical information or takes privileged actions, we strongly encourage developers to write code that checks that the origin header matches the host or an allowlist.\u003c/p\u003e\n\u003ch2 id=\"conclusion\" id=\"conclusion\"\u003eConclusion\u003ca href=\"#conclusion\" aria-label=\"Conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eUsing CORS to bypass the same-origin policy has always led to common mistakes. Finding and fixing these issues is relatively simple once you understand CORS mechanics. New and improving browser protections have mitigated some of the risk and may eliminate this bug class altogether in the future. Oftentimes, finding CORS issues is as simple as searching for “CORS” or \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e in the code to see if any insecure presets or logic are used.\u003c/p\u003e\n\u003cp\u003eCheck out the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\"\u003eMozilla Developer Network CORS page\u003c/a\u003e if you wish to become better acquainted with how CORS works and the config you choose when using a CORS framework.\u003c/p\u003e\n\u003cp\u003eIf you’re building an application without authentication that utilizes critical functionality, remember to check the Host header as an extra security measure.\u003c/p\u003e\n\u003cp\u003eFinally, \u003ca href=\"https://github.com/security/advanced-security/code-security\"\u003eGitHub Code Security\u003c/a\u003e can help you secure your project by detecting and suggesting a fix for bugs such as \u003ca href=\"https://codeql.github.com/codeql-query-help/javascript/js-cors-misconfiguration-for-credentials/\"\u003eCORS misconfiguration\u003c/a\u003e!\u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/11400619?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/11400619?v=4\u0026amp;s=200\" alt=\"Kevin Stubbings\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2025-04-03T16:00:24Z",
  "modifiedTime": null
}
