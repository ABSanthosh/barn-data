{
  "id": "46bdf000-8bc2-4dcd-8f3a-b28eb560e98f",
  "title": "jOOQ 3.19’s new Explicit and Implicit to-many path joins",
  "link": "https://blog.jooq.org/jooq-3-19s-new-explicit-and-implicit-to-many-path-joins/",
  "description": "jOOQ 3.19 finally delivers on a set of features that will greatly simplify your queries further, after jOOQ 3.11 introduced implicit to-one joins: What are these features? Many ORMs (e.g. JPA, Doctrine, jOOQ 3.11 and others) support “path joins” (they may have different names for this concept). A path join is a join derived from … Continue reading jOOQ 3.19’s new Explicit and Implicit to-many path joins →",
  "author": "lukaseder",
  "published": "Thu, 28 Dec 2023 14:35:14 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-development",
    "correlated subqueries",
    "explicit path joins",
    "implicit join path correlation",
    "implicit joins",
    "java",
    "jooq",
    "path joins",
    "sql",
    "to-many path joins"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 11504,
  "excerpt": "jOOQ 3.19 supports explicit path joins, to-many path joins, and implicit join path correlation to greatly simplify your SQL queries",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "jOOQ 3.19 finally delivers on a set of features that will greatly simplify your queries further, after jOOQ 3.11 introduced implicit to-one joins: Explicit path joins To-many path joins Implicit join path correlation What are these features? Many ORMs (e.g. JPA, Doctrine, jOOQ 3.11 and others) support “path joins” (they may have different names for this concept). A path join is a join derived from a path where the query language allows for navigating foreign keys. E.g. in jOOQ, you can write: ctx.select( CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME, CUSTOMER.address().city().country().NAME) .from(CUSTOMER) .fetch(); The generated query looks something like this: SELECT customer.first_name, customer.last_name, country.name FROM customer JOIN address ON customer.address_id = address.address_id JOIN city ON address.city_id = city.city_id JOIN country ON city.country_id = country.country_id Depending on your tastes, the implicit join syntax may be much more readable than the explicit one. In addition to that, it’s impossible to ever write a wrong join predicate this way (wrong columns compared, or missing columns in a composite key) because the meta data is known to jOOQ and generated correctly, every time. Very idiomatic SQL In fact these features are quite idiomatic in SQL, in general. Imagine a new version of the SQL standard that allows for declaring “labels” on foreign keys: CREATE TABLE book ( .. author_id INT REFERENCES author PARENT PATH LABEL author CHILD PATH LABEL books ); And now, you could reference those labels in queries: SELECT book.title, book.author.first_name FROM book Or: SELECT author.id, author.first_name, author.last_name, COUNT(*) FROM author LEFT JOIN author.books GROUP BY author.id Because: why not? We can dream! In fact, ORDBMS extensions (as implemented by Oracle), implemented something similar with the REF type, but it’s never been adopted, regrettably. But for now, let’s look at what new things jOOQ is offering. New: Explicit path joins As mentioned initially, one new thing in jOOQ 3.19 is support for explicit path joins. This was rarely necessary so far, because the implicit to-one join semantics is obvious, but sometimes, you may want to make the join path declaration explicit, or have control over the join type on a per-query basis, e.g. if you prefer LEFT JOIN over INNER JOIN. Note: jOOQ already generates LEFT JOIN for nullable foreign keys. You can explicitly join paths like this now: ctx.select( CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME, CUSTOMER.address().city().country().NAME) .from(CUSTOMER) // The entire path will be left joined: .leftJoin(CUSTOMER.address().city().country() .fetch(); Or even more explicitly, like this: ctx.select( CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME, CUSTOMER.address().city().country().NAME) .from(CUSTOMER) .leftJoin(CUSTOMER.address()) .leftJoin(CUSTOMER.address().city()) .leftJoin(CUSTOMER.address().city().country()) .fetch(); Obviously, you can also assign each path to a local variable, and use aliases and all the other jOOQ features, as always. Note that the JOIN .. ON clause is now optional, because jOOQ already generates it for you based on the available foreign key meta data. If you require an additional join predicate on a path (which is very rarely necessary, and now, it’s finally possible), you can do so: ctx.select( CUSTOMER.FIRST_NAME, CUSTOMER.LAST_NAME, CUSTOMER.address().city().country().NAME) .from(CUSTOMER) .leftJoin(CUSTOMER.address().city()) // You may have your reasons to display the country only if // the city name starts with A .on(CUSTOMER.address().city().NAME.like(\"A%\")) .leftJoin(CUSTOMER.address().city().country()) .fetch(); In order to profit from this new path based join, the \u003cimplicitJoinPathTableSubtypes/\u003e code generation flag needs to be turned on (which it is, by default). The feature also works without the flag, but then, the ON clause will be mandatory for most join types. Turning off the flag can be useful if you want to avoid too many types being generated by jOOQ (one Path type per table). New: to-many path joins The main reason for introducing the above explicit path based joins are the new to-many path joins. Implicit to-many path joins are unavailable by default (via an exception thrown), because of their weird semantics within a query. For example, when finding all the films of an actor: ctx.select( ACTOR.FIRST_NAME, ACTOR.LAST_NAME, ACTOR.film().TITLE) .from(ACTOR) .fetch(); It may be tempting to write queries this way, but this would change one of the fundamental assumptions of SQL, namely that rows can be generated only in the FROM clause (or in GROUP BY, with GROUPING SETS), and they’re filtered mainly in the WHERE, HAVING, QUALIFY clauses. See an overview of SQL clauses here. But in the above example, a projection (i.e. an expression in SELECT) is capable of generating rows by creating a cartesian product! Just by adding the FILM.TITLE column, suddenly, an ACTOR.FIRST_NAME and ACTOR.LAST_NAME will be repeated, which may or may not be what people expect. This is a very un-SELECT-y thing to do, as if Stream.map() could generate or filter rows! Even worse, what if you write this: ctx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) .from(ACTOR) .where(ACTOR.film().TITLE.like(\"A%\")) .fetch(); This looks as though we’re querying for actors who played in films starting with the letter A, but in fact, we’re again creating a cartesian product between ACTOR × FILM where each actor is repeated for each matching film. Since we’re no longer projecting any FILM columns, this looks like a mistake! The result may look like this: |first_name|last_name||----------|---------||PENELOPE |GUINESS ||PENELOPE |GUINESS ||PENELOPE |GUINESS ||NICK |WAHLBERG ||NICK |WAHLBERG ||ED |CHASE ||ED |CHASE ||ED |CHASE | And if you’re not careful, then you might be tempted to remove the duplicates with DISTINCT, which just makes things worse. So, in order to make things explicit, you have to explicitly declare the paths in the FROM clause, e.g.: ctx.select( ACTOR.FIRST_NAME, ACTOR.LAST_NAME, ACTOR.film().TITLE) .from(ACTOR) .leftJoin(ACTOR.film()) .fetch(); Now, the cartesian product is visible in the jOOQ query, and doesn’t surprise you as a developer (or reviewer) of this code anymore. Plus, with to-many path joins, the INNER or OUTER semantics of the JOIN is more important than with to-one path joins, so you’re forced to make a choice. Overriding the default Note that if you disagree with the above default of disallowing such queries, you can tell jOOQ to allow implicit to-many path joins by specifying a new Settings.renderImplicitJoinType value: Settings settings = new Settings() .withRenderImplicitJoinType(RenderImplicitJoinType.LEFT_JOIN); Many-to-many paths You may have noticed in the examples above that we skipped the relationship table when writing ACTOR.film(). This is purely a code generation feature, where the code generator recognises relationship tables based on a unique constraint on the two foreign keys: CREATE TABLE film_actor ( actor_id BIGINT REFERENCES actor, film_id BIGINT REFERENCES film, PRIMARY KEY (actor_id, film_id) ) Because you love normalisation (there’s a constraint on the foreign keys) and you hate slow queries (you didn’t use an unnecessary surrogate key), this clearly qualifies as a relationship table to jOOQ. Hence, you can write ACTOR.film().TITLE instead of ACTOR.filmActor().film().TITLE. If you ever need to access auxiliary attributes on the relationship table, you can obviously still do that, as both paths are available from the code generator. New: implicit path correlation Possibly the most powerful new feature is the implicit path correlation support, which allows for correlating subqueries based on paths that start with a table reference of the outer query. This is again best explained by example. Before, you had to correlate subqueries explicitly, like this, e.g. to find all actors that played in films whose title starts with \"A\": ctx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) .from(ACTOR) .where(exists( selectOne() .from(FILM_ACTOR) .where(FILM_ACTOR.ACTOR_ID.eq(ACTOR.ACTOR_ID)) .and(FILM_ACTOR.film().TITLE.like(\"A%\")) )) .fetch(); This is quickly very tedious to write, and unreadable. Now, with implicit path correlations, you can just access the FILM_ACTOR and FILM tables from the ACTOR table in the correlated subquery! ctx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) .from(ACTOR) .where(exists( selectOne() .from(ACTOR.film()) .where(ACTOR.film().TITLE.like(\"A%\")) )) .fetch(); Or even: ctx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) .from(ACTOR) .leftSemiJoin(ACTOR.film()) .on(ACTOR.film().TITLE.like(\"A%\")) .fetch(); This is particularly useful with MULTISET correlated subqueries as well! Getting actors, and all their films, and all their film categories is a breeze, even more than before: ctx.select( ACTOR.FIRST_NAME, ACTOR.LAST_NAME, multiset(select(ACTOR.film().TITLE).from(ACTOR.film())).as(\"films\"), multiset( selectDistinct(ACTOR.film().category().NAME) .from(ACTOR.film().category()) ).as(\"categories\") ) .from(ACTOR) .fetch(); This is how simple it is now to produce a query generating data like this: [ { \"first_name\":\"PENELOPE\", \"last_name\":\"GUINESS\", \"films\":[ { \"title\":\"ACADEMY DINOSAUR\" }, { \"title\":\"ANACONDA CONFESSIONS\" }, { \"title\":\"ANGELS LIFE\" }, ... ], \"categories\":[ { \"name\":\"Family\" }, { \"name\":\"Games\" }, { \"name\":\"Animation\" }, ... ] }, { \"first_name\":\"NICK\", \"last_name\":\"WAHLBERG\", ... }] Everything continues to be type safe, and you can continue combining this with ad-hoc conversion in order to map data to your DTOs very easily: record Actor ( String firstName, String lastName, List\u003cString\u003e titles, List\u003cString\u003e categories ) {} List\u003cActor\u003e actors = ctx.select( ACTOR.FIRST_NAME, ACTOR.LAST_NAME, multiset(select(ACTOR.film().TITLE).from(ACTOR.film())).as(\"films\") .convertFrom(r -\u003e r.collect(Records.intoList())), multiset( selectDistinct(ACTOR.film().category().NAME) .from(ACTOR.film().category()) ).as(\"categories\") .convertFrom(r -\u003e r.collect(Records.intoList())) ) .from(ACTOR) .fetch(Records.mapping(Actor::new)); It’s really hard not to love this! Conclusion Time to upgrade to jOOQ 3.19! Path based implicit joins have been around for many years, since jOOQ 3.11. But now, with these 3 new features, you’ll love them even more! Explicit path joins – To give fine-grained control over the join type, as well as make to-many path joins explicit To-many path joins – To navigate foreign keys from parent to children Implicit join path correlation – To greatly simplify all sorts of correlated subqueries Get jOOQ 3.19 now!",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12345\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003ejOOQ 3.19 finally delivers on a set of features that will greatly simplify your queries further, after \u003ca href=\"https://blog.jooq.org/type-safe-implicit-join-through-path-navigation-in-jooq-3-11/\" data-type=\"link\" data-id=\"https://blog.jooq.org/type-safe-implicit-join-through-path-navigation-in-jooq-3-11/\"\u003ejOOQ 3.11 introduced implicit to-one joins\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\"\u003eExplicit path joins\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\"\u003eTo-many path joins\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\"\u003eImplicit join path correlation\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eWhat are these features?\u003c/h2\u003e\n\n\n\n\u003cp\u003eMany ORMs (e.g. JPA, Doctrine, jOOQ 3.11 and others) support “path joins” (they may have different names for this concept). A path join is a join derived from a path where the query language allows for navigating foreign keys. E.g. in jOOQ, you can write:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n       CUSTOMER.FIRST_NAME,\n       CUSTOMER.LAST_NAME,\n       CUSTOMER.address().city().country().NAME)\n   .from(CUSTOMER)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe generated query looks something like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  customer.first_name,\n  customer.last_name,\n  country.name\nFROM\n  customer\n  JOIN address ON customer.address_id = address.address_id\n  JOIN city ON address.city_id = city.city_id \n  JOIN country ON city.country_id = country.country_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eDepending on your tastes, the implicit join syntax may be much more readable than the explicit one. In addition to that, it’s impossible to ever write a wrong join predicate this way (wrong columns compared, or missing columns in a composite key) because the meta data is known to jOOQ and generated correctly, every time.\u003c/p\u003e\n\n\n\n\u003ch3\u003eVery idiomatic SQL\u003c/h3\u003e\n\n\n\n\u003cp\u003eIn fact these features are quite idiomatic in SQL, in general. Imagine a new version of the SQL standard that allows for declaring “labels” on foreign keys:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE TABLE book (\n  ..\n  author_id INT REFERENCES author \n    PARENT PATH LABEL author \n    CHILD PATH LABEL books\n);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd now, you could reference those labels in queries:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT book.title, book.author.first_name\nFROM book\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  author.id, \n  author.first_name, \n  author.last_name,\n  COUNT(*)\nFROM author\nLEFT JOIN author.books\nGROUP BY author.id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBecause: why not? We can dream! In fact, ORDBMS extensions (as implemented by Oracle), implemented something similar with the \u003ccode\u003eREF\u003c/code\u003e type, but it’s never been adopted, regrettably.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut for now, let’s look at what new things jOOQ is offering.\u003c/p\u003e\n\n\n\n\u003ch2\u003eNew: Explicit path joins\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs mentioned initially, one new thing in jOOQ 3.19 is support for \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\"\u003eexplicit path joins\u003c/a\u003e. This was rarely necessary so far, because the implicit \u003ccode\u003eto-one\u003c/code\u003e join semantics is obvious, but sometimes, you may want to make the join path declaration explicit, or have control over the join type on a per-query basis, e.g. if you prefer \u003ccode\u003eLEFT JOIN\u003c/code\u003e over \u003ccode\u003eINNER JOIN\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eNote: jOOQ already generates \u003ccode\u003eLEFT JOIN\u003c/code\u003e for nullable foreign keys.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eYou can explicitly join paths like this now:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n       CUSTOMER.FIRST_NAME,\n       CUSTOMER.LAST_NAME,\n       CUSTOMER.address().city().country().NAME)\n   .from(CUSTOMER)\n\n   // The entire path will be left joined:\n   .leftJoin(CUSTOMER.address().city().country()\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr even more explicitly, like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n       CUSTOMER.FIRST_NAME,\n       CUSTOMER.LAST_NAME,\n       CUSTOMER.address().city().country().NAME)\n   .from(CUSTOMER)\n   .leftJoin(CUSTOMER.address())\n   .leftJoin(CUSTOMER.address().city())\n   .leftJoin(CUSTOMER.address().city().country())\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eObviously, you can also assign each path to a local variable, and use aliases and all the other jOOQ features, as always.\u003c/p\u003e\n\n\n\n\u003cp\u003eNote that the \u003ccode\u003eJOIN .. ON\u003c/code\u003e clause is now optional, because jOOQ already generates it for you based on the available foreign key meta data. If you require an additional join predicate on a path (which is very rarely necessary, and now, it’s finally possible), you can do so:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n       CUSTOMER.FIRST_NAME,\n       CUSTOMER.LAST_NAME,\n       CUSTOMER.address().city().country().NAME)\n   .from(CUSTOMER)\n   .leftJoin(CUSTOMER.address().city())\n      // You may have your reasons to display the country only if\n      // the city name starts with A\n      .on(CUSTOMER.address().city().NAME.like(\u0026#34;A%\u0026#34;))\n   .leftJoin(CUSTOMER.address().city().country())\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIn order to profit from this new path based join, the \u003ccode\u003e\u0026lt;implicitJoinPathTableSubtypes/\u0026gt;\u003c/code\u003e code generation flag needs to be turned on (which it is, by default).\u003c/p\u003e\n\n\n\n\u003cp\u003eThe feature also works without the flag, but then, the \u003ccode\u003eON\u003c/code\u003e clause will be mandatory for most join types. Turning off the flag can be useful if you want to avoid too many types being generated by jOOQ (one \u003ccode\u003ePath\u003c/code\u003e type per table).\u003c/p\u003e\n\n\n\n\u003ch2\u003eNew: to-many path joins\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe main reason for introducing the above explicit path based joins are the new \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\"\u003e\u003ccode\u003eto-many\u003c/code\u003e path joins\u003c/a\u003e. \u003cem\u003eImplicit \u003c/em\u003eto-many path joins are unavailable by default (via an exception thrown), because of their weird semantics within a query. For example, when finding all the films of an actor:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n      ACTOR.FIRST_NAME,\n      ACTOR.LAST_NAME,\n      ACTOR.film().TITLE)\n   .from(ACTOR)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIt may be tempting to write queries this way, but this would change one of the fundamental assumptions of SQL, namely that rows can be generated only in the \u003ccode\u003eFROM\u003c/code\u003e clause (\u003ca href=\"https://blog.jooq.org/do-you-really-understand-sqls-group-by-and-having-clauses/\" data-type=\"link\" data-id=\"https://blog.jooq.org/do-you-really-understand-sqls-group-by-and-having-clauses/\"\u003eor in \u003ccode\u003eGROUP BY\u003c/code\u003e, with \u003ccode\u003eGROUPING SETS\u003c/code\u003e\u003c/a\u003e), and they’re filtered mainly in the \u003ccode\u003eWHERE\u003c/code\u003e, \u003ccode\u003eHAVING\u003c/code\u003e, \u003ccode\u003eQUALIFY\u003c/code\u003e clauses. \u003ca href=\"https://blog.jooq.org/a-beginners-guide-to-the-true-order-of-sql-operations/\" data-type=\"post\" data-id=\"6620\"\u003eSee an overview of SQL clauses here\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut in the above example, a projection (i.e. an expression in \u003ccode\u003eSELECT\u003c/code\u003e) is capable of generating rows by creating a cartesian product! Just by adding the \u003ccode\u003eFILM.TITLE\u003c/code\u003e column, suddenly, an \u003ccode\u003eACTOR.FIRST_NAME\u003c/code\u003e and \u003ccode\u003eACTOR.LAST_NAME\u003c/code\u003e will be repeated, which may or may not be what people expect.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is a very un-\u003ccode\u003eSELECT\u003c/code\u003e-y thing to do, \u003ca href=\"https://blog.jooq.org/common-sql-clauses-and-their-equivalents-in-java-8-streams/\" data-type=\"link\" data-id=\"https://blog.jooq.org/common-sql-clauses-and-their-equivalents-in-java-8-streams/\"\u003eas if \u003ccode\u003eStream.map()\u003c/code\u003e could generate or filter rows!\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eEven worse, what if you write this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME)\n   .from(ACTOR)\n   .where(ACTOR.film().TITLE.like(\u0026#34;A%\u0026#34;))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis \u003cem\u003elooks \u003c/em\u003eas though we’re querying for actors who played in films starting with the letter \u003ccode\u003eA\u003c/code\u003e, but in fact, we’re again creating a cartesian product between \u003ccode\u003eACTOR × FILM\u003c/code\u003e where each actor is repeated for each matching film. Since we’re no longer \u003cem\u003eprojecting \u003c/em\u003eany \u003ccode\u003eFILM\u003c/code\u003e columns, this looks like a mistake! The result may look like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|first_name|last_name|\u003cbr/\u003e|----------|---------|\u003cbr/\u003e|PENELOPE  |GUINESS  |\u003cbr/\u003e|PENELOPE  |GUINESS  |\u003cbr/\u003e|PENELOPE  |GUINESS  |\u003cbr/\u003e|NICK      |WAHLBERG |\u003cbr/\u003e|NICK      |WAHLBERG |\u003cbr/\u003e|ED        |CHASE    |\u003cbr/\u003e|ED        |CHASE    |\u003cbr/\u003e|ED        |CHASE    |\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd if you’re not careful, then you might be tempted to \u003ca href=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-sql-select-distinct/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/reference/dont-do-this/dont-do-this-sql-select-distinct/\"\u003eremove the duplicates with \u003ccode\u003eDISTINCT\u003c/code\u003e, which just makes things worse\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eSo, in order to make things explicit, you have to explicitly declare the paths in the \u003ccode\u003eFROM\u003c/code\u003e clause, e.g.:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n      ACTOR.FIRST_NAME,\n      ACTOR.LAST_NAME,\n      ACTOR.film().TITLE)\n   .from(ACTOR)\n   .leftJoin(ACTOR.film())\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNow, the cartesian product is visible in the jOOQ query, and doesn’t surprise you as a developer (or reviewer) of this code anymore. Plus, with \u003ccode\u003eto-many\u003c/code\u003e path joins, the \u003ccode\u003eINNER\u003c/code\u003e or \u003ccode\u003eOUTER\u003c/code\u003e semantics of the \u003ccode\u003eJOIN\u003c/code\u003e is more important than with \u003ccode\u003eto-one\u003c/code\u003e path joins, so you’re forced to make a choice.\u003c/p\u003e\n\n\n\n\u003ch3\u003eOverriding the default\u003c/h3\u003e\n\n\n\n\u003cp\u003eNote that if you disagree with the above default of disallowing such queries, you can tell jOOQ to allow implicit \u003ccode\u003eto-many\u003c/code\u003e path joins \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/dsl-context/custom-settings/settings-implicit-join-type/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/dsl-context/custom-settings/settings-implicit-join-type/\"\u003eby specifying a new \u003ccode\u003eSettings.renderImplicitJoinType\u003c/code\u003e value\u003c/a\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSettings settings = new Settings()\n    .withRenderImplicitJoinType(RenderImplicitJoinType.LEFT_JOIN);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch3\u003eMany-to-many paths\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou may have noticed in the examples above that we skipped the relationship table when writing \u003ccode\u003eACTOR.film()\u003c/code\u003e. This is purely a code generation feature, where the code generator recognises relationship tables based on a unique constraint on the two foreign keys:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE TABLE film_actor (\n  actor_id BIGINT REFERENCES actor,\n  film_id BIGINT REFERENCES film,\n\n  PRIMARY KEY (actor_id, film_id)\n)\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBecause you love normalisation (there’s a constraint on the foreign keys) and you hate slow queries (\u003ca href=\"https://blog.jooq.org/the-cost-of-useless-surrogate-keys-in-relationship-tables/\" data-type=\"post\" data-id=\"8021\"\u003eyou didn’t use an unnecessary surrogate key\u003c/a\u003e), this clearly qualifies as a relationship table to jOOQ.\u003c/p\u003e\n\n\n\n\u003cp\u003eHence, you can write \u003ccode\u003eACTOR.film().TITLE\u003c/code\u003e instead of \u003ccode\u003eACTOR.filmActor().film().TITLE\u003c/code\u003e. If you ever need to access auxiliary attributes on the relationship table, you can obviously still do that, as both paths are available from the code generator.\u003c/p\u003e\n\n\n\n\u003ch2\u003eNew: implicit path correlation\u003c/h2\u003e\n\n\n\n\u003cp\u003ePossibly the most powerful new feature is the \u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\"\u003eimplicit path correlation support\u003c/a\u003e, which allows for correlating subqueries based on paths that start with a table reference of the outer query. This is again best explained by example.\u003c/p\u003e\n\n\n\n\u003cp\u003eBefore, you had to correlate subqueries explicitly, like this, e.g. to find all actors that played in films whose title starts with \u003ccode\u003e\u0026#34;A\u0026#34;\u003c/code\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME)\n   .from(ACTOR)\n   .where(exists(\n       selectOne()\n       .from(FILM_ACTOR)\n       .where(FILM_ACTOR.ACTOR_ID.eq(ACTOR.ACTOR_ID))\n       .and(FILM_ACTOR.film().TITLE.like(\u0026#34;A%\u0026#34;))\n   ))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis is quickly very tedious to write, and unreadable. Now, with implicit path correlations, you can just access the \u003ccode\u003eFILM_ACTOR\u003c/code\u003e and \u003ccode\u003eFILM\u003c/code\u003e tables from the \u003ccode\u003eACTOR\u003c/code\u003e table in the correlated subquery!\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME)\n   .from(ACTOR)\n   .where(exists(\n       selectOne()\n       .from(ACTOR.film())\n       .where(ACTOR.film().TITLE.like(\u0026#34;A%\u0026#34;))\n   ))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eOr even:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME)\n   .from(ACTOR)\n   .leftSemiJoin(ACTOR.film())\n   .on(ACTOR.film().TITLE.like(\u0026#34;A%\u0026#34;))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis is particularly useful with \u003ca href=\"https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/\" data-type=\"link\" data-id=\"https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/\"\u003e\u003ccode\u003eMULTISET\u003c/code\u003e correlated subqueries\u003c/a\u003e as well! Getting actors, and all their films, and all their film categories is a breeze, even more than before:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003ectx.select(\n       ACTOR.FIRST_NAME, \n       ACTOR.LAST_NAME,\n       multiset(select(ACTOR.film().TITLE).from(ACTOR.film())).as(\u0026#34;films\u0026#34;),\n       multiset(\n           selectDistinct(ACTOR.film().category().NAME)\n           .from(ACTOR.film().category())\n       ).as(\u0026#34;categories\u0026#34;)\n   )\n   .from(ACTOR)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis is how simple it is now to produce a query generating data like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e[\u003cbr/\u003e   {\u003cbr/\u003e      \u0026#34;first_name\u0026#34;:\u0026#34;PENELOPE\u0026#34;,\u003cbr/\u003e      \u0026#34;last_name\u0026#34;:\u0026#34;GUINESS\u0026#34;,\u003cbr/\u003e      \u0026#34;films\u0026#34;:[\u003cbr/\u003e         { \u0026#34;title\u0026#34;:\u0026#34;ACADEMY DINOSAUR\u0026#34; },\u003cbr/\u003e         { \u0026#34;title\u0026#34;:\u0026#34;ANACONDA CONFESSIONS\u0026#34; },\u003cbr/\u003e         { \u0026#34;title\u0026#34;:\u0026#34;ANGELS LIFE\u0026#34; },\u003cbr/\u003e         ...\u003cbr/\u003e      ],\u003cbr/\u003e      \u0026#34;categories\u0026#34;:[\u003cbr/\u003e         { \u0026#34;name\u0026#34;:\u0026#34;Family\u0026#34; },\u003cbr/\u003e         { \u0026#34;name\u0026#34;:\u0026#34;Games\u0026#34; },\u003cbr/\u003e         { \u0026#34;name\u0026#34;:\u0026#34;Animation\u0026#34; },\u003cbr/\u003e         ...\u003cbr/\u003e      ]\u003cbr/\u003e   },\u003cbr/\u003e   {\u003cbr/\u003e      \u0026#34;first_name\u0026#34;:\u0026#34;NICK\u0026#34;,\u003cbr/\u003e      \u0026#34;last_name\u0026#34;:\u0026#34;WAHLBERG\u0026#34;,\u003cbr/\u003e\t  ...\u003cbr/\u003e   }\u003cbr/\u003e]\u003c/pre\u003e\n\n\n\n\u003cp\u003eEverything continues to be type safe, and you can continue combining this with \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\"\u003ead-hoc conversion\u003c/a\u003e in order to map data to your DTOs very easily:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003erecord Actor (\n    String firstName, String lastName, \n    List\u0026lt;String\u0026gt; titles, \n    List\u0026lt;String\u0026gt; categories\n) {}\n\nList\u0026lt;Actor\u0026gt; actors =\nctx.select(\n       ACTOR.FIRST_NAME, \n       ACTOR.LAST_NAME,\n       multiset(select(ACTOR.film().TITLE).from(ACTOR.film())).as(\u0026#34;films\u0026#34;)\n           .convertFrom(r -\u0026gt; r.collect(Records.intoList())),\n       multiset(\n           selectDistinct(ACTOR.film().category().NAME)\n           .from(ACTOR.film().category())\n       ).as(\u0026#34;categories\u0026#34;)\n           .convertFrom(r -\u0026gt; r.collect(Records.intoList()))\n   )\n   .from(ACTOR)\n   .fetch(Records.mapping(Actor::new));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIt’s really hard not to love this!\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eTime to upgrade to jOOQ 3.19! Path based implicit joins have been around for many years, since jOOQ 3.11. But now, with these 3 new features, you’ll love them even more!\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/explicit-path-join/\"\u003eExplicit path joins\u003c/a\u003e – To give fine-grained control over the join type, as well as make \u003ccode\u003eto-many\u003c/code\u003e path joins explicit\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-to-many-join/\"\u003eTo-many path joins\u003c/a\u003e – To navigate foreign keys from parent to children\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/3.19/manual/sql-building/sql-statements/select-statement/implicit-path-correlation/\"\u003eImplicit join path correlation\u003c/a\u003e – To greatly simplify all sorts of correlated subqueries\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://www.jooq.org/download/\" data-type=\"link\" data-id=\"https://www.jooq.org/download/\"\u003eGet jOOQ 3.19 now!\u003c/a\u003e\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2023-12-28T14:35:14Z",
  "modifiedTime": "2023-12-14T14:47:17Z"
}
