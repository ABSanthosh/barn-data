{
  "id": "43f37623-d191-4641-b957-32de2332a3fb",
  "title": "Gracefully Handling Third Party API Failures",
  "link": "https://stackabuse.com/gracefully-handling-third-party-api-failures/",
  "description": "Software isn't what it used to be. That's not necessarily a bad thing, but it does come with its own set of challenges. In the past, if you wanted to build a feature, you'd have to build it from scratch, without AI ðŸ˜± Fast forward from the dark ages of just",
  "author": "Scott Robinson",
  "published": "Thu, 13 Jun 2024 20:50:59 GMT",
  "source": "https://stackabuse.com/rss/",
  "categories": [
    "devops",
    "api"
  ],
  "byline": "Scott Robinson",
  "length": 8971,
  "excerpt": "Software isn't what it used to be. That's not necessarily a bad thing, but it does come with its own set of challenges. In the past, if you wanted to build a fe...",
  "siteName": "Stack Abuse",
  "favicon": "",
  "text": "Software isn't what it used to be. That's not necessarily a bad thing, but it does come with its own set of challenges. In the past, if you wanted to build a feature, you'd have to build it from scratch, without AI ðŸ˜± Fast forward from the dark ages of just a few years ago, and we have a plethora of third party APIs at our disposal that can help us build features faster and more efficiently than before. The Prevalence of Third Party APIs As software developers, we often go back and forth between \"I can build all of this myself\" and \"I need to outsource everything\" so we can deploy our app faster. Nowadays there really seems to be an API for just about everything: Auth Payments AI SMS Infrastructure Weather Translation The list goes on... (and on...) If it's something your app needs, there's a good chance there's an API for it. In fact, Rapid API, a popular API marketplace/hub, has over 50,000 APIs listed on their platform. 283 of those are for weather alone! There are even 4 different APIs for Disc Golf ðŸ˜³ But I digress... While we've done a great job of abstracting away the complexity of building apps and new features, we've also introduced a new set of problems: what happens when the API goes down? Handling API Down Time When you're building an app that relies on third party dependencies, you're essentially building a distributed system. You have your app, and you have the external resource you're calling. If the API goes down, your app is likely to be affected. How much it's affected depends on what the API does for you. So how do you handle this? There are a few strategies you can employ: Retry Mechanism One of the simplest ways to handle an API failure is to just retry the request. After all, this is the low-hanging fruit of error handling. If the API call failed, it might just be a busy server that dropped your request. If you retry it, it might go through. This is a good strategy for transient errors OpenAI's APIs, for example, are extremely popular and have a limited number of GPUs to service requests. So it's highly likely that delaying and retrying a few seconds later will work (depending on the error they sent back, of course). This can be done in a few different ways: Exponential backoff: Retry the request after a certain amount of time, and increase that time exponentially with each retry. Fixed backoff: Retry the request after a certain amount of time, and keep that time constant with each retry. Random backoff: Retry the request after a random amount of time, and keep that time random with each retry. You can also try varying the number of retries you attempt. Each of these configurations will depend on the API you're calling and if there are other strategies in place to handle the error. Here is a very simple retry mechanism in JavaScript: const delay = ms =\u003e { return new Promise(fulfill =\u003e { setTimeout(fulfill, ms); }); }; const callWithRetry = async (fn, {validate, retries=3, delay: delayMs=2000, logger}={}) =\u003e { let res = null; let err = null; for (let i = 0; i \u003c retries; i++) { try { res = await fn(); break; } catch (e) { err = e; if (!validate || validate(e)) { if (logger) logger.error(`Error calling fn: ${e.message} (retry ${i + 1} of ${retries})`); if (i \u003c retries - 1) await delay(delayMs); } } } if (err) throw err; return res; }; If the API you're accessing has a rate limit and your calls have exceeded that limit, then employing a retry strategy can be a good way to handle that. To tell if you're being rate limited, you can check the response headers for one or more of the following: X-RateLimit-Limit: The maximum number of requests you can make in a given time period. X-RateLimit-Remaining: The number of requests you have left in the current time period. X-RateLimit-Reset: The time at which the rate limit will reset. But the retry strategy is not a silver bullet, of course. If the API is down for an extended period of time, you'll just be hammering it with requests that will never go through, getting you nowhere. So what else can you do? Circuit Breaker Pattern The Circuit Breaker Pattern is a design pattern that can help you gracefully handle failures in distributed systems. It's a pattern that's been around for a while, and it's still relevant today. The idea is that you have a \"circuit breaker\" that monitors the state of the API you're calling. If the API is down, the circuit breaker will \"trip\" and stop sending requests to the API. This can help prevent your app from wasting time and resources on a service that's not available. When the circuit breaker trips, you can do a few things: Return a cached response Return a default response Return an error Here's a simple implementation of a circuit breaker in JavaScript: class CircuitBreaker { constructor({failureThreshold=3, successThreshold=2, timeout=5000}={}) { this.failureThreshold = failureThreshold; this.successThreshold = successThreshold; this.timeout = timeout; this.state = 'CLOSED'; this.failureCount = 0; this.successCount = 0; } async call(fn) { if (this.state === 'OPEN') { return this.handleOpenState(); } try { const res = await fn(); this.successCount++; if (this.successCount \u003e= this.successThreshold) { this.successCount = 0; this.failureCount = 0; this.state = 'CLOSED'; } return res; } catch (e) { this.failureCount++; if (this.failureCount \u003e= this.failureThreshold) { this.state = 'OPEN'; setTimeout(() =\u003e { this.state = 'HALF_OPEN'; }, this.timeout); } throw e; } } handleOpenState() { throw new Error('Circuit is open'); } } In this case, the open state will return a generic error, but you could easily modify it to return a cached response or a default response. Graceful Degradation Regardless of whether or not you use the previous error handling strategies, the most important thing is to ensure that your app can still function when the API is down and communicate issues with the user. This is known as \"graceful degradation.\" This means that your app should still be able to provide some level of service to the user, even if the API is down, and even if that just means you return an error to the end caller. Whether your service itself is an API, web app, mobile device, or something else, you should always have a fallback plan in place for when your third party dependencies are down. This could be as simple as returning a 503 status code, or as complex as returning a cached response, a default response, or a detailed error. Both the UI and transport layer should communicate these issues to the user so they can take action as necessary. What's more frustrating as an end user? An app that doesn't work and doesn't tell you why, or an app that doesn't work but tells you why and what you can do about it? Monitoring and Alerting Finally, it's important to monitor the health of the APIs you're calling. If you're using a third party API, you're at the mercy of that API's uptime. If it goes down, you need to know about it. You can use a service like Ping Bot to monitor the health of the API and alert you if it goes down. Check out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually learn it!Handling all of the error cases of a downed API can be difficult to do in testing and integration, so reviewing an API's past incidents and monitoring current incidents can help you understand both how reliable the resource is and where your app may fall short in handling those errors. With Ping Bot's uptime monitoring, you can see the current status and also look back at the historical uptime and details of your dependency's downtime, which can help you determine why your own app may have failed. You can also set up alerts to notify you when the API goes down, so you can take action as soon as it happens. Have Ping Bot send alerts to your email, Slack, Discord, or webhook to automatically alert your team and servers when an API goes down. Conclusion Third party APIs are a great way to build features quickly and efficiently, but they come with their own set of challenges. When the API goes down, your app is likely to be affected. By employing a retry mechanism, circuit breaker pattern, and graceful degradation, you can ensure that your app can still function when the API is down. Monitoring and alerting can help you stay on top of the health of the APIs you're calling, so you can take action as soon as they go down.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eSoftware isn\u0026#39;t what it used to be. That\u0026#39;s not necessarily a bad thing, but it does come with its own set of challenges. In the past, if you wanted to build a feature, you\u0026#39;d have to build it from scratch, \u003cstrong\u003ewithout AI\u003c/strong\u003e ðŸ˜± Fast forward from the dark ages of just a few years ago, and we have a plethora of third party APIs at our disposal that can help us build features faster and more efficiently than before.\u003c/p\u003e\n\u003ch2 id=\"theprevalenceofthirdpartyapis\"\u003eThe Prevalence of Third Party APIs\u003c/h2\u003e\n\u003cp\u003eAs software developers, we often go back and forth between \u0026#34;I can build all of this myself\u0026#34; and \u0026#34;I need to outsource \u003cem\u003eeverything\u003c/em\u003e\u0026#34; so we can deploy our app faster. Nowadays there really seems to be an API for just about everything:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAuth\u003c/li\u003e\n\u003cli\u003ePayments\u003c/li\u003e\n\u003cli\u003eAI\u003c/li\u003e\n\u003cli\u003eSMS\u003c/li\u003e\n\u003cli\u003eInfrastructure\u003c/li\u003e\n\u003cli\u003eWeather\u003c/li\u003e\n\u003cli\u003eTranslation\u003c/li\u003e\n\u003cli\u003eThe list goes on... (and on...)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf it\u0026#39;s something your app needs, there\u0026#39;s a good chance there\u0026#39;s an API for it. In fact, Rapid API, a popular API marketplace/hub, has over 50,000 APIs listed on their platform. 283 of those are for weather alone! There are even 4 different APIs for \u003cem\u003eDisc Golf\u003c/em\u003e ðŸ˜³ But I digress...\u003c/p\u003e\n\u003cp\u003eWhile we\u0026#39;ve done a great job of abstracting away the complexity of building apps and new features, we\u0026#39;ve also introduced a new set of problems: what happens when the API goes down?\u003c/p\u003e\n\u003ch2 id=\"handlingapidowntime\"\u003eHandling API Down Time\u003c/h2\u003e\n\u003cp\u003eWhen you\u0026#39;re building an app that relies on third party dependencies, you\u0026#39;re essentially building a distributed system. You have your app, and you have the external resource you\u0026#39;re calling. If the API goes down, your app is likely to be affected. How much it\u0026#39;s affected depends on what the API does for you. So how do you handle this? There are a few strategies you can employ:\u003c/p\u003e\n\u003ch3 id=\"retrymechanism\"\u003eRetry Mechanism\u003c/h3\u003e\n\u003cp\u003eOne of the simplest ways to handle an API failure is to just retry the request. After all, this is the low-hanging fruit of error handling. If the API call failed, it might just be a busy server that dropped your request. If you retry it, it might go through. This is a good strategy for transient errors\u003c/p\u003e\n\u003cp\u003eOpenAI\u0026#39;s APIs, for example, are extremely popular and have a limited number of GPUs to service requests. So it\u0026#39;s highly likely that delaying and retrying a few seconds later will work (depending on the error they sent back, of course).\u003c/p\u003e\n\u003cp\u003eThis can be done in a few different ways:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExponential backoff: Retry the request after a certain amount of time, and increase that time exponentially with each retry.\u003c/li\u003e\n\u003cli\u003eFixed backoff: Retry the request after a certain amount of time, and keep that time constant with each retry.\u003c/li\u003e\n\u003cli\u003eRandom backoff: Retry the request after a random amount of time, and keep that time random with each retry.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can also try varying the number of retries you attempt. Each of these configurations will depend on the API you\u0026#39;re calling and if there are other strategies in place to handle the error.\u003c/p\u003e\n\u003cp\u003eHere is a very simple retry mechanism in JavaScript:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e delay = \u003cspan\u003e\u003cspan\u003ems\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003ePromise\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003efulfill\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n        \u003cspan\u003esetTimeout\u003c/span\u003e(fulfill, ms);\n    });\n};\n\n\u003cspan\u003econst\u003c/span\u003e callWithRetry = \u003cspan\u003easync\u003c/span\u003e (fn, {validate, retries=\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003edelay\u003c/span\u003e: delayMs=\u003cspan\u003e2000\u003c/span\u003e, logger}={}) =\u0026gt; {\n    \u003cspan\u003elet\u003c/span\u003e res = \u003cspan\u003enull\u003c/span\u003e;\n    \u003cspan\u003elet\u003c/span\u003e err = \u003cspan\u003enull\u003c/span\u003e;\n    \u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003elet\u003c/span\u003e i = \u003cspan\u003e0\u003c/span\u003e; i \u0026lt; retries; i++) {\n        \u003cspan\u003etry\u003c/span\u003e {\n            res = \u003cspan\u003eawait\u003c/span\u003e fn();\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        } \u003cspan\u003ecatch\u003c/span\u003e (e) {\n            err = e;\n            \u003cspan\u003eif\u003c/span\u003e (!validate || validate(e)) {\n                \u003cspan\u003eif\u003c/span\u003e (logger) logger.error(\u003cspan\u003e`Error calling fn: \u003cspan\u003e${e.message}\u003c/span\u003e (retry \u003cspan\u003e${i + \u003cspan\u003e1\u003c/span\u003e}\u003c/span\u003e of \u003cspan\u003e${retries}\u003c/span\u003e)`\u003c/span\u003e);\n                \u003cspan\u003eif\u003c/span\u003e (i \u0026lt; retries - \u003cspan\u003e1\u003c/span\u003e) \u003cspan\u003eawait\u003c/span\u003e delay(delayMs);\n            }\n        }\n    }\n    \u003cspan\u003eif\u003c/span\u003e (err) \u003cspan\u003ethrow\u003c/span\u003e err;\n    \u003cspan\u003ereturn\u003c/span\u003e res;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the API you\u0026#39;re accessing has a rate limit and your calls have exceeded that limit, then employing a retry strategy can be a good way to handle that. To tell if you\u0026#39;re being rate limited, you can check the response headers for one or more of the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eX-RateLimit-Limit\u003c/code\u003e: The maximum number of requests you can make in a given time period.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eX-RateLimit-Remaining\u003c/code\u003e: The number of requests you have left in the current time period.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eX-RateLimit-Reset\u003c/code\u003e: The time at which the rate limit will reset.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut the retry strategy is not a silver bullet, of course. If the API is down for an extended period of time, you\u0026#39;ll just be hammering it with requests that will never go through, getting you nowhere. So what else can you do?\u003c/p\u003e\n\u003ch3 id=\"circuitbreakerpattern\"\u003eCircuit Breaker Pattern\u003c/h3\u003e\n\u003cp\u003eThe Circuit Breaker Pattern is a design pattern that can help you gracefully handle failures in distributed systems. It\u0026#39;s a pattern that\u0026#39;s been around for a while, and it\u0026#39;s still relevant today. The idea is that you have a \u0026#34;circuit breaker\u0026#34; that monitors the state of the API you\u0026#39;re calling. If the API is down, the circuit breaker will \u0026#34;trip\u0026#34; and stop sending requests to the API. This can help prevent your app from wasting time and resources on a service that\u0026#39;s not available.\u003c/p\u003e\n\u003cp\u003eWhen the circuit breaker trips, you can do a few things:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReturn a cached response\u003c/li\u003e\n\u003cli\u003eReturn a default response\u003c/li\u003e\n\u003cli\u003eReturn an error\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere\u0026#39;s a simple implementation of a circuit breaker in JavaScript:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCircuitBreaker\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan\u003e\u003cspan\u003econstructor\u003c/span\u003e(\u003cspan\u003e{failureThreshold=\u003cspan\u003e3\u003c/span\u003e, successThreshold=\u003cspan\u003e2\u003c/span\u003e, timeout=\u003cspan\u003e5000\u003c/span\u003e}={}\u003c/span\u003e)\u003c/span\u003e {\n        \u003cspan\u003ethis\u003c/span\u003e.failureThreshold = failureThreshold;\n        \u003cspan\u003ethis\u003c/span\u003e.successThreshold = successThreshold;\n        \u003cspan\u003ethis\u003c/span\u003e.timeout = timeout;\n        \u003cspan\u003ethis\u003c/span\u003e.state = \u003cspan\u003e\u0026#39;CLOSED\u0026#39;\u003c/span\u003e;\n        \u003cspan\u003ethis\u003c/span\u003e.failureCount = \u003cspan\u003e0\u003c/span\u003e;\n        \u003cspan\u003ethis\u003c/span\u003e.successCount = \u003cspan\u003e0\u003c/span\u003e;\n    }\n\n    \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ecall\u003c/span\u003e(\u003cspan\u003efn\u003c/span\u003e)\u003c/span\u003e {\n        \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003ethis\u003c/span\u003e.state === \u003cspan\u003e\u0026#39;OPEN\u0026#39;\u003c/span\u003e) {\n            \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e.handleOpenState();\n        }\n\n        \u003cspan\u003etry\u003c/span\u003e {\n            \u003cspan\u003econst\u003c/span\u003e res = \u003cspan\u003eawait\u003c/span\u003e fn();\n            \u003cspan\u003ethis\u003c/span\u003e.successCount++;\n            \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003ethis\u003c/span\u003e.successCount \u0026gt;= \u003cspan\u003ethis\u003c/span\u003e.successThreshold) {\n                \u003cspan\u003ethis\u003c/span\u003e.successCount = \u003cspan\u003e0\u003c/span\u003e;\n                \u003cspan\u003ethis\u003c/span\u003e.failureCount = \u003cspan\u003e0\u003c/span\u003e;\n                \u003cspan\u003ethis\u003c/span\u003e.state = \u003cspan\u003e\u0026#39;CLOSED\u0026#39;\u003c/span\u003e;\n            }\n            \u003cspan\u003ereturn\u003c/span\u003e res;\n        } \u003cspan\u003ecatch\u003c/span\u003e (e) {\n            \u003cspan\u003ethis\u003c/span\u003e.failureCount++;\n            \u003cspan\u003eif\u003c/span\u003e (\u003cspan\u003ethis\u003c/span\u003e.failureCount \u0026gt;= \u003cspan\u003ethis\u003c/span\u003e.failureThreshold) {\n                \u003cspan\u003ethis\u003c/span\u003e.state = \u003cspan\u003e\u0026#39;OPEN\u0026#39;\u003c/span\u003e;\n                \u003cspan\u003esetTimeout\u003c/span\u003e(\u003cspan\u003e() =\u0026gt;\u003c/span\u003e {\n                    \u003cspan\u003ethis\u003c/span\u003e.state = \u003cspan\u003e\u0026#39;HALF_OPEN\u0026#39;\u003c/span\u003e;\n                }, \u003cspan\u003ethis\u003c/span\u003e.timeout);\n            }\n            \u003cspan\u003ethrow\u003c/span\u003e e;\n        }\n    }\n\n    \u003cspan\u003e\u003cspan\u003ehandleOpenState\u003c/span\u003e(\u003cspan\u003e\u003c/span\u003e)\u003c/span\u003e {\n        \u003cspan\u003ethrow\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eError\u003c/span\u003e(\u003cspan\u003e\u0026#39;Circuit is open\u0026#39;\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this case, the open state will return a generic error, but you could easily modify it to return a cached response or a default response.\u003c/p\u003e\n\u003ch3 id=\"gracefuldegradation\"\u003eGraceful Degradation\u003c/h3\u003e\n\u003cp\u003eRegardless of whether or not you use the previous error handling strategies, the most important thing is to ensure that your app can still function when the API is down and communicate issues with the user. This is known as \u0026#34;graceful degradation.\u0026#34; This means that your app should still be able to provide some level of service to the user, even if the API is down, and even if that just means you return an error to the end caller.\u003c/p\u003e\n\u003cp\u003eWhether your service itself is an API, web app, mobile device, or something else, you should always have a fallback plan in place for when your third party dependencies are down. This could be as simple as returning a 503 status code, or as complex as returning a cached response, a default response, or a detailed error.\u003c/p\u003e\n\u003cp\u003eBoth the UI and transport layer should communicate these issues to the user so they can take action as necessary. What\u0026#39;s more frustrating as an end user? An app that doesn\u0026#39;t work and doesn\u0026#39;t tell you why, or an app that doesn\u0026#39;t work but tells you why and what you can do about it?\u003c/p\u003e\n\u003ch2 id=\"monitoringandalerting\"\u003eMonitoring and Alerting\u003c/h2\u003e\n\u003cp\u003eFinally, it\u0026#39;s important to monitor the health of the APIs you\u0026#39;re calling. If you\u0026#39;re using a third party API, you\u0026#39;re at the mercy of that API\u0026#39;s uptime. If it goes down, you need to know about it. You can use a service like \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://pingbot.dev/\"\u003ePing Bot\u003c/a\u003e to monitor the health of the API and alert you if it goes down.\u003c/p\u003e\n\u003cdiv data-nosnippet=\"\" id=\"ad-lead-magnet\"\u003e\u003cp\u003eCheck out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually \u003cem\u003elearn\u003c/em\u003e it!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHandling all of the error cases of a downed API can be difficult to do in testing and integration, so reviewing an API\u0026#39;s past incidents and monitoring current incidents can help you understand both how reliable the resource is and where your app may fall short in handling those errors.\u003c/p\u003e\n\n\u003cp\u003eWith Ping Bot\u0026#39;s \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://pingbot.dev/features/monitoring\"\u003euptime monitoring\u003c/a\u003e, you can see the current status and also look back at the historical uptime and details of your dependency\u0026#39;s downtime, which can help you determine why your own app may have failed.\u003c/p\u003e\n\u003cp\u003eYou can also set up alerts to notify you when the API goes down, so you can take action as soon as it happens. Have Ping Bot send alerts to your email, Slack, Discord, or webhook to automatically alert your team and servers when an API goes down.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThird party APIs are a great way to build features quickly and efficiently, but they come with their own set of challenges. When the API goes down, your app is likely to be affected. By employing a retry mechanism, circuit breaker pattern, and graceful degradation, you can ensure that your app can still function when the API is down. Monitoring and alerting can help you stay on top of the health of the APIs you\u0026#39;re calling, so you can take action as soon as they go down.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-06-13T20:50:59Z",
  "modifiedTime": "2024-06-13T20:55:21Z"
}
