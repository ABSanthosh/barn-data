{
  "id": "18967e84-7c1d-404c-91ce-67cb2f4e717a",
  "title": "Enhance build security and reach SLSA Level 3 with GitHub Artifact Attestations",
  "link": "https://github.blog/enterprise-software/devsecops/enhance-build-security-and-reach-slsa-level-3-with-github-artifact-attestations/",
  "description": "Learn how GitHub Artifact Attestations can enhance your build security and help your organization achieve SLSA Level 3. This post breaks down the basics of SLSA, explains the importance of artifact attestations, and provides a step-by-step guide to securing your build process. The post Enhance build security and reach SLSA Level 3 with GitHub Artifact Attestations appeared first on The GitHub Blog.",
  "author": "Kristina Heidinger",
  "published": "Thu, 19 Dec 2024 18:00:13 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "DevSecOps",
    "Enterprise software",
    "GitHub Artifact Attestations",
    "SLSA",
    "supply chain security"
  ],
  "byline": "Kristina Heidinger",
  "length": 12617,
  "excerpt": "Learn how GitHub Artifact Attestations can enhance your build security and help your organization achieve SLSA Level 3. This post breaks down the basics of SLSA, explains the importance of artifact attestations, and provides a step-by-step guide to securing your build process.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "The need for software build security is more pressing than ever. High-profile software supply chain attacks like SolarWinds, MOVEit, 3CX, and Applied Materials have revealed just how vulnerable the software build process can be. As attackers exploit weaknesses in the build pipeline to inject their malicious components, traditional security measures—like scanning source code, securing production environments and source control allow lists—are no longer enough. To defend against these sophisticated threats, organizations must treat their build systems with the same level of care and security as their production environments. These supply chain attacks are particularly dangerous because they can undermine trust in your business itself: if an attacker can infiltrate your build process, they can distribute compromised software to your customers, partners, and end-users. So, how can organizations secure their build processes, and ensure that what they ship is exactly what they intended to build? The Supply-chain Levels for Software Artifacts (SLSA) framework was developed to address these needs. SLSA provides a comprehensive, step-by-step methodology for building integrity and provenance guarantees into your software supply chain. This might sound complicated, but the good news is that GitHub Artifact Attestations simplify the journey to SLSA Level 3! In this post, we’ll break down what you need to know about SLSA, how Artifact Attestations work, and how they can boost your GitHub Actions build security to the next level. Securing your build process: An introduction to SLSA What is build security? When we build software, we convert source code into deployable artifacts—whether those are binaries, container images or packaged libraries. This transformation occurs through multiple stages, such as compilation, packaging and testing, each of which could potentially introduce vulnerabilities or malicious modifications. A properly secured build process can: Help ensure the integrity of your deployed artifacts by providing a higher level of assurance that the code has not been tampered with during the build process. Provide transparency into the build process, allowing you to audit the provenance of your deployed artifacts. Maintain confidentiality by safeguarding sensitive data and secrets used in the build process. By securing the build process, organizations can ensure that the software reaching end-users is the intended and unaltered version. This makes securing the build process just as important as securing the source code and deployment environments. Introducing SLSA: A framework for build security SLSA is a community-driven framework governed by the Open Source Security Foundation (OpenSSF), designed to help organizations systematically secure their software supply chains through a series of progressively stronger controls and best practices. The framework is organized into four levels, each representing a higher degree of security maturity: Level 0: No security guarantees Level 1: Provenance exists for traceability, but minimal tamper resistance Level 2: Provenance signed by a managed build platform, deterring simple tampering Level 3: Provenance from a hardened, tamper-resistant build platform, ensuring high security against compromise Provenance refers to the cryptographic record generated for each artifact, providing an unforgeable paper trail of its build history. This record allows you to trace artifacts back to their origins, allowing for verification of how, when and by whom the artifact was created. Why SLSA Level 3 matters for build security Achieving SLSA Level 3 is a critical step in building a secure and trustworthy software supply chain. This level requires organizations to implement rigorous standards for provenance and isolation, ensuring that artifacts are produced in a controlled and verifiable manner. An organization that has achieved SLSA Level 3 is capable of significantly mitigating the most common attack vectors targeting software build pipelines. Here’s a breakdown of the specific requirements for reaching SLSA Level 3: Provenance generation and availability: A detailed provenance record must be generated for each build, documenting how, when and by whom each artifact was produced. This provenance must be accessible to users for verification. Managed build system: Builds must take place on ephemeral build systems—short-lived, on-demand environments that are provisioned for each build in order to isolate builds from one another, reducing the risk of cross-contamination and unauthorized access. Restricted access to signing material: User-defined build steps should not have access to sensitive signing material to authenticate provenance, keeping signing operations separate and secure. GitHub Artifact Attestations help simplify your journey to SLSA Level 3 by enabling secure, automated build verification within your GitHub Actions workflows. While generating build provenance records is foundational to SLSA Level 1, the key distinction at SLSA Level 3 is the separation of the signature process from the rest of your build job. At Level 3, the signing happens on dedicated infrastructure, separated from the build workflow itself. The importance of verifying signatures While signing artifacts is a critical step, it becomes meaningless without verification. Simply having attestations does not provide any security advantages if they are not verified. Verification ensures that the signed artifacts are authentic and have not been tampered with. The GitHub CLI makes this process easy, allowing you to verify signatures at any stage of your CI/CD pipeline. For example, you can verify Terraform plans before applying them, ensure that Ansible or Salt configurations are authentic before deployment, validate containers before they are deployed to Kubernetes, or use it as part of a GitOps workflow driven by tools like Flux. GitHub offers several native ways to verify Artifact Attestations: GitHub CLI: This is the easiest way to verify signatures. Kubernetes Admission Controller: Use GitHub’s distribution of the admission controller for automated verification in Kubernetes environments. Offline verification: Download the attestations and verify them offline using the GitHub CLI for added security and flexibility in isolated environments. By verifying signatures during deployment, you can ensure that what you deploy to production is indeed what you built. Achieving SLSA Level 3 compliance with GitHub Artifact Attestations Reaching SLSA Level 3 may seem complex, but GitHub’s Artifact Attestations feature makes it remarkably straightforward. Generating build provenance puts you at SLSA Level 1, and by using GitHub Artifact Attestations on GitHub-hosted runners, you reach SLSA Level 2 by default. From this point, advancing to SLSA Level 3 is a straightforward journey! The critical difference between SLSA Level 2 and Level 3 lies in using a reusable workflow for provenance generation. This allows you to centrally enforce build security across all projects and enables stronger verification, as you can confirm that a specific reusable workflow was used for signing. With just a few lines of YAML added to your workflow, you can gain build provenance without the burden of managing cryptographic key material or setting up additional infrastructure. Build provenance made simple GitHub Artifact Attestations streamline the process of establishing provenance for your builds. By enabling provenance generation directly within GitHub Actions workflows, you ensure that each artifact includes a verifiable record of its build history. This level of transparency is crucial for SLSA Level 3 compliance. Best of all, you don’t need to worry about the onerous process of handling cryptographic key material. GitHub manages all of the required infrastructure, from running a Sigstore instance to serving as a root signing certificate authority for you. Check out our earlier blog to learn more about how to set up Artifact Attestations in your workflow. Secure signing with ephemeral machines GitHub Actions-hosted runners, executing workflows on ephemeral machines, ensure that each build process occurs in a clean and isolated environment. This model is fundamental for SLSA Level 3, which mandates secure and separate handling of key material used in signing. When you create a reusable workflow for provenance generation, your organization can use it centrally across all projects. This establishes a consistent, trusted source for provenance records. Additionally, signing occurs on dedicated hardware that is separate from the build machine, ensuring that neither the source code nor the developer triggering the build system can influence or alter the build process. With this level of separation, your workflows inherently meet SLSA Level 3 requirements. Below is an example of a reusable workflow that can be utilized across the organization to sign artifacts: name: Sign Artifact on: workflow_call: inputs: artifact-path: required: true type: string jobs: sign-artifact: runs-on: ubuntu-latest permissions: id-token: write attestations: write contents: read steps: - name: Attest Build Provenance uses: actions/attest-build-provenance@\u003cversion\u003e with: subject-path: ${{ inputs.artifact-path }} When you want to use this reusable workflow for signing in any other workflow, you can call it as follows: name: Sign Artifact Workflow on: push: branches: - main jobs: sign: runs-on: ubuntu-latest steps: - name: Sign Artifact uses: \u003crepository\u003e/.github/workflows/sign-artifact.yml@\u003cversion\u003e with: artifact-path: \"path/to/your-artifact.tar.gz\" This architecture of ephemeral environments and centralized provenance generation guarantees that signing operations are isolated from the build process itself, preventing unauthorized access to the signing process. By ensuring that signing occurs in a dedicated, controlled environment, the risk of compromising the signing workflow can be greatly reduced so that malicious actors can not tamper with the signing action’s code and deviate from the intended process. Additionally, provenance is generated consistently across all builds, providing a unified record of build history for the entire organization. To verify that an artifact was signed using this reusable workflow, you can use the GitHub CLI with the following command: gh artifact verify \u003cfile-path\u003e --signer-workflow \u003cowner\u003e/\u003crepository\u003e/.github/workflows/sign-artifact.yml This verification process ensures that the artifact was built and signed using the anticipated pipeline, reinforcing the integrity of your software supply chain. A more secure future GitHub Artifact Attestations bring the assurance and structure of SLSA Level 3 to your builds without having to manage additional security infrastructure. By simply adding a few lines of YAML and moving the provenance generation into a reusable workflow, you’re well on your way to achieving SLSA Level 3 compliance with ease! Ready to strengthen your build security and achieve SLSA Level 3? Start using GitHub Artifact Attestations today or explore our documentation to learn more. Tags: GitHub Artifact Attestations SLSA supply chain security Written by Senior Product Manager, GitHub Related posts Streamlining your MLOps pipeline with GitHub Actions and Arm64 runners Explore how Arm’s optimized performance and cost-efficient architecture, coupled with PyTorch, can enhance machine learning operations, from model training to deployment and learn how to leverage CI/CD for machine learning workflows, while reducing time, cost, and errors in the process. Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more Work at GitHub! Check out our current job openings. Apply now",
  "image": "https://github.blog/wp-content/uploads/2024/04/Enterprise-DarkMode-2-3.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eThe need for software build security is more pressing than ever. High-profile software supply chain attacks like \u003ca href=\"https://www.wired.com/story/the-untold-story-of-solarwinds-the-boldest-supply-chain-hack-ever/\"\u003eSolarWinds\u003c/a\u003e, \u003ca href=\"https://cyberint.com/blog/research/moveit-supply-chain-attack/\"\u003eMOVEit\u003c/a\u003e, \u003ca href=\"https://www.wired.com/story/3cx-supply-chain-attack-times-two/\"\u003e3CX\u003c/a\u003e, and \u003ca href=\"https://www.cpomagazine.com/cyber-security/major-semiconductor-firm-applied-materials-hit-by-supply-chain-attack-ransomware-impact-will-cost-250-million/\"\u003eApplied Materials\u003c/a\u003e have revealed just how vulnerable the software build process can be. As attackers exploit weaknesses in the build pipeline to inject their malicious components, traditional security measures—like scanning source code, securing production environments and source control allow lists—are no longer enough. To defend against these sophisticated threats, organizations must treat their build systems with the same level of care and security as their production environments.\u003c/p\u003e\n\u003cp\u003eThese supply chain attacks are particularly dangerous because they can undermine trust in your business itself: if an attacker can infiltrate your build process, they can distribute compromised software to your customers, partners, and end-users. So, how can organizations secure their build processes, and ensure that what they ship is exactly what they intended to build?\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://slsa.dev/spec/v1.0/levels\"\u003eSupply-chain Levels for Software Artifacts\u003c/a\u003e (SLSA) framework was developed to address these needs. SLSA provides a comprehensive, step-by-step methodology for building integrity and provenance guarantees into your software supply chain. This might sound complicated, but the good news is that GitHub Artifact Attestations simplify the journey to SLSA Level 3!\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll break down what you need to know about SLSA, how Artifact Attestations work, and how they can boost your GitHub Actions build security to the next level.\u003c/p\u003e\n\u003ch2 id=\"securing-your-build-process-an-introduction-to-slsa\" id=\"securing-your-build-process-an-introduction-to-slsa\"\u003eSecuring your build process: An introduction to SLSA\u003ca href=\"#securing-your-build-process-an-introduction-to-slsa\" aria-label=\"Securing your build process: An introduction to SLSA\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"what-is-build-security\" id=\"what-is-build-security\"\u003eWhat is build security?\u003ca href=\"#what-is-build-security\" aria-label=\"What is build security?\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhen we build software, we convert source code into deployable artifacts—whether those are binaries, container images or packaged libraries. This transformation occurs through multiple stages, such as compilation, packaging and testing, each of which could potentially introduce vulnerabilities or malicious modifications.\u003c/p\u003e\n\u003cp\u003eA properly secured build process can:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHelp ensure the integrity of your deployed artifacts\u003c/strong\u003e by providing a higher level of assurance that the code has not been tampered with during the build process.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProvide transparency into the build process\u003c/strong\u003e, allowing you to audit the provenance of your deployed artifacts.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintain confidentiality\u003c/strong\u003e by safeguarding sensitive data and secrets used in the build process.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy securing the build process, organizations can ensure that the software reaching end-users is the intended and unaltered version. \u003cstrong\u003eThis makes securing the build process just as important as securing the source code and deployment environments\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"introducing-slsa-a-framework-for-build-security\" id=\"introducing-slsa-a-framework-for-build-security\"\u003eIntroducing SLSA: A framework for build security\u003ca href=\"#introducing-slsa-a-framework-for-build-security\" aria-label=\"Introducing SLSA: A framework for build security\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://slsa.dev/spec/v1.0/levels\"\u003eSLSA \u003c/a\u003eis a community-driven framework governed by the \u003ca href=\"https://openssf.org/\"\u003eOpen Source Security Foundation (OpenSSF)\u003c/a\u003e, designed to help organizations systematically secure their software supply chains through a series of progressively stronger controls and best practices.\u003c/p\u003e\n\u003cp\u003eThe framework is organized into four levels, each representing a higher degree of security maturity:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLevel 0\u003c/strong\u003e: No security guarantees\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLevel 1\u003c/strong\u003e: Provenance exists for traceability, but minimal tamper resistance\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLevel 2\u003c/strong\u003e: Provenance signed by a managed build platform, deterring simple tampering\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLevel 3\u003c/strong\u003e: Provenance from a hardened, tamper-resistant build platform, ensuring high security against compromise\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eProvenance refers to the cryptographic record generated for each artifact, providing an unforgeable paper trail of its build history. This record allows you to trace artifacts back to their origins, allowing for verification of how, when and by whom the artifact was created.\u003c/p\u003e\n\u003ch2 id=\"why-slsa-level-3-matters-for-build-security\" id=\"why-slsa-level-3-matters-for-build-security\"\u003eWhy SLSA Level 3 matters for build security\u003ca href=\"#why-slsa-level-3-matters-for-build-security\" aria-label=\"Why SLSA Level 3 matters for build security\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAchieving \u003ca href=\"https://slsa.dev/spec/v1.0/levels#build-l3\"\u003eSLSA Level 3\u003c/a\u003e is a critical step in building a secure and trustworthy software supply chain. This level requires organizations to implement rigorous standards for provenance and isolation, ensuring that artifacts are produced in a controlled and verifiable manner. \u003cstrong\u003eAn organization that has achieved SLSA Level 3 is capable of significantly mitigating the most common attack vectors targeting software build pipelines.\u003c/strong\u003e Here’s a breakdown of the specific requirements for reaching SLSA Level 3:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProvenance generation and availability\u003c/strong\u003e: A detailed provenance record must be generated for each build, documenting how, when and by whom each artifact was produced. This provenance must be accessible to users for verification.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eManaged build system\u003c/strong\u003e: Builds must take place on ephemeral build systems—short-lived, on-demand environments that are provisioned for each build in order to isolate builds from one another, reducing the risk of cross-contamination and unauthorized access.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRestricted access to signing material\u003c/strong\u003e: User-defined build steps should not have access to sensitive signing material to authenticate provenance, keeping signing operations separate and secure.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds\"\u003eGitHub Artifact Attestations\u003c/a\u003e help simplify your journey to SLSA Level 3 by enabling secure, automated build verification within your GitHub Actions workflows. While generating build provenance records is foundational to SLSA Level 1, the key distinction at SLSA Level 3 is the separation of the signature process from the rest of your build job. At Level 3, the signing happens on dedicated infrastructure, separated from the build workflow itself.\u003c/p\u003e\n\u003ch2 id=\"the-importance-of-verifying-signatures\" id=\"the-importance-of-verifying-signatures\"\u003eThe importance of verifying signatures\u003ca href=\"#the-importance-of-verifying-signatures\" aria-label=\"The importance of verifying signatures\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhile signing artifacts is a critical step, it becomes meaningless without verification. Simply having attestations does not provide any security advantages if they are not verified. \u003cstrong\u003eVerification ensures that the signed artifacts are authentic and have not been tampered with\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://cli.github.com/\"\u003eGitHub CLI\u003c/a\u003e makes this process easy, allowing you to verify signatures at any stage of your CI/CD pipeline. For example, you can verify \u003ca href=\"https://developer.hashicorp.com/terraform\"\u003eTerraform\u003c/a\u003e plans before applying them, ensure that \u003ca href=\"https://docs.ansible.com/ansible/latest/reference_appendices/config.html\"\u003eAnsible\u003c/a\u003e or \u003ca href=\"https://docs.saltproject.io/en/latest/topics/states/index.html\"\u003eSalt\u003c/a\u003e configurations are authentic before deployment, validate containers before they are deployed to \u003ca href=\"https://kubernetes.io/\"\u003eKubernetes\u003c/a\u003e, or use it as part of a GitOps workflow driven by tools like \u003ca href=\"https://fluxcd.io/\"\u003eFlux\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGitHub offers several native ways to verify Artifact Attestations:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://cli.github.com/manual/gh_attestation_verify\"\u003eGitHub CLI\u003c/a\u003e\u003c/strong\u003e: This is the easiest way to verify signatures.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://docs.github.com/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller\"\u003eKubernetes Admission Controller\u003c/a\u003e\u003c/strong\u003e: Use GitHub’s distribution of the admission controller for automated verification in Kubernetes environments.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://docs.github.com/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline\"\u003eOffline verification\u003c/a\u003e\u003c/strong\u003e: Download the attestations and verify them offline using the GitHub CLI for added security and flexibility in isolated environments.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy verifying signatures during deployment, you can ensure that what you deploy to production is indeed what you built.\u003c/p\u003e\n\u003ch2 id=\"achieving-slsa-level-3-compliance-with-github-artifact-attestations\" id=\"achieving-slsa-level-3-compliance-with-github-artifact-attestations\"\u003eAchieving SLSA Level 3 compliance with GitHub Artifact Attestations\u003ca href=\"#achieving-slsa-level-3-compliance-with-github-artifact-attestations\" aria-label=\"Achieving SLSA Level 3 compliance with GitHub Artifact Attestations\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eReaching SLSA Level 3 may seem complex, but GitHub’s Artifact Attestations feature makes it remarkably straightforward. Generating build provenance puts you at \u003ca href=\"https://slsa.dev/spec/v1.0/levels#build-l1\"\u003eSLSA Level 1\u003c/a\u003e, and by using GitHub Artifact Attestations on GitHub-hosted runners, you reach \u003ca href=\"https://slsa.dev/spec/v1.0/levels#build-l2\"\u003eSLSA Level 2\u003c/a\u003e by default. From this point, advancing to \u003ca href=\"https://slsa.dev/spec/v1.0/levels#build-l3\"\u003eSLSA Level 3\u003c/a\u003e is a straightforward journey!\u003c/p\u003e\n\u003cp\u003eThe critical difference between SLSA Level 2 and Level 3 lies in using a \u003ca href=\"https://docs.github.com/actions/sharing-automations/reusing-workflows\"\u003ereusable workflow\u003c/a\u003e for provenance generation. This allows you to centrally enforce build security across all projects and enables stronger verification, as you can confirm that a \u003cstrong\u003especific\u003c/strong\u003e reusable workflow was used for signing. With just a few lines of YAML added to your workflow, you can gain build provenance without the burden of managing cryptographic key material or setting up additional infrastructure.\u003c/p\u003e\n\u003ch3 id=\"build-provenance-made-simple\" id=\"build-provenance-made-simple\"\u003eBuild provenance made simple\u003ca href=\"#build-provenance-made-simple\" aria-label=\"Build provenance made simple\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eGitHub Artifact Attestations streamline the process of establishing provenance for your builds. By enabling provenance generation directly within GitHub Actions workflows, you ensure that each artifact includes a verifiable record of its build history. This level of transparency is crucial for SLSA Level 3 compliance.\u003c/p\u003e\n\u003cp\u003eBest of all, you don’t need to worry about the onerous process of handling cryptographic key material. GitHub manages all of the required infrastructure, from running a \u003ca href=\"https://www.sigstore.dev/\"\u003eSigstore\u003c/a\u003e instance to serving as a root signing certificate authority for you.\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e\n  Check out \u003ca href=\"https://github.blog/news-insights/product-news/introducing-artifact-attestations-now-in-public-beta/\"\u003eour earlier blog\u003c/a\u003e to learn more about how to set up Artifact Attestations in your workflow.\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"secure-signing-with-ephemeral-machines\" id=\"secure-signing-with-ephemeral-machines\"\u003eSecure signing with ephemeral machines\u003ca href=\"#secure-signing-with-ephemeral-machines\" aria-label=\"Secure signing with ephemeral machines\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners\"\u003eGitHub Actions-hosted runners\u003c/a\u003e, executing workflows on ephemeral machines, ensure that each build process occurs in a clean and isolated environment. This model is fundamental for SLSA Level 3, which mandates secure and separate handling of key material used in signing.\u003c/p\u003e\n\u003cp\u003eWhen you create a \u003ca href=\"https://docs.github.com/actions/sharing-automations/reusing-workflows\"\u003ereusable workflow\u003c/a\u003e for provenance generation, your organization can use it centrally across all projects. This  establishes a consistent, trusted source for provenance records. Additionally, signing occurs on dedicated hardware that is separate from the build machine, ensuring that neither the source code nor the developer triggering the build system can influence or alter the build process. With this level of separation, your workflows inherently meet SLSA Level 3 requirements.\u003c/p\u003e\n\u003cp\u003eBelow is an example of a reusable workflow that can be utilized across the organization to sign artifacts:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Sign Artifact\n\non:\n  workflow_call:\n    inputs:\n      artifact-path:\n            required: true\n            type: string\n\njobs:\n  sign-artifact:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      attestations: write\n      contents: read\n\n    steps:\n    - name: Attest Build Provenance\n          uses: actions/attest-build-provenance@\u0026lt;version\u0026gt;\n          with:\n          subject-path: ${{ inputs.artifact-path }}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen you want to use this reusable workflow for signing in any other workflow, you can call it as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ename: Sign Artifact Workflow\n\non:\n  push:\n    branches:\n    - main\n\njobs:\n  sign:\n    runs-on: ubuntu-latest\n\n    steps:\n    - name: Sign Artifact\n          uses: \u0026lt;repository\u0026gt;/.github/workflows/sign-artifact.yml@\u0026lt;version\u0026gt;\n          with:\n            artifact-path: \u0026#34;path/to/your-artifact.tar.gz\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis architecture of ephemeral environments and centralized provenance generation guarantees that signing operations are isolated from the build process itself, preventing unauthorized access to the signing process. By ensuring that signing occurs in a dedicated, controlled environment, the risk of compromising the signing workflow can be greatly reduced so that malicious actors can not tamper with the signing action’s code and deviate from the intended process. Additionally, provenance is generated consistently across all builds, providing a unified record of build history for the entire organization.\u003c/p\u003e\n\u003cp\u003eTo verify that an artifact was signed using this reusable workflow, you can use the \u003ca href=\"https://cli.github.com/\"\u003eGitHub CLI\u003c/a\u003e with the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egh artifact verify \u0026lt;file-path\u0026gt; --signer-workflow \u0026lt;owner\u0026gt;/\u0026lt;repository\u0026gt;/.github/workflows/sign-artifact.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis verification process ensures that the artifact was built and signed using the anticipated pipeline, reinforcing the integrity of your software supply chain.\u003c/p\u003e\n\u003ch2 id=\"a-more-secure-future\" id=\"a-more-secure-future\"\u003eA more secure future\u003ca href=\"#a-more-secure-future\" aria-label=\"A more secure future\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGitHub Artifact Attestations bring the assurance and structure of SLSA Level 3 to your builds without having to manage additional security infrastructure. By simply adding a few lines of YAML and moving the provenance generation into a reusable workflow, you’re well on your way to achieving SLSA Level 3 compliance with ease!\u003c/p\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cstrong\u003eReady to strengthen your build security and achieve SLSA Level 3?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eStart using GitHub Artifact Attestations today or explore our \u003ca href=\"https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds\"\u003edocumentation\u003c/a\u003e to learn more.\u003c/p\u003e\n\u003c/div\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/github-artifact-attestations/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tGitHub Artifact Attestations\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/slsa/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tSLSA\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/supply-chain-security/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tsupply chain security\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/1447438?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/1447438?v=4\u0026amp;s=200\" alt=\"Kristina Heidinger\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSenior Product Manager, GitHub\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003csection\u003e\n\t\u003ch2\u003e\n\t\tRelated posts\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\n\t\t\t\t\u003ch3\u003e\n\t\t\t\u003ca href=\"https://github.blog/enterprise-software/ci-cd/streamlining-your-mlops-pipeline-with-github-actions-and-arm64-runners/\" target=\"_self\"\u003e\n\t\t\t\tStreamlining your MLOps pipeline with GitHub Actions and Arm64 runners\t\t\t\u003c/a\u003e\n\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eExplore how Arm’s optimized performance and cost-efficient architecture, coupled with PyTorch, can enhance machine learning operations, from model training to deployment and learn how to leverage CI/CD for machine learning workflows, while reducing time, cost, and errors in the process.\u003c/p\u003e\n\t\t\n\t\u003c/div\u003e\n\u003c/article\u003e\n\u003carticle\u003e\n\t\n\u003c/article\u003e\n\u003carticle\u003e\n\t\n\u003c/article\u003e\n\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.blog/developer-skills/github/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\"\u003e\u003cpath fill=\"currentColor\" d=\"M7.28033 3.21967C6.98744 2.92678 6.51256 2.92678 6.21967 3.21967C5.92678 3.51256 5.92678 3.98744 6.21967 4.28033L7.28033 3.21967ZM11 8L11.5303 8.53033C11.8232 8.23744 11.8232 7.76256 11.5303 7.46967L11 8ZM6.21967 11.7197C5.92678 12.0126 5.92678 12.4874 6.21967 12.7803C6.51256 13.0732 6.98744 13.0732 7.28033 12.7803L6.21967 11.7197ZM6.21967 4.28033L10.4697 8.53033L11.5303 7.46967L7.28033 3.21967L6.21967 4.28033ZM10.4697 7.46967L6.21967 11.7197L7.28033 12.7803L11.5303 8.53033L10.4697 7.46967Z\"\u003e\u003c/path\u003e\u003cpath stroke=\"currentColor\" d=\"M1.75 8H11\" stroke-width=\"1.5\" stroke-linecap=\"round\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2022/05/careers.svg\" width=\"44\" height=\"44\" alt=\"Work at GitHub!\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tWork at GitHub!\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eCheck out our current job openings.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Apply now; ref_location:bottom recirculation;\" href=\"https://www.github.careers/careers-home\" target=\"_blank\" aria-label=\"Apply now\"\u003e\n\t\t\t\t\tApply now\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-12-19T18:00:13Z",
  "modifiedTime": "2024-12-19T17:51:24Z"
}
