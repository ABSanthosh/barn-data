{
  "id": "8974d9ee-2bf7-4068-bff5-1786c07738ae",
  "title": "Highlights from Git 2.47",
  "link": "https://github.blog/open-source/git/highlights-from-git-2-47/",
  "description": "Git 2.47 is here, with features like incremental multi-pack indexes and more. Check out our coverage of some of the highlights here. The post Highlights from Git 2.47 appeared first on The GitHub Blog.",
  "author": "Taylor Blau",
  "published": "Mon, 07 Oct 2024 15:59:17 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Git",
    "Open Source"
  ],
  "byline": "Taylor Blau",
  "length": 12741,
  "excerpt": "Git 2.47 is here, with features like incremental multi-pack indexes and more. Check out our coverage of some of the highlights here.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "The open source Git project just released Git 2.47 with features and bug fixes from over 83 contributors, 28 of them new. We last caught up with you on the latest in Git back when 2.46 was released. To celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time. Incremental multi-pack indexes Returning readers of this series will no doubt remember our coverage of all things related to multi-pack indexes (MIDXs). If you’re new here, or could use a refresher, here’s a brief recap. Git stores objects (the blobs, trees, commits, and tags that make up your repository’s contents) in one of two formats: either loose or packed. Loose objects are the individual files stored in the two-character sub-directories of $GIT_DIR/objects, each representing a shard of the total set of loose objects. For instance, the object 08103b9f2b6e7fbed517a7e268e4e371d84a9a10 would be stored loose at $GIT_DIR/objects/08/103b9f2b6e7fbed517a7e268e4e371d84a9a10. Objects can also be packed together in a single file known as a packfile. Packfiles store multiple objects together in a binary format, which has a couple of advantages over storing objects loose. Packfiles often have better cache locality because similar objects are often packed next to or near each other. Packfiles also have the advantage of being able to represent objects as deltas of one another, enabling a more compact representation of pairs of similar objects. However, repositories can start to experience poor performance when they accumulate many packfiles, since Git has to search through each packfile to perform every object lookup. To improve performance when a repository accumulates too many packs, a repository must repack to generate a single new pack which contains the combined contents of all existing packs. This leaves the repository with only a single pack (resulting in faster lookup times), but the cost of generating that pack can be expensive. In Git 2.21, multi-pack indexes were introduced to mitigate this expense. MIDXs are an index mapping between objects to the pack and location within that pack at which they appear. Because MIDXs can store information about objects across multiple packs, they enable fast object lookups for repositories that have many individual packs, like so: Here the multi-pack index is shown as a series of colored rectangles, each representing an object. The arrows point to those objects’ location within the pack from which they were selected in the MIDX, and encode the information stored in the MIDX itself. But generating and updating the repository’s MIDX takes time, too: each object in the packs which are part of the MIDX need to be examined to record their object ID and offset within their source pack. This time can stretch even further if you are using multi-pack reachability bitmaps, since it adds a potentially large number of traversals covering significant portions of the repository to the runtime. So what is there to do? Repacking your repository to optimize object lookups can be slow, but so can updating your repository’s multi-pack index. Git 2.47 introduces a new experimental feature known as incremental multi-pack indexes, which allow storing more than one multi-pack index together in a chain of MIDX layers. Each layer contains packs and objects which are distinct from earlier layers, so the MIDX can be updated quickly via an append operation that only takes time proportional to the new objects being added, not the size of the overall MIDX. Here’s an example: The first half of the figure is the same as earlier, but the second half shows a new incremental layer in the multi-pack index chain. The objects contained in the MIDX on the second half are unique to the ones on the first half. But note that the source packs which appear in the MIDX on the second half have some overlap with the objects which appear in the MIDX on the first half. In Git 2.47, the incremental multi-pack index feature is still considered experimental, and doesn’t yet support multi-pack reachability bitmaps. But support for incremental multi-pack bitmaps is currently under review and will hopefully appear in a future release. (At GitHub, we plan to use incremental multi-pack bitmaps as part of further scaling efforts to support even larger repositories during repository maintenance. When we do, expect a blog post from us covering the details.) You can experiment with incremental multi-pack indexes by running: $ git multi-pack-index write --incremental to add new packs to your repository’s existing MIDX today. [source] Quickly find base branches with for-each-ref Have you ever been working on a branch, or spelunking through a new codebase and wondered to yourself, “what is this branch based on”? It’s a common question, but the answer can be surprisingly difficult to answer with the previously existing tools. A good approximation for determining what branch was the likely starting point for some commit C is to select the branch which minimizes the first-parent commits which are unique to C. (Here, “first parent commits” are the commits which are reachable by only walking through a merge commit’s first parent instead of traversing through all of its parents). If you’re wondering: “why limit the traversal to the first-parent history?”, the answer is because the first-parent history reflects the main path through history which leads up to a commit. By minimizing the number of unique first-parent commits among a set of candidate base branches, you are essentially searching for the one whose primary development path is closest to commit C. So the branch with the fewest unique first-parent commits is likely where C originated or was branched from. You might think that you could use something like git rev-list --count --first-parent to count the number of first-parent commits between two endpoints. But that’s not quite the case, since rev-list will remove all commits reachable from the base before returning the unique count. Git 2.47 introduces a new tool for figuring out which branch was the likely starting point for some commit via a new atom used in for-each-ref‘s --format specification. For example, let’s say I’m trying to figure out which branch name was picked for a topic I worked on upstream. $ needle=fcb2205b77470c60f996a3206b2d4aebf6e951e3 $ git for-each-ref --contains $needle refs/remotes/origin | wc -l 63 Naively searching for the set of branches which contain the thing I’m looking for can return many results, for example if my commit was merged and is now contained in many other branches. But the new %(is-base:) atom can produce the right answer: $ git for-each-ref --format=\"%(refname) %(is-base:$needle)\" refs/remotes/origin \\ | grep '(' refs/remotes/origin/tb/incremental-midx-part-1 (fcb2205b77470c60f996a3206b2d4aebf6e951e3) [source] Git is famously portable and compatible with a wide variety of systems and architectures, including some fairly exotic ones. But until this most recent release, Git has lacked a formal platform support policy. This release includes a new “Platform Support Policy” document which outlines Git’s official policy on the matter. The exact details can be found in the source link below, but the current gist is that platforms must have C99 or C11, use versions of dependencies which are stable or have long-term support, and must have an active security support system. Discussions about adding additional requirements, including possibly depending upon Rust in a future version, are ongoing. The policy also has suggestions for platform maintainers on which branches to test and how to report and fix compatibility issues. [source] A couple of releases ago, we discussed Git’s preliminary support for a new reference backend known as reftable. If you’re fuzzy on the details, our previous post is chock full of them. This release brings a number of unit tests which were written in the reftable implementation’s custom testing framework to Git’s standard unit test framework. These migrations were done by Chandra Pratap, one of the Git project’s Google Summer of Code (GSoC) contributors. This release also saw reftable gain better support when dealing with concurrent writers, particularly during stack compaction. The reftable backend also gained support for git for-each-ref’s –exclude option which we wrote about when Git 2.42 was released. [source, source, source, source, source, source, source, source, source, source, source, source] While we’re on the topic of unit testing, there were a number of other areas of the project which received more thorough unit test coverage, or migrated over existing test from Git’s Shell-based integration test suite. Git’s hashmap API, OID array, and urlmatch normalization features all were converted from Shell-based tests with custom helpers to unit tests. The unit test framework itself also received significant attention, ultimately resulting in using the Clar framework, which was originally written to replace the unit test framework in libgit2. Many of these unit test conversions were done by Ghanshyam Thakkar, another one of Git’s GSoC contributors. Congratulations, Ghanshyam! [source, source, source, source, source, source, source] While we’re on the topic of Google Summer of Code contributors, we should mention last (but not least!) another student, shejialuo, improved git fsck to check the reference storage backend for integrity in addition to the regular object store. They introduced a new git refs verify sub-command which is run through via git fsck, and catches many reference corruption issues. [source] Since at least 2019, there has been an effort to find and annotate unused parameters in functions across Git’s codebase. Annotating parameters as unused can help identify better APIs, and often the presence of an unused parameter can point out a legitimate bug in that function’s implementation. For many years, the Git project has sought to compile with -Wunused-parameter under its special DEVELOPER=1 mode, making it a compile-time error to have or introduce any unused parameters across the codebase. During that time, there have been many unused parameter cleanups and bug fixes, all done while working around other active development going on in related areas. In this release, that effort came to a close. Now when compiling with DEVELOPER=1, it is now a compile-time error to have unused parameters, making Git’s codebase cleaner and safer going forward. [source, source, source, source, source, source, source, source] Way back when Git 2.34 was released, we covered a burgeoning effort to find and fix memory leaks throughout the Git codebase. Back then, we wrote that since Git typically has a very short runtime, it is much less urgent to free memory than it is in, say, library code, since a process’s memory will be “freed” by the operating system when the process stops. But as Git internals continue to be reshaped with the eventual goal of having them be call-able as a first party library, plugging any memory leaks throughout the codebase is vitally important. That effort has continued in this release, with more leaks throughout the codebase being plugged. For all of the details, check out the source links below: [source, source, source, source] The git mergetool command learned a new tool configuration for Visual Studio Code. While it has always been possible to manually configure Git to run VSCode’s 3-way merge resolution, it required manual configuration. In Git 2.47, you can now easily configure your repository by running: $ git config set merge.tool vscode and subsequent runs of git mergetool will automatically open VSCode in the correct configuration. [source] The rest of the iceberg That’s just a sample of changes from the latest release. For more, check out the release notes for 2.47, or any previous version in the Git repository. Written by Taylor Blau is a Staff Software Engineer at GitHub where he works on Git. Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more GitHub Universe 2024 Get tickets to the 10th anniversary of our global developer event on AI, DevEx, and security. Get tickets",
  "image": "https://github.blog/wp-content/uploads/2024/10/image3.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eThe open source Git project just \u003ca href=\"https://lore.kernel.org/git/xmqqa5fg9bsz.fsf@gitster.g/T/#u\"\u003ereleased Git 2.47\u003c/a\u003e with features and bug fixes from over 83 contributors, 28 of them new. We last caught up with you on the latest in Git back when \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-46/\"\u003e2.46 was released\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time.\u003c/p\u003e\n\u003ch2 id=\"incremental-multi-pack-indexes\" id=\"incremental-multi-pack-indexes\"\u003eIncremental multi-pack indexes\u003ca href=\"#incremental-multi-pack-indexes\" aria-label=\"Incremental multi-pack indexes\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eReturning readers of this series will no doubt remember our coverage of all things related to multi-pack indexes (MIDXs). If you’re new here, or could use a refresher, here’s a brief recap.\u003c/p\u003e\n\u003cp\u003eGit stores objects (the blobs, trees, commits, and tags that make up your repository’s contents) in one of two formats: either loose or packed. Loose objects are the individual files stored in the two-character sub-directories of \u003ccode\u003e$GIT_DIR/objects\u003c/code\u003e, each representing a shard of the total set of loose objects. For instance, the object \u003ccode\u003e08103b9f2b6e7fbed517a7e268e4e371d84a9a10\u003c/code\u003e would be stored loose at \u003ccode\u003e$GIT_DIR/objects/08/103b9f2b6e7fbed517a7e268e4e371d84a9a10\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eObjects can also be packed together in a single file known as a \u003ca href=\"https://git-scm.com/book/en/v2/Git-Internals-Packfiles\"\u003epackfile\u003c/a\u003e. Packfiles store multiple objects together in a binary format, which has a couple of advantages over storing objects loose. Packfiles often have better \u003ca href=\"https://en.wikipedia.org/wiki/Locality_of_reference\"\u003ecache locality\u003c/a\u003e because similar objects are often packed next to or near each other. Packfiles also have the advantage of being able to represent objects as deltas of one another, enabling a more compact representation of pairs of similar objects.\u003c/p\u003e\n\u003cp\u003eHowever, repositories can start to experience poor performance when they accumulate many packfiles, since Git has to search through each packfile to perform every object lookup. To improve performance when a repository accumulates too many packs, a repository must repack to generate a single new pack which contains the combined contents of all existing packs. This leaves the repository with only a single pack (resulting in faster lookup times), but the cost of generating that pack can be expensive.\u003c/p\u003e\n\u003cp\u003eIn Git 2.21, \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-21/#multi-pack-indexes\"\u003emulti-pack indexes\u003c/a\u003e were introduced to mitigate this expense. MIDXs are an index mapping between objects to the pack and location within that pack at which they appear. Because MIDXs can store information about objects across multiple packs, they enable fast object lookups for repositories that have many individual packs, like so:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/10/image1.png?w=1024\u0026amp;resize=1024%2C453\" alt=\"non-incremental multi-pack index (MIDX) with objects in three packs\" width=\"1024\" height=\"453\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/10/image1.png?w=1999 1999w, https://github.blog/wp-content/uploads/2024/10/image1.png?w=300 300w, https://github.blog/wp-content/uploads/2024/10/image1.png?w=768 768w, https://github.blog/wp-content/uploads/2024/10/image1.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/10/image1.png?w=1536 1536w\" sizes=\"(max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eHere the multi-pack index is shown as a series of colored rectangles, each representing an object. The arrows point to those objects’ location within the pack from which they were selected in the MIDX, and encode the information stored in the MIDX itself.\u003c/p\u003e\n\u003cp\u003eBut generating and updating the repository’s MIDX takes time, too: each object in the packs which are part of the MIDX need to be examined to record their object ID and offset within their source pack. This time can stretch even further if you are using \u003ca href=\"https://github.blog/open-source/git/scaling-monorepo-maintenance/#multi-pack-bitmaps\"\u003emulti-pack reachability bitmaps\u003c/a\u003e, since it adds a potentially large number of traversals covering significant portions of the repository to the runtime.\u003c/p\u003e\n\u003cp\u003eSo what is there to do? Repacking your repository to optimize object lookups can be slow, but so can updating your repository’s multi-pack index.\u003c/p\u003e\n\u003cp\u003eGit 2.47 introduces a new experimental feature known as incremental multi-pack indexes, which allow storing more than one multi-pack index together in a chain of MIDX layers. Each layer contains packs and objects which are distinct from earlier layers, so the MIDX can be updated quickly via an append operation that only takes time proportional to the new objects being added, not the size of the overall MIDX. Here’s an example:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/10/image2.png?w=1024\u0026amp;resize=1024%2C793\" alt=\"incremental MIDX with two layers, describing objects in six unique packs)\" width=\"1024\" height=\"793\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/10/image2.png?w=1999 1999w, https://github.blog/wp-content/uploads/2024/10/image2.png?w=300 300w, https://github.blog/wp-content/uploads/2024/10/image2.png?w=768 768w, https://github.blog/wp-content/uploads/2024/10/image2.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/10/image2.png?w=1536 1536w\" sizes=\"(max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe first half of the figure is the same as earlier, but the second half shows a new incremental layer in the multi-pack index chain. The objects contained in the MIDX on the second half are unique to the ones on the first half. But note that the source packs which appear in the MIDX on the second half have some overlap with the objects which appear in the MIDX on the first half.\u003c/p\u003e\n\u003cp\u003eIn Git 2.47, the incremental multi-pack index feature is still considered experimental, and doesn’t yet support multi-pack reachability bitmaps. But support for incremental multi-pack bitmaps is currently \u003ca href=\"https://lore.kernel.org/git/cover.1723755667.git.me@ttaylorr.com/\"\u003eunder review\u003c/a\u003e and will hopefully appear in a future release.\u003c/p\u003e\n\u003cp\u003e(At GitHub, we plan to use incremental multi-pack bitmaps as part of further scaling efforts to support even larger repositories during repository maintenance. When we do, expect a blog post from us covering the details.)\u003c/p\u003e\n\u003cp\u003eYou can experiment with incremental multi-pack indexes by running:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git multi-pack-index write --incremental\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eto add new packs to your repository’s existing MIDX today.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/53129a06809fe64fb0baefdc19428bed5d929abe...fcb2205b77470c60f996a3206b2d4aebf6e951e3\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003ch2 id=\"quickly-find-base-branches-with-for-each-ref\" id=\"quickly-find-base-branches-with-for-each-ref\"\u003eQuickly find base branches with \u003ccode\u003efor-each-ref\u003c/code\u003e\u003ca href=\"#quickly-find-base-branches-with-for-each-ref\" aria-label=\"Quickly find base branches with \u0026lt;code\u0026gt;for-each-ref\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eHave you ever been working on a branch, or spelunking through a new codebase and wondered to yourself, “what is this branch based on”? It’s a common question, but the answer can be surprisingly difficult to answer with the previously existing tools.\u003c/p\u003e\n\u003cp\u003eA good approximation for determining what branch was the likely starting point for some commit C is to select the branch which minimizes the first-parent commits which are unique to C. (Here, “first parent commits” are the commits which are reachable by only walking through a merge commit’s first parent instead of traversing through all of its parents).\u003c/p\u003e\n\u003cp\u003eIf you’re wondering: “why limit the traversal to the first-parent history?”, the answer is because the first-parent history reflects the main path through history which leads up to a commit. By minimizing the number of unique first-parent commits among a set of candidate base branches, you are essentially searching for the one whose primary development path is closest to commit C. So the branch with the fewest unique first-parent commits is likely where C originated or was branched from.\u003c/p\u003e\n\u003cp\u003eYou might think that you could use something like \u003ccode\u003egit rev-list --count --first-parent\u003c/code\u003e to count the number of first-parent commits between two endpoints. But that’s not quite the case, since rev-list will remove all commits reachable from the base before returning the unique count.\u003c/p\u003e\n\u003cp\u003eGit 2.47 introduces a new tool for figuring out which branch was the likely starting point for some commit via a new atom used in \u003ccode\u003efor-each-ref\u003c/code\u003e‘s \u003ccode\u003e--format\u003c/code\u003e specification. For example, let’s say I’m trying to figure out which branch name was picked for a topic I worked on upstream.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ needle=fcb2205b77470c60f996a3206b2d4aebf6e951e3\n$ git for-each-ref --contains $needle refs/remotes/origin | wc -l\n63\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNaively searching for the set of branches which contain the thing I’m looking for can return many results, for example if my commit was merged and is now contained in many other branches. But the new \u003ccode\u003e%(is-base:\u003c/code\u003e) atom can produce the right answer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git for-each-ref --format=\u0026#34;%(refname) %(is-base:$needle)\u0026#34; refs/remotes/origin \\\n  | grep \u0026#39;(\u0026#39;\nrefs/remotes/origin/tb/incremental-midx-part-1 (fcb2205b77470c60f996a3206b2d4aebf6e951e3)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/3dd2a2feca6e47b2931dadadad44f92a35e8cf51...4b707a6e99651b1ba7c8718f95ee57c6721c85d6\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003chr/\u003e\n\u003cul\u003e\n\u003cli\u003eGit is famously portable and compatible with a wide variety of systems and architectures, including some fairly exotic ones. But until this most recent release, Git has lacked a formal platform support policy.\n\u003cp\u003eThis release includes a new “\u003ca href=\"https://github.com/git/git/blob/v2.47.0/Documentation/technical/platform-support.txt\"\u003ePlatform Support Policy\u003c/a\u003e” document which outlines Git’s official policy on the matter. The exact details can be found in the source link below, but the current gist is that platforms must have \u003ca href=\"https://en.wikipedia.org/wiki/C99\"\u003eC99\u003c/a\u003e or \u003ca href=\"https://en.wikipedia.org/wiki/C11_(C_standard_revision)\"\u003eC11\u003c/a\u003e, use versions of dependencies which are stable or have long-term support, and must have an active security support system. Discussions about adding additional requirements, including possibly depending upon Rust in a future version, are ongoing.\u003c/p\u003e\n\u003cp\u003eThe policy also has suggestions for platform maintainers on which branches to test and how to report and fix compatibility issues.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/a3d71f2076d423dd7d0e929ca213707336db0290...d53db106e0ffcaa82ab8336adc35d7e790d985cb\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA couple of releases ago, \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-45/#preliminary-reftable-support\"\u003ewe discussed\u003c/a\u003e Git’s preliminary support for a new reference backend known as \u003ca href=\"https://git-scm.com/docs/reftable\"\u003ereftable\u003c/a\u003e. If you’re fuzzy on the details, our previous post is chock full of them.\u003c/p\u003e\n\u003cp\u003eThis release brings a number of unit tests which were written in the reftable implementation’s custom testing framework to Git’s standard unit test framework. These migrations were done by Chandra Pratap, one of the Git project’s \u003ca href=\"https://summerofcode.withgoogle.com/programs/2024/projects/tlh611d7\"\u003eGoogle Summer of Code (GSoC) contributors\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis release also saw reftable gain better support when dealing with concurrent writers, particularly during stack compaction. The reftable backend also gained support for git for-each-ref’s –exclude option which we wrote about \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-42/#exclude-references-by-pattern-in-for-each-ref\"\u003ewhen Git 2.42 was released\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/c639478d794c4d3065d1ef6e98b87c7e74a6823b...18695250667912d8278e76dce453706c3d488173\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/ed155187b429a2a6b6475efe1767053df37ccfe1...2b14ced370aea017efc32b525fd72a6dd2cc60c5\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/dd903659cd54d4e21ca41b0c1f5d10b66763eb60...85da2a2ab62e24a8b9ff183fe3a451b445632487\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/d4d677704d74db389d2f56975794cd85acb8181f...08e83b5ec5db41dd01ce2af54ee67cb1d77e8a6e\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/17d4b10aea6bda2027047a0e3548a6f8ad667dde...e49d2472d2320d370b34c7fcdde933660c47968b\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/668843e6d8568b1054a55c4f3e8ee7c55acb5380...d2511eeae5fc679cf1b1591b3604e6abf5c056c2\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/5e56a39e6a9b8621e62f7a18ed027777a095dba7...5e440bf7f1884e79f345225e55fbe3ccabf42b5a\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/6891103f7206f2a46c579ec87f4f61482e377a27...6f1e9394e2e02d16dfbef02c1585a1acfd2a5118\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/2b9b229cb4e6097be538db18a0124d30215b3a30...f234df07f66c8f67391cc8ded5ade43b8a4428b6\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/61fd5de05fbb20b07a36b9f099dd86db7fa85db0...3a498b49d1b7d1ffc939b87310533a40ecbd8c43\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/6c3c451fb6e1c3ca83f74e63079d4d0af01b2d69...0dc84a806c53b02b465616d26efbca73682c58dd\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/468ebc52f3a8221e2f4863e0194059f113618273...9a1fb8af9887c99420f41a36667e4a7905d6266b\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhile we’re on the topic of unit testing, there were a number of other areas of the project which received more thorough unit test coverage, or migrated over existing test from Git’s Shell-based integration test suite.\u003c/p\u003e\n\u003cp\u003eGit’s hashmap API, OID array, and urlmatch normalization features all were converted from Shell-based tests with custom helpers to unit tests. The unit test framework itself also received significant attention, ultimately resulting in using the \u003ca href=\"https://github.com/clar-test/clar\"\u003eClar framework\u003c/a\u003e, which was originally written to replace the unit test framework in libgit2.\u003c/p\u003e\n\u003cp\u003eMany of these unit test conversions were done by Ghanshyam Thakkar, another one of Git’s \u003ca href=\"https://summerofcode.withgoogle.com/programs/2024/projects/e9C4rhrv\"\u003eGSoC contributors\u003c/a\u003e. Congratulations, Ghanshyam!\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/7644bb0aaa9f89cd5d523cbecfd9d87d890b4cb9...8afda42fce60126fe6d3bde86a44d8db63a77c08\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/3fb745257b30a643ee78c9a7c52ab107c82e4745...c3de556a841f132832f742d1c4d3a2618ee3b355\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/63b5fcdde90361195f7f6ade199c90d91e2ecf53...a680635e05848f4428b4867b7e7ad0e07c94ae8b\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/029c870ab55434ad90652a4b82b1616679ea17be...05026637f3ed0787f15c27da9142896596cc6873\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/b9849e4f7631d80f146d159bf7b60263b3205632...9ddec6b79af6786bc628e66a75f47040fea1857b\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/f6df5e2d05eae0c0c425b9be9f05be63f3823856...3469a23659d8197190d2765cf9f31dec5ab602fa\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/406f326d271e0bacecdb00425422c5fa3f314930...6e71d6ac7cb575d04c452762662b00a89cd0b0db\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhile we’re on the topic of Google Summer of Code contributors, we should mention last (but not least!) another student, \u003ca href=\"https://summerofcode.withgoogle.com/programs/2024/projects/ukm4PTEF\"\u003eshejialuo\u003c/a\u003e, improved \u003ccode\u003egit fsck\u003c/code\u003e to check the reference storage backend for integrity in addition to the regular object store. They introduced a new \u003ccode\u003egit refs verify\u003c/code\u003e sub-command which is run through via \u003ccode\u003egit fsck\u003c/code\u003e, and catches many reference corruption issues.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/87a1768b93a67d0420255a43d9e07387b2e805ad...1c31be45b3b263670c7d2a91c27cc119b77dd2e2\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSince \u003ca href=\"https://github.com/git/git/compare/fa2f2f085ed8999b799d48e652f9e438571e8491...61b0fcbb64d00d52290d433c1e754c01740b3d19\"\u003eat least 2019\u003c/a\u003e, there has been an effort to find and annotate unused parameters in functions across Git’s codebase. Annotating parameters as unused can help identify better APIs, and often the presence of an unused parameter can point out a legitimate bug in that function’s implementation.\u003c/p\u003e\n\u003cp\u003eFor many years, the Git project has sought to compile with \u003ccode\u003e-Wunused-parameter\u003c/code\u003e under its special \u003ccode\u003eDEVELOPER=1\u003c/code\u003e mode, making it a compile-time error to have or introduce any unused parameters across the codebase. During that time, there have been many unused parameter cleanups and bug fixes, all done while working around other active development going on in related areas.\u003c/p\u003e\n\u003cp\u003eIn this release, that effort came to a close. Now when compiling with \u003ccode\u003eDEVELOPER=1\u003c/code\u003e, it is now a compile-time error to have unused parameters, making Git’s codebase cleaner and safer going forward.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/a6dce0afc3f26428721deaa6267a89141b5d5a5e...d4dc0efd7d4b71acadae61f619b9e84f97d15c83\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/21c66081ca726f300296a5c6d29088caf8740417...516a9ec3d5874aad41757e573f7b841bb45cb098\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/4476304a06e6dad284e0d75245cd32f01a01a8c7...ab8bcd2dbd2f4e820d3bfb3d79b123655c52561b\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/5ecd5fa58b3315d6bdd6ef9218c7ae442782bc5d...a051ca5e650138230f3dd61bda911f0f409ebf23\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/6dcb2db0fa20cbad961ebdc8414ce4f9246d8c2b...a61bc8879eaade17eccec2a22693501480843db1\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/2ff26d228600848ecf3d44b3796beee310ebcccf...a6bcb3ca010ed47d26dfa5d5d221f91a46887c2f\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/1f4d89dfce80e17e6d9939b93391a8ba3885f750...72c9793c154edbde16085f0f04db970e082c7f0b\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/bb9c16bd4f1a9a00799e10c81ee6506cf468c0c7...1784522a1f3d35195c2c28137ed49f36caa5022e\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWay back \u003ca href=\"https://github.blog/open-source/git/highlights-from-git-2-34/\"\u003ewhen Git 2.34 was released\u003c/a\u003e, we covered a burgeoning effort to find and fix memory leaks throughout the Git codebase. Back then, we wrote that since Git typically has a very short runtime, it is much less urgent to free memory than it is in, say, library code, since a process’s memory will be “freed” by the operating system when the process stops.\u003c/p\u003e\n\u003cp\u003eBut as Git internals continue to be reshaped with the eventual goal of having them be call-able as a first party library, plugging any memory leaks throughout the codebase is vitally important.\u003c/p\u003e\n\u003cp\u003eThat effort has continued in this release, with more leaks throughout the codebase being plugged. For all of the details, check out the source links below:\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/2b800ec45e53051c41a85900009430704bfdf031...46f6ca2a68e02dd68132ed0b64cd55a8b6569e29\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/f123c19e72190e666fbcd827924fd1f090a9d6ae...13b23d2da552b9476a0025562bc4ab8954d5be45\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/3a7362eb9fad0c4838f5cfaa95ed3c51a4c18d93...77d4b3dd73c44b2c617345a6d9686d2f7f5b8a68\"\u003esource\u003c/a\u003e, \u003ca href=\"https://github.com/git/git/compare/25673b1c476756ec0587fb0596ab3c22b96dc52a...f30bfafcd41d0f13575361957dc361aa2be4d4c5\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003egit mergetool\u003c/code\u003e command learned a new tool configuration for Visual Studio Code. While it \u003ca href=\"https://github.com/microsoft/vscode/issues/5770#issuecomment-1188658476\"\u003ehas always been possible\u003c/a\u003e to manually configure Git to run VSCode’s 3-way merge resolution, it required manual configuration.\u003c/p\u003e\n\u003cp\u003eIn Git 2.47, you can now easily configure your repository by running:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git config set merge.tool vscode\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand subsequent runs of git mergetool will automatically open VSCode in the correct configuration.\u003c/p\u003e\n\u003cp\u003e[\u003ca href=\"https://github.com/git/git/compare/f4806a9a3e2640f2df1c3f092a50c834f4e4f2e6...6b77283f5e7fffcc74c032f2e692aaab1ddbe58a\"\u003esource\u003c/a\u003e]\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-rest-of-the-iceberg\" id=\"the-rest-of-the-iceberg\"\u003eThe rest of the iceberg\u003ca href=\"#the-rest-of-the-iceberg\" aria-label=\"The rest of the iceberg\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThat’s just a sample of changes from the latest release. For more, check out the release notes for \u003ca href=\"https://github.com/git/git/blob/v2.47.0/Documentation/RelNotes/2.47.0.txt\"\u003e2.47\u003c/a\u003e, or \u003ca href=\"https://github.com/git/git/tree/v2.47.0/Documentation/RelNotes\"\u003eany previous version\u003c/a\u003e in \u003ca href=\"https://github.com/git/git\"\u003ethe Git repository\u003c/a\u003e.\u003c/p\u003e\n\n\t\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/443245?v=4\u0026amp;s=200\" alt=\"Taylor Blau\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eTaylor Blau is a Staff Software Engineer at GitHub where he works on Git.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.blog/developer-skills/github/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\"\u003e\u003cpath fill=\"currentColor\" d=\"M7.28033 3.21967C6.98744 2.92678 6.51256 2.92678 6.21967 3.21967C5.92678 3.51256 5.92678 3.98744 6.21967 4.28033L7.28033 3.21967ZM11 8L11.5303 8.53033C11.8232 8.23744 11.8232 7.76256 11.5303 7.46967L11 8ZM6.21967 11.7197C5.92678 12.0126 5.92678 12.4874 6.21967 12.7803C6.51256 13.0732 6.98744 13.0732 7.28033 12.7803L6.21967 11.7197ZM6.21967 4.28033L10.4697 8.53033L11.5303 7.46967L7.28033 3.21967L6.21967 4.28033ZM10.4697 7.46967L6.21967 11.7197L7.28033 12.7803L11.5303 8.53033L10.4697 7.46967Z\"\u003e\u003c/path\u003e\u003cpath stroke=\"currentColor\" d=\"M1.75 8H11\" stroke-width=\"1.5\" stroke-linecap=\"round\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/04/Icon.svg\" width=\"44\" height=\"44\" alt=\"GitHub Universe 2024\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub Universe 2024\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eGet tickets to the 10th anniversary of our global developer event on AI, DevEx, and security.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Get tickets; ref_location:bottom recirculation;\" href=\"https://githubuniverse.com/?utm_source=Blog\u0026amp;utm_medium=GitHub\u0026amp;utm_campaign=blog-module\" target=\"_blank\" aria-label=\"Get tickets\"\u003e\n\t\t\t\t\tGet tickets\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-10-07T15:59:17Z",
  "modifiedTime": "2024-10-09T16:19:32Z"
}
