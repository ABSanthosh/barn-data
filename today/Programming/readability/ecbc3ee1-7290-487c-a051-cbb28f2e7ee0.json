{
  "id": "ecbc3ee1-7290-487c-a051-cbb28f2e7ee0",
  "title": "Considerations for making a tree view component accessible",
  "link": "https://github.blog/engineering/user-experience/considerations-for-making-a-tree-view-component-accessible/",
  "description": "A deep dive on the work that went into making the component that powers repository and pull request file trees. The post Considerations for making a tree view component accessible appeared first on The GitHub Blog.",
  "author": "Eric Bailey",
  "published": "Tue, 28 Jan 2025 17:00:39 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Engineering",
    "User experience",
    "accessibility",
    "APG",
    "ARIA",
    "Assistive Technology",
    "Components",
    "Primer",
    "Screen Readers",
    "Tree View",
    "WCAG"
  ],
  "byline": "Eric Bailey",
  "length": 13569,
  "excerpt": "A deep dive on the work that went into making the component that powers repository and pull request file trees.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Tree views are a core part of the GitHub experience. You’ve encountered one if you’ve ever navigated through a repository’s file structure or reviewed a pull request. On GitHub, a tree view is the list of folders and the files they contain. It is analogous to the directory structure your operating system uses as a way of organizing things. Tree views are notoriously difficult to implement in an accessible way. This post is a deep dive into some of the major considerations that went into how we made GitHub’s tree view component accessible. We hope that it can be used as a reference and help others. Start with Windows It’s important to have components with complex interaction requirements map to something people are already familiar with using. This allows for responsiveness to the keypresses they will try to navigate and take action on our tree view instances. We elected to adopt Windows File Explorer’s tree view implementation, given the prominence of Windows’ usage for desktop screen reader users. Navigating and taking actions on items in Windows’ tree view using NVDA and JAWS helped us get a better understanding of how things worked, including factors such as focus management, keyboard shortcuts, and expected assistive technology announcements. Then maybe reference the APG The ARIA Authoring Practices Guide (APG) is a bit of an odd artifact. It looks official but is no longer recognized by the W3C as a formal document. This is to say that the APG can serve as a helpful high-level resource for things to consider for your overall approach, but its suggestions for code necessitate deeper scrutiny. Build from a solid, semantic foundation At its core, a tree view is a list of lists. Because of this, we used ul and li elements for parent and child nodes: \u003cul\u003e \u003cli\u003e \u003cul\u003e \u003cli\u003e.github/\u003c/li\u003e \u003cli\u003esource/\u003c/li\u003e \u003cli\u003etest/\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003e.gitignore\u003c/li\u003e \u003cli\u003eREADME.md\u003c/li\u003e \u003c/ul\u003e There are a few reasons for doing this, but the main considerations are: Better assurance that a meaningful accessibility tree is generated, Lessening the work we need for future maintenance, and consequential re-verification that our updates continue to work properly, and Better guaranteed interoperability between different browsers, apps, and other technologies. NOTE: GitHub currently does not virtualize its file trees. We would need to revisit this architectural decision if this ever changes. Better broad assistive technology support The more complicated an interactive pattern is, the greater the risk that there are bugs or gaps with assistive technology support. Given the size of the audience GitHub serves, it’s important that we consider more than just majority share assistive technology considerations. We found that utilizing semantic HTML elements also performed better for some less-common assistive technologies. This was especially relevant with some lower-power devices, like an entry-level Android smartphone from 2021. Better Forced Color Mode support Semantic HTML elements also map to native operating system UI patterns, meaning that Forced Color Mode’s heuristics will recognize them without any additional effort. This is helpful for people who rely on the mode to see screen content. The heuristic mapping behavior does not occur if we used semantically neutral div or span elements, and would have to be manually recreated and maintained. A composite widget allows a component that contains multiple interactive elements to only require one tab stop unless someone chooses to interact with it further. Consider a file tree for a repository that contains 500+ files in 20+ directories. Without a composite widget treatment, someone may have to press Tab far too many times to bypass the file tree component and get what they need. Think about wrapping it in a landmark Like using a composite widget, landmark regions help some people quickly and efficiently navigate through larger overall sections of the page. Because of this, we wrapped the entire file tree in a nav landmark element. This does not mean every tree view component should be a landmark, however! We made this decision for the file tree because it is frequently interacted with as a way to navigate through a repository’s content. Go with a roving tabindex approach A roving tabindex is a technique that uses tabindex=\"-1\" applied to each element in a series, and then updates the tabindex value to use 0 instead in response to user keyboard input. This allows someone to traverse the series of elements, as focus “roves” to follow their keypresses. \u003cli tabindex=\"-1\"\u003eFile 1\u003c/li\u003e \u003cli tabindex=\"-1\"\u003eFile 2\u003c/li\u003e \u003cli tabindex=\"0\"\u003eFile 3\u003c/li\u003e \u003cli tabindex=\"-1\"\u003eFile 4\u003c/li\u003e The roving tabindex approach performed better than utilizing aria-activedescendant, which had issues with VoiceOver on macOS and iOS. Enhance with ARIA We use a considered set of ARIA declarations to build off our semantic foundation. Note that while we intentionally started with semantic HTML, there are certain ARIA declarations that are needed. The use of ARIA here is necessary and intentional, as it expands the capabilities of HTML to describe something that HTML alone cannot describe—a tree view construct. Our overall approach follows what the APG suggests, in that we use the following: role=\"tree\" is placed on the parent ul element, to communicate that it is a tree view construct. role=\"treeitem\" is placed on the child li elements, to communicate that they are tree view nodes. role=\"group\" is declared on child ul elements, to communicate that they contain branch and leaf nodes. aria-expanded is declared on directories, with a value of true to communicate that the branch node is in an opened state and a value of false to communicate that it is in a collapsed state instead. aria-selected is used to indicate if branch or leaf nodes have been chosen by user navigation, and can therefore have user actions applied to them. We also made the following additions: aria-hidden=\"true\" is applied to SVG icons (folders, files, etc.) to ensure its content is not announced. aria-current=\"true\" is placed on the selected node to better support when a node is deep linked to via URL. NOTE: We use “branch node” and “leaf node” as broad terms that can apply to all tree view components we use on GitHub. For the file tree, branch nodes would correspond to directories and subdirectories, and leaf nodes would correspond to files. Support expected navigation techniques The following behaviors are what people will try when operating a tree view construct, so we support them: Keyboard keypresses Tab: Places focus on the entire tree view component, then moves focus to the next focusable item on the view. Enter: If a branch node is selected: Displays the directory’s contents. If a leaf node is selected: Displays the leaf node’s contents. Down: Moves selection to the next node that can be selected without opening or closing a node. Up: Moves selection to the previous node that can be selected without opening or closing a node. Right: If a branch node is selected and in a collapsed state: Expands the selected collapsed branch node and does not move selection. If a branch node is selected and in an expanded state: Moves selection to the directory’s first child node. Left: If a branch node is selected and in an expanded state: Collapses the selected collapsed directory node and does not move selection. If a branch node is selected and in a collapsed state: Moves selection to the node’s parent directory. If a leaf node is selected: Moves selection to the leaf node’s parent directory. End: Moves selection to the last node that can be selected. Home: Moves selection to the first node that can be selected. We also support typeahead selection, as we are modeling Windows File Explorer’s tree view behaviors. Here, we move selection to the node closest to the currently selected node whose name matches what the user types. Middle clicking Nodes on tree view constructs are tree items, not links. Because of this, tree view nodes do not support the behaviors you get with using an anchor element, such as opening its URL in a new tab or window. We use JavaScript to listen for middle clicks and Control+Enter keypresses to replicate this behavior. Consider states Loading Tree views on GitHub can take time to retrieve their content, and we may not always know how much content a branch node contains. Live region announcements are tricky to get right, but integral to creating an equivalent experience. We use the following announcements: If there is a known amount of nodes that load, we enumerate the incoming content with an announcement that reads, “Loading {x} items.” If there is an unknown number of nodes that load, we instead use a more generic announcement of, “Loading…” If there are no nodes that load we use an announcement message that reads, “{branch node name} is empty.” Additionally, we manage focus for loading content: If focus is placed on a placeholder loading node when the content loads in: Move focus from the placeholder node to the first child node in the branch node. If focus is on a placeholder loading node but the branch node does not contain content: Move focus back to the branch node. Additionally, we remove the branch node’s aria-expanded declaration. Errors Circumstances can conspire to interfere with a tree view component’s intended behavior. Examples of this could be a branch node failing to retrieve content or a partial system outage. In these scenarios, the tree view component will use a straightforward dialog component to communicate the error. Fix interoperability issues As previously touched on, complicated interaction patterns run the risk of compatibility issues. Because of this, it’s essential to test your efforts with actual assistive technology to ensure it actually works. We made the following adjustments to provide better assistive technology support: Use aria-level Screen readers can report on the depth of a nested list item. For example, a li element placed inside of a ul element nested three levels deep can announce itself as such. We found that we needed to explicitly declare the level on each li element to recreate this behavior for a tree view. For our example, we’d also need to set aria-level=\"3\" on the li element. This fix addressed multiple forms of assistive technology we tested with. Explicitly set the node’s accessible name on the li element A node’s accessible name is typically set by the text string placed inside the li element: \u003cli\u003eREADME.md\u003c/li\u003e However, we found that VoiceOver on macOS and iOS did not support this. This may be because of the relative complexity of each node’s inner DOM structure. We used aria-labelledby to get around this problem, with a value that pointed to the id set on the text portion of each node: \u003cli aria-labelledby=\"readme-md\"\u003e \u003cdiv\u003e \u003c!-- Icon --\u003e \u003c/div\u003e \u003cdiv id=\"readme-md\"\u003e README.md \u003c/div\u003e \u003c/li\u003e This guarantees that: the node’s accessible name is announced when focus is placed on the li element, and that the announcement matches what is shown visually. Where we’d like to go from here There’s a couple areas we’re prototyping and iterating on to better serve our users: Supporting links inside a node Browsers apply a lot of behaviors to anchor elements, such as the ability to copy the URL. We’d like to replace the JavaScript that listens for middle clicks with a more robust native solution, only without sacrificing interoperability and assistive technology support. Supporting multiple actions per node Tree views constructs were designed assuming a user will only ever navigate to a node and activate it. GitHub has use cases that require actions other than activating the node, and we’re exploring how to accomplish that. This is exciting, as it represents an opportunity to evolve the tree view construct on the web. Always learning An accessible tree view is a complicated component to make, and it requires a lot of effort and testing to get right. However, this work helps to ensure that everyone can use a core part of GitHub, regardless of device, circumstance, or ability. We hope that highlighting the considerations that went into our work can help you on your accessibility journey. Share your experience: We’d love to hear from you if you’ve run into issues using our tree view component with assistive technology. This feedback is invaluable to helping us continue to make GitHub more accessible. Tags: accessibility APG ARIA Assistive Technology Components Primer Screen Readers Tree View WCAG Written by Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more Work at GitHub! Check out our current job openings. Apply now",
  "image": "https://github.blog/wp-content/uploads/2024/02/AI-DarkMode-3-1.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eTree views are a core part of the GitHub experience. You’ve encountered one if you’ve ever navigated through a repository’s file structure or reviewed a pull request.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=1024\u0026amp;resize=1024%2C653\" alt=\"Browsing files on Primer\u0026#39;s design repository. A tree view showing the repositories directory structure occupies a quarter of the screen. The other three quarters are taken up by the content of the content subdirectory. The tree view shows expanded and collapsed directories, as well as files nested at multiple levels of depth.\" width=\"1024\" height=\"653\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=2544 2544w, https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/01/github-repo-browser.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eOn GitHub, a tree view is the list of folders and the files they contain. It is analogous to the directory structure your operating system uses as a way of organizing things.\u003c/p\u003e\n\u003cp\u003eTree views are notoriously difficult to implement in an accessible way. This post is a deep dive into some of the major considerations that went into how we made \u003ca href=\"https://primer.style/components/tree-view\"\u003eGitHub’s tree view component\u003c/a\u003e accessible. We hope that it can be used as a reference and help others.\u003c/p\u003e\n\u003ch2 id=\"start-with-windows\" id=\"start-with-windows\"\u003eStart with Windows\u003ca href=\"#start-with-windows\" aria-label=\"Start with Windows\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIt’s important to have components with complex interaction requirements \u003cstrong\u003emap to something people are already familiar with using\u003c/strong\u003e. This allows for responsiveness to the keypresses they will try to navigate and take action on our tree view instances.\u003c/p\u003e\n\u003cp\u003eWe elected to adopt Windows File Explorer’s tree view implementation, given \u003ca href=\"https://webaim.org/projects/screenreadersurvey9/#os\"\u003ethe prominence of Windows’ usage\u003c/a\u003e for desktop screen reader users.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=1024\u0026amp;resize=1024%2C783\" alt=\"A Windows 11 File Explorer window showing a tree view and a list of subdirectories that one of its folders contains. The tree view demonstrates how the C drive contains multiple nested folders to organize its content.\" width=\"1024\" height=\"783\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=1744 1744w, https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=768 768w, https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/01/windows-file-explorer.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eNavigating and taking actions on items in Windows’ tree view using \u003ca href=\"https://www.nvaccess.org/\"\u003eNVDA\u003c/a\u003e and \u003ca href=\"https://www.freedomscientific.com/products/software/jaws/\"\u003eJAWS\u003c/a\u003e helped us get a better understanding of how things worked, including factors such as focus management, keyboard shortcuts, and expected assistive technology announcements.\u003c/p\u003e\n\u003ch2 id=\"then-maybe-reference-the-apg\" id=\"then-maybe-reference-the-apg\"\u003eThen maybe reference the APG\u003ca href=\"#then-maybe-reference-the-apg\" aria-label=\"Then maybe reference the APG\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/\"\u003eARIA Authoring Practices Guide (APG)\u003c/a\u003e is a bit of an odd artifact. It looks official but is no \u003ca href=\"https://lists.w3.org/Archives/Public/public-wai-announce/2022AprJun/0003.html\"\u003elonger recognized by the W3C as a formal document\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis is to say that the APG can serve as a helpful high-level resource for things to consider for your overall approach, but its suggestions for code necessitate deeper scrutiny.\u003c/p\u003e\n\u003ch2 id=\"build-from-a-solid-semantic-foundation\" id=\"build-from-a-solid-semantic-foundation\"\u003eBuild from a solid, semantic foundation\u003ca href=\"#build-from-a-solid-semantic-foundation\" aria-label=\"Build from a solid, semantic foundation\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAt its core, a tree view is a list of lists. Because of this, we used \u003ccode\u003eul\u003c/code\u003e and \u003ccode\u003eli\u003c/code\u003e elements for parent and child nodes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;ul\u0026gt;\n  \u0026lt;li\u0026gt;\n    \u0026lt;ul\u0026gt;\n      \u0026lt;li\u0026gt;.github/\u0026lt;/li\u0026gt;\n      \u0026lt;li\u0026gt;source/\u0026lt;/li\u0026gt;\n      \u0026lt;li\u0026gt;test/\u0026lt;/li\u0026gt;\n    \u0026lt;/ul\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;.gitignore\u0026lt;/li\u0026gt;\n  \u0026lt;li\u0026gt;README.md\u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are a few reasons for doing this, but the main considerations are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBetter assurance that \u003ca href=\"https://alistapart.com/article/semantics-to-screen-readers/\"\u003ea meaningful accessibility tree is generated\u003c/a\u003e,  \u003c/li\u003e\n\u003cli\u003eLessening the work we need for future maintenance, and consequential re-verification that our updates continue to work properly, and  \u003c/li\u003e\n\u003cli\u003eBetter guaranteed interoperability between different browsers, apps, and other technologies.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: GitHub currently does not virtualize its file trees. We would need to revisit this architectural decision if this ever changes.\u003c/p\u003e\n\u003ch3 id=\"better-broad-assistive-technology-support\" id=\"better-broad-assistive-technology-support\"\u003eBetter broad assistive technology support\u003ca href=\"#better-broad-assistive-technology-support\" aria-label=\"Better broad assistive technology support\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe more complicated an interactive pattern is, the greater the risk that there are \u003ca href=\"https://www.a11yproject.com/posts/aria-has-perfect-support/#compatibility-issues\"\u003ebugs or gaps with assistive technology support\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGiven the size of the audience GitHub serves, it’s important that we consider more than just \u003ca href=\"https://webaim.org/projects/screenreadersurvey10/#primary\"\u003emajority share assistive technology\u003c/a\u003e considerations.\u003c/p\u003e\n\u003cp\u003eWe found that utilizing semantic HTML elements also performed better for some less-common assistive technologies. This was especially relevant with some lower-power devices, like an entry-level Android smartphone from 2021.\u003c/p\u003e\n\u003ch3 id=\"better-forced-color-mode-support\" id=\"better-forced-color-mode-support\"\u003eBetter Forced Color Mode support\u003ca href=\"#better-forced-color-mode-support\" aria-label=\"Better Forced Color Mode support\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSemantic HTML elements also map to native operating system UI patterns, meaning that \u003ca href=\"https://blogs.windows.com/msedgedev/2020/09/17/styling-for-windows-high-contrast-with-new-standards-for-forced-colors/\"\u003eForced Color Mode\u003c/a\u003e’s heuristics will recognize them without any additional effort. This is helpful for people who rely on the mode to see screen content.\u003c/p\u003e\n\u003cp\u003eThe heuristic mapping behavior does not occur if we used semantically neutral \u003ccode\u003ediv\u003c/code\u003e or \u003ccode\u003espan\u003c/code\u003e elements, and would have to be manually recreated and maintained.\u003c/p\u003e\n\n\u003cp\u003eA \u003ca href=\"https://w3c.github.io/aria/#composite\"\u003ecomposite widget\u003c/a\u003e allows a component that contains multiple interactive elements to only require one tab stop unless someone chooses to interact with it further.\u003c/p\u003e\n\u003cp\u003eConsider a file tree for a repository that contains 500+ files in 20+ directories. Without a composite widget treatment, someone may have to press \u003ckbd\u003eTab\u003c/kbd\u003e far too many times to bypass the file tree component and get what they need.\u003c/p\u003e\n\u003ch2 id=\"think-about-wrapping-it-in-a-landmark\" id=\"think-about-wrapping-it-in-a-landmark\"\u003eThink about wrapping it in a landmark\u003ca href=\"#think-about-wrapping-it-in-a-landmark\" aria-label=\"Think about wrapping it in a landmark\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLike using a composite widget, \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/\"\u003elandmark regions\u003c/a\u003e help some people quickly and efficiently navigate through larger overall sections of the page. Because of this, we wrapped the entire file tree in a \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/practices/landmark-regions/\"\u003e\u003ccode\u003enav\u003c/code\u003e landmark element\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis does not mean every tree view component should be a landmark, however! We made this decision for the file tree because it is frequently interacted with as \u003ca href=\"https://www.w3.org/WAI/WCAG22/Understanding/multiple-ways.html\"\u003ea way to navigate through a repository’s content\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"go-with-a-roving-tabindex-approach\" id=\"go-with-a-roving-tabindex-approach\"\u003eGo with a roving \u003ccode\u003etabindex\u003c/code\u003e approach\u003ca href=\"#go-with-a-roving-tabindex-approach\" aria-label=\"Go with a roving \u0026lt;code\u0026gt;tabindex\u0026lt;/code\u0026gt; approach\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_roving_tabindex\"\u003eroving tabindex\u003c/a\u003e is a technique that uses \u003ccode\u003etabindex=\u0026#34;-1\u0026#34;\u003c/code\u003e applied to each element in a series, and then updates the \u003ccode\u003etabindex\u003c/code\u003e value to use \u003ccode\u003e0\u003c/code\u003e instead in response to user keyboard input. This allows someone to traverse the series of elements, as focus “roves” to follow their keypresses.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;li tabindex=\u0026#34;-1\u0026#34;\u0026gt;File 1\u0026lt;/li\u0026gt;\n\u0026lt;li tabindex=\u0026#34;-1\u0026#34;\u0026gt;File 2\u0026lt;/li\u0026gt;\n\u0026lt;li tabindex=\u0026#34;0\u0026#34;\u0026gt;File 3\u0026lt;/li\u0026gt;\n\u0026lt;li tabindex=\u0026#34;-1\u0026#34;\u0026gt;File 4\u0026lt;/li\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe roving \u003ccode\u003etabindex\u003c/code\u003e approach performed better than \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant\"\u003eutilizing \u003ccode\u003earia-activedescendant\u003c/code\u003e\u003c/a\u003e, which had issues with VoiceOver on macOS and iOS.\u003c/p\u003e\n\u003ch2 id=\"enhance-with-aria\" id=\"enhance-with-aria\"\u003eEnhance with ARIA\u003ca href=\"#enhance-with-aria\" aria-label=\"Enhance with ARIA\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe use a considered set of \u003ca href=\"https://w3c.github.io/aria/\"\u003eARIA\u003c/a\u003e declarations to build off our semantic foundation.\u003c/p\u003e\n\u003cp\u003eNote that while we intentionally started with semantic HTML, there are certain ARIA declarations that are needed. The use of ARIA here is necessary and intentional, as it expands the capabilities of HTML to describe something that HTML alone cannot describe—a tree view construct.\u003c/p\u003e\n\u003cp\u003eOur overall approach follows \u003ca href=\"https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#wai-ariaroles,states,andproperties\"\u003ewhat the APG suggests\u003c/a\u003e, in that we use the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erole=\u0026#34;tree\u0026#34;\u003c/code\u003e is placed on the parent \u003ccode\u003eul\u003c/code\u003e element, to communicate that it is a tree view construct.  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erole=\u0026#34;treeitem\u0026#34;\u003c/code\u003e is placed on the child \u003ccode\u003eli\u003c/code\u003e elements, to communicate that they are tree view nodes.  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erole=\u0026#34;group\u0026#34;\u003c/code\u003e is declared on child \u003ccode\u003eul\u003c/code\u003e elements, to communicate that they contain branch and leaf nodes.  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earia-expanded\u003c/code\u003e is declared on directories, with a value of \u003ccode\u003etrue\u003c/code\u003e to communicate that the branch node is in an opened state and a value of \u003ccode\u003efalse\u003c/code\u003e to communicate that it is in a collapsed state instead.  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earia-selected\u003c/code\u003e is used to indicate if branch or leaf nodes have been chosen by user navigation, and can therefore have user actions applied to them.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also made the following additions:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003earia-hidden=\u0026#34;true\u0026#34;\u003c/code\u003e is applied to SVG icons (folders, files, etc.) to ensure its content is not announced.  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earia-current=\u0026#34;true\u0026#34;\u003c/code\u003e is placed on the selected node to better support when a node is deep linked to via URL.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: We use “branch node” and “leaf node” as broad terms that can apply to all tree view components we use on GitHub. For the file tree, branch nodes would correspond to directories and subdirectories, and leaf nodes would correspond to files.\u003c/p\u003e\n\u003ch2 id=\"support-expected-navigation-techniques\" id=\"support-expected-navigation-techniques\"\u003eSupport expected navigation techniques\u003ca href=\"#support-expected-navigation-techniques\" aria-label=\"Support expected navigation techniques\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe following behaviors are what people will try when operating a tree view construct, so we support them:\u003c/p\u003e\n\u003ch3 id=\"keyboard-keypresses\" id=\"keyboard-keypresses\"\u003eKeyboard keypresses\u003ca href=\"#keyboard-keypresses\" aria-label=\"Keyboard keypresses\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ckbd\u003eTab\u003c/kbd\u003e: Places focus on the entire tree view component, then moves focus to the next focusable item on the view.  \u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eEnter\u003c/kbd\u003e:\n\u003cul\u003e\n\u003cli\u003eIf a branch node is selected: Displays the directory’s contents.  \u003c/li\u003e\n\u003cli\u003eIf a leaf node is selected: Displays the leaf node’s contents.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eDown\u003c/kbd\u003e: Moves selection to the next node that can be selected without opening or closing a node.  \u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eUp\u003c/kbd\u003e: Moves selection to the previous node that can be selected without opening or closing a node.  \u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eRight\u003c/kbd\u003e:\n\u003cul\u003e\n\u003cli\u003eIf a branch node is selected and in a collapsed state: Expands the selected collapsed branch node and does not move selection.  \u003c/li\u003e\n\u003cli\u003eIf a branch node is selected and in an expanded state: Moves selection to the directory’s first child node.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eLeft\u003c/kbd\u003e:\n\u003cul\u003e\n\u003cli\u003eIf a branch node is selected and in an expanded state: Collapses the selected collapsed directory node and does not move selection.  \u003c/li\u003e\n\u003cli\u003eIf a branch node is selected and in a collapsed state: Moves selection to the node’s parent directory.  \u003c/li\u003e\n\u003cli\u003eIf a leaf node is selected: Moves selection to the leaf node’s parent directory.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eEnd\u003c/kbd\u003e: Moves selection to the last node that can be selected.  \u003c/li\u003e\n\u003cli\u003e\u003ckbd\u003eHome\u003c/kbd\u003e: Moves selection to the first node that can be selected.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also support \u003cstrong\u003etypeahead selection\u003c/strong\u003e, as we are modeling Windows File Explorer’s tree view behaviors. Here, we move selection to the node closest to the currently selected node whose name matches what the user types.\u003c/p\u003e\n\u003ch3 id=\"middle-clicking\" id=\"middle-clicking\"\u003eMiddle clicking\u003ca href=\"#middle-clicking\" aria-label=\"Middle clicking\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNodes on tree view constructs are \u003ca href=\"https://w3c.github.io/aria/#treeitem\"\u003etree items\u003c/a\u003e, not links. Because of this, tree view nodes do not support the behaviors you get with using an anchor element, such as opening its URL in a new tab or window.\u003c/p\u003e\n\u003cp\u003eWe use JavaScript to listen for middle clicks and \u003ckbd\u003eControl\u003c/kbd\u003e+\u003ckbd\u003eEnter\u003c/kbd\u003e keypresses to replicate this behavior.\u003c/p\u003e\n\u003ch2 id=\"consider-states\" id=\"consider-states\"\u003eConsider states\u003ca href=\"#consider-states\" aria-label=\"Consider states\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"loading\" id=\"loading\"\u003eLoading\u003ca href=\"#loading\" aria-label=\"Loading\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTree views on GitHub can take time to retrieve their content, and we may not always know how much content a branch node contains.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2025/01/tree-view-loading-nodes.png?w=890\u0026amp;resize=890%2C282\" alt=\"A directory called, \u0026#39;src\u0026#39; that is selected and in an expanded that. It contains a single leaf node that contains a loading spinner with a label of \u0026#39;Loading…\u0026#34;.\" width=\"890\" height=\"282\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2025/01/tree-view-loading-nodes.png?w=890 890w, https://github.blog/wp-content/uploads/2025/01/tree-view-loading-nodes.png?w=300 300w, https://github.blog/wp-content/uploads/2025/01/tree-view-loading-nodes.png?w=768 768w\" sizes=\"auto, (max-width: 890px) 100vw, 890px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.w3.org/TR/wai-aria-1.3/#dfn-live-region\"\u003eLive region\u003c/a\u003e announcements are \u003ca href=\"https://tetralogical.com/blog/2024/05/01/why-are-my-live-regions-not-working/\"\u003etricky to get right\u003c/a\u003e, but integral to creating an equivalent experience. We use the following announcements:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf there is a known amount of nodes that load, we enumerate the incoming content with an announcement that reads, “Loading {x} items.”  \u003c/li\u003e\n\u003cli\u003eIf there is an unknown number of nodes that load, we instead use a more generic announcement of, “Loading…”  \u003c/li\u003e\n\u003cli\u003eIf there are no nodes that load we use an announcement message that reads, “{branch node name} is empty.”\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, we \u003ca href=\"https://primer.style/guides/accessibility/focus-management\"\u003emanage focus\u003c/a\u003e for loading content:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf focus is placed on a placeholder loading node when the content loads in: Move focus from the placeholder node to the first child node in the branch node.   \u003c/li\u003e\n\u003cli\u003eIf focus is on a placeholder loading node but the branch node does not contain content: Move focus back to the branch node. Additionally, we remove the branch node’s \u003ccode\u003earia-expanded\u003c/code\u003e declaration.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"errors\" id=\"errors\"\u003eErrors\u003ca href=\"#errors\" aria-label=\"Errors\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCircumstances can conspire to interfere with a tree view component’s intended behavior. Examples of this could be a branch node failing to retrieve content or a \u003ca href=\"https://primer.style/ui-patterns/degraded-experiences\"\u003epartial system outage\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn these scenarios, the tree view component will use a straightforward \u003ca href=\"https://primer.style/components/dialog\"\u003edialog component\u003c/a\u003e to communicate the error.\u003c/p\u003e\n\u003ch2 id=\"fix-interoperability-issues\" id=\"fix-interoperability-issues\"\u003eFix interoperability issues\u003ca href=\"#fix-interoperability-issues\" aria-label=\"Fix interoperability issues\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAs previously touched on, complicated interaction patterns run the risk of compatibility issues. Because of this, it’s essential to test your efforts with actual assistive technology to \u003cstrong\u003eensure it actually works\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWe made the following adjustments to provide better assistive technology support:\u003c/p\u003e\n\u003ch3 id=\"use-aria-level\" id=\"use-aria-level\"\u003eUse \u003ccode\u003earia-level\u003c/code\u003e\u003ca href=\"#use-aria-level\" aria-label=\"Use \u0026lt;code\u0026gt;aria-level\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eScreen readers can report on the depth of a nested list item. For example, a \u003ccode\u003eli\u003c/code\u003e element placed inside of a \u003ccode\u003eul\u003c/code\u003e element nested three levels deep can announce itself as such.\u003c/p\u003e\n\u003cp\u003eWe found that we needed to explicitly declare the level on each \u003ccode\u003eli\u003c/code\u003e element to recreate this behavior for a tree view. For our example, we’d also need to set \u003ccode\u003earia-level=\u0026#34;3\u0026#34;\u003c/code\u003e on the \u003ccode\u003eli\u003c/code\u003e element.\u003c/p\u003e\n\u003cp\u003eThis fix addressed multiple forms of assistive technology we tested with.\u003c/p\u003e\n\u003ch3 id=\"explicitly-set-the-nodes-accessible-name-on-the-li-element\" id=\"explicitly-set-the-nodes-accessible-name-on-the-li-element\"\u003eExplicitly set the node’s accessible name on the \u003ccode\u003eli\u003c/code\u003e element\u003ca href=\"#explicitly-set-the-nodes-accessible-name-on-the-li-element\" aria-label=\"Explicitly set the node’s accessible name on the \u0026lt;code\u0026gt;li\u0026lt;/code\u0026gt; element\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA node’s \u003ca href=\"https://sarahmhigley.com/writing/whats-in-a-name/\"\u003eaccessible name\u003c/a\u003e is typically set by the text string placed inside the \u003ccode\u003eli\u003c/code\u003e element:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;li\u0026gt;README.md\u0026lt;/li\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, we found that \u003ca href=\"https://support.apple.com/guide/voiceover/get-started-vo4be8816d70/10/mac/15.0\"\u003eVoiceOver on macOS\u003c/a\u003e and \u003ca href=\"https://support.apple.com/guide/iphone/turn-on-and-practice-voiceover-iph3e2e415f/ios\"\u003eiOS\u003c/a\u003e did not support this. This may be because of the relative complexity of each node’s inner DOM structure.\u003c/p\u003e\n\u003cp\u003eWe used \u003ccode\u003earia-labelledby\u003c/code\u003e to get around this problem, with a value that pointed to the \u003ccode\u003eid\u003c/code\u003e set on the text portion of each node:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;li aria-labelledby=\u0026#34;readme-md\u0026#34;\u0026gt;\n  \u0026lt;div\u0026gt;\n   \u0026lt;!-- Icon --\u0026gt;\n  \u0026lt;/div\u0026gt;\n  \u0026lt;div id=\u0026#34;readme-md\u0026#34;\u0026gt;\n    README.md\n  \u0026lt;/div\u0026gt;\n\u0026lt;/li\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis guarantees that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe node’s accessible name is announced when focus is placed on the \u003ccode\u003eli\u003c/code\u003e element,   \u003c/li\u003e\n\u003cli\u003eand that the announcement matches what is shown visually.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"where-wed-like-to-go-from-here\" id=\"where-wed-like-to-go-from-here\"\u003eWhere we’d like to go from here\u003ca href=\"#where-wed-like-to-go-from-here\" aria-label=\"Where we’d like to go from here\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere’s a couple areas we’re prototyping and iterating on to better serve our users:\u003c/p\u003e\n\u003ch3 id=\"supporting-links-inside-a-node\" id=\"supporting-links-inside-a-node\"\u003eSupporting links inside a node\u003ca href=\"#supporting-links-inside-a-node\" aria-label=\"Supporting links inside a node\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBrowsers apply a lot of behaviors to anchor elements, such as the ability to copy the URL.\u003c/p\u003e\n\u003cp\u003eWe’d like to replace the JavaScript that listens for middle clicks with a more robust native solution, only without sacrificing interoperability and assistive technology support.\u003c/p\u003e\n\u003ch3 id=\"supporting-multiple-actions-per-node\" id=\"supporting-multiple-actions-per-node\"\u003eSupporting multiple actions per node\u003ca href=\"#supporting-multiple-actions-per-node\" aria-label=\"Supporting multiple actions per node\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTree views constructs were designed assuming a user will only ever navigate to a node and activate it.\u003c/p\u003e\n\u003cp\u003eGitHub has use cases that require actions other than activating the node, and we’re exploring how to accomplish that. This is exciting, as it represents an opportunity to evolve the tree view construct on the web.\u003c/p\u003e\n\u003ch2 id=\"always-learning\" id=\"always-learning\"\u003eAlways learning\u003ca href=\"#always-learning\" aria-label=\"Always learning\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAn accessible tree view is a complicated component to make, and it requires a lot of effort and testing to get right. However, this work helps to ensure that everyone can use a core part of GitHub, regardless of device, circumstance, or ability.\u003c/p\u003e\n\u003cp\u003eWe hope that highlighting the considerations that went into our work can help you on your accessibility journey.\u003cbr/\u003e\n\u003c/p\u003e\u003cp\u003e\u003cb\u003eShare your experience\u003c/b\u003e: \u003ca href=\"https://github.com/orgs/community/discussions/categories/accessibility\"\u003eWe’d love to hear from you\u003c/a\u003e if you’ve run into issues using our tree view component with assistive technology. This feedback is invaluable to helping us continue to make GitHub more accessible.\u003c/p\u003e\n\n\t\n\u003csection\u003e\n\t\u003chr/\u003e\n\t\u003cdiv\u003e\n\t\t\u003ch2\u003eTags:\u003c/h2\u003e\n\t\t\u003cul\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/accessibility/\" rel=\"tag\"\u003e\n\t\t\t\t\t\taccessibility\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/apg/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tAPG\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/aria/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tARIA\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/assistive-technology/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tAssistive Technology\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/components/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tComponents\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/primer/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tPrimer\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/screen-readers/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tScreen Readers\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/tree-view/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tTree View\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\t\t\u003cli\u003e\n\t\t\t\t\t\u003ca href=\"https://github.blog/tag/wcag/\" rel=\"tag\"\u003e\n\t\t\t\t\t\tWCAG\t\t\t\t\t\u003c/a\u003e\n\t\t\t\t\u003c/li\u003e\n\t\t\t\t\t\u003c/ul\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/634191?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/634191?v=4\u0026amp;s=200\" alt=\"Eric Bailey\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.blog/developer-skills/github/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\"\u003e\u003cpath fill=\"currentColor\" d=\"M7.28033 3.21967C6.98744 2.92678 6.51256 2.92678 6.21967 3.21967C5.92678 3.51256 5.92678 3.98744 6.21967 4.28033L7.28033 3.21967ZM11 8L11.5303 8.53033C11.8232 8.23744 11.8232 7.76256 11.5303 7.46967L11 8ZM6.21967 11.7197C5.92678 12.0126 5.92678 12.4874 6.21967 12.7803C6.51256 13.0732 6.98744 13.0732 7.28033 12.7803L6.21967 11.7197ZM6.21967 4.28033L10.4697 8.53033L11.5303 7.46967L7.28033 3.21967L6.21967 4.28033ZM10.4697 7.46967L6.21967 11.7197L7.28033 12.7803L11.5303 8.53033L10.4697 7.46967Z\"\u003e\u003c/path\u003e\u003cpath stroke=\"currentColor\" d=\"M1.75 8H11\" stroke-width=\"1.5\" stroke-linecap=\"round\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2022/05/careers.svg\" width=\"44\" height=\"44\" alt=\"Work at GitHub!\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tWork at GitHub!\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eCheck out our current job openings.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Apply now; ref_location:bottom recirculation;\" href=\"https://www.github.careers/careers-home\" target=\"_blank\" aria-label=\"Apply now\"\u003e\n\t\t\t\t\tApply now\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-01-28T17:00:39Z",
  "modifiedTime": "2025-01-27T22:08:27Z"
}
