{
  "id": "a68ce4b4-e267-41a5-9fd7-14c1ffd623aa",
  "title": "WebAssembly with Go: Taking Web Apps to the Next Level",
  "link": "https://betterprogramming.pub/webassembly-with-go-taking-web-apps-to-the-next-level-8d81fccd8250?source=rss----d0b105d10f0a---4",
  "description": "",
  "author": "Ege Aytin",
  "published": "Fri, 10 Nov 2023 17:31:06 GMT",
  "source": "https://medium.com/feed/better-programming",
  "categories": [
    "javascript",
    "golang",
    "tutorial"
  ],
  "byline": "Ege Aytin",
  "length": 21622,
  "excerpt": "You might’ve noticed the increasing chatter around WebAssembly (WASM) in the dev community. Its potential is vast, and we’ve found it invaluable in enhancing our open source project! Hi everyone, I’m…",
  "siteName": "Better Programming",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "You might’ve noticed the increasing chatter around WebAssembly (WASM) in the dev community. Its potential is vast, and we’ve found it invaluable in enhancing our open source project!Hi everyone, I’m part of the team behind Permify, an open-source infra that helps developers to create and manage granular permissions throughout their applications.In this article, I’ll demonstrate why and how we integrated WebAssembly (WASM) into our Playground and gained benefits from its collaboration with Golang.What does this playground do? Well, without diving too deep, its a interactive module of Permify which used for creating and testing authorization models.Throughout this post, I’ll be sharing:A brief explanation of WASM and the benefits of using it with Go.A peek into what spurred our choice to integrate WASM in Permify.WASM Implementation, includingQuick Warm Up: WASM Implementation with GoDeeper Dive: Permify’s WASM Code BreakdownFrontend: Steps to Embed Go WASM in a React ApplicationBy the end, you should have a clearer understanding of why and how we leveraged WASM’s capabilities for our project.Understanding WebAssemblyWebAssembly (Wasm) has established itself as a pivotal technology, enabling quick and efficient code execution in web browsers and forming a robust bridge between web applications and the high-performance typically associated with native applications.1. Unveiling WebAssembly:Wasm acts as a low-level virtual machine, executing a compact binary code that’s translated from high-level languages.Primary Advantages:Universal Browser Support: Thanks to its support from all major browsers, Wasm delivers consistent performance across diverse platforms.Near-Native Performance: Intentionally designed to execute binary code at a speed akin to native applications, Wasm enhances the responsiveness of web applications considerably.In our open-source project, Permify, we strategically incorporated Go (also known as Golang) into its foundational core, selecting it for its widely recognized static typing, concurrency handling, and performance optimization. When the development journey led us to craft the Permify Playground, WebAssembly stepped into the spotlight as a crucial element.2. Blending Go \u0026 WebAssembly:Characteristics of Go: Celebrated for its optimal performance and concurrency handling capabilities, Go has carved a sturdy standing within the developer community.Synergy with WebAssembly: The translation of Go code into WebAssembly enables developers to effectively utilize Go’s robust performance and concurrency management directly within the browser, propelling the creation of powerful, efficient, and scalable web applications.Our journey isn’t just about melding Go and WebAssembly. Moving forward, we’ll unearth why Wasm was pinpointed as the technology of choice for the Permify Playground development and what significant benefits were reaped from this decision.Why WebAssembly?The inception of the Permify Playground brought with it a key question: How to showcase our capabilities without being entwined in the complexities and maintenance woes of traditional server architectures? WebAssembly appeared as a shining answer. Adopting this binary instruction format allowed us to:Execute In-Browser: Permify’s playground could operate straight within the browser, sidestepping server maintenance overheads and repetitive API calls, and notably, making ongoing maintenance a breeze in comparison to older server-based approaches.Achieve Peak Performance: Employing WebAssembly ensures that our Go application operates with a level of performance that competes with native applications, enhancing user interactions and bolstering response times.Harvesting Technical Benefits and Gathering User FeedbackUtilizing WebAssembly in our Permify Playground led us down a path of discernible technical advantages and an embrace from the community:Swift Execution: By side-stepping server interactions and deploying WebAssembly in-browser, we’ve been able to deliver ultra-fast response times.Uncomplicated User Interface: Centralizing our playground in the browser, we’ve dispelled complexities associated with multi-tool workflows, delivering a clean and straightforward user experience.Community Validation: The affirming feedback and positive reception from the developer community stand as validation of our technological choices and implementations.Join us in the following sections as we delve deeper into the technicalities, feedback, and learnings from our adventure, providing a thorough exploration of our endeavours with WebAssembly.WASM Implementation with GoBefore we explore Permify’s use of WebAssembly (WASM) and Go, let’s understand their combination in a sample app. What follows is a step-by-step guide to bringing them together, setting the stage for our deeper dive into Permify’s implementation.1. Transforming Go into WebAssembly:Steps:To get started, ensure you’ve set the WebAssembly build target in Go:GOOS=js GOARCH=wasm go build -o main.wasm main.goNext, apply optimizations to reduce the file size and enhance performance:wasm-opt main.wasm --enable-bulk-memory -Oz -o play.wasmHandling Events:Suppose you want your Go function to react to a button click from your web page:package mainimport \"syscall/js\"func registerCallbacks() { js.Global().Set(\"handleClick\", js.FuncOf(handleClick))}func handleClick(this js.Value, inputs []js.Value) interface{} { println(\"Button clicked!\") return nil}In your HTML, after loading your WebAssembly module:\u003cbutton onclick=\"window.handleClick()\"\u003eClick me\u003c/button\u003e2. Integrating with Web Pages:Initializing Wasm:Ensure you have the wasm_exec.js script linked, then instantiate your Wasm module:\u003cscript src=\"wasm_exec.js\"\u003e\u003c/script\u003e\u003cscript\u003e const go = new Go(); WebAssembly.instantiateStreaming(fetch(\"play.wasm\"), go.importObject).then((result) =\u003e { go.run(result.instance); });\u003c/script\u003eInteracting with the DOM:Accessing and modifying web elements is fundamental. For instance, changing the content of a paragraph element from Go would look something like this:func updateDOMContent() { document := js.Global().Get(\"document\") element := document.Call(\"getElementById\", \"myParagraph\") element.Set(\"innerText\", \"Updated content from Go!\")}3. The Gains: Efficiency \u0026 Speed:Go’s Goroutines in the Browser:Imagine having multiple data fetch operations that can run simultaneously without blocking the main thread:func fetchData(url string, ch chan string) { // Simulate data fetch. ch \u003c- \"Data from \" + url}func main() { ch := make(chan string) go fetchData(\"\u003chttps://api.example1.com\u003e\", ch) go fetchData(\"\u003chttps://api.example2.com\u003e\", ch) data1 := \u003c-ch data2 := \u003c-ch println(data1, data2)}Navigating through Go and WebAssembly (WASM) showcases a powerful union, merging Go’s concurrent processing with WASM’s rapid client-side execution. The depth explored in our sample app lights the way forward into Permify, where we apply these technological strengths into a scalable, real-world authorization system.Deeper Dive: Permify’s WASM Code BreakdownLet’s dive a bit deeper into the heart of our WebAssembly integration by exploring the key segments of our Go-based WASM code.1. Setting up the Go-to-WASM Environmentinvolves preparing and specifying our Go code to be compiled for a WebAssembly runtime.// go:build wasm// +build wasmThese lines serve as directives to the Go compiler, signaling that the following code is designated for a WebAssembly runtime environment. Specifically://go:build wasm: A build constraint ensuring the code is compiled only for WASM targets, adhering to modern syntax.// +build wasm: An analogous constraint, utilizing older syntax for compatibility with prior Go versions.In essence, these directives guide the compiler to include this code segment only when compiling for a WebAssembly architecture, ensuring an appropriate setup and function within this specific runtime.2. Bridging JavaScript and Go with the run Functionpackage mainimport ( \"context\" \"encoding/json\" \"syscall/js\" \"google.golang.org/protobuf/encoding/protojson\" \"github.com/Permify/permify/pkg/development\")var dev *development.Developmentfunc run() js.Func { // The `run` function returns a new JavaScript function // that wraps the Go function. return js.FuncOf(func(this js.Value, args []js.Value) interface{} { // t will be used to store the unmarshaled JSON data. // The use of an empty interface{} type means it can hold any type of value. var t interface{} // Unmarshal JSON from JavaScript function argument (args[0]) to Go's data structure (map). // args[0].String() gets the JSON string from the JavaScript argument, // which is then converted to bytes and unmarshaled (parsed) into the map `t`. err := json.Unmarshal([]byte(args[0].String()), \u0026t) // If an error occurs during unmarshaling (parsing) the JSON, // it returns an array with the error message \"invalid JSON\" to JavaScript. if err != nil { return js.ValueOf([]interface{}{\"invalid JSON\"}) } // Attempt to assert that the parsed JSON (`t`) is a map with string keys. // This step ensures that the unmarshaled JSON is of the expected type (map). input, ok := t.(map[string]interface{}) // If the assertion is false (`ok` is false), // it returns an array with the error message \"invalid JSON\" to JavaScript. if !ok { return js.ValueOf([]interface{}{\"invalid JSON\"}) } // Run the main logic of the application with the parsed input. // It’s assumed that `dev.Run` processes `input` in some way and returns any errors encountered during that process. errors := dev.Run(context.Background(), input) // If no errors are present (the length of the `errors` slice is 0), // return an empty array to JavaScript to indicate success with no errors. if len(errors) == 0 { return js.ValueOf([]interface{}{}) } // If there are errors, each error in the `errors` slice is marshaled (converted) to a JSON string. // `vs` is a slice that will store each of these JSON error strings. vs := make([]interface{}, 0, len(errors)) // Iterate through each error in the `errors` slice. for _, r := range errors { // Convert the error `r` to a JSON string and store it in `result`. // If an error occurs during this marshaling, it returns an array with that error message to JavaScript. result, err := json.Marshal(r) if err != nil { return js.ValueOf([]interface{}{err.Error()}) } // Add the JSON error string to the `vs` slice. vs = append(vs, string(result)) } // Return the `vs` slice (containing all JSON error strings) to JavaScript. return js.ValueOf(vs) })}Within the realm of Permify, the run function stands as a cornerstone, executing a crucial bridging operation between JavaScript inputs and Go's processing capabilities. It orchestrates real-time data interchange in JSON format, safeguarding that Permify's core functionalities are smoothly and instantaneously accessible via a browser interface.Digging into run:JSON Data Interchange: Translating JavaScript inputs into a format utilizable by Go, the function unmarshals JSON, transferring data between JS and Go, assuring that the robust processing capabilities of Go can seamlessly manipulate browser-sourced inputs.Error Handling: Ensuring clarity and user-awareness, it conducts meticulous error-checking during data parsing and processing, returning relevant error messages back to the JavaScript environment to ensure user-friendly interactions.Contextual Processing: By employing dev.Run, it processes the parsed input within a certain context, managing application logic while handling potential errors to assure steady data management and user feedback.Bidirectional Communication: As errors are marshaled back into JSON format and returned to JavaScript, the function ensures a two-way data flow, keeping both environments in synchronized harmony.Thus, through adeptly managing data, error-handling, and ensuring a fluid two-way communication channel, run serves as an integral bridge, linking JavaScript and Go to ensure the smooth, real-time operation of Permify within a browser interface. This facilitation of interaction not only heightens user experience but also leverages the respective strengths of JavaScript and Go within the Permify environment.3. Main Execution and Initialization// Continuing from the previously discussed code...func main() { // Instantiate a channel, 'ch', with no buffer, acting as a synchronization point for the goroutine. ch := make(chan struct{}, 0) // Create a new instance of 'Container' from the 'development' package and assign it to the global variable 'dev'. dev = development.NewContainer() // Attach the previously defined 'run' function to the global JavaScript object, // making it callable from the JavaScript environment. js.Global().Set(\"run\", run()) // Utilize a channel receive expression to halt the 'main' goroutine, preventing the program from terminating. \u003c-ch}ch := make(chan struct{}, 0): A synchronization channel is created to coordinate the activity of goroutines (concurrent threads in Go).dev = development.NewContainer(): Initializes a new container instance from the development package and assigns it to dev.js.Global().Set(\"run\", run()): Exposes the Go run function to the global JavaScript context, enabling JavaScript to call Go functions.\u003c-ch: Halts the main goroutine indefinitely, ensuring that the Go WebAssembly module remains active in the JavaScript environment.In summary, the code establishes a Go environment running within WebAssembly that exposes specific functionality (run function) to the JavaScript side and keeps itself active and available for function calls from JavaScript.Building the Go Code into a WASM ModuleBefore we delve into Permify’s rich functionalities, it’s paramount to elucidate the steps of converting our Go code into a WASM module, priming it for browser execution.For enthusiasts eager to delve deep into the complete Go codebase, don’t hesitate to browse our GitHub repository: Permify Wasm Code.1. Compiling to WASMKickstart the transformation of our Go application into a WASM binary with this command:GOOS=js GOARCH=wasm go build -o permify.wasm main.goThis directive cues the Go compiler to churn out a .wasm binary attuned for JavaScript environments, with main.go as the source. The output, permify.wasm, is a concise rendition of our Go capabilities, primed for web deployment.2. WASM Exec JSIn conjunction with the WASM binary, the Go ecosystem offers an indispensable JavaScript piece named wasm_exec.js. It's pivotal for initializing and facilitating our WASM module within a browser setting. You can typically locate this essential script inside the Go installation, under misc/wasm.However, to streamline your journey, we’ve hosted wasm_exec.js right here for direct access: wasm_exec.cp \"$(go env GOROOT)/misc/wasm/wasm_exec.js\" .Equipped with these pivotal assets — the WASM binary and its companion JavaScript — the stage is set for its amalgamation into our frontend.Steps to Embed Go WASM in a React Application1. Setting Up the React Application StructureTo kick things off, ensure you have a directory structure that clearly separates your WebAssembly-related code from the rest of your application. Based on your given structure, the loadWasm folder seems to be where all the magic happens:loadWasm/│├── index.tsx // Your main React component that integrates WASM.├── wasm_exec.js // Provided by Go, bridges the gap between Go's WASM and JS.└── wasmTypes.d.ts // TypeScript type declarations for WebAssembly.To view the complete structure and delve into the specifics of each file, refer to the Permify Playground on GitHub.2. Establishing Type DeclarationsInside the wasmTypes.d.ts, global type declarations are made which expand upon the Window interface to acknowledge the new methods brought in by Go's WebAssembly:declare global { export interface Window { Go: any; run: (shape: string) =\u003e any[]; }}export {};This ensures TypeScript recognizes the Go constructor and the run method when called on the global window object.3. Preparing the WebAssembly LoaderIn index.tsx, several critical tasks are accomplished:Import Dependencies: First off, we import the required JS and TypeScript declarations:import \"./wasm_exec.js\";import \"./wasmTypes.d.ts\";WebAssembly Initialization: The asynchronous function loadWasm takes care of the entire process:async function loadWasm(): Promise\u003cvoid\u003e { const goWasm = new window.Go(); const result = await WebAssembly.instantiateStreaming( fetch(\"play.wasm\"), goWasm.importObject ); goWasm.run(result.instance);}Here, new window.Go() initializes the Go WASM environment. WebAssembly.instantiateStreaming fetches the WASM module, compiles it, and creates an instance. Finally, goWasm.run activates the WASM module.React Component with Loader UI: The LoadWasm component uses the useEffect hook to asynchronously load the WebAssembly when the component mounts:export const LoadWasm: React.FC\u003cReact.PropsWithChildren\u003c{}\u003e\u003e = (props) =\u003e { const [isLoading, setIsLoading] = React.useState(true); useEffect(() =\u003e { loadWasm().then(() =\u003e { setIsLoading(false); }); }, []); if (isLoading) { return ( \u003cdiv className=\"wasm-loader-background h-screen\"\u003e \u003cdiv className=\"center-of-screen\"\u003e \u003cSVG src={toAbsoluteUrl(\"/media/svg/rocket.svg\")} /\u003e \u003c/div\u003e \u003c/div\u003e ); } else { return \u003cReact.Fragment\u003e{props.children}\u003c/React.Fragment\u003e; }};While loading, SVG rocket is displayed to indicate that initialization is ongoing. This feedback is crucial as users might otherwise be uncertain about what’s transpiring behind the scenes. Once loading completes, children components or content will render.4. Calling WebAssembly FunctionsGiven your Go WASM exposes a method named run, you can invoke it as follows:function Run(shape) { return new Promise((resolve) =\u003e { let res = window.run(shape); resolve(res); });}This function essentially acts as a bridge, allowing the React frontend to communicate with the Go backend logic encapsulated in the WASM.5. Implementing the Run Button in ReactTo integrate a button that triggers the WebAssembly function when clicked, follow these steps:Creating the Button ComponentFirst, we’ll create a simple React component with a button:import React from \"react\";type RunButtonProps = { shape: string; onResult: (result: any[]) =\u003e void;};function RunButton({ shape, onResult }: RunButtonProps) { const handleClick = async () =\u003e { let result = await Run(shape); onResult(result); }; return \u003cbutton onClick={handleClick}\u003eRun WebAssembly\u003c/button\u003e;}In the code above, the RunButton component accepts two props:shape: The shape argument to pass to the WebAssembly run function.onResult: A callback function that receives the result of the WebAssembly function and can be used to update the state or display the result in the UI.Integrating the Button in the Main ComponentNow, in your main component (or wherever you’d like to place the button), integrate the RunButton:import React, { useState } from \"react\";import RunButton from \"./path_to_RunButton_component\"; // Replace with the actual pathfunction App() { const [result, setResult] = useState\u003cany[]\u003e([]); // Define the shape content const shapeContent = { schema: `|- entity user {} entity account { relation owner @user relation following @user relation follower @user attribute public boolean action view = (owner or follower) or public } entity post { relation account @account attribute restricted boolean action view = account.view action comment = account.following not restricted action like = account.following not restricted }`, relationships: [ \"account:1#owner@user:kevin\", \"account:2#owner@user:george\", \"account:1#following@user:george\", \"account:2#follower@user:kevin\", \"post:1#account@account:1\", \"post:2#account@account:2\", ], attributes: [ \"account:1$public|boolean:true\", \"account:2$public|boolean:false\", \"post:1$restricted|boolean:false\", \"post:2$restricted|boolean:true\", ], scenarios: [ { name: \"Account Viewing Permissions\", description: \"Evaluate account viewing permissions for 'kevin' and 'george'.\", checks: [ { entity: \"account:1\", subject: \"user:kevin\", assertions: { view: true, }, }, ], }, ], }; return ( \u003cdiv\u003e \u003cRunButton shape={JSON.stringify(shapeContent)} onResult={setResult} /\u003e \u003cdiv\u003e Results: \u003cul\u003e {result.map((item, index) =\u003e ( \u003cli key={index}\u003e{item}\u003c/li\u003e ))} \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e );}In this example, App is a component that contains the RunButton. When the button is clicked, the result from the WebAssembly function is displayed in a list below the button.ConclusionThroughout this exploration, the integration of WebAssembly with Go was unfolded, illuminating the pathway toward enhanced web development and optimal user interactions within browsers.The journey involved setting up the Go environment, converting Go code to WebAssembly, and executing it within a web context, ultimately giving life to the interactive platform showcased at play.permify.co.This platform stands not only as an example but also as a beacon, illustrating the concrete and potent capabilities achievable when intertwining these technological domains.",
  "image": "https://miro.medium.com/v2/resize:fit:1000/1*b4sFFT3X6e0dVCvKAAtMIg.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@ege.aytin?source=post_page-----8d81fccd8250--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Ege Aytin\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*RdNP0tCkDIFylUpov6P7iA.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://betterprogramming.pub/?source=post_page-----8d81fccd8250--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Better Programming\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*QNoA3XlXLHz22zQazc0syg.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"57c2\"\u003eYou might’ve noticed the increasing chatter around \u003ca href=\"https://webassembly.org/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eWebAssembly (WASM)\u003c/a\u003e in the dev community. Its potential is vast, and we’ve found it invaluable in enhancing our open source project!\u003c/p\u003e\u003cp id=\"9201\"\u003eHi everyone, I’m part of the team behind \u003ca href=\"https://github.com/Permify/permify\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePermify\u003c/a\u003e, an open-source infra that helps developers to create and manage granular permissions throughout their applications.\u003c/p\u003e\u003cp id=\"8113\"\u003eIn this article, I’ll demonstrate why and how we integrated WebAssembly (WASM) into our \u003ca href=\"https://play.permify.co/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePlayground\u003c/a\u003e and gained benefits from its collaboration with Golang.\u003c/p\u003e\u003cp id=\"7b93\"\u003eWhat does this playground do? Well, without diving too deep, its a interactive module of Permify which used for creating and testing authorization models.\u003c/p\u003e\u003cp id=\"2f67\"\u003eThroughout this post, I’ll be sharing:\u003c/p\u003e\u003cul\u003e\u003cli id=\"a76c\"\u003e\u003cstrong\u003e\u003cem\u003eA brief explanation of WASM and the benefits of using it with Go.\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"75e9\"\u003e\u003cstrong\u003e\u003cem\u003eA peek into what spurred our choice to integrate WASM in Permify.\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"9698\"\u003e\u003cstrong\u003e\u003cem\u003eWASM Implementation, including\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"a341\"\u003e\u003cstrong\u003e\u003cem\u003eQuick Warm Up: WASM Implementation with Go\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"81bd\"\u003e\u003cstrong\u003e\u003cem\u003eDeeper Dive: Permify’s WASM Code Breakdown\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"bdac\"\u003e\u003cstrong\u003e\u003cem\u003eFrontend: Steps to Embed Go WASM in a React Application\u003c/em\u003e\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"86e6\"\u003eBy the end, you should have a clearer understanding of why and how we leveraged WASM’s capabilities for our project.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"1f22\"\u003eUnderstanding WebAssembly\u003c/h2\u003e\u003cp id=\"6482\"\u003eWebAssembly (Wasm) has established itself as a pivotal technology, enabling quick and efficient code execution in web browsers and forming a robust bridge between web applications and the high-performance typically associated with native applications.\u003c/p\u003e\u003ch2 id=\"4625\"\u003e1. Unveiling WebAssembly:\u003c/h2\u003e\u003cp id=\"7254\"\u003eWasm acts as a low-level virtual machine, executing a compact binary code that’s translated from high-level languages.\u003c/p\u003e\u003cp id=\"5569\"\u003ePrimary Advantages:\u003c/p\u003e\u003cul\u003e\u003cli id=\"beae\"\u003eUniversal Browser Support: Thanks to its support from all major browsers, Wasm delivers consistent performance across diverse platforms.\u003c/li\u003e\u003cli id=\"52f1\"\u003eNear-Native Performance: Intentionally designed to execute binary code at a speed akin to native applications, Wasm enhances the responsiveness of web applications considerably.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"09ee\"\u003eIn our open-source project, Permify, we strategically incorporated Go (also known as Golang) into its foundational core, selecting it for its widely recognized static typing, concurrency handling, and performance optimization. When the development journey led us to craft the Permify Playground, WebAssembly stepped into the spotlight as a crucial element.\u003c/p\u003e\u003ch2 id=\"e427\"\u003e2. Blending Go \u0026amp; WebAssembly:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"d78d\"\u003eCharacteristics of Go: Celebrated for its optimal performance and concurrency handling capabilities, Go has carved a sturdy standing within the developer community.\u003c/li\u003e\u003cli id=\"8c20\"\u003eSynergy with WebAssembly: The translation of Go code into WebAssembly enables developers to effectively utilize Go’s robust performance and concurrency management directly within the browser, propelling the creation of powerful, efficient, and scalable web applications.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"f7fa\"\u003eOur journey isn’t just about melding Go and WebAssembly. Moving forward, we’ll unearth why Wasm was pinpointed as the technology of choice for the Permify Playground development and what significant benefits were reaped from this decision.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"8087\"\u003eWhy WebAssembly?\u003c/h2\u003e\u003cp id=\"e640\"\u003eThe inception of the Permify Playground brought with it a key question: How to showcase our capabilities without being entwined in the complexities and maintenance woes of traditional server architectures? WebAssembly appeared as a shining answer. Adopting this binary instruction format allowed us to:\u003c/p\u003e\u003cul\u003e\u003cli id=\"86b4\"\u003eExecute In-Browser: Permify’s playground could operate straight within the browser, sidestepping server maintenance overheads and repetitive API calls, and notably, making ongoing maintenance a breeze in comparison to older server-based approaches.\u003c/li\u003e\u003cli id=\"0110\"\u003eAchieve Peak Performance: Employing WebAssembly ensures that our Go application operates with a level of performance that competes with native applications, enhancing user interactions and bolstering response times.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6cf6\"\u003eHarvesting Technical Benefits and Gathering User Feedback\u003c/h2\u003e\u003cp id=\"9f20\"\u003eUtilizing WebAssembly in our Permify Playground led us down a path of discernible technical advantages and an embrace from the community:\u003c/p\u003e\u003cul\u003e\u003cli id=\"0dd5\"\u003eSwift Execution: By side-stepping server interactions and deploying WebAssembly in-browser, we’ve been able to deliver ultra-fast response times.\u003c/li\u003e\u003cli id=\"3e9a\"\u003eUncomplicated User Interface: Centralizing our playground in the browser, we’ve dispelled complexities associated with multi-tool workflows, delivering a clean and straightforward user experience.\u003c/li\u003e\u003cli id=\"e79a\"\u003eCommunity Validation: The affirming feedback and positive reception from the developer community stand as validation of our technological choices and implementations.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0bcf\"\u003eJoin us in the following sections as we delve deeper into the technicalities, feedback, and learnings from our adventure, providing a thorough exploration of our endeavours with WebAssembly.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"85e7\"\u003eWASM Implementation with Go\u003c/h2\u003e\u003cp id=\"ebee\"\u003eBefore we explore Permify’s use of WebAssembly (WASM) and Go, let’s understand their combination in a sample app. What follows is a step-by-step guide to bringing them together, setting the stage for our deeper dive into Permify’s implementation.\u003c/p\u003e\u003ch2 id=\"48fe\"\u003e1. Transforming Go into WebAssembly:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"9756\"\u003e\u003cstrong\u003eSteps:\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003col\u003e\u003cli id=\"91a0\"\u003eTo get started, ensure you’ve set the WebAssembly build target in Go:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"f36b\"\u003eGOOS=js GOARCH=wasm go build -o main.wasm main.go\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"cad3\"\u003eNext, apply optimizations to reduce the file size and enhance performance:\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003cspan id=\"3449\"\u003ewasm-opt main.wasm --enable-bulk-memory -Oz -o play.wasm\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"44c1\"\u003e\u003cstrong\u003eHandling Events:\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6796\"\u003eSuppose you want your Go function to react to a button click from your web page:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5aae\"\u003epackage main\u003cp\u003eimport \u0026#34;syscall/js\u0026#34;\u003c/p\u003e\u003cp\u003efunc registerCallbacks() {\u003cbr/\u003e    js.Global().Set(\u0026#34;handleClick\u0026#34;, js.FuncOf(handleClick))\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003efunc handleClick(this js.Value, inputs []js.Value) interface{} {\u003cbr/\u003e    println(\u0026#34;Button clicked!\u0026#34;)\u003cbr/\u003e    return nil\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ca9\"\u003eIn your HTML, after loading your WebAssembly module:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a044\"\u003e\u0026lt;button onclick=\u0026#34;window.handleClick()\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"2970\"\u003e2. Integrating with Web Pages:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"f748\"\u003e\u003cstrong\u003eInitializing Wasm:\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5790\"\u003eEnsure you have the \u003ccode\u003ewasm_exec.js\u003c/code\u003e script linked, then instantiate your Wasm module:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dbe5\"\u003e\u0026lt;script src=\u0026#34;wasm_exec.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u003cbr/\u003e\u0026lt;script\u0026gt;\u003cbr/\u003e    const go = new Go();\u003cbr/\u003e    WebAssembly.instantiateStreaming(fetch(\u0026#34;play.wasm\u0026#34;), go.importObject).then((result) =\u0026gt; {\u003cbr/\u003e        go.run(result.instance);\u003cbr/\u003e    });\u003cbr/\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"3be5\"\u003e\u003cstrong\u003eInteracting with the DOM:\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8372\"\u003eAccessing and modifying web elements is fundamental. For instance, changing the content of a paragraph element from Go would look something like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"af46\"\u003efunc updateDOMContent() {\u003cbr/\u003e    document := js.Global().Get(\u0026#34;document\u0026#34;)\u003cbr/\u003e    element := document.Call(\u0026#34;getElementById\u0026#34;, \u0026#34;myParagraph\u0026#34;)\u003cbr/\u003e    element.Set(\u0026#34;innerText\u0026#34;, \u0026#34;Updated content from Go!\u0026#34;)\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"647c\"\u003e3. The Gains: Efficiency \u0026amp; Speed:\u003c/h2\u003e\u003cul\u003e\u003cli id=\"cdaf\"\u003e\u003cstrong\u003eGo’s Goroutines in the Browser:\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d6e7\"\u003eImagine having multiple data fetch operations that can run simultaneously without blocking the main thread:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8c14\"\u003efunc fetchData(url string, ch chan string) {\u003cbr/\u003e    // Simulate data fetch.\u003cbr/\u003e    ch \u0026lt;- \u0026#34;Data from \u0026#34; + url\u003cbr/\u003e}\u003cp\u003efunc main() {\u003cbr/\u003e    ch := make(chan string)\u003cbr/\u003e    go fetchData(\u0026#34;\u0026lt;https://api.example1.com\u0026gt;\u0026#34;, ch)\u003cbr/\u003e    go fetchData(\u0026#34;\u0026lt;https://api.example2.com\u0026gt;\u0026#34;, ch)\u003c/p\u003e\u003cp\u003e    data1 := \u0026lt;-ch\u003cbr/\u003e    data2 := \u0026lt;-ch\u003cbr/\u003e    println(data1, data2)\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"aeb5\"\u003eNavigating through Go and WebAssembly (WASM) showcases a powerful union, merging Go’s concurrent processing with WASM’s rapid client-side execution. The depth explored in our sample app lights the way forward into Permify, where we apply these technological strengths into a scalable, real-world authorization system.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"3451\"\u003eDeeper Dive: Permify’s WASM Code Breakdown\u003c/h2\u003e\u003cp id=\"8de0\"\u003eLet’s dive a bit deeper into the heart of our WebAssembly integration by exploring the key segments of our Go-based WASM code.\u003c/p\u003e\u003ch2 id=\"d82f\"\u003e1. Setting up the Go-to-WASM Environment\u003c/h2\u003e\u003cp id=\"803f\"\u003einvolves preparing and specifying our Go code to be compiled for a WebAssembly runtime.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5061\"\u003e// go:build wasm\u003cbr/\u003e// +build wasm\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f96d\"\u003eThese lines serve as directives to the Go compiler, signaling that the following code is designated for a WebAssembly runtime environment. Specifically:\u003c/p\u003e\u003cul\u003e\u003cli id=\"269a\"\u003e\u003ccode\u003e//go:build wasm\u003c/code\u003e: A build constraint ensuring the code is compiled only for WASM targets, adhering to modern syntax.\u003c/li\u003e\u003cli id=\"f096\"\u003e\u003ccode\u003e// +build wasm\u003c/code\u003e: An analogous constraint, utilizing older syntax for compatibility with prior Go versions.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"889c\"\u003eIn essence, these directives guide the compiler to include this code segment only when compiling for a WebAssembly architecture, ensuring an appropriate setup and function within this specific runtime.\u003c/p\u003e\u003ch2 id=\"6d04\"\u003e2. Bridging JavaScript and Go with the \u003ccode\u003erun\u003c/code\u003e Function\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"00d7\"\u003epackage main\u003cp\u003eimport (\u003cbr/\u003e \u0026#34;context\u0026#34;\u003cbr/\u003e \u0026#34;encoding/json\u0026#34;\u003cbr/\u003e \u0026#34;syscall/js\u0026#34;\u003c/p\u003e\u003cp\u003e \u0026#34;google.golang.org/protobuf/encoding/protojson\u0026#34;\u003c/p\u003e\u003cp\u003e \u0026#34;github.com/Permify/permify/pkg/development\u0026#34;\u003cbr/\u003e)\u003c/p\u003e\u003cp\u003evar dev *development.Development\u003c/p\u003e\u003cp\u003efunc run() js.Func {\u003cbr/\u003e  // The `run` function returns a new JavaScript function\u003cbr/\u003e  // that wraps the Go function.\u003cbr/\u003e return js.FuncOf(func(this js.Value, args []js.Value) interface{} {\u003c/p\u003e\u003cp\u003e  // t will be used to store the unmarshaled JSON data.\u003cbr/\u003e  // The use of an empty interface{} type means it can hold any type of value.\u003cbr/\u003e  var t interface{}\u003c/p\u003e\u003cp\u003e  // Unmarshal JSON from JavaScript function argument (args[0]) to Go\u0026#39;s data structure (map).\u003cbr/\u003e  // args[0].String() gets the JSON string from the JavaScript argument,\u003cbr/\u003e  // which is then converted to bytes and unmarshaled (parsed) into the map `t`.\u003cbr/\u003e  err := json.Unmarshal([]byte(args[0].String()), \u0026amp;t)\u003c/p\u003e\u003cp\u003e  // If an error occurs during unmarshaling (parsing) the JSON,\u003cbr/\u003e  // it returns an array with the error message \u0026#34;invalid JSON\u0026#34; to JavaScript.\u003cbr/\u003e  if err != nil {\u003cbr/\u003e   return js.ValueOf([]interface{}{\u0026#34;invalid JSON\u0026#34;})\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  // Attempt to assert that the parsed JSON (`t`) is a map with string keys.\u003cbr/\u003e  // This step ensures that the unmarshaled JSON is of the expected type (map).\u003cbr/\u003e  input, ok := t.(map[string]interface{})\u003c/p\u003e\u003cp\u003e  // If the assertion is false (`ok` is false),\u003cbr/\u003e  // it returns an array with the error message \u0026#34;invalid JSON\u0026#34; to JavaScript.\u003cbr/\u003e  if !ok {\u003cbr/\u003e   return js.ValueOf([]interface{}{\u0026#34;invalid JSON\u0026#34;})\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  // Run the main logic of the application with the parsed input.\u003cbr/\u003e  // It’s assumed that `dev.Run` processes `input` in some way and returns any errors encountered during that process.\u003cbr/\u003e  errors := dev.Run(context.Background(), input)\u003c/p\u003e\u003cp\u003e  // If no errors are present (the length of the `errors` slice is 0),\u003cbr/\u003e  // return an empty array to JavaScript to indicate success with no errors.\u003cbr/\u003e  if len(errors) == 0 {\u003cbr/\u003e   return js.ValueOf([]interface{}{})\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  // If there are errors, each error in the `errors` slice is marshaled (converted) to a JSON string.\u003cbr/\u003e  // `vs` is a slice that will store each of these JSON error strings.\u003cbr/\u003e  vs := make([]interface{}, 0, len(errors))\u003c/p\u003e\u003cp\u003e  // Iterate through each error in the `errors` slice.\u003cbr/\u003e  for _, r := range errors {\u003cbr/\u003e   // Convert the error `r` to a JSON string and store it in `result`.\u003cbr/\u003e   // If an error occurs during this marshaling, it returns an array with that error message to JavaScript.\u003cbr/\u003e   result, err := json.Marshal(r)\u003cbr/\u003e   if err != nil {\u003cbr/\u003e    return js.ValueOf([]interface{}{err.Error()})\u003cbr/\u003e   }\u003cbr/\u003e   // Add the JSON error string to the `vs` slice.\u003cbr/\u003e   vs = append(vs, string(result))\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  // Return the `vs` slice (containing all JSON error strings) to JavaScript.\u003cbr/\u003e  return js.ValueOf(vs)\u003cbr/\u003e })\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"469a\"\u003eWithin the realm of Permify, the \u003ccode\u003erun\u003c/code\u003e function stands as a cornerstone, executing a crucial bridging operation between JavaScript inputs and Go\u0026#39;s processing capabilities. It orchestrates real-time data interchange in JSON format, safeguarding that Permify\u0026#39;s core functionalities are smoothly and instantaneously accessible via a browser interface.\u003c/p\u003e\u003cp id=\"9fc1\"\u003eDigging into \u003ccode\u003erun\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8e7b\"\u003eJSON Data Interchange: Translating JavaScript inputs into a format utilizable by Go, the function unmarshals JSON, transferring data between JS and Go, assuring that the robust processing capabilities of Go can seamlessly manipulate browser-sourced inputs.\u003c/li\u003e\u003cli id=\"37dc\"\u003eError Handling: Ensuring clarity and user-awareness, it conducts meticulous error-checking during data parsing and processing, returning relevant error messages back to the JavaScript environment to ensure user-friendly interactions.\u003c/li\u003e\u003cli id=\"1f63\"\u003eContextual Processing: By employing \u003ccode\u003edev.Run\u003c/code\u003e, it processes the parsed input within a certain context, managing application logic while handling potential errors to assure steady data management and user feedback.\u003c/li\u003e\u003cli id=\"28fa\"\u003eBidirectional Communication: As errors are marshaled back into JSON format and returned to JavaScript, the function ensures a two-way data flow, keeping both environments in synchronized harmony.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"06b8\"\u003eThus, through adeptly managing data, error-handling, and ensuring a fluid two-way communication channel, \u003ccode\u003erun\u003c/code\u003e serves as an integral bridge, linking JavaScript and Go to ensure the smooth, real-time operation of Permify within a browser interface. This facilitation of interaction not only heightens user experience but also leverages the respective strengths of JavaScript and Go within the Permify environment.\u003c/p\u003e\u003ch2 id=\"a672\"\u003e3. Main Execution and Initialization\u003c/h2\u003e\u003cpre\u003e\u003cspan id=\"ea7a\"\u003e// Continuing from the previously discussed code...\u003cp\u003efunc main() {\u003cbr/\u003e  // Instantiate a channel, \u0026#39;ch\u0026#39;, with no buffer, acting as a synchronization point for the goroutine.\u003cbr/\u003e  ch := make(chan struct{}, 0)\u003c/p\u003e\u003cp\u003e  // Create a new instance of \u0026#39;Container\u0026#39; from the \u0026#39;development\u0026#39; package and assign it to the global variable \u0026#39;dev\u0026#39;.\u003cbr/\u003e  dev = development.NewContainer()\u003c/p\u003e\u003cp\u003e  // Attach the previously defined \u0026#39;run\u0026#39; function to the global JavaScript object,\u003cbr/\u003e  // making it callable from the JavaScript environment.\u003cbr/\u003e  js.Global().Set(\u0026#34;run\u0026#34;, run())\u003c/p\u003e\u003cp\u003e  // Utilize a channel receive expression to halt the \u0026#39;main\u0026#39; goroutine, preventing the program from terminating.\u003cbr/\u003e  \u0026lt;-ch\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003col\u003e\u003cli id=\"ce52\"\u003e\u003ccode\u003ech := make(chan struct{}, 0)\u003c/code\u003e: A synchronization channel is created to coordinate the activity of goroutines (concurrent threads in Go).\u003c/li\u003e\u003cli id=\"abdd\"\u003e\u003ccode\u003edev = development.NewContainer()\u003c/code\u003e: Initializes a new container instance from the development package and assigns it to \u003ccode\u003edev\u003c/code\u003e.\u003c/li\u003e\u003cli id=\"7b89\"\u003e\u003ccode\u003ejs.Global().Set(\u0026#34;run\u0026#34;, run())\u003c/code\u003e: Exposes the Go \u003ccode\u003erun\u003c/code\u003e function to the global JavaScript context, enabling JavaScript to call Go functions.\u003c/li\u003e\u003cli id=\"29d5\"\u003e\u003ccode\u003e\u0026lt;-ch\u003c/code\u003e: Halts the \u003ccode\u003emain\u003c/code\u003e goroutine indefinitely, ensuring that the Go WebAssembly module remains active in the JavaScript environment.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"6baf\"\u003eIn summary, the code establishes a Go environment running within WebAssembly that exposes specific functionality (\u003ccode\u003erun\u003c/code\u003e function) to the JavaScript side and keeps itself active and available for function calls from JavaScript.\u003c/p\u003e\u003ch2 id=\"4fd4\"\u003eBuilding the Go Code into a WASM Module\u003c/h2\u003e\u003cp id=\"ecaf\"\u003eBefore we delve into Permify’s rich functionalities, it’s paramount to elucidate the steps of converting our Go code into a WASM module, priming it for browser execution.\u003c/p\u003e\u003cp id=\"2fbc\"\u003eFor enthusiasts eager to delve deep into the complete Go codebase, don’t hesitate to browse our GitHub repository: \u003ca href=\"https://github.com/Permify/permify/tree/master/pkg/development\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePermify Wasm Code\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"5958\"\u003e1. Compiling to WASM\u003c/h2\u003e\u003cp id=\"74d6\"\u003eKickstart the transformation of our Go application into a WASM binary with this command:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"de37\"\u003eGOOS=js GOARCH=wasm go build -o permify.wasm main.go\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5006\"\u003eThis directive cues the Go compiler to churn out a \u003ccode\u003e.wasm\u003c/code\u003e binary attuned for JavaScript environments, with \u003ccode\u003emain.go\u003c/code\u003e as the source. The output, \u003ccode\u003epermify.wasm\u003c/code\u003e, is a concise rendition of our Go capabilities, primed for web deployment.\u003c/p\u003e\u003ch2 id=\"e793\"\u003e2. WASM Exec JS\u003c/h2\u003e\u003cp id=\"4d69\"\u003eIn conjunction with the WASM binary, the Go ecosystem offers an indispensable JavaScript piece named \u003ccode\u003ewasm_exec.js\u003c/code\u003e. It\u0026#39;s pivotal for initializing and facilitating our WASM module within a browser setting. You can typically locate this essential script inside the Go installation, under \u003ccode\u003emisc/wasm\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"f89d\"\u003eHowever, to streamline your journey, we’ve hosted \u003ccode\u003ewasm_exec.js\u003c/code\u003e right here for direct access: \u003ca href=\"https://github.com/Permify/permify/tree/master/playground/src/loadWasm\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ewasm_exec\u003c/a\u003e.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2d9f\"\u003ecp \u0026#34;$(go env GOROOT)/misc/wasm/wasm_exec.js\u0026#34; .\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"4f75\"\u003eEquipped with these pivotal assets — the WASM binary and its companion JavaScript — the stage is set for its amalgamation into our frontend.\u003c/p\u003e\u003ch2 id=\"66ac\"\u003eSteps to Embed Go WASM in a React Application\u003c/h2\u003e\u003ch2 id=\"0817\"\u003e1. Setting Up the React Application Structure\u003c/h2\u003e\u003cp id=\"ebf2\"\u003eTo kick things off, ensure you have a directory structure that clearly separates your WebAssembly-related code from the rest of your application. Based on your given structure, the \u003ccode\u003eloadWasm\u003c/code\u003e folder seems to be where all the magic happens:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5b3d\"\u003eloadWasm/\u003cbr/\u003e│\u003cbr/\u003e├── index.tsx            // Your main React component that integrates WASM.\u003cbr/\u003e├── wasm_exec.js         // Provided by Go, bridges the gap between Go\u0026#39;s WASM and JS.\u003cbr/\u003e└── wasmTypes.d.ts       // TypeScript type declarations for WebAssembly.\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ec4f\"\u003eTo view the complete structure and delve into the specifics of each file, refer to the \u003ca href=\"https://github.com/Permify/permify/tree/master/playground/src/loadWasm\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePermify Playground on GitHub\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"a18b\"\u003e2. Establishing Type Declarations\u003c/h2\u003e\u003cp id=\"ab9a\"\u003eInside the \u003ccode\u003ewasmTypes.d.ts\u003c/code\u003e, global type declarations are made which expand upon the Window interface to acknowledge the new methods brought in by Go\u0026#39;s WebAssembly:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"4496\"\u003edeclare global {\u003cbr/\u003e  export interface Window {\u003cbr/\u003e    Go: any;\u003cbr/\u003e    run: (shape: string) =\u0026gt; any[];\u003cbr/\u003e  }\u003cbr/\u003e}\u003cbr/\u003eexport {};\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5a51\"\u003eThis ensures TypeScript recognizes the \u003ccode\u003eGo\u003c/code\u003e constructor and the \u003ccode\u003erun\u003c/code\u003e method when called on the global \u003ccode\u003ewindow\u003c/code\u003e object.\u003c/p\u003e\u003ch2 id=\"bf6a\"\u003e3. Preparing the WebAssembly Loader\u003c/h2\u003e\u003cp id=\"a944\"\u003eIn \u003ccode\u003eindex.tsx\u003c/code\u003e, several critical tasks are accomplished:\u003c/p\u003e\u003cul\u003e\u003cli id=\"f76c\"\u003e\u003cstrong\u003eImport Dependencies:\u003c/strong\u003e First off, we import the required JS and TypeScript declarations:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"c36c\"\u003eimport \u0026#34;./wasm_exec.js\u0026#34;;\u003cbr/\u003eimport \u0026#34;./wasmTypes.d.ts\u0026#34;;\u003c/span\u003e\u003c/pre\u003e\u003cul\u003e\u003cli id=\"a49e\"\u003e\u003cstrong\u003eWebAssembly Initialization:\u003c/strong\u003e The asynchronous function \u003ccode\u003eloadWasm\u003c/code\u003e takes care of the entire process:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"e334\"\u003easync function loadWasm(): Promise\u0026lt;void\u0026gt; {\u003cbr/\u003e  const goWasm = new window.Go();\u003cbr/\u003e  const result = await WebAssembly.instantiateStreaming(\u003cbr/\u003e    fetch(\u0026#34;play.wasm\u0026#34;),\u003cbr/\u003e    goWasm.importObject\u003cbr/\u003e  );\u003cbr/\u003e  goWasm.run(result.instance);\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"97df\"\u003eHere, \u003ccode\u003enew window.Go()\u003c/code\u003e initializes the Go WASM environment. \u003ccode\u003eWebAssembly.instantiateStreaming\u003c/code\u003e fetches the WASM module, compiles it, and creates an instance. Finally, \u003ccode\u003egoWasm.run\u003c/code\u003e activates the WASM module.\u003c/p\u003e\u003cul\u003e\u003cli id=\"6750\"\u003e\u003cstrong\u003eReact Component with Loader UI:\u003c/strong\u003e The \u003ccode\u003eLoadWasm\u003c/code\u003e component uses the \u003ccode\u003euseEffect\u003c/code\u003e hook to asynchronously load the WebAssembly when the component mounts:\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003cspan id=\"66eb\"\u003eexport const LoadWasm: React.FC\u0026lt;React.PropsWithChildren\u0026lt;{}\u0026gt;\u0026gt; = (props) =\u0026gt; {\u003cbr/\u003e  const [isLoading, setIsLoading] = React.useState(true);\u003cp\u003e  useEffect(() =\u0026gt; {\u003cbr/\u003e    loadWasm().then(() =\u0026gt; {\u003cbr/\u003e      setIsLoading(false);\u003cbr/\u003e    });\u003cbr/\u003e  }, []);\u003c/p\u003e\u003cp\u003e  if (isLoading) {\u003cbr/\u003e    return (\u003cbr/\u003e      \u0026lt;div className=\u0026#34;wasm-loader-background h-screen\u0026#34;\u0026gt;\u003cbr/\u003e        \u0026lt;div className=\u0026#34;center-of-screen\u0026#34;\u0026gt;\u003cbr/\u003e          \u0026lt;SVG src={toAbsoluteUrl(\u0026#34;/media/svg/rocket.svg\u0026#34;)} /\u0026gt;\u003cbr/\u003e        \u0026lt;/div\u0026gt;\u003cbr/\u003e      \u0026lt;/div\u0026gt;\u003cbr/\u003e    );\u003cbr/\u003e  } else {\u003cbr/\u003e    return \u0026lt;React.Fragment\u0026gt;{props.children}\u0026lt;/React.Fragment\u0026gt;;\u003cbr/\u003e  }\u003cbr/\u003e};\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b345\"\u003eWhile loading, SVG rocket is displayed to indicate that initialization is ongoing. This feedback is crucial as users might otherwise be uncertain about what’s transpiring behind the scenes. Once loading completes, children components or content will render.\u003c/p\u003e\u003ch2 id=\"803b\"\u003e4. Calling WebAssembly Functions\u003c/h2\u003e\u003cp id=\"3642\"\u003eGiven your Go WASM exposes a method named \u003ccode\u003erun\u003c/code\u003e, you can invoke it as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2a39\"\u003efunction Run(shape) {\u003cbr/\u003e  return new Promise((resolve) =\u0026gt; {\u003cbr/\u003e    let res = window.run(shape);\u003cbr/\u003e    resolve(res);\u003cbr/\u003e  });\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"5db1\"\u003eThis function essentially acts as a bridge, allowing the React frontend to communicate with the Go backend logic encapsulated in the WASM.\u003c/p\u003e\u003ch2 id=\"bc83\"\u003e5. Implementing the Run Button in React\u003c/h2\u003e\u003cp id=\"c03d\"\u003eTo integrate a button that triggers the WebAssembly function when clicked, follow these steps:\u003c/p\u003e\u003col\u003e\u003cli id=\"8939\"\u003e\u003cstrong\u003eCreating the Button Component\u003c/strong\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"5e53\"\u003eFirst, we’ll create a simple React component with a button:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2272\"\u003eimport React from \u0026#34;react\u0026#34;;\u003cp\u003etype RunButtonProps = {\u003cbr/\u003e  shape: string;\u003cbr/\u003e  onResult: (result: any[]) =\u0026gt; void;\u003cbr/\u003e};\u003c/p\u003e\u003cp\u003efunction RunButton({ shape, onResult }: RunButtonProps) {\u003cbr/\u003e  const handleClick = async () =\u0026gt; {\u003cbr/\u003e    let result = await Run(shape);\u003cbr/\u003e    onResult(result);\u003cbr/\u003e  };\u003c/p\u003e\u003cp\u003e  return \u0026lt;button onClick={handleClick}\u0026gt;Run WebAssembly\u0026lt;/button\u0026gt;;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"ea9a\"\u003eIn the code above, the \u003ccode\u003eRunButton\u003c/code\u003e component accepts two props:\u003c/p\u003e\u003cul\u003e\u003cli id=\"bef5\"\u003e\u003ccode\u003eshape\u003c/code\u003e: The shape argument to pass to the WebAssembly \u003ccode\u003erun\u003c/code\u003e function.\u003c/li\u003e\u003cli id=\"1afa\"\u003e\u003ccode\u003eonResult\u003c/code\u003e: A callback function that receives the result of the WebAssembly function and can be used to update the state or display the result in the UI.\u003c/li\u003e\u003c/ul\u003e\u003col\u003e\u003cli id=\"4b68\"\u003eIntegrating the Button in the Main Component\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"f52b\"\u003eNow, in your main component (or wherever you’d like to place the button), integrate the \u003ccode\u003eRunButton\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8ef0\"\u003eimport React, { useState } from \u0026#34;react\u0026#34;;\u003cbr/\u003eimport RunButton from \u0026#34;./path_to_RunButton_component\u0026#34;; // Replace with the actual path\u003cp\u003efunction App() {\u003cbr/\u003e  const [result, setResult] = useState\u0026lt;any[]\u0026gt;([]);\u003c/p\u003e\u003cp\u003e  // Define the shape content\u003cbr/\u003e  const shapeContent = {\u003cbr/\u003e    schema: `|-\u003cbr/\u003e    entity user {}\u003c/p\u003e\u003cp\u003e    entity account {\u003cbr/\u003e        relation owner @user\u003cbr/\u003e        relation following @user\u003cbr/\u003e        relation follower @user\u003c/p\u003e\u003cp\u003e        attribute public boolean\u003cbr/\u003e        action view = (owner or follower) or public  \u003cbr/\u003e    }\u003c/p\u003e\u003cp\u003e    entity post {\u003cbr/\u003e        relation account @account\u003c/p\u003e\u003cp\u003e        attribute restricted boolean\u003c/p\u003e\u003cp\u003e        action view = account.view\u003c/p\u003e\u003cp\u003e        action comment = account.following not restricted\u003cbr/\u003e        action like = account.following not restricted\u003cbr/\u003e    }`,\u003cbr/\u003e    relationships: [\u003cbr/\u003e      \u0026#34;account:1#owner@user:kevin\u0026#34;,\u003cbr/\u003e      \u0026#34;account:2#owner@user:george\u0026#34;,\u003cbr/\u003e      \u0026#34;account:1#following@user:george\u0026#34;,\u003cbr/\u003e      \u0026#34;account:2#follower@user:kevin\u0026#34;,\u003cbr/\u003e      \u0026#34;post:1#account@account:1\u0026#34;,\u003cbr/\u003e      \u0026#34;post:2#account@account:2\u0026#34;,\u003cbr/\u003e    ],\u003cbr/\u003e    attributes: [\u003cbr/\u003e      \u0026#34;account:1$public|boolean:true\u0026#34;,\u003cbr/\u003e      \u0026#34;account:2$public|boolean:false\u0026#34;,\u003cbr/\u003e      \u0026#34;post:1$restricted|boolean:false\u0026#34;,\u003cbr/\u003e      \u0026#34;post:2$restricted|boolean:true\u0026#34;,\u003cbr/\u003e    ],\u003cbr/\u003e    scenarios: [\u003cbr/\u003e      {\u003cbr/\u003e        name: \u0026#34;Account Viewing Permissions\u0026#34;,\u003cbr/\u003e        description:\u003cbr/\u003e          \u0026#34;Evaluate account viewing permissions for \u0026#39;kevin\u0026#39; and \u0026#39;george\u0026#39;.\u0026#34;,\u003cbr/\u003e        checks: [\u003cbr/\u003e          {\u003cbr/\u003e            entity: \u0026#34;account:1\u0026#34;,\u003cbr/\u003e            subject: \u0026#34;user:kevin\u0026#34;,\u003cbr/\u003e            assertions: {\u003cbr/\u003e              view: true,\u003cbr/\u003e            },\u003cbr/\u003e          },\u003cbr/\u003e        ],\u003cbr/\u003e      },\u003cbr/\u003e    ],\u003cbr/\u003e  };\u003c/p\u003e\u003cp\u003e  return (\u003cbr/\u003e    \u0026lt;div\u0026gt;\u003cbr/\u003e      \u0026lt;RunButton shape={JSON.stringify(shapeContent)} onResult={setResult} /\u0026gt;\u003cbr/\u003e      \u0026lt;div\u0026gt;\u003cbr/\u003e        Results:\u003cbr/\u003e        \u0026lt;ul\u0026gt;\u003cbr/\u003e          {result.map((item, index) =\u0026gt; (\u003cbr/\u003e            \u0026lt;li key={index}\u0026gt;{item}\u0026lt;/li\u0026gt;\u003cbr/\u003e          ))}\u003cbr/\u003e        \u0026lt;/ul\u0026gt;\u003cbr/\u003e      \u0026lt;/div\u0026gt;\u003cbr/\u003e    \u0026lt;/div\u0026gt;\u003cbr/\u003e  );\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e931\"\u003eIn this example, \u003ccode\u003eApp\u003c/code\u003e is a component that contains the \u003ccode\u003eRunButton\u003c/code\u003e. When the button is clicked, the result from the WebAssembly function is displayed in a list below the button.\u003c/p\u003e\u003ch2 id=\"1cef\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"dc6f\"\u003eThroughout this exploration, the integration of WebAssembly with Go was unfolded, illuminating the pathway toward enhanced web development and optimal user interactions within browsers.\u003c/p\u003e\u003cp id=\"ebed\"\u003eThe journey involved setting up the Go environment, converting Go code to WebAssembly, and executing it within a web context, ultimately giving life to the interactive platform showcased at \u003ca href=\"https://play.permify.co/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eplay.permify.co\u003c/a\u003e.\u003c/p\u003e\u003cp id=\"2c4e\"\u003eThis platform stands not only as an example but also as a beacon, illustrating the concrete and potent capabilities achievable when intertwining these technological domains.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": "2023-11-10T17:31:06.352Z",
  "modifiedTime": null
}
