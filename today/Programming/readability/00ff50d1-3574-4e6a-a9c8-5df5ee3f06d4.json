{
  "id": "00ff50d1-3574-4e6a-a9c8-5df5ee3f06d4",
  "title": "Keep the databases top-notch",
  "link": "https://engineering.prezi.com/keep-the-databases-top-notch-96b2d004e1cf?source=rss----911e72786e31---4",
  "description": "",
  "author": "Alex",
  "published": "Tue, 09 May 2023 12:58:13 GMT",
  "source": "https://engineering.prezi.com/feed",
  "categories": [
    "blue-green-deployment",
    "rds",
    "aws"
  ],
  "byline": "Alex",
  "length": 5427,
  "excerpt": "Databases are often the most critical parts of applications. Prezi is no exception to this. We store and read persistent data from many different databases while serving requests from our users…",
  "siteName": "Prezi Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*U0lNGgJfm0Qo1ZfYDS36KA.png",
  "text": "Photo by ThisisEngineering RAEng on UnsplashDatabases are often the most critical parts of applications. Prezi is no exception to this. We store and read persistent data from many different databases while serving requests from our users.There is often some hesitation when it comes to updating databases. Taking down databases for maintenance usually takes down the services that use them.Early this year, the SRE team started to work on the maintenance task for our AWS RDS MySQL instances. We started looking at our options.The “maintenance window” approachA very classical approach is to define a maintenance window and do the necessary actions within this window. This works but is not a very user-friendly approach. It is even worse if one operates at a global scale from a central infrastructure: which user do you want to hit with the downtime?A benefit of this approach is that you create a clear state in the database before the action by disabling all writing operations at the beginning. In case the application can serve only read-only traffic, it is also possible to offer a read-only instance during the maintenance window.As we looked into the services that would be affected by our maintenance, we discovered that two services within the critical path of our user experience were affected. Declaring a maintenance window and shutting down the service would have been a major degradation of our offered service.We ran tests on snapshots of those instances and concluded that we would need a downtime of roughly 1 hour to be finished.We said: this is only the way to go if we find nothing else.The “poor man’s blue/green” approachThere are some strategies that can help to hide most of the downtime from your users. It is possible to access a database through a load balancer that is able to forward traffic only to a specific instance.It is also possible to use a primary/secondary setup where you can promote an already patched instance to become the new primary instance.Most of the time, the challenge in this approach is the synchronization between the instances — just to name some: transactions, foreign keys, and network latency between the different systems that can make transactions tedious.And this design pattern must be incorporated from the beginning. Changing the setup from connecting to a single instance to an advanced setup needs downtime too.Another downside of this approach is: You have to pay for both instances.For our case, this approach wasn’t the way to go as we didn’t build most of our databases in such a design.Enter: AWS RDS Blue/Green deploymentAWS introduced blue/green deployment at the Re:Invent late in 2022. There is this overlay at the top of the RDS console that keeps coming up and tells you to try blue/green deployment.AWS ConsoleBlue/Green offers the possibility to create a database cluster on the fly from a primary instance (blue). The newly created instance (green) can be updated without affecting the primary instance. There is a logical sync from blue to green. Under the hood, AWS RDS creates a MySql replication that syncs contents from the blue environment to the green one.The initial creation of the blue/green setup is transparent for the applications that use the database. So you can set up all the things without affecting your users.A configured Blue/Green deploymentOnce ready and running, the connections can be switched over from blue to green with a short downtime of approximately 1 minute.Switchover summaryAfter successfully switching traffic from the blue to the green database, the old instance is retained. It can serve as a fallback if the new instance is somehow broken. Once confident that nothing was broken, it can be removed. So you only have to run 2 databases at a time for the time of maintenance tasks.Ex-Blue/Green deploymentIn the past 4 weeks, we used this approach for updating roughly 30 databases to the latest MySQL minor version. It worked like a charm. Even for our most critical databases, we were able to reduce the downtime to approximately 3 minutes.Things we learned during that process:There is no way back after you’ve triggered the switchover process. After moving the traffic over from blue to green, you’ll end up with two independent instances that are no longer in sync. The replication in between is gone.Your old instance even has a new VPC endpoint. There is no way to sync those databases again. This means: If you need the old instance again, a possible rollback can be a re-deployment of the application with a config that uses the old instance again.Doing downtime-free database upgrades manually is a tedious, complex, and error-prone process. It involves a lot of clicking and a lot of waiting. It would be better to automate the steps.Take care that you select the correct MySQL parameter group while setting up your blue/green deployment. You can’t change this on the green instance afterward. It cost us some time to rebuild the blue/green deployment.Always do a manual and fresh snapshot before any actions. Even though we did not need it, it makes you more confident if you have a clear state to go back to.ConclusionThe blue/green deployment makes database updates easy and very user-friendly.The next step is building automation scripts around this, which prepare everything up to the point of the switchover. This will make the process less error-prone and it will require less engineer time.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*JA0F7dKbF1y3Cc6T",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@la3mmchen?source=post_page-----96b2d004e1cf--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Alex\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*qlKWQ5hAPbo5cLIv_PuLSQ.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://engineering.prezi.com/?source=post_page-----96b2d004e1cf--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Prezi Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*ecIYF5KMJj1G4-_pkFWy0g.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003ePhoto by \u003ca href=\"https://unsplash.com/@thisisengineering?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eThisisEngineering RAEng\u003c/a\u003e on \u003ca href=\"https://unsplash.com/?utm_source=medium\u0026amp;utm_medium=referral\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUnsplash\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"02ed\"\u003eDatabases are often the most critical parts of applications. Prezi is no exception to this. \u003cbr/\u003eWe store and read persistent data from many different databases while serving requests from our users.\u003c/p\u003e\u003cp id=\"ecad\"\u003eThere is often some hesitation when it comes to updating databases. Taking down databases for maintenance usually takes down the services that use them.\u003c/p\u003e\u003cp id=\"6825\"\u003eEarly this year, the SRE team started to work on the maintenance task for our AWS RDS MySQL instances. We started looking at our options.\u003c/p\u003e\u003ch2 id=\"de89\"\u003eThe “maintenance window” approach\u003c/h2\u003e\u003cp id=\"e7ca\"\u003eA very classical approach is to define a maintenance window and do the necessary actions within this window. This works but is not a very user-friendly approach. It is even worse if one operates at a global scale from a central infrastructure: which user do you want to hit with the downtime?\u003c/p\u003e\u003cp id=\"41c0\"\u003eA benefit of this approach is that you create a clear state in the database before the action by disabling all writing operations at the beginning. In case the application can serve only read-only traffic, it is also possible to offer a read-only instance during the maintenance window.\u003c/p\u003e\u003cp id=\"3521\"\u003eAs we looked into the services that would be affected by our maintenance, we discovered that two services within the critical path of our user experience were affected. Declaring a maintenance window and shutting down the service would have been a major degradation of our offered service.\u003c/p\u003e\u003cp id=\"a9f4\"\u003eWe ran tests on snapshots of those instances and concluded that we would need a downtime of roughly 1 hour to be finished.\u003c/p\u003e\u003cp id=\"0a43\"\u003eWe said: this is only the way to go if we find nothing else.\u003c/p\u003e\u003ch2 id=\"7a3c\"\u003eThe “poor man’s blue/green” approach\u003c/h2\u003e\u003cp id=\"4d68\"\u003eThere are some strategies that can help to hide most of the downtime from your users. It is possible to access a database through a load balancer that is able to forward traffic only to a specific instance.\u003c/p\u003e\u003cp id=\"8a8e\"\u003eIt is also possible to use a primary/secondary setup where you can promote an already patched instance to become the new primary instance.\u003c/p\u003e\u003cp id=\"7b32\"\u003eMost of the time, the challenge in this approach is the synchronization between the instances — just to name some: transactions, foreign keys, and network latency between the different systems that can make transactions tedious.\u003c/p\u003e\u003cp id=\"7461\"\u003eAnd this design pattern must be incorporated from the beginning. Changing the setup from connecting to a single instance to an advanced setup needs downtime too.\u003c/p\u003e\u003cp id=\"7495\"\u003eAnother downside of this approach is: You have to pay for both instances.\u003c/p\u003e\u003cp id=\"6bac\"\u003eFor our case, this approach wasn’t the way to go as we didn’t build most of our databases in such a design.\u003c/p\u003e\u003ch2 id=\"3d41\"\u003eEnter: AWS RDS Blue/Green deployment\u003c/h2\u003e\u003cp id=\"fd2e\"\u003eAWS introduced \u003ca href=\"https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/blue-green-deployments-overview.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eblue/green deployment\u003c/a\u003e at the Re:Invent late in 2022. There is this overlay at the top of the RDS console that keeps coming up and tells you to try blue/green deployment.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eAWS Console\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ab77\"\u003eBlue/Green offers the possibility to create a database cluster on the fly from a primary instance (blue). The newly created instance (green) can be updated without affecting the primary instance. There is a logical sync from blue to green. Under the hood, AWS RDS creates a MySql replication that syncs contents from the blue environment to the green one.\u003c/p\u003e\u003cp id=\"10ef\"\u003eThe initial creation of the blue/green setup is transparent for the applications that use the database. So you can set up all the things without affecting your users.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eA configured Blue/Green deployment\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"b699\"\u003eOnce ready and running, the connections can be switched over from blue to green with a short downtime of approximately 1 minute.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSwitchover summary\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"57d4\"\u003eAfter successfully switching traffic from the blue to the green database, the old instance is retained. It can serve as a fallback if the new instance is somehow broken. Once confident that nothing was broken, it can be removed. So you only have to run 2 databases at a time for the time of maintenance tasks.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eEx-Blue/Green deployment\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"fd20\"\u003eIn the past 4 weeks, we used this approach for updating roughly 30 databases to the latest MySQL minor version. It worked like a charm. Even for our most critical databases, we were able to reduce the downtime to approximately 3 minutes.\u003c/p\u003e\u003cp id=\"7a64\"\u003eThings we learned during that process:\u003c/p\u003e\u003cul\u003e\u003cli id=\"14dc\"\u003eThere is no way back after you’ve triggered the switchover process. After moving the traffic over from blue to green, you’ll end up with two independent instances that are no longer in sync. The replication in between is gone.\u003cbr/\u003eYour old instance even has a new VPC endpoint. There is no way to sync those databases again. \u003cbr/\u003eThis means: If you need the old instance again, a possible rollback can be a re-deployment of the application with a config that uses the old instance again.\u003c/li\u003e\u003cli id=\"729d\"\u003eDoing downtime-free database upgrades manually is a tedious, complex, and error-prone process. It involves a lot of clicking and a lot of waiting. It would be better to automate the steps.\u003c/li\u003e\u003cli id=\"b530\"\u003eTake care that you select the correct MySQL parameter group while setting up your blue/green deployment. You can’t change this on the green instance afterward. It cost us some time to rebuild the blue/green deployment.\u003c/li\u003e\u003cli id=\"1e39\"\u003eAlways do a manual and fresh snapshot before any actions. Even though we did not need it, it makes you more confident if you have a clear state to go back to.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5bee\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"cc22\"\u003eThe blue/green deployment makes database updates easy and very user-friendly.\u003c/p\u003e\u003cp id=\"e604\"\u003eThe next step is building automation scripts around this, which prepare everything up to the point of the switchover. This will make the process less error-prone and it will require less engineer time.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2023-05-09T12:58:13.278Z",
  "modifiedTime": null
}
