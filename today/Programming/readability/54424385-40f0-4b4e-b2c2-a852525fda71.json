{
  "id": "54424385-40f0-4b4e-b2c2-a852525fda71",
  "title": "Ktor 3.0 Is Now Available With New Features and Improved Performance",
  "link": "https://blog.jetbrains.com/kotlin/2024/10/ktor-3-0/",
  "description": "This new version uses Kotlin 2.0 and switches to kotlinx-io, making Ktor more up to date and better connected with other Kotlin tools. Ktor 3.0 works faster and gives you more options for building client-server applications. If youâ€™re new to Ktor or need a reminder about how it works, our recent blog post, Ktor 101: [â€¦]",
  "author": "Anton Arhipov",
  "published": "Thu, 10 Oct 2024 15:18:14 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "ktor",
    "news",
    "release"
  ],
  "byline": "Anton Arhipov",
  "length": 11412,
  "excerpt": "Ktor 3.0 is faster, better integrated with Kotlin tools, and offers more options for client-server apps. Find more details in the blog post.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains Ktor NewsKtor 3.0 Is Now Available With New Features and Improved Performance This new version uses Kotlin 2.0 and switches to kotlinx-io, making Ktor more up to date and better connected with other Kotlin tools. Ktor 3.0 works faster and gives you more options for building client-server applications. If youâ€™re new to Ktor or need a reminder about how it works, our recent blog post, Ktor 101: Efficient JVM HTTP Toolkit, explains its main features. The following post will give you a solid overview of whatâ€™s new and improved in Ktor 3.0. Build now with Ktor 3.0! Migrating to kotlinx-io The biggest change in this new version is the switch to the kotlinx-io library, which is based on Okio. This change may affect you if you use Ktorâ€™s low-level IO APIs. We made this change to standardize IO functionality across Kotlin libraries and improve performance, as shown in our benchmarks. Breaking changes The changes mainly affect low-level IO APIs, including classes like Input, Output, ByteReadChannel, and ByteWriteChannel. If you use these classes directly, youâ€™ll see deprecation warnings. You should update your code to use the alternatives provided by the kotlinx-io library. Donâ€™t worry â€“ weâ€™ll keep supporting the old APIs until version 4.0, giving you ample time to migrate. The new kotlinx-io library offers a multiplatform API that can handle various data sources and provides a range of capabilities, including working with files, using compression, and more. For more details, check out the kotlinx-io API documentation. Performance improvements By switching to kotlinx-io, weâ€™ve cut down on the unnecessary copying of bytes between ByteReadChannel, ByteWriteChannel, and network interfaces. This allows for more efficient byte transformations and parsing, making room for future performance improvements. Our IO benchmark tests, based on real-world Ktor applications, show impressive results. Some tests saw over 90% improvement, and weâ€™re working on even more enhancements. Support for server-sent events (SSE) In Ktor 3.0, we added the initial support for server-sent events (SSE) both for the server and the client. Server-sent events is a technology that enables servers to push events to clients over an HTTP connection. SSE provides a one-way communication channel from the server to the client. This approach is useful for scenarios where the server needs to send event-based updates without requiring the client to repeatedly poll for new information. To implement SSE support in the Ktor application, first, add the SSE dependency to your projectâ€™s build script: implementation(\"io.ktor:ktor-server-sse-jvm\") Next, install the SSE plugin in your Ktor application, and create an endpoint using the sse{} function: import io.ktor.server.application.* import io.ktor.server.engine.* import io.ktor.server.netty.* import io.ktor.server.routing.* import io.ktor.server.sse.* import io.ktor.sse.* import kotlinx.coroutines.delay fun main() { embeddedServer(Netty, port = 8080) { install(SSE) routing { sse { repeat(42) { val name = call.parameters[\"name\"] ?: \"World\" send(ServerSentEvent(data = \"Hello, $name! $it\")) delay(1000) } close() } } }.start(wait = true) } Within the sse {...} block, you have access to a ServerSSESession instance with the following capabilities. send(): Create and send a ServerSentEvent to the client. call: Access the associated ApplicationCall that initiated the session. close(): End the session and terminate the connection with the client. Please note that currently, Ktor does not provide support for data compression of SSE responses. If you use the Compression plugin, it will skip compression for SSE responses by default. To consume the events using the Ktor client, in the simplest case, you only need to invoke the sse function on the client instance as follows: import io.ktor.client.* import io.ktor.client.engine.cio.* import io.ktor.client.plugins.sse.* import kotlinx.coroutines.runBlocking fun main() { val client = HttpClient(CIO) { install(SSE) } runBlocking { client.sse(host = \"127.0.0.1\", port = 8080, path = \"/sse\") { incoming.collect { event -\u003e println(event) } } } } In the example above, the client will consume the events as long as the server is sending the data. Serving static resources from ZIP archives The new function, staticZip, allows users to serve the contents of a ZIP archive as static content. Hereâ€™s a basic example of how to use it: routing { staticZip( remotePath = \"/\", basePath = \"base\", Path(\"files/text-files.zip\") ) { default(\"file.txt\") //modify the response by adding the HTTP Etag header modify { path, call -\u003e call.response.headers.append(HttpHeaders.ETag, path.fileName.toString()) } } } Letâ€™s break down the example into the key components: remotePath â€“ the base URL path where the ZIP contents will be accessible. basePath â€“ the base path within the ZIP file you wish to serve. In our example, we assume that the ZIP archive contains the base directory. All paths inside the specified basePath will be accessible recursively at \"remotePath/path/to/resource\". This means you can organize your ZIP file with subfolders, and theyâ€™ll be reflected in the URL structure. Path(\"files/text-files.zip\")â€“ the path to the ZIP file you want to serve. The default() function â€“ this allows you to specify a default file to serve if no specific file is requested. The modify block â€“ this enables you to customize the response. In this example, weâ€™re adding an ETag header based on the file name. See the full example on the Ktor samples repository on GitHub. Support for CSRF Support for CSRF (Cross-Site Request Forgery) protection was added with the new plugin. Protection is enabled for state-changing operations including POST, PUT, and DELETE. Generally, itâ€™s applicable only for projects that use session cookies and forms, since enabling this can unnecessarily complicate your application. To enable CSRF support in the Ktor application, first, add the following dependency to your projectâ€™s build script: implementation(\"io.ktor:ktor-server-csrf-jvm\") Next, you can enable the CSRF protection for the selected routes in the application as follows: route(\"/csrf\") { install(CSRF) { allowOrigin(\"https://localhost:8080\") originMatchesHost() checkHeader(\"X-CSRF\") { csrfHeader -\u003e request.headers[HttpHeaders.Origin]?.let { origin -\u003e csrfHeader == origin.hashCode().toString(32) // 1ndrgg9 } == true } onFailure { respondText(\"Access denied!\", status = HttpStatusCode.Forbidden) } } post { call.respondText(\"CSRF check was successful\") } } In the configuration block, the plugin provides a few methods for verifying the requests: allowOrigin specifies that only the requests from the predefined origin are allowed. In our example, itâ€™s https://localhost:8080. originMatchesHost enforces that the requestâ€™s origin must match the applicationâ€™s host. checkHeader enables arbitrary header validation. If you run the application with the code above and send a POST request to the /csrf endpoint using the curl command, you will see the following: curl -X POST -H \"Content-Type: application/json\" --data '{}' http://localhost:8080/csrf Access denied! Adding the required headers will make it pass the checks: curl -X POST -H \"X-CSRF: 1ndrgg9\" -H \"Origin: http://localhost:8080\" -H \"Content-Type: application/json\" --data '{}' http://localhost:8080/csrf CSRF check passed! Ktor client for Wasm The Ktor client now supports WebAssembly (Wasm) as a build target. While Kotlin/Wasm is still in its early stages (Alpha), adding Wasm support to the Ktor client is an important step in expanding the Kotlin Multiplatform ecosystem. To showcase this new capability, weâ€™ve created a sample Compose Multiplatform project that uses the Ktor client with a WebAssembly (wasmJs) target. To use the Ktor client, you need to add the corresponding dependency to your projectâ€™s build script: implementation(\"io.ktor:ktor-client-core:$ktor_version\") Migration Guide Ktor 3.0 brings some significant changes. We have prepared a migration guide for you to make the transition easier. Here, we highlight the most notable changes. Whether you upgrade your existing projects to Ktor 3.0 or not, you can start building your new projects with Ktor 3.0 right away! Start a new project with Ktor 3.0 Explicit loading of modulesï»¿ in TestApplication From now on, the TestApplication class requires explicit loading of modules. The following test will start an empty application and will not load any modules: @Test fun testRoot() = testApplication {// TestApplication scope client.get(\"/\").apply { assertEquals(HttpStatusCode.OK, status) assertEquals(\"Hello World!\", bodyAsText()) } } Instead, you must explicitly load your modules within the testApplication function or load the configuration file manually. @Test fun testRoot() = testApplication { application { configureRouting() } client.get(\"/\").apply { assertEquals(HttpStatusCode.OK, status) assertEquals(\"Hello World!\", bodyAsText()) } } Plugin updates The CallLogging plugin package has been renamed, fixing a typo: The Locations plugin has been replaced with the new Resources plugin for type-safe routing. These changes aim to improve Ktorâ€™s architecture, security, and developer experience. Users upgrading from Ktor 2.x should refer to the detailed migration guide to ensure a smooth transition to the new version. What else to read and watch ðŸ“° The Ktor Roadmap for 2024 ðŸ“° The Ktor Plugin Registry Has Launched! ðŸ“° Ktor 101: Efficient JVM HTTP Toolkit ðŸŽ¥ Managing Complexity With Ktor ðŸŽ¥ Extending Ktor: Unleash the Full Potential of Kotlinâ€™s Web Framework Your Ktor teamJetBrainsThe Drive to Develop Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/10/Social_Share_1280x720-2x.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/ktor/\"\u003eKtor\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/kotlin/category/news/\"\u003eNews\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eKtor 3.0 Is Now Available With New Features and Improved Performance\u003c/h2\u003e                    \n                    \n\u003cp\u003eThis new version uses Kotlin 2.0 and switches to \u003ca href=\"http://kotlinx.io\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ekotlinx-io\u003c/a\u003e, making Ktor more up to date and better connected with other Kotlin tools. Ktor 3.0 works faster and gives you more options for building client-server applications.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf youâ€™re new to Ktor or need a reminder about how it works, our recent blog post, \u003ca href=\"https://blog.jetbrains.com/idea/2024/09/ktor-101-efficient-jvm-http-toolkit/\"\u003eKtor 101: Efficient JVM HTTP Toolkit\u003c/a\u003e, explains its main features.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe following post will give you a solid overview of whatâ€™s new and improved in Ktor 3.0.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca title=\"Build now with Ktor 3.0!\" href=\"https://kotl.in/rc94yb\" target=\"_blank\" rel=\"noopener\"\u003eBuild now with Ktor 3.0!\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eMigrating to kotlinx-io\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe biggest change in this new version is the switch to the \u003ca href=\"https://github.com/Kotlin/kotlinx-io/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ekotlinx-io\u003c/a\u003e library, which is based on \u003ca href=\"https://github.com/square/okio\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eOkio\u003c/a\u003e. This change may affect you if you use Ktorâ€™s low-level IO APIs. We made this change to standardize IO functionality across Kotlin libraries and improve performance, as shown in our benchmarks.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBreaking changes\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe changes mainly affect low-level IO APIs, including classes like \u003ca href=\"https://github.com/ktorio/ktor/blob/main/ktor-io/common/src/io/ktor/utils/io/core/Input.kt\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eInput\u003c/a\u003e, \u003ca href=\"https://github.com/ktorio/ktor/blob/main/ktor-io/common/src/io/ktor/utils/io/core/Output.kt\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eOutput\u003c/a\u003e, \u003ca href=\"https://github.com/ktorio/ktor/blob/main/ktor-io/common/src/io/ktor/utils/io/ByteReadChannel.kt\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eByteReadChannel\u003c/a\u003e, and \u003ca href=\"https://github.com/ktorio/ktor/blob/main/ktor-io/common/src/io/ktor/utils/io/ByteWriteChannel.kt\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eByteWriteChannel\u003c/a\u003e. If you use these classes directly, youâ€™ll see deprecation warnings. You should update your code to use the alternatives provided by the kotlinx-io library. Donâ€™t worry â€“ weâ€™ll keep supporting the old APIs until version 4.0, giving you ample time to migrate.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe new kotlinx-io library offers a multiplatform API that can handle various data sources and provides a range of capabilities, including working with files, using compression, and more. For more details, check out the kotlinx-io \u003ca href=\"https://kotlin.github.io/kotlinx-io/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eAPI documentation\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003ePerformance improvements\u003c/h2\u003e\n\n\n\n\u003cp\u003eBy switching to kotlinx-io, weâ€™ve cut down on the unnecessary copying of bytes between \u003ccode\u003eByteReadChannel\u003c/code\u003e, \u003ccode\u003eByteWriteChannel\u003c/code\u003e, and network interfaces. This allows for more efficient byte transformations and parsing, making room for future performance improvements.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur \u003ca href=\"https://github.com/ktorio/ktor-benchmarks/tree/main/io-benchmarks\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eIO benchmark\u003c/a\u003e tests, based on real-world Ktor applications, show impressive results. Some tests saw over 90% improvement, and weâ€™re working on even more enhancements.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1974\" height=\"768\" data-id=\"516893\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/ktor-3-io-benchmarks.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\u003c/figure\u003e\n\n\n\n\u003ch2\u003eSupport for server-sent events (SSE)\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn Ktor 3.0, we added the initial support for server-sent events (SSE) both for the server and the client.\u003c/p\u003e\n\n\n\n\u003cp\u003eServer-sent events is a technology that enables servers to push events to clients over an HTTP connection. SSE provides a one-way communication channel from the server to the client. This approach is useful for scenarios where the server needs to send event-based updates without requiring the client to repeatedly poll for new information.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo implement SSE support in the Ktor application, first, add the SSE dependency to your projectâ€™s build script:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimplementation(\u0026#34;io.ktor:ktor-server-sse-jvm\u0026#34;)\u003c/pre\u003e\n\n\n\n\n\n\n\n\u003cp\u003eNext, install the SSE plugin in your Ktor application, and create an endpoint using the \u003ccode\u003esse{}\u003c/code\u003e function:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport io.ktor.server.application.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\nimport io.ktor.server.routing.*\nimport io.ktor.server.sse.*\nimport io.ktor.sse.*\nimport kotlinx.coroutines.delay\n\nfun main() {\n   embeddedServer(Netty, port = 8080) {\n       install(SSE)\n       routing {\n           sse {\n               repeat(42) {\n                   val name = call.parameters[\u0026#34;name\u0026#34;] ?: \u0026#34;World\u0026#34;\n                   send(ServerSentEvent(data = \u0026#34;Hello, $name! $it\u0026#34;))\n                   delay(1000)\n               }\n               close()\n           }\n       }\n   }.start(wait = true)\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWithin the \u003ccode\u003esse {...}\u003c/code\u003e block, you have access to a \u003ccode\u003eServerSSESession\u003c/code\u003e instance with the following capabilities.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esend()\u003c/code\u003e: Create and send a \u003ccode\u003eServerSentEvent\u003c/code\u003e to the client.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ecall\u003c/code\u003e: Access the associated \u003ccode\u003eApplicationCall\u003c/code\u003e that initiated the session.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eclose()\u003c/code\u003e: End the session and terminate the connection with the client.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003ePlease note that currently, Ktor does not provide support for data compression of SSE responses. If you use the Compression plugin, it will skip compression for SSE responses by default.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo consume the events using the Ktor client, in the simplest case, you only need to invoke the \u003ccode\u003esse\u003c/code\u003e function on the client instance as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport io.ktor.client.*\nimport io.ktor.client.engine.cio.*\nimport io.ktor.client.plugins.sse.*\nimport kotlinx.coroutines.runBlocking\n\nfun main() {\n   val client = HttpClient(CIO) {\n       install(SSE)\n   }\n\n   runBlocking {\n       client.sse(host = \u0026#34;127.0.0.1\u0026#34;, port = 8080, path = \u0026#34;/sse\u0026#34;) {\n           incoming.collect { event -\u0026gt; println(event) }\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn the example above, the client will consume the events as long as the server is sending the data.\u003c/p\u003e\n\n\n\n\u003ch2\u003eServing static resources from ZIP archives\u003c/h2\u003e\n\n\n\n\u003cdiv\u003e\u003cp\u003eThe new function, \u003ccode\u003estaticZip\u003c/code\u003e, allows users to serve the contents of a ZIP archive as static content. \u003c/p\u003e\u003cp\u003eHereâ€™s a basic example of how to use it:\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003erouting {\n   staticZip(\n       remotePath = \u0026#34;/\u0026#34;,\n       basePath = \u0026#34;base\u0026#34;, \n       Path(\u0026#34;files/text-files.zip\u0026#34;)\n   ) {\n       default(\u0026#34;file.txt\u0026#34;)\n\n       //modify the response by adding the HTTP Etag header\n       modify { path, call -\u0026gt;\n           call.response.headers.append(HttpHeaders.ETag,\n        path.fileName.toString())\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eLetâ€™s break down the example into the key components:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eremotePath\u003c/code\u003e â€“ the base URL path where the ZIP contents will be accessible.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ebasePath\u003c/code\u003e â€“ the base path within the ZIP file you wish to serve. In our example, we assume that the ZIP archive contains the \u003ccode\u003ebase\u003c/code\u003e directory. All paths inside the specified \u003ccode\u003ebasePath\u003c/code\u003e will be accessible recursively at \u003ccode\u003e\u0026#34;remotePath/path/to/resource\u0026#34;\u003c/code\u003e. This means you can organize your ZIP file with subfolders, and theyâ€™ll be reflected in the URL structure.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003ePath(\u0026#34;files/text-files.zip\u0026#34;)\u003c/code\u003eâ€“ the path to the ZIP file you want to serve.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003edefault()\u003c/code\u003e function â€“ this allows you to specify a default file to serve if no specific file is requested.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003emodify\u003c/code\u003e block â€“ this enables you to customize the response. In this example, weâ€™re adding an ETag header based on the file name.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eSee the full example on the \u003ca href=\"https://github.com/ktorio/ktor-documentation/tree/3.0.0-beta-2/codeSnippets/snippets/static-zip\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKtor samples repository on GitHub\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSupport for CSRF\u003c/h2\u003e\n\n\n\n\u003cp\u003eSupport for CSRF (\u003ca href=\"https://owasp.org/www-community/attacks/csrf\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eCross-Site Request Forgery\u003c/a\u003e) protection was added with the new plugin. Protection is enabled for state-changing operations including POST, PUT, and DELETE.\u003c/p\u003e\n\n\n\n\u003cp\u003eGenerally, itâ€™s applicable only for projects that use session cookies and forms, since enabling this can unnecessarily complicate your application.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo enable CSRF support in the Ktor application, first, add the following dependency to your projectâ€™s build script:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimplementation(\u0026#34;io.ktor:ktor-server-csrf-jvm\u0026#34;)\u003c/pre\u003e\n\n\n\n\u003cp\u003eNext, you can enable the CSRF protection for the selected routes in the application as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eroute(\u0026#34;/csrf\u0026#34;) {\n   install(CSRF) {\n       allowOrigin(\u0026#34;https://localhost:8080\u0026#34;)\n\n       originMatchesHost()\n\n       checkHeader(\u0026#34;X-CSRF\u0026#34;) { csrfHeader -\u0026gt;\n           request.headers[HttpHeaders.Origin]?.let { origin -\u0026gt;\n               csrfHeader == origin.hashCode().toString(32) // 1ndrgg9\n           } == true\n       }\n\n       onFailure {\n           respondText(\u0026#34;Access denied!\u0026#34;, status = HttpStatusCode.Forbidden)\n       }\n   }\n   post {\n       call.respondText(\u0026#34;CSRF check was successful\u0026#34;)\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eIn the configuration block, the plugin provides a few methods for verifying the requests:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eallowOrigin\u003c/code\u003e specifies that only the requests from the predefined origin are allowed. In our example, itâ€™s \u003ccode\u003ehttps://localhost:8080\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eoriginMatchesHost\u003c/code\u003e enforces that the requestâ€™s origin must match the applicationâ€™s host.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003echeckHeader\u003c/code\u003e enables arbitrary header validation.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf you run the application with the code above and send a \u003ccode\u003ePOST\u003c/code\u003e request to the \u003ccode\u003e/csrf\u003c/code\u003e endpoint using the \u003ccode\u003ecurl\u003c/code\u003e command, you will see the following:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ecurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{}\u0026#39; http://localhost:8080/csrf\nAccess denied!\u003c/pre\u003e\n\n\n\n\u003cp\u003eAdding the required headers will make it pass the checks:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ecurl -X POST -H \u0026#34;X-CSRF: 1ndrgg9\u0026#34; -H \u0026#34;Origin: http://localhost:8080\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; --data \u0026#39;{}\u0026#39; http://localhost:8080/csrf\nCSRF check passed!\u003c/pre\u003e\n\n\n\n\u003ch2\u003eKtor client for Wasm\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe Ktor client now supports WebAssembly (Wasm) as a build target. While \u003ca href=\"https://kotlinlang.org/docs/wasm-overview.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin/Wasm\u003c/a\u003e is still in its early stages (Alpha), adding Wasm support to the Ktor client is an important step in expanding the Kotlin Multiplatform ecosystem. To showcase this new capability, weâ€™ve created a \u003ca href=\"https://github.com/antonarhipov/ktor-samples-fork/tree/main/ktor-client-wasm\" target=\"_blank\" rel=\"noreferrer noopener\"\u003esample Compose Multiplatform project\u003c/a\u003e that uses the Ktor client with a WebAssembly (\u003ccode\u003ewasmJs\u003c/code\u003e) target.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo use the Ktor client, you need to add the corresponding dependency to your projectâ€™s build script:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimplementation(\u0026#34;io.ktor:ktor-client-core:$ktor_version\u0026#34;)\u003c/pre\u003e\n\n\n\n\u003ch2\u003eMigration Guide\u003c/h2\u003e\n\n\n\n\u003cp\u003eKtor 3.0 brings some significant changes. We have prepared a \u003ca href=\"https://ktor.io/docs/migrating-3.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003emigration guide\u003c/a\u003e for you to make the transition easier. Here, we highlight the most notable changes.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhether you upgrade your existing projects to Ktor 3.0 or not, you can start building your new projects with Ktor 3.0 right away!\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca title=\"Build now with Ktor 3.0!\" href=\"https://kotl.in/mx6tmq\" target=\"_blank\" rel=\"noopener\"\u003eStart a new project with Ktor 3.0\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003ch3\u003eExplicit loading of modulesï»¿ in \u003ccode\u003eTestApplication\u003c/code\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eFrom now on, the \u003ca href=\"https://api.ktor.io/ktor-server/ktor-server-test-host/io.ktor.server.testing/-test-application/index.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eTestApplication\u003c/a\u003e class requires explicit loading of modules. The following test will start an empty application and will not load any modules:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e @Test\n fun testRoot() = testApplication {// TestApplication scope\n   client.get(\u0026#34;/\u0026#34;).apply {\n     assertEquals(HttpStatusCode.OK, status)\n     assertEquals(\u0026#34;Hello World!\u0026#34;, bodyAsText())\n   }\n }\u003c/pre\u003e\n\n\n\n\u003cp\u003eInstead, you must explicitly load your modules within the \u003ca href=\"https://api.ktor.io/ktor-server/ktor-server-test-host/io.ktor.server.testing/test-application.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003etestApplication\u003c/a\u003e function or load the configuration file manually.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@Test\n fun testRoot() = testApplication {\n   application {\n     configureRouting()\n   }\n   client.get(\u0026#34;/\u0026#34;).apply {\n     assertEquals(HttpStatusCode.OK, status)\n     assertEquals(\u0026#34;Hello World!\u0026#34;, bodyAsText())\n   }\n }\u003c/pre\u003e\n\n\n\n\u003ch3\u003ePlugin updates\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eCallLogging\u003c/code\u003e plugin package has been renamed, fixing a typo:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1310\" height=\"250\" data-id=\"516907\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/ktor-3-calllogging-fix.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eLocations\u003c/code\u003e plugin \u003ca href=\"https://ktor.io/docs/3.0.0-beta-2/migrating-3.html#locations-plugin-has-been-removed\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ehas been replaced\u003c/a\u003e with the new \u003ccode\u003eResources\u003c/code\u003e plugin for type-safe routing.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1302\" height=\"578\" data-id=\"516918\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/10/ktor-3-migration.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\u003c/figure\u003e\n\n\n\n\u003cp\u003eThese changes aim to improve Ktorâ€™s architecture, security, and developer experience. Users upgrading from Ktor 2.x should refer to the detailed \u003ca href=\"https://ktor.io/docs/3.0.0-beta-2/migrating-3.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003emigration guide\u003c/a\u003e to ensure a smooth transition to the new version.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat else to read and watch\u003c/h2\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eðŸ“° \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/03/the-ktor-roadmap-for-2024/\"\u003eThe Ktor Roadmap for 2024\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eðŸ“° \u003ca href=\"https://blog.jetbrains.com/kotlin/2024/04/the-ktor-plugin-registry/\"\u003eThe Ktor Plugin Registry Has Launched!\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eðŸ“° \u003ca href=\"https://blog.jetbrains.com/idea/2024/09/ktor-101-efficient-jvm-http-toolkit/\"\u003eKtor 101: Efficient JVM HTTP Toolkit\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eðŸŽ¥ \u003ca href=\"https://youtu.be/RiNRQNLcpj8?si=yYw9S13Lookl0HVb\" target=\"_blank\" rel=\"noopener\"\u003eManaging Complexity With Ktor\u003c/a\u003e \u003c/li\u003e\n\n\n\n\u003cli\u003eðŸŽ¥ \u003ca href=\"https://www.youtube.com/live/HAARGzM0ICs?si=Ejt1eesAIXLxzm_V\" target=\"_blank\" rel=\"noopener\"\u003eExtending Ktor: Unleash the Full Potential of Kotlinâ€™s Web Framework\u003c/a\u003e\u003ca href=\"https://www.youtube.com/@Kotlin\" target=\"_blank\" rel=\"noopener\"\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eYour Ktor team\u003cbr/\u003e\u003cem\u003eJetBrains\u003c/em\u003e\u003cbr/\u003e\u003cem\u003eThe Drive to Develop\u003c/em\u003e\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
