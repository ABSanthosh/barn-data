{
  "id": "cf84a3b9-2c53-407a-b123-cfbf77f01e4e",
  "title": "How to use jOOQ’s Converters with UNION Operations",
  "link": "https://blog.jooq.org/how-to-use-jooqs-converters-with-union-operations/",
  "description": "jOOQ 3.15 introduced the concept of an ad-hoc converter, a converter that is applied “ad-hoc” to a single query. It uses the same underlying mechanisms as any ordinary Converter that is attached to generated code for use in every query. An example of such an ad-hoc converter is this: While there are other ways to … Continue reading How to use jOOQ’s Converters with UNION Operations →",
  "author": "lukaseder",
  "published": "Thu, 02 Mar 2023 11:18:17 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-in-use",
    "Ad-hoc converter",
    "Converter",
    "jooq",
    "Multiset",
    "UNION"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 3750,
  "excerpt": "When using jOOQ Converters with UNION queries, remember that jOOQ will only consider the first UNION subquery's Converters, since jOOQ doesn't know which subquery contributed which rows.",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "jOOQ 3.15 introduced the concept of an ad-hoc converter, a converter that is applied “ad-hoc” to a single query. It uses the same underlying mechanisms as any ordinary Converter that is attached to generated code for use in every query. An example of such an ad-hoc converter is this: // Without the converter, assuming BOOK.ID is of type Field\u003cInteger\u003e Result\u003cRecord1\u003cInteger\u003e\u003e result = ctx.select(BOOK.ID) .from(BOOK) .fetch(); // With the converter Result\u003cRecord1\u003cLong\u003e\u003e result = ctx.select(BOOK.ID.convertFrom(i -\u003e i.longValue())) .from(BOOK) .fetch(); While there are other ways to convert data types, e.g. by using CAST() or COERCE() expressions, this approach attaches a Converter to the field, which is called right after reading the Integer value from the JDBC ResultSet in order to turn it into a Long. This conversion is done on the client side. The RDBMS that executes the query is not aware of it. That’s an important detail! The RDBMS is not aware of it! Caveat: Using UNION An interesting issue (#14693) was raised recently on the issue tracker regarding the use of such ad-hoc converters in a UNION. For example, let’s assume this query is being run: Result\u003cRecord1\u003cInteger\u003e\u003e result = ctx.select(BOOK.ID) .from(BOOK) .union( select(AUTHOR.ID) .from(AUTHOR)) .fetch(); This might produce something like: |id | |---| |1 | |2 | |3 | |4 | Assuming available BOOK.ID are [1, 2, 3, 4] and available AUTHOR.ID are [1, 2], the UNION will remove duplicates. What do you think will happen when we attach this ad-hoc converter only to the second UNION subquery? Result\u003cRecord1\u003cInteger\u003e\u003e result = ctx.select(BOOK.ID) .from(BOOK) .union( select(AUTHOR.ID.convertFrom(i -\u003e -i)) .from(AUTHOR)) .fetch(); Its goal seems to be to get the negative value of each AUTHOR.ID, while keeping the BOOK.ID intact. But remember: The conversion happens in the client, not the server, so the RDBMS isn’t aware of it This means it has no effect on the UNION operator Furthermore, jOOQ doesn’t know which UNION subquery contributes which row, so it couldn’t possibly decide whether to apply the converter or not! And that’s effectively what happens. The result is still: |id | |---| |1 | |2 | |3 | |4 | And the lambda i -\u003e -i is never called! This isn’t just true for ad-hoc converters, it’s also true for any other Converter (or Binding) that you attach to these projected columns. jOOQ will only ever consider the row type of the first UNION subquery when fetching results from a JDBC (or R2DBC) ResultSet. You only have to guarantee that both row types are compatible for the Java compiler to type check your query. Solution There are really only 2 solutions to such a situation: If you’re sure your conversion should happen in your client code (as opposed to the server), then you should apply it at least to the first UNION subquery. Ideally, you’ll just apply it to all the UNION subqueries for consistency reasons, including in case you extract a subquery for it to be reused. Possibly, you should have moved the conversion to the server side, in the first place In the latter case, this query might make more sense, if the intention was to create negative AUTHOR.ID values: Result\u003cRecord1\u003cInteger\u003e\u003e result = ctx.select(BOOK.ID) .from(BOOK) .union( select(AUTHOR.ID.neg()) .from(AUTHOR)) .fetch(); This will now produce the following SQL query: SELECT book.id FROM book UNION SELECT -author.id FROM author And a result set like this: |id | |---| |-2 | |-1 | |1 | |2 | |3 | |4 | Keep this in mind when using ad-hoc converters along with MULTISET, in particular! Post navigation",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content\"\u003e\n\t\t\u003cmain id=\"main\" role=\"main\"\u003e\n\n\t\t\t\n\u003carticle id=\"post-11981\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003ejOOQ 3.15 introduced the concept of an \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-execution/fetching/ad-hoc-converter/\" target=\"_blank\"\u003ead-hoc converter\u003c/a\u003e, a converter that is applied “ad-hoc” to a single query. It uses the same underlying mechanisms as any ordinary \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Converter.html\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Converter.html\" target=\"_blank\"\u003eConverter\u003c/a\u003e\u003c/code\u003e that is \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/codegen-database-forced-types-converter/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/code-generation/codegen-advanced/codegen-config-database/codegen-database-forced-types/codegen-database-forced-types-converter/\" target=\"_blank\"\u003eattached to generated code\u003c/a\u003e for use in every query.\u003c/p\u003e\n\n\n\n\u003cp\u003eAn example of such an ad-hoc converter is this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// Without the converter, assuming BOOK.ID is of type Field\u0026lt;Integer\u0026gt;\nResult\u0026lt;Record1\u0026lt;Integer\u0026gt;\u0026gt; result =\nctx.select(BOOK.ID)\n   .from(BOOK)\n   .fetch();\n\n// With the converter\nResult\u0026lt;Record1\u0026lt;Long\u0026gt;\u0026gt; result =\nctx.select(BOOK.ID.convertFrom(i -\u0026gt; i.longValue()))\n   .from(BOOK)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWhile there are other ways to convert data types, e.g. by using \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/cast-expressions/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/cast-expressions/\" target=\"_blank\"\u003eCAST()\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/datatype-coercions/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/column-expressions/datatype-coercions/\" target=\"_blank\"\u003eCOERCE()\u003c/a\u003e\u003c/code\u003e expressions, this approach attaches a \u003ccode\u003e\u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Converter.html\" data-type=\"URL\" data-id=\"https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Converter.html\" target=\"_blank\"\u003eConverter\u003c/a\u003e\u003c/code\u003e to the field, which is called right after reading the \u003ccode\u003eInteger\u003c/code\u003e value from the JDBC \u003ccode\u003eResultSet\u003c/code\u003e in order to turn it into a \u003ccode\u003eLong\u003c/code\u003e. This conversion is done on the client side. The RDBMS that executes the query is not aware of it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThat’s an important detail! \u003cem\u003eThe RDBMS is not aware of it!\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eCaveat: Using UNION\u003c/h2\u003e\n\n\n\n\u003cp\u003eAn interesting issue (\u003ca rel=\"noreferrer noopener\" href=\"https://github.com/jOOQ/jOOQ/issues/14693\" data-type=\"URL\" data-id=\"https://github.com/jOOQ/jOOQ/issues/14693\" target=\"_blank\"\u003e#14693\u003c/a\u003e) was raised recently on the issue tracker regarding the use of such ad-hoc converters in a \u003ccode\u003eUNION\u003c/code\u003e. For example, let’s assume this query is being run:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eResult\u0026lt;Record1\u0026lt;Integer\u0026gt;\u0026gt; result =\nctx.select(BOOK.ID)\n   .from(BOOK)\n   .union(\n    select(AUTHOR.ID)\n   .from(AUTHOR))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis might produce something like:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|id |\n|---|\n|1  |\n|2  |\n|3  |\n|4  |\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eAssuming available \u003ccode\u003eBOOK.ID\u003c/code\u003e are \u003ccode\u003e[1, 2, 3, 4]\u003c/code\u003e and available \u003ccode\u003eAUTHOR.ID\u003c/code\u003e are \u003ccode\u003e[1, 2]\u003c/code\u003e, the \u003ccode\u003eUNION\u003c/code\u003e will remove duplicates.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat do you think will happen when we attach this ad-hoc converter only to the second \u003ccode\u003eUNION\u003c/code\u003e subquery?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eResult\u0026lt;Record1\u0026lt;Integer\u0026gt;\u0026gt; result =\nctx.select(BOOK.ID)\n   .from(BOOK)\n   .union(\n    select(AUTHOR.ID.convertFrom(i -\u0026gt; -i))\n   .from(AUTHOR))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIts goal seems to be to get the negative value of each \u003ccode\u003eAUTHOR.ID\u003c/code\u003e, while keeping the \u003ccode\u003eBOOK.ID\u003c/code\u003e intact. But remember:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe conversion happens in the client, not the server, so the RDBMS isn’t aware of it\u003c/li\u003e\n\n\n\n\u003cli\u003eThis means it has no effect on the \u003ccode\u003eUNION\u003c/code\u003e operator\u003c/li\u003e\n\n\n\n\u003cli\u003eFurthermore, jOOQ doesn’t know which \u003ccode\u003eUNION\u003c/code\u003e subquery contributes which row, so it couldn’t possibly decide whether to apply the converter or not!\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAnd that’s effectively what happens. The result is still:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|id |\n|---|\n|1  |\n|2  |\n|3  |\n|4  |\u003c/pre\u003e\n\n\n\n\u003cp\u003eAnd the lambda \u003ccode\u003ei -\u0026gt; -i\u003c/code\u003e is never called! This isn’t just true for ad-hoc converters, it’s also true for any other \u003ccode\u003eConverter\u003c/code\u003e (or \u003ccode\u003eBinding\u003c/code\u003e) that you attach to these projected columns. jOOQ will only ever consider the row type of the first \u003ccode\u003eUNION\u003c/code\u003e subquery when fetching results from a JDBC (or R2DBC) \u003ccode\u003eResultSet\u003c/code\u003e. You only have to guarantee that both row types are compatible for the Java compiler to type check your query.\u003c/p\u003e\n\n\n\n\u003ch2\u003eSolution\u003c/h2\u003e\n\n\n\n\u003cp\u003eThere are really only 2 solutions to such a situation:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf you’re sure your conversion should happen in your client code (as opposed to the server), then you should apply it at least to the first \u003ccode\u003eUNION\u003c/code\u003e subquery. Ideally, you’ll just apply it to all the \u003ccode\u003eUNION\u003c/code\u003e subqueries for consistency reasons, including in case you extract a subquery for it to be reused.\u003c/li\u003e\n\n\n\n\u003cli\u003ePossibly, you should have moved the conversion to the server side, in the first place\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn the latter case, this query might make more sense, if the intention was to create negative \u003ccode\u003eAUTHOR.ID\u003c/code\u003e values:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eResult\u0026lt;Record1\u0026lt;Integer\u0026gt;\u0026gt; result =\nctx.select(BOOK.ID)\n   .from(BOOK)\n   .union(\n    select(AUTHOR.ID.neg())\n   .from(AUTHOR))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis will now produce the following SQL query:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT book.id\nFROM book\nUNION\nSELECT -author.id\nFROM author\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd a result set like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|id |\n|---|\n|-2 |\n|-1 |\n|1  |\n|2  |\n|3  |\n|4  |\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eKeep this in mind when \u003ca href=\"https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/\" data-type=\"post\" data-id=\"9172\"\u003eusing ad-hoc converters along with \u003ccode\u003eMULTISET\u003c/code\u003e\u003c/a\u003e, in particular!\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\n\n\t\u003cnav aria-label=\"Posts\"\u003e\n\t\t\u003ch2\u003ePost navigation\u003c/h2\u003e\n\t\t\n\t\u003c/nav\u003e\n\n\t\t\u003c/main\u003e\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2023-03-02T11:18:17Z",
  "modifiedTime": "2023-03-02T11:18:17Z"
}
