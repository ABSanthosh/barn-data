{
  "id": "44005d17-4a6a-46ca-8e9d-daf37999585e",
  "title": "How to streamline GitHub API calls in Azure Pipelines",
  "link": "https://github.blog/enterprise-software/ci-cd/how-to-streamline-github-api-calls-in-azure-pipelines/",
  "description": "Build a custom Azure DevOps extension that eliminates the complexity of JWT generation and token management, enabling powerful automation and enhanced security controls. The post How to streamline GitHub API calls in Azure Pipelines appeared first on The GitHub Blog.",
  "author": "Tiago Pascoal",
  "published": "Thu, 24 Jul 2025 16:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Automation",
    "CI/CD",
    "Company",
    "DevOps",
    "Enterprise software",
    "automation",
    "Azure DevOps",
    "integrations"
  ],
  "byline": "Tiago Pascoal",
  "length": 22905,
  "excerpt": "Build a custom Azure DevOps extension that eliminates the complexity of JWT generation and token management, enabling automation and security controls.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Azure Pipelines is a cloud-based continuous integration and continuous delivery (CI/CD) service that automatically builds, tests, and deploys code similarly to GitHub Actions. While it is part of Azure DevOps, Azure Pipelines has built-in support to build and deploy code stored in GitHub repositories. Because Azure Pipelines is fully integrated into GitHub development flows, pipelines can be triggered by pushes or pull requests, and it reports the results of the job execution back to GitHub via GitHub status checks. This way, developers can easily see if a given commit is healthy or block pull request merges if the pipeline is not compliant with GitHub rulesets. When you need additional functionality, you can use either extensions available in the marketplace  or GitHub APIs to deepen the integration with GitHub. Below, we’ll show how you can streamline the process of calling the GitHub API from Azure Pipelines by abstracting authentication with GitHub Apps and introducing a custom Azure DevOps extension, this will allow pipeline authors to easily authenticate against GitHub and call GitHub APIs without implementing authentication logic themselves. This approach provides enhanced security through centralized credential management, improved maintainability by standardizing GitHub integrations, time savings through cross-project reusability, and simplified operations with centrally managed updates for bug fixes. Common use cases and scenarios The GitHub API is very rich, so the possibilities for customization are almost endless. Some of the most common scenarios for GitHub calls in Azure Pipelines include: Setting status checks on commits or pull requests: Report the success or failure of pipeline steps (like tests, builds, or security scans) back to GitHub, enabling rulesets utilization to enforce policies, and providing clear feedback to developers about the health of their code changes. Adding comments to pull requests: Automatically post pipeline results, test coverage reports, performance metrics, or deployment information directly to pull request discussions, keeping all relevant information in one place for code reviewers. Updating files in repositories: Automatically update documentation, configuration files, or version numbers as part of your CI/CD process, such as updating a CHANGELOG.md file or bumping version numbers in package files. Managing GitHub Issues: Automatically create, update, or close issues based on pipeline results, such as creating bug reports when tests fail or closing issues when related features are successfully deployed. Integrating with GitHub Advanced Security: Send code scanning results to GitHub’s code scanning, enabling centralized vulnerability management, security insights, and supporting DevSecOps practices across your development workflow. Managing releases and assets: Automatically create GitHub releases and upload build artifacts, binaries, or documentation as release assets when deployments are successful, streamlining your release management process. Tracking deployments with GitHub deployments: Integrate with GitHub’s deployment API to provide visibility into deployment history and status directly in the GitHub interface. Triggering GitHub Actions workflows: Orchestrate hybrid CI/CD scenarios where Azure Pipelines handles certain build or deployment tasks and then triggers GitHub Actions workflows for additional processing or notifications. Understanding GitHub API: REST vs. GraphQL The GitHub API provides programmatic access to most of GitHub’s features and data, offering two distinct interfaces: REST and GraphQL. The REST API follows RESTful principles and provides straightforward HTTP endpoints for common operations like managing repositories, issues, pull requests, and workflows. It’s well documented, easy to get started with, and supports authentication via personal access tokens, GitHub Apps, or OAuth tokens. GitHub’s GraphQL API offers a more flexible and efficient approach to data retrieval. Unlike REST, where you might need multiple requests to gather related data, GraphQL allows you to specify exactly what data you need in a single request, reducing over-fetching and under-fetching of data. This is particularly valuable when you need to retrieve complex, nested data structures or when you want to optimize network requests in your applications. You can see some examples in Exploring GitHub CLI: How to interact with GitHub’s GraphQL API endpoint. Both APIs serve as the foundation for integrating GitHub’s functionality into external tools, automating workflows, and building custom solutions that extend GitHub’s capabilities. How to choose the right authentication method GitHub offers three primary authentication methods for accessing its APIs. Personal Access Tokens (PATs) are the simplest method, providing a token tied to a user account with specific permissions. OAuth tokens are designed for third-party applications that need to act on behalf of different users, implementing a standard authorization flow where users grant specific permissions to the application.  GitHub Apps provide the most robust and scalable solution, operating as their own entities with fine-grained permissions, installation-based access, and higher rate limits — making them ideal for organizations and production applications that need to interact with multiple repositories or organizations while maintaining tight security controls. Authentication TypeProsConsPersonal Access Tokens (PATs)– Simple to create and use– Quick to get started– Good for personal automation– Can be scoped to multiple organizations– Configurable permissions per token– Admins can revoke organization access– Configurable expiration dates– Work with most GitHub API libraries– No additional infrastructure needed– Tied to user account lifecycle– Limited to user’s permissions– Classic PATs have coarse-grained permissions– Require manual rotation– Browser-based management only– If compromised, expose all accessible organization(s)/repositoriesOAuth Tokens– Standard OAuth 2.0 flow– Organization admins control app access– Can act on behalf of multiple users– Excellent for web applications– User-approved permissions– Refresh token mechanism– Widely supported by frameworks– Good for user-facing applications– Require storing refresh tokens securely– Need server infrastructure– More complex than PATs for simple automation– Still tied to user accounts– Require initial browser authorization– Token management complexity– Potential for scope creep– User revocation affects functionalityGitHub Apps– Act as independent identity– Fine-grained, repository-level permissions– Installation-based access control– Tokens can be scoped down at runtime– Short-lived tokens (1 hour max)– Higher rate limits– Best security model available– No user account dependency– Audit trail for all actions– Can be installed across multiple orgs– More complex initial setup– Require JWT implementation– May be overkill for simple scenarios– Require understanding of installation concept– Private key management responsibility– More moving parts to maintain– Not all APIs support Apps PATs have two flavors: classic and fine-grained. Classic PATs provide repository-wide access with coarse permissions. Fine-grained PATs offer more granular control, since they are  scoped to a single organization, allow specified permissions at the repository level, and limit access to specific repositories. Administrators can also require approval of fine-grained tokens before they can be used, making them a more secure choice for repository access management. However, they currently do not support all API calls and still have some limitations compared to classic PATs. Because of their fine-grained permissions, security features, and higher rate limits, GitHub Apps are the ideal choice for machine-to-machine integration with Azure Pipelines. What’s more, the short-lived tokens and installation-based access model provide better security controls compared to PATs and OAuth tokens, making them particularly well-suited for automation in CI/CD scenarios. Registering and installing a GitHub App In order to use an application for authentication, register it as a GitHub App, and then install it on the accounts, organizations, or enterprises the application will interact with. These are the steps to follow: Register the GitHub App in GitHub enterprise, organization, or account. Make sure to select the appropriate permissions for the application. The permissions will determine what the application can do in the enterprise, organization, and repositories to which it has access. Permissions may be modified at any time. Note that if the application is already installed, changes will require a new authorization from the owner administrators before they take effect. Take care to understand the consequences of making the app public or private. It is very likely that you will want to make the app private, as it is only intended to be used by you or your organization. The semantics of public and private also vary depending on the  GitHub Enterprise Cloud type (Enterprise with personal accounts, with managed users, or with data residency). If a private key was generated, save it in a safe place. Private keys are used to authenticate against GitHub to generate an installation token. Note that a key can be revoked or up to 20 more may be generated if desired.  Install the GitHub App on the accounts or organizations the application will interact with. When an app is installed, select which repositories the app will have access to. Options include all repositories (current and future) or you can select individual repositories. Note: An unlimited number of GitHub Apps may be installed on each account, but only 100 GitHub Apps may be registered per enterprise, organization, or account. GitHub App authentication flow GitHub Apps use a two-step authentication process to access the GitHub API. First, the app authenticates itself using a JSON Web Token (JWT) signed with its private key. This JWT proves the app’s identity but doesn’t provide access to any GitHub resource. To call GitHub APIs, the app needs to obtain an installation token. Installation tokens are scoped (enterprise, organization, or account) access tokens that are generated using the app’s JWT authentication. These tokens are short-lived (valid for one hour) and can only access the resources on the scope they are installed on (enterprise, organization, or repository) and use at max the permissions granted during the app’s installation. To obtain an installation token, there are two approaches: either use a known installation ID, or retrieve the ID by calling the installations API. Once the app has the installation ID, it requests a new token using that ID. The resulting installation token inherits the app’s permissions and repository access for that installation. It can optionally request the token with reduced permissions or limited to specific repositories — a useful security feature when you don’t need the app’s full access scope. The resulting installation token can then be used to make GitHub API calls with the returned permissions. Note: The application can also authenticate on a user’s behalf, but it’s not an ideal scenario for CI/CD pipelines where we want to use a service account and not a user account. From a pipeline perspective, generating an installation token is all that’s needed to call GitHub APIs. Pipeline authors have three main options to generate installation tokens in Azure Pipelines: Use a command-line tool: Several tools are available that can generate installation tokens directly from a pipeline step. For example, gh-token is a popular open source tool that handles the entire token generation process. Write custom scripts: Implement the token generation process using bash/curl or PowerShell scripts following the authentication steps described above. This grants full control over the process but requires more implementation effort. Use Azure Pipeline tasks: While Azure Pipelines doesn’t provide built-in GitHub App authentication, you can either: Find a suitable task in the Azure DevOps marketplace. Create a custom task that implements the GitHub App authentication flow. Next, we’ll explore creating a custom task using an Azure DevOps extension to provide an integration with GitHub App authentication and dynamically generated installation tokens. Azure DevOps extension for GitHub App authentication When creating an integration between Azure Pipelines and GitHub, security of the app private key should be top of mind. Possession of this key grants permissions to generate installation tokens and make API calls on behalf of the app, so it must be stored securely. Within Azure Pipelines, we have several options for storing sensitive data: Azure Pipeline secrets store, which can be accessed via secret variables Azure Pipelines secure files Azure Pipelines service connections, which are project-level resources used to store authentication details for external services Service connections in Azure Pipelines provide several key benefits for managing external service authentication, including: Centralized access control where administrators can specify which pipelines can use the connection Support for multiple authentication schemes Ability to share connections across multiple pipelines within a project Built-in security controls for managing who can view or modify connection details Keep sensitive credentials hidden from pipeline authors while still allowing usage Shared connections across multiple projects, reducing duplication and management overhead For GitHub App authentication, service connections are particularly valuable because they: Securely store the app’s private key Allow administrators to configure and enforce connection behaviors Provide better security compared to storing secrets directly in pipelines or variable groups For those eager to explore the sample code, check out the repository. The key components and configuration are detailed below. Creating a custom Azure DevOps extension Azure DevOps extensions are packages that add new capabilities to Azure DevOps services. In our case, we need to create an extension that provides two key components: Custom service connection type for securely storing GitHub App credentials (and other settings) Custom task that uses those credentials to generate installation tokens An extension consists of a manifest file that describes what the extension provides, along with the actual implementation code. The development process involves creating the extension structure, defining the service connection schema, implementing the custom task logic in PowerShell (Windows only) or JavaScript/TypeScript for cross-platform compatibility, and packaging everything into a distributable format. Once created, the extension can be published privately for your organization or shared publicly through the Azure DevOps Marketplace, making it available for others who have similar GitHub integration needs. We are not going to do a full walkthrough of the extension creation process, but we will demonstrate the most important steps. You can find all the information here:  Extensions overview How to build an extension How to create an extension How to add a custom pipelines task extension. Adding a custom service connection To enable GitHub App authentication in Azure Pipelines, we need to create a custom service connection type since there isn’t a built-in one. This can be done by adding a custom endpoint contribution to our extension, which will define how the service connection stores and validates the GitHub App credentials, and provides a user-friendly UI for configuring the connection settings like App ID, private key, and other properties. We need to add a contribution of type ms.vss-endpoint.service-endpoint-type to the extension contributions manifest. This contribution will define the service connection type and its properties, like the authentication scheme, the endpoint schema, and the input fields that will be displayed in the service connection configuration dialogue. Something like this (see a snippet below, or explore the full contribution definition in reference implementation): \"contributions\": [ { \"id\": \"github-app-service-endpoint-type\", \"description\": \"GitHub App Service Connection\", \"type\": \"ms.vss-endpoint.service-endpoint-type\", \"targets\": [ \"ms.vss-endpoint.endpoint-types\" ], \"properties\": { \"name\": \"githubappauthentication\", \"isVerifiable\": false, \"displayName\": \"GitHub App\", \"url\": { \"value\": \"https://api.github.com/\", \"displayName\": \"GitHub API URL\", \"isVisible\": \"true\" }, ... }, Once you install the extension, you can add/manage the service connection of type “GitHub App” and configure the app’s ID, private key, and other settings. The service connection will securely store the private key and can be used by custom tasks to generate installation tokens in a pipeline. In addition to storing the private key, the custom service connection can also store other settings, such as the GitHub API URL and the app client ID. It can also be used to limit token permissions or scope the token to specific repositories. By optionally enforcing these settings at the service connection level, administrators can ensure consistency and security, rather than leaving configuration decisions to pipeline authors. Adding a custom task Now that we have a secure way to store the GitHub App credentials, we can create a custom task that will use the service connection to generate an installation token. The task will be a TypeScript application (cross platform) and use the Azure DevOps Extension SDK. While I already shared the full walkthrough of creating a custom task, here is an abbreviated list to follow: Create the custom task skeleton Declare the inputs and outputs on the task manifest (task.json) Implement the code Declare the task and its assets on the extension manifest (vss-extension.json) I have created an extension sample that contains both the service connection as well as a custom task that generates a GitHub installation token for API calls. Since the extension is not published to the marketplace, you have to (privately) publish under your account, share it with your Azure DevOps enterprise or organization, and then install it on all organizations where you want to use the custom task. Jump to the next section If you choose this path, as you are now ready to use the custom task in your pipeline. Note: The sample includes both a GitHub Actions workflow and an Azure Pipelines YAML pipeline that builds and packages the extension as an Azure DevOps extension that can be published in the Azure DevOps marketplace. Using the custom task in Azure Pipelines The task supports receiving the private key, as a string, a file (to be combined with secure files), or preferably a service connection (see input parameters). Assuming you have a service connection named my-github-app-service-connection, let’s see how can use task to create a comment in a pull request in the GitHub repository that triggers the pipeline using the GitHub CLI to call the GitHub API: steps: - task: create-github-app-token@1 displayName: create installation token name: getToken inputs: githubAppConnection: my-github-app-service-connection - bash: | pr_number=$(System.PullRequest.PullRequestNumber) repo=$(Build.Repository.Name) echo \"Creating comment in pull request #${pr_number} in repository ${repo}\" gh api -X POST \"/repos/${repo}/issues/${pr_number}/comments\" -f body=\"Posting a comment from Azure Pipelines\" displayName: Create comment in pull request condition: eq(variables['Build.Reason'], 'PullRequest') env: GH_TOKEN: $(getToken.installationToken) Running this pipeline will result in a comment being posted in the pull request: Pretty simple, right? The task will create an installation token using the service connection and export it as a variable, which can be accessed as getToken.installationToken (with getToken being the identifier of the step). It can then be used to authenticate against GitHub, in this case using the GitHub CLI command, which will take care of the API call and authentication for us (we could have also used curl or any other HTTP client). The task also exports other variables: tokenExpiration: the expiration date of the generated token, in ISO 8601 format installationId: the ID of the installation for which the token was generated Unlocking powerful automation capabilities beyond basic CI/CD By leveraging GitHub Apps for authentication, organizations can establish secure, scalable Azure Pipelines integrations that provide fine-grained permissions, short-lived tokens, and better security controls compared to traditional PATs. The custom Azure DevOps extension approach provides a seamless integration experience that abstracts away the complexities of GitHub App authentication. Through service connections and custom tasks, pipeline authors can easily generate installation tokens without worrying about JWT generation, installation ID management, or token lifecycle concerns. The streamlined approach also enables development teams to implement rich GitHub integrations, including automated status checks, pull request comments, issue management, security scanning integration, and deployment tracking. The result? A more cohesive development workflow where Azure Pipelines and GitHub work together seamlessly to provide comprehensive visibility and automation throughout the software development lifecycle. Whether you’re looking to enhance your existing CI/CD processes or build entirely new automated workflows, the combination of Azure Pipelines and GitHub API through GitHub Apps provides a robust foundation for modern DevOps practices. This will allow you to enrich your existing pipelines with GitHub capabilities as you move your code from Azure Repos to GitHub. Explore more blog posts covering a range of topics essential for enterprise software development \u003e Written by Tiago Pascoal a Staff DevOps Architect on the GitHub FastTrack team, before joining GitHub he was a DevOps Architect at Microsoft in the Azure DevOps team. He spends his day helping people with their DevOps practices, with a focus on GitHub, DevOps and AI.",
  "image": "https://github.blog/wp-content/uploads/2025/04/wallpaper_github_generic_2.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/get-started/what-is-azure-pipelines?view=azure-devops\"\u003eAzure Pipelines\u003c/a\u003e is a cloud-based continuous integration and continuous delivery (CI/CD) service that automatically builds, tests, and deploys code similarly to GitHub Actions. While it is part of Azure DevOps, Azure Pipelines has built-in support to build and deploy code stored in \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/repos/github?view=azure-devops\u0026amp;tabs=yaml\"\u003eGitHub repositories\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBecause Azure Pipelines is fully integrated into GitHub development flows, pipelines can be triggered by pushes or pull requests, and it reports the results of the job execution back to GitHub via \u003ca href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks\"\u003eGitHub status checks\u003c/a\u003e. This way, developers can easily see if a given commit is healthy or block pull request merges if the pipeline is not compliant with \u003ca href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/about-rulesets\"\u003eGitHub rulesets\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you need additional functionality, you can use either extensions available in the \u003ca href=\"https://marketplace.visualstudio.com/azuredevops\"\u003emarketplace\u003c/a\u003e  or \u003ca href=\"https://docs.github.com/rest\"\u003eGitHub APIs\u003c/a\u003e to deepen the integration with GitHub. Below, we’ll show how you can streamline the process of calling the GitHub API from Azure Pipelines by abstracting authentication with GitHub Apps and introducing a custom Azure DevOps extension, this will allow pipeline authors to easily authenticate against GitHub and call GitHub APIs without implementing authentication logic themselves. This approach provides enhanced security through centralized credential management, improved maintainability by standardizing GitHub integrations, time savings through cross-project reusability, and simplified operations with centrally managed updates for bug fixes.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-common-use-cases-and-scenarios\"\u003eCommon use cases and scenarios\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe GitHub API is very rich, so the possibilities for customization are almost endless. Some of the most common scenarios for GitHub calls in Azure Pipelines include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSetting \u003c/strong\u003e\u003ca href=\"https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks\"\u003e\u003cstrong\u003estatus checks\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e on commits or pull requests\u003c/strong\u003e: Report the success or failure of pipeline steps (like tests, builds, or security scans) back to GitHub, enabling \u003ca href=\"https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/about-rulesets\"\u003erulesets\u003c/a\u003e utilization to enforce policies, and providing clear feedback to developers about the health of their code changes.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eAdding comments to pull requests\u003c/strong\u003e: Automatically post pipeline results, test coverage reports, performance metrics, or deployment information directly to pull request discussions, keeping all relevant information in one place for code reviewers.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUpdating files in repositories\u003c/strong\u003e: Automatically update documentation, configuration files, or version numbers as part of your CI/CD process, such as updating a \u003ccode\u003eCHANGELOG.md\u003c/code\u003e file or bumping version numbers in package files.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eManaging GitHub Issues\u003c/strong\u003e: Automatically create, update, or close issues based on pipeline results, such as creating bug reports when tests fail or closing issues when related features are successfully deployed.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eIntegrating with GitHub Advanced Security\u003c/strong\u003e: Send code scanning results to GitHub’s \u003ca href=\"https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning\"\u003ecode scanning\u003c/a\u003e, enabling centralized vulnerability management, security insights, and supporting DevSecOps practices across your development workflow.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eManaging releases and assets\u003c/strong\u003e: Automatically create GitHub releases and upload build artifacts, binaries, or documentation as release assets when deployments are successful, streamlining your release management process.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eTracking deployments with GitHub deployments\u003c/strong\u003e: Integrate with GitHub’s \u003ca href=\"https://docs.github.com/en/rest/deployments/deployments?apiVersion=2022-11-28\"\u003edeployment API\u003c/a\u003e to provide visibility into \u003ca href=\"https://docs.github.com/en/actions/how-tos/managing-workflow-runs-and-deployments/managing-deployments/viewing-deployment-history\"\u003edeployment history and status\u003c/a\u003e directly in the GitHub interface.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eTriggering GitHub Actions workflows\u003c/strong\u003e: Orchestrate hybrid CI/CD scenarios where Azure Pipelines handles certain build or deployment tasks and then triggers GitHub Actions workflows for additional processing or notifications.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2 id=\"h-understanding-github-api-rest-vs-graphql\"\u003eUnderstanding GitHub API: REST vs. GraphQL\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe GitHub API provides programmatic access to most of GitHub’s features and data, offering two distinct interfaces: \u003ca href=\"https://docs.github.com/en/rest?apiVersion=2022-11-28\"\u003eREST\u003c/a\u003e and \u003ca href=\"https://docs.github.com/en/graphql\"\u003eGraphQL\u003c/a\u003e. The REST API follows RESTful principles and provides straightforward HTTP endpoints for common operations like managing repositories, issues, pull requests, and workflows. It’s well documented, easy to get started with, and supports authentication via personal access tokens, GitHub Apps, or OAuth tokens.\u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub’s GraphQL API offers a more flexible and efficient approach to data retrieval. Unlike REST, where you might need multiple requests to gather related data, GraphQL allows you to specify exactly what data you need in a single request, reducing over-fetching and under-fetching of data. This is particularly valuable when you need to retrieve complex, nested data structures or when you want to optimize network requests in your applications. You can see some examples in \u003ca href=\"https://github.blog/developer-skills/github/exploring-github-cli-how-to-interact-with-githubs-graphql-api-endpoint/\"\u003eExploring GitHub CLI: How to interact with GitHub’s GraphQL API endpoint\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eBoth APIs serve as the foundation for integrating GitHub’s functionality into external tools, automating workflows, and building custom solutions that extend GitHub’s capabilities.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-how-to-choose-the-right-authentication-method\"\u003eHow to choose the right authentication method\u003c/h2\u003e\n\n\n\n\u003cp\u003eGitHub offers three primary \u003ca href=\"https://docs.github.com/en/rest/authentication/authenticating-to-the-rest-api?apiVersion=2022-11-28\"\u003eauthentication\u003c/a\u003e methods for accessing its APIs. Personal Access Tokens (PATs) are the simplest method, providing a token tied to a user account with specific permissions. OAuth tokens are designed for third-party applications that need to act on behalf of different users, implementing a standard authorization flow where users grant specific permissions to the application. \u003c/p\u003e\n\n\n\n\u003cp\u003eGitHub Apps provide the most robust and scalable solution, operating as their own entities with fine-grained permissions, installation-based access, and higher rate limits — making them ideal for organizations and production applications that need to interact with multiple repositories or organizations while maintaining tight security controls.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cstrong\u003eAuthentication Type\u003c/strong\u003e\u003c/th\u003e\u003cth\u003e\u003cstrong\u003ePros\u003c/strong\u003e\u003c/th\u003e\u003cth\u003e\u003cstrong\u003eCons\u003c/strong\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ePersonal Access Tokens (PATs)\u003c/td\u003e\u003ctd\u003e– Simple to create and use\u003cbr/\u003e– Quick to get started\u003cbr/\u003e– Good for personal automation\u003cbr/\u003e– Can be scoped to multiple organizations\u003cbr/\u003e– Configurable permissions per token\u003cbr/\u003e– Admins can revoke organization access\u003cbr/\u003e– Configurable expiration dates\u003cbr/\u003e– Work with most GitHub API libraries\u003cbr/\u003e– No additional infrastructure needed\u003c/td\u003e\u003ctd\u003e– Tied to user account lifecycle\u003cbr/\u003e– Limited to user’s permissions\u003cbr/\u003e– Classic PATs have coarse-grained permissions\u003cbr/\u003e– Require manual rotation\u003cbr/\u003e– Browser-based management only\u003cbr/\u003e– If compromised, expose all accessible organization(s)/repositories\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eOAuth Tokens\u003c/td\u003e\u003ctd\u003e– Standard OAuth 2.0 flow\u003cbr/\u003e– Organization admins control app access\u003cbr/\u003e– Can act on behalf of multiple users\u003cbr/\u003e– Excellent for web applications\u003cbr/\u003e– User-approved permissions\u003cbr/\u003e– Refresh token mechanism\u003cbr/\u003e– Widely supported by frameworks\u003cbr/\u003e– Good for user-facing applications\u003c/td\u003e\u003ctd\u003e– Require storing refresh tokens securely\u003cbr/\u003e– Need server infrastructure\u003cbr/\u003e– More complex than PATs for simple automation\u003cbr/\u003e– Still tied to user accounts\u003cbr/\u003e– Require initial browser authorization\u003cbr/\u003e– Token management complexity\u003cbr/\u003e– Potential for scope creep\u003cbr/\u003e– User revocation affects functionality\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eGitHub Apps\u003c/td\u003e\u003ctd\u003e– Act as independent identity\u003cbr/\u003e– Fine-grained, repository-level permissions\u003cbr/\u003e– Installation-based access control\u003cbr/\u003e– Tokens can be scoped down at runtime\u003cbr/\u003e– Short-lived tokens (1 hour max)\u003cbr/\u003e– Higher rate limits\u003cbr/\u003e– Best security model available\u003cbr/\u003e– No user account dependency\u003cbr/\u003e– Audit trail for all actions\u003cbr/\u003e– Can be installed across multiple orgs\u003c/td\u003e\u003ctd\u003e– More complex initial setup\u003cbr/\u003e– Require JWT implementation\u003cbr/\u003e– May be overkill for simple scenarios\u003cbr/\u003e– Require understanding of installation concept\u003cbr/\u003e– Private key management responsibility\u003cbr/\u003e– More moving parts to maintain\u003cbr/\u003e– Not all APIs support Apps\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003ePATs have two flavors: classic and fine-grained. Classic PATs provide repository-wide access with coarse permissions. Fine-grained PATs offer more granular control, since they are  scoped to a single organization, allow specified permissions at the repository level, and limit access to specific repositories. Administrators can also \u003ca href=\"https://docs.github.com/en/organizations/managing-programmatic-access-to-your-organization/managing-requests-for-personal-access-tokens-in-your-organization\"\u003erequire approval\u003c/a\u003e of fine-grained tokens before they can be used, making them a more secure choice for repository access management. However, they currently do not support all API calls and still have some limitations compared to classic PATs.\u003c/p\u003e\n\n\n\n\u003cp\u003eBecause of their fine-grained permissions, security features, and higher rate limits, GitHub Apps are the ideal choice for machine-to-machine integration with Azure Pipelines. What’s more, the short-lived tokens and installation-based access model provide better security controls compared to PATs and OAuth tokens, making them particularly well-suited for automation in CI/CD scenarios.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"registering-and-installing-a-github-app\"\u003eRegistering and installing a GitHub App\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn order to use an application for authentication, register it as a GitHub App, and then install it on the accounts, organizations, or enterprises the application will interact with.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese are the steps to follow:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://docs.github.com/en/developers/apps/creating-a-github-app\"\u003eRegister the GitHub App\u003c/a\u003e in GitHub enterprise, organization, or account.\n\u003cul\u003e\n\u003cli\u003eMake sure to select the appropriate permissions for the application. The permissions will determine what the application can do in the enterprise, organization, and repositories to which it has access.\u003c/li\u003e\n\n\n\n\u003cli\u003ePermissions may be modified at any time. Note that if the application is already installed, changes will require a new authorization from the owner administrators before they take effect.\u003c/li\u003e\n\n\n\n\u003cli\u003eTake care to understand the consequences of making the app public or private. It is very likely that you will want to make the app private, as it is only intended to be used by you or your organization. The semantics of public and private also vary depending on the  GitHub Enterprise Cloud type (Enterprise with personal accounts, with managed users, or with data residency).\u003c/li\u003e\n\n\n\n\u003cli\u003eIf a private key was generated, save it in a safe place. Private keys are used to authenticate against GitHub to generate an installation token. Note that a key can be revoked or up to 20 more may be generated if desired. \u003cbr/\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://docs.github.com/en/developers/apps/installing-github-apps\"\u003eInstall the GitHub App\u003c/a\u003e on the accounts or organizations the application will interact with.\n\u003cul\u003e\n\u003cli\u003eWhen an app is installed, select which repositories the app will have access to. Options include all repositories (current and future) or you can select individual repositories.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: An unlimited number of GitHub Apps may be installed on each account, but only 100 GitHub Apps may be registered per enterprise, organization, or account.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"github-app-authentication-flow\"\u003eGitHub App authentication flow\u003c/h2\u003e\n\n\n\n\u003cp\u003eGitHub Apps use a two-step authentication process to access the GitHub API. First, the \u003ca href=\"https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/about-authentication-with-a-github-app#authentication-as-a-github-app\"\u003eapp authenticates itself\u003c/a\u003e using a JSON Web Token (JWT) signed with its private key. This JWT proves the app’s identity but doesn’t provide access to any GitHub resource. To call GitHub APIs, the app needs to obtain an \u003ca href=\"https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/about-authentication-with-a-github-app#authentication-as-an-app-installation\"\u003einstallation token\u003c/a\u003e. Installation tokens are scoped (enterprise, organization, or account) access tokens that are generated using the app’s JWT authentication. These tokens are short-lived (valid for one hour) and can only access the resources on the scope they are installed on (enterprise, organization, or repository) and use at max the permissions granted during the app’s installation.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo obtain an installation token, there are two approaches: either use a known installation ID, or retrieve the ID by calling the installations API. Once the app has the installation ID, it requests a new token using that ID. The resulting installation token inherits the app’s permissions and repository access for that installation. It can optionally request the token with reduced permissions or limited to specific repositories — a useful security feature when you don’t need the app’s full access scope.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe resulting installation token can then be used to make GitHub API calls with the returned permissions.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: The application can also authenticate on a user’s \u003ca href=\"https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/about-authentication-with-a-github-app#authentication-on-behalf-of-a-user\"\u003ebehalf,\u003c/a\u003e but it’s not an ideal scenario for CI/CD pipelines where we want to use a service account and not a user account.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" height=\"897\" width=\"1024\" src=\"https://github.blog/wp-content/uploads/2025/07/image1.png?resize=1024%2C897\" alt=\"Sequence diagram showing GitHub App authentication flow between Client and GitHub, including JWT generation, installation ID retrieval, and installation token creation steps.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/image1.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/07/image1.png?w=300 300w, https://github.blog/wp-content/uploads/2025/07/image1.png?w=768 768w, https://github.blog/wp-content/uploads/2025/07/image1.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/07/image1.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom a pipeline perspective, generating an installation token is all that’s needed to call GitHub APIs.\u003c/p\u003e\n\n\n\n\u003cp\u003ePipeline authors have three main options to generate installation tokens in Azure Pipelines:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eUse a command-line tool\u003c/strong\u003e: Several tools are available that can generate installation tokens directly from a pipeline step. For example, \u003ca href=\"https://github.com/Link-/gh-token\"\u003egh-token\u003c/a\u003e is a popular open source tool that handles the entire token generation process.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eWrite custom scripts\u003c/strong\u003e: Implement the token generation process using bash/curl or PowerShell scripts following the authentication steps described above. This grants full control over the process but requires more implementation effort.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eUse Azure Pipeline tasks\u003c/strong\u003e: While Azure Pipelines doesn’t provide built-in GitHub App authentication, you can either:\n\u003cul\u003e\n\u003cli\u003eFind a suitable task in the \u003ca href=\"https://marketplace.visualstudio.com/azuredevops\"\u003eAzure DevOps marketplace\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eCreate a custom task that implements the GitHub App authentication flow.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eNext, we’ll explore creating a custom task using an Azure DevOps extension to provide an integration with GitHub App authentication and dynamically generated installation tokens.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"azure-devops-extension-for-github-app-authentication\"\u003eAzure DevOps extension for GitHub App authentication\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen creating an integration between Azure Pipelines and GitHub, security of the app private key should be top of mind. Possession of this key grants permissions to generate installation tokens and make API calls on behalf of the app, so it must be stored securely. Within Azure Pipelines, we have several options for \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/security/secrets?view=azure-devops\"\u003estoring\u003c/a\u003e sensitive data:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAzure Pipeline secrets store, which can be accessed via \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/process/set-secret-variables\"\u003esecret variables\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eAzure Pipelines \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/library/secure-files\"\u003esecure files\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eAzure Pipelines \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/library/service-endpoints?view=azure-devops\"\u003eservice connections\u003c/a\u003e, which are project-level resources used to store authentication details for external services\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eService connections in Azure Pipelines provide several key benefits for managing external service authentication, including:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCentralized access control where administrators can specify which pipelines can use the connection\u003c/li\u003e\n\n\n\n\u003cli\u003eSupport for multiple authentication schemes\u003c/li\u003e\n\n\n\n\u003cli\u003eAbility to share connections across multiple pipelines within a project\u003c/li\u003e\n\n\n\n\u003cli\u003eBuilt-in security controls for managing who can view or modify connection details\u003c/li\u003e\n\n\n\n\u003cli\u003eKeep sensitive credentials hidden from pipeline authors while still allowing usage\u003c/li\u003e\n\n\n\n\u003cli\u003eShared connections across multiple projects, reducing duplication and management overhead\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor GitHub App authentication, service connections are particularly valuable because they:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eSecurely store the app’s private key\u003c/li\u003e\n\n\n\n\u003cli\u003eAllow administrators to configure and enforce connection behaviors\u003c/li\u003e\n\n\n\n\u003cli\u003eProvide better security compared to storing secrets directly in pipelines or variable groups\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eFor those eager to explore the sample code, check out the \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task\"\u003erepository\u003c/a\u003e. The key components and configuration are detailed below.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"creating-a-custom-azure-devops-extension\"\u003eCreating a custom Azure DevOps extension\u003c/h3\u003e\n\n\n\n\u003cp\u003eAzure DevOps extensions are packages that add new capabilities to Azure DevOps services. In our case, we need to create an extension that provides two key components:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCustom service connection type for securely storing GitHub App credentials (and other settings)\u003c/li\u003e\n\n\n\n\u003cli\u003eCustom task that uses those credentials to generate installation tokens\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAn extension consists of a manifest file that describes what the extension provides, along with the actual implementation code.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe development process involves creating the extension structure, defining the service connection schema, implementing the custom task logic in PowerShell (Windows only) or JavaScript/TypeScript for cross-platform compatibility, and packaging everything into a distributable format. Once created, the extension can be published privately for your organization or shared publicly through the Azure DevOps Marketplace, making it available for others who have similar GitHub integration needs.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe are not going to do a full walkthrough of the extension creation process, but we will demonstrate the most important steps. You can find all the information here: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/overview?view=azure-devops\"\u003eExtensions overview\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/overview?view=azure-devops#build-an-extension\"\u003eHow to build an extension\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/develop/create-extension?view=azure-devops\"\u003eHow to create an extension\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/develop/add-build-task?view=azure-devops\"\u003eHow to add a custom pipelines task extension\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch4 id=\"adding-a-custom-service-connection\"\u003eAdding a custom service connection\u003c/h4\u003e\n\n\n\n\u003cp\u003eTo enable GitHub App authentication in Azure Pipelines, we need to create a custom service connection type since there isn’t a built-in one. This can be done by adding a \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/develop/service-endpoints?view=azure-devops\"\u003ecustom endpoint contribution\u003c/a\u003e to our extension, which will define how the service connection stores and validates the GitHub App credentials, and provides a user-friendly UI for configuring the connection settings like App ID, private key, and other properties.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe need to add a contribution of type \u003ccode\u003ems.vss-endpoint.service-endpoint-type\u003c/code\u003e to the extension contributions manifest. This contribution will define the service connection type and its properties, like the authentication scheme, the endpoint schema, and the input fields that will be displayed in the service connection configuration dialogue.\u003c/p\u003e\n\n\n\n\u003cp\u003eSomething like this (see a snippet below, or explore the full contribution definition in \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task/blob/1c0778fb64e344fcf237c06894795ce8547abf7c/vss-extension.json#L44\"\u003ereference implementation\u003c/a\u003e):\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e\u0026#34;contributions\u0026#34;: [\n  {\n    \u0026#34;id\u0026#34;: \u0026#34;github-app-service-endpoint-type\u0026#34;,\n    \u0026#34;description\u0026#34;: \u0026#34;GitHub App Service Connection\u0026#34;,\n    \u0026#34;type\u0026#34;: \u0026#34;ms.vss-endpoint.service-endpoint-type\u0026#34;,\n    \u0026#34;targets\u0026#34;: [ \u0026#34;ms.vss-endpoint.endpoint-types\u0026#34; ],\n    \u0026#34;properties\u0026#34;: {\n        \u0026#34;name\u0026#34;: \u0026#34;githubappauthentication\u0026#34;,\n        \u0026#34;isVerifiable\u0026#34;: false,\n        \u0026#34;displayName\u0026#34;: \u0026#34;GitHub App\u0026#34;,\n        \u0026#34;url\u0026#34;: {\n            \u0026#34;value\u0026#34;: \u0026#34;https://api.github.com/\u0026#34;,\n            \u0026#34;displayName\u0026#34;: \u0026#34;GitHub API URL\u0026#34;,\n            \u0026#34;isVisible\u0026#34;: \u0026#34;true\u0026#34;\n        },\n        ...\n  },\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eOnce you install the extension, you can add/manage the service connection of type “GitHub App” and configure the app’s ID, private key, and other settings. The service connection will securely store the private key and can be used by custom tasks to generate installation tokens in a pipeline.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"752\" height=\"425\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/07/image2.png?resize=752%2C425\" alt=\"Azure DevOps new service connection dialog showing different connection types including Generic, GitHub, GitHub App (highlighted with red arrow), GitHub Enterprise Server, and Incoming WebHook options.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/image2.png?w=752 752w, https://github.blog/wp-content/uploads/2025/07/image2.png?w=300 300w\" sizes=\"auto, (max-width: 752px) 100vw, 752px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn addition to storing the private key, the custom service connection can also store other settings, such as the GitHub API URL and the app client ID. It can also be used to limit token permissions or scope the token to specific repositories. By optionally enforcing these settings at the service connection level, administrators can ensure consistency and security, rather than leaving configuration decisions to pipeline authors.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" height=\"1024\" width=\"624\" src=\"https://github.blog/wp-content/uploads/2025/07/image3.png?resize=624%2C1024\" alt=\"Azure DevOps service connection configuration form for custom GitHub App authentication, showing fields for GitHub API URL, Client ID, Private Key, Token Permissions, and Service Connection Name.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/image3.png?w=696 696w, https://github.blog/wp-content/uploads/2025/07/image3.png?w=183 183w, https://github.blog/wp-content/uploads/2025/07/image3.png?w=624 624w\" sizes=\"auto, (max-width: 624px) 100vw, 624px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch4 id=\"adding-a-custom-task\"\u003eAdding a custom task\u003c/h4\u003e\n\n\n\n\u003cp\u003eNow that we have a secure way to store the GitHub App credentials, we can create a custom task that will use the service connection to generate an installation token. The task will be a TypeScript application (cross platform) and use the \u003ca href=\"https://github.com/Microsoft/azure-devops-extension-sdk\"\u003eAzure DevOps Extension SDK\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/extend/develop/add-build-task?view=azure-devops\"\u003eWhile I already shared the full walkthrough of creating a custom task\u003c/a\u003e, here is an abbreviated list to follow:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCreate the custom task skeleton\u003c/li\u003e\n\n\n\n\u003cli\u003eDeclare the inputs and outputs on the task manifest (\u003ccode\u003etask.json\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eImplement the code\u003c/li\u003e\n\n\n\n\u003cli\u003eDeclare the task and its assets on the extension manifest (\u003ccode\u003evss-extension.json\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eI have created an \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task\"\u003eextension sample\u003c/a\u003e that contains both the service connection as well as a custom task that generates a GitHub installation token for API calls. Since the extension is not published to the marketplace, you have to (privately) publish under your account, share it with your Azure DevOps enterprise or organization, and then install it on all organizations where you want to use the custom task.\u003c/p\u003e\n\n\n\n\u003cp\u003eJump to the next section If you choose this path, as you are now ready to use the custom task in your pipeline.\u003c/p\u003e\n\n\n\n\u003cp\u003eNote: The sample includes both a \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task/blob/main/.github/workflows/ci.yml\"\u003eGitHub Actions workflow\u003c/a\u003e and an \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task/blob/main/azure-pipelines.yml\"\u003eAzure Pipelines YAML pipeline\u003c/a\u003e that builds and packages the extension as an Azure DevOps extension that can be published in the Azure DevOps marketplace.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"using-the-custom-task-in-azure-pipelines\"\u003eUsing the custom task in Azure Pipelines\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe task supports receiving the private key, as a string, a file (to be combined with \u003ca href=\"https://learn.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops\"\u003esecure files\u003c/a\u003e), or preferably a service connection (see \u003ca href=\"https://github.com/tspascoal/azure-pipelines-create-github-app-token-task?tab=readme-ov-file#input-parameters\"\u003einput parameters\u003c/a\u003e).\u003c/p\u003e\n\n\n\n\u003cp\u003eAssuming you have a service connection named \u003ccode\u003emy-github-app-service-connection\u003c/code\u003e, let’s see how can use task to create a comment in a pull request in the GitHub repository that triggers the pipeline using the \u003ca href=\"https://cli.github.com/\"\u003eGitHub CLI\u003c/a\u003e to call the GitHub API:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003esteps:\n- task: create-github-app-token@1\n  displayName: create installation token\n  name: getToken\n  inputs:\n    githubAppConnection: my-github-app-service-connection\n\n- bash: |\n    pr_number=$(System.PullRequest.PullRequestNumber)\n    repo=$(Build.Repository.Name)\n    echo \u0026#34;Creating comment in pull request #${pr_number} in repository ${repo}\u0026#34;\n    gh api -X POST \u0026#34;/repos/${repo}/issues/${pr_number}/comments\u0026#34; -f body=\u0026#34;Posting a comment from Azure Pipelines\u0026#34;\n  displayName: Create comment in pull request\n  condition: eq(variables[\u0026#39;Build.Reason\u0026#39;], \u0026#39;PullRequest\u0026#39;)\n  env:\n    GH_TOKEN: $(getToken.installationToken)\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eRunning this pipeline will result in a comment being posted in the pull request:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" loading=\"lazy\" height=\"504\" width=\"1024\" src=\"https://github.blog/wp-content/uploads/2025/07/image4.png?resize=1024%2C504\" alt=\"Screenshot of a GitHub pull request snippet showing an Azure Pipelines Status check, and comment that reads \u0026#39;Posting a comment from Azure Pipelines\u0026#39; written by our pipeline.\" srcset=\"https://github.blog/wp-content/uploads/2025/07/image4.png?w=1399 1399w, https://github.blog/wp-content/uploads/2025/07/image4.png?w=300 300w, https://github.blog/wp-content/uploads/2025/07/image4.png?w=768 768w, https://github.blog/wp-content/uploads/2025/07/image4.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003ePretty simple, right? The task will create an installation token using the service connection and export it as a variable, which can be accessed as \u003ccode\u003egetToken.installationToken\u003c/code\u003e (with \u003ccode\u003egetToken\u003c/code\u003e being the identifier of the step). It can then be used to authenticate against GitHub, in this case using the GitHub CLI command, which will take care of the API call and authentication for us (we could have also used \u003ccode\u003ecurl\u003c/code\u003e or any other HTTP client).\u003c/p\u003e\n\n\n\n\u003cp\u003eThe task also exports other variables:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etokenExpiration\u003c/code\u003e: the expiration date of the generated token, in ISO 8601 format\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003einstallationId\u003c/code\u003e: the ID of the installation for which the token was generated\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2 id=\"unlocking-powerful-automation-capabilities-beyond-basic-ci-cd\"\u003eUnlocking powerful automation capabilities beyond basic CI/CD\u003c/h2\u003e\n\n\n\n\u003cp\u003eBy leveraging GitHub Apps for authentication, organizations can establish secure, scalable Azure Pipelines integrations that provide fine-grained permissions, short-lived tokens, and better security controls compared to traditional PATs.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe custom Azure DevOps extension approach provides a seamless integration experience that abstracts away the complexities of GitHub App authentication. Through service connections and custom tasks, pipeline authors can easily generate installation tokens without worrying about JWT generation, installation ID management, or token lifecycle concerns.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe streamlined approach also enables development teams to implement rich GitHub integrations, including automated status checks, pull request comments, issue management, security scanning integration, and deployment tracking. The result? A more cohesive development workflow where Azure Pipelines and GitHub work together seamlessly to provide comprehensive visibility and automation throughout the software development lifecycle.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhether you’re looking to enhance your existing CI/CD processes or build entirely new automated workflows, the combination of Azure Pipelines and GitHub API through GitHub Apps provides a robust foundation for modern DevOps practices. This will allow you to enrich your existing pipelines with GitHub capabilities as you move your code from Azure Repos to GitHub.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eExplore more blog posts\u003c/strong\u003e covering a range of topics essential for \u003ca href=\"https://github.blog/enterprise-software/\"\u003eenterprise software development \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/7847935?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/7847935?v=4\u0026amp;s=200\" alt=\"Tiago Pascoal\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cp\u003eTiago Pascoal a Staff DevOps Architect on the GitHub FastTrack team, before joining GitHub he was a DevOps Architect at Microsoft in the Azure DevOps team.\u003c/p\u003e\n\u003cp\u003eHe spends his day helping people with their DevOps practices, with a focus on GitHub, DevOps and AI.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": "2025-07-24T16:00:00Z",
  "modifiedTime": null
}
