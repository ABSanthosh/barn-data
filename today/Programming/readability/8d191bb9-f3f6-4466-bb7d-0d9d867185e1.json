{
  "id": "8d191bb9-f3f6-4466-bb7d-0d9d867185e1",
  "title": "One Roundtrip Per Navigation",
  "link": "https://overreacted.io/one-roundtrip-per-navigation/",
  "description": "What do HTML, GraphQL, and RSC have in common?",
  "author": "",
  "published": "Thu, 29 May 2025 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 25176,
  "excerpt": "What do HTML, GraphQL, and RSC have in common?",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "How many requests should it take to navigate to another page? In the simplest case, a navigation is resolved in a single request. You click a link, the browser requests the HTML content for the new URL, and then displays it. In practice, a page might also want to display some images, load some client-side JavaScript, load some extra styles, and so on. So there’ll be a bunch of requests. Some will be render-blocking (so the browser will defer displaying the page until they resolve), and the rest will be “nice-to-have”. Maybe they’ll be important for full interactivity but the browser can already display the page while they load. Okay, but what about loading data? How many API requests should it take to get the data for the next page? HTML Before much of the web development has moved to the client, this question didn’t even make sense. There was no concept of “hitting the API” because you wouldn’t think of your server as an API server—it was just the server, returning HTML. In traditional “HTML apps”, aka websites, getting the data always takes a single roundtrip. The user clicks a link, the server returns the HTML, and all the data necessary to display the next page is already embedded within that HTML. The HTML itself is the data. It doesn’t need further processing—it’s ready for display: \u003carticle\u003e \u003ch1\u003eOne Roundtrip Per Navigation\u003c/h1\u003e \u003cp\u003eHow many requests should it take to navigate to another page?\u003c/p\u003e \u003cul class=\"comments\"\u003e \u003cli\u003eYou're just reinventing HTML\u003c/li\u003e \u003cli\u003eYou're just reinventing PHP\u003c/li\u003e \u003cli\u003eYou're just reinventing GraphQL\u003c/li\u003e \u003cli\u003eYou're just reinventing Remix\u003c/li\u003e \u003cli\u003eYou're just reinventing Astro\u003c/li\u003e \u003c/ul\u003e \u003c/article\u003e (Yes, technically some static, reusable and cacheable parts like images, scripts, and styles get “outlined”, but you can also always inline them whenever that’s useful.) “REST” Things changed as we moved more of the application logic to the client side. The data we want to fetch is usually determined by the UI we need to display. When we want to show a post, we need to fetch that post. When we want to show a post’s comments, we need to fetch those comments. So how many fetches do we make? With JSON APIs, a technique known as REST suggests to expose an endpoint per a conceptual “resource”. Nobody knows what exactly a “resource” is but usually the backend team will be in charge of defining this concept. So maybe you’ll have a Post “resource” and a Post Comments “resource”, and so you’ll be able to load the data for the post page (which contains the post and its comments) in two fetches. But where do these two fetches happen? In server-centric HTML apps (aka websites) you could hit two REST APIs during a single request, and still return all the data as a single response. This is because the REST API requests would happen on the server. The REST API was used mostly as an explicit boundary for the data layer, but it was not really required (many were happy to use an in-process data layer that you can import—like in Rails or Django). Regardless of REST, the data (HTML) arrived to the client (browser) in one piece. As we started moving UI logic to the client for richer interactivity, it felt natural to keep the existing REST APIs but to fetch them from the client. Isn’t that kind of flexiblity exactly what JSON APIs were great at? Everything became a JSON API: const [post, comments] = await Promise.all([ fetch(`/api/posts/${postId}`).then(res =\u003e res.json()), fetch(`/api/posts/${postId}/comments`).then(res =\u003e res.json()) ]); However as a result, there are now two fetches in the Network tab: one fetch for the Post and another fetch for that Post’s Comments. A single page—a single link click—often needs data from more than one REST “resource”. In the best case, you can hit a couple of endpoints and call it a day. In the worst case, you might have to hit N endpoints for N items, or hit the server repeatedly in a series of client/server waterfalls (get some data, compute stuff from it, use that to get some more data). An inefficiency is creeping in. When we were on the server, making a bunch of REST requests was cheap because we had control over how our code is deployed. If those REST endpoints were far away, we could move our server closer to them or even move their code in-process. We could use replication or server-side caching. Even if something got inefficient, on the server we have many levers to improve that inefficiency. Nothing is stopping us from improving things on the server side. However, if you think of the server as a black box, you can’t improve on the APIs it provides. You can’t optimize a client/server waterfall if the server doesn’t return all the data needed to run requests in parallel. You can’t reduce the number of parallel requests if the server doesn’t provide an API that returns all the data in a batch. At some point you’re going to hit a wall. Components The problem above wouldn’t be so bad if not for the tension between efficiency and encapsulation. As developers, we feel compelled to place the logic to load the data close to where this data is used. Someone might say this leads to “spaghetti code”, but it doesn’t have to! The idea itself is solid. Recall—the UI determines the data. The data you need depends on what you want to display. The data fetching logic and the UI logic are inherently coupled—when one changes, the other needs to be aware of that. You don’t want to break stuff by “underfetching” or bloat it by “overfetching”. But how do you keep the UI logic and the data fetching in sync? The most direct approach would be to put the data loading logic directly in your UI components. That’s the “$.ajax in a Backbone.View” approach, or “fetch in useEffect” approach. It was incredibly popular with the rise of client-side UI—and still is. The benefit of this approach is colocation: the code that says what data to load is located right next to the code consuming it. Different people can write components that depend on different data sources, and then put them together: function PostContent({ postId }) { const [post, setPost] = useState() useEffect(() =\u003e { fetch(`/api/posts/${postId}`) .then(res =\u003e res.json()) .then(setPost); }, []); if (!post) { return null; } return ( \u003carticle\u003e \u003ch1\u003e{post.title}\u003c/h1\u003e \u003cp\u003e{post.content}\u003c/p\u003e \u003cComments postId={postId} /\u003e \u003c/article\u003e ); } function Comments({ postId }) { const [comments, setComments] = useState([]) useEffect(() =\u003e { fetch(`/api/posts/${postId}/comments`) .then(res =\u003e res.json()) .then(setComments); }, []) return ( \u003cul className=\"comments\"\u003e {comments.map(c =\u003e \u003cli key={c.id}\u003e{c.text}\u003c/li\u003e)} \u003c/ul\u003e ); } However, this approach makes the problem from the previous section much more severe. Not only does rendering a single page take a bunch of requests, these requests are now spread out in the codebase. How do you audit for inefficiencies? Someone might edit a component, add some data loading to it, and thus introduce a new client/server waterfall to a dozen different screens using that component. If our components ran on the server only—like Astro Components—data fetching delays would at best be nonexistent and at worst be predictable. But on the client, smudging the data fetching logic across components cascades the inefficiencies without good levers to fix them—we can’t move the user any closer to our servers. (And inherent waterfalls can’t be fixed from the client at all—even by prefetching.) Let’s see if adding a bit more structure to our data fetching code can help. Queries Interestingly, solutions that bring some structure to data fetching—like React Query (useQuery)—aren’t on their own immune to this. They’re much more principled than fetch in useEffect (and caching helps) but you get the same “N queries for N items” and “client/server query waterfalls” problems with them. function usePostQuery(postId) { return useQuery( ['post', postId], () =\u003e fetch(`/api/posts/${postId}`).then(res =\u003e res.json()) ); } function usePostCommentsQuery(postId) { return useQuery( ['post-comments', postId], () =\u003e fetch(`/api/posts/${postId}/comments`).then(res =\u003e res.json()) ); } function PostContent({ postId }) { const { data: post } = usePostQuery(postId); if (!post) { return null; } return ( \u003carticle\u003e \u003ch1\u003e{post.title}\u003c/h1\u003e \u003cp\u003e{post.content}\u003c/p\u003e \u003cComments postId={postId} /\u003e \u003c/article\u003e ); } function Comments({ postId }) { const { data: comments } = usePostCommentsQuery(postId); return ( \u003cul className=\"comments\"\u003e {comments.map(c =\u003e \u003cli key={c.id}\u003e{c.text}\u003c/li\u003e)} \u003c/ul\u003e ); } In fact, client-side caching in general is a bit of a red herring. It is essential for the Back button to be instant in client-side apps (and thus should not be neglected), and it helps to reuse stuff from the cache for some navigations like tab switches. But for many navigations—primarily clicking on links—the user actually expects to see fresh content. It’s why the browser waits to load the page in “HTML apps”! The user might not want the whole page to be replaced (especially if your app has a navigation “shell”), but the content area is expected to be fresh after a link click. (Of course, prefetching on hover for an instant-and-fresh navigation is even nicer.) Counter-intuitively, this means that faster is not always better. It’s often worse for the user experience to show a flash of stale cached content and then immediately replace it a la “stale-while-revalidate”. It betrays the user’s intent. Clicking the link carries an expectation of freshness. I don’t want to have to Ctrl+R “just in case”. Client-side caching helps if the content couldn’t have changed yet or you simply don’t care to reflect the changes, but it isn’t panacea and doesn’t fix other issues. It solves a range of problems, but it doesn’t reduce the number of requests when we want the data to be fresh, and it doesn’t help us prevent client/server waterfalls. So now we have this tension: it feels tempting to colocate the UI with its data requirements, but we also want to avoid client/server waterfalls and firing too many parallel requests. Client-side caching of queries alone doesn’t fix this. What do we do? Client Loaders One thing we could do is to give up on colocation. Suppose that for each route, we define a function that will load all the data for that route. We’ll call it a loader: async function clientLoader({ params }) { const { postId } = params; const [post, comments] = await Promise.all([ fetch(`/api/posts/${postId}`).then(res =\u003e res.json()), fetch(`/api/posts/${postId}/comments`).then(res =\u003e res.json()) ]); return { post, comments }; } This example is using the clientLoader API from React Router, but the idea itself is more general. For each navigation, assume that the router runs the loader for the next route, and then hands off the data to your component hierarchy. The downside of this approach is that the data requirements are no longer colocated with the components that need that data. There’s now a piece of code “at the top” of each route that has to “know” what the entire hierarchy below it needs. In that sense, it feels like a step back from fetching in Queries or in Components. The upside of this approach is that it’s way easier to avoid client/server waterfalls. They are still possible (and sometimes unavoidable) because the clientLoader function runs on the client—but they are visible. You’re not creating client/server waterfalls by default, which fetching in Components or Queries suffered from. Server Loaders Another upside of loaders is that, if each route has a self-contained loader, it is easy to move some of this logic to the server. Since the loader is independent from your components (it runs before any components), you could make it a part of your HTML or API server—or even a separate “BFF” server (a “backend for frontend”). // This could run on the server instead async function loader({ params }) { const { postId } = params; const [post, comments] = await Promise.all([ fetch(`/api/posts/${postId}`).then(res =\u003e res.json()), fetch(`/api/posts/${postId}/comments`).then(res =\u003e res.json()) ]); return { post, comments }; } This is the model followed by the React Router loader function as well as the old school Next.js getServerSideProps(). (Usually, a code transform “detaches” the server loader code from the rest of your code which is destined for the client.) Why move the loader to the server? If you don’t treat the server as a black box beyond your control, it is the natural place to put your data fetching code. When you’re on the server, you have all the levers to improve common performance problems. You often have control over latency—for example, you can your BFF server closer to the data source. Then even inherent waterfalls will be cheap. If the data source is slow, you have ability to add cross-request caching on the server. You also have the option of dispensing with microservices entirely and moving your data layer to be in-process, like in Rails: import { loadPost, loadComments } from 'my-data-layer'; async function loader({ params }) { const { postId } = params; const [post, comments] = await Promise.all([ loadPost(postId), loadComments(postId) ]); return { post, comments }; } An in-process data layer gives you the ultimate opportunities for optimization. It lets you drop down to a lower level whenever necessary (for example, to call an optimized stored procedure for a particular screen). In-memory per-request caching and batching let you reduce the number of database trips even further. You don’t have to worry about overfetching or underfetching—each loader can send just the data that its screen needs. No more “expanding” “REST” “resources”. But even if you stick with calling the REST APIs, you’ve recovered a lot of useful properties of traditional “HTML apps”—the kind of architecture you’d have with Rails or Django. From the client perspective, the data (JSON this time) arrives in a single roundtrip. And client/server waterfalls can never happen in this model. Okay, so those are the upsides of server loaders. What are the downsides? Server Functions Recall that when we decided to use loaders, we’ve given up on colocation. What if we keep the loaders on the server but write a loader per component so that we can regain the colocation? This might require further blurring the boundaries between server and client code but let’s roll with it for now and see where it leads. The way you would do this depends on what “boundary-blurring” mechanism you use. Let’s start with TanStack Server Functions as an example. This lets us declare a few TanStack Server Functions that the client can import: import { createServerFn } from '@tanstack/react-start' import { loadPost, loadComments } from 'my-data-layer'; export const getPost = createServerFn({ method: 'GET' }).handler( async (postId) =\u003e loadPost(postId) ); export const getComments = createServerFn({ method: 'GET' }).handler( async (postId) =\u003e loadComments(postId) ); Here is an alternative example with the React Server Functions syntax instead: 'use server'; import { loadPost, loadComments } from 'my-data-layer'; export async function getPost(postId) { return loadPost(postId); } export async function getComments(postId) { return loadComments(postId); } I won’t dwell on their differences for now—for the purposes of this post let’s consider them equivalent. In both cases, they create implicit RPC endpoints. The point is that your client-side components can import them directly. No need to set up a REST endpoint of an “API route”. It’s an implicit API route by import. Now we have colocation again! PostContent only needs getPost: import { getPost } from './my-server-functions'; import { Comments } from './Comments'; function usePostQuery(postId) { return useQuery(['post', postId], () =\u003e getPost(postId)); } function PostContent({ postId }) { const { data: post } = usePostQuery(postId); if (!post) { return null; } return ( \u003carticle\u003e \u003ch1\u003e{post.title}\u003c/h1\u003e \u003cp\u003e{post.content}\u003c/p\u003e \u003cComments postId={postId} /\u003e \u003c/article\u003e ); } Similarly, Comments can import getComments directly from the server: import { getComments } from './my-server-functions'; function usePostCommentsQuery(postId) { return useQuery(['post-comments', postId], () =\u003e getComments(postId)); } export function Comments({ postId }) { const { data: comments } = usePostCommentsQuery(postId); return ( \u003cul className=\"comments\"\u003e {comments.map(c =\u003e \u003cli key={c.id}\u003e{c.text}\u003c/li\u003e)} \u003c/ul\u003e ); } But wait… This doesn’t actually help any of the problems we outlined earlier! In fact, we’ve regressed the performance characteristics back to fetching inside Components or Queries. The only thing that Server Functions help with is nicer syntax (import instead of an API route). But when used for colocated data fetching, Server Functions are a step back from Server Loaders. They don’t enforce fetching in a single roundtrip, and don’t prevent client/server waterfalls. Server Functions reduce the plumbing of calling the server but they do not improve data fetching. Does anything? GraphQL Fragments Tragically misunderstood, GraphQL is one take on efficient colocation. The idea of GraphQL—the way it was intended to be used—is that individual components can declare their data dependencies as fragments which then get composed together. (After many years, thankfully, Apollo supports this too.) This means that the Comment component can declare its own data needs: function Comments({ comments }) { return ( \u003cul className=\"comments\"\u003e {comments.map(comment =\u003e ( \u003cComment key={comment.id} comment={comment} /\u003e ))} \u003c/ul\u003e ); } function Comment({ comment }) { const data = useFragment( graphql` fragment CommentFragment on Comment { id text } `, comment ); return \u003cli\u003e{data.text}\u003c/li\u003e; } Note that the Comment component does not do any data fetching on its own. It only declares what data it needs. Now let’s look at the PostContent component. The PostContent component composes the Comment’s fragment into its own: function PostContent({ post }) { const data = useFragment( graphql` fragment PostContentFragment on Post { title content comments { id ...CommentFragment } } `, post ); return ( \u003carticle\u003e \u003ch1\u003e{data.title}\u003c/h1\u003e \u003cp\u003e{data.content}\u003c/p\u003e \u003cComments comments={data.comments} /\u003e \u003c/article\u003e ); } The actual data fetching happens somewhere at the top level. The fragments would compose into this GraphQL query that describes the data for the entire route: query PostPageQuery($postId: ID!) { post(id: $postId) { # From PostContentFragment title content comments { # From CommentFragment id text } } } It’s like an automatically generated loader! For every screen, it’s now possible to generate a query that precisely describes all the data needed by that screen, according to the source code of your components. If you want to change what data is needed by some component, you just change the fragment in that component, and all the queries will change automatically. With GraphQL fragments, each navigation loads data in a single roundtrip. GraphQL is not for everyone. I still feel a bit lost in the syntax (partially because I never heavily used it) and it requires some institutional knowledge to use it well—both on the server side and on the client side. I’m not here to sell you on GraphQL. But it deserves to be said that GraphQL is one of the few approaches that actually did crack this nut. It lets you colocate data requirements with UI but without the penalties of doing it naïvely (that Components and Queries suffer from, with or without Server Functions). In other words, GraphQL offers both the performance characteristics of Server Loaders and the colocation and modularity of Queries. There’s another solution that attempts to do that. RSC React Server Components are the React team’s answer to the question that plagued the team throughout the 2010s. “How to do data fetching in React?” Imagine that each component that needs some data can have its own Server Loader. This is the simplest possible solution—a function per such component. Now, we know that calling Server Loaders from components for data fetching would have been a mistake—we’d go straight back to client/server waterfalls. So we’ll do it the other way around. Our Server Loaders will return our components: import { loadPost, loadComments } from 'my-data-layer'; import { PostContent, Comments } from './client'; function PostContentLoader({ postId }) { const post = await loadPost(postId); return ( \u003cPostContent post={post}\u003e \u003cCommentsLoader postId={postId} /\u003e \u003c/PostContent\u003e ); } function CommentsLoader({ postId }) { const comments = await loadComments(postId); return \u003cComments comments={comments} /\u003e; } 'use client'; export function PostContent({ post, children }) { return ( \u003carticle\u003e \u003ch1\u003e{post.title}\u003c/h1\u003e \u003cp\u003e{post.content}\u003c/p\u003e {children} \u003c/article\u003e ); } export function Comments({ comments }) { return ( \u003cul className=\"comments\"\u003e {comments.map(c =\u003e \u003cli key={c.id}\u003e{c.text}\u003c/li\u003e)} \u003c/ul\u003e ); } The data flows down. The server is the source of truth. Components that want to “receive props from the server” opt into that with the 'use client' directive. Since our “Server Loaders” are indistinguishable from components, we’re calling them Server Components. But they’re a composable version of Server Loaders. This might remind you of the old “Container vs Presentational Components” pattern, except all “Containers” run on the server to avoid extra roundtrips. What do we get from this approach? We get the efficiency of Server Loaders. All of the performance optimization strategies that apply to them (per-request caching, cross-request caching, deploying closer to the data source) apply to Server Components. There’s a guarantee that client/server waterfalls can’t happen. Data arrives in one roundtrip. We get the colocation of Components (or GraphQL Fragments). Although data dependencies aren’t literally declared in the same file, they’re a single hop away. You can always “Find All References” to find where the server props are coming from, just like when you look for where the props come from in React in general. We get the “vanilla” mental model of HTML apps. There’s no separate “API” (although you can add one if you’d like) or long-term normalized client caching. You return a tree, but your palette is your React components (rather than HTML). There’s no special language to learn, or data loading APIs. In a way, there is no API. In fact, the example above can be collapsed to: import { loadPost, loadComments } from 'my-data-layer'; async function PostContent({ postId }) { const post = await loadPost(postId); return ( \u003carticle\u003e \u003ch1\u003e{post.title}\u003c/h1\u003e \u003cp\u003e{post.content}\u003c/p\u003e \u003cComments postId={postId} /\u003e \u003c/article\u003e ); } async function Comments({ postId }) { const comments = await loadComments(postId); return ( \u003cul className=\"comments\"\u003e {comments.map(c =\u003e \u003cli key={c.id}\u003e{c.text}\u003c/li\u003e)} \u003c/ul\u003e ); } When the user requests the page (whether the navigation is initial or subsequent), the client will make a single request to the server. The server will start serializing the output, starting from the \u003cPostContent postId={123} /\u003e, recursively unfolding it, and streaming a React tree that will either turn to HTML or JSON. From the client’s perspective, every navigation results in a single request to the server. From the server’s perspective, the data loading logic is split as modularly as necessary. The server passes data to the client by returning the client tree. So What? In this post, I tried to show how RSC relate to different aspects of existing data fetching solutions. There’s many things I haven’t covered, but I’ll note a few: Fetching data in a single roundtrip might seem like a bad idea if some part is slower to load. (RSC solves this by streaming, GraphQL by the @defer directive.) Client/server waterfalls might seem like less of a problem if you use prefetching. (That’s not true; for inherent client/server waterfalls, prefetching doesn’t help.) Fetching in components might seem like a bad idea due to server-only waterfalls. (This is true in some cases, depending on whether you use a low-latency data layer. I don’t think this speaks against RSC but I’ll save that for another post.) If there’s one thing I’d like to you to take away, it’s that there aren’t many solutions that aim to solve both colocation and efficiency. HTML templates do that (with Astro as a modern contender), GraphQL does it, and RSC also does it. Something to ask your favorite framework for!",
  "image": "https://overreacted.io/one-roundtrip-per-navigation/opengraph-image?5b0b970dfd19bb8c",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eHow many requests should it take to navigate to another page?\u003c/p\u003e\n\u003cp\u003eIn the simplest case, a navigation is resolved in a single request. You click a link, the browser requests the HTML content for the new URL, and then displays it.\u003c/p\u003e\n\u003cp\u003eIn practice, a page might also want to display some images, load some client-side JavaScript, load some extra styles, and so on. So there’ll be a bunch of requests. Some will be render-blocking (so the browser will defer displaying the page until they resolve), and the rest will be “nice-to-have”. Maybe they’ll be important for full interactivity but the browser can already display the page while they load.\u003c/p\u003e\n\u003cp\u003eOkay, but what about loading \u003cem\u003edata\u003c/em\u003e?\u003c/p\u003e\n\u003cp\u003eHow many API requests should it take to get the \u003cem\u003edata\u003c/em\u003e for the next page?\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"html\"\u003e\u003ca target=\"_self\" href=\"#html\"\u003eHTML\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBefore much of the web development has moved to the client, this question didn’t even make sense. There was no concept of “hitting the API” because you wouldn’t think of your server as an \u003cem\u003eAPI server\u003c/em\u003e—it was just \u003cem\u003ethe server\u003c/em\u003e, returning HTML.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn traditional “HTML apps”, aka websites, getting the data always takes a single roundtrip.\u003c/strong\u003e The user clicks a link, the server returns the HTML, and all the data necessary to display the next page is already embedded \u003cem\u003ewithin\u003c/em\u003e that HTML. The HTML itself \u003cem\u003eis\u003c/em\u003e the data. It doesn’t need further processing—it’s ready for display:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"html\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"html\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eOne Roundtrip Per Navigation\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eHow many requests should it take to navigate to another page?\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e class=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eYou\u0026#39;re just reinventing HTML\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eYou\u0026#39;re just reinventing PHP\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eYou\u0026#39;re just reinventing GraphQL\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eYou\u0026#39;re just reinventing Remix\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003eYou\u0026#39;re just reinventing Astro\u003c/span\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003e(Yes, technically some static, reusable and cacheable parts like images, scripts, and styles get “outlined”, but you can also always inline them whenever that’s useful.)\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"rest\"\u003e\u003ca target=\"_self\" href=\"#rest\"\u003e“REST”\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThings changed as we moved more of the application logic to the client side. The data we want to fetch is usually determined by the UI we need to display. When we want to show a post, we need to fetch that post. When we want to show a post’s comments, we need to fetch those comments. So how many fetches do we make?\u003c/p\u003e\n\u003cp\u003eWith JSON APIs, a technique \u003ca target=\"_blank\" href=\"https://htmx.org/essays/how-did-rest-come-to-mean-the-opposite-of-rest\"\u003eknown as\u003c/a\u003e REST suggests to expose an endpoint per a conceptual “resource”. Nobody knows what exactly a “resource” is but usually the backend team will be in charge of defining this concept. So maybe you’ll have a Post “resource” and a Post Comments “resource”, and so you’ll be able to load the data for the post page (which contains the post and its comments) in two fetches.\u003c/p\u003e\n\u003cp\u003eBut \u003cem\u003ewhere\u003c/em\u003e do these two fetches happen?\u003c/p\u003e\n\u003cp\u003eIn server-centric HTML apps (aka websites) you could hit two REST APIs during a single request, and still return all the data as a single response. This is because the REST API requests would happen \u003cem\u003eon the server\u003c/em\u003e. The REST API was used mostly as an explicit boundary for the data layer, but it was not really required (many were happy to use an in-process data layer that you can import—like in Rails or Django). Regardless of REST, the data (HTML) arrived to the client (browser) in one piece.\u003c/p\u003e\n\u003cp\u003eAs we started moving UI logic to the client for richer interactivity, it felt natural to keep the existing REST APIs but to \u003ccode\u003efetch\u003c/code\u003e them \u003cem\u003efrom\u003c/em\u003e the client. Isn’t that kind of flexiblity exactly what JSON APIs were great at? Everything became a JSON API:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003econst [\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eall\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e()),\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/comments`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e]);\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003e\u003cstrong\u003eHowever as a result, there are now two fetches in the Network tab: one fetch for the Post and another fetch for that Post’s Comments.\u003c/strong\u003e A single page—a single link click—often needs data from more than one REST “resource”. In the best case, you can hit a couple of endpoints and call it a day. In the worst case, you might have to hit N endpoints for N items, or hit the server repeatedly in a series of client/server waterfalls (get some data, compute stuff from it, use that to get some more data).\u003c/p\u003e\n\u003cp\u003eAn inefficiency is creeping in. When we were on the server, making a bunch of REST requests was cheap because we had control over how our code is deployed. If those REST endpoints were far away, we could move our server closer to them or even move their code in-process. We could use replication or server-side caching. Even if something got inefficient, on the server we have many \u003cem\u003elevers\u003c/em\u003e to improve that inefficiency. Nothing is \u003cem\u003estopping\u003c/em\u003e us from improving things on the server side.\u003c/p\u003e\n\u003cp\u003eHowever, if you think of the server as a black box, you can’t improve on the APIs it provides. You can’t optimize a client/server waterfall if the server doesn’t return all the data needed to run requests in parallel. You can’t reduce the number of parallel requests if the server doesn’t provide an API that returns all the data in a batch.\u003c/p\u003e\n\u003cp\u003eAt some point you’re going to hit a wall.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"components\"\u003e\u003ca target=\"_self\" href=\"#components\"\u003eComponents\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe problem above wouldn’t be so bad if not for the tension between efficiency and encapsulation. As developers, we feel compelled to place the logic to load the data close to where this data is used. Someone might say this leads to “spaghetti code”, but it doesn’t have to! The idea itself is solid. Recall—the UI \u003cem\u003edetermines\u003c/em\u003e the data. The data you need depends on what you want to display. The data fetching logic and the UI logic are \u003cem\u003einherently coupled\u003c/em\u003e—when one changes, the other needs to be aware of that. You don’t want to break stuff by “underfetching” or bloat it by “overfetching”. But how do you keep the UI logic and the data fetching in sync?\u003c/p\u003e\n\u003cp\u003eThe most direct approach would be to put the data loading logic directly in your UI components. That’s the “\u003ccode\u003e$.ajax\u003c/code\u003e in a \u003ccode\u003eBackbone.View\u003c/code\u003e” approach, or “\u003ccode\u003efetch\u003c/code\u003e in \u003ccode\u003euseEffect\u003c/code\u003e” approach. It was incredibly popular with the rise of client-side UI—and still is. The benefit of this approach is \u003cem\u003ecolocation:\u003c/em\u003e the code that says what data to load is located right next to the code consuming it. Different people can write components that depend on different data sources, and then put them together:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e setPost\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  useEffect\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      .\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      .\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esetPost\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  },\u003c/span\u003e\u003cspan\u003e []);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (!\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e null\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e postId={\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e setComments\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e useState\u003c/span\u003e\u003cspan\u003e([])\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  useEffect\u003c/span\u003e\u003cspan\u003e(()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/comments`\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      .\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      .\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esetComments\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  },\u003c/span\u003e\u003cspan\u003e [])\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e}\u0026gt;{\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;)}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eHowever, this approach makes the problem from the previous section much more severe. Not only does rendering a single page take a bunch of requests, these requests are now \u003cem\u003espread out in the codebase\u003c/em\u003e. How do you audit for inefficiencies?\u003c/p\u003e\n\u003cp\u003eSomeone might edit a component, add some data loading to it, and thus introduce a new client/server waterfall to a dozen different screens using that component. If our components ran on the server \u003cem\u003eonly\u003c/em\u003e—like \u003ca target=\"_blank\" href=\"https://docs.astro.build/en/basics/astro-components/\"\u003eAstro Components\u003c/a\u003e—data fetching delays would at best be nonexistent and at worst be predictable. But on the client, smudging the data fetching logic across components cascades the inefficiencies without good levers to fix them—we can’t \u003cem\u003emove the user\u003c/em\u003e any closer to our servers. (And \u003cem\u003einherent\u003c/em\u003e waterfalls can’t be fixed from the client at all—even by prefetching.)\u003c/p\u003e\n\u003cp\u003eLet’s see if adding a bit more structure to our data fetching code can help.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"queries\"\u003e\u003ca target=\"_self\" href=\"#queries\"\u003eQueries\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eInterestingly, solutions that bring some structure to data fetching—like \u003ca target=\"_blank\" href=\"https://tanstack.com/query/latest/docs/framework/react/overview\"\u003eReact Query\u003c/a\u003e (\u003ccode\u003euseQuery\u003c/code\u003e)—aren’t on their own immune to this. They’re much more principled than \u003ccode\u003efetch\u003c/code\u003e in \u003ccode\u003euseEffect\u003c/code\u003e (and caching helps) but you get the same “N queries for N items” and “client/server query waterfalls” problems with them.\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e usePostQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e useQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    [\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e postId\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    ()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e usePostCommentsQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e useQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    [\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003epost-comments\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e postId\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    ()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/comments`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e usePostQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (!\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e null\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e postId={\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e usePostCommentsQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e}\u0026gt;{\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;)}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eIn fact, client-side caching in general is a bit of a red herring. It is essential for the Back button to be instant in client-side apps (and thus should not be neglected), and it helps to reuse stuff from the cache for some navigations like tab switches. But for many navigations—primarily clicking on links—the user actually \u003cem\u003eexpects\u003c/em\u003e to see fresh content. It’s why the browser waits to load the page in “HTML apps”! The user might not want the \u003cem\u003ewhole\u003c/em\u003e page to be replaced (especially if your app has a navigation “shell”), but the content area is expected to be fresh after a link click. (Of course, prefetching on hover for an instant-\u003cem\u003eand\u003c/em\u003e-fresh navigation is even nicer.)\u003c/p\u003e\n\u003cp\u003eCounter-intuitively, this means that faster is not \u003cem\u003ealways\u003c/em\u003e better. It’s often \u003cem\u003eworse\u003c/em\u003e for the user experience to show a flash of stale cached content and then immediately replace it a la “stale-while-revalidate”. It betrays the user’s intent. Clicking the link carries an expectation of freshness. I don’t want to have to Ctrl+R “just in case”.\u003c/p\u003e\n\u003cp\u003eClient-side caching helps if the content \u003cem\u003ecouldn’t have changed yet\u003c/em\u003e or you simply don’t care to reflect the changes, but it isn’t panacea and doesn’t fix other issues. It solves a range of problems, but it doesn’t reduce the number of requests when we \u003cem\u003ewant\u003c/em\u003e the data to be fresh, and it doesn’t help us prevent client/server waterfalls.\u003c/p\u003e\n\u003cp\u003eSo now we have this tension: it feels tempting to colocate the UI with its data requirements, but we also want to avoid client/server waterfalls and firing too many parallel requests. Client-side caching of queries \u003cem\u003ealone\u003c/em\u003e doesn’t fix this.\u003c/p\u003e\n\u003cp\u003eWhat do we do?\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"client-loaders\"\u003e\u003ca target=\"_self\" href=\"#client-loaders\"\u003eClient Loaders\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eOne thing we could do is to give up on colocation. Suppose that for each route, we define a function that will load all the data for that route. We’ll call it a \u003cem\u003eloader:\u003c/em\u003e\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e clientLoader\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ params }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e params\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eall\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e()),\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/comments`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  ]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e post\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments \u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThis example is using the \u003ca target=\"_blank\" href=\"https://reactrouter.com/start/framework/data-loading#client-data-loading\"\u003e\u003ccode\u003eclientLoader\u003c/code\u003e\u003c/a\u003e API from React Router, but the idea itself is more general. For each navigation, assume that the router runs the loader for the next route, and then hands off the data to your component hierarchy.\u003c/p\u003e\n\u003cp\u003eThe downside of this approach is that the data requirements are no longer colocated with the components that need that data. There’s now a piece of code “at the top” of each route that has to “know” what the entire hierarchy below it needs. In that sense, it feels like a step back from fetching in Queries or in Components.\u003c/p\u003e\n\u003cp\u003eThe upside of this approach is that it’s way easier to avoid client/server waterfalls. They are still \u003cem\u003epossible\u003c/em\u003e (and sometimes unavoidable) because the \u003ccode\u003eclientLoader\u003c/code\u003e function runs on the client—but they are \u003cem\u003evisible\u003c/em\u003e. You’re not creating client/server waterfalls \u003cem\u003eby default\u003c/em\u003e, which fetching in Components or Queries suffered from.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"server-loaders\"\u003e\u003ca target=\"_self\" href=\"#server-loaders\"\u003eServer Loaders\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAnother upside of loaders is that, if each route has a self-contained loader, it is easy to move some of this logic \u003cem\u003eto the server\u003c/em\u003e. Since the loader is independent from your components (it runs \u003cem\u003ebefore\u003c/em\u003e any components), you could make it a part of your HTML or API server—or even a separate “BFF” server (a \u003cem\u003e“backend for frontend”\u003c/em\u003e).\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// This could run on the server instead\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e loader\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ params }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e params\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eall\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e()),\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    fetch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e`/api/posts/\u003c/span\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e/comments`\u003c/span\u003e\u003cspan\u003e).\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eres \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e res\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejson\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  ]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e post\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments \u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThis is the model followed by the \u003ca target=\"_blank\" href=\"https://reactrouter.com/start/framework/data-loading#server-data-loading\"\u003eReact Router \u003ccode\u003eloader\u003c/code\u003e function\u003c/a\u003e as well as the old school Next.js \u003ccode\u003egetServerSideProps()\u003c/code\u003e. (Usually, a code transform “detaches” the server loader code from the rest of your code which is destined for the client.)\u003c/p\u003e\n\u003cp\u003eWhy move the loader to the server?\u003c/p\u003e\n\u003cp\u003eIf you don’t treat the server as a black box beyond your control, it is \u003cem\u003ethe\u003c/em\u003e natural place to put your data fetching code. When you’re on the server, you have all the levers to improve common performance problems. You often have control over latency—for example, you can your BFF server closer to the data source. Then even \u003cem\u003einherent\u003c/em\u003e waterfalls will be cheap. If the data source is slow, you have ability to add cross-request caching on the server. You also have the option of dispensing with microservices entirely and moving your data layer to be in-process, like in Rails:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e loadComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003emy-data-layer\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e loader\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ params }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e params\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const [\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments\u003c/span\u003e\u003cspan\u003e] \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eall\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e    loadPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e    loadComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  ]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e post\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e comments \u003c/span\u003e\u003cspan\u003e};\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eAn in-process data layer gives you the ultimate opportunities for optimization. It lets you drop down to a lower level whenever necessary (for example, to call an optimized stored procedure for a particular screen). In-memory per-request caching and batching let you reduce the number of database trips even further. You don’t have to worry about overfetching or underfetching—each loader can send \u003cem\u003ejust the data that its screen needs\u003c/em\u003e. No more “expanding” “REST” “resources”.\u003c/p\u003e\n\u003cp\u003eBut even if you stick with calling the REST APIs, you’ve recovered a lot of useful properties of traditional “HTML apps”—the kind of architecture you’d have with Rails or Django. \u003cstrong\u003eFrom the client perspective, the data (JSON this time) arrives in a single roundtrip.\u003c/strong\u003e And client/server waterfalls \u003cem\u003ecan never happen\u003c/em\u003e in this model.\u003c/p\u003e\n\u003cp\u003eOkay, so those are the upsides of server loaders. What are the downsides?\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"server-functions\"\u003e\u003ca target=\"_self\" href=\"#server-functions\"\u003eServer Functions\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRecall that when we decided to use loaders, we’ve given up on colocation.\u003c/p\u003e\n\u003cp\u003eWhat if we keep the loaders on the server but write a \u003cem\u003eloader per component\u003c/em\u003e so that we can regain the colocation? This might require further blurring the boundaries between server and client code but let’s roll with it for now and see where it leads.\u003c/p\u003e\n\u003cp\u003eThe way you would do this depends on what “boundary-blurring” mechanism you use. Let’s start with \u003ca target=\"_blank\" href=\"https://tanstack.com/start/latest/docs/framework/react/server-functions\"\u003eTanStack Server Functions\u003c/a\u003e as an example.\u003c/p\u003e\n\u003cp\u003eThis lets us declare a few TanStack Server Functions that the client can import:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e createServerFn \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e@tanstack/react-start\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e loadComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003emy-data-layer\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport const \u003c/span\u003e\u003cspan\u003egetPost\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e createServerFn\u003c/span\u003e\u003cspan\u003e({\u003c/span\u003e\u003cspan\u003e method\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003eGET\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e }).\u003c/span\u003e\u003cspan\u003ehandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  async \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e =\u0026gt; \u003c/span\u003e\u003cspan\u003eloadPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport const \u003c/span\u003e\u003cspan\u003egetComments\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e createServerFn\u003c/span\u003e\u003cspan\u003e({\u003c/span\u003e\u003cspan\u003e method\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003eGET\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e }).\u003c/span\u003e\u003cspan\u003ehandler\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  async \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e =\u0026gt; \u003c/span\u003e\u003cspan\u003eloadComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eHere is an alternative example with the \u003ca target=\"_blank\" href=\"https://react.dev/reference/rsc/server-functions\"\u003eReact Server Functions\u003c/a\u003e syntax instead:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003euse server\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e loadComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003emy-data-layer\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e async\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e getPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e async\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e getComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e loadComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eI won’t dwell on their differences for now—for the purposes of this post let’s consider them equivalent. In both cases, \u003ca href=\"https://overreacted.io/what-does-use-client-do/#use-server\"\u003ethey create implicit RPC endpoints.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe point is that your client-side components can import them directly. No need to set up a REST endpoint of an “API route”. It’s an implicit API route by \u003ccode\u003eimport\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNow we have colocation again! \u003ccode\u003ePostContent\u003c/code\u003e only needs \u003ccode\u003egetPost\u003c/code\u003e:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e getPost \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./my-server-functions\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e Comments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./Comments\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e usePostQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e useQuery\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e postId\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003e ()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e getPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e usePostQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  if\u003c/span\u003e\u003cspan\u003e (!\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    return\u003c/span\u003e\u003cspan\u003e null\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e postId={\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eSimilarly, \u003ccode\u003eComments\u003c/code\u003e can import \u003ccode\u003egetComments\u003c/code\u003e directly from the server:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e getComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./my-server-functions\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e usePostCommentsQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e useQuery\u003c/span\u003e\u003cspan\u003e([\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003epost-comments\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e postId\u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\u003cspan\u003e ()\u003c/span\u003e\u003cspan\u003e =\u0026gt;\u003c/span\u003e\u003cspan\u003e getComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const { \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e } \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e usePostCommentsQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e}\u0026gt;{\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;)}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eBut wait…\u003c/p\u003e\n\u003cp\u003eThis doesn’t actually help any of the problems we outlined earlier!\u003c/p\u003e\n\u003cp\u003eIn fact, we’ve \u003cem\u003eregressed\u003c/em\u003e the performance characteristics back to fetching inside \u003ca href=\"#components\"\u003eComponents\u003c/a\u003e or \u003ca href=\"#queries\"\u003eQueries\u003c/a\u003e. The only thing that Server Functions help with is \u003cem\u003enicer syntax\u003c/em\u003e (\u003ccode\u003eimport\u003c/code\u003e instead of an API route). But when used for \u003cem\u003ecolocated data fetching\u003c/em\u003e, Server Functions are a \u003cem\u003estep back\u003c/em\u003e from Server Loaders. They don’t enforce fetching in a single roundtrip, and don’t prevent client/server waterfalls. Server Functions reduce the plumbing of \u003cem\u003ecalling the server\u003c/em\u003e but they do not improve data fetching.\u003c/p\u003e\n\u003cp\u003eDoes anything?\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"graphql-fragments\"\u003e\u003ca target=\"_self\" href=\"#graphql-fragments\"\u003eGraphQL Fragments\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTragically misunderstood, GraphQL is one take on efficient colocation.\u003c/p\u003e\n\u003cp\u003eThe idea of GraphQL—the way it was \u003ca target=\"_blank\" href=\"https://alan.norbauer.com/articles/relay-style-graphql/\"\u003eintended\u003c/a\u003e to be used—is that individual components can declare their data dependencies as \u003cem\u003efragments\u003c/em\u003e which then get composed together. (After many years, thankfully, \u003ca target=\"_blank\" href=\"https://www.apollographql.com/blog/optimizing-data-fetching-with-apollo-client-leveraging-usefragment-and-colocated-fragments\"\u003eApollo supports this too.\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eThis means that the \u003ccode\u003eComment\u003c/code\u003e component can declare its own data needs:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ comments }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecomment \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        \u0026lt;\u003c/span\u003e\u003cspan\u003eComment\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e} comment={\u003c/span\u003e\u003cspan\u003ecomment\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      ))}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e Comment\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ comment }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e useFragment\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    graphql\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e      fragment CommentFragment on Comment {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e        id\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e        text\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    `\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    comment\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eNote that the \u003ccode\u003eComment\u003c/code\u003e component \u003cstrong\u003edoes not do any data fetching on its own.\u003c/strong\u003e It only \u003cem\u003edeclares\u003c/em\u003e what data it needs. Now let’s look at the \u003ccode\u003ePostContent\u003c/code\u003e component.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ePostContent\u003c/code\u003e component \u003cem\u003ecomposes\u003c/em\u003e the \u003ccode\u003eComment\u003c/code\u003e’s fragment into its own:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ post }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e useFragment\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    graphql\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      fragment PostContentFragment on Post {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        title\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        content\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        comments {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e          id\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e          ...CommentFragment\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    `\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    post\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e comments={\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eThe actual data fetching happens somewhere at the top level. The fragments would compose into this GraphQL query that describes the data \u003cem\u003efor the entire route:\u003c/em\u003e\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"graphql\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"graphql\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003equery\u003c/span\u003e\u003cspan\u003e PostPageQuery\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e$postId: \u003c/span\u003e\u003cspan\u003eID\u003c/span\u003e\u003cspan\u003e!)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  post\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eid: $postId\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    # From PostContentFragment\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    title\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    content\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    comments {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      # From CommentFragment\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      id\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      text\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eIt’s like an automatically generated loader!\u003c/p\u003e\n\u003cp\u003eFor every screen, it’s now possible to generate a query that precisely describes all the data needed by that screen, according to the source code of your components. If you want to change what data is needed by some component, you just change the fragment in that component, and all the queries will change automatically. \u003cstrong\u003eWith GraphQL fragments, each navigation loads data in a single roundtrip.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGraphQL is not for everyone. I still feel a bit lost in the syntax (partially because I never heavily used it) and it requires some institutional knowledge to use it well—both on the server side and on the client side. I’m not here to sell you on GraphQL.\u003c/p\u003e\n\u003cp\u003eBut it deserves to be said that GraphQL is one of the \u003cem\u003efew\u003c/em\u003e approaches that actually \u003cem\u003edid\u003c/em\u003e crack this nut. It lets you colocate data requirements with UI but \u003cem\u003ewithout\u003c/em\u003e the penalties of doing it naïvely (that \u003ca href=\"#components\"\u003eComponents\u003c/a\u003e and \u003ca href=\"#queries\"\u003eQueries\u003c/a\u003e suffer from, with or without \u003ca href=\"#server-functions\"\u003eServer Functions\u003c/a\u003e). In other words, GraphQL offers both the performance characteristics of \u003ca href=\"#server-loaders\"\u003eServer Loaders\u003c/a\u003e \u003cem\u003eand\u003c/em\u003e the colocation and modularity of \u003ca href=\"#queries\"\u003eQueries\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThere’s another solution that attempts to do that.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"rsc\"\u003e\u003ca target=\"_self\" href=\"#rsc\"\u003eRSC\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eReact Server Components are the React team’s answer to the question that plagued the team throughout the 2010s. “How to do data fetching in React?”\u003c/p\u003e\n\u003cp\u003eImagine that each component that needs some data can have its own \u003ca href=\"#server-loaders\"\u003eServer Loader\u003c/a\u003e. This is the simplest possible solution—a function per such component.\u003c/p\u003e\n\u003cp\u003eNow, we know that calling Server Loaders \u003cem\u003efrom\u003c/em\u003e components for data fetching \u003ca href=\"#server-functions\"\u003ewould have been a mistake\u003c/a\u003e—we’d go straight back to client/server waterfalls. So we’ll do it the other way around. Our Server Loaders will \u003cem\u003ereturn\u003c/em\u003e our components:\u003c/p\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e loadComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003emy-data-layer\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e Comments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003e./client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e PostContentLoader\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003eloadPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003ePostContent\u003c/span\u003e\u003cspan\u003e post={\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e}\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eCommentsLoader\u003c/span\u003e\u003cspan\u003e postId={\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003ePostContent\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e CommentsLoader\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003eloadComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\" data-highlighted-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e comments={\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e} /\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cdiv\u003e\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003euse client\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ post\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e children }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003echildren\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eexport\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ comments }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e}\u0026gt;{\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;)}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\u003c/div\u003e\n\u003cp\u003eThe data flows down. The server is the source of truth. Components that want to “receive props from the server” opt into that with the \u003ca href=\"https://overreacted.io/what-does-use-client-do/\"\u003e\u003ccode\u003e\u0026#39;use client\u0026#39;\u003c/code\u003e directive\u003c/a\u003e. Since our “Server Loaders” are indistinguishable from components, we’re calling them Server Components. But they’re a composable version of Server Loaders.\u003c/p\u003e\n\u003cp\u003eThis might remind you of the old “Container vs Presentational Components” pattern, except all “Containers” run on the server to avoid extra roundtrips.\u003c/p\u003e\n\u003cp\u003eWhat do we get from this approach?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eWe get the efficiency of \u003ca href=\"#server-loaders\"\u003eServer Loaders\u003c/a\u003e.\u003c/strong\u003e All of the performance optimization strategies that apply to them (per-request caching, cross-request caching, deploying closer to the data source) apply to Server Components. There’s a guarantee that client/server waterfalls can’t happen. Data arrives in one roundtrip.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWe get the colocation of \u003ca href=\"#components\"\u003eComponents\u003c/a\u003e (or \u003ca href=\"#graphql-fragments\"\u003eGraphQL Fragments\u003c/a\u003e).\u003c/strong\u003e Although data dependencies aren’t literally declared in the same file, they’re a single hop away. You can always “Find All References” to find where the \u003cem\u003eserver props\u003c/em\u003e are coming from, just like when you look for where the props come from in React in general.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWe get the “vanilla” mental model of \u003ca href=\"#html\"\u003eHTML\u003c/a\u003e apps.\u003c/strong\u003e There’s no separate “API” (although you can add one if you’d like) or long-term normalized client caching. You return a tree, but your palette is your React components (rather than HTML). There’s no special language to learn, or data loading APIs. In a way, there \u003cem\u003eis\u003c/em\u003e no API.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn fact, the example above can be collapsed to:\u003c/p\u003e\n\u003cfigure data-rehype-pretty-code-figure=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"js\" data-theme=\"Overnight\"\u003e\u003ccode data-language=\"js\" data-theme=\"Overnight\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003cspan\u003e loadPost\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e loadComments \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e from\u003c/span\u003e\u003cspan\u003e \u0026#39;\u003c/span\u003e\u003cspan\u003emy-data-layer\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e PostContent\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003eloadPost\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etitle\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eh1\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;{\u003c/span\u003e\u003cspan\u003epost\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtent\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      \u0026lt;\u003c/span\u003e\u003cspan\u003eComments\u003c/span\u003e\u003cspan\u003e postId={\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e} /\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003earticle\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e function\u003c/span\u003e\u003cspan\u003e Comments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{ postId }\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  const \u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e =\u003c/span\u003e\u003cspan\u003e await \u003c/span\u003e\u003cspan\u003eloadComments\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epostId\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  return\u003c/span\u003e\u003cspan\u003e (\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e className=\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e      {\u003c/span\u003e\u003cspan\u003ecomments\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ec \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u0026lt;\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e key={\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eid\u003c/span\u003e\u003cspan\u003e}\u0026gt;{\u003c/span\u003e\u003cspan\u003ec\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etext\u003c/span\u003e\u003cspan\u003e}\u0026lt;/\u003c/span\u003e\u003cspan\u003eli\u003c/span\u003e\u003cspan\u003e\u0026gt;)}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e    \u0026lt;/\u003c/span\u003e\u003cspan\u003eul\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  );\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\u003cp\u003eWhen the user requests the page (whether the navigation is initial or subsequent), the client will make a \u003cstrong\u003esingle request to the server.\u003c/strong\u003e The server will start serializing the output, starting from the \u003ccode\u003e\u0026lt;PostContent postId={123} /\u0026gt;\u003c/code\u003e, recursively unfolding it, and streaming a React tree that will either turn to HTML or JSON.\u003c/p\u003e\n\u003cp\u003eFrom the client’s perspective, every navigation results in a single request to the server. From the server’s perspective, the data loading logic is split as modularly as necessary. The server passes data to the client by \u003cem\u003ereturning\u003c/em\u003e the client tree.\u003c/p\u003e\n\u003chr/\u003e\n\u003ch3 id=\"so-what\"\u003e\u003ca target=\"_self\" href=\"#so-what\"\u003eSo What?\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIn this post, I tried to show how RSC relate to different aspects of existing data fetching solutions. There’s many things I haven’t covered, but I’ll note a few:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFetching data in a single roundtrip might seem like a bad idea if some part is slower to load. (RSC solves this by streaming, GraphQL by the \u003ccode\u003e@defer\u003c/code\u003e directive.)\u003c/li\u003e\n\u003cli\u003eClient/server waterfalls might seem like less of a problem if you use prefetching. (That’s not true; for \u003cem\u003einherent\u003c/em\u003e client/server waterfalls, prefetching doesn’t help.)\u003c/li\u003e\n\u003cli\u003eFetching in components might seem like a bad idea due to server-only waterfalls. (This is true in some cases, depending on whether you use a low-latency data layer. I don’t think this speaks against RSC but I’ll save that for another post.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eIf there’s one thing I’d like to you to take away, it’s that there aren’t many solutions that aim to solve both colocation \u003cem\u003eand\u003c/em\u003e efficiency. HTML templates do that (with \u003ca target=\"_blank\" href=\"https://astro.build/\"\u003eAstro\u003c/a\u003e as a modern contender), GraphQL does it, and RSC also does it.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSomething to ask your favorite framework for!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "26 min read",
  "publishedTime": null,
  "modifiedTime": null
}
