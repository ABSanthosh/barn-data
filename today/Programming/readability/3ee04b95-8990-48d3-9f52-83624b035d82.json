{
  "id": "3ee04b95-8990-48d3-9f52-83624b035d82",
  "title": "How We Built Purrfect Code: A Puzzle Game for Developers",
  "link": "https://developers.googleblog.com/en/how-we-built-purrfect-code/",
  "description": "Purrfect Code is a sokoban style box pushing puzzler Purrfect based on Google tech (Flutter, IDX, FLAME, Firebase) and designed to be playable on web browsers. Open the game in Project IDX, earn badges for each level, and showcase your badges on your Developer Profile.",
  "author": "",
  "published": "",
  "source": "http://feeds.feedburner.com/GDBcode",
  "categories": null,
  "byline": "Google for Developers",
  "length": 12236,
  "excerpt": "Purrfect Code is a sokoban style box pushing puzzler Purrfect based on Google tech (Flutter, IDX, FLAME, Firebase) and designed to be playable on web browsers. Open the game in Project IDX, earn badges for each level, and showcase your badges on your Developer Profile.",
  "siteName": "",
  "favicon": "",
  "text": "\"Purrfect Code\" is a new box-pushing programming puzzle game, powered by Flutter, Dart, and the Flame game engine and designed to challenge developers to solve puzzles by writing code.Game OverviewIn \"Purrfect Code,\" players are tasked with updating the programming of a janitor robot on Google's new space station headquarters where a shipment of cats has mistakenly arrived. The goal of the game is to help the robot safely round up boxes containing the cats and push them onto teleporter plates so they can get home. Players write JavaScript to control the robots movements while trying to discover efficient solutions to navigate through grid-based puzzles.The game is a fun way to explore coding, using your intelligence and creativity. Each level is focused on a programming concept and gently increases in complexity over the course of the five levels in the game.The game loop is as follows:Players write JavaScript code to move the robot (up, down, left, or right)2. They then run their code and watch as the robot attempts to solve the level3. The level is completed when all boxes containing cats are pushed to the teleporter plates4. Players are scored on the efficiency of their solutions including the number of spaces moved and the brevity of their code Sorry, your browser doesn't support playback for this video Building the Game with Flutter, Dart, and FlameWe chose to build \"Purrfect Code\" using Flutter and Dart, as they provide a powerful and flexible framework for creating multi-platform applications and games. Flutter's widget system and reactive programming model allowed us to create a responsive user interface for a variety of screen sizes in the browser. Dart's strongly-typed and object-oriented programming features made it easy to structure our code and keep our codebase clean. The Flame game engine, built on top of Flutter, offered a nice foundation of basic features needed for game development, allowing us to focus on our gameplay logic and the unique aspects of the game. Flutter and Flame were a clear choice for this project due to Purrfect Code’s nature as a unique game/app hybrid with both an IDE inspired UI and a game view with animated sprites and sound.Chrome and JavaScript: Leveraging Built-in Browser SupportOnce we settled on the programming concept for the game, we needed to choose what programming language players would use. We wanted something familiar and popular among devs. Initially we considered using Python as the in-game programming language. However after some consideration, we decided to go with JavaScript to leverage the built-in JavaScript support provided by Chrome. By utilizing JavaScript, we could tap into the browser's native capabilities without the need to load an additional language interpreter. This decision not only simplified our development process, but also ensured a seamless experience for players, as the game could load quickly with minimal dependencies.Flutter’s 3.22 release at Google I/O this year introduced stable support for WebAssembly (WASM) which allowed us to optimize performance-critical parts of the game. By compiling certain game logic to WASM, we ensured that \"Purrfect Code\" runs efficiently in the browser, delivering a smooth and responsive gaming experience without compromising on performance. var dir = [moveEast,moveNorth,moveWest,moveSouth]; for(i=0;i\u003c4;i++){ for(j=0;j\u003c5;j++)dir[i](); } Flame Game Engine: Modular and Efficient Game DevelopmentTo bring \"Purrfect Code\" to life, we utilized the Flame Game Engine, an open source modular game engine built on Flutter that provides many of the commonly needed features for game development. Flame leverages the robust infrastructure of Flutter while simplifying the code required to build our project. It offers a simple yet effective game loop implementation and a wide range of essential functionalities, such as audio playback, sprite management, animation features, collision, and the Flame Component System (FCS). The engine's component-based architecture, sprite rendering, and animation support enabled us to create visually appealing graphics, smooth animations, and interactive gameplay elements without having to reinvent the wheel. Leveraging Flame, made the development process more efficient with essential features ready at hand, allowing us to focus on creating an engaging gaming experience for our players.Implementing Game Features with FlameFlame offers a simple yet effective game loop implementation and a wide range of essential functionalities, such as audio playback, sprite management, animation features, collision, and the Flame Component System (FCS).Flame's sprite rendering and animation system allowed us to bring the game's characters and environments to life without having to write graphics code. We could create sprite sheets, define animation sequences, and smoothly animate the character's movements and special effects. We used Flame’s priority system to write a visual sorting system for our “top down” game perspective. Our artist built levels with many overlapping features to enhance the feeling of depth with the sprites and give the game view a less “grid like” appearance. We needed to make sure that when the robot would move behind them that it would be occluded correctly. Flame’s priority system allowed us to assign priorities to different visual elements, ensuring that they were drawn in the correct order and overlapped properly. This system was flexible enough for us to include a shadow system where individual components could feature animated shadows that mirrored object actions and gave the art a feeling of depth that made scenes both more vibrant and easier to visually comprehend.The BoxShadow class in our codebase is a good example of this and shows how we created dynamic and interactive shadows for the game's moving box objects. By extending the SpriteAnimationComponent and implementing the GridElement and HasVisibility mixins, we were able to load sprite sheets for the box shadow and box teleport animations, define multiple animations for open, closed, idle and the teleporting states and integrate them into the grid-based layout. The onLoad method loads the animations and sets the initial position and priority of the component based on its grid position, while the update method ensures that the component's priority updates dynamically if the box moves in front of or behind an occluding object. Using Flame’s priority and animation systems this way enabled us to create shadow effects which always help users visually understand virtual spaces and make them more believable and leads to a more integrated visual presentation.Excerpt from box_shadow.dart, view the full class on GitHub to learn more. @override Future\u003cvoid\u003e onLoad() async { await _loadAnimations().then((_) =\u003e {animation = _boxClosed}); position.add(Vector2( ((gridPosition.x * gridPixelDimensions.x) + gridPixelOffset.x), ((gridPosition.y * gridPixelDimensions.y) + gridPixelOffset.y))); priority = getLayeredGridValue(); } @override void update(double dt) async { super.update(dt); if (getLayeredGridValue() != priority) { priority = getLayeredGridValue(); } } Google Developer Program and BadgesBecause we wanted to keep the scope for the game small, and we wanted to be able to deploy it as a simple web page we wanted to avoid setting up a backend for the game. But we did want some way for developers to be rewarded for their progress, similar to achievement systems in popular gaming platforms. Instead of building a separate backend system for tracking player progress and achievements, we integrated with Google Developer Program by allowing players to click a link and collect a badge on their profile once they’d completed a level, providing a sense of accomplishment and recognition within the developer community. Project IDX: A Streamlined Development EnvironmentDuring the development of \"Purrfect Code,\" we leveraged Google’s Project IDX, an AI-assisted workspace for full-stack, multi platform app development in the cloud. Since we were already comfortable working in VS Code, Project IDX provided a familiar environment for coding, debugging, and testing our game and allowed us to get up and running quickly. With Flutter and Dart already set up and ready to go in the browser, we could dive straight into development without the hassle of local environment configuration. The intelligent code completion, real-time error checking, and integrated debugging tools offered by Project IDX helped us keep our productivity high. If you’re curious, Project IDX is a great way to quickly try out Purrfect Code and explore its code directly from your browser. Click this link to open the project directly in IDX and run the project yourself. Make sure to check the box that asks if this is a Flutter app.Firebase for Fast Secure HostingWe chose Firebase Hosting to ensure the secure and efficient global delivery of Purrfect Code. The platform's zero-configuration SSL guarantees content is served over HTTPS, enhancing security. Furthermore, its support for modern web frameworks and automated builds from our GitHub repository enabled rapid deployment of updates. The Firebase CLI, local emulation, and preview URLs streamlined our testing and collaboration processes. These features, coupled with the potential for future game evolutions leveraging the Gemini sample templates for AI integration, made Firebase Hosting the ideal choice for launching our game.Firebase Configuration With WASMPurrfect Code uses Web Assembly which requires some additional steps during deployment. In our firebase.json configuration we add a predeploy command that enables our web build to be built with WASM. The “--no-strip-wasm” argument prevents the code from running through one last minimization step which makes errors more difficult to read and debug. WASM also requires a cross-origin opener policy and a cross origin embedder policy for multi-threading and memory sharing. \"hosting\": { \"predeploy\": \"flutter build web --wasm\", \"public\": \"build/web\", \"ignore\": [ \"firebase.json\", \"**/.*\" ], \"headers\": [ { \"source\": \"**/*\", \"headers\": [ { \"key\": \"cross-origin-opener-policy\", \"value\": \"same-origin\" }, { \"key\": \"cross-origin-embedder-policy\", \"value\": \"require-corp\" } ] } ] } Learning and ResourcesThroughout the development of \"Purrfect Code,\" we relied on various resources and drew inspiration from existing projects, a body of work we hope that this project can add to. Here are some key learning resources and references we found valuable:Reference ProjectsWe used the Super Dash and I/O Flip games as references for best practices and implementation ideas. Both projects provided valuable insights into structuring a Flutter game, handling game states, and implementing game mechanics. Super Dash was directly relevant because it was simple and didn’t require backend services, like our game. I/O Flip was bigger and does support a backend, as well as generative AI features so may be of interest to devs building games that require those features. Both are valuable resources if you’re interested in making games in Flutter.ConclusionWe hope that \"Purrfect Code\" not only provides an enjoyable gaming experience but also serves as a learning resource for developers interested in game development with Flutter and Flame. The combination of Flutter, Flame and Chrome proved to be a great fit for our game/app hybrid, providing us with a solid foundation for UI development, graphics rendering, sound management, and more. We encourage you to explore the game's source code and experiment with extending it further. There are numerous possibilities for adding new features, levels, and gameplay mechanics. Jump into the codebase in Project IDX, check the box that asks if this is a Flutter app, and let your creativity run wild!",
  "image": "https://storage.googleapis.com/gweb-developer-goog-blog-assets/images/image2_R0cO2EO.2e16d0ba.fill-1200x600.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n    \n      \n    \n\n    \n\n    \n\n    \n\n    \n    \u003cdiv\u003e\n           \u003cdiv\u003e\n    \u003cp data-block-key=\"k83go\"\u003e\u0026#34;\u003ca href=\"https://goo.gle/purrfect-code-hub\"\u003ePurrfect Code\u003c/a\u003e\u0026#34; is a new box-pushing programming puzzle game, powered by Flutter, Dart, and the Flame game engine and designed to challenge developers to solve puzzles by writing code.\u003c/p\u003e\u003ch2 data-block-key=\"4pmbp\"\u003e\u003cb\u003e\u003cbr/\u003eGame Overview\u003c/b\u003e\u003c/h2\u003e\u003cp data-block-key=\"ch3h\"\u003eIn \u0026#34;Purrfect Code,\u0026#34; players are tasked with updating the programming of a janitor robot on Google\u0026#39;s new space station headquarters where a shipment of cats has mistakenly arrived. The goal of the game is to help the robot safely round up boxes containing the cats and push them onto teleporter plates so they can get home. Players write JavaScript to control the robots movements while trying to discover efficient solutions to navigate through grid-based puzzles.\u003c/p\u003e\u003cp data-block-key=\"bt816\"\u003eThe game is a fun way to explore coding, using your intelligence and creativity. Each level is focused on a programming concept and gently increases in complexity over the course of the five levels in the game.\u003c/p\u003e\u003cp data-block-key=\"1sq75\"\u003eThe game loop is as follows:\u003c/p\u003e\u003col\u003e\u003cli data-block-key=\"e9f28\"\u003ePlayers write JavaScript code to move the robot (up, down, left, or right)\u003c/li\u003e\u003c/ol\u003e\u003cp data-block-key=\"huc9\"\u003e2. They then run their code and watch as the robot attempts to solve the level\u003c/p\u003e\u003cp data-block-key=\"51qmn\"\u003e3. The level is completed when all boxes containing cats are pushed to the teleporter plates\u003c/p\u003e\u003cp data-block-key=\"dphrh\"\u003e4. Players are scored on the efficiency of their solutions including the number of spaces moved and the brevity of their code\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\n    \n        \u003cvideo autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" poster=\"https://storage.googleapis.com/gweb-developer-goog-blog-assets/original_videos/wagtailvideo-gizol0ut_thumb.jpg\"\u003e\n\u003csource src=\"https://storage.googleapis.com/gweb-developer-goog-blog-assets/original_videos/purrfect_code.mp4\" type=\"video/mp4\"/\u003e\n\u003cp\u003eSorry, your browser doesn\u0026#39;t support playback for this video\u003c/p\u003e\n\n\u003c/video\u003e\n    \n    \n\u003c/div\u003e  \u003cdiv\u003e\n    \u003ch2 data-block-key=\"k83go\"\u003e\u003cb\u003eBuilding the Game with Flutter, Dart, and Flame\u003c/b\u003e\u003c/h2\u003e\u003cp data-block-key=\"b0m5v\"\u003eWe chose to build \u0026#34;\u003ca href=\"https://goo.gle/purrfect-code-hub\"\u003ePurrfect Code\u003c/a\u003e\u0026#34; using Flutter and Dart, as they provide a powerful and flexible framework for creating multi-platform applications and games. Flutter\u0026#39;s widget system and reactive programming model allowed us to create a responsive user interface for a variety of screen sizes in the browser. Dart\u0026#39;s strongly-typed and object-oriented programming features made it easy to structure our code and keep our codebase clean. The Flame game engine, built on top of Flutter, offered a nice foundation of basic features needed for game development, allowing us to focus on our gameplay logic and the unique aspects of the game. Flutter and Flame were a clear choice for this project due to Purrfect Code’s nature as a unique game/app hybrid with both an IDE inspired UI \u003ci\u003eand\u003c/i\u003e a game view with animated sprites and sound.\u003c/p\u003e\u003ch3 data-block-key=\"36ihr\"\u003e\u003cbr/\u003e\u003cb\u003eChrome and JavaScript: Leveraging Built-in Browser Support\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"1ms1k\"\u003eOnce we settled on the programming concept for the game, we needed to choose what programming language players would use. We wanted something familiar and popular among devs. Initially we considered using Python as the in-game programming language. However after some consideration, we decided to go with JavaScript to leverage the built-in JavaScript support provided by Chrome. By utilizing JavaScript, we could tap into the browser\u0026#39;s native capabilities without the need to load an additional language interpreter. This decision not only simplified our development process, but also ensured a seamless experience for players, as the game could load quickly with minimal dependencies.\u003c/p\u003e\u003cp data-block-key=\"bce1m\"\u003eFlutter’s \u003ca href=\"https://medium.com/flutter/whats-new-in-flutter-3-22-fbde6c164fe3\"\u003e3.22 release at Google I/O\u003c/a\u003e this year introduced stable support for WebAssembly (WASM) which allowed us to optimize performance-critical parts of the game. By compiling certain game logic to WASM, we ensured that \u0026#34;Purrfect Code\u0026#34; runs efficiently in the browser, delivering a smooth and responsive gaming experience without compromising on performance.\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evar\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edir\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003emoveEast\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003emoveNorth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003emoveWest\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003emoveSouth\u003c/span\u003e\u003cspan\u003e];\u003c/span\u003e\n\u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e){\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003e5\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003cspan\u003ej\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003edir\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e]();\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e  \u003cdiv\u003e\n    \u003ch3 data-block-key=\"k83go\"\u003e\u003cb\u003eFlame Game Engine: Modular and Efficient Game Development\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"315nu\"\u003eTo bring \u0026#34;Purrfect Code\u0026#34; to life, we utilized the Flame Game Engine, an open source modular game engine built on Flutter that provides many of the commonly needed features for game development. Flame leverages the robust infrastructure of Flutter while simplifying the code required to build our project. It offers a simple yet effective game loop implementation and a wide range of essential functionalities, such as audio playback, sprite management, animation features, collision, and the Flame Component System (FCS). The engine\u0026#39;s component-based architecture, sprite rendering, and animation support enabled us to create visually appealing graphics, smooth animations, and interactive gameplay elements without having to reinvent the wheel. Leveraging Flame, made the development process more efficient with essential features ready at hand, allowing us to focus on creating an engaging gaming experience for our players.\u003c/p\u003e\u003ch3 data-block-key=\"aqgd7\"\u003e\u003cbr/\u003e\u003cb\u003eImplementing Game Features with Flame\u003c/b\u003e\u003c/h3\u003e\u003ch6 data-block-key=\"bs76o\"\u003eFlame offers a simple yet effective game loop implementation and a wide range of essential functionalities, such as audio playback, sprite management, animation features, collision, and the Flame Component System (FCS).\u003c/h6\u003e\u003cp data-block-key=\"9jjat\"\u003eFlame\u0026#39;s sprite rendering and animation system allowed us to bring the game\u0026#39;s characters and environments to life without having to write graphics code. We could create sprite sheets, define animation sequences, and smoothly animate the character\u0026#39;s movements and special effects. We used Flame’s priority system to write a visual sorting system for our “top down” game perspective. Our artist built levels with many overlapping features to enhance the feeling of depth with the sprites and give the game view a less “grid like” appearance. We needed to make sure that when the robot would move behind them that it would be occluded correctly. Flame’s priority system allowed us to assign priorities to different visual elements, ensuring that they were drawn in the correct order and overlapped properly. This system was flexible enough for us to include a shadow system where individual components could feature animated shadows that mirrored object actions and gave the art a feeling of depth that made scenes both more vibrant and easier to visually comprehend.\u003c/p\u003e\u003cp data-block-key=\"54llu\"\u003eThe BoxShadow class in our codebase is a good example of this and shows how we created dynamic and interactive shadows for the game\u0026#39;s moving box objects. By extending the SpriteAnimationComponent and implementing the GridElement and HasVisibility mixins, we were able to load sprite sheets for the box shadow and box teleport animations, define multiple animations for open, closed, idle and the teleporting states and integrate them into the grid-based layout. The onLoad method loads the animations and sets the initial position and priority of the component based on its grid position, while the update method ensures that the component\u0026#39;s priority updates dynamically if the box moves in front of or behind an occluding object. Using Flame’s priority and animation systems this way enabled us to create shadow effects which always help users visually understand virtual spaces and make them more believable and leads to a more integrated visual presentation.\u003c/p\u003e\u003cp data-block-key=\"b0er\"\u003e\u003ci\u003eExcerpt from box_shadow.dart,\u003c/i\u003e \u003ca href=\"https://github.com/devchallengedemo/purrfect_code/blob/main/lib/src/sokoban_view/components/box_shadow.dart\"\u003e\u003ci\u003eview the full class\u003c/i\u003e\u003c/a\u003e\u003ci\u003e on GitHub to learn more.\u003c/i\u003e\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e@override\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eFuture\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eonLoad\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eawait\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e_loadAnimations\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u0026gt;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e_boxClosed\u003c/span\u003e\u003cspan\u003e});\u003c/span\u003e\n\n\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eposition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eadd\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eVector2\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003egridPosition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egridPixelDimensions\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egridPixelOffset\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e((\u003c/span\u003e\u003cspan\u003egridPosition\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egridPixelDimensions\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egridPixelOffset\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)));\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egetLayeredGridValue\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e@override\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003evoid\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eupdate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edouble\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edt\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eupdate\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edt\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\n\n\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003egetLayeredGridValue\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e!=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003epriority\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003egetLayeredGridValue\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e  \u003cdiv\u003e\n    \u003ch3 data-block-key=\"k83go\"\u003e\u003cb\u003eGoogle Developer Program and Badges\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"5rbi4\"\u003eBecause we wanted to keep the scope for the game small, and we wanted to be able to deploy it as a simple web page we wanted to avoid setting up a backend for the game. But we did want some way for developers to be rewarded for their progress, similar to achievement systems in popular gaming platforms. Instead of building a separate backend system for tracking player progress and achievements, we integrated with Google Developer Program by allowing players to click a link and collect a badge on their profile once they’d completed a level, providing a sense of accomplishment and recognition within the developer community.\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\n    \u003cp\u003e\u003cimg src=\"https://storage.googleapis.com/gweb-developer-goog-blog-assets/images/image1_vQeaWU2.original.png\" alt=\"Purrfect Code Google Developer Program profile badges\"/\u003e\n        \n        \n    \u003c/p\u003e\n\u003c/div\u003e\n  \u003cdiv\u003e\n    \u003ch3 data-block-key=\"k83go\"\u003e\u003cb\u003eProject IDX: A Streamlined Development Environment\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"fehun\"\u003eDuring the development of \u0026#34;Purrfect Code,\u0026#34; we leveraged Google’s Project IDX, an AI-assisted workspace for full-stack, multi platform app development in the cloud. Since we were already comfortable working in VS Code, Project IDX provided a familiar environment for coding, debugging, and testing our game and allowed us to get up and running quickly. With Flutter and Dart already set up and ready to go in the browser, we could dive straight into development without the hassle of local environment configuration. The intelligent code completion, real-time error checking, and integrated debugging tools offered by Project IDX helped us keep our productivity high. If you’re curious, Project IDX is a great way to quickly try out Purrfect Code and explore its code directly from your browser. \u003ca href=\"https://goo.gle/purrfect-code-idx\"\u003eClick this link to open the project directly in IDX and run the project yourself\u003c/a\u003e. Make sure to check the box that asks if this is a Flutter app.\u003c/p\u003e\u003ch3 data-block-key=\"ebkeg\"\u003e\u003cbr/\u003e\u003cb\u003eFirebase for Fast Secure Hosting\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"8vv87\"\u003eWe chose Firebase Hosting to ensure the secure and efficient global delivery of Purrfect Code. The platform\u0026#39;s zero-configuration SSL guarantees content is served over HTTPS, enhancing security. Furthermore, its support for modern web frameworks and automated builds from our GitHub repository enabled rapid deployment of updates. The Firebase CLI, local emulation, and preview URLs streamlined our testing and collaboration processes. These features, coupled with the potential for future game evolutions leveraging the Gemini sample templates for AI integration, made Firebase Hosting the ideal choice for launching our game.\u003c/p\u003e\u003ch3 data-block-key=\"f6kv5\"\u003e\u003cbr/\u003e\u003cb\u003eFirebase Configuration With WASM\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"fd5ju\"\u003ePurrfect Code uses Web Assembly which requires some additional steps during deployment. In our firebase.json configuration we add a predeploy command that enables our web build to be built with WASM. The “--no-strip-wasm” argument prevents the code from running through one last minimization step which makes errors more difficult to read and debug. WASM also requires a cross-origin opener policy and a cross origin embedder policy for multi-threading and memory sharing.\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u0026#34;hosting\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#34;predeploy\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;flutter build web --wasm\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#34;public\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;build/web\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#34;ignore\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;firebase.json\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e\u0026#34;**/.*\u0026#34;\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e],\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e\u0026#34;headers\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003e\u0026#34;source\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;**/*\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003e\u0026#34;headers\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\n\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e              \u003c/span\u003e\u003cspan\u003e\u0026#34;key\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;cross-origin-opener-policy\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e              \u003c/span\u003e\u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;same-origin\u0026#34;\u003c/span\u003e\n\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003e},\u003c/span\u003e\n\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n\u003cspan\u003e              \u003c/span\u003e\u003cspan\u003e\u0026#34;key\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;cross-origin-embedder-policy\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e              \u003c/span\u003e\u003cspan\u003e\u0026#34;value\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#34;require-corp\u0026#34;\u003c/span\u003e\n\u003cspan\u003e            \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e          \u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e  \u003cdiv\u003e\n    \u003ch2 data-block-key=\"k83go\"\u003e\u003cb\u003eLearning and Resources\u003c/b\u003e\u003c/h2\u003e\u003cp data-block-key=\"62gpp\"\u003eThroughout the development of \u0026#34;Purrfect Code,\u0026#34; we relied on various resources and drew inspiration from existing projects, a body of work we hope that this project can add to. Here are some key learning resources and references we found valuable:\u003c/p\u003e\u003ch3 data-block-key=\"ccgda\"\u003e\u003cbr/\u003e\u003cb\u003eReference Projects\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"f5pio\"\u003eWe used the \u003ca href=\"https://medium.com/@vgv_team/how-we-built-the-new-super-dash-demo-in-flutter-and-flame-in-just-six-weeks-9c7aa2a5ad31\"\u003eSuper Dash\u003c/a\u003e and \u003ca href=\"https://developers.googleblog.com/en/how-its-made-io-flip-adds-a-twist-to-a-classic-card-game-with-generative-ai/\"\u003eI/O Flip\u003c/a\u003e games as references for best practices and implementation ideas. Both projects provided valuable insights into structuring a Flutter game, handling game states, and implementing game mechanics. Super Dash was directly relevant because it was simple and didn’t require backend services, like our game. I/O Flip was bigger and does support a backend, as well as generative AI features so may be of interest to devs building games that require those features. Both are valuable resources if you’re interested in making \u003ca href=\"https://flutter.dev/games\"\u003egames in Flutter\u003c/a\u003e.\u003c/p\u003e\u003ch2 data-block-key=\"66fvv\"\u003e\u003cb\u003e\u003cbr/\u003eConclusion\u003c/b\u003e\u003c/h2\u003e\u003cp data-block-key=\"694q4\"\u003eWe hope that \u0026#34;\u003ca href=\"https://goo.gle/purrfect-code-hub\"\u003ePurrfect Code\u003c/a\u003e\u0026#34; not only provides an enjoyable gaming experience but also serves as a learning resource for developers interested in game development with Flutter and Flame. The combination of \u003ca href=\"https://flutter.dev/\"\u003eFlutter\u003c/a\u003e, \u003ca href=\"https://flame-engine.org/\"\u003eFlame\u003c/a\u003e and \u003ca href=\"https://www.google.com/chrome/\"\u003eChrome\u003c/a\u003e proved to be a great fit for our game/app hybrid, providing us with a solid foundation for UI development, graphics rendering, sound management, and more. We encourage you to explore the game\u0026#39;s source code and experiment with extending it further. There are numerous possibilities for adding new features, levels, and gameplay mechanics. Jump into the codebase in \u003ca href=\"https://goo.gle/purrfect-code-idx\"\u003eProject IDX\u003c/a\u003e, check the box that asks if this is a Flutter app, and let your creativity run wild! \u003c/p\u003e\n\u003c/div\u003e \n      \u003c/div\u003e\n    \n\n    \n\n    \n    \n    \n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-08-08T00:00:00Z",
  "modifiedTime": null
}
