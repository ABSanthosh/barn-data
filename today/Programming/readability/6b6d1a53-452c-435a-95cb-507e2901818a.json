{
  "id": "6b6d1a53-452c-435a-95cb-507e2901818a",
  "title": "Bliki: Cycle Time",
  "link": "https://martinfowler.com/bliki/CycleTime.html",
  "description": "",
  "author": "",
  "published": "2024-09-04T00:00:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": [
    "bliki"
  ],
  "byline": "Martin Fowler",
  "length": 4702,
  "excerpt": "The time it takes for a feature to be developed",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "Cycle Time is a measure of how long it takes to get a new feature in a software system from idea to running in production. In Agile circles, we try to minimize cycle time. We do this by defining and implementing very small features and minimizing delays in the development process. Although the rough notion of cycle time, and the importance of reducing it, is common, there is a lot of variations on how cycle time is measured. A key characteristic of agile software development is a shift from a Waterfall Process, where work is decomposed based on activity (analysis, coding, testing) to an Iterative Process where work is based on a subset of functionality (simple pricing, bulk discount, valued-customer discount). Doing this generates a feedback loop where we can learn from putting small features in front of users. This learning allows us to improve our development process and allows us to better understand where the software product can provide value for our customers. 1 1: It also avoids work being stuck in late activities such as testing and integration, which were notoriously difficult to estimate. This feedback is a core benefit of an iterative approach, and like most such feedback loops, the quicker I get the feedback, the happier I am. Thus agile folks put a lot of emphasis on how fast we can get a feature through the entire workflow and into production. The phrase cycle time is a measure of that. But here we run into difficulties. When do we start and stop the clock on cycle time? The stopping time is the easiest, most glibly it's when the feature is put into production and helping its users. But there are circumstances where this can get muddy. If a team is using a Canary Release, should it be when used by the first cohort, or only when released to the full population? Do we count only when the app store has approved its release, thus adding an unpredictable delay that's mostly outside the control of the development team?. The start time has even more variations. A common marker is when a developer makes a first commit to that feature, but that ignores any time spent in preparatory analysis. Many people would go further back and say: “when the customer first has the idea for a feature”. This is all very well for a high priority feature, but how about something that isn't that urgent, and thus sits in a triage area for a few weeks before being ready to enter development. Do we start the clock when the team first places the feature on the card wall and we start to seriously work on it? I also run into the phase lead time, sometimes instead of “cycle time”, but often together - where people make a distinction between the two, often based on a different start time. However there isn't any consistency between how people distinguish between them. So in general, I treat “lead time” as a synonym to “cycle time”, and if someone is using both, I make sure I understand how that individual is making the distinction. The different bands of cycle time all have their advantages, and it's often handy to use different bands in the same situation, to highlight differences. In that situation, I'd use a distinguishing adjective (e.g. “first-commit cycle time” vs “idea cycle time”) to tell them apart. There's no generally accepted terms for such adjectives, but I think they are better than trying to create a distinction between “cycle time” and “lead time”. What these questions tell us is that cycle time, while a useful concept, is inherently slippery. We should be wary of comparing cycle times between teams, unless we can be confident we have consistent notions of their stop and start times. But despite this, thinking in terms of cycle time, and trying to minimize it, is a useful activity. It's usually worthwhile to build a value stream map that shows every step from idea to production, identifying the steps in the work flow, how much time is spent on them, and how much waiting between them. Understanding this flow of work allows us to find ways to reduce the cycle time. Two commonly effective interventions are to reduce the size of features and (counter-intuitively) increase Slack. Doing the work to understand flow to improve it is worthwhile because the faster we get ideas into production, the more rapidly we gain the benefits of the new features, and get the feedback to learn and improve our ways of working. Acknowledgements Andrew Harmel-Law, Chris Ford, James Lewis, José Pinar, Kief Morris, Manoj Kumar M, Matteo Vaccari, and Rafael Ferreira discussed this post on our internal mailing list",
  "image": "https://martinfowler.com/bliki/images/cycle-time/sketch.svg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eCycle Time is a measure of how long it takes to get a new feature in a\n  software system from idea to running in production. In Agile circles, we try\n  to minimize cycle time. We do this by defining and implementing very small\n  features and minimizing delays in the development process. Although the rough\n  notion of cycle time, and the importance of reducing it, is common, there is a\n  lot of variations on how cycle time is measured.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/bliki/images/cycle-time/sketch.svg\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\u003cp\u003eA key characteristic of agile software development is a shift from a\n  \u003ca href=\"https://martinfowler.com/bliki/WaterfallProcess.html\"\u003eWaterfall Process\u003c/a\u003e, where work is decomposed based on\n  activity (analysis, coding, testing) to an Iterative Process where work is\n  based on a subset of functionality (simple pricing, bulk discount,\n  valued-customer discount). Doing this generates a feedback loop where we can learn\n  from putting small features in front of users. This learning allows us to\n  improve our development process and allows us to better understand where the\n  software product can provide value for our customers. \u003cspan data-footnote=\"footnote-late-activities\"\u003e1\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cspan\u003e1: \u003c/span\u003eIt also avoids work being stuck in late\n    activities such as testing and integration, which were notoriously difficult\n    to estimate.\u003c/p\u003e\n\n\u003cp\u003eThis feedback is a core benefit of an iterative approach, and like most\n  such feedback loops, the quicker I get the feedback, the happier I am. Thus\n  agile folks put a lot of emphasis on how fast we can get a feature through the\n  entire workflow and into production. The phrase \u003ci\u003ecycle time\u003c/i\u003e is a measure of that.\u003c/p\u003e\n\n\u003cp\u003eBut here we run into difficulties. When do we start and stop the clock on\n  cycle time?\u003c/p\u003e\n\n\u003cp\u003eThe stopping time is the easiest, most glibly it\u0026#39;s when the feature is put\n  into production and helping its users. But there are circumstances where this\n  can get muddy. If a team is using a \u003ca href=\"https://martinfowler.com/bliki/CanaryRelease.html\"\u003eCanary Release\u003c/a\u003e, should it\n  be when used by the first cohort, or only when released to the full\n  population? Do we count only when the app store has approved its release, thus\n  adding an unpredictable delay that\u0026#39;s mostly outside the control of the\n  development team?.\u003c/p\u003e\n\n\u003cp\u003eThe start time has even more variations. A common marker is when a\n  developer makes a first commit to that feature, but that ignores any time\n  spent in preparatory analysis. Many people would go further back and say:\n  “when the customer first has the idea for a feature”. This is all very well\n  for a high priority feature, but how about something that isn\u0026#39;t that urgent,\n  and thus sits in a triage area for a few weeks before being ready to enter\n  development. Do we start the clock when the team first places the feature on\n  the card wall\n  and we start to seriously work on it?\u003c/p\u003e\n\n\u003cp\u003eI also run into the phase \u003cb\u003elead time\u003c/b\u003e, sometimes instead of\n  “cycle time”, but often together - where people make a distinction between the\n  two, often based on a different start time. However there isn\u0026#39;t any\n  consistency between how people distinguish between them. So in general, I\n  treat “lead time” as a synonym to “cycle time”, and if someone is using both,\n  I make sure I understand how that individual is making the distinction.\u003c/p\u003e\n\n\u003cp\u003eThe different bands of cycle time all have their advantages, and it\u0026#39;s often\n  handy to use different bands in the same situation, to highlight differences.\n  In that situation, I\u0026#39;d use a distinguishing adjective (e.g. “first-commit cycle\n  time” vs “idea cycle time”) to tell them apart. There\u0026#39;s no generally accepted\n  terms for such adjectives, but I think they are better than trying to\n  create a distinction between “cycle time” and “lead time”.\u003c/p\u003e\n\n\u003cp\u003eWhat these questions tell us is that cycle time, while a useful concept, is\n  inherently slippery. We should be wary of comparing cycle times between teams,\n  unless we can be confident we have consistent notions of their stop and start times.\u003c/p\u003e\n\n\u003cp\u003eBut despite this, thinking in terms of cycle time, and trying to minimize\n  it, is a useful activity. It\u0026#39;s usually worthwhile to build a value stream map\n  that shows every step from idea to production, identifying the steps in the\n  work flow, how much time is spent on them, and how much waiting between them.\n  Understanding this flow of work allows us to find ways to reduce the cycle\n  time. Two commonly effective interventions are to reduce the size of features\n  and (counter-intuitively) increase \u003ca href=\"https://martinfowler.com/bliki/Slack.html\"\u003eSlack\u003c/a\u003e. Doing the work to\n  understand flow to improve it is worthwhile because\n  the faster we get ideas into production, the more\n  rapidly we gain the benefits of the new features, and get the feedback to\n  learn and improve our ways of working.\u003c/p\u003e\n\n\n\n\n\n\u003cdiv\u003e\n\u003ch2\u003eAcknowledgements\u003c/h2\u003e\u003cp\u003e\nAndrew Harmel-Law, Chris Ford, James Lewis, José Pinar, Kief Morris, Manoj Kumar M, Matteo\n    Vaccari, and Rafael Ferreira discussed this post\n    on our internal mailing list\n  \u003c/p\u003e\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": "2024-09-04T00:00:00-04:00"
}
