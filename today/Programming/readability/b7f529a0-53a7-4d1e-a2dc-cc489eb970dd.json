{
  "id": "b7f529a0-53a7-4d1e-a2dc-cc489eb970dd",
  "title": "How to Turn a List of Flat Elements into a Hierarchy in Java, SQL, or jOOQ",
  "link": "https://blog.jooq.org/how-to-turn-a-list-of-flat-elements-into-a-hierarchy-in-java-sql-or-jooq/",
  "description": "Occasionally, you want to write a SQL query and fetch a hierarchy of data, whose flat representation may look like this: The result might be: |id |parent_id|label | |---|---------|-------------------| |1 | |C: | |2 |1 |eclipse | |3 |2 |configuration | |4 |2 |dropins | |5 |2 |features | |7 |2 |plugins | |8 |2 … Continue reading How to Turn a List of Flat Elements into a Hierarchy in Java, SQL, or jOOQ →",
  "author": "lukaseder",
  "published": "Fri, 24 Mar 2023 15:45:28 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "java",
    "jooq-development",
    "sql",
    "Collector",
    "Collectors",
    "Hierarchical SQL",
    "PostgreSQL",
    "Recursive SQL"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 11824,
  "excerpt": "This article illustrates various ways of turning a flat representation of hierarchical dataa into an object or JSON hierarchy, using SQL, jOOQ, or vanilla Java.",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "Occasionally, you want to write a SQL query and fetch a hierarchy of data, whose flat representation may look like this: SELECT id, parent_id, label FROM t_directory; The result might be: |id |parent_id|label | |---|---------|-------------------| |1 | |C: | |2 |1 |eclipse | |3 |2 |configuration | |4 |2 |dropins | |5 |2 |features | |7 |2 |plugins | |8 |2 |readme | |9 |8 |readme_eclipse.html| |10 |2 |src | |11 |2 |eclipse.exe | Get the hierarchy with SQL Now, you could run a recursive PostgreSQL query like the below monster to turn that into a JSON document: WITH RECURSIVE d1 (id, parent_id, name) as ( SELECT id, parent_id, label FROM t_directory ), d2 AS ( SELECT d1.*, 0 AS level FROM d1 WHERE parent_id IS NULL UNION ALL SELECT d1.*, d2.level + 1 FROM d1 JOIN d2 ON d2.id = d1.parent_id ), d3 AS ( SELECT d2.*, null::jsonb children FROM d2 WHERE level = (SELECT max(level) FROM d2) UNION ( SELECT (branch_parent).*, jsonb_strip_nulls( jsonb_agg(branch_child - 'parent_id' - 'level' ORDER BY branch_child-\u003e\u003e'name' ) FILTER ( WHERE branch_child-\u003e\u003e'parent_id' = (branch_parent).id::text ) ) FROM ( SELECT branch_parent, to_jsonb(branch_child) AS branch_child FROM d2 branch_parent JOIN d3 branch_child ON branch_child.level = branch_parent.level + 1 ) branch GROUP BY branch_parent ) ) SELECT jsonb_pretty(jsonb_agg(to_jsonb(d3) - 'parent_id' - 'level')) AS tree FROM d3 WHERE level = 0; I’ve given this query also as an answer to this Stack Overflow question. Some inspiration for the query in this blog post. And behold, we have a JSON tree: [ { \"id\": 1, \"name\": \"C:\", \"children\": [ { \"id\": 2, \"name\": \"eclipse\", \"children\": [ { \"id\": 3, \"name\": \"configuration\" }, { \"id\": 4, \"name\": \"dropins\" }, { \"id\": 11, \"name\": \"eclipse.exe\" }, { \"id\": 5, \"name\": \"features\" }, { \"id\": 7, \"name\": \"plugins\" }, { \"id\": 8, \"name\": \"readme\", \"children\": [ { \"id\": 9, \"name\": \"readme_eclipse.html\" } ] }, { \"id\": 10, \"name\": \"src\" } ] } ] } ] But that’s quite a beast of a SQL query, and perhaps, you don’t need to do this with SQL in the first place. Doing this with jOOQ 3.19 In fact, starting from jOOQ 3.19 and #12341, you can do this entirely with jOOQ, using a Collector. Assuming you have this client side representation for your data: record File(int id, String name, List\u003cFile\u003e children) {} Now, you can write: List\u003cFile\u003e result = ctx.select(T_DIRECTORY.ID, T_DIRECTORY.PARENT_ID, T_DIRECTORY.LABEL) .from(T_DIRECTORY) .orderBy(T_DIRECTORY.ID) .collect(Records.intoHierarchy( r -\u003e r.value1(), r -\u003e r.value2(), r -\u003e new File(r.value1(), r.value3(), new ArrayList\u003c\u003e()), (p, c) -\u003e p.children().add(c) )); That’s it! When you print the result, you’ll get: [ File[id=1, name=C:, children=[ File[id=2, name=eclipse, children=[ File[id=3, name=configuration, children=[]], File[id=4, name=dropins, children=[]], File[id=5, name=features, children=[]], File[id=7, name=plugins, children=[]], File[id=8, name=readme, children=[ File[id=9, name=readme_eclipse.html, children=[]] ]], File[id=10, name=src, children=[]], File[id=11, name=eclipse.exe, children=[]] ]] ]] ] Or, if you prefer JSON output, just use Jackson, or whatever, to serialise your data as follows: new ObjectMapper() .writerWithDefaultPrettyPrinter() .writeValue(System.out, result); And now, you’re getting: [ { \"id\" : 1, \"name\" : \"C:\", \"children\" : [ { \"id\" : 2, \"name\" : \"eclipse\", \"children\" : [ { \"id\" : 3, \"name\" : \"configuration\" }, { \"id\" : 4, \"name\" : \"dropins\" }, { \"id\" : 5, \"name\" : \"features\" }, { \"id\" : 7, \"name\" : \"plugins\" }, { \"id\" : 8, \"name\" : \"readme\", \"children\" : [ { \"id\" : 9, \"name\" : \"readme_eclipse.html\" } ] }, { \"id\" : 10, \"name\" : \"src\" }, { \"id\" : 11, \"name\" : \"eclipse.exe\" } ] } ] } ] Very cool, huh? Don’t use jOOQ? No problem, just copy this Collector: The above isn’t really jOOQ specific magic. You can just copy the following Collector from jOOQ to achieve the same thing with your pure Java code: public static final \u003cK, E, R extends Record\u003e Collector\u003cR, ?, List\u003cE\u003e\u003e intoHierarchy( Function\u003c? super R, ? extends K\u003e keyMapper, Function\u003c? super R, ? extends K\u003e parentKeyMapper, Function\u003c? super R, ? extends E\u003e nodeMapper, BiConsumer\u003c? super E, ? super E\u003e parentChildAppender ) { return Collectors.collectingAndThen( Collectors.toMap(keyMapper, r -\u003e new SimpleImmutableEntry\u003cR, E\u003e( r, nodeMapper.apply(r) )), m -\u003e { List\u003cE\u003e r = new ArrayList\u003c\u003e(); m.forEach((k, v) -\u003e { Entry\u003cR, E\u003e parent = m.get( parentKeyMapper.apply(v.getKey()) ); if (parent != null) parentChildAppender.accept( parent.getValue(), v.getValue() ); else r.add(v.getValue()); }); return r; } ); } With this collector, and the following types / data: record Flat(int id, int parentId, String name) {} record Hierarchical(int id, String name, List\u003cHierarchical\u003e children) {} List\u003cFlat\u003e data = List.of( new Flat(1, 0, \"C:\"), new Flat(2, 1, \"eclipse\"), new Flat(3, 2, \"configuration\"), new Flat(4, 2, \"dropins\"), new Flat(5, 2, \"features\"), new Flat(7, 2, \"plugins\"), new Flat(8, 2, \"readme\"), new Flat(9, 8, \"readme_eclipse.html\"), new Flat(10, 2, \"src\"), new Flat(11, 2, \"eclipse.exe\") ); You can now create the same hierarchy again, using the Collector directly on the list: List\u003cHierarchical\u003e result = data.stream().collect(intoHierarchy( e -\u003e e.id(), e -\u003e e.parentId(), e -\u003e new Hierarchical(e.id(), e.name(), new ArrayList\u003c\u003e()), (p, c) -\u003e p.children().add(c) )); An alternative API A previous version of this blog post used an alternative API design for the Collector: public static final \u003cK, E, R\u003e Collector\u003cR, ?, List\u003cE\u003e\u003e intoHierarchy( Function\u003c? super R, ? extends K\u003e keyMapper, Function\u003c? super R, ? extends K\u003e parentKeyMapper, BiFunction\u003c? super R, ? super List\u003cE\u003e, ? extends E\u003e recordMapper ) { record Tuple3\u003cT1, T2, T3\u003e(T1 t1, T2 t2, T3 t3) {} return Collectors.collectingAndThen( Collectors.toMap(keyMapper, r -\u003e { List\u003cE\u003e e = new ArrayList\u003c\u003e(); return new Tuple3\u003cR, C, E\u003e(r, e, recordMapper.apply(r, e)); }), m -\u003e { List\u003cE\u003e r = new ArrayList\u003c\u003e(); m.forEach((k, v) -\u003e { K parent = parentKeyMapper.apply(v.t1()); E child = v.t3(); if (m.containsKey(parent)) m.get(parent).t2().add(child); else r.add(child); }); return r; } ); } This can lead to more compact usages in client code: List\u003cHierarchical\u003e result = data.stream().collect(intoHierarchy( e -\u003e e.id(), e -\u003e e.parentId(), (e, l) -\u003e new Hierarchical(e.id(), e.name(), l) )); However, it relies on type inference of the target type (see JEP 101). As soon as you don’t hint the target type anymore, inference falls appart, so this won’t compile: List\u003c?\u003e result = data.stream().collect(intoHierarchy( e -\u003e e.id(), e -\u003e e.parentId(), (e, l) -\u003e new Hierarchical(e.id(), e.name(), l) )); This design would be quite impractical for users, especially when writing complex jOOQ queries, so it was rejected. A more complex jOOQ example In jOOQ, all results, including nested collections (e.g. those produced by MULTISET) can be collected, so if you have a nested hierarchy, such as comments on a blog post, just collect them with jOOQ. Assuming this schema: CREATE TABLE post ( id INT PRIMARY KEY, title TEXT ); CREATE TABLE comment ( id INT PRIMARY KEY, parent_id INT REFERENCES comment, post_id INT REFERENCES post, text TEXT ); INSERT INTO post VALUES (1, 'Helo'), (2, 'World'); INSERT INTO comment VALUES (1, NULL, 1, 'You misspelled \"Hello\"'), (2, 1, 1, 'Thanks, will fix soon'), (3, 2, 1, 'Still not fixed'), (4, NULL, 2, 'Impeccable blog post, thanks'); You could write a query like this: record Post(int id, String title, List\u003cComment\u003e comments) {} record Comment(int id, String text, List\u003cComment\u003e replies) {} List\u003cPost\u003e result = ctx.select( POST.ID, POST.TITLE, multiset( select(COMMENT.ID, COMMENT.PARENT_ID, COMMENT.TEXT) .from(COMMENT) .where(COMMENT.POST_ID.eq(POST.ID)) ).convertFrom(r -\u003e r.collect(intoHierarchy( r -\u003e r.value1(), r -\u003e r.value2(), r -\u003e new Comment(r.value1(), r.value3(), new ArrayList\u003c\u003e()), (p, c) -\u003e p.replies().add(c) ))) ) .from(POST) .orderBy(POST.ID) .fetch(mapping(Post::new)); All of this is type-safe, as always with jOOQ! Now, check out what this prints, when serialised with Jackson: [ { \"id\" : 1, \"title\" : \"Helo\", \"comments\" : [ { \"id\" : 1, \"text\" : \"You misspelled \\\"Hello\\\"\", \"replies\" : [ { \"id\" : 2, \"text\" : \"Thanks, will fix soon\", \"replies\" : [ { \"id\" : 3, \"text\" : \"Still not fixed\" } ] } ] } ] }, { \"id\" : 2, \"title\" : \"World\", \"comments\" : [ { \"id\" : 4, \"text\" : \"Impeccable blog post, thanks\" } ] } ] Note, if you only want to show a subtree, or a tree up until a certain depth, you can still run a hierarchical query in your MULTISET subquery using WITH RECURSIVE or CONNECT BY. Conclusion Collector is a much underrated API in the JDK. Any JDK Collection can be turned into a Stream and its elements can be collected. In jOOQ, a ResultQuery is an Iterable, which also offers a convenient collect() method (it just executes the query, streams results, and collects records into your Collector). Our functional library jOOλ has many additional collectors in its Agg class, e.g. for: Bitwise aggregation Statistical aggregation, like standard deviation, correlation, percentiles, etc. Collecting things into a hierarchy isn’t really that special. It’s just another collector, which I’m sure, you’ll be using much more frequently from now on!",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12025\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eOccasionally, you want to write a SQL query and fetch a hierarchy of data, whose flat representation may look like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT id, parent_id, label\nFROM t_directory;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe result might be:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|id |parent_id|label              |\n|---|---------|-------------------|\n|1  |         |C:                 |\n|2  |1        |eclipse            |\n|3  |2        |configuration      |\n|4  |2        |dropins            |\n|5  |2        |features           |\n|7  |2        |plugins            |\n|8  |2        |readme             |\n|9  |8        |readme_eclipse.html|\n|10 |2        |src                |\n|11 |2        |eclipse.exe        |\n\u003c/pre\u003e\n\n\n\n\u003ch2\u003eGet the hierarchy with SQL\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow, you could run a recursive PostgreSQL query like the below monster to turn that into a JSON document:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eWITH RECURSIVE\n  d1 (id, parent_id, name) as (\n    SELECT id, parent_id, label\n    FROM t_directory\n  ),\n  d2 AS (\n    SELECT d1.*, 0 AS level\n    FROM d1\n    WHERE parent_id IS NULL\n    UNION ALL\n    SELECT d1.*, d2.level + 1\n    FROM d1\n    JOIN d2 ON d2.id = d1.parent_id\n  ),\n  d3 AS (\n    SELECT d2.*, null::jsonb children\n    FROM d2\n    WHERE level = (SELECT max(level) FROM d2)\n    UNION (\n      SELECT \n        (branch_parent).*, \n        jsonb_strip_nulls(\n          jsonb_agg(branch_child - \u0026#39;parent_id\u0026#39; - \u0026#39;level\u0026#39; \n            ORDER BY branch_child-\u0026gt;\u0026gt;\u0026#39;name\u0026#39;\n          ) FILTER (\n            WHERE branch_child-\u0026gt;\u0026gt;\u0026#39;parent_id\u0026#39; = (branch_parent).id::text\n          )\n        )\n      FROM (\n        SELECT\n          branch_parent,\n          to_jsonb(branch_child) AS branch_child\n        FROM d2 branch_parent\n        JOIN d3 branch_child \n          ON branch_child.level = branch_parent.level + 1\n      ) branch\n      GROUP BY branch_parent\n    )\n  )\nSELECT \n  jsonb_pretty(jsonb_agg(to_jsonb(d3) - \u0026#39;parent_id\u0026#39; - \u0026#39;level\u0026#39;)) AS tree\nFROM d3\nWHERE level = 0;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eI’ve given this query also as \u003ca href=\"https://stackoverflow.com/a/68861529/521799\" data-type=\"URL\" data-id=\"https://stackoverflow.com/a/68861529/521799\"\u003ean answer to this Stack Overflow question\u003c/a\u003e. Some inspiration for the query \u003ca href=\"https://schinckel.net/2017/07/01/tree-data-as-a-nested-list-redux/\"\u003ein this blog post\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAnd behold, we have a JSON tree:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e[\n    {\n        \u0026#34;id\u0026#34;: 1,\n        \u0026#34;name\u0026#34;: \u0026#34;C:\u0026#34;,\n        \u0026#34;children\u0026#34;: [\n            {\n                \u0026#34;id\u0026#34;: 2,\n                \u0026#34;name\u0026#34;: \u0026#34;eclipse\u0026#34;,\n                \u0026#34;children\u0026#34;: [\n                    {\n                        \u0026#34;id\u0026#34;: 3,\n                        \u0026#34;name\u0026#34;: \u0026#34;configuration\u0026#34;\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 4,\n                        \u0026#34;name\u0026#34;: \u0026#34;dropins\u0026#34;\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 11,\n                        \u0026#34;name\u0026#34;: \u0026#34;eclipse.exe\u0026#34;\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 5,\n                        \u0026#34;name\u0026#34;: \u0026#34;features\u0026#34;\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 7,\n                        \u0026#34;name\u0026#34;: \u0026#34;plugins\u0026#34;\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 8,\n                        \u0026#34;name\u0026#34;: \u0026#34;readme\u0026#34;,\n                        \u0026#34;children\u0026#34;: [\n                            {\n                                \u0026#34;id\u0026#34;: 9,\n                                \u0026#34;name\u0026#34;: \u0026#34;readme_eclipse.html\u0026#34;\n                            }\n                        ]\n                    },\n                    {\n                        \u0026#34;id\u0026#34;: 10,\n                        \u0026#34;name\u0026#34;: \u0026#34;src\u0026#34;\n                    }\n                ]\n            }\n        ]\n    }\n]\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eBut that’s quite a beast of a SQL query, and perhaps, you don’t need to do this with SQL in the first place.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDoing this with jOOQ 3.19\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn fact, starting from jOOQ 3.19 and \u003ca href=\"https://github.com/jOOQ/jOOQ/issues/12341\"\u003e#12341\u003c/a\u003e, you can do this entirely with jOOQ, using a \u003ccode\u003eCollector\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eAssuming you have this client side representation for your data:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003erecord File(int id, String name, List\u0026lt;File\u0026gt; children) {}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNow, you can write:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eList\u0026lt;File\u0026gt; result =\nctx.select(T_DIRECTORY.ID, T_DIRECTORY.PARENT_ID, T_DIRECTORY.LABEL)\n   .from(T_DIRECTORY)\n   .orderBy(T_DIRECTORY.ID)\n   .collect(Records.intoHierarchy(\n       r -\u0026gt; r.value1(),\n       r -\u0026gt; r.value2(),\n       r -\u0026gt; new File(r.value1(), r.value3(), new ArrayList\u0026lt;\u0026gt;()),\n       (p, c) -\u0026gt; p.children().add(c)\n   ));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThat’s it! When you print the result, you’ll get:\u003c/p\u003e\n\n\n\n\u003cpre\u003e[\n  File[id=1, name=C:, children=[\n    File[id=2, name=eclipse, children=[\n      File[id=3, name=configuration, children=[]], \n      File[id=4, name=dropins, children=[]], \n      File[id=5, name=features, children=[]], \n      File[id=7, name=plugins, children=[]], \n      File[id=8, name=readme, children=[\n        File[id=9, name=readme_eclipse.html, children=[]]\n      ]], \n      File[id=10, name=src, children=[]], \n      File[id=11, name=eclipse.exe, children=[]]\n    ]]\n  ]]\n]\u003c/pre\u003e\n\n\n\n\u003cp\u003eOr, if you prefer JSON output, just use Jackson, or whatever, to serialise your data as follows:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003enew ObjectMapper()\n    .writerWithDefaultPrettyPrinter()\n    .writeValue(System.out, result);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd now, you’re getting:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e[ {\n  \u0026#34;id\u0026#34; : 1,\n  \u0026#34;name\u0026#34; : \u0026#34;C:\u0026#34;,\n  \u0026#34;children\u0026#34; : [ {\n    \u0026#34;id\u0026#34; : 2,\n    \u0026#34;name\u0026#34; : \u0026#34;eclipse\u0026#34;,\n    \u0026#34;children\u0026#34; : [ {\n      \u0026#34;id\u0026#34; : 3,\n      \u0026#34;name\u0026#34; : \u0026#34;configuration\u0026#34;\n    }, {\n      \u0026#34;id\u0026#34; : 4,\n      \u0026#34;name\u0026#34; : \u0026#34;dropins\u0026#34;\n    }, {\n      \u0026#34;id\u0026#34; : 5,\n      \u0026#34;name\u0026#34; : \u0026#34;features\u0026#34;\n    }, {\n      \u0026#34;id\u0026#34; : 7,\n      \u0026#34;name\u0026#34; : \u0026#34;plugins\u0026#34;\n    }, {\n      \u0026#34;id\u0026#34; : 8,\n      \u0026#34;name\u0026#34; : \u0026#34;readme\u0026#34;,\n      \u0026#34;children\u0026#34; : [ {\n        \u0026#34;id\u0026#34; : 9,\n        \u0026#34;name\u0026#34; : \u0026#34;readme_eclipse.html\u0026#34;\n      } ]\n    }, {\n      \u0026#34;id\u0026#34; : 10,\n      \u0026#34;name\u0026#34; : \u0026#34;src\u0026#34;\n    }, {\n      \u0026#34;id\u0026#34; : 11,\n      \u0026#34;name\u0026#34; : \u0026#34;eclipse.exe\u0026#34;\n    } ]\n  } ]\n} ]\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eVery cool, huh?\u003c/p\u003e\n\n\n\n\u003ch2\u003eDon’t use jOOQ? No problem, just copy this Collector:\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe above isn’t really jOOQ specific magic. You can just copy the following \u003ccode\u003eCollector\u003c/code\u003e from jOOQ to achieve the same thing with your pure Java code:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003epublic static final \u0026lt;K, E, R extends Record\u0026gt;\nCollector\u0026lt;R, ?, List\u0026lt;E\u0026gt;\u0026gt; intoHierarchy(\n    Function\u0026lt;? super R, ? extends K\u0026gt; keyMapper,\n    Function\u0026lt;? super R, ? extends K\u0026gt; parentKeyMapper,\n    Function\u0026lt;? super R, ? extends E\u0026gt; nodeMapper,\n    BiConsumer\u0026lt;? super E, ? super E\u0026gt; parentChildAppender\n) {\n    return Collectors.collectingAndThen(\n        Collectors.toMap(keyMapper, r -\u0026gt; new SimpleImmutableEntry\u0026lt;R, E\u0026gt;(\n            r, nodeMapper.apply(r)\n        )),\n        m -\u0026gt; {\n            List\u0026lt;E\u0026gt; r = new ArrayList\u0026lt;\u0026gt;();\n\n            m.forEach((k, v) -\u0026gt; {\n                Entry\u0026lt;R, E\u0026gt; parent = m.get(\n                    parentKeyMapper.apply(v.getKey())\n                );\n\n                if (parent != null)\n                    parentChildAppender.accept(\n                        parent.getValue(), v.getValue()\n                    );\n                else\n                    r.add(v.getValue());\n            });\n\n            return r;\n        }\n    );\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eWith this collector, and the following types / data:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003erecord Flat(int id, int parentId, String name) {}\nrecord Hierarchical(int id, String name, List\u0026lt;Hierarchical\u0026gt; children) {}\n\nList\u0026lt;Flat\u0026gt; data = List.of(\n    new Flat(1, 0, \u0026#34;C:\u0026#34;),\n    new Flat(2, 1, \u0026#34;eclipse\u0026#34;),\n    new Flat(3, 2, \u0026#34;configuration\u0026#34;),\n    new Flat(4, 2, \u0026#34;dropins\u0026#34;),\n    new Flat(5, 2, \u0026#34;features\u0026#34;),\n    new Flat(7, 2, \u0026#34;plugins\u0026#34;),\n    new Flat(8, 2, \u0026#34;readme\u0026#34;),\n    new Flat(9, 8, \u0026#34;readme_eclipse.html\u0026#34;),\n    new Flat(10, 2, \u0026#34;src\u0026#34;),\n    new Flat(11, 2, \u0026#34;eclipse.exe\u0026#34;)\n);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eYou can now create the same hierarchy again, using the \u003ccode\u003eCollector\u003c/code\u003e directly on the list:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eList\u0026lt;Hierarchical\u0026gt; result =\ndata.stream().collect(intoHierarchy(\n    e -\u0026gt; e.id(),\n    e -\u0026gt; e.parentId(),\n    e -\u0026gt; new Hierarchical(e.id(), e.name(), new ArrayList\u0026lt;\u0026gt;()),\n    (p, c) -\u0026gt; p.children().add(c)\n));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eAn alternative API\u003c/h2\u003e\n\n\n\n\u003cp\u003eA previous version of this blog post used an alternative API design for the \u003ccode\u003eCollector\u003c/code\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003epublic static final \u0026lt;K, E, R\u0026gt; Collector\u0026lt;R, ?, List\u0026lt;E\u0026gt;\u0026gt; intoHierarchy(\n    Function\u0026lt;? super R, ? extends K\u0026gt; keyMapper,\n    Function\u0026lt;? super R, ? extends K\u0026gt; parentKeyMapper,\n    BiFunction\u0026lt;? super R, ? super List\u0026lt;E\u0026gt;, ? extends E\u0026gt; recordMapper\n) {\n    record Tuple3\u0026lt;T1, T2, T3\u0026gt;(T1 t1, T2 t2, T3 t3) {}\n    return Collectors.collectingAndThen(\n        Collectors.toMap(keyMapper, r -\u0026gt; {\n            List\u0026lt;E\u0026gt; e = new ArrayList\u0026lt;\u0026gt;();\n            return new Tuple3\u0026lt;R, C, E\u0026gt;(r, e, recordMapper.apply(r, e));\n        }),\n        m -\u0026gt; {\n            List\u0026lt;E\u0026gt; r = new ArrayList\u0026lt;\u0026gt;();\n\n            m.forEach((k, v) -\u0026gt; {\n                K parent = parentKeyMapper.apply(v.t1());\n                E child = v.t3();\n\n                if (m.containsKey(parent))\n                    m.get(parent).t2().add(child);\n                else\n                    r.add(child);\n            });\n\n            return r;\n        }\n    );\n}\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis can lead to more compact usages in client code:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eList\u0026lt;Hierarchical\u0026gt; result =\ndata.stream().collect(intoHierarchy(\n    e -\u0026gt; e.id(),\n    e -\u0026gt; e.parentId(),\n    (e, l) -\u0026gt; new Hierarchical(e.id(), e.name(), l)\n));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eHowever, it relies on type inference of the target type (see \u003ca href=\"https://openjdk.org/jeps/101\" data-type=\"URL\" data-id=\"https://openjdk.org/jeps/101\"\u003eJEP 101\u003c/a\u003e). As soon as you don’t hint the target type anymore, inference falls appart, so this won’t compile:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eList\u0026lt;?\u0026gt; result =\ndata.stream().collect(intoHierarchy(\n    e -\u0026gt; e.id(),\n    e -\u0026gt; e.parentId(),\n    (e, l) -\u0026gt; new Hierarchical(e.id(), e.name(), l)\n));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis design would be quite impractical for users, especially when writing complex jOOQ queries, so it was rejected.\u003c/p\u003e\n\n\n\n\u003ch2\u003eA more complex jOOQ example\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn jOOQ, all results, including nested collections (\u003ca href=\"https://blog.jooq.org/jooq-3-15s-new-multiset-operator-will-change-how-you-think-about-sql/\" data-type=\"post\" data-id=\"9172\"\u003ee.g. those produced by \u003ccode\u003eMULTISET\u003c/code\u003e\u003c/a\u003e) can be collected, so if you have a nested hierarchy, such as comments on a blog post, just collect them with jOOQ.\u003c/p\u003e\n\n\n\n\u003cp\u003eAssuming this schema:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE TABLE post (\n  id INT PRIMARY KEY,\n  title TEXT\n);\n\nCREATE TABLE comment (\n  id INT PRIMARY KEY,\n  parent_id INT REFERENCES comment,\n  post_id INT REFERENCES post,\n  text TEXT\n);\n\nINSERT INTO post \nVALUES\n  (1, \u0026#39;Helo\u0026#39;),\n  (2, \u0026#39;World\u0026#39;);\n  \nINSERT INTO comment\nVALUES \n  (1, NULL, 1, \u0026#39;You misspelled \u0026#34;Hello\u0026#34;\u0026#39;),\n  (2, 1, 1, \u0026#39;Thanks, will fix soon\u0026#39;),\n  (3, 2, 1, \u0026#39;Still not fixed\u0026#39;),\n  (4, NULL, 2, \u0026#39;Impeccable blog post, thanks\u0026#39;);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eYou could write a query like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003erecord Post(int id, String title, List\u0026lt;Comment\u0026gt; comments) {}\nrecord Comment(int id, String text, List\u0026lt;Comment\u0026gt; replies) {}\n\nList\u0026lt;Post\u0026gt; result =\nctx.select(\n       POST.ID, \n       POST.TITLE,\n       multiset(\n           select(COMMENT.ID, COMMENT.PARENT_ID, COMMENT.TEXT)\n           .from(COMMENT)\n           .where(COMMENT.POST_ID.eq(POST.ID))\n       ).convertFrom(r -\u0026gt; r.collect(intoHierarchy(\n           r -\u0026gt; r.value1(),\n           r -\u0026gt; r.value2(),\n           r -\u0026gt; new Comment(r.value1(), r.value3(), new ArrayList\u0026lt;\u0026gt;()),\n           (p, c) -\u0026gt; p.replies().add(c)\n       )))\n   )\n   .from(POST)\n   .orderBy(POST.ID)\n   .fetch(mapping(Post::new));\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAll of this is type-safe, as always with jOOQ!\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, check out what this prints, when serialised with Jackson:\u003c/p\u003e\n\n\n\n\u003cpre\u003e[ {\n  \u0026#34;id\u0026#34; : 1,\n  \u0026#34;title\u0026#34; : \u0026#34;Helo\u0026#34;,\n  \u0026#34;comments\u0026#34; : [ {\n    \u0026#34;id\u0026#34; : 1,\n    \u0026#34;text\u0026#34; : \u0026#34;You misspelled \\\u0026#34;Hello\\\u0026#34;\u0026#34;,\n    \u0026#34;replies\u0026#34; : [ {\n      \u0026#34;id\u0026#34; : 2,\n      \u0026#34;text\u0026#34; : \u0026#34;Thanks, will fix soon\u0026#34;,\n      \u0026#34;replies\u0026#34; : [ {\n        \u0026#34;id\u0026#34; : 3,\n        \u0026#34;text\u0026#34; : \u0026#34;Still not fixed\u0026#34;\n      } ]\n    } ]\n  } ]\n}, {\n  \u0026#34;id\u0026#34; : 2,\n  \u0026#34;title\u0026#34; : \u0026#34;World\u0026#34;,\n  \u0026#34;comments\u0026#34; : [ {\n    \u0026#34;id\u0026#34; : 4,\n    \u0026#34;text\u0026#34; : \u0026#34;Impeccable blog post, thanks\u0026#34;\n  } ]\n} ]\u003c/pre\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eNote, if you only want to show a subtree, or a tree up until a certain depth, you can still run a hierarchical query in your \u003ccode\u003eMULTISET\u003c/code\u003e subquery using \u003ccode\u003eWITH RECURSIVE\u003c/code\u003e or \u003ccode\u003eCONNECT BY\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eCollector\u003c/code\u003e is a much underrated API in the JDK. Any JDK \u003ccode\u003eCollection\u003c/code\u003e can be turned into a \u003ccode\u003eStream\u003c/code\u003e and its elements can be collected. In jOOQ, a \u003ca href=\"https://blog.jooq.org/a-hidden-jooq-gem-foreach-loop-over-resultquery/\" data-type=\"post\" data-id=\"6494\"\u003e\u003ccode\u003eResultQuery\u003c/code\u003e is an \u003ccode\u003eIterable\u003c/code\u003e\u003c/a\u003e, which also offers a convenient \u003ccode\u003e\u003ca href=\"https://blog.jooq.org/use-resultquery-collect-to-implement-powerful-mappings/\" data-type=\"post\" data-id=\"9117\"\u003ecollect()\u003c/a\u003e\u003c/code\u003e method (it just executes the query, streams results, and collects records into your \u003ccode\u003eCollector\u003c/code\u003e).\u003c/p\u003e\n\n\n\n\u003cp\u003eOur functional library \u003ca href=\"https://github.com/jOOQ/jOOL\"\u003ejOOλ\u003c/a\u003e has many additional collectors in its \u003ccode\u003e\u003ca href=\"https://www.jooq.org/products/jOO%ce%bb/javadoc/latest/org.jooq.jool/org/jooq/lambda/Agg.html\"\u003eAgg\u003c/a\u003e\u003c/code\u003e class, e.g. for:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBitwise aggregation\u003c/li\u003e\n\n\n\n\u003cli\u003eStatistical aggregation, like standard deviation, correlation, percentiles, etc.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCollecting things into a hierarchy isn’t really that special. It’s just another collector, which I’m sure, you’ll be using much more frequently from now on!\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2023-03-24T15:45:28Z",
  "modifiedTime": "2023-05-23T07:01:34Z"
}
