{
  "id": "5129b570-16fb-4644-8ddd-512fda6cca87",
  "title": "Guide to Hash Tables in Python",
  "link": "https://stackabuse.com/hash-tables-in-python/",
  "description": "While Python doesn't have a built-in data structure explicitly called a \"hash table\", it provides the dictionary, which is a form of a hash table. Python dictionaries are unordered collections of key-value pairs, where the key is unique and holds a corresponding value. Thanks to a process known as \"hashing\"",
  "author": "Dimitrije Stamenic",
  "published": "Thu, 09 Nov 2023 20:19:44 GMT",
  "source": "https://stackabuse.com/rss/",
  "categories": [
    "python",
    "data structures"
  ],
  "byline": "Dimitrije Stamenic",
  "length": 24291,
  "excerpt": "While Python doesn't have a built-in data structure explicitly called a \"hash table\", it provides the dictionary, which is a form of a hash table. Py...",
  "siteName": "Stack Abuse",
  "favicon": "",
  "text": "While Python doesn't have a built-in data structure explicitly called a \"hash table\", it provides the dictionary, which is a form of a hash table. Python dictionaries are unordered collections of key-value pairs, where the key is unique and holds a corresponding value. Thanks to a process known as \"hashing\", dictionaries enable efficient retrieval, addition, and removal of entries. Note: If you're a Python programmer and have ever used a dictionary to store data as key-value pairs, you've already benefited from hash table technology without necessarily knowing it! Python dictionaries are implemented using hash tables! In this guide, we'll delve into the world of hash tables. We'll start with the basics, explaining what hash tables are and how they work. We'll also explore Python's implementation of hash tables via dictionaries, provide a step-by-step guide to creating a hash table in Python, and even touch on how to handle hash collisions. Along the way, we'll demonstrate the utility and efficiency of hash tables with real-world examples and handy Python snippets. Defining Hash Tables: Key-Value Pair Data Structure Since dictionaries in Python are essentially an implementation of hash tables, let's first focus on what hash tables actually are, and dive into Python implementation afterward. Hash tables are a type of data structure that provides a mechanism to store data in an associative manner. In a hash table, data is stored in an array format, but each data value has its own unique key, which is used to identify the data. This mechanism is based on key-value pairs, making the retrieval of data a swift process. The analogy often used to explain this concept is a real-world dictionary. In a dictionary, you use a known word (the \"key\") to find its meaning (the \"value\"). If you know the word, you can quickly find its definition. Similarly, in a hash table, if you know the key, you can quickly retrieve its value. Essentially, we are trying to store key-value pairs in the most efficient way possible. For example, say we want to create a hash table that stores the birth month of various people. The people's names are our keys and their birth months are the values: +-----------------------+ | Key | Value | +-----------------------+ | Alice | January | | Bob | May | | Charlie | January | | David | August | | Eve | December | | Brian | May | +-----------------------+ To store these key-value pairs in a hash table, we'll first need a way to convert the value of keys to the appropriate indexes of the array that represents a hash table. That's where a hash function comes into play! Being the backbone of a hash table implementation, this function processes the key and returns the corresponding index in the data storage array - just as we need. The goal of a good hash function is to distribute the keys evenly across the array, minimizing the chance of collisions (where two keys produce the same index). In reality, hash functions are much more complex, but for simplicity, let's use a hash function that maps each name to an index by taking the ASCII value of the first letter of the name modulo the size of the table: def simple_hash(key, array_size): return ord(key[0]) % array_size This hash function is simple, but it could lead to collisions because different keys might start with the same letter and hence the resulting indices will be the same. For example, say our array has the size of 10, running the simple_hash(key, 10) for each of our keys will give us: Alternatively, we can reshape this data in a more concise way: +---------------------+ | Key | Index | +---------------------+ | Alice | 5 | | Bob | 6 | | Charlie | 7 | | David | 8 | | Eve | 9 | | Brian | 6 | +---------------------+ Here, Bob and Brian have the same index in the resulting array, which results in a collision. We'll talk more about collisions in the latter sections - both in terms of creating hash functions that minimize the chance of collisions and resolving collisions when they occur. Designing robust hash functions is one of the most important aspects of hash table efficiency! Note: In Python, dictionaries are an implementation of a hash table, where the keys are hashed, and the resulting hash value determines where in the dictionary's underlying data storage the corresponding value is placed. In the following sections, we'll dive deeper into the inner workings of hash tables, discussing their operations, potential issues (like collisions), and solutions to these problems. Demystifying the Role of Hash Functions in Hash Tables Hash functions are the heart and soul of hash tables. They serve as a bridge between the keys and their associated values, providing a means of efficiently storing and retrieving data. Understanding the role of hash functions in hash tables is crucial to grasp how this powerful data structure operates. What is a Hash Function? In the context of hash tables, a hash function is a special function that takes a key as input and returns an index which the corresponding value should be stored or retrieved from. It transforms the key into a hash - a number that corresponds to an index in the array that forms the underlying structure of the hash table. The hash function needs to be deterministic, meaning that it should always produce the same hash for the same key. This way, whenever you want to retrieve a value, you can use the hash function on the key to find out where the value is stored. The Role of Hash Functions in Hash Tables The main objective of a hash function in a hash table is to distribute the keys as uniformly as possible across the array. This is important because the uniform distribution of keys allows for a constant time complexity of O(1) for data operations such as insertions, deletions, and retrievals on average. To illustrate how a hash function works in a hash table, let's again take a look at the example from the previous section: +-----------------------+ | Key | Value | +-----------------------+ | Alice | January | | Bob | May | | Charlie | January | | David | August | | Eve | December | | Brian | May | +-----------------------+ As before, assume we have a hash function, simple_hash(key), and a hash table of size 10. As we've seen before, running, say, \"Alice\" through the simple_hash() function returns the index 5. That means we can find the element with the key \"Alice\" and the value \"January\" in the array representing the hash table, on the index 5 (6th element of that array): And that applies to each key of our original data. Running each key through the hash function will give us the integer value - an index in the hash table array where that element is stored: +---------------------+ | Key | Index | +---------------------+ | Alice | 5 | | Bob | 6 | | Charlie | 7 | | David | 8 | | Eve | 9 | | Brian | 6 | +---------------------+ This can easily translate to the array representing a hash table - an element with the key \"Alice\" will be stored under index 5, \"Bob\" under index 6, and so on: Note: Under the index 6 there are two elements - {\"Bob\", \"February\"} and {\"Brian\", \"May\"}. In the illustration above, that collision was solved using the method called separate chaining, which we'll talk about more later in this article. When we want to retrieve the value associated with the key \"Alice\", we again pass the key to the hash function, which returns the index 5. We then immediately access the value at index 3 of the hash table, which is \"January\". Challenges with Hash Functions While the idea behind hash functions is fairly straightforward, designing a good hash function can be challenging. A primary concern is what's known as a collision, which occurs when two different keys hash to the same index in the array. Just take a look at the \"Bob\" and \"Brian\" keys in our example. They have the same index, meaning they are stored in the same place in the hash table array. In its essence, this is an example of a hashing collision. The likelihood of collisions is dictated by the hash function and the size of the hash table. While it's virtually impossible to completely avoid collisions for any non-trivial amount of data, a good hash function coupled with an appropriately sized hash table will minimize the chances of collisions. Different strategies such as open addressing and separate chaining can be used to resolve collisions when they occur, which we'll cover in a later section. Analyzing Time Complexity of Hash Tables: A Comparison One of the key benefits of using hash tables, which sets them apart from many other data structures, is their time complexity for basic operations. Time complexity is a computational concept that refers to the amount of time an operation or a function takes to run, as a function of the size of the input to the program. When discussing time complexity, we generally refer to three cases: Best Case: The minimum time required for executing an operation. Average Case: The average time needed for executing an operation. Worst Case: The maximum time needed for executing an operation. Hash tables are especially noteworthy for their impressive time complexity in the average case scenario. In that scenario, basic operations in hash tables (inserting, deleting, and accessing elements) have a constant time complexity of O(1). The constant time complexity implies that the time taken to perform these operations remains constant, regardless of the number of elements in the hash table. This makes these operations extremely efficient, especially when dealing with large datasets. While the average case time complexity for hash tables is O(1), the worst-case scenario is a different story. If multiple keys hash to the same index (a situation known as a collision), the time complexity can degrade to O(n), where n is the number of keys mapped to the same index. Check out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually learn it!This scenario occurs because, when resolving collisions, additional steps must be taken to store and retrieve data, typically by traversing a linked list of entries that hash to the same index. Note: With a well-designed hash function and a correctly sized hash table, this worst-case scenario is generally the exception rather than the norm. A good hash function paired with appropriate collision resolution strategies can keep collisions to a minimum. Comparing to Other Data Structures When compared to other data structures, hash tables stand out for their efficiency. For instance, operations like search, insertion, and deletion in a balanced binary search tree or a balanced AVL Tree have a time complexity of O(log n), which, although not bad, is not as efficient as the O(1) time complexity that hash tables offer in the average case. While arrays and linked lists offer O(1) time complexity for some operations, they can't maintain this level of efficiency across all basic operations. For example, searching in an unsorted array or linked list takes O(n) time, and insertion in an array takes O(n) time in the worst case. Python's Approach to Hash Tables: An Introduction to Dictionaries Python provides a built-in data structure that implements the functionality of a hash table called a dictionary, often referred to as a \"dict\". Dictionaries are one of Python's most powerful data structures, and understanding how they work can significantly boost your programming skills. What are Dictionaries? In Python, dictionaries (dicts) are unordered collections of key-value pairs. Keys in a dictionary are unique and immutable, which means they can't be changed once they're set. This property is essential for the correct functioning of a hash table. Values, on the other hand, can be of any type and are mutable, meaning you can change them. A key-value pair in a dictionary is also known as an item. Each key in a dictionary is associated (or mapped) to a single value, forming a key-value pair: my_dict = {\"Alice\": \"January\", \"Bob\": \"May\", \"Charlie\": \"January\"} How do Dictionaries Work in Python? Behind the scenes, Python's dictionaries operate as a hash table. When you create a dictionary and add a key-value pair, Python applies a hash function to the key, which results in a hash value. This hash value then determines where in memory the corresponding value will be stored. The beauty of this is that when you want to retrieve the value, Python applies the same hash function to the key, which rapidly guides Python to where the value is stored, regardless of the size of the dictionary: my_dict = {} my_dict[\"Alice\"] = \"January\" # Hash function determines the location for \"January\" print(my_dict[\"Alice\"]) # \"January\" Key Operations and Time Complexity Python's built-in dictionary data structure makes performing basic hash table operations—such as insertions, access, and deletions a breeze. These operations typically have an average time complexity of O(1), making them remarkably efficient. Note: As with hash tables, the worst-case time complexity can be O(n), but this happens rarely, only when there are hash collisions. Inserting key-value pairs into a Python dictionary is straightforward. You simply assign a value to a key using the assignment operator (=). If the key doesn't already exist in the dictionary, it's added. If it does exist, its current value is replaced with the new value: my_dict = {} my_dict[\"Alice\"] = \"January\" my_dict[\"Bob\"] = \"May\" print(my_dict) # Outputs: {'Alice': 'January', 'Bob': 'May'} Accessing a value in a Python dictionary is just as simple as inserting one. You can access the value associated with a particular key by referencing the key in square brackets. If you attempt to access a key that doesn't exist in the dictionary, Python will raise a KeyError: print(my_dict[\"Alice\"]) # Outputs: Python # Raises KeyError: 'Charlie' print(my_dict[\"Charlie\"]) To prevent this error, you can use the dictionary's get() method, which allows you to return a default value if the key doesn't exist: print(my_dict.get(\"Charlie\", \"Unknown\")) # Outputs: Unknown Note: Similarly, the setdefault() method can be used to safely insert a key-value pair into the dictionary if the key doesn't already exist: my_dict.setdefault(\"new_key\", \"default_value\") You can remove a key-value pair from a Python dictionary using the del keyword. If the key exists in the dictionary, it's removed along with its value. If the key doesn't exist, Python will also raise a KeyError: del my_dict[\"Bob\"] print(my_dict) # Outputs: {'Alice': 'January'} # Raises KeyError: 'Bob' del my_dict[\"Bob\"] Like with access, if you want to prevent an error when trying to delete a key that doesn't exist, you can use the dictionary's pop() method, which removes a key, returns its value if it exists, and returns a default value if it doesn't: print(my_dict.pop(\"Bob\", \"Unknown\")) # Outputs: Unknown All-in-all, Python dictionaries serve as a high-level, user-friendly implementation of a hash table. They are easy to use, yet powerful and efficient, making them an excellent tool for handling a wide variety of programming tasks. Advice: If you're testing for membership (i.e., whether an item is in a collection), a dictionary (or a set) is often a more efficient choice than a list or a tuple, especially for larger collections. That's because dictionaries and sets use hash tables, which allow them to test for membership in constant time (O(1)), as opposed to lists or tuples, which take linear time (O(n)). In the next sections, we will dive deeper into the practical aspects of using dictionaries in Python, including creating dictionaries (hash tables), performing operations, and handling collisions. How to Create Your First Hash Table in Python Python's dictionaries provide a ready-made implementation of hash tables, allowing you to store and retrieve key-value pairs with excellent efficiency. However, to understand hash tables thoroughly, it can be beneficial to implement one from scratch. In this section, we'll guide you through creating a simple hash table in Python. We'll start by defining a HashTable class. The hash table will be represented by a list (the table), and we will use a very simple hash function that calculates the remainder of the ASCII value of the key string's first character divided by the size of the table: class HashTable: def __init__(self, size): self.size = size self.table = [None]*size def _hash(self, key): return ord(key[0]) % self.size In this class, we have the __init__() method to initialize the hash table, and a _hash() method, which is our simple hash function. Now, we'll add methods to our HashTable class for adding key-value pairs, getting values by key, and removing entries: class HashTable: def __init__(self, size): self.size = size self.table = [None]*size def _hash(self, key): return ord(key[0]) % self.size def set(self, key, value): hash_index = self._hash(key) self.table[hash_index] = (key, value) def get(self, key): hash_index = self._hash(key) if self.table[hash_index] is not None: return self.table[hash_index][1] raise KeyError(f'Key {key} not found') def remove(self, key): hash_index = self._hash(key) if self.table[hash_index] is not None: self.table[hash_index] = None else: raise KeyError(f'Key {key} not found') The set() method adds a key-value pair to the table, while the get() method retrieves a value by its key. The remove() method deletes a key-value pair from the hash table. Note: If the key doesn't exist, the get and remove methods raise a KeyError. Now, we can create a hash table and use it to store and retrieve data: # Create a hash table of size 10 hash_table = HashTable(10) # Add some key-value pairs hash_table.set('Alice', 'January') hash_table.set('Bob', 'May') # Retrieve a value print(hash_table.get('Alice')) # Outputs: 'January' # Remove a key-value pair hash_table.remove('Bob') # This will raise a KeyError, as 'Bob' was removed print(hash_table.get('Bob')) Note: The above hash table implementation is quite simple and does not handle hash collisions. In real-world use, you'd need a more sophisticated hash function and collision resolution strategy. Resolving Collisions in Python Hash Tables Hash collisions are an inevitable part of using hash tables. A hash collision occurs when two different keys hash to the same index in the hash table. As Python dictionaries are an implementation of hash tables, they also need a way to handle these collisions. Python's built-in hash table implementation uses a method called \"open addressing\" to handle hash collisions. However, to better understand the collision resolution process, let's discuss a simpler method called \"separate chaining\". Separate Chaining Separate chaining is a collision resolution method in which each slot in the hash table holds a linked list of key-value pairs. When a collision occurs (i.e., two keys hash to the same index), the key-value pair is simply appended to the end of the linked list at the colliding index. Remember, we had a collision in our example because both \"Bob\" and \"Brian\" had the same index - 6. Let's use that example to illustrate the mechanism behind separate chaining. If we were to assume that the \"Bob\" element was added to the hash table first, we'd run into the problem when trying to store the \"Brian\" element since the index 6 was already taken. Solving this situation using separate chaining would include adding the \"Brian\" element as the second element of the linked list assigned to index 6 (the \"Bob\" element is the first element of that list). And that's all there is to it, just as shown in the following illustration: Here's how we might modify our HashTable class from the previous example to use separate chaining: class HashTable: def __init__(self, size): self.size = size self.table = [[] for _ in range(size)] def _hash(self, key): return ord(key[0]) % self.size def set(self, key, value): hash_index = self._hash(key) for kvp in self.table[hash_index]: if kvp[0] == key: kvp[1] = value return self.table[hash_index].append([key, value]) def get(self, key): hash_index = self._hash(key) for kvp in self.table[hash_index]: if kvp[0] == key: return kvp[1] raise KeyError(f'Key {key} not found') def remove(self, key): hash_index = self._hash(key) for i, kvp in enumerate(self.table[hash_index]): if kvp[0] == key: self.table[hash_index].pop(i) return raise KeyError(f'Key {key} not found') In this updated implementation, the table is initialized as a list of empty lists (i.e., each slot is an empty linked list). In the set() method, we iterate over the linked list at the hashed index, updating the value if the key already exists. If it doesn't, we append a new key-value pair to the list. The get() and remove() methods also need to iterate over the linked list at the hashed index to find the key they're looking for. While this approach solves the problem of collisions, it does lead to an increase in time complexity when collisions are frequent. Open Addressing The method used by Python dictionaries to handle collisions is more sophisticated than separate chaining. Python uses a form of open addressing called \"probing\". In probing, when a collision occurs, the hash table checks the next available slot and places the key-value pair there instead. The process of finding the next available slot is called \"probing\", and several strategies can be used, such as: Linear probing - checking one slot at a time in order Quadratic probing - checking slots in increasing powers of two Note: The specific method Python uses is more complex than any of these, but it ensures that lookups, insertions, and deletions remain close to O(1) time complexity even in cases where collisions are frequent. Let's just take a quick look at the collision example from the previous section, and show how would we treat it using the open addressing method. Say we have a hash table with only one element - {\"Bob\", \"May\"} on the index number 6. Now, we wouldn't be able to add the \"Brian\" element to the hash table due to the collision. But, the mechanism of linear probing tells us to store it in the first empty index - 7. That's it, easy right?",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eWhile Python doesn\u0026#39;t have a built-in data structure explicitly called a \u003cem\u003e\u0026#34;hash table\u0026#34;\u003c/em\u003e,  it provides the \u003cem\u003edictionary\u003c/em\u003e, which is a form of a hash table. Python dictionaries are unordered collections of \u003cem\u003ekey-value pairs\u003c/em\u003e, where the key is unique and holds a corresponding value. Thanks to a process known as \u003cem\u003e\u0026#34;hashing\u0026#34;\u003c/em\u003e, dictionaries enable efficient retrieval, addition, and removal of entries.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If you\u0026#39;re a Python programmer and have ever used a dictionary to store data as key-value pairs, you\u0026#39;ve already benefited from hash table technology without necessarily knowing it! \u003cstrong\u003ePython dictionaries are implemented using hash tables!\u003c/strong\u003e\u003c/p\u003e\n                \u003c/div\u003e\n            \n            \n            \u003cblockquote\u003e\n\u003cp\u003eIn this guide, we\u0026#39;ll delve into the world of hash tables. We\u0026#39;ll start with the basics, explaining what hash tables are and how they work. We\u0026#39;ll also explore Python\u0026#39;s implementation of hash tables via dictionaries, provide a step-by-step guide to creating a hash table in Python, and even touch on how to handle hash collisions. Along the way, we\u0026#39;ll demonstrate the utility and efficiency of hash tables with real-world examples and handy Python snippets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"defininghashtableskeyvaluepairdatastructure\"\u003eDefining Hash Tables: Key-Value Pair Data Structure\u003c/h3\u003e\n\u003cp\u003eSince dictionaries in Python are essentially an implementation of hash tables, let\u0026#39;s first focus on what hash tables actually are, and dive into Python implementation afterward.\u003c/p\u003e\n\u003cp\u003eHash tables are a type of data structure that provides a mechanism to store data in an \u003cem\u003eassociative manner\u003c/em\u003e. In a hash table, data is stored in an \u003cem\u003earray format\u003c/em\u003e, but each data value has its own \u003cem\u003eunique key\u003c/em\u003e, which is used to identify the data. This mechanism is based on key-value pairs, making the retrieval of data a swift process.\u003c/p\u003e\n\u003cp\u003eThe analogy often used to explain this concept is a real-world dictionary. In a dictionary, you use a known word (the \u0026#34;key\u0026#34;) to find its meaning (the \u0026#34;value\u0026#34;). If you know the word, you can quickly find its definition. Similarly, in a hash table, if you know the key, you can quickly retrieve its value.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEssentially, we are trying to store key-value pairs in the most efficient way possible.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFor example, say we want to create a hash table that stores the birth month of various people. The people\u0026#39;s names are our keys and their birth months are the values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+-----------------------+\n|   Key   |   Value     |\n+-----------------------+\n| Alice   | January     |\n| Bob     | May         |\n| Charlie | January     |\n| David   | August      |\n| Eve     | December    |\n| Brian   | May         |\n+-----------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo store these key-value pairs in a hash table, we\u0026#39;ll first need a way to convert the value of keys to the appropriate indexes of the array that represents a hash table. That\u0026#39;s where a \u003cstrong\u003ehash function\u003c/strong\u003e comes into play! Being the backbone of a hash table implementation, this function processes the key and returns the corresponding index in the data storage array - just as we need.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe goal of a \u003cem\u003egood hash function\u003c/em\u003e is to distribute the keys evenly across the array, minimizing the chance of collisions (where two keys produce the same index).\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIn reality, hash functions are much more complex, but for simplicity, let\u0026#39;s use a hash function that maps each name to an index by taking the ASCII value of the first letter of the name modulo the size of the table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003esimple_hash\u003c/span\u003e(\u003cspan\u003ekey, array_size\u003c/span\u003e):\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eord\u003c/span\u003e(key[\u003cspan\u003e0\u003c/span\u003e]) % array_size\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis hash function is \u003cem\u003esimple\u003c/em\u003e, but it \u003cem\u003ecould lead to collisions\u003c/em\u003e because different keys might start with the same letter and hence the resulting indices will be the same. For example, say our array has the size of \u003ccode\u003e10\u003c/code\u003e, running the \u003ccode\u003esimple_hash(key, 10)\u003c/code\u003e for each of our keys will give us:\u003c/p\u003e\n\n\u003cp\u003eAlternatively, we can reshape this data in a more concise way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+---------------------+\n|   Key   |   Index   |\n+---------------------+\n| Alice   |     5     |\n| Bob     |     6     |\n| Charlie |     7     |\n| David   |     8     |\n| Eve     |     9     |\n| Brian   |     6     |\n+---------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, \u003ccode\u003eBob\u003c/code\u003e and \u003ccode\u003eBrian\u003c/code\u003e have the same index in the resulting array, which results in \u003cem\u003ea collision\u003c/em\u003e. We\u0026#39;ll talk more about collisions in the latter sections - both in terms of creating hash functions that minimize the chance of collisions and resolving collisions when they occur.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eDesigning robust hash functions is one of the most important aspects of hash table efficiency!\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e In Python, dictionaries are an implementation of a hash table, where the keys are hashed, and the resulting hash value determines where in the dictionary\u0026#39;s underlying data storage the corresponding value is placed.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eIn the following sections, we\u0026#39;ll dive deeper into the inner workings of hash tables, discussing their operations, potential issues (like collisions), and solutions to these problems.\u003c/p\u003e\n\u003ch3 id=\"demystifyingtheroleofhashfunctionsinhashtables\"\u003eDemystifying the Role of Hash Functions in Hash Tables\u003c/h3\u003e\n\u003cp\u003eHash functions are the \u003cem\u003eheart and soul\u003c/em\u003e of hash tables. They serve as a bridge between the keys and their associated values, providing a means of efficiently storing and retrieving data. Understanding the role of hash functions in hash tables is crucial to grasp how this powerful data structure operates.\u003c/p\u003e\n\u003ch4 id=\"whatisahashfunction\"\u003eWhat is a Hash Function?\u003c/h4\u003e\n\u003cp\u003eIn the context of hash tables, a hash function is a special function that takes a \u003cem\u003ekey as input\u003c/em\u003e and \u003cem\u003ereturns an index\u003c/em\u003e which the corresponding value should be stored or retrieved from. It transforms the key into a \u003cem\u003e\u003cstrong\u003ehash\u003c/strong\u003e\u003c/em\u003e - a number that corresponds to an index in the array that forms the underlying structure of the hash table.\u003c/p\u003e\n\u003cp\u003eThe hash function needs to be \u003cem\u003e\u003cstrong\u003edeterministic\u003c/strong\u003e\u003c/em\u003e, meaning that it should always produce the same hash for the same key. This way, whenever you want to retrieve a value, you can use the hash function on the key to find out where the value is stored.\u003c/p\u003e\n\u003ch4 id=\"theroleofhashfunctionsinhashtables\"\u003eThe Role of Hash Functions in Hash Tables\u003c/h4\u003e\n\u003cp\u003eThe main objective of a hash function in a hash table is to distribute the keys \u003cem\u003eas uniformly as possible\u003c/em\u003e across the array. This is important because the uniform distribution of keys allows for a constant time complexity of \u003cem\u003eO(1)\u003c/em\u003e for data operations such as insertions, deletions, and retrievals \u003cem\u003eon average\u003c/em\u003e.\u003c/p\u003e\n\n            \n            \u003cp\u003eTo illustrate how a hash function works in a hash table, let\u0026#39;s again take a look at the example from the previous section:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+-----------------------+\n|   Key   |   Value     |\n+-----------------------+\n| Alice   | January     |\n| Bob     | May         |\n| Charlie | January     |\n| David   | August      |\n| Eve     | December    |\n| Brian   | May         |\n+-----------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs before, assume we have a hash function, \u003ccode\u003esimple_hash(key)\u003c/code\u003e, and a hash table of size \u003ccode\u003e10\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAs we\u0026#39;ve seen before, running, say, \u003ccode\u003e\u0026#34;Alice\u0026#34;\u003c/code\u003e through the \u003ccode\u003esimple_hash()\u003c/code\u003e function returns the index \u003ccode\u003e5\u003c/code\u003e. That means we can find the element with the key \u003ccode\u003e\u0026#34;Alice\u0026#34;\u003c/code\u003e and the value \u003ccode\u003e\u0026#34;January\u0026#34;\u003c/code\u003e in the array representing the hash table, on the index \u003ccode\u003e5\u003c/code\u003e (6th element of that array):\u003c/p\u003e\n\n\u003cp\u003eAnd that applies to each key of our original data. Running each key through the hash function will give us the integer value - an index in the hash table array where that element is stored:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e+---------------------+\n|   Key   |   Index   |\n+---------------------+\n| Alice   |     5     |\n| Bob     |     6     |\n| Charlie |     7     |\n| David   |     8     |\n| Eve     |     9     |\n| Brian   |     6     |\n+---------------------+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis can easily translate to the array representing a hash table - an element with the key \u003ccode\u003e\u0026#34;Alice\u0026#34;\u003c/code\u003e will be stored under index \u003ccode\u003e5\u003c/code\u003e, \u003ccode\u003e\u0026#34;Bob\u0026#34;\u003c/code\u003e under index \u003ccode\u003e6\u003c/code\u003e, and  so on:\u003c/p\u003e\n\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Under the index \u003ccode\u003e6\u003c/code\u003e there are two elements - \u003ccode\u003e{\u0026#34;Bob\u0026#34;, \u0026#34;February\u0026#34;}\u003c/code\u003e and \u003ccode\u003e{\u0026#34;Brian\u0026#34;, \u0026#34;May\u0026#34;}\u003c/code\u003e. In the illustration above, that collision was solved using the method called \u003cem\u003eseparate chaining\u003c/em\u003e, which we\u0026#39;ll talk about more later in this article.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eWhen we want to retrieve the value associated with the key \u003ccode\u003e\u0026#34;Alice\u0026#34;\u003c/code\u003e, we again pass the key to the hash function, which returns the index \u003ccode\u003e5\u003c/code\u003e. We then immediately access the value at index \u003ccode\u003e3\u003c/code\u003e of the hash table, which is \u003ccode\u003e\u0026#34;January\u0026#34;\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"challengeswithhashfunctions\"\u003eChallenges with Hash Functions\u003c/h4\u003e\n\u003cp\u003eWhile the idea behind hash functions is fairly straightforward, \u003cstrong\u003edesigning a good hash function can be challenging\u003c/strong\u003e. A primary concern is what\u0026#39;s known as a \u003cem\u003ecollision\u003c/em\u003e, which occurs when two different keys hash to the same index in the array.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJust take a look at the \u003ccode\u003e\u0026#34;Bob\u0026#34;\u003c/code\u003e and \u003ccode\u003e\u0026#34;Brian\u0026#34;\u003c/code\u003e keys in our example. They have the same index, meaning they are stored in the same place in the hash table array. In its essence, this is an example of a hashing collision.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe likelihood of \u003cem\u003ecollisions\u003c/em\u003e is dictated by the hash function and the size of the hash table. While it\u0026#39;s virtually impossible to completely avoid collisions for any non-trivial amount of data, a good hash function coupled with an appropriately sized hash table will minimize the chances of collisions.\u003c/p\u003e\n\u003cp\u003eDifferent strategies such as \u003cem\u003eopen addressing\u003c/em\u003e and \u003cem\u003eseparate chaining\u003c/em\u003e can be used to resolve collisions when they occur, which we\u0026#39;ll cover in a later section.\u003c/p\u003e\n\u003ch3 id=\"analyzingtimecomplexityofhashtablesacomparison\"\u003eAnalyzing Time Complexity of Hash Tables: A Comparison\u003c/h3\u003e\n\u003cp\u003eOne of the key benefits of using hash tables, which sets them apart from many other data structures, is their time complexity for basic operations. Time complexity is a computational concept that refers to the amount of time an operation or a function takes to run, as a function of the size of the input to the program.\u003c/p\u003e\n\u003cp\u003eWhen discussing time complexity, we generally refer to three cases:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eBest Case:\u003c/strong\u003e The minimum time required for executing an operation.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAverage Case:\u003c/strong\u003e The average time needed for executing an operation.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWorst Case:\u003c/strong\u003e The maximum time needed for executing an operation.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHash tables are especially noteworthy for their \u003cem\u003eimpressive time complexity in the \u003cstrong\u003eaverage case\u003c/strong\u003e scenario\u003c/em\u003e. In that scenario, basic operations in hash tables (inserting, deleting, and accessing elements) have a \u003cstrong\u003econstant time complexity of O(1)\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThe constant time complexity implies that the time taken to perform these operations remains constant, regardless of the number of elements in the hash table.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis makes these operations extremely efficient, especially when dealing with large datasets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWhile the average case time complexity for hash tables is O(1), \u003cem\u003ethe \u003cstrong\u003eworst-case\u003c/strong\u003e scenario is a different story\u003c/em\u003e. If multiple keys hash to the same index (a situation known as a \u003cem\u003ecollision\u003c/em\u003e), the time complexity can degrade to \u003cstrong\u003eO(n)\u003c/strong\u003e, where \u003cem\u003en\u003c/em\u003e is the number of keys mapped to the same index.\u003c/p\u003e\n\u003cdiv data-nosnippet=\"\" id=\"ad-lead-magnet\"\u003e\u003cp\u003eCheck out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually \u003cem\u003elearn\u003c/em\u003e it!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis scenario occurs because, when resolving collisions, additional steps must be taken to store and retrieve data, typically by traversing a linked list of entries that hash to the same index.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e With a well-designed hash function and a correctly sized hash table, this worst-case scenario is generally the exception rather than the norm. A good hash function paired with appropriate collision resolution strategies can keep collisions to a minimum.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch4 id=\"comparingtootherdatastructures\"\u003eComparing to Other Data Structures\u003c/h4\u003e\n\u003cp\u003eWhen compared to other data structures, \u003cem\u003ehash tables stand out for their efficiency\u003c/em\u003e. For instance, operations like search, insertion, and deletion in a balanced binary search tree or a balanced AVL Tree have a time complexity of \u003cem\u003eO(log n)\u003c/em\u003e, which, although not bad, is not as efficient as the \u003cem\u003eO(1)\u003c/em\u003e time complexity that hash tables offer in the average case.\u003c/p\u003e\n\u003cp\u003eWhile arrays and linked lists offer \u003cem\u003eO(1)\u003c/em\u003e time complexity for some operations, they can\u0026#39;t maintain this level of efficiency across all basic operations. For example, searching in an unsorted array or linked list takes \u003cem\u003eO(n)\u003c/em\u003e time, and insertion in an array takes \u003cem\u003eO(n)\u003c/em\u003e time in the worst case.\u003c/p\u003e\n\u003ch3 id=\"pythonsapproachtohashtablesanintroductiontodictionaries\"\u003ePython\u0026#39;s Approach to Hash Tables: An Introduction to Dictionaries\u003c/h3\u003e\n\u003cp\u003ePython provides a built-in data structure that implements the functionality of a hash table called a dictionary, often referred to as a \u0026#34;dict\u0026#34;. Dictionaries are one of Python\u0026#39;s most powerful data structures, and understanding how they work can significantly boost your programming skills.\u003c/p\u003e\n\n            \n            \u003ch4 id=\"whataredictionaries\"\u003eWhat are Dictionaries?\u003c/h4\u003e\n\u003cp\u003eIn Python, dictionaries (dicts) are unordered collections of key-value pairs. Keys in a dictionary are unique and immutable, which means they can\u0026#39;t be changed once they\u0026#39;re set. This property is essential for the correct functioning of a hash table. Values, on the other hand, can be of any type and are mutable, meaning you can change them.\u003c/p\u003e\n\u003cp\u003eA key-value pair in a dictionary is also known as an item. Each key in a dictionary is associated (or mapped) to a single value, forming a key-value pair:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy_dict = {\u003cspan\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;January\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;May\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;Charlie\u0026#34;\u003c/span\u003e: \u003cspan\u003e\u0026#34;January\u0026#34;\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"howdodictionariesworkinpython\"\u003eHow do Dictionaries Work in Python?\u003c/h4\u003e\n\u003cp\u003eBehind the scenes, \u003cem\u003ePython\u0026#39;s dictionaries operate as a hash table\u003c/em\u003e. When you create a dictionary and add a key-value pair, Python applies a hash function to the key, which results in a hash value. This hash value then determines where in memory the corresponding value will be stored.\u003c/p\u003e\n\u003cp\u003eThe beauty of this is that when you want to retrieve the value, Python applies the same hash function to the key, which rapidly guides Python to where the value is stored, regardless of the size of the dictionary:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy_dict = {}\nmy_dict[\u003cspan\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e] = \u003cspan\u003e\u0026#34;January\u0026#34;\u003c/span\u003e \u003cspan\u003e# Hash function determines the location for \u0026#34;January\u0026#34;\u003c/span\u003e\n\u003cspan\u003eprint\u003c/span\u003e(my_dict[\u003cspan\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e]) \u003cspan\u003e# \u0026#34;January\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"keyoperationsandtimecomplexity\"\u003eKey Operations and Time Complexity\u003c/h4\u003e\n\u003cp\u003ePython\u0026#39;s built-in dictionary data structure makes performing basic hash table operations—such as insertions, access, and deletions a breeze. These operations typically have an average time complexity of O(1), making them remarkably efficient.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e As with hash tables, the worst-case time complexity can be \u003cem\u003eO(n)\u003c/em\u003e, but this happens rarely, only when there are hash collisions.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003e\u003cstrong\u003eInserting key-value pairs\u003c/strong\u003e into a Python dictionary is straightforward. You simply assign a value to a key using the assignment operator (\u003ccode\u003e=\u003c/code\u003e). If the key doesn\u0026#39;t already exist in the dictionary, it\u0026#39;s added. If it does exist, its current value is replaced with the new value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy_dict = {}\nmy_dict[\u003cspan\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e] = \u003cspan\u003e\u0026#34;January\u0026#34;\u003c/span\u003e\nmy_dict[\u003cspan\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e] = \u003cspan\u003e\u0026#34;May\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eprint\u003c/span\u003e(my_dict)  \u003cspan\u003e# Outputs: {\u0026#39;Alice\u0026#39;: \u0026#39;January\u0026#39;, \u0026#39;Bob\u0026#39;: \u0026#39;May\u0026#39;}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAccessing a value\u003c/strong\u003e in a Python dictionary is just as simple as inserting one. You can access the value associated with a particular key by referencing the key in square brackets. If you attempt to access a key that doesn\u0026#39;t exist in the dictionary, Python will raise a \u003ccode\u003eKeyError\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprint\u003c/span\u003e(my_dict[\u003cspan\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e])  \u003cspan\u003e# Outputs: Python\u003c/span\u003e\n\n\u003cspan\u003e# Raises KeyError: \u0026#39;Charlie\u0026#39;\u003c/span\u003e\n\u003cspan\u003eprint\u003c/span\u003e(my_dict[\u003cspan\u003e\u0026#34;Charlie\u0026#34;\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo prevent this error, you can use the dictionary\u0026#39;s \u003ccode\u003eget()\u003c/code\u003e method, which allows you to return a default value if the key doesn\u0026#39;t exist:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprint\u003c/span\u003e(my_dict.get(\u003cspan\u003e\u0026#34;Charlie\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;Unknown\u0026#34;\u003c/span\u003e))  \u003cspan\u003e# Outputs: Unknown\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n            \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Similarly, the \u003ccode\u003esetdefault()\u003c/code\u003e method can be used to safely insert a key-value pair into the dictionary if the key doesn\u0026#39;t already exist:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emy_dict.setdefault(\u003cspan\u003e\u0026#34;new_key\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;default_value\u0026#34;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\n                    \u003c/div\u003e\n            \u003cp\u003eYou can \u003cstrong\u003eremove a key-value pair\u003c/strong\u003e from a Python dictionary using the \u003ccode\u003edel\u003c/code\u003e keyword. If the key exists in the dictionary, it\u0026#39;s removed along with its value. If the key doesn\u0026#39;t exist, Python will also raise a \u003ccode\u003eKeyError\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edel\u003c/span\u003e my_dict[\u003cspan\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e]\n\u003cspan\u003eprint\u003c/span\u003e(my_dict)  \u003cspan\u003e# Outputs: {\u0026#39;Alice\u0026#39;: \u0026#39;January\u0026#39;}\u003c/span\u003e\n\n\u003cspan\u003e# Raises KeyError: \u0026#39;Bob\u0026#39;\u003c/span\u003e\n\u003cspan\u003edel\u003c/span\u003e my_dict[\u003cspan\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLike with access, if you want to prevent an error when trying to delete a key that doesn\u0026#39;t exist, you can use the dictionary\u0026#39;s \u003ccode\u003epop()\u003c/code\u003e method, which removes a key, returns its value if it exists, and returns a default value if it doesn\u0026#39;t:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprint\u003c/span\u003e(my_dict.pop(\u003cspan\u003e\u0026#34;Bob\u0026#34;\u003c/span\u003e, \u003cspan\u003e\u0026#34;Unknown\u0026#34;\u003c/span\u003e))  \u003cspan\u003e# Outputs: Unknown\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAll-in-all, Python dictionaries serve as a high-level, user-friendly implementation of a hash table. They are easy to use, yet powerful and efficient, making them an excellent tool for handling a wide variety of programming tasks.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eAdvice:\u003c/strong\u003e If you\u0026#39;re testing for membership (i.e., whether an item is in a collection), a dictionary (or a set) is often a more efficient choice than a list or a tuple, especially for larger collections. That\u0026#39;s because dictionaries and sets use hash tables, which allow them to test for membership in constant time (\u003cem\u003eO(1)\u003c/em\u003e), as opposed to lists or tuples, which take linear time (\u003cem\u003eO(n)\u003c/em\u003e).\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eIn the next sections, we will dive deeper into the practical aspects of using dictionaries in Python, including creating dictionaries (hash tables), performing operations, and handling collisions.\u003c/p\u003e\n\u003ch3 id=\"howtocreateyourfirsthashtableinpython\"\u003eHow to Create Your First Hash Table in Python\u003c/h3\u003e\n\u003cp\u003ePython\u0026#39;s dictionaries provide a ready-made implementation of hash tables, allowing you to store and retrieve key-value pairs with excellent efficiency. However, to understand hash tables thoroughly, it can be beneficial to implement one from scratch. In this section, we\u0026#39;ll guide you through creating a simple hash table in Python.\u003c/p\u003e\n\u003cp\u003eWe\u0026#39;ll start by defining a \u003ccode\u003eHashTable\u003c/code\u003e class. The hash table will be represented by a list (the \u003ccode\u003etable\u003c/code\u003e), and we will use a very simple hash function that calculates the remainder of the ASCII value of the key string\u0026#39;s first character divided by the size of the table:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eHashTable\u003c/span\u003e:\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself, size\u003c/span\u003e):\u003c/span\u003e\n        self.size = size\n        self.table = [\u003cspan\u003eNone\u003c/span\u003e]*size\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e_hash\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eord\u003c/span\u003e(key[\u003cspan\u003e0\u003c/span\u003e]) % self.size\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this class, we have the \u003ccode\u003e__init__()\u003c/code\u003e method to initialize the hash table, and a \u003ccode\u003e_hash()\u003c/code\u003e method, which is our simple hash function.\u003c/p\u003e\n\u003cp\u003eNow, we\u0026#39;ll add methods to our \u003ccode\u003eHashTable\u003c/code\u003e class for adding key-value pairs, getting values by key, and removing entries:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eHashTable\u003c/span\u003e:\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself, size\u003c/span\u003e):\u003c/span\u003e\n        self.size = size\n        self.table = [\u003cspan\u003eNone\u003c/span\u003e]*size\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e_hash\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eord\u003c/span\u003e(key[\u003cspan\u003e0\u003c/span\u003e]) % self.size\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eset\u003c/span\u003e(\u003cspan\u003eself, key, value\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        self.table[hash_index] = (key, value)\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        \u003cspan\u003eif\u003c/span\u003e self.table[hash_index] \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e:\n            \u003cspan\u003ereturn\u003c/span\u003e self.table[hash_index][\u003cspan\u003e1\u003c/span\u003e]\n\n        \u003cspan\u003eraise\u003c/span\u003e KeyError(\u003cspan\u003ef\u0026#39;Key \u003cspan\u003e{key}\u003c/span\u003e not found\u0026#39;\u003c/span\u003e)\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eremove\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        \u003cspan\u003eif\u003c/span\u003e self.table[hash_index] \u003cspan\u003eis\u003c/span\u003e \u003cspan\u003enot\u003c/span\u003e \u003cspan\u003eNone\u003c/span\u003e:\n            self.table[hash_index] = \u003cspan\u003eNone\u003c/span\u003e\n        \u003cspan\u003eelse\u003c/span\u003e:\n            \u003cspan\u003eraise\u003c/span\u003e KeyError(\u003cspan\u003ef\u0026#39;Key \u003cspan\u003e{key}\u003c/span\u003e not found\u0026#39;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eset()\u003c/code\u003e method adds a key-value pair to the table, while the \u003ccode\u003eget()\u003c/code\u003e method retrieves a value by its key. The \u003ccode\u003eremove()\u003c/code\u003e method deletes a key-value pair from the hash table.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e If the key doesn\u0026#39;t exist, the \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eremove\u003c/code\u003e methods raise a \u003ccode\u003eKeyError\u003c/code\u003e.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eNow, we can create a hash table and use it to store and retrieve data:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# Create a hash table of size 10\u003c/span\u003e\nhash_table = HashTable(\u003cspan\u003e10\u003c/span\u003e)\n\n\u003cspan\u003e# Add some key-value pairs\u003c/span\u003e\nhash_table.\u003cspan\u003eset\u003c/span\u003e(\u003cspan\u003e\u0026#39;Alice\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;January\u0026#39;\u003c/span\u003e)\nhash_table.\u003cspan\u003eset\u003c/span\u003e(\u003cspan\u003e\u0026#39;Bob\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;May\u0026#39;\u003c/span\u003e)\n\n\u003cspan\u003e# Retrieve a value\u003c/span\u003e\n\u003cspan\u003eprint\u003c/span\u003e(hash_table.get(\u003cspan\u003e\u0026#39;Alice\u0026#39;\u003c/span\u003e))  \u003cspan\u003e# Outputs: \u0026#39;January\u0026#39;\u003c/span\u003e\n\n\u003cspan\u003e# Remove a key-value pair\u003c/span\u003e\nhash_table.remove(\u003cspan\u003e\u0026#39;Bob\u0026#39;\u003c/span\u003e)\n\n\u003cspan\u003e# This will raise a KeyError, as \u0026#39;Bob\u0026#39; was removed\u003c/span\u003e\n\u003cspan\u003eprint\u003c/span\u003e(hash_table.get(\u003cspan\u003e\u0026#39;Bob\u0026#39;\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The above hash table implementation is quite simple and does not handle hash collisions. In real-world use, you\u0026#39;d need a more sophisticated hash function and collision resolution strategy.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"resolvingcollisionsinpythonhashtables\"\u003eResolving Collisions in Python Hash Tables\u003c/h3\u003e\n\u003cp\u003eHash collisions are an inevitable part of using hash tables. A hash collision occurs when two different keys hash to the same index in the hash table. As Python dictionaries are an implementation of hash tables, they also need a way to handle these collisions.\u003c/p\u003e\n\u003cp\u003ePython\u0026#39;s built-in hash table implementation uses a method called \u003cem\u003e\u003cstrong\u003e\u0026#34;open addressing\u0026#34;\u003c/strong\u003e\u003c/em\u003e to handle hash collisions. However, to better understand the collision resolution process, let\u0026#39;s discuss a simpler method called \u003cem\u003e\u003cstrong\u003e\u0026#34;separate chaining\u0026#34;\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch4 id=\"separatechaining\"\u003eSeparate Chaining\u003c/h4\u003e\n\u003cp\u003eSeparate chaining is a collision resolution method in which each slot in the hash table holds a linked list of key-value pairs. When a collision occurs (i.e., two keys hash to the same index), the key-value pair is simply appended to the end of the linked list at the colliding index.\u003c/p\u003e\n\u003cp\u003eRemember, we had a collision in our example because both \u003ccode\u003e\u0026#34;Bob\u0026#34;\u003c/code\u003e and \u003ccode\u003e\u0026#34;Brian\u0026#34;\u003c/code\u003e had the same index - \u003ccode\u003e6\u003c/code\u003e. Let\u0026#39;s use that example to illustrate the mechanism behind separate chaining. If we were to assume that the \u003ccode\u003e\u0026#34;Bob\u0026#34;\u003c/code\u003e element was added to the hash table first, we\u0026#39;d run into the problem when trying to store the \u003ccode\u003e\u0026#34;Brian\u0026#34;\u003c/code\u003e element since the index \u003ccode\u003e6\u003c/code\u003e was already taken.\u003c/p\u003e\n\u003cp\u003eSolving this situation using separate chaining would include adding the \u003ccode\u003e\u0026#34;Brian\u0026#34;\u003c/code\u003e element as the second element of the linked list assigned to index \u003ccode\u003e6\u003c/code\u003e (the \u003ccode\u003e\u0026#34;Bob\u0026#34;\u003c/code\u003e element is the first element of that list). And that\u0026#39;s all there is to it, just as shown in the following illustration:\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s how we might modify our \u003ccode\u003eHashTable\u003c/code\u003e class from the previous example to use separate chaining:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eHashTable\u003c/span\u003e:\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself, size\u003c/span\u003e):\u003c/span\u003e\n        self.size = size\n        self.table = [[] \u003cspan\u003efor\u003c/span\u003e _ \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erange\u003c/span\u003e(size)]\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e_hash\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eord\u003c/span\u003e(key[\u003cspan\u003e0\u003c/span\u003e]) % self.size\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eset\u003c/span\u003e(\u003cspan\u003eself, key, value\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        \u003cspan\u003efor\u003c/span\u003e kvp \u003cspan\u003ein\u003c/span\u003e self.table[hash_index]:\n            \u003cspan\u003eif\u003c/span\u003e kvp[\u003cspan\u003e0\u003c/span\u003e] == key:\n                kvp[\u003cspan\u003e1\u003c/span\u003e] = value\n                \u003cspan\u003ereturn\u003c/span\u003e\n\n        self.table[hash_index].append([key, value])\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eget\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        \u003cspan\u003efor\u003c/span\u003e kvp \u003cspan\u003ein\u003c/span\u003e self.table[hash_index]:\n            \u003cspan\u003eif\u003c/span\u003e kvp[\u003cspan\u003e0\u003c/span\u003e] == key:\n                \u003cspan\u003ereturn\u003c/span\u003e kvp[\u003cspan\u003e1\u003c/span\u003e]\n\n        \u003cspan\u003eraise\u003c/span\u003e KeyError(\u003cspan\u003ef\u0026#39;Key \u003cspan\u003e{key}\u003c/span\u003e not found\u0026#39;\u003c/span\u003e)\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eremove\u003c/span\u003e(\u003cspan\u003eself, key\u003c/span\u003e):\u003c/span\u003e\n        hash_index = self._\u003cspan\u003ehash\u003c/span\u003e(key)\n        \u003cspan\u003efor\u003c/span\u003e i, kvp \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003eenumerate\u003c/span\u003e(self.table[hash_index]):\n            \u003cspan\u003eif\u003c/span\u003e kvp[\u003cspan\u003e0\u003c/span\u003e] == key:\n                self.table[hash_index].pop(i)\n                \u003cspan\u003ereturn\u003c/span\u003e\n\n        \u003cspan\u003eraise\u003c/span\u003e KeyError(\u003cspan\u003ef\u0026#39;Key \u003cspan\u003e{key}\u003c/span\u003e not found\u0026#39;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this updated implementation, the \u003ccode\u003etable\u003c/code\u003e is initialized as a list of empty lists (i.e., each slot is an empty linked list). In the \u003ccode\u003eset()\u003c/code\u003e method, we iterate over the linked list at the hashed index, updating the value if the key already exists. If it doesn\u0026#39;t, we append a new key-value pair to the list.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eget()\u003c/code\u003e and \u003ccode\u003eremove()\u003c/code\u003e methods also need to iterate over the linked list at the hashed index to find the key they\u0026#39;re looking for.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eWhile this approach solves the problem of collisions, it does lead to an increase in time complexity when collisions are frequent.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"openaddressing\"\u003eOpen Addressing\u003c/h4\u003e\n\u003cp\u003eThe method used by Python dictionaries to handle collisions is more sophisticated than separate chaining. Python uses a form of open addressing called \u003cem\u003e\u003cstrong\u003e\u0026#34;probing\u0026#34;\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn probing, when a collision occurs, the hash table checks the next available slot and places the key-value pair there instead. The process of finding the next available slot is called \u0026#34;probing\u0026#34;, and several strategies can be used, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eLinear probing\u003c/em\u003e - checking one slot at a time in order\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eQuadratic probing\u003c/em\u003e - checking slots in increasing powers of two\u003c/li\u003e\n\u003c/ul\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The specific method Python uses is more complex than any of these, but it ensures that lookups, insertions, and deletions remain close to \u003cem\u003eO(1)\u003c/em\u003e time complexity even in cases where collisions are frequent.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eLet\u0026#39;s just take a quick look at the collision example from the previous section, and show how would we treat it using the open addressing method. Say we have a hash table with only one element - \u003ccode\u003e{\u0026#34;Bob\u0026#34;, \u0026#34;May\u0026#34;}\u003c/code\u003e on the index number \u003ccode\u003e6\u003c/code\u003e.  Now, we wouldn\u0026#39;t be able to add the \u003ccode\u003e\u0026#34;Brian\u0026#34;\u003c/code\u003e element to the hash table due to the collision. But, the mechanism of linear probing tells us to store it in the first empty index - \u003ccode\u003e7\u003c/code\u003e. That\u0026#39;s it, easy right?\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "25 min read",
  "publishedTime": "2023-11-09T20:19:44Z",
  "modifiedTime": "2024-04-18T14:55:02Z"
}
