{
  "id": "6edd4e2f-0282-458d-9c12-8a00888d71a1",
  "title": "Understanding and Improving SwiftUI Performance",
  "link": "https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896?source=rss----53c7c27702d5---4",
  "description": "",
  "author": "Cal Stephens",
  "published": "Tue, 24 Jun 2025 16:43:07 GMT",
  "source": "https://medium.com/feed/airbnb-engineering",
  "categories": [
    "ios",
    "swiftui",
    "performance",
    "engineering",
    "mobile"
  ],
  "byline": "Cal Stephens",
  "length": 14575,
  "excerpt": "New techniques we’re using at Airbnb to improve and maintain performance of SwiftUI features at scale Airbnb first adopted SwiftUI in 2022, starting with individual components and later expanding to…",
  "siteName": "The Airbnb Tech Blog",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Understanding and Improving SwiftUI PerformanceNew techniques we’re using at Airbnb to improve and maintain performance of SwiftUI features at scaleBy Cal Stephens, Miguel JimenezAirbnb first adopted SwiftUI in 2022, starting with individual components and later expanding to entire screens and features. We’ve seen major improvements to engineers’ productivity thanks to its declarative, flexible, and composable architecture. However, adopting SwiftUI has brought new challenges related to performance. For example, there are many common code patterns in SwiftUI that can be inefficient, and many small papercuts can add up to a large cumulative performance hit. To begin addressing some of these issues at scale, we’ve created new tooling for proactively identifying these cases and statically validating correctness.SwiftUI feature architecture at AirbnbWe’ve been leveraging declarative UI patterns at Airbnb for many years, using our UIKit-based Epoxy library and unidirectional data flow systems. When adopting SwiftUI in our screen layer, we decided to continue using our existing unidirectional data flow library. This simplified the process of incrementally adopting SwiftUI within our large codebase, and we find it improves the quality and maintainability of features.However, we noticed that SwiftUI features using our unidirectional data flow library didn’t perform as well as we expected, and it wasn’t immediately obvious to us what the problem was. Understanding SwiftUI’s performance characteristics is an important requirement for building performant and outside of the “standard” SwiftUI toolbox.Understanding SwiftUI view diffingWhen working with declarative UI systems like SwiftUI, it’s important to ensure the framework knows which views need to be re-evaluated and re-rendered when the state of the screen changes. Changes are detected by diffing the view’s stored properties any time its parent is updated. Ideally the view’s body will only be re-evaluated when its properties actually change:However, this behavior is not always the reality (more on why in a moment). Unnecessary view body evaluations hurt performance by performing unnecessary work.How do you know how often a view’s body is re-evaluated in a real app? An easy way to visualize this is with a modifier that applies a random color to the view every time it’s rendered. When testing this on various views in our app’s most performance-sensitive screens, we quickly found that many views were re-evaluated and re-rendered more often than necessary:The SwiftUI view diffing algorithmSwiftUI’s built-in diffing algorithm is often overlooked and not officially documented, but it has a huge impact on performance. To determine if a view’s body needs to be re-evaluated, SwiftUI uses a reflection-based diffing algorithm to compare each of the view’s stored properties:If a type is Equatable, SwiftUI compares the old and new values using the type’s Equatable conformance. Otherwise:SwiftUI compares value types (e.g., structs) by recursively comparing each instance property.SwiftUI compares reference types (e.g., classes) using reference identity.SwiftUI attempts to compare closures by identity. However, most non-trivial closures cannot be compared reliably.If all of the view’s properties compare as equal to the previous value, then the body isn’t re-evalulated and the content isn’t re-rendered. Values using SwiftUI property wrappers like @State and @Environment don’t participate in this diffing algorithm, and instead trigger view updates through different mechanisms.When reviewing different views in our codebase, we found several common patterns that confounded SwiftUI’s diffing algorithm:Some types are inherently not supported, like closures.Simple data types stored on the view may be unexpectedly compared by reference instead of by value.Here’s an example SwiftUI view with properties that interact poorly with the diffing algorithm:struct MyView: View { /// A generated data model that is a struct with value semantics, /// but is copy-on-write and wraps an internal reference type. /// Compared by reference, not by value, which could cause unwanted body evaluations. let dataModel: CopyOnWriteDataModel /// Other miscellaneous properties used by the view. Typically structs, but sometimes a class. /// Unexpected comparisons by reference could cause unwanted body evaluations. let requestState: MyFeatureRequestState /// An action handler for this view, part of our unidirectional data flow library. /// Wraps a closure that routes the action to the screen's action handler. /// Closures almost always compare as not-equal, and typically cause unwanted body evaluations. let handler: Handler\u003cMyViewAction\u003e var body: some View { ... }}If a view contains any value that isn’t diffable, the entire view becomes non-diffable. Preventing this in a scalable way is almost impossible with existing tools. This finding also reveals the performance issue caused by our unidirectional data flow library: action handling is closure-based, but SwiftUI can’t diff closures!In some cases, like with the action handlers from our unidirectional data flow library, making the value diffable would require large, invasive, and potentially undesirable architecture changes. Even in simpler cases, this process is still time consuming, and there’s no easy way to prevent a regression from creeping in later on. This is a big obstacle when trying to improve and maintain performance at scale in large codebases with many different contributors.Controlling SwiftUI view diffingFortunately, we have another option: If a view conforms to Equatable, SwiftUI will diff it using its Equatable conformance instead of using the default reflection-based diffing algorithm.The advantage of this approach is that it lets us selectively decide which properties should be compared when diffing our view. In our case, we know that the handler object doesn’t affect the content or identity of our view. We only want our view to be re-evalulated and re-rendered when the dataModel and requestState values are updated. We can express that with a custom Equatable implementation:// An Equatable conformance that makes the above SwiftUI view diffable.extension MyView: Equatable { static func ==(lhs: MyView, rhs: MyView) -\u003e Bool { lhs.dataModel == rhs.dataModel \u0026\u0026 lhs.requestState == rhs.requestState // Intentionally not comparing handler, which isn't Equatable. }}However:This is a lot of additional boilerplate for engineers to write, especially for views with lots of properties.Writing and maintaining a custom conformance is error-prone. You can easily forget to update the Equatable conformance when adding new properties later, which would cause bugs.So, instead of manually writing and maintaining Equatable conformances, we created a new @Equatable macro that generates conformances for us.// A sample SwiftUI view that has adopted @Equatable// and is now guaranteed to be diffable.@Equatablestruct MyView: View { // Simple data types must be Equatable, or the build will fail. let dataModel: CopyOnWriteDataModel let requestState: MyFeatureRequestState // Types that aren't Equatable can be excluded from the // generated Equatable conformance using @SkipEquatable, // as long as they don’t affect the output of the view body. @SkipEquatable let handler: Handler\u003cMyViewAction\u003e var body: some View { ... }}The @Equatable macro generates an Equatable implementation that compares all of the view’s stored instance properties, excluding properties with SwiftUI property wrappers like@State and @Environment that trigger view updates through other mechanisms. Properties that aren’t Equatable and don’t affect the output of the view body can be marked with @SkipEquatable to exclude them from the generated implementation. This allows us to continue using the closure-based action handlers from our unidirectional data flow library without impacting the SwiftUI diffing process!After adopting the @Equatable macro on a view, that view is guaranteed to be diffable. If an engineer adds a non-Equatable property later, the build will fail, highlighting a potential regression in the diffing behavior. This effectively makes the @Equatable macro a sophisticated linter — which is really valuable for scaling these performance improvements in a codebase with many components and many contributors, since it makes it less likely for regressions to slip in later.Managing the size of view bodiesAnother essential aspect of SwiftUI diffing is understanding that SwiftUI can only diff proper View structs. Any other code, such as computed properties or helper functions that generate a SwiftUI view, cannot be diffed.Consider the following example:// Complex SwiftUI views are often simplified by// splitting the view body into separate computed properties.struct MyScreen: View { /// The unidirectional data flow state store for this feature. @ObservedObject var store: StateStore\u003cMyState, MyAction\u003e var body: some View { VStack { headerSection actionCardSection } } private var headerSection: some View { Text(store.state.titleString) .textStyle(.title) } private var actionCardSection: some View { VStack { Image(store.state.cardSelected ? \"enabled\" : \"disabled\") Text(\"This is a selectable card\") } .strokedCard(.roundedRect_mediumCornerRadius_12) .scaleEffectButton(action: { store.handle(.cardTapped) }) }}This is a common way to organize complex view bodies, since it makes the code easier to read and maintain. However, at runtime, SwiftUI effectively inlines the views returned from the properties into the main view body, as if we instead wrote:// At runtime, computed properties are no different// from just having a single, large view body!struct MyScreen: View { @ObservedObject var store: StateStore\u003cMyState, MyAction\u003e // Re-evaluated every time the state of the screen is updated. var body: some View { Text(store.state.titleString) .textStyle(.title) VStack { Image(store.state.cardSelected ? \"enabled\" : \"disabled\") Text(\"This is a selectable card\") } .strokedCard(.roundedRect_mediumCornerRadius_12) .scaleEffectButton(action: { store.handle(.cardTapped) }) }}Since all of this code is part of the same view body, all of it will be re-evaluated when any part of the screen’s state changes. While this specific example is simple, as the view grows larger and more complicated, re-evaluating it will become more expensive. Eventually there would be a large amount of unnecessary work happening on every screen update, hurting performance.To improve performance, we can implement the layout code in separate SwiftUI views. This allows SwiftUI to properly diff each child view, only re-evaluating their bodies when necessary:struct MyScreen: View { @ObservedObject var store: StateStore\u003cMyState, MyAction\u003e var body: some View { VStack { HeaderSection(title: store.state.titleString) CardSection( isCardSelected: store.state.isCardSelected, handler: store.handler) } }}/// Only re-evaluated and re-rendered when the title property changes.@Equatablestruct HeaderSection: View { let title: String var body: some View { Text(title) .textStyle(.title) }}/// Only re-evaluated and re-rendered when the isCardSelected property changes.@Equatablestruct CardSection: View { let isCardSelected: Bool @SkipEquatable let handler: Handler\u003cMyAction\u003e var body: some View { VStack { Image(store.state.isCardSelected ? \"enabled\" : \"disabled\") Text(\"This is a selectable card\") } .strokedCard(.roundedRect_mediumCornerRadius_12) .scaleEffectButton(action: { handler.handle(.cardTapped) }) }}By breaking the view into smaller, diffable pieces, SwiftUI can efficiently update only the parts of the view that actually changed. This approach helps maintain performance as a feature grows more complex.View body complexity lint ruleLarge, complex views aren’t always obvious during development. Easily available metrics like total line count aren’t a good proxy for complexity. To help engineers know when it’s time to refactor a view into smaller, diffable pieces, we created a custom SwiftLint rule that parses the view body using SwiftSyntax and measures its complexity. We defined the view complexity metric as a value that increases every time you compose views using computed properties, functions, or closures. With this rule we automatically trigger an alert in Xcode when a view is getting too complex. (The complexity limit is configurable, and we currently allow a maximum complexity level of 10.)The rule shows as a warning during local Xcode builds alerting engineers as early as possible. In this screenshot, the complexity limit is set to 3, and this specific view has a complexity of 5.ConclusionWith an understanding of how SwiftUI view diffing works, we can use an @Equatable macro to ensure view bodies are only re-evaluated when the values inside views actually change, break views into smaller parts for faster re-evaluation, and encourage developers to refactor views before they get too large and complex.Applying these three techniques to SwiftUI views in our app has led to a large reduction in unnecessary view re-evaluation and re-renders. Revisiting the examples from earlier, you see far fewer re-renders in the search bar and filter panel:Using results from our page performance score system, we’ve found that adopting these techniques in our most complicated SwiftUI screens really does improve performance for our users. For example, we reduced scroll hitches by 15% on our main Search screen by adopting @Equatable on its most important views, and breaking apart large view bodies into smaller diffable pieces. These techniques also give us the flexibility to use a feature architecture that best suits our needs without compromising performance or imposing burdensome limitations (e.g., completely avoiding closures in SwiftUI views).Of course, these techniques aren’t a silver bullet. It’s not necessary for all SwiftUI features to use them, and these techniques by themselves aren’t enough to guarantee great performance. However, understanding how and why they work serves as a valuable foundation for building performant SwiftUI features, and makes it easier to spot and avoid problematic patterns in your own code.If you’re interested in joining us on our quest to make the best iOS app in the App Store, please see our careers page for open iOS roles.",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*qBYJ9abMpZyuODmbHkYD5Q.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ch2 id=\"fca2\" data-testid=\"storyTitle\"\u003e\u003cstrong\u003eUnderstanding and Improving SwiftUI Performance\u003c/strong\u003e\u003c/h2\u003e\u003cdiv tabindex=\"-1\" aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://medium.com/@calstephens98?source=post_page---byline--37b77ac61896---------------------------------------\" data-discover=\"true\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Cal Stephens\" src=\"https://miro.medium.com/v2/resize:fill:64:64/1*_mdLFeRldMIbg6MCFe-DJQ.jpeg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cp id=\"7d50\"\u003eNew techniques we’re using at Airbnb to improve and maintain performance of SwiftUI features at scale\u003c/p\u003e\u003cp id=\"8049\"\u003eBy \u003ca href=\"https://www.linkedin.com/in/calstephens/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCal Stephens\u003c/a\u003e, \u003ca href=\"https://www.linkedin.com/in/miguel-jimenez-b98216112\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMiguel Jimenez\u003c/a\u003e\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"f5d5\"\u003eAirbnb \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/unlocking-swiftui-at-airbnb-ea58f50cde49\" data-discover=\"true\"\u003efirst adopted SwiftUI in 2022\u003c/a\u003e, starting with individual components and later expanding to entire screens and features. We’ve seen major improvements to engineers’ productivity thanks to its declarative, flexible, and composable architecture. However, adopting SwiftUI has brought new challenges related to performance. For example, there are many common code patterns in SwiftUI that can be inefficient, and many small papercuts can add up to a large cumulative performance hit. To begin addressing some of these issues at scale, we’ve created new tooling for proactively identifying these cases and statically validating correctness.\u003c/p\u003e\u003ch2 id=\"21b1\"\u003eSwiftUI feature architecture at Airbnb\u003c/h2\u003e\u003cp id=\"6a39\"\u003eWe’ve been leveraging declarative UI patterns at Airbnb for many years, using our UIKit-based \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-epoxy-for-ios-6bf062be1670\" data-discover=\"true\"\u003eEpoxy library\u003c/a\u003e and \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/introducing-epoxy-for-ios-6bf062be1670#fbe0\" data-discover=\"true\"\u003eunidirectional data flow\u003c/a\u003e systems. When adopting SwiftUI in our screen layer, we decided to continue using our existing unidirectional data flow library. This simplified the process of incrementally adopting SwiftUI within our large codebase, and we find it improves the quality and maintainability of features.\u003c/p\u003e\u003cp id=\"8863\"\u003eHowever, we noticed that SwiftUI features using our unidirectional data flow library didn’t perform as well as we expected, and it wasn’t immediately obvious to us what the problem was. Understanding SwiftUI’s performance characteristics is an important requirement for building performant and outside of the “standard” SwiftUI toolbox.\u003c/p\u003e\u003ch2 id=\"2fa3\"\u003eUnderstanding SwiftUI view diffing\u003c/h2\u003e\u003cp id=\"5841\"\u003eWhen working with declarative UI systems like SwiftUI, it’s important to ensure the framework knows which views need to be re-evaluated and re-rendered when the state of the screen changes. Changes are detected by diffing the view’s stored properties any time its parent is updated. Ideally the view’s body will only be re-evaluated when its properties actually change:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1b24\"\u003eHowever, this behavior is not always the reality (more on why in a moment). Unnecessary view body evaluations hurt performance by performing unnecessary work.\u003c/p\u003e\u003cp id=\"6e99\"\u003eHow do you know how often a view’s body is re-evaluated in a real app? An easy way to visualize this is with a modifier that applies a random color to the view every time it’s rendered. When testing this on various views in our app’s most performance-sensitive screens, we quickly found that many views were re-evaluated and re-rendered more often than necessary:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"8688\"\u003eThe SwiftUI view diffing algorithm\u003c/h2\u003e\u003cp id=\"2287\"\u003eSwiftUI’s built-in diffing algorithm is often overlooked and not officially documented, but it has a huge impact on performance. To determine if a view’s body needs to be re-evaluated, SwiftUI uses a reflection-based diffing algorithm to compare each of the view’s stored properties:\u003c/p\u003e\u003col\u003e\u003cli id=\"3445\"\u003eIf a type is \u003cem\u003eEquatable\u003c/em\u003e, SwiftUI compares the old and new values using the type’s \u003cem\u003eEquatable\u003c/em\u003e conformance. Otherwise:\u003c/li\u003e\u003cli id=\"b3dd\"\u003eSwiftUI compares value types (e.g., structs) by recursively comparing each instance property.\u003c/li\u003e\u003cli id=\"d263\"\u003eSwiftUI compares reference types (e.g., classes) using reference identity.\u003c/li\u003e\u003cli id=\"6503\"\u003eSwiftUI attempts to compare closures by identity. However, most non-trivial closures cannot be compared reliably.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"3b35\"\u003eIf all of the view’s properties compare as equal to the previous value, then the body isn’t re-evalulated and the content isn’t re-rendered. Values using SwiftUI property wrappers like\u003cem\u003e @State \u003c/em\u003eand \u003cem\u003e@Environment\u003c/em\u003e don’t participate in this diffing algorithm, and instead trigger view updates through different mechanisms.\u003c/p\u003e\u003cp id=\"7caf\"\u003eWhen reviewing different views in our codebase, we found several common patterns that confounded SwiftUI’s diffing algorithm:\u003c/p\u003e\u003col\u003e\u003cli id=\"ca6d\"\u003eSome types are inherently not supported, like closures.\u003c/li\u003e\u003cli id=\"62fa\"\u003eSimple data types stored on the view may be unexpectedly compared by reference instead of by value.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"ad3d\"\u003eHere’s an example SwiftUI view with properties that interact poorly with the diffing algorithm:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"0d40\"\u003estruct MyView: View {\u003cbr/\u003e  /// A generated data model that is a struct with value semantics,\u003cbr/\u003e  /// but is copy-on-write and wraps an internal reference type.\u003cbr/\u003e  /// Compared by reference, not by value, which could cause unwanted body evaluations.\u003cbr/\u003e  let dataModel: CopyOnWriteDataModel\u003cp\u003e  /// Other miscellaneous properties used by the view. Typically structs, but sometimes a class.\u003cbr/\u003e  /// Unexpected comparisons by reference could cause unwanted body evaluations.\u003cbr/\u003e  let requestState: MyFeatureRequestState\u003c/p\u003e\u003cp\u003e  /// An action handler for this view, part of our unidirectional data flow library. \u003cbr/\u003e  /// Wraps a closure that routes the action to the screen\u0026#39;s action handler.\u003cbr/\u003e  /// Closures almost always compare as not-equal, and typically cause unwanted body evaluations. \u003cbr/\u003e  let handler: Handler\u0026lt;MyViewAction\u0026gt;\u003c/p\u003e\u003cp\u003e  var body: some View { ... }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"b83f\"\u003eIf a view contains any value that isn’t diffable, the entire view becomes non-diffable. Preventing this in a scalable way is almost impossible with existing tools. This finding also reveals the performance issue caused by our unidirectional data flow library: action handling is closure-based, but SwiftUI can’t diff closures!\u003c/p\u003e\u003cp id=\"655d\"\u003eIn some cases, like with the action handlers from our unidirectional data flow library, making the value diffable would require large, invasive, and potentially undesirable architecture changes. Even in simpler cases, this process is still time consuming, and there’s no easy way to prevent a regression from creeping in later on. This is a big obstacle when trying to improve and maintain performance at scale in large codebases with many different contributors.\u003c/p\u003e\u003ch2 id=\"d1a2\"\u003eControlling SwiftUI view diffing\u003c/h2\u003e\u003cp id=\"89a9\"\u003eFortunately, we have another option: If a view conforms to Equatable, SwiftUI will diff it using its Equatable conformance \u003cem\u003einstead\u003c/em\u003e of using the default reflection-based diffing algorithm.\u003c/p\u003e\u003cp id=\"8e46\"\u003eThe advantage of this approach is that it lets us selectively decide which properties should be compared when diffing our view. In our case, we know that the handler object doesn’t affect the content or identity of our view. We only want our view to be re-evalulated and re-rendered when the \u003cem\u003edataModel\u003c/em\u003e and \u003cem\u003erequestState\u003c/em\u003e values are updated. We can express that with a custom \u003cem\u003eEquatable\u003c/em\u003e implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ff79\"\u003e// An Equatable conformance that makes the above SwiftUI view diffable.\u003cbr/\u003eextension MyView: Equatable {\u003cbr/\u003e  static func ==(lhs: MyView, rhs: MyView) -\u0026gt; Bool {\u003cbr/\u003e    lhs.dataModel == rhs.dataModel\u003cbr/\u003e      \u0026amp;\u0026amp; lhs.requestState == rhs.requestState\u003cbr/\u003e      // Intentionally not comparing handler, which isn\u0026#39;t Equatable.\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f9de\"\u003eHowever:\u003c/p\u003e\u003col\u003e\u003cli id=\"97d7\"\u003eThis is a lot of additional boilerplate for engineers to write, especially for views with lots of properties.\u003c/li\u003e\u003cli id=\"de77\"\u003eWriting and maintaining a custom conformance is error-prone. You can easily forget to update the \u003cem\u003eEquatable\u003c/em\u003e conformance when adding new properties later, which would cause bugs.\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"9a18\"\u003eSo, instead of manually writing and maintaining \u003cem\u003eEquatable\u003c/em\u003e conformances, we created a new\u003cem\u003e @Equatable \u003c/em\u003emacro that generates conformances for us.\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"7850\"\u003e// A sample SwiftUI view that has adopted @Equatable\u003cbr/\u003e// and is now guaranteed to be diffable.\u003cbr/\u003e@Equatable\u003cbr/\u003estruct MyView: View {\u003cbr/\u003e  // Simple data types must be Equatable, or the build will fail.\u003cbr/\u003e  let dataModel: CopyOnWriteDataModel\u003cbr/\u003e  let requestState: MyFeatureRequestState\u003cp\u003e  // Types that aren\u0026#39;t Equatable can be excluded from the\u003cbr/\u003e  // generated Equatable conformance using @SkipEquatable,\u003cbr/\u003e  // as long as they don’t affect the output of the view body.\u003cbr/\u003e  @SkipEquatable let handler: Handler\u0026lt;MyViewAction\u0026gt;\u003c/p\u003e\u003cp\u003e  var body: some View { ... }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2551\"\u003eThe \u003cem\u003e@Equatable\u003c/em\u003e macro generates an \u003cem\u003eEquatable\u003c/em\u003e implementation that compares all of the view’s stored instance properties, excluding properties with SwiftUI property wrappers like\u003cem\u003e@State \u003c/em\u003eand \u003cem\u003e@Environment\u003c/em\u003e that trigger view updates through other mechanisms. Properties that aren’t \u003cem\u003eEquatable\u003c/em\u003e and don’t affect the output of the view body can be marked with \u003cem\u003e@SkipEquatable\u003c/em\u003e to exclude them from the generated implementation. This allows us to continue using the closure-based action handlers from our unidirectional data flow library without impacting the SwiftUI diffing process!\u003c/p\u003e\u003cp id=\"1055\"\u003eAfter adopting the \u003cem\u003e@Equatable\u003c/em\u003e macro on a view, that view is guaranteed to be diffable. If an engineer adds a non-\u003cem\u003eEquatable\u003c/em\u003e property later, the build will fail, highlighting a potential regression in the diffing behavior. This effectively makes the \u003cem\u003e@Equatable\u003c/em\u003e macro a sophisticated linter — which is really valuable for scaling these performance improvements in a codebase with many components and many contributors, since it makes it less likely for regressions to slip in later.\u003c/p\u003e\u003ch2 id=\"65ab\"\u003eManaging the size of view bodies\u003c/h2\u003e\u003cp id=\"8976\"\u003eAnother essential aspect of SwiftUI diffing is understanding that SwiftUI can only diff proper View structs. Any other code, such as computed properties or helper functions that generate a SwiftUI view, cannot be diffed.\u003c/p\u003e\u003cp id=\"affb\"\u003eConsider the following example:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5455\"\u003e// Complex SwiftUI views are often simplified by\u003cbr/\u003e// splitting the view body into separate computed properties.\u003cbr/\u003estruct MyScreen: View {\u003cbr/\u003e  /// The unidirectional data flow state store for this feature.\u003cbr/\u003e  @ObservedObject var store: StateStore\u0026lt;MyState, MyAction\u0026gt;\u003cp\u003e  var body: some View {\u003cbr/\u003e    VStack {\u003cbr/\u003e      headerSection\u003cbr/\u003e      actionCardSection\u003cbr/\u003e    }\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  private var headerSection: some View {\u003cbr/\u003e    Text(store.state.titleString)\u003cbr/\u003e      .textStyle(.title)\u003cbr/\u003e  }\u003c/p\u003e\u003cp\u003e  private var actionCardSection: some View {\u003cbr/\u003e    VStack {\u003cbr/\u003e      Image(store.state.cardSelected ? \u0026#34;enabled\u0026#34; : \u0026#34;disabled\u0026#34;)\u003cbr/\u003e      Text(\u0026#34;This is a selectable card\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    .strokedCard(.roundedRect_mediumCornerRadius_12)\u003cbr/\u003e    .scaleEffectButton(action: {\u003cbr/\u003e      store.handle(.cardTapped) \u003cbr/\u003e    })\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"150a\"\u003eThis is a common way to organize complex view bodies, since it makes the code easier to read and maintain. However, at runtime, SwiftUI effectively inlines the views returned from the properties into the main view body, as if we instead wrote:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"8144\"\u003e// At runtime, computed properties are no different\u003cbr/\u003e// from just having a single, large view body!\u003cbr/\u003estruct MyScreen: View {\u003cbr/\u003e  @ObservedObject var store: StateStore\u0026lt;MyState, MyAction\u0026gt;\u003cp\u003e  // Re-evaluated every time the state of the screen is updated.\u003cbr/\u003e  var body: some View {\u003cbr/\u003e    Text(store.state.titleString)\u003cbr/\u003e      .textStyle(.title)\u003c/p\u003e\u003cp\u003e    VStack {\u003cbr/\u003e      Image(store.state.cardSelected ? \u0026#34;enabled\u0026#34; : \u0026#34;disabled\u0026#34;)\u003cbr/\u003e      Text(\u0026#34;This is a selectable card\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    .strokedCard(.roundedRect_mediumCornerRadius_12)\u003cbr/\u003e    .scaleEffectButton(action: {\u003cbr/\u003e      store.handle(.cardTapped) \u003cbr/\u003e    })\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"a040\"\u003eSince all of this code is part of the same view body, all of it will be re-evaluated when any part of the screen’s state changes. While this specific example is simple, as the view grows larger and more complicated, re-evaluating it will become more expensive. Eventually there would be a large amount of unnecessary work happening on every screen update, hurting performance.\u003c/p\u003e\u003cp id=\"f96e\"\u003eTo improve performance, we can implement the layout code in separate SwiftUI views. This allows SwiftUI to properly diff each child view, only re-evaluating their bodies when necessary:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1105\"\u003estruct MyScreen: View {\u003cbr/\u003e  @ObservedObject var store: StateStore\u0026lt;MyState, MyAction\u0026gt;\u003cp\u003e  var body: some View {\u003cbr/\u003e    VStack {\u003cbr/\u003e      HeaderSection(title: store.state.titleString)\u003cbr/\u003e      CardSection(\u003cbr/\u003e       isCardSelected: store.state.isCardSelected,\u003cbr/\u003e       handler: store.handler)\u003cbr/\u003e    }\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e/// Only re-evaluated and re-rendered when the title property changes.\u003cbr/\u003e@Equatable\u003cbr/\u003estruct HeaderSection: View {\u003cbr/\u003e  let title: String\u003c/p\u003e\u003cp\u003e  var body: some View {\u003cbr/\u003e    Text(title)\u003cbr/\u003e      .textStyle(.title)\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e/// Only re-evaluated and re-rendered when the isCardSelected property changes.\u003cbr/\u003e@Equatable\u003cbr/\u003estruct CardSection: View {\u003cbr/\u003e  let isCardSelected: Bool\u003cbr/\u003e  @SkipEquatable let handler: Handler\u0026lt;MyAction\u0026gt;\u003c/p\u003e\u003cp\u003e  var body: some View {\u003cbr/\u003e    VStack {\u003cbr/\u003e      Image(store.state.isCardSelected ? \u0026#34;enabled\u0026#34; : \u0026#34;disabled\u0026#34;)\u003cbr/\u003e      Text(\u0026#34;This is a selectable card\u0026#34;)\u003cbr/\u003e    }\u003cbr/\u003e    .strokedCard(.roundedRect_mediumCornerRadius_12)\u003cbr/\u003e    .scaleEffectButton(action: {\u003cbr/\u003e      handler.handle(.cardTapped) \u003cbr/\u003e    })\u003cbr/\u003e  }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"eb39\"\u003eBy breaking the view into smaller, diffable pieces, SwiftUI can efficiently update only the parts of the view that actually changed. This approach helps maintain performance as a feature grows more complex.\u003c/p\u003e\u003ch2 id=\"3869\"\u003eView body complexity lint rule\u003c/h2\u003e\u003cp id=\"3e58\"\u003eLarge, complex views aren’t always obvious during development. Easily available metrics like total line count aren’t a good proxy for complexity. To help engineers know when it’s time to refactor a view into smaller, diffable pieces, we created a custom \u003ca href=\"https://github.com/realm/SwiftLint\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSwiftLint\u003c/a\u003e rule that parses the view body using \u003ca href=\"https://github.com/swiftlang/swift-syntax\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSwiftSyntax\u003c/a\u003e and measures its complexity. We defined the view complexity metric as a value that increases every time you compose views using computed properties, functions, or closures. With this rule we automatically trigger an alert in Xcode when a view is getting too complex. (The complexity limit is configurable, and we currently allow a maximum complexity level of 10.)\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eThe rule shows as a warning during local Xcode builds alerting engineers as early as possible. In this screenshot, the complexity limit is set to 3, and this specific view has a complexity of 5.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"c15f\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"ed7c\"\u003eWith an understanding of how SwiftUI view diffing works, we can use an \u003cem\u003e@Equatable\u003c/em\u003e macro to ensure view bodies are only re-evaluated when the values inside views actually change, break views into smaller parts for faster re-evaluation, and encourage developers to refactor views before they get too large and complex.\u003c/p\u003e\u003cp id=\"3882\"\u003eApplying these three techniques to SwiftUI views in our app has led to a large reduction in unnecessary view re-evaluation and re-renders. Revisiting the examples from earlier, you see far fewer re-renders in the search bar and filter panel:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"083c\"\u003eUsing results from our \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-ios-36d5f200bc73\" data-discover=\"true\"\u003epage performance score\u003c/a\u003e system, we’ve found that adopting these techniques in our most complicated SwiftUI screens really does improve performance for our users. For example, we reduced \u003ca rel=\"noopener\" href=\"https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-ios-36d5f200bc73#4c63\" data-discover=\"true\"\u003escroll hitches\u003c/a\u003e by\u003cstrong\u003e \u003c/strong\u003e15% on our main Search screen by adopting \u003cem\u003e@Equatable\u003c/em\u003e on its most important views, and breaking apart large view bodies into smaller diffable pieces. These techniques also give us the flexibility to use a feature architecture that best suits our needs without compromising performance or imposing burdensome limitations (e.g., completely avoiding closures in SwiftUI views).\u003c/p\u003e\u003cp id=\"91b5\"\u003eOf course, these techniques aren’t a silver bullet. It’s not necessary for all SwiftUI features to use them, and these techniques by themselves aren’t enough to guarantee great performance. However, understanding how and why they work serves as a valuable foundation for building performant SwiftUI features, and makes it easier to spot and avoid problematic patterns in your own code.\u003c/p\u003e\u003cp id=\"4eb4\"\u003eIf you’re interested in joining us on our quest to make the best iOS app in the App Store, please see our \u003ca href=\"https://careers.airbnb.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ecareers\u003c/a\u003e page for open iOS roles.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": "2025-06-24T16:43:07.673Z",
  "modifiedTime": null
}
