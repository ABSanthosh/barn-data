{
  "id": "59350fff-6857-45e1-906a-b713c4900977",
  "title": "Introducing Annotated Logger: A Python package to aid in adding metadata to logs",
  "link": "https://github.blog/developer-skills/programming-languages-and-frameworks/introducing-annotated-logger-a-python-package-to-aid-in-adding-metadata-to-logs/",
  "description": "We’re open sourcing Annotated Logger, a Python package that helps make logs searchable with consistent metadata. The post Introducing Annotated Logger: A Python package to aid in adding metadata to logs appeared first on The GitHub Blog.",
  "author": "Joseph Henrich",
  "published": "Thu, 19 Dec 2024 17:00:28 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Developer skills",
    "Programming languages \u0026 frameworks",
    "logging",
    "open source",
    "python"
  ],
  "byline": "Joseph Henrich",
  "length": 25777,
  "excerpt": "We’re open sourcing Annotated Logger, a Python package that helps make logs searchable with consistent metadata.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "What it is Annotated Logger is a Python package that allows you to decorate functions and classes, which then log when complete and can request a customized logger object, which has additional fields pre-added. GitHub’s Vulnerability Management team created this tool to make it easier to find and filter logs in Splunk. Why we made it We have several Python projects that have grown in complexity over the years and have used Splunk to ingest and search those logs. We have always sent our logs in via JSON, which makes it easy to add in extra fields. However, there were a number of fields, like what Git branch was deployed, that we also wanted to send, plus, there were fields, like the CVE name of the vulnerability being processed, that we wanted to add for messages in a given function. Both are possible with the base Python logger, but it’s a lot of manual work repeating the same thing over and over, or building and managing a dictionary of extra fields that are included in every log message. The Annotated Logger started out as a simple decorator in one of our repositories, but was extracted into a package in its own right as we started to use it in all of our projects. As we’ve continued to use it, its features have grown and been updated. How and why to use it Now that I’ve gotten a bit of the backstory out of the way, here’s what it does, why you should use it, and how to configure it for your specific needs. At its simplest, you decorate a function with @annotate_logs() and it will “just work.” If you’d like to dive right in and poke around, the example folder contains examples that fully exercise the features. @annotate_logs() def foo(): return True \u003e\u003e\u003e foo() {\"created\": 1733176439.5067494, \"levelname\": \"DEBUG\", \"name\": \"annotated_logger.8fcd85f5-d47f-4925-8d3f-935d45ceeefc\", \"message\": \"start\", \"action\": \"__main__:foo\", \"annotated\": true} {\"created\": 1733176439.506998, \"levelname\": \"INFO\", \"name\": \"annotated_logger.8fcd85f5-d47f-4925-8d3f-935d45ceeefc\", \"message\": \"success\", \"action\": \"__main__:foo\", \"success\": true, \"run_time\": \"0.0\", \"annotated\": true} True Here is a more complete example that makes use of a number of the features. Make sure to install the package: pip install annotated-logger first. import os from annotated_logger import AnnotatedLogger al = AnnotatedLogger( name=\"annotated_logger.example\", annotations={\"branch\": os.environ.get(\"BRANCH\", \"unknown-branch\")} ) annotate_logs = al.annotate_logs @annotate_logs() def split_username(annotated_logger, username): annotated_logger.annotate(username=username) annotated_logger.info(\"This is a very important message!\", extra={\"important\": True}) return list(username) \u003e\u003e\u003e split_username(\"crimsonknave\") {\"created\": 1733349907.7293086, \"levelname\": \"DEBUG\", \"name\": \"annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\", \"message\": \"start\", \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"annotated\": true} {\"created\": 1733349907.7296104, \"levelname\": \"INFO\", \"name\": \"annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\", \"message\": \"This is a very important message!\", \"important\": true, \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"username\": \"crimsonknave\", \"annotated\": true} {\"created\": 1733349907.729843, \"levelname\": \"INFO\", \"name\": \"annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\", \"message\": \"success\", \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"username\": \"crimsonknave\", \"success\": true, \"run_time\": \"0.0\", \"count\": 12, \"annotated\": true} ['c', 'r', 'i', 'm', 's', 'o', 'n', 'k', 'n', 'a', 'v', 'e'] \u003e\u003e\u003e \u003e\u003e\u003e split_username(1) {\"created\": 1733349913.719831, \"levelname\": \"DEBUG\", \"name\": \"annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\", \"message\": \"start\", \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"annotated\": true} {\"created\": 1733349913.719936, \"levelname\": \"INFO\", \"name\": \"annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\", \"message\": \"This is a very important message!\", \"important\": true, \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"username\": 1, \"annotated\": true} {\"created\": 1733349913.7200255, \"levelname\": \"ERROR\", \"name\": \"annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\", \"message\": \"Uncaught Exception in logged function\", \"exc_info\": \"Traceback (most recent call last):\\n File \\\"/home/crimsonknave/code/annotated-logger/annotated_logger/__init__.py\\\", line 758, in wrap_function\\n result = wrapped(*new_args, **new_kwargs) # pyright: ignore[reportCallIssue]\\n File \\\"\u003cstdin\u003e\\\", line 5, in split_username\\nTypeError: 'int' object is not iterable\", \"action\": \"__main__:split_username\", \"branch\": \"unknown-branch\", \"username\": 1, \"success\": false, \"exception_title\": \"'int' object is not iterable\", \"annotated\": true} Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e File \"\u003cmakefun-gen-0\u003e\", line 2, in split_username File \"/home/crimsonknave/code/annotated-logger/annotated_logger/__init__.py\", line 758, in wrap_function result = wrapped(*new_args, **new_kwargs) # pyright: ignore[reportCallIssue] File \"\u003cstdin\u003e\", line 5, in split_username TypeError: 'int' object is not iterable There are a few things going on in this example. Let’s break it down piece by piece. The Annotated Logger requires a small amount of setup to use; specifically, you need to instantiate an instance of the AnnotatedLogger class. This class contains all of the configuration for the loggers. Here we set the name of the logger. (You will need to update the logging config if your name does not start with annotated_logger or there will be nothing configured to log your messages.) We also set a branch annotation that will be sent with all log messages. After that, we create an alias for the decorator. You don’t have to do this, but I find it’s easier to read than @al.annotate_logs(). Now, we decorate and define our method, but this time we’re going to ask the decorator to provide us with a logger object, annotated_logger. This annotated_logger variable can be used just like a standard logger object but has some extra features. This annotated_logger argument is added by the decorator before calling the decorated method. The signature of the decorated method is adjusted so that it does not have an annotated_logger parameter (see how it’s called with just name). There are optional parameters to the decorator that allow type hints to correctly parse the modified signature. We make use of one of those features right away by calling the annotate method, which will add whatever kwargs we pass to the extra field of all log messages that use the logger. Any field added as an annotation will be included in each subsequent log message that uses that logger. You can override an annotation by annotating again with the same name At last, we send a log message! In this message we also pass in a field that’s only for that log message, in the same way you would when using logger. In the second call, we passed an int to the name field and list threw an exception. This exception is logged automatically and then re-raised. This makes it much easier to know if/when a method ended (unless the process was killed). Let’s break down each of the fields in the log message: Field Source Description created logging Standard Logging field. levelname logging Standard Logging field. name annotated_logger Logger name (set via class instantiation). message logging Standard Logging field for log content. action annotated_logger Method name the logger was created for. branch AnnotatedLogger() Set from the configuration’s branch annotation. annotated annotated_logger Boolean indicating if the message was sent via Annotated Logger. important annotated_logger.info Annotation set for a specific log message. username annotated_logger.annotate Annotation set by user. success annotated_logger Indicates if the method completed successfully (True/False). run_time annotated_logger Duration of the method execution. count annotated_logger Length of the return value (if applicable). The success, run_time and count fields are added automatically to the message (“success”) that is logged after a decorated method is completed without an exception being raised. Under the covers How it’s implemented The Annotated Logger interacts with Logging via two main classes: AnnotatedAdapter and AnnotatedFilter. AnnotatedAdapter is a subclass of logging.LoggerAdapter and is what all annotated_logger arguments are instances of. AnnotatedFilter is a subclass of logging.Filter and is where the annotations are actually injected into the log messages. As a user outside of config and plugins, the only part of the code you will only interact with are AnnotatedAdapter in methods and the decorator itself. Each instance of the AnnotatedAdapter class has an AnnotatedFilter instance—the AnnotatedAdapter.annotate method passes those annotations on to the filter where they are stored. When a message is logged, that filter will calculate all the annotations it should have and then update the existing LogRecord object with those annotations. Because each invocation of a method gets its own AnnotatedAdapter object it also has its own AnnotatedFilter object. This ensures that there is no leaking of annotations from one method call to another. Type hinting The Annotated Logger is fully type hinted internally and fully supports type hinting of decorated methods. But a little bit of additional detail is required in the decorator invocation. The annotate_logs method takes a number of optional arguments. For type hinting, _typing_self, _typing_requested, _typing_class and provided are relevant. The three arguments that start with _typing have no impact on the behavior of the decorator and are only used in method signature overrides for type hinting. Setting provided to True tells the decorator that the annotated_logger should not be created and will be provided by the caller (thus the signature shouldn’t be altered). _typing_self defaults to True as that is how most of my code is written. provided, _typing_class and _typing_requested default to False. class Example: @annotate_logs(_typing_requested=True) def foo(self, annotated_logger): ... e = Example() e.foo() Plugins There are a number of plugins that come packaged with the Annotated Logger. Plugins allow for the user to hook into two places: when an exception is caught by the decorator and when logging a message. You can create your own plugin by creating a class that defines the filter and uncaught_exception methods (or inherits from annotated_logger.plugins.BasePlugin which provides noop methods for both). The filter method of a plugin is called when a message is being logged. Plugins are called in the order they are set in the config. They are called by the AnnotatedFilter object of the AnnotatedAdapter and work like any logging.Filter. They take a record argument which is a logging.LogRecord object. They can manipulate that record in any way they want and those modifications will persist. Additionally, just like any logging filter, they can stop a message from being logged by returning False. The uncaught_exception method of a plugin is called when the decorator catches an exception in the decorated method. It takes two arguments, exception and logger. The logger argument is the annotated_logger for the decorated method. This allows the plugin to annotate the log message stating that there was an uncaught exception that is about to be logged once the plugins have all processed their uncaught_exception methods. Here is an example of a simple plugin. The plugin inherits from the BasePlugin, which isn’t strictly needed here since it implements both filter and uncaught_exception, but if it didn’t, inheriting from the BasePlugin means that it would fall back to the default noop methods. The plugin has an init so that it can take and store arguments. The filter and uncaught_exception methods will end up with the same result: flagged=True being set if a word matches. But they do it slightly differently, filter is called while a given log message is being processed and so the annotation it adds is directly to that record. While uncaught_exception is called if an exception is raised and not caught during the execution of the decorated method, so it doesn’t have a specific log record to interact with and set an annotation on the logger. The only difference in outcome would be if another plugin emitted a log message during its uncaught_exception method after FlagWordPlugin, in that case, the additional log message would also have flagged=True on it. from annotated_logger.plugins import BasePlugin class FlagWordPlugin(BasePlugin): \"\"\"Plugin that flags any log message/exception that contains a word in a list.\"\"\" def __init__(self, *wordlist): \"\"\"Save the wordlist.\"\"\" self.wordlist = wordlist def filter(self, record): \"\"\"Add annotation if the message contains words in the wordlist.\"\"\" for word in self.wordlist: if word in record.msg: record.flagged = True def uncaught_exception(self, exception, logger): \"\"\"Add annotation if exception title contains words in the wordlist.\"\"\" for word in self.wordlist: if word in str(exception) logger.annotate(flagged=True) AnnotatedLogger(plugins=[FlagWordPlugin(\"danger\", \"Will Robinson\")]) Plugins are stored in a list and the order they are added can matter. The BasePlugin is always the first plugin in the list; any that are set in configuration are added after it. When a log message is being sent the filter methods of each plugin will be called in the order they appear in the list. Because the filter methods often modify the record directly, one filter can break another if, for example, one filter removed or renamed a field that another filter used. Conversely, one filter could expect another to have added or altered a field before its run and would fail if it was ahead of the other filter. Finally, just like in the logging module, the filter method can stop a log from being emitted by returning False. As soon as a filter does so the processing ends and any Plugins later in the list will not have their filter methods called. If the decorated method raises an exception that is not caught, then the plugins will again execute in order. The most common interaction is plugins attempting to set/modify the same annotation. The BasePlugin and RequestsPlugin both set the exception_title annotation. Since the BasePlugin is always first, the title it sets will be overridden. Other interactions would be one plugin setting an annotation before or after another plugin that emits a log message or sends data to a third-party. In both of those cases the order will impact if the annotation is present or not. Plugins that come with the Annotated Logger: GitHubActionsPlugin—Set a level of log messages to also be emitted in actions notation (notice::). NameAdjusterPlugin—Add a pre/postfix to a name to avoid collisions in any log processing software (source is a field in Splunk, but we often include it as a field and it’s just hidden). RemoverPlugin—Remove a field. Exclude password/key fields and set an object’s attributes to the log if you want or ignore fields like taskName that are set when running async, but not sync. NestedRemoverPlugin—Remove a field no matter how deep in a dictionary it is. RenamerPlugin—Rename one field to another (don’t like levelname and want level, this is how you do that). RequestsPlugin—Adds a title and status code to the annotations if the exception inherits from requests.exceptions.HTTPError. RuntimeAnnotationsPlugin—Sets dynamic annotations. dictconfig When adding the Annotated Logger to an existing project, or one that uses other packages that log messages (flask, django, and so on), you can configure all of the Annotated Logger via dictConfig by supplying a dictConfig compliant dictionary as the config argument when initializing the Annotated Logger class. If, instead, you wish to do this yourself you can pass config=False and reference annotated_logger.DEFAULT_LOGGING_CONFIG to obtain the config that is used when none is provided and alter/extract as needed. There is one special case where the Annotated Logger will modify the config passed to it: if there is a filter named annotated_filter that entry will be replaced with a reference to a filter that is created by the instance of the Annotated Logger that’s being created. This allows any annotations or other options set to be applied to messages that use that filter. You can instead create a filter that uses the AnnotatedFilter class, but it won’t have any of the config the rest of your logs have. Notes dictConfig partly works when merging dictionaries. I have found that some parts of the config are not overwritten, but other parts seem to lose their references. So, I would encourage you to build up a logging config for everything and call it once only. If you pass config, the Annotated Logger will call logging.config.dictConfig on your config after it has the option to add/adjust the config. The logging_config.py example has a much more detailed breakdown and set of examples. Pytest mock Included with the package is a pytest mock to assist in testing for logged messages. I know that there are some strong opinions about testing log messages, and I don’t suggest doing it extensively, or frequently, but sometimes it’s the easiest way to check a loop, or the log message is tied to an alert, and it is important how it’s formatted. In these cases, you can ask for the annotated_logger_mock fixture which will intercept, record and forward all log messages. def test_logs(annotated_logger_mock): with pytest.raises(KeyError): complicated_method() annotated_logger_mock.assert_logged( \"ERROR\", # Log level \"That's not the right key\", # Log message present={\"success\": False, \"key\": \"bad-key\"}, # annotations and their values that are required absent=[\"fake-annotations\"], # annotations that are forbidden count=1 # Number of times log messages should match ) The assert_logged method makes use of pychoir for flexible matching. None of the parameters are required, so feel free to use whichever makes sense. Below is a breakdown of the default and valid values for each parameter. Parameter Default Value Valid Values Description level Matches anything String or string-based matcher Log level to check (e.g., “ERROR”). message Matches anything String or string-based matcher Log message to check. present Empty dictionary Dictionary with string keys and any value Annotations required in the log. absent Empty set `ALL`, set, or list of strings Annotations that must not be present in the log. count All positive integers Integer or integer-based matcher Number of times the log message should match. The present key is often what makes the mock truly useful. It allows you to require the things you care about and ignore the things you don’t care about. For example, nobody wants their tests to fail because the run_time of a method went from 0.0 to 0.1 or fail because the hostname is different on different test machines. But both of those are useful things to have in the logs. This mock should replace everything you use the caplog fixture for and more. Other features Class decorators and persist Classes can be decorated with @annotate_logs as well. These classes will have an annotated_logger attribute added after the init (I was unable to get it to work inside the __init__). Any decorated methods of that class will have an annotated_logger that’s based on the class logger. Calls to annotate that pass persist=True will set the annotations on the class Annotated Logger and so subsequent calls of any decorated method of that instance will have those annotations. The class instance’s annotated_logger will also have an annotation of class specifying which class the logs are coming from. Iterators The Annotated Logger also supports logging iterations of an enumerable object. annotated_logger.iterator will log the start, each step of the iteration, and when the iteration is complete. This can be useful for pagination in an API if your results object is enumerable, logging each time a page is fetched instead of sitting for a long time with no indication if the pages are hanging or there are simply many pages. By default the iterator method will log the value of each iteration, but this can be disabled by setting value=False. You can also specify the level to log the iterations at if you don’t want the default of info. Provided Because each decorated method gets its own annotated_logger calls to other methods will not have any annotations from the caller. Instead of simply passing the annotated_logger object to the method being called, you can specify provided=True in the decorator invocation. This does two things: first, it means that this method won’t have an annotated_logger created and passed automatically, instead it requires that the first argument be an existing annotated_logger, which it will use as a basis for the annotated_logger object it creates for the function. Second, it adds the annotation of subaction and sets the decorated function’s name as its value, the action annotation is preserved as from the method that called and provided the annotated_logger. Annotations are not persisted from a method decorated with provided=True to the method that called it, unless the class of the calling method was decorated and the called action annotated with persist=True, in which case the annotation is set on the annotated_logger of the instance and shared with all methods as is normal for decorated classes. The most common use of this is with private methods, especially ones created during a refactor to extract some self contained logic. But other uses are for common methods that are called from a number of different places. Split messages Long messages wreak havoc on log parsing tools. I’ve encountered cases where the HTML of a 500 error page was too long for Splunk to parse, causing the entire log entry to be discarded and its annotations to go unprocessed. Setting max_length when configuring the Annotated Logger will break long messages into multiple log messages each annotated with split=True, split_complete=False, message_parts=# and message_part=#. The last part of the long message will have split_complete=True when it is logged. Only messages can be split like this; annotations will not trigger the splitting. However, a plugin could truncate any values with a length over a certain size. Pre/Post hooks You can register hooks that are executed before and after the decorated method is called. The pre_call and post_call parameters of the decorator take a reference to a function and will call that function right before passing in the same arguments that the function will be/was called with. This allows the hooks to add annotations and/or log anything that is desired (assuming the decorated function requested an annotated_logger). Examples of this would be having a set of annotations that annotate fields on a model and a pre_call that sets them in a standard way. Or a post_call that logs if the function left a model in an unsaved state. Runtime annotations Most annotations are static, but sometimes you need something that’s dynamic. These are achieved via the RuntimeAnnotationsPlugin in the Annotated Logger config. The RuntimeAnnotationsPlugin takes a dict of names and references to functions. These functions will be called and passed the log record when the plugin’s filter method is invoked just before the log message is emitted. Whatever is returned by the function will be set as the value of the annotation of the log message currently being logged. A common use case is to annotate a request/correlation id, which identifies all of the log messages that were part of a given API request. For Django, one way to do this is via django-guid. Tips, tricks and gotchas When using the decorator in more than one file, it’s useful to do all of the configuration in a file like log.py. That allows you to from project.log import annotate_logs everywhere you want to use it and you know it’s all configured and everything will be using the same setup. Namespacing your loggers helps when there are two projects that both use the Annotated Logger (a package and a service that uses the package). If you are setting anything via dictConfig you will want to have a single config that has everything for all Annotated Loggers. In addition to setting a correlation id for the API request being processed, passing the correlation id of the caller and then annotating that will allow you to trace from the logs of service A to the specific logs in Service B that relate to a call made by service A. Plugins are very flexible. For example: Send every exception log message to a service like Sentry. Suppress logs from another package, like Django, that you don’t want to see (assuming you’ve configured Django’s logs to use a filter for your Annotated Logger). Add annotations for extra information about specific types of exceptions (see the RequestsPlugin). Set run time annotations on a subset of messages (instead of all messages with RuntimeAnnotationsPlugin) Questions, feedback and requests We’d love to hear any questions, comments or requests you might have in an issue. Pull requests welcome as well! Written by Senior Software Engineer, GitHub",
  "image": "https://github.blog/wp-content/uploads/2024/02/Productivity-DarkMode-2-2.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003ch2 id=\"what-it-is\" id=\"what-it-is\"\u003eWhat it is\u003ca href=\"#what-it-is\" aria-label=\"What it is\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/github/annotated-logger\"\u003eAnnotated Logger\u003c/a\u003e is a Python package that allows you to decorate functions and classes, which then log when complete and can request a customized logger object, which has additional fields pre-added. GitHub’s Vulnerability Management team created this tool to make it easier to find and filter logs in Splunk.\u003c/p\u003e\n\u003ch2 id=\"why-we-made-it\" id=\"why-we-made-it\"\u003eWhy we made it\u003ca href=\"#why-we-made-it\" aria-label=\"Why we made it\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe have several Python projects that have grown in complexity over the years and have used Splunk to ingest and search those logs. We have always sent our logs in via JSON, which makes it easy to add in extra fields. However, there were a number of fields, like what Git branch was deployed, that we also wanted to send, plus, there were fields, like the CVE name of the vulnerability being processed, that we wanted to add for messages in a given function. Both are possible with the base Python logger, but it’s a lot of manual work repeating the same thing over and over, or building and managing a dictionary of extra fields that are included in every log message.\u003c/p\u003e\n\u003cp\u003eThe Annotated Logger started out as a simple decorator in one of our repositories, but was extracted into a package in its own right as we started to use it in all of our projects. As we’ve continued to use it, its features have grown and been updated.\u003c/p\u003e\n\u003ch2 id=\"how-and-why-to-use-it\" id=\"how-and-why-to-use-it\"\u003eHow and why to use it\u003ca href=\"#how-and-why-to-use-it\" aria-label=\"How and why to use it\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow that I’ve gotten a bit of the backstory out of the way, here’s what it does, why you should use it, and how to configure it for your specific needs. At its simplest, you decorate a function with \u003ccode\u003e@annotate_logs()\u003c/code\u003e and it will “just work.” If you’d like to dive right in and poke around, the \u003ca href=\"https://github.com/github/annotated-logger/tree/main/example\"\u003eexample folder\u003c/a\u003e contains examples that fully exercise the features.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@annotate_logs()\ndef foo():\n    return True\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt;\u0026gt; foo()\n{\u0026#34;created\u0026#34;: 1733176439.5067494, \u0026#34;levelname\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.8fcd85f5-d47f-4925-8d3f-935d45ceeefc\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:foo\u0026#34;, \u0026#34;annotated\u0026#34;: true}\n{\u0026#34;created\u0026#34;: 1733176439.506998, \u0026#34;levelname\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.8fcd85f5-d47f-4925-8d3f-935d45ceeefc\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:foo\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;run_time\u0026#34;: \u0026#34;0.0\u0026#34;, \u0026#34;annotated\u0026#34;: true}\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a more complete example that makes use of a number of the features. Make sure to install the package: \u003ccode\u003epip install annotated-logger\u003c/code\u003e first.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport os\nfrom annotated_logger import AnnotatedLogger\nal = AnnotatedLogger(\n    name=\u0026#34;annotated_logger.example\u0026#34;,\n    annotations={\u0026#34;branch\u0026#34;: os.environ.get(\u0026#34;BRANCH\u0026#34;, \u0026#34;unknown-branch\u0026#34;)}\n)\nannotate_logs = al.annotate_logs\n\n@annotate_logs()\ndef split_username(annotated_logger, username):\n    annotated_logger.annotate(username=username)\n    annotated_logger.info(\u0026#34;This is a very important message!\u0026#34;, extra={\u0026#34;important\u0026#34;: True})\n    return list(username)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026gt;\u0026gt;\u0026gt; split_username(\u0026#34;crimsonknave\u0026#34;)\n{\u0026#34;created\u0026#34;: 1733349907.7293086, \u0026#34;levelname\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;annotated\u0026#34;: true}\n{\u0026#34;created\u0026#34;: 1733349907.7296104, \u0026#34;levelname\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;This is a very important message!\u0026#34;, \u0026#34;important\u0026#34;: true, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;crimsonknave\u0026#34;, \u0026#34;annotated\u0026#34;: true}\n{\u0026#34;created\u0026#34;: 1733349907.729843, \u0026#34;levelname\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.c499f318-e54b-4f54-9030-a83607fa8519\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;crimsonknave\u0026#34;, \u0026#34;success\u0026#34;: true, \u0026#34;run_time\u0026#34;: \u0026#34;0.0\u0026#34;, \u0026#34;count\u0026#34;: 12, \u0026#34;annotated\u0026#34;: true}\n[\u0026#39;c\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;e\u0026#39;]\n\u0026gt;\u0026gt;\u0026gt;\n\u0026gt;\u0026gt;\u0026gt; split_username(1)\n{\u0026#34;created\u0026#34;: 1733349913.719831, \u0026#34;levelname\u0026#34;: \u0026#34;DEBUG\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;annotated\u0026#34;: true}\n{\u0026#34;created\u0026#34;: 1733349913.719936, \u0026#34;levelname\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;This is a very important message!\u0026#34;, \u0026#34;important\u0026#34;: true, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;username\u0026#34;: 1, \u0026#34;annotated\u0026#34;: true}\n{\u0026#34;created\u0026#34;: 1733349913.7200255, \u0026#34;levelname\u0026#34;: \u0026#34;ERROR\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;annotated_logger.example.1c354f32-dc76-4a6a-8082-751106213cbd\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uncaught Exception in logged function\u0026#34;, \u0026#34;exc_info\u0026#34;: \u0026#34;Traceback (most recent call last):\\n  File \\\u0026#34;/home/crimsonknave/code/annotated-logger/annotated_logger/__init__.py\\\u0026#34;, line 758, in wrap_function\\n  result = wrapped(*new_args, **new_kwargs)  # pyright: ignore[reportCallIssue]\\n  File \\\u0026#34;\u0026lt;stdin\u0026gt;\\\u0026#34;, line 5, in split_username\\nTypeError: \u0026#39;int\u0026#39; object is not iterable\u0026#34;, \u0026#34;action\u0026#34;: \u0026#34;__main__:split_username\u0026#34;, \u0026#34;branch\u0026#34;: \u0026#34;unknown-branch\u0026#34;, \u0026#34;username\u0026#34;: 1, \u0026#34;success\u0026#34;: false, \u0026#34;exception_title\u0026#34;: \u0026#34;\u0026#39;int\u0026#39; object is not iterable\u0026#34;, \u0026#34;annotated\u0026#34;: true}\nTraceback (most recent call last):\n  File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt;\n  File \u0026#34;\u0026lt;makefun-gen-0\u0026gt;\u0026#34;, line 2, in split_username\n  File \u0026#34;/home/crimsonknave/code/annotated-logger/annotated_logger/__init__.py\u0026#34;, line 758, in wrap_function\n    result = wrapped(*new_args, **new_kwargs)  # pyright: ignore[reportCallIssue]\n  File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 5, in split_username\nTypeError: \u0026#39;int\u0026#39; object is not iterable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are a few things going on in this example. Let’s break it down piece by piece.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe Annotated Logger requires a small amount of setup to use; specifically, you need to instantiate an instance of the \u003ccode\u003eAnnotatedLogger\u003c/code\u003e class. This class contains all of the configuration for the loggers.\n\u003cul\u003e\n\u003cli\u003eHere we set the name of the logger. (You will need to update the logging config if your name does not start with \u003ccode\u003eannotated_logger\u003c/code\u003e or there will be nothing configured to log your messages.)\u003c/li\u003e\n\u003cli\u003eWe also set a \u003ccode\u003ebranch\u003c/code\u003e annotation that will be sent with all log messages.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAfter that, we create an alias for the decorator. You don’t have to do this, but I find it’s easier to read than \u003ccode\u003e@al.annotate_logs()\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eNow, we decorate and define our method, but this time we’re going to ask the decorator to provide us with a logger object, \u003ccode\u003eannotated_logger\u003c/code\u003e. This \u003ccode\u003eannotated_logger\u003c/code\u003e variable can be used just like a standard \u003ccode\u003elogger\u003c/code\u003e object but has some extra features.\n\u003cul\u003e\n\u003cli\u003eThis \u003ccode\u003eannotated_logger\u003c/code\u003e argument is added by the decorator before calling the decorated method.\u003c/li\u003e\n\u003cli\u003eThe signature of the decorated method is adjusted so that it does not have an \u003ccode\u003eannotated_logger\u003c/code\u003e parameter (see how it’s called with just name).\u003c/li\u003e\n\u003cli\u003eThere are optional parameters to the decorator that allow type hints to correctly parse the modified signature.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eWe make use of one of those features right away by calling the \u003ccode\u003eannotate method\u003c/code\u003e, which will add whatever kwargs we pass to the \u003ccode\u003eextra\u003c/code\u003e field of all log messages that use the logger.\n\u003cul\u003e\n\u003cli\u003eAny field added as an annotation will be included in each subsequent log message that uses that logger.\u003c/li\u003e\n\u003cli\u003eYou can override an annotation by annotating again with the same name\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eAt last, we send a log message! In this message we also pass in a field that’s only for that log message, in the same way you would when using \u003ccode\u003elogger\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIn the second call, we passed an \u003ccode\u003eint\u003c/code\u003e to the name field and \u003ccode\u003elist\u003c/code\u003e threw an exception.\n\u003cul\u003e\n\u003cli\u003eThis exception is logged automatically and then re-raised.\u003c/li\u003e\n\u003cli\u003eThis makes it much easier to know if/when a method ended (unless the process was killed).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s break down each of the fields in the log message:\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eField\u003c/th\u003e\n\u003cth\u003eSource\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ecreated\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003elogging\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eStandard \u003ccode\u003eLogging\u003c/code\u003e field.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003elevelname\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003elogging\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eStandard \u003ccode\u003eLogging\u003c/code\u003e field.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\u003ctd\u003ename\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eLogger name (set via class instantiation).\u003c/td\u003e\n\n\u003c/tr\u003e\u003ctr\u003e\n\u003ctd\u003emessage\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003elogging\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eStandard \u003ccode\u003eLogging\u003c/code\u003e field for log content.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eaction\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eMethod name the logger was created for.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ebranch\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAnnotatedLogger()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSet from the configuration’s \u003ccode\u003ebranch\u003c/code\u003e annotation.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eannotated\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eBoolean indicating if the message was sent via Annotated Logger.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eimportant\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger.info\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eAnnotation set for a specific log message.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eusername\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger.annotate\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eAnnotation set by user.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esuccess\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eIndicates if the method completed successfully (True/False).\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003erun_time\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eDuration of the method execution.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecount\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eannotated_logger\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eLength of the return value (if applicable).\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003esuccess\u003c/code\u003e, \u003ccode\u003erun_time\u003c/code\u003e and \u003ccode\u003ecount\u003c/code\u003e fields are added automatically to the message (“success”) that is logged after a decorated method is completed without an exception being raised.\u003c/p\u003e\n\u003ch2 id=\"under-the-covers\" id=\"under-the-covers\"\u003eUnder the covers\u003ca href=\"#under-the-covers\" aria-label=\"Under the covers\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"how-its-implemented\" id=\"how-its-implemented\"\u003eHow it’s implemented\u003ca href=\"#how-its-implemented\" aria-label=\"How it’s implemented\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe Annotated Logger interacts with \u003ccode\u003eLogging\u003c/code\u003e via two main classes: \u003ccode\u003eAnnotatedAdapter\u003c/code\u003e and \u003ccode\u003eAnnotatedFilter\u003c/code\u003e. \u003ccode\u003eAnnotatedAdapter\u003c/code\u003e is a subclass of \u003ccode\u003elogging.LoggerAdapter\u003c/code\u003e and is what all \u003ccode\u003eannotated_logger\u003c/code\u003e arguments are instances of. \u003ccode\u003eAnnotatedFilter\u003c/code\u003e is a subclass of \u003ccode\u003elogging.Filter\u003c/code\u003e and is where the annotations are actually injected into the log messages. As a user outside of config and plugins, the only part of the code you will only interact with are \u003ccode\u003eAnnotatedAdapter\u003c/code\u003e in methods and the decorator itself. Each instance of the \u003ccode\u003eAnnotatedAdapter\u003c/code\u003e class has an \u003ccode\u003eAnnotatedFilter\u003c/code\u003e instance—the \u003ccode\u003eAnnotatedAdapter.annotate\u003c/code\u003e method passes those annotations on to the filter where they are stored. When a message is logged, that filter will calculate all the annotations it should have and then update the existing \u003ccode\u003eLogRecord\u003c/code\u003e object with those annotations.\u003c/p\u003e\n\u003cp\u003eBecause each invocation of a method gets its own \u003ccode\u003eAnnotatedAdapter\u003c/code\u003e object it also has its own \u003ccode\u003eAnnotatedFilter\u003c/code\u003e object. This ensures that there is no leaking of annotations from one method call to another.\u003c/p\u003e\n\u003ch3 id=\"type-hinting\" id=\"type-hinting\"\u003eType hinting\u003ca href=\"#type-hinting\" aria-label=\"Type hinting\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe Annotated Logger is fully type hinted internally and fully supports type hinting of decorated methods. But a little bit of additional detail is required in the decorator invocation. The \u003ccode\u003eannotate_logs\u003c/code\u003e method takes a number of optional arguments. For type hinting, \u003ccode\u003e_typing_self\u003c/code\u003e, \u003ccode\u003e_typing_requested\u003c/code\u003e, \u003ccode\u003e_typing_class\u003c/code\u003e and \u003ccode\u003eprovided\u003c/code\u003e are relevant. The three arguments that start with \u003ccode\u003e_typing\u003c/code\u003e have no impact on the behavior of the decorator and are only used in method signature overrides for type hinting. Setting \u003ccode\u003eprovided\u003c/code\u003e to \u003ccode\u003eTrue\u003c/code\u003e tells the decorator that the \u003ccode\u003eannotated_logger\u003c/code\u003e should not be created and will be provided by the caller (thus the signature shouldn’t be altered).\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_typing_self\u003c/code\u003e defaults to \u003ccode\u003eTrue\u003c/code\u003e as that is how most of my code is written. \u003ccode\u003eprovided\u003c/code\u003e, \u003ccode\u003e_typing_class\u003c/code\u003e and \u003ccode\u003e_typing_requested\u003c/code\u003e default to \u003ccode\u003eFalse\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass Example:\n    @annotate_logs(_typing_requested=True)\n    def foo(self, annotated_logger):\n        ...\n\ne = Example()\ne.foo()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"plugins\" id=\"plugins\"\u003ePlugins\u003ca href=\"#plugins\" aria-label=\"Plugins\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere are a number of plugins that come packaged with the Annotated Logger. Plugins allow for the user to hook into two places: when an exception is caught by the decorator and when logging a message. You can create your own plugin by creating a class that defines the \u003ccode\u003efilter\u003c/code\u003e and \u003ccode\u003euncaught_exception\u003c/code\u003e methods (or inherits from \u003ccode\u003eannotated_logger.plugins.BasePlugin\u003c/code\u003e which provides noop methods for both).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003efilter\u003c/code\u003e method of a plugin is called when a message is being logged. Plugins are called in the order they are set in the config. They are called by the AnnotatedFilter object of the AnnotatedAdapter and work like any \u003ccode\u003elogging.Filter\u003c/code\u003e. They take a record argument which is a \u003ccode\u003elogging.LogRecord\u003c/code\u003e object. They can manipulate that record in any way they want and those modifications will persist. Additionally, just like any logging filter, they can stop a message from being logged by returning \u003ccode\u003eFalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003euncaught_exception\u003c/code\u003e method of a plugin is called when the decorator catches an exception in the decorated method. It takes two arguments, \u003ccode\u003eexception\u003c/code\u003e and \u003ccode\u003elogger\u003c/code\u003e. The \u003ccode\u003elogger\u003c/code\u003e argument is the \u003ccode\u003eannotated_logger\u003c/code\u003e for the decorated method. This allows the plugin to annotate the log message stating that there was an uncaught exception that is about to be logged once the plugins have all processed their \u003ccode\u003euncaught_exception\u003c/code\u003e methods.\u003c/p\u003e\n\u003cp\u003eHere is an example of a simple plugin. The plugin inherits from the \u003ccode\u003eBasePlugin\u003c/code\u003e, which isn’t strictly needed here since it implements both \u003ccode\u003efilter\u003c/code\u003e and \u003ccode\u003euncaught_exception\u003c/code\u003e, but if it didn’t, inheriting from the BasePlugin means that it would fall back to the default noop methods. The plugin has an init so that it can take and store arguments. The \u003ccode\u003efilter\u003c/code\u003e and \u003ccode\u003euncaught_exception\u003c/code\u003e methods will end up with the same result: \u003ccode\u003eflagged=True\u003c/code\u003e being set if a word matches. But they do it slightly differently, \u003ccode\u003efilter\u003c/code\u003e is called while a given log message is being processed and so the annotation it adds is directly to that record. While \u003ccode\u003euncaught_exception\u003c/code\u003e is called if an exception is raised and not caught during the execution of the decorated method, so it doesn’t have a specific log record to interact with and set an annotation on the logger. The only difference in outcome would be if another plugin emitted a log message during its \u003ccode\u003euncaught_exception\u003c/code\u003e method after \u003ccode\u003eFlagWordPlugin\u003c/code\u003e, in that case, the additional log message would also have \u003ccode\u003eflagged=True\u003c/code\u003e on it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efrom annotated_logger.plugins import BasePlugin\n\nclass FlagWordPlugin(BasePlugin):\n    \u0026#34;\u0026#34;\u0026#34;Plugin that flags any log message/exception that contains a word in a list.\u0026#34;\u0026#34;\u0026#34;\n    def __init__(self, *wordlist):\n        \u0026#34;\u0026#34;\u0026#34;Save the wordlist.\u0026#34;\u0026#34;\u0026#34;\n        self.wordlist = wordlist\n\n    def filter(self, record):\n    \u0026#34;\u0026#34;\u0026#34;Add annotation if the message contains words in the wordlist.\u0026#34;\u0026#34;\u0026#34;\n    for word in self.wordlist:\n        if word in record.msg:\n            record.flagged = True\n\n    def uncaught_exception(self, exception, logger):\n    \u0026#34;\u0026#34;\u0026#34;Add annotation if exception title contains words in the wordlist.\u0026#34;\u0026#34;\u0026#34;\n    for word in self.wordlist:\n        if word in str(exception)\n            logger.annotate(flagged=True)\n\n\nAnnotatedLogger(plugins=[FlagWordPlugin(\u0026#34;danger\u0026#34;, \u0026#34;Will Robinson\u0026#34;)])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlugins are stored in a list and the order they are added can matter. The \u003ccode\u003eBasePlugin\u003c/code\u003e is always the first plugin in the list; any that are set in configuration are added after it.\u003c/p\u003e\n\u003cp\u003eWhen a log message is being sent the \u003ccode\u003efilter\u003c/code\u003e methods of each plugin will be called in the order they appear in the list. Because the \u003ccode\u003efilter\u003c/code\u003e methods often modify the record directly, one filter can break another if, for example, one filter removed or renamed a field that another filter used. Conversely, one filter could expect another to have added or altered a field before its run and would fail if it was ahead of the other filter. Finally, just like in the \u003ccode\u003elogging\u003c/code\u003e module, the \u003ccode\u003efilter\u003c/code\u003e method can stop a log from being emitted by returning False. As soon as a filter does so the processing ends and any Plugins later in the list will not have their \u003ccode\u003efilter\u003c/code\u003e methods called.\u003c/p\u003e\n\u003cp\u003eIf the decorated method raises an exception that is not caught, then the plugins will again execute in order. The most common interaction is plugins attempting to set/modify the same annotation. The \u003ccode\u003eBasePlugin\u003c/code\u003e and \u003ccode\u003eRequestsPlugin\u003c/code\u003e both set the \u003ccode\u003eexception_title\u003c/code\u003e annotation. Since the \u003ccode\u003eBasePlugin\u003c/code\u003e is always first, the title it sets will be overridden. Other interactions would be one plugin setting an annotation before or after another plugin that emits a log message or sends data to a third-party. In both of those cases the order will impact if the annotation is present or not.\u003c/p\u003e\n\u003cp\u003ePlugins that come with the Annotated Logger:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGitHubActionsPlugin\u003c/code\u003e—Set a level of log messages to also be emitted in actions notation (\u003ccode\u003enotice::\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNameAdjusterPlugin\u003c/code\u003e—Add a pre/postfix to a name to avoid collisions in any log processing software (\u003ccode\u003esource\u003c/code\u003e is a field in Splunk, but we often include it as a field and it’s just hidden).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRemoverPlugin\u003c/code\u003e—Remove a field. Exclude \u003ccode\u003epassword\u003c/code\u003e/\u003ccode\u003ekey\u003c/code\u003e fields and set an object’s attributes to the log if you want or ignore fields like \u003ccode\u003etaskName\u003c/code\u003e that are set when running async, but not sync.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNestedRemoverPlugin\u003c/code\u003e—Remove a field no matter how deep in a dictionary it is.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRenamerPlugin\u003c/code\u003e—Rename one field to another (don’t like \u003ccode\u003elevelname\u003c/code\u003e and want \u003ccode\u003elevel\u003c/code\u003e, this is how you do that).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRequestsPlugin\u003c/code\u003e—Adds a title and status code to the annotations if the exception inherits from \u003ccode\u003erequests.exceptions.HTTPError\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRuntimeAnnotationsPlugin\u003c/code\u003e—Sets dynamic annotations.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"dictconfig\" id=\"dictconfig\"\u003edictconfig\u003ca href=\"#dictconfig\" aria-label=\"dictconfig\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhen adding the Annotated Logger to an existing project, or one that uses other packages that log messages (flask, django, and so on), you can configure all of the Annotated Logger via \u003ca href=\"https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig\"\u003e\u003ccode\u003edictConfig\u003c/code\u003e\u003c/a\u003e by supplying a \u003ccode\u003edictConfig\u003c/code\u003e compliant dictionary as the \u003ccode\u003econfig\u003c/code\u003e argument when initializing the Annotated Logger class. If, instead, you wish to do this yourself you can pass \u003ccode\u003econfig=False\u003c/code\u003e and reference \u003ccode\u003eannotated_logger.DEFAULT_LOGGING_CONFIG\u003c/code\u003e to obtain the config that is used when none is provided and alter/extract as needed.\u003c/p\u003e\n\u003cp\u003eThere is one special case where the Annotated Logger will modify the config passed to it: if there is a filter named \u003ccode\u003eannotated_filter\u003c/code\u003e that entry will be replaced with a reference to a filter that is created by the instance of the Annotated Logger that’s being created. This allows any annotations or other options set to be applied to messages that use that filter. You can instead create a filter that uses the AnnotatedFilter class, but it won’t have any of the config the rest of your logs have.\u003c/p\u003e\n\u003ch4 id=\"notes\" id=\"notes\"\u003eNotes\u003ca href=\"#notes\" aria-label=\"Notes\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003edictConfig\u003c/code\u003e partly works when merging dictionaries. I have found that some parts of the config are not overwritten, but other parts seem to lose their references. So, I would encourage you to build up a logging config for everything and call it once only. If you pass \u003ccode\u003econfig\u003c/code\u003e, the Annotated Logger will call \u003ccode\u003elogging.config.dictConfig\u003c/code\u003e on your config after it has the option to add/adjust the config.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://github.com/github/annotated-logger/blob/main/example/logging_config.py\"\u003e\u003ccode\u003elogging_config.py\u003c/code\u003e\u003c/a\u003e example has a much more detailed breakdown and set of examples.\u003c/p\u003e\n\u003ch3 id=\"pytest-mock\" id=\"pytest-mock\"\u003ePytest mock\u003ca href=\"#pytest-mock\" aria-label=\"Pytest mock\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIncluded with the package is a pytest mock to assist in testing for logged messages. I know that there are some strong opinions about testing log messages, and I don’t suggest doing it extensively, or frequently, but sometimes it’s the easiest way to check a loop, or the log message is tied to an alert, and it is important how it’s formatted. In these cases, you can ask for the \u003ccode\u003eannotated_logger_mock\u003c/code\u003e fixture which will intercept, record and forward all log messages.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edef test_logs(annotated_logger_mock):\n    with pytest.raises(KeyError):\n        complicated_method()\n    annotated_logger_mock.assert_logged(\n        \u0026#34;ERROR\u0026#34;,  # Log level\n        \u0026#34;That\u0026#39;s not the right key\u0026#34;,  # Log message\n        present={\u0026#34;success\u0026#34;: False, \u0026#34;key\u0026#34;: \u0026#34;bad-key\u0026#34;},  # annotations and their values that are required\n        absent=[\u0026#34;fake-annotations\u0026#34;],  # annotations that are forbidden\n        count=1  # Number of times log messages should match\n    )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eassert_logged\u003c/code\u003e method makes use of \u003ca href=\"https://pypi.org/project/pychoir/\"\u003epychoir\u003c/a\u003e for flexible matching. None of the parameters are required, so feel free to use whichever makes sense. Below is a breakdown of the default and valid values for each parameter.\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eParameter\u003c/th\u003e\n\u003cth\u003eDefault Value\u003c/th\u003e\n\u003cth\u003eValid Values\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003elevel\u003c/td\u003e\n\u003ctd\u003eMatches anything\u003c/td\u003e\n\u003ctd\u003eString or string-based matcher\u003c/td\u003e\n\u003ctd\u003eLog level to check (e.g., “ERROR”).\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emessage\u003c/td\u003e\n\u003ctd\u003eMatches anything\u003c/td\u003e\n\u003ctd\u003eString or string-based matcher\u003c/td\u003e\n\u003ctd\u003eLog message to check.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003epresent\u003c/td\u003e\n\u003ctd\u003eEmpty dictionary\u003c/td\u003e\n\u003ctd\u003eDictionary with string keys and any value\u003c/td\u003e\n\u003ctd\u003eAnnotations required in the log.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eabsent\u003c/td\u003e\n\u003ctd\u003eEmpty set\u003c/td\u003e\n\u003ctd\u003e`ALL`, set, or list of strings\u003c/td\u003e\n\u003ctd\u003eAnnotations that must not be present in the log.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecount\u003c/td\u003e\n\u003ctd\u003eAll positive integers\u003c/td\u003e\n\u003ctd\u003eInteger or integer-based matcher\u003c/td\u003e\n\u003ctd\u003eNumber of times the log message should match.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003epresent\u003c/code\u003e key is often what makes the mock truly useful. It allows you to require the things you care about and ignore the things you don’t care about. For example, nobody wants their tests to fail because the \u003ccode\u003erun_time\u003c/code\u003e of a method went from \u003ccode\u003e0.0\u003c/code\u003e to \u003ccode\u003e0.1\u003c/code\u003e or fail because the hostname is different on different test machines. But both of those are useful things to have in the logs. This mock should replace everything you use the \u003ccode\u003ecaplog\u003c/code\u003e fixture for and more.\u003c/p\u003e\n\u003ch2 id=\"other-features\" id=\"other-features\"\u003eOther features\u003ca href=\"#other-features\" aria-label=\"Other features\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"class-decorators-and-persist\" id=\"class-decorators-and-persist\"\u003eClass decorators and persist\u003ca href=\"#class-decorators-and-persist\" aria-label=\"Class decorators and persist\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eClasses can be decorated with \u003ccode\u003e@annotate_logs\u003c/code\u003e as well. These classes will have an \u003ccode\u003eannotated_logger\u003c/code\u003e attribute added after the init (I was unable to get it to work inside the \u003ccode\u003e__init__\u003c/code\u003e). Any decorated methods of that class will have an \u003ccode\u003eannotated_logger\u003c/code\u003e that’s based on the class logger. Calls to \u003ccode\u003eannotate\u003c/code\u003e that pass \u003ccode\u003epersist=True\u003c/code\u003e will set the annotations on the class Annotated Logger and so subsequent calls of any decorated method of that instance will have those annotations. The class instance’s \u003ccode\u003eannotated_logger\u003c/code\u003e will also have an annotation of \u003ccode\u003eclass\u003c/code\u003e specifying which class the logs are coming from.\u003c/p\u003e\n\u003ch3 id=\"iterators\" id=\"iterators\"\u003eIterators\u003ca href=\"#iterators\" aria-label=\"Iterators\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe Annotated Logger also supports logging iterations of an \u003ccode\u003eenumerable\u003c/code\u003e object. \u003ccode\u003eannotated_logger.iterator\u003c/code\u003e will log the start, each step of the iteration, and when the iteration is complete. This can be useful for pagination in an API if your results object is enumerable, logging each time a page is fetched instead of sitting for a long time with no indication if the pages are hanging or there are simply many pages.\u003c/p\u003e\n\u003cp\u003eBy default the \u003ccode\u003eiterator\u003c/code\u003e method will log the value of each iteration, but this can be disabled by setting \u003ccode\u003evalue=False\u003c/code\u003e. You can also specify the level to log the iterations at if you don’t want the default of \u003ccode\u003einfo\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"provided\" id=\"provided\"\u003eProvided\u003ca href=\"#provided\" aria-label=\"Provided\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBecause each decorated method gets its own \u003ccode\u003eannotated_logger\u003c/code\u003e calls to other methods will not have any annotations from the caller. Instead of simply passing the \u003ccode\u003eannotated_logger\u003c/code\u003e object to the method being called, you can specify \u003ccode\u003eprovided=True\u003c/code\u003e in the decorator invocation. This does two things: first, it means that this method won’t have an \u003ccode\u003eannotated_logger\u003c/code\u003e created and passed automatically, instead it requires that the first argument be an existing \u003ccode\u003eannotated_logger\u003c/code\u003e, which it will use as a basis for the \u003ccode\u003eannotated_logger\u003c/code\u003e object it creates for the function. Second, it adds the annotation of \u003ccode\u003esubaction\u003c/code\u003e and sets the decorated function’s name as its value, the \u003ccode\u003eaction\u003c/code\u003e annotation is preserved as from the method that called and provided the \u003ccode\u003eannotated_logger\u003c/code\u003e. Annotations are not persisted from a method decorated with \u003ccode\u003eprovided=True\u003c/code\u003e to the method that called it, unless the class of the calling method was decorated and the called action annotated with \u003ccode\u003epersist=True\u003c/code\u003e, in which case the annotation is set on the \u003ccode\u003eannotated_logger\u003c/code\u003e of the instance and shared with all methods as is normal for decorated classes.\u003c/p\u003e\n\u003cp\u003eThe most common use of this is with private methods, especially ones created during a refactor to extract some self contained logic. But other uses are for common methods that are called from a number of different places.\u003c/p\u003e\n\u003ch3 id=\"split-messages\" id=\"split-messages\"\u003eSplit messages\u003ca href=\"#split-messages\" aria-label=\"Split messages\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLong messages wreak havoc on log parsing tools. I’ve encountered cases where the HTML of a 500 error page was too long for Splunk to parse, causing the entire log entry to be discarded and its annotations to go unprocessed. Setting \u003ccode\u003emax_length\u003c/code\u003e when configuring the Annotated Logger will break long messages into multiple log messages each annotated with \u003ccode\u003esplit=True\u003c/code\u003e, \u003ccode\u003esplit_complete=False\u003c/code\u003e, \u003ccode\u003emessage_parts=#\u003c/code\u003e and \u003ccode\u003emessage_part=#\u003c/code\u003e. The last part of the long message will have \u003ccode\u003esplit_complete=True\u003c/code\u003e when it is logged.\u003c/p\u003e\n\u003cp\u003eOnly messages can be split like this; annotations will not trigger the splitting. However, a plugin could truncate any values with a length over a certain size.\u003c/p\u003e\n\u003ch3 id=\"pre-post-hooks\" id=\"pre-post-hooks\"\u003ePre/Post hooks\u003ca href=\"#pre-post-hooks\" aria-label=\"Pre/Post hooks\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou can register hooks that are executed before and after the decorated method is called. The \u003ccode\u003epre_call\u003c/code\u003e and \u003ccode\u003epost_call\u003c/code\u003e parameters of the decorator take a reference to a function and will call that function right before passing in the same arguments that the function will be/was called with. This allows the hooks to add annotations and/or log anything that is desired (assuming the decorated function requested an \u003ccode\u003eannotated_logger\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eExamples of this would be having a set of annotations that annotate fields on a model and a \u003ccode\u003epre_call\u003c/code\u003e that sets them in a standard way. Or a \u003ccode\u003epost_call\u003c/code\u003e that logs if the function left a model in an unsaved state.\u003c/p\u003e\n\u003ch3 id=\"runtime-annotations\" id=\"runtime-annotations\"\u003eRuntime annotations\u003ca href=\"#runtime-annotations\" aria-label=\"Runtime annotations\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eMost annotations are static, but sometimes you need something that’s dynamic. These are achieved via the \u003ccode\u003eRuntimeAnnotationsPlugin\u003c/code\u003e in the Annotated Logger config. The \u003ccode\u003eRuntimeAnnotationsPlugin\u003c/code\u003e takes a dict of names and references to functions. These functions will be called and passed the log record when the plugin’s filter method is invoked just before the log message is emitted. Whatever is returned by the function will be set as the value of the annotation of the log message currently being logged.\u003c/p\u003e\n\u003cp\u003eA common use case is to annotate a request/correlation id, which identifies all of the log messages that were part of a given API request. For Django, one way to do this is via \u003ca href=\"https://pypi.org/project/django-guid/\"\u003edjango-guid\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"tips-tricks-and-gotchas\" id=\"tips-tricks-and-gotchas\"\u003eTips, tricks and gotchas\u003ca href=\"#tips-tricks-and-gotchas\" aria-label=\"Tips, tricks and gotchas\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eWhen using the decorator in more than one file, it’s useful to do all of the configuration in a file like \u003ccode\u003elog.py\u003c/code\u003e. That allows you to \u003ccode\u003efrom project.log import annotate_logs\u003c/code\u003e everywhere you want to use it and you know it’s all configured and everything will be using the same setup.\u003c/li\u003e\n\u003cli\u003eNamespacing your loggers helps when there are two projects that both use the Annotated Logger (a package and a service that uses the package). If you are setting anything via \u003ccode\u003edictConfig\u003c/code\u003e you will want to have a single config that has everything for all Annotated Loggers.\u003c/li\u003e\n\u003cli\u003eIn addition to setting a correlation id for the API request being processed, passing the correlation id of the caller and then annotating that will allow you to trace from the logs of service A to the specific logs in Service B that relate to a call made by service A.\u003c/li\u003e\n\u003cli\u003ePlugins are very flexible. For example:\n\u003cul\u003e\n\u003cli\u003eSend every \u003ccode\u003eexception\u003c/code\u003e log message to a service like Sentry.\u003c/li\u003e\n\u003cli\u003eSuppress logs from another package, like Django, that you don’t want to see (assuming you’ve configured Django’s logs to use a filter for your Annotated Logger).\u003c/li\u003e\n\u003cli\u003eAdd annotations for extra information about specific types of exceptions (see the \u003ccode\u003eRequestsPlugin\u003c/code\u003e).\u003c/li\u003e\n\u003cli\u003eSet run time annotations on a subset of messages (instead of all messages with \u003ccode\u003eRuntimeAnnotationsPlugin\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"questions-feedback-and-requests\" id=\"questions-feedback-and-requests\"\u003eQuestions, feedback and requests\u003ca href=\"#questions-feedback-and-requests\" aria-label=\"Questions, feedback and requests\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe’d love to hear any questions, comments or requests you might have in an \u003ca href=\"https://github.com/github/annotated-logger/issues\"\u003eissue\u003c/a\u003e. Pull requests welcome as well!\u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/352979?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/352979?v=4\u0026amp;s=200\" alt=\"Joseph Henrich\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSenior Software Engineer, GitHub\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": "2024-12-19T17:00:28Z",
  "modifiedTime": "2024-12-18T21:31:44Z"
}
