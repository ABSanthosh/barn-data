{
  "id": "02365d3e-c3ab-4e8c-a1e2-aabdd6cd9cc3",
  "title": "Behind the Scenes: Never Trust User Input",
  "link": "https://stackabuse.com/behind-the-scenes-never-trust-user-input/",
  "description": "This article is the first in a series of posts I'm writing about running various SaaS products and websites for the last 8 years. I'll be sharing some of the issues I've dealt with, lessons I've learned, mistakes I've made, and maybe a few things that went right. Let me",
  "author": "Scott Robinson",
  "published": "Thu, 14 Dec 2023 19:27:59 GMT",
  "source": "https://stackabuse.com/rss/",
  "categories": [
    "SaaS"
  ],
  "byline": "Scott Robinson",
  "length": 5920,
  "excerpt": "This article is the first in a series of posts I'm writing about running various SaaS products and websites for the last 8 years. I'll be sharing some of the is...",
  "siteName": "Stack Abuse",
  "favicon": "",
  "text": "This article is the first in a series of posts I'm writing about running various SaaS products and websites for the last 8 years. I'll be sharing some of the issues I've dealt with, lessons I've learned, mistakes I've made, and maybe a few things that went right. Let me know what you think! Back in 2019 or 2020, I had decided to rewrite the entire backend for Block Sender, a SaaS application that helps users create better email blocks, among other features. In the process, I added a few new features and upgraded to much more modern technologies. I ran the tests, deployed the code, manually tested everything in production, and other than a few random odds and ends, everything seemed to be working great. I wish this was the end of the story, but... A few weeks later, I was notified by a customer (which is embarrassing in itself) that the service wasn't working and they were getting lots of should-be-blocked emails in their inbox, so I investigated. Many times this issue is due to Google removing the connection from our service to the user's account, which the system handles by notifying the user via email and asking them to reconnect, but this time it was something else. It looked like the backend worker that handles checking emails against user blocks kept crashing every 5-10 minutes. The weirdest part - there were no errors in the logs, memory was fine, but the CPU would occasionally spike at seemingly random times. So for the next 24 hours (with a 3-hour break to sleep - sorry customers ðŸ˜¬), I had to manually restart the worker every time it crashed. For some reason, the Elastic Beanstalk service was waiting far too long to restart, which is why I had to do it manually. Debugging issues in production is always a pain, especially since I couldn't reproduce the issue locally, let alone figure out what was causing it. So like any \"good\" developer, I just started logging everything and waited for the server to crash again. Since the CPU was spiking periodically, I figured it wasn't a macro issue (like when you run out of memory) and was probably being caused by a specific email or user. So I tried to narrow it down: Was it crashing on a certain email ID or type? Was it crashing for a given customer? Was it crashing at some regular interval? After hours of this, and staring at logs longer than I'd care to, eventually, I did narrow it down to a specific customer. From there, the search space narrowed quite a bit - it was most likely a blocking rule or a specific email our server kept retrying on. Luckily for me, it was the former, which is a far easier problem to debug given that we're a very privacy-focused company and don't store or view any email data. Before we get into the exact problem, let's first talk about one of Block Sender's features. At the time I had many customers asking for wildcard blocking, which would allow them to block certain types of email addresses that followed the same pattern. For example, if you wanted to block all emails from marketing email addresses, you could use the wildcard marketing@* and it would block all emails from any address that started with marketing@. One thing I didn't think about is that not everyone understands how wildcards work. I assumed that most people would use them in the same way I do as a developer, using one * to represent any number of characters. Unfortunately, this particular user had assumed you needed to use one wildcard for each character you wanted to match. In their case, they wanted to block all emails from a certain domain (which is a native feature Block Sender has, but they must not have realized it, which is a whole problem in itself). So instead of using *@example.com, they used **********@example.com. POV: Watching your users use your app... To handle wildcards on our worker server, we're using the Node.js library matcher, which helps with glob matching by turning it into a regular expression. This library would then turn **********@example.com into something like the following regex: /[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*@example\\.com/i If you have any experience with regex, you know that they can get very complicated very quickly, especially on a computational level. Matching the above expression to any reasonable length of text becomes very computationally expensive, which ended up tying up the CPU on our worker server. This is why the server would crash every few minutes; it would get stuck trying to match a complex regular expression to an email address. So every time this user received an email, in addition to all of the retries we built in to handle temporary failures, it would crash our server. So how did I fix this? Obviously, the quick fix was to find all blocks with multiple wildcards in succession and correct them. But I also needed to do a better job of sanitizing user input. Any user could enter a regex and take down the entire system with a ReDoS attack. Check out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually learn it!Handling this particular case was fairly simple - remove successive wildcard characters: block = block.replace(/\\*+/g, '*') But that still leaves the app open to other types of ReDoS attacks. Luckily there are a number of packages/libraries to help us with these types as well: safe-regex rxxr2 Using a combination of the solutions above, and other safeguards, I've been able to prevent this from happening again. But it was a good reminder that you can never trust user input, and you should always sanitize it before using it in your application. I wasn't even aware this was a potential issue until it happened to me, so hopefully, this helps someone else avoid the same problem. Have any questions, comments, or want to share a story of your own? Reach out on Twitter!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003csmall\u003e\u003cem\u003eThis article is the first in a series of posts I\u0026#39;m writing about running various SaaS products and websites for the last 8 years. I\u0026#39;ll be sharing some of the issues I\u0026#39;ve dealt with, lessons I\u0026#39;ve learned, mistakes I\u0026#39;ve made, and maybe a few things that went right. \u003ca target=\"_blank\" href=\"https://twitter.com/ScottWRobinson\"\u003eLet me know\u003c/a\u003e what you think!\u003c/em\u003e\u003c/small\u003e\u003c/p\u003e\n\u003cp\u003eBack in 2019 or 2020, I had decided to rewrite the entire backend for \u003ca href=\"https://blocksender.io/\"\u003eBlock Sender\u003c/a\u003e, a SaaS application that helps users create better email blocks, among other features. In the process, I added a few new features and upgraded to much more modern technologies. I ran the tests, deployed the code, manually tested everything in production, and other than a few random odds and ends, everything seemed to be working great. I wish this was the end of the story, but...\u003c/p\u003e\n\u003cp\u003eA few weeks later, I was notified by a customer (which is embarrassing in itself) that the service wasn\u0026#39;t working and they were getting lots of should-be-blocked emails in their inbox, so I investigated. Many times this issue is due to Google removing the connection from our service to the user\u0026#39;s account, which the system handles by notifying the user via email and asking them to reconnect, but this time it was something else.\u003c/p\u003e\n\u003cp\u003eIt looked like the backend worker that handles checking emails against user blocks kept crashing every 5-10 minutes. The weirdest part - there were no errors in the logs, memory was fine, but the CPU would occasionally spike at seemingly random times. So for the next 24 hours (with a 3-hour break to sleep - sorry customers ðŸ˜¬), I had to manually restart the worker every time it crashed. For some reason, the Elastic Beanstalk service was waiting far too long to restart, which is why I had to do it manually.\u003c/p\u003e\n\u003cp\u003eDebugging issues in production is always a pain, especially since I couldn\u0026#39;t reproduce the issue locally, let alone figure out what was causing it. So like any \u0026#34;good\u0026#34; developer, I just started logging \u003cem\u003eeverything\u003c/em\u003e and waited for the server to crash again. Since the CPU was spiking periodically, I figured it wasn\u0026#39;t a macro issue (like when you run out of memory) and was probably being caused by a specific email or user. So I tried to narrow it down:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWas it crashing on a certain email ID or type?\u003c/li\u003e\n\u003cli\u003eWas it crashing for a given customer?\u003c/li\u003e\n\u003cli\u003eWas it crashing at some regular interval?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAfter hours of this, and staring at logs longer than I\u0026#39;d care to, eventually, I did narrow it down to a specific customer. From there, the search space narrowed quite a bit - it was most likely a blocking rule or a specific email our server kept retrying on. Luckily for me, it was the former, which is a far easier problem to debug given that we\u0026#39;re a very privacy-focused company and don\u0026#39;t store or view any email data.\u003c/p\u003e\n\u003cp\u003eBefore we get into the exact problem, let\u0026#39;s first talk about one of Block Sender\u0026#39;s features. At the time I had many customers asking for wildcard blocking, which would allow them to block certain types of email addresses that followed the same pattern. For example, if you wanted to block all emails from marketing email addresses, you could use the wildcard \u003ccode\u003emarketing@*\u003c/code\u003e and it would block all emails from any address that started with \u003ccode\u003emarketing@\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOne thing I didn\u0026#39;t think about is that not everyone understands how wildcards work. I assumed that most people would use them in the same way I do as a developer, using one \u003ccode\u003e*\u003c/code\u003e to represent any number of characters. Unfortunately, this particular user had assumed you needed to use \u003cem\u003eone wildcard for each character you wanted to match\u003c/em\u003e. In their case, they wanted to block all emails from a certain domain (which is a native feature Block Sender has, but they must not have realized it, which is a whole problem in itself). So instead of using \u003ccode\u003e*@example.com\u003c/code\u003e, they used \u003ccode\u003e**********@example.com\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://s3.stackabuse.com/media/articles/behind-the-scenes-never-trust-user-input-1.gif\" alt=\"POV: Watching your users use your app...\"/\u003e\u003cbr/\u003e\n\u003csmall\u003ePOV: Watching your users use your app...\u003c/small\u003e\u003c/p\u003e\n\u003cp\u003eTo handle wildcards on our worker server, we\u0026#39;re using the Node.js library \u003ca target=\"_blank\" rel=\"nofollow noopener\" href=\"https://www.npmjs.com/package/matcher\"\u003ematcher\u003c/a\u003e, which helps with glob matching by turning it into a regular expression. This library would then turn \u003ccode\u003e**********@example.com\u003c/code\u003e into something like the following regex:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*[\\s\\S]*@example\\.com/i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you have any experience with regex, you know that they can get very complicated very quickly, especially on a computational level. Matching the above expression to any reasonable length of text becomes very computationally expensive, which ended up tying up the CPU on our worker server. \u003cstrong\u003eThis is why the server would crash every few minutes; it would get stuck trying to match a complex regular expression to an email address\u003c/strong\u003e. So every time this user received an email, in addition to all of the retries we built in to handle temporary failures, it would crash our server.\u003c/p\u003e\n\u003cp\u003eSo how did I fix this? Obviously, the quick fix was to find all blocks with multiple wildcards in succession and correct them. But I also needed to do a better job of sanitizing user input. Any user could enter a regex and take down the entire system with a \u003ca target=\"_blank\" rel=\"nofollow noopener\" href=\"https://en.wikipedia.org/wiki/ReDoS\"\u003eReDoS attack\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv data-nosnippet=\"\" id=\"ad-lead-magnet\"\u003e\u003cp\u003eCheck out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually \u003cem\u003elearn\u003c/em\u003e it!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHandling this particular case was fairly simple - remove successive wildcard characters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eblock = block.replace(\u003cspan\u003e/\\*+/g\u003c/span\u003e, \u003cspan\u003e\u0026#39;*\u0026#39;\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut that still leaves the app open to other types of ReDoS attacks. Luckily there are a number of packages/libraries to help us with these types as well:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"nofollow noopener\" href=\"https://www.npmjs.com/package/safe-regex\"\u003esafe-regex\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"nofollow noopener\" href=\"https://github.com/superhuman/rxxr2\"\u003erxxr2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing a combination of the solutions above, and other safeguards, I\u0026#39;ve been able to prevent this from happening again. But it was a good reminder that you can never trust user input, and you should always sanitize it before using it in your application. I wasn\u0026#39;t even aware this was a potential issue until it happened to me, so hopefully, this helps someone else avoid the same problem.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eHave any questions, comments, or want to share a story of your own? Reach out on \u003ca target=\"_blank\" href=\"https://twitter.com/ScottWRobinson\"\u003eTwitter\u003c/a\u003e!\u003c/em\u003e\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2023-12-14T19:27:59Z",
  "modifiedTime": "2023-12-14T19:28:04Z"
}
