{
  "id": "a16946ab-8518-4dd8-9bd4-98cfde632704",
  "title": "Using child pipelines to continuously deploy to five environments",
  "link": "https://about.gitlab.com/blog/2024/09/26/using-child-pipelines-to-continuously-deploy-to-five-environments",
  "description": "",
  "author": "Olivier Dupré",
  "published": "2024-09-26T00:00:00.000Z",
  "source": "https://about.gitlab.com/atom.xml",
  "categories": null,
  "byline": "Olivier Dupré",
  "length": 36909,
  "excerpt": "Learn how to manage continuous deployment to multiple environments, including temporary, on-the-fly sandboxes, with a minimalist GitLab workflow.",
  "siteName": "GitLab",
  "favicon": "https://about.gitlab.com/blog/nuxt-images/ico/favicon-192x192.png?cache=2022041",
  "text": "DevSecOps teams sometimes require the ability to manage continuous deployment across multiple environments — and they need to do so without changing their workflows. The GitLab DevSecOps platform supports this need, including temporary, on-the-fly sandboxes, with a minimalist approach. In this article, you'll learn how to run continuous deployment of infrastructure using Terraform, over multiple environments. This strategy can easily be applied to any project, whether it is infrastructure as code (IaC) relying on another technology, such as Pulumi or Ansible, source code in any language, or a monorepo that mixes many languages. The final pipeline that you will have at the end of this tutorial will deploy: A temporary review environment for each feature branch. An integration environment, easy to wipe out and deployed from the main branch. A QA environment, also deployed from the main branch, to run quality assurance steps. A staging environment, deployed for every tag. This is the last round before production. A production environment, just after the staging environment. This one is triggered manually for demonstration, but can also be continuously deployed. Here is the legend for the flow charts in this article: Round boxes are the GitLab branches. Square boxes are the environments. Text on the arrows are the actions to flow from one box to the next. Angled squares are decision steps. flowchart LR A(main) --\u003e|new feature| B(feature_X) B --\u003e|auto deploy| C[review/feature_X] B --\u003e|merge| D(main) C --\u003e|destroy| D D --\u003e|auto deploy| E[integration] E --\u003e|manual| F[qa] D --\u003e|tag| G(X.Y.Z) F --\u003e|validate| G G --\u003e|auto deploy| H[staging] H --\u003e|manual| I{plan} I --\u003e|manual| J[production] On each step, you'll learn the why and the what before moving to the how. This will help you fully understand and replicate this tutorial. Why Continuous integration is almost a de facto standard. Most companies have implemented CI pipelines or are willing to standardize their practice. Continuous delivery, which pushes artifacts to a repository or registry at the end of the CI pipeline, is also popular. Continuous deployment, which goes further and deploys these artifacts automatically, is less widespread. When it has been implemented, we see it essentially in the application field. When discussing continuously deploying infrastructure, the picture seems less obvious, and is more about managing several environments. In contrast, testing, securing, and verifying the infrastructure's code seems more challenging. And this is one of the fields where DevOps has not yet reached its maturity. One of the other fields is to shift security left, integrating security teams and, more importantly, security concerns, earlier in the delivery lifecycle, to upgrade from DevOps to DevSecOps. Given this high-level picture, in this tutorial, you will work toward a simple, yet efficient way to implement DevSecOps for your infrastructure through the example of deploying resources to five environments, gradually progressing from development to production. Note: Even if I advocate embracing a FinOps approach and reducing the number of environments, sometimes there are excellent reasons to maintain more than just dev, staging, and production. So, please, adapt the examples below to match your needs. What The rise of cloud technology has driven the usage of IaC. Ansible and Terraform were among the first to pave the road here. OpenTofu, Pulumi, AWS CDK, Google Deploy Manager, and many others joined the party. Defining IaC is a perfect solution to feel safe when deploying infrastructure. You can test it, deploy it, and replay it again and again until you reach your goal. Unfortunately, we often see companies maintain several branches, or even repositories, for each of their target environments. And this is where the problems start. They are no longer enforcing a process. They are no longer ensuring that any change in the production code base has been accurately tested in previous environments. And they start seeing drifts from one environment to the other. I realized this tutorial was necessary when, at a conference I attended, every participant said they do not have a workflow that enforces the infrastructure to be tested thoroughly before being deployed to production. And they all agreed that sometimes they patch the code directly in production. Sure, this is fast, but is it safe? How do you report back to previous environments? How do you ensure there are no side effects? How do you control whether you are putting your company at risk with new vulnerabilities being pushed too quickly in production? The question of why DevOps teams deploy directly to production is critical here. Is it because the pipeline could be more efficient or faster? Is there no automation? Or, even worse, because there is no way to test accurately outside of production? In the next section, you will learn how to implement automation for your infrastructure and ensure that your DevOps team can effectively test what you are doing before pushing to any environment impacting others. You will see how your code is secured and its deployment is controlled, end-to-end. How As mentioned earlier, there are many IaC languages out there nowadays and we objectively cannot cover all of them in a single article. So, I will rely on a basic Terraform code running on Version 1.4. Please do not focus on the IaC language itself but instead on the process that you could apply to your own ecosystem. The Terraform code Let's start with a fundamental Terraform code. We are going to deploy to AWS, a virtual private cloud (VPC), which is a virtual network. In that VPC, we will deploy a public and a private subnet. As their name implies, they are subnets of the main VPC. Finally, we will add an Elastic Cloud Compute (EC2) instance (a virtual machine) in the public subnet. This demonstrates the deployment of four resources without adding too much complexity. The idea is to focus on the pipeline, not the code. Here is the target we want to reach for your repository. Let’s do it step by step. First, we declare all resources in a terraform/main.tf file: provider \"aws\" { region = var.aws_default_region } resource \"aws_vpc\" \"main\" { cidr_block = var.aws_vpc_cidr tags = { Name = var.aws_resources_name } } resource \"aws_subnet\" \"public_subnet\" { vpc_id = aws_vpc.main.id cidr_block = var.aws_public_subnet_cidr tags = { Name = \"Public Subnet\" } } resource \"aws_subnet\" \"private_subnet\" { vpc_id = aws_vpc.main.id cidr_block = var.aws_private_subnet_cidr tags = { Name = \"Private Subnet\" } } resource \"aws_instance\" \"sandbox\" { ami = var.aws_ami_id instance_type = var.aws_instance_type subnet_id = aws_subnet.public_subnet.id tags = { Name = var.aws_resources_name } } As you can see, there are a couple of variables that are needed for this code, so let's declare them in a terraform/variables.tf file: variable \"aws_ami_id\" { description = \"The AMI ID of the image being deployed.\" type = string } variable \"aws_instance_type\" { description = \"The instance type of the VM being deployed.\" type = string default = \"t2.micro\" } variable \"aws_vpc_cidr\" { description = \"The CIDR of the VPC.\" type = string default = \"10.0.0.0/16\" } variable \"aws_public_subnet_cidr\" { description = \"The CIDR of the public subnet.\" type = string default = \"10.0.1.0/24\" } variable \"aws_private_subnet_cidr\" { description = \"The CIDR of the private subnet.\" type = string default = \"10.0.2.0/24\" } variable \"aws_default_region\" { description = \"Default region where resources are deployed.\" type = string default = \"eu-west-3\" } variable \"aws_resources_name\" { description = \"Default name for the resources.\" type = string default = \"demo\" } Already, we are almost good to go on the IaC side. What's missing is a way to share the Terraform states. For those who don't know, Terraform works schematically doing the following: plan checks the differences between the current state of the infrastructure and what is defined in the code. Then, it outputs the differences. apply applies the differences in the plan and updates the state. First round, the state is empty, then it is filled with the details (ID, etc.) of the resources applied by Terraform. The problem is: Where is that state stored? How do we share it so several developers can collaborate on code? The solution is fairly simple: Leverage GitLab to store and share the state for you through a Terraform HTTP backend. The first step in using this backend is to create the most simple terraform/backend.tf file. The second step will be handled in the pipeline. terraform { backend \"http\" { } } Et voilà! We have a bare minimum Terraform code to deploy these four resources. We will provide the variable values at the runtime, so let's do that later. The workflow The workflow that we are going to implement now is the following: flowchart LR A(main) --\u003e|new feature| B(feature_X) B --\u003e|auto deploy| C[review/feature_X] B --\u003e|merge| D(main) C --\u003e|destroy| D D --\u003e|auto deploy| E[integration] E --\u003e|manual| F[qa] D --\u003e|tag| G(X.Y.Z) F --\u003e|validate| G G --\u003e|auto deploy| H[staging] H --\u003e|manual| I{plan} I --\u003e|manual| J[production] Create a feature branch. This will continuously run all scanners on the code to ensure that it is still compliant and secured. This code will be continuously deployed to a temporary environment review/feature_branch with the name of the current branch. This is a safe environment where the developers and operations teams can test their code without impacting anybody. This is also where we will enforce the process, like enforcing code reviews and running scanners, to ensure that the quality and security of the code are acceptable and do not put your assets at risk. The infrastructure deployed by this branch is automatically destroyed when the branch is closed. This helps you keep your budget under control. flowchart LR A(main) --\u003e|new feature| B(feature_X) B --\u003e|auto deploy| C[review/feature_X] B --\u003e|merge| D(main) C --\u003e|destroy| D Once approved, the feature branch will be merged into the main branch. This is a protected branch where no one can push. This is mandatory to ensure that every change request to production is thoroughly tested. That branch is also continuously deployed. The target here is the integration environment. To keep this environment slightly more stable, its deletion is not automated but can be triggered manually. flowchart LR D(main) --\u003e|auto deploy| E[integration] From there, manual approval is required to trigger the next deployment. This will deploy the main branch to the qa environment. Here, I have set a rule to prevent deletion from the pipeline. The idea is that this environment should be quite stable (after all, it's already the third environment), and I would like to prevent deletion by mistake. Feel free to adapt the rules to match your processes. flowchart LR D(main)--\u003e|auto deploy| E[integration] E --\u003e|manual| F[qa] To proceed, we will need to tag the code. We are relying on protected tags here to ensure that only a specific set of users are allowed to deploy to these last two environments. This will immediately trigger a deployment to the staging environment. flowchart LR D(main) --\u003e|tag| G(X.Y.Z) F[qa] --\u003e|validate| G G --\u003e|auto deploy| H[staging] Finally, we are landing to production. When discussing infrastructure, it is often challenging to deploy progressively (10%, 25%, etc.), so we will deploy the whole infrastructure. Still, we control that deployment with a manual trigger of this last step. And to enforce maximum control on this highly critical environment, we will control it as a protected environment. flowchart LR H[staging] --\u003e|manual| I{plan} I --\u003e|manual| J[production] The pipeline To implement the above workflow, we are now going to implement a pipeline with two downstream pipelines. The main pipeline Let's start with the main pipeline. This is the one that will be triggered automatically on any push to a feature branch, any merge to the default branch, or any tag. The one that will do true continuous deployment to the following environments: dev, integration, and staging. And it is declared in the .gitlab-ci.yml file at the root of your project. Stages: - test - environments .environment: stage: environments variables: TF_ROOT: terraform TF_CLI_ARGS_plan: \"-var-file=../vars/$variables_file.tfvars\" trigger: include: .gitlab-ci/.first-layer.gitlab-ci.yml strategy: depend # Wait for the triggered pipeline to successfully complete forward: yaml_variables: true # Forward variables defined in the trigger job pipeline_variables: true # Forward manual pipeline variables and scheduled pipeline variables review: extends: .environment variables: environment: review/$CI_COMMIT_REF_SLUG TF_STATE_NAME: $CI_COMMIT_REF_SLUG variables_file: review TF_VAR_aws_resources_name: $CI_COMMIT_REF_SLUG # Used in the tag Name of the resources deployed, to easily differenciate them rules: - if: $CI_COMMIT_BRANCH \u0026\u0026 $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH integration: extends: .environment variables: environment: integration TF_STATE_NAME: $environment variables_file: $environment rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH staging: extends: .environment variables: environment: staging TF_STATE_NAME: $environment variables_file: $environment rules: - if: $CI_COMMIT_TAG #### TWEAK # This tweak is needed to display vulnerability results in the merge widgets. # As soon as this issue https://gitlab.com/gitlab-org/gitlab/-/issues/439700 is resolved, the `include` instruction below can be removed. # Until then, the SAST IaC scanners will run in the downstream pipelines, but their results will not be available directly in the merge request widget, making it harder to track them. # Note: This workaround is perfectly safe and will not slow down your pipeline. include: - template: Security/SAST-IaC.gitlab-ci.yml #### END TWEAK This pipeline runs only two stages: test and environments. The former is needed for the TWEAK to run scanners. The later triggers a child pipeline with a different set of variables for each case defined above (push to the branch, merge to the default branch, or tag). We are adding here a dependency with the keyword strategy:depend on our child pipeline so the pipeline view in GitLab will be updated only once the deployment is finished. As you can see here, we are defining a base job, hidden, and we are extending it with specific variables and rules to trigger only one deployment for each target environment. Besides the predefined variables, we are using two new entries that we need to define: The variables specific to each environment: ../vars/$variables_file.tfvars The child pipeline, defined in .gitlab-ci/.first-layer.gitlab-ci.yml Let's start with the smallest part, the variable definitions. The variable definitions We are going here to mix two solutions to provide variables to Terraform: The first one using .tfvars files for all non-sensitive input, which should be stored within GitLab. The second using environment variables with the prefix TF_VAR. That second way to inject variables, associated with the GitLab capacity to mask variables, protect them, and scope them to environments is a powerful solution to prevent sensitive information leakages. (If you consider your production’s private CIDR very sensitive, you could protect it like this, ensuring it is only available for the production environment, for pipelines running against protected branches and tags, and that its value is masked in the job’s logs.) Additionally, each variable file should be controlled through a CODEOWNERS file to set who can modify each of them. [Production owners] vars/production.tfvars @operations-group [Staging owners] vars/staging.tfvars @odupre @operations-group [CodeOwners owners] CODEOWNERS @odupre This article is not a Terraform training, so we will go very fast and simply show here the vars/review.tfvars file. Subsequent environment files are, of course, very similar. Just set the non-sensitive variables and their values here. aws_vpc_cidr = \"10.1.0.0/16\" aws_public_subnet_cidr = \"10.1.1.0/24\" aws_private_subnet_cidr = \"10.1.2.0/24\" The child pipeline This one is where the actual work is done. So, it is slightly more complex than the first one. But there is no difficulty here that we cannot overcome together! As we have seen in the definition of the main pipeline, that downstream pipeline is declared in the file .gitlab-ci/.first-layer.gitlab-ci.yml. Let's break it down into small chunks. We'll see the big picture at the end. Run Terraform commands and secure the code First, we want to run a pipeline for Terraform. We, at GitLab, are open source. So, our Terraform template is open source. And you simply need to include it. This can be achieved with the following snippet: include: - template: Terraform.gitlab-ci.yml This template runs for you the Terraform checks on the formatting and validates your code, before planning and applying it. It also allows you to destroy what you have deployed. And, because GitLab is the a single, unified DevSecOps platform, we are also automatically including two security scanners within that template to find potential threats in your code and warn you before you deploy it to the next environments. Now that we have checked, secured, built, and deployed our code, let's do some tricks. We will cache the job results to reuse them in subsequent pipeline jobs. This is as simple as adding the following piece of code: default: cache: # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy - key: cache-$CI_COMMIT_REF_SLUG fallback_keys: - cache-$CI_DEFAULT_BRANCH paths: - . Here, we are defining a different cache for each commit, falling back to the main branch name if needed. If we look carefully at the templates that we are using, we can see that it has some rules to control when jobs are run. We want to run all controls (both QA and security) on all branches. So, we are going to override these settings. Run controls on all branches GitLab templates are a powerful feature where one can override only a piece of the template. Here, we are interested only in overwriting the rules of some jobs to always run quality and security checks. Everything else defined for these jobs will stay as defined in the template. fmt: rules: - when: always validate: rules: - when: always kics-iac-sast: rules: - when: always iac-sast: rules: - when: always Now that we have enforced the quality and security controls, we want to differentiate how the main environments (integration and staging) in the workflow and review environments behave. Let's start by defining the main environment’s behavior, and we will tweak this configuration for the review environments. CD to integration and staging As defined earlier, we want to deploy the main branch and the tags to these two environments. We are adding rules to control that on both the build and deploy jobs. Then, we want to enable destroy only for the integration as we have defined staging to be too critical to be deleted with a single click. This is error-prone and we don't want to do that. Finally, we are linking the deploy job to the destroy one, so we can stop the environment directly from GitLab GUI. The GIT_STRATEGY is here to prevent retrieving the code from the source branch in the runner when destroying. This would fail if the branch has been deleted manually, so we are relying on the cache to get everything we need to run the Terraform instructions. build: # terraform plan environment: name: $TF_STATE_NAME action: prepare rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH - if: $CI_COMMIT_TAG deploy: # terraform apply --\u003e automatically deploy on corresponding env (integration or staging) when merging to default branch or tagging. Second layer environments (qa and production) will be controlled manually environment: name: $TF_STATE_NAME action: start on_stop: destroy rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH - if: $CI_COMMIT_TAG destroy: extends: .terraform:destroy variables: GIT_STRATEGY: none dependencies: - build environment: name: $TF_STATE_NAME action: stop rules: - if: $CI_COMMIT_TAG # Do not destroy production when: never - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH \u0026\u0026 $TF_DESTROY == \"true\" # Manually destroy integration env. when: manual As said, this matches the need to deploy to integration and staging. But we are still missing a temporary environment where the developers can experience and validate their code without impacts on others. This is where the deployment to the review environment takes place. CD to review environments Deploying to review environment is not too different than deploying to integration and staging. So we will once again leverage GitLab's capacity to overwrite only pieces of job definition here. First, we set rules to run these jobs only on feature branches. Then, we link the deploy_review job to destroy_review. This will allow us to stop the environment manually from the GitLab user interface, but more importantly, it will automatically trigger the environment destruction when the feature branch is closed. This is a good FinOps practice to help you control your operational expenditures. Since Terraform needs a plan file to destroy an infrastructure, exactly like it needs one to build an infrastructure, then we are adding a dependency from destroy_review to build_review, to retrieve its artifacts. Finally, we see here that the environment's name is set to $environment. It has been set in the main pipeline to review/$CI_COMMIT_REF_SLUG, and forwarded to this child pipeline with the instruction trigger:forward:yaml_variables:true. build_review: extends: build rules: - if: $CI_COMMIT_TAG when: never - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH when: on_success deploy_review: extends: deploy dependencies: - build_review environment: name: $environment action: start on_stop: destroy_review # url: https://$CI_ENVIRONMENT_SLUG.example.com rules: - if: $CI_COMMIT_TAG when: never - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH when: on_success destroy_review: extends: destroy dependencies: - build_review environment: name: $environment action: stop rules: - if: $CI_COMMIT_TAG # Do not destroy production when: never - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # Do not destroy staging when: never - when: manual So, to recap, we now have a pipeline that can: Deploy temporary review environments, which are automatically cleaned up when the feature branch is closed Continuously deploy the default branch to integration Continuously deploy the tags to staging Let's now add an extra layer, where we will deploy, based on a manual trigger this time, to qa and production environments. Continously deploy to QA and production Because not everybody is willing to deploy continuously to production, we will add a manual validation to the next two deployments. From a purely CD perspective, we would not add this trigger, but take this as an opportunity to learn how to run jobs from other triggers. So far, we have started a child pipeline from the main pipeline to run all deployments. Since we want to run other deployments from the default branch and the tags, we will add another layer dedicated to these additional steps. Nothing new here. We will just repeat exactly the same process as the one we only did for the main pipeline. Going this way allows you to manipulate as many layers as you need. I have already seen up to nine environments in some places. Without arguing once again on the benefits to have fewer environments, the process that we are using here makes it very easy to implement the same pipeline all the way from early stages to final delivery, while keeping your pipeline definition simple and split in small chunks that you can maintain at no cost. To prevent variable conflicts here, we are just using new var names to identify the Terraform state and input file. .2nd_layer: stage: 2nd_layer variables: TF_ROOT: terraform trigger: include: .gitlab-ci/.second-layer.gitlab-ci.yml # strategy: depend # Do NOT wait for the downstream pipeline to finish to mark upstream pipeline as successful. Otherwise, all pipelines will fail when reaching the pipeline timeout before deployment to 2nd layer. forward: yaml_variables: true # Forward variables defined in the trigger job pipeline_variables: true # Forward manual pipeline variables and scheduled pipeline variables qa: extends: .2nd_layer variables: TF_STATE_NAME_2: qa environment: $TF_STATE_NAME_2 TF_CLI_ARGS_plan_2: \"-var-file=../vars/$TF_STATE_NAME_2.tfvars\" rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH production: extends: .2nd_layer variables: TF_STATE_NAME_2: production environment: $TF_STATE_NAME_2 TF_CLI_ARGS_plan_2: \"-var-file=../vars/$TF_STATE_NAME_2.tfvars\" rules: - if: $CI_COMMIT_TAG One important trick here is the strategy used for the new downstream pipeline. We leave that trigger:strategy to its default value; otherwise, the main pipeline would wait for your grand-child pipeline to finish. With a manual trigger, this could last for a very long time and make your pipeline dashboard harder to read and understand. You have probably already wondered what is the content of that .gitlab-ci/.second-layer.gitlab-ci.yml file we are including here. We will cover that in the next section. The first layer complete pipeline definition If you are looking for a complete view of this first layer (stored in .gitlab-ci/.first-layer.gitlab-ci.yml), just expand the section below. variables: TF_VAR_aws_ami_id: $AWS_AMI_ID TF_VAR_aws_instance_type: $AWS_INSTANCE_TYPE TF_VAR_aws_default_region: $AWS_DEFAULT_REGION include: - template: Terraform.gitlab-ci.yml default: cache: # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy - key: cache-$CI_COMMIT_REF_SLUG fallback_keys: - cache-$CI_DEFAULT_BRANCH paths: - . stages: - validate - test - build - deploy - cleanup - 2nd_layer # Use to deploy a 2nd environment on both the main branch and on the tags fmt: rules: - when: always validate: rules: - when: always kics-iac-sast: rules: - if: $SAST_DISABLED == 'true' || $SAST_DISABLED == '1' when: never - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/ when: never - when: on_success iac-sast: rules: - if: $SAST_DISABLED == 'true' || $SAST_DISABLED == '1' when: never - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/ when: never - when: on_success ########################################################################################################### ## Integration env. and Staging. env ## * Auto-deploy to Integration on merge to main. ## * Auto-deploy to Staging on tag. ## * Integration can be manually destroyed if TF_DESTROY is set to true. ## * Destroy of next env. is not automated to prevent errors. ########################################################################################################### build: # terraform plan environment: name: $TF_STATE_NAME action: prepare rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH - if: $CI_COMMIT_TAG deploy: # terraform apply --\u003e automatically deploy on corresponding env (integration or staging) when merging to default branch or tagging. Second layer environments (qa and production) will be controlled manually environment: name: $TF_STATE_NAME action: start on_stop: destroy rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH - if: $CI_COMMIT_TAG destroy: extends: .terraform:destroy variables: GIT_STRATEGY: none dependencies: - build environment: name: $TF_STATE_NAME action: stop rules: - if: $CI_COMMIT_TAG # Do not destroy production when: never - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH \u0026\u0026 $TF_DESTROY == \"true\" # Manually destroy integration env. when: manual ########################################################################################################### ########################################################################################################### ## Dev env. ## * Temporary environment. Lives and dies with the Merge Request. ## * Auto-deploy on push to feature branch. ## * Auto-destroy on when Merge Request is closed. ########################################################################################################### build_review: extends: build rules: - if: $CI_COMMIT_TAG when: never - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH when: on_success deploy_review: extends: deploy dependencies: - build_review environment: name: $environment action: start on_stop: destroy_review # url: https://$CI_ENVIRONMENT_SLUG.example.com rules: - if: $CI_COMMIT_TAG when: never - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH when: on_success destroy_review: extends: destroy dependencies: - build_review environment: name: $environment action: stop rules: - if: $CI_COMMIT_TAG # Do not destroy production when: never - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # Do not destroy staging when: never - when: manual ########################################################################################################### ########################################################################################################### ## Second layer ## * Deploys from main branch to qa env. ## * Deploys from tag to production. ########################################################################################################### .2nd_layer: stage: 2nd_layer variables: TF_ROOT: terraform trigger: include: .gitlab-ci/.second-layer.gitlab-ci.yml # strategy: depend # Do NOT wait for the downstream pipeline to finish to mark upstream pipeline as successful. Otherwise, all pipelines will fail when reaching the pipeline timeout before deployment to 2nd layer. forward: yaml_variables: true # Forward variables defined in the trigger job pipeline_variables: true # Forward manual pipeline variables and scheduled pipeline variables qa: extends: .2nd_layer variables: TF_STATE_NAME_2: qa environment: $TF_STATE_NAME_2 TF_CLI_ARGS_plan_2: \"-var-file=../vars/$TF_STATE_NAME_2.tfvars\" rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH production: extends: .2nd_layer variables: TF_STATE_NAME_2: production environment: $TF_STATE_NAME_2 TF_CLI_ARGS_plan_2: \"-var-file=../vars/$TF_STATE_NAME_2.tfvars\" rules: - if: $CI_COMMIT_TAG ########################################################################################################### At this stage, we are already deploying safely to three environments. That is my personal ideal recommendation. However, if you need more environments, add them to your CD pipeline. You have certainly already noted that we include a downstream pipeline with the keyword trigger:include. This includes the file .gitlab-ci/.second-layer.gitlab-ci.yml. We want to run almost the same pipeline so obviously, its content is very similar to the one we have detailed above. The main advantage here to define this grand-child pipeline is that it lives on its own, making both variables and rules way easier to define. The grand-child pipeline This second layer pipeline is a brand new pipeline. Hence, it needs to mimic the first layer definition with: Inclusion of the Terraform template. Enforcement of security checks. Terraform validation would be duplicates of the first layer, but security scanners may find threats that did not yet exist when scanners previously ran (for example, if you deploy to production a couple of days after your deployment to staging). Overwrite build and deploy jobs to set specific rules. Note that the destroy stage is no longer automated to prevent too fast deletions. As explained above, the TF_STATE_NAME and TF_CLI_ARGS_plan have been provided from the main pipeline to the child pipeline. We needed another variable name to pass these values from the child pipeline to here, the grand-child pipeline. This is why they are postfixed with _2 in the child pipeline and the value is copied back to the appropriate variable during the before_script here. Since we have already broken down each step above, we can zoom out here directly to the broad view of the global second layer definition (stored in .gitlab-ci/.second-layer.gitlab-ci.yml). # Use to deploy a second environment on both the default branch and the tags. include: template: Terraform.gitlab-ci.yml stages: - validate - test - build - deploy fmt: rules: - when: never validate: rules: - when: never kics-iac-sast: rules: - if: $SAST_DISABLED == 'true' || $SAST_DISABLED == '1' when: never - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/ when: never - when: always ########################################################################################################### ## QA env. and Prod. env ## * Manually trigger build and auto-deploy in QA ## * Manually trigger both build and deploy in Production ## * Destroy of these env. is not automated to prevent errors. ########################################################################################################### build: # terraform plan cache: # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy - key: $TF_STATE_NAME_2 fallback_keys: - cache-$CI_DEFAULT_BRANCH paths: - . environment: name: $TF_STATE_NAME_2 action: prepare before_script: # Hack to set new variable values on the second layer, while still using the same variable names. Otherwise, due to variable precedence order, setting new value in the trigger job, does not cascade these new values to the downstream pipeline - TF_STATE_NAME=$TF_STATE_NAME_2 - TF_CLI_ARGS_plan=$TF_CLI_ARGS_plan_2 rules: - when: manual deploy: # terraform apply cache: # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy - key: $TF_STATE_NAME_2 fallback_keys: - cache-$CI_DEFAULT_BRANCH paths: - . environment: name: $TF_STATE_NAME_2 action: start before_script: # Hack to set new variable values on the second layer, while still using the same variable names. Otherwise, due to variable precedence order, setting new value in the trigger job, does not cascade these new values to the downstream pipeline - TF_STATE_NAME=$TF_STATE_NAME_2 - TF_CLI_ARGS_plan=$TF_CLI_ARGS_plan_2 rules: - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH - if: $CI_COMMIT_TAG \u0026\u0026 $TF_AUTO_DEPLOY == \"true\" - if: $CI_COMMIT_TAG when: manual ########################################################################################################### Et voilà. We are ready to go. Feel free to change the way you control your job executions, leveraging for example GitLab's capacity to delay a job before deploying to production. Try it yourself We finally reached our destination. We are now able to control deployments to five different environments, with only the feature branches, the main branch, and tags. We are intensively reusing GitLab open source templates to ensure efficiency and security in our pipelines. We are leveraging GitLab template capacities to overwrite only the blocks that need custom control. We have split the pipeline in small chunks, controlling the downstream pipelines to match exactly what we need. From there, the floor is yours. You could, for example, easily update the main pipeline to trigger downstream pipelines for your software source code, with the trigger:rules:changes keyword. And use another template depending on the changes that happened. But that is another story.",
  "image": "https://images.ctfassets.net/r9o86ar0p03f/3Ldy1urjMStQCl4qnOBvE0/1cdde9c89eef7a81d19057ad22ab371e/AdobeStock_397632156.jpeg?fm=webp\u0026w=820\u0026h=500",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-v-b794d8fe=\"\" data-v-7488832a=\"\" data-v-74bd29c6=\"\"\u003e\u003cp\u003eDevSecOps teams sometimes require the ability to manage continuous deployment across multiple environments — and they need to do so without changing their workflows. The \u003ca href=\"https://about.gitlab.com/\"\u003eGitLab DevSecOps platform\u003c/a\u003e supports this need, including temporary, on-the-fly sandboxes, with a minimalist approach. In this article, you\u0026#39;ll learn how to run continuous deployment of infrastructure using Terraform, over multiple environments.\u003c/p\u003e\n\u003cp\u003eThis strategy can easily be applied to any project, whether it is infrastructure as code (IaC) relying on another technology, such as \u003ca href=\"https://www.pulumi.com/\"\u003ePulumi\u003c/a\u003e or \u003ca href=\"https://www.ansible.com/\"\u003eAnsible\u003c/a\u003e, source code in any language, or a monorepo that mixes many languages.\u003c/p\u003e\n\u003cp\u003eThe final pipeline that you will have at the end of this tutorial will deploy:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA temporary \u003cstrong\u003ereview\u003c/strong\u003e environment for each feature branch.\u003c/li\u003e\n\u003cli\u003eAn \u003cstrong\u003eintegration\u003c/strong\u003e environment, easy to wipe out and deployed from the main branch.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eQA\u003c/strong\u003e environment, also deployed from the main branch, to run quality assurance steps.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003estaging\u003c/strong\u003e environment, deployed for every tag. This is the last round before production.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003eproduction\u003c/strong\u003e environment, just after the staging environment. This one is triggered manually for demonstration, but can also be continuously deployed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHere is the legend for the flow charts in this article:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRound boxes are the GitLab branches.\u003c/li\u003e\n\u003cli\u003eSquare boxes are the environments.\u003c/li\u003e\n\u003cli\u003eText on the arrows are the actions to flow from one box to the next.\u003c/li\u003e\n\u003cli\u003eAngled squares are decision steps.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003eflowchart LR\n    A(main) --\u0026gt;|new feature| B(feature_X)\n\n    B --\u0026gt;|auto deploy| C[review/feature_X]\n    B --\u0026gt;|merge| D(main)\n    C --\u0026gt;|destroy| D\n\n    D --\u0026gt;|auto deploy| E[integration]\n    E --\u0026gt;|manual| F[qa]\n\n    D --\u0026gt;|tag| G(X.Y.Z)\n    F --\u0026gt;|validate| G\n\n    G --\u0026gt;|auto deploy| H[staging]\n    H --\u0026gt;|manual| I{plan}\n    I --\u0026gt;|manual| J[production]\n\u003c/pre\u003e\n\u003cp\u003eOn each step, you\u0026#39;ll learn the \u003ca href=\"#why\"\u003ewhy\u003c/a\u003e and the \u003ca href=\"#what\"\u003ewhat\u003c/a\u003e before moving to the \u003ca href=\"#how\"\u003ehow\u003c/a\u003e. This will help you fully understand and replicate this tutorial.\u003c/p\u003e\n\u003ch2 id=\"why\" tabindex=\"-1\"\u003eWhy \u003ca href=\"#why\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://about.gitlab.com/topics/ci-cd/#what-is-continuous-integration-ci\"\u003eContinuous integration\u003c/a\u003e is almost a de facto standard. Most companies have implemented CI pipelines or are willing to standardize their practice.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://about.gitlab.com/topics/ci-cd/#what-is-continuous-delivery-cd\"\u003eContinuous delivery\u003c/a\u003e, which pushes artifacts to a repository or registry at the end of the CI pipeline, is also popular.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eContinuous deployment, which goes further and deploys these artifacts automatically, is less widespread. When it has been implemented, we see it essentially in the application field. When discussing continuously deploying  infrastructure, the picture seems less obvious, and is more about managing several environments. In contrast, testing, securing, and verifying the infrastructure\u0026#39;s code seems more challenging. And this is one of the fields where DevOps has not yet reached its maturity. One of the other fields is to shift security left, integrating security teams and, more importantly, security concerns, earlier in the delivery lifecycle, to upgrade from DevOps to \u003cem\u003e\u003cstrong\u003eDevSecOps\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGiven this high-level picture, in this tutorial, you will work toward a simple, yet efficient way to implement DevSecOps for your infrastructure through the example of deploying resources to five environments, gradually progressing from development to production.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Even if I advocate embracing a FinOps approach and reducing the number of environments, sometimes there are excellent reasons to maintain more than just dev, staging, and production. So, please, adapt the examples below to match your needs.\u003c/p\u003e\n\u003ch2 id=\"what\" tabindex=\"-1\"\u003eWhat \u003ca href=\"#what\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe rise of cloud technology has driven the usage of IaC. Ansible and Terraform were among the first to pave the road here. OpenTofu, Pulumi, AWS CDK, Google Deploy Manager, and many others joined the party.\u003c/p\u003e\n\u003cp\u003eDefining IaC is a perfect solution to feel safe when deploying infrastructure. You can test it, deploy it, and replay it again and again until you reach your goal.\u003c/p\u003e\n\u003cp\u003eUnfortunately, we often see companies maintain several branches, or even repositories, for each of their target environments. And this is where the problems start. They are no longer enforcing a process. They are no longer ensuring that any change in the production code base has been accurately tested in previous environments. And they start seeing drifts from one environment to the other.\u003c/p\u003e\n\u003cp\u003eI realized this tutorial was necessary when, at a conference I attended, every participant said they do not have a workflow that enforces the infrastructure to be tested thoroughly before being deployed to production. And they all agreed that sometimes they patch the code directly in production. Sure, this is fast, but is it safe? How do you report back to previous environments? How do you ensure there are no side effects? How do you control whether you are putting your company at risk with new vulnerabilities being pushed too quickly in production?\u003c/p\u003e\n\u003cp\u003eThe question of \u003cem\u003ewhy\u003c/em\u003e DevOps teams deploy directly to production is critical here. Is it because the pipeline could be more efficient or faster? Is there no automation? Or, even worse, because there is \u003cem\u003eno way to test accurately outside of production\u003c/em\u003e?\u003c/p\u003e\n\u003cp\u003eIn the next section, you will learn how to implement automation for your infrastructure and ensure that your DevOps team can effectively test what you are doing before pushing to any environment impacting others. You will see how your code is secured and its deployment is controlled, end-to-end.\u003c/p\u003e\n\u003ch2 id=\"how\" tabindex=\"-1\"\u003eHow \u003ca href=\"#how\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAs mentioned earlier, there are many IaC languages out there nowadays and we objectively cannot cover \u003cem\u003eall\u003c/em\u003e of them in a single article. So, I will rely on a basic Terraform code running on Version 1.4. Please do not focus on the IaC language itself but instead on the process that you could apply to your own ecosystem.\u003c/p\u003e\n\u003ch3 id=\"the-terraform-code\" tabindex=\"-1\"\u003eThe Terraform code \u003ca href=\"#the-terraform-code\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLet\u0026#39;s start with a fundamental Terraform code.\u003c/p\u003e\n\u003cp\u003eWe are going to deploy to AWS, a virtual private cloud (VPC), which is a virtual network. In that VPC, we will deploy a public and a private subnet. As their name implies, they are subnets of the main VPC. Finally, we will add an Elastic Cloud Compute (EC2) instance (a virtual machine) in the public subnet.\u003c/p\u003e\n\u003cp\u003eThis demonstrates the deployment of four resources without adding too much complexity. The idea is to focus on the pipeline, not the code.\u003c/p\u003e\n\u003cp\u003eHere is the target we want to reach for your repository.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/4kyISHbgIyCDxq4SWLoVPI/2a4d265573f2cba5d90944e2d09a681f/image5.png\" alt=\"target for repository\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s do it step by step.\u003c/p\u003e\n\u003cp\u003eFirst, we declare all resources in a \u003ccode\u003eterraform/main.tf\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprovider \u0026#34;aws\u0026#34; {\n  region = var.aws_default_region\n}\n\nresource \u0026#34;aws_vpc\u0026#34; \u0026#34;main\u0026#34; {\n  cidr_block = var.aws_vpc_cidr\n\n  tags = {\n    Name     = var.aws_resources_name\n  }\n}\n\nresource \u0026#34;aws_subnet\u0026#34; \u0026#34;public_subnet\u0026#34; {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = var.aws_public_subnet_cidr\n\n  tags = {\n    Name = \u0026#34;Public Subnet\u0026#34;\n  }\n}\nresource \u0026#34;aws_subnet\u0026#34; \u0026#34;private_subnet\u0026#34; {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = var.aws_private_subnet_cidr\n\n  tags = {\n    Name = \u0026#34;Private Subnet\u0026#34;\n  }\n}\n\nresource \u0026#34;aws_instance\u0026#34; \u0026#34;sandbox\u0026#34; {\n  ami           = var.aws_ami_id\n  instance_type = var.aws_instance_type\n\n  subnet_id = aws_subnet.public_subnet.id\n\n  tags = {\n    Name     = var.aws_resources_name\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, there are a couple of variables that are needed for this code, so let\u0026#39;s declare them in a \u003ccode\u003eterraform/variables.tf\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evariable \u0026#34;aws_ami_id\u0026#34; {\n  description = \u0026#34;The AMI ID of the image being deployed.\u0026#34;\n  type        = string\n}\n\nvariable \u0026#34;aws_instance_type\u0026#34; {\n  description = \u0026#34;The instance type of the VM being deployed.\u0026#34;\n  type        = string\n  default     = \u0026#34;t2.micro\u0026#34;\n}\n\nvariable \u0026#34;aws_vpc_cidr\u0026#34; {\n  description = \u0026#34;The CIDR of the VPC.\u0026#34;\n  type        = string\n  default     = \u0026#34;10.0.0.0/16\u0026#34;\n}\n\nvariable \u0026#34;aws_public_subnet_cidr\u0026#34; {\n  description = \u0026#34;The CIDR of the public subnet.\u0026#34;\n  type        = string\n  default     = \u0026#34;10.0.1.0/24\u0026#34;\n}\n\nvariable \u0026#34;aws_private_subnet_cidr\u0026#34; {\n  description = \u0026#34;The CIDR of the private subnet.\u0026#34;\n  type        = string\n  default     = \u0026#34;10.0.2.0/24\u0026#34;\n}\n\nvariable \u0026#34;aws_default_region\u0026#34; {\n  description = \u0026#34;Default region where resources are deployed.\u0026#34;\n  type        = string\n  default     = \u0026#34;eu-west-3\u0026#34;\n}\n\nvariable \u0026#34;aws_resources_name\u0026#34; {\n  description = \u0026#34;Default name for the resources.\u0026#34;\n  type        = string\n  default     = \u0026#34;demo\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlready, we are almost good to go on the IaC side. What\u0026#39;s missing is a way to share the Terraform states. For those who don\u0026#39;t know, Terraform works schematically doing the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eplan\u003c/code\u003e checks the differences between the current state of the infrastructure and what is defined in the code. Then, it outputs the differences.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eapply\u003c/code\u003e applies the differences in the \u003ccode\u003eplan\u003c/code\u003e and updates the state.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFirst round, the state is empty, then it is filled with the details (ID, etc.) of the resources applied by Terraform.\u003c/p\u003e\n\u003cp\u003eThe problem is: Where is that state stored? How do we share it so several developers can collaborate on code?\u003c/p\u003e\n\u003cp\u003eThe solution is fairly simple: Leverage GitLab to store and share the state for you through a \u003ca href=\"https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html\"\u003eTerraform HTTP backend\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe first step in using this backend is to create the most simple \u003ccode\u003eterraform/backend.tf\u003c/code\u003e file. The second step will be handled in the pipeline.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eterraform {\n  backend \u0026#34;http\u0026#34; {\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEt voilà! We have a bare minimum Terraform code to deploy these four resources. We will provide the variable values at the runtime, so let\u0026#39;s do that later.\u003c/p\u003e\n\u003ch3 id=\"the-workflow\" tabindex=\"-1\"\u003eThe workflow \u003ca href=\"#the-workflow\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe workflow that we are going to implement now is the following:\u003c/p\u003e\n\u003cpre\u003eflowchart LR\n    A(main) --\u0026gt;|new feature| B(feature_X)\n\n    B --\u0026gt;|auto deploy| C[review/feature_X]\n    B --\u0026gt;|merge| D(main)\n    C --\u0026gt;|destroy| D\n\n    D --\u0026gt;|auto deploy| E[integration]\n    E --\u0026gt;|manual| F[qa]\n\n    D --\u0026gt;|tag| G(X.Y.Z)\n    F --\u0026gt;|validate| G\n\n    G --\u0026gt;|auto deploy| H[staging]\n    H --\u0026gt;|manual| I{plan}\n    I --\u0026gt;|manual| J[production]\n\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003eCreate a \u003cstrong\u003efeature\u003c/strong\u003e branch. This will continuously run all scanners on the code to ensure that it is still compliant and secured. This code will be continuously deployed to a temporary environment \u003ccode\u003ereview/feature_branch\u003c/code\u003e with the name of the current branch. This is a safe environment where the developers and operations teams can test their code without impacting anybody. This is also where we will enforce the process, like enforcing code reviews and running scanners, to ensure that the quality and security of the code are acceptable and do not put your assets at risk. The infrastructure deployed by this branch is automatically destroyed when the branch is closed. This helps you keep your budget under control.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003eflowchart LR\n    A(main) --\u0026gt;|new feature| B(feature_X)\n\n    B --\u0026gt;|auto deploy| C[review/feature_X]\n    B --\u0026gt;|merge| D(main)\n    C --\u0026gt;|destroy| D\n\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eOnce approved, the feature branch will be \u003cstrong\u003emerged\u003c/strong\u003e into the main branch. This is a \u003ca href=\"https://docs.gitlab.com/ee/user/project/protected_branches.html\"\u003eprotected branch\u003c/a\u003e where no one can push. This is mandatory to ensure that every change request to production is thoroughly tested. That branch is also continuously deployed. The target here is the \u003ccode\u003eintegration\u003c/code\u003e environment. To keep this environment slightly more stable, its deletion is not automated but can be triggered manually.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003eflowchart LR\n    D(main) --\u0026gt;|auto deploy| E[integration]\n\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eFrom there, manual approval is required to trigger the next deployment. This will deploy the main branch to the \u003ccode\u003eqa\u003c/code\u003e environment. Here, I have set a rule to prevent deletion from the pipeline. The idea is that this environment should be quite stable (after all, it\u0026#39;s already the third environment), and I would like to prevent deletion by mistake. Feel free to adapt the rules to match your processes.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003eflowchart LR\n    D(main)--\u0026gt;|auto deploy| E[integration]\n    E --\u0026gt;|manual| F[qa]\n\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eTo proceed, we will need to \u003cstrong\u003etag\u003c/strong\u003e the code. We are relying on \u003ca href=\"https://docs.gitlab.com/ee/user/project/protected_tags.html\"\u003eprotected tags\u003c/a\u003e here to ensure that only a specific set of users are allowed to deploy to these last two environments. This will immediately trigger a deployment to the \u003ccode\u003estaging\u003c/code\u003e environment.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003eflowchart LR\n    D(main) --\u0026gt;|tag| G(X.Y.Z)\n    F[qa] --\u0026gt;|validate| G\n\n    G --\u0026gt;|auto deploy| H[staging]\n\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eFinally, we are landing to \u003ccode\u003eproduction\u003c/code\u003e. When discussing infrastructure, it is often challenging to deploy progressively (10%, 25%, etc.), so we will deploy the whole infrastructure. Still, we control that deployment with a manual trigger of this last step. And to enforce maximum control on this highly critical environment, we will control it as a \u003ca href=\"https://docs.gitlab.com/ee/ci/environments/protected_environments.html\"\u003eprotected environment\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003eflowchart LR\n    H[staging] --\u0026gt;|manual| I{plan}\n    I --\u0026gt;|manual| J[production]\n\u003c/pre\u003e\n\u003ch3 id=\"the-pipeline\" tabindex=\"-1\"\u003eThe pipeline \u003ca href=\"#the-pipeline\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTo implement the above \u003ca href=\"#the-workflow\"\u003eworkflow\u003c/a\u003e, we are now going to implement a pipeline with two \u003ca href=\"https://docs.gitlab.com/ee/ci/pipelines/downstream_pipelines.html\"\u003edownstream pipelines\u003c/a\u003e.\u003c/p\u003e\n\u003ch4 id=\"the-main-pipeline\" tabindex=\"-1\"\u003eThe main pipeline \u003ca href=\"#the-main-pipeline\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eLet\u0026#39;s start with the main pipeline. This is the one that will be triggered automatically on any \u003cstrong\u003epush to a feature branch\u003c/strong\u003e, any \u003cstrong\u003emerge to the default branch\u003c/strong\u003e, or any \u003cstrong\u003etag\u003c/strong\u003e. \u003cem\u003eThe one\u003c/em\u003e that will do true \u003cstrong\u003econtinuous deployment\u003c/strong\u003e to the following environments: \u003ccode\u003edev\u003c/code\u003e, \u003ccode\u003eintegration\u003c/code\u003e, and \u003ccode\u003estaging\u003c/code\u003e. And it is declared in the \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file at the root of your project.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/5VZtpwJ0wirGoGhlBp5goB/3ff5133e3e5f138a370ea91c47e19205/image1.png\" alt=\"the repository target\"/\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eStages:\n  - test\n  - environments\n\n.environment:\n  stage: environments\n  variables:\n    TF_ROOT: terraform\n    TF_CLI_ARGS_plan: \u0026#34;-var-file=../vars/$variables_file.tfvars\u0026#34;\n  trigger:\n    include: .gitlab-ci/.first-layer.gitlab-ci.yml\n    strategy: depend            # Wait for the triggered pipeline to successfully complete\n    forward:\n      yaml_variables: true      # Forward variables defined in the trigger job\n      pipeline_variables: true  # Forward manual pipeline variables and scheduled pipeline variables\n\nreview:\n  extends: .environment\n  variables:\n    environment: review/$CI_COMMIT_REF_SLUG\n    TF_STATE_NAME: $CI_COMMIT_REF_SLUG\n    variables_file: review\n    TF_VAR_aws_resources_name: $CI_COMMIT_REF_SLUG  # Used in the tag Name of the resources deployed, to easily differenciate them\n  rules:\n    - if: $CI_COMMIT_BRANCH \u0026amp;\u0026amp; $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n\nintegration:\n  extends: .environment\n  variables:\n    environment: integration\n    TF_STATE_NAME: $environment\n    variables_file: $environment\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\nstaging:\n  extends: .environment\n  variables:\n    environment: staging\n    TF_STATE_NAME: $environment\n    variables_file: $environment\n  rules:\n    - if: $CI_COMMIT_TAG\n\n#### TWEAK\n# This tweak is needed to display vulnerability results in the merge widgets.\n# As soon as this issue https://gitlab.com/gitlab-org/gitlab/-/issues/439700 is resolved, the `include` instruction below can be removed.\n# Until then, the SAST IaC scanners will run in the downstream pipelines, but their results will not be available directly in the merge request widget, making it harder to track them.\n# Note: This workaround is perfectly safe and will not slow down your pipeline.\ninclude:\n  - template: Security/SAST-IaC.gitlab-ci.yml\n#### END TWEAK\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis pipeline runs only two stages: \u003ccode\u003etest\u003c/code\u003e and  \u003ccode\u003eenvironments\u003c/code\u003e. The former is needed for the \u003cem\u003eTWEAK\u003c/em\u003e to run scanners. The later triggers a child pipeline with a different set of variables for each case defined above (push to the branch, merge to the default branch, or tag).\u003c/p\u003e\n\u003cp\u003eWe are adding here a dependency with the keyword \u003ca href=\"https://docs.gitlab.com/ee/ci/yaml/index.html#triggerstrategy\"\u003estrategy:depend\u003c/a\u003e on our child pipeline so the pipeline view in GitLab will be updated only once the deployment is finished.\u003c/p\u003e\n\u003cp\u003eAs you can see here, we are defining a base job, \u003ca href=\"https://docs.gitlab.com/ee/ci/jobs/#hide-jobs\"\u003ehidden\u003c/a\u003e, and we are extending it with specific variables and rules to trigger only one deployment for each target environment.\u003c/p\u003e\n\u003cp\u003eBesides the \u003ca href=\"https://docs.gitlab.com/ee/ci/variables/predefined_variables.html\"\u003epredefined variables\u003c/a\u003e, we are using two new entries that we need to define:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#the-variable-definitions\"\u003eThe variables specific\u003c/a\u003e to each environment: \u003ccode\u003e../vars/$variables_file.tfvars\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#the-child-pipeline\"\u003eThe child pipeline\u003c/a\u003e, defined in \u003ccode\u003e.gitlab-ci/.first-layer.gitlab-ci.yml\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLet\u0026#39;s start with the smallest part, the variable definitions.\u003c/p\u003e\n\u003ch3 id=\"the-variable-definitions\" tabindex=\"-1\"\u003eThe variable definitions \u003ca href=\"#the-variable-definitions\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWe are going here to mix two solutions to provide variables to Terraform:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first one using \u003ca href=\"https://developer.hashicorp.com/terraform/language/values/variables#variable-definitions-tfvars-files\"\u003e.tfvars files\u003c/a\u003e for all non-sensitive input, which should be stored within GitLab.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/6rAyFn6Q1tn2mlVwrwl1ix/0c27108a5cc969f46c9e601d1d3b97cf/image2.png\" alt=\"solution one to provide variables to Terraform\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe second using \u003ca href=\"https://developer.hashicorp.com/terraform/language/values/variables#environment-variables\"\u003eenvironment variables\u003c/a\u003e with the prefix \u003ccode\u003eTF_VAR\u003c/code\u003e. That second way to inject variables, associated with the GitLab capacity to \u003ca href=\"https://docs.gitlab.com/ee/ci/variables/#mask-a-cicd-variable\"\u003emask variables\u003c/a\u003e, \u003ca href=\"https://docs.gitlab.com/ee/ci/variables/#protect-a-cicd-variable\"\u003eprotect them\u003c/a\u003e, and \u003ca href=\"https://docs.gitlab.com/ee/ci/environments/index.html#limit-the-environment-scope-of-a-cicd-variable\"\u003escope them to environments\u003c/a\u003e is a powerful solution to \u003cstrong\u003eprevent sensitive information leakages\u003c/strong\u003e. (If you consider your production’s private CIDR very sensitive, you could protect it like this, ensuring it is only available for the \u003ccode\u003eproduction\u003c/code\u003e environment, for pipelines running against protected branches and tags, and that its value is masked in the job’s logs.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/6SIld37mwZijL5XTFwZDU8/9a5c9c9ccea51d84d4b192cf7e8b7b9d/image4.png\" alt=\"solution two to provide variables to Terraform\"/\u003e\u003c/p\u003e\n\u003cp\u003eAdditionally, each variable file should be controlled through a \u003ca href=\"https://docs.gitlab.com/ee/user/project/codeowners/\"\u003e\u003ccode\u003eCODEOWNERS\u003c/code\u003e file\u003c/a\u003e to set who can modify each of them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[Production owners] \nvars/production.tfvars @operations-group\n\n[Staging owners]\nvars/staging.tfvars @odupre @operations-group\n\n[CodeOwners owners]\nCODEOWNERS @odupre\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis article is not a Terraform training, so we will go very fast and simply show here the \u003ccode\u003evars/review.tfvars\u003c/code\u003e file. Subsequent environment files are, of course, very similar. Just set the non-sensitive variables and their values here.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws_vpc_cidr = \u0026#34;10.1.0.0/16\u0026#34;\naws_public_subnet_cidr = \u0026#34;10.1.1.0/24\u0026#34;\naws_private_subnet_cidr = \u0026#34;10.1.2.0/24\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"the-child-pipeline\" tabindex=\"-1\"\u003eThe child pipeline \u003ca href=\"#the-child-pipeline\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eThis one is where the actual work is done. So, it is slightly more complex than the first one. But there is no difficulty here that we cannot overcome together!\u003c/p\u003e\n\u003cp\u003eAs we have seen in the definition of the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e, that downstream pipeline is declared in the file \u003ccode\u003e.gitlab-ci/.first-layer.gitlab-ci.yml\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://images.ctfassets.net/r9o86ar0p03f/2lCJbyciVLeG6EzgaULxxr/02e3010ca06bf2cee96948f2b8d3fa75/image3.png\" alt=\"Downstream pipeline declared in file\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s break it down into small chunks. We\u0026#39;ll see the big picture at the end.\u003c/p\u003e\n\u003ch5 id=\"run-terraform-commands-and-secure-the-code\" tabindex=\"-1\"\u003eRun Terraform commands and secure the code \u003ca href=\"#run-terraform-commands-and-secure-the-code\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eFirst, we want to run a pipeline for Terraform. We, at GitLab, are open source. So, our Terraform template is open source. And you simply need to include it. This can be achieved with the following snippet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einclude:\n  - template: Terraform.gitlab-ci.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis template runs for you the Terraform checks on the formatting and validates your code, before planning and applying it. It also allows you to destroy what you have deployed.\u003c/p\u003e\n\u003cp\u003eAnd, because GitLab is the a single, unified DevSecOps platform, we are also automatically including two security scanners within that template to find potential threats in your code and warn you before you deploy it to the next environments.\u003c/p\u003e\n\u003cp\u003eNow that we have checked, secured, built, and deployed our code, let\u0026#39;s do some tricks.\u003c/p\u003e\n\n\u003cp\u003eWe will cache the job results to reuse them in subsequent pipeline jobs. This is as simple as adding the following piece of code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edefault:\n  cache:  # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy\n    - key: cache-$CI_COMMIT_REF_SLUG\n      fallback_keys:\n        - cache-$CI_DEFAULT_BRANCH\n      paths:\n        - .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, we are defining a different cache for each commit, falling back to the main branch name if needed.\u003c/p\u003e\n\u003cp\u003eIf we look carefully at the templates that we are using, we can see that it has some rules to control when jobs are run. We want to run all controls (both QA and security) on all branches. So, we are going to override these settings.\u003c/p\u003e\n\u003ch5 id=\"run-controls-on-all-branches\" tabindex=\"-1\"\u003eRun controls on all branches \u003ca href=\"#run-controls-on-all-branches\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eGitLab templates are a powerful feature where one can override only a piece of the template. Here, we are interested only in overwriting the rules of some jobs to always run quality and security checks. Everything else defined for these jobs will stay as defined in the template.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efmt:\n  rules:\n    - when: always\n\nvalidate:\n  rules:\n    - when: always\n\nkics-iac-sast:\n  rules:\n    - when: always\n\niac-sast:\n  rules:\n    - when: always\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that we have enforced the quality and security controls, we want to differentiate how the main environments (integration and staging) in the \u003ca href=\"#the-workflow\"\u003eworkflow\u003c/a\u003e and review environments behave. Let\u0026#39;s start by defining the main environment’s behavior, and we will tweak this configuration for the review environments.\u003c/p\u003e\n\u003ch5 id=\"cd-to-integration-and-staging\" tabindex=\"-1\"\u003eCD to integration and staging \u003ca href=\"#cd-to-integration-and-staging\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eAs defined earlier, we want to deploy the main branch and the tags to these two environments. We are adding rules to control that on both the \u003ccode\u003ebuild\u003c/code\u003e and \u003ccode\u003edeploy\u003c/code\u003e jobs. Then, we want to enable \u003ccode\u003edestroy\u003c/code\u003e only for the \u003ccode\u003eintegration\u003c/code\u003e as we have defined \u003ccode\u003estaging\u003c/code\u003e to be too critical to be deleted with a single click. This is error-prone and we don\u0026#39;t want to do that.\u003c/p\u003e\n\u003cp\u003eFinally, we are linking the \u003ccode\u003edeploy\u003c/code\u003e job to the \u003ccode\u003edestroy\u003c/code\u003e one, so we can \u003ccode\u003estop\u003c/code\u003e the environment directly from GitLab GUI.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eGIT_STRATEGY\u003c/code\u003e is here to prevent retrieving the code from the source branch in the runner when destroying. This would fail if the branch has been deleted manually, so we are relying on the cache to get everything we need to run the Terraform instructions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebuild:  # terraform plan\n  environment:\n    name: $TF_STATE_NAME\n    action: prepare\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    - if: $CI_COMMIT_TAG\n\ndeploy: # terraform apply --\u0026gt; automatically deploy on corresponding env (integration or staging) when merging to default branch or tagging. Second layer environments (qa and production) will be controlled manually\n  environment: \n    name: $TF_STATE_NAME\n    action: start\n    on_stop: destroy\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    - if: $CI_COMMIT_TAG\n\ndestroy:\n  extends: .terraform:destroy\n  variables:\n    GIT_STRATEGY: none\n  dependencies:\n    - build\n  environment:\n    name: $TF_STATE_NAME\n    action: stop\n  rules:\n    - if: $CI_COMMIT_TAG  # Do not destroy production\n      when: never\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH \u0026amp;\u0026amp; $TF_DESTROY == \u0026#34;true\u0026#34; # Manually destroy integration env.\n      when: manual\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs said, this matches the need to deploy to \u003ccode\u003eintegration\u003c/code\u003e and \u003ccode\u003estaging\u003c/code\u003e. But we are still missing a temporary environment where the developers can experience and validate their code without impacts on others. This is where the deployment to the \u003ccode\u003ereview\u003c/code\u003e environment takes place.\u003c/p\u003e\n\u003ch5 id=\"cd-to-review-environments\" tabindex=\"-1\"\u003eCD to review environments \u003ca href=\"#cd-to-review-environments\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eDeploying to review environment is not too different than deploying to \u003ccode\u003eintegration\u003c/code\u003e and \u003ccode\u003estaging\u003c/code\u003e. So we will once again leverage GitLab\u0026#39;s capacity to overwrite only pieces of job definition here.\u003c/p\u003e\n\u003cp\u003eFirst, we set rules to run these jobs only on feature branches.\u003c/p\u003e\n\u003cp\u003eThen, we link the \u003ccode\u003edeploy_review\u003c/code\u003e job to \u003ccode\u003edestroy_review\u003c/code\u003e. This will allow us to stop the environment \u003cstrong\u003emanually\u003c/strong\u003e from the GitLab user interface, but more importantly, it will \u003cstrong\u003eautomatically trigger the environment destruction\u003c/strong\u003e when the feature branch is closed. This is a good FinOps practice to help you control your operational expenditures.\u003c/p\u003e\n\u003cp\u003eSince Terraform needs a plan file to destroy an infrastructure, exactly like it needs one to build an infrastructure, then we are adding a dependency from \u003ccode\u003edestroy_review\u003c/code\u003e to \u003ccode\u003ebuild_review\u003c/code\u003e, to retrieve its artifacts.\u003c/p\u003e\n\u003cp\u003eFinally, we see here that the environment\u0026#39;s name is set to \u003ccode\u003e$environment\u003c/code\u003e. It has been set in the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e to \u003ccode\u003ereview/$CI_COMMIT_REF_SLUG\u003c/code\u003e, and forwarded to this child pipeline with the instruction \u003ccode\u003etrigger:forward:yaml_variables:true\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebuild_review:\n  extends: build\n  rules:\n    - if: $CI_COMMIT_TAG\n      when: never\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: on_success\n\ndeploy_review:\n  extends: deploy\n  dependencies:\n    - build_review\n  environment:\n    name: $environment\n    action: start\n    on_stop: destroy_review\n    # url: https://$CI_ENVIRONMENT_SLUG.example.com\n  rules:\n    - if: $CI_COMMIT_TAG\n      when: never\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: on_success\n\ndestroy_review:\n  extends: destroy\n  dependencies:\n    - build_review\n  environment:\n    name: $environment\n    action: stop\n  rules:\n    - if: $CI_COMMIT_TAG  # Do not destroy production\n      when: never\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH   # Do not destroy staging\n      when: never\n    - when: manual\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo, to recap, we now have a pipeline that can:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDeploy temporary review environments, which are automatically cleaned up when the feature branch is closed\u003c/li\u003e\n\u003cli\u003eContinuously deploy the \u003cstrong\u003edefault branch\u003c/strong\u003e to \u003ccode\u003eintegration\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eContinuously deploy the \u003cstrong\u003etags\u003c/strong\u003e to \u003ccode\u003estaging\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet\u0026#39;s now add an extra layer, where we will deploy, based on a manual trigger this time, to \u003ccode\u003eqa\u003c/code\u003e and \u003ccode\u003eproduction\u003c/code\u003e environments.\u003c/p\u003e\n\u003ch5 id=\"continously-deploy-to-qa-and-production\" tabindex=\"-1\"\u003eContinously deploy to QA and production \u003ca href=\"#continously-deploy-to-qa-and-production\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eBecause not everybody is willing to deploy continuously to production, we will add a manual validation to the next two deployments. From a purely \u003cstrong\u003eCD\u003c/strong\u003e perspective, we would not add this trigger, but take this as an opportunity to learn how to run jobs from other triggers.\u003c/p\u003e\n\u003cp\u003eSo far, we have started a \u003ca href=\"#the-child-pipeline\"\u003echild pipeline\u003c/a\u003e from the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e to run all deployments.\u003c/p\u003e\n\u003cp\u003eSince we want to run other deployments from the default branch and the tags, we will add another layer dedicated to these additional steps. Nothing new here. We will just repeat exactly the same process as the one we only did for the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e. Going this way allows you to manipulate as many layers as you need. I have already seen up to nine environments in some places.\u003c/p\u003e\n\u003cp\u003eWithout arguing once again on the benefits to have fewer environments, the process that we are using here makes it very easy to implement the same pipeline all the way from early stages to final delivery, while keeping your pipeline definition simple and split in small chunks that you can maintain at no cost.\u003c/p\u003e\n\u003cp\u003eTo prevent variable conflicts here, we are just using new var names to identify the Terraform state and input file.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e.2nd_layer:\n  stage: 2nd_layer\n  variables:\n    TF_ROOT: terraform\n  trigger:\n    include: .gitlab-ci/.second-layer.gitlab-ci.yml\n    # strategy: depend            # Do NOT wait for the downstream pipeline to finish to mark upstream pipeline as successful. Otherwise, all pipelines will fail when reaching the pipeline timeout before deployment to 2nd layer.\n    forward:\n      yaml_variables: true      # Forward variables defined in the trigger job\n      pipeline_variables: true  # Forward manual pipeline variables and scheduled pipeline variables\n\nqa:\n  extends: .2nd_layer\n  variables:\n    TF_STATE_NAME_2: qa\n    environment: $TF_STATE_NAME_2\n    TF_CLI_ARGS_plan_2: \u0026#34;-var-file=../vars/$TF_STATE_NAME_2.tfvars\u0026#34;\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\nproduction:\n  extends: .2nd_layer\n  variables:\n    TF_STATE_NAME_2: production\n    environment: $TF_STATE_NAME_2\n    TF_CLI_ARGS_plan_2: \u0026#34;-var-file=../vars/$TF_STATE_NAME_2.tfvars\u0026#34;\n  rules:\n    - if: $CI_COMMIT_TAG\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eOne important trick here is the strategy used for the new downstream pipeline.\u003c/strong\u003e We leave that \u003ccode\u003etrigger:strategy\u003c/code\u003e to its default value; otherwise, the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e would wait for your \u003ca href=\"#the-grand-child-pipeline\"\u003egrand-child pipeline\u003c/a\u003e to finish. With a manual trigger, this could last for a very long time and make your pipeline dashboard harder to read and understand.\u003c/p\u003e\n\u003cp\u003eYou have probably already wondered what is the content of that \u003ccode\u003e.gitlab-ci/.second-layer.gitlab-ci.yml\u003c/code\u003e file we are including here.  We will cover that in the next section.\u003c/p\u003e\n\u003ch5 id=\"the-first-layer-complete-pipeline-definition\" tabindex=\"-1\"\u003eThe first layer complete pipeline definition \u003ca href=\"#the-first-layer-complete-pipeline-definition\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h5\u003e\n\u003cp\u003eIf you are looking for a complete view of this first layer (stored in \u003ccode\u003e.gitlab-ci/.first-layer.gitlab-ci.yml\u003c/code\u003e), just expand the section below.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evariables:\n  TF_VAR_aws_ami_id: $AWS_AMI_ID\n  TF_VAR_aws_instance_type: $AWS_INSTANCE_TYPE\n  TF_VAR_aws_default_region: $AWS_DEFAULT_REGION\n\ninclude:\n  - template: Terraform.gitlab-ci.yml\n\ndefault:\n  cache:  # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy\n    - key: cache-$CI_COMMIT_REF_SLUG\n      fallback_keys:\n        - cache-$CI_DEFAULT_BRANCH\n      paths:\n        - .\n\nstages:\n  - validate\n  - test\n  - build\n  - deploy\n  - cleanup\n  - 2nd_layer       # Use to deploy a 2nd environment on both the main branch and on the tags\n\nfmt:\n  rules:\n    - when: always\n\nvalidate:\n  rules:\n    - when: always\n\nkics-iac-sast:\n  rules:\n    - if: $SAST_DISABLED == \u0026#39;true\u0026#39; || $SAST_DISABLED == \u0026#39;1\u0026#39;\n      when: never\n    - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/\n      when: never\n    - when: on_success\n\niac-sast:\n  rules:\n    - if: $SAST_DISABLED == \u0026#39;true\u0026#39; || $SAST_DISABLED == \u0026#39;1\u0026#39;\n      when: never\n    - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/\n      when: never\n    - when: on_success\n\n###########################################################################################################\n## Integration env. and Staging. env\n##  * Auto-deploy to Integration on merge to main.\n##  * Auto-deploy to Staging on tag.\n##  * Integration can be manually destroyed if TF_DESTROY is set to true.\n##  * Destroy of next env. is not automated to prevent errors.\n###########################################################################################################\nbuild:  # terraform plan\n  environment:\n    name: $TF_STATE_NAME\n    action: prepare\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    - if: $CI_COMMIT_TAG\n\ndeploy: # terraform apply --\u0026gt; automatically deploy on corresponding env (integration or staging) when merging to default branch or tagging. Second layer environments (qa and production) will be controlled manually\n  environment: \n    name: $TF_STATE_NAME\n    action: start\n    on_stop: destroy\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    - if: $CI_COMMIT_TAG\n\ndestroy:\n  extends: .terraform:destroy\n  variables:\n    GIT_STRATEGY: none\n  dependencies:\n    - build\n  environment:\n    name: $TF_STATE_NAME\n    action: stop\n  rules:\n    - if: $CI_COMMIT_TAG  # Do not destroy production\n      when: never\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH \u0026amp;\u0026amp; $TF_DESTROY == \u0026#34;true\u0026#34; # Manually destroy integration env.\n      when: manual\n###########################################################################################################\n\n###########################################################################################################\n## Dev env.\n##  * Temporary environment. Lives and dies with the Merge Request.\n##  * Auto-deploy on push to feature branch.\n##  * Auto-destroy on when Merge Request is closed.\n###########################################################################################################\nbuild_review:\n  extends: build\n  rules:\n    - if: $CI_COMMIT_TAG\n      when: never\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: on_success\n\ndeploy_review:\n  extends: deploy\n  dependencies:\n    - build_review\n  environment:\n    name: $environment\n    action: start\n    on_stop: destroy_review\n    # url: https://$CI_ENVIRONMENT_SLUG.example.com\n  rules:\n    - if: $CI_COMMIT_TAG\n      when: never\n    - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\n      when: on_success\n\ndestroy_review:\n  extends: destroy\n  dependencies:\n    - build_review\n  environment:\n    name: $environment\n    action: stop\n  rules:\n    - if: $CI_COMMIT_TAG  # Do not destroy production\n      when: never\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH   # Do not destroy staging\n      when: never\n    - when: manual\n###########################################################################################################\n\n###########################################################################################################\n## Second layer\n##  * Deploys from main branch to qa env.\n##  * Deploys from tag to production.\n###########################################################################################################\n.2nd_layer:\n  stage: 2nd_layer\n  variables:\n    TF_ROOT: terraform\n  trigger:\n    include: .gitlab-ci/.second-layer.gitlab-ci.yml\n    # strategy: depend            # Do NOT wait for the downstream pipeline to finish to mark upstream pipeline as successful. Otherwise, all pipelines will fail when reaching the pipeline timeout before deployment to 2nd layer.\n    forward:\n      yaml_variables: true      # Forward variables defined in the trigger job\n      pipeline_variables: true  # Forward manual pipeline variables and scheduled pipeline variables\n\nqa:\n  extends: .2nd_layer\n  variables:\n    TF_STATE_NAME_2: qa\n    environment: $TF_STATE_NAME_2\n    TF_CLI_ARGS_plan_2: \u0026#34;-var-file=../vars/$TF_STATE_NAME_2.tfvars\u0026#34;\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\nproduction:\n  extends: .2nd_layer\n  variables:\n    TF_STATE_NAME_2: production\n    environment: $TF_STATE_NAME_2\n    TF_CLI_ARGS_plan_2: \u0026#34;-var-file=../vars/$TF_STATE_NAME_2.tfvars\u0026#34;\n  rules:\n    - if: $CI_COMMIT_TAG\n###########################################################################################################\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this stage, we are already deploying safely to three environments. That is my personal ideal recommendation. However, if you need more environments, add them to your CD pipeline.\u003c/p\u003e\n\u003cp\u003eYou have certainly already noted that we include a downstream pipeline with the keyword \u003ccode\u003etrigger:include\u003c/code\u003e. This includes the file \u003ccode\u003e.gitlab-ci/.second-layer.gitlab-ci.yml\u003c/code\u003e. We want to run almost the same pipeline so obviously, its content is very similar to the one we have detailed above. The main advantage here to define this \u003ca href=\"#the-grand-child-pipeline\"\u003egrand-child pipeline\u003c/a\u003e is that it lives on its own, making both variables and rules way easier to define.\u003c/p\u003e\n\u003ch3 id=\"the-grand-child-pipeline\" tabindex=\"-1\"\u003eThe grand-child pipeline \u003ca href=\"#the-grand-child-pipeline\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThis second layer pipeline is a brand new pipeline. Hence, it needs to mimic the first layer definition with:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#run-terraform-commands-and-secure-the-code\"\u003eInclusion of the Terraform template\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#run-controls-on-all-branches\"\u003eEnforcement of security checks\u003c/a\u003e. Terraform validation would be duplicates of the first layer, but security scanners may find threats that did not yet exist when scanners previously ran (for example, if you deploy to production a couple of days after your deployment to staging).\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#cd-to-review-environments\"\u003eOverwrite build and deploy jobs to set specific rules\u003c/a\u003e. Note that the \u003ccode\u003edestroy\u003c/code\u003e stage is no longer automated to prevent too fast deletions.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs explained above, the \u003ccode\u003eTF_STATE_NAME\u003c/code\u003e and \u003ccode\u003eTF_CLI_ARGS_plan\u003c/code\u003e have been provided from the \u003ca href=\"#the-main-pipeline\"\u003emain pipeline\u003c/a\u003e to the \u003ca href=\"#the-child-pipeline\"\u003echild pipeline\u003c/a\u003e. We needed another variable name to pass these values from the \u003ca href=\"#the-child-pipeline\"\u003echild pipeline\u003c/a\u003e to here, the \u003ca href=\"#the-grand-child-pipeline\"\u003egrand-child pipeline\u003c/a\u003e. This is why they are postfixed with \u003ccode\u003e_2\u003c/code\u003e in the child pipeline and the value is copied back to the appropriate variable during the \u003ccode\u003ebefore_script\u003c/code\u003e here.\u003c/p\u003e\n\u003cp\u003eSince we have already broken down each step above, we can zoom out here directly to the broad view of the global second layer definition (stored in \u003ccode\u003e.gitlab-ci/.second-layer.gitlab-ci.yml\u003c/code\u003e).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Use to deploy a second environment on both the default branch and the tags.\n\ninclude:\n  template: Terraform.gitlab-ci.yml\n\nstages:\n  - validate\n  - test\n  - build\n  - deploy\n\nfmt:\n  rules:\n    - when: never\n\nvalidate:\n  rules:\n    - when: never\n\nkics-iac-sast:\n  rules:\n    - if: $SAST_DISABLED == \u0026#39;true\u0026#39; || $SAST_DISABLED == \u0026#39;1\u0026#39;\n      when: never\n    - if: $SAST_EXCLUDED_ANALYZERS =~ /kics/\n      when: never\n    - when: always\n\n###########################################################################################################\n## QA env. and Prod. env\n##  * Manually trigger build and auto-deploy in QA\n##  * Manually trigger both build and deploy in Production\n##  * Destroy of these env. is not automated to prevent errors.\n###########################################################################################################\nbuild:  # terraform plan\n  cache:  # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy\n    - key: $TF_STATE_NAME_2\n      fallback_keys:\n        - cache-$CI_DEFAULT_BRANCH\n      paths:\n        - .\n  environment:\n    name: $TF_STATE_NAME_2\n    action: prepare\n  before_script:  # Hack to set new variable values on the second layer, while still using the same variable names. Otherwise, due to variable precedence order, setting new value in the trigger job, does not cascade these new values to the downstream pipeline\n    - TF_STATE_NAME=$TF_STATE_NAME_2\n    - TF_CLI_ARGS_plan=$TF_CLI_ARGS_plan_2\n  rules:\n    - when: manual\n\ndeploy: # terraform apply\n  cache:  # Use a shared cache or tagged runners to ensure terraform can run on apply and destroy\n    - key: $TF_STATE_NAME_2\n      fallback_keys:\n        - cache-$CI_DEFAULT_BRANCH\n      paths:\n        - .\n  environment: \n    name: $TF_STATE_NAME_2\n    action: start\n  before_script:  # Hack to set new variable values on the second layer, while still using the same variable names. Otherwise, due to variable precedence order, setting new value in the trigger job, does not cascade these new values to the downstream pipeline\n    - TF_STATE_NAME=$TF_STATE_NAME_2\n    - TF_CLI_ARGS_plan=$TF_CLI_ARGS_plan_2\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n    - if: $CI_COMMIT_TAG \u0026amp;\u0026amp; $TF_AUTO_DEPLOY == \u0026#34;true\u0026#34;\n    - if: $CI_COMMIT_TAG\n      when: manual\n###########################################################################################################\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEt voilà. \u003cstrong\u003eWe are ready to go.\u003c/strong\u003e Feel free to change the way you control your job executions, leveraging for example GitLab\u0026#39;s capacity to \u003ca href=\"https://docs.gitlab.com/ee/ci/jobs/job_control.html#run-a-job-after-a-delay\"\u003edelay a job\u003c/a\u003e before deploying to production.\u003c/p\u003e\n\u003ch2 id=\"try-it-yourself\" tabindex=\"-1\"\u003eTry it yourself \u003ca href=\"#try-it-yourself\"\u003e\u003csvg width=\"24\" height=\"24\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M12.2426 3.75736C11.4615 2.97631 10.1952 2.97631 9.41416 3.75736L7.99995 5.17157C7.60942 5.56209 6.97626 5.56209 6.58573 5.17157C6.19521 4.78105 6.19521 4.14788 6.58573 3.75736L7.99995 2.34314C9.56205 0.781046 12.0947 0.781046 13.6568 2.34314C15.2189 3.90524 15.2189 6.4379 13.6568 8L12.2426 9.41421C11.8521 9.80473 11.2189 9.80473 10.8284 9.41421C10.4379 9.02369 10.4379 8.39052 10.8284 8L12.2426 6.58578C13.0236 5.80473 13.0236 4.5384 12.2426 3.75736Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M10.5355 5.4645C10.926 5.85502 10.926 6.48819 10.5355 6.87871L6.87863 10.5356C6.4881 10.9261 5.85494 10.9261 5.46441 10.5356C5.07389 10.145 5.07389 9.51188 5.46441 9.12135L9.12127 5.4645C9.51179 5.07397 10.145 5.07397 10.5355 5.4645Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003cpath d=\"M3.75742 9.41422C2.97637 10.1953 2.97637 11.4616 3.75742 12.2426C4.53847 13.0237 5.8048 13.0237 6.58584 12.2426L8.00006 10.8284C8.39058 10.4379 9.02375 10.4379 9.41427 10.8284C9.8048 11.219 9.8048 11.8521 9.41427 12.2426L8.00006 13.6569C6.43796 15.219 3.9053 15.219 2.3432 13.6569C0.781107 12.0948 0.781107 9.56211 2.3432 8.00001L3.75742 6.5858C4.14794 6.19527 4.78111 6.19527 5.17163 6.5858C5.56216 6.97632 5.56215 7.60948 5.17163 8.00001L3.75742 9.41422Z\" fill=\"#333333\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe finally reached our destination. We are now able to control \u003cstrong\u003edeployments to five different environments\u003c/strong\u003e, with only the \u003cstrong\u003efeature branches\u003c/strong\u003e, the \u003cstrong\u003emain branch\u003c/strong\u003e, and \u003cstrong\u003etags\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are intensively reusing GitLab open source templates to ensure efficiency and security in our pipelines.\u003c/li\u003e\n\u003cli\u003eWe are leveraging GitLab template capacities to overwrite only the blocks that need custom control.\u003c/li\u003e\n\u003cli\u003eWe have split the pipeline in small chunks, controlling the downstream pipelines to match exactly what we need.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFrom there, the floor is yours. You could, for example, easily update the main pipeline to trigger downstream pipelines for your software source code, with the \u003ca href=\"https://docs.gitlab.com/ee/ci/yaml/#ruleschanges\"\u003etrigger:rules:changes\u003c/a\u003e keyword. And use another \u003ca href=\"https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates/\"\u003etemplate\u003c/a\u003e depending on the changes that happened. But that is another story.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "39 min read",
  "publishedTime": "2024-09-26T00:00:00Z",
  "modifiedTime": null
}
