{
  "id": "acbb89b5-5d99-409a-8fab-d1cf9dd6e08b",
  "title": "JEP 505 Delivers Fifth Preview of Java's Structured Concurrency with Key API Refinements",
  "link": "https://www.infoq.com/news/2025/05/jep-505-concurrency-preview-5/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "JEP 505, Structured Concurrency, has reached Targeted status in JDK 25. This refined API enhances parallel task management through static factory methods like StructuredTaskScope.open(). It improves cancellation, observability, and subtask lifetime handling, ensuring clearer, safer code. Developers are encouraged to explore and provide feedback on this innovative iteration. By A N M Bazlur Rahman",
  "author": "A N M Bazlur Rahman",
  "published": "Mon, 12 May 2025 14:45:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "JDK 25",
    "JDK",
    "Java",
    "Structured Concurrency",
    "Concurrency",
    "Virtual Thread",
    "JEP",
    "Development",
    "news"
  ],
  "byline": "A N M Bazlur Rahman",
  "length": 6377,
  "excerpt": "JEP 505, Structured Concurrency, has reached Targeted status in JDK 25. This refined API enhances parallel task management through static factory methods like StructuredTaskScope.open(). It improves c",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20250506220057/apple-touch-icon.png",
  "text": "JEP 505, Structured Concurrency (Fifth Preview), has reached Targeted status in the JDK 25 release. The API, which has evolved through five preview iterations, aims to simplify and provide developers with clearer, safer frameworks for managing parallel tasks, particularly when working with virtual threads. The latest preview refines the API introduced in earlier incubations (JEP 428, JEP 437) and previews (JEP 453, JEP 462, JEP 480, JEP 499). Most notably, StructuredTaskScope is no longer instantiated via public constructors. Developers now open a scope through static factory methods, such as StructuredTaskScope.open(), a change that clarifies defaults and paves the way for richer completion policies. According to the JEP specification, structured concurrency addresses three fundamental concerns in parallel programming: Keeping subtask lifetimes strictly confined to a well-defined parent scope Implementing reliable cancellation that prevents resource leaks Enhancing observability through structured thread hierarchies The API centers around the java.util.concurrent.StructuredTaskScope class, which manages a group of concurrent subtasks. Developers fork subtasks within a scope and then join them together, with the scope automatically managing their execution boundaries. For example, consider the following coding snippets: try (var scope = StructuredTaskScope.open()) { Subtask\u003cString\u003e user = scope.fork(() -\u003e fetchUser(userId)); Subtask\u003cList\u003cOrder\u003e\u003e orders = scope.fork(() -\u003e fetchOrders(userId)); scope.join(); // Wait for all subtasks // Process results or handle exceptions String userName = user.get(); List\u003cOrder\u003e userOrders = orders.get(); } This example demonstrates the fundamental usage pattern of structured concurrency. It creates a scope using the new factory method, forks two concurrently executed tasks (fetching user data and orders), waits for both to complete with join(), and then retrieves their results. The scope guarantees that both subtasks are either completed or cancelled when execution leaves the block. For contrast, here's how the same code would have looked in previous previews of the Structured Concurrency API: try (var scope = new StructuredTaskScope\u003c\u003e()) { Subtask\u003cString\u003e user = scope.fork(() -\u003e fetchUser(userId)); Subtask\u003cList\u003cOrder\u003e\u003e orders = scope.fork(() -\u003e fetchOrders(userId)); scope.join(); // Process results or handle exceptions String userName = user.get(); List\u003cOrder\u003e userOrders = orders.get(); } While the basic structure remains similar, the fifth preview introduces factory methods like StructuredTaskScope.open() replaces the constructor-based instantiation. This change improves API readability and gives library maintainers more flexibility for future evolution without breaking compatibility. The zero-argument open() factory creates a scope that fails fast: if any subtask throws, the remaining ones are interrupted and join() rethrows. Developers can supply custom policies via open(Joiner), for example: // Return the first successful result, cancel the rest \u003cT\u003e T race(Collection\u003cCallable\u003cT\u003e\u003e tasks) throws InterruptedException { try (var scope = StructuredTaskScope.open( Joiner.\u003cT\u003eanySuccessfulResultOrThrow())) { tasks.forEach(scope::fork); return scope.join(); } } Each fork launches a subtask, by default on a virtual thread, returning a Subtask handle whose get() is safe only after join() completes. The scope enforces structure: calls to fork or join from non-owner threads, or exiting the block without closing, raise StructureViolationException. The factory method allSuccessfulOrThrow() returns a new joiner that, when all subtasks complete successfully, yields a stream of the subtasks: \u003cT\u003e List\u003cT\u003e runConcurrently(Collection\u003cCallable\u003cT\u003e\u003e tasks) throws InterruptedException { try (var scope = StructuredTaskScope.open(Joiner.\u003cT\u003eallSuccessfulOrThrow())) { tasks.forEach(scope::fork); return scope.join().map(Subtask::get).toList(); } } If one or more subtasks fail, then join() throws a FailedException, with the exception from one of the failed subtasks as its cause. The Joiner interface declares three additional factory methods. The awaitAll() method returns a new joiner that waits for all subtasks to complete, whether successfully or not. The awaitAllSuccessfulOrThrow() method returns a new joiner that waits for all subtasks to complete successfully. Lastly, allUntil(Predicate\u003cSubtask\u003c? extends T\u003e\u003e isDone) returns a new joiner that, when all subtasks complete successfully or else a predicate on a completed subtask returns true, cancels the enclosing scope and yields a stream of all the subtasks. When using any Joiner, it is critical to create a new Joiner for each StructuredTaskScope. Joiner objects should never be used in different task scopes or reused after a scope is closed. The Joiner interface can be implemented directly to support custom completion policies. It has two type parameters: T for the result type of the subtasks executed in the scope, and R for the result type of the join() method. The interface looks as follows: public interface Joiner\u003cT, R\u003e { public default boolean onFork(Subtask\u003c? extends T\u003e subtask); public default boolean onComplete(Subtask\u003c? extends T\u003e subtask); public R result() throws Throwable; } The onFork() method is invoked when forking a subtask, while the onComplete() method is invoked when a subtask completes. The specification also clarifies that a scope’s subtasks inherit ScopedValue bindings. If a scope's owner reads a value from a bound ScopedValue then each subtask will read the same value. This JEP also extends the JSON thread-dump format added for virtual threads to show how StructuredTaskScopes group threads into a hierarchy: $jcmd \u003cpid\u003e Thread.dump_to_file -format=json \u003cfile\u003e The JSON object for each scope contains an array of the threads forked in the scope, together with their stack traces. As a preview feature, the OpenJDK team encourages developers to experiment with this fifth iteration in JDK 25 and provide feedback. This input is vital for maturing the API. About the Author A N M Bazlur Rahman",
  "image": "https://res.infoq.com/news/2025/05/jep-505-concurrency-preview-5/en/headerimage/generatedHeaderImage-1747024009207.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eJEP 505, \u003ca href=\"https://openjdk.org/jeps/505\"\u003eStructured Concurrency (Fifth Preview)\u003c/a\u003e, has reached \u003cstrong\u003eTargeted\u003c/strong\u003e status in the JDK 25 release. The API, which has evolved through five preview iterations, aims to simplify and provide developers with clearer, safer frameworks for managing parallel tasks, particularly when working with virtual threads. The latest preview refines the API introduced in earlier incubations (\u003ca href=\"https://openjdk.org/jeps/428\"\u003eJEP 428\u003c/a\u003e, \u003ca href=\"https://openjdk.org/jeps/437\"\u003eJEP 437\u003c/a\u003e) and previews (\u003ca href=\"https://openjdk.org/jeps/453\"\u003eJEP 453\u003c/a\u003e, \u003ca href=\"https://openjdk.org/jeps/462\"\u003eJEP 462\u003c/a\u003e, \u003ca href=\"https://openjdk.org/jeps/480\"\u003eJEP 480\u003c/a\u003e, \u003ca href=\"https://openjdk.org/jeps/499\"\u003eJEP 499\u003c/a\u003e). Most notably, \u003cstrong\u003e\u003ccode\u003eStructuredTaskScope\u003c/code\u003e\u003c/strong\u003e is no longer instantiated via public constructors. Developers now open a scope through static factory methods, such as \u003cstrong\u003e\u003ccode\u003eStructuredTaskScope.open()\u003c/code\u003e\u003c/strong\u003e, a change that clarifies defaults and paves the way for richer completion policies.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eAccording to the JEP specification, structured concurrency addresses three fundamental concerns in parallel programming:\u003c/p\u003e\n\n\u003cul dir=\"ltr\"\u003e\n\t\u003cli role=\"presentation\"\u003eKeeping subtask lifetimes strictly confined to a well-defined parent scope\u003c/li\u003e\n\t\u003cli role=\"presentation\"\u003eImplementing reliable cancellation that prevents resource leaks\u003c/li\u003e\n\t\u003cli role=\"presentation\"\u003eEnhancing observability through structured thread hierarchies\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp dir=\"ltr\"\u003eThe API centers around the \u003cstrong\u003e\u003ccode\u003ejava.util.concurrent.StructuredTaskScope\u003c/code\u003e\u003c/strong\u003e class, which manages a group of concurrent subtasks. Developers fork subtasks within a scope and then join them together, with the scope automatically managing their execution boundaries.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eFor example, consider the following coding snippets:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry (var scope = StructuredTaskScope.open()) {\n    Subtask\u0026lt;String\u0026gt; user = scope.fork(() -\u0026gt; fetchUser(userId));\n    Subtask\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; orders = scope.fork(() -\u0026gt; fetchOrders(userId));\n    \n    scope.join();  // Wait for all subtasks\n    \n    // Process results or handle exceptions\n    String userName = user.get();\n    List\u0026lt;Order\u0026gt; userOrders = orders.get();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis example demonstrates the fundamental usage pattern of structured concurrency. It creates a scope using the new factory method, forks two concurrently executed tasks (fetching user data and orders), waits for both to complete with join(), and then retrieves their results. The scope guarantees that both subtasks are either completed or cancelled when execution leaves the block.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eFor contrast, here\u0026#39;s how the same code would have looked in previous previews of the Structured Concurrency API:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry (var scope = new StructuredTaskScope\u0026lt;\u0026gt;()) {  \n    Subtask\u0026lt;String\u0026gt; user = scope.fork(() -\u0026gt; fetchUser(userId));\n    Subtask\u0026lt;List\u0026lt;Order\u0026gt;\u0026gt; orders = scope.fork(() -\u0026gt; fetchOrders(userId));\n    \n    scope.join();\n    \n    // Process results or handle exceptions\n    String userName = user.get();\n    List\u0026lt;Order\u0026gt; userOrders = orders.get();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp dir=\"ltr\"\u003eWhile the basic structure remains similar, the fifth preview introduces factory methods like \u003cstrong\u003e\u003ccode\u003eStructuredTaskScope.open()\u003c/code\u003e\u003c/strong\u003e replaces the constructor-based instantiation. This change improves API readability and gives library maintainers more flexibility for future evolution without breaking compatibility.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe zero-argument \u003cstrong\u003e\u003ccode\u003eopen()\u003c/code\u003e\u003c/strong\u003e factory creates a scope that fails fast: if any subtask throws, the remaining ones are interrupted and \u003cstrong\u003e\u003ccode\u003ejoin()\u003c/code\u003e\u003c/strong\u003e rethrows. Developers can supply custom policies via \u003cstrong\u003e\u003ccode\u003eopen(Joiner)\u003c/code\u003e\u003c/strong\u003e, for example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e// Return the first successful result, cancel the rest\n\u0026lt;T\u0026gt; T race(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt; tasks) throws InterruptedException {\n    try (var scope = StructuredTaskScope.open(\n            Joiner.\u0026lt;T\u0026gt;anySuccessfulResultOrThrow())) {\n        tasks.forEach(scope::fork);\n        return scope.join();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eEach fork launches a subtask, by default on a virtual thread, returning a \u003cstrong\u003e\u003ccode\u003eSubtask\u003c/code\u003e\u003c/strong\u003e handle whose \u003cstrong\u003e\u003ccode\u003eget()\u003c/code\u003e\u003c/strong\u003e is safe only after \u003cstrong\u003e\u003ccode\u003ejoin()\u003c/code\u003e\u003c/strong\u003e completes. The scope enforces structure: calls to fork or join from non-owner threads, or exiting the block without closing, raise \u003cstrong\u003e\u003ccode\u003eStructureViolationException\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe factory method \u003cstrong\u003e\u003ccode\u003eallSuccessfulOrThrow()\u003c/code\u003e\u003c/strong\u003e returns a new joiner that, when all subtasks complete successfully, yields a stream of the subtasks:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; runConcurrently(Collection\u0026lt;Callable\u0026lt;T\u0026gt;\u0026gt; tasks) throws InterruptedException {\n    try (var scope = StructuredTaskScope.open(Joiner.\u0026lt;T\u0026gt;allSuccessfulOrThrow())) {\n        tasks.forEach(scope::fork);\n        return scope.join().map(Subtask::get).toList();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp dir=\"ltr\"\u003eIf one or more subtasks fail, then \u003cstrong\u003e\u003ccode\u003ejoin()\u003c/code\u003e\u003c/strong\u003e throws a \u003cstrong\u003e\u003ccode\u003eFailedException\u003c/code\u003e\u003c/strong\u003e, with the exception from one of the failed subtasks as its cause.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe \u003cstrong\u003e\u003ccode\u003eJoiner\u003c/code\u003e\u003c/strong\u003e interface declares three additional factory methods. The \u003cstrong\u003e\u003ccode\u003eawaitAll()\u003c/code\u003e\u003c/strong\u003e method returns a new joiner that waits for all subtasks to complete, whether successfully or not. The \u003cstrong\u003e\u003ccode\u003eawaitAllSuccessfulOrThrow()\u003c/code\u003e\u003c/strong\u003e method returns a new joiner that waits for all subtasks to complete successfully. Lastly, \u003cstrong\u003e\u003ccode\u003eallUntil(Predicate\u0026lt;Subtask\u0026lt;? extends T\u0026gt;\u0026gt; isDone)\u003c/code\u003e\u003c/strong\u003e returns a new joiner that, when all subtasks complete successfully or else a predicate on a completed subtask returns true, cancels the enclosing scope and yields a stream of all the subtasks.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eWhen using any \u003cstrong\u003e\u003ccode\u003eJoiner\u003c/code\u003e\u003c/strong\u003e, it is critical to create a new Joiner for each \u003cstrong\u003e\u003ccode\u003eStructuredTaskScope\u003c/code\u003e\u003c/strong\u003e. Joiner objects should never be used in different task scopes or reused after a scope is closed.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe \u003cstrong\u003e\u003ccode\u003eJoiner\u003c/code\u003e\u003c/strong\u003e interface can be implemented directly to support custom completion policies. It has two type parameters: \u003ccode\u003e\u003cstrong\u003eT\u003c/strong\u003e\u003c/code\u003e for the result type of the subtasks executed in the scope, and \u003cstrong\u003e\u003ccode\u003eR\u003c/code\u003e\u003c/strong\u003e for the result type of the \u003ccode\u003e\u003cstrong\u003ejoin()\u003c/strong\u003e\u003c/code\u003e method. The interface looks as follows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epublic interface Joiner\u0026lt;T, R\u0026gt; {\n    public default boolean onFork(Subtask\u0026lt;? extends T\u0026gt; subtask);\n    public default boolean onComplete(Subtask\u0026lt;? extends T\u0026gt; subtask);\n    public R result() throws Throwable;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp dir=\"ltr\"\u003eThe \u003cstrong\u003e\u003ccode\u003eonFork()\u003c/code\u003e\u003c/strong\u003e method is invoked when forking a subtask, while the \u003cstrong\u003e\u003ccode\u003eonComplete()\u003c/code\u003e\u003c/strong\u003e method is invoked when a subtask completes.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe specification also clarifies that a scope’s subtasks inherit \u003cstrong\u003e\u003ccode\u003eScopedValue\u003c/code\u003e\u003c/strong\u003e \u003ca href=\"https://openjdk.org/jeps/487\"\u003ebindings\u003c/a\u003e. If a scope\u0026#39;s owner reads a value from a bound \u003cstrong\u003e\u003ccode\u003eScopedValue\u003c/code\u003e\u003c/strong\u003e then each subtask will read the same value.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThis JEP also extends the JSON thread-dump format added for virtual threads to show how \u003ccode\u003e\u003cstrong\u003eStructuredTaskScopes\u003c/strong\u003e\u003c/code\u003e group threads into a hierarchy:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e$jcmd \u0026lt;pid\u0026gt; Thread.dump_to_file -format=json \u0026lt;file\u0026gt;\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp dir=\"ltr\"\u003eThe JSON object for each scope contains an array of the threads forked in the scope, together with their stack traces.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eAs a preview feature, the OpenJDK team encourages developers to experiment with this fifth iteration in JDK 25 and provide feedback. This input is vital for maturing the API.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-A-N-M-Bazlur-Rahman\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eA N M Bazlur Rahman\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-05-12T00:00:00Z",
  "modifiedTime": null
}
