{
  "id": "dd3c69f5-2074-43c6-8e9f-ef037ce709dc",
  "title": "Gameboy Doctor: debug and fix your gameboy emulator",
  "link": "https://robertheaton.com/gameboy-doctor/",
  "description": "Are you building a Gameboy emulator? Are you stuck? Are you failing Blargg’s test ROMs and can’t work out why? Gameboy Doctor can help! (GitHub link) What is Gameboy Doctor? Gameboy Doctor is a tool that compares your emulator to an example emulator that passes Blargg’s test ROMs. It finds the exact tick where your emulator’s state diverges from the example, helping you isolate and fix your bugs. You don’t need to have implemented an LCD in order to use it, and you don’t even have to be able to successfully get any kind of pass/fail message back from Blargg! All you need is a minimally functional CPU and motherboard. Requirements Just Python3, no third-party libraries. How do I use Gameboy Doctor? 0. Clone the repo The tool is available on GitHub - clone it using git. 1. Choose a test ROM Choose a cpu_instrs individual test ROM (these are currently the only ones supported by Gameboy Doctor - see below) 2. Make 2 tweaks to your emulator You’ll need to make 2 changes to the internal workings of your emulator. They’ll probably take about 20 minutes to do, but they’ll save you hours and days of aimless debugging. The changes are: Initialize the CPU’s state to the state it should have immediately after executing the boot ROM: Register Value A 0x01 F 0xB0 (or CH-Z if managing flags individually) B 0x00 C 0x13 D 0x00 E 0xD8 H 0x01 L 0x4D SP 0xFFFE PC 0x0100 Hardcode your LCD (or your motherboard’s memory map if you haven’t implemented an LCD yet) to return 0x90 when the LY register is read (memory location 0xFF44). This is what I did when generating my example logs, because returning a constant prevent spurious log divergences. 3. Log the state of your CPU Next, update your emulator to write the state of the CPU after each operation to a logfile. Use a new line for each tick, and use the following format for each state (replace the example numbers with your CPU’s values): A:00 F:11 B:22 C:33 D:44 E:55 H:66 L:77 SP:8888 PC:9999 PCMEM:AA,BB,CC,DD All of the values between A and PC are the hex-encoded values of the corresponding registers. The final value (PCMEM) is the 4 bytes stored in the memory locations near PC (ie. the values at pc,pc+1,pc+2,pc+3). Run your emulator and get a log file. You can kill the program at any point - Gameboy Doctor will tell you if your log file is correct but ends before the test ROM has finished its assertions. If you pass the test then your emulator will display the word “Passed” on the LCD, and write the bytes for the word “Passed” to the serial output. However, you don’t need to pass or even finish the tests in order to use Gameboy Doctor. 4. Feed your logfile to Gameboy Doctor Once you have your logfile, feed it into Gameboy Doctor like so: ./gameboy-doctor /path/to/your/logfile $ROM_TYPE $ROM_NUMBER For example, to check the 3rd cpu_instrs ROM: ./gameboy-doctor /path/to/your/logfile cpu_instrs 3 On windows you may need to invoke the Python interpreter directly: python3 gameboy-doctor /path/to/your/logfile cpu_instrs 3 Gameboy Doctor will tell you how you’re doing and give suggestions on bugfixes. For example: $ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3 ============== ERROR ============== Mismatch in CPU state at line 9997: MINE: A:3E F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14 YOURS: A:3D F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14 The CPU state before this (at line 9996) was: A:3E F:10 B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0207 PCMEM:12,1C,20,FB The last operation executed (in between lines 9996 and 9997) was: 0x12 LD (DE) A Perhaps the problem is with this opcode, or with your interrupt handling? Eventually you’ll hopefully see: $ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3 ============== SUCCESS ============== Your log file matched mine for all 1066160 lines - you passed the test ROM! Future Work Gameboy Doctor currently only supports Blargg’s cpu_instrs test ROMs because these are the most useful for initial debugging. It should be relatively easy to support other test ROMs, although small timing differences that don’t affect the successful running of the emulator may cause divergences in CPU states between otherwise well-functioning emulators. Let me know if you find Gameboy Doctor useful and I’ll work on expanding the ROMs and emulators it supports. Acknowledgements This tool was inspired by GitHub user wheremyfoodat. th { text-align: left; }",
  "author": "",
  "published": "Sat, 03 Dec 2022 00:00:00 +0000",
  "source": "https://robertheaton.com/feed.xml",
  "categories": null,
  "byline": "",
  "length": 4749,
  "excerpt": "Are you building a Gameboy emulator? Are you stuck? Are you failing Blargg’s test ROMs and can’t work out why?",
  "siteName": "Robert Heaton",
  "favicon": "https://robertheaton.com/images/fav.png",
  "text": "Are you building a Gameboy emulator? Are you stuck? Are you failing Blargg’s test ROMs and can’t work out why? Gameboy Doctor can help! (GitHub link) What is Gameboy Doctor? Gameboy Doctor is a tool that compares your emulator to an example emulator that passes Blargg’s test ROMs. It finds the exact tick where your emulator’s state diverges from the example, helping you isolate and fix your bugs. You don’t need to have implemented an LCD in order to use it, and you don’t even have to be able to successfully get any kind of pass/fail message back from Blargg! All you need is a minimally functional CPU and motherboard. Requirements Just Python3, no third-party libraries. How do I use Gameboy Doctor? 0. Clone the repo The tool is available on GitHub - clone it using git. 1. Choose a test ROM Choose a cpu_instrs individual test ROM (these are currently the only ones supported by Gameboy Doctor - see below) 2. Make 2 tweaks to your emulator You’ll need to make 2 changes to the internal workings of your emulator. They’ll probably take about 20 minutes to do, but they’ll save you hours and days of aimless debugging. The changes are: Initialize the CPU’s state to the state it should have immediately after executing the boot ROM: Register Value A 0x01 F 0xB0 (or CH-Z if managing flags individually) B 0x00 C 0x13 D 0x00 E 0xD8 H 0x01 L 0x4D SP 0xFFFE PC 0x0100 Hardcode your LCD (or your motherboard’s memory map if you haven’t implemented an LCD yet) to return 0x90 when the LY register is read (memory location 0xFF44). This is what I did when generating my example logs, because returning a constant prevent spurious log divergences. 3. Log the state of your CPU Next, update your emulator to write the state of the CPU after each operation to a logfile. Use a new line for each tick, and use the following format for each state (replace the example numbers with your CPU’s values): A:00 F:11 B:22 C:33 D:44 E:55 H:66 L:77 SP:8888 PC:9999 PCMEM:AA,BB,CC,DD All of the values between A and PC are the hex-encoded values of the corresponding registers. The final value (PCMEM) is the 4 bytes stored in the memory locations near PC (ie. the values at pc,pc+1,pc+2,pc+3). Run your emulator and get a log file. You can kill the program at any point - Gameboy Doctor will tell you if your log file is correct but ends before the test ROM has finished its assertions. If you pass the test then your emulator will display the word “Passed” on the LCD, and write the bytes for the word “Passed” to the serial output. However, you don’t need to pass or even finish the tests in order to use Gameboy Doctor. 4. Feed your logfile to Gameboy Doctor Once you have your logfile, feed it into Gameboy Doctor like so: ./gameboy-doctor /path/to/your/logfile $ROM_TYPE $ROM_NUMBER For example, to check the 3rd cpu_instrs ROM: ./gameboy-doctor /path/to/your/logfile cpu_instrs 3 On windows you may need to invoke the Python interpreter directly: python3 gameboy-doctor /path/to/your/logfile cpu_instrs 3 Gameboy Doctor will tell you how you’re doing and give suggestions on bugfixes. For example: $ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3 ============== ERROR ============== Mismatch in CPU state at line 9997: MINE: A:3E F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14 YOURS: A:3D F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14 The CPU state before this (at line 9996) was: A:3E F:10 B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0207 PCMEM:12,1C,20,FB The last operation executed (in between lines 9996 and 9997) was: 0x12 LD (DE) A Perhaps the problem is with this opcode, or with your interrupt handling? Eventually you’ll hopefully see: $ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3 ============== SUCCESS ============== Your log file matched mine for all 1066160 lines - you passed the test ROM! Future Work Gameboy Doctor currently only supports Blargg’s cpu_instrs test ROMs because these are the most useful for initial debugging. It should be relatively easy to support other test ROMs, although small timing differences that don’t affect the successful running of the emulator may cause divergences in CPU states between otherwise well-functioning emulators. Let me know if you find Gameboy Doctor useful and I’ll work on expanding the ROMs and emulators it supports. Acknowledgements This tool was inspired by GitHub user wheremyfoodat.",
  "image": "https://robertheaton.com/images/nintendo-upside-down.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eAre you \u003ca href=\"https://gbdev.io/pandocs/\"\u003ebuilding a Gameboy emulator\u003c/a\u003e? Are you stuck? Are you failing \u003ca href=\"https://github.com/retrio/gb-test-roms\"\u003eBlargg’s test ROMs\u003c/a\u003e and can’t work out why?\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://robertheaton.com/images/nintendo-upside-down.png\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eGameboy Doctor can help! (\u003ca href=\"https://github.com/robert/gameboy-doctor\"\u003eGitHub link\u003c/a\u003e)\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://robertheaton.com/images/example.jpg\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"what-is-gameboy-doctor\"\u003eWhat is Gameboy Doctor?\u003c/h2\u003e\n\n\u003cp\u003eGameboy Doctor is a tool that compares your emulator to an example emulator that passes Blargg’s test ROMs. It finds the exact tick where your emulator’s state diverges from the example, helping you isolate and fix your bugs. You don’t need to have implemented an LCD in order to use it, and you don’t even have to be able to successfully get any kind of pass/fail message back from Blargg! All you need is a minimally functional CPU and motherboard.\u003c/p\u003e\n\n\u003ch2 id=\"requirements\"\u003eRequirements\u003c/h2\u003e\n\n\u003cp\u003eJust Python3, no third-party libraries.\u003c/p\u003e\n\n\u003ch2 id=\"how-do-i-use-gameboy-doctor\"\u003eHow do I use Gameboy Doctor?\u003c/h2\u003e\n\n\u003ch3 id=\"0-clone-the-repo\"\u003e0. Clone the repo\u003c/h3\u003e\n\n\u003cp\u003eThe tool is available \u003ca href=\"https://github.com/robert/gameboy-doctor\"\u003eon GitHub\u003c/a\u003e - clone it using git.\u003c/p\u003e\n\n\u003ch3 id=\"1-choose-a-test-rom\"\u003e1. Choose a test ROM\u003c/h3\u003e\n\n\u003cp\u003eChoose a \u003ca href=\"https://github.com/retrio/gb-test-roms/tree/master/cpu_instrs/individual\"\u003e\u003ccode\u003ecpu_instrs\u003c/code\u003e individual test ROM\u003c/a\u003e (these are currently the only ones supported by Gameboy Doctor - see below)\u003c/p\u003e\n\n\u003ch3 id=\"2-make-2-tweaks-to-your-emulator\"\u003e2. Make 2 tweaks to your emulator\u003c/h3\u003e\n\n\u003cp\u003eYou’ll need to make 2 changes to the internal workings of your emulator. They’ll probably take about 20 minutes to do, but they’ll save you hours and days of aimless debugging. The changes are:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eInitialize the CPU’s state to the state it should have immediately after executing the boot ROM:\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eRegister\u003c/th\u003e\n      \u003cth\u003eValue\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eA\u003c/td\u003e\n      \u003ctd\u003e0x01\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eF\u003c/td\u003e\n      \u003ctd\u003e0xB0 (or \u003ccode\u003eCH-Z\u003c/code\u003e if managing flags individually)\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eB\u003c/td\u003e\n      \u003ctd\u003e0x00\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC\u003c/td\u003e\n      \u003ctd\u003e0x13\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eD\u003c/td\u003e\n      \u003ctd\u003e0x00\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eE\u003c/td\u003e\n      \u003ctd\u003e0xD8\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eH\u003c/td\u003e\n      \u003ctd\u003e0x01\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eL\u003c/td\u003e\n      \u003ctd\u003e0x4D\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eSP\u003c/td\u003e\n      \u003ctd\u003e0xFFFE\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ePC\u003c/td\u003e\n      \u003ctd\u003e0x0100\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cul\u003e\n  \u003cli\u003eHardcode your LCD (or your motherboard’s memory map if you haven’t implemented an LCD yet) to return \u003ccode\u003e0x90\u003c/code\u003e when the \u003ccode\u003eLY\u003c/code\u003e register is read (memory location \u003ccode\u003e0xFF44\u003c/code\u003e). This is what I did when generating my example logs, because returning a constant prevent spurious log divergences.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"3-log-the-state-of-your-cpu\"\u003e3. Log the state of your CPU\u003c/h3\u003e\n\n\u003cp\u003eNext, update your emulator to write the state of the CPU after each operation to a logfile. Use a new line for each tick, and use the following format for each state (replace the example numbers with your CPU’s values):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003eA:00 F:11 B:22 C:33 D:44 E:55 H:66 L:77 SP:8888 PC:9999 PCMEM:AA,BB,CC,DD\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAll of the values between \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003ePC\u003c/code\u003e are the hex-encoded values of the corresponding registers. The final value (\u003ccode\u003ePCMEM\u003c/code\u003e) is the 4 bytes stored in the memory locations near \u003ccode\u003ePC\u003c/code\u003e (ie. the values at \u003ccode\u003epc,pc+1,pc+2,pc+3\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eRun your emulator and get a log file. You can kill the program at any point - Gameboy Doctor will tell you if your log file is correct but ends before the test ROM has finished its assertions. If you pass the test then your emulator will display the word “Passed” on the LCD, and write the bytes for the word “Passed” to \u003ca href=\"https://gbdev.io/pandocs/Serial_Data_Transfer_%28Link_Cable%29.html\"\u003ethe serial output\u003c/a\u003e. However, you don’t need to pass or even finish the tests in order to use Gameboy Doctor.\u003c/p\u003e\n\n\u003ch3 id=\"4-feed-your-logfile-to-gameboy-doctor\"\u003e4. Feed your logfile to Gameboy Doctor\u003c/h3\u003e\n\n\u003cp\u003eOnce you have your logfile, feed it into Gameboy Doctor like so:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e./gameboy-doctor /path/to/your/logfile $ROM_TYPE $ROM_NUMBER\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eFor example, to check the 3rd cpu_instrs ROM:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e./gameboy-doctor /path/to/your/logfile cpu_instrs 3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eOn windows you may need to invoke the Python interpreter directly:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003epython3 gameboy-doctor /path/to/your/logfile cpu_instrs 3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eGameboy Doctor will tell you how you’re doing and give suggestions on bugfixes. For example:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3\n============== ERROR ==============\n\nMismatch in CPU state at line 9997:\n\nMINE:   A:3E F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14\nYOURS:  A:3D F:C--- B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0208 PCMEM:1C,20,FB,14\n\nThe CPU state before this (at line 9996) was:\n\n\t      A:3E F:10 B:01 C:07 D:C9 E:BA H:49 L:BB SP:FFFE PC:0207 PCMEM:12,1C,20,FB\n\nThe last operation executed (in between lines 9996 and 9997) was:\n\n\t      0x12 LD (DE) A\n\nPerhaps the problem is with this opcode, or with your interrupt handling?\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eEventually you’ll hopefully see:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ ./gameboy-doctor ../my-emulator/logs/3.log cpu_instrs 3\n============== SUCCESS ==============\n\nYour log file matched mine for all 1066160 lines - you passed the test ROM!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2 id=\"future-work\"\u003eFuture Work\u003c/h2\u003e\n\n\u003cp\u003eGameboy Doctor currently only supports Blargg’s \u003ccode\u003ecpu_instrs\u003c/code\u003e test ROMs because these are the most useful for initial debugging. It should be relatively easy to support other test ROMs, although small timing differences that don’t affect the successful running of the emulator may cause divergences in CPU states between otherwise well-functioning emulators.\u003c/p\u003e\n\n\u003cp\u003eLet me know if you find Gameboy Doctor useful and I’ll work on expanding the ROMs and emulators it supports.\u003c/p\u003e\n\n\u003ch2 id=\"acknowledgements\"\u003eAcknowledgements\u003c/h2\u003e\n\n\u003cp\u003eThis tool was inspired by \u003ca href=\"https://github.com/wheremyfoodat/Gameboy-logs\"\u003eGitHub user wheremyfoodat\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
