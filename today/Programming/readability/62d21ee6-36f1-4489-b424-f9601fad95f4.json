{
  "id": "62d21ee6-36f1-4489-b424-f9601fad95f4",
  "title": "The Wave/Particle Duality of Git Commits",
  "link": "https://www.thirtythreeforty.net/posts/2020/01/the-wave-particle-duality-of-git-commits/",
  "description": "A lot of my friends get confused when they encounter more advanced Git topics such as git rebase. This misunderstanding typically arises during the first merge conflict that interrupts the rebase process. The central point of confusion is usually how Git can reapply one commit onto another. My friends are confused about why a snapshot could have a merge conflict. Shouldn’t it be obvious, they think, what the final state should be? In order to understand what’s going on, it’s first necessary to take a quick detour into quantum physics—tongue planted firmly in cheek. Wave/particle duality If you’re not already passingly familiar with this particular flavor of apparent quantum nonsense, I am afraid you’re about to get a lot more confused. It turns out that particles such as photons (and electrons, etc) have properties of both classical particles and waves. This leads to experimental results such as the well-known double-slit experiment. If photons are fired through a slit onto a piece of film, they create a band where they passed through the slit, acting as if photons are particles. However, photons that pass through two side-by-side slits interfere with themselves to create an interference pattern on a piece of film, as if photons are waves. The small extra ripples are the interference from the second slit. (photo CC BY-SA 3.0, by Jordgette) The upshot is that it is important to realize that photons are neither particles nor waves, but rather something strange that behaves like both. What do photons have to do with Git? I’m glad you asked. It’s easy to see that many Git operations treat commits as snapshots. Every Git user knows how to use checkout: $ git checkout 42bd1ef5 \u0026\u0026 ls -lh HEAD is now at 42bd1ef Adjust padding for social links total 48K drwxr-xr-x 2 georgev georgev 4.0K Jun 1 2019 archetypes drwxr-xr-x 3 georgev georgev 4.0K Jun 1 2019 assets drwxr-xr-x 2 georgev georgev 4.0K Jun 1 2019 images drwxr-xr-x 7 georgev georgev 4.0K Aug 25 13:27 layouts -rw-r--r-- 1 georgev georgev 9.3K Jan 4 12:21 README.md drwxr-xr-x 3 georgev georgev 4.0K Aug 15 01:01 static -rw-r--r-- 1 georgev georgev 712 Jun 1 2019 theme.toml But other commands, such as show, output a unified diff—that is, a patch: $ git show 42bd1ef5 commit 42bd1ef5c5541815ad0ae4eba2c695387228e719 Author: George Hilliard Date: Tue Dec 31 10:43:45 2019 -0600 Adjust padding for social links diff --git a/assets/scss/hyde-hyde/_sidebar.scss b/assets/scss/hyde-hyde/_sidebar.scss index 0686b42..6b34856 100644 --- a/assets/scss/hyde-hyde/_sidebar.scss +++ b/assets/scss/hyde-hyde/_sidebar.scss @@ -54,7 +54,7 @@ .social { text-align: center; a { - padding: 0 4px; + padding: 0 7px; @include link-no-decoration(); } } The same commit hash is present in both commands. There’s no “--as-patch” or “--as-snapshot” flags to indicate a difference. I am in fact referring to the same object. What is going on? Commits, it seems, are neither patches nor snapshots until they are observed. Rather, they are something strange1 that can be treated as either a patch or a snapshot, just as a photon has properties of both a particle and a wave. When Git treats a commit as a patch, it appears as the difference between its snapshot and that of its parent. When Git treats a commit as a snapshot, it appears as the tree of files that were in the staging area when the commit was made. This duality of Git commits is what enables operations such as rebase. Git commands such as rebase, cherry-pick, format-patch, etc, all treat a Git commit as a patch, rather than as a snapshot. When viewed this way, Git’s rebase operation suddenly makes a whole lot more sense: Git takes a string of commits, interprets them as patches, and applies them to the commit you specify. A simple rebase, where C4’s diff has been applied to C3. (from Git docs) If this process goes smoothly, this creates a new string of commits, with the destination snapshot modified according to the original commits-as-patches. And so this is also why it’s possible for rebase to create “merge conflicts:” it’s the patches, not that snapshots, that won’t apply cleanly. Is this a silly way to think of commits? Probably. But it has been helpful to at least one other person when I explained it this way. I hope it helps you too. You can subscribe to updates via RSS or email. This duality extends as far as the underlying storage format: individual commits are stored as something very similar to a snapshot: they are a “tree” referencing “blobs”, all referenced by a “commit” blob. But pack files are stored similar to patches, with objects optionally being stored as a “delta” to another object occurring earlier in the pack. This is an internal detail that most users of Git need not be aware of. ↩︎",
  "author": "George Hilliard",
  "published": "Mon, 20 Jan 2020 08:00:00 -0600",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 4830,
  "excerpt": "Yet another way to think of git rebase",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "A lot of my friends get confused when they encounter more advanced Git topics such as git rebase. This misunderstanding typically arises during the first merge conflict that interrupts the rebase process. The central point of confusion is usually how Git can reapply one commit onto another. My friends are confused about why a snapshot could have a merge conflict. Shouldn’t it be obvious, they think, what the final state should be? In order to understand what’s going on, it’s first necessary to take a quick detour into quantum physics—tongue planted firmly in cheek. Wave/particle duality If you’re not already passingly familiar with this particular flavor of apparent quantum nonsense, I am afraid you’re about to get a lot more confused. It turns out that particles such as photons (and electrons, etc) have properties of both classical particles and waves. This leads to experimental results such as the well-known double-slit experiment. If photons are fired through a slit onto a piece of film, they create a band where they passed through the slit, acting as if photons are particles. However, photons that pass through two side-by-side slits interfere with themselves to create an interference pattern on a piece of film, as if photons are waves. The small extra ripples are the interference from the second slit. (photo CC BY-SA 3.0, by Jordgette) The upshot is that it is important to realize that photons are neither particles nor waves, but rather something strange that behaves like both. What do photons have to do with Git? I’m glad you asked. It’s easy to see that many Git operations treat commits as snapshots. Every Git user knows how to use checkout: $ git checkout 42bd1ef5 \u0026\u0026 ls -lh HEAD is now at 42bd1ef Adjust padding for social links total 48K drwxr-xr-x 2 georgev georgev 4.0K Jun 1 2019 archetypes drwxr-xr-x 3 georgev georgev 4.0K Jun 1 2019 assets drwxr-xr-x 2 georgev georgev 4.0K Jun 1 2019 images drwxr-xr-x 7 georgev georgev 4.0K Aug 25 13:27 layouts -rw-r--r-- 1 georgev georgev 9.3K Jan 4 12:21 README.md drwxr-xr-x 3 georgev georgev 4.0K Aug 15 01:01 static -rw-r--r-- 1 georgev georgev 712 Jun 1 2019 theme.toml But other commands, such as show, output a unified diff—that is, a patch: $ git show 42bd1ef5 commit 42bd1ef5c5541815ad0ae4eba2c695387228e719 Author: George Hilliard \u003cthirtythreeforty@gmail.com\u003e Date: Tue Dec 31 10:43:45 2019 -0600 Adjust padding for social links diff --git a/assets/scss/hyde-hyde/_sidebar.scss b/assets/scss/hyde-hyde/_sidebar.scss index 0686b42..6b34856 100644 --- a/assets/scss/hyde-hyde/_sidebar.scss +++ b/assets/scss/hyde-hyde/_sidebar.scss @@ -54,7 +54,7 @@ .social { text-align: center; a { - padding: 0 4px; + padding: 0 7px; @include link-no-decoration(); } } The same commit hash is present in both commands. There’s no “--as-patch” or “--as-snapshot” flags to indicate a difference. I am in fact referring to the same object. What is going on? Commits, it seems, are neither patches nor snapshots until they are observed. Rather, they are something strange1 that can be treated as either a patch or a snapshot, just as a photon has properties of both a particle and a wave. When Git treats a commit as a patch, it appears as the difference between its snapshot and that of its parent. When Git treats a commit as a snapshot, it appears as the tree of files that were in the staging area when the commit was made. This duality of Git commits is what enables operations such as rebase. Git commands such as rebase, cherry-pick, format-patch, etc, all treat a Git commit as a patch, rather than as a snapshot. When viewed this way, Git’s rebase operation suddenly makes a whole lot more sense: Git takes a string of commits, interprets them as patches, and applies them to the commit you specify. A simple rebase, where C4’s diff has been applied to C3. (from Git docs) If this process goes smoothly, this creates a new string of commits, with the destination snapshot modified according to the original commits-as-patches. And so this is also why it’s possible for rebase to create “merge conflicts:” it’s the patches, not that snapshots, that won’t apply cleanly. Is this a silly way to think of commits? Probably. But it has been helpful to at least one other person when I explained it this way. I hope it helps you too. You can subscribe to updates via RSS or email. This duality extends as far as the underlying storage format: individual commits are stored as something very similar to a snapshot: they are a “tree” referencing “blobs”, all referenced by a “commit” blob. But pack files are stored similar to patches, with objects optionally being stored as a “delta” to another object occurring earlier in the pack. This is an internal detail that most users of Git need not be aware of. ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" tabindex=\"-1\"\u003e\n\u003carticle\u003e\n\u003cheader\u003e\n\n\n\u003c/header\u003e\n\u003cdiv\u003e\n\u003cp\u003eA lot of my friends get confused when they encounter more advanced Git topics such as \u003ca href=\"https://git-scm.com/book/en/v2/Git-Branching-Rebasing\"\u003e\u003ccode\u003egit rebase\u003c/code\u003e\u003c/a\u003e.\nThis misunderstanding typically arises during the first merge conflict that interrupts the rebase process.\nThe central point of confusion is usually how Git can reapply one commit onto another.\nMy friends are confused about why a snapshot could have a merge conflict.\nShouldn’t it be obvious, they think, what the final state should be?\u003c/p\u003e\n\u003cp\u003eIn order to understand what’s going on, it’s first necessary to take a quick detour into quantum physics—tongue planted firmly in cheek.\u003c/p\u003e\n\u003ch2 id=\"waveparticle-duality\"\u003eWave/particle duality\u003c/h2\u003e\n\u003cp\u003eIf you’re not already passingly familiar with this particular flavor of apparent quantum nonsense, I am afraid you’re about to get a lot more confused.\nIt turns out that particles such as photons (and electrons, etc) have properties of both classical particles and waves.\nThis leads to experimental results such as the well-known \u003ca href=\"https://en.wikipedia.org/wiki/Double-slit_experiment\"\u003edouble-slit experiment\u003c/a\u003e.\nIf photons are fired through a slit onto a piece of film, they create a band where they passed through the slit, acting as if photons are particles.\nHowever, photons that pass through two side-by-side slits interfere with themselves to create an interference pattern on a piece of film, as if photons are waves.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/the-wave-particle-duality-of-git-commits/slits.jpg\" alt=\"An example of the double-slit experiment\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eThe small extra ripples are the interference from the second slit.\n\u003ca href=\"https://commons.wikimedia.org/w/index.php?curid=9529698\"\u003e(photo CC BY-SA 3.0, by Jordgette)\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThe upshot is that it is important to realize that photons are neither particles nor waves, but rather \u003ca href=\"https://thecuriouschameleon.wordpress.com/2012/09/02/the-jabberwocky-electron/\"\u003esomething strange that behaves like both\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"what-do-photons-have-to-do-with-git\"\u003eWhat do photons have to do with Git?\u003c/h2\u003e\n\u003cp\u003eI’m glad you asked.\u003c/p\u003e\n\u003cp\u003eIt’s easy to see that many Git operations treat commits as snapshots.\nEvery Git user knows how to use \u003ccode\u003echeckout\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"shell\"\u003e$ git checkout 42bd1ef5 \u003cspan\u003e\u0026amp;\u0026amp;\u003c/span\u003e ls -lh\nHEAD is now at 42bd1ef Adjust padding \u003cspan\u003efor\u003c/span\u003e social links\ntotal 48K\ndrwxr-xr-x \u003cspan\u003e2\u003c/span\u003e georgev georgev 4.0K Jun  \u003cspan\u003e1\u003c/span\u003e  \u003cspan\u003e2019\u003c/span\u003e archetypes\ndrwxr-xr-x \u003cspan\u003e3\u003c/span\u003e georgev georgev 4.0K Jun  \u003cspan\u003e1\u003c/span\u003e  \u003cspan\u003e2019\u003c/span\u003e assets\ndrwxr-xr-x \u003cspan\u003e2\u003c/span\u003e georgev georgev 4.0K Jun  \u003cspan\u003e1\u003c/span\u003e  \u003cspan\u003e2019\u003c/span\u003e images\ndrwxr-xr-x \u003cspan\u003e7\u003c/span\u003e georgev georgev 4.0K Aug \u003cspan\u003e25\u003c/span\u003e 13:27 layouts\n-rw-r--r-- \u003cspan\u003e1\u003c/span\u003e georgev georgev 9.3K Jan  \u003cspan\u003e4\u003c/span\u003e 12:21 README.md\ndrwxr-xr-x \u003cspan\u003e3\u003c/span\u003e georgev georgev 4.0K Aug \u003cspan\u003e15\u003c/span\u003e 01:01 static\n-rw-r--r-- \u003cspan\u003e1\u003c/span\u003e georgev georgev  \u003cspan\u003e712\u003c/span\u003e Jun  \u003cspan\u003e1\u003c/span\u003e  \u003cspan\u003e2019\u003c/span\u003e theme.toml\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eBut other commands, such as \u003ccode\u003eshow\u003c/code\u003e, output a unified diff—that is, a patch:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"diff\"\u003e$ git show 42bd1ef5\ncommit 42bd1ef5c5541815ad0ae4eba2c695387228e719\nAuthor: George Hilliard \u0026lt;thirtythreeforty@gmail.com\u0026gt;\nDate:   Tue Dec 31 10:43:45 2019 -0600\n\n    Adjust padding for social links\n\n\u003cspan\u003ediff --git a/assets/scss/hyde-hyde/_sidebar.scss b/assets/scss/hyde-hyde/_sidebar.scss\n\u003c/span\u003e\u003cspan\u003eindex 0686b42..6b34856 100644\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e--- a/assets/scss/hyde-hyde/_sidebar.scss\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e+++ b/assets/scss/hyde-hyde/_sidebar.scss\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e@@ -54,7 +54,7 @@\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e .social {\n   text-align: center;\n   a {\n\u003cspan\u003e-    padding: 0 4px;\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e+    padding: 0 7px;\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e     @include link-no-decoration();\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe same commit hash is present in both commands.\nThere’s no “\u003ccode\u003e--as-patch\u003c/code\u003e” or “\u003ccode\u003e--as-snapshot\u003c/code\u003e” flags to indicate a difference.\nI am in fact referring to the \u003cem\u003esame object\u003c/em\u003e.\nWhat is going on?\u003c/p\u003e\n\u003cp\u003eCommits, it seems, are neither patches nor snapshots until they are observed.\nRather, \u003cstrong\u003ethey are something strange\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e that can be treated as either a patch or a snapshot\u003c/strong\u003e, just as a photon has properties of both a particle and a wave.\u003c/p\u003e\n\u003cp\u003eWhen Git treats a commit as a patch, it appears as the difference between its snapshot and that of its parent.\nWhen Git treats a commit as a snapshot, it appears as the tree of files that were in the staging area when the commit was made.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThis duality of Git commits is what enables operations such as rebase.\u003c/strong\u003e\nGit commands such as \u003ca href=\"https://git-scm.com/book/en/v2/Git-Branching-Rebasing\"\u003e\u003ccode\u003erebase\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://git-scm.com/docs/git-cherry-pick\"\u003e\u003ccode\u003echerry-pick\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://thoughtbot.com/blog/send-a-patch-to-someone-using-git-format-patch\"\u003e\u003ccode\u003eformat-patch\u003c/code\u003e\u003c/a\u003e, etc, all treat a Git commit as a patch, rather than as a snapshot.\nWhen viewed this way, Git’s rebase operation suddenly makes a whole lot more sense: Git takes a string of commits, interprets them as patches, and applies them to the commit you specify.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2020/01/the-wave-particle-duality-of-git-commits/basic-rebase-3.png\" alt=\"Rebase diagram\"/\u003e\u003cfigcaption\u003e\n\u003cp\u003eA simple rebase, where \u003ccode\u003eC4\u003c/code\u003e’s diff has been applied to \u003ccode\u003eC3\u003c/code\u003e.\n\u003ca href=\"https://git-scm.com/book/en/v2/Git-Branching-Rebasing\"\u003e(from Git docs)\u003c/a\u003e\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eIf this process goes smoothly, this creates a new string of commits, with the destination snapshot modified according to the original commits-as-patches.\nAnd so this is also why it’s possible for rebase to create “merge conflicts:” it’s the patches, not that snapshots, that won’t apply cleanly.\u003c/p\u003e\n\u003cp\u003eIs this a silly way to think of commits?\nProbably.\nBut it has been helpful to at least one other person when I explained it this way.\nI hope it helps you too.\u003c/p\u003e\n\u003cp\u003eYou can \u003ca href=\"https://www.thirtythreeforty.net/subscribe/\"\u003esubscribe to updates\u003c/a\u003e via RSS or email.\u003c/p\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eThis duality extends as far as the underlying storage format: individual commits are stored as something very similar to a snapshot: they are a “tree” referencing “blobs”, all referenced by a “commit” blob. But \u003cem\u003e\u003ca href=\"https://git-scm.com/docs/pack-format\"\u003epack files\u003c/a\u003e\u003c/em\u003e are stored similar to patches, with objects optionally being stored as a “delta” to another object occurring earlier in the pack. This is an internal detail that most users of Git need not be aware of. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\n\n\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2020-01-20T08:00:00-06:00",
  "modifiedTime": "2020-01-20T08:00:00-06:00"
}
