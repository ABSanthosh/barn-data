{
  "id": "3556e7d6-e23c-498b-af53-8f3ae9124d78",
  "title": "Instance Main Methods Move from Preview to Final in JDK 25",
  "link": "https://www.infoq.com/news/2025/05/jdk25-instance-main-methods/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "JEP 512 enhances Java with Compact Source Files and Instance Main Methods in JDK 25, easing the learning curve for beginners. Key features include simplified syntax, automatic imports, and a new IO helper class, empowering developers to create programs with minimal complexity. These changes solidify Java's commitment to accessibility and innovation in programming. By A N M Bazlur Rahman",
  "author": "A N M Bazlur Rahman",
  "published": "Mon, 05 May 2025 14:27:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "JEP",
    "Java",
    "Java in Education",
    "JDK 25",
    "Development",
    "news"
  ],
  "byline": "A N M Bazlur Rahman",
  "length": 5421,
  "excerpt": "JEP 512 enhances Java with Compact Source Files and Instance Main Methods in JDK 25, easing the learning curve for beginners. Key features include simplified syntax, automatic imports, and a new IO he",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20250422123038_u1/apple-touch-icon.png",
  "text": "JEP 512, Compact Source Files and Instance Main Methods, has been integrated for JDK 25 following a comprehensive four-round preview cycle beginning with JDK 21. Previously known as Implicitly Declared Classes and Instance Main Methods, these features are now finalized for JDK 25. This evolution introduces refined concepts such as Compact Source Files, flexible instance main methods, a new console I/O helper class, java.lang.IO, and automatic imports for core libraries. The primary goal is to provide beginners with an accessible entry into the Java language, while also enabling experienced developers to craft scripts and prototypes with significantly reduced ceremony. The initiative aligns with the vision articulated by Brian Goetz, Oracle's Java Language Architect, in his September 2022 blog post, \"Paving the On-Ramp.\" Additionally, Gavin Bierman, Oracle's Consulting Member of Technical Staff, recently published the initial specification draft for community review. Traditionally, even the simplest Java program required explicit class declarations: // Traditional \"Hello, World!\" public class HelloWorld {     public static void main(String[] args) {         System.out.println(\"Hello, World!\");     } } JEP 512 addresses this complexity by introducing implicitly declared classes. If a source file (.java) contains methods or fields outside explicit class declarations, the Java compiler treats these contents as belonging to an unnamed, implicitly declared top-level class. This significantly simplifies beginner programs: // \"Hello, World!\" using JEP 512 features void main() {     IO.println(\"Hello, World!\"); } Complementing implicitly declared classes, JEP 512 introduces support for instance methods as program entry points. For simpler scenarios, the historical requirement for a static entry point (public static void main(String[] args)) has been relaxed. The Java launcher protocol now recognizes instance main methods. If the class selected for launching lacks a suitable static main method, the launcher searches for an instance main method. The preferred instance entry-point signature is straightforward: void main() {     // Program logic } An alternative signature, void main(String[] args), is also supported for scenarios involving command-line arguments. This approach eliminates beginners' immediate need to grapple with the static keyword or the String[] args parameter. When utilizing an instance main method, the Java launcher automatically instantiates the class before invoking the main method. Addressing another common point of complexity, particularly reading from System.in and printing via System.out.println, JEP 512 introduces a utility class, java.lang.IO. Residing in the java.lang package, it is implicitly available without explicit import statements. It provides essential static methods for basic console interactions: public static void print(Object obj); public static void println(Object obj); public static void println(); public static String readln(String prompt); public static String readln(); This facilitates simple, interactive programming: // Simple interactive program using java.lang.IO void main() {     String name = IO.readln(\"Please enter your name: \");     IO.print(\"Pleased to meet you, \");     IO.println(name); } Notably, while the IO class itself requires no import, its static methods are no longer implicitly imported into compact source files as in earlier previews. Developers must explicitly qualify method calls (e.g., IO.println(...)) unless using explicit static imports. This adjustment ensures a smoother transition when evolving compact source files into regular classes, avoiding sudden additional requirements like static imports. Further minimizing boilerplate, particularly beneficial for beginners unfamiliar with package structures, compact source files now automatically access all public top-level classes and interfaces from packages exported by the java.base module. This implicit import resembles a declaration (import module java.base;) proposed in a companion JEP, providing seamless access to common classes such as those in java.util, java.io, and java.math (e.g., List, ArrayList, File, BigDecimal). Thus, classes can be directly utilized without explicit imports: // Compact source file using List without explicit import void main() {     var authors = List.of(\"Bazlur\", \"Shaaf\", \"Mike\"); // List is auto-imported     for (var name : authors) {         IO.println(name);     } } The finalization of Compact Source Files, instance main methods, the java.lang.IO class, and automatic imports from the java.base module in JDK 25 marks a substantial refinement to improve Java's learning curve and simplify small program development. By reducing initial complexity, these enhancements facilitate a gradual introduction to Java without compromising the smooth transition to advanced programming constructs. Crucially, these features maintain compatibility and integrate seamlessly into the standard Java toolchain, reinforcing their place as core components rather than isolated dialects. If widely adopted, these improvements could profoundly influence Java education and developers' approach when crafting simple utilities and prototypes. About the Author A N M Bazlur Rahman",
  "image": "https://res.infoq.com/news/2025/05/jdk25-instance-main-methods/en/headerimage/generatedHeaderImage-1746254868247.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\n\n\u003cp dir=\"ltr\"\u003eJEP 512, \u003ca href=\"https://openjdk.org/jeps/512\"\u003eCompact Source Files and Instance Main Methods\u003c/a\u003e, has been integrated for JDK 25 following a comprehensive four-round preview cycle beginning with JDK 21. Previously known as Implicitly Declared Classes and Instance Main Methods, these features are now finalized for \u003ca href=\"https://jdk.java.net/25/\"\u003eJDK 25\u003c/a\u003e. This evolution introduces refined concepts such as Compact Source Files, flexible instance main methods, a new console I/O helper class,\u003ccode\u003e java.lang.IO\u003c/code\u003e, and automatic imports for core libraries. The primary goal is to provide beginners with an accessible entry into the Java language, while also enabling experienced developers to craft scripts and prototypes with significantly reduced ceremony.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe initiative aligns with the vision articulated by \u003ca href=\"https://www.linkedin.com/in/briangoetz/\"\u003eBrian Goetz\u003c/a\u003e, Oracle\u0026#39;s Java Language Architect, in his September 2022 blog post, \u0026#34;\u003ca href=\"https://openjdk.org/projects/amber/design-notes/on-ramp\"\u003ePaving the On-Ramp.\u003c/a\u003e\u0026#34; Additionally, \u003ca href=\"https://www.linkedin.com/in/gavin-bierman-a0173075/\"\u003eGavin Bierman\u003c/a\u003e, Oracle\u0026#39;s Consulting Member of Technical Staff, recently \u003ca href=\"https://mail.openjdk.org/pipermail/amber-dev/2023-May/008065.html\"\u003epublished\u003c/a\u003e the initial \u003ca href=\"https://cr.openjdk.org/~gbierman/jep445/jep445-20230502/specs/unnamed-classes-instance-main-methods-jls.html\"\u003especification draft \u003c/a\u003efor community review.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eTraditionally, even the simplest Java program required explicit class declarations:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e// Traditional \u0026#34;Hello, World!\u0026#34;\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\u0026#34;Hello, World!\u0026#34;);\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eJEP 512 addresses this complexity by introducing implicitly declared classes. If a source file (\u003ccode\u003e.java\u003c/code\u003e) contains methods or fields outside explicit class declarations, the Java compiler treats these contents as belonging to an unnamed, implicitly declared top-level class. This significantly simplifies beginner programs:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e// \u0026#34;Hello, World!\u0026#34; using JEP 512 features\nvoid main() {\n    IO.println(\u0026#34;Hello, World!\u0026#34;);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eComplementing implicitly declared classes, JEP 512 introduces support for instance methods as program entry points. For simpler scenarios, the historical requirement for a static entry point (\u003ccode\u003epublic static void main(String[] args)\u003c/code\u003e) has been relaxed.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eThe Java launcher protocol now recognizes instance main methods. If the class selected for launching lacks a suitable static main method, the launcher searches for an instance main method. The preferred instance entry-point signature is straightforward:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003evoid main() {\n    // Program logic\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn alternative signature, \u003ccode\u003evoid main(String[] args)\u003c/code\u003e, is also supported for scenarios involving command-line arguments. This approach eliminates beginners\u0026#39; immediate need to grapple with the \u003ccode\u003estatic\u003c/code\u003e keyword or the \u003ccode\u003eString[] args\u003c/code\u003e parameter. When utilizing an instance main method, the Java launcher automatically instantiates the class before invoking the main method.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eAddressing another common point of complexity, particularly reading from \u003ccode\u003eSystem.in\u003c/code\u003e and printing via \u003ccode\u003eSystem.out.println, \u003c/code\u003eJEP 512 introduces a utility class, \u003ccode\u003ejava.lang.IO\u003c/code\u003e. Residing in the \u003ccode\u003ejava.lang\u003c/code\u003e package, it is implicitly available without explicit import statements. It provides essential static methods for basic console interactions:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epublic static void print(Object obj);\npublic static void println(Object obj);\npublic static void println();\npublic static String readln(String prompt);\npublic static String readln();\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis facilitates simple, interactive programming:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e// Simple interactive program using java.lang.IO\nvoid main() {\n    String name = IO.readln(\u0026#34;Please enter your name: \u0026#34;);\n    IO.print(\u0026#34;Pleased to meet you, \u0026#34;);\n    IO.println(name);\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNotably, while the \u003ccode\u003eIO\u003c/code\u003e class itself requires no import, its static methods are no longer implicitly imported into compact source files as in earlier previews. Developers must explicitly qualify method calls (e.g., \u003ccode\u003eIO.println(...)\u003c/code\u003e) unless using explicit static imports. This adjustment ensures a smoother transition when evolving compact source files into regular classes, avoiding sudden additional requirements like static imports.\u003c/p\u003e\n\n\u003cp dir=\"ltr\"\u003eFurther minimizing boilerplate, particularly beneficial for beginners unfamiliar with package structures, compact source files now automatically access all public top-level classes and interfaces from packages exported by the \u003ccode\u003ejava.base\u003c/code\u003e module. This implicit import resembles a declaration (\u003ccode\u003eimport module java.base;\u003c/code\u003e) proposed in a companion JEP, providing seamless access to common classes such as those in \u003ccode\u003ejava.util, java.io\u003c/code\u003e, and \u003ccode\u003ejava.math\u003c/code\u003e (e.g., \u003ccode\u003eList, ArrayList, File, BigDecimal\u003c/code\u003e). Thus, classes can be directly utilized without explicit imports:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e// Compact source file using List without explicit import\nvoid main() {\n    var authors = List.of(\u0026#34;Bazlur\u0026#34;, \u0026#34;Shaaf\u0026#34;, \u0026#34;Mike\u0026#34;); // List is auto-imported\n    for (var name : authors) {\n        IO.println(name);\n    }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe finalization of Compact Source Files, instance main methods, the \u003ccode\u003ejava.lang.IO\u003c/code\u003e class, and automatic imports from the \u003ccode\u003ejava.base\u003c/code\u003e module in JDK 25 marks a substantial refinement to improve Java\u0026#39;s learning curve and simplify small program development. By reducing initial complexity, these enhancements facilitate a gradual introduction to Java without compromising the smooth transition to advanced programming constructs. Crucially, these features maintain compatibility and integrate seamlessly into the standard Java toolchain, reinforcing their place as core components rather than isolated dialects. If widely adopted, these improvements could profoundly influence Java education and developers\u0026#39; approach when crafting simple utilities and prototypes.\u003c/p\u003e\n\n\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-A-N-M-Bazlur-Rahman\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eA N M Bazlur Rahman\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-05-05T00:00:00Z",
  "modifiedTime": null
}
