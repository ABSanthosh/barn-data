{
  "id": "1b9ebced-4637-475c-b44a-d9c0dcba6193",
  "title": "Java Evolves to Tackle Pinning with JEP 491",
  "link": "https://www.infoq.com/news/2024/11/java-evolves-tackle-pinning/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "JEP 491, \"Synchronize Virtual Threads without Pinning,\" is now Proposed to Target for JDK 24. This initiative aims to resolve Java's \"pinning\" issue, a limitation of the synchronized keyword, which restricts scalability with virtual threads. JEP 491 eliminates this constraint, unlocking high-performance concurrency without extensive refactoring. By A N M Bazlur Rahman",
  "author": "A N M Bazlur Rahman",
  "published": "Mon, 04 Nov 2024 14:47:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Virtual Thread",
    "Concurrency",
    "Java 24",
    "Java",
    "Development",
    "news"
  ],
  "byline": "A N M Bazlur Rahman",
  "length": 5086,
  "excerpt": "JEP 491, \u0026quot;Synchronize Virtual Threads without Pinning,\u0026quot; is now Proposed to Target for JDK 24. This initiative aims to resolve Java's \u0026quot;pinning\u0026quot; issue, a limitation of the synchronized keyword, which re",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s2_20241101091555/apple-touch-icon.png",
  "text": "JEP 491, Synchronize Virtual Threads without Pinning, has been promoted to Proposed to Target status for JDK 24. This proposal aims to overhaul how Java’s synchronized methods interact with virtual threads to eliminate the longstanding issue of “pinning” that limits thread scalability. Virtual threads, introduced in JDK 21, enable increased throughput of applications utilizing hundreds of thousands of threads. However, pinning — a limitation due to synchronized keyword — has restricted Java developers from fully capitalizing on this innovation. JEP 491 addresses this issue, paving the way for high-performance, high-concurrency applications without requiring extensive refactoring. In Java, synchronization is achieved with monitors associated with each object. A thread entering a synchronized block or method acquires a lock on the monitor. This ensures that only one thread can execute within that block or method at a time. However, in Java’s current model, the JVM registers the monitor lock with the platform thread — not the virtual thread. This association has resulted in pinning: once a virtual thread acquires a lock, it is bound to the underlying platform thread, preventing the scheduler from reallocating it to other virtual threads. Consider the following example, where a method reads bytes from a socket: synchronized byte[] getData() { byte[] buf = ...; int nread = socket.getInputStream().read(buf); // Can block here ... } If this method blocks during the read operation, the JVM will pin the virtual thread to its platform thread, essentially consuming the resources until data is available. Such blocking limits scalability, as pinned virtual threads occupy platform threads that could otherwise support additional virtual threads. JEP 491 proposes allowing virtual threads to unmount even within synchronized blocks, freeing their platform carriers to execute other virtual threads. To help developers identify problematic code, the JDK currently records a jdk.VirtualThreadPinned event in JDK Flight Recorder (JFR) whenever a virtual thread blocks within a synchronized method. This event has been invaluable for pinpointing areas where developers may need to refactor code or switch from synchronized to java.util.concurrent locks to avoid pinning. For instance, code that involves heavy I/O operations within synchronized blocks leads to pinning. However, with JEP 491’s proposed changes, the jdk.VirtualThreadPinned event will only remain relevant for scenarios where virtual threads interact with native code. Furthermore, the jdk.tracePinnedThreads system property, which logs stack traces when virtual threads block, will no longer be necessary and will be removed to prevent performance issues. This JEP proposes reimplementing the synchronized keyword, which will enable virtual threads to acquire, hold, and release monitors without tying these actions to their carrier threads. The JVM scheduler will allow blocked virtual threads to unmount from platform threads, releasing those threads for other tasks. This will involve changes to the Object.wait() and Object.notify() mechanisms, allowing virtual threads to suspend and resume without locking their carrier platform threads. For example, a virtual thread that calls Object.wait() in a synchronized block will unmount and remount when signaled to continue, as shown below: synchronized void waitForCondition() { while (!condition) { wait(); // Virtual thread unmounts here } ... } With this approach, applications can scale better without requiring developers to abandon synchronized in favour of java.util.concurrent locks. JEP 491 acknowledges that a few exceptional scenarios will continue to pin virtual threads. These cases include blocking inside class initializers, waiting for class initialization by other threads, and blocking while resolving symbolic references during class loading. While these instances are relatively rare, they may cause issues under specific conditions, particularly in highly concurrent applications. The proposal suggests monitoring these scenarios and revisiting them in future updates if they become problematic. One alternative to JEP 491 is to increase the parallelism of the virtual thread scheduler to mitigate the effects of pinning. However, this approach is limited by a default cap of 256 platform threads to the scheduler. Another option involves rewriting bytecode to replace synchronized with ReentrantLock dynamically, but this solution would entail high overhead and complexity, which can potentially compromise performance and compatibility with existing JVM features. As Java continues to evolve, JEP 491 will serve as a critical step toward refining virtual threads and simplifying Java’s concurrency model. The proposed changes will allow developers to build high-throughput applications without the trade-offs previously required. About the Author A N M Bazlur Rahman",
  "image": "https://res.infoq.com/news/2024/11/java-evolves-tackle-pinning/en/headerimage/header+%288%29-1730519825008.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eJEP 491, \u003ca href=\"https://openjdk.org/jeps/491\"\u003eSynchronize Virtual Threads without Pinning\u003c/a\u003e, has been promoted to \u003cstrong\u003eProposed to Target\u003c/strong\u003e status for JDK 24. This proposal aims to overhaul how Java’s \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e methods interact with virtual threads to eliminate the longstanding issue of “\u003ca href=\"https://openjdk.org/jeps/444#Pinning\"\u003epinning\u003c/a\u003e” that limits thread scalability. \u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Thread.html#virtual-threads\"\u003eVirtual threads\u003c/a\u003e, introduced in \u003ca href=\"https://openjdk.org/projects/jdk/21/\"\u003eJDK 21\u003c/a\u003e, enable increased throughput of applications utilizing hundreds of thousands of threads. However, pinning — a limitation due to \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e keyword — has restricted Java developers from fully capitalizing on this innovation. JEP 491 addresses this issue, paving the way for high-performance, high-concurrency applications without requiring extensive refactoring.\u003c/p\u003e\n\n\u003cp\u003eIn Java, synchronization is achieved with monitors associated with each object. A thread entering a \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e block or method acquires a lock on the \u003ca href=\"https://en.wikipedia.org/wiki/Monitor_(synchronization)\"\u003emonitor\u003c/a\u003e. This ensures that only one thread can execute within that block or method at a time. However, in Java’s current model, the JVM registers the monitor lock with the \u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Thread.html#platform-threads\"\u003eplatform thread\u003c/a\u003e — not the virtual thread. This association has resulted in pinning: once a virtual thread acquires a lock, it is bound to the underlying platform thread, preventing the scheduler from reallocating it to other virtual threads.\u003c/p\u003e\n\n\u003cp\u003eConsider the following example, where a method reads bytes from a socket:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esynchronized byte[] getData() {\n    byte[] buf = ...;\n    int nread = socket.getInputStream().read(buf); // Can block here\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf this method blocks during the read operation, the JVM will pin the virtual thread to its platform thread, essentially consuming the resources until data is available. Such blocking limits scalability, as pinned virtual threads occupy platform threads that could otherwise support additional virtual threads. JEP 491 proposes allowing virtual threads to unmount even within synchronized blocks, freeing their platform carriers to execute other virtual threads.\u003c/p\u003e\n\n\u003cp\u003eTo help developers identify problematic code, the JDK currently records a \u003cstrong\u003e\u003ccode\u003e\u003ca href=\"https://openjdk.org/jeps/444#JDK-Flight-Recorder-JFR\"\u003ejdk.VirtualThreadPinned\u003c/a\u003e\u003c/code\u003e\u003c/strong\u003e event in JDK Flight Recorder (JFR) whenever a virtual thread blocks within a synchronized method. This event has been invaluable for pinpointing areas where developers may need to refactor code or switch from \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e to \u003cstrong\u003e\u003ccode\u003e\u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/locks/package-summary.html\"\u003ejava.util.concurrent\u003c/a\u003e\u003c/code\u003e\u003c/strong\u003e locks to avoid pinning. For instance, code that involves heavy I/O operations within synchronized blocks leads to pinning. However, with JEP 491’s proposed changes, the \u003cstrong\u003e\u003ccode\u003ejdk.VirtualThreadPinned\u003c/code\u003e\u003c/strong\u003e event will only remain relevant for scenarios where virtual threads interact with native code.\u003c/p\u003e\n\n\u003cp\u003eFurthermore, the \u003cstrong\u003e\u003ccode\u003ejdk.tracePinnedThreads\u003c/code\u003e\u003c/strong\u003e system property, which logs stack traces when virtual threads block, will no longer be necessary and will be removed to prevent performance issues.\u003c/p\u003e\n\n\u003cp\u003eThis JEP proposes reimplementing the \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e keyword, which will enable virtual threads to acquire, hold, and release monitors without tying these actions to their carrier threads. The JVM scheduler will allow blocked virtual threads to unmount from platform threads, releasing those threads for other tasks. This will involve changes to the \u003cstrong\u003e\u003ccode\u003e\u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Object.html#wait()\"\u003eObject.wait()\u003c/a\u003e\u003c/code\u003e\u003c/strong\u003e and \u003cstrong\u003e\u003ccode\u003e\u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Object.html#notify()\"\u003eObject.notify()\u003c/a\u003e\u003c/code\u003e\u003c/strong\u003e mechanisms, allowing virtual threads to suspend and resume without locking their carrier platform threads.\u003c/p\u003e\n\n\u003cp\u003eFor example, a virtual thread that calls \u003cstrong\u003e\u003ccode\u003eObject.wait()\u003c/code\u003e\u003c/strong\u003e in a synchronized block will unmount and remount when signaled to continue, as shown below:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esynchronized void waitForCondition() {\n    while (!condition) {\n        wait();  // Virtual thread unmounts here\n    }\n    ...\n}\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith this approach, applications can scale better without requiring developers to abandon \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e in favour of \u003cstrong\u003e\u003ccode\u003ejava.util.concurrent\u003c/code\u003e\u003c/strong\u003e locks.\u003c/p\u003e\n\n\u003cp\u003eJEP 491 acknowledges that a few exceptional scenarios will continue to pin virtual threads. These cases include blocking inside class initializers, waiting for class initialization by other threads, and blocking while resolving symbolic references during class loading. While these instances are relatively rare, they may cause issues under specific conditions, particularly in highly concurrent applications. The proposal suggests monitoring these scenarios and revisiting them in future updates if they become problematic.\u003c/p\u003e\n\n\u003cp\u003eOne alternative to JEP 491 is to increase the parallelism of the virtual thread scheduler to mitigate the effects of pinning. However, this approach is limited by a default cap of 256 platform threads to the scheduler. Another option involves rewriting bytecode to replace \u003cstrong\u003e\u003ccode\u003esynchronized\u003c/code\u003e\u003c/strong\u003e with \u003cstrong\u003e\u003ccode\u003e\u003ca href=\"https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html\"\u003eReentrantLock\u003c/a\u003e\u003c/code\u003e\u003c/strong\u003e dynamically, but this solution would entail high overhead and complexity, which can potentially compromise performance and compatibility with existing JVM features.\u003c/p\u003e\n\n\u003cp\u003eAs Java continues to evolve, JEP 491 will serve as a critical step toward refining virtual threads and simplifying Java’s concurrency model. The proposed changes will allow developers to build high-throughput applications without the trade-offs previously required.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-A-N-M-Bazlur-Rahman\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eA N M Bazlur Rahman\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-11-04T00:00:00Z",
  "modifiedTime": null
}
