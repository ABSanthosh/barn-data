{
  "id": "354e73cb-4fbd-4ed8-b2de-5f0c17a35afe",
  "title": "Designing My Linux-Powered Business Card",
  "link": "https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/",
  "description": "Table of Contents Designing the computer Picking a processor Finding resources for the F1C100s Everything else Designing the physical card Sizing Graphic design USB Hand-assembly Software Porting U-Boot and Linux Building the flash image Flashing a card Finishing touches I recently built a business card that runs Linux. This is a detailed design log, plus a few random notes, from the build. If you want to see the blinkenlights, first you should go read my other blog post detailing the finished product. Designing the computer First and foremost, I would need to choose a Linux-capable processor, because it would be the driving factor in the affordability and feasibility of the final product. Picking a processor I started by looking for processors that were the magic combination: inexpensive, USB, no BGA footprints, and purchasable somewhere, even if I had to get it from Taobao. (You usually can’t buy these processors from Mouser or the manufacturer.) Ideally, there would also be a known-good piece of hardware I could get as a development board. I also really wanted a part that had RAM included in the package. This is fairly rare for microprocessors, in contrast to micro_controllers_ which typically don’t have enough juice to run Linux. This constraint really narrowed down my choices, but I stuck with it because it would make design and assembly a lot easier. Many of the processors in this price class are made by Chinese companies and there’s not a lot of info about them available in English, so finding them takes some digging. (If you know of other Chinese-only processors in this category, please let me know about them as I would be excited to learn about them.) My first attempt was using an STM32F4, which can be persuaded to run Linux if it’s hooked up to external SDRAM, like in this Emcraft Systems system-on-module. Unfortunately the STM32 parts that can be hooked up to SDRAM are BGA, or else they use obscure RAM buses that I can barely find any documentation for, let alone buy parts for. The nail in this coffin is that the cheapest STM32F4 that would work was around $9 for the processor alone. That’s too expensive if I’m going to give away the result. I looked around a lot at the chips used in really cheap routers. Parts like the AR9331 are ancient MIPS-based designs that continue to be used in bottom-of-the-line routers. Unfortunately most of these parts are—you guessed it—BGA, and even the ones that aren’t, still don’t have RAM included. Really what I wanted was a really cheap processor for IoT, dashcams, or tablets. I struck gold with Sipeed’s Lichee boards, which are the cheapest Linux development boards I’ve seen anywhere. The Lichee Zero has an Allwinner V3s, which seemed to tick all the boxes. It’s QFP, has 64MB built-in RAM, and there are even people selling them on eBay. The V3s is very well supported by the sunxi community. Unfortunately the best price I could find was around $4 on Taobao. This wasn’t the end of the world if it was the best I could do, but I kept looking. Finally I found my pigeon: the Lichee Nano uses a very small Allwinner part called the F1C100s. Here’s the Nano next to an SD card. Pretty small. This is an ARM9 design Allwinner apparently makes for dashcams. ARM9 is ancient technology, but I am not trying to win any performance awards. The part comes in a QFN package with a rather small 0.4mm pitch, but at the end of the day it’s still workable with a steady hand. It has 32MB RAM in the package, which is a veritable bounty for my purposes. It is astoundingly cheap for a Linux-capable processor: In single quantities, I found it at $1.20 or so on Taobao, and recently I’ve seen listings for $0.90 apiece. I bought a big bag of them (top left). (It turns out that you can buy nearly any chip under the sun on Taobao. I used Superbuy to batch up my purchases into one box shipped overseas.) Finding resources for the F1C100s The best resource I found was that Sipeed actually published their schematic for the Lichee Nano. This was absolutely invaluable as there were several places in the datasheet where a pin was named, but there was nothing explaining what you should do with the pin. Googling around also led me to the reference manual for the F1C600, which is apparently an F1C100s rebadged as Linux-capable. So I had register definitions and a real datasheet. I want to reiterate that I’m doing this as a hack. Using random schematics you find on the internet is not the best way to build a product. Allwinner does not support this part unless you are a large company and get in touch with them directly. The F1C100s so cheap that it’s not even supported by the sunxi folks, but some work was done in early 2019 getting the part supported the Linux kernel. I found a branch on GitHub by Icenowy who added drivers for some of the other peripherals. I also found a port of U-Boot. With all this, I decided that the software was complete enough that I could write drivers for anything else I needed. Everything else Once I had the processor picked and laid out in KiCAD, the rest was reasonably easy. I made sure the interfaces were all very similar to the Nano, so that I could get my code working on the Nano and hopefully everything would Just Boot on the business card. I used ordinary NOR flash for storage and added an LED for bling. The first version had an unpopulated JTAG header on the back in case I got into dire straits; this proved unnecessary and I removed it on the second spin. I also threw in a Shitty Add-on header, just in case I needed UART on the final card. This was removed on the second spin and replaced with a nice compact SOICbite footprint; I have needed neither. Here’s the schematic; click to download. I hope it helps you if you want to use this part. Feel free to contact me if you have questions. Designing the physical card Sizing Board space was not a problem; the computer easily fits in the bottom corner of a standard-size card. A bigger problem was that I wanted the card to be as thin as possible; however, a PCB must be 2.2mm or so thick to make it fit in a USB port. I solved this by selecting 1mm PCBs and laser-cutting some 1mm acrylic into appropriately-sized spacers. The final assembly step is to superglue this spacer into place. Graphic design Designing the text of the card was easy enough, but because there’s no way to use custom fonts in KiCAD, I needed to import it as a vector. Unfortunately there is not a good solution to putting vector images on any layer except Edge.Cuts, and of course I did not want to do that. The best way I found was to export the design from Inkscape as a super-high-resolution 4000dpi PNG file, then trace it as a footprint in KiCAD using bitmap2component. Although tracing a bitmap makes my inner typographer cringe a little, in practice the resolution of the footprint far exceeds the board house’s capabilities and it looks great without hand-tracing every letter. Plenty of points here on the curves. USB Routing USB was tricky on this board because the traces are fairly long. Although I’m just using full speed USB, which is pretty forgiving, I still did my best to impedance-control these traces. The USB traces are comically large because the two-layer board makes getting decent capacitance difficult. Thank goodness it’s only 1mm thick (a standard 1.6mm board would make the traces even fatter). Hand-assembly I’m laser-cutting my own stencil. The 0.2mm apertures for the processor pins are at the hairy edge of what the machine is capable of. I ended up cutting the pins in two passes, skipping every other one, to prevent them from all melting together as the laser cut them one after the other. If I ever need to go any smaller, I’ll definitely just order a stencil from OSH Stencils. Software Porting U-Boot and Linux The first step of porting Linux to any board is getting U-Boot up and running. Someone on GitHub named Icenowy had done some work getting an older U-Boot version running on the part; it was in rough shape but it would boot, which I was very glad about. I rebased this onto v2019.04 and added support in a couple drivers for various other mostly-uninteresting subsystems like the pin controller and clock. Due to a bug, about 70% of my overall effort on the software was spent getting U-Boot to talk to the flash. U-Boot has a driver for the SPI peripheral on this part, but it didn’t work. The symptom was that the SPI peripheral could detect the flash chip, but always read garbage from it. It turned out that U-Boot likes to reset the SPI peripheral when it’s done with it. This apparently hasn’t caused any problems for other Allwinner parts. However, on the F1C100s, resetting the peripheral unsurprisingly erases its configuration registers, especially those for setting speed. Once I figured this out, it was a quick fix to reconfigure the registers when needed: From 869a7c04f23fe9e10c26b7f1af9774ea813ea49a Mon Sep 17 00:00:00 2001 From: George Hilliard Date: Wed, 19 Jun 2019 22:37:30 -0500 Subject: [PATCH] sunxi-spi: restore bus speed and mode after reset The sunxi SPI peripheral driver resets the device completely (disabling clocks and power) when the bus is released and turns it back on when claiming. On the F1C100s (and maybe others), the peripheral resets back to default register settings, losing speed and mode settings. Restore these settings when resetting the peripheral. Signed-off-by: George Hilliard Cc: Jagan Teki --- drivers/spi/spi-sunxi.c | 10 +++++++++- 1 file changed, 9 insertions(+), 1 deletion(-) diff --git a/drivers/spi/spi-sunxi.c b/drivers/spi/spi-sunxi.c index dbfeac77eec..2d02289d04d 100644 --- a/drivers/spi/spi-sunxi.c +++ b/drivers/spi/spi-sunxi.c @@ -35,6 +35,10 @@ DECLARE_GLOBAL_DATA_PTR; +/* Forward declarations of some reused functions */ +static int sun4i_spi_set_speed(struct udevice *dev, uint speed); +static int sun4i_spi_set_mode(struct udevice *dev, uint mode); + /* sun4i spi registers */ #define SUN4I_RXDATA_REG 0x00 #define SUN4I_TXDATA_REG 0x04 @@ -300,7 +304,8 @@ static inline int sun4i_spi_set_clock(struct udevice *dev, bool enable) static int sun4i_spi_claim_bus(struct udevice *dev) { - struct sun4i_spi_priv *priv = dev_get_priv(dev-\u003eparent); + struct udevice *bus = dev-\u003eparent; + struct sun4i_spi_priv *priv = dev_get_priv(bus); int ret; ret = sun4i_spi_set_clock(dev-\u003eparent, true); @@ -317,6 +322,9 @@ static int sun4i_spi_claim_bus(struct udevice *dev) setbits_le32(SPI_REG(priv, SPI_TCR), SPI_BIT(priv, SPI_TCR_CS_MANUAL) | SPI_BIT(priv, SPI_TCR_CS_ACTIVE_LOW)); + sun4i_spi_set_speed(bus, priv-\u003efreq); + sun4i_spi_set_mode(bus, priv-\u003emode); + return 0; } Everything works great after this fix! Linux 5.2 booted like a champ. Again, I ported Icenowy’s Linux work forward—some of it had been merged; some of it needed massaging to apply. Normal Linux kernel development stuff. There were a couple typos that I fixed to get USB working. Building the flash image The board has 8MB of flash. This must include the bootloader, the kernel, the root filesystem, and the small persistent partition. I decided to use UBI to house everything except the bootloader, which has to be positioned at the very front of the flash. Using genimage, I define the physical partitions: image flash.bin { flash {} flashtype = w25q64 partition uboot { image = \"u-boot-sunxi-with-spl.bin\" size = 256K } partition rootubi { image = root.ubi size = 0 } } Then, root.ubi is built from the partitions' images: image root.ubi { ubi {} partition kernel { image = \"zImage\" read-only = true } partition dtb { image = \"businesscard.dtb\" read-only = true } partition root { image = \"rootfs.squashfs\" read-only = true } partition flashdrive { image = flashdrive.img read-only = true } partition persist { image = persist.ubifs } } During build, genimage uses this definition to automatically compile a binary ready to flash to the card. Flashing a card Once I’m ready to program a newly made card, I simply plug it into my laptop. The processor can’t find anything to boot (the flash is blank), so it runs its built-in “FEL mode,” which lets me use a tool called sunxi-fel to send the generated image over USB: output/host/bin/sunxi-fel -p spiflash-write 0 output/images/flash.bin Flashing eight measly megabytes takes the better part of two minutes, because NOR flash has an amazingly slow write speed of around 100KB/s. Finishing touches Getting everything buttoned up is the hardest part of any project, in my opinion. I’ve been working on these blog posts, and cleaning up my Buildroot work, for the past month or so in my spare time. I hope to ultimately upstream all the software changes, and I’ve open-sourced everything for the benefit of the community. Soon I hope to put together a “resource page” for the F1C100s with links to everything you need to get going with it. In the meantime, you can go get everything from the Resources section of my main write-up. I’ll also drop another plug for my ongoing Mastering Embedded Linux series. I’m walking through how to build hardware and software from scratch for tiny, cheap Linux systems much like my business card. I hope you have enjoyed this write-up. Feel free to leave comments or drop me a line!",
  "author": "George Hilliard",
  "published": "Mon, 23 Dec 2019 19:37:00 -0500",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 13416,
  "excerpt": "Behind-the-scenes build log for my Linux-powered business card",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "Table of Contents Designing the computer Picking a processor Finding resources for the F1C100s Everything else Designing the physical card Sizing Graphic design USB Hand-assembly Software Porting U-Boot and Linux Building the flash image Flashing a card Finishing touches I recently built a business card that runs Linux. This is a detailed design log, plus a few random notes, from the build. If you want to see the blinkenlights, first you should go read my other blog post detailing the finished product. Designing the computer First and foremost, I would need to choose a Linux-capable processor, because it would be the driving factor in the affordability and feasibility of the final product. Picking a processor I started by looking for processors that were the magic combination: inexpensive, USB, no BGA footprints, and purchasable somewhere, even if I had to get it from Taobao. (You usually can’t buy these processors from Mouser or the manufacturer.) Ideally, there would also be a known-good piece of hardware I could get as a development board. I also really wanted a part that had RAM included in the package. This is fairly rare for microprocessors, in contrast to micro_controllers_ which typically don’t have enough juice to run Linux. This constraint really narrowed down my choices, but I stuck with it because it would make design and assembly a lot easier. Many of the processors in this price class are made by Chinese companies and there’s not a lot of info about them available in English, so finding them takes some digging. (If you know of other Chinese-only processors in this category, please let me know about them as I would be excited to learn about them.) My first attempt was using an STM32F4, which can be persuaded to run Linux if it’s hooked up to external SDRAM, like in this Emcraft Systems system-on-module. Unfortunately the STM32 parts that can be hooked up to SDRAM are BGA, or else they use obscure RAM buses that I can barely find any documentation for, let alone buy parts for. The nail in this coffin is that the cheapest STM32F4 that would work was around $9 for the processor alone. That’s too expensive if I’m going to give away the result. I looked around a lot at the chips used in really cheap routers. Parts like the AR9331 are ancient MIPS-based designs that continue to be used in bottom-of-the-line routers. Unfortunately most of these parts are—you guessed it—BGA, and even the ones that aren’t, still don’t have RAM included. Really what I wanted was a really cheap processor for IoT, dashcams, or tablets. I struck gold with Sipeed’s Lichee boards, which are the cheapest Linux development boards I’ve seen anywhere. The Lichee Zero has an Allwinner V3s, which seemed to tick all the boxes. It’s QFP, has 64MB built-in RAM, and there are even people selling them on eBay. The V3s is very well supported by the sunxi community. Unfortunately the best price I could find was around $4 on Taobao. This wasn’t the end of the world if it was the best I could do, but I kept looking. Finally I found my pigeon: the Lichee Nano uses a very small Allwinner part called the F1C100s. Here’s the Nano next to an SD card. Pretty small. This is an ARM9 design Allwinner apparently makes for dashcams. ARM9 is ancient technology, but I am not trying to win any performance awards. The part comes in a QFN package with a rather small 0.4mm pitch, but at the end of the day it’s still workable with a steady hand. It has 32MB RAM in the package, which is a veritable bounty for my purposes. It is astoundingly cheap for a Linux-capable processor: In single quantities, I found it at $1.20 or so on Taobao, and recently I’ve seen listings for $0.90 apiece. I bought a big bag of them (top left). (It turns out that you can buy nearly any chip under the sun on Taobao. I used Superbuy to batch up my purchases into one box shipped overseas.) Finding resources for the F1C100s The best resource I found was that Sipeed actually published their schematic for the Lichee Nano. This was absolutely invaluable as there were several places in the datasheet where a pin was named, but there was nothing explaining what you should do with the pin. Googling around also led me to the reference manual for the F1C600, which is apparently an F1C100s rebadged as Linux-capable. So I had register definitions and a real datasheet. I want to reiterate that I’m doing this as a hack. Using random schematics you find on the internet is not the best way to build a product. Allwinner does not support this part unless you are a large company and get in touch with them directly. The F1C100s so cheap that it’s not even supported by the sunxi folks, but some work was done in early 2019 getting the part supported the Linux kernel. I found a branch on GitHub by Icenowy who added drivers for some of the other peripherals. I also found a port of U-Boot. With all this, I decided that the software was complete enough that I could write drivers for anything else I needed. Everything else Once I had the processor picked and laid out in KiCAD, the rest was reasonably easy. I made sure the interfaces were all very similar to the Nano, so that I could get my code working on the Nano and hopefully everything would Just Boot on the business card. I used ordinary NOR flash for storage and added an LED for bling. The first version had an unpopulated JTAG header on the back in case I got into dire straits; this proved unnecessary and I removed it on the second spin. I also threw in a Shitty Add-on header, just in case I needed UART on the final card. This was removed on the second spin and replaced with a nice compact SOICbite footprint; I have needed neither. Here’s the schematic; click to download. I hope it helps you if you want to use this part. Feel free to contact me if you have questions. Designing the physical card Sizing Board space was not a problem; the computer easily fits in the bottom corner of a standard-size card. A bigger problem was that I wanted the card to be as thin as possible; however, a PCB must be 2.2mm or so thick to make it fit in a USB port. I solved this by selecting 1mm PCBs and laser-cutting some 1mm acrylic into appropriately-sized spacers. The final assembly step is to superglue this spacer into place. Graphic design Designing the text of the card was easy enough, but because there’s no way to use custom fonts in KiCAD, I needed to import it as a vector. Unfortunately there is not a good solution to putting vector images on any layer except Edge.Cuts, and of course I did not want to do that. The best way I found was to export the design from Inkscape as a super-high-resolution 4000dpi PNG file, then trace it as a footprint in KiCAD using bitmap2component. Although tracing a bitmap makes my inner typographer cringe a little, in practice the resolution of the footprint far exceeds the board house’s capabilities and it looks great without hand-tracing every letter. Plenty of points here on the curves. USB Routing USB was tricky on this board because the traces are fairly long. Although I’m just using full speed USB, which is pretty forgiving, I still did my best to impedance-control these traces. The USB traces are comically large because the two-layer board makes getting decent capacitance difficult. Thank goodness it’s only 1mm thick (a standard 1.6mm board would make the traces even fatter). Hand-assembly I’m laser-cutting my own stencil. The 0.2mm apertures for the processor pins are at the hairy edge of what the machine is capable of. I ended up cutting the pins in two passes, skipping every other one, to prevent them from all melting together as the laser cut them one after the other. If I ever need to go any smaller, I’ll definitely just order a stencil from OSH Stencils. Software Porting U-Boot and Linux The first step of porting Linux to any board is getting U-Boot up and running. Someone on GitHub named Icenowy had done some work getting an older U-Boot version running on the part; it was in rough shape but it would boot, which I was very glad about. I rebased this onto v2019.04 and added support in a couple drivers for various other mostly-uninteresting subsystems like the pin controller and clock. Due to a bug, about 70% of my overall effort on the software was spent getting U-Boot to talk to the flash. U-Boot has a driver for the SPI peripheral on this part, but it didn’t work. The symptom was that the SPI peripheral could detect the flash chip, but always read garbage from it. It turned out that U-Boot likes to reset the SPI peripheral when it’s done with it. This apparently hasn’t caused any problems for other Allwinner parts. However, on the F1C100s, resetting the peripheral unsurprisingly erases its configuration registers, especially those for setting speed. Once I figured this out, it was a quick fix to reconfigure the registers when needed: From 869a7c04f23fe9e10c26b7f1af9774ea813ea49a Mon Sep 17 00:00:00 2001 From: George Hilliard \u003cthirtythreeforty@gmail.com\u003e Date: Wed, 19 Jun 2019 22:37:30 -0500 Subject: [PATCH] sunxi-spi: restore bus speed and mode after reset The sunxi SPI peripheral driver resets the device completely (disabling clocks and power) when the bus is released and turns it back on when claiming. On the F1C100s (and maybe others), the peripheral resets back to default register settings, losing speed and mode settings. Restore these settings when resetting the peripheral. Signed-off-by: George Hilliard \u003cthirtythreeforty@gmail.com\u003e Cc: Jagan Teki \u003cjteki@openedev.com\u003e --- drivers/spi/spi-sunxi.c | 10 +++++++++- 1 file changed, 9 insertions(+), 1 deletion(-) diff --git a/drivers/spi/spi-sunxi.c b/drivers/spi/spi-sunxi.c index dbfeac77eec..2d02289d04d 100644 --- a/drivers/spi/spi-sunxi.c +++ b/drivers/spi/spi-sunxi.c @@ -35,6 +35,10 @@ DECLARE_GLOBAL_DATA_PTR; +/* Forward declarations of some reused functions */ +static int sun4i_spi_set_speed(struct udevice *dev, uint speed); +static int sun4i_spi_set_mode(struct udevice *dev, uint mode); + /* sun4i spi registers */ #define SUN4I_RXDATA_REG 0x00 #define SUN4I_TXDATA_REG 0x04 @@ -300,7 +304,8 @@ static inline int sun4i_spi_set_clock(struct udevice *dev, bool enable) static int sun4i_spi_claim_bus(struct udevice *dev) { - struct sun4i_spi_priv *priv = dev_get_priv(dev-\u003eparent); + struct udevice *bus = dev-\u003eparent; + struct sun4i_spi_priv *priv = dev_get_priv(bus); int ret; ret = sun4i_spi_set_clock(dev-\u003eparent, true); @@ -317,6 +322,9 @@ static int sun4i_spi_claim_bus(struct udevice *dev) setbits_le32(SPI_REG(priv, SPI_TCR), SPI_BIT(priv, SPI_TCR_CS_MANUAL) | SPI_BIT(priv, SPI_TCR_CS_ACTIVE_LOW)); + sun4i_spi_set_speed(bus, priv-\u003efreq); + sun4i_spi_set_mode(bus, priv-\u003emode); + return 0; } Everything works great after this fix! Linux 5.2 booted like a champ. Again, I ported Icenowy’s Linux work forward—some of it had been merged; some of it needed massaging to apply. Normal Linux kernel development stuff. There were a couple typos that I fixed to get USB working. Building the flash image The board has 8MB of flash. This must include the bootloader, the kernel, the root filesystem, and the small persistent partition. I decided to use UBI to house everything except the bootloader, which has to be positioned at the very front of the flash. Using genimage, I define the physical partitions: image flash.bin { flash {} flashtype = w25q64 partition uboot { image = \"u-boot-sunxi-with-spl.bin\" size = 256K } partition rootubi { image = root.ubi size = 0 } } Then, root.ubi is built from the partitions' images: image root.ubi { ubi {} partition kernel { image = \"zImage\" read-only = true } partition dtb { image = \"businesscard.dtb\" read-only = true } partition root { image = \"rootfs.squashfs\" read-only = true } partition flashdrive { image = flashdrive.img read-only = true } partition persist { image = persist.ubifs } } During build, genimage uses this definition to automatically compile a binary ready to flash to the card. Flashing a card Once I’m ready to program a newly made card, I simply plug it into my laptop. The processor can’t find anything to boot (the flash is blank), so it runs its built-in “FEL mode,” which lets me use a tool called sunxi-fel to send the generated image over USB: output/host/bin/sunxi-fel -p spiflash-write 0 output/images/flash.bin Flashing eight measly megabytes takes the better part of two minutes, because NOR flash has an amazingly slow write speed of around 100KB/s. Finishing touches Getting everything buttoned up is the hardest part of any project, in my opinion. I’ve been working on these blog posts, and cleaning up my Buildroot work, for the past month or so in my spare time. I hope to ultimately upstream all the software changes, and I’ve open-sourced everything for the benefit of the community. Soon I hope to put together a “resource page” for the F1C100s with links to everything you need to get going with it. In the meantime, you can go get everything from the Resources section of my main write-up. I’ll also drop another plug for my ongoing Mastering Embedded Linux series. I’m walking through how to build hardware and software from scratch for tiny, cheap Linux systems much like my business card. I hope you have enjoyed this write-up. Feel free to leave comments or drop me a line!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cdiv\u003e\n\u003cp\u003e\n\u003clabel for=\"tocToggle\"\u003eTable of Contents\u003c/label\u003e\u003c/p\u003e\u003cnav id=\"TableOfContents\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#designing-the-computer\"\u003eDesigning the computer\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#picking-a-processor\"\u003ePicking a processor\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#finding-resources-for-the-f1c100s\"\u003eFinding resources for the F1C100s\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#everything-else\"\u003eEverything else\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#designing-the-physical-card\"\u003eDesigning the physical card\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#sizing\"\u003eSizing\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#graphic-design\"\u003eGraphic design\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#usb\"\u003eUSB\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#hand-assembly\"\u003eHand-assembly\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#software\"\u003eSoftware\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#porting-u-boot-and-linux\"\u003ePorting U-Boot and Linux\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#building-the-flash-image\"\u003eBuilding the flash image\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#flashing-a-card\"\u003eFlashing a card\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#finishing-touches\"\u003eFinishing touches\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/nav\u003e\n\u003c/div\u003e\n\u003cp\u003eI recently built a business card that runs Linux.\nThis is a detailed design log, plus a few random notes, from the build.\nIf you want to see the blinkenlights, first you should go \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/\"\u003eread my other blog post\u003c/a\u003e detailing the finished product.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/businesscard-top.jpg\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/businesscard-top_huad90566bef925e8b01048d4355f78bd6_6751801_1024x1024_fit_q80_box.jpg\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\n\u003c/figure\u003e\n\u003ch2 id=\"designing-the-computer\"\u003eDesigning the computer\u003c/h2\u003e\n\u003cp\u003eFirst and foremost, I would need to choose a Linux-capable processor, because it would be the driving factor in the affordability and feasibility of the final product.\u003c/p\u003e\n\u003ch3 id=\"picking-a-processor\"\u003ePicking a processor\u003c/h3\u003e\n\u003cp\u003eI started by looking for processors that were the magic combination: inexpensive, USB, no BGA footprints, and purchasable \u003cem\u003esomewhere\u003c/em\u003e, even if I had to get it from Taobao.\n(You usually can’t buy these processors from Mouser or the manufacturer.)\nIdeally, there would also be a known-good piece of hardware I could get as a development board.\u003c/p\u003e\n\u003cp\u003eI also really wanted a part that had RAM included in the package.\nThis is fairly rare for microprocessors, in contrast to micro_controllers_ which typically don’t have enough juice to run Linux.\nThis constraint really narrowed down my choices, but I stuck with it because it would make design and assembly a lot easier.\u003c/p\u003e\n\u003cp\u003eMany of the processors in this price class are made by Chinese companies and there’s not a lot of info about them available in English, so finding them takes some digging.\n(If you know of other Chinese-only processors in this category, please let me know about them as I would be excited to learn about them.)\u003c/p\u003e\n\u003cp\u003eMy first attempt was using an STM32F4, which can be persuaded to run Linux if it’s hooked up to external SDRAM, like in this Emcraft Systems system-on-module.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://emcraft.com/products/224\"\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/stm32f4-som.jpg\"/\u003e\u003c/a\u003e\n\u003c/figure\u003e\n\u003cp\u003eUnfortunately the STM32 parts that can be hooked up to SDRAM are BGA, or else they use obscure RAM buses that I can barely find any documentation for, let alone buy parts for.\nThe nail in this coffin is that the cheapest STM32F4 that would work was around $9 for the processor alone.\nThat’s too expensive if I’m going to give away the result.\u003c/p\u003e\n\u003cp\u003eI looked around a lot at the chips used in really cheap routers.\nParts like the AR9331 are ancient MIPS-based designs that continue to be used in bottom-of-the-line routers.\nUnfortunately most of these parts are—you guessed it—BGA, and even the ones that aren’t, still don’t have RAM included.\u003c/p\u003e\n\u003cp\u003eReally what I wanted was a really cheap processor for IoT, dashcams, or tablets.\nI struck gold with Sipeed’s Lichee boards, which are the cheapest Linux development boards I’ve seen anywhere.\u003c/p\u003e\n\u003cp\u003eThe Lichee Zero has an Allwinner V3s, which seemed to tick all the boxes.\nIt’s QFP, has 64MB built-in RAM, and there are even people selling them on eBay.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/lichee-zero.jpg\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/lichee-zero_hucca5cdbffd503e86746693b5554e401e_56551_1024x1024_fit_q80_box.jpg\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\n\u003c/figure\u003e\n\u003cp\u003eThe V3s is very well supported by the \u003ca href=\"https://linux-sunxi.org/Main_Page\"\u003esunxi community\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eUnfortunately the best price I could find was around $4 on Taobao.\nThis wasn’t the end of the world if it was the best I could do, but I kept looking.\u003c/p\u003e\n\u003cp\u003eFinally I found my pigeon: the Lichee Nano uses a very small Allwinner part called the F1C100s.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/lichee-nano.jpg\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/lichee-nano_hub2cc585659300fdfe543be4bf09a4068_98656_1024x1024_fit_q80_box.jpg\" alt=\"Here\u0026amp;rsquo;s the Nano next to an SD card.  Pretty small.\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\u003cfigcaption\u003e\n\u003cp\u003eHere’s the Nano next to an SD card. Pretty small.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThis is an ARM9 design Allwinner apparently makes for dashcams.\nARM9 is ancient technology, but I am not trying to win any performance awards.\nThe part comes in a QFN package with a rather small 0.4mm pitch, but at the end of the day it’s still workable with a steady hand.\nIt has 32MB RAM in the package, which is a veritable bounty for my purposes.\u003c/p\u003e\n\u003cp\u003eIt is \u003cem\u003eastoundingly\u003c/em\u003e cheap for a Linux-capable processor: In single quantities, I found it at $1.20 or so on Taobao, and recently I’ve seen listings for $0.90 apiece.\nI bought a big bag of them (top left).\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/stuff-from-china.jpg\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/stuff-from-china_hu4df3fa4bbb610217074910c9a3bf1ed1_1030672_1024x1024_fit_q80_box.jpg\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\n\u003c/figure\u003e\n\u003cp\u003e(It turns out that you can buy nearly any chip under the sun on Taobao.\nI used \u003ca href=\"https://www.superbuy.com/en/?partnercode=wZjaNJ\"\u003eSuperbuy\u003c/a\u003e to batch up my purchases into one box shipped overseas.)\u003c/p\u003e\n\u003ch3 id=\"finding-resources-for-the-f1c100s\"\u003eFinding resources for the F1C100s\u003c/h3\u003e\n\u003cp\u003eThe best resource I found was that Sipeed actually published their schematic for the Lichee Nano.\nThis was absolutely invaluable as there were several places in the datasheet where a pin was \u003cem\u003enamed\u003c/em\u003e, but there was nothing explaining what you should do with the pin.\u003c/p\u003e\n\u003cp\u003eGoogling around also led me to the reference manual for the F1C600, which is apparently an F1C100s rebadged as Linux-capable.\nSo I had register definitions and a real datasheet.\u003c/p\u003e\n\u003cp\u003eI want to reiterate that I’m doing this as a hack.\nUsing random schematics you find on the internet is not the best way to build a product.\u003c/p\u003e\n\u003cp\u003eAllwinner does \u003cem\u003enot\u003c/em\u003e support this part unless you are a large company and get in touch with them directly.\nThe F1C100s so cheap that it’s not even supported by the sunxi folks, but some work was done in early 2019 getting the part supported the Linux kernel.\nI found a branch on GitHub by Icenowy who added drivers for some of the other peripherals.\u003c/p\u003e\n\u003cp\u003eI also found a port of U-Boot.\u003c/p\u003e\n\u003cp\u003eWith all this, I decided that the software was complete enough that I could write drivers for anything else I needed.\u003c/p\u003e\n\u003ch3 id=\"everything-else\"\u003eEverything else\u003c/h3\u003e\n\u003cp\u003eOnce I had the processor picked and laid out in KiCAD, the rest was reasonably easy.\nI made sure the interfaces were all very similar to the Nano, so that I could get my code working on the Nano and hopefully everything would Just Boot on the business card.\u003c/p\u003e\n\u003cp\u003eI used ordinary NOR flash for storage and added an LED for bling.\u003c/p\u003e\n\u003cp\u003eThe first version had an unpopulated JTAG header on the back in case I got into dire straits; this proved unnecessary and I removed it on the second spin.\u003c/p\u003e\n\u003cp\u003eI also threw in a \u003ca href=\"https://hackaday.com/2019/03/20/introducing-the-shitty-add-on-v1-69bis-standard/\"\u003eShitty Add-on header\u003c/a\u003e, just in case I needed UART on the final card.\nThis was removed on the second spin and replaced with a nice compact \u003ca href=\"https://hackaday.com/2019/06/13/soicbite-a-program-debug-connector-for-an-soic-test-clip/\"\u003eSOICbite\u003c/a\u003e footprint; I have needed neither.\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/soicbite.jpg\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eHere’s the schematic; click to download.\nI hope it helps you if you want to use this part.\nFeel free to contact me if you have questions.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/businesscard.pdf\"\u003e\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/schematic-preview.svg\"/\u003e\u003c/a\u003e\n\u003c/figure\u003e\n\u003ch2 id=\"designing-the-physical-card\"\u003eDesigning the physical card\u003c/h2\u003e\n\u003ch3 id=\"sizing\"\u003eSizing\u003c/h3\u003e\n\u003cp\u003eBoard space was not a problem; the computer easily fits in the bottom corner of a standard-size card.\nA bigger problem was that I wanted the card to be as thin as possible; however, a PCB must be 2.2mm or so thick to make it fit in a USB port.\nI solved this by selecting 1mm PCBs and laser-cutting some 1mm acrylic into appropriately-sized spacers.\nThe final assembly step is to superglue this spacer into place.\u003c/p\u003e\n\u003ch3 id=\"graphic-design\"\u003eGraphic design\u003c/h3\u003e\n\u003cp\u003eDesigning the text of the card was easy enough, but because there’s no way to use custom fonts in KiCAD, I needed to import it as a vector.\nUnfortunately there is not a good solution to putting vector images on any layer except \u003ccode\u003eEdge.Cuts\u003c/code\u003e, and of course I did not want to do that.\nThe best way I found was to export the design from Inkscape as a super-high-resolution 4000dpi PNG file, then trace it as a footprint in KiCAD using \u003ccode\u003ebitmap2component\u003c/code\u003e.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/footprint.png\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/footprint_huad2273c4ac47fa0e0b8df89db389aefb_186627_1024x1024_fit_q80_box_3.png\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\n\u003c/figure\u003e\n\u003cp\u003eAlthough tracing a bitmap makes my inner typographer cringe a little, in practice the resolution of the footprint far exceeds the board house’s capabilities and it looks great without hand-tracing every letter.\u003c/p\u003e\n\u003cfigure\u003e\u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/footprint-detail.png\"\u003e\n\u003cimg src=\"https://www.thirtythreeforty.net/posts/2019/12/designing-my-linux-business-card/footprint-detail_hu5f13be528dd0ad22be3afa2ec6a097e8_186088_1024x1024_fit_q80_box_3.png\" alt=\"Plenty of points here on the curves.\" title=\"(click for large version)\"/\u003e \u003c/a\u003e\u003cfigcaption\u003e\n\u003cp\u003ePlenty of points here on the curves.\u003c/p\u003e\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003ch3 id=\"usb\"\u003eUSB\u003c/h3\u003e\n\u003cp\u003eRouting USB was tricky on this board because the traces are fairly long.\nAlthough I’m just using full speed USB, which is pretty forgiving, I still did my best to impedance-control these traces.\nThe USB traces are comically large because the two-layer board makes getting decent capacitance difficult.\nThank goodness it’s only 1mm thick (a standard 1.6mm board would make the traces even fatter).\u003c/p\u003e\n\u003ch3 id=\"hand-assembly\"\u003eHand-assembly\u003c/h3\u003e\n\u003cp\u003eI’m laser-cutting my own stencil.\nThe 0.2mm apertures for the processor pins are at the hairy edge of what the machine is capable of.\nI ended up cutting the pins in two passes, skipping every other one, to prevent them from all melting together as the laser cut them one after the other.\u003c/p\u003e\n\u003cp\u003eIf I ever need to go any smaller, I’ll definitely just order a stencil from OSH Stencils.\u003c/p\u003e\n\u003ch2 id=\"software\"\u003eSoftware\u003c/h2\u003e\n\u003ch3 id=\"porting-u-boot-and-linux\"\u003ePorting U-Boot and Linux\u003c/h3\u003e\n\u003cp\u003eThe first step of porting Linux to any board is getting U-Boot up and running.\u003c/p\u003e\n\u003cp\u003eSomeone on GitHub named Icenowy had done some work getting an older U-Boot version running on the part; it was in rough shape but it would boot, which I was very glad about.\nI rebased this onto v2019.04 and added support in a \u003ca href=\"https://github.com/thirtythreeforty/u-boot/commits/f1c100s-v2019.04\"\u003ecouple drivers\u003c/a\u003e for various other mostly-uninteresting subsystems like the pin controller and clock.\u003c/p\u003e\n\u003cp\u003eDue to a bug, about 70% of my overall effort on the software was spent getting U-Boot to talk to the flash.\nU-Boot has a driver for the SPI peripheral on this part, but it didn’t work.\nThe symptom was that the SPI peripheral could detect the flash chip, but always read garbage from it.\nIt turned out that U-Boot likes to reset the SPI peripheral when it’s done with it.\nThis apparently hasn’t caused any problems for other Allwinner parts.\nHowever, on the F1C100s, resetting the peripheral unsurprisingly erases its configuration registers, especially those for setting speed.\nOnce I figured this out, it was a \u003ca href=\"https://github.com/thirtythreeforty/u-boot/commit/869a7c04f23fe9e10c26b7f1af9774ea813ea49a\"\u003equick fix\u003c/a\u003e to reconfigure the registers when needed:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"diff\"\u003eFrom 869a7c04f23fe9e10c26b7f1af9774ea813ea49a Mon Sep 17 00:00:00 2001\nFrom: George Hilliard \u0026lt;thirtythreeforty@gmail.com\u0026gt;\nDate: Wed, 19 Jun 2019 22:37:30 -0500\nSubject: [PATCH] sunxi-spi: restore bus speed and mode after reset\n\nThe sunxi SPI peripheral driver resets the device completely (disabling\nclocks and power) when the bus is released and turns it back on when\nclaiming.  On the F1C100s (and maybe others), the peripheral resets back\nto default register settings, losing speed and mode settings.\n\nRestore these settings when resetting the peripheral.\n\nSigned-off-by: George Hilliard \u0026lt;thirtythreeforty@gmail.com\u0026gt;\nCc: Jagan Teki \u0026lt;jteki@openedev.com\u0026gt;\n\u003cspan\u003e---\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e drivers/spi/spi-sunxi.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\n\u003cspan\u003ediff --git a/drivers/spi/spi-sunxi.c b/drivers/spi/spi-sunxi.c\n\u003c/span\u003e\u003cspan\u003eindex dbfeac77eec..2d02289d04d 100644\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e--- a/drivers/spi/spi-sunxi.c\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e+++ b/drivers/spi/spi-sunxi.c\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e@@ -35,6 +35,10 @@\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\n DECLARE_GLOBAL_DATA_PTR;\n\n\u003cspan\u003e+/* Forward declarations of some reused functions */\n\u003c/span\u003e\u003cspan\u003e+static int sun4i_spi_set_speed(struct udevice *dev, uint speed);\n\u003c/span\u003e\u003cspan\u003e+static int sun4i_spi_set_mode(struct udevice *dev, uint mode);\n\u003c/span\u003e\u003cspan\u003e+\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e /* sun4i spi registers */\n #define SUN4I_RXDATA_REG\t\t0x00\n #define SUN4I_TXDATA_REG\t\t0x04\n\u003cspan\u003e@@ -300,7 +304,8 @@ static inline int sun4i_spi_set_clock(struct udevice *dev, bool enable)\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\n static int sun4i_spi_claim_bus(struct udevice *dev)\n {\n\u003cspan\u003e-\tstruct sun4i_spi_priv *priv = dev_get_priv(dev-\u0026gt;parent);\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e+\tstruct udevice *bus = dev-\u0026gt;parent;\n\u003c/span\u003e\u003cspan\u003e+\tstruct sun4i_spi_priv *priv = dev_get_priv(bus);\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \tint ret;\n\n \tret = sun4i_spi_set_clock(dev-\u0026gt;parent, true);\n\u003cspan\u003e@@ -317,6 +322,9 @@ static int sun4i_spi_claim_bus(struct udevice *dev)\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \tsetbits_le32(SPI_REG(priv, SPI_TCR), SPI_BIT(priv, SPI_TCR_CS_MANUAL) |\n \t\t     SPI_BIT(priv, SPI_TCR_CS_ACTIVE_LOW));\n\n\u003cspan\u003e+\tsun4i_spi_set_speed(bus, priv-\u0026gt;freq);\n\u003c/span\u003e\u003cspan\u003e+\tsun4i_spi_set_mode(bus, priv-\u0026gt;mode);\n\u003c/span\u003e\u003cspan\u003e+\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \treturn 0;\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eEverything works great after this fix!\u003c/p\u003e\n\u003cp\u003eLinux 5.2 booted like a champ.\nAgain, I ported Icenowy’s Linux work forward—some of it had been merged; some of it needed massaging to apply.\nNormal Linux kernel development stuff.\nThere were a couple typos that I fixed to get USB working.\u003c/p\u003e\n\u003ch3 id=\"building-the-flash-image\"\u003eBuilding the flash image\u003c/h3\u003e\n\u003cp\u003eThe board has 8MB of flash.\nThis must include the bootloader, the kernel, the root filesystem, and the small persistent partition.\nI decided to use UBI to house everything except the bootloader, which has to be positioned at the very front of the flash.\u003c/p\u003e\n\u003cp\u003eUsing genimage, I define the physical partitions:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"golang\"\u003eimage flash.bin {\n\tflash {}\n\tflashtype = w25q64\n\tpartition uboot {\n\t\timage = \u003cspan\u003e\u0026#34;u-boot-sunxi-with-spl.bin\u0026#34;\u003c/span\u003e\n\t\tsize = \u003cspan\u003e256\u003c/span\u003eK\n\t}\n\tpartition rootubi {\n\t\timage = root.ubi\n\t\tsize = \u003cspan\u003e0\u003c/span\u003e\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThen, \u003ccode\u003eroot.ubi\u003c/code\u003e is built from the partitions\u0026#39; images:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"golang\"\u003eimage root.ubi {\n\tubi {}\n\tpartition kernel {\n\t\timage = \u003cspan\u003e\u0026#34;zImage\u0026#34;\u003c/span\u003e\n\t\tread\u003cspan\u003e-\u003c/span\u003eonly = \u003cspan\u003etrue\u003c/span\u003e\n\t}\n\tpartition dtb {\n\t\timage = \u003cspan\u003e\u0026#34;businesscard.dtb\u0026#34;\u003c/span\u003e\n\t\tread\u003cspan\u003e-\u003c/span\u003eonly = \u003cspan\u003etrue\u003c/span\u003e\n\t}\n\tpartition root {\n\t\timage = \u003cspan\u003e\u0026#34;rootfs.squashfs\u0026#34;\u003c/span\u003e\n\t\tread\u003cspan\u003e-\u003c/span\u003eonly = \u003cspan\u003etrue\u003c/span\u003e\n\t}\n\tpartition flashdrive {\n\t\timage = flashdrive.img\n\t\tread\u003cspan\u003e-\u003c/span\u003eonly = \u003cspan\u003etrue\u003c/span\u003e\n\t}\n\tpartition persist {\n\t\timage = persist.ubifs\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDuring build, genimage uses this definition to automatically compile a binary ready to flash to the card.\u003c/p\u003e\n\u003ch3 id=\"flashing-a-card\"\u003eFlashing a card\u003c/h3\u003e\n\u003cp\u003eOnce I’m ready to program a newly made card, I simply plug it into my laptop.\nThe processor can’t find anything to boot (the flash is blank), so it runs its built-in “FEL mode,” which lets me use a tool called \u003ccode\u003esunxi-fel\u003c/code\u003e to send the generated image over USB:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eoutput/host/bin/sunxi-fel -p spiflash-write 0 output/images/flash.bin\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFlashing eight measly megabytes takes the better part of two minutes, because NOR flash has an amazingly slow write speed of around 100KB/s.\u003c/p\u003e\n\u003ch2 id=\"finishing-touches\"\u003eFinishing touches\u003c/h2\u003e\n\u003cp\u003eGetting everything buttoned up is the hardest part of any project, in my opinion.\nI’ve been working on these blog posts, and cleaning up my Buildroot work, for the past month or so in my spare time.\nI hope to ultimately upstream all the software changes, and I’ve open-sourced everything for the benefit of the community.\u003c/p\u003e\n\u003cp\u003eSoon I hope to put together a “resource page” for the F1C100s with links to everything you need to get going with it.\nIn the meantime, you can go get everything from the \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/#resources\"\u003eResources section\u003c/a\u003e of my main write-up.\nI’ll also drop another plug for my ongoing \u003ca href=\"https://www.thirtythreeforty.net/posts/2019/08/mastering-embedded-linux-part-1-concepts/\"\u003eMastering Embedded Linux\u003c/a\u003e series.\nI’m walking through how to build hardware and software from scratch for tiny, cheap Linux systems much like my business card.\u003c/p\u003e\n\u003cp\u003eI hope you have enjoyed this write-up.\nFeel free to leave comments or \u003ca href=\"mailto:thirtythreeforty@gmail.com\"\u003edrop me a line\u003c/a\u003e!\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2019-12-23T19:37:00-05:00",
  "modifiedTime": "2019-12-23T19:37:00-05:00"
}
