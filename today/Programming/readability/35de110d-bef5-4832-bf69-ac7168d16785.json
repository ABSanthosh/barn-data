{
  "id": "35de110d-bef5-4832-bf69-ac7168d16785",
  "title": "Android Image Loading at SoundCloud",
  "link": "https://developers.soundcloud.com/blog/android-images-at-soundcloud",
  "description": "The SoundCloud Android app recently got a significant makeover: a “new year, new me” type of thing. Our remarkable design team and…",
  "author": "",
  "published": "Thu, 13 Oct 2022 00:00:00 GMT",
  "source": "https://developers.soundcloud.com/blog/blog.rss",
  "categories": null,
  "byline": "",
  "length": 20528,
  "excerpt": "The SoundCloud Android app recently got a significant makeover: a “new year, new me” type of thing. Our remarkable design team and outstanding engineers worked together to revamp the way we display all kinds of images in the app, and I’m about to take you behind the scenes on this “glow-up” journey.",
  "siteName": "",
  "favicon": "",
  "text": "The SoundCloud Android app recently got a significant makeover: a “new year, new me” type of thing. Our remarkable design team and outstanding engineers worked together to revamp the way we display all kinds of images in the app, and I’m about to take you behind the scenes on this “glow-up” journey. A Peek at the UI First, here’s a look at the user interface (UI). We went from the old design: To the new design: Below are some images you’ll come across while using the redesigned SoundCloud app. Simple Track This is a basic single image for tracks. Playlist This image is for a playlist. It has a background stack with colors picked from the playlist artwork. Special Playlist This image is for special playlists. It includes additional indicators, a blurred image stack, and a circular artist image. These images look great, but as you might guess, they’re all backed by code, and the implementation wasn’t exactly straightforward. “With great design comes great code!” —Someone’s uncle From Design to Code Implementation Want to know how we did it? This section will cover how we went from the design ideas to implementing them in code. First off, all images now have rounded corners. This is thanks to ShapeableImageView, which supports rounded images. Playlists show the main artwork and two images behind the main artwork, and each image has rounded corners. We accomplished this by creating an XML file containing a ConstraintLayout with three children of ShapeableImageView: \u003cConstraintLayout\u003e \u003cShapeableImageView id=\"stack2\" /\u003e \u003cShapeableImageView id=\"stack1\" /\u003e \u003cShapeableImageView id=\"playlistArtwork\" /\u003e \u003cConstraintLayout/\u003e We have some special types of playlists that can have additional overlays/blur or more images on top of the main artwork. For special playlists (see the Special Playlist section), we added another ShapeableImageView as an overlay to the ConstraintLayout with visibility=\"gone\". If a playlist is “special,” the ShapeableImageViews visibility is changed to visible: \u003cConstraintLayout\u003e \u003cShapeableImageView id=\"stack2\" /\u003e \u003cShapeableImageView id=\"stack1\" /\u003e \u003cShapeableImageView id=\"playlistArtwork\" /\u003e \u003cShapeableImageView id=\"playlistTypeIndicator\" visibility=\"gone\" /\u003e \u003cConstraintLayout/\u003e For playlists, the primary colors of the main artwork determine the image stack colors. We used the [Android palette library][] to make this happen. It has a simple API that picks the primary colors from images, which we can use as background colors for the stack. Additionally, images fade in when loaded. We use the PicassoDrawable, which crossfades the newly loaded bitmap with whatever image was previously loaded. To highlight the fade-in animation, the duration of the animation was set to 200 milliseconds. Placeholders are displayed while the actual images are downloading, and com.squareup.picasso.Target provides a callback function: fun onPrepareLoad(placeHolderDrawable: Drawable?) onPrepareLoad enables us to add a gray color to the stacks and a default image while waiting for the main artwork to load. Loading and Displaying Images with Picasso We use Picasso to load images. Picasso also offers a simple API, picasso.load(url).into(target), to download and cache images. The image cache is used throughout the whole app so that an image in the cache will never download twice. Picasso can download or load an image from the local disk (cache). Picasso is extendable for custom image loading operations. For example, if image loading fails, we want to display an error image. There are a few different ways to do that with Picasso. At SoundCloud, we have a custom ImageView that implements Picasso.Target. Every time we load an image into the ImageView, we animate (fade in) the new image bitmap: class ArtworkImageView : Target { override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) { animateBitmap(bitmap) } override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) { animateFailureBitmap() } override fun onPrepareLoad(placeHolderDrawable: Drawable?) { showPlaceholderBitmap() } } After implementing the redesign, the images looked fantastic, the design team approved, and the product managers were happy. But it came with a catch: Images were loading slower than before. The slow performance was visible while scrolling, and images flickered when moving between screens. The redesign had impacted image performance. The following section will cover how we fixed the image loading performance. Slow Image Performance Investigation and Fixes We started debugging and discovered not a single culprit, but rather a bunch of issues that were contributing to the performance problem. We also investigated the app’s GPU overdrawing, which I’ll elaborate on later. The next sections outline the specific issues we encountered and how we fixed them. Issue #1 — Palette LruCache To generate the image stack colors, we use the Android palette library. To save time on regenerating the palette, we used LruCache\u003cBitmap, Palette\u003e to store the bitmap and palette key-value pair for faster on-demand loading. So every time we loaded an image, the code below executed: if (isInCache(bitmap)) { return getTheCachedPaletteFor(bitmap) } else { val palette = generatePaletteFrom(bitmap) storePalette(bitmap, palette) return palette } Using a Bitmap as a key, we retrieved the palette from LruCache. However, using bitmaps as keys to the cache caused a performance issue. Given that bitmaps are large objects, it’s best to never use them as keys to a Cache, Map, or any other data structure. This is because comparing bitmaps is time-consuming. Solution #1 The fix ended up being simple. We switched from LruCache\u003cBitmap, Palette\u003e to LruCache\u003cString, Palette\u003e. The String is the URL of the loaded bitmap, and comparing strings is quick and consumes less memory. The code is below: if (isInCache(url)) { return getTheCachedPalette(url) } else { val palette = generatePaletteFrom(bitmap) storePalette(url, palette) return palette } Issue #2 — Palette Color Generation To generate the palette colors from bitmaps, we used the code below: Palette.from(bitmap).generate() The code is simple: It provides the bitmap and generates the primary colors for that bitmap. But palette generation takes time. It works by checking each pixel in a bitmap to find the most used colors. For example, if an image contains a lot of red, then the palette will contain the red color. The bitmaps we use to generate the palette have a size of 500×500, which is large and slows the palette generation. Solution #2 A faster way to generate the palette is to first scale down the bitmap and then generate the palette. The palette has a function, resizeBitmapArea(size), that scales the bitmap down, so we went from 500×500 to 15×15. We also use maximumColorCount(colors) to find fewer colors, as in our implementation, we only needed the dominant color. By default, the palette finds 16 different colors. The code below generates palettes faster, but the tradeoff is primary color accuracy, which is ultimately fine; shades of red are still red: Palette.from(bitmap) .resizeBitmapArea(225) // Scales down the bitmap area to a 15×15. .maximumColorCount(6) .generate() Issue #3 — Animating from the Placeholder to the Real Image When loading images the first time, we displayed a placeholder and then displayed the actual downloaded image with a fade-in animation. Once the image was cached and the user scrolled through the RecyclerView, we still saw the fading in and out from the placeholder to the actual image, even though the image was cached. Solution #3 To address this, we dropped animations for cached images. Luckily, Picasso offers the from enum, Picasso.LoadedFrom, together with the loaded bitmap. Picasso.LoadedFrom tells us where the bitmap was loaded from: enum LoadedFrom { MEMORY DISK NETWORK } If the image was loaded from NETWORK, we animate the new image; otherwise, we display the image without an animation: ArtworkImageView : TrackArtwork { override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) { if(from == Picasso.LoadedFrom.NETWORK) { animateBitmap(bitmap) // Animate from placeholder to real image. } else { showBitmapWithoutAnimation(bitmap) // Directly display image from cache. } } } Another minor tweak was that we made the fade-in animation faster — from 200 ms to 60 ms. 200 ms felt like we were showing off our fancy animations rather than benefitting the user by displaying the image quickly. Issue #4 — Image Preloading in RecyclerView Many screens in the SoundCloud app consist of lists of tracks or playlists, which means the user will scroll through the list to play a track. While the user scrolls, the new images are loaded and cached. Downloading new images takes time, so we thought it’d make sense to download and cache a few of the upcoming images in a list before the images of tracks/playlists are even displayed on the screen. Solution #4 We preloaded the three subsequent images in RecyclerViews. If you use Glide, you’ll know it supports preloading images out of the box. Since we use Picasso for image loading, we implemented image preloading based on Glide’s example. When preloading items, we needed to consider the following: How many not-yet visible items do we want to preload? In other words, how many items did we want to preload? These items are always not visible until the user scrolls down to them. How many items are left to preload? We needed to check if we were about to reach the end of the RecyclerView; for example, if we were always preloading the next five items and reaching the last bottom four items, we needed to stop preloading toward the end of the RecyclerView. Make sure we don’t preload items twice. Only load items that aren’t yet visible on the screen. If we hardcode the preload size to 5 items but show 10 items, we end up preloading items that were already loaded. Below is the ItemPreLoader class, which handles all the points mentioned above: const val DEFAULT_PRELOAD_ITEMS_SIZE = 3 /*** * The `ItemPreLoader` calculates which items should be preloaded. * * Items can only be preloaded when the conditions below are met: * 1. `preloadEnabled` is `true`, meaning that `PreloadScrollListener` has enabled preloading. * 2. `lastVisiblePosition` is larger than `0`. The first few items are already preloaded by the adapter, and if we try to load more items immediately, it could overwhelm the app's memory. * 3. `lastVisiblePosition` is smaller than `items.size`. We shouldn’t continue preloading elements outside the bounds of the list (`IndexOutOfBoundsException`). * 4. `startIndex` is larger than `lastPreloadedPosition`. Already preloaded items must not be loaded again. * 5. The list isn’t exhausted; there are more items. Same as 2. * 6. The last visible item’s `ViewType` must be the same as the `ViewType` of the item we’re currently preloading. Otherwise, we'll cause a `ClassCastException` if the `ViewTypes` are different. `getItemViewType(lastVisiblePosition) == getItemViewType(realIndex)` ensures we don't cause a `ClassCastException`. * * If the above conditions are met, `ItemPreLoader` slices the items list from the `adapterPosition`(`startIndex`) to the `lastIndex`(`startIndex + preloadItemsSize`) and calls `viewHolder.preloadNextItem` on those items. */ class ItemPreLoader( val preloadItemsSize: Int = DEFAULT_PRELOAD_ITEMS_SIZE ) { var preloadEnabled = false internal var adapterPosition = 0 private var lastPreloadedPosition = -1 fun \u003cT\u003e preLoadItems( viewHolder: ScViewHolder\u003cT\u003e, items: List\u003cT\u003e, position: Int, getItemViewType: (Int) -\u003e Int ) { val lastVisiblePosition = max(adapterPosition, position) /* - `preloadEnabled` must be `true` to continue preloading items. - `lastVisiblePosition` can be set to `-1` if there are no items in the adapter. In this case, we don't want to preload items. - `lastVisiblePosition` can be set to `0`. We don't want to start preloading immediately when creating an adapter, and the adapter already loads the next item(s) to be shown. */ if (!preloadEnabled || lastVisiblePosition \u003c= 0) { return } val startIndex = if (preloadItemsSize \u003c lastVisiblePosition) { lastVisiblePosition + 1 } else { preloadItemsSize } val lastPreloadIndex = (startIndex + preloadItemsSize - 1).coerceAtMost(items.lastIndex) if (startIndex in lastPreloadedPosition until lastPreloadIndex) { lastPreloadedPosition = lastPreloadIndex var realIndex = startIndex items.slice(startIndex..lastPreloadIndex).forEach { if (getItemViewType(lastVisiblePosition) == getItemViewType(realIndex)) { viewHolder.preloadNextItem(it) } realIndex++ } } } } We also needed to set a custom OnScrollListener to the RecyclerView. The OnScrollListener: Enables item preloading when the user scrolls down. Disables item preloading when the list is idle or the user scrolls up. Finds the last visible item position in RecyclerView. class PreloadScrollListener(val itemPreLoader: ItemPreLoader) : RecyclerView.OnScrollListener() { /** * The scroll state can only have the following three values: * 1. `SCROLL_STATE_IDLE` is when the user isn't scrolling, and it enables image preloading. * 2. `SCROLL_STATE_DRAGGING` is when the user is scrolling with their finger on the screen, and it enables image preloading. * 3. `SCROLL_STATE_SETTLING` is when the user fling scrolls, and it disables image preloading. */ override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) { super.onScrollStateChanged(recyclerView, newState) when (newState) { SCROLL_STATE_IDLE, SCROLL_STATE_DRAGGING -\u003e itemPreLoader.preloadEnabled = true SCROLL_STATE_SETTLING -\u003e itemPreLoader.preloadEnabled = false } } /*** * There's a special case where the user scrolls upward. In this case, image preloading is disabled. * * The `PreloadScrollListener` also sets the `ItemPreLoader.adapterPosition`. * The `LastVisibleAdapterPositionFinder` class grabs the `LayoutManager` from the `RecyclerView`, and from the `LayoutManager`, we find the last visible item position. */ override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) { super.onScrolled(recyclerView, dx, dy) if (dy \u003c 0) { itemPreLoader.preloadEnabled = false } val position = findLastVisiblePosition(recyclerView) itemPreLoader.adapterPosition = position } } Finally, here’s the code to find the last visible item in the RecyclerView: fun findLastVisiblePosition(recyclerView: RecyclerView): Int { return when (recyclerView.layoutManager) { is LinearLayoutManager -\u003e getLastVisiblePositionFrom(recyclerView.layoutManager as LinearLayoutManager) else -\u003e -1 } } fun getLastVisiblePositionFrom(manager: LinearLayoutManager): Int { return manager.findLastVisibleItemPosition() } GPU Overdrawing GPU overdrawing is when an app draws the same pixel more than once within the same frame. As a result, GPU overdraw visualization shows where an app might be doing more rendering work than necessary. We caused a high overdraw severity because we were rendering/drawing three ImageViews on top of each other in the stacked ImageViews when displaying playlists. This is something we shouldn’t do. The Issue We draw three full images on top of each other, even though only 10 percent of the stacked images are visible. With stacks, 90 percent of an image isn’t visible, but it’s still drawn, which affects the frame rate. To fix overdrawing, we would’ve needed to add a lot of custom complex drawing logic, which would take time to build, debug, and maintain. So the tradeoff here was unlikely to be worth the upfront effort and maintenance difficulties. We did build the custom drawing logic, but it was too complex to maintain, and there was no performance benefit. The main ideas were: Flatten the stacked ImageViews into one ImageView. Draw only the visible areas of bitmaps. Faster image drawing. The code below draws three bitmaps on a custom view. Only the bitmaps’ visible areas are drawn, so as to avoid GPU overdrawing. Since only a subset (10 percent) of the bitmaps is drawn, drawing is now faster: StackedImageView: View() { val visibleBitmapOffset = 40f override fun draw(canvas: Canvas) { // Show the bitmap area calculations. val bounds = RectF(0, 0, width, height) val paint = Paint() paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_ATOP) canvas.drawBitmap(topStackBitmap, null, topArea(bounds), paint) canvas.drawBitmap(middleStackBitmap, null, middleArea(bounds), paint) canvas.drawBitmap(bottomStackBitmap, null, bottomArea(bounds), paint) } } private fun topArea(bounds: RectF) = bounds.copy().apply { right -= visibleBitmapOffset * 2 bottom -= visibleBitmapOffset * 2 } private fun middleArea(bounds: RectF) = bounds.copy().apply { top += visibleBitmapOffset right -= visibleBitmapOffset left += visibleBitmapOffset bottom -= visibleBitmapOffset } private fun bottomArea(bounds: RectF) = bounds.copy().apply { top += visibleBitmapOffset * 2 left += visibleBitmapOffset * 2 } The code above calculates the bounds (area) of each bitmap. The bounds are the area into which the bitmap will be drawn. The visibleBitmapOffset defines how many pixels the bounds will be moved/offset. In the top stack bitmap area, the bitmap is displaced by visibleBitmapOffset*2 pixels toward the top-left corner. In the middle stack bitmap area, all sides are moved by visibleBitmapOffset/2 pixels, placing the bitmap in the middle of the view. In the bottom stack bitmap area, the bitmap is displaced by visibleBitmapOffset*2 pixels toward the bottom-right corner. To draw only the visible bitmap areas and avoid overdrawing, we use paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_ATOP). PorterDuff.Mode.DST_ATOP draws only the outside area of the following image. So if there is already something drawn in the view, then DST_ATOP only draws the outer part of what we’re drawing now. Since we already drew the top bitmap, only the middle bitmap’s outer part is drawn. It’s the same with the bottom bitmap; only the outer section is drawn. The section above outlines the basics of how to draw three images without overdrawing. Complications arise when the images have round corners; the stacks can be solid colors; and there can be more images on top of the stack, fading in each stack of bitmaps and drawing rounded borders. Implementing all of that led to a great deal of drawing code, which was hard to maintain. Thus, it wasn’t included in the project. If you want to learn more about computer graphics drawing, Fundamentals of Computer Graphics is a great book. Conclusion Redesigning an entire app takes a lot of time — from product managers coming up with the product specifications, whiteboarding sessions, and creating wireframes, to UI and UX designers drawing the final design. Finally, the engineers have to implement the new design and rewrite UI components, and usually, all this work is done under pressure with a set deadline. We all like to go fast and get a redesign done, but as a result, we end up rushing and forgetting the important stuff like properly testing the new UI to see if it works, and checking to ensure the performance and frame rate are acceptable. Testing and measuring performance is the responsibility of the engineers, so it’s of the utmost importance to always test and measure the performance of your new UI. With proper performance measuring and testing, we were able to identify and fix image UI issues we encountered. And although it took longer, SoundCloud ended up with a more polished product.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eThe SoundCloud Android app recently got a significant makeover: a “new year, new me” type of thing. Our remarkable design team and outstanding engineers worked together to revamp the way we display all kinds of images in the app, and I’m about to take you behind the scenes on this “glow-up” journey.\u003c/p\u003e\n\u003ch2\u003eA Peek at the UI\u003c/h2\u003e\n\u003cp\u003eFirst, here’s a look at the user interface (UI).\u003c/p\u003e\n\u003cp\u003eWe went from the old design:\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/e9c61/old-design.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Old Design\" title=\"Old Design\" src=\"https://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/8ff1e/old-design.png\" srcset=\"https://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/9ec3c/old-design.png 200w,\nhttps://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/c7805/old-design.png 400w,\nhttps://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/8ff1e/old-design.png 800w,\nhttps://developers.soundcloud.com/blog/static/c18857cf1ce1b71115fc5dbf032f1ef7/e9c61/old-design.png 1080w\" sizes=\"(max-width: 800px) 100vw, 800px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eTo the new design:\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/e9c61/new-design-.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"New Design\" title=\"New Design\" src=\"https://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/8ff1e/new-design-.png\" srcset=\"https://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/9ec3c/new-design-.png 200w,\nhttps://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/c7805/new-design-.png 400w,\nhttps://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/8ff1e/new-design-.png 800w,\nhttps://developers.soundcloud.com/blog/static/de1546939637c82b311dd4c89d0df25d/e9c61/new-design-.png 1080w\" sizes=\"(max-width: 800px) 100vw, 800px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eBelow are some images you’ll come across while using the redesigned SoundCloud app.\u003c/p\u003e\n\u003ch3\u003eSimple Track\u003c/h3\u003e\n\u003cp\u003eThis is a basic single image for tracks.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/ebd7bf40581eec28611b0c44fb23f157/aff45/track.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Track artwork\" title=\"Track artwork\" src=\"https://developers.soundcloud.com/blog/static/ebd7bf40581eec28611b0c44fb23f157/aff45/track.png\" srcset=\"https://developers.soundcloud.com/blog/static/ebd7bf40581eec28611b0c44fb23f157/9ec3c/track.png 200w,\nhttps://developers.soundcloud.com/blog/static/ebd7bf40581eec28611b0c44fb23f157/c7805/track.png 400w,\nhttps://developers.soundcloud.com/blog/static/ebd7bf40581eec28611b0c44fb23f157/aff45/track.png 475w\" sizes=\"(max-width: 475px) 100vw, 475px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003ePlaylist\u003c/h3\u003e\n\u003cp\u003eThis image is for a playlist. It has a background stack with colors picked from the playlist artwork.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/6d1b13fe2ce4f70b4ddc1de2b1b1db60/bad17/playlist.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Playlist artwork\" title=\"Playlist artwork\" src=\"https://developers.soundcloud.com/blog/static/6d1b13fe2ce4f70b4ddc1de2b1b1db60/bad17/playlist.png\" srcset=\"https://developers.soundcloud.com/blog/static/6d1b13fe2ce4f70b4ddc1de2b1b1db60/9ec3c/playlist.png 200w,\nhttps://developers.soundcloud.com/blog/static/6d1b13fe2ce4f70b4ddc1de2b1b1db60/c7805/playlist.png 400w,\nhttps://developers.soundcloud.com/blog/static/6d1b13fe2ce4f70b4ddc1de2b1b1db60/bad17/playlist.png 477w\" sizes=\"(max-width: 477px) 100vw, 477px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003eSpecial Playlist\u003c/h3\u003e\n\u003cp\u003eThis image is for special playlists. It includes additional indicators, a blurred image stack, and a circular artist image.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/b99d84ea7234658fde470ebcfe59948c/aff45/artist-station.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Special Playlist Artwork\" title=\"Special Playlist Artwork\" src=\"https://developers.soundcloud.com/blog/static/b99d84ea7234658fde470ebcfe59948c/aff45/artist-station.png\" srcset=\"https://developers.soundcloud.com/blog/static/b99d84ea7234658fde470ebcfe59948c/9ec3c/artist-station.png 200w,\nhttps://developers.soundcloud.com/blog/static/b99d84ea7234658fde470ebcfe59948c/c7805/artist-station.png 400w,\nhttps://developers.soundcloud.com/blog/static/b99d84ea7234658fde470ebcfe59948c/aff45/artist-station.png 475w\" sizes=\"(max-width: 475px) 100vw, 475px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eThese images look great, but as you might guess, they’re all backed by code, and the implementation wasn’t exactly straightforward.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e“With great design comes great code!”\u003c/em\u003e —Someone’s uncle\u003c/p\u003e\n\u003ch2\u003eFrom Design to Code Implementation\u003c/h2\u003e\n\u003cp\u003eWant to know how we did it? This section will cover how we went from the design ideas to implementing them in code.\u003c/p\u003e\n\u003cp\u003eFirst off, all images now have rounded corners. This is thanks to \u003ccode\u003eShapeableImageView\u003c/code\u003e, which supports rounded images.\u003c/p\u003e\n\u003cp\u003ePlaylists show the main artwork and two images behind the main artwork, and each image has rounded corners. We accomplished this by creating an XML file containing a \u003ccode\u003eConstraintLayout\u003c/code\u003e with three children of \u003ccode\u003eShapeableImageView\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;ConstraintLayout\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;stack2\u0026#34; /\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;stack1\u0026#34; /\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;playlistArtwork\u0026#34; /\u0026gt;\n\u0026lt;ConstraintLayout/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe have some special types of playlists that can have additional overlays/blur or more images on top of the main artwork. For special playlists (see the \u003ca href=\"#special-playlist\"\u003eSpecial Playlist\u003c/a\u003e section), we added another \u003ccode\u003eShapeableImageView\u003c/code\u003e as an overlay to the \u003ccode\u003eConstraintLayout\u003c/code\u003e with \u003ccode\u003evisibility=\u0026#34;gone\u0026#34;\u003c/code\u003e. If a playlist is “special,” the \u003ccode\u003eShapeableImageView\u003c/code\u003es \u003ccode\u003evisibility\u003c/code\u003e is changed to \u003ccode\u003evisible\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;ConstraintLayout\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;stack2\u0026#34; /\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;stack1\u0026#34; /\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;playlistArtwork\u0026#34; /\u0026gt;\n    \u0026lt;ShapeableImageView id=\u0026#34;playlistTypeIndicator\u0026#34; visibility=\u0026#34;gone\u0026#34; /\u0026gt;\n\u0026lt;ConstraintLayout/\u0026gt;\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFor playlists, the primary colors of the main artwork determine the image stack colors. We used the [Android palette library][] to make this happen. It has a simple API that picks the primary colors from images, which we can use as background colors for the stack.\u003c/p\u003e\n\u003cp\u003eAdditionally, images fade in when loaded. We use the \u003ca href=\"https://github.com/square/picasso/blob/master/picasso/src/main/java/com/squareup/picasso3/PicassoDrawable.kt\"\u003e\u003ccode\u003ePicassoDrawable\u003c/code\u003e\u003c/a\u003e, which crossfades the newly loaded bitmap with whatever image was previously loaded. To highlight the fade-in animation, the duration of the animation was set to 200 milliseconds.\u003c/p\u003e\n\u003cp\u003ePlaceholders are displayed while the actual images are downloading, and \u003ccode\u003ecom.squareup.picasso.Target\u003c/code\u003e provides a callback function:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efun onPrepareLoad(placeHolderDrawable: Drawable?)\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eonPrepareLoad\u003c/code\u003e enables us to add a gray color to the stacks and a default image while waiting for the main artwork to load.\u003c/p\u003e\n\u003ch3\u003eLoading and Displaying Images with Picasso\u003c/h3\u003e\n\u003cp\u003eWe use \u003ca href=\"https://square.github.io/picasso/\"\u003ePicasso\u003c/a\u003e to load images. Picasso also offers a simple API, \u003ccode\u003epicasso.load(url).into(target)\u003c/code\u003e, to download and cache images.\u003c/p\u003e\n\u003cp\u003eThe image cache is used throughout the whole app so that an image in the cache will never download twice. Picasso can download or load an image from the local disk (cache).\u003c/p\u003e\n\u003cp\u003ePicasso is extendable for custom image loading operations. For example, if image loading fails, we want to display an error image. There are a few different ways to do that with Picasso. At SoundCloud, we have a custom \u003ccode\u003eImageView\u003c/code\u003e that implements \u003ccode\u003ePicasso.Target\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eEvery time we load an image into the \u003ccode\u003eImageView\u003c/code\u003e, we animate (fade in) the new image bitmap:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eclass ArtworkImageView : Target {\n    override fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) {\n        animateBitmap(bitmap)\n    }\n\n    override fun onBitmapFailed(e: Exception, errorDrawable: Drawable?) {\n        animateFailureBitmap()\n    }\n\n    override fun onPrepareLoad(placeHolderDrawable: Drawable?) {\n        showPlaceholderBitmap()\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAfter implementing the redesign, the images looked fantastic, the design team approved, and the product managers were happy. But it came with a catch: Images were loading slower than before. The slow performance was visible while scrolling, and images flickered when moving between screens. The redesign had impacted image performance.\u003c/p\u003e\n\u003cp\u003eThe following section will cover how we fixed the image loading performance.\u003c/p\u003e\n\u003ch2\u003eSlow Image Performance Investigation and Fixes\u003c/h2\u003e\n\u003cp\u003eWe started debugging and discovered not a single culprit, but rather a bunch of issues that were contributing to the performance problem. We also investigated the app’s GPU overdrawing, which I’ll elaborate on later. The next sections outline the specific issues we encountered and how we fixed them.\u003c/p\u003e\n\u003ch3\u003eIssue #1 — Palette LruCache\u003c/h3\u003e\n\u003cp\u003eTo generate the image stack colors, we use the Android palette library. To save time on regenerating the palette, we used \u003ccode\u003eLruCache\u0026lt;Bitmap, Palette\u0026gt;\u003c/code\u003e to store the bitmap and palette key-value pair for faster on-demand loading.\u003c/p\u003e\n\u003cp\u003eSo every time we loaded an image, the code below executed:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eif (isInCache(bitmap)) {\n    return getTheCachedPaletteFor(bitmap)\n} else {\n    val palette = generatePaletteFrom(bitmap)\n    storePalette(bitmap, palette)\n\n    return palette\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eUsing a \u003ccode\u003eBitmap\u003c/code\u003e as a key, we retrieved the palette from \u003ccode\u003eLruCache\u003c/code\u003e. However, using bitmaps as keys to the cache caused a performance issue. Given that bitmaps are large objects, it’s best to never use them as keys to a \u003ccode\u003eCache\u003c/code\u003e, \u003ccode\u003eMap\u003c/code\u003e, or any other data structure. This is because comparing bitmaps is time-consuming.\u003c/p\u003e\n\u003ch3\u003eSolution #1\u003c/h3\u003e\n\u003cp\u003eThe fix ended up being simple. We switched from \u003ccode\u003eLruCache\u0026lt;Bitmap, Palette\u0026gt;\u003c/code\u003e to \u003ccode\u003eLruCache\u0026lt;String, Palette\u0026gt;\u003c/code\u003e. The \u003ccode\u003eString\u003c/code\u003e is the URL of the loaded bitmap, and comparing strings is quick and consumes less memory.\u003c/p\u003e\n\u003cp\u003eThe code is below:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eif (isInCache(url)) {\n    return getTheCachedPalette(url)\n} else {\n    val palette = generatePaletteFrom(bitmap)\n    storePalette(url, palette)\n\n    return palette\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eIssue #2 — Palette Color Generation\u003c/h3\u003e\n\u003cp\u003eTo generate the palette colors from bitmaps, we used the code below:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003ePalette.from(bitmap).generate()\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe code is simple: It provides the bitmap and generates the primary colors for that bitmap. But palette generation takes time. It works by checking each pixel in a bitmap to find the most used colors. For example, if an image contains a lot of red, then the palette will contain the red color.\u003c/p\u003e\n\u003cp\u003eThe bitmaps we use to generate the palette have a size of 500×500, which is large and slows the palette generation.\u003c/p\u003e\n\u003ch3\u003eSolution #2\u003c/h3\u003e\n\u003cp\u003eA faster way to generate the palette is to first scale down the bitmap and then generate the palette.\u003c/p\u003e\n\u003cp\u003eThe palette has a function, \u003ccode\u003eresizeBitmapArea(size)\u003c/code\u003e, that scales the bitmap down, so we went from 500×500 to 15×15. We also use \u003ccode\u003emaximumColorCount(colors)\u003c/code\u003e to find fewer colors, as in our implementation, we only needed the dominant color. By default, the palette finds 16 different colors.\u003c/p\u003e\n\u003cp\u003eThe code below generates palettes faster, but the tradeoff is primary color accuracy, which is ultimately fine; shades of red are still red:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003ePalette.from(bitmap)\n    .resizeBitmapArea(225) // Scales down the bitmap area to a 15×15.\n    .maximumColorCount(6)\n    .generate()\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eIssue #3 — Animating from the Placeholder to the Real Image\u003c/h3\u003e\n\u003cp\u003eWhen loading images the first time, we displayed a placeholder and then displayed the actual downloaded image with a fade-in animation. Once the image was cached and the user scrolled through the \u003ccode\u003eRecyclerView\u003c/code\u003e, we still saw the fading in and out from the placeholder to the actual image, even though the image was cached.\u003c/p\u003e\n\u003ch3\u003eSolution #3\u003c/h3\u003e\n\u003cp\u003eTo address this, we dropped animations for cached images. Luckily, Picasso offers the \u003ccode\u003efrom\u003c/code\u003e enum, \u003ccode\u003ePicasso.LoadedFrom\u003c/code\u003e, together with the loaded bitmap. \u003ccode\u003ePicasso.LoadedFrom\u003c/code\u003e tells us where the bitmap was loaded from:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eenum LoadedFrom {\n    MEMORY\n    DISK\n    NETWORK\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf the image was loaded from \u003ccode\u003eNETWORK\u003c/code\u003e, we animate the new image; otherwise, we display the image without an animation:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eArtworkImageView : TrackArtwork {\n\n\toverride fun onBitmapLoaded(bitmap: Bitmap, from: Picasso.LoadedFrom) {\n            if(from == Picasso.LoadedFrom.NETWORK) {\n                animateBitmap(bitmap) // Animate from placeholder to real image.\n            } else {\n                showBitmapWithoutAnimation(bitmap) // Directly display image from cache.\n            }\n        }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnother minor tweak was that we made the fade-in animation faster — from 200 ms to 60 ms. 200 ms felt like we were showing off our fancy animations rather than benefitting the user by displaying the image quickly.\u003c/p\u003e\n\u003ch3\u003eIssue #4 — Image Preloading in RecyclerView\u003c/h3\u003e\n\u003cp\u003eMany screens in the SoundCloud app consist of lists of tracks or playlists, which means the user will scroll through the list to play a track. While the user scrolls, the new images are loaded and cached. Downloading new images takes time, so we thought it’d make sense to download and cache a few of the upcoming images in a list before the images of tracks/playlists are even displayed on the screen.\u003c/p\u003e\n\u003ch3\u003eSolution #4\u003c/h3\u003e\n\u003cp\u003eWe preloaded the three subsequent images in \u003ccode\u003eRecyclerView\u003c/code\u003es. If you use \u003ca href=\"https://bumptech.github.io/glide/int/recyclerview.html\"\u003eGlide\u003c/a\u003e, you’ll know it supports preloading images out of the box.\u003c/p\u003e\n\u003cp\u003eSince we use Picasso for image loading, we implemented image preloading based on Glide’s example.\u003c/p\u003e\n\u003cp\u003eWhen preloading items, we needed to consider the following:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eHow many not-yet visible items do we want to preload? In other words, how many items did we want to preload? These items are always not visible until the user scrolls down to them.\u003c/li\u003e\n\u003cli\u003eHow many items are left to preload? We needed to check if we were about to reach the end of the \u003ccode\u003eRecyclerView\u003c/code\u003e; for example, if we were always preloading the next five items and reaching the last bottom four items, we needed to stop preloading toward the end of the \u003ccode\u003eRecyclerView\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eMake sure we don’t preload items twice.\u003c/li\u003e\n\u003cli\u003eOnly load items that aren’t yet visible on the screen. If we hardcode the preload size to 5 items but show 10 items, we end up preloading items that were already loaded.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBelow is the \u003ccode\u003eItemPreLoader\u003c/code\u003e class, which handles all the points mentioned above:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003econst val DEFAULT_PRELOAD_ITEMS_SIZE = 3\n\n/***\n * The `ItemPreLoader` calculates which items should be preloaded.\n *\n * Items can only be preloaded when the conditions below are met:\n * 1. `preloadEnabled` is `true`, meaning that `PreloadScrollListener` has enabled preloading.\n * 2. `lastVisiblePosition` is larger than `0`. The first few items are already preloaded by the adapter, and if we try to load more items immediately, it could overwhelm the app\u0026#39;s memory.\n * 3. `lastVisiblePosition` is smaller than `items.size`. We shouldn’t continue preloading elements outside the bounds of the list (`IndexOutOfBoundsException`).\n * 4. `startIndex` is larger than `lastPreloadedPosition`. Already preloaded items must not be loaded again.\n * 5. The list isn’t exhausted; there are more items. Same as 2.\n * 6. The last visible item’s `ViewType` must be the same as the `ViewType` of the item we’re currently preloading. Otherwise, we\u0026#39;ll cause a `ClassCastException` if the `ViewTypes` are different. `getItemViewType(lastVisiblePosition) == getItemViewType(realIndex)` ensures we don\u0026#39;t cause a `ClassCastException`.\n *\n * If the above conditions are met, `ItemPreLoader` slices the items list from the `adapterPosition`(`startIndex`) to the `lastIndex`(`startIndex + preloadItemsSize`) and calls `viewHolder.preloadNextItem` on those items.\n */\nclass ItemPreLoader(\n    val preloadItemsSize: Int = DEFAULT_PRELOAD_ITEMS_SIZE\n) {\n    var preloadEnabled = false\n\n    internal var adapterPosition = 0\n    private var lastPreloadedPosition = -1\n\n    fun \u0026lt;T\u0026gt; preLoadItems(\n        viewHolder: ScViewHolder\u0026lt;T\u0026gt;,\n        items: List\u0026lt;T\u0026gt;,\n        position: Int,\n        getItemViewType: (Int) -\u0026gt; Int\n    ) {\n        val lastVisiblePosition = max(adapterPosition, position)\n\n        /*\n            - `preloadEnabled` must be `true` to continue preloading items.\n            - `lastVisiblePosition` can be set to `-1` if there are no items in the adapter. In this case, we don\u0026#39;t want to preload items.\n            - `lastVisiblePosition` can be set to `0`. We don\u0026#39;t want to start preloading immediately when creating an adapter,\n                and the adapter already loads the next item(s) to be shown.\n         */\n        if (!preloadEnabled || lastVisiblePosition \u0026lt;= 0) {\n            return\n        }\n\n        val startIndex = if (preloadItemsSize \u0026lt; lastVisiblePosition) {\n            lastVisiblePosition + 1\n        } else {\n            preloadItemsSize\n        }\n\n        val lastPreloadIndex = (startIndex + preloadItemsSize - 1).coerceAtMost(items.lastIndex)\n\n        if (startIndex in lastPreloadedPosition until lastPreloadIndex) {\n            lastPreloadedPosition = lastPreloadIndex\n            var realIndex = startIndex\n\n            items.slice(startIndex..lastPreloadIndex).forEach {\n                if (getItemViewType(lastVisiblePosition) == getItemViewType(realIndex)) {\n                    viewHolder.preloadNextItem(it)\n                }\n\n                realIndex++\n            }\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe also needed to set a custom \u003ccode\u003eOnScrollListener\u003c/code\u003e to the \u003ccode\u003eRecyclerView\u003c/code\u003e. The \u003ccode\u003eOnScrollListener\u003c/code\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEnables item preloading when the user scrolls down.\u003c/li\u003e\n\u003cli\u003eDisables item preloading when the list is idle or the user scrolls up.\u003c/li\u003e\n\u003cli\u003eFinds the last visible item position in \u003ccode\u003eRecyclerView\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eclass PreloadScrollListener(val itemPreLoader: ItemPreLoader) : RecyclerView.OnScrollListener() {\n\n    /**\n     * The scroll state can only have the following three values:\n     * 1. `SCROLL_STATE_IDLE` is when the user isn\u0026#39;t scrolling, and it enables image preloading.\n     * 2. `SCROLL_STATE_DRAGGING` is when the user is scrolling with their finger on the screen, and it enables image preloading.\n     * 3. `SCROLL_STATE_SETTLING` is when the user fling scrolls, and it disables image preloading.\n     */\n    override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {\n        super.onScrollStateChanged(recyclerView, newState)\n\n        when (newState) {\n            SCROLL_STATE_IDLE, SCROLL_STATE_DRAGGING -\u0026gt; itemPreLoader.preloadEnabled = true\n            SCROLL_STATE_SETTLING -\u0026gt; itemPreLoader.preloadEnabled = false\n        }\n    }\n\n    /***\n     * There\u0026#39;s a special case where the user scrolls upward. In this case, image preloading is disabled.\n     *\n     * The `PreloadScrollListener` also sets the `ItemPreLoader.adapterPosition`.\n     * The `LastVisibleAdapterPositionFinder` class grabs the `LayoutManager` from the `RecyclerView`, and from the `LayoutManager`, we find the last visible item position.\n     */\n    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {\n        super.onScrolled(recyclerView, dx, dy)\n\n        if (dy \u0026lt; 0) {\n            itemPreLoader.preloadEnabled = false\n        }\n\n        val position = findLastVisiblePosition(recyclerView)\n        itemPreLoader.adapterPosition = position\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFinally, here’s the code to find the last visible item in the \u003ccode\u003eRecyclerView\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003efun findLastVisiblePosition(recyclerView: RecyclerView): Int {\n    return when (recyclerView.layoutManager) {\n        is LinearLayoutManager -\u0026gt; getLastVisiblePositionFrom(recyclerView.layoutManager as LinearLayoutManager)\n        else -\u0026gt; -1\n    }\n}\n\nfun getLastVisiblePositionFrom(manager: LinearLayoutManager): Int {\n    return manager.findLastVisibleItemPosition()\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2\u003eGPU Overdrawing\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering#debug_overdraw\"\u003eGPU overdrawing\u003c/a\u003e is when an app draws the same pixel more than once within the same frame. As a result, GPU overdraw visualization shows where an app might be doing more rendering work than necessary.\u003c/p\u003e\n\u003cp\u003eWe caused a high overdraw severity because we were rendering/drawing three \u003ccode\u003eImageView\u003c/code\u003es on top of each other in the stacked \u003ccode\u003eImageView\u003c/code\u003es when displaying playlists. This is something we shouldn’t do.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/bb59d/over-draw.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Overdraw\" title=\"Overdraw\" src=\"https://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/8ff1e/over-draw.png\" srcset=\"https://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/9ec3c/over-draw.png 200w,\nhttps://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/c7805/over-draw.png 400w,\nhttps://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/8ff1e/over-draw.png 800w,\nhttps://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/6ff5e/over-draw.png 1200w,\nhttps://developers.soundcloud.com/blog/static/933953b257a06d8b925be681264b7f58/bb59d/over-draw.png 1328w\" sizes=\"(max-width: 800px) 100vw, 800px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003eThe Issue\u003c/h3\u003e\n\u003cp\u003eWe draw three full images on top of each other, even though only 10 percent of the stacked images are visible. With stacks, 90 percent of an image isn’t visible, but it’s still drawn, which affects the frame rate.\u003c/p\u003e\n\u003cp\u003eTo fix overdrawing, we would’ve needed to add a lot of custom complex drawing logic, which would take time to build, debug, and maintain. So the tradeoff here was unlikely to be worth the upfront effort and maintenance difficulties.\u003c/p\u003e\n\u003cp\u003eWe did build the custom drawing logic, but it was too complex to maintain, and there was no performance benefit.\u003c/p\u003e\n\u003cp\u003eThe main ideas were:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFlatten the stacked \u003ccode\u003eImageView\u003c/code\u003es into one \u003ccode\u003eImageView\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eDraw only the visible areas of bitmaps.\u003c/li\u003e\n\u003cli\u003eFaster image drawing.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe code below draws three bitmaps on a custom view. Only the bitmaps’ visible areas are drawn, so as to avoid GPU overdrawing. Since only a subset (10 percent) of the bitmaps is drawn, drawing is now faster:\u003c/p\u003e\n\u003cdiv data-language=\"text\"\u003e\u003cpre\u003e\u003ccode\u003eStackedImageView: View() {\n\n    val visibleBitmapOffset = 40f\n\n    override fun draw(canvas: Canvas) {\n\t// Show the bitmap area calculations.\n\tval bounds = RectF(0, 0, width, height)\n\n\tval paint = Paint()\n       \tpaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_ATOP)\n\n        canvas.drawBitmap(topStackBitmap, null, topArea(bounds), paint)\n        canvas.drawBitmap(middleStackBitmap, null, middleArea(bounds), paint)\n        canvas.drawBitmap(bottomStackBitmap, null, bottomArea(bounds), paint)\n    }\n}\n\nprivate fun topArea(bounds: RectF) = bounds.copy().apply {\n        right -= visibleBitmapOffset * 2\n        bottom -= visibleBitmapOffset * 2\n    }\n\n    private fun middleArea(bounds: RectF) = bounds.copy().apply {\n        top += visibleBitmapOffset\n        right -= visibleBitmapOffset\n        left += visibleBitmapOffset\n        bottom -= visibleBitmapOffset\n    }\n\n    private fun bottomArea(bounds: RectF) = bounds.copy().apply {\n        top += visibleBitmapOffset * 2\n        left += visibleBitmapOffset * 2\n    }\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe code above calculates the bounds (area) of each bitmap. The bounds are the area into which the bitmap will be drawn. The \u003ccode\u003evisibleBitmapOffset\u003c/code\u003e defines how many pixels the bounds will be moved/offset.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIn the top stack bitmap area, the bitmap is displaced by \u003ccode\u003evisibleBitmapOffset*2\u003c/code\u003e pixels toward the top-left corner.\u003c/li\u003e\n\u003cli\u003eIn the middle stack bitmap area, all sides are moved by \u003ccode\u003evisibleBitmapOffset/2\u003c/code\u003e pixels, placing the bitmap in the middle of the view.\u003c/li\u003e\n\u003cli\u003eIn the bottom stack bitmap area, the bitmap is displaced by \u003ccode\u003evisibleBitmapOffset*2\u003c/code\u003e pixels toward the bottom-right corner.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTo draw only the visible bitmap areas and avoid overdrawing, we use \u003ccode\u003epaint.xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_ATOP)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePorterDuff.Mode.DST_ATOP\u003c/code\u003e draws only the outside area of the following image. So if there is already something drawn in the view, then \u003ccode\u003eDST_ATOP\u003c/code\u003e only draws the outer part of what we’re drawing now. Since we already drew the top bitmap, only the middle bitmap’s outer part is drawn. It’s the same with the bottom bitmap; only the outer section is drawn.\u003c/p\u003e\n\u003cp\u003eThe section above outlines the basics of how to draw three images without overdrawing. Complications arise when the images have round corners; the stacks can be solid colors; and there can be more images on top of the stack, fading in each stack of bitmaps and drawing rounded borders. Implementing all of that led to a great deal of drawing code, which was hard to maintain. Thus, it wasn’t included in the project.\u003c/p\u003e\n\u003cp\u003eIf you want to learn more about computer graphics drawing, \u003ca href=\"https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390\"\u003e\u003cem\u003eFundamentals of Computer Graphics\u003c/em\u003e\u003c/a\u003e is a great book.\u003c/p\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eRedesigning an entire app takes a lot of time — from product managers coming up with the product specifications, whiteboarding sessions, and creating wireframes, to UI and UX designers drawing the final design. Finally, the engineers have to implement the new design and rewrite UI components, and usually, all this work is done under pressure with a set deadline.\u003c/p\u003e\n\u003cp\u003eWe all like to go fast and get a redesign done, but as a result, we end up rushing and forgetting the important stuff like properly testing the new UI to see if it works, and checking to ensure the performance and frame rate are acceptable. Testing and measuring performance is the responsibility of the engineers, so it’s of the utmost importance to always test and measure the performance of your new UI.\u003c/p\u003e\n\u003cp\u003eWith proper performance measuring and testing, we were able to identify and fix image UI issues we encountered. And although it took longer, SoundCloud ended up with a more polished product.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": null,
  "modifiedTime": null
}
