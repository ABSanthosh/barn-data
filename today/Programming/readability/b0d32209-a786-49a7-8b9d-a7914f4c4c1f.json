{
  "id": "b0d32209-a786-49a7-8b9d-a7914f4c4c1f",
  "title": "Deploying Go Apps with Kubernetes",
  "link": "https://blog.jetbrains.com/go/2024/11/20/deploying-go-apps-with-kubernetes/",
  "description": "We live in a world where things change at a rapid pace, and the latest and greatest quickly becomes outdated. The same goes for deploying applications to servers. You used to have to physically travel to a data center to deploy your changes. Later on, we moved to VMs. Then containers came along and changed […]",
  "author": "Mukul Mantosh",
  "published": "Wed, 20 Nov 2024 11:24:31 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "tutorials",
    "go",
    "goland",
    "kubernetes"
  ],
  "byline": "Mukul Mantosh",
  "length": 23112,
  "excerpt": "We live in a world where things change at a rapid pace, and the latest and greatest quickly becomes outdated. The same goes for deploying applications to servers. You used to have to physically travel",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A cross-platform Go IDE with extended support for JavaScript, TypeScript, and databases TutorialsDeploying Go Apps with Kubernetes We live in a world where things change at a rapid pace, and the latest and greatest quickly becomes outdated. The same goes for deploying applications to servers. You used to have to physically travel to a data center to deploy your changes. Later on, we moved to VMs. Then containers came along and changed the game again. Containers have been widely adopted by most industries, and one of the most popular containerization tools is Docker. However, as complexity grew, people started looking for orchestration tools that were effective at scale, performed load balancing, self-healed, and more. There were many contenders in the competition, like Apache Mesos, HashiCorp Nomad, and Docker Swarm, but Kubernetes has thrived for a long time due to its robust ecosystem, extensive community support, scalability, and ability to manage complex, distributed applications across multiple environments. Source: drgarcia1986.medium.com Kubernetes is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. Originally developed by Google, it is now maintained by the CNCF. Kubernetes is one of the largest open-source projects to date. With over a decade of development, its maturity is undeniable, boasting more than 88,000 contributors. Check out the 10 Years of Kubernetes blog post for more insights. In this tutorial, we are going to create a Go application and prepare it to run inside a Kubernetes cluster.  Let’s get started! Creating a Go application in GoLand In this tutorial, we’ll start by creating a basic Go application which performs CRUD operations. We’ll then containerize the application and deploy it to the local Kubernetes cluster using Docker Desktop. You can access the source code used in this tutorial here. To create your project, launch GoLand and click New Project.  Provide necessary information such as the project name, GOROOT, and environment variables. Even if you don’t have the Go SDK installed on your system, GoLand will assist you in downloading the correct SDK. Then click Create. Installing packages Gorilla Mux Once the project has been created, install Gorilla. The Gorilla Mux package is among the most widely used routers. It offers functionalities for route matching, serving static files, supporting middleware and websockets, managing CORS requests, and testing handlers. Installing it from GoLand is simple and straightforward. Just import the package name, and the IDE will prompt you to install it. Alternatively, you can use the default method by accessing the Terminal and executing the following command: go get -u github.com/gorilla/mux GORM GORM is an Object Relational Mapping (ORM) library for Go. It simplifies database interactions by making it easier for developers to work with database records and perform CRUD (Create, Read, Update, Delete) operations. *NOTE: We will be using the Postgres driver. To install, run the following command in the Terminal: go get -u gorm.io/gorm go get -u gorm.io/driver/postgres Alternatively, you can also directly mention the package in the go.mod file and GoLand will take care of the installation. NOTE: When you see // indirect next to a dependency in the require block of your go.mod file, it indicates that your project does not import this package directly in its code, but some other package that your project imports does.  Building core business functions Now, we have installed the core packages required to build the application. It’s time to start writing the core business logic.  Database Let’s begin with the database. Create a database.go file under project root.  Let’s break it down step-by-step.  In this section we are managing a database client using the GORM library for Postgres. DBClient: This is an interface with two method signatures: Ready(): This function returns a boolean value based on whether the database is ready or not.  RunMigration(): This function performs database migrations.  Client: This is a concrete type Client that implements the DBClient interface. It contains a single db *gorm.DB field which points to a gorm.DB instance. Next, in the Ready method we perform a RAW SQL query to check database readiness. It will return a boolean response (true or false).  Under RunMigration, we first check whether the database is ready. If successful, we proceed to invoke the AutoMigrate method provided by GORM to apply migrations to the database schema. As noted in the comment, we need to register the model to run the migration. We haven’t created a model yet, but don’t worry – we’ll get to that shortly.  The NewDBClient function constructs a database connection from environment variables, creating a Client that can be used to interact with the database. The database section is done. Now let’s create our user model.  User model Create a model.go file under the project root.  Here you can see the User struct with fields ID, Name, Email, and Age, each annotated with JSON tags for serialization and GORM tags for database constraints, including primary key, uniqueness, and non-null constraints. These tags specify database constraints and behaviors using GORM: gorm:\"primaryKey\": The ID field is the primary key. gorm:\"not null\": The Name and Email fields cannot be NULL in the database. gorm:\"unique\": The Email must be unique across the database table. Now we need to pass the User model to the AutoMigrate function which we discussed earlier.  Server We have implemented the database and the user model, so now it’s time to construct the mux server.  Create the server.go and routes.go files under the project root. We’ll just leave this routes.go file empty for now, and we’ll cover what to do with it in the next section when we start defining HTTP handlers. Let’s break down the ‘server.go’ file step-by-step. The Server interface declares two methods:  – Start() error: Starts the server and returns any errors that pop up.  – routes(): Defines the server routes. The MuxServer struct implements the Server interface.  It contains:  – gorilla *mux.Router: An instance of Gorilla Mux Router.  – Client: An embedded field pointing to a database client.  NewServer is a constructor function that creates and initializes a MuxServer instance.   It accepts a Client which refers to a database client.   A new MuxServer is created with:  – A new router from mux.NewRouter().  – The provided db client.  – The server.routes()method is called to set up the routes.  The Start method takes care of starting up the HTTP server and listening on port 8080.  We haven’t defined any HTTP handlers yet, which is why the routes function is currently empty.  Let’s take care of that now. HTTP handlers Create a new file called controller.go under the project root.  Once you’ve created the file, go ahead and open model.go and add the following struct: The UserParam struct serves as a data transfer object (DTO) specifically for input handling, often seen in web APIs or web forms.  Separation of Concerns: The User struct represents the data structure of a user entity in the system, which corresponds directly to the database schema. The UserParam struct is used for handling input validation and data transfer, particularly from HTTP requests. Security: You’ll have better control over your data by separating fields into two categories: (1) information received from requests (like user input), and (2) information stored in the database. This gives you control over what data is exposed, enhances security by filtering out sensitive info, and ensures you only transfer necessary data between layers.  Let’s go ahead and start implementing the HTTP handlers.  Head back into the controller.go file. Let’s break it down step-by-step. We are going to implement the basic CRUD (Create, Read, Update, and Delete) operations on the User model.  Add User To create a new user and add it to the database. List Users To list all users from the database. Update User To update an existing user’s details. Delete User To delete an existing user. Now, it’s time to update the routes.  In this function, we’ll set up various kinds of routes (GET, POST, PUT and DELETE) to handle requests. Running the application We’re almost done! It’s time to define the entry point of the application where we can initialize the database, run migrations, and start the server. Create a new file called main.go under the project root. As you can see from the code below, we are initializing the database client, running database migration, and starting up the server.  Now, it’s time to start the server. Before that, make sure you are running a local instance of Postgres. I will use Docker to spin up a postgres container. Run the following command in the Terminal: docker run --name goland-k8s-demo -p 5432:5432 -e POSTGRES_PASSWORD=********** -d postgres Once the container is up and running, go ahead and modify the Run Configuration.  Add these variables to the Environment field, as shown in the image below: DB_HOST DB_USERNAME DB_PASSWORD DB_NAME DB_PORT Once done, apply the changes. Click the play icon to start the application.  Once the application is running, navigate to http-client | apis.http. You can play around with the REST APIs directly from the IDE itself.  Diving into K8s Now that we have developed the entire application,  it’s time to deploy the application inside the Kubernetes cluster.  The process starts with creating the Dockerfile. Dockerfile A Dockerfile is a text document that contains a set of instructions for building a Docker image. It defines how the image should be constructed, including the base image to use, the files to include, and any commands to run during the build process. Create a new file under project root and name it “Dockerfile”. Simply follow the steps I’ve outlined to build the Docker image. I’ll walk you through it step by step. FROM golang:1.23-alpine AS builder Starts with golang:1.23-alpine as the base image and labels the stage as builder. WORKDIR /app Set the working directory to /app. COPY . . Copies the entire current directory (.) into the /app directory. RUN CGO_ENABLED=0 GOOS=linux go build -o go_k8s Runs the Go build command to compile the application.  CGO_ENABLED=0 disables CGO (CGO enables the creation of Go packages that call C code).  GOOS=linux sets the target OS to Linux.  The output binary is named go_k8s. FROM gcr.io/distroless/base Uses a minimal distroless base image for the final container, focusing on security by excluding unnecessary components. To learn more about distroless images, check this out.  WORKDIR /app Sets the working directory to /app in the final stage. COPY --from=builder /app/go_k8s . Copies the go_k8s binary from the /app directory of the builder stage into the /app directory of the final image. CMD [\"./go_k8s\"] Sets the command to run when the container starts, which is the go_k8s binary. The final image is kept as small and secure as possible, containing only the Go application binary without any unnecessary build tools or dependencies. Go ahead and build the Docker image.  Click Run ‘Dockerfile’. Note: Before running, make sure the Docker daemon is running in the background. For this tutorial we are going to be using Docker Desktop. Once the image is successfully built, push the image to the Docker registry. Right-click the image tag and select Edit Configuration. Provide the image tag and apply the changes. Note: Before pushing, make sure to change the image tag based on the Docker repository which you have created in DockerHub. The image tag should follow the format \u003chub-user\u003e/\u003crepo-name\u003e[:\u003ctag\u003e]. Follow the steps to create repositories. In this example, the tag mukulmantosh/go_k8s:1.0 is for demonstration only and may change based on your account type. Here, mukulmantosh represents the user, while go_k8s is the repository name and 1.0 is the specified tag. Make sure to re-run the build process.  You can see that the image tag has been applied.  It’s time to push the image.  Right-click on the image tag, then select Push Image. Click Add and provide your Docker registry information. Once successfully authenticated, click OK to push the image. Once the image is successfully pushed, you can observe the changes in DockerHub.  Well, the image is built and pushed. Now it’s time to work on the second part – writing the Kubernetes YAML files.  Writing K8s manifests This part of the tutorial covers how to deploy applications to local Kubernetes clusters. In this tutorial, we have utilized Docker Desktop, though you can also opt for Minikube or Kind. If you’ve chosen Docker Desktop as your preferred platform for running Kubernetes, be sure to enable Kubernetes in the settings by clicking the Enable Kubernetes checkbox. Once Kubernetes is up and running, it’s time to create a namespace. What is a namespace? In Kubernetes, a namespace is a logical partitioning of the cluster that allows you to divide resources and organize them into groups. Namespaces enable multiple teams or projects to share the same cluster while maintaining isolation and avoiding naming conflicts. Source: belowthemalt.com Begin by creating a directory called k8s in the root of your project. Next, create a new file and name it ns.yaml. NOTE: A Kubernetes manifest is typically written in YAML or JSON format and outlines various parameters for the resource, including its type, metadata, and specifications. This YAML file would create a namespace named go-k8s-demo in your Kubernetes cluster. Let’s break it down. apiVersion: v1: This specifies the API version of the Kubernetes resource. In this case, v1 indicates that the resource is using version 1 of the Kubernetes API. kind: Namespace: This indicates the type of Kubernetes resource being defined. It can be Deployment, Service, etc. metadata: This section holds metadata about the Kubernetes resource. Metadata usually includes details like the name, labels, and annotations. If you type the following command in the Terminal, it will show you lists of the API resources available in the Kubernetes cluster.  kubectl api-resources Okay – you’ve created the YAML file. Now it’s time to execute it.  There are two ways you can create a namespace: If you prefer using the Terminal, you can run this command: kubectl create ns go-k8s-demo Or, you can apply a file by running this command: cd k8s kubectl apply -f ns.yaml Both methods will create the same namespace. Creating a namespace with GoLand You also have the option of doing this in GoLand. Yes, you read that right, you can play with your Kubernetes clusters directly from the GoLand IDE.  As a side note, if you’re using GoLand 2024.2 or later, the Kubernetes plugin is already bundled with the IDE, so you don’t need to install it separately. Open the Service tool window  by going to View | Tool Windows | Services. Right-click on Kubernetes | Add Clusters | From Default Directory. Select docker-desktop and click Add Clusters. You will see docker-desktop as your newly added cluster. Click the play icon to connect to it. Return to the YAML file and hover over the top right corner of the screen and click Apply to Cluster to set your cluster to docker-desktop. Once done, apply the changes. The namespace is successfully created.  We will now switch to the newly created namespace to easily view the applications running within it. You might be asking, “This works with a local cluster, but what about connecting to an external one?” Good news! You can do that as well. You can also modify the paths for the kubectl and helm executables. Additionally, you have the option to customize Kubernetes configuration files at either the global or project level. Database and K8s The namespace has been created. Now let’s start working on the database. PersistentVolume We are going to create a persistent volume. A PersistentVolume (PV) in Kubernetes provides storage for your application’s pods. Think of it as a storage space that exists independently of any specific application. Unlike regular storage that disappears when an application stops, a PersistentVolume retains the data, making it suitable for applications that need to save files or databases. Create a new folder called db in the project root, and then add a new file named pv.yaml inside it. This YAML configuration defines a PersistentVolume named postgres-pv with 1 GB of storage. It is associated with the postgres application and can be accessed as read-write by one node at a time. The volume is stored locally on the host at the path /data/db. PersistentVolumeClaim Create a new file called pvc.yaml under db. A PersistentVolumeClaim (PVC) in Kubernetes is a request for storage by a user or application. It allows you to specify how much storage you need and what characteristics it should have, such as access modes (like read/write). In this YAML configuration we are creating a PVC in the go-k8s-demo namespace requesting 1 GiB of storage with a ReadWriteOnce access mode using the manual storage class. ConfigMap Create a new file cm.yaml under db. A ConfigMap in Kubernetes is a resource used to store configuration data in a key-value format. It allows you to separate configuration from application code, making it easier to manage and modify settings without needing to rebuild your application. Deployment A Deployment in Kubernetes is a resource used to manage and orchestrate the deployment of applications. It allows you to define how many instances of your application (called Pods) you want to run, and it ensures that they are running as expected. Create a new file deploy.yaml under db. This YAML file defines a deployment of a single PostgreSQL container running version 17.0, which exposes port 5432 and runs only one instance. It loads environment variables from a ConfigMap and uses a PersistentVolume to store data.  Service A Service in Kubernetes is an abstraction that defines a logical set of pods and a way to access them. It provides a stable endpoint for your applications, making it easier to communicate with groups of pods. Source: kubernetes.io Create a new file svc.yaml under db. In this YAML file we have defined a Kubernetes Service named postgres-service. The Service exposes port 5432 and routes traffic to the pods labeled with app: postgres-db, so it will allow other applications within the cluster to connect to the database. Launching DB We now have all of the configuration files needed to start the database. Let’s execute them. There are two methods to do this. First, open the Terminal, navigate to the db directory, and run the following command: cd db kubectl apply -f . To see the current status of your pods, you can run the following command: kubectl get pods -n go-k8s-demo The second option is quite easy with GoLand. You don’t need to remember the commands – just the follow along with the video below: Application and K8s Now that the database is up and running, it’s time to prepare our backend application. Begin by creating an app folder inside the k8s directory. ConfigMap Create a new file called cm.yaml under app. Enter the required database credentials. NOTE: Grab the credentials from db/cm.yaml that you defined earlier when creating the database pod. postgres-service under DB_HOST refers to the db/svc.yaml service we created earlier. Deployment Now let’s move on to the deployment.  Create a new file called deploy.yaml under app.  In this YAML file we define a Kubernetes deployment that runs a single replica of a pod, which contains a single container using the mukulmantosh/go_k8s:1.0 image. The container exposes port 8080 and gets its environment variables from a ConfigMap named app-cm. Service Now let’s wrap up the last file.  Create a file called svc.yaml under app. To summarize, we set up a service named app-service that allows external traffic to reach your application running in the cluster through port 30004. Requests received here are forwarded to port 8080 on the application pods. Testing Now let’s deploy our application and start testing it out.  The process is going to be exactly the same as what we did for the database. Navigate to the app directory and run the following command: cd app kubectl apply -f . Alternatively, you can do this in GoLand, which is quite easy and straightforward.  You can also check the status of your application by running the following command: kubectl get pods -n go-k8s-demo Let’s test out the application by sending an HTTP request. The application works! This was just a brief demonstration of how to use Kubernetes with Go, but there are many more possibilities to explore. References If you already have a strong grasp of Kubernetes and want to learn how to deploy in a live cluster, take a look at my tutorial on deploying Go apps in Google Kubernetes Engine. Subscribe to GoLang Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/11/go-social_share_blog_1280x720_en-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/go/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/GoLand-1.svg\" alt=\"Go logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA cross-platform Go IDE with extended support for JavaScript, TypeScript, and databases\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/go/category/tutorials/\"\u003eTutorials\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eDeploying Go Apps with Kubernetes\u003c/h2\u003e                    \n                    \n\u003cp\u003eWe live in a world where things change at a rapid pace, and the latest and greatest quickly becomes outdated. The same goes for deploying applications to servers. You used to have to physically travel to a data center to deploy your changes. Later on, we moved to VMs. Then containers came along and changed the game again.\u003c/p\u003e\n\n\n\n\u003cp\u003eContainers have been widely adopted by most industries, and one of the most popular containerization tools is \u003ca href=\"https://www.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDocker\u003c/a\u003e. However, as complexity grew, people started looking for orchestration tools that were effective at scale, performed load balancing, self-healed, and more. There were many contenders in the competition, like \u003ca href=\"https://mesos.apache.org/\" target=\"_blank\" rel=\"noopener\"\u003eApache Mesos\u003c/a\u003e, \u003ca href=\"https://www.nomadproject.io/\" target=\"_blank\" rel=\"noopener\"\u003eHashiCorp Nomad\u003c/a\u003e, and \u003ca href=\"https://docs.docker.com/engine/swarm/\" target=\"_blank\" rel=\"noopener\"\u003eDocker Swarm\u003c/a\u003e, but Kubernetes has thrived for a long time due to its robust ecosystem, extensive community support, scalability, and ability to manage complex, distributed applications across multiple environments.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"894\" height=\"894\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/Artboard-1-2x.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSource: \u003cem\u003edrgarcia1986.medium.com\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener\"\u003eKubernetes\u003c/a\u003e is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. Originally developed by Google, it is now maintained by the \u003ca href=\"https://www.cncf.io/projects/\" target=\"_blank\" rel=\"noopener\"\u003eCNCF\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eKubernetes is one of the largest open-source projects to date. With over a decade of development, its maturity is undeniable, boasting more than 88,000 contributors. Check out the \u003ca href=\"https://kubernetes.io/blog/2024/06/06/10-years-of-kubernetes/\" target=\"_blank\" rel=\"noopener\"\u003e10 Years of Kubernetes\u003c/a\u003e blog post for more insights.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this tutorial, we are going to create a Go application and prepare it to run inside a Kubernetes cluster. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s get started!\u003c/p\u003e\n\n\n\n\u003ch2\u003eCreating a Go application in GoLand\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn this tutorial, we’ll start by creating a basic Go application which performs CRUD operations. We’ll then containerize the application and deploy it to the local Kubernetes cluster using Docker Desktop.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can access the source code used in this tutorial \u003ca href=\"https://github.com/mukulmantosh/go_kubernetes\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo create your project, launch GoLand and click \u003cem\u003eNew Project\u003c/em\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003eProvide necessary information such as the project name, \u003ca href=\"https://www.jetbrains.com/help/go/configuring-goroot-and-gopath.html#goroot\" target=\"_blank\" rel=\"noopener\"\u003eGOROOT\u003c/a\u003e, and environment variables.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven if you don’t have the Go SDK installed on your system, GoLand will assist you in \u003ca href=\"https://www.jetbrains.com/help/go/configuring-goroot-and-gopath.html#download-go-sdk\" target=\"_blank\" rel=\"noopener\"\u003edownloading\u003c/a\u003e the correct SDK.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcMKDzdcC-JvIzy398LQmTt3Zbs7Ji6XxQpUPCOoBSU80oZKW15QcNFnJ7h0PN7UZdR7IHQzIm7mRCL-fYZ03P2uZr9P3MZiY99ukm4HZhUBBtwEZMVxItjtor6tX0YAKn-f-RYpS4RNeDkp54ACHUu_PI?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThen click \u003cem\u003eCreate\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eInstalling packages\u003c/h2\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eGorilla Mux\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eOnce the project has been created, install \u003ca href=\"https://gorilla.github.io/\" target=\"_blank\" rel=\"noopener\"\u003eGorilla\u003c/a\u003e. The Gorilla Mux package is among the most widely used routers. It offers functionalities for route matching, serving static files, supporting middleware and websockets, managing CORS requests, and testing handlers.\u003c/p\u003e\n\n\n\n\u003cp\u003eInstalling it from GoLand is simple and straightforward. Just import the package name, and the IDE will prompt you to install it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcptza6O49QG_SMXQdAWGYstxGMMb4qwEExlChEE-4WyZ7V8rKqVEGKootXpdJX-Dbwg0UW0hbt3dr3Ey8AELPFIzm5kbxgTatdEgFQTzuWj4lqMSDgI6uMfmltQg-46XzeYlIAdnT_HlKiTkCJnto2MUvp?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAlternatively, you can use the default method by accessing the Terminal and executing the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ego get -u github.com/gorilla/mux\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcFRW7G6ocK6eSSCBtySfoMejCA-lMySSIFCQdTy0O1iERTTrWry_wwDhkSM0arUyliw46Q9komZQDyOROdLldXqVMocWcpwitVZywplmOvt226a60zgkw8hz3odJzf1qyuHfwjCQa51-D15w8iTE3RPn3j?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eGORM\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"https://gorm.io/\" target=\"_blank\" rel=\"noopener\"\u003eGORM\u003c/a\u003e is an Object Relational Mapping (ORM) library for Go. It simplifies database interactions by making it easier for developers to work with database records and perform CRUD (Create, Read, Update, Delete) operations.\u003c/p\u003e\n\n\n\n\u003cp\u003e*\u003cstrong\u003eNOTE\u003c/strong\u003e: We will be using the \u003ca href=\"https://www.postgresql.org/\" target=\"_blank\" rel=\"noopener\"\u003ePostgres\u003c/a\u003e driver.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo install, run the following command in the Terminal:\u003c/p\u003e\n\n\n\n\u003cpre\u003ego get -u gorm.io/gorm\ngo get -u gorm.io/driver/postgres\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlternatively, you can also directly mention the package in the \u003ca href=\"https://go.dev/doc/modules/gomod-ref\" target=\"_blank\" rel=\"noopener\"\u003ego.mod\u003c/a\u003e file and GoLand will take care of the installation.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXceZEY0Wc48Koyq2r4wd2RZ-dxp-rp9juOeDidnteZNAy6ppjty4hUVFdDEmvMwW3odUyYOd69FfFC8hbEIzFMRlOGxTSx-VoNNDXJvIJwwQwE3c0PTRBWwdUyH4fYwYZqGFjfJ_bHugjI9KLECw0VBuGt0?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcoXq-a4276ZlhdyHVFMtigUK1Ol2vZvwXB34xUHFd97PcHy02Ecl8gBshUTq7tAPHAK8A8_CQ0ywLVIJ-SdCC8sHiL49phkKD3Z70WqzrtmVvdQ9p1kcPSd8bDlgyqWkh6WeEzlOlX_TJfsbm_G_4IbBdP?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: When you see \u003ccode\u003e// indirect\u003c/code\u003e next to a dependency in the \u003ccode\u003erequire\u003c/code\u003e block of your \u003ccode\u003ego.mod\u003c/code\u003e file, it indicates that your project does not import this package directly in its code, but some other package that your project imports does. \u003c/p\u003e\n\n\n\n\u003ch2\u003eBuilding core business functions\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow, we have installed the core packages required to build the application. It’s time to start writing the core business logic. \u003c/p\u003e\n\n\n\n\u003ch3\u003eDatabase\u003c/h3\u003e\n\n\n\n\u003cp\u003eLet’s begin with the database.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a \u003ccode\u003edatabase.go\u003c/code\u003e file under project root. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcoTEt8J2UMn81H7vv8n9IxIpO0bfU2ZfsNFApea6920wzWAn5GoJGFNDhy7_y_apAaeoNwOx5PUgcyAoS40Q73GRxctTm5TLLNIcm3MVs3x3myX0VuEKAdMADGpiius2UYSpXRV4qp8peEKEcY7Zo9p4ko?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s break it down step-by-step. \u003c/p\u003e\n\n\n\n\u003cp\u003eIn this section we are managing a database client using the GORM library for Postgres.\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eDBClient\u003c/code\u003e\u003c/strong\u003e: This is an interface with two method signatures:\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eReady()\u003c/code\u003e\u003c/strong\u003e: This function returns a boolean value based on whether the database is ready or not. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eRunMigration()\u003c/code\u003e\u003c/strong\u003e: This function performs database migrations. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXc7OdvHhC7dQ90PHYLJCAiekFEYMY_Ea3XLWHBk1d-LYwNKNG6mytgtxLY0xD64z8MEZgTyY5egkqdJfsiDLsGK4mGNQGJ51Uph4jZvEiBP0bfMSskojQW3k37os1J9IINFXV6WPT1dm447xRw53b9mGRX_?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eClient\u003c/code\u003e\u003c/strong\u003e: This is a concrete type \u003ccode\u003eClient\u003c/code\u003e that implements the \u003ccode\u003eDBClient\u003c/code\u003e interface. It contains a single \u003ccode\u003edb *gorm.DB\u003c/code\u003e field which points to a \u003ccode\u003egorm.DB\u003c/code\u003e instance.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdUQvsNWGmnEhTjPSHvz2a65eQycqkpo79VoOR569qm6tawBz3hnYHTqM_iwNsdRlsJfBvuNutBHhBX6ftuYMYKPobRBgQQWmlsc0Q4ZtvU0KTj0zyO4-olgDf5Cr_olwrEceNF5AUlijfYVu6rWM7NomI1?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003col start=\"3\"\u003e\n\u003cli\u003eNext, in the \u003ccode\u003eReady\u003c/code\u003e method we perform a RAW SQL query to check database readiness. It will return a boolean response (true or false). \u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfnc1CWg_OZ5dRdh8snZ-0mkhsAt5bLb91mwr9kafhKrXHWOkhDcM8YG1b9Z3cIDKXnCtlKXGaKj-AFT0AOZUF-9TAce4V7Z3TxZjPYG1WxocqYmT1WmSntAowZMAgBWPXwwPsoyOQGJhCehSYLj_hiz0Rj?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003col start=\"4\"\u003e\n\u003cli\u003eUnder \u003cstrong\u003e\u003ccode\u003eRunMigration\u003c/code\u003e\u003c/strong\u003e, we first check whether the database is ready. If successful, we proceed to invoke the \u003ccode\u003eAutoMigrate\u003c/code\u003e method provided by GORM to apply migrations to the database schema. As noted in the comment, we need to register the model to run the migration. We haven’t created a model yet, but don’t worry – we’ll get to that shortly. \u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfG0UMHBTzgN8stvwllpG0Dpc2NAku1NhDHMgcot_fX1NyRCknwtbh9mAXCKbir4fTKdRWbyLPOoOhQ5KRUc7648csDIYMszYcrTpsHRCRoIdCMyl3nvi8ysuj18I5MJPQAf-8HxD1OOVROjQOh4uAtrMjs?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003col start=\"5\"\u003e\n\u003cli\u003eThe \u003ccode\u003eNewDBClient\u003c/code\u003e function constructs a database connection from environment variables, creating a \u003ccode\u003eClient\u003c/code\u003e that can be used to interact with the database.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe80O40fDLowwWQpZLCQLJYD3XuBt3IxdFRQ_6zS3RUJ9xqDyor8pEyyuJW0XQsZPXP0wZJNKS5eRBakVuByOCrEaq324zTsuoY0f88QtuuD-nt3RFMTjkbLdooqNF0iMEhxZj-_zlYBQ8ARpe2F6BOEzph?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe database section is done. Now let’s create our user model. \u003c/p\u003e\n\n\n\n\u003ch3\u003eUser model\u003c/h3\u003e\n\n\n\n\u003cp\u003eCreate a \u003ccode\u003emodel.go\u003c/code\u003e file under the project root. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXc7hPLQP_SI5z_PhRlBRdbyV0r1lkhYDBllcnagGenY6SVvGsLE-Vx86I-DccbLCEEaZNdOTwzjAbGUZV8Ug1YpKP6VQgfz26GYMgh_EEETtnsvWlWSDtmrhEe391bqZweKp_FygvUoFgnFzx5OHe9Qz5Y?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcd5nG-228uRCWhJVeD_kPHujxCRkwGaB0OOzIdNbPakW2D5Wi6wjY6W0pHkg-1cAvsYLXIlXdkprUnt03RkG6I2ZBXKv1Df8qULibDKUR02RIKHIRiZNc5U_YCxPJ72hAR7BCaXce1B9N4yFoEIldYdupq?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eHere you can see the \u003cstrong\u003e\u003ccode\u003eUser\u003c/code\u003e\u003c/strong\u003e struct with fields \u003cstrong\u003e\u003ccode\u003eID\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003eName\u003c/code\u003e\u003c/strong\u003e, \u003cstrong\u003e\u003ccode\u003eEmail\u003c/code\u003e\u003c/strong\u003e, and \u003cstrong\u003e\u003ccode\u003eAge\u003c/code\u003e\u003c/strong\u003e, each annotated with JSON tags for serialization and GORM tags for database constraints, including primary key, uniqueness, and non-null constraints.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese tags specify database constraints and behaviors using GORM:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003egorm:\u0026#34;primaryKey\u0026#34;\u003c/code\u003e: The \u003ccode\u003eID\u003c/code\u003e field is the primary key.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003egorm:\u0026#34;not null\u0026#34;\u003c/code\u003e: The \u003ccode\u003eName\u003c/code\u003e and \u003ccode\u003eEmail\u003c/code\u003e fields cannot be \u003ccode\u003eNULL\u003c/code\u003e in the database.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003egorm:\u0026#34;unique\u0026#34;\u003c/code\u003e: The \u003ccode\u003eEmail\u003c/code\u003e must be unique across the database table.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow we need to pass the \u003ccode\u003eUser\u003c/code\u003e model to the \u003ccode\u003eAutoMigrate\u003c/code\u003e function which we discussed earlier. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdPNWyPUyafYUMLqED0spgIg2KUztwuZSv9wnH99rfNKnWmVFHYQxQNOGHn5r11Qq-KKuo0a-GpzPwB2yxS7C58ILaWtwA51hc_KITQao17vU-s98eVq4Maf3-eQBUuO1F9YQpCpdAR5v4jXSFvi8XuNzfc?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eServer\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe have implemented the database and the user model, so now it’s time to construct the mux server. \u003c/p\u003e\n\n\n\n\u003cp\u003eCreate the \u003ccode\u003eserver.go\u003c/code\u003e and \u003ccode\u003eroutes.go\u003c/code\u003e files under the project root.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdteR3N0nCQhr0voNDJVbY_sXNUJPF91ANaRodDoLFARhb5QeR7PwxlqyMWoxmRc3-VnftdP3iQTKlugCyHhNB8ie5H8qEP5PfgYWv4hzltIWxLl1bp3SHFxQg8-nw_dvN4aiX0ttTZGJGCbOX618Ey8tQK?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe’ll just leave this \u003ccode\u003eroutes.go\u003c/code\u003e file empty for now, and we’ll cover what to do with it in the next section when we start defining HTTP handlers.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXemO_-EOIqo7ZWoIX4DDr1I4X-Gw6qO9EQ4ko6kyG-tuQGzB5uMrAFv8H9ON-qJtqLB_4BkOzy7rzwlHd-u2czRq7TgNmxwlfUMkFzALXf8y_a9EiQt-B5Y_Cnf79gwV6dKh3aZS174b7tpafPSgJK2RIxH?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s break down the ‘\u003ccode\u003eserver.go\u003c/code\u003e’ file step-by-step.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe6JXR1V-6tKokaxTOVE8k4xvZdL1dzdTVk0M9AHcE02Auj9EPqD-VN_G0Bs2AKLqIv9KVe9tM3Ln9jd19i7XFXZspoIwdMikIMpJCvXMtOX0mxKeMHLsyP-56KEgAg6pjNZRXIqN6pPdf4dif-caRmSiT5?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eServer\u003c/code\u003e interface declares two methods: \u003c/p\u003e\n\n\n\n\u003cp\u003e– \u003ccode\u003eStart() error\u003c/code\u003e: Starts the server and returns any errors that pop up. \u003c/p\u003e\n\n\n\n\u003cp\u003e– \u003ccode\u003eroutes()\u003c/code\u003e: Defines the server routes.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdf38_-DMxLd4pZ3BiwEpbW0ZhCw-qaf849yPHcbs3sjb1xk95LeQzf3YbrzpKyK12GSaywfy_57WbCzK3gawwXWr03_LFgrTZ0LhWZpC6Ll_wRiORRmNP0rCfDMPAZ2XDrcgPE-P_rgXiKM9SYw48NKi0K?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eMuxServer\u003c/code\u003e struct implements the \u003ccode\u003eServer\u003c/code\u003e interface. \u003c/p\u003e\n\n\n\n\u003cp\u003eIt contains: \u003c/p\u003e\n\n\n\n\u003cp\u003e– \u003ccode\u003egorilla *mux.Router\u003c/code\u003e: An instance of Gorilla Mux Router. \u003c/p\u003e\n\n\n\n\u003cp\u003e– \u003ccode\u003eClient\u003c/code\u003e: An embedded field pointing to a database client. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdZnuMqxkeVoMFfUo-76xoKkFmmKCPpD8-_NI6hq9kjVXoVz-xErk4cLK-o5Q_vUy9y9u55CNrikR0LW5yGUzkS2AsMWEs8nawD8Lj6nLgD-acrxYIlqw4md0QMeKETvKQeGQE7jDKQXvdTj0Gb0mr5bk0?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eNewServer\u003c/code\u003e is a constructor function that creates and initializes a \u003ccode\u003eMuxServer\u003c/code\u003e instance. \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e It accepts a \u003ccode\u003eClient\u003c/code\u003e which refers to a database client. \u003c/li\u003e\n\n\n\n\u003cli\u003e A new \u003ccode\u003eMuxServer\u003c/code\u003e is created with: \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e– A new router from \u003ccode\u003emux.NewRouter()\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003e– The provided \u003ccode\u003edb\u003c/code\u003e client. \u003c/p\u003e\n\n\n\n\u003cp\u003e– The \u003ccode\u003eserver.routes()\u003c/code\u003emethod is called to set up the routes. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdqy9-_o6Q-vYg-p1tHLq7TIHdPw8nl1-mIZ0aH6E-GdVH0WAhSLqRz5tUI2OVsCzgyrkvpbAZRRdNl4PknY8Ce-sJxnF8v3YJxEhFFYjvypGS8fsIZXB2-Db-9WVOm_f5sj_TwpN7si7C0hHTjSWKbyyas?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eStart\u003c/code\u003e method takes care of starting up the HTTP server and listening on port 8080. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcUgtGDTAYtYog4GUtUAbrmKmuPfmCfr17ZDwyNA9DZc993RTB9GNpy-oe5QwjkXe-AT-rNBqMApoqNdAz3mCnIeD_6f1cb1Cdi7KoGPC5zfYTqFGNdUpGqCXajXLw13FC_FitY0QY21ast-JWJB7bvvI0?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe haven’t defined any HTTP handlers yet, which is why the routes function is currently empty. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s take care of that now.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXd536HFvV6I24YHPgDX5nUXA72tL82awLLHyAAsbz-urdmjwkU4YokanwaxpQ-q4MM4h4SGFOEchOFC1ZeZycgIf9YABnFovAxUA3SgLlLZSWaLmwCxXDJSPwh2A4n3leE1xgKTcjvzCrZwGUNPmAwbgCI?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eHTTP handlers\u003c/h3\u003e\n\n\n\n\u003cp\u003eCreate a new file called \u003ccode\u003econtroller.go\u003c/code\u003e under the project root. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfdowRVbvWtUohs8H5757AuP8Mc_SSpf9jWlJCpvrMediNw1mVKD1W72WlvA3TjbP3Sa4fCi5Sdg5Uq_OMu_fitiBURip6TAL9X0EPJN9UlHeGRek4rkLHHEwa3edMNcbvYhijnaETMdEmfrFa5kWkKeDCZ?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce you’ve created the file, go ahead and open \u003ccode\u003emodel.go\u003c/code\u003e and add the following struct:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcGKm4ZrW5JUA8a12e96CJlJ86VzuX4jjFsRs2-EjTYqY5MRkjwIPDSWjQdydsyrEne5VTp6DJQF4fj_FaRqWUcZEWk_JV64wX0vDUtb5oVLRdnvNmuiWTW0ZhQvCez3ei1s3eseosPDFO__boVYN9g1yPb?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eUserParam\u003c/code\u003e struct serves as a data transfer object (DTO) specifically for input handling, often seen in web APIs or web forms. \u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eSeparation of Concerns:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eUser\u003c/code\u003e struct represents the data structure of a user entity in the system, which corresponds directly to the database schema. The \u003ccode\u003eUserParam\u003c/code\u003e struct is used for handling input validation and data transfer, particularly from HTTP requests.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eSecurity:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eYou’ll have better control over your data by separating fields into two categories: (1) information received from requests (like user input), and (2) information stored in the database. This gives you control over what data is exposed, enhances security by filtering out sensitive info, and ensures you only transfer necessary data between layers. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s go ahead and start implementing the HTTP handlers. \u003c/p\u003e\n\n\n\n\u003cp\u003eHead back into the \u003ccode\u003econtroller.go\u003c/code\u003e file.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfDdCsNQVI70j7PIoQ5PQE65pLb_15wCtcoFPYpJzWh-5vVOKD-5TUyT9N8osLR_DS7CsCqKKKHlISnq2n_a_8AjNwNQFfVzOlILeJOwvvvESw2ysDXuBV6EO4Nefbf7thf68xLFRiZ7QzzIK_6K3tb58w?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s break it down step-by-step. We are going to implement the basic CRUD (Create, Read, Update, and Delete) operations on the \u003ccode\u003eUser\u003c/code\u003e model. \u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eAdd User\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eTo create a new user and add it to the database.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcLCP6Td-IHb3Ric-QT4L7IglX4_4LCl8ubXAzzsnsS2K1TxmZvuBZe2lOwzqTHFbD2omEvwct4na-bCfhMbGVjCYoN6CQAO1ZXZbOMFIfYk5w8y8RV2Mdb6xPM-947_DFYG_fnYCtf-888qr9JGkEkK-EL?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eList Users\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eTo list all users from the database.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcYzjIcspeefaoprgTWDVFHiqVg2xn3xg8jNhxXdI6takWk1PrGH3NHd_SU-5PAIN9QxmIGtylMkiPs3iVqwrU7GYU2yI3iZ7PHRcCuKD9Y25p3cum_8XBw3wh_rj2e7jzByivcWvYtRnpR1qJzaVT65c1Q?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eUpdate User\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eTo update an existing user’s details.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfzCm69OovXsvXnNtEK4O3xBkBWD_E2nc5Paq2oFq9R1lUd2qG2rgNPJ9xO24GKmdYNAJEau5NAZYwUoJ5m9OmzWWd5cgxEIstibpR_YBff6fgQVKVGuCn9X_X1O94-Ri86uBs8xjcna2cJUqFCXorbhrd8?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eDelete User\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eTo delete an existing user.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeXXG97JVXFk2wGbOshSb04p1Wqj7jz1xHNHSlmDcKsJMoR10FFM145KtWd-c-plDKp7PQXL5nKd3fEjAmdwnYPvc_AwbHNf16FWMcJen2FCK3AtBuKx0uU_LPd9fHho6pXr3-9ZkbEqsjPnFgMoJqc6S4?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, it’s time to update the routes. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeCRp_XofLtNOalDVe9rULxyAs0VfusqXSvZi_V1OHk8N2PAGXamOOC7tcFDoXdeL1cZL-7nVH2cdgly4orGpOJ3llnKwZMVwGCNAvYaUcibMw7-T-xOwFtGD7cGVY7V4k8wZccIDk7rp9aWPr-zZ4AnMLt?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this function, we’ll set up various kinds of routes (\u003ccode\u003eGET\u003c/code\u003e, \u003ccode\u003ePOST\u003c/code\u003e, \u003ccode\u003ePUT\u003c/code\u003e and \u003ccode\u003eDELETE\u003c/code\u003e) to handle requests.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdv6T4W3L5w26V9B6sTKmxT39F2jPl47Ce8hyk55p6rjekrtXBiSZ0UJV87-57rj_f8oQ4iKdZTjNlxRSpCN7SVAQfTOvpsXmOquLrvdPjiGC9xC-oCQUFRIGCKb-nSWpMKbrLQfXm9GA4MpGGmere0fPsa?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eRunning the application\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe’re almost done! It’s time to define the entry point of the application where we can initialize the database, run migrations, and start the server.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new file called \u003ccode\u003emain.go\u003c/code\u003e under the project root.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfnXFGSX7lWM0kkFct5YXGox-yWXz7W09FydPakVMRxXhvpa107sAzT89wiql5nNBT7qgpcGgk_JEcQJrTgytRAcp7qgS9lLw3ESpA6tw94_li39nIIfepOFhBbRqKVAxyY2wJVJngN6A0dG6zpk95qGkw?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs you can see from the code below, we are initializing the database client, running database migration, and starting up the server. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcoSNvOt2G9k1AVIaKxI-N_jI2HZjR-yJQbCyDcT0X-EpdzUVwEhWw_atg7MAmQz4htjD_TRuWGkcfENF5hvAYTA8mPFuuGyp8pppZqO-eOPk6PfiJYzW9yPUEX46jxAvz2cZHA8kw8v2Ac8x3lHi-t9Vsr?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eNow, it’s time to start the server. Before that, make sure you are running a local instance of \u003ca href=\"https://www.postgresql.org/docs/current/tutorial-install.html\" target=\"_blank\" rel=\"noopener\"\u003ePostgres\u003c/a\u003e. I will use Docker to spin up a postgres container.\u003c/p\u003e\n\n\n\n\u003cp\u003eRun the following command in the Terminal:\u003c/p\u003e\n\n\n\n\u003cpre\u003edocker run --name goland-k8s-demo -p 5432:5432 -e POSTGRES_PASSWORD=********** -d postgres\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdwH9rU1eZd0E00EUp9uCVgVJ1RfI_-yz1r4R91GyP45PN-DdzqOx056D2rrme1Wsa2IOYTRffjCZ2uJ1E_45XZ2SIzdomgJ2pi8zM0pFixk6cSCAF9clUZeZe55IYSpRc5WIFp9HqqGzB4XicY2qCC7-0G?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the container is up and running, go ahead and modify the \u003ca href=\"https://www.jetbrains.com/help/go/run-debug-configuration.html\" target=\"_blank\" rel=\"noopener\"\u003eRun Configuration\u003c/a\u003e. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdvzMGQ-IkAjvbKBO4qmh0txMeh8RHL5lfuRbut3Lio9oWudC31W86J2Tboeh6H6tayMVW4UgF6dNDlpn5GEf2or94NzoH9KKN3Un08T0DVoHL6wnkDn3eiDLeVMYeV4voMol0I9AElaR5xWta1AMJOq2E?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAdd these variables to the \u003cem\u003eEnvironment\u003c/em\u003e field, as shown in the image below:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDB_HOST\u003c/li\u003e\n\n\n\n\u003cli\u003eDB_USERNAME\u003c/li\u003e\n\n\n\n\u003cli\u003eDB_PASSWORD\u003c/li\u003e\n\n\n\n\u003cli\u003eDB_NAME\u003c/li\u003e\n\n\n\n\u003cli\u003eDB_PORT\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdK4UZQ6WpXO_Pkx0RPjX5j0i-QbaxZdOA1qIA9A-FWU48uuAwENypjKCM8EvvhHAnaLvjfIM4M7ct0i6jxK4uk-SZqK31vNQwMKvQVXoktovk2RMk641q7qwUsTgDmxe_9s209mUmDKcT4Ow9ISmYX7DwQ?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdfLOYRRbVJl5vEv_XCbUAasuMfzYLnPLfzrDj-IBPfm9ZwUqgEY9DaM96GjvbkKkk8uv4eOWWnmIXzKCrIA1XuJujvn0St7BJ56Afnbtt_4Rm9n6vKK-CNyOnfj5WzS8V1cGg1WIHiJshdBEgt5-P05go?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce done, apply the changes.\u003c/p\u003e\n\n\n\n\u003cp\u003eClick the play icon to start the application. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeYzaMNRSqOoM8EoM-nA2m-Uvzph8Gh7uf0pzyjReZHNgj6VPfwJxSVreu4Qxvgd9QDMcYr-v8XPYcKjjak4nTciletvuFjYq6Pj31X0xHEuPOs8oAkeHSRXv2lE539XnadtKnuNRcsLgzyidRU1YMDciZ8?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe03T46EgH7BMYRhTHdCVsJTjCNRTT76UGNI5rh2s8GAUuSNPi3hHBTVuydnDjD3OFahnQcU5MBZ9lO-lLVpv9jTQhodGqK8hrL9wSH6L0iEdgix-hcDeaaMP43JhCJwu4OYTabU1cm0F9o0Fqj5bqZGUdl?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the application is running, navigate to \u003cem\u003ehttp-client | apis.http\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can play around with the REST APIs directly from the IDE itself. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfeZ8XYjicRWiXpy5ypKb64_mm7XFjLpHddzpJSA0b_k5KPNGeSDCaeK8a4FqD514jDp-udpDBU5bmXByrmSbzWPBq8ORXSW1J1TmFb5nqPloQ12jJ_9iFi32T9dWXUFRMv-lYLBdH7LIHzxvUpNvZx-P6D?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eDiving into K8s\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow that we have developed the entire application,  it’s time to deploy the application inside the Kubernetes cluster. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe process starts with creating the Dockerfile.\u003c/p\u003e\n\n\n\n\u003ch3\u003eDockerfile\u003c/h3\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://docs.docker.com/reference/dockerfile/\" target=\"_blank\" rel=\"noopener\"\u003eDockerfile\u003c/a\u003e is a text document that contains a set of instructions for building a Docker image. It defines how the image should be constructed, including the base image to use, the files to include, and any commands to run during the build process.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new file under project root and name it “Dockerfile”.\u003c/p\u003e\n\n\n\n\u003cp\u003eSimply follow the steps I’ve outlined to build the Docker image. I’ll walk you through it step by step.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfmy90UN_iJO01TkGC5lGmWzCYIlnJZ6qPVQvnsNh9doFZqL_Qvrmlz4tf47FCnK3Nm7PePtg2EIFNGodGzSOAtfJcPeBqJ4eddzs63dlLlPoy5Gj2wU4eFcnCZ_auU6ilYjjAhQ8_shjekQT--11VZThCG?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfxxOi0BLW_mZftPgg5wQg4iPUpLNqjW7yLiBAJuv0vOFJ7aM2JKjDMYL4I9XXcd_NzJhp7441SUnPStVD9YvKt4EmJQIONReBxR9zP62le_NxTEsXpthyM0CCCx3Qt5DHHbHXdRpOYlQEADQ6jwKH9DMhT?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eFROM golang:1.23-alpine AS builder\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eStarts with \u003ccode\u003egolang:1.23-alpine\u003c/code\u003e as the base image and labels the stage as \u003ccode\u003ebuilder\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eWORKDIR /app\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eSet the working directory to \u003ccode\u003e/app\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eCOPY . .\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eCopies the entire current directory (\u003ccode\u003e.\u003c/code\u003e) into the \u003ccode\u003e/app\u003c/code\u003e directory.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eRUN CGO_ENABLED=0 GOOS=linux go build -o go_k8s\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eRuns the Go build command to compile the application. \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCGO_ENABLED=0\u003c/code\u003e disables \u003ca href=\"https://pkg.go.dev/cmd/cgo\" target=\"_blank\" rel=\"noopener\"\u003eCGO\u003c/a\u003e (CGO enables the creation of Go packages that call C code).\u003c/li\u003e\n\n\n\n\u003cli\u003e \u003ccode\u003eGOOS=linux\u003c/code\u003e sets the target OS to Linux. \u003c/li\u003e\n\n\n\n\u003cli\u003eThe output binary is named \u003ccode\u003ego_k8s\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eFROM gcr.io/distroless/base\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eUses a minimal \u003ccode\u003edistroless\u003c/code\u003e base image for the final container, focusing on security by excluding unnecessary components. To learn more about distroless images, check \u003ca href=\"https://github.com/GoogleContainerTools/distroless\" target=\"_blank\" rel=\"noopener\"\u003ethis\u003c/a\u003e out. \u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eWORKDIR /app\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eSets the working directory to \u003ccode\u003e/app\u003c/code\u003e in the final stage.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eCOPY --from=builder /app/go_k8s .\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eCopies the \u003ccode\u003ego_k8s\u003c/code\u003e binary from the \u003ccode\u003e/app\u003c/code\u003e directory of the builder stage into the \u003ccode\u003e/app\u003c/code\u003e directory of the final image.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eCMD [\u0026#34;./go_k8s\u0026#34;]\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eSets the command to run when the container starts, which is the \u003ccode\u003ego_k8s\u003c/code\u003e binary.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe final image is kept as small and secure as possible, containing only the Go application binary without any unnecessary build tools or dependencies.\u003c/p\u003e\n\n\n\n\u003cp\u003eGo ahead and build the Docker image. \u003c/p\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eRun ‘Dockerfile’.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eNote: Before running, make sure the Docker daemon is running in the background. For this tutorial we are going to be using \u003ca href=\"https://www.docker.com/products/docker-desktop/\" target=\"_blank\" rel=\"noopener\"\u003eDocker Desktop\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfRAg3OEcig7iBc2XFwmu8iYMxvqwRowLDzSJJGptmcUgbXJhrxJRMkUe234g23LkUgs8NQ0YbPf85LqCirLj6Vx47fV4wKsghIrn65fl7mTvYo1I8snid_pp6kbnv2vybE2c8vmjX_KsPc_PeWLonZ37M?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the image is successfully built, push the image to the Docker registry.\u003c/p\u003e\n\n\n\n\u003cp\u003eRight-click the image tag and select \u003cem\u003eEdit Configuration\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfsVn49fHboN0sOxsQYny4MLx_utBSWdov6pEB6JRR1TpRDe3V7bBBLM9rIg_nrhrUswljWh_1fNZV6pgJcSNx9Vv767kvr2pq4LBbOB0qRlNeliHqMrPxFGYPYVDxLl7TBGZGzEu50SOyXX-dFobXMXdtL?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eProvide the image tag and apply the changes.\u003c/p\u003e\n\n\n\n\u003cp\u003eNote:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBefore pushing, make sure to change the image tag based on the Docker repository which you have created in \u003ca href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\"\u003eDockerHub\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe image tag should follow the format \u003ccode\u003e\u0026lt;hub-user\u0026gt;/\u0026lt;repo-name\u0026gt;[:\u0026lt;tag\u0026gt;]\u003c/code\u003e. Follow the steps to create \u003ca href=\"https://docs.docker.com/docker-hub/repos/create/\" target=\"_blank\" rel=\"noopener\"\u003erepositories\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIn this example, the tag \u003ccode\u003emukulmantosh/go_k8s:1.0\u003c/code\u003e is for demonstration only and may change based on your account type. Here, \u003ccode\u003emukulmantosh\u003c/code\u003e represents the user, while \u003ccode\u003ego_k8s\u003c/code\u003e is the repository name and \u003ccode\u003e1.0\u003c/code\u003e is the specified tag.\u003cbr/\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdG9gU3HhHpdDSqYwWO3AWGvWMCoSAWucqy3XDbClvBZaSBLO928KI0HqmA0ndWE13JrsXUgnzQSh994Uzr4ndBIjADqiY8ndXQ3riDFwcyoTk3Yfql4teypc-nIXbWbHxXbPNha_wm9KezOrVfQh1sG5s?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eMake sure to re-run the build process. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXerB5km4c37rBP78ajWouxY4QzzrgfF8nEe4It128HhTEPLxPldtJhdSSjLVeDl-b3-aitiJ-lmp0N28kQxpz7d8a0oFkQK0Q5aWGatZwgUpiL29zs70dEM3XcwjbrVxnFQmI6e6QAFdOvwZBnsmi6ZuH6j?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can see that the image tag has been applied. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdQcxnwe-vAvnHpGBuxQP091YCIvuKXgo4DgB_bcXBfbIX9IoPXG9EvqSbhpzlQCYrr5mqTA02FSFdhVSy1Tj05Tug-PofpS8nYffAFbG3YnCwy47gVw03cxmvCweaexxgDmFDQQ6O8qtKvKYrE1uxvEXim?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIt’s time to push the image. \u003c/p\u003e\n\n\n\n\u003cp\u003eRight-click on the image tag, then select \u003cem\u003ePush Image\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfCANtYXPN_tSDnI1ac-b9ZIEVjCra9Kgn3e7KdvCyl8SrmTYoJNsLIuR2x2yyBfpKx6PV3LO6gW2pJAialbVbuiDLh6MnORWY1vw4bKMIY0-PurNCJn8SfCyZdfLMckvMeX4GZio4oU37vEqg7L2tmCyg?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eClick \u003cem\u003eAdd\u003c/em\u003e and provide your Docker registry information.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfJEDwK6HfcjcbJL543ZUB77J3QDR-ovW8cFWAuAAJrnWmjHHpfIrrGPmhKJR4uQk8RrxhEK0D0PtC4eFTSlpbB8HjISxYGAeUlyXaMeQ729isTpFJBbGwDn6IMXUQSOKTT8dPnGBL38-T0xOch9GA2qB96?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeWTb56QRmhFycGWHHv6yADQUhnbQd55-bJJadBtmjkanPG5ShD7b0kMqUD3tW12FZ0poLGEix-sxcdR8KagILKvuWkGmsKyNSkOL4UaetC_at7-eajCfnWqQuUY6gIPQlSJlCG7EaA8i9JtmowQtFgXEvT?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce successfully authenticated, click \u003cem\u003eOK\u003c/em\u003e to push the image.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcmic6L7PrNOZ8MZHLOox8E3Wl_jTvlKND3PcqiOhdUKHJJ241gtN12QOpglElyFHsIhcypqgacbBJ8Vwr7d3Zqo6oJ1yMGz96n_gh8SYaJLEnskcb7nRo7Y4jVOn4TSXjM78NBI3NqSBiur29SlG5Qh66t?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce the image is successfully pushed, you can observe the changes in DockerHub. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcKtKkx_VSfLmAJq2rbMHTza5QcRfL8DM6-0_wQwf4KX9L23t0t7JeFSHnDW-LZsADxvhmuAV6efUTIpyqOT_miXxr9G0gkVnopvDuscuuDv7YlBzz-kmaSu5eUKYqYsuZXUwRBhpYM0VH75IWu?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWell, the image is built and pushed. Now it’s time to work on the second part – writing the Kubernetes YAML files. \u003c/p\u003e\n\n\n\n\u003ch3\u003eWriting K8s manifests\u003c/h3\u003e\n\n\n\n\u003cp\u003eThis part of the tutorial covers how to deploy applications to local Kubernetes clusters.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this tutorial, we have utilized Docker Desktop, though you can also opt for \u003ca href=\"https://minikube.sigs.k8s.io/docs/\" target=\"_blank\" rel=\"noopener\"\u003eMinikube\u003c/a\u003e or \u003ca href=\"https://kind.sigs.k8s.io/\" target=\"_blank\" rel=\"noopener\"\u003eKind\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you’ve chosen Docker Desktop as your preferred platform for running Kubernetes, be sure to enable Kubernetes in the settings by clicking the \u003cem\u003eEnable Kubernetes\u003c/em\u003e checkbox.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdji9YwtTdr2c6Splr-Rq2ZLcWY_8m4lDYR3sd3CPukZLqocKqiw0wPX51y9wkQtFm8ilJoDdSd7yEDRQm-Rr-qFDnPyODbBFL_mOWzyKo2-FpvMRwcuSsSKlGmQ4blWVqccC2si_40ckafait2cCqUQWkX?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOnce Kubernetes is up and running, it’s time to create a namespace.\u003c/p\u003e\n\n\n\n\u003ch3\u003eWhat is a namespace?\u003c/h3\u003e\n\n\n\n\u003cp\u003eIn Kubernetes, a \u003ca href=\"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/\" target=\"_blank\" rel=\"noopener\"\u003enamespace\u003c/a\u003e is a logical partitioning of the cluster that allows you to divide resources and organize them into groups. Namespaces enable multiple teams or projects to share the same cluster while maintaining isolation and avoiding naming conflicts.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1100\" height=\"355\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/namespace.webp\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSource: \u003cem\u003ebelowthemalt.com\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eBegin by creating a directory called \u003ccode\u003ek8s\u003c/code\u003e in the root of your project.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, create a new file and name it \u003ccode\u003ens.yaml\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: A Kubernetes manifest is typically written in YAML or JSON format and outlines various parameters for the resource, including its type, metadata, and specifications.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXc2jrG9PCtguS3_Fw-UgNG2DB1wAoBQV30Dt712KemelSdv7YG2yEu3sYKfX1j-obgOVZYdb-NJe07Nu8Sw6hYfbuk-ihFaJ4bbGtjSBkkFyo1AES3ayyOG416ZlGBla8oCITJzd1K_bmSJ_kAn0FPK7wdP?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis YAML file would create a namespace named \u003ccode\u003ego-k8s-demo\u003c/code\u003e in your Kubernetes cluster.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s break it down.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eapiVersion: v1\u003c/code\u003e\u003c/strong\u003e: This specifies the API version of the Kubernetes resource. In this case, v1 indicates that the resource is using version 1 of the Kubernetes API.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ekind: Namespace\u003c/code\u003e\u003c/strong\u003e: This indicates the type of Kubernetes resource being defined. It can be Deployment, Service, etc.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003emetadata\u003c/code\u003e\u003c/strong\u003e: This section holds metadata about the Kubernetes resource. Metadata usually includes details like the name, labels, and annotations.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you type the following command in the Terminal, it will show you lists of the API resources available in the Kubernetes cluster. \u003c/p\u003e\n\n\n\n\u003cpre\u003ekubectl api-resources\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXd8JU7ujaUvWAQktoIwRrq7cWEGVlJ4Y_5UfDdv1gLbcCjlWsyiPSIzhBQGM16zEcaipnafhx_m5YKG_Aw0ALhOOXXnd0oPuLnqQrlSgz1F5lESAgw4D8VUcsAS7xXALjben_pnM5sFrMkC7rF1n3MzYgJo?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eOkay – you’ve created the YAML file. Now it’s time to execute it. \u003c/p\u003e\n\n\n\n\u003cp\u003eThere are two ways you can create a namespace:\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you prefer using the Terminal, you can run this command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ekubectl create ns go-k8s-demo\u003c/pre\u003e\n\n\n\n\u003cp\u003eOr, you can apply a file by running this command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ecd k8s\nkubectl apply -f ns.yaml\u003c/pre\u003e\n\n\n\n\u003cp\u003eBoth methods will create the same namespace.\u003c/p\u003e\n\n\n\n\u003ch3\u003eCreating a namespace with GoLand\u003c/h3\u003e\n\n\n\n\u003cp\u003eYou also have the option of doing this in GoLand. Yes, you read that right, you can play with your Kubernetes \u003ca href=\"https://www.jetbrains.com/help/go/kubernetes.html\" target=\"_blank\" rel=\"noopener\"\u003eclusters\u003c/a\u003e directly from the GoLand IDE. \u003c/p\u003e\n\n\n\n\u003cp\u003eAs a side note, if you’re using GoLand 2024.2 or later, the Kubernetes plugin is already bundled with the IDE, so you don’t need to install it separately.\u003c/p\u003e\n\n\n\n\u003cp\u003eOpen the \u003ca href=\"https://www.jetbrains.com/help/go/services-tool-window.html\" target=\"_blank\" rel=\"noopener\"\u003e\u003cem\u003eService\u003c/em\u003e tool window\u003c/a\u003e  by going to \u003cem\u003eView | Tool Windows | Services\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdASRlLRCWkeGbXe45dOS4unUOSIsI1s4iz1bg1H5I8HLIAoBZQ5meIaYY-NwWQf8KyWG_K_7Qq6mnSh01g5jO8CA8YuNde8Q_N-AwcrWkvINWWxWxaodgzfBqAi4dPJWtaSGpfMUCUIMwbh-OoFSUMpAxE?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eRight-click on \u003cem\u003eKubernetes | Add Clusters | From Default Directory.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcBgAAb_XBbWtmIZVEbj0ha_Ha1j8f1KV8sQSDBEW0lb0YddE-7dE8mMce9Sm1nYyjZhRKy5mueN3pKICtnZaW0fE947d7A1zW7_F_YZtHHZPZLBK7hn5oElVf2zdwrBWBsKfBAkQP-D_xZ4jo3LSBMz5HY?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSelect \u003cem\u003edocker-desktop\u003c/em\u003e and click \u003cem\u003eAdd Clusters\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfAp-DjDjWPQ_gEo27QWcodvQPZKq0hffdbeh-O2Aqoo0hCJLBw7KmZDVHZG7Fp2hpFXfE3mfGsuO1CTuw8Vq6aPzIHVTwcaOHainS685rsDQ1n9_uYD_6wr__tF2JUXbOibgtzoRWNiRJeF16-0xjW_8U?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou will see docker-desktop as your newly added cluster. Click the play icon to connect to it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfDrzvwlWjGjq9ZTFNQImLnZj9oVd9AU2x2Aqx4Jk8Ie3milAtm2pT0jFUJWAcRydtqixa8dG_k-7_b4RGjoCYVFqwXlNyzneZ4_FMaVkl0yX2kxRnhz4w9sNzGzuIsgmyV2ku7jb0QtwUfSszYYeg1NCrk?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe7ZlDcgjtBd8PnuQHEx23x2tqJaswlu3QhpXG-KNXRwHz9sS5Pi_f2u8i36aPdEaWwpCKcIknicROoXZAmg2y1wmAig2H5pdXkjuUdcMeCmPP34irTgaTvN93KoA9NKH_-6drfMzPtDFQT5LffrHtHFBqn?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eReturn to the YAML file and hover over the top right corner of the screen and click \u003cem\u003eApply to Cluster \u003c/em\u003eto set your cluster to docker-desktop.\u003c/p\u003e\n\n\n\n\u003cp\u003eOnce done, apply the changes.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdggNgnTAVfZXg2BxAmaI4KjGBIJHiSuwXxfpMq8nTJ-E4I0qwZ-JHf57IORqjdFggCFW_pU76Qp633Ct8ySpOe6HflC2G6XmepH1viNJ0fggCzETWMpbTZe9hkT-hUEJEVE_cc7yY_JXyRMg31XacQQ1IE?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe namespace is successfully created. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXfK2_GCFvXOYNkWZ6AoF0R12LIb04mZ7o1L4RpeZEB3Odhm2D2flsNudV3ue7iZK3Qf0Z7QuTpYgKhAC4mGZmDccRzJCQR6Faon1W3oBB49OM8iSx3RkrlIYil9FC55PIUx8RPjukmt1Wxhum2qFeYUyuna?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eWe will now switch to the newly created namespace to easily view the applications running within it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXelXpQWMAmreJp8dCDFdxvGX4LOT-d5jwZauJjkDYn-ZunGuq9pGzNxRSnIrBCRZfnJAiEBgteJ3uBJwxWW0Jzg841XdHf8Pj5KkgzFsElQ1H0x3-u5nMgNkmokrQCWPkTgq7sQWPnzxpi4qbZc8f09Fh0?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdrFYbt57lGUhQJWJLu0ToGQN7db_uVJaMSrngiVM-uwpGp29rkPo1fP_4pC4y0u3Fb26DbqeI_kbXhsYKc8O_0Jb_w_VUxio2_Lhu_pMNX1wMN9_SEZ0GZYH0nieop1YFEExk3x9GfwwAJ72oCSbv1ATY?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou might be asking, “This works with a local cluster, but what about connecting to an external one?” Good news! You can do that as well.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdHT3A9-wjYDKNtJdlI1ICLeX-Ukn82hSX8x_iIEbfSrrCAVSKS7HmGxI1AFqnvr7A2_JQe1AyC-AnBMTj26FEIqksFwF7EumeQl2ix4mqofMW2qeOZcHkjrhcYaRjKE43OolvwETk_ppoSsL5D8YLaw_RD?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can also modify the paths for the kubectl and helm executables. Additionally, you have the option to customize Kubernetes configuration files at either the global or project \u003ca href=\"https://www.jetbrains.com/help/go/kubernetes.html#multiple-kubeconfig\" target=\"_blank\" rel=\"noopener\"\u003elevel\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcftpSapD2tODPlODnlMcMsUrJhKYmB-832hi-19TSDLx9u8BJgLMl_FRmtZDPF9PpGTRqm5V5tNfRItTT-x0MamlfiPoDaSmwhJt0ZT2I71EWOnQsrjDl9HvipkXBEEM1qETrh4ugAMkMFjmHvX-QF5TX9?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcEGHdqJ2JttQE98ol8heubZjJQQZi4c3t7oiczEfk2tAc9_qK1Ms7j7YCqo8jOWxvLtb69jj8hGcNly0t_I1aNhBX3H_5F1mQ4DLxzIXPgqcKeqf87Ikuqs2BGQU898Sp4lBH96IfUcFzEImprGrku9d4?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eDatabase and K8s\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe namespace has been created. Now let’s start working on the database.\u003c/p\u003e\n\n\n\n\u003ch4\u003ePersistentVolume\u003c/h4\u003e\n\n\n\n\u003cp\u003eWe are going to create a \u003ca href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/\" target=\"_blank\" rel=\"noopener\"\u003epersistent volume\u003c/a\u003e. A PersistentVolume (PV) in Kubernetes provides storage for your application’s pods. Think of it as a storage space that exists independently of any specific application.\u003c/p\u003e\n\n\n\n\u003cp\u003eUnlike regular storage that disappears when an application stops, a PersistentVolume retains the data, making it suitable for applications that need to save files or databases.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new folder called \u003ccode\u003edb\u003c/code\u003e in the project root, and then add a new file named \u003ccode\u003epv.yaml\u003c/code\u003e inside it.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeQDowMgudS0tN7B1u9yM8Ps3TTGXea6lkonge0-uvjgW6psK35GjCCxMd4IbaRnP7CeODrr5LtRZiv9YdFsREcJqAf2vaKEqu9e_ESGCKhHMcnNX9iURWdrTlW_H93ad3unzcpq5pf0yJV0LaC6xUq7fA?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis YAML configuration defines a \u003ccode\u003ePersistentVolume\u003c/code\u003e named \u003ccode\u003epostgres-pv\u003c/code\u003e with 1 GB of storage. It is associated with the \u003ccode\u003epostgres\u003c/code\u003e application and can be accessed as read-write by one node at a time. The volume is stored locally on the host at the path \u003ccode\u003e/data/db\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch4\u003ePersistentVolumeClaim\u003c/h4\u003e\n\n\n\n\u003cp\u003eCreate a new file called \u003ccode\u003epvc.yaml\u003c/code\u003e under \u003ccode\u003edb\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim\" target=\"_blank\" rel=\"noopener\"\u003ePersistentVolumeClaim\u003c/a\u003e (PVC) in Kubernetes is a request for storage by a user or application. It allows you to specify how much storage you need and what characteristics it should have, such as access modes (like read/write).\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXct7G2hx6pfBI8cY6FHXnvkUF9yZ30avMWUqlDL4NlcanuwxsZ3bYfX_X3_hlutQ0J976hyq_s7B8ZPhmcInbY1EP-2VcfaZPyCKKLmQVHNyl9OQ2knaYVqxzFilyJsTIhF64gCS9tYwgyipP0HrPtHkexX?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this YAML configuration we are creating a PVC in the \u003ccode\u003ego-k8s-demo\u003c/code\u003e namespace requesting 1 GiB of storage with a \u003ccode\u003eReadWriteOnce\u003c/code\u003e access mode using the \u003ccode\u003emanual\u003c/code\u003e storage class.\u003c/p\u003e\n\n\n\n\u003ch4\u003eConfigMap\u003c/h4\u003e\n\n\n\n\u003cp\u003eCreate a new file \u003ccode\u003ecm.yaml\u003c/code\u003e under \u003ccode\u003edb\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://kubernetes.io/docs/concepts/configuration/configmap/\" target=\"_blank\" rel=\"noopener\"\u003eConfigMap\u003c/a\u003e in Kubernetes is a resource used to store configuration data in a key-value format. It allows you to separate configuration from application code, making it easier to manage and modify settings without needing to rebuild your application.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXe_7ymPcLUB5U43RUtEocotRcOyhRaWBki32TLN4z6wBMm9EDigz2ekiuGqDdBAxkEGGD3BcWQ8G_woYQRFwPSU6xS_3IEg5O1Hdh5mUPUmfQ8sSJpr4z-hS5X4UKpDD_2KXj0QNeA9KTs6vof_TsWyNAud?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch4\u003eDeployment\u003c/h4\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\" target=\"_blank\" rel=\"noopener\"\u003eDeployment\u003c/a\u003e in Kubernetes is a resource used to manage and orchestrate the deployment of applications. It allows you to define how many instances of your application (called Pods) you want to run, and it ensures that they are running as expected.\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new file \u003ccode\u003edeploy.yaml\u003c/code\u003e under \u003ccode\u003edb\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXeUFeCdvpbDJK8AdH2r4ATePHuuVuuDv0LHNTLrAoQmQ3-I8AtGYlDWDCtOdOtP2-qy_fAwUQHyhGx5br48AuLZmt-RNJzOxSvGa8BM6fA0a7XkEJCwdPuVNcKAFU-bSRV4WbzKzIQ9reF9Bl8s8m307qqJ?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThis YAML file defines a deployment of a single PostgreSQL container running version 17.0, which exposes port 5432 and runs only one instance. It loads environment variables from a \u003ccode\u003eConfigMap\u003c/code\u003e and uses a \u003ccode\u003ePersistentVolume\u003c/code\u003e to store data. \u003c/p\u003e\n\n\n\n\u003ch4\u003eService\u003c/h4\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://kubernetes.io/docs/concepts/services-networking/service/\" target=\"_blank\" rel=\"noopener\"\u003eService\u003c/a\u003e in Kubernetes is an abstraction that defines a logical set of pods and a way to access them. It provides a stable endpoint for your applications, making it easier to communicate with groups of pods.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdpBp6StvtyQDkYxFBKAYJosdo2sZfzdq4ESWcc2Do1omrxIvREfxWsao3JeUT4L8XeZwZCqdFdzHAa5twRYyyyrLjo4vBXAbpUDu1wgs_VJY4--Oqi0B4b41f_XF1SN2Uy7tOTycYGJPr15WUaCyNgk5Q?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eSource: \u003cem\u003ekubernetes.io\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new file \u003ccode\u003esvc.yaml\u003c/code\u003e under \u003ccode\u003edb\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcE1FqtzBj9dwblVzkVF0fd7jh3pTmchm2XVrkN8VVSokZNnH81X1P8VR_X0qFexMUTc86xp4vTuO7AOqqdSxz60vw0HOxAAEoWr52lVV167NoDkpYQ9-AnKr4LNdoXKVSijiR_O13GjhkR_YiH-1N_YUwH?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this YAML file we have defined a Kubernetes Service named \u003ccode\u003epostgres-service\u003c/code\u003e. The Service exposes port 5432 and routes traffic to the pods labeled with \u003ccode\u003eapp: postgres-db\u003c/code\u003e, so it will allow other applications within the cluster to connect to the database.\u003c/p\u003e\n\n\n\n\u003ch4\u003eLaunching DB\u003c/h4\u003e\n\n\n\n\u003cp\u003eWe now have all of the configuration files needed to start the database. Let’s execute them.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere are two methods to do this.\u003c/p\u003e\n\n\n\n\u003cp\u003eFirst, open the Terminal, navigate to the \u003ccode\u003edb\u003c/code\u003e directory, and run the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ecd db\nkubectl apply -f .\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo see the current status of your pods, you can run the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ekubectl get pods -n go-k8s-demo\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdUizRxGAfJBXKkojbP_ll9rwvWtvCWiKAzIS-aroKVpQsxK7NuM6A8hhZoGhGjGcTn0sNFHd1V3kA4ZiFCFwNhFzf3HCHV3jVJOXNAR3PbuBiUrNWWzRurJLJ6a9JH8aKmBx3_r1_88-U-ht4tc1Gx4eOj?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe second option is quite easy with GoLand. You don’t need to remember the commands – just the follow along with the video below:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/goland_k8s_1.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eApplication and K8s\u003c/h3\u003e\n\n\n\n\u003cp\u003eNow that the database is up and running, it’s time to prepare our backend application.\u003c/p\u003e\n\n\n\n\u003cp\u003eBegin by creating an \u003ccode\u003eapp\u003c/code\u003e folder inside the \u003ccode\u003ek8s\u003c/code\u003e directory.\u003c/p\u003e\n\n\n\n\u003ch4\u003eConfigMap\u003c/h4\u003e\n\n\n\n\u003cp\u003eCreate a new file called \u003ccode\u003ecm.yaml\u003c/code\u003e under \u003ccode\u003eapp\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eEnter the required database credentials.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eGrab the credentials from \u003ccode\u003edb/cm.yaml\u003c/code\u003e that you defined earlier when creating the database pod.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003epostgres-service\u003c/code\u003e under \u003ccode\u003eDB_HOST\u003c/code\u003e refers to the \u003ccode\u003edb/svc.yaml\u003c/code\u003e service we created earlier.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXexSfcnunENGdnpjr3xoOMLZUtlKJy6mBfVJF7u5TByDiIxaa_o8Z2LUQh2qp9nSosu4ac2Z0RXCEN5gCQRxH3pXjYrltX9RBT-Y5rwwkmGkjNwrdXMAMQW3rMG72dj1Cx5ndQv8qGFx5f55OlXS5qugKYg?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXdV7D4yJl_kkha9X1sJMtrTCiiWP_Xe-3eKMWuXdbTz2AUwZrS585E20tonemFV-Olsuw_DQiMlxeB7jDPkZOyF0FmoBXYG8mKiHxvLNbzA5xNFSYKKKQFkbXcGWMBHqmyOC3yNXCNC7Vi9Rv9lUVJn5KOg?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcR9qyhU6MiyDIT7ZW8y5gWlefgjT89AOWGgzXaK1fV9u06QmzgruvfC3DZXlvHE4RRnjzNExzoDnV4eAg3aHYFLsmKWmM-uvtYTkHTHkLh6Bekavf5KyEPOuRwBEl58gQ5aqGhbn8Ga_mL9frAZTS3ffE?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch4\u003eDeployment\u003c/h4\u003e\n\n\n\n\u003cp\u003eNow let’s move on to the deployment. \u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a new file called \u003ccode\u003edeploy.yaml\u003c/code\u003e under \u003ccode\u003eapp\u003c/code\u003e. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXevgfcDz4-lInG7z_4BO3oFDRyVlF7QdqwFitAh8ocXbOH05A8S4dxee-4f7bgrxq_fFv4kRM5iyfn9BO6xGedQvW7UOXe3eK4zh1gFt5wKblbBwTCzyBCxXjSgb4dYGBNyt-9z3w6NG5S6UjG8Z7NjA1yP?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"2080\" height=\"2604\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/deploy.yaml_.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eIn this YAML file we define a Kubernetes deployment that runs a single replica of a pod, which contains a single container using the \u003ccode\u003emukulmantosh/go_k8s:1.0\u003c/code\u003e image. The container exposes port 8080 and gets its environment variables from a \u003ccode\u003eConfigMap\u003c/code\u003e named \u003ccode\u003eapp-cm\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003ch4\u003eService\u003c/h4\u003e\n\n\n\n\u003cp\u003eNow let’s wrap up the last file. \u003c/p\u003e\n\n\n\n\u003cp\u003eCreate a file called \u003ccode\u003esvc.yaml\u003c/code\u003e under \u003ccode\u003eapp\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXesGbO34PVXCcZG6_HEPccSmwrBWjqE4OgqpEr2EaI7tfPpw6XO5cUndBM7KGyyhN7PDwUGvgkvXuUq4--DUmhjZ3Eew0AJOvyhSGGkbZvkHKPsy586keatOQ2lgATw9EvbAHlg_fytdpzO-kAdZ-KDIlvt?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eTo summarize, we set up a service named \u003ccode\u003eapp-service\u003c/code\u003e that allows external traffic to reach your application running in the cluster through port 30004. Requests received here are forwarded to port 8080 on the application pods.\u003c/p\u003e\n\n\n\n\u003ch2\u003eTesting\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow let’s deploy our application and start testing it out. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe process is going to be exactly the same as what we did for the database.\u003c/p\u003e\n\n\n\n\u003cp\u003eNavigate to the \u003ccode\u003eapp\u003c/code\u003e directory and run the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ecd app\nkubectl apply -f .\u003c/pre\u003e\n\n\n\n\u003cp\u003eAlternatively, you can do this in GoLand, which is quite easy and straightforward. \u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2024/11/goland_kubernetes_running_part2.mp4\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou can also check the status of your application by running the following command:\u003c/p\u003e\n\n\n\n\u003cpre\u003ekubectl get pods -n go-k8s-demo\u003c/pre\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcSEcrj33nwQf4hfv6QT8KPF375aHu1Pp0BTbMPSPbwwPXyMHC230G_3SRuMWj-vEXcuAq-mYqHPwv3qQXlOr6qMMnUfR-veEEkWGNOoBUOW1JbTzhwaSjjGGc_99im9_kLnsfot3X7tMNtmzLhFl_PbQIC?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s test out the application by sending an HTTP request.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXcIJcqpBl0oqePspHJtP_7CKbHsdPCcxWTpjfEmVvdCjxahLdA6UxLwgyeB2BUBquAyHCiC1Nk8bu6orvPAWtazvQgvib9NsmybkWGyRw3I707TTz7YKq3cJ3SODw3qNmYyvsqzDJOvFii_ntRlWIhOAVQ?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://lh7-rt.googleusercontent.com/docsz/AD_4nXduTIEWbee186g2PNiP90ipZSbDZSRlrXZFi-owt11fB3Hb7g8Z07JB5zXWzw8V_BNGbBjohvBDnKS6tlq2iwqA4X6INb6hb6_CUmOL3biasuzwIEu69pMGHAWsJOr17kpxNanBtGlThoWGm5nIyVST2XVS?key=cmOOFmren0-Yj2IOP4a1eg\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe application works!\u003c/p\u003e\n\n\n\n\u003cp\u003eThis was just a brief demonstration of how to use Kubernetes with Go, but there are many more possibilities to \u003ca href=\"https://www.jetbrains.com/help/go/kubernetes.html#create_resource_file\" target=\"_blank\" rel=\"noopener\"\u003eexplore\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2\u003eReferences\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf you already have a strong grasp of Kubernetes and want to learn how to deploy in a live cluster, take a look at my \u003ca href=\"https://medium.com/google-cloud/deploying-go-api-on-gke-google-cloud-9cec676bb3a6\" target=\"_blank\" rel=\"noopener\"\u003etutorial\u003c/a\u003e on deploying Go apps in Google Kubernetes Engine.\u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to GoLang Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "24 min read",
  "publishedTime": null,
  "modifiedTime": null
}
