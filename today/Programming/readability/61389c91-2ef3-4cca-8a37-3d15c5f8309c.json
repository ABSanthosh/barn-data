{
  "id": "61389c91-2ef3-4cca-8a37-3d15c5f8309c",
  "title": "Think About SQL MERGE in Terms of a RIGHT JOIN",
  "link": "https://blog.jooq.org/think-about-sql-merge-in-terms-of-a-right-join/",
  "description": "RIGHT JOIN is an esoteric feature in the SQL language, and hardly ever seen in the real world, because almost every RIGHT JOIN can just be expressed as an equivalent LEFT JOIN. The following two statements are equivalent: It’s not unreasonable to expect these two statements to produce the same execution plan on most RDBMS, … Continue reading Think About SQL MERGE in Terms of a RIGHT JOIN →",
  "author": "lukaseder",
  "published": "Thu, 13 Mar 2025 14:45:53 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "databricks",
    "firebird",
    "MERGE",
    "outer join",
    "PostgreSQL",
    "RIGHT JOIN",
    "SQL Server",
    "WHEN MATCHED",
    "WHEN NOT MATCHED",
    "WHEN NOT MATCHED BY SOURCE"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 9232,
  "excerpt": "A SQL MERGE statement performs actions based on a RIGHT JOIN between target and source tables",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "RIGHT JOIN is an esoteric feature in the SQL language, and hardly ever seen in the real world, because almost every RIGHT JOIN can just be expressed as an equivalent LEFT JOIN. The following two statements are equivalent: -- Popular SELECT c.first_name, c.last_name, p.amount FROM customer AS c LEFT JOIN payment AS p ON c.customer_id = p.customer_id -- Esoteric SELECT c.first_name, c.last_name, p.amount FROM payment AS p RIGHT JOIN customer AS c ON c.customer_id = p.customer_id It’s not unreasonable to expect these two statements to produce the same execution plan on most RDBMS, given that they’re logically equivalent. Since we’ve grown used to reading things from left to right and top to bottom, I don’t think RIGHT JOIN will become more popular any time soon. There is, however, one place in the SQL language where RIGHT JOIN is surprisingly ubiquitous! The MERGE statement Why is it a surprise? Because that place doesn’t use the same syntax for joining two tables. But that’s exactly what happens in the MERGE statement. Let’s look at the following MERGE statement that takes: A staging table (SOURCE table) to load data from An ordinary table (TARGET table) to store data into With a schema like this: CREATE TABLE book_to_book_store ( book_id BIGINT NOT NULL REFERENCES book, name TEXT NOT NULL REFERENCES book_store, stock INT NOT NULL, PRIMARY KEY (book_id, name) ); CREATE TABLE book_to_book_store_staging AS SELECT * FROM book_to_book_store WITH NO DATA; A query that could be typical of an ETL job: -- The target table MERGE INTO book_to_book_store AS t -- The source table USING book_to_book_store_staging AS s -- The RIGHT JOIN predicate ON t.book_id = s.book_id AND t.name = s.name -- The actions for each row, based on RIGHT JOIN matching WHEN MATCHED THEN UPDATE SET stock = s.stock WHEN NOT MATCHED THEN INSERT (book_id, name, stock) VALUES (s.book_id, s.name, s.stock); This is simply taking all the rows from the BOOK_TO_BOOK_STORE_STAGING table, and merges them into BOOK_TO_BOOK_STORE: If the row already exists (there’s a MATCH), then the STOCK is updated If the row doesn’t already exist (there’s no MATCH), then the row is inserted But we don’t use this source -\u003e target syntactic order, we first specify the target table BOOK_TO_BOOK_STORE, and then we RIGHT JOIN the BOOK_TO_BOOK_STORE_STAGING table to it. Think about it this way: SELECT * FROM book_to_book_store AS t RIGHT JOIN book_to_book_store_staging AS s ON t.book_id = s.book_id AND t.name = s.name And, if we think of a RIGHT JOIN not as a Venn diagram, but as a cartesian product as follows, then it can be seen easily what is done per MATCH or non-MATCH: |t.name |t.book_id|t.stock|s.name |s.book_id|s.stock||------------|---------|-------|------------|---------|-------|| | | |Faraway Land|1 |9 | \u003c-- NOT MATCHED|Faraway Land|2 |10 |Faraway Land|2 |12 | \u003c-- MATCHED|Faraway Land|3 |10 |Faraway Land|3 |5 | \u003c-- MATCHED| | | |Paper Trail |1 |1 | \u003c-- NOT MATCHED|Paper Trail |3 |2 |Paper Trail |3 |0 | \u003c-- MATCHED As always with a RIGHT JOIN, every row from right side of the join is matched with a matching row from the left side of the join, or an empty row of NULL values, if there’s no such match. After this MERGE, we want the resulting data to be updated as follows: |t.name |t.book_id|t.stock|s.name |s.book_id|s.stock||------------|---------|-------|------------|---------|-------||Faraway Land|1 |9 |Faraway Land|1 |9 | \u003c-- NOT MATCHED|Faraway Land|2 |12 |Faraway Land|2 |12 | \u003c-- MATCHED|Faraway Land|3 |5 |Faraway Land|3 |5 | \u003c-- MATCHED|Faraway Land|1 |1 |Paper Trail |1 |1 | \u003c-- NOT MATCHED|Paper Trail |3 |0 |Paper Trail |3 |0 | \u003c-- MATCHED This is how the MERGE statement works. Note, I said before that the JOIN is producing a cartesian product. Unlike with SELECT statements, however, there’s a limitation to MERGE where the cartesian product must not produce any duplicate matches per TARGET row, as the order of actions wouldn’t be defined if there were multiple SOURCE rows per TARGET row. Deleting rows MERGE is more powerful than just performing INSERT and UPDATE. It can also DELETE rows. Let’s assume that we want a staging table’s STOCK = 0 to mean that the row should be deleted, instead of the STOCK being set to 0. Then we can write: MERGE INTO book_to_book_store AS t USING book_to_book_store_staging AS s ON t.book_id = s.book_id AND t.name = s.name WHEN MATCHED AND s.stock = 0 THEN DELETE WHEN MATCHED THEN UPDATE SET stock = s.stock WHEN NOT MATCHED THEN INSERT (book_id, name, stock) VALUES (s.book_id, s.name, s.stock); Now, with the above staging data, we’ll remove the last row instead of updating it: |t.name |t.book_id|t.stock|s.name |s.book_id|s.stock||------------|---------|-------|------------|---------|-------||Faraway Land|1 |9 |Faraway Land|1 |9 | \u003c-- NOT MATCHED : INSERT|Faraway Land|2 |10 |Faraway Land|2 |12 | \u003c-- MATCHED : UPDATE|Faraway Land|3 |10 |Faraway Land|3 |5 | \u003c-- MATCHED : UPDATE|Paper Trail |1 |1 |Paper Trail |1 |1 | \u003c-- NOT MATCHED : INSERT| | | |Paper Trail |3 |0 | \u003c-- MATCHED : DELETE The RIGHT JOIN semantics is still the same, just the action is different now, depending on the additional AND clause of the WHEN MATCHED clause. Matching by source Some RDBMS support an even more powerful vendor specific variant of MERGE, which should be added to the IEC/ISO 9075 standard, in my opinion. The BY TARGET / BY SOURCE clause. Let’s have a look at the following statement: MERGE INTO book_to_book_store AS t USING book_to_book_store_staging AS s ON t.book_id = s.book_id AND t.name = s.name WHEN MATCHED THEN UPDATE SET stock = s.stock WHEN NOT MATCHED BY TARGET THEN INSERT (book_id, name, stock) VALUES (s.book_id, s.name, s.stock) WHEN NOT MATCHED BY SOURCE THEN DELETE; Adding a WHEN NOT MATCHED BY SOURCE clause has the simple effect of turning the RIGHT JOIN operation into a FULL JOIN operation. Think of it this way: SELECT * FROM book_to_book_store AS t FULL JOIN book_to_book_store_staging AS s ON t.book_id = s.book_id AND t.name = s.name Now, the result might look something like this: |t.name |t.book_id|t.stock|s.name |s.book_id|s.stock||------------|---------|-------|------------|---------|-------|| | | |Faraway Land|1 |9 | \u003c-- NOT MATCHED BY TARGET|Faraway Land|2 |10 |Faraway Land|2 |12 | \u003c-- MATCHED|Faraway Land|3 |10 |Faraway Land|3 |5 | \u003c-- MATCHED| | | |Paper Trail |1 |1 | \u003c-- NOT MATCHED BY TARGET|Paper Trail |3 |2 | | | | \u003c-- NOT MATCHED BY SOURCE The terms NOT MATCHED BY TARGET and NOT MATCHED BY SOURCE are quite self-explanatory when visualised as above, and probably less confusing to beginners than LEFT JOIN and RIGHT JOIN. I wouldn’t mind SQL syntax to be enhanced in a way that it would be possible to identify whether a NULL value originating from an OUTER JOIN is due to: The source data containing the NULL value The row being NOT MATCHED by the “other side” of the OUTER JOIN Imagine a hypothetical syntax like this: SELECT c.first_name, c.last_name, p.amount FROM customer AS c LEFT JOIN payment AS p ON c.customer_id = p.customer_id WHERE p IS NOT MATCHED BY JOIN -- Effectively an ANTI JOIN Anyway… When deleting rows, this approach is much more convenient than having to rely on an interpretation of the semantics of data, such as STOCK = 0 meaning a deletion. We now have absent rows in the SOURCE table (the staging) table, which simply mean the row must be deleted, if that’s how we want to model things. So, after running the above MERGE statement, we’ll get this outcome again: |t.name |t.book_id|t.stock|s.name |s.book_id|s.stock||------------|---------|-------|------------|---------|-------||Faraway Land|1 |9 |Faraway Land|1 |9 | \u003c-- NOT MATCHED BY TARGET : INSERT|Faraway Land|2 |12 |Faraway Land|2 |12 | \u003c-- MATCHED : UPDATE|Faraway Land|3 |5 |Faraway Land|3 |5 | \u003c-- MATCHED : UPDATE|Faraway Land|1 |1 |Paper Trail |1 |1 | \u003c-- NOT MATCHED BY TARGET : INSERT| | | | | | | \u003c-- NOT MATCHED BY SOURCE : DELETE At least the following RDBMS support the BY SOURCE and BY TARGET clauses: Databricks Firebird 5 PostgreSQL 17 SQL Server Given how useful this is, I’ll expect more RDBMS to adopt this T-SQL syntax, soon. jOOQ 3.20 has added support for it, and a future version of jOOQ may emulate it by moving the FULL JOIN into the USING clause.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-12938\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003e\u003ccode\u003e\u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/table-expressions/joined-tables/join-type-outer/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/table-expressions/joined-tables/join-type-outer/\"\u003eRIGHT JOIN\u003c/a\u003e\u003c/code\u003e is an esoteric feature in the SQL language, and hardly ever seen in the real world, because almost every \u003ccode\u003eRIGHT JOIN\u003c/code\u003e can just be expressed as an equivalent \u003ccode\u003eLEFT JOIN\u003c/code\u003e. The following two statements are equivalent:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e-- Popular\nSELECT c.first_name, c.last_name, p.amount\nFROM customer AS c\nLEFT JOIN payment AS p ON c.customer_id = p.customer_id\n\n-- Esoteric\nSELECT c.first_name, c.last_name, p.amount\nFROM payment AS p\nRIGHT JOIN customer AS c ON c.customer_id = p.customer_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIt’s not unreasonable to expect these two statements to produce the same execution plan on most RDBMS, given that they’re logically equivalent. Since we’ve grown used to reading things from left to right and top to bottom, I don’t think \u003ccode\u003eRIGHT JOIN\u003c/code\u003e will become more popular any time soon.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere is, however, one place in the SQL language where \u003ccode\u003eRIGHT JOIN\u003c/code\u003e is surprisingly ubiquitous!\u003c/p\u003e\n\n\n\n\u003ch3\u003eThe MERGE statement\u003c/h3\u003e\n\n\n\n\u003cp\u003eWhy is it a surprise? Because that place doesn’t use the same syntax for joining two tables. But that’s exactly what happens in the \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/\"\u003e\u003ccode\u003eMERGE\u003c/code\u003e statement\u003c/a\u003e. Let’s look at the following \u003ccode\u003eMERGE\u003c/code\u003e statement that takes:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eA staging table (\u003ccode\u003eSOURCE\u003c/code\u003e table) to load data from\u003c/li\u003e\n\n\n\n\u003cli\u003eAn ordinary table (\u003ccode\u003eTARGET\u003c/code\u003e table) to store data into\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWith a schema like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eCREATE TABLE book_to_book_store (\n  book_id BIGINT NOT NULL REFERENCES book,\n  name TEXT NOT NULL REFERENCES book_store,\n  stock INT NOT NULL,\n\n  PRIMARY KEY (book_id, name)\n);\n\nCREATE TABLE book_to_book_store_staging AS \nSELECT * FROM book_to_book_store\nWITH NO DATA;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eA query that could be typical of an \u003ca href=\"https://en.wikipedia.org/wiki/Extract,_transform,_load\" data-type=\"link\" data-id=\"https://en.wikipedia.org/wiki/Extract,_transform,_load\"\u003eETL job\u003c/a\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e-- The target table\nMERGE INTO book_to_book_store AS t\n\n-- The source table\nUSING book_to_book_store_staging AS s\n\n-- The RIGHT JOIN predicate\nON t.book_id = s.book_id AND t.name = s.name\n\n-- The actions for each row, based on RIGHT JOIN matching\nWHEN MATCHED THEN UPDATE SET stock = s.stock\nWHEN NOT MATCHED THEN INSERT (book_id, name, stock) \nVALUES (s.book_id, s.name, s.stock);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThis is simply taking all the rows from the \u003ccode\u003eBOOK_TO_BOOK_STORE_STAGING\u003c/code\u003e table, and merges them into \u003ccode\u003eBOOK_TO_BOOK_STORE\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf the row already exists (there’s a \u003ccode\u003eMATCH\u003c/code\u003e), then the \u003ccode\u003eSTOCK\u003c/code\u003e is updated\u003c/li\u003e\n\n\n\n\u003cli\u003eIf the row doesn’t already exist (there’s no \u003ccode\u003eMATCH\u003c/code\u003e), then the row is inserted\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBut we don’t use this source -\u0026gt; target syntactic order, we first specify the target table \u003ccode\u003eBOOK_TO_BOOK_STORE\u003c/code\u003e, and then we \u003ccode\u003eRIGHT JOIN\u003c/code\u003e the \u003ccode\u003eBOOK_TO_BOOK_STORE_STAGING\u003c/code\u003e table to it. Think about it this way:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT *\nFROM book_to_book_store AS t\nRIGHT JOIN book_to_book_store_staging AS s\nON t.book_id = s.book_id AND t.name = s.name\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd, if we think of a \u003ccode\u003eRIGHT JOIN\u003c/code\u003e not as a \u003ca href=\"https://blog.jooq.org/say-no-to-venn-diagrams-when-explaining-joins/\" data-type=\"link\" data-id=\"https://blog.jooq.org/say-no-to-venn-diagrams-when-explaining-joins/\"\u003eVenn diagram\u003c/a\u003e, but as a cartesian product as follows, then it can be seen easily what is done per \u003ccode\u003eMATCH\u003c/code\u003e or non-\u003ccode\u003eMATCH\u003c/code\u003e:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|t.name      |t.book_id|t.stock|s.name      |s.book_id|s.stock|\u003cbr/\u003e|------------|---------|-------|------------|---------|-------|\u003cbr/\u003e|            |         |       |Faraway Land|1        |9      | \u0026lt;-- NOT MATCHED\u003cbr/\u003e|Faraway Land|2        |10     |Faraway Land|2        |12     | \u0026lt;--     MATCHED\u003cbr/\u003e|Faraway Land|3        |10     |Faraway Land|3        |5      | \u0026lt;--     MATCHED\u003cbr/\u003e|            |         |       |Paper Trail |1        |1      | \u0026lt;-- NOT MATCHED\u003cbr/\u003e|Paper Trail |3        |2      |Paper Trail |3        |0      | \u0026lt;--     MATCHED\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs always with a \u003ccode\u003eRIGHT JOIN\u003c/code\u003e, every row from right side of the join is matched with a matching row from the left side of the join, or an empty row of \u003ccode\u003eNULL\u003c/code\u003e values, if there’s no such match. After this \u003ccode\u003eMERGE\u003c/code\u003e, we want the resulting data to be updated as follows:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|t.name      |t.book_id|t.stock|s.name      |s.book_id|s.stock|\u003cbr/\u003e|------------|---------|-------|------------|---------|-------|\u003cbr/\u003e\u003cstrong\u003e\u003cmark\u003e|Faraway Land|1        |9      |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|1        |9      | \u0026lt;-- NOT MATCHED\u003cbr/\u003e|Faraway Land|2        \u003cstrong\u003e\u003cmark\u003e|12     |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|2        |12     | \u0026lt;--     MATCHED\u003cbr/\u003e|Faraway Land|3        \u003cstrong\u003e\u003cmark\u003e|5      |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|3        |5      | \u0026lt;--     MATCHED\u003cbr/\u003e\u003cmark\u003e\u003cstrong\u003e|Faraway Land|1        |1      |\u003c/strong\u003e\u003c/mark\u003ePaper Trail |1        |1      | \u0026lt;-- NOT MATCHED\u003cbr/\u003e|Paper Trail |3        \u003cmark\u003e\u003cstrong\u003e|0      |\u003c/strong\u003e\u003c/mark\u003ePaper Trail |3        |0      | \u0026lt;--     MATCHED\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is how the \u003ccode\u003eMERGE\u003c/code\u003e statement works.\u003c/p\u003e\n\n\n\n\u003cp\u003eNote, I said before that the \u003ccode\u003eJOIN\u003c/code\u003e is producing a cartesian product. Unlike with \u003ccode\u003eSELECT\u003c/code\u003e statements, however, there’s a limitation to \u003ccode\u003eMERGE\u003c/code\u003e where the cartesian product must not produce any duplicate matches per \u003ccode\u003eTARGET\u003c/code\u003e row, as the order of actions wouldn’t be defined if there were multiple \u003ccode\u003eSOURCE\u003c/code\u003e rows per \u003ccode\u003eTARGET\u003c/code\u003e row.\u003c/p\u003e\n\n\n\n\u003ch3\u003eDeleting rows\u003c/h3\u003e\n\n\n\n\u003cp\u003e\u003ccode\u003eMERGE\u003c/code\u003e is more powerful than just performing \u003ccode\u003eINSERT\u003c/code\u003e and \u003ccode\u003eUPDATE\u003c/code\u003e. It can also \u003ccode\u003eDELETE\u003c/code\u003e rows. Let’s assume that we want a staging table’s \u003ccode\u003eSTOCK = 0\u003c/code\u003e to mean that the row should be deleted, instead of the \u003ccode\u003eSTOCK\u003c/code\u003e being set to \u003ccode\u003e0\u003c/code\u003e. Then we can write:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eMERGE INTO book_to_book_store AS t\nUSING book_to_book_store_staging AS s\nON t.book_id = s.book_id AND t.name = s.name\nWHEN MATCHED AND s.stock = 0 THEN DELETE\nWHEN MATCHED THEN UPDATE SET stock = s.stock\nWHEN NOT MATCHED THEN INSERT (book_id, name, stock) \nVALUES (s.book_id, s.name, s.stock);\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNow, with the above staging data, we’ll remove the last row instead of updating it:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|t.name      |t.book_id|t.stock|s.name      |s.book_id|s.stock|\u003cbr/\u003e|------------|---------|-------|------------|---------|-------|\u003cbr/\u003e\u003cstrong\u003e\u003cmark\u003e|Faraway Land|1        |9      |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|1        |9      | \u0026lt;-- NOT MATCHED : INSERT\u003cbr/\u003e|Faraway Land|2        \u003cstrong\u003e\u003cmark\u003e|10     |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|2        |12     | \u0026lt;--     MATCHED : UPDATE\u003cbr/\u003e|Faraway Land|3        \u003cstrong\u003e\u003cmark\u003e|10     |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|3        |5      | \u0026lt;--     MATCHED : UPDATE\u003cbr/\u003e\u003cmark\u003e\u003cstrong\u003e|Paper Trail |1        |1      |\u003c/strong\u003e\u003c/mark\u003ePaper Trail |1        |1      | \u0026lt;-- NOT MATCHED : INSERT\u003cbr/\u003e\u003cstrong\u003e\u003cmark\u003e|            |         |       |\u003c/mark\u003e\u003c/strong\u003ePaper Trail |3        |0      | \u0026lt;--     MATCHED : DELETE\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eRIGHT JOIN\u003c/code\u003e semantics is still the same, just the action is different now, depending on the \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/merge-when-matched-and/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/merge-when-matched-and/\"\u003eadditional \u003ccode\u003eAND\u003c/code\u003e clause of the \u003ccode\u003eWHEN MATCHED\u003c/code\u003e clause\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch3\u003eMatching by source\u003c/h3\u003e\n\n\n\n\u003cp\u003eSome RDBMS support an even more powerful vendor specific variant of \u003ccode\u003eMERGE\u003c/code\u003e, which should be added to the IEC/ISO 9075 standard, in my opinion. The \u003ccode\u003eBY TARGET\u003c/code\u003e / \u003ccode\u003eBY SOURCE\u003c/code\u003e clause. Let’s have a look at the following statement:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eMERGE INTO book_to_book_store AS t\nUSING book_to_book_store_staging AS s\nON t.book_id = s.book_id AND t.name = s.name\nWHEN MATCHED THEN UPDATE SET stock = s.stock\nWHEN NOT MATCHED BY TARGET THEN INSERT (book_id, name, stock) \nVALUES (s.book_id, s.name, s.stock)\nWHEN NOT MATCHED BY SOURCE THEN DELETE;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAdding a \u003ccode\u003eWHEN NOT MATCHED BY SOURCE\u003c/code\u003e clause has the simple effect of turning the \u003ccode\u003eRIGHT JOIN\u003c/code\u003e operation into a \u003ccode\u003eFULL JOIN\u003c/code\u003e operation. Think of it this way:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT *\nFROM book_to_book_store AS t\nFULL JOIN book_to_book_store_staging AS s\nON t.book_id = s.book_id AND t.name = s.name\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNow, the result might look something like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|t.name      |t.book_id|t.stock|s.name      |s.book_id|s.stock|\u003cbr/\u003e|------------|---------|-------|------------|---------|-------|\u003cbr/\u003e|            |         |       |Faraway Land|1        |9      | \u0026lt;-- NOT MATCHED BY TARGET\u003cbr/\u003e|Faraway Land|2        |10     |Faraway Land|2        |12     | \u0026lt;--     MATCHED\u003cbr/\u003e|Faraway Land|3        |10     |Faraway Land|3        |5      | \u0026lt;--     MATCHED\u003cbr/\u003e|            |         |       |Paper Trail |1        |1      | \u0026lt;-- NOT MATCHED BY TARGET\u003cbr/\u003e|Paper Trail |3        |2      |            |         |       | \u0026lt;-- NOT MATCHED BY SOURCE\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe terms \u003ccode\u003eNOT MATCHED BY TARGET\u003c/code\u003e and \u003ccode\u003eNOT MATCHED BY SOURCE\u003c/code\u003e are quite self-explanatory when visualised as above, and probably less confusing to beginners than \u003ccode\u003eLEFT JOIN\u003c/code\u003e and \u003ccode\u003eRIGHT JOIN\u003c/code\u003e. I wouldn’t mind SQL syntax to be enhanced in a way that it would be possible to identify whether a \u003ccode\u003eNULL\u003c/code\u003e value originating from an \u003ccode\u003eOUTER JOIN\u003c/code\u003e is due to:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe source data containing the \u003ccode\u003eNULL\u003c/code\u003e value\u003c/li\u003e\n\n\n\n\u003cli\u003eThe row being \u003ccode\u003eNOT MATCHED\u003c/code\u003e by the “other side” of the \u003ccode\u003eOUTER JOIN\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eImagine a hypothetical syntax like this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT c.first_name, c.last_name, p.amount\nFROM customer AS c\nLEFT JOIN payment AS p ON c.customer_id = p.customer_id\nWHERE p IS NOT MATCHED BY JOIN -- Effectively an ANTI JOIN\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnyway…\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen deleting rows, this approach is much more convenient than having to rely on an interpretation of the semantics of data, such as \u003ccode\u003eSTOCK = 0\u003c/code\u003e meaning a deletion. We now have \u003cem\u003eabsent\u003c/em\u003e rows in the \u003ccode\u003eSOURCE\u003c/code\u003e table (the staging) table, which simply mean the row must be deleted, if that’s how we want to model things. So, after running the above \u003ccode\u003eMERGE\u003c/code\u003e statement, we’ll get this outcome again:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|t.name      |t.book_id|t.stock|s.name      |s.book_id|s.stock|\u003cbr/\u003e|------------|---------|-------|------------|---------|-------|\u003cbr/\u003e\u003cstrong\u003e\u003cmark\u003e|Faraway Land|1        |9      |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|1        |9      | \u0026lt;-- NOT MATCHED BY TARGET : INSERT\u003cbr/\u003e|Faraway Land|2        \u003cstrong\u003e\u003cmark\u003e|12     |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|2        |12     | \u0026lt;--     MATCHED           : UPDATE\u003cbr/\u003e|Faraway Land|3        \u003cstrong\u003e\u003cmark\u003e|5      |\u003c/mark\u003e\u003c/strong\u003eFaraway Land|3        |5      | \u0026lt;--     MATCHED           : UPDATE\u003cbr/\u003e\u003cmark\u003e\u003cstrong\u003e|Faraway Land|1        |1      |\u003c/strong\u003e\u003c/mark\u003ePaper Trail |1        |1      | \u0026lt;-- NOT MATCHED BY TARGET : INSERT\u003cbr/\u003e\u003cstrong\u003e\u003cmark\u003e|            |         |       |\u003c/mark\u003e\u003c/strong\u003e            |         |       | \u0026lt;-- NOT MATCHED BY SOURCE : DELETE\u003c/pre\u003e\n\n\n\n\u003cp\u003eAt least the following RDBMS support the \u003ccode\u003eBY SOURCE\u003c/code\u003e and \u003ccode\u003eBY TARGET\u003c/code\u003e clauses:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDatabricks\u003c/li\u003e\n\n\n\n\u003cli\u003eFirebird 5\u003c/li\u003e\n\n\n\n\u003cli\u003ePostgreSQL 17\u003c/li\u003e\n\n\n\n\u003cli\u003eSQL Server\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eGiven how useful this is, I’ll expect more RDBMS to adopt this T-SQL syntax, soon. \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/merge-when-not-matched-by-source/\" data-type=\"link\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/merge-statement/merge-when-not-matched-by-source/\"\u003ejOOQ 3.20 has added support for it\u003c/a\u003e, and a future version of jOOQ may emulate it \u003ca href=\"https://github.com/jooq/jooq/issues/17775\" data-type=\"link\" data-id=\"https://github.com/jooq/jooq/issues/17775\"\u003eby moving the \u003ccode\u003eFULL JOIN\u003c/code\u003e into the \u003ccode\u003eUSING\u003c/code\u003e clause\u003c/a\u003e.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2025-03-13T14:45:53Z",
  "modifiedTime": "2025-03-13T14:50:58Z"
}
