{
  "id": "cb3b4d54-9bf0-48e4-a688-7e9a8b28292c",
  "title": "GitHub Issues search now supports nested queries and boolean operators: Here’s how we (re)built it",
  "link": "https://github.blog/developer-skills/application-development/github-issues-search-now-supports-nested-queries-and-boolean-operators-heres-how-we-rebuilt-it/",
  "description": "Plus, considerations in updating one of GitHub's oldest and most heavily used features. The post GitHub Issues search now supports nested queries and boolean operators: Here’s how we (re)built it appeared first on The GitHub Blog.",
  "author": "Deborah Digges",
  "published": "Tue, 13 May 2025 16:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Application development",
    "Architecture \u0026 optimization",
    "Developer skills",
    "Engineering",
    "Engineering principles",
    "GitHub Issues",
    "Issues search"
  ],
  "byline": "Deborah Digges",
  "length": 13891,
  "excerpt": "Building this feature presented significant challenges. We're excited to take you behind the scenes.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Originally, Issues search was limited by a simple, flat structure of queries. But with advanced search syntax, you can now construct searches using logical AND/OR operators and nested parentheses, pinpointing the exact set of issues you care about. Building this feature presented significant challenges: ensuring backward compatibility with existing searches, maintaining performance under high query volume, and crafting a user-friendly experience for nested searches. We’re excited to take you behind the scenes to share how we took this long-requested feature from idea to production. Here’s what you can do with the new syntax and how it works behind the scenes Issues search now supports building queries with logical AND/OR operators across all fields, with the ability to nest query terms. For example is:issue state:open author:rileybroughten (type:Bug OR type:Epic) finds all issues that are open AND were authored by rileybroughten AND are either of type bug or epic. How did we get here? Previously, as mentioned, Issues search only supported a flat list of query fields and terms, which were implicitly joined by a logical AND. For example, the query assignee:@me label:support new-project translated to “give me all issues that are assigned to me AND have the label support AND contain the text new-project.” But the developer community has been asking for more flexibility in issue search, repeatedly, for nearly a decade now. They wanted to be able to find all issues that had either the label support or the label question, using the query label:support OR label:question. So, we shipped an enhancement towards this request in 2021, when we enabled an OR style search using a comma-separated list of values. However, they still wanted the flexibility to search this way across all issue fields, and not just the labels field. So we got to work.  Technical architecture and implementation From an architectural perspective, we swapped out the existing search module for Issues (IssuesQuery), with a new search module (ConditionalIssuesQuery), that was capable of handling nested queries while continuing to support existing query formats. This involved rewriting IssueQuery, the search module that parsed query strings and mapped them into Elasticsearch queries. To build a new search module, we first needed to understand the existing search module, and how a single search query flowed through the system. At a high level, when a user performs a search, there are three stages in its execution: Parse: Breaking the user input string into a structure that is easier to process (like a list or a tree) Query: Transforming the parsed structure into an Elasticsearch query document, and making a query against Elasticsearch. Normalize: Mapping the results obtained from Elasticsearch (JSON) into Ruby objects for easy access and pruning the results to remove records that had since been removed from the database. Each stage presented its own challenges, which we’ll explore in more detail below. The Normalize step remained unchanged during the re-write, so we won’t dive into that one. Parse stage The user input string (the search phrase) is first parsed into an intermediate structure. The search phrase could include: Query terms: The relevant words the user is trying to find more information about (ex: “models”) Search filters: These restrict the set of returned search documents based on some criteria (ex: “assignee:Deborah-Digges”)  Example search phrase:  Find all issues assigned to me that contain the word “codespaces”: is:issue assignee:@me codespaces Find all issues with the label documentation that are assigned to me: assignee:@me label:documentation The old parsing method: flat list When only flat, simple queries were supported, it was sufficient to parse the user’s search string into a list of search terms and filters, which would then be passed along to the next stage of the search process. The new parsing method: abstract syntax tree As nested queries may be recursive, parsing the search string into a list was no longer sufficient. We changed this component to parse the user’s search string into an Abstract Syntax Tree (AST) using the parsing library parslet. We defined a grammar (a PEG or Parsing Expression Grammar) to represent the structure of a search string. The grammar supports both the existing query syntax and the new nested query syntax, to allow for backward compatibility. A simplified grammar for a boolean expression described by a PEG grammar for the parslet parser is shown below: class Parser \u003c Parslet::Parser rule(:space) { match[\" \"].repeat(1) } rule(:space?) { space.maybe } rule(:lparen) { str(\"(\") \u003e\u003e space? } rule(:rparen) { str(\")\") \u003e\u003e space? } rule(:and_operator) { str(\"and\") \u003e\u003e space? } rule(:or_operator) { str(\"or\") \u003e\u003e space? } rule(:var) { str(\"var\") \u003e\u003e match[\"0-9\"].repeat(1).as(:var) \u003e\u003e space? } # The primary rule deals with parentheses. rule(:primary) { lparen \u003e\u003e or_operation \u003e\u003e rparen | var } # Note that following rules are both right-recursive. rule(:and_operation) { (primary.as(:left) \u003e\u003e and_operator \u003e\u003e and_operation.as(:right)).as(:and) | primary } rule(:or_operation) { (and_operation.as(:left) \u003e\u003e or_operator \u003e\u003e or_operation.as(:right)).as(:or) | and_operation } # We start at the lowest precedence rule. root(:or_operation) end For example, this user search string:is:issue AND (author:deborah-digges OR author:monalisa ) would be parsed into the following AST: { \"root\": { \"and\": { \"left\": { \"filter_term\": { \"attribute\": \"is\", \"value\": [ { \"filter_value\": \"issue\" } ] } }, \"right\": { \"or\": { \"left\": { \"filter_term\": { \"attribute\": \"author\", \"value\": [ { \"filter_value\": \"deborah-digges\" } ] } }, \"right\": { \"filter_term\": { \"attribute\": \"author\", \"value\": [ { \"filter_value\": \"monalisa\" } ] } } } } } } } Query Once the query is parsed into an intermediate structure, the next steps are to: Transform this intermediate structure into a query document that Elasticsearch understands Execute the query against Elasticsearch to obtain results Executing the query in step 2 remained the same between the old and new systems, so let’s only go over the differences in building the query document below. The old query generation: linear mapping of filter terms using filter classes Each filter term (Ex: label:documentation) has a class that knows how to convert it into a snippet of an Elasticsearch query document. During query document generation, the correct class for each filter term is invoked to construct the overall query document. The new query generation: recursive AST traversal to generate Elasticsearch bool query We recursively traversed the AST generated during parsing to build an equivalent Elasticsearch query document. The nested structure and boolean operators map nicely to Elasticsearch’s boolean query with the AND, OR, and NOT operators mapping to the must, should, and should_not clauses. We re-used the building blocks for the smaller pieces of query generation to recursively construct a nested query document during the tree traversal. Continuing from the example in the parsing stage, the AST would be transformed into a query document that looked like this: { \"query\": { \"bool\": { \"must\": [ { \"bool\": { \"must\": [ { \"bool\": { \"must\": { \"prefix\": { \"_index\": \"issues\" } } } }, { \"bool\": { \"should\": { \"terms\": { \"author_id\": [ \"\u003cDEBORAH_DIGGES_AUTHOR_ID\u003e\", \"\u003cMONALISA_AUTHOR_ID\u003e\" ] } } } } ] } } ] } // SOME TERMS OMITTED FOR BREVITY } } With this new query document, we execute a search against Elasticsearch. This search now supports logical AND/OR operators and parentheses to search for issues in a more fine-grained manner. Considerations Issues is one of the oldest and most heavily -used features on GitHub. Changing core functionality like Issues search, a feature with an average of  nearly 2000 queries per second (QPS)—that’s almost 160M queries a day!—presented a number of challenges to overcome. Ensuring backward compatibility Issue searches are often bookmarked, shared among users, and linked in documents, making them important artifacts for developers and teams. Therefore, we wanted to introduce this new capability for nested search queries without breaking existing queries for users.  We validated the new search system before it even reached users by: Testing extensively: We ran our new search module against all unit and integration tests for the existing search module. To ensure that the GraphQL and REST API contracts remained unchanged, we ran the tests for the search endpoint both with the feature flag for the new search system enabled and disabled. Validating correctness in production with dark-shipping: For 1% of issue searches, we ran the user’s search against both the existing and new search systems in a background job, and logged differences in responses. By analyzing these differences we were able to fix bugs and missed edge cases before they reached our users. We weren’t sure at the outset how to define “differences,” but we settled on “number of results” for the first iteration. In general, it seemed that we could determine whether a user would be surprised by the results of their search against the new search capability if a search returned a different number of results when they were run within a second or less of each other. Preventing performance degradation We expected more complex nested queries to use more resources on the backend than simpler queries, so we needed to establish a realistic baseline for nested queries, while ensuring no regression in the performance of existing, simpler ones. For 1% of Issue searches, we ran equivalent queries against both the existing and the new search systems. We used scientist, GitHub’s open source Ruby library, for carefully refactoring critical paths, to compare the performance of equivalent queries to ensure that there was no regression. Preserving user experience We didn’t want users to have a worse experience than before just because more complex searches were possible.  We collaborated closely with product and design teams to ensure usability didn’t decrease as we added this feature by: Limiting the number of nested levels in a query to five. From customer interviews, we found this to be a sweet spot for both utility and usability. Providing helpful UI/UX cues: We highlight the AND/OR keywords in search queries, and provide users with the same auto-complete feature for filter terms in the UI that they were accustomed to for simple flat queries. Minimizing risk to existing users For a feature that is used by millions of users a day, we needed to be intentional about rolling it out in a way that minimized risk to users. We built confidence in our system by: Limiting blast radius: To gradually build confidence, we only integrated the new system in the GraphQL API and the Issues tab for a repository in the UI to start. This gave us time to collect, respond to, and incorporate feedback without risking a degraded experience for all consumers. Once we were happy with its performance, we rolled it out to the Issues dashboard and the REST API. Testing internally and with trusted partners: As with every feature we build at GitHub, we tested this feature internally for the entire period of its development by shipping it to our own team during the early days, and then gradually rolling it out to all GitHub employees. We then shipped it to trusted partners to gather initial user feedback. And there you have it, that’s how we built, validated, and shipped the new and improved Issues search! Feedback Want to try out this exciting new functionality? Head to our docs to learn about how to use boolean operators and parentheses to search for the issues you care about! If you have any feedback for this feature, please drop us a note on our community discussions. Acknowledgements Special thanks to AJ Schuster, Riley Broughten, Stephanie Goldstein, Eric Jorgensen Mike Melanson and Laura Lindeman for the feedback on several iterations of this blog post! Written by Sr. Software Engineer Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more Enterprise content Executive insights, curated just for you Get started",
  "image": "https://github.blog/wp-content/uploads/2025/05/github-generic-wallpaper-rubber-duck-invertocat.png?fit=1920%2C1080",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eOriginally, Issues search was limited by a simple, flat structure of queries. But with \u003ca href=\"https://github.blog/changelog/2025-04-09-evolving-github-issues-and-projects/#%f0%9f%95%b5%ef%b8%8f%e2%99%80%ef%b8%8f-finding-what-you-need-with-advanced-search\"\u003eadvanced search syntax\u003c/a\u003e, you can now construct searches using logical AND/OR operators and nested parentheses, pinpointing the exact set of issues you care about.\u003c/p\u003e\n\n\n\n\u003cp\u003eBuilding this feature presented significant challenges: ensuring backward compatibility with existing searches, maintaining performance under high query volume, and crafting a user-friendly experience for nested searches. We’re excited to take you behind the scenes to share how we took this long-requested feature from idea to production.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-here-s-what-you-can-do-with-the-new-syntax-and-how-it-works-behind-the-scenes\"\u003eHere’s what you can do with the new syntax and how it works behind the scenes\u003c/h2\u003e\n\n\n\n\u003cp\u003eIssues search now supports building queries with logical AND/OR operators across \u003cem\u003eall\u003c/em\u003e fields, with the ability to nest query terms. For example \u003ccode\u003eis:issue state:open author:rileybroughten (type:Bug OR type:Epic)\u003c/code\u003e finds all \u003cem\u003eissues\u003c/em\u003e that are \u003cem\u003eopen\u003c/em\u003e AND were \u003cem\u003eauthor\u003c/em\u003eed by \u003cem\u003erileybroughten\u003c/em\u003e AND are either of type \u003cem\u003ebug\u003c/em\u003e or \u003cem\u003eepic\u003c/em\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"3818\" height=\"1532\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?resize=3818%2C1532\" alt=\"Screenshot of an Issues search query involving the logical OR operator.\" srcset=\"https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=3818 3818w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=2048 2048w, https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?w=3000 3000w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2 id=\"how-did-we-get-here\"\u003eHow did we get here?\u003c/h2\u003e\n\n\n\n\u003cp\u003ePreviously, as mentioned, Issues search only supported a flat list of query fields and terms, which were implicitly joined by a logical AND. For example, the query \u003ccode\u003eassignee:@me label:support new-project\u003c/code\u003e translated to “give me all issues that are assigned to me AND have the label \u003cem\u003esupport \u003c/em\u003eAND\u003cem\u003e \u003c/em\u003econtain the text \u003cem\u003enew-project.\u003c/em\u003e”\u003c/p\u003e\n\n\n\n\u003cp\u003eBut the developer community has been \u003ca href=\"https://github.com/isaacs/github/issues/660\"\u003easking for more flexibility in issue search\u003c/a\u003e, \u003ca href=\"https://github.com/orgs/community/discussions/4507\"\u003erepeatedly\u003c/a\u003e, for nearly a decade now. They wanted to be able to find all issues that had \u003cem\u003eeither\u003c/em\u003e the label \u003ccode\u003esupport\u003c/code\u003e or the label \u003ccode\u003equestion\u003c/code\u003e, using the query \u003ccode\u003elabel:support OR label:question\u003c/code\u003e. So, we shipped an \u003ca href=\"https://github.blog/changelog/2021-08-02-search-issues-by-label-using-logical-or/\"\u003eenhancement towards this request\u003c/a\u003e in 2021, when we enabled an OR style search using a comma-separated list of values.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, they still wanted \u003ca href=\"https://github.com/orgs/community/discussions/4507#discussioncomment-3076699\"\u003ethe flexibility to search this way across \u003cem\u003eall\u003c/em\u003e issue fields\u003c/a\u003e, and not just the \u003cem\u003elabels\u003c/em\u003e field. So we got to work. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-technical-architecture-and-implementation\"\u003eTechnical architecture and implementation\u003c/h2\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"3197\" height=\"1518\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/1_architecture.png?resize=3197%2C1518\" alt=\"The architecture of the Issues search system (and the changes needed to build this feature).\" srcset=\"https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=3197 3197w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=2048 2048w, https://github.blog/wp-content/uploads/2025/05/1_architecture.png?w=3000 3000w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eFrom an architectural perspective, we swapped out the existing search module for Issues (IssuesQuery), with a new search module (ConditionalIssuesQuery), that was capable of handling nested queries while continuing to support existing query formats.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis involved rewriting IssueQuery, the search module that parsed query strings and mapped them into Elasticsearch queries.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"2694\" height=\"988\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?resize=2694%2C988\" alt=\"Search Architecture\" srcset=\"https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=2694 2694w, https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=300 300w, https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=768 768w, https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?w=2048 2048w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eTo build a new search module, we first needed to understand the existing search module, and how a single search query flowed through the system. At a high level, when a user performs a search, there are three stages in its execution:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eParse\u003c/strong\u003e: Breaking the user input string into a structure that is easier to process (like a list or a tree)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eQuery\u003c/strong\u003e: Transforming the parsed structure into an Elasticsearch query document, and making a query against Elasticsearch.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eNormalize: \u003c/strong\u003eMapping the results obtained from Elasticsearch (JSON) into Ruby objects for easy access and pruning the results to remove records that had since been removed from the database.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eEach stage presented its own challenges, which we’ll explore in more detail below. The \u003cem\u003eNormalize\u003c/em\u003e step remained unchanged during the re-write, so we won’t dive into that one.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"parse-stage\"\u003eParse stage\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe user input string (the search phrase) is first parsed into an intermediate structure. The search phrase could include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eQuery terms:\u003c/strong\u003e The relevant words the user is trying to find more information about (ex: “models”)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSearch filters: \u003c/strong\u003eThese restrict the set of returned search documents based on some criteria (ex: “assignee:Deborah-Digges”)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e Example search phrase: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFind all issues assigned to me that contain the word “codespaces”:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eis:issue assignee:@me codespaces\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\n\n\n\u003cli\u003eFind all issues with the label \u003cem\u003edocumentation\u003c/em\u003e that are assigned to me:\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eassignee:@me label:documentation\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch4 id=\"the-old-parsing-method-flat-list\"\u003eThe old parsing method: flat list\u003c/h4\u003e\n\n\n\n\u003cp\u003eWhen only flat, simple queries were supported, it was sufficient to parse the user’s search string into a list of search terms and filters, which would then be passed along to the next stage of the search process.\u003c/p\u003e\n\n\n\n\u003ch4 id=\"the-new-parsing-method-abstract-syntax-tree\"\u003eThe new parsing method: abstract syntax tree\u003c/h4\u003e\n\n\n\n\u003cp\u003eAs nested queries may be recursive, parsing the search string into a list was no longer sufficient. We changed this component to parse the user’s search string into an Abstract Syntax Tree (AST) using the parsing library \u003ca href=\"https://github.com/kschiess/parslet\"\u003eparslet\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe defined a grammar (a PEG or Parsing Expression Grammar) to represent the structure of a search string. The grammar supports both the existing query syntax and the new nested query syntax, to allow for backward compatibility.\u003c/p\u003e\n\n\n\n\u003cp\u003eA \u003ca href=\"https://github.com/kschiess/parslet/blob/master/example/boolean_algebra.rb\"\u003esimplified grammar\u003c/a\u003e for a boolean expression described by a PEG grammar for the parslet parser is shown below:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003eclass Parser \u0026lt; Parslet::Parser\n  rule(:space)  { match[\u0026#34; \u0026#34;].repeat(1) }\n  rule(:space?) { space.maybe }\n\n  rule(:lparen) { str(\u0026#34;(\u0026#34;) \u0026gt;\u0026gt; space? }\n  rule(:rparen) { str(\u0026#34;)\u0026#34;) \u0026gt;\u0026gt; space? }\n\n  rule(:and_operator) { str(\u0026#34;and\u0026#34;) \u0026gt;\u0026gt; space? }\n  rule(:or_operator)  { str(\u0026#34;or\u0026#34;)  \u0026gt;\u0026gt; space? }\n\n  rule(:var) { str(\u0026#34;var\u0026#34;) \u0026gt;\u0026gt; match[\u0026#34;0-9\u0026#34;].repeat(1).as(:var) \u0026gt;\u0026gt; space? }\n\n  # The primary rule deals with parentheses.\n  rule(:primary) { lparen \u0026gt;\u0026gt; or_operation \u0026gt;\u0026gt; rparen | var }\n\n  # Note that following rules are both right-recursive.\n  rule(:and_operation) { \n    (primary.as(:left) \u0026gt;\u0026gt; and_operator \u0026gt;\u0026gt; \n      and_operation.as(:right)).as(:and) | \n    primary }\n    \n  rule(:or_operation)  { \n    (and_operation.as(:left) \u0026gt;\u0026gt; or_operator \u0026gt;\u0026gt; \n      or_operation.as(:right)).as(:or) | \n    and_operation }\n\n  # We start at the lowest precedence rule.\n  root(:or_operation)\nend\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eFor example, this user search string:\u003cbr/\u003e\u003ccode\u003eis:issue AND (author:deborah-digges OR author:monalisa )\u003c/code\u003e \u003cbr/\u003ewould be parsed into the following AST:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;root\u0026#34;: {\n    \u0026#34;and\u0026#34;: {\n      \u0026#34;left\u0026#34;: {\n        \u0026#34;filter_term\u0026#34;: {\n          \u0026#34;attribute\u0026#34;: \u0026#34;is\u0026#34;,\n          \u0026#34;value\u0026#34;: [\n            {\n              \u0026#34;filter_value\u0026#34;: \u0026#34;issue\u0026#34;\n            }\n          ]\n        }\n      },\n      \u0026#34;right\u0026#34;: {\n        \u0026#34;or\u0026#34;: {\n          \u0026#34;left\u0026#34;: {\n            \u0026#34;filter_term\u0026#34;: {\n              \u0026#34;attribute\u0026#34;: \u0026#34;author\u0026#34;,\n              \u0026#34;value\u0026#34;: [\n                {\n                  \u0026#34;filter_value\u0026#34;: \u0026#34;deborah-digges\u0026#34;\n                }\n              ]\n            }\n          },\n          \u0026#34;right\u0026#34;: {\n            \u0026#34;filter_term\u0026#34;: {\n              \u0026#34;attribute\u0026#34;: \u0026#34;author\u0026#34;,\n              \u0026#34;value\u0026#34;: [\n                {\n                  \u0026#34;filter_value\u0026#34;: \u0026#34;monalisa\u0026#34;\n                }\n              ]\n            }\n          }\n        }\n      }\n    }\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003ch3 id=\"query\"\u003eQuery\u003c/h3\u003e\n\n\n\n\u003cp\u003eOnce the query is parsed into an intermediate structure, the next steps are to:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eTransform this intermediate structure into a query document that Elasticsearch understands\u003c/li\u003e\n\n\n\n\u003cli\u003eExecute the query against Elasticsearch to obtain results\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eExecuting the query in step 2 remained the same between the old and new systems, so let’s only go over the differences in building the query document below.\u003c/p\u003e\n\n\n\n\u003ch4 id=\"the-old-query-generation-linear-mapping-of-filter-terms-using-filter-classes\"\u003eThe old query generation: linear mapping of filter terms using filter classes\u003c/h4\u003e\n\n\n\n\u003cp\u003eEach filter term (Ex: \u003ccode\u003elabel:documentation\u003c/code\u003e) has a class that knows how to convert it into a snippet of an Elasticsearch query document. During query document generation, the correct class for each filter term is invoked to construct the overall query document.\u003c/p\u003e\n\n\n\n\u003ch4 id=\"the-new-query-generation-recursive-ast-traversal-to-generate-elasticsearch-bool-query\"\u003eThe new query generation: recursive AST traversal to generate Elasticsearch bool query\u003c/h4\u003e\n\n\n\n\u003cp\u003eWe recursively traversed the AST generated during parsing to build an equivalent Elasticsearch query document. The nested structure and boolean operators map nicely to Elasticsearch’s \u003ca href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html\"\u003eboolean query\u003c/a\u003e with the AND, OR, and NOT operators mapping to the \u003cem\u003emust\u003c/em\u003e, \u003cem\u003eshould\u003c/em\u003e, and \u003cem\u003eshould_not\u003c/em\u003e clauses.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe re-used the building blocks for the smaller pieces of query generation to recursively construct a nested query document during the tree traversal.\u003c/p\u003e\n\n\n\n\u003cp\u003eContinuing from the example in the parsing stage, the AST would be transformed into a query document that looked like this:\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003e{\n  \u0026#34;query\u0026#34;: {\n    \u0026#34;bool\u0026#34;: {\n      \u0026#34;must\u0026#34;: [\n        {\n          \u0026#34;bool\u0026#34;: {\n            \u0026#34;must\u0026#34;: [\n              {\n                \u0026#34;bool\u0026#34;: {\n                  \u0026#34;must\u0026#34;: {\n                    \u0026#34;prefix\u0026#34;: {\n                      \u0026#34;_index\u0026#34;: \u0026#34;issues\u0026#34;\n                    }\n                  }\n                }\n              },\n              {\n                \u0026#34;bool\u0026#34;: {\n                  \u0026#34;should\u0026#34;: {\n                    \u0026#34;terms\u0026#34;: {\n                      \u0026#34;author_id\u0026#34;: [\n                        \u0026#34;\u0026lt;DEBORAH_DIGGES_AUTHOR_ID\u0026gt;\u0026#34;,\n                        \u0026#34;\u0026lt;MONALISA_AUTHOR_ID\u0026gt;\u0026#34;\n                      ]\n                    }\n                  }\n                }\n              }\n            ]\n          }\n        }\n      ]\n    }\n    // SOME TERMS OMITTED FOR BREVITY\n  }\n}\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith this new query document, we execute a search against Elasticsearch. This search now supports logical AND/OR operators and parentheses to search for issues in a more fine-grained manner.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"considerations\"\u003eConsiderations\u003c/h2\u003e\n\n\n\n\u003cp\u003eIssues is one of the oldest and most heavily -used features on GitHub. Changing core functionality like Issues search, a feature with an average of  nearly 2000 queries per second (QPS)—that’s almost 160M queries a day!—presented a number of challenges to overcome.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"ensuring-backward-compatibility\"\u003eEnsuring backward compatibility\u003c/h3\u003e\n\n\n\n\u003cp\u003eIssue searches are often bookmarked, shared among users, and linked in documents, making them important artifacts for developers and teams. Therefore, we wanted to introduce this new capability for nested search queries without breaking existing queries for users. \u003c/p\u003e\n\n\n\n\u003cp\u003eWe validated the new search system before it even reached users by:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTesting extensively\u003c/strong\u003e: We ran our new search module against all unit and integration tests for the existing search module. To ensure that the GraphQL and REST API contracts remained unchanged, we ran the tests for the search endpoint both with the feature flag for the new search system enabled and disabled.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eValidating correctness in production with dark-shipping: \u003c/strong\u003eFor 1% of issue searches, we ran the user’s search against both the existing and new search systems in a background job, and logged differences in responses. By analyzing these differences we were able to fix bugs and missed edge cases before they reached our users.\n\u003cul\u003e\n\u003cli\u003eWe weren’t sure at the outset how to define “differences,” but we settled on “number of results” for the first iteration. In general, it seemed that we could determine whether a user would be surprised by the results of their search against the new search capability if a search returned a different number of results when they were run within a second or less of each other.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3 id=\"preventing-performance-degradation\"\u003ePreventing performance degradation\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe expected more complex nested queries to use more resources on the backend than simpler queries, so we needed to establish a realistic baseline for nested queries, while ensuring no regression in the performance of existing, simpler ones.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor 1% of Issue searches, we ran equivalent queries against both the existing and the new search systems. We used \u003ca href=\"https://github.com/github/scientist\"\u003escientist\u003c/a\u003e, GitHub’s open source Ruby library, for carefully refactoring critical paths, to compare the performance of equivalent queries to ensure that there was no regression.\u003c/p\u003e\n\n\n\n\u003ch3 id=\"preserving-user-experience\"\u003ePreserving user experience\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe didn’t want users to have a worse experience than before just because more complex searches were\u003cem\u003e possible\u003c/em\u003e. \u003c/p\u003e\n\n\n\n\u003cp\u003eWe collaborated closely with product and design teams to ensure usability didn’t decrease as we added this feature by:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLimiting the number of nested levels \u003c/strong\u003ein a query to five. From customer interviews, we found this to be a sweet spot for both utility and usability.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eProviding helpful UI/UX cues\u003c/strong\u003e: We highlight the AND/OR keywords in search queries, and provide users with the same auto-complete feature for filter terms in the UI that they were accustomed to for simple flat queries.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3 id=\"minimizing-risk-to-existing-users\"\u003eMinimizing risk to existing users\u003c/h3\u003e\n\n\n\n\u003cp\u003eFor a feature that is used by millions of users a day, we needed to be intentional about rolling it out in a way that minimized risk to users.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe built confidence in our system by:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLimiting blast radius\u003c/strong\u003e: To gradually build confidence, we only integrated the new system in the GraphQL API and the Issues tab for a repository in the UI to start. This gave us time to collect, respond to, and incorporate feedback without risking a degraded experience for all consumers. Once we were happy with its performance, we rolled it out to the \u003ca href=\"https://github.blog/changelog/2025-04-02-github-issues-dashboard-updates/\"\u003eIssues dashboard\u003c/a\u003e and the \u003ca href=\"https://github.blog/changelog/2025-03-06-github-issues-projects-api-support-for-issues-advanced-search-and-more/\"\u003eREST API\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eTesting internally and with trusted partners\u003c/strong\u003e: As with every feature we build at GitHub, we tested this feature internally for the entire period of its development by shipping it to our own team during the early days, and then gradually rolling it out to all GitHub employees. We then shipped it to trusted partners to gather initial user feedback.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eAnd there you have it, that’s how we built, validated, and shipped the new and improved Issues search!\u003c/p\u003e\n\n\n\n\u003ch2 id=\"feedback\"\u003eFeedback\u003c/h2\u003e\n\n\n\n\u003cp\u003eWant to try out this exciting new functionality? Head to our docs to learn about how to use \u003ca href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests#using-boolean-operators\"\u003eboolean operators\u003c/a\u003e and \u003ca href=\"https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests#using-parentheses-for-more-complicated-filters\"\u003eparentheses\u003c/a\u003e to search for the issues you care about!\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you have any feedback for this feature, please drop us a note on our \u003ca href=\"https://github.com/orgs/community/discussions/categories/announcements\"\u003ecommunity discussions\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"acknowledgements\"\u003eAcknowledgements\u003c/h2\u003e\n\n\n\n\u003cp\u003eSpecial thanks to AJ Schuster, Riley Broughten, Stephanie Goldstein, Eric Jorgensen Mike Melanson and Laura Lindeman for the feedback on several iterations of this blog post!\u003c/p\u003e\n\n\n\n\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/3866405?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/3866405?v=4\u0026amp;s=200\" alt=\"Deborah Digges\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eSr. Software Engineer\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.com/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2022/05/careers.svg\" width=\"44\" height=\"44\" alt=\"Enterprise content\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tEnterprise content\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eExecutive insights, curated just for you\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Get started; ref_location:bottom recirculation;\" href=\"https://github.com/solutions/executive-insights\" target=\"_blank\" aria-label=\"Get started\"\u003e\n\t\t\t\t\tGet started\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-05-13T16:00:00Z",
  "modifiedTime": null
}
