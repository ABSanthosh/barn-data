{
  "id": "ec82bd40-b27c-4115-9887-77700444bc54",
  "title": "Tainting and Labeling Kubernetes Nodes to Run Special Workload — A quick guide that is finally NOT confusing",
  "link": "https://buffer.com/resources/tainting-and-labeling-kubernetes-nodes-to-run-special-workload-e2-80-8a--e2-80-8aa-quick-guide-that-is-finally-not-confusing/",
  "description": "A quick guide to tainting and labeling kubernetes. This post is an overview of tainting and labeling kubernetes nodes to run special workload.",
  "author": "Steven Cheng",
  "published": "Tue, 03 Dec 2019 23:11:37 GMT",
  "source": "https://buffer.com/resources/overflow/rss/",
  "categories": [
    "Overflow"
  ],
  "byline": "Joe Birch",
  "length": 3711,
  "excerpt": "A quick guide to tainting and labeling kubernetes. This post is an overview of tainting and labeling kubernetes nodes to run special workload.",
  "siteName": "Buffer: All-you-need social media toolkit for small businesses",
  "favicon": "https://buffer.com/static/icons/apple-touch-icon.png",
  "text": "All right folks, I intend to keep this one short and that’s what I will do. I mean, it’s supposed to be easy but the official documentation(1, 2) makes it unnecessarily confusing. So I think maybe I can help to fill in the gap.I will be using one of our business requirements at Buffer in this project, as an example for this blog post.Quick recapSo, we need a few nodes that are dedicated to running cronjobs, and nothing else. At the same time, we want to make sure the cornjobs are scheduled to these nodes, and nowhere else. This means we need 2 thingsTainted nodes that don’t take other workloadsThe workload that only goes to the destination nodesNow, let’s start from nodes, then the workloadNodesSince the requirement is broken down to 2 aspects (see above), there are 2 things we will need to specify for nodes. As always, kops is my weapon of choice.In kops, you can do this kops edit ig \u003cINSTANCE GROUP IN INTEREST\u003eapiVersion: kops.k8s.io/v1alpha2 kind: InstanceGroup metadata:   labels:     kops.k8s.io/cluster: steven.k8s.com   name: frequent-cronjob-nodes spec:   image: kope.io/k8s-1.13-debian-stretch   machineType: m4.xlarge   maxSize: 2   minSize: 2   nodeLabels:     kops.k8s.io/instancegroup: frequent-cronjob-nodes   role: Node   subnets:   - us-east-1b   - us-east-1c   taints:   - dedicated=frequent-cronjob-nodes:NoScheduleTainting nodesThis prevents other workloads from being scheduled to them. It’s achieved by these 2 linestaints: - dedicated=frequent-cronjob-nodes:NoScheduleLabeling nodesThis helps a specialized workload to locate the nodes. It’s achieved by these 2 linesnodeLabels:   kops.k8s.io/instancegroup: frequent-cronjob-nodesI know there are people who don’t use kops out there. If you are one of them, here are 2 commands to helpkubectl taint nodes \u003cNODE IN INTEREST\u003e dedicated=frequent-cronjob-nodes:NoSchedulekubectl label nodes \u003cNODE IN INTEREST\u003e kops.k8s.io/instancegroup=frequent-cronjob-nodeWorkloadSimilar to nodes, we will need to do 2 things to the deployment/cronjob yaml file. I’m including a complete yaml to save our eyes from this (yeah, you know what I’m talking about).apiVersion: batch/v1beta1 kind: CronJob metadata:   namespace: dev   name: steven-cron   labels:     app: steven-cron spec:   schedule: \"* * * * *\"   jobTemplate:     spec:       template:         spec:           nodeSelector:             kops.k8s.io/instancegroup: frequent-cronjob-nodes           tolerations:           - key: dedicated             value: frequent-cronjob-nodes             operator: \"Equal\"             effect: NoSchedule           containers:           - name: steven-cron             image: buffer/steven-cron             command: [\"php\", \"./src/Crons/index.php\"]           imagePullSecrets:             - name: bufferTolerating taintsThis makes sure the workload can be scheduled to the tainted nodes. It’s achieved by these linestolerations: - key: dedicated     value: frequent-cronjob-nodes     operator: \"Equal\"     effect: NoScheduleSpecifying destination nodesThis makes sure the workload is only to be scheduled to the specified nodes. It’s achieved by these 2 linesnodeSelector:     kops.k8s.io/instancegroup: frequent-cronjob-nodesProfitThis is it. We can now rest assure the right workload will be going to the right nodes. In this way, we can start building some specialized node groups for specialized workloads, say GPU nodes for machine learning or memory-intensive nodes for local caching.I hope this helps in any way. Until next time, please feel free to hit me up on Twitter should you have any questions. ?Try Buffer for free140,000+ small businesses like yours use Buffer to build their brand on social media every monthGet started now",
  "image": "https://buffer.com/resources/content/images/wp-content/uploads/2019/12/440px-Kubernetes_logo_without_workmark.svg_.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eAll right folks, I intend to keep this one short and that’s what I will do. I mean, it’s supposed to be easy but the official documentation(\u003ca href=\"https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/\" rel=\"noreferrer noopener\"\u003e1\u003c/a\u003e, \u003ca href=\"https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes/#add-a-label-to-a-node\" rel=\"noreferrer noopener\"\u003e2\u003c/a\u003e) makes it unnecessarily confusing. So I think maybe I can help to fill in the gap.\u003c/p\u003e\u003cp\u003eI will be using one of our business requirements at Buffer \u003ca href=\"https://itnext.io/how-to-set-kubernetes-resource-requests-and-limits-a-saga-to-improve-cluster-stability-and-a7b1800ecff1\"\u003ein this\u003c/a\u003e \u003ca href=\"https://buffer.com/resources/how-to-set-kubernetes-resource-requests-and-limits-e2-80-8a--e2-80-8aa-saga-to-improve-cluster-stability-and-efficiency/\"\u003eproject\u003c/a\u003e, as an example for this blog post.\u003c/p\u003e\u003ch3 id=\"quick-recap\"\u003eQuick recap\u003c/h3\u003e\u003cp\u003eSo, we need a few nodes that are dedicated to running cronjobs, and nothing else. At the same time, we want to make sure the cornjobs are scheduled to these nodes, and nowhere else. This means we need 2 things\u003c/p\u003e\u003cul\u003e\u003cli\u003eTainted nodes that don’t take other workloads\u003c/li\u003e\u003cli\u003eThe workload that only goes to the destination nodes\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNow, let’s start from nodes, then the workload\u003c/p\u003e\u003ch3 id=\"nodes\"\u003eNodes\u003c/h3\u003e\u003cp\u003eSince the requirement is broken down to 2 aspects (see above), there are 2 things we will need to specify for nodes. As always, kops is my weapon of choice.\u003c/p\u003e\u003cp\u003eIn kops, you can do this \u003ccode\u003ekops edit ig \u0026lt;INSTANCE GROUP IN INTEREST\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eapiVersion: kops.k8s.io/v1alpha2\nkind: InstanceGroup\nmetadata:\n  labels:\n    kops.k8s.io/cluster: steven.k8s.com\n  name: frequent-cronjob-nodes\nspec:\n  image: kope.io/k8s-1.13-debian-stretch\n  machineType: m4.xlarge\n  maxSize: 2\n  minSize: 2\n  nodeLabels:\n    kops.k8s.io/instancegroup: frequent-cronjob-nodes\n  role: Node\n  subnets:\n  - us-east-1b\n  - us-east-1c\n  taints:\n  - dedicated=frequent-cronjob-nodes:NoSchedule\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tainting-nodes\"\u003eTainting nodes\u003c/h3\u003e\u003cp\u003eThis prevents other workloads from being scheduled to them. It’s achieved by these 2 lines\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etaints: \n- dedicated=frequent-cronjob-nodes:NoSchedule\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"labeling-nodes\"\u003eLabeling nodes\u003c/h3\u003e\u003cp\u003eThis helps a specialized workload to locate the nodes. It’s achieved by these 2 lines\u003c/p\u003e\u003cpre\u003e\u003ccode\u003enodeLabels:   \nkops.k8s.io/instancegroup: frequent-cronjob-nodes\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI know there are people who don’t use kops out there. If you are one of them, here are 2 commands to help\u003c/p\u003e\u003cp\u003e\u003ccode\u003ekubectl taint nodes \u0026lt;NODE IN INTEREST\u0026gt; dedicated=frequent-cronjob-nodes:NoSchedule\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ekubectl label nodes \u0026lt;NODE IN INTEREST\u0026gt; kops.k8s.io/instancegroup=frequent-cronjob-node\u003c/code\u003e\u003c/p\u003e\u003ch3 id=\"workload\"\u003eWorkload\u003c/h3\u003e\u003cp\u003eSimilar to nodes, we will need to do 2 things to the deployment/cronjob yaml file. I’m including a complete yaml to save our eyes \u003ca href=\"https://twitter.com/caged/status/1039937162769096704\" rel=\"noreferrer noopener\"\u003efrom this\u003c/a\u003e (yeah, you know what I’m talking about).\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eapiVersion: batch/v1beta1\nkind: CronJob\nmetadata:\n  namespace: dev\n  name: steven-cron\n  labels:\n    app: steven-cron\nspec:\n  schedule: \u0026#34;* * * * *\u0026#34;\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          nodeSelector:\n            kops.k8s.io/instancegroup: frequent-cronjob-nodes\n          tolerations:\n          - key: dedicated\n            value: frequent-cronjob-nodes\n            operator: \u0026#34;Equal\u0026#34;\n            effect: NoSchedule\n          containers:\n          - name: steven-cron\n            image: buffer/steven-cron\n            command: [\u0026#34;php\u0026#34;, \u0026#34;./src/Crons/index.php\u0026#34;]\n          imagePullSecrets:\n            - name: buffer\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"tolerating-taints\"\u003eTolerating taints\u003c/h3\u003e\u003cp\u003eThis makes sure the workload can be scheduled to the tainted nodes. It’s achieved by these lines\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etolerations: \n- key: dedicated   \n  value: frequent-cronjob-nodes   \n  operator: \u0026#34;Equal\u0026#34;   \n  effect: NoSchedule\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"specifying-destination-nodes\"\u003eSpecifying destination nodes\u003c/h3\u003e\u003cp\u003eThis makes sure the workload is only to be scheduled to the specified nodes. It’s achieved by these 2 lines\u003c/p\u003e\u003cpre\u003e\u003ccode\u003enodeSelector:   \n  kops.k8s.io/instancegroup: frequent-cronjob-nodes\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"profit\"\u003eProfit\u003c/h3\u003e\u003cp\u003eThis is it. We can now rest assure the right workload will be going to the right nodes. In this way, we can start building some specialized node groups for specialized workloads, say GPU nodes for machine learning or memory-intensive nodes for local caching.\u003c/p\u003e\u003cp\u003eI hope this helps in any way. Until next time, please feel free to hit me up on \u003ca href=\"https://twitter.com/stevenc81\" rel=\"noreferrer noopener\"\u003eTwitter\u003c/a\u003e should you have any questions. ?\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"midpost-cta\"\u003e\u003ch3\u003eTry Buffer for free\u003c/h3\u003e\u003cp\u003e140,000+ small businesses like yours use Buffer to build their brand on social media every month\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://login.buffer.com/signup?product=buffer\u0026amp;plan=free\u0026amp;cycle=year\u0026amp;cta=bufferBlogLibrary-post-midCTA-signup-1\" role=\"button\"\u003eGet started now\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
