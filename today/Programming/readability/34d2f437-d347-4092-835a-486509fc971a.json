{
  "id": "34d2f437-d347-4092-835a-486509fc971a",
  "title": "A more complex codemod",
  "link": "https://martinfowler.com/articles/codemods-api-refactoring.html#RefactoringAnAvatarComponent",
  "description": "",
  "author": "",
  "published": "2025-01-08T09:44:00-05:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": [
    "skip-home-page"
  ],
  "byline": "Juntao QIU | 邱俊涛",
  "length": 19438,
  "excerpt": "Using codemods to upgrade client code on API changes",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "As a library developer, you may create a popular utility that hundreds of thousands of developers rely on daily, such as lodash or React. Over time, usage patterns might emerge that go beyond your initial design. When this happens, you may need to extend an API by adding parameters or modifying function signatures to fix edge cases. The challenge lies in rolling out these breaking changes without disrupting your users’ workflows. This is where codemods come in—a powerful tool for automating large-scale code transformations, allowing developers to introduce breaking API changes, refactor legacy codebases, and maintain code hygiene with minimal manual effort. In this article, we’ll explore what codemods are and the tools you can use to create them, such as jscodeshift, hypermod.io, and codemod.com. We’ll walk through real-world examples, from cleaning up feature toggles to refactoring component hierarchies. You’ll also learn how to break down complex transformations into smaller, testable pieces—a practice known as codemod composition—to ensure flexibility and maintainability. By the end, you’ll see how codemods can become a vital part of your toolkit for managing large-scale codebases, helping you keep your code clean and maintainable while handling even the most challenging refactoring tasks. Breaking Changes in APIs Returning to the scenario of the library developer, after the initial release, new usage patterns emerge, prompting the need to extend an API—perhaps by adding a parameter or modifying a function signature to make it easier to use. For simple changes, a basic find-and-replace in the IDE might work. In more complex cases, you might resort to using tools like sed or awk. However, when your library is widely adopted, the scope of such changes becomes harder to manage. You can’t be sure how extensively the modification will impact your users, and the last thing you want is to break existing functionality that doesn’t need updating. A common approach is to announce the breaking change, release a new version, and ask users to migrate at their own pace. But this workflow, while familiar, often doesn't scale well, especially for major shifts. Consider React’s transition from class components to function components with hooks—a paradigm shift that took years for large codebases to fully adopt. By the time teams managed to migrate, more breaking changes were often already on the horizon. For library developers, this situation creates a burden. Maintaining multiple older versions to support users who haven’t migrated is both costly and time-consuming. For users, frequent changes risk eroding trust. They may hesitate to upgrade or start exploring more stable alternatives, which perpetuating the cycle. But what if you could help users manage these changes automatically? What if you could release a tool alongside your update that refactors their code for them—renaming functions, updating parameter order, and removing unused code without requiring manual intervention? That’s where codemods come in. Several libraries, including React and Next.js, have already embraced codemods to smooth the path for version bumps. For example, React provides codemods to handle the migration from older API patterns, like the old Context API, to newer ones. So, what exactly is the codemod we’re talking about here? What is a Codemod? A codemod (code modification) is an automated script used to transform code to follow new APIs, syntax, or coding standards. Codemods use Abstract Syntax Tree (AST) manipulation to apply consistent, large-scale changes across codebases. Initially developed at Facebook, codemods helped engineers manage refactoring tasks for large projects like React. As Facebook scaled, maintaining the codebase and updating APIs became increasingly difficult, prompting the development of codemods. Manually updating thousands of files across different repositories was inefficient and error-prone, so the concept of codemods—automated scripts that transform code—was introduced to tackle this problem. The process typically involves three main steps: Parsing the code into an AST, where each part of the code is represented as a tree structure. Modifying the tree by applying a transformation, such as renaming a function or changing parameters. Rewriting the modified tree back into the source code. By using this approach, codemods ensure that changes are applied consistently across every file in a codebase, reducing the chance of human error. Codemods can also handle complex refactoring scenarios, such as changes to deeply nested structures or removing deprecated API usage. If we visualize the process, it would look something like this: Figure 1: The three steps of a typical codemod process The idea of a program that can “understand” your code and then perform automatic transformations isn’t new. That’s how your IDE works when you run refactorings like Extract Function, Rename Variable, or Inline Function. Essentially, your IDE parses the source code into ASTs and applies predefined transformations to the tree, saving the result back into your files. For modern IDEs, many things happen under the hood to ensure changes are applied correctly and efficiently, such as determining the scope of the change and resolving conflicts like variable name collisions. Some refactorings even prompt you to input parameters, such as when using Change Function Declaration, where you can adjust the order of parameters or default values before finalizing the change. Use jscodeshift in JavaScript Codebases Let’s look at a concrete example to understand how we could run a codemod in a JavaScript project. The JavaScript community has several tools that make this work feasible, including parsers that convert source code into an AST, as well as transpilers that can transform the tree into other formats (this is how TypeScript works). Additionally, there are tools that help apply codemods to entire repositories automatically. One of the most popular tools for writing codemods is jscodeshift, a toolkit maintained by Facebook. It simplifies the creation of codemods by providing a powerful API to manipulate ASTs. With jscodeshift, developers can search for specific patterns in the code and apply transformations at scale. You can use jscodeshift to identify and replace deprecated API calls with updated versions across an entire project. Let’s break down a typical workflow for composing a codemod manually. Clean a Stale Feature Toggle Let’s start with a simple yet practical example to demonstrate the power of codemods. Imagine you’re using a feature toggle in your codebase to control the release of unfinished or experimental features. Once the feature is live in production and working as expected, the next logical step is to clean up the toggle and any related logic. For instance, consider the following code: const data = featureToggle('feature-new-product-list') ? { name: 'Product' } : undefined; Once the feature is fully released and no longer needs a toggle, this can be simplified to: const data = { name: 'Product' }; The task involves finding all instances of featureToggle in the codebase, checking whether the toggle refers to feature-new-product-list, and removing the conditional logic surrounding it. At the same time, other feature toggles (like feature-search-result-refinement, which may still be in development) should remain untouched. The codemod needs to understand the structure of the code to apply changes selectively. Understanding the AST Before we dive into writing the codemod, let’s break down how this specific code snippet looks in an AST. You can use tools like AST Explorer to visualize how source code and AST are mapped. It’s helpful to understand the node types you're interacting with before applying any changes. The image below shows the syntax tree in terms of ECMAScript syntax. It contains nodes like Identifier (for variables), StringLiteral (for the toggle name), and more abstract nodes like CallExpression and ConditionalExpression. Figure 2: The Abstract Syntax Tree representation of the feature toggle check In this AST representation, the variable data is assigned using a ConditionalExpression. The test part of the expression calls featureToggle('feature-new-product-list'). If the test returns true, the consequent branch assigns { name: 'Product' } to data. If false, the alternate branch assigns undefined. For a task with clear input and output, I prefer writing tests first, then implementing the codemod. I start by defining a negative case to ensure we don’t accidentally change things we want to leave untouched, followed by a real case that performs the actual conversion. I begin with a simple scenario, implement it, then add a variation (like checking if featureToggle is called inside an if statement), implement that case, and ensure all tests pass. This approach aligns well with Test-Driven Development (TDD), even if you don’t practice TDD regularly. Knowing exactly what the transformation's inputs and outputs are before coding improves safety and efficiency, especially when tweaking codemods. With jscodeshift, you can write tests to verify how the codemod behaves: const transform = require(\"../remove-feature-new-product-list\"); defineInlineTest( transform, {}, ` const data = featureToggle('feature-new-product-list') ? { name: 'Product' } : undefined; `, ` const data = { name: 'Product' }; `, \"delete the toggle feature-new-product-list in conditional operator\" ); The defineInlineTest function from jscodeshift allows you to define the input, expected output, and a string describing the test's intent. Now, running the test with a normal jest command will fail because the codemod isn’t written yet. The corresponding negative case would ensure the code remains unchanged for other feature toggles: defineInlineTest( transform, {}, ` const data = featureToggle('feature-search-result-refinement') ? { name: 'Product' } : undefined; `, ` const data = featureToggle('feature-search-result-refinement') ? { name: 'Product' } : undefined; `, \"do not change other feature toggles\" ); Writing the Codemod Let’s start by defining a simple transform function. Create a file called transform.js with the following code structure: module.exports = function(fileInfo, api, options) { const j = api.jscodeshift; const root = j(fileInfo.source); // manipulate the tree nodes here return root.toSource(); }; This function reads the file into a tree and uses jscodeshift’s API to query, modify, and update the nodes. Finally, it converts the AST back to source code with .toSource(). Now we can start implementing the transform steps: Find all instances of featureToggle. Verify that the argument passed is 'feature-new-product-list'. Replace the entire conditional expression with the consequent part, effectively removing the toggle. Here’s how we achieve this using jscodeshift: module.exports = function (fileInfo, api, options) { const j = api.jscodeshift; const root = j(fileInfo.source); // Find ConditionalExpression where the test is featureToggle('feature-new-product-list') root .find(j.ConditionalExpression, { test: { callee: { name: \"featureToggle\" }, arguments: [{ value: \"feature-new-product-list\" }], }, }) .forEach((path) =\u003e { // Replace the ConditionalExpression with the 'consequent' j(path).replaceWith(path.node.consequent); }); return root.toSource(); }; The codemod above: Finds ConditionalExpression nodes where the test calls featureToggle('feature-new-product-list'). Replaces the entire conditional expression with the consequent (i.e., { name: 'Product' }), removing the toggle logic and leaving simplified code behind. This example demonstrates how easy it is to create a useful transformation and apply it to a large codebase, significantly reducing manual effort. You’ll need to write more test cases to handle variations like if-else statements, logical expressions (e.g., !featureToggle('feature-new-product-list')), and so on to make the codemod robust in real-world scenarios. Once the codemod is ready, you can test it out on a target codebase, such as the one you're working on. jscodeshift provides a command-line tool that you can use to apply the codemod and report the results. $ jscodeshift -t transform-name src/ After validating the results, check that all functional tests still pass and that nothing breaks—even if you're introducing a breaking change. Once satisfied, you can commit the changes and raise a pull request as part of your normal workflow. Codemods Improve Code Quality and Maintainability Codemods aren’t just useful for managing breaking API changes—they can significantly improve code quality and maintainability. As codebases evolve, they often accumulate technical debt, including outdated feature toggles, deprecated methods, or tightly coupled components. Manually refactoring these areas can be time-consuming and error-prone. By automating refactoring tasks, codemods help keep your codebase clean and free of legacy patterns. Regularly applying codemods allows you to enforce new coding standards, remove unused code, and modernize your codebase without having to manually modify every file. Refactoring an Avatar Component Now, let’s look at a more complex example. Suppose you’re working with a design system that includes an Avatar component tightly coupled with a Tooltip. Whenever a user passes a name prop into the Avatar, it automatically wraps the avatar with a tooltip. Figure 3: A avatar component with a tooltip Here’s the current Avatar implementation: import { Tooltip } from \"@design-system/tooltip\"; const Avatar = ({ name, image }: AvatarProps) =\u003e { if (name) { return ( \u003cTooltip content={name}\u003e \u003cCircleImage image={image} /\u003e \u003c/Tooltip\u003e ); } return \u003cCircleImage image={image} /\u003e; }; The goal is to decouple the Tooltip from the Avatar component, giving developers more flexibility. Developers should be able to decide whether to wrap the Avatar in a Tooltip. In the refactored version, Avatar will simply render the image, and users can apply a Tooltip manually if needed. Here’s the refactored version of Avatar: const Avatar = ({ image }: AvatarProps) =\u003e { return \u003cCircleImage image={image} /\u003e; }; Now, users can manually wrap the Avatar with a Tooltip as needed: import { Tooltip } from \"@design-system/tooltip\"; import { Avatar } from \"@design-system/avatar\"; const UserProfile = () =\u003e { return ( \u003cTooltip content=\"Juntao Qiu\"\u003e \u003cAvatar image=\"/juntao.qiu.avatar.png\" /\u003e \u003c/Tooltip\u003e ); }; The challenge arises when there are hundreds of Avatar usages spread across the codebase. Manually refactoring each instance would be highly inefficient, so we can use a codemod to automate this process. Using tools like AST Explorer, we can inspect the component and see which nodes represent the Avatar usage we’re targeting. An Avatar component with both name and image props is parsed into an abstract syntax tree as shown below: Figure 4: AST of the Avatar component usage Writing the Codemod Let’s break down the transformation into smaller tasks: Find Avatar usage in the component tree. Check if the name prop is present. If not, do nothing. If present: Create a Tooltip node. Add the name to the Tooltip. Remove the name from Avatar. Add Avatar as a child of the Tooltip. Replace the original Avatar node with the new Tooltip. To begin, we’ll find all instances of Avatar (I’ll omit some of the tests, but you should write comparison tests first). defineInlineTest( { default: transform, parser: \"tsx\" }, {}, ` \u003cAvatar name=\"Juntao Qiu\" image=\"/juntao.qiu.avatar.png\" /\u003e `, ` \u003cTooltip content=\"Juntao Qiu\"\u003e \u003cAvatar image=\"/juntao.qiu.avatar.png\" /\u003e \u003c/Tooltip\u003e `, \"wrap avatar with tooltip when name is provided\" ); Similar to the featureToggle example, we can use root.find with search criteria to locate all Avatar nodes: root .find(j.JSXElement, { openingElement: { name: { name: \"Avatar\" } }, }) .forEach((path) =\u003e { // now we can handle each Avatar instance }); Next, we check if the name prop is present: root .find(j.JSXElement, { openingElement: { name: { name: \"Avatar\" } }, }) .forEach((path) =\u003e { const avatarNode = path.node; const nameAttr = avatarNode.openingElement.attributes.find( (attr) =\u003e attr.name.name === \"name\" ); if (nameAttr) { const tooltipElement = createTooltipElement( nameAttr.value.value, avatarNode ); j(path).replaceWith(tooltipElement); } }); For the createTooltipElement function, we use the jscodeshift API to create a new JSX node, with the name prop applied to the Tooltip and the Avatar component as a child. Finally, we call replaceWith to replace the current path. Here’s a preview of how it looks in Hypermod, where the codemod is written on the left. The top part on the right is the original code, and the bottom part is the transformed result: Figure 5: Run checks inside hypermod before apply it to your codebase This codemod searches for all instances of Avatar. If a name prop is found, it removes the name prop from Avatar, wraps the Avatar inside a Tooltip, and passes the name prop to the Tooltip. By now, I hope it’s clear that codemods are incredibly useful and that the workflow is intuitive, especially for large-scale changes where manual updates would be a huge burden. However, that's not the whole picture. In the next section, I’ll shed light on some of the challenges and how we can address these less-than-ideal aspects. We're releasing this article in installments. Future installments will talk about how to compose codemods to deal with common problems, and tools such as OpenRewrite to do this in other languages. To find out when we publish the next installment subscribe to this site's RSS feed, or Martin's feeds on Mastodon, Bluesky, LinkedIn, or X (Twitter).",
  "image": "https://martinfowler.com/articles/codemods-api-refactoring/card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eAs a library developer, you may create a popular utility that hundreds of\n    thousands of developers rely on daily, such as lodash or React. Over time,\n    usage patterns might emerge that go beyond your initial design. When this\n    happens, you may need to extend an API by adding parameters or modifying\n    function signatures to fix edge cases. The challenge lies in rolling out\n    these breaking changes without disrupting your users’ workflows.\u003c/p\u003e\n\n\u003cp\u003eThis is where \u003ci\u003ecodemods\u003c/i\u003e come in—a powerful tool for automating\n    large-scale code transformations, allowing developers to introduce breaking\n    API changes, refactor legacy codebases, and maintain code hygiene with\n    minimal manual effort.\u003c/p\u003e\n\n\u003cp\u003eIn this article, we’ll explore what codemods are and the tools you can\n    use to create them, such as \u003ca href=\"https://github.com/facebook/jscodeshift\"\u003ejscodeshift\u003c/a\u003e, \u003ca href=\"https://www.hypermod.io/\"\u003ehypermod.io\u003c/a\u003e, and \u003ca href=\"http://codemod.com/\"\u003ecodemod.com\u003c/a\u003e. We’ll walk through real-world examples,\n    from cleaning up feature toggles to refactoring component hierarchies.\n    You’ll also learn how to break down complex transformations into smaller,\n    testable pieces—a practice known as codemod composition—to ensure\n    flexibility and maintainability.\u003c/p\u003e\n\n\u003cp\u003eBy the end, you’ll see how codemods can become a vital part of your\n    toolkit for managing large-scale codebases, helping you keep your code clean\n    and maintainable while handling even the most challenging refactoring\n    tasks.\u003c/p\u003e\n\n\u003csection id=\"BreakingChangesInApis\"\u003e\n\u003ch2\u003eBreaking Changes in APIs\u003c/h2\u003e\n\n\u003cp\u003eReturning to the scenario of the library developer, after the initial\n      release, new usage patterns emerge, prompting the need to extend an\n      API—perhaps by adding a parameter or modifying a function signature to\n      make it easier to use.\u003c/p\u003e\n\n\u003cp\u003eFor simple changes, a basic find-and-replace in the IDE might work. In\n      more complex cases, you might resort to using tools like \u003ccode\u003esed\u003c/code\u003e\n      or \u003ccode\u003eawk\u003c/code\u003e. However, when your library is widely adopted, the\n      scope of such changes becomes harder to manage. You can’t be sure how\n      extensively the modification will impact your users, and the last thing\n      you want is to break existing functionality that doesn’t need\n      updating.\u003c/p\u003e\n\n\u003cp\u003eA common approach is to announce the breaking change, release a new\n      version, and ask users to migrate at their own pace. But this workflow,\n      while familiar, often doesn\u0026#39;t scale well, especially for major shifts.\n      Consider React’s transition from class components to function components\n      with hooks—a paradigm shift that took years for large codebases to fully\n      adopt. By the time teams managed to migrate, more breaking changes were\n      often already on the horizon.\u003c/p\u003e\n\n\u003cp\u003eFor library developers, this situation creates a burden. Maintaining\n      multiple older versions to support users who haven’t migrated is both\n      costly and time-consuming. For users, frequent changes risk eroding trust.\n      They may hesitate to upgrade or start exploring more stable alternatives,\n      which perpetuating the cycle.\u003c/p\u003e\n\n\u003cp\u003eBut what if you could help users manage these changes automatically?\n      What if you could release a tool alongside your update that refactors\n      their code for them—renaming functions, updating parameter order, and\n      removing unused code without requiring manual intervention?\u003c/p\u003e\n\n\u003cp\u003eThat’s where codemods come in. Several libraries, including React\n      and Next.js, have already embraced codemods to smooth the path for version\n      bumps. For example, React provides codemods to handle the migration from\n      older API patterns, like the old Context API, to newer ones.\u003c/p\u003e\n\n\u003cp\u003eSo, what exactly is the codemod we’re talking about here?\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"WhatIsACodemod\"\u003e\n\u003ch2\u003eWhat is a Codemod?\u003c/h2\u003e\n\n\u003cp\u003eA \u003cb\u003ecodemod\u003c/b\u003e (code modification) is an automated script used to transform\n      code to follow new APIs, syntax, or coding standards. Codemods use\n      Abstract Syntax Tree (AST) manipulation to apply consistent, large-scale\n      changes across codebases. Initially developed at Facebook, codemods helped\n      engineers manage refactoring tasks for large projects like React. As\n      Facebook scaled, maintaining the codebase and updating APIs became\n      increasingly difficult, prompting the development of codemods.\u003c/p\u003e\n\n\u003cp\u003eManually updating thousands of files across different repositories was\n      inefficient and error-prone, so the concept of codemods—automated scripts\n      that transform code—was introduced to tackle this problem.\u003c/p\u003e\n\n\u003cp\u003eThe process typically involves three main steps:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ci\u003eParsing\u003c/i\u003e the code into an AST, where each part of the code is\n        represented as a tree structure.\u003c/li\u003e\n\n\u003cli\u003e\u003ci\u003eModifying\u003c/i\u003e the tree by applying a transformation, such as renaming a\n        function or changing parameters.\u003c/li\u003e\n\n\u003cli\u003e\u003ci\u003eRewriting\u003c/i\u003e the modified tree back into the source code.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eBy using this approach, codemods ensure that changes are applied\n      consistently across every file in a codebase, reducing the chance of human\n      error. Codemods can also handle complex refactoring scenarios, such as\n      changes to deeply nested structures or removing deprecated API usage.\u003c/p\u003e\n\n\u003cp\u003eIf we visualize the process, it would look something like this:\u003c/p\u003e\n\n\u003cdiv id=\"codemod-process.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/codemod-process.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 1: The three steps of a typical codemod process\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThe idea of a program that can “understand” your code and then perform\n      automatic transformations isn’t new. That’s how your IDE works when you\n      run refactorings like \u003ca href=\"http://refactoring.com/catalog/extractFunction.html\"\u003e\u003cname\u003eExtract Function\u003c/name\u003e\u003c/a\u003e, \u003ca href=\"http://refactoring.com/catalog/renameVariable.html\"\u003e\u003cname\u003eRename Variable\u003c/name\u003e\u003c/a\u003e, or \u003ca href=\"http://refactoring.com/catalog/inlineFunction.html\"\u003e\u003cname\u003eInline Function\u003c/name\u003e\u003c/a\u003e.\n      Essentially, your IDE parses the source code into ASTs and applies\n      predefined transformations to the tree, saving the result back into your\n      files.\u003c/p\u003e\n\n\u003cp\u003eFor modern IDEs, many things happen under the hood to ensure changes\n      are applied correctly and efficiently, such as determining the scope of\n      the change and resolving conflicts like variable name collisions. Some\n      refactorings even prompt you to input parameters, such as when using\n      \u003ca href=\"http://refactoring.com/catalog/changeFunctionDeclaration.html\"\u003e\u003cname\u003eChange Function Declaration\u003c/name\u003e\u003c/a\u003e, where you can adjust the\n      order of parameters or default values before finalizing the change.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UseJscodeshiftInJavascriptCodebases\"\u003e\n\u003ch2\u003eUse jscodeshift in JavaScript Codebases\u003c/h2\u003e\n\n\u003cp\u003eLet’s look at a concrete example to understand how we could run a\n      codemod in a JavaScript project. The JavaScript community has several\n      tools that make this work feasible, including parsers that convert source\n      code into an AST, as well as transpilers that can transform the tree into\n      other formats (this is how TypeScript works). Additionally, there are\n      tools that help apply codemods to entire repositories automatically.\u003c/p\u003e\n\n\u003cp\u003eOne of the most popular tools for writing codemods is \u003ca href=\"https://github.com/facebook/jscodeshift\"\u003ejscodeshift\u003c/a\u003e, a toolkit maintained by Facebook.\n      It simplifies the creation of codemods by providing a powerful API to\n      manipulate ASTs. With jscodeshift, developers can search for specific\n      patterns in the code and apply transformations at scale.\u003c/p\u003e\n\n\u003cp\u003eYou can use \u003ccode\u003ejscodeshift\u003c/code\u003e to identify and replace deprecated API calls\n      with updated versions across an entire project.\u003c/p\u003e\n\n\u003cp\u003eLet’s break down a typical workflow for composing a codemod\n      manually.\u003c/p\u003e\n\n\u003csection id=\"feature-toggle-example\"\u003e\n\u003ch3\u003eClean a Stale Feature Toggle\u003c/h3\u003e\n\n\u003cp\u003eLet’s start with a simple yet practical example to demonstrate the\n        power of codemods. Imagine you’re using a \u003ca href=\"https://martinfowler.com/articles/feature-toggles.html\"\u003efeature\n        toggle\u003c/a\u003e in your\n        codebase to control the release of unfinished or experimental features.\n        Once the feature is live in production and working as expected, the next\n        logical step is to clean up the toggle and any related logic.\u003c/p\u003e\n\n\u003cp\u003eFor instance, consider the following code:\u003c/p\u003e\n\n\u003cpre\u003econst data = featureToggle(\u0026#39;feature-new-product-list\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n\u003c/pre\u003e\n\n\u003cp\u003eOnce the feature is fully released and no longer needs a toggle, this\n        can be simplified to:\u003c/p\u003e\n\n\u003cpre\u003econst data = { name: \u0026#39;Product\u0026#39; };\n\u003c/pre\u003e\n\n\u003cp\u003eThe task involves finding all instances of \u003ccode\u003efeatureToggle\u003c/code\u003e in the\n        codebase, checking whether the toggle refers to\n        \u003ccode\u003efeature-new-product-list\u003c/code\u003e, and removing the conditional logic surrounding\n        it. At the same time, other feature toggles (like\n        \u003ccode\u003efeature-search-result-refinement\u003c/code\u003e, which may still be in development)\n        should remain untouched. The codemod needs to \u003ci\u003eunderstand\u003c/i\u003e the structure\n        of the code to apply changes selectively.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UnderstandingTheAst\"\u003e\n\u003ch3\u003eUnderstanding the AST\u003c/h3\u003e\n\n\u003cp\u003eBefore we dive into writing the codemod, let’s break down how this\n        specific code snippet looks in an AST. You can use tools like \u003ca href=\"https://astexplorer.net/\"\u003eAST\n        Explorer\u003c/a\u003e to visualize how source code and AST\n        are mapped. It’s helpful to understand the node types you\u0026#39;re interacting\n        with before applying any changes.\u003c/p\u003e\n\n\u003cp\u003eThe image below shows the syntax tree in terms of ECMAScript syntax. It\n        contains nodes like \u003ccode\u003eIdentifier\u003c/code\u003e (for variables), \u003ccode\u003eStringLiteral\u003c/code\u003e (for the\n        toggle name), and more abstract nodes like \u003ccode\u003eCallExpression\u003c/code\u003e and\n        \u003ccode\u003eConditionalExpression\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv id=\"ast-feature-toggle.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/ast-feature-toggle.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 2: The Abstract Syntax Tree representation of the feature toggle check\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eIn this AST representation, the variable \u003ccode\u003edata\u003c/code\u003e is assigned using a\n        \u003ccode\u003eConditionalExpression\u003c/code\u003e. The \u003ci\u003etest\u003c/i\u003e part of the expression calls\n        \u003ccode\u003efeatureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e. If the test returns \u003ccode\u003etrue\u003c/code\u003e,\n        the \u003ci\u003econsequent\u003c/i\u003e branch assigns \u003ccode\u003e{ name: \u0026#39;Product\u0026#39; }\u003c/code\u003e to \u003ccode\u003edata\u003c/code\u003e. If\n        \u003ccode\u003efalse\u003c/code\u003e, the \u003ci\u003ealternate\u003c/i\u003e branch assigns \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor a task with clear input and output, I prefer writing tests first,\n        then implementing the codemod. I start by defining a negative case to\n        ensure we don’t accidentally change things we want to leave untouched,\n        followed by a real case that performs the actual conversion. I begin with\n        a simple scenario, implement it, then add a variation (like checking if\n        featureToggle is called inside an if statement), implement that case, and\n        ensure all tests pass.\u003c/p\u003e\n\n\u003cp\u003eThis approach aligns well with \u003ca href=\"https://martinfowler.com/bliki/TestDrivenDevelopment.html\"\u003eTest-Driven Development (TDD)\u003c/a\u003e, even\n        if you don’t practice TDD regularly. Knowing exactly what the\n        transformation\u0026#39;s inputs and outputs are before coding improves safety and\n        efficiency, especially when tweaking codemods.\u003c/p\u003e\n\n\u003cp\u003eWith jscodeshift, you can write tests to verify how the codemod\n        behaves:\u003c/p\u003e\n\n\u003cpre\u003econst \u003cspan\u003etransform\u003c/span\u003e = require(\u0026#34;../remove-feature-new-product-list\u0026#34;);\n\ndefineInlineTest(\n  \u003cspan\u003etransform\u003c/span\u003e,\n  {},\n  `\n  const data = featureToggle(\u0026#39;feature-new-product-list\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  `\n  const data = { name: \u0026#39;Product\u0026#39; };\n  `,\n  \u0026#34;delete the toggle feature-new-product-list in conditional operator\u0026#34;\n);\n\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003edefineInlineTest\u003c/code\u003e function from jscodeshift allows you to define\n        the input, expected output, and a string describing the test\u0026#39;s intent.\n        Now, running the test with a normal \u003ccode\u003ejest\u003c/code\u003e command will fail because the\n        codemod isn’t written yet.\u003c/p\u003e\n\n\u003cp\u003eThe corresponding negative case would ensure the code remains \u003ci\u003eunchanged\u003c/i\u003e\n        for other feature toggles:\u003c/p\u003e\n\n\u003cpre\u003edefineInlineTest(\n  transform,\n  {},\n  `\n  const data = featureToggle(\u0026#39;feature-search-result-refinement\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  `\n  const data = featureToggle(\u0026#39;feature-search-result-refinement\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  \u0026#34;do not change other feature toggles\u0026#34;\n);\n\u003c/pre\u003e\n\u003c/section\u003e\n\n\u003csection id=\"WritingTheCodemod\"\u003e\n\u003ch3\u003eWriting the Codemod\u003c/h3\u003e\n\n\u003cp\u003eLet’s start by defining a simple \u003ci\u003etransform\u003c/i\u003e function. Create a file\n        called \u003ccode\u003etransform.js\u003c/code\u003e with the following code structure:\u003c/p\u003e\n\n\u003cpre\u003emodule.exports = function(fileInfo, api, options) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n\n  // manipulate the tree nodes here\n\n  return root.toSource();\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis function reads the file into a tree and uses jscodeshift’s API to\n        query, modify, and update the nodes. Finally, it converts the AST back to\n        source code with \u003ccode\u003e.toSource()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNow we can start implementing the transform steps:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eFind all instances of \u003ccode\u003efeatureToggle\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eVerify that the argument passed is \u003ccode\u003e\u0026#39;feature-new-product-list\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eReplace the entire conditional expression with the \u003ci\u003econsequent\u003c/i\u003e part,\n          effectively removing the toggle.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eHere’s how we achieve this using \u003ccode\u003ejscodeshift\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003emodule.exports = function (fileInfo, api, options) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n\n  // Find ConditionalExpression where the test is featureToggle(\u0026#39;feature-new-product-list\u0026#39;)\n  root\n    .find(j.ConditionalExpression, {\n      test: {\n        callee: { name: \u0026#34;featureToggle\u0026#34; },\n        arguments: [{ value: \u0026#34;feature-new-product-list\u0026#34; }],\n      },\n    })\n    .forEach((path) =\u0026gt; {\n      // Replace the ConditionalExpression with the \u0026#39;consequent\u0026#39;\n      j(path).replaceWith(path.node.consequent);\n    });\n\n  return root.toSource();\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe codemod above:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFinds \u003ccode\u003eConditionalExpression\u003c/code\u003e nodes where the test calls\n          \u003ccode\u003efeatureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eReplaces the entire conditional expression with the consequent (i.e., \u003ccode\u003e{\n          name: \u0026#39;Product\u0026#39; }\u003c/code\u003e), removing the toggle logic and leaving simplified code\n          behind.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis example demonstrates how easy it is to create a useful\n        transformation and apply it to a large codebase, significantly reducing\n        manual effort.\u003c/p\u003e\n\n\u003cp\u003eYou’ll need to write more test cases to handle variations like\n        \u003ccode\u003eif-else\u003c/code\u003e statements, logical expressions (e.g.,\n        \u003ccode\u003e!featureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e), and so on to make the\n        codemod robust in real-world scenarios.\u003c/p\u003e\n\n\u003cp\u003eOnce the codemod is ready, you can test it out on a target codebase,\n        such as the one you\u0026#39;re working on. jscodeshift provides a command-line\n        tool that you can use to apply the codemod and report the results.\u003c/p\u003e\n\n\u003cpre\u003e$ jscodeshift -t transform-name src/\n\u003c/pre\u003e\n\n\u003cp\u003eAfter validating the results, check that all functional tests still\n        pass and that nothing breaks—even if you\u0026#39;re introducing a breaking change.\n        Once satisfied, you can commit the changes and raise a pull request as\n        part of your normal workflow.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"CodemodsImproveCodeQualityAndMaintainability\"\u003e\n\u003ch3\u003eCodemods Improve Code Quality and Maintainability\u003c/h3\u003e\n\n\u003cp\u003eCodemods aren’t just useful for managing breaking API changes—they can\n        significantly improve code quality and maintainability. As codebases\n        evolve, they often accumulate technical debt, including outdated feature\n        toggles, deprecated methods, or tightly coupled components. Manually\n        refactoring these areas can be time-consuming and error-prone.\u003c/p\u003e\n\n\u003cp\u003eBy automating refactoring tasks, codemods help keep your codebase clean\n        and free of legacy patterns. Regularly applying codemods allows you to\n        enforce new coding standards, remove unused code, and modernize your\n        codebase without having to manually modify every file.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"RefactoringAnAvatarComponent\"\u003e\n\u003ch3\u003eRefactoring an Avatar Component\u003c/h3\u003e\n\n\u003cp\u003eNow, let’s look at a more complex example. Suppose you’re working with\n        a design system that includes an \u003ccode\u003eAvatar\u003c/code\u003e component tightly coupled with a\n        \u003ccode\u003eTooltip\u003c/code\u003e. Whenever a user passes a \u003ccode\u003ename\u003c/code\u003e prop into the \u003ccode\u003eAvatar\u003c/code\u003e, it\n        automatically wraps the avatar with a tooltip.\u003c/p\u003e\n\n\u003cdiv id=\"avatar-section.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/avatar-section.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 3: A avatar component with a tooltip\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eHere’s the current \u003ccode\u003eAvatar\u003c/code\u003e implementation:\u003c/p\u003e\n\n\u003cpre\u003eimport { Tooltip } from \u0026#34;@design-system/tooltip\u0026#34;;\n\nconst Avatar = ({ name, image }: AvatarProps) =\u0026gt; {\n  if (name) {\n    return (\n      \u0026lt;Tooltip content={name}\u0026gt;\n        \u0026lt;CircleImage image={image} /\u0026gt;\n      \u0026lt;/Tooltip\u0026gt;\n    );\n  }\n\n  return \u0026lt;CircleImage image={image} /\u0026gt;;\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe goal is to decouple the \u003ccode\u003eTooltip\u003c/code\u003e from the \u003ccode\u003eAvatar\u003c/code\u003e component,\n        giving developers more flexibility. Developers should be able to decide\n        whether to wrap the \u003ccode\u003eAvatar\u003c/code\u003e in a \u003ccode\u003eTooltip\u003c/code\u003e. In the refactored version,\n        \u003ccode\u003eAvatar\u003c/code\u003e will simply render the image, and users can apply a \u003ccode\u003eTooltip\u003c/code\u003e\n        manually if needed.\u003c/p\u003e\n\n\u003cp\u003eHere’s the refactored version of \u003ccode\u003eAvatar\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003econst Avatar = ({ image }: AvatarProps) =\u0026gt; {\n  return \u0026lt;CircleImage image={image} /\u0026gt;;\n};\n\u003c/pre\u003e\n\n\u003cp\u003eNow, users can manually wrap the \u003ccode\u003eAvatar\u003c/code\u003e with a \u003ccode\u003eTooltip\u003c/code\u003e as\n        needed:\u003c/p\u003e\n\n\u003cpre\u003eimport { Tooltip } from \u0026#34;@design-system/tooltip\u0026#34;;\nimport { Avatar } from \u0026#34;@design-system/avatar\u0026#34;;\n\nconst UserProfile = () =\u0026gt; {\n  return (\n    \u0026lt;Tooltip content=\u0026#34;Juntao Qiu\u0026#34;\u0026gt;\n      \u0026lt;Avatar image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    \u0026lt;/Tooltip\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe challenge arises when there are hundreds of Avatar usages spread\n        across the codebase. Manually refactoring each instance would be highly\n        inefficient, so we can use a codemod to automate this process.\u003c/p\u003e\n\n\u003cp\u003eUsing tools like \u003ca href=\"https://astexplorer.net/\"\u003eAST Explorer\u003c/a\u003e, we can\n        inspect the component and see which nodes represent the \u003ccode\u003eAvatar\u003c/code\u003e usage\n        we’re targeting. An \u003ccode\u003eAvatar\u003c/code\u003e component with both \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eimage\u003c/code\u003e props \n        is parsed into an abstract syntax tree as shown below:\u003c/p\u003e\n\n\u003cdiv id=\"avatar-ast.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/avatar-ast.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 4: AST of the Avatar component usage\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"WritingTheCodemod\"\u003e\n\u003ch3\u003eWriting the Codemod\u003c/h3\u003e\n\n\u003cp\u003eLet’s break down the transformation into smaller tasks:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFind \u003ccode\u003eAvatar\u003c/code\u003e usage in the component tree.\u003c/li\u003e\n\n\u003cli\u003eCheck if the \u003ccode\u003ename\u003c/code\u003e prop is present.\u003c/li\u003e\n\n\u003cul\u003e\n\u003cli\u003e If not, do nothing.\u003c/li\u003e\n\n\u003cli\u003e If present:\u003c/li\u003e\n\n\u003cul\u003e\n\u003cli\u003e Create a \u003ccode\u003eTooltip\u003c/code\u003e node.\u003c/li\u003e\n\n\u003cli\u003e Add the \u003ccode\u003ename\u003c/code\u003e to the \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Remove the \u003ccode\u003ename\u003c/code\u003e from \u003ccode\u003eAvatar\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Add \u003ccode\u003eAvatar\u003c/code\u003e as a child of the \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Replace the original \u003ccode\u003eAvatar\u003c/code\u003e node with the new \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cul\u003e\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo begin, we’ll find all instances of Avatar (I’ll omit some of the\n        tests, but you should write comparison tests first).\u003c/p\u003e\n\n\u003cpre\u003edefineInlineTest(\n    { default: transform, \u003cspan\u003eparser\u003c/span\u003e: \u0026#34;tsx\u0026#34; },\n    {},\n    `\n    \u0026lt;Avatar name=\u0026#34;Juntao Qiu\u0026#34; image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    `,\n    `\n    \u0026lt;Tooltip content=\u0026#34;Juntao Qiu\u0026#34;\u0026gt;\n      \u0026lt;Avatar image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    \u0026lt;/Tooltip\u0026gt;\n    `,\n    \u0026#34;wrap avatar with tooltip when name is provided\u0026#34;\n  );\n\u003c/pre\u003e\n\n\u003cp\u003eSimilar to the \u003ccode\u003efeatureToggle\u003c/code\u003e example, we can use \u003ccode\u003eroot.find\u003c/code\u003e with\n        search criteria to locate all Avatar nodes:\u003c/p\u003e\n\n\u003cpre\u003eroot\n  .find(j.JSXElement, {\n    openingElement: { name: { name: \u0026#34;Avatar\u0026#34; } },\n  })\n  .forEach((path) =\u0026gt; {\n    // now we can handle each Avatar instance\n  });\n\u003c/pre\u003e\n\n\u003cp\u003eNext, we check if the \u003ccode\u003ename\u003c/code\u003e prop is present:\u003c/p\u003e\n\n\u003cpre\u003eroot\n  .find(j.JSXElement, {\n    openingElement: { name: { name: \u0026#34;Avatar\u0026#34; } },\n  })\n  .forEach((path) =\u0026gt; {\n    const avatarNode = path.node;\n\n    const nameAttr = avatarNode.openingElement.attributes.find(\n      (attr) =\u0026gt; attr.name.name === \u0026#34;name\u0026#34;\n    );\n\n    if (nameAttr) {\n      const tooltipElement = createTooltipElement(\n        nameAttr.value.value,\n        avatarNode\n      );\n      j(path).\u003cspan\u003ereplaceWith\u003c/span\u003e(tooltipElement);\n    }\n  });\n\u003c/pre\u003e\n\n\u003cp\u003eFor the \u003ccode\u003ecreateTooltipElement\u003c/code\u003e function, we use the\n        jscodeshift API to create a new JSX node, with the \u003ccode\u003ename\u003c/code\u003e\n        prop applied to the \u003ccode\u003eTooltip\u003c/code\u003e and the \u003ccode\u003eAvatar\u003c/code\u003e\n        component as a child. Finally, we call \u003ccode\u003ereplaceWith\u003c/code\u003e to\n        replace the current \u003ccode\u003epath\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere’s a preview of how it looks in\n        \u003ca href=\"https://www.hypermod.io/\"\u003eHypermod\u003c/a\u003e, where the codemod is written on\n        the left. The top part on the right is the original code, and the bottom\n        part is the transformed result:\u003c/p\u003e\n\n\u003cdiv id=\"hypermod.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/hypermod.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 5: Run checks inside hypermod before apply it to your codebase\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis codemod searches for all instances of \u003ccode\u003eAvatar\u003c/code\u003e. If a\n        \u003ccode\u003ename\u003c/code\u003e prop is found, it removes the \u003ccode\u003ename\u003c/code\u003e prop\n        from \u003ccode\u003eAvatar\u003c/code\u003e, wraps the \u003ccode\u003eAvatar\u003c/code\u003e inside a\n        \u003ccode\u003eTooltip\u003c/code\u003e, and passes the \u003ccode\u003ename\u003c/code\u003e prop to the\n        \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBy now, I hope it’s clear that codemods are incredibly useful and\n        that the workflow is intuitive, especially for large-scale changes where\n        manual updates would be a huge burden. However, that\u0026#39;s not the whole\n        picture. In the next section, I’ll shed light on some of the challenges\n        and how we can address these less-than-ideal aspects.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eWe\u0026#39;re releasing this article in installments. Future installments\n        will talk about how to compose codemods to deal with common problems,\n        and tools such as OpenRewrite to do this in other languages.\u003c/p\u003e\n\n\n\u003cp\u003e To find out when we publish the next installment subscribe to this\n    site\u0026#39;s\n    \u003ca href=\"https://martinfowler.com/feed.atom\"\u003eRSS feed\u003c/a\u003e, or Martin\u0026#39;s feeds on\n    \u003ca href=\"https://toot.thoughtworks.com/@mfowler\"\u003eMastodon\u003c/a\u003e,\n    \u003ca href=\"https://bsky.app/profile/martinfowler.com\"\u003eBluesky\u003c/a\u003e,\n    \u003ca href=\"https://www.linkedin.com/in/martin-fowler-com/\"\u003eLinkedIn\u003c/a\u003e, or\n    \u003ca href=\"https://twitter.com/martinfowler\"\u003eX (Twitter)\u003c/a\u003e.\n    \u003c/p\u003e\n\u003c/div\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": null,
  "modifiedTime": "2025-01-07T00:00:00Z"
}
