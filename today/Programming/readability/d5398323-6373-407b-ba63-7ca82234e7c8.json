{
  "id": "d5398323-6373-407b-ba63-7ca82234e7c8",
  "title": "Enhancing AI Powered Developer Tools with Gemini API",
  "link": "https://developers.googleblog.com/en/enhancing-ai-powered-developer-tools-with-gemini-api/",
  "description": "The integration of Gemini's 1.5 models with Sublayer's Ruby-based AI agent framework enables developer teams to automate their documentation process, streamline workflows, and build AI-driven applications.",
  "author": "",
  "published": "",
  "source": "http://feeds.feedburner.com/GDBcode",
  "categories": null,
  "byline": "Vishal Dharmadhikari, Paige Bailey, Scott Werner",
  "length": 7352,
  "excerpt": "The integration of Gemini's 1.5 models with Sublayer's Ruby-based AI agent framework enables developer teams to automate their documentation process, streamline workflows, and build AI-driven applications.",
  "siteName": "",
  "favicon": "",
  "text": "The democratization of AI over the past year has unlocked two big opportunities for developers - making it incredibly easy to integrate cutting-edge AI into their projects and bringing AI-driven efficiencies into their development process.Sublayer, a Ruby based AI agent framework, demonstrates the power and efficiency of the Gemini API by integrating our 1.5 models into their core developer offering as well as within their own tooling workflows.Keeping the Sublayer documentation up-to-date with GeminiOne of the opportunities with AI for developers is to enable teams, especially within small, early stage startups, to do more with less. For many, this could be in something as simple yet crucial as documentation. In their own workflows, Sublayer tackles this by integrating their library with Gemini 1.5 Pro and building AI automations to support the work of keeping their documentation up to date and identifying areas of improvement.“It all came about because Gemini’s massive context window really gives you the breathing room to try out new ideas without getting bogged down in complex, optimized implementations up front,” says Scott Werner, CEO of Sublayer, who recently wrote about this concept in Waste Inferences!The process works like this:Any time a PR is merged into the main Sublayer repository, it triggers an agent to get to work updating the documentation.2. The agent generates a prompt that contains the entire contents of the library, the entire contents of the documentation, and all the relevant contents of the PR along with instructions explaining the task and sends it to Gemini.3. Gemini then responds with structured outputs containing the file paths, names, and contents which the Sublayer library converts into an object to use.4. Finally, the agent takes the structured information it received and uses it to create a new branch, make the requested changes to the files, and submit a new PR. # Get the diff from the PR diff = GithubGetDiffAction.new(repo: repo, pr_number: pr_number).call # Get the contents of the library repository and docs repository code_context = GetContextAction.new(path: code_repo_path).call doc_context = GetContextAction.new(path: doc_repo_path).call # Use Gemini 1.5 Pro to decide whether this PR requires a documentation update result = DocUpdateNecessityGenerator.new( code_context: code_context, doc_context: doc_context, diff: diff ).generate # Use Gemini 1.5 Pro to generate suggested changes to the documentation doc_update_suggestions = DocUpdateSuggestionGenerator.new( code_context: code_context, doc_context: doc_context, context_ignore_list: context_ignore_list, diff: diff ).generate # Use Gemini 1.5 Pro to generate the changes to the suggested files file_updates = DocUpdateGenerator.new( code_context: code_context, suggestions: suggestions, doc_context: doc_context, context_ignore_list: context_ignore_list ).generate # Update each of the files returned by Gemini 1.5 Pro and create a new PR See the complete workflow code in Sublayer’s open source examplesAfter the success of this first project they have expanded further into agents that monitor separate resource repositories to focus on keeping a specific catalog page of their docs up to date. There’s even a similar task that runs overnight where Gemini analyzes the current documentation, identifies a few areas of improvement, ranks them based on impact, and generates a single PR for the Sublayer team to wake up to and review every morning.Bringing AI to the Ruby developer community with Gemini modelsOutside of making their own developer infrastructure and tooling more efficient, Sublayer also supports Gemini models within their core product functionality.Sublayer’s mission is to empower individual developers and small teams to tackle ambitious projects that were previously out of reach due to cost or complexity. They're focused on automating tedious, time-consuming, and repetitive tasks – the perfect use case for AI. This can range from large-scale code migrations, where similar operations need to be repeated thousands of times, to day-to-day efficiencies achieved by automating small tasks on a checklist that drain time and energy.A primary challenge for Sublayer is supporting the Ruby developer community, which has been relatively underserved in the AI ecosystem. Integrating Gemini allowed them to meet the increasing demand for Gemini support within their tools. Sublayer's Gemini implementation is highly efficient, requiring only about 60 lines of code thanks to their abstraction layer. They use structured outputs, interacting with models in a single-turn iterative process. This approach simplifies development and debugging, helping developers build robust applications.\"When building LLM-based apps, break the problem down into the smallest possible components,\" advises Werner. \"You want to design your programs to handle any model output effectively, which may even mean intentionally adding steps for a person to review and edit before moving on.\"LLMs, a core piece of the AI infrastructure puzzleTo Sublayer, LLMs like Gemini are essential pieces of infrastructure, akin to databases. Their framework is designed to seamlessly integrate calls to both Gemini 1.5 Pro and Gemini 1.5 Flash, retrieving structured data that developers can readily utilize in their applications. This approach opens up a world of possibilities, from extracting insights from diverse data sources to generating code and transforming codebases across languages and libraries. Sublayer even uses the Gemini models to enable users to generate new functional components within the framework itself. This \"self-assembling\" characteristic encourages experimentation and allows users to explore novel ideas rapidly.\"Gemini is great at solving all the problems our framework is designed to make easy – code generation, task decomposition, following instructions, and generating new data structures based on examples,\"– Scott Werner, CEO of SublayerWhat’s nextLooking ahead, Sublayer is getting ready to launch Augmentations.ai, a platform that makes the automations they’re creating available to all development teams. Their initial release will feature two tools powered by Gemini 1.5 Pro: Semantic Linting, which allows teams to create AI-powered code review rules that understand context and enforce evolving best practices, and Weekly Summaries, which turns development activity across multiple repositories and product management tools into actionable insights for leadership.They plan to continue utilizing a mix of Gemini 1.5 Pro for more complex tasks and Gemini 1.5 Flash for the more latency-sensitive, user-facing, functionality as they release more tools on the Augmentations platform. This work will also feed back into their open source framework, enabling the Ruby community to take advantage of new Gemini functionality as it comes out, while being driven by real-world use by the Sublayer team.Sublayer's story showcases the transformative potential of the Gemini API. It's a testament to how easily developers can integrate Gemini into their workflows, opening up a world of opportunities for innovation and automation. To start building with Gemini models, read our API documentation.",
  "image": "https://storage.googleapis.com/gweb-developer-goog-blog-assets/images/Gemini-API-Sublayer.2e16d0ba.fill-1200x600.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n    \n      \n    \n\n    \n\n    \n\n    \n\n    \n    \u003cdiv\u003e\n          \n\n\u003cdiv\u003e\n    \u003cp data-block-key=\"v2zde\"\u003eThe democratization of AI over the past year has unlocked two big opportunities for developers - making it incredibly easy to integrate cutting-edge AI into their projects and bringing AI-driven efficiencies into their development process.\u003c/p\u003e\u003cp data-block-key=\"f7v5l\"\u003e\u003ca href=\"https://www.sublayer.com/\"\u003eSublayer\u003c/a\u003e, a Ruby based AI agent framework, demonstrates the power and efficiency of the Gemini API by integrating our 1.5 models into their core developer offering as well as within their own tooling workflows.\u003c/p\u003e\u003ch3 data-block-key=\"e3moi\"\u003e\u003cbr/\u003e\u003cb\u003eKeeping the Sublayer documentation up-to-date with Gemini\u003c/b\u003e\u003cbr/\u003e\u003c/h3\u003e\u003cdiv data-block-key=\"83v16\"\u003e\u003cp\u003eOne of the opportunities with AI for developers is to enable teams, especially within small, early stage startups, to do more with less. For many, this could be in something as simple yet crucial as documentation. In their own workflows, Sublayer tackles this by integrating their library with Gemini 1.5 Pro and building AI automations to support the work of keeping their documentation up to date and identifying areas of improvement.\u003c/p\u003e\u003cp\u003e“It all came about because Gemini’s massive context window really gives you the breathing room to try out new ideas without getting bogged down in complex, optimized implementations up front,” says Scott Werner, CEO of Sublayer, who recently wrote about this concept in \u003ca href=\"https://www.sublayer.com/blog/posts/waste-inferences\"\u003eWaste Inferences!\u003c/a\u003e\u003c/p\u003e\u003cp\u003eThe process works like this:\u003c/p\u003e\u003c/div\u003e\u003col\u003e\u003cli data-block-key=\"c945n\"\u003eAny time a PR is merged into the main Sublayer repository, it triggers an agent to get to work updating the documentation.\u003c/li\u003e\u003c/ol\u003e\u003cp data-block-key=\"8oeti\"\u003e2. The agent generates a prompt that contains the entire contents of the library, the entire contents of the documentation, and all the relevant contents of the PR along with instructions explaining the task and sends it to Gemini.\u003c/p\u003e\u003cp data-block-key=\"35sm6\"\u003e3. Gemini then responds with structured outputs containing the file paths, names, and contents which the Sublayer library converts into an object to use.\u003c/p\u003e\u003cp data-block-key=\"es7q8\"\u003e4. Finally, the agent takes the structured information it received and uses it to create a new branch, make the requested changes to the files, and submit a new PR.\u003c/p\u003e\n\u003c/div\u003e   \n\n\u003cdiv\u003e\u003cpre\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e# Get the diff from the PR\u003c/span\u003e\n\u003cspan\u003ediff\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eGithubGetDiffAction\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erepo\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003erepo\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epr_number\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003epr_number\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e\n\n\u003cspan\u003e# Get the contents of the library repository and docs repository\u003c/span\u003e\n\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eGetContextAction\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecode_repo_path\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e\n\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eGetContextAction\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edoc_repo_path\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e\n\n\u003cspan\u003e# Use Gemini 1.5 Pro to decide whether this PR requires a documentation update\u003c/span\u003e\n\u003cspan\u003eresult\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eDocUpdateNecessityGenerator\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003ediff\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ediff\u003c/span\u003e\n\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egenerate\u003c/span\u003e\n\n\u003cspan\u003e# Use Gemini 1.5 Pro to generate suggested changes to the documentation\u003c/span\u003e\n\u003cspan\u003edoc_update_suggestions\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eDocUpdateSuggestionGenerator\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003econtext_ignore_list\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econtext_ignore_list\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ediff\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ediff\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egenerate\u003c/span\u003e\n\n\u003cspan\u003e# Use Gemini 1.5 Pro to generate the changes to the suggested files\u003c/span\u003e\n\u003cspan\u003efile_updates\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eDocUpdateGenerator\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003enew\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003ecode_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003esuggestions\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003esuggestions\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003edoc_context\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003econtext_ignore_list\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003econtext_ignore_list\u003c/span\u003e\n\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egenerate\u003c/span\u003e\n\n\u003cspan\u003e# Update each of the files returned by Gemini 1.5 Pro and create a new PR\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e  \u003cdiv\u003e\n    \u003cp data-block-key=\"jl5aw\"\u003e\u003ci\u003e\u003csub\u003eSee the complete workflow code in\u003c/sub\u003e\u003c/i\u003e \u003ca href=\"https://github.com/sublayerapp/sublayer/blob/main/.github/workflows/github_actions/update_docs.rb\"\u003e\u003ci\u003e\u003csub\u003eSublayer’s open source examples\u003c/sub\u003e\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\u003cp data-block-key=\"6jtb4\"\u003e\u003cbr/\u003eAfter the success of this first project they have expanded further into agents that monitor separate resource repositories to focus on keeping a specific catalog page of their docs up to date. There’s even a similar task that runs overnight where Gemini analyzes the current documentation, identifies a few areas of improvement, ranks them based on impact, and generates a single PR for the Sublayer team to wake up to and review every morning.\u003c/p\u003e\u003ch3 data-block-key=\"dk4je\"\u003e\u003cb\u003e\u003cbr/\u003eBringing AI to the Ruby developer community with Gemini models\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"co9p8\"\u003eOutside of making their own developer infrastructure and tooling more efficient, Sublayer also supports Gemini models within their core product functionality.\u003c/p\u003e\u003cp data-block-key=\"fr9rm\"\u003eSublayer’s mission is to empower individual developers and small teams to tackle ambitious projects that were previously out of reach due to cost or complexity. They\u0026#39;re focused on automating tedious, time-consuming, and repetitive tasks – the perfect use case for AI. This can range from large-scale code migrations, where similar operations need to be repeated thousands of times, to day-to-day efficiencies achieved by automating small tasks on a checklist that drain time and energy.\u003c/p\u003e\u003cp data-block-key=\"160uc\"\u003eA primary challenge for Sublayer is supporting the Ruby developer community, which has been relatively underserved in the AI ecosystem. Integrating Gemini allowed them to meet the increasing demand for Gemini support within their tools. Sublayer\u0026#39;s Gemini implementation is highly efficient, requiring only about 60 lines of code thanks to their abstraction layer. They use structured outputs, interacting with models in a single-turn iterative process. This approach simplifies development and debugging, helping developers build robust applications.\u003c/p\u003e\u003cp data-block-key=\"8pkha\"\u003e\u0026#34;When building LLM-based apps, break the problem down into the smallest possible components,\u0026#34; advises Werner. \u0026#34;You want to design your programs to handle any model output effectively, which may even mean intentionally adding steps for a person to review and edit before moving on.\u0026#34;\u003c/p\u003e\u003ch3 data-block-key=\"bik75\"\u003e\u003cb\u003e\u003cbr/\u003eLLMs, a core piece of the AI infrastructure puzzle\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"73tdp\"\u003eTo Sublayer, LLMs like Gemini are essential pieces of infrastructure, akin to databases. Their framework is designed to seamlessly integrate calls to both Gemini 1.5 Pro and Gemini 1.5 Flash, retrieving structured data that developers can readily utilize in their applications. This approach opens up a world of possibilities, from extracting insights from diverse data sources to generating code and transforming codebases across languages and libraries. Sublayer even uses the Gemini models to enable users to generate new functional components within the framework itself. This \u0026#34;self-assembling\u0026#34; characteristic encourages experimentation and allows users to explore novel ideas rapidly.\u003c/p\u003e\u003cblockquote data-block-key=\"bjttb\"\u003e\u003ci\u003e\u0026#34;Gemini is great at solving all the problems our framework is designed to make easy – code generation, task decomposition, following instructions, and generating new data structures based on examples,\u0026#34;\u003c/i\u003e\u003csub\u003e\u003cbr/\u003e–\u003c/sub\u003e \u003cb\u003e\u003csub\u003eScott Werner\u003c/sub\u003e\u003c/b\u003e\u003csub\u003e, CEO of Sublayer\u003c/sub\u003e\u003c/blockquote\u003e\u003ch3 data-block-key=\"6ja9k\"\u003e\u003cb\u003e\u003cbr/\u003eWhat’s next\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"5uh5\"\u003eLooking ahead, Sublayer is getting ready to launch \u003ca href=\"http://augmentations.ai/\"\u003eAugmentations.ai\u003c/a\u003e, a platform that makes the automations they’re creating available to all development teams. Their initial release will feature two tools powered by Gemini 1.5 Pro: Semantic Linting, which allows teams to create AI-powered code review rules that understand context and enforce evolving best practices, and Weekly Summaries, which turns development activity across multiple repositories and product management tools into actionable insights for leadership.\u003c/p\u003e\u003cp data-block-key=\"47j8t\"\u003eThey plan to continue utilizing a mix of Gemini 1.5 Pro for more complex tasks and Gemini 1.5 Flash for the more latency-sensitive, user-facing, functionality as they release more tools on the Augmentations platform. This work will also feed back into their open source framework, enabling the Ruby community to take advantage of new Gemini functionality as it comes out, while being driven by real-world use by the Sublayer team.\u003c/p\u003e\u003cp data-block-key=\"cj87h\"\u003eSublayer\u0026#39;s story showcases the transformative potential of the Gemini API. It\u0026#39;s a testament to how easily developers can integrate Gemini into their workflows, opening up a world of opportunities for innovation and automation. To start building with Gemini models, read our \u003ca href=\"http://ai.google.dev/gemini-api\"\u003eAPI documentation\u003c/a\u003e.\u003c/p\u003e\n\u003c/div\u003e \n      \u003c/div\u003e\n    \n\n    \n\n    \n    \n    \n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-11-14T00:00:00Z",
  "modifiedTime": null
}
