{
  "id": "7f741470-1c89-4ff8-8bce-9cb0601c272a",
  "title": "Spinning up a Hugo-powered blog with GitLab Pages",
  "link": "https://www.thirtythreeforty.net/posts/2019/06/spinning-up-a-hugo-blog/",
  "description": "In the name of documenting some of my free time for fun and profit(tm), I am starting a blog. I am many things, but I am not a web developer, so I need something quick and easy to use. At the same time, as a programmer, I really appreciate the ability to script my text documents where needed, and to have automation around my chosen tools. I have elected to use the popular Hugo as the right combination of a) powerful and b) easy to get started with. So, as my first challenge for myself, I would like to automatically build and publish the blog from source every time I upload a change. I would also like to secure the site with HTTPS, because it’s 2019. Unfortunately, my choice of Hugo means I am out of the GitHub Pages ecosystem, which only allows you to use Jekyll. This isn’t really the end of the world, as I am a huge fan of GitLab’s continuous integration (CI), including their very generous free tier of build servers. So I’ll give a quick run-through of what you need to do to get a site online, for free1, in about an hour. This assumes you: 10 min Have followed the excellent Hugo Getting Started Guide 5 min Have initialized a Git repository on GitLab and pushed your blog/code there 20 min Have bought your domain of choice, or are okay with using something.gitlab.io. GitLab CI Right. Let’s set up CI. If you’re already generating your site on the command line with Hugo, this is cake. We’ll use a Docker image with Hugo installed, generate the site, and tag the generated folder as the artifact. Then, GitLab will serve this folder. They have some really good documentation about all this. For some reason, there isn’t an official Hugo Docker image, so for now I’ll use one supplied by GitLab that appears to be well maintained. Here’s the .gitlab-ci.yml file. image: registry.gitlab.com/pages/hugo:latest variables: GIT_SUBMODULE_STRATEGY: recursive pages: script: - hugo artifacts: paths: - public only: - master The important parts are that the job is named pages, the content appears in a public/ directory in the artifact, and the job only runs on the master branch—you don’t want to publish whichever branch you last pushed to! Commit this to the root of the repository, and push. GitLab will run the script and publish your site! In my experience, this takes up to 30 minutes to propagate. Be patient, and do all your validation on your workstation before you publish. Custom domain If you want a custom domain, head to your GitLab repo’s Settings \u003e Pages and add the domain. You will need to validate it by adding a custom DNS TXT record, and point the actual domain at GitLab servers. Note: be sure to leave the TXT record in place! GitLab periodically revalidates it and your site will get un-validated if you remove it. HTTPS If you want a custom domain name for your blog, and you want it accessible via HTTPS, this is where it gets hairy. GitLab does not quite yet support automatic HTTPS with LetsEncrypt for custom domains like GitHub does. So, there are a couple ways to do HTTPS. We could go through CloudFlare, but that requires monkeying with your site’s DNS nameservers and adds an extra account to keep track of. We could also use LetsEncrypt and maybe even use a GitLab CI job to pass the challenges and keep the certificate updated automatically. The DNS challenge, which simply involves adding a DNS record much like GitLab’s challenge earlier, would be ideal for this, because it could be accomplished entirely from a runner with plain certbot. Unfortunately, most DNS providers provide a terrible or nonexistent API, so you’d need to use something like Google Cloud DNS for this to be a viable option. The HTTP challenge sounds like a lot of pain. Normally you’d have a webserver watching a folder that certbot can poke directly, and the challenge would be quick and automated. But with a Git-tracked and Hugo-processed site, you’d need to commit the file, push the file, wait for GitLab Pages to update (which can take a while), etc. This does not sound fun. Fortunately, Rodrigo Dato has done the hard work and written a tool called gitlab-le that does all the steps you need. I have built and published a gitlab-le Docker image that you can grab: $ docker run --rm -it registry.gitlab.com/thirtythreeforty/gitlab-letsencrypt gitlab-le Let’s call this tool from CI by adding a job in .gitlab-ci.yml: certificate: image: registry.gitlab.com/thirtythreeforty/gitlab-letsencrypt script: - | gitlab-le \\ --domain YOUR_DOMAIN \\ --email YOUR_EMAIL \\ --repository YOUR_BLOG_REPO_URL \\ --token $GITLAB_ACCESS_TOKEN \\ --path static/.well-known/acme-challenge when: manual When you generate your access token, it would be smart to put it in a CI variable, so it’s not checked into your repository. Note also that Hugo copies things in the static folder as-is to the output folder, so that’s where we’ll have gitlab-le put the challenge info. When you run this, either via Docker or as a GitLab job, you should see something like: By using Let's Encrypt, you are agreeing to the TOS at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf Uploaded challenge file, polling until it is available at http://www.thirtythreeforty.net/.well-known/acme-challenge/7Vui_I58QATNbtTz1C3CasYriSShSbJKxnCk0IKY5FE Could not find challenge file. Retrying in 30s... Could not find challenge file. Retrying in 30s... Success! Your GitLab page has been configured to use an HTTPS certificate obtained from Let's Encrypt. Try it out: https://www.thirtythreeforty.net (GitLab might take a few minutes to start using your certificate for the first time) This certificate expires on Mon Sep 02 2019 01:59:40 GMT+0000 (Coordinated Universal Time). You will need to run gitlab-le again at some time before this date. You can add this as a periodic job in GitLab if you like. Wrapping up So this blog is built with Hugo, compiled on GitLab CI, hosted on GitLab Pages, and secured via LetsEncrypt. Let me know if you have any feedback on any of this! Renting a domain will of course cost a small fee. ↩︎",
  "author": "George Hilliard",
  "published": "Sat, 01 Jun 2019 00:00:00 +0000",
  "source": "https://www.thirtythreeforty.net/posts/index.xml",
  "categories": null,
  "byline": "",
  "length": 6102,
  "excerpt": "A quick guide to setting up a Hugo GitLab Pages site with automatic LetsEncrypt renewal",
  "siteName": "",
  "favicon": "https://www.thirtythreeforty.net/apple-touch-icon-144-precomposed.png",
  "text": "In the name of documenting some of my free time for fun and profit(tm), I am starting a blog. I am many things, but I am not a web developer, so I need something quick and easy to use. At the same time, as a programmer, I really appreciate the ability to script my text documents where needed, and to have automation around my chosen tools. I have elected to use the popular Hugo as the right combination of a) powerful and b) easy to get started with. So, as my first challenge for myself, I would like to automatically build and publish the blog from source every time I upload a change. I would also like to secure the site with HTTPS, because it’s 2019. Unfortunately, my choice of Hugo means I am out of the GitHub Pages ecosystem, which only allows you to use Jekyll. This isn’t really the end of the world, as I am a huge fan of GitLab’s continuous integration (CI), including their very generous free tier of build servers. So I’ll give a quick run-through of what you need to do to get a site online, for free1, in about an hour. This assumes you: 10 min Have followed the excellent Hugo Getting Started Guide 5 min Have initialized a Git repository on GitLab and pushed your blog/code there 20 min Have bought your domain of choice, or are okay with using something.gitlab.io. GitLab CI Right. Let’s set up CI. If you’re already generating your site on the command line with Hugo, this is cake. We’ll use a Docker image with Hugo installed, generate the site, and tag the generated folder as the artifact. Then, GitLab will serve this folder. They have some really good documentation about all this. For some reason, there isn’t an official Hugo Docker image, so for now I’ll use one supplied by GitLab that appears to be well maintained. Here’s the .gitlab-ci.yml file. image: registry.gitlab.com/pages/hugo:latest variables: GIT_SUBMODULE_STRATEGY: recursive pages: script: - hugo artifacts: paths: - public only: - master The important parts are that the job is named pages, the content appears in a public/ directory in the artifact, and the job only runs on the master branch—you don’t want to publish whichever branch you last pushed to! Commit this to the root of the repository, and push. GitLab will run the script and publish your site! In my experience, this takes up to 30 minutes to propagate. Be patient, and do all your validation on your workstation before you publish. Custom domain If you want a custom domain, head to your GitLab repo’s Settings \u003e Pages and add the domain. You will need to validate it by adding a custom DNS TXT record, and point the actual domain at GitLab servers. Note: be sure to leave the TXT record in place! GitLab periodically revalidates it and your site will get un-validated if you remove it. HTTPS If you want a custom domain name for your blog, and you want it accessible via HTTPS, this is where it gets hairy. GitLab does not quite yet support automatic HTTPS with LetsEncrypt for custom domains like GitHub does. So, there are a couple ways to do HTTPS. We could go through CloudFlare, but that requires monkeying with your site’s DNS nameservers and adds an extra account to keep track of. We could also use LetsEncrypt and maybe even use a GitLab CI job to pass the challenges and keep the certificate updated automatically. The DNS challenge, which simply involves adding a DNS record much like GitLab’s challenge earlier, would be ideal for this, because it could be accomplished entirely from a runner with plain certbot. Unfortunately, most DNS providers provide a terrible or nonexistent API, so you’d need to use something like Google Cloud DNS for this to be a viable option. The HTTP challenge sounds like a lot of pain. Normally you’d have a webserver watching a folder that certbot can poke directly, and the challenge would be quick and automated. But with a Git-tracked and Hugo-processed site, you’d need to commit the file, push the file, wait for GitLab Pages to update (which can take a while), etc. This does not sound fun. Fortunately, Rodrigo Dato has done the hard work and written a tool called gitlab-le that does all the steps you need. I have built and published a gitlab-le Docker image that you can grab: $ docker run --rm -it registry.gitlab.com/thirtythreeforty/gitlab-letsencrypt gitlab-le Let’s call this tool from CI by adding a job in .gitlab-ci.yml: certificate: image: registry.gitlab.com/thirtythreeforty/gitlab-letsencrypt script: - | gitlab-le \\ --domain YOUR_DOMAIN \\ --email YOUR_EMAIL \\ --repository YOUR_BLOG_REPO_URL \\ --token $GITLAB_ACCESS_TOKEN \\ --path static/.well-known/acme-challenge when: manual When you generate your access token, it would be smart to put it in a CI variable, so it’s not checked into your repository. Note also that Hugo copies things in the static folder as-is to the output folder, so that’s where we’ll have gitlab-le put the challenge info. When you run this, either via Docker or as a GitLab job, you should see something like: By using Let's Encrypt, you are agreeing to the TOS at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf Uploaded challenge file, polling until it is available at http://www.thirtythreeforty.net/.well-known/acme-challenge/7Vui_I58QATNbtTz1C3CasYriSShSbJKxnCk0IKY5FE Could not find challenge file. Retrying in 30s... Could not find challenge file. Retrying in 30s... Success! Your GitLab page has been configured to use an HTTPS certificate obtained from Let's Encrypt. Try it out: https://www.thirtythreeforty.net (GitLab might take a few minutes to start using your certificate for the first time) This certificate expires on Mon Sep 02 2019 01:59:40 GMT+0000 (Coordinated Universal Time). You will need to run gitlab-le again at some time before this date. You can add this as a periodic job in GitLab if you like. Wrapping up So this blog is built with Hugo, compiled on GitLab CI, hosted on GitLab Pages, and secured via LetsEncrypt. Let me know if you have any feedback on any of this! Renting a domain will of course cost a small fee. ↩︎",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" tabindex=\"-1\"\u003e\n\u003carticle\u003e\n\u003cheader\u003e\n\n\n\u003c/header\u003e\n\u003cdiv\u003e\n\u003cp\u003eIn the name of documenting some of my free time for fun and profit(tm), I am starting a blog.\nI am many things, but I am not a web developer, so I need something quick and easy to use.\u003c/p\u003e\n\u003cp\u003eAt the same time, as a programmer, I really appreciate the ability to script my text documents where needed, and to have automation around my chosen tools.\nI have elected to use the popular \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e as the right combination of a) powerful and b) easy to get started with.\u003c/p\u003e\n\u003cp\u003eSo, as my first challenge for myself, I would like to automatically build and publish the blog from source every time I upload a change.\nI would also like to secure the site with HTTPS, because it’s 2019.\u003c/p\u003e\n\u003cp\u003eUnfortunately, my choice of Hugo means I am out of the GitHub Pages ecosystem, which \u003ca href=\"https://help.github.com/en/articles/using-jekyll-as-a-static-site-generator-with-github-pages\"\u003eonly allows you to use Jekyll\u003c/a\u003e.\nThis isn’t really the end of the world, as I am a huge fan of GitLab’s continuous integration (CI), including their very generous free tier of build servers.\nSo I’ll give a quick run-through of what you need to do to get a site online, for free\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e, in about an hour.\u003c/p\u003e\n\u003cp\u003eThis assumes you:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e10 min\u003c/strong\u003e Have followed the excellent \u003ca href=\"https://gohugo.io/getting-started/quick-start/\"\u003eHugo Getting Started Guide\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e5 min\u003c/strong\u003e Have initialized a Git repository on GitLab and pushed your blog/code there\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e20 min\u003c/strong\u003e Have bought your domain of choice, or are okay with using \u003cem\u003esomething\u003c/em\u003e.gitlab.io.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"gitlab-ci\"\u003eGitLab CI\u003c/h3\u003e\n\u003cp\u003eRight. Let’s set up CI.\nIf you’re already generating your site on the command line with Hugo, this is cake.\nWe’ll use a Docker image with Hugo installed, generate the site, and tag the generated folder as the artifact.\nThen, GitLab will serve this folder.\nThey have some \u003ca href=\"https://docs.gitlab.com/ee/user/project/pages/getting_started_part_four.html\"\u003ereally good documentation\u003c/a\u003e about all this.\u003c/p\u003e\n\u003cp\u003eFor some reason, there isn’t an official Hugo Docker image, so for now I’ll use one \u003ca href=\"https://gitlab.com/pages/hugo/container_registry\"\u003esupplied by GitLab\u003c/a\u003e that appears to be well maintained.\u003c/p\u003e\n\u003cp\u003eHere’s the \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e file.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yaml\"\u003e\u003cspan\u003eimage\u003c/span\u003e:\u003cspan\u003e \u003c/span\u003eregistry.gitlab.com/pages/hugo:latest\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003evariables\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eGIT_SUBMODULE_STRATEGY\u003c/span\u003e:\u003cspan\u003e \u003c/span\u003erecursive\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003epages\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003escript\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e- hugo\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eartifacts\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003epaths\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e- public\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eonly\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e- master\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe important parts are that the job is named \u003ccode\u003epages\u003c/code\u003e, the content appears in a \u003ccode\u003epublic/\u003c/code\u003e directory in the artifact, and the job only runs on the master branch—you don’t want to publish whichever branch you last pushed to!\u003c/p\u003e\n\u003cp\u003eCommit this to the root of the repository, and push.\nGitLab will run the script and publish your site!\nIn my experience, this takes up to 30 minutes to propagate.\nBe patient, and do all your validation on your workstation before you publish.\u003c/p\u003e\n\u003ch3 id=\"custom-domain\"\u003eCustom domain\u003c/h3\u003e\n\u003cp\u003eIf you want a custom domain, head to your GitLab repo’s Settings \u0026gt; Pages and add the domain.\nYou will need to validate it by adding a custom DNS TXT record, and point the actual domain at GitLab servers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: be sure to leave the TXT record in place!\nGitLab periodically revalidates it and your site will get un-validated if you remove it.\u003c/p\u003e\n\u003ch3 id=\"https\"\u003eHTTPS\u003c/h3\u003e\n\u003cp\u003eIf you want a custom domain name for your blog, \u003cem\u003eand\u003c/em\u003e you want it accessible via HTTPS, this is where it gets hairy.\n\u003ca href=\"https://gitlab.com/gitlab-org/gitlab-ce/issues/28996\"\u003eGitLab does not \u003cem\u003equite\u003c/em\u003e yet support automatic HTTPS with LetsEncrypt\u003c/a\u003e for custom domains like GitHub does.\nSo, there are a couple ways to do HTTPS.\nWe could go through CloudFlare, but that requires monkeying with your site’s DNS nameservers and adds an extra account to keep track of.\nWe could also use LetsEncrypt and maybe even use a GitLab CI job to pass the challenges and keep the certificate updated automatically.\u003c/p\u003e\n\u003cp\u003eThe DNS challenge, which simply involves adding a DNS record much like GitLab’s challenge earlier, would be ideal for this, because it could be accomplished entirely from a runner with plain \u003ccode\u003ecertbot\u003c/code\u003e.\nUnfortunately, most DNS providers provide a terrible or nonexistent API, so you’d need to use something like Google Cloud DNS for this to be a viable option.\u003c/p\u003e\n\u003cp\u003eThe HTTP challenge sounds like a lot of pain.\nNormally you’d have a webserver watching a folder that \u003ccode\u003ecertbot\u003c/code\u003e can poke directly, and the challenge would be quick and automated.\nBut with a Git-tracked and Hugo-processed site, you’d need to commit the file, push the file, wait for GitLab Pages to update (which can take a while), etc.\nThis does not sound fun.\u003c/p\u003e\n\u003cp\u003eFortunately, Rodrigo Dato has done \u003ca href=\"https://www.rolodato.com/2018/01/14/static-websites-for-hackers.html\"\u003ethe hard work\u003c/a\u003e and written a tool called \u003ccode\u003egitlab-le\u003c/code\u003e that does \u003cem\u003eall\u003c/em\u003e the steps you need.\nI have built and published \u003ca href=\"https://gitlab.com/thirtythreeforty/gitlab-letsencrypt/container_registry\"\u003ea \u003ccode\u003egitlab-le\u003c/code\u003e Docker image\u003c/a\u003e that you can grab:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"bash\"\u003e$ docker run --rm -it registry.gitlab.com/thirtythreeforty/gitlab-letsencrypt gitlab-le\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet’s call this tool from CI by adding a job in \u003ccode\u003e.gitlab-ci.yml\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yaml\"\u003e\u003cspan\u003ecertificate\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eimage\u003c/span\u003e:\u003cspan\u003e \u003c/span\u003eregistry.gitlab.com/thirtythreeforty/gitlab-letsencrypt\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003escript\u003c/span\u003e:\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e- |\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    gitlab-le \\\n\u003c/span\u003e\u003cspan\u003e      --domain YOUR_DOMAIN \\\n\u003c/span\u003e\u003cspan\u003e      --email YOUR_EMAIL \\\n\u003c/span\u003e\u003cspan\u003e      --repository YOUR_BLOG_REPO_URL \\\n\u003c/span\u003e\u003cspan\u003e      --token $GITLAB_ACCESS_TOKEN \\\n\u003c/span\u003e\u003cspan\u003e      --path static/.well-known/acme-challenge\u003c/span\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003ewhen\u003c/span\u003e:\u003cspan\u003e \u003c/span\u003emanual\u003cspan\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWhen you \u003ca href=\"https://gitlab.com/profile/personal_access_tokens\"\u003egenerate your access token\u003c/a\u003e, it would be smart to put it in a CI variable, so it’s not checked into your repository.\nNote also that Hugo copies things in the \u003ccode\u003estatic\u003c/code\u003e folder as-is to the output folder, so that’s where we’ll have \u003ccode\u003egitlab-le\u003c/code\u003e put the challenge info.\u003c/p\u003e\n\u003cp\u003eWhen you run this, either via Docker or as a GitLab job, you should see something like:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"plain\"\u003eBy using Let\u0026#39;s Encrypt, you are agreeing to the TOS at https://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf\nUploaded challenge file, polling until it is available at http://www.thirtythreeforty.net/.well-known/acme-challenge/7Vui_I58QATNbtTz1C3CasYriSShSbJKxnCk0IKY5FE\nCould not find challenge file. Retrying in 30s...\nCould not find challenge file. Retrying in 30s...\nSuccess! Your GitLab page has been configured to use an HTTPS certificate obtained from Let\u0026#39;s Encrypt.\nTry it out: https://www.thirtythreeforty.net (GitLab might take a few minutes to start using your certificate for the first time)\n\nThis certificate expires on Mon Sep 02 2019 01:59:40 GMT+0000 (Coordinated Universal Time). You will need to run gitlab-le again at some time before this date.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eYou can add this as a periodic job in GitLab if you like.\u003c/p\u003e\n\u003ch3 id=\"wrapping-up\"\u003eWrapping up\u003c/h3\u003e\n\u003cp\u003eSo this blog is built with Hugo, compiled on GitLab CI, hosted on GitLab Pages, and secured via LetsEncrypt.\nLet me know if you have any feedback on any of this!\u003c/p\u003e\n\u003csection role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\" role=\"doc-endnote\"\u003e\n\u003cp\u003eRenting a domain will of course cost a small fee. \u003ca href=\"#fnref:1\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n\u003c/div\u003e\n\n\n\n\n\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2019-06-01T00:00:00Z",
  "modifiedTime": "2019-06-01T00:00:00Z"
}
