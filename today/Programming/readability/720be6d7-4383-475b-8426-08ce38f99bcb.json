{
  "id": "720be6d7-4383-475b-8426-08ce38f99bcb",
  "title": "Spring Debugger: Working With Dynamic Database Connections Just Got Simpler",
  "link": "https://blog.jetbrains.com/idea/2025/07/spring-debugger-working-with-dynamic-database-connections-just-got-simpler/",
  "description": "While building Spring Boot applications, you can leverage Testcontainers to spin up any required services, such as a database or messaging broker, as Docker containers at application startup. This enables a ready-to-code setup, minimizing environment friction so you can focus on delivering high-quality, maintainable code. For database-driven development, IntelliJ IDEA provides enterprise-grade, professional-level tooling out […]",
  "author": "Siva Katamreddy",
  "published": "Tue, 15 Jul 2025 12:16:31 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "database-tools",
    "debugging",
    "spring",
    "springboot"
  ],
  "byline": "Siva Katamreddy",
  "length": 5503,
  "excerpt": "Developing with multiple environments, configs, and TestContainers can make it tough to keep track of your database connections. Spring Debugger lists every DataSource straight in your IDE as soon as your app starts! More in our blog post.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the IDE for Professional Development in Java and Kotlin IntelliJ IDEASpring Debugger: Working With Dynamic Database Connections Just Got Simpler While building Spring Boot applications, you can leverage Testcontainers to spin up any required services, such as a database or messaging broker, as Docker containers at application startup. This enables a ready-to-code setup, minimizing environment friction so you can focus on delivering high-quality, maintainable code. For database-driven development, IntelliJ IDEA provides enterprise-grade, professional-level tooling out of the box. You can: Reverse-engineer JPA entities from an existing schema Generate Flyway or Liquibase migrations directly from your JPA models Access a suite of built-in integrations (e.g., SQL consoles, schema diff, and more) that help you maintain a clean, consistent database lifecycle IntelliJ IDEA’s ergonomic UI and preconfigured environments allow you to code faster, refactor more smoothly, and catch potential issues before they become bugs. This means that using IntelliJ IDEA combined with Testcontainers is a productivity booster. However, there is just one problem… Testcontainers map container ports to random host ports to avoid conflicts. Each time you restart your application, you must fetch the new mapped port and manually update IntelliJ IDEA’s DataSource connection properties. JetBrains addressed this problem with the Spring Debugger plugin. It automatically registers the DataSource connection to any relational databases started by Testcontainers. Additionally, the DataSource connection will be automatically created while running Testcontainers tests. You can use the Spring Debugger plugin with IntelliJ IDEA Ultimate 2025.1.2 or any later versions. NOTE: Spring Debugger automatic DataSource registration works with Testcontainers and Docker Compose too. You can also watch the demonstration of Spring Debugger plugin’s automatic DataSource registration feature in this video. Spring Debugger: Working With Dynamic Database Connections Just Got Simpler Let’s explore this feature using a practical example. Local development using Testcontainers To follow along, clone the Spring Boot sample project from here. This repository contains a Spring Boot REST API project using the starters Spring Web, Validation, Spring Data JPA, PostgreSQL Driver, Flyway Migration, and Testcontainers. Open the project in IntelliJ IDEA Ultimate and run TestBookmarksApplication.java in debug mode to start the application. As you can see, when you start the application, Testcontainers start a PostgreSQL database, and a PostgreSQL DataSource is automatically registered in IntelliJ IDEA’s Database tool window. NOTE: The DataSource will be automatically registered ONLY when you start the application in debug mode. When you stop the application, the registered DataSource will be automatically deleted from the Database tool window. Debugging Testcontainers based tests A DataSource is automatically registered both when running the application and when running tests. You can run your Testcontainers-based tests in debug mode, set a breakpoint, and explore the data in your database. Here is an example of running a Spring Boot integration test that interacts with a PostgreSQL database started by Testcontainers. As you can see, while running the test, we can set a breakpoint and verify the data in the database if needed. Here is another example of debugging a Spring Data JPA Repository test using @DataJpaTest. Local development and testing with MongoDB In addition to the relational databases, the automatic registration of the DataSource works for MongoDB as well. Summary IntelliJ IDEA’s automatic registration of Testcontainers data sources in the Database tool window eliminates the need for manually registering the DataSources. This makes local development and debugging of the Testcontainers tests using databases much simpler. As of now, this feature works for relational databases and MongoDB only, but support for more databases will be added in upcoming IntelliJ IDEA versions. To learn more about the features of the Spring Debugger plugin, please read the documentation. What are you waiting for? Download the latest version of IntelliJ IDEA Ultimate and install the Spring Debugger plugin and try the features of its plugin for yourself. Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/07/IJ-social-BlogSocialShare-1280x720-2x-2.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eSpring Debugger: Working With Dynamic Database Connections Just Got Simpler\u003c/h2\u003e                    \n                    \n\u003cp\u003eWhile building Spring Boot applications, you can leverage \u003ca href=\"https://testcontainers.com/\" data-type=\"link\" data-id=\"https://testcontainers.com/\" target=\"_blank\" rel=\"noopener\"\u003eTestcontainers\u003c/a\u003e to spin up any required services, such as a database or messaging broker, as Docker containers at application startup. This enables a ready-to-code setup, minimizing environment friction so you can focus on delivering high-quality, maintainable code.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor database-driven development, IntelliJ IDEA provides enterprise-grade, professional-level tooling out of the box. You can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ca href=\"https://www.jetbrains.com/help/idea/jpa-buddy-reverse-engineering.html\" data-type=\"link\" data-id=\"https://www.jetbrains.com/help/idea/jpa-buddy-reverse-engineering.html\" target=\"_blank\" rel=\"noopener\"\u003eReverse-engineer\u003c/a\u003e JPA entities\u003c/strong\u003e from an existing schema\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eGenerate Flyway or Liquibase migrations\u003c/strong\u003e directly from your JPA models\u003c/li\u003e\n\n\n\n\u003cli\u003eAccess a suite of \u003cstrong\u003ebuilt-in integrations\u003c/strong\u003e (e.g., SQL consoles, schema diff, and more) that help you maintain a clean, consistent database lifecycle\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cbr/\u003eIntelliJ IDEA’s ergonomic UI and preconfigured environments allow you to code faster, refactor more smoothly, and catch potential issues before they become bugs. This means that using IntelliJ IDEA combined with Testcontainers is a productivity booster. However, there is just one problem…\u003c/p\u003e\n\n\n\n\u003cp\u003eTestcontainers map container ports to random host ports to avoid conflicts. Each time you restart your application, you must fetch the new mapped port and manually update IntelliJ IDEA’s DataSource connection properties.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/1.SpringDebugger-DataSourceRegistration-Problem.webm\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eJetBrains addressed this problem with the \u003ca href=\"https://plugins.jetbrains.com/plugin/25302-spring-debugger\" target=\"_blank\" rel=\"noopener\"\u003eSpring Debugger\u003c/a\u003e plugin. It automatically registers the DataSource connection to any relational databases started by Testcontainers. Additionally, the DataSource connection will be automatically created while running Testcontainers tests. You can use the Spring Debugger plugin with IntelliJ IDEA Ultimate 2025.1.2 or any later versions.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE:\u003c/strong\u003e Spring Debugger automatic DataSource registration works with \u003ca href=\"https://docs.spring.io/spring-boot/reference/features/dev-services.html#features.dev-services.testcontainers\" data-type=\"link\" data-id=\"https://docs.spring.io/spring-boot/reference/features/dev-services.html#features.dev-services.testcontainers\" target=\"_blank\" rel=\"noopener\"\u003eTestcontainers\u003c/a\u003e and \u003ca href=\"https://docs.spring.io/spring-boot/reference/features/dev-services.html#features.dev-services.docker-compose\" data-type=\"link\" data-id=\"https://docs.spring.io/spring-boot/reference/features/dev-services.html#features.dev-services.docker-compose\" target=\"_blank\" rel=\"noopener\"\u003eDocker Compose\u003c/a\u003e too.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eYou can also watch the demonstration of Spring Debugger plugin’s automatic DataSource registration feature in this video.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cp\u003e\n\u003ciframe title=\"Spring Debugger – No More Database Port Conflicts\" width=\"500\" height=\"281\" src=\"https://www.youtube.com/embed/fDm51kOqrgY?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\u003cfigcaption\u003eSpring Debugger: Working With Dynamic Database Connections Just Got Simpler\u003c/figcaption\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eLet’s explore this feature using a practical example.\u003c/p\u003e\n\n\n\n\u003ch2\u003eLocal development using Testcontainers\u003c/h2\u003e\n\n\n\n\u003cp\u003eTo follow along, clone the Spring Boot sample project from \u003ca href=\"https://github.com/sivaprasadreddy/spring-boot-bookmarks-crud\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis repository contains a Spring Boot REST API project using the starters Spring Web, Validation, Spring Data JPA, PostgreSQL Driver, Flyway Migration, and Testcontainers.\u003c/p\u003e\n\n\n\n\u003cp\u003eOpen the project in IntelliJ IDEA Ultimate and run TestBookmarksApplication.java in debug mode to start the application.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/2.SpringDebugger-DebugApp-AutoRegister-DS.webm\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs you can see, when you start the application, Testcontainers start a PostgreSQL database, and a PostgreSQL DataSource is automatically registered in IntelliJ IDEA’s \u003cem\u003eDatabase\u003c/em\u003e tool window.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eNOTE:\u003c/strong\u003e The DataSource will be automatically registered ONLY when you start the application in debug mode.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhen you stop the application, the registered DataSource will be automatically deleted from the \u003cem\u003eDatabase\u003c/em\u003e tool window.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDebugging Testcontainers based tests\u003c/h2\u003e\n\n\n\n\u003cp\u003eA DataSource is automatically registered both when running the application and when running tests. You can run your Testcontainers-based tests in debug mode, set a breakpoint, and explore the data in your database.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is an example of running a Spring Boot integration test that interacts with a PostgreSQL database started by Testcontainers.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/3.SpringDebugger-Debugging-IntegrationTest.webm\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs you can see, while running the test, we can set a breakpoint and verify the data in the database if needed.\u003c/p\u003e\n\n\n\n\u003cp\u003eHere is another example of debugging a Spring Data JPA Repository test using \u003ccode\u003e@DataJpaTest\u003c/code\u003e.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/4.SpringDebugger-DbSliceTest.webm\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eLocal development and testing with MongoDB\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn addition to the relational databases, the automatic registration of the DataSource works for MongoDB as well.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cvideo controls=\"\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/05/5.SpringDebugger-MongoDB.webm\"\u003e\u003c/video\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntelliJ IDEA’s automatic registration of Testcontainers data sources in the \u003cem\u003eDatabase\u003c/em\u003e tool window eliminates the need for manually registering the DataSources. This makes local development and debugging of the Testcontainers tests using databases much simpler.\u003c/p\u003e\n\n\n\n\u003cp\u003eAs of now, this feature works for relational databases and MongoDB only, but support for more databases will be added in upcoming IntelliJ IDEA versions.\u003c/p\u003e\n\n\n\n\u003cp\u003eTo learn more about the features of the Spring Debugger plugin, please read the \u003ca href=\"https://www.jetbrains.com/help/idea/spring-debugger.html\" target=\"_blank\" rel=\"noopener\"\u003edocumentation\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat are you waiting for? Download the latest version of \u003ca href=\"https://www.jetbrains.com/idea/download/\" target=\"_blank\" rel=\"noopener\"\u003eIntelliJ IDEA Ultimate\u003c/a\u003e and install the \u003ca href=\"https://plugins.jetbrains.com/plugin/25302-spring-debugger\" target=\"_blank\" rel=\"noopener\"\u003eSpring Debugger\u003c/a\u003e plugin and try the features of its plugin for yourself.\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
