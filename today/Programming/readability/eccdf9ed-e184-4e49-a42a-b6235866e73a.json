{
  "id": "eccdf9ed-e184-4e49-a42a-b6235866e73a",
  "title": "Catching Compromised Cookies",
  "link": "https://slack.engineering/catching-compromised-cookies/",
  "description": "Slack uses cookies to track session states for users on slack.com and the Slack Desktop app. The ever-present cookie banners have made cookies mainstream, but as a quick refresher, cookies are a little piece of client-side state associated with a website that is sent up to the web server on every request. Websites use this […] The post Catching Compromised Cookies appeared first on Slack Engineering.",
  "author": "Ryan Slama",
  "published": "Mon, 24 Jun 2024 10:00:51 +0000",
  "source": "https://slack.engineering/feed",
  "categories": [
    "Uncategorized",
    "security"
  ],
  "byline": "Ryan Slama Sr. Software Engineer, Security",
  "length": 12791,
  "excerpt": "Slack uses cookies to track session states for users on slack.com and the Slack Desktop app. The ever-present cookie banners have made cookies mainstream, but as a quick refresher, cookies are a little piece of client-side state associated with a website that is sent up to the web server on every request. Websites use this …",
  "siteName": "Slack Engineering",
  "favicon": "https://slack.engineering/wp-content/uploads/sites/7/2020/05/cropped-octothrope-1.png?w=192",
  "text": "Slack uses cookies to track session states for users on slack.com and the Slack Desktop app. The ever-present cookie banners have made cookies mainstream, but as a quick refresher, cookies are a little piece of client-side state associated with a website that is sent up to the web server on every request. Websites use this piece of information to inject state into the inherently stateless protocol of HTTP. At Slack, that means every time you sign into a workspace, your cookie (which we call the session cookie) is updated to reflect this. Since session cookies are frequently used to uniquely identify users in applications across the internet, they have become an obvious target for malicious actors looking to gain access to systems. If hackers present a cookie as their own, the website will typically grant them access as if they were the original user. Malicious actors often acquire these cookies through malware running on a user’s device, using the malware to silently steal cookies and other sensitive data and send them to a server controlled by the attackers. Using this stolen data allows them to gain access to a variety of internet applications ranging from banking services to social media sites. The consequences of this can be severe, ranging from financial loss and identity theft to the exposure of confidential communications and personal information.  Slack workspaces contain sensitive data and can be an attractive target for attackers. Consider the situation where a threat actor phishes a user and manages to install malware on their device. The malware could then steal cookies, which are stored in the device’s browser, and replay those cookies to impersonate the user. To take a real world example, imagine you left your house key under the mat and someone managed to discover it, clone it, and put it back so you had no idea. One way to reduce the risk of a copied key is to change your locks regularly. If you do that, a thief would have only a limited window of time to use the key they copied.  In Slack, the analogue of changing your lock is the session duration feature. Admins can configure how long they want someone’s session to last before they have to log in again. This helps limit the risk of stolen cookies, but it’s not perfect. Attackers still have a window of time to use their copy of the cookie and session duration doesn’t tell us when an attacker is active. In addition, users get frustrated when the session duration is too short as they find themselves having to sign in when they’re just trying to get work done. Cookies for various sites are frequently compromised by real attackers looking to gain access to company information. Malware operators steal cookies and sell them on dark web marketplaces to the highest bidder. While we can’t ensure the security of the devices our customers use to access Slack, we wanted to go further to protect our customers’ data. This blog talks about how we can detect when cookies are stolen and alert workspace administrators. Detecting cookie misuse The core idea behind our strategy is to detect session forking. That is, understanding if a cookie is being used from more than one device at the same time: To detect session forking, we use multiple components to detect signals in parallel. Those components can cover the gaps between each other and increase the accuracy of our system. The most important component is the last access timestamp. Last access timestamp The last access timestamp corresponds to when the server set the cookie on the client. We store the timestamp both in the cookie and in the database. On future requests, we compare the timestamp on the incoming cookie with the timestamp in the database. If they do not match, this indicates that the user is sending an old version of the cookie. We regularly refresh the cookie with a more recent last access timestamp and update the database accordingly. If a malicious actor obtains a stolen cookie, they will likely receive an outdated version with an old timestamp. When they use that cookie to access Slack, we’ll compare the old timestamp in the cookie with the newer value in the database. Since they don’t match, we will detect that the session has been forked.  A bad actor might try to prevent this by regularly interacting with Slack via the stolen cookie. In that case, we’d update the last access timestamp for the bad actor’s cookie and the database. When the original user starts Slack again, they present their old copy of the cookie. We compare that with the newer value in the database and again determine that a session fork has occurred. Based on the last access time, we don’t know which side of a forked session is legitimate. We can only tell that there are two (or more) copies of the cookie when there should be one. Testing Once we had a basic version of the system working, the next step was to evaluate its effectiveness. Our initial results were not ideal. We had a true positive in the form of a coworker who was using their cookie to automate actions in Slack. But in various circumstances, our detection logic resulted in both false negatives and false positives. For the feature to be a meaningful security improvement, we need reliable detection to be able to act on the signals we generate. Our pilot customers planned on automatically invalidating sessions that might have been forked, which meant that our high number of false positives would be disruptive to their work. False positives From our investigation, we found that users were triggering detection events while going about their normal day. We found many different edge cases that caused this. Sometimes, we would try to set a new cookie with an updated timestamp, but the client never received the new cookie. That meant the Slack client now had a different last access time from the database, making it present similarly to an old, stolen cookie. This case would result in a false detection event. So we introduced the IP address. If the last access time is different, but the IP address matches the IP stored in the database alongside the old timestamp, the request is likely coming from the same computer and therefore unlikely to be stolen. This change alone eliminated a large percentage of the false positives, but failed to address some of the key shortcomings in the design. For the last access timestamp to work, we need clients to reliably set cookies. We have various hypotheses for why clients weren’t setting cookies, such as laptops going to sleep before the server could respond. We should only update the timestamp in the database after we know the client has stored the new cookie. To accomplish this, we use a two-phased approach, where each request is idempotent. We update the session cookie by setting a separate “session candidate” cookie. If we receive a request with a newer session candidate cookie set, we promote it to the session cookie. We update the timestamp in the database after the client presents us with a newer timestamp via the session candidate cookie. With this approach, if the client does not receive a response for any particular request, we will pick up where we left off in the process. If the server tries to set a session candidate cookie, but the client does not present a session candidate cookie on the next request, we’ll just set it again. Likewise, if the client does not receive the headers to promote the value in the session candidate cookie to the session cookie, we will just include those headers on the next request. When the client provides both session candidate and session cookies, we will consider either timestamp value when comparing with the database timestamp. In the above diagram, the session cookie would match the database since this is the first request that the client sends the session candidate cookie. In the last request of the diagram below, the session candidate cookie will match the timestamp in the database. We have also done work to mitigate the impact of race conditions where the client sends a group of API requests in quick succession. We want to avoid the situation where we update the database on the first request that comes in, but other requests are already in flight with the old version of the cookie. If the timestamp in the database was just updated, we don’t have a proper old value to compare with the incoming cookie timestamp. To that end, we ignore the timestamp in those requests. A request in this instant could theoretically evade detection, but it would be very hard for an attacker to predict exactly when the original user sends the first request causing the database to be updated. An attacker can’t take multiple guesses to try to time the window because if any one request falls outside the window, we will detect that the cookie has been forked. This reduces false positives from in-flight requests without compromising the value offered by the feature. Risk level measurement We now have some new information in addition to the last access timestamp (i.e. information about the device and network) that we can combine. We then algorithmically generate an assessment about whether a detection is a true or false positive. With our calculated probability, we categorized the risk as low, medium or high. For anything determined to be high risk, we send an event to the audit log. We are continuing to improve our algorithm to further reduce false positives. Performance concerns In the diagrams above, we focus on the logic around updating the last access timestamp in the cookie and database. That’s the most complex interaction of this system, but not the most common. For the vast majority of API requests, we merely compare the timestamp with the existing value and determine if the request is an anomaly. Due to Slack’s real-time nature, our clients can be very chatty and send many API requests during simple user interaction. As presented above, our last access timestamp needs to be read from the database on every request. Introducing a new database read on every request would be significant in terms of load. While some of this load could be taken by a cache, we can simplify further and avoid some of the database reads in the first place. If the last access time in the cookie is recent, we know the cookie is in active use since that means the server just set it. This means if the session were forked, we would have already triggered a detection event. We can avoid reading from the database until some time has passed, based on the assumption that attackers do not instantly steal and sell cookies. When the cookie ages out of that window, we set a fresh cookie. This approach allows us to avoid interacting with the database on a significant majority of API requests. This approach also lends well to the usage patterns of Slack users, who often use Slack in bursts with many API requests. Rollout As with the other anomaly detections we’ve rolled out, we worked closely with pilot customers to develop their understanding of the feature. Anomalies aren’t intended as a clear indicator of malicious behavior so much as something unexpected in an environment and should be investigated as potentially malicious. In some cases this cookie anomaly could happen for normal reasons, such as a computer being restored from a backup. We worked closely with our pilot customers to validate and improve our detection capabilities.  This limited rollout gave us the opportunity to better understand the performance characteristics of our design as well as investigate sources of noise in the data. The information we collected at this stage led to several key improvements, including our two-phase cookie updating approach. After reducing the noise to an acceptable level and validating that the feature worked as expected, we gradually rolled out the detection logic to the rest of Slack. We communicate detection events to customers via Slack’s audit log. Customers can ingest audit logs into their own Security Event Manager such as Splunk or ELK and combine it with other data streams to draw a conclusion about the security of their users’ data. Future development Today we are delivering detections to customers via the audit log and allowing them to correlate logs in their internal tools to make appropriate security decisions. In the future, we believe we could further improve the system by automatically invalidating sessions flagged with a high-risk detection. This would automatically sign out both the legitimate users and attackers. The legitimate users would have to re-authenticate with Slack, while attackers would lose the connection and ability to impersonate the user. Interested in building innovative projects and making developers’ work lives easier? We’re hiring 💼 Apply now",
  "image": "https://slack.engineering/wp-content/uploads/sites/7/2024/06/david-sanchez-_MsN3by690Q-unsplash-1.jpg?resize=1280,1920",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content-area\"\u003e\n\t\t\u003cmain id=\"primary\"\u003e\n\t\t\t\u003carticle id=\"post-16687\"\u003e\n\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\t\t\u003cp\u003e\u003cspan\u003eSlack uses cookies to track session states for users on slack.com and the Slack Desktop app. The ever-present cookie banners have made cookies mainstream, but as a quick re\u003c/span\u003e\u003cspan\u003efresher, cookies are a little piece of client-side state associated with a website that is sent up to the web server on every request. Websites use this piece of information to inject state into the inherently stateless protocol of HTTP. At Slack, that means every time you sign into a workspace, your cookie (which we call the session cookie) is updated to reflect this.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSince session cookies are frequently used to uniquely identify users in applications across the internet, they have become an obvious target for malicious actors looking to gain access to systems. If hackers present a cookie as their own, the website will typically grant them access as if they were the original user. Malicious actors often acquire these cookies through malware running on a user’s device, using the malware to silently steal cookies and other sensitive data and send them to a server controlled by the attackers. Using this stolen data allows them to gain access to a variety of internet applications ranging from banking\u003c/span\u003e\u003cspan\u003e services to social\u003c/span\u003e\u003cspan\u003e media sites. The consequences of this can be severe, ranging from financial loss and identity theft to the exposure of confidential communications and personal information. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSlack workspaces contain sensitive data and can be an attractive target for attackers. Consider the situation where a threat actor phishes a user and manages to install malware on their device. The malware could then steal cookies, which are stored in the device’s browser, and replay those cookies to impersonate the user. To take a real world example, imagine you left your house key under the mat and someone managed to discover it, clone it, and put it back so you had no idea. One way to reduce the risk of a copied key is to change your locks regularly. If you do that, a thief would have only a limited window of time to use the key they copied. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIn Slack, the analogue of changing your\u003c/span\u003e\u003cspan\u003e lock is the session duration feature. Admins can configure how long they want someone’s session to last before they have to log in again. This helps limit the risk of stolen cookies, but it’s not perfect. Attackers still have a window of time to use their copy of the cookie and session duration doesn’t tell us when an attacker is active. In addition, users get frustrated when the session duration is too short as they find themselves having to sign in when they’re just trying to get work done.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eCookies for various sites are frequently compromised by real attackers looking to gain access to company information. Malware operators steal cookies and sell them on dark web marketplaces to the highest bidder. While we can’t ensure the security of the devices our customers use to access Slack, we wanted to go further to protect our customers’ data. This blog talks about how we can detect when cookies are stolen and alert workspace administrators.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eDetecting cookie misuse\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe core idea behind our strategy is to detect \u003c/span\u003e\u003ci\u003e\u003cspan\u003esession forking\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e. That is, understanding if a cookie is being used from more than one device at the same time:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" width=\"1406\" height=\"1404\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png?w=640\" alt=\"Diagram showing a cookie being stolen by an attacker\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png 1406w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png?resize=160,160 160w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png?resize=640,639 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png?resize=768,767 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-01.png?resize=1280,1278 1280w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTo detect session forking, we use multiple components to detect signals in parallel. Those components can cover the gaps between each other and increase the accuracy of our system. \u003c/span\u003e\u003cspan\u003eThe most important component is the \u003c/span\u003e\u003cb\u003elast access timestamp\u003c/b\u003e\u003ci\u003e\u003cspan\u003e.\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eLast access timestamp\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eThe last access timestamp corresponds to when the serve\u003c/span\u003e\u003cspan\u003er set the cookie on the client. We store the timestamp both in the cookie and in the database. On future requests, we compare the timestamp on the incoming cookie with the timestamp in the database. If they do not match, this indicates that the user is sending an old version of the cookie.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" width=\"3022\" height=\"988\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?w=640\" alt=\"Diagram of a request that takes a session cookie, compares the timestamp with the value in the database, writes a new timestamp to the database, and returns a new session cookie to a client\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png 3022w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=640,209 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=768,251 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=1280,418 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=1536,502 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=2048,670 2048w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-02.png?resize=1920,628 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe regularly refresh the cookie with a more recent last\u003c/span\u003e\u003cspan\u003e access timestamp and update the database accordingly. If a malicious actor obtains a stolen cookie, they will likely receive an outdated version with an old timestamp. When they use that cookie to access Slack, we’ll compare the old timestamp in the cookie with the newer value in the database. Since they don’t match, we will detect that the session has been forked. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eA bad actor might try to prevent this by regularly interacting with Slack via the stolen cookie. In that case, we’d update the last access timestamp for the bad actor’s cookie and the database. When the original user starts Slack again, they present their old copy of the cookie. We compare that with the newer value in the database and again determine that a session fork has occurred. Based on the last access time, we don’t know which side of a forked session is legitimate. We can only tell that there are two (or more) copies of the cookie when there should be one.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eTesting\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eOnce we had a basic version of the system working, the next step was to evaluate its effectiveness. Our initial results were not ideal. We had a true positive in the form of a coworker who was using their cookie to automate actions in Slack. But in various circumstances, our detection logic resulted in both false negatives and false positives. For the feature to be a meaningful security improvement, we need reliable detection to be able to act on the signals we generate. Our pilot customers planned on automatically invalidating sessions that might have been forked, which meant that our high number of false positives would be disruptive to their work.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eFalse positives\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eFrom our investigation, we found that users were triggering detection events while going about their normal day. We found many different edge cases that caused this. Sometimes, we would try to set a new cookie with an updated timestamp, but the client never received the new cookie. That meant the Slack client now had a different last access time from the database, making it present similarly to an old, stolen cookie. This case would result in a false detection event.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"2544\" height=\"1556\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?w=640\" alt=\"Diagram showing a response containing a new session cookie failing to reach the client and a second request that triggers a detection event when the client presents the old cookie value to the server\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png 2544w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=640,391 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=768,470 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=1280,783 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=1536,939 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=2048,1253 2048w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-03.png?resize=1920,1174 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSo we introduced the IP address. If the last access time is different, but the IP address matches the IP stored in the database alongside the old timestamp, the request is likely coming from the same computer and therefore unlikely to be stolen. This change alone eliminated a large percentage of the false positives, but failed to address some of the key shortcomings in the design.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eFor the last access timestamp to work, we need clients to reliably set cookies. We have various hypotheses for why clients weren’t setting cookies, such as laptops going to sleep before the server could respond.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe should only update the timestamp in the database after we know the client has stored the new cookie. To accomplish this, we use a two-phased approach, where each request is idempotent. We update the session cookie by setting a separate “session candidate” cookie. If we receive a request with a newer session candidate cookie set, we promote it to the session cookie. We update the timestamp in the database after the client presents us with a newer timestamp via the session candidate cookie.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"2776\" height=\"1500\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?w=640\" alt=\"Diagram showing one request where a session candidate cookie is set after comparing the timestamp with the database and a second request compares the timestamp with both the session and session candidate cookies. That request promotes the value in the session candidate cookie to be the new value of the session cookie and unsets the session candidate cookie\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png 2776w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=640,346 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=768,415 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=1280,692 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=1536,830 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=2048,1107 2048w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-04.png?resize=1920,1037 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWith this approach, if the client does not receive a response for any particular request, we will \u003c/span\u003e\u003cspan\u003epick up where we left off in the process. If the server tries to set a session candidate cookie, but the client does not present a session candidate cookie on the next request, we’ll just set it again. Likewise, if the client does not receive the headers to promote the value in the session candidate cookie to the session cookie, we will just include those headers on the next request. When the client provides both session candidate and session cookies, we will consider either timestamp value when comparing with the database timestamp. In the above diagram, the session cookie would match the database since this is the first request that the client sends the session candidate cookie. In the last request of the diagram below, the session candidate co\u003c/span\u003e\u003cspan\u003eokie will match the timestamp in the database.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"1926\" height=\"1794\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?w=640\" alt=\"Diagram showing several requests where some of the responses do not reach the client. The system continues working, despite this\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png 1926w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?resize=640,596 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?resize=768,715 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?resize=1280,1192 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?resize=1536,1431 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-05.png?resize=1920,1788 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe have also done work to mitigate the im\u003c/span\u003e\u003cspan\u003epact of race conditions where the client sends a group of API requests in quick succession. We want to avoid the situation where we update the database on the first request that comes in, but other requests are already in flight with the old version of the cookie. If the timestamp in the database was just updated, we don’t have a proper old value to compare with the incoming cookie timestamp. To that end, we ignore the timestamp in those requests. A request in this instant could theoretically evade detection, but it would be very hard for an attacker to predict exactly when the original user sends the first request causing the database to be updated. An attacker can’t take multiple guesses to try to time the window because if any one request falls outside the window, we will detect that the cookie has been forked. This reduces false positives from in-flight requests without compromising the value offered by the feature.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eRisk level measurement\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eWe now have some new information in addition to the last access timestamp (i.e. information about the device and network) that we can combine. We then algorithmically generate an assessment about whether a detection is a true or false positive. With our calculated probability, we categorized the risk as low, medium or high. For anything determined to be high risk, we send an event to the audit log. We are continuing to improve our algorithm to further reduce false positives.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003ePerformance concerns\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eIn the diagrams above, we focus on the logic around updating the last access timestamp in the cookie and database. That’s the most complex interaction of this system, but not the most common. For the vast majority of API requests, we merely compare the timestamp with the existing value and determine if the request is an anomaly.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"2932\" height=\"1466\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?w=640\" alt=\"Diagram showing several requests in short succession all comparing the timestamp before a final request sets a new timestamp and updates the cookie\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png 2932w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=640,320 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=768,384 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=1280,640 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=1536,768 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=2048,1024 2048w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-06.png?resize=1920,960 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eDue to Slack’s real-time nature, our clients can be very chatty and send many API requests during simple user interaction. As presented above, our last access timestamp needs to be read from the database on every request. Introducing a new database read on every request would be significant in terms of load. While some of this load could be taken by a cache, we can simplify further and avoid some of the database reads in the first place.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\u003cimg loading=\"lazy\" decoding=\"async\" width=\"2970\" height=\"1520\" src=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?w=640\" alt=\"Diagram showing several requests in short succession which do not update the database before a final request sets a new timestamp and updates the cookie\" srcset=\"https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png 2970w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=640,328 640w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=768,393 768w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=1280,655 1280w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=1536,786 1536w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=2048,1048 2048w, https://slack.engineering/wp-content/uploads/sites/7/2024/06/Catching-Compromised-Cookies-07.png?resize=1920,983 1920w\" sizes=\"(max-width: 959px) 688px, (max-width: 1023px) 768px, 1172px\"/\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIf the last access time in the cookie is recent, we know the cookie is in active use since that means the server just set it. This means if the session were forked, we would have already triggered a detection event. We can avoid reading from the database until some time has passed, based on the assumption that attackers do not instantly steal and sell cookies. When the cookie ages out of that window, we set a fresh cookie. This approach allows us to avoid interacting with the database on a significant majority of API requests. This approach also lends well to the usage patterns of Slack users, who often use Slack in bursts with many API requests.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eRollout\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eAs with the other anomaly detections we’ve rolled out, we worked closely with pilot customers to develop their understanding of the feature. Anomalies aren’t intended as a clear indicator of malicious behavior so much as something unexpected in an environment and should be investigated as potentially malicious. In some cases this cookie anomaly could happen for normal reasons, such as a computer being restored from a backup. We worked closely with our pilot customers to validate and improve our detection capabilities. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis limited rollout gave us the opportunity to better understand the performance characteristics of our design as well as investigate sources of noise in the data. The information we collected at this stage led to several key improvements, including our two-phase cookie updating approach. After reducing the noise to an acceptable level and validating that the feature worked as expected, we gradually rolled out the detection logic to the rest of Slack.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe communicate detection events to customers via Slack’s \u003c/span\u003e\u003ca href=\"https://api.slack.com/admins/audit-logs-anomaly\"\u003e\u003cspan\u003eaudit log\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e. Customers can ingest audit logs into their own Security Event Manager such as Splunk or ELK and combine it with other data streams to draw a conclusion about the security of their users’ data.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eFuture development\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eToday we are delivering detections to customers via the audit log and allowing them to correlate logs in their internal tools to make appropriate security decisions. In the future, we believe we could further improve the system by automatically invalidating sessions flagged with a high-risk detection. This would automatically sign out both the legitimate users and attackers. The legitimate users would have to re-authenticate with Slack, while attackers would lose the connection and ability to impersonate the user.\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003eInterested in building innovative projects and making developers’ work lives easier? We’re hiring 💼\u003c/i\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://slack.com/careers/dept/engineering#openings?utm_source=blog_eng\"\u003e\u003ci\u003eApply now\u003c/i\u003e\u003c/a\u003e\u003c/p\u003e\n\t\t\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\u003c/article\u003e\n\n\t\t\n\t\t\u003c/main\u003e\n\n\t\t\n\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2024-06-24T10:00:51Z",
  "modifiedTime": "2024-06-21T20:23:22Z"
}
