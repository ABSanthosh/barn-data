{
  "id": "07282a90-5ea2-4cec-ae32-1c712d4c61b5",
  "title": "Simplify your Agent \"vibe building\" flow with ADK and Gemini CLI",
  "link": "https://developers.googleblog.com/en/simplify-agent-building-adk-gemini-cli/",
  "description": "The updated Agent Development Kit (ADK) simplifies and accelerates the process of building AI agents by providing the CLI with a deep, cost-effective understanding of the ADK framework, allowing developers to quickly ideate, generate, test, and improve functional agents through conversational prompts, eliminating friction and keeping them in a productive \"flow\" state.",
  "author": "",
  "published": "",
  "source": "http://feeds.feedburner.com/GDBcode",
  "categories": null,
  "byline": "Julia Wiesinger, Hangfei Lin",
  "length": 8362,
  "excerpt": "The updated Agent Development Kit (ADK) simplifies and accelerates the process of building AI agents by providing the CLI with a deep, cost-effective understanding of the ADK framework, allowing developers to quickly ideate, generate, test, and improve functional agents through conversational prompts, eliminating friction and keeping them in a productive \"flow\" state.",
  "siteName": "",
  "favicon": "https://storage.googleapis.com/gweb-developer-goog-blog-assets/meta/apple-touch-icon.png",
  "text": "For developers, the state of \"flow\" is sacred. It’s that magical space where your ideas translate into code almost effortlessly. The biggest enemy to this flow is friction— the reading of documentation, the framework selection, and the context-switching that pulls you out of the creative zone.That's why we’re excited to announce updates to Agent Development Kit (ADK) that, when paired with the Gemini CLI, are designed to eliminate friction and supercharge your agent \"vibe coding\" experience. This combination allows for all the right context in a seamless conversation between you and Gemini, turning your high-level ideas into functional agents with unprecedented speed and fluidity. This way, you can spend more time solving real-world problems using agents and far less time coding them from scratch.The secret sauce: How ADK's llms-full.txt fuels your flowThe heart of this upgrade is the revamped llms-full.txt file included in the ADK repository. Think of this file as a perfectly organized, condensed guide to the entire ADK framework. It’s a map that details all the ADK’s components, functions, and best practices.Specifically, we shortened the file by more than 50% (fewer tokens, yay!) and made it easier for LLMs to understand. This is the key to a better vibe coding experience because it means: Gemini has a full understanding of ADK…without eating your context window or falling prey to “context rot”.So now paired with Gemini CLI, you have a powerful coding assistant that you’ve transformed into an ADK specialist at far lower cost and improved accuracy. CLI gains a deep, native understanding of the framework, enabling it to translate your high-level plans directly into accurate, idiomatic multi-agent code. This dramatically accelerates the speed-to-prototype; because you can generate a functional agent in minutes, you are free to experiment and iterate without a heavy upfront investment in coding time.Vibe in action: Building an AI Github issue labeling agentLet's see what this feels like in a real-world scenario. We'll build an AI agent to label ADK’s Github issues for easier issue prioritization and assignment, going from a simple idea to a working ADK agent in just a few steps.Step 0: Download llms-full.txtDownload the llms-full.txt from adk-python to your working directory.Step 1: Ideate the Plan with Gemini CLIFirst, we use the Gemini CLI as a brainstorming partner to create a high-level plan.You: I want to build an AI agent, leveraging the ADK framework, to help me label Github issues with Gemini in my repo (https://github.com/google/adk-python). It should read the Github issues and label it with some predefined labels (please come up with some common labels first). Come up with a plan on how to do it. @llms-full.txtGemini CLI:Plan: GitHub Issue Labeling AgentThe goal is to create a Python-based AI agent that can analyze a GitHub issue and apply a relevant, predefined label from your repository. We'll use the ADK framework to orchestrate the agent's logic and a Gemini model for the analysis.Phase 1: Project Setup \u0026 Configuration1. Initialize Project: Set up a new Python project directory.2. Install Dependencies: Install the google-adk library and a GitHub API client library like PyGithub.3. GitHub Authentication: Create a GitHub Personal Access Token (PAT) with repo permissions to allow the agent to read issues and apply labels. This token will be configured securely as an environment variable.Phase 2: Develop Custom Tools for GitHubThe agent needs tools to interact with GitHub. We will create a github_tools.py file containing the following functions, which will be exposed to the agent:get_issue(repo_name, issue_number): Fetches the title and body of a specific GitHub issue.get_available_labels(repo_name): Retrieves the list of all existing labels for the repository.apply_label(repo_name, issue_number, label): Applies a given label to a specific issue.Phase 3: Build the Labeling AgentUsing the ADK framework, we will define a new Agent in a main.py file:1. Agent Definition: The agent will be configured to use a Gemini model (e.g., gemini-1.5-flash).2. Tool Integration: The custom GitHub tools from Phase 2 will be provided to the agent.3. Core Instruction (Prompt): The agent's system prompt will instruct it to follow a clear workflow:First, use the get_issue tool to understand the issue's content.Then, use the get_available_labels tool to see the valid options.Based on its analysis, decide on the single best label to apply.Finally, use the apply_label tool to add the chosen label to the issue.Phase 4: Create the Application EntrypointWe will create a simple command-line interface (CLI) in main.py that allows you to run the agent. It will accept the GitHub repository name and an issue number as input, and then trigger the agent to perform the labeling task.Would you like me to proceed with the implementation of this plan?You've defined the logic without writing a single line of code.Step 2: Convert the Plan into an ADK AgentNow, let's use the ADK's llms-full.txt to turn that plan into a real agent.You: Great. Now, generate the code for this plan using the Python ADK. @llms-full.txt (The Gemini CLI now references the ADK's llms-full.txt to translate the plan into correct ADK code.)Gemini CLI import argparse import asyncio from google.adk.agents import Agent from google.adk.runners import Runner from google.adk.sessions import InMemorySessionService from google.genai import types from github_tools import get_issue, get_available_labels, apply_label labeling_agent = Agent( name=\"github_labeler\", model=\"gemini-1.5-flash\", instruction=\"\"\"You are an AI agent that labels GitHub issues. 1. First, use the 'get_issue' tool to read the issue's title and body. 2. Then, use the 'get_available_labels' tool to see all possible labels for the repository. 3. Analyze the issue content and choose the most relevant label from the available options. 4. Finally, use the 'apply_label' tool to add the chosen label to the issue. 5. Respond with a confirmation message stating which label was applied. \"\"\", tools=[get_issue, get_available_labels, apply_label], ) Python Copied from github import Github from config import GITHUB_TOKEN g = Github(GITHUB_TOKEN) def get_issue(repo_name: str, issue_number: int) -\u003e str: \"\"\"Fetches the title and body of a specific GitHub issue.\"\"\" repo = g.get_repo(repo_name) issue = repo.get_issue(number=issue_number) return f\"Title: {issue.title}\\nBody: {issue.body}\" def get_available_labels(repo_name: str) -\u003e list[str]: \"\"\"Retrieves the list of all existing labels for the repository.\"\"\" repo = g.get_repo(repo_name) labels = [label.name for label in repo.get_labels()] return labels def apply_label(repo_name: str, issue_number: int, label: str) -\u003e str: \"\"\"Applies a given label to a specific issue.\"\"\" repo = g.get_repo(repo_name) issue = repo.get_issue(number=issue_number) issue.add_to_labels(label) return f\"Successfully applied label '{label}' to issue #{issue_number}.\" Python Copied (It also generated requirements.txt, label_config.py but we will not list it here for brevity.)Instantly, you have a complete, functional agent application that correctly uses the ADK framework. The CLI handled all the boilerplate because the llms-full.txt file gave it the necessary context.Step 3 \u0026 4: Test and Improve in the FlowWith the code generated, you can test it locally. Maybe you find a bug or think of an improvement. For example, you want a summary after the ADK agent completes the labels. You stay in your flow and simply ask for the change.You: Could you add a new label called “some_new_label” to the agent?The Gemini CLI, still holding the context of your script, refactors the code to implement the change. There's no need to manually edit the code or lose your momentum.Step 5: Rinse and RepeatThis iterative loop is the new workflow:1: Ideate on your agent's logic.2: Generate the ADK code with Gemini CLI.3: Test it instantly.4: Improve it with simple, conversational requests.You can repeat this cycle until your agent is perfect, all without the friction that typically pulls you out of your creative zone.",
  "image": "https://storage.googleapis.com/gweb-developer-goog-blog-assets/images/adk-gemini-cli-agent-building.2e16d0ba.fill-1200x600.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n    \n      \n    \n\n    \n\n    \n\n    \n\n    \n    \u003cdiv\u003e\n          \n\n\u003cdiv\u003e\n    \u003cp data-block-key=\"ftpe0\"\u003eFor developers, the state of \u0026#34;flow\u0026#34; is sacred. It’s that magical space where your ideas translate into code almost effortlessly. The biggest enemy to this flow is friction— the reading of documentation, the framework selection, and the context-switching that pulls you out of the creative zone.\u003c/p\u003e\u003cp data-block-key=\"brtfn\"\u003eThat\u0026#39;s why we’re excited to announce updates to \u003ca href=\"https://developers.googleblog.com/en/agent-development-kit-easy-to-build-multi-agent-applications/\"\u003eAgent Development Kit\u003c/a\u003e (ADK) that, when paired with the \u003ca href=\"https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/\"\u003eGemini CLI\u003c/a\u003e, are designed to eliminate friction and supercharge your agent \u0026#34;vibe coding\u0026#34; experience. This combination allows for all the right context in a seamless conversation between you and Gemini, turning your high-level ideas into functional agents with unprecedented speed and fluidity. This way, you can spend more time solving real-world problems using agents and far less time coding them from scratch.\u003c/p\u003e\u003ch2 data-block-key=\"mt9jv\" id=\"the-secret-sauce:-how-adk\u0026#39;s-llms-full.txt-fuels-your-flow\"\u003e\u003cb\u003e\u003cbr/\u003e\u003c/b\u003eThe secret sauce: How ADK\u0026#39;s llms-full.txt fuels your flow\u003c/h2\u003e\u003cp data-block-key=\"b2isa\"\u003eThe heart of this upgrade is the revamped \u003ca href=\"https://github.com/google/adk-python/blob/main/llms-full.txt\"\u003e\u003ccode\u003ellms-full.txt\u003c/code\u003e\u003c/a\u003e file included in the ADK repository. Think of this file as a perfectly organized, condensed guide to the entire ADK framework. It’s a map that details all the ADK’s components, functions, and best practices.\u003c/p\u003e\u003cp data-block-key=\"8up18\"\u003eSpecifically, we shortened the file by more than 50% (fewer tokens, yay!) and made it easier for LLMs to understand. This is the key to a better vibe coding experience because it means: \u003cb\u003eGemini has a full understanding of ADK…without eating your context window or falling prey to “context rot”.\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"ef83l\"\u003eSo now paired with Gemini CLI, you have a powerful coding assistant that you’ve transformed into an ADK specialist at far lower cost and improved accuracy. CLI gains a deep, native understanding of the framework, enabling it to translate your high-level plans directly into accurate, idiomatic multi-agent code. This dramatically accelerates the speed-to-prototype; because you can generate a functional agent in minutes, you are free to experiment and iterate without a heavy upfront investment in coding time.\u003c/p\u003e\u003ch2 data-block-key=\"sabtt\" id=\"vibe-in-action:-building-an-ai-github-issue-labeling-agent\"\u003e\u003cb\u003e\u003cbr/\u003e\u003c/b\u003eVibe in action: Building an AI Github issue labeling agent\u003c/h2\u003e\u003cp data-block-key=\"afpqe\"\u003eLet\u0026#39;s see what this feels like in a real-world scenario. We\u0026#39;ll build an AI agent to label ADK’s Github issues for easier issue prioritization and assignment, going from a simple idea to a working ADK agent in just a few steps.\u003c/p\u003e\u003ch3 data-block-key=\"yzknp\" id=\"step-0:-download-llms-full.txt\"\u003e\u003cb\u003e\u003cbr/\u003eStep 0: Download llms-full.txt\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"3d7j3\"\u003eDownload the \u003ccode\u003ellms-full.txt\u003c/code\u003e from \u003ca href=\"https://github.com/google/adk-python\"\u003eadk-python\u003c/a\u003e to your working directory.\u003c/p\u003e\u003ch3 data-block-key=\"jshvh\" id=\"step-1:-ideate-the-plan-with-gemini-cli\"\u003e\u003cb\u003e\u003cbr/\u003eStep 1: Ideate the Plan with Gemini CLI\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"4hv8c\"\u003eFirst, we use the Gemini CLI as a brainstorming partner to create a high-level plan.\u003c/p\u003e\u003cp data-block-key=\"86smp\"\u003e\u003cb\u003eYou:\u003c/b\u003e \u003ci\u003eI want to build an AI agent, leveraging the ADK framework, to help me label Github issues with Gemini in my repo (https://github.com/google/adk-python). It should read the Github issues and label it with some predefined labels\u003c/i\u003e (please come up with some common labels first)\u003ci\u003e. Come up with a plan on how to do it. @llms-full.txt\u003c/i\u003e\u003c/p\u003e\u003cp data-block-key=\"9f2le\"\u003e\u003cb\u003eGemini CLI:\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"7rtfd\"\u003e\u003cb\u003ePlan: GitHub Issue Labeling Agent\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"e1iut\"\u003eThe goal is to create a Python-based AI agent that can analyze a GitHub issue and apply a relevant, predefined label from your repository. We\u0026#39;ll use the ADK framework to orchestrate the agent\u0026#39;s logic and a Gemini model for the analysis.\u003c/p\u003e\u003cp data-block-key=\"3406f\"\u003e\u003cb\u003ePhase 1: Project Setup \u0026amp; Configuration\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"73bje\"\u003e1. \u003cb\u003eInitialize Project:\u003c/b\u003e Set up a new Python project directory.\u003c/p\u003e\u003cp data-block-key=\"8k05d\"\u003e2. \u003cb\u003eInstall Dependencies:\u003c/b\u003e Install the \u003ccode\u003egoogle-adk\u003c/code\u003e library and a GitHub API client library like \u003ccode\u003ePyGithub\u003c/code\u003e.\u003c/p\u003e\u003cp data-block-key=\"5tigt\"\u003e3. \u003cb\u003eGitHub Authentication:\u003c/b\u003e Create a GitHub Personal Access Token (PAT) with \u003ccode\u003erepo\u003c/code\u003e permissions to allow the agent to read issues and apply labels. This token will be configured securely as an environment variable.\u003c/p\u003e\u003cp data-block-key=\"e9okj\"\u003e\u003cb\u003e\u003cbr/\u003ePhase 2: Develop Custom Tools for GitHub\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"jvqr\"\u003eThe agent needs tools to interact with GitHub. We will create a \u003ccode\u003egithub_tools.py\u003c/code\u003e file containing the following functions, which will be exposed to the agent:\u003c/p\u003e\u003cul\u003e\u003cli data-block-key=\"902a6\"\u003e\u003ccode\u003eget_issue(repo_name, issue_number)\u003c/code\u003e: Fetches the title and body of a specific GitHub issue.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli data-block-key=\"2ar9p\"\u003e\u003ccode\u003eget_available_labels(repo_name)\u003c/code\u003e: Retrieves the list of all existing labels for the repository.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli data-block-key=\"d8ka9\"\u003e\u003ccode\u003eapply_label(repo_name, issue_number, label)\u003c/code\u003e: Applies a given label to a specific issue.\u003c/li\u003e\u003c/ul\u003e\u003cp data-block-key=\"7kq5\"\u003e\u003cb\u003e\u003cbr/\u003ePhase 3: Build the Labeling Agent\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"3dhdd\"\u003eUsing the ADK framework, we will define a new \u003ccode\u003eAgent\u003c/code\u003e in a \u003ccode\u003emain.py\u003c/code\u003e file:\u003c/p\u003e\u003cp data-block-key=\"7m6r8\"\u003e1. \u003cb\u003eAgent Definition:\u003c/b\u003e The agent will be configured to use a Gemini model (e.g., \u003ccode\u003egemini-1.5-flash\u003c/code\u003e).\u003c/p\u003e\u003cp data-block-key=\"7mhr0\"\u003e2. \u003cb\u003eTool Integration:\u003c/b\u003e The custom GitHub tools from Phase 2 will be provided to the agent.\u003c/p\u003e\u003cp data-block-key=\"buscd\"\u003e3. \u003cb\u003eCore Instruction (Prompt):\u003c/b\u003e The agent\u0026#39;s system prompt will instruct it to follow a clear workflow:\u003c/p\u003e\u003cul\u003e\u003cli data-block-key=\"otva\"\u003eFirst, use the \u003ccode\u003eget_issue\u003c/code\u003e tool to understand the issue\u0026#39;s content.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli data-block-key=\"fikc0\"\u003eThen, use the \u003ccode\u003eget_available_labels\u003c/code\u003e tool to see the valid options.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli data-block-key=\"dm5au\"\u003eBased on its analysis, decide on the single best label to apply.\u003c/li\u003e\u003c/ul\u003e\u003cul\u003e\u003cli data-block-key=\"5186c\"\u003eFinally, use the \u003ccode\u003eapply_label\u003c/code\u003e tool to add the chosen label to the issue.\u003c/li\u003e\u003c/ul\u003e\u003cp data-block-key=\"fpjib\"\u003e\u003cb\u003e\u003cbr/\u003ePhase 4: Create the Application Entrypoint\u003c/b\u003e\u003c/p\u003e\u003cp data-block-key=\"96rtt\"\u003eWe will create a simple command-line interface (CLI) in \u003ccode\u003emain.py\u003c/code\u003e that allows you to run the agent. It will accept the GitHub repository name and an issue number as input, and then trigger the agent to perform the labeling task.\u003c/p\u003e\u003cp data-block-key=\"adifu\"\u003eWould you like me to proceed with the implementation of this plan?\u003c/p\u003e\u003cp data-block-key=\"59dnh\"\u003e\u003cbr/\u003eYou\u0026#39;ve defined the logic without writing a single line of code.\u003c/p\u003e\u003ch3 data-block-key=\"givb2\" id=\"step-2:-convert-the-plan-into-an-adk-agent\"\u003e\u003cb\u003e\u003cbr/\u003eStep 2: Convert the Plan into an ADK Agent\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"5ka3p\"\u003eNow, let\u0026#39;s use the ADK\u0026#39;s \u003ccode\u003ellms-full.txt\u003c/code\u003e to turn that plan into a real agent.\u003c/p\u003e\u003cp data-block-key=\"1em5b\"\u003e\u003cb\u003eYou:\u003c/b\u003e \u003ci\u003eGreat. Now, generate the code for this plan using the Python ADK. @llms-full.txt\u003c/i\u003e (The Gemini CLI now references the ADK\u0026#39;s \u003ccode\u003ellms-full.txt\u003c/code\u003e to translate the plan into correct ADK code.)\u003c/p\u003e\u003cp data-block-key=\"1k8v6\"\u003e\u003cb\u003eGemini CLI\u003c/b\u003e\u003c/p\u003e\n\u003c/div\u003e  \u003cdiv\u003e\n    \u003cpre\u003e\u003ccode\u003eimport argparse\nimport asyncio\nfrom google.adk.agents import Agent\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom google.genai import types\n\nfrom github_tools import get_issue, get_available_labels, apply_label\n\n\n\nlabeling_agent = Agent(\n    name=\u0026#34;github_labeler\u0026#34;,\n    model=\u0026#34;gemini-1.5-flash\u0026#34;,\n    instruction=\u0026#34;\u0026#34;\u0026#34;You are an AI agent that labels GitHub issues.\n    1. First, use the \u0026#39;get_issue\u0026#39; tool to read the issue\u0026#39;s title and body.\n    2. Then, use the \u0026#39;get_available_labels\u0026#39; tool to see all possible labels for the repository.\n    3. Analyze the issue content and choose the most relevant label from the available options.\n    4. Finally, use the \u0026#39;apply_label\u0026#39; tool to add the chosen label to the issue.\n    5. Respond with a confirmation message stating which label was applied.\n    \u0026#34;\u0026#34;\u0026#34;,\n    tools=[get_issue, get_available_labels, apply_label],\n)\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003e\n        Python\n    \u003c/p\u003e\n    \u003cp\u003e\u003cspan\u003eCopied\u003c/span\u003e\n        \n    \u003c/p\u003e\n    \n    \n\u003c/div\u003e    \u003cdiv\u003e\n    \u003cpre\u003e\u003ccode\u003efrom github import Github\nfrom config import GITHUB_TOKEN\n\ng = Github(GITHUB_TOKEN)\n\ndef get_issue(repo_name: str, issue_number: int) -\u0026gt; str:\n    \u0026#34;\u0026#34;\u0026#34;Fetches the title and body of a specific GitHub issue.\u0026#34;\u0026#34;\u0026#34;\n    repo = g.get_repo(repo_name)\n    issue = repo.get_issue(number=issue_number)\n    return f\u0026#34;Title: {issue.title}\\nBody: {issue.body}\u0026#34;\n\ndef get_available_labels(repo_name: str) -\u0026gt; list[str]:\n    \u0026#34;\u0026#34;\u0026#34;Retrieves the list of all existing labels for the repository.\u0026#34;\u0026#34;\u0026#34;\n    repo = g.get_repo(repo_name)\n    labels = [label.name for label in repo.get_labels()]\n    return labels\n\ndef apply_label(repo_name: str, issue_number: int, label: str) -\u0026gt; str:\n    \u0026#34;\u0026#34;\u0026#34;Applies a given label to a specific issue.\u0026#34;\u0026#34;\u0026#34;\n    repo = g.get_repo(repo_name)\n    issue = repo.get_issue(number=issue_number)\n    issue.add_to_labels(label)\n    return f\u0026#34;Successfully applied label \u0026#39;{label}\u0026#39; to issue #{issue_number}.\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n    \u003cp\u003e\n        Python\n    \u003c/p\u003e\n    \u003cp\u003e\u003cspan\u003eCopied\u003c/span\u003e\n        \n    \u003c/p\u003e\n    \n    \n\u003c/div\u003e  \u003cdiv\u003e\n    \u003cp data-block-key=\"ftpe0\"\u003e(It also generated requirements.txt, \u003ca href=\"http://config.py/\"\u003elabel_config.py\u003c/a\u003e but we will not list it here for brevity.)\u003c/p\u003e\u003cp data-block-key=\"9u66c\"\u003eInstantly, you have a complete, functional agent application that correctly uses the ADK framework. The CLI handled all the boilerplate because the \u003ccode\u003ellms-full.txt\u003c/code\u003e file gave it the necessary context.\u003c/p\u003e\u003ch3 data-block-key=\"77mws\" id=\"step-3-and-4:-test-and-improve-in-the-flow\"\u003e\u003cb\u003e\u003cbr/\u003eStep 3 \u0026amp; 4: Test and Improve in the Flow\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"8mqk9\"\u003eWith the code generated, you can test it locally. Maybe you find a bug or think of an improvement. For example, you want a summary after the ADK agent completes the labels. You stay in your flow and simply ask for the change.\u003c/p\u003e\u003cp data-block-key=\"c346f\"\u003e\u003cb\u003eYou:\u003c/b\u003e \u003ci\u003eCould you add a new label called “some_new_label” to the agent?\u003c/i\u003e\u003c/p\u003e\u003cp data-block-key=\"etfof\"\u003e\u003cbr/\u003eThe Gemini CLI, still holding the context of your script, refactors the code to implement the change. There\u0026#39;s no need to manually edit the code or lose your momentum.\u003c/p\u003e\u003ch3 data-block-key=\"ylu79\" id=\"step-5:-rinse-and-repeat\"\u003e\u003cb\u003e\u003cbr/\u003eStep 5: Rinse and Repeat\u003c/b\u003e\u003c/h3\u003e\u003cp data-block-key=\"1sehg\"\u003eThis iterative loop is the new workflow:\u003c/p\u003e\u003cp data-block-key=\"c2c9n\"\u003e1:\u003cb\u003e Ideate\u003c/b\u003e on your agent\u0026#39;s logic.\u003c/p\u003e\u003cp data-block-key=\"1ff7v\"\u003e2:\u003cb\u003e Generate\u003c/b\u003e the ADK code with Gemini CLI.\u003c/p\u003e\u003cp data-block-key=\"e0an4\"\u003e3:\u003cb\u003e Test\u003c/b\u003e it instantly.\u003c/p\u003e\u003cp data-block-key=\"8lpc5\"\u003e4:\u003cb\u003e Improve\u003c/b\u003e it with simple, conversational requests.\u003c/p\u003e\u003cp data-block-key=\"eo3pf\"\u003eYou can repeat this cycle until your agent is perfect, all without the friction that typically pulls you out of your creative zone.\u003c/p\u003e\n\u003c/div\u003e \n      \u003c/div\u003e\n    \n\n    \n\n    \n    \n    \n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2025-07-16T00:00:00Z",
  "modifiedTime": null
}
