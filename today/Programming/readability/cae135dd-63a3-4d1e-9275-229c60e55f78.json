{
  "id": "cae135dd-63a3-4d1e-9275-229c60e55f78",
  "title": "Testing the contents of generated HTML",
  "link": "https://martinfowler.com/articles/tdd-html-templates.html#Level2TestingHtmlStructure",
  "description": "",
  "author": "",
  "published": "2024-05-22T10:14:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": [
    "skip-home-page"
  ],
  "byline": "Matteo Vaccari",
  "length": 70388,
  "excerpt": "Unit testing HTML templates",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "After a decade or more where Single-Page-Applications generated by JavaScript frameworks have become the norm, we see that server-side rendered HTML is becoming popular again, also thanks to libraries such as HTMX or Turbo. Writing a rich web UI in a traditionally server-side language like Go or Java is now not just possible, but a very attractive proposition. We then face the problem of how to write automated tests for the HTML parts of our web applications. While the JavaScript world has evolved powerful and sophisticated ways to test the UI, ranging in size from unit-level to integration to end-to-end, in other languages we do not have such a richness of tools available. When writing a web application in Go or Java, HTML is commonly generated through templates, which contain small fragments of logic. It is certainly possible to test them indirectly through end-to-end tests, but those tests are slow and expensive. We can instead write unit tests that use CSS selectors to probe the presence and correct content of specific HTML elements within a document. Parameterizing these tests makes it easy to add new tests and to clearly indicate what details each test is verifying. This approach works with any language that has access to an HTML parsing library that supports CSS selectors; examples are provided in Go and Java. Motivation Why test-drive HTML templates? After all, the most reliable way to check that a template works is to render it to HTML and open it in a browser, right? There's some truth in this; unit tests cannot prove that a template works as expected when rendered in a browser, so checking them manually is necessary. And if we make a mistake in the logic of a template, usually the template breaks in an obvious way, so the error is quickly spotted. On the other hand: Relying on manual tests only is risky; what if we make a change that breaks a template, and we don't test it because we did not think it would impact the template? We could get an error in production! Templates often contain logic, such as if-then-else's or iterations over arrays of items, and when the array is empty, we often need to show something different. Manual checking all cases, for all of these bits of logic, becomes unsustainable very quickly There are errors that are not visible in the browser. Browsers are extremely tolerant of inconsistencies in HTML, relying on heuristics to fix our broken HTML, but then we might get different results in different browsers, on different devices. It's good to check that the HTML structures we are building in our templates correspond to what we think. It turns out that test-driving HTML templates is easy; let's see how to do it in Go and Java. I will be using as a starting point the TodoMVC template, which is a sample application used to showcase JavaScript frameworks. We will see techniques that can be applied to any programming language and templating technology, as long as we have access to a suitable HTML parser. This article is a bit long; you may want to take a look at the final solution in Go or in Java, or jump to the conclusions. Level 1: checking for sound HTML The number one thing we want to check is that the HTML we produce is basically sound. I don't mean to check that HTML is valid according to the W3C; it would be cool to do it, but it's better to start with much simpler and faster checks. For instance, we want our tests to break if the template generates something like \u003cdiv\u003efoo\u003c/p\u003e Let's see how to do it in stages: we start with the following test that tries to compile the template. In Go we use the standard html/template package. Go func Test_wellFormedHtml(t *testing.T) { templ := template.Must(template.ParseFiles(\"index.tmpl\")) _ = templ } In Java, we use jmustache because it's very simple to use; Freemarker or Velocity are other common choices. Java @Test void indexIsSoundHtml() { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(\"/index.tmpl\"))); } If we run this test, it will fail, because the index.tmpl file does not exist. So we create it, with the above broken HTML. Now the test should pass. Then we create a model for the template to use. The application manages a todo-list, and we can create a minimal model for demonstration purposes. Go func Test_wellFormedHtml(t *testing.T) { templ := template.Must(template.ParseFiles(\"index.tmpl\")) model := todo.NewList() _ = templ _ = model } Java @Test void indexIsSoundHtml() { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(\"/index.tmpl\"))); var model = new TodoList(); } Now we render the template, saving the results in a bytes buffer (Go) or as a String (Java). Go func Test_wellFormedHtml(t *testing.T) { templ := template.Must(template.ParseFiles(\"index.tmpl\")) model := todo.NewList() var buf bytes.Buffer err := templ.Execute(\u0026buf, model) if err != nil { panic(err) } } Java @Test void indexIsSoundHtml() { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(\"/index.tmpl\"))); var model = new TodoList(); var html = template.execute(model); } At this point, we want to parse the HTML and we expect to see an error, because in our broken HTML there is a div element that is closed by a p element. There is an HTML parser in the Go standard library, but it is too lenient: if we run it on our broken HTML, we don't get an error. Luckily, the Go standard library also has an XML parser that can be configured to parse HTML (thanks to this Stack Overflow answer) Go func Test_wellFormedHtml(t *testing.T) { templ := template.Must(template.ParseFiles(\"index.tmpl\")) model := todo.NewList() // render the template into a buffer var buf bytes.Buffer err := templ.Execute(\u0026buf, model) if err != nil { panic(err) } // check that the template can be parsed as (lenient) XML decoder := xml.NewDecoder(bytes.NewReader(buf.Bytes())) decoder.Strict = false decoder.AutoClose = xml.HTMLAutoClose decoder.Entity = xml.HTMLEntity for { _, err := decoder.Token() switch err { case io.EOF: return // We're done, it's valid! case nil: // do nothing default: t.Fatalf(\"Error parsing html: %s\", err) } } } source This code configures the HTML parser to have the right level of leniency for HTML, and then parses the HTML token by token. Indeed, we see the error message we wanted: --- FAIL: Test_wellFormedHtml (0.00s) index_template_test.go:61: Error parsing html: XML syntax error on line 4: unexpected end element \u003c/p\u003e In Java, a versatile library to use is jsoup: Java @Test void indexIsSoundHtml() { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(\"/index.tmpl\"))); var model = new TodoList(); var html = template.execute(model); var parser = Parser.htmlParser().setTrackErrors(10); Jsoup.parse(html, \"\", parser); assertThat(parser.getErrors()).isEmpty(); } source And we see it fail: java.lang.AssertionError: Expecting empty but was:\u003c[\u003c1:13\u003e: Unexpected EndTag token [\u003c/p\u003e] when in state [InBody], Success! Now if we copy over the contents of the TodoMVC template to our index.tmpl file, the test passes. The test, however, is too verbose: we extract two helper functions, in order to make the intention of the test clearer, and we get Go func Test_wellFormedHtml(t *testing.T) { model := todo.NewList() buf := renderTemplate(\"index.tmpl\", model) assertWellFormedHtml(t, buf) } source Java @Test void indexIsSoundHtml() { var model = new TodoList(); var html = renderTemplate(\"/index.tmpl\", model); assertSoundHtml(html); } source Level 2: testing HTML structure What else should we test? We know that the looks of a page can only be tested, ultimately, by a human looking at how it is rendered in a browser. However, there is often logic in templates, and we want to be able to test that logic. One might be tempted to test the rendered HTML with string equality, but this technique fails in practice, because templates contain a lot of details that make string equality assertions impractical. The assertions become very verbose, and when reading the assertion, it becomes difficult to understand what it is that we're trying to prove. What we need is a technique to assert that some parts of the rendered HTML correspond to what we expect, and to ignore all the details we don't care about. One way to do this is by running queries with the CSS selector language: it is a powerful language that allows us to select the elements that we care about from the whole HTML document. Once we have selected those elements, we (1) count that the number of element returned is what we expect, and (2) that they contain the text or other content that we expect. The UI that we are supposed to generate looks like this: There are several details that are rendered dynamically: The number of items and their text content change, obviously The style of the todo-item changes when it's completed (e.g., the second) The “2 items left” text will change with the number of non-completed items One of the three buttons “All”, “Active”, “Completed” will be highlighted, depending on the current url; for instance if we decide that the url that shows only the “Active” items is /active, then when the current url is /active, the “Active” button should be surrounded by a thin red rectangle The “Clear completed” button should only be visible if any item is completed Each of this concerns can be tested with the help of CSS selectors. This is a snippet from the TodoMVC template (slightly simplified). I have not yet added the dynamic bits, so what we see here is static content, provided as an example: index.tmpl \u003csection class=\"todoapp\"\u003e \u003cul class=\"todo-list\"\u003e \u003c!-- These are here just to show the structure of the list items --\u003e \u003c!-- List items should get the class `completed` when marked as completed --\u003e \u003cli class=\"completed\"\u003e ② \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\" checked\u003e \u003clabel\u003eTaste JavaScript\u003c/label\u003e ① \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003eBuy a unicorn\u003c/label\u003e ① \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e \u003cfooter class=\"footer\"\u003e \u003c!-- This should be `0 items left` by default --\u003e \u003cspan class=\"todo-count\"\u003e\u003cstrong\u003e0\u003c/strong\u003e item left\u003c/span\u003e ⓷ \u003cul class=\"filters\"\u003e \u003cli\u003e \u003ca class=\"selected\" href=\"#/\"\u003eAll\u003c/a\u003e ④ \u003c/li\u003e \u003cli\u003e \u003ca href=\"#/active\"\u003eActive\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca href=\"#/completed\"\u003eCompleted\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c!-- Hidden if no completed items are left ↓ --\u003e \u003cbutton class=\"clear-completed\"\u003eClear completed\u003c/button\u003e ⑤ \u003c/footer\u003e \u003c/section\u003e source By looking at the static version of the template, we can deduce which CSS selectors can be used to identify the relevant elements for the 5 dynamic features listed above: featureCSS selector ①All the itemsul.todo-list li ②Completed itemsul.todo-list li.completed ⓷Items leftspan.todo-count ④Highlighted navigation linkul.filters a.selected ⑤Clear completed buttonbutton.clear-completed We can use these selectors to focus our tests on just the things we want to test. Testing HTML content The first test will look for all the items, and prove that the data set up by the test is rendered correctly. func Test_todoItemsAreShown(t *testing.T) { model := todo.NewList() model.Add(\"Foo\") model.Add(\"Bar\") buf := renderTemplate(model) // assert there are two \u003cli\u003e elements inside the \u003cul class=\"todo-list\"\u003e // assert the first \u003cli\u003e text is \"Foo\" // assert the second \u003cli\u003e text is \"Bar\" } We need a way to query the HTML document with our CSS selector; a good library for Go is goquery, that implements an API inspired by jQuery. In Java, we keep using the same library we used to test for sound HTML, namely jsoup. Our test becomes: Go func Test_todoItemsAreShown(t *testing.T) { model := todo.NewList() model.Add(\"Foo\") model.Add(\"Bar\") buf := renderTemplate(\"index.tmpl\", model) // parse the HTML with goquery document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes())) if err != nil { // if parsing fails, we stop the test here with t.FatalF t.Fatalf(\"Error rendering template %s\", err) } // assert there are two \u003cli\u003e elements inside the \u003cul class=\"todo-list\"\u003e selection := document.Find(\"ul.todo-list li\") assert.Equal(t, 2, selection.Length()) // assert the first \u003cli\u003e text is \"Foo\" assert.Equal(t, \"Foo\", text(selection.Nodes[0])) // assert the second \u003cli\u003e text is \"Bar\" assert.Equal(t, \"Bar\", text(selection.Nodes[1])) } func text(node *html.Node) string { // A little mess due to the fact that goquery has // a .Text() method on Selection but not on html.Node sel := goquery.Selection{Nodes: []*html.Node{node}} return strings.TrimSpace(sel.Text()) } source Java @Test void todoItemsAreShown() throws IOException { var model = new TodoList(); model.add(\"Foo\"); model.add(\"Bar\"); var html = renderTemplate(\"/index.tmpl\", model); // parse the HTML with jsoup Document document = Jsoup.parse(html, \"\"); // assert there are two \u003cli\u003e elements inside the \u003cul class=\"todo-list\"\u003e var selection = document.select(\"ul.todo-list li\"); assertThat(selection).hasSize(2); // assert the first \u003cli\u003e text is \"Foo\" assertThat(selection.get(0).text()).isEqualTo(\"Foo\"); // assert the second \u003cli\u003e text is \"Bar\" assertThat(selection.get(1).text()).isEqualTo(\"Bar\"); } source If we still haven't changed the template to populate the list from the model, this test will fail, because the static template todo items have different text: Go --- FAIL: Test_todoItemsAreShown (0.00s) index_template_test.go:44: First list item: want Foo, got Taste JavaScript index_template_test.go:49: Second list item: want Bar, got Buy a unicorn Java IndexTemplateTest \u003e todoItemsAreShown() FAILED org.opentest4j.AssertionFailedError: Expecting: \u003c\"Taste JavaScript\"\u003e to be equal to: \u003c\"Foo\"\u003e but was not. We fix it by making the template use the model data: Go \u003cul class=\"todo-list\"\u003e {{ range .Items }} \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003e{{ .Title }}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e source Java - jmustache \u003cul class=\"todo-list\"\u003e {{ #allItems }} \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003e{{ title }}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e {{ /allItems }} \u003c/ul\u003e source Test both content and soundness at the same time Our test works, but it is a bit verbose, especially the Go version. If we're going to have more tests, they will become repetitive and difficult to read, so we make it more concise by extracting a helper function for parsing the html. We also remove the comments, as the code should be clear enough Go func Test_todoItemsAreShown(t *testing.T) { model := todo.NewList() model.Add(\"Foo\") model.Add(\"Bar\") buf := renderTemplate(\"index.tmpl\", model) document := parseHtml(t, buf) selection := document.Find(\"ul.todo-list li\") assert.Equal(t, 2, selection.Length()) assert.Equal(t, \"Foo\", text(selection.Nodes[0])) assert.Equal(t, \"Bar\", text(selection.Nodes[1])) } func parseHtml(t *testing.T, buf bytes.Buffer) *goquery.Document { document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes())) if err != nil { // if parsing fails, we stop the test here with t.FatalF t.Fatalf(\"Error rendering template %s\", err) } return document } Java @Test void todoItemsAreShown() throws IOException { var model = new TodoList(); model.add(\"Foo\"); model.add(\"Bar\"); var html = renderTemplate(\"/index.tmpl\", model); var document = parseHtml(html); var selection = document.select(\"ul.todo-list li\"); assertThat(selection).hasSize(2); assertThat(selection.get(0).text()).isEqualTo(\"Foo\"); assertThat(selection.get(1).text()).isEqualTo(\"Bar\"); } private static Document parseHtml(String html) { return Jsoup.parse(html, \"\"); } Much better! At least in my opinion. Now that we extracted the parseHtml helper, it's a good idea to check for sound HTML in the helper: Go func parseHtml(t *testing.T, buf bytes.Buffer) *goquery.Document { assertWellFormedHtml(t, buf) document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes())) if err != nil { // if parsing fails, we stop the test here with t.FatalF t.Fatalf(\"Error rendering template %s\", err) } return document } source Java private static Document parseHtml(String html) { var parser = Parser.htmlParser().setTrackErrors(10); var document = Jsoup.parse(html, \"\", parser); assertThat(parser.getErrors()).isEmpty(); return document; } source And with this, we can get rid of the first test that we wrote, as we are now testing for sound HTML all the time. The second test Now we are in a good position for testing more rendering logic. The second dynamic feature in our list is “List items should get the class completed when marked as completed”. We can write a test for this: Go func Test_completedItemsGetCompletedClass(t *testing.T) { model := todo.NewList() model.Add(\"Foo\") model.AddCompleted(\"Bar\") buf := renderTemplate(\"index.tmpl\", model) document := parseHtml(t, buf) selection := document.Find(\"ul.todo-list li.completed\") assert.Equal(t, 1, selection.Size()) assert.Equal(t, \"Bar\", text(selection.Nodes[0])) } source Java @Test void completedItemsGetCompletedClass() { var model = new TodoList(); model.add(\"Foo\"); model.addCompleted(\"Bar\"); var html = renderTemplate(\"/index.tmpl\", model); Document document = Jsoup.parse(html, \"\"); var selection = document.select(\"ul.todo-list li.completed\"); assertThat(selection).hasSize(1); assertThat(selection.text()).isEqualTo(\"Bar\"); } source And this test can be made green by adding this bit of logic to the template: Go \u003cul class=\"todo-list\"\u003e {{ range .Items }} \u003cli class=\"{{ if .IsCompleted }}completed{{ end }}\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003e{{ .Title }}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e source Java - jmustache \u003cul class=\"todo-list\"\u003e {{ #allItems }} \u003cli class=\"{{ #isCompleted }}completed{{ /isCompleted }}\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003e{{ title }}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e {{ /allItems }} \u003c/ul\u003e source So little by little, we can test and add the various dynamic features that our template should have. Make it easy to add new tests The first of the 20 tips from the excellent talk by Russ Cox on Go Testing is “Make it easy to add new test cases“. Indeed, in Go there is a tendency to make most tests parameterized, for this very reason. On the other hand, while Java has good support for parameterized tests with JUnit 5, they don't seem to be used as much. Since our current two tests have the same structure, we could factor them into a single parameterized test. A test case for us will consist of: A name (so that we can produce clear error messages when the test fails) A model (in our case a todo.List) A CSS selector A list of text matches that we expect to find when we run the CSS selector on the rendered HTML. So this is the data structure for our test cases: Go var testCases = []struct { name string model *todo.List selector string matches []string }{ { name: \"all todo items are shown\", model: todo.NewList(). Add(\"Foo\"). Add(\"Bar\"), selector: \"ul.todo-list li\", matches: []string{\"Foo\", \"Bar\"}, }, { name: \"completed items get the 'completed' class\", model: todo.NewList(). Add(\"Foo\"). AddCompleted(\"Bar\"), selector: \"ul.todo-list li.completed\", matches: []string{\"Bar\"}, }, } source Java record TestCase(String name, TodoList model, String selector, List\u003cString\u003e matches) { @Override public String toString() { return name; } } public static TestCase[] indexTestCases() { return new TestCase[]{ new TestCase( \"all todo items are shown\", new TodoList() .add(\"Foo\") .add(\"Bar\"), \"ul.todo-list li\", List.of(\"Foo\", \"Bar\")), new TestCase( \"completed items get the 'completed' class\", new TodoList() .add(\"Foo\") .addCompleted(\"Bar\"), \"ul.todo-list li.completed\", List.of(\"Bar\")), }; } source And this is our parameterized test: Go func Test_indexTemplate(t *testing.T) { for _, test := range testCases { t.Run(test.name, func(t *testing.T) { buf := renderTemplate(\"index.tmpl\", test.model) assertWellFormedHtml(t, buf) document := parseHtml(t, buf) selection := document.Find(test.selector) require.Equal(t, len(test.matches), len(selection.Nodes), \"unexpected # of matches\") for i, node := range selection.Nodes { assert.Equal(t, test.matches[i], text(node)) } }) } } source Java @ParameterizedTest @MethodSource(\"indexTestCases\") void testIndexTemplate(TestCase test) { var html = renderTemplate(\"/index.tmpl\", test.model); var document = parseHtml(html); var selection = document.select(test.selector); assertThat(selection).hasSize(test.matches.size()); for (int i = 0; i \u003c test.matches.size(); i++) { assertThat(selection.get(i).text()).isEqualTo(test.matches.get(i)); } } source We can now run our parameterized test and see it pass: Go $ go test -v === RUN Test_indexTemplate === RUN Test_indexTemplate/all_todo_items_are_shown === RUN Test_indexTemplate/completed_items_get_the_'completed'_class --- PASS: Test_indexTemplate (0.00s) --- PASS: Test_indexTemplate/all_todo_items_are_shown (0.00s) --- PASS: Test_indexTemplate/completed_items_get_the_'completed'_class (0.00s) PASS ok tdd-html-templates 0.608s Java $ ./gradlew test \u003e Task :test IndexTemplateTest \u003e testIndexTemplate(TestCase) \u003e [1] all todo items are shown PASSED IndexTemplateTest \u003e testIndexTemplate(TestCase) \u003e [2] completed items get the 'completed' class PASSED Note how, by giving a name to our test cases, we get very readable test output, both on the terminal and in the IDE: Having rewritten our two old tests in table form, it's now super easy to add another. This is the test for the “x items left” text: Go { name: \"items left\", model: todo.NewList(). Add(\"One\"). Add(\"Two\"). AddCompleted(\"Three\"), selector: \"span.todo-count\", matches: []string{\"2 items left\"}, }, source Java new TestCase( \"items left\", new TodoList() .add(\"One\") .add(\"Two\") .addCompleted(\"Three\"), \"span.todo-count\", List.of(\"2 items left\")), source And the corresponding change in the html template is: Go \u003cspan class=\"todo-count\"\u003e\u003cstrong\u003e{{len .ActiveItems}}\u003c/strong\u003e items left\u003c/span\u003e source Java - jmustache \u003cspan class=\"todo-count\"\u003e\u003cstrong\u003e{{activeItemsCount}}\u003c/strong\u003e items left\u003c/span\u003e source The above change in the template requires a supporting method in the model: Go type Item struct { Title string IsCompleted bool } type List struct { Items []*Item } func (l *List) ActiveItems() []*Item { var result []*Item for _, item := range l.Items { if !item.IsCompleted { result = append(result, item) } } return result } source Java public class TodoList { private final List\u003cTodoItem\u003e items = new ArrayList\u003c\u003e(); // ... public long activeItemsCount() { return items.stream().filter(TodoItem::isActive).count(); } } source We've invested a little effort in our testing infrastructure, so that adding new test cases is easier. In the next section, we'll see that the requirements for the next test cases will push us to refine our test infrastructure further. Making the table more expressive, at the expense of the test code We will now test the “All”, “Active” and “Completed” navigation links at the bottom of the UI (see the picture above), and these depend on which url we are visiting, which is something that our template has no way to find out. Currently, all we pass to our template is our model, which is a todo-list. It's not correct to add the currently visited url to the model, because that is user navigation state, not application state. So we need to pass more information to the template beyond the model. An easy way is to pass a map, which we construct in our renderTemplate function: Go func renderTemplate(model *todo.List, path string) bytes.Buffer { templ := template.Must(template.ParseFiles(\"index.tmpl\")) var buf bytes.Buffer data := map[string]any{ \"model\": model, \"path\": path, } err := templ.Execute(\u0026buf, data) if err != nil { panic(err) } return buf } Java private String renderTemplate(String templateName, TodoList model, String path) { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(templateName))); var data = Map.of( \"model\", model, \"path\", path ); return template.execute(data); } And correspondingly our test cases table has one more field: Go var testCases = []struct { name string model *todo.List path string selector string matches []string }{ { name: \"all todo items are shown\", model: todo.NewList(). Add(\"Foo\"). Add(\"Bar\"), selector: \"ul.todo-list li\", matches: []string{\"Foo\", \"Bar\"}, }, // ... the other cases { name: \"highlighted navigation link: All\", path: \"/\", selector: \"ul.filters a.selected\", matches: []string{\"All\"}, }, { name: \"highlighted navigation link: Active\", path: \"/active\", selector: \"ul.filters a.selected\", matches: []string{\"Active\"}, }, { name: \"highlighted navigation link: Completed\", path: \"/completed\", selector: \"ul.filters a.selected\", matches: []string{\"Completed\"}, }, } Java record TestCase(String name, TodoList model, String path, String selector, List\u003cString\u003e matches) { @Override public String toString() { return name; } } public static TestCase[] indexTestCases() { return new TestCase[]{ new TestCase( \"all todo items are shown\", new TodoList() .add(\"Foo\") .add(\"Bar\"), \"/\", \"ul.todo-list li\", List.of(\"Foo\", \"Bar\")), // ... the previous cases new TestCase( \"highlighted navigation link: All\", new TodoList(), \"/\", \"ul.filters a.selected\", List.of(\"All\")), new TestCase( \"highlighted navigation link: Active\", new TodoList(), \"/active\", \"ul.filters a.selected\", List.of(\"Active\")), new TestCase( \"highlighted navigation link: Completed\", new TodoList(), \"/completed\", \"ul.filters a.selected\", List.of(\"Completed\")), }; } We notice that for the three new cases, the model is irrelevant; while for the previous cases, the path is irrelevant. The Go syntax allows us to initialize a struct with just the fields we're interested in, but Java does not have a similar feature, so we're pushed to pass extra information, and this makes the test cases table harder to understand. A developer might look at the first test case and wonder if the expected behavior depends on the path being set to “/”, and might be tempted to add more cases with a different path. In the same way, when reading the highlighted navigation link test cases, the developer might wonder if the expected behavior depends on the model being set to an empty todo list. If so, one might be led to add irrelevant test cases for the highlighted link with non-empty todo-lists. We want to optimize for the time of the developers, so it's worthwhile to avoid adding irrelevant data to our test case. In Java we might pass null for the irrelevant fields, but there's a better way: we can use the builder pattern, popularized by Joshua Bloch. We can quickly write one for the Java TestCase record this way: Java record TestCase(String name, TodoList model, String path, String selector, List\u003cString\u003e matches) { @Override public String toString() { return name; } public static final class Builder { String name; TodoList model; String path; String selector; List\u003cString\u003e matches; public Builder name(String name) { this.name = name; return this; } public Builder model(TodoList model) { this.model = model; return this; } public Builder path(String path) { this.path = path; return this; } public Builder selector(String selector) { this.selector = selector; return this; } public Builder matches(String ... matches) { this.matches = Arrays.asList(matches); return this; } public TestCase build() { return new TestCase(name, model, path, selector, matches); } } } Hand-coding builders is a little tedious, but doable, though there are automated ways to write them. Now we can rewrite our Java test cases with the Builder, to achieve greater clarity: Java public static TestCase[] indexTestCases() { return new TestCase[]{ new TestCase.Builder() .name(\"all todo items are shown\") .model(new TodoList() .add(\"Foo\") .add(\"Bar\")) .selector(\"ul.todo-list li\") .matches(\"Foo\", \"Bar\") .build(), // ... other cases new TestCase.Builder() .name(\"highlighted navigation link: Completed\") .path(\"/completed\") .selector(\"ul.filters a.selected\") .matches(\"Completed\") .build(), }; } So, where are we with our tests? At present, they fail for the wrong reason: null-pointer exceptions due to the missing model and path values. In order to get our new test cases to fail for the right reason, namely that the template does not yet have logic to highlight the correct link, we must provide default values for model and path. In Go, we can do this in the test method: Go func Test_indexTemplate(t *testing.T) { for _, test := range testCases { t.Run(test.name, func(t *testing.T) { if test.model == nil { test.model = todo.NewList() } buf := renderTemplate(test.model, test.path) // ... same as before }) } } source In Java, we can provide default values in the builder: Java public static final class Builder { String name; TodoList model = new TodoList(); String path = \"/\"; String selector; List\u003cString\u003e matches; // ... } source With these changes, we see that the last two test cases, the ones for the highlighted link Active and Completed fail, for the expected reason that the highlighted link does not change: Go === RUN Test_indexTemplate/highlighted_navigation_link:_Active index_template_test.go:82: Error Trace: .../tdd-templates/go/index_template_test.go:82 Error: Not equal: expected: \"Active\" actual : \"All\" === RUN Test_indexTemplate/highlighted_navigation_link:_Completed index_template_test.go:82: Error Trace: .../tdd-templates/go/index_template_test.go:82 Error: Not equal: expected: \"Completed\" actual : \"All\" Java IndexTemplateTest \u003e testIndexTemplate(TestCase) \u003e [5] highlighted navigation link: Active FAILED org.opentest4j.AssertionFailedError: Expecting: \u003c\"All\"\u003e to be equal to: \u003c\"Active\"\u003e but was not. IndexTemplateTest \u003e testIndexTemplate(TestCase) \u003e [6] highlighted navigation link: Completed FAILED org.opentest4j.AssertionFailedError: Expecting: \u003c\"All\"\u003e to be equal to: \u003c\"Completed\"\u003e but was not. To make the tests pass, we make these changes to the template: Go \u003cul class=\"filters\"\u003e \u003cli\u003e \u003ca class=\"{{ if eq .path \"/\" }}selected{{ end }}\" href=\"#/\"\u003eAll\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca class=\"{{ if eq .path \"/active\" }}selected{{ end }}\" href=\"#/active\"\u003eActive\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca class=\"{{ if eq .path \"/completed\" }}selected{{ end }}\" href=\"#/completed\"\u003eCompleted\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e source Java - jmustache \u003cul class=\"filters\"\u003e \u003cli\u003e \u003ca class=\"{{ #pathRoot }}selected{{ /pathRoot }}\" href=\"#/\"\u003eAll\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca class=\"{{ #pathActive }}selected{{ /pathActive }}\" href=\"#/active\"\u003eActive\u003c/a\u003e \u003c/li\u003e \u003cli\u003e \u003ca class=\"{{ #pathCompleted }}selected{{ /pathCompleted }}\" href=\"#/completed\"\u003eCompleted\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e source Since the Mustache template language does not allow for equality testing, we must change the data passed to the template so that we execute the equality tests before rendering the template: Java private String renderTemplate(String templateName, TodoList model, String path) { var template = Mustache.compiler().compile( new InputStreamReader( getClass().getResourceAsStream(templateName))); var data = Map.of( \"model\", model, \"pathRoot\", path.equals(\"/\"), \"pathActive\", path.equals(\"/active\"), \"pathCompleted\", path.equals(\"/completed\") ); return template.execute(data); } source And with these changes, all of our tests now pass. To recap this section, we made the test code a little bit more complicated, so that the test cases are clearer: this is a very good tradeoff! Level 3: testing HTML behaviour In the story so far, we tested the behaviour of the HTML templates, by checking the structure of the generated HTML. That's good, but what if we wanted to test the behaviour of the HTML itself, plus any CSS and JavaScript it may use? The behaviour of HTML by itself is usually pretty obvious, because there is not much of it. The only elements that can interact with the user are the anchor (\u003ca\u003e), \u003cform\u003e and \u003cinput\u003e elements, but the picture changes completely when we add CSS, that can hide, show, move around things and lots more, and with JavaScript, that can add any behaviour to a page. In an application that is primarily rendered server-side, we expect that most behaviour is implemented by returning new HTML with a round-trip to the user, and this can be tested adequately with the techniques we've seen so far, but what if we wanted to speed up the application behaviour with a library such as HTMX? This library works through special attributes that are added to elements to add Ajax behaviour. These attributes are in effect a DSL that we might want to test. How can we test the combination of HTML, CSS and JavaScript in a unit test? Testing HTML, CSS and JavaScript requires something that is able to interpret and execute their behaviours; in other words, we need a browser! It is customary to use headless browsers in end-to-end tests; can we use them for unitary tests instead? I think this is possible, using the following techniques, although I must admit I have yet to try this on a real project. We will use the Playwright library, that is available for both Go and Java. The tests we are going to write will be slower, because we will have to wait a few seconds for the headless browser to start, but will retain some of the important characteristics of unit tests, primarily that we are testing just the HTML (and any associated CSS and JavaScript), in isolation from any other server-side logic. Continuing with the TodoMVC example, the next thing we might want to test is what happens when the user clicks on the checkbox of a todo item. What we'd like to happen is that: A POST call to the server is made, so that the application knows that the state of a todo item has changed The server returns new HTML for the dynamic part of the page, namely all of the section with class “todoapp”, so that we can show the new state of the application including the count of remaining “active” items (see the template above) The page replaces the old contents of the “todoapp” section with the new ones. Loading the page in the Playwright browser We start with a test that will just load the initial HTML. The test is a little involved, so I show the complete code here, and then I will comment it bit by bit. Go func Test_toggleTodoItem(t *testing.T) { // render the initial HTML model := todo.NewList(). Add(\"One\"). Add(\"Two\") initialHtml := renderTemplate(\"index.tmpl\", model, \"/\") // open the browser page with Playwright page := openPage() defer page.Close() logActivity(page) // stub network calls err := page.Route(\"**\", func(route playwright.Route) { if route.Request().URL() == \"http://localhost:4567/index.html\" { // serve the initial HTML stubResponse(route, initialHtml.String(), \"text/html\") } else { // avoid unexpected requests panic(\"unexpected request: \" + route.Request().URL()) } }) if err != nil { t.Fatal(err) } // load initial HTML in the page response, err := page.Goto(\"http://localhost:4567/index.html\") if err != nil { t.Fatal(err) } if response.Status() != 200 { t.Fatalf(\"unexpected status: %d\", response.Status()) } } source Java public class IndexBehaviourTest { static Playwright playwright; static Browser browser; @BeforeAll static void launchBrowser() { playwright = Playwright.create(); browser = playwright.chromium().launch(); } @AfterAll static void closeBrowser() { playwright.close(); } @Test void toggleTodoItem() { // Render the initial html TodoList model = new TodoList() .add(\"One\") .add(\"Two\"); String initialHtml = renderTemplate(\"/index.tmpl\", model, \"/\"); try (Page page = browser.newPage()) { logActivity(page); // stub network calls page.route(\"**\", route -\u003e { if (route.request().url().equals(\"http://localhost:4567/index.html\")) { // serve the initial HTML route.fulfill(new Route.FulfillOptions() .setContentType(\"text/html\") .setBody(initialHtml)); } else { // we don't want unexpected calls fail(String.format(\"Unexpected request: %s %s\", route.request().method(), route.request().url())); } }); // load initial html page.navigate(\"http://localhost:4567/index.html\"); } } } source At the start of the test, we initialize the model with two todo items “One” and “Two”, then we render the template as before: Go model := todo.NewList(). Add(\"One\"). Add(\"Two\") initialHtml := renderTemplate(\"index.tmpl\", model, \"/\") Java TodoList model = new TodoList() .add(\"One\") .add(\"Two\"); String initialHtml = renderTemplate(\"/index.tmpl\", model, \"/\"); Then we open the Playwright “page”, which will start a headless browser Go page := openPage() defer page.Close() logActivity(page) Java try (Page page = browser.newPage()) { logActivity(page); The openPage function in Go returns a Playwright Page object, Go func openPage() playwright.Page { pw, err := playwright.Run() if err != nil { log.Fatalf(\"could not start playwright: %v\", err) } browser, err := pw.Chromium.Launch() if err != nil { log.Fatalf(\"could not launch browser: %v\", err) } page, err := browser.NewPage() if err != nil { log.Fatalf(\"could not create page: %v\", err) } return page } and the logActivity function provides feedback on what the page is doing Go func logActivity(page playwright.Page) { page.OnRequest(func(request playwright.Request) { log.Printf(\"\u003e\u003e %s %s\\n\", request.Method(), request.URL()) }) page.OnResponse(func(response playwright.Response) { log.Printf(\"\u003c\u003c %d %s\\n\", response.Status(), response.URL()) }) page.OnLoad(func(page playwright.Page) { log.Println(\"Loaded: \" + page.URL()) }) page.OnConsole(func(message playwright.ConsoleMessage) { log.Println(\"! \" + message.Text()) }) } Java private void logActivity(Page page) { page.onRequest(request -\u003e System.out.printf(\"\u003e\u003e %s %s%n\", request.method(), request.url())); page.onResponse(response -\u003e System.out.printf(\"\u003c\u003c %s %s%n\", response.status(), response.url())); page.onLoad(page1 -\u003e System.out.println(\"Loaded: \" + page1.url())); page.onConsoleMessage(consoleMessage -\u003e System.out.println(\"! \" + consoleMessage.text())); } Then we stub all network activity that the page might try to do Go err := page.Route(\"**\", func(route playwright.Route) { if route.Request().URL() == \"http://localhost:4567/index.html\" { // serve the initial HTML stubResponse(route, initialHtml.String(), \"text/html\") } else { // avoid unexpected requests panic(\"unexpected request: \" + route.Request().URL()) } }) Java // stub network calls page.route(\"**\", route -\u003e { if (route.request().url().equals(\"http://localhost:4567/index.html\")) { // serve the initial HTML route.fulfill(new Route.FulfillOptions() .setContentType(\"text/html\") .setBody(initialHtml)); } else { // we don't want unexpected calls fail(String.format(\"Unexpected request: %s %s\", route.request().method(), route.request().url())); } }); and we ask the page to load the initial HTML Go response, err := page.Goto(\"http://localhost:4567/index.html\") Java page.navigate(\"http://localhost:4567/index.html\"); With all this machinery in place, we run the test; it succeeds and it logs the stubbed network activity on standard output: Go === RUN Test_toggleTodoItem \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html Loaded: http://localhost:4567/index.html --- PASS: Test_toggleTodoItem (0.89s) Java IndexBehaviourTest \u003e toggleTodoItem() STANDARD_OUT \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html Loaded: http://localhost:4567/index.html IndexBehaviourTest \u003e toggleTodoItem() PASSED So with this test we are now able to load arbitrary HTML in a headless browser. In the next sections we'll see how to simulate user interaction with elements of the page, and observe the page's behaviour. But first we need to solve a problem with the lack of identifiers in our domain model. Identifying todo items Now we want to click on the “One” checkbox. The problem we have is that at present, we have no way to identify individual todo items, so we introduce an Id field in the todo item: Go – updated model with Id type Item struct { Id int Title string IsCompleted bool } func (l *List) AddWithId(id int, title string) *List { item := Item{ Id: id, Title: title, } l.Items = append(l.Items, \u0026item) return l } // Add creates a new todo.Item with a random Id func (l *List) Add(title string) *List { item := Item{ Id: generateRandomId(), Title: title, } l.Items = append(l.Items, \u0026item) return l } func generateRandomId() int { return abs(rand.Int()) } Java – updated model with Id public class TodoList { private final List\u003cTodoItem\u003e items = new ArrayList\u003c\u003e(); public TodoList add(String title) { items.add(new TodoItem(generateRandomId(), title, false)); return this; } public TodoList addCompleted(String title) { items.add(new TodoItem(generateRandomId(), title, true)); return this; } public TodoList add(int id, String title) { items.add(new TodoItem(id, title, false)); return this; } private static int generateRandomId() { return new Random().nextInt(0, Integer.MAX_VALUE); } } public record TodoItem(int id, String title, boolean isCompleted) { public boolean isActive() { return !isCompleted; } } And we update the model in our test to add explicit Ids Go – adding Id in the test data func Test_toggleTodoItem(t *testing.T) { // render the initial HTML model := todo.NewList(). AddWithId(101, \"One\"). AddWithId(102, \"Two\") initialHtml := renderTemplate(\"index.tmpl\", model, \"/\") // ... } Java – adding Id in the test data @Test void toggleTodoItem() { // Render the initial html TodoList model = new TodoList() .add(101, \"One\") .add(102, \"Two\"); String initialHtml = renderTemplate(\"/index.tmpl\", model, \"/\"); } We are now ready to test user interaction with the page. Clicking on a todo item We want to simulate user interaction with the HTML page. It might be tempting to continue to use CSS selectors to identify the specific checkbox that we want to click, but there's a better way: there is a consensus among front-end developers that the best way to test interaction with a page is to use it the same way that users do. For instance, you don't look for a button through a CSS locator such as button.buy; instead, you look for something clickable with the label “Buy”. In practice, this means identifying parts of the page through their ARIA roles. To this end, we add code to our test to look for a checkbox labelled “One”: Go func Test_toggleTodoItem(t *testing.T) { // ... // click on the \"One\" checkbox checkbox := page.GetByRole(*playwright.AriaRoleCheckbox, playwright.PageGetByRoleOptions{Name: \"One\"}) if err := checkbox.Click(); err != nil { t.Fatal(err) } } Java @Test void toggleTodoItem() { // ... // click on the \"One\" checkbox var checkbox = page.getByRole(AriaRole.CHECKBOX, new Page.GetByRoleOptions().setName(\"One\")); checkbox.click(); } } We run the test, and it fails: Go \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html Loaded: http://localhost:4567/index.html --- FAIL: Test_toggleTodoItem (32.74s) index_behaviour_test.go:50: playwright: timeout: Timeout 30000ms exceeded. Java IndexBehaviourTest \u003e toggleTodoItem() STANDARD_OUT \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html Loaded: http://localhost:4567/index.html IndexBehaviourTest \u003e toggleTodoItem() FAILED com.microsoft.playwright.TimeoutError: Error { message='Timeout 30000ms exceeded. ... Playwright waited 30 seconds for the desired checkbox to appear. It turns out that our HTML code does not link the label to the checkbox properly: generated HTML with bad accessibility \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput class=\"toggle\" type=\"checkbox\"\u003e \u003clabel\u003eOne\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e We fix it by using the for attribute in the template, index.tmpl – Go \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-{{.Id}}\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-{{.Id}}\"\u003e{{.Title}}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e index.tmpl – Java \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-{{ id }}\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-{{ id }}\"\u003e{{ title }}\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e So that it generates proper, accessible HTML: generated HTML with better accessibility \u003cli\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-101\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-101\"\u003eOne\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e We run again the test, and it passes. In this section we saw how testing the HTML in the same was as users interact with it led us to use ARIA roles, which led to improving accessibility of our generated HTML. In the next section, we will see how to test that the click on a todo item triggers a remote call to the server, that should result in swapping a part of the current HTML with the HTML returned by the XHR call. Round-trip to the server Now we will extend our test. We tell the test that if call to POST /toggle/101 is received, it should return some stubbed HTML. Go } else if route.Request().URL() == \"http://localhost:4567/toggle/101\" \u0026\u0026 route.Request().Method() == \"POST\" { // we expect that a POST /toggle/101 request is made when we click on the \"One\" checkbox const stubbedHtml = ` \u003csection class=\"todoapp\"\u003e \u003cp\u003eStubbed html\u003c/p\u003e \u003c/section\u003e` stubResponse(route, stubbedHtml, \"text/html\") Java } else if (route.request().url().equals(\"http://localhost:4567/toggle/101\") \u0026\u0026 route.request().method().equals(\"POST\")) { // we expect that a POST /toggle/101 request is made when we click on the \"One\" checkbox String stubbedHtml = \"\"\" \u003csection class=\"todoapp\"\u003e \u003cp\u003eStubbed html\u003c/p\u003e \u003c/section\u003e \"\"\"; route.fulfill(new Route.FulfillOptions() .setContentType(\"text/html\") .setBody(stubbedHtml)); And we stub the loading of the HTMX library, which we load from a local file: Go } else if route.Request().URL() == \"https://unpkg.com/htmx.org@1.9.12\" { // serve the htmx library stubResponse(route, readFile(\"testdata/htmx.min.js\"), \"application/javascript\") Go } else if (route.request().url().equals(\"https://unpkg.com/htmx.org@1.9.12\")) { // serve the htmx library route.fulfill(new Route.FulfillOptions() .setContentType(\"text/html\") .setBody(readFile(\"/htmx.min.js\"))); Finally, we add the expectation that, after we click the checkbox, the section of the HTML that contains most of the application is reloaded. Go // click on the \"One\" checkbox checkbox := page.GetByRole(*playwright.AriaRoleCheckbox, playwright.PageGetByRoleOptions{Name: \"One\"}) if err := checkbox.Click(); err != nil { t.Fatal(err) } // check that the page has been updated document := parseHtml(t, content(t, page)) elements := document.Find(\"body \u003e section.todoapp \u003e p\") assert.Equal(t, \"Stubbed html\", elements.Text(), must(page.Content())) java // click on the \"One\" checkbox var checkbox = page.getByRole(AriaRole.CHECKBOX, new Page.GetByRoleOptions().setName(\"One\")); checkbox.click(); // check that the page has been updated var document = parseHtml(page.content()); var elements = document.select(\"body \u003e section.todoapp \u003e p\"); assertThat(elements.text()) .describedAs(page.content()) .isEqualTo(\"Stubbed html\"); We run the test, and it fails, as expected. In order to understand why exactly it fails, we add to the error message the whole HTML document. Go assert.Equal(t, \"Stubbed html\", elements.Text(), must(page.Content())) Java assertThat(elements.text()) .describedAs(page.content()) .isEqualTo(\"Stubbed html\"); The error message is very verbose, but we see that the reason it fails is that we don't see the stubbed HTML in the output. This means that the page did not make the expected XHR call. Go – Java is similar --- FAIL: Test_toggleTodoItem (2.75s) === RUN Test_toggleTodoItem \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html Loaded: http://localhost:4567/index.html index_behaviour_test.go:67: Error Trace: .../index_behaviour_test.go:67 Error: Not equal: expected: \"Stubbed html\" actual : \"\" ... Test: Test_toggleTodoItem Messages: \u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eTemplate • TodoMVC\u003c/title\u003e \u003cscript src=\"https://unpkg.com/htmx.org@1.9.12\"\u003e\u003c/script\u003e \u003cbody\u003e \u003csection class=\"todoapp\"\u003e ... \u003cli class=\"\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-101\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-101\"\u003eOne\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e ... We can make this test pass by changing the HTML template to use HTMX to make an XHR call back to the server. First we load the HTMX library: index.tmpl \u003ctitle\u003eTemplate • TodoMVC\u003c/title\u003e \u003cscript src=\"https://unpkg.com/htmx.org@1.9.12\"\u003e\u003c/script\u003e Then we add the HTMX attributes to the checkboxes: index.tmpl \u003cinput data-hx-post=\"/toggle/{{.Id}}\" data-hx-target=\"section.todoapp\" id=\"checkbox-{{.Id}}\" class=\"toggle\" type=\"checkbox\"\u003e The data-hx-post annotation will make HTMX do a POST call to the specified url. The data-hx-target tells HTMX to copy the HTML returned by the call, to the element specified by the section.todoapp CSS locator. We run again the test, and it still fails! Go – Java is similar --- FAIL: Test_toggleTodoItem (2.40s) === RUN Test_toggleTodoItem \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html \u003e\u003e GET https://unpkg.com/htmx.org@1.9.12 \u003c\u003c 200 https://unpkg.com/htmx.org@1.9.12 Loaded: http://localhost:4567/index.html \u003e\u003e POST http://localhost:4567/toggle/101 \u003c\u003c 200 http://localhost:4567/toggle/101 index_behaviour_test.go:67: Error Trace: .../index_behaviour_test.go:67 Error: Not equal: expected: \"Stubbed html\" actual : \"\" ... Test: Test_toggleTodoItem Messages: \u003c!DOCTYPE html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003eTemplate • TodoMVC\u003c/title\u003e \u003cscript src=\"https://unpkg.com/htmx.org@1.9.12\"\u003e\u003c/script\u003e ... \u003cbody\u003e \u003csection class=\"todoapp\"\u003e\u003csection class=\"todoapp\"\u003e \u003cp\u003eStubbed html\u003c/p\u003e \u003c/section\u003e\u003c/section\u003e ... \u003c/body\u003e\u003c/html\u003e The log lines show that the POST call happened as expected, but examination of the error message shows that the HTML structure we expected is not there: we have a section.todoapp nested inside another. This means that we are not using the HTMX annotations correctly, and shows why this kind of test can be valuable. We add the missing annotation index.tmpl \u003cinput data-hx-post=\"/toggle/{{.Id}}\" data-hx-target=\"section.todoapp\" data-hx-swap=\"outerHTML\" id=\"checkbox-{{.Id}}\" class=\"toggle\" type=\"checkbox\"\u003e The default behaviour of HTMX is to replace the inner HTML of the target element. The data-hx-swap=”outerHTML” annotation tells HTMX to replace the outer HTML instead. and we test again, and this time it passes! Go === RUN Test_toggleTodoItem \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html \u003e\u003e GET https://unpkg.com/htmx.org@1.9.12 \u003c\u003c 200 https://unpkg.com/htmx.org@1.9.12 Loaded: http://localhost:4567/index.html \u003e\u003e POST http://localhost:4567/toggle/101 \u003c\u003c 200 http://localhost:4567/toggle/101 --- PASS: Test_toggleTodoItem (1.39s) Java IndexBehaviourTest \u003e toggleTodoItem() STANDARD_OUT \u003e\u003e GET http://localhost:4567/index.html \u003c\u003c 200 http://localhost:4567/index.html \u003e\u003e GET https://unpkg.com/htmx.org@1.9.12 \u003c\u003c 200 https://unpkg.com/htmx.org@1.9.12 Loaded: http://localhost:4567/index.html \u003e\u003e POST http://localhost:4567/toggle/101 \u003c\u003c 200 http://localhost:4567/toggle/101 IndexBehaviourTest \u003e toggleTodoItem() PASSED In this section we saw how to write a test for the behaviour of our HTML that, while using the complicated machinery of a headless browser, still feels more like a unit test than an integration test. It is in fact testing just an HTML page with any associated CSS and JavaScript, in isolation from other parts of the application such as controllers, services or repositories. The test costs 2-3 seconds of waiting time for the headless browser to come up, which is usually too much for a unit test; however, like a unit test, it is very stable, as it is not flaky, and its failures are documented with a relatively clear error message. See the final version of the test in Go and in Java. Bonus level: Stringly asserted Esko Luontola, TDD expert and author of the online course tdd.mooc.fi, suggested an alternative to testing HTML with CSS selectors: the idea is to transform HTML into a human-readable canonical form. Let's take for example this snippet of generated HTML: \u003cul class=\"todo-list\"\u003e \u003cli class=\"\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-100\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-100\"\u003eOne\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-200\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-200\"\u003eTwo\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e \u003cli class=\"completed\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput id=\"checkbox-300\" class=\"toggle\" type=\"checkbox\"\u003e \u003clabel for=\"checkbox-300\"\u003eThree\u003c/label\u003e \u003cbutton class=\"destroy\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e \u003c/ul\u003e We could visualize the above HTML by: deleting all HTML tags reducing every sequence of whitespace characters to a single blank to arrive at: One Two Three This, however, removes too much of the HTML structure to be useful. For instance, it does not let us distinguish between active and completed items. Some HTML element represent visible content: for instance \u003cinput value=\"foo\" /\u003e shows a text box with the word “foo” that is an important part of the way we perceive HTML. To visualize those elements, Esko suggests to add a data-test-icon attribute that supplies some text to be used in place of the element when visualizing it for testing. With this, \u003cinput value=\"foo\" data-test-icon=\"[foo]\" /\u003e the input element is visualized as [foo], with the square brackets hinting that the word “foo” sits inside an editable text box. Now if we add test-icons to our HTML template, Go -- Java is similar \u003cul class=\"todo-list\"\u003e {{ range .model.AllItems }} \u003cli class=\"{{ if .IsCompleted }}completed{{ end }}\"\u003e \u003cdiv class=\"view\"\u003e \u003cinput data-hx-post=\"/toggle/{{ .Id }}\" data-hx-target=\"section.todoapp\" data-hx-swap=\"outerHTML\" id=\"checkbox-{{ .Id }}\" class=\"toggle\" type=\"checkbox\" data-test-icon=\"{{ if .IsCompleted }}✅{{ else }}⬜{{ end }}\"\u003e \u003clabel for=\"checkbox-{{ .Id }}\"\u003e{{ .Title }}\u003c/label\u003e \u003cbutton class=\"destroy\" data-test-icon=\"❌️\"\u003e\u003c/button\u003e \u003c/div\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e we can assert against its canonical visual representation like this: Go func Test_visualize_html_example(t *testing.T) { model := todo.NewList(). Add(\"One\"). Add(\"Two\"). AddCompleted(\"Three\") buf := renderTemplate(\"todo-list.tmpl\", model, \"/\") expected := ` ⬜ One ❌️ ⬜ Two ❌️ ✅ Three ❌️ ` assert.Equal(t, normalizeWhitespace(expected), visualizeHtml(buf.String())) } Java @Test void visualize_html_example() { var model = new TodoList() .add(\"One\") .add(\"Two\") .addCompleted(\"Three\"); var html = renderTemplate(\"/todo-list.tmpl\", model, \"/\"); assertThat(visualizeHtml(html)) .isEqualTo(normalizeWhitespace(\"\"\" ⬜ One ❌️ ⬜ Two ❌️ ✅ Three ❌️ \"\"\")); } Here is Esko Luontola's Java implementation of the two functions that make this possible, and my translation to Go of his code. Go func visualizeHtml(html string) string { // custom visualization using data-test-icon attribute html = replaceAll(html, \"\u003c[^\u003c\u003e]+\\\\bdata-test-icon=\\\"(.*?)\\\".*?\u003e\", \" $1 \") // strip all HTML tags: inline elements html = replaceAll(html, \"\u003c/?(a|abbr|b|big|cite|code|em|i|small|span|strong|tt)\\\\b.*?\u003e\", \"\") // strip all HTML tags: block elements html = replaceAll(html, \"\u003c[^\u003e]*\u003e\", \" \") // replace HTML character entities html = replaceAll(html, \"\u0026nbsp;\", \" \") html = replaceAll(html, \"\u0026lt;\", \"\u003c\") html = replaceAll(html, \"\u0026gt;\", \"\u003e\") html = replaceAll(html, \"\u0026quot;\", \"\\\"\") html = replaceAll(html, \"\u0026apos;\", \"'\") html = replaceAll(html, \"\u0026amp;\", \"\u0026\") return normalizeWhitespace(html) } func normalizeWhitespace(s string) string { return strings.TrimSpace(replaceAll(s, \"\\\\s+\", \" \")) } func replaceAll(src, regex, repl string) string { re := regexp.MustCompile(regex) return re.ReplaceAllString(src, repl) } source Java public static String visualizeHtml(String html) { // custom visualization using data-test-icon attribute html = html.replaceAll(\"\u003c[^\u003c\u003e]+\\\\bdata-test-icon=\\\"(.*?)\\\".*?\u003e\", \" $1 \"); // strip all HTML tags html = html.replaceAll(\"\u003c/?(a|abbr|b|big|cite|code|em|i|small|span|strong|tt)\\\\b.*?\u003e\", \"\") // inline elements .replaceAll(\"\u003c[^\u003e]*\u003e\", \" \"); // block elements // replace HTML character entities html = html.replaceAll(\"\u0026nbsp;\", \" \") .replaceAll(\"\u0026lt;\", \"\u003c\") // must be after stripping HTML tags, to avoid creating accidental elements .replaceAll(\"\u0026gt;\", \"\u003e\") .replaceAll(\"\u0026quot;\", \"\\\"\") .replaceAll(\"\u0026apos;\", \"'\") .replaceAll(\"\u0026amp;\", \"\u0026\"); // must be last, to avoid creating accidental character entities return normalizeWhitespace(html); } public static String normalizeWhitespace(String s) { return s.replaceAll(\"\\\\s+\", \" \").trim(); } source In this section, we have seen a technique for asserting HTML content that is an alternative to the CSS selector-based technique used in the rest of the article. Esko Luontola has reported great success with it, and I hope readers have success with it too! This technique of asserting against large, complicated data structures such as HTML pages by reducing them to a canonical string version has no name that I know of. Martin Fowler suggested “stringly asserted”, and from his suggestion comes the name of this section. Conclusion Modern web applications often have very complicated templates. In my experience, when we start testing these templates, we inevitably find errors: the templates do not always produce the HTML we think. And often, time is lost debugging the templates, when we could write automated tests that do the testing for us instead. What should we test then? When we have an IF in a template, we should test the rendering of the two cases: when the IF condition happens to be true, and when it happens to be false When we have an iteration over a list of items in a template, we should test the rendering when the list is empty, and when it is non-empty When a part of the model we pass to the template might be nil (in Go) or null (in Java), we should test the rendering with both a nil/null value and with a non-nil/null value In all the above cases, we should test that the output of our templates is sound HTML, and that the essential structure of the generated HTML corresponds to what we think it should be If our HTML page has non-obvious behaviour implemented in JavaScript or CSS, we might want to test it using a headless browser. The techniques presented in the last section might make these tests cheaper. This practice will not prevent all errors, but will prevent many errors that could result in our users seeing web pages that are broken or incorrect. In conclusion, I think that automated testing of HTML templates makes our work with web applications easier and safer. I hope we now see that it's easy (and fun!) to test them.",
  "image": "https://martinfowler.com/articles/tdd-html-templates/card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eAfter a decade or more where Single-Page-Applications generated by\n    JavaScript frameworks \u003ca href=\"https://www.thoughtworks.com/radar/techniques/spa-by-default\"\u003ehave\n    become the norm\u003c/a\u003e, we see that server-side rendered HTML is becoming\n    popular again, also thanks to libraries such as \u003ca href=\"https://htmx.org/\"\u003eHTMX\u003c/a\u003e or \u003ca href=\"https://turbo.hotwired.dev/\"\u003eTurbo\u003c/a\u003e. Writing a rich web UI in a\n    traditionally server-side language like Go or Java is now not just possible,\n    but a very attractive proposition.\u003c/p\u003e\n\n\u003cp\u003eWe then face the problem of how to write automated tests for the HTML\n    parts of our web applications. While the JavaScript world has evolved \u003ca href=\"https://github.com/jsdom/jsdom\"\u003epowerful\u003c/a\u003e and \u003ca href=\"https://testing-library.com/\"\u003esophisticated\u003c/a\u003e ways to test the UI,\n    ranging in size from unit-level to integration to end-to-end, in other\n    languages we do not have such a richness of tools available.\u003c/p\u003e\n\n\u003cp\u003eWhen writing a web application in Go or Java, HTML is commonly generated\n    through templates, which contain small fragments of logic. It is certainly\n    possible to test them indirectly through end-to-end tests, but those tests\n    are slow and expensive.\u003c/p\u003e\n\n\u003cp\u003eWe can instead write unit tests that use CSS selectors to probe the\n    presence and correct content of specific HTML elements within a document.\n    Parameterizing these tests makes it easy to add new tests and to clearly\n    indicate what details each test is verifying. This approach works with any\n    language that has access to an HTML parsing library that supports CSS\n    selectors; examples are provided in Go and Java.\u003c/p\u003e\n\n\u003csection id=\"Motivation\"\u003e\n\u003ch2\u003eMotivation\u003c/h2\u003e\n\n\u003cp\u003eWhy test-drive HTML templates? After all, the most reliable way to check\n      that a template works is to render it to HTML and open it in a browser,\n      right?\u003c/p\u003e\n\n\u003cp\u003eThere\u0026#39;s some truth in this; unit tests cannot prove that a template\n        works as expected when rendered in a browser, so checking them manually\n        is necessary. And if we make a\n      mistake in the logic of a template, \u003cb\u003eusually\u003c/b\u003e the template breaks\n      in an obvious way, so the error is quickly spotted.\u003c/p\u003e\n\n\u003cp\u003eOn the other hand:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eRelying on manual tests only is risky; what if we make a change that breaks\n        a template, and we don\u0026#39;t test it because we did not think it would impact the\n        template? We could get an error in production! \u003c/li\u003e\n\n\u003cli\u003eTemplates often contain logic, such as if-then-else\u0026#39;s or iterations over arrays of items,\n          and when the array is empty, we often need to show something different.\n          Manual checking all cases, for all of these bits of logic, becomes unsustainable very quickly\u003c/li\u003e\n\n\u003cli\u003eThere are errors that are not visible in the browser. Browsers are extremely\n        tolerant of inconsistencies in HTML, relying on heuristics to fix our broken\n        HTML, but then we might get different results in different browsers, on different devices. It\u0026#39;s good\n        to check that the HTML structures we are building in our templates correspond to\n        what we think.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIt turns out that test-driving HTML templates is easy; let\u0026#39;s see how to\n      do it in Go and Java. I will be using as a starting point the \u003ca href=\"https://github.com/tastejs/todomvc-app-template\" title=\"GitHub -       tastejs/todomvc-app-template: Template used for creating TodoMVC apps\"\u003eTodoMVC\n      template\u003c/a\u003e, which is a sample application used to showcase JavaScript\n      frameworks.\u003c/p\u003e\n\n\u003cp\u003eWe will see techniques that can be applied to any programming language and templating technology, as long as we have\n        access to a suitable HTML parser.\u003c/p\u003e\n\n\u003cdiv id=\"test.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/tdd-html-templates/test.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis article is a bit long; you may want to take a look at the\n        \u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/tree/main/go\"\u003efinal solution in Go\u003c/a\u003e or\n      \u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/tree/main/java\"\u003ein Java\u003c/a\u003e,\n        or \u003ca href=\"#Conclusion\"\u003ejump to the conclusions\u003c/a\u003e.\n      \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Level1CheckingForSoundHtml\"\u003e\n\u003ch2\u003eLevel 1: checking for sound HTML\u003c/h2\u003e\n\n\u003cp\u003eThe number one thing we want to check is that the HTML we produce is\n      basically sound. I don\u0026#39;t mean to check that HTML is valid according to the\n      W3C; it would be cool to do it, but it\u0026#39;s better to start with much simpler and faster checks.\n      For instance, we want our tests to\n      break if the template generates something like\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;div\u0026gt;foo\u0026lt;/p\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eLet\u0026#39;s see how to do it in stages: we start with the following test that\n      tries to compile the template. In Go we use the standard \u003ccode\u003ehtml/template\u003c/code\u003e package.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_wellFormedHtml(t *testing.T) {\n    templ := template.Must(template.ParseFiles(\u0026#34;index.tmpl\u0026#34;))\n    _ = templ\n  }\u003c/pre\u003e\n\n\u003cp\u003eIn Java, we use \u003ca href=\"https://github.com/samskivert/jmustache?tab=readme-ov-file\"\u003ejmustache\u003c/a\u003e\n      because it\u0026#39;s very simple to use; \u003ca href=\"https://freemarker.apache.org/\"\u003eFreemarker\u003c/a\u003e or\n      \u003ca href=\"https://velocity.apache.org/\"\u003eVelocity\u003c/a\u003e are other common choices.\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void indexIsSoundHtml() {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(\u0026#34;/index.tmpl\u0026#34;)));\n  }\u003c/pre\u003e\n\n\u003cp\u003eIf we run this test, it will fail, because the \u003ccode\u003eindex.tmpl\u003c/code\u003e file does\n      not exist. So we create it, with the above broken HTML. Now the test should pass.\u003c/p\u003e\n\n\u003cp\u003eThen we create a \u003ci\u003emodel\u003c/i\u003e for the template to use. The application manages a todo-list, and\n      we can create a minimal model for demonstration purposes.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_wellFormedHtml(t *testing.T) {\n    templ := template.Must(template.ParseFiles(\u0026#34;index.tmpl\u0026#34;))\n\u003cspan\u003e    model := todo.NewList()\u003c/span\u003e\n    _ = templ\n    _ = model\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void indexIsSoundHtml() {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(\u0026#34;/index.tmpl\u0026#34;)));\n\u003cspan\u003e      var model = new TodoList();\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003eNow we render the template, saving the results in a bytes buffer (Go) or as a \u003ccode\u003eString\u003c/code\u003e (Java).\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_wellFormedHtml(t *testing.T) {\n    templ := template.Must(template.ParseFiles(\u0026#34;index.tmpl\u0026#34;))\n    model := todo.NewList()\n    var buf bytes.Buffer\n\u003cspan\u003e    err := templ.Execute(\u0026amp;buf, model)\u003c/span\u003e\n    if err != nil {\n      panic(err)\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void indexIsSoundHtml() {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(\u0026#34;/index.tmpl\u0026#34;)));\n      var model = new TodoList();\n  \n\u003cspan\u003e      var html = template.execute(model);\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003eAt this point, we want to \u003ci\u003eparse\u003c/i\u003e the HTML and we expect to see an\n      error, because in our broken HTML there is a \u003ccode\u003ediv\u003c/code\u003e element that\n      is closed by a \u003ccode\u003ep\u003c/code\u003e element. There is an HTML parser in the Go\n      standard library, but it is too lenient: if we run it on our broken HTML, we don\u0026#39;t get an\n      error. Luckily, the Go standard library also has an XML parser that can be\n      configured to parse HTML (thanks to \u003ca href=\"https://stackoverflow.com/a/52410528/164802\" title=\"HTML Validation with       Golang - Stack Overflow\"\u003ethis Stack Overflow answer\u003c/a\u003e)\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_wellFormedHtml(t *testing.T) {\n    templ := template.Must(template.ParseFiles(\u0026#34;index.tmpl\u0026#34;))\n    model := todo.NewList()\n    \n    // render the template into a buffer\n    var buf bytes.Buffer\n    err := templ.Execute(\u0026amp;buf, model)\n    if err != nil {\n      panic(err)\n    }\n  \n    // check that the template can be parsed as (lenient) XML\n\u003cspan\u003e    decoder := xml.NewDecoder(bytes.NewReader(buf.Bytes()))\n    decoder.Strict = false\n    decoder.AutoClose = xml.HTMLAutoClose\n    decoder.Entity = xml.HTMLEntity\n    for {\n      _, err := decoder.Token()\n      switch err {\n      case io.EOF:\n        return // We\u0026#39;re done, it\u0026#39;s valid!\n      case nil:\n        // do nothing\n      default:\n        t.Fatalf(\u0026#34;Error parsing html: %s\u0026#34;, err)\n      }\u003c/span\u003e\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/d086bd52079958c3264dd2d595baead1695e1efb/go/index_template_test.go#L12\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThis code configures the HTML parser to have the right level of leniency\n      for HTML, and then parses the HTML token by token. Indeed, we see the error\n      message we wanted:\u003c/p\u003e\n\n\u003cpre\u003e--- FAIL: Test_wellFormedHtml (0.00s)\n    index_template_test.go:61: Error parsing html: XML syntax error on line 4: unexpected end element \u0026lt;/p\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eIn Java, a versatile library to use is \u003ca href=\"https://jsoup.org/\"\u003ejsoup\u003c/a\u003e:\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void indexIsSoundHtml() {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(\u0026#34;/index.tmpl\u0026#34;)));\n      var model = new TodoList();\n  \n      var html = template.execute(model);\n  \n\u003cspan\u003e      var parser = Parser.htmlParser().setTrackErrors(10);\n      Jsoup.parse(html, \u0026#34;\u0026#34;, parser);\n      assertThat(parser.getErrors()).isEmpty();\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/333447d1c91b615e58cf948ac0e030e48b0ad704/java/src/test/java/org/example/IndexTemplateTest.java#L17\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd we see it fail:\u003c/p\u003e\n\n\u003cpre\u003ejava.lang.AssertionError: \nExpecting empty but was:\u0026lt;[\u0026lt;1:13\u0026gt;: Unexpected EndTag token [\u0026lt;/p\u0026gt;] when in state [InBody],\n\u003c/pre\u003e\n\n\u003cp\u003eSuccess! Now if we copy over \u003ca href=\"https://github.com/tastejs/todomvc-app-template/blob/dbccc73a9584ed693d206dc0fb8cceabb81aaab8/index.html\" title=\"Template • TodoMVC\"\u003ethe contents of the TodoMVC\n      template\u003c/a\u003e to our \u003ccode\u003eindex.tmpl\u003c/code\u003e file, the test passes.\u003c/p\u003e\n\n\u003cp\u003eThe test, however, is too verbose: we extract two helper functions, in\n      order to make the intention of the test clearer, and we get\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_wellFormedHtml(t *testing.T) {\n    model := todo.NewList()\n  \n    buf := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model)\n  \n    assertWellFormedHtml(t, buf)\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/fea085413f3dbd2375f9f36107cc741960eb0499/go/index_template_test.go#L12\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void indexIsSoundHtml() {\n      var model = new TodoList();\n  \n      var html = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model);\n  \n      assertSoundHtml(html);\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/fea085413f3dbd2375f9f36107cc741960eb0499/java/src/test/java/org/example/IndexTemplateTest.java#L16\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Level2TestingHtmlStructure\"\u003e\n\u003ch2\u003eLevel 2: testing HTML structure\u003c/h2\u003e\n\n\u003csection id=\"WhatElseShouldWeTest\"\u003e\n\u003ch3\u003eWhat else should we test?\u003c/h3\u003e\n\n\u003cp\u003eWe know that the looks of a page can only be tested, ultimately, by a\n      human looking at how it is rendered in a browser. However, there is often\n      logic in templates, and we want to be able to test that logic.\u003c/p\u003e\n\n\u003cp\u003eOne might be tempted to test the rendered HTML with string equality,\n      but this technique fails in practice, because templates contain a lot of\n      details that make string equality assertions impractical. The assertions\n      become very verbose, and when reading the assertion, it becomes difficult\n      to understand what it is that we\u0026#39;re trying to prove.\u003c/p\u003e\n\n\u003cp\u003eWhat we need\n      is a technique to assert that \u003ci\u003esome parts\u003c/i\u003e of the rendered HTML\n      correspond to what we expect, and to \u003ci\u003eignore all the details we don\u0026#39;t\n      care about.\u003c/i\u003e One way to do this is by running queries with the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_selectors\" title=\"CSS selectors - CSS: Cascading Style Sheets | MDN\"\u003eCSS selector language\u003c/a\u003e:\n      it is a powerful language that allows us to select the\n      elements that we care about from the whole HTML document. Once we have\n      selected those elements, we (1) count that the number of element returned\n      is what we expect, and (2) that they contain the text or other content\n      that we expect.\u003c/p\u003e\n\n\u003cp\u003eThe UI that we are supposed to generate looks like this:\u003c/p\u003e\n\n\u003cdiv id=\"todos.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/tdd-html-templates/todos.png\" width=\"571\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThere are several details that are rendered dynamically:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eThe number of items and their text content change, obviously\u003c/li\u003e\n\n\u003cli\u003eThe style of the todo-item changes when it\u0026#39;s completed (e.g., the\n        second)\u003c/li\u003e\n\n\u003cli\u003eThe “2 items left” text will change with the number of non-completed\n        items\u003c/li\u003e\n\n\u003cli\u003eOne of the three buttons “All”, “Active”, “Completed” will be\n        highlighted, depending on the current url; for instance if we decide that the\n        url that shows only the “Active” items is \u003ccode\u003e/active\u003c/code\u003e, then when the current url\n        is \u003ccode\u003e/active\u003c/code\u003e, the “Active” button should be surrounded by a thin red\n        rectangle\u003c/li\u003e\n\n\u003cli\u003eThe “Clear completed” button should only be visible if any item is\n        completed \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eEach of this concerns can be tested with the help of CSS selectors.\u003c/p\u003e\n\n\u003cp id=\"index.tmpl\"\u003eThis is a snippet from the TodoMVC template (slightly simplified). I\n      have not yet added the dynamic bits, so what we see here is static\n      content, provided as an example:\u003c/p\u003e\n\n\u003cp\u003eindex.tmpl\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\n    \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n      \u0026lt;!-- These are here just to show the structure of the list items --\u0026gt;\n      \u0026lt;!-- List items should get the class `completed` when marked as completed --\u0026gt;\n      \u0026lt;li \u003cspan\u003eclass=\u0026#34;completed\u0026#34;\u003c/span\u003e\u0026gt;  \u003cspan\u003e②\u003c/span\u003e\n        \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n          \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34; checked\u0026gt;\n\u003cspan\u003e          \u0026lt;label\u0026gt;Taste JavaScript\u0026lt;/label\u0026gt; \u003cspan\u003e①\u003c/span\u003e\u003c/span\u003e\n          \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n        \u0026lt;/div\u0026gt;\n      \u0026lt;/li\u0026gt;\n      \u0026lt;li\u0026gt;\n        \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n          \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n\u003cspan\u003e          \u0026lt;label\u0026gt;Buy a unicorn\u0026lt;/label\u0026gt; \u003cspan\u003e①\u003c/span\u003e\u003c/span\u003e\n          \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n        \u0026lt;/div\u0026gt;\n      \u0026lt;/li\u0026gt;\n    \u0026lt;/ul\u0026gt;\n    \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt;\n      \u0026lt;!-- This should be `0 items left` by default --\u0026gt;\n      \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt;\u0026lt;\u003cspan\u003estrong\u0026gt;0\u0026lt;/strong\u0026gt; item left\u003c/span\u003e\u0026lt;/span\u0026gt; \u003cspan\u003e⓷\u003c/span\u003e\n      \u0026lt;ul class=\u0026#34;filters\u0026#34;\u0026gt;\n        \u0026lt;li\u0026gt;\n          \u0026lt;a \u003cspan\u003eclass=\u0026#34;selected\u0026#34;\u003c/span\u003e href=\u0026#34;#/\u0026#34;\u0026gt;All\u0026lt;/a\u0026gt; \u003cspan\u003e④\u003c/span\u003e\n        \u0026lt;/li\u0026gt;\n        \u0026lt;li\u0026gt;\n          \u0026lt;a href=\u0026#34;#/active\u0026#34;\u0026gt;Active\u0026lt;/a\u0026gt;\n        \u0026lt;/li\u0026gt;\n        \u0026lt;li\u0026gt;\n          \u0026lt;a href=\u0026#34;#/completed\u0026#34;\u0026gt;Completed\u0026lt;/a\u0026gt;\n        \u0026lt;/li\u0026gt;\n      \u0026lt;/ul\u0026gt;\n      \u0026lt;!-- Hidden if no completed items are left ↓ --\u0026gt;\n\u003cspan\u003e      \u0026lt;button class=\u0026#34;clear-completed\u0026#34;\u0026gt;Clear completed\u0026lt;/button\u0026gt; \u003cspan\u003e⑤\u003c/span\u003e\u003c/span\u003e\n    \u0026lt;/footer\u0026gt;\n  \u0026lt;/section\u0026gt;  \u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/fea085413f3dbd2375f9f36107cc741960eb0499/go/original-template.html#L19\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eBy looking at the static version of the template, we can deduce which\n      CSS selectors can be used to identify the relevant elements for the 5 dynamic\n      features listed above:\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003efeature\u003c/th\u003e\u003cth\u003eCSS selector\u003c/th\u003e\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\u003ctd\u003e①\u003c/td\u003e\u003ctd\u003eAll the items\u003c/td\u003e\u003ctd\u003eul.todo-list li\u003c/td\u003e\u003c/tr\u003e\n\n\u003ctr\u003e\u003ctd\u003e②\u003c/td\u003e\u003ctd\u003eCompleted items\u003c/td\u003e\u003ctd\u003eul.todo-list li.completed\u003c/td\u003e\u003c/tr\u003e\n\n\u003ctr\u003e\u003ctd\u003e⓷\u003c/td\u003e\u003ctd\u003eItems left\u003c/td\u003e\u003ctd\u003espan.todo-count\u003c/td\u003e\u003c/tr\u003e\n\n\u003ctr\u003e\u003ctd\u003e④\u003c/td\u003e\u003ctd\u003eHighlighted navigation link\u003c/td\u003e\u003ctd\u003eul.filters a.selected\u003c/td\u003e\u003c/tr\u003e\n\n\u003ctr\u003e\u003ctd\u003e⑤\u003c/td\u003e\u003ctd\u003eClear completed button\u003c/td\u003e\u003ctd\u003ebutton.clear-completed\u003c/td\u003e\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eWe can use these selectors to focus our tests on just the things we want to test.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"TestingHtmlContent\"\u003e\n\u003ch3\u003eTesting HTML content\u003c/h3\u003e\n\n\u003cp\u003eThe first test will look for \u003cb\u003eall the items\u003c/b\u003e, and prove that the data\n      set up by the test is rendered correctly.\u003c/p\u003e\n\n\u003cpre\u003efunc Test_todoItemsAreShown(t *testing.T) {\n  model := todo.NewList()\n  model.Add(\u0026#34;Foo\u0026#34;)\n  model.Add(\u0026#34;Bar\u0026#34;)\n\n  buf := renderTemplate(model)\n\n  // assert there are two \u0026lt;li\u0026gt; elements inside the \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt; \n  // assert the first \u0026lt;li\u0026gt; text is \u0026#34;Foo\u0026#34;\n  // assert the second \u0026lt;li\u0026gt; text is \u0026#34;Bar\u0026#34;\n}\n\u003c/pre\u003e\n\n\u003cp\u003eWe need a way to query the HTML document with our CSS selector; a good\n      library for Go is \u003ca href=\"https://github.com/PuerkitoBio/goquery\" title=\"GitHub - PuerkitoBio/goquery: A little like that j-thing, only in       Go.\"\u003egoquery\u003c/a\u003e, that implements an API inspired by jQuery.\n      In Java, we keep using the same library we used to test for sound HTML, namely\n      \u003ca href=\"https://jsoup.org/\"\u003ejsoup\u003c/a\u003e. Our test becomes:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_todoItemsAreShown(t *testing.T) {\n    model := todo.NewList()\n    model.Add(\u0026#34;Foo\u0026#34;)\n    model.Add(\u0026#34;Bar\u0026#34;)\n  \n    buf := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model)\n  \n    // parse the HTML with goquery\n\u003cspan\u003e    document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes()))\u003c/span\u003e\n    if err != nil {\n      // if parsing fails, we stop the test here with t.FatalF\n      t.Fatalf(\u0026#34;Error rendering template %s\u0026#34;, err)\n    }\n  \n    // assert there are two \u0026lt;li\u0026gt; elements inside the \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n\u003cspan\u003e    selection := document.Find(\u0026#34;ul.todo-list li\u0026#34;)\u003c/span\u003e\n    assert.Equal(t, 2, selection.Length())\n  \n    // assert the first \u0026lt;li\u0026gt; text is \u0026#34;Foo\u0026#34;\n\u003cspan\u003e    assert.Equal(t, \u0026#34;Foo\u0026#34;, text(selection.Nodes[0]))\u003c/span\u003e\n  \n    // assert the second \u0026lt;li\u0026gt; text is \u0026#34;Bar\u0026#34;\n\u003cspan\u003e    assert.Equal(t, \u0026#34;Bar\u0026#34;, text(selection.Nodes[1]))\u003c/span\u003e\n  }\n  \n  func text(node *html.Node) string {\n    // A little mess due to the fact that goquery has\n    // a .Text() method on Selection but not on html.Node\n    sel := goquery.Selection{Nodes: []*html.Node{node}}\n    return strings.TrimSpace(sel.Text())\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/f447f8720f72c5159e7fd519885ae27b9c246483/go/index_template_test.go#L24\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void todoItemsAreShown() throws IOException {\n      var model = new TodoList();\n      model.add(\u0026#34;Foo\u0026#34;);\n      model.add(\u0026#34;Bar\u0026#34;);\n  \n      var html = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model);\n  \n      // parse the HTML with jsoup\n\u003cspan\u003e      Document document = Jsoup.parse(html, \u0026#34;\u0026#34;);\u003c/span\u003e\n  \n      // assert there are two \u0026lt;li\u0026gt; elements inside the \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n\u003cspan\u003e      var selection = document.select(\u0026#34;ul.todo-list li\u0026#34;);\u003c/span\u003e\n      assertThat(selection).hasSize(2);\n  \n      // assert the first \u0026lt;li\u0026gt; text is \u0026#34;Foo\u0026#34;\n\u003cspan\u003e      assertThat(selection.get(0).text()).isEqualTo(\u0026#34;Foo\u0026#34;);\u003c/span\u003e\n  \n      // assert the second \u0026lt;li\u0026gt; text is \u0026#34;Bar\u0026#34;\n\u003cspan\u003e      assertThat(selection.get(1).text()).isEqualTo(\u0026#34;Bar\u0026#34;);\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/f447f8720f72c5159e7fd519885ae27b9c246483/java/src/test/java/org/example/IndexTemplateTest.java#L27\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIf we still haven\u0026#39;t changed the template to populate the list from the\n      model, this test will fail, because the static template\n      todo items have different text:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  --- FAIL: Test_todoItemsAreShown (0.00s)\n      index_template_test.go:44: First list item: want Foo, got Taste JavaScript\n      index_template_test.go:49: Second list item: want Bar, got Buy a unicorn\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  IndexTemplateTest \u0026gt; todoItemsAreShown() FAILED\n      org.opentest4j.AssertionFailedError:\n      Expecting:\n       \u0026lt;\u0026#34;Taste JavaScript\u0026#34;\u0026gt;\n      to be equal to:\n       \u0026lt;\u0026#34;Foo\u0026#34;\u0026gt;\n      but was not.\u003c/pre\u003e\n\n\u003cp\u003eWe fix it by making the template use the model data:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n\u003cspan\u003e    {{ range .Items }}\u003c/span\u003e\n      \u0026lt;li\u0026gt;\n        \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n          \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n\u003cspan\u003e          \u0026lt;label\u0026gt;{{ .Title }}\u0026lt;/label\u0026gt;\u003c/span\u003e\n          \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n        \u0026lt;/div\u0026gt;\n      \u0026lt;/li\u0026gt;\n\u003cspan\u003e    {{ end }}\u003c/span\u003e\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/f447f8720f72c5159e7fd519885ae27b9c246483/go/index.tmpl#L25\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava - jmustache\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n\u003cspan\u003e    {{ #allItems }}\u003c/span\u003e\n    \u0026lt;li\u0026gt;\n      \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n        \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n\u003cspan\u003e        \u0026lt;label\u0026gt;{{ title }}\u0026lt;/label\u0026gt;\u003c/span\u003e\n        \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n      \u0026lt;/div\u0026gt;\n    \u0026lt;/li\u0026gt;\n\u003cspan\u003e    {{ /allItems }}\u003c/span\u003e\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/f447f8720f72c5159e7fd519885ae27b9c246483/java/src/main/resources/index.tmpl#L25\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"TestBothContentAndSoundnessAtTheSameTime\"\u003e\n\u003ch3\u003eTest both content and soundness at the same time\u003c/h3\u003e\n\n\u003cp\u003eOur test works, but it is a bit verbose, especially the Go version. If we\u0026#39;re going to have more\n      tests, they will become repetitive and difficult to read, so we make it more concise by extracting a helper function for parsing the html. We also remove the\n      comments, as the code should be clear enough\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_todoItemsAreShown(t *testing.T) {\n    model := todo.NewList()\n    model.Add(\u0026#34;Foo\u0026#34;)\n    model.Add(\u0026#34;Bar\u0026#34;)\n  \n    buf := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model)\n  \n\u003cspan\u003e    document := parseHtml(t, buf)\u003c/span\u003e\n    selection := document.Find(\u0026#34;ul.todo-list li\u0026#34;)\n    assert.Equal(t, 2, selection.Length())\n    assert.Equal(t, \u0026#34;Foo\u0026#34;, text(selection.Nodes[0]))\n    assert.Equal(t, \u0026#34;Bar\u0026#34;, text(selection.Nodes[1]))\n  }\n  \n\u003cspan\u003e  func parseHtml(t *testing.T, buf bytes.Buffer) *goquery.Document {\u003c/span\u003e\n\u003cspan\u003e    document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes()))\u003c/span\u003e\n    if err != nil {\n      // if parsing fails, we stop the test here with t.FatalF\n      t.Fatalf(\u0026#34;Error rendering template %s\u0026#34;, err)\n    }\n\u003cspan\u003e    return document\n  }\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void todoItemsAreShown() throws IOException {\n      var model = new TodoList();\n      model.add(\u0026#34;Foo\u0026#34;);\n      model.add(\u0026#34;Bar\u0026#34;);\n  \n      var html = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model);\n  \n\u003cspan\u003e      var document = parseHtml(html);\u003c/span\u003e\n      var selection = document.select(\u0026#34;ul.todo-list li\u0026#34;);\n      assertThat(selection).hasSize(2);\n      assertThat(selection.get(0).text()).isEqualTo(\u0026#34;Foo\u0026#34;);\n      assertThat(selection.get(1).text()).isEqualTo(\u0026#34;Bar\u0026#34;);\n  }\n  \n\u003cspan\u003e  private static Document parseHtml(String html) {\u003c/span\u003e\n\u003cspan\u003e      return Jsoup.parse(html, \u0026#34;\u0026#34;);\n  }\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\n        Much better! At least in my opinion. Now that we extracted the \u003ccode\u003eparseHtml\u003c/code\u003e helper, it\u0026#39;s\n        a good idea to check for sound HTML in the helper:\n      \u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func parseHtml(t *testing.T, buf bytes.Buffer) *goquery.Document {\n\u003cspan\u003e    assertWellFormedHtml(t, buf)\u003c/span\u003e\n    document, err := goquery.NewDocumentFromReader(bytes.NewReader(buf.Bytes()))\n    if err != nil {\n      // if parsing fails, we stop the test here with t.FatalF\n      t.Fatalf(\u0026#34;Error rendering template %s\u0026#34;, err)\n    }\n    return document\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e113a1e60305c9671563bc47d42fa00345c714da/go/index_template_test.go#L51\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  private static Document parseHtml(String html) {\n\u003cspan\u003e      var parser = Parser.htmlParser().setTrackErrors(10);\u003c/span\u003e\n      var document = Jsoup.parse(html, \u0026#34;\u0026#34;, \u003cspan\u003eparser\u003c/span\u003e);\n\u003cspan\u003e      assertThat(parser.getErrors()).isEmpty();\u003c/span\u003e\n      return document;\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e113a1e60305c9671563bc47d42fa00345c714da/java/src/test/java/org/example/IndexTemplateTest.java#L43\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd with this, we can get rid of the first test that we wrote, as we are now testing for sound HTML all the time.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"TheSecondTest\"\u003e\n\u003ch3\u003eThe second test\u003c/h3\u003e\n\n\u003cp\u003eNow we are in a good position for testing more rendering logic. The\n      second dynamic feature in our list is “List items should get the class\n      \u003ccode\u003ecompleted\u003c/code\u003e when marked as completed”. We can write a test for this:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_completedItemsGetCompletedClass(t *testing.T) {\n    model := todo.NewList()\n    model.Add(\u0026#34;Foo\u0026#34;)\n\u003cspan\u003e    model.AddCompleted(\u0026#34;Bar\u0026#34;)\u003c/span\u003e\n  \n    buf := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model)\n  \n    document := parseHtml(t, buf)\n\u003cspan\u003e    selection := document.Find(\u0026#34;ul.todo-list li.completed\u0026#34;)\u003c/span\u003e\n    assert.Equal(t, 1, selection.Size())\n    assert.Equal(t, \u0026#34;Bar\u0026#34;, text(selection.Nodes[0]))\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e113a1e60305c9671563bc47d42fa00345c714da/go/index_template_test.go#L38\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void completedItemsGetCompletedClass() {\n      var model = new TodoList();\n      model.add(\u0026#34;Foo\u0026#34;);\n\u003cspan\u003e      model.addCompleted(\u0026#34;Bar\u0026#34;);\u003c/span\u003e\n  \n      var html = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model);\n  \n      Document document = Jsoup.parse(html, \u0026#34;\u0026#34;);\n\u003cspan\u003e      var selection = document.select(\u0026#34;ul.todo-list li.completed\u0026#34;);\u003c/span\u003e\n      assertThat(selection).hasSize(1);\n      assertThat(selection.text()).isEqualTo(\u0026#34;Bar\u0026#34;);\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e113a1e60305c9671563bc47d42fa00345c714da/java/src/test/java/org/example/IndexTemplateTest.java#L30\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd this test can be made green by adding this bit of logic to the\n      template:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n    {{ range .Items }}\n\u003cspan\u003e      \u0026lt;li class=\u0026#34;{{ if .IsCompleted }}completed{{ end }}\u0026#34;\u0026gt;\u003c/span\u003e\n        \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n          \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n          \u0026lt;label\u0026gt;{{ .Title }}\u0026lt;/label\u0026gt;\n          \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n        \u0026lt;/div\u0026gt;\n      \u0026lt;/li\u0026gt;\n    {{ end }}\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/60f833ea61e1e4bdb0ac25cb8706704e0b971b84/go/index.tmpl#L24\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava - jmustache\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n    {{ #allItems }}\n\u003cspan\u003e    \u0026lt;li class=\u0026#34;{{ #isCompleted }}completed{{ /isCompleted }}\u0026#34;\u0026gt;\u003c/span\u003e\n      \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n        \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n        \u0026lt;label\u0026gt;{{ title }}\u0026lt;/label\u0026gt;\n        \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n      \u0026lt;/div\u0026gt;\n    \u0026lt;/li\u0026gt;\n    {{ /allItems }}\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/60f833ea61e1e4bdb0ac25cb8706704e0b971b84/java/src/main/resources/index.tmpl#L24\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eSo little by little, we can test and add the various dynamic features\n      that our template should have.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"MakeItEasyToAddNewTests\"\u003e\n\u003ch3\u003eMake it easy to add new tests\u003c/h3\u003e\n\n\u003cp\u003eThe first of the 20 tips from the excellent \u003ca href=\"https://research.swtch.com/testing\"\u003etalk by Russ Cox on Go\n      Testing\u003c/a\u003e is “\u003cb\u003eMake it easy to add new test cases\u003c/b\u003e“. Indeed, in Go there\n      is a tendency to make most tests parameterized, for this very reason.\n      On the other hand, while Java has\n      \u003ca href=\"https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests\"\u003egood support\n       for parameterized tests\u003c/a\u003e with JUnit 5, they don\u0026#39;t seem to be used as much.\n\n      Since our current two tests have the same structure, we\n      could factor them into a single parameterized test. \u003c/p\u003e\n\n\u003cp\u003eA test case for us will consist of:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA name (so that we can produce clear error messages when the test\n        fails)\u003c/li\u003e\n\n\u003cli\u003eA model (in our case a \u003ccode\u003etodo.List\u003c/code\u003e)\u003c/li\u003e\n\n\u003cli\u003eA CSS selector\u003c/li\u003e\n\n\u003cli\u003eA list of text matches that we expect to find when we run the CSS\n        selector on the rendered HTML.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo this is the data structure for our test cases:\u003c/p\u003e\n\n\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  var testCases = []struct {\n    name     string\n    model    *todo.List\n    selector string\n    matches  []string\n  }{\n    {\n      name: \u0026#34;all todo items are shown\u0026#34;,\n      model: todo.NewList().\n        Add(\u0026#34;Foo\u0026#34;).\n        Add(\u0026#34;Bar\u0026#34;),\n      selector: \u0026#34;ul.todo-list li\u0026#34;,\n      matches:  []string{\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;},\n    },\n    {\n      name: \u0026#34;completed items get the \u0026#39;completed\u0026#39; class\u0026#34;,\n      model: todo.NewList().\n        Add(\u0026#34;Foo\u0026#34;).\n        AddCompleted(\u0026#34;Bar\u0026#34;),\n      selector: \u0026#34;ul.todo-list li.completed\u0026#34;,\n      matches:  []string{\u0026#34;Bar\u0026#34;},\n    },\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/02c7aa117f88723f61aa817c94c14662fb9b0719/go/index_template_test.go#L17\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  record TestCase(String name,\n                  TodoList model,\n                  String selector,\n                  List\u0026lt;String\u0026gt; matches) {\n      @Override\n      public String toString() {\n          return name;\n      }\n  }\n  \n  public static TestCase[] indexTestCases() {\n      return new TestCase[]{\n              new TestCase(\n                      \u0026#34;all todo items are shown\u0026#34;,\n                      new TodoList()\n                              .add(\u0026#34;Foo\u0026#34;)\n                              .add(\u0026#34;Bar\u0026#34;),\n                      \u0026#34;ul.todo-list li\u0026#34;,\n                      List.of(\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;)),\n              new TestCase(\n                      \u0026#34;completed items get the \u0026#39;completed\u0026#39; class\u0026#34;,\n                      new TodoList()\n                              .add(\u0026#34;Foo\u0026#34;)\n                              .addCompleted(\u0026#34;Bar\u0026#34;),\n                      \u0026#34;ul.todo-list li.completed\u0026#34;,\n                      List.of(\u0026#34;Bar\u0026#34;)),\n      };\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/02c7aa117f88723f61aa817c94c14662fb9b0719/java/src/test/java/org/example/IndexTemplateTest.java#L16\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd this is our parameterized test:\u003c/p\u003e\n\n\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_indexTemplate(t *testing.T) {\n    for _, test := range testCases {\n      t.Run(test.name, func(t *testing.T) {\n        buf := renderTemplate(\u0026#34;index.tmpl\u0026#34;, test.model)\n  \n        assertWellFormedHtml(t, buf)\n        document := parseHtml(t, buf)\n        selection := document.Find(test.selector)\n        require.Equal(t, len(test.matches), len(selection.Nodes), \u0026#34;unexpected # of matches\u0026#34;)\n        for i, node := range selection.Nodes {\n          assert.Equal(t, test.matches[i], text(node))\n        }\n      })\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/02c7aa117f88723f61aa817c94c14662fb9b0719/go/index_template_test.go#L42\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @ParameterizedTest\n  @MethodSource(\u0026#34;indexTestCases\u0026#34;)\n  void testIndexTemplate(TestCase test) {\n      var html = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, test.model);\n  \n      var document = parseHtml(html);\n      var selection = document.select(test.selector);\n      assertThat(selection).hasSize(test.matches.size());\n      for (int i = 0; i \u0026lt; test.matches.size(); i++) {\n          assertThat(selection.get(i).text()).isEqualTo(test.matches.get(i));\n      }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/02c7aa117f88723f61aa817c94c14662fb9b0719/java/src/test/java/org/example/IndexTemplateTest.java#L45\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eWe can now run our parameterized test and see it pass:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  $ go test -v\n  === RUN   Test_indexTemplate\n  === RUN   Test_indexTemplate/\u003cspan\u003eall_todo_items_are_shown\u003c/span\u003e\n  === RUN   Test_indexTemplate/\u003cspan\u003ecompleted_items_get_the_\u0026#39;completed\u0026#39;_class\u003c/span\u003e\n  --- PASS: Test_indexTemplate (0.00s)\n      --- PASS: Test_indexTemplate/\u003cspan\u003eall_todo_items_are_shown\u003c/span\u003e (0.00s)\n      --- PASS: Test_indexTemplate/\u003cspan\u003ecompleted_items_get_the_\u0026#39;completed\u0026#39;_class\u003c/span\u003e (0.00s)\n  PASS\n  ok    tdd-html-templates  0.608s\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  $ ./gradlew test\n  \n  \u0026gt; Task :test\n  \n  IndexTemplateTest \u0026gt; testIndexTemplate(TestCase) \u0026gt; [1] \u003cspan\u003eall todo items are shown\u003c/span\u003e PASSED\n  IndexTemplateTest \u0026gt; testIndexTemplate(TestCase) \u0026gt; [2] \u003cspan\u003ecompleted items get the \u0026#39;completed\u0026#39; class\u003c/span\u003e PASSED\u003c/pre\u003e\n\n\u003cp\u003eNote how, by giving a name to our test cases, we get very readable test output, both on the terminal and in the IDE:\u003c/p\u003e\n\n\u003cdiv id=\"param-test-output-ide.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/tdd-html-templates/param-test-output-ide.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eHaving rewritten our two old tests in table form, it\u0026#39;s now super easy to add\n      another. This is the test for the “\u003ci\u003ex\u003c/i\u003e items left” text:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  {\n    name: \u0026#34;items left\u0026#34;,\n    model: todo.NewList().\n      Add(\u0026#34;One\u0026#34;).\n      Add(\u0026#34;Two\u0026#34;).\n      AddCompleted(\u0026#34;Three\u0026#34;),\n    selector: \u0026#34;span.todo-count\u0026#34;,\n    matches:  []string{\u0026#34;2 items left\u0026#34;},\n  },\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/go/index_template_test.go#L41\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  new TestCase(\n      \u0026#34;items left\u0026#34;,\n      new TodoList()\n              .add(\u0026#34;One\u0026#34;)\n              .add(\u0026#34;Two\u0026#34;)\n              .addCompleted(\u0026#34;Three\u0026#34;),\n      \u0026#34;span.todo-count\u0026#34;,\n      List.of(\u0026#34;2 items left\u0026#34;)),\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/java/src/test/java/org/example/IndexTemplateTest.java#L42\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd the corresponding change in the html template is:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;\u003cspan\u003e{{len .ActiveItems}}\u003c/span\u003e\u0026lt;/strong\u0026gt; items left\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/go/index.tmpl#L37\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava - jmustache\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;span class=\u0026#34;todo-count\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;\u003cspan\u003e{{activeItemsCount}}\u003c/span\u003e\u0026lt;/strong\u0026gt; items left\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/java/src/main/resources/index.tmpl#L37\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThe above change in the template requires a supporting method in the model:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  type Item struct {\n    Title       string\n    IsCompleted bool\n  }\n  \n  type List struct {\n    Items []*Item\n  }\n  \n\u003cspan\u003e  func (l *List) ActiveItems() []*Item {\n    var result []*Item\n    for _, item := range l.Items {\n      if !item.IsCompleted {\n        result = append(result, item)\n      }\n    }\n    return result\n  }\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/go/todo/list.go#L48\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  public class TodoList {\n      private final List\u0026lt;TodoItem\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\n      // ...\n\u003cspan\u003e      public long activeItemsCount() {\n          return items.stream().filter(TodoItem::isActive).count();\n      }\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/00f2cbf2fb9abbaf2fa0dd020080b9a5d241123d/java/src/main/java/org/example/TodoList.java#L23\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\n        We\u0026#39;ve invested a little effort in our testing infrastructure, so that adding new\n        test cases is easier.  In the next section, we\u0026#39;ll see that the requirements\n        for the next test cases will push us to refine our test infrastructure further.\n      \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"MakingTheTableMoreExpressiveAtTheExpenseOfTheTestCode\"\u003e\n\u003ch3\u003eMaking the table more expressive, at the expense of the test code\u003c/h3\u003e\n\n\n\n\u003cp\u003eWe will now test the “All”, “Active” and “Completed” navigation links at\n      the bottom of the UI (\u003ca href=\"#todos.png\"\u003esee the picture above\u003c/a\u003e),\n      and these depend on which url we are visiting, which is\n      something that our template has no way to find out.\n\n      Currently, all we pass to our template is our model, which is a todo-list.\n      It\u0026#39;s not correct to add the currently visited url to the model, because that is\n      user navigation state, not application state.\n\n      So we need to pass more information to the template beyond the model. An easy way\n      is to pass a map, which we construct in our\n      \u003ccode\u003erenderTemplate\u003c/code\u003e function: \u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func renderTemplate(model *todo.List, path string) bytes.Buffer {\n    templ := template.Must(template.ParseFiles(\u0026#34;index.tmpl\u0026#34;))\n    var buf bytes.Buffer\n\u003cspan\u003e    data := map[string]any{\n      \u0026#34;model\u0026#34;: model,\n      \u0026#34;path\u0026#34;:  path,\n    }\u003c/span\u003e\n    err := templ.Execute(\u0026amp;buf, \u003cspan\u003edata\u003c/span\u003e)\n    if err != nil {\n      panic(err)\n    }\n    return buf\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  private String renderTemplate(String templateName, TodoList model, String path) {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(templateName)));\n\u003cspan\u003e      var data = Map.of(\n              \u0026#34;model\u0026#34;, model,\n              \u0026#34;path\u0026#34;, path\n      );\u003c/span\u003e\n      return template.execute(\u003cspan\u003edata\u003c/span\u003e);\n  }\u003c/pre\u003e\n\n\u003cp\u003eAnd correspondingly our test cases table has one more field:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  var testCases = []struct {\n    name     string\n    model    *todo.List\n\u003cspan\u003e    path     string\u003c/span\u003e\n    selector string\n    matches  []string\n  }{\n    {\n      name: \u0026#34;all todo items are shown\u0026#34;,\n      model: todo.NewList().\n        Add(\u0026#34;Foo\u0026#34;).\n        Add(\u0026#34;Bar\u0026#34;),\n      selector: \u0026#34;ul.todo-list li\u0026#34;,\n      matches:  []string{\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;},\n    },\n  // ... the other cases\n    {\n      name:     \u0026#34;highlighted navigation link: All\u0026#34;,\n\u003cspan\u003e      path:     \u0026#34;/\u0026#34;,\u003c/span\u003e\n      selector: \u0026#34;ul.filters a.selected\u0026#34;,\n      matches:  []string{\u0026#34;All\u0026#34;},\n    },\n    {\n      name:     \u0026#34;highlighted navigation link: Active\u0026#34;,\n\u003cspan\u003e      path:     \u0026#34;/active\u0026#34;,\u003c/span\u003e\n      selector: \u0026#34;ul.filters a.selected\u0026#34;,\n      matches:  []string{\u0026#34;Active\u0026#34;},\n    },\n    {\n      name:     \u0026#34;highlighted navigation link: Completed\u0026#34;,\n\u003cspan\u003e      path:     \u0026#34;/completed\u0026#34;,\u003c/span\u003e\n      selector: \u0026#34;ul.filters a.selected\u0026#34;,\n      matches:  []string{\u0026#34;Completed\u0026#34;},\n    },\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  record TestCase(String name,\n                  TodoList model,\n\u003cspan\u003e                  String path,\u003c/span\u003e\n                  String selector,\n                  List\u0026lt;String\u0026gt; matches) {\n      @Override\n      public String toString() {\n          return name;\n      }\n  }\n  \n  public static TestCase[] indexTestCases() {\n      return new TestCase[]{\n              new TestCase(\n                      \u0026#34;all todo items are shown\u0026#34;,\n                      new TodoList()\n                              .add(\u0026#34;Foo\u0026#34;)\n                              .add(\u0026#34;Bar\u0026#34;),\n\u003cspan\u003e                      \u0026#34;/\u0026#34;,\u003c/span\u003e\n                      \u0026#34;ul.todo-list li\u0026#34;,\n                      List.of(\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;)),\n              // ... the previous cases\n              new TestCase(\n                      \u0026#34;highlighted navigation link: All\u0026#34;,\n                      new TodoList(),\n\u003cspan\u003e                      \u0026#34;/\u0026#34;,\u003c/span\u003e\n                      \u0026#34;ul.filters a.selected\u0026#34;,\n                      List.of(\u0026#34;All\u0026#34;)),\n              new TestCase(\n                      \u0026#34;highlighted navigation link: Active\u0026#34;,\n                      new TodoList(),\n\u003cspan\u003e                      \u0026#34;/active\u0026#34;,\u003c/span\u003e\n                      \u0026#34;ul.filters a.selected\u0026#34;,\n                      List.of(\u0026#34;Active\u0026#34;)),\n              new TestCase(\n                      \u0026#34;highlighted navigation link: Completed\u0026#34;,\n                      new TodoList(),\n\u003cspan\u003e                      \u0026#34;/completed\u0026#34;,\u003c/span\u003e\n                      \u0026#34;ul.filters a.selected\u0026#34;,\n                      List.of(\u0026#34;Completed\u0026#34;)),\n      };\n  }\u003c/pre\u003e\n\n\u003cp\u003eWe notice that for the three new cases, the \u003ci\u003emodel is irrelevant\u003c/i\u003e;\n        while for the previous cases, \u003ci\u003ethe path is irrelevant\u003c/i\u003e.  The Go syntax allows us\n        to initialize a struct with just the fields we\u0026#39;re interested in, but Java does not have\n        a similar feature, so we\u0026#39;re pushed to pass extra information, and this makes the test cases\n        table harder to understand.\n        \u003c/p\u003e\n\n\u003cp\u003e\n        A developer might look at the first test case and wonder if the expected behavior depends\n        on the path being set to \u003ccode\u003e“/”\u003c/code\u003e, and might be tempted to add more cases with\n        a different path. In the same way, when reading the\n        \u003ci\u003ehighlighted navigation link\u003c/i\u003e test cases, the developer might wonder if the\n        expected behavior depends on the model being set to an empty todo list. If so, one might\n        be led to add irrelevant test cases for the highlighted link with non-empty todo-lists.\n      \u003c/p\u003e\n\n\u003cp\u003e\n        We want to optimize for the time of the developers, so it\u0026#39;s worthwhile to avoid adding irrelevant\n        data to our test case.  In Java we might pass \u003ccode\u003enull\u003c/code\u003e for the\n        irrelevant fields, but there\u0026#39;s a better way: we can use\n        \u003ca href=\"https://martinfowler.com/dslCatalog/constructionBuilder.html\"\u003ethe builder pattern\u003c/a\u003e,\n        popularized by \u003ca href=\"https://www.goodreads.com/book/show/34927404-effective-java\"\u003eJoshua Bloch\u003c/a\u003e.\n        We can quickly write one for the Java \u003ccode\u003eTestCase\u003c/code\u003e record this way:\n      \u003c/p\u003e\n\n\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  record TestCase(String name,\n                  TodoList model,\n                  String path,\n                  String selector,\n                  List\u0026lt;String\u0026gt; matches) {\n      @Override\n      public String toString() {\n          return name;\n      }\n  \n\u003cspan\u003e      public static final class Builder {\n          String name;\n          TodoList model;\n          String path;\n          String selector;\n          List\u0026lt;String\u0026gt; matches;\n  \n          public Builder name(String name) {\n              this.name = name;\n              return this;\n          }\n  \n          public Builder model(TodoList model) {\n              this.model = model;\n              return this;\n          }\n  \n          public Builder path(String path) {\n              this.path = path;\n              return this;\n          }\n  \n          public Builder selector(String selector) {\n              this.selector = selector;\n              return this;\n          }\n  \n          public Builder matches(String ... matches) {\n              this.matches = Arrays.asList(matches);\n              return this;\n          }\n  \n          public TestCase build() {\n              return new TestCase(name, model, path, selector, matches);\n          }\n      }\u003c/span\u003e\n  }\u003c/pre\u003e\n\n\u003cp\u003eHand-coding builders is a little tedious, but doable, though there are\n      \u003ca href=\"https://projectlombok.org/\"\u003eautomated\u003c/a\u003e \u003ca href=\"https://github.com/Randgalt/record-builder\"\u003eways\u003c/a\u003e to write them.\n      Now we can rewrite our Java test cases with the \u003ccode\u003eBuilder\u003c/code\u003e, to\n      achieve greater clarity:\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  public static TestCase[] indexTestCases() {\n      return new TestCase[]{\n              new TestCase.Builder()\n                      .\u003cspan\u003ename\u003c/span\u003e(\u0026#34;all todo items are shown\u0026#34;)\n                      .\u003cspan\u003emodel\u003c/span\u003e(new TodoList()\n                              .add(\u0026#34;Foo\u0026#34;)\n                              .add(\u0026#34;Bar\u0026#34;))\n                      .\u003cspan\u003eselector\u003c/span\u003e(\u0026#34;ul.todo-list li\u0026#34;)\n                      .\u003cspan\u003ematches\u003c/span\u003e(\u0026#34;Foo\u0026#34;, \u0026#34;Bar\u0026#34;)\n                      .build(),\n              // ... other cases\n              new TestCase.Builder()\n                      .\u003cspan\u003ename\u003c/span\u003e(\u0026#34;highlighted navigation link: Completed\u0026#34;)\n                      .\u003cspan\u003epath\u003c/span\u003e(\u0026#34;/completed\u0026#34;)\n                      .\u003cspan\u003eselector\u003c/span\u003e(\u0026#34;ul.filters a.selected\u0026#34;)\n                      .\u003cspan\u003ematches\u003c/span\u003e(\u0026#34;Completed\u0026#34;)\n                      .build(),\n      };\n  }\u003c/pre\u003e\n\n\u003cp\u003eSo, where are we with our tests? At present, they fail for the wrong reason: null-pointer exceptions\n        due to the missing \u003ccode\u003emodel\u003c/code\u003e and \u003ccode\u003epath\u003c/code\u003e values.\n        In order to get our new test cases to fail for the right reason, namely that the template does\n        not yet have logic to highlight the correct link, we must\n         provide default values for \u003ccode\u003emodel\u003c/code\u003e and \u003ccode\u003epath\u003c/code\u003e. In Go, we can do this\n        in the test method:\n      \u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_indexTemplate(t *testing.T) {\n    for _, test := range testCases {\n      t.Run(test.name, func(t *testing.T) {\n\u003cspan\u003e        if test.model == nil {\n          test.model = todo.NewList()\n        }\u003c/span\u003e\n        buf := renderTemplate(test.model, test.path)\n        // ... same as before \n      })\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/1e7262185957947c4983a07a1d3eb79bfa1025e0/go/index_template_test.go#L72\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIn Java, we can provide default values in the builder:\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  public static final class Builder {\n      String name;\n\u003cspan\u003e      TodoList model = new TodoList();\u003c/span\u003e\n\u003cspan\u003e      String path = \u0026#34;/\u0026#34;;\u003c/span\u003e\n      String selector;\n      List\u0026lt;String\u0026gt; matches;\n      // ...\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/1e7262185957947c4983a07a1d3eb79bfa1025e0/java/src/test/java/org/example/IndexTemplateTest.java#L31\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eWith these changes, we see that the last two test cases, the ones for the highlighted link \u003ci\u003eActive\u003c/i\u003e\n      and \u003ci\u003eCompleted\u003c/i\u003e fail, for the expected reason that the highlighted link does not change:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  === RUN   Test_indexTemplate/highlighted_navigation_link:_Active\n      index_template_test.go:82: \n            Error Trace:  .../tdd-templates/go/index_template_test.go:82\n            Error:        Not equal: \n\u003cspan\u003e                          expected: \u0026#34;Active\u0026#34;\u003c/span\u003e\n\u003cspan\u003e                          actual  : \u0026#34;All\u0026#34;\u003c/span\u003e\n  === RUN   Test_indexTemplate/highlighted_navigation_link:_Completed\n      index_template_test.go:82: \n            Error Trace:  .../tdd-templates/go/index_template_test.go:82\n            Error:        Not equal: \n\u003cspan\u003e                          expected: \u0026#34;Completed\u0026#34;\u003c/span\u003e\n\u003cspan\u003e                          actual  : \u0026#34;All\u0026#34;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  IndexTemplateTest \u0026gt; testIndexTemplate(TestCase) \u0026gt; [5] highlighted navigation link: Active FAILED\n      org.opentest4j.AssertionFailedError:\n      Expecting:\n\u003cspan\u003e       \u0026lt;\u0026#34;All\u0026#34;\u0026gt;\u003c/span\u003e\n      to be equal to:\n\u003cspan\u003e       \u0026lt;\u0026#34;Active\u0026#34;\u0026gt;\u003c/span\u003e\n      but was not.\n  \n  IndexTemplateTest \u0026gt; testIndexTemplate(TestCase) \u0026gt; [6] highlighted navigation link: Completed FAILED\n      org.opentest4j.AssertionFailedError:\n      Expecting:\n\u003cspan\u003e       \u0026lt;\u0026#34;All\u0026#34;\u0026gt;\u003c/span\u003e\n      to be equal to:\n\u003cspan\u003e       \u0026lt;\u0026#34;Completed\u0026#34;\u0026gt;\u003c/span\u003e\n      but was not.\u003c/pre\u003e\n\n\u003cp\u003eTo make the tests pass, we make these changes to the template:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;filters\u0026#34;\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ if eq .path \u0026#34;/\u0026#34; }}selected{{ end }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/\u0026#34;\u0026gt;All\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ if eq .path \u0026#34;/active\u0026#34; }}selected{{ end }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/active\u0026#34;\u0026gt;Active\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ if eq .path \u0026#34;/completed\u0026#34; }}selected{{ end }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/completed\u0026#34;\u0026gt;Completed\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/1e7262185957947c4983a07a1d3eb79bfa1025e0/go/index.tmpl#L39\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava - jmustache\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;filters\u0026#34;\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ #pathRoot }}selected{{ /pathRoot }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/\u0026#34;\u0026gt;All\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ #pathActive }}selected{{ /pathActive }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/active\u0026#34;\u0026gt;Active\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n    \u0026lt;li\u0026gt;\n      \u0026lt;a \u003cspan\u003eclass=\u0026#34;{{ #pathCompleted }}selected{{ /pathCompleted }}\u003c/span\u003e\u0026#34; href=\u0026#34;#/completed\u0026#34;\u0026gt;Completed\u0026lt;/a\u0026gt;\n    \u0026lt;/li\u0026gt;\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/1e7262185957947c4983a07a1d3eb79bfa1025e0/java/src/main/resources/index.tmpl#L39\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eSince the Mustache template language does not allow for equality testing, we must change the\n        data passed to the template so that we execute the equality tests before rendering the template:\n      \u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  private String renderTemplate(String templateName, TodoList model, String path) {\n      var template = Mustache.compiler().compile(\n              new InputStreamReader(\n                      getClass().getResourceAsStream(templateName)));\n      var data = Map.of(\n              \u0026#34;model\u0026#34;, model,\n\u003cspan\u003e              \u0026#34;pathRoot\u0026#34;, path.equals(\u0026#34;/\u0026#34;),\u003c/span\u003e\n\u003cspan\u003e              \u0026#34;pathActive\u0026#34;, path.equals(\u0026#34;/active\u0026#34;),\u003c/span\u003e\n\u003cspan\u003e              \u0026#34;pathCompleted\u0026#34;, path.equals(\u0026#34;/completed\u0026#34;)\u003c/span\u003e\n      );\n      return template.execute(data);\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/1e7262185957947c4983a07a1d3eb79bfa1025e0/java/src/test/java/org/example/IndexTemplateTest.java#L132\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd with these changes, all of our tests now pass.\u003c/p\u003e\n\n\u003cp\u003eTo recap this section, we made the test code a little bit more complicated, so that the test\n      cases are clearer: this is a very good tradeoff!\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Level3TestingHtmlBehaviour\"\u003e\n\u003ch2\u003eLevel 3: testing HTML behaviour\u003c/h2\u003e\n\n\u003cp\u003eIn the story so far, we tested \u003ci\u003ethe behaviour of the HTML\n      templates\u003c/i\u003e, by checking \u003ci\u003ethe structure of the generated HTML\u003c/i\u003e.\n      That\u0026#39;s good, but what if we wanted to test the behaviour of the HTML\n      itself, plus any CSS and JavaScript it may use?\u003c/p\u003e\n\n\u003cp\u003e The behaviour of HTML by itself is usually pretty obvious, because\n      there is not much of it. The only elements that can interact with the\n      user are the anchor (\u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e), \u003ccode\u003e\u0026lt;form\u0026gt;\u003c/code\u003e and\n      \u003ccode\u003e\u0026lt;input\u0026gt;\u003c/code\u003e elements, but the picture changes completely when\n      we add CSS, that can hide, show, move around things and lots more, and\n      with JavaScript, that can add any behaviour to a page. \u003c/p\u003e\n\n\u003cp\u003e In an application that is primarily rendered server-side, we expect\n      that most behaviour is implemented by returning new HTML with a\n      round-trip to the user, and this can be tested adequately with the\n      techniques we\u0026#39;ve seen so far, but what if we wanted to speed up the\n      application behaviour with a library such as \u003ca href=\"https://htmx.org/\"\u003eHTMX\u003c/a\u003e? This library works through special\n      attributes that are added to elements to add Ajax behaviour. These\n      attributes are in effect a \u003ca href=\"https://martinfowler.com/dsl.html\"\u003eDSL\u003c/a\u003e that we might want to\n      test. \u003c/p\u003e\n\n\u003cp\u003eHow can we test the combination of HTML, CSS and JavaScript in\n      a unit test?\u003c/p\u003e\n\n\u003cdiv id=\"playwright.svg\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/tdd-html-templates/playwright.svg\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e Testing HTML, CSS and JavaScript requires something that is able to\n      interpret and execute their behaviours; in other words, we need a\n      browser! It is customary to use headless browsers in end-to-end tests;\n      can we use them for unitary tests instead? I think this is possible,\n      using the following techniques, although I must admit I have yet to try\n      this on a real project.\u003c/p\u003e\n\n\u003cp\u003e We will use the \u003ca href=\"https://playwright.dev/\"\u003ePlaywright\u003c/a\u003e\n      library, that is available for both \u003ca href=\"https://github.com/playwright-community/playwright-go\"\u003eGo\u003c/a\u003e and\n      \u003ca href=\"https://playwright.dev/java/docs/intro\"\u003eJava\u003c/a\u003e. The tests we\n      are going to write will be slower, because we will have to wait a few\n      seconds for the headless browser to start, but will retain some of the\n      important characteristics of unit tests, primarily that we are testing\n      just the HTML (and any associated CSS and JavaScript), in isolation from\n      any other server-side logic. \u003c/p\u003e\n\n\u003cp\u003e Continuing with the \u003ca href=\"https://todomvc.com/\"\u003eTodoMVC\u003c/a\u003e\n      example, the next thing we might want to test is what happens when the\n      user clicks on the checkbox of a todo item. What we\u0026#39;d like to happen is\n      that: \u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eA POST call to the server is made, so that the application knows\n        that the state of a todo item has changed\u003c/li\u003e\n\n\u003cli\u003eThe server returns new HTML for the dynamic part of the page,\n        namely all of the section with class “todoapp”, so that we can show the\n        new state of the application including the count of remaining “active”\n        items (\u003ca href=\"#index.tmpl\"\u003esee the template above\u003c/a\u003e)\u003c/li\u003e\n\n\u003cli\u003eThe page replaces the old contents of the “todoapp” section with\n        the new ones.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003csection id=\"LoadingThePageInThePlaywrightBrowser\"\u003e\n\u003ch3\u003eLoading the page in the Playwright browser\u003c/h3\u003e\n\n\u003cp\u003eWe start with a test that will just load the initial HTML. The test\n        is a little involved, so I show the complete code here, and then I will\n        comment it bit by bit.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_toggleTodoItem(t *testing.T) {\n    // render the initial HTML\n    model := todo.NewList().\n      Add(\u0026#34;One\u0026#34;).\n      Add(\u0026#34;Two\u0026#34;)\n\u003cspan\u003e    initialHtml := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;)\u003c/span\u003e\n  \n    // open the browser page with Playwright\n\u003cspan\u003e    page := openPage()\u003c/span\u003e\n    defer page.Close()\n    logActivity(page)\n  \n    // stub network calls\n    err := \u003cspan\u003epage.Route(\u0026#34;**\u0026#34;\u003c/span\u003e, func(route playwright.Route) {\n      if route.Request().URL() == \u003cspan\u003e\u0026#34;http://localhost:4567/index.html\u0026#34;\u003c/span\u003e {\n        // serve the initial HTML\n\u003cspan\u003e        stubResponse(route, initialHtml.String(), \u0026#34;text/html\u0026#34;)\u003c/span\u003e\n      } else {\n        // avoid unexpected requests\n        panic(\u0026#34;unexpected request: \u0026#34; + route.Request().URL())\n      }\n    })\n    if err != nil {\n      t.Fatal(err)\n    }\n  \n    // load initial HTML in the page\n\u003cspan\u003e    response, err := page.Goto(\u0026#34;http://localhost:4567/index.html\u0026#34;)\u003c/span\u003e\n    if err != nil {\n      t.Fatal(err)\n    }\n    if response.Status() != 200 {\n      t.Fatalf(\u0026#34;unexpected status: %d\u0026#34;, response.Status())\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/5b7a971fe23e70081165a4562da115ad37d5253f/go/index_behaviour_test.go#L11\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  public class IndexBehaviourTest {\n      static Playwright playwright;\n      static Browser browser;\n  \n      @BeforeAll\n      static void launchBrowser() {\n          playwright = Playwright.create();\n          browser = playwright.chromium().launch();\n      }\n  \n      @AfterAll\n      static void closeBrowser() {\n          playwright.close();\n      }\n  \n      @Test\n      void toggleTodoItem() {\n          // Render the initial html\n          TodoList model = new TodoList()\n                  .add(\u0026#34;One\u0026#34;)\n                  .add(\u0026#34;Two\u0026#34;);\n\u003cspan\u003e\u003cspan\u003e          String initialHtml = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;);\u003c/span\u003e\u003c/span\u003e\n          \n\u003cspan\u003e          try (Page page = browser.newPage()) {\u003c/span\u003e\n              logActivity(page);\n  \n              // stub network calls\n              \u003cspan\u003epage.route(\u0026#34;**\u0026#34;\u003c/span\u003e, route -\u0026gt; {\n                  if (route.request().url().equals(\u003cspan\u003e\u0026#34;http://localhost:4567/index.html\u0026#34;\u003c/span\u003e)) {\n                      // serve the initial HTML\n                      route.fulfill(new Route.FulfillOptions()\n                              .setContentType(\u0026#34;text/html\u0026#34;)\n\u003cspan\u003e                              .setBody(initialHtml));\u003c/span\u003e\n                  } else {\n                      // we don\u0026#39;t want unexpected calls\n                      fail(String.format(\u0026#34;Unexpected request: %s %s\u0026#34;, route.request().method(), route.request().url()));\n                  }\n              });\n          \n              // load initial html\n\u003cspan\u003e              page.navigate(\u0026#34;http://localhost:4567/index.html\u0026#34;);\u003c/span\u003e\n          }\n      }\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/bedbaf713edc525cf402662aa861b1fb155e2415/java/src/test/java/org/example/IndexBehaviourTest.java#L32\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAt the start of the test, we initialize the model with two todo\n        items “One” and “Two”, then we render the template as before: \u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  model := todo.NewList().\n    Add(\u0026#34;One\u0026#34;).\n    Add(\u0026#34;Two\u0026#34;)\n  initialHtml := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;)\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  TodoList model = new TodoList()\n          .add(\u0026#34;One\u0026#34;)\n          .add(\u0026#34;Two\u0026#34;);\n  String initialHtml = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;);\u003c/pre\u003e\n\n\u003cp\u003eThen we open the Playwright “page”, which will start a headless\n        browser\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  page := openPage()\n  defer page.Close()\n  logActivity(page)\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  try (Page page = browser.newPage()) {\n      logActivity(page);\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eopenPage\u003c/code\u003e function in Go returns a Playwright\n        \u003ccode\u003ePage\u003c/code\u003e object,\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func openPage() playwright.Page {\n    pw, err := playwright.Run()\n    if err != nil {\n      log.Fatalf(\u0026#34;could not start playwright: %v\u0026#34;, err)\n    }\n    browser, err := pw.Chromium.Launch()\n    if err != nil {\n      log.Fatalf(\u0026#34;could not launch browser: %v\u0026#34;, err)\n    }\n    page, err := browser.NewPage()\n    if err != nil {\n      log.Fatalf(\u0026#34;could not create page: %v\u0026#34;, err)\n    }\n    return page\n  }\u003c/pre\u003e\n\n\u003cp\u003eand the \u003ccode\u003elogActivity\u003c/code\u003e function provides feedback on what\n        the page is doing\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func logActivity(page playwright.Page) {\n    page.OnRequest(func(request playwright.Request) {\n      log.Printf(\u0026#34;\u0026gt;\u0026gt; %s %s\\n\u0026#34;, request.Method(), request.URL())\n    })\n    page.OnResponse(func(response playwright.Response) {\n      log.Printf(\u0026#34;\u0026lt;\u0026lt; %d %s\\n\u0026#34;, response.Status(), response.URL())\n    })\n    page.OnLoad(func(page playwright.Page) {\n      log.Println(\u0026#34;Loaded: \u0026#34; + page.URL())\n    })\n    page.OnConsole(func(message playwright.ConsoleMessage) {\n      log.Println(\u0026#34;!  \u0026#34; + message.Text())\n    })\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  private void logActivity(Page page) {\n      page.onRequest(request -\u0026gt; System.out.printf(\u0026#34;\u0026gt;\u0026gt; %s %s%n\u0026#34;, request.method(), request.url()));\n      page.onResponse(response -\u0026gt; System.out.printf(\u0026#34;\u0026lt;\u0026lt; %s %s%n\u0026#34;, response.status(), response.url()));\n      page.onLoad(page1 -\u0026gt; System.out.println(\u0026#34;Loaded: \u0026#34; + page1.url()));\n      page.onConsoleMessage(consoleMessage -\u0026gt; System.out.println(\u0026#34;!  \u0026#34; + consoleMessage.text()));\n  }\u003c/pre\u003e\n\n\u003cp\u003eThen we stub all network activity that the page might try to do\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  err := page.Route(\u003cspan\u003e\u0026#34;**\u0026#34;\u003c/span\u003e, func(route playwright.Route) {\n    if route.Request().URL() == \u0026#34;http://localhost:4567/index.html\u0026#34; {\n      // serve the initial HTML\n      stubResponse(route, initialHtml.String(), \u0026#34;text/html\u0026#34;)\n    } else {\n      // avoid unexpected requests\n      panic(\u0026#34;unexpected request: \u0026#34; + route.Request().URL())\n    }\n  })\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  // stub network calls\n  page.route(\u003cspan\u003e\u0026#34;**\u0026#34;\u003c/span\u003e, route -\u0026gt; {\n      if (route.request().url().equals(\u0026#34;http://localhost:4567/index.html\u0026#34;)) {\n          // serve the initial HTML\n          route.fulfill(new Route.FulfillOptions()\n                  .setContentType(\u0026#34;text/html\u0026#34;)\n                  .setBody(initialHtml));\n      } else {\n          // we don\u0026#39;t want unexpected calls\n          fail(String.format(\u0026#34;Unexpected request: %s %s\u0026#34;, route.request().method(), route.request().url()));\n      }\n  });\u003c/pre\u003e\n\n\u003cp\u003eand we ask the page to load the initial HTML\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  response, err := page.Goto(\u0026#34;http://localhost:4567/index.html\u0026#34;)\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  page.navigate(\u0026#34;http://localhost:4567/index.html\u0026#34;);\u003c/pre\u003e\n\n\u003cp\u003eWith all this machinery in place, we run the test; it succeeds and\n        it logs the stubbed network activity on standard output:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  === RUN   Test_toggleTodoItem\n  \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n  \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n  Loaded: http://localhost:4567/index.html\n  --- PASS: Test_toggleTodoItem (0.89s)\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  IndexBehaviourTest \u0026gt; toggleTodoItem() STANDARD_OUT\n      \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n      \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n      Loaded: http://localhost:4567/index.html\n  \n  IndexBehaviourTest \u0026gt; toggleTodoItem() PASSED\u003c/pre\u003e\n\n\u003cp\u003eSo with this test we are now able to load arbitrary HTML in a\n        headless browser. In the next sections we\u0026#39;ll see how to simulate user\n        interaction with elements of the page, and observe the page\u0026#39;s\n        behaviour. But first we need to solve a problem with the lack of\n        identifiers in our domain model. \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"IdentifyingTodoItems\"\u003e\n\u003ch3\u003eIdentifying todo items\u003c/h3\u003e\n\n\u003cp\u003eNow we want to click on the “One” checkbox. The problem we have is\n        that at present, we have no way to identify individual todo items, so\n        we introduce an \u003ccode\u003eId\u003c/code\u003e field in the todo item:\u003c/p\u003e\n\n\u003cp\u003eGo – updated model with Id\n\u003c/p\u003e\n\n\u003cpre\u003e  type Item struct {\n\u003cspan\u003e    Id          int\u003c/span\u003e\n    Title       string\n    IsCompleted bool\n  }\n  \n\u003cspan\u003e\u003cspan\u003e  func (l *List) AddWithId(id int, title string) *List {\u003c/span\u003e\u003c/span\u003e\n    item := Item{\n\u003cspan\u003e      Id:    id,\u003c/span\u003e\n      Title: title,\n    }\n    l.Items = append(l.Items, \u0026amp;item)\n    return l\n  }\n  \n  // Add creates a new todo.Item with a random Id\n  func (l *List) Add(title string) *List {\n    item := Item{\n\u003cspan\u003e      Id:    generateRandomId(),\u003c/span\u003e\n      Title: title,\n    }\n    l.Items = append(l.Items, \u0026amp;item)\n    return l\n  }\n  \n\u003cspan\u003e\u003cspan\u003e  func generateRandomId() int {\u003c/span\u003e\u003c/span\u003e\n    return abs(rand.Int())\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava – updated model with Id\n\u003c/p\u003e\n\n\u003cpre\u003e  public class TodoList {\n      private final List\u0026lt;TodoItem\u0026gt; items = new ArrayList\u0026lt;\u0026gt;();\n  \n      public TodoList add(String title) {\n          items.add(new TodoItem(\u003cspan\u003egenerateRandomId()\u003c/span\u003e, title, false));\n          return this;\n      }\n  \n      public TodoList addCompleted(String title) {\n          items.add(new TodoItem(\u003cspan\u003egenerateRandomId()\u003c/span\u003e, title, true));\n          return this;\n      }\n  \n      public TodoList add(\u003cspan\u003eint id\u003c/span\u003e, String title) {\n          items.add(new TodoItem(\u003cspan\u003eid, \u003c/span\u003etitle, false));\n          return this;\n      }\n  \n      private static int generateRandomId() {\n          return new Random().nextInt(0, Integer.MAX_VALUE);\n      }\n  }\n  \n  public record TodoItem(\u003cspan\u003eint id\u003c/span\u003e, String title, boolean isCompleted) {\n      public boolean isActive() {\n          return !isCompleted;\n      }\n  }\u003c/pre\u003e\n\n\u003cp\u003eAnd we update the model in our test to add explicit Ids\u003c/p\u003e\n\n\u003cp\u003eGo – adding Id in the test data\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_toggleTodoItem(t *testing.T) {\n    // render the initial HTML\n    model := todo.NewList().\n\u003cspan\u003e      AddWithId(101, \u0026#34;One\u0026#34;).\u003c/span\u003e\n\u003cspan\u003e      AddWithId(102, \u0026#34;Two\u0026#34;)\u003c/span\u003e\n    initialHtml := renderTemplate(\u0026#34;index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;)\n    // ... \n  }\u003c/pre\u003e\n\n\u003cp\u003eJava – adding Id in the test data\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void toggleTodoItem() {\n      // Render the initial html\n      TodoList model = new TodoList()\n\u003cspan\u003e              .add(101, \u0026#34;One\u0026#34;)\u003c/span\u003e\n\u003cspan\u003e              .add(102, \u0026#34;Two\u0026#34;);\u003c/span\u003e\n      String initialHtml = renderTemplate(\u0026#34;/index.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;);\n  }\u003c/pre\u003e\n\n\u003cp\u003eWe are now ready to test user interaction with the page.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ClickingOnATodoItem\"\u003e\n\u003ch3\u003eClicking on a todo item\u003c/h3\u003e\n\n\u003cp\u003eWe want to simulate user interaction with the HTML page. It might be\n        tempting to continue to use CSS selectors to identify the specific\n        checkbox that we want to click, but there\u0026#39;s a better way: there is a\n        consensus among front-end developers that the best way to test\n        interaction with a page is \u003ca href=\"https://testing-library.com/docs/guiding-principles/\"\u003eto use it\n        the same way that users do\u003c/a\u003e. For instance, you don\u0026#39;t look for a\n        button through a CSS locator such as \u003ccode\u003ebutton.buy\u003c/code\u003e; instead,\n        you look for something clickable with the label “Buy”. In practice,\n        this means identifying parts of the page through their \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\"\u003e\n        ARIA\u003c/a\u003e roles.\u003c/p\u003e\n\n\u003cp\u003eTo this end, we add code to our test to look for a checkbox labelled\n        “One”:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_toggleTodoItem(t *testing.T) {\n    // ...\n    // click on the \u0026#34;One\u0026#34; checkbox\n    \u003cspan\u003echeckbox\u003c/span\u003e := page.GetByRole(*playwright.\u003cspan\u003eAriaRoleCheckbox\u003c/span\u003e, playwright.PageGetByRoleOptions{\u003cspan\u003eName: \u0026#34;One\u0026#34;\u003c/span\u003e})\n    if err := \u003cspan\u003echeckbox.Click()\u003c/span\u003e; err != nil {\n      t.Fatal(err)\n    }\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void toggleTodoItem() {\n          // ...\n          // click on the \u0026#34;One\u0026#34; checkbox\n          var \u003cspan\u003echeckbox\u003c/span\u003e = page.getByRole(\u003cspan\u003eAriaRole.CHECKBOX\u003c/span\u003e, new Page.GetByRoleOptions()\u003cspan\u003e.setName(\u0026#34;One\u0026#34;)\u003c/span\u003e);\n          \u003cspan\u003echeckbox.click()\u003c/span\u003e;\n      }\n  }\u003c/pre\u003e\n\n\u003cp\u003eWe run the test, and it fails:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n  \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n  Loaded: http://localhost:4567/index.html\n  --- FAIL: Test_toggleTodoItem (32.74s)\n      index_behaviour_test.go:50: \u003cspan\u003eplaywright: timeout: Timeout 30000ms exceeded\u003c/span\u003e.\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  IndexBehaviourTest \u0026gt; toggleTodoItem() STANDARD_OUT\n      \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n      \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n      Loaded: http://localhost:4567/index.html\n  \n  IndexBehaviourTest \u0026gt; toggleTodoItem() FAILED\n      com.microsoft.playwright.TimeoutError: Error {\n        message=\u0026#39;\u003cspan\u003eTimeout 30000ms exceeded\u003c/span\u003e.\n      ...  \u003c/pre\u003e\n\n\u003cp\u003ePlaywright waited 30 seconds for the desired checkbox to appear. It\n        turns out that our HTML code does not \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label#fo         r\"\u003elink the label to the checkbox\u003c/a\u003e properly:\u003c/p\u003e\n\n\u003cp\u003egenerated HTML with bad accessibility\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n\u003cspan\u003e      \u0026lt;label\u0026gt;One\u0026lt;/label\u0026gt;\u003c/span\u003e\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eWe fix it by using the \u003ccode\u003efor\u003c/code\u003e attribute in the\n        template,\u003c/p\u003e\n\n\u003cp\u003eindex.tmpl – Go\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input \u003cspan\u003eid=\u0026#34;checkbox-{{.Id}}\u0026#34;\u003c/span\u003e class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label \u003cspan\u003efor=\u0026#34;checkbox-{{.Id}}\u0026#34;\u003c/span\u003e\u0026gt;{{.Title}}\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eindex.tmpl – Java\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input \u003cspan\u003eid=\u0026#34;checkbox-{{ id }}\u0026#34;\u003c/span\u003e class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label \u003cspan\u003efor=\u0026#34;checkbox-{{ id }}\u0026#34;\u003c/span\u003e\u0026gt;{{ title }}\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eSo that it generates proper, accessible HTML:\u003c/p\u003e\n\n\u003cp\u003egenerated HTML with better accessibility\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;li\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input \u003cspan\u003eid=\u0026#34;checkbox-101\u0026#34;\u003c/span\u003e class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label \u003cspan\u003efor=\u0026#34;checkbox-101\u0026#34;\u003c/span\u003e\u0026gt;One\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eWe run again the test, and it passes. \u003c/p\u003e\n\n\u003cp\u003eIn this section we saw how testing the HTML in the same was as users\n        interact with it led us to use ARIA roles, which led to improving\n        accessibility of our generated HTML. In the next section, we will see\n        how to test that the click on a todo item triggers a remote call to the\n        server, that should result in swapping a part of the current HTML with\n        the HTML returned by the XHR call.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Round-tripToTheServer\"\u003e\n\u003ch3\u003eRound-trip to the server\u003c/h3\u003e\n\n\u003cp\u003eNow we will extend our test. We tell the test that if call to\n        \u003ccode\u003ePOST /toggle/101\u003c/code\u003e is received, it should return some\n        stubbed HTML.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  } else if route.Request().URL() == \u003cspan\u003e\u0026#34;http://localhost:4567/toggle/101\u0026#34;\u003c/span\u003e \u0026amp;\u0026amp; route.Request().Method() == \u003cspan\u003e\u0026#34;POST\u0026#34;\u003c/span\u003e {\n    // we expect that a POST /toggle/101 request is made when we click on the \u0026#34;One\u0026#34; checkbox\n    const stubbedHtml = `\n      \u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\n        \u0026lt;p\u0026gt;Stubbed html\u0026lt;/p\u0026gt;\n      \u0026lt;/section\u0026gt;`\n    stubResponse(route, stubbedHtml, \u0026#34;text/html\u0026#34;)\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  } else if (route.request().url().equals(\u003cspan\u003e\u0026#34;http://localhost:4567/toggle/101\u0026#34;\u003c/span\u003e) \u0026amp;\u0026amp; route.request().method().equals(\u003cspan\u003e\u0026#34;POST\u0026#34;\u003c/span\u003e)) {\n      // we expect that a POST /toggle/101 request is made when we click on the \u0026#34;One\u0026#34; checkbox\n      String stubbedHtml = \u0026#34;\u0026#34;\u0026#34;\n          \u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\n              \u0026lt;p\u0026gt;Stubbed html\u0026lt;/p\u0026gt;\n          \u0026lt;/section\u0026gt;\n          \u0026#34;\u0026#34;\u0026#34;;\n      route.fulfill(new Route.FulfillOptions()\n              .setContentType(\u0026#34;text/html\u0026#34;)\n              .setBody(stubbedHtml));\u003c/pre\u003e\n\n\u003cp\u003eAnd we stub the loading of the HTMX library, which we load from a\n        local file:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  } else if route.Request().URL() == \u003cspan\u003e\u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;\u003c/span\u003e {\n    // serve the htmx library\n    stubResponse(route, readFile(\u0026#34;testdata/htmx.min.js\u0026#34;), \u0026#34;application/javascript\u0026#34;)\u003c/pre\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  } else if (route.request().url().equals(\u003cspan\u003e\u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;\u003c/span\u003e)) {\n      // serve the htmx library\n      route.fulfill(new Route.FulfillOptions()\n              .setContentType(\u0026#34;text/html\u0026#34;)\n              .setBody(readFile(\u0026#34;/htmx.min.js\u0026#34;)));\u003c/pre\u003e\n\n\u003cp\u003e Finally, we add the expectation that, after we click the checkbox,\n        the section of the HTML that contains most of the application is\n        reloaded. \u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  // click on the \u0026#34;One\u0026#34; checkbox\n  checkbox := page.GetByRole(*playwright.AriaRoleCheckbox, playwright.PageGetByRoleOptions{Name: \u0026#34;One\u0026#34;})\n  if err := checkbox.Click(); err != nil {\n    t.Fatal(err)\n  }\n\n  // check that the page has been updated\n  document := \u003cspan\u003eparseHtml\u003c/span\u003e(t, content(t, page))\n  elements := document.Find(\u003cspan\u003e\u0026#34;body \u0026gt; section.todoapp \u0026gt; p\u0026#34;\u003c/span\u003e)\n  assert.Equal(t, \u003cspan\u003e\u0026#34;Stubbed html\u0026#34;\u003c/span\u003e, \u003cspan\u003eelements.Text()\u003c/span\u003e, must(page.Content()))\n\u003c/pre\u003e\n\n\u003cp\u003ejava\n\u003c/p\u003e\n\n\u003cpre\u003e  // click on the \u0026#34;One\u0026#34; checkbox\n  var checkbox = page.getByRole(AriaRole.CHECKBOX, new Page.GetByRoleOptions().setName(\u0026#34;One\u0026#34;));\n  checkbox.click();\n\n  // check that the page has been updated\n  var document = \u003cspan\u003eparseHtml\u003c/span\u003e(page.content());\n  var elements = document.select(\u003cspan\u003e\u0026#34;body \u0026gt; section.todoapp \u0026gt; p\u0026#34;\u003c/span\u003e);\n  assertThat(\u003cspan\u003eelements.text()\u003c/span\u003e)\n          .describedAs(page.content())\n          .isEqualTo(\u003cspan\u003e\u0026#34;Stubbed html\u0026#34;\u003c/span\u003e);\u003c/pre\u003e\n\n\u003cp\u003eWe run the test, and it fails, as expected. In order to understand\n        why exactly it fails, we add to the error message the whole HTML\n        document.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  assert.Equal(t, \u0026#34;Stubbed html\u0026#34;, elements.Text(), \u003cspan\u003emust(page.Content())\u003c/span\u003e)\n\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  assertThat(elements.text())\n\u003cspan\u003e          .describedAs(page.content())\u003c/span\u003e\n          .isEqualTo(\u0026#34;Stubbed html\u0026#34;);\u003c/pre\u003e\n\n\u003cp\u003eThe error message is very verbose, but we see that the reason it\n        fails is that we don\u0026#39;t see the stubbed HTML in the output. This means\n        that the page did not make the expected XHR call.\u003c/p\u003e\n\n\u003cp\u003eGo – Java is similar\n\u003c/p\u003e\n\n\u003cpre\u003e  --- FAIL: Test_toggleTodoItem (2.75s)\n  === RUN   Test_toggleTodoItem\n  \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n  \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n  Loaded: http://localhost:4567/index.html\n      index_behaviour_test.go:67:\n            Error Trace:  .../index_behaviour_test.go:67\n            Error:        Not equal:\n\u003cspan\u003e                          expected: \u0026#34;Stubbed html\u0026#34;\u003c/span\u003e\n\u003cspan\u003e                          actual  : \u0026#34;\u0026#34;\u003c/span\u003e\n                          ...\n            Test:         Test_toggleTodoItem\n            Messages:     \u0026lt;!DOCTYPE html\u0026gt;\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\u0026lt;head\u0026gt;\n                              \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\n                              \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt;\n                              \u0026lt;title\u0026gt;Template • TodoMVC\u0026lt;/title\u0026gt;\n                              \u0026lt;script src=\u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n                            \u0026lt;body\u0026gt;\n                              \u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\n                          ...\n                                    \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\n                                      \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n                                        \u0026lt;input id=\u0026#34;checkbox-101\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n                                        \u0026lt;label for=\u0026#34;checkbox-101\u0026#34;\u0026gt;One\u0026lt;/label\u0026gt;\n                                        \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n                                      \u0026lt;/div\u0026gt;\n                                    \u0026lt;/li\u0026gt;\n                          ...\u003c/pre\u003e\n\n\u003cp\u003eWe can make this test pass by changing the HTML template to use HTMX\n        to make an XHR call back to the server. First we load the HTMX\n        library:\u003c/p\u003e\n\n\u003cp\u003eindex.tmpl\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;title\u0026gt;Template • TodoMVC\u0026lt;/title\u0026gt;\n\u003cspan\u003e  \u0026lt;script src=\u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u003c/span\u003e\n\u003c/pre\u003e\n\n\u003cp\u003eThen we add the HTMX attributes to the checkboxes:\u003c/p\u003e\n\n\u003cp\u003eindex.tmpl\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;input\n\u003cspan\u003e      data-hx-post=\u0026#34;/toggle/{{.Id}}\u0026#34;\u003c/span\u003e\n\u003cspan\u003e      data-hx-target=\u0026#34;section.todoapp\u0026#34;\u003c/span\u003e\n      id=\u0026#34;checkbox-{{.Id}}\u0026#34;\n      class=\u0026#34;toggle\u0026#34;\n      type=\u0026#34;checkbox\u0026#34;\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003edata-hx-post\u003c/code\u003e annotation will make HTMX do a POST\n        call to the specified url. The \u003ccode\u003edata-hx-target\u003c/code\u003e tells HTMX\n        to copy the HTML returned by the call, to the element specified by the\n        \u003ccode\u003esection.todoapp\u003c/code\u003e CSS locator. \u003c/p\u003e\n\n\u003cp\u003eWe run again the test, and it still fails!\u003c/p\u003e\n\n\u003cp\u003eGo – Java is similar\n\u003c/p\u003e\n\n\u003cpre\u003e  --- FAIL: Test_toggleTodoItem (2.40s)\n  === RUN   Test_toggleTodoItem\n  \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n  \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n  \u0026gt;\u0026gt; GET https://unpkg.com/htmx.org@1.9.12\n  \u0026lt;\u0026lt; 200 https://unpkg.com/htmx.org@1.9.12\n  Loaded: http://localhost:4567/index.html\n  \u0026gt;\u0026gt; POST http://localhost:4567/toggle/101\n  \u0026lt;\u0026lt; 200 http://localhost:4567/toggle/101\n      index_behaviour_test.go:67:\n            Error Trace:  .../index_behaviour_test.go:67\n            Error:        Not equal:\n                          expected: \u0026#34;Stubbed html\u0026#34;\n                          actual  : \u0026#34;\u0026#34;\n                          ...\n            Test:         Test_toggleTodoItem\n            Messages:     \u0026lt;!DOCTYPE html\u0026gt;\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\u0026lt;head\u0026gt;\n                              \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\n                              \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1\u0026#34;\u0026gt;\n                              \u0026lt;title\u0026gt;Template • TodoMVC\u0026lt;/title\u0026gt;\n                              \u0026lt;script src=\u0026#34;https://unpkg.com/htmx.org@1.9.12\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n                          ...\n                            \u0026lt;body\u0026gt;\n\u003cspan\u003e                              \u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\u0026lt;section class=\u0026#34;todoapp\u0026#34;\u0026gt;\u003c/span\u003e\n                                    \u0026lt;p\u0026gt;Stubbed html\u0026lt;/p\u0026gt;\n\u003cspan\u003e                                  \u0026lt;/section\u0026gt;\u0026lt;/section\u0026gt;\u003c/span\u003e\n                          ...\n                          \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eThe log lines show that the POST call happened as expected, but\n        examination of the error message shows that the HTML structure we\n        expected is not there: we have a \u003ccode\u003esection.todoapp\u003c/code\u003e nested\n        inside another. This means that we are not using the HTMX annotations\n        correctly, and shows why this kind of test can be valuable. We add the\n        missing annotation\u003c/p\u003e\n\n\u003cp\u003eindex.tmpl\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;input\n      data-hx-post=\u0026#34;/toggle/{{.Id}}\u0026#34;\n      data-hx-target=\u0026#34;section.todoapp\u0026#34;\n\u003cspan\u003e      data-hx-swap=\u0026#34;outerHTML\u0026#34;\u003c/span\u003e\n      id=\u0026#34;checkbox-{{.Id}}\u0026#34;\n      class=\u0026#34;toggle\u0026#34;\n      type=\u0026#34;checkbox\u0026#34;\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003eThe default behaviour of HTMX is to replace the inner HTML of the\n        target element. The \u003ccode\u003edata-hx-swap=”outerHTML”\u003c/code\u003e annotation\n        tells HTMX to replace the outer HTML instead.\u003c/p\u003e\n\n\u003cp\u003eand we test again, and this time it passes!\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  === RUN   Test_toggleTodoItem\n  \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n  \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n  \u0026gt;\u0026gt; GET https://unpkg.com/htmx.org@1.9.12\n  \u0026lt;\u0026lt; 200 https://unpkg.com/htmx.org@1.9.12\n  Loaded: http://localhost:4567/index.html\n  \u0026gt;\u0026gt; POST http://localhost:4567/toggle/101\n  \u0026lt;\u0026lt; 200 http://localhost:4567/toggle/101\n  --- PASS: Test_toggleTodoItem (1.39s)\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  IndexBehaviourTest \u0026gt; toggleTodoItem() STANDARD_OUT\n      \u0026gt;\u0026gt; GET http://localhost:4567/index.html\n      \u0026lt;\u0026lt; 200 http://localhost:4567/index.html\n      \u0026gt;\u0026gt; GET https://unpkg.com/htmx.org@1.9.12\n      \u0026lt;\u0026lt; 200 https://unpkg.com/htmx.org@1.9.12\n      Loaded: http://localhost:4567/index.html\n      \u0026gt;\u0026gt; POST http://localhost:4567/toggle/101\n      \u0026lt;\u0026lt; 200 http://localhost:4567/toggle/101\n  \n  IndexBehaviourTest \u0026gt; toggleTodoItem() PASSED\u003c/pre\u003e\n\n\u003cp\u003eIn this section we saw how to write a test for the behaviour of our\n        HTML that, while using the complicated machinery of a headless browser,\n        still feels more like a unit test than an integration test. It is in\n        fact testing just an HTML page with any associated CSS and JavaScript,\n        in isolation from other parts of the application such as controllers,\n        services or repositories.\u003c/p\u003e\n\n\u003cp\u003eThe test costs 2-3 seconds of waiting time for the headless browser to come up, which is usually too much for a unit test; however, like a unit test, it is very stable, as it is not flaky, and its failures are documented with a relatively clear error message.\u003c/p\u003e\n\n\u003cp\u003eSee the final version of the test \u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/d80394498b23698d295976b9521c369393dcaf31/go/index_behaviour_test.go\"\u003ein Go\u003c/a\u003e and \u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/7bc57fb9c505f9ccc420014fce9e10d6b2245326/java/src/test/java/org/example/IndexBehaviourTest.java\"\u003ein Java\u003c/a\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"BonusLevelStringlyAsserted\"\u003e\n\u003ch2\u003eBonus level: \u003ci\u003eStringly asserted\u003c/i\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://luontola.fi/about\"\u003eEsko Luontola\u003c/a\u003e, TDD expert and author of the online course \u003ca href=\"https://tdd.mooc.fi/\"\u003etdd.mooc.fi\u003c/a\u003e, \u003ca href=\"https://x.com/EskoLuontola/status/1793950013816713691\"\u003esuggested an alternative\u003c/a\u003e to testing HTML with CSS selectors: the idea is to transform HTML into a human-readable canonical form.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026#39;s take for example this snippet of generated HTML:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n  \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input id=\u0026#34;checkbox-100\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label for=\u0026#34;checkbox-100\u0026#34;\u0026gt;One\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li class=\u0026#34;\u0026#34;\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input id=\u0026#34;checkbox-200\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label for=\u0026#34;checkbox-200\u0026#34;\u0026gt;Two\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n  \u0026lt;li class=\u0026#34;completed\u0026#34;\u0026gt;\n    \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n      \u0026lt;input id=\u0026#34;checkbox-300\u0026#34; class=\u0026#34;toggle\u0026#34; type=\u0026#34;checkbox\u0026#34;\u0026gt;\n      \u0026lt;label for=\u0026#34;checkbox-300\u0026#34;\u0026gt;Three\u0026lt;/label\u0026gt;\n      \u0026lt;button class=\u0026#34;destroy\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  \u0026lt;/li\u0026gt;\n\u0026lt;/ul\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eWe could visualize the above HTML by:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003edeleting all HTML tags\u003c/li\u003e\n\n\u003cli\u003ereducing every sequence of whitespace characters to a single blank\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eto arrive at:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eOne Two Three\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eThis, however, removes too much of the HTML structure to be useful. For instance, it does not let us distinguish between active and completed items. Some HTML element represent visible content: for instance\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026lt;input value=\u0026#34;foo\u0026#34; /\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eshows a text box with the word “foo” that is an important part of the  way we perceive HTML. To visualize those elements, Esko suggests to add a \u003ccode\u003edata-test-icon\u003c/code\u003e attribute that supplies some text to be used in place of the element when visualizing it for testing.  With this,\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026lt;input value=\u0026#34;foo\u0026#34; data-test-icon=\u0026#34;[foo]\u0026#34; /\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003ethe input element is visualized as \u003ccode\u003e[foo]\u003c/code\u003e, with the square brackets hinting that the word “foo” sits inside an editable text box. Now if we add test-icons to our HTML template,\u003c/p\u003e\n\n\u003cp\u003eGo -- Java is similar\n\u003c/p\u003e\n\n\u003cpre\u003e  \u0026lt;ul class=\u0026#34;todo-list\u0026#34;\u0026gt;\n      {{ range .model.AllItems }}\n      \u0026lt;li class=\u0026#34;{{ if .IsCompleted }}completed{{ end }}\u0026#34;\u0026gt;\n          \u0026lt;div class=\u0026#34;view\u0026#34;\u0026gt;\n              \u0026lt;input data-hx-post=\u0026#34;/toggle/{{ .Id }}\u0026#34;\n                     data-hx-target=\u0026#34;section.todoapp\u0026#34;\n                     data-hx-swap=\u0026#34;outerHTML\u0026#34;\n                     id=\u0026#34;checkbox-{{ .Id }}\u0026#34;\n                     class=\u0026#34;toggle\u0026#34;\n                     type=\u0026#34;checkbox\u0026#34;\n                     \u003cspan\u003edata-test-icon=\u0026#34;{{ if .IsCompleted }}✅{{ else }}⬜{{ end }}\u0026#34;\u003c/span\u003e\u0026gt;\n              \u0026lt;label for=\u0026#34;checkbox-{{ .Id }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/label\u0026gt;\n              \u0026lt;button class=\u0026#34;destroy\u0026#34; \u003cspan\u003edata-test-icon=\u0026#34;❌️\u0026#34;\u003c/span\u003e\u0026gt;\u0026lt;/button\u0026gt;\n          \u0026lt;/div\u0026gt;\n      \u0026lt;/li\u0026gt;\n      {{ end }}\n  \u0026lt;/ul\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003ewe can assert against its canonical visual representation like this:\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func Test_visualize_html_example(t *testing.T) {\n    model := todo.NewList().\n      Add(\u0026#34;One\u0026#34;).\n      Add(\u0026#34;Two\u0026#34;).\n      AddCompleted(\u0026#34;Three\u0026#34;)\n  \n    buf := renderTemplate(\u0026#34;todo-list.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;)\n  \n\u003cspan\u003e    expected := `\u003c/span\u003e\n\u003cspan\u003e      ⬜ One ❌️\u003c/span\u003e\n\u003cspan\u003e      ⬜ Two ❌️\u003c/span\u003e\n\u003cspan\u003e      ✅ Three ❌️\u003c/span\u003e\n      `\n    assert.Equal(t, \u003cspan\u003enormalizeWhitespace\u003c/span\u003e(expected), \u003cspan\u003evisualizeHtml\u003c/span\u003e(buf.String()))\n  }\u003c/pre\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  @Test\n  void visualize_html_example() {\n      var model = new TodoList()\n              .add(\u0026#34;One\u0026#34;)\n              .add(\u0026#34;Two\u0026#34;)\n              .addCompleted(\u0026#34;Three\u0026#34;);\n  \n      var html = renderTemplate(\u0026#34;/todo-list.tmpl\u0026#34;, model, \u0026#34;/\u0026#34;);\n  \n      assertThat(\u003cspan\u003evisualizeHtml\u003c/span\u003e(html))\n              .isEqualTo(\u003cspan\u003enormalizeWhitespace\u003c/span\u003e(\u0026#34;\u0026#34;\u0026#34;\n\u003cspan\u003e                      ⬜ One ❌️\u003c/span\u003e\n\u003cspan\u003e                      ⬜ Two ❌️\u003c/span\u003e\n\u003cspan\u003e                      ✅ Three ❌️\u003c/span\u003e\n                      \u0026#34;\u0026#34;\u0026#34;));\n  }\u003c/pre\u003e\n\n\u003cp\u003eHere is Esko Luontola\u0026#39;s Java implementation of the two functions that make this possible, and my translation to Go of his code.\u003c/p\u003e\n\n\u003cp\u003eGo\n\u003c/p\u003e\n\n\u003cpre\u003e  func visualizeHtml(html string) string {\n    //  custom visualization using data-test-icon attribute\n    html = replaceAll(html, \u0026#34;\u0026lt;[^\u0026lt;\u0026gt;]+\\\\bdata-test-icon=\\\u0026#34;(.*?)\\\u0026#34;.*?\u0026gt;\u0026#34;, \u0026#34; $1 \u0026#34;)\n    // strip all HTML tags: inline elements\n    html = replaceAll(html, \u0026#34;\u0026lt;/?(a|abbr|b|big|cite|code|em|i|small|span|strong|tt)\\\\b.*?\u0026gt;\u0026#34;, \u0026#34;\u0026#34;)\n    // strip all HTML tags: block elements\n    html = replaceAll(html, \u0026#34;\u0026lt;[^\u0026gt;]*\u0026gt;\u0026#34;, \u0026#34; \u0026#34;)\n    // replace HTML character entities\n    html = replaceAll(html, \u0026#34;\u0026amp;nbsp;\u0026#34;, \u0026#34; \u0026#34;)\n    html = replaceAll(html, \u0026#34;\u0026amp;lt;\u0026#34;, \u0026#34;\u0026lt;\u0026#34;)\n    html = replaceAll(html, \u0026#34;\u0026amp;gt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;)\n    html = replaceAll(html, \u0026#34;\u0026amp;quot;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;)\n    html = replaceAll(html, \u0026#34;\u0026amp;apos;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;)\n    html = replaceAll(html, \u0026#34;\u0026amp;amp;\u0026#34;, \u0026#34;\u0026amp;\u0026#34;)\n    return normalizeWhitespace(html)\n  }\n  \n  func normalizeWhitespace(s string) string {\n    return strings.TrimSpace(replaceAll(s, \u0026#34;\\\\s+\u0026#34;, \u0026#34; \u0026#34;))\n  }\n  \n  func replaceAll(src, regex, repl string) string {\n    re := regexp.MustCompile(regex)\n    return re.ReplaceAllString(src, repl)\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e9de5c6872d6273b19fa62d8df19762bfbd0e37b/go/html_util.go#L8\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eJava\n\u003c/p\u003e\n\n\u003cpre\u003e  public static String visualizeHtml(String html) {\n     //  custom visualization using data-test-icon attribute\n     html = html.replaceAll(\u0026#34;\u0026lt;[^\u0026lt;\u0026gt;]+\\\\bdata-test-icon=\\\u0026#34;(.*?)\\\u0026#34;.*?\u0026gt;\u0026#34;, \u0026#34; $1 \u0026#34;);\n     // strip all HTML tags\n     html = html.replaceAll(\u0026#34;\u0026lt;/?(a|abbr|b|big|cite|code|em|i|small|span|strong|tt)\\\\b.*?\u0026gt;\u0026#34;, \u0026#34;\u0026#34;) // inline elements\n             .replaceAll(\u0026#34;\u0026lt;[^\u0026gt;]*\u0026gt;\u0026#34;, \u0026#34; \u0026#34;);  // block elements\n     // replace HTML character entities\n     html = html.replaceAll(\u0026#34;\u0026amp;nbsp;\u0026#34;, \u0026#34; \u0026#34;)\n             .replaceAll(\u0026#34;\u0026amp;lt;\u0026#34;, \u0026#34;\u0026lt;\u0026#34;) // must be after stripping HTML tags, to avoid creating accidental elements\n             .replaceAll(\u0026#34;\u0026amp;gt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;)\n             .replaceAll(\u0026#34;\u0026amp;quot;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;)\n             .replaceAll(\u0026#34;\u0026amp;apos;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;)\n             .replaceAll(\u0026#34;\u0026amp;amp;\u0026#34;, \u0026#34;\u0026amp;\u0026#34;); // must be last, to avoid creating accidental character entities\n     return normalizeWhitespace(html);\n  }\n  \n  public static String normalizeWhitespace(String s) {\n     return s.replaceAll(\u0026#34;\\\\s+\u0026#34;, \u0026#34; \u0026#34;).trim();\n  }\u003c/pre\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/xpmatteo/tdd-html-templates/blob/e9de5c6872d6273b19fa62d8df19762bfbd0e37b/java/src/test/java/org/example/HtmUtil.java#L5\"\u003esource\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eIn this section, we have seen a technique for asserting HTML content that is an alternative to the CSS selector-based technique used in the rest of the article. Esko Luontola has reported great success with it, and I hope readers have success with it too!\u003c/p\u003e\n\n\u003cp\u003eThis technique of asserting against large, complicated data structures such as HTML pages by reducing them to a canonical string version has no name that I know of. Martin Fowler \u003ca href=\"https://x.com/martinfowler/status/1794052758544478245\"\u003esuggested\u003c/a\u003e “stringly asserted”, and from his suggestion comes the name of this section.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Conclusion\"\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eModern web applications often have very complicated templates. In my\n      experience, when we start testing these templates, we inevitably find\n      errors: the templates do not always produce the HTML we think. And often,\n      time is lost debugging the templates, when we could write automated tests\n      that do the testing for us instead.\u003c/p\u003e\n\n\u003cp\u003eWhat should we test then?\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eWhen we have an IF in a template, we should test the rendering of\n        the two cases: when the IF condition happens to be true, and when it\n        happens to be false\u003c/li\u003e\n\n\u003cli\u003eWhen we have an iteration over a list of items in a template, we\n        should test the rendering when the list is empty, and when it is\n        non-empty \u003c/li\u003e\n\n\u003cli\u003eWhen a part of the model we pass to the template might be\n        \u003ccode\u003enil\u003c/code\u003e (in Go) or \u003ccode\u003enull\u003c/code\u003e (in Java), we should test\n        the rendering with both a \u003ccode\u003enil/null\u003c/code\u003e value and with a\n        non-\u003ccode\u003enil/null\u003c/code\u003e value \u003c/li\u003e\n\n\u003cli\u003eIn all the above cases, we should test that the output of our\n        templates is sound HTML, and that the essential structure of the\n        generated HTML corresponds to what we think it should be\u003c/li\u003e\n\n\u003cli\u003eIf our HTML page has non-obvious behaviour implemented in\n        JavaScript or CSS, we might want to test it using a headless browser.\n        The techniques presented \u003ca href=\"#Level3TestingHtmlBehaviour\"\u003ein the\n        last section\u003c/a\u003e might make these tests cheaper.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis practice will not prevent \u003ci\u003eall\u003c/i\u003e errors, but will prevent\n      many errors that could result in our users seeing web pages that are\n      broken or incorrect.\u003c/p\u003e\n\n\u003cp\u003eIn conclusion, I think that automated testing of HTML templates makes\n      our work with web applications easier and safer. I hope we now see that\n      it\u0026#39;s easy (and fun!) to test them.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "73 min read",
  "publishedTime": null,
  "modifiedTime": "2024-06-05T00:00:00Z"
}
