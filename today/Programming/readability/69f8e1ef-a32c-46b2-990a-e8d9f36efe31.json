{
  "id": "69f8e1ef-a32c-46b2-990a-e8d9f36efe31",
  "title": "How to Write a Derived Table in jOOQ",
  "link": "https://blog.jooq.org/how-to-write-a-derived-table-in-jooq/",
  "description": "One of the more frequent questions about jOOQ is how to write a derived table (or a CTE). The jOOQ manual shows a simple example of a derived table: In SQL: In jOOQ: And that’s pretty much it. The question usually arises from the fact that there’s a surprising lack of type safety when working … Continue reading How to Write a Derived Table in jOOQ →",
  "author": "lukaseder",
  "published": "Fri, 24 Feb 2023 09:18:48 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "jooq-in-use",
    "sql",
    "cte",
    "derived table",
    "jooq",
    "Type safety"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 3147,
  "excerpt": "One of the more frequent questions about jOOQ is how to write a derived table (or a CTE). The jOOQ manual shows a simple example of a derived table: In SQL: SELECT nested.* FROM ( SELECT AUTHOR_ID,…",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "One of the more frequent questions about jOOQ is how to write a derived table (or a CTE). The jOOQ manual shows a simple example of a derived table: In SQL: SELECT nested.* FROM ( SELECT AUTHOR_ID, count(*) books FROM BOOK GROUP BY AUTHOR_ID ) nested ORDER BY nested.books DESC In jOOQ: // Declare the derived table up front: Table\u003c?\u003e nested = select(BOOK.AUTHOR_ID, count().as(\"books\")) .from(BOOK) .groupBy(BOOK.AUTHOR_ID).asTable(\"nested\"); // Then use it in SQL: ctx.select(nested.fields()) .from(nested) .orderBy(nested.field(\"books\")) .fetch(); And that’s pretty much it. The question usually arises from the fact that there’s a surprising lack of type safety when working with derived tables (or CTE, which are not that much different). Two things have to be understood: Unlike SQL, the Java language can reference an object that hasn’t been declared yet, lexically, so we have to declare the derived table before using it. Unlike generated code from the catalog, a derived table is just an expression, and there isn’t really a good way to add attributes to this expression, based on the expression’s structure, at least not in Java. That means that columns of a derived table aren’t dereferenceable in a type safe way. You can, however, reuse expressions, as shown below: // Declare a field expression up front: Field\u003cInteger\u003e count = count().as(\"books\"); // Then use it in the derived table: Table\u003c?\u003e nested = select(BOOK.AUTHOR_ID, count) .from(BOOK) .groupBy(BOOK.AUTHOR_ID).asTable(\"nested\"); // And use it as well in the outer query, when dereferencing a column: ctx.select(nested.fields()) .from(nested) .orderBy(nested.field(count)) .fetch(); Did you really need the derived table? A lot of times when I answer such questions on Stack Overflow or elsewhere, it becomes apparent that the derived table wasn’t needed in the first place. In fact, this very example from the jOOQ manual didn’t need any derived table! The SQL query can be simplified to this: SELECT AUTHOR_ID, count(*) books FROM BOOK GROUP BY AUTHOR_ID ORDER BY books DESC Nothing is lost by this simplification. Seeing when a simplification can take place might require some practice. It’s always good to be mindful of the logical order of operations in SQL, to make sure the resulting query is equivalent. But when it is, then it’s much easier to translate to jOOQ, because now, we can use generated code again, everywhere, and don’t have to rely on the less type safe dereferencing of columns from derived tables. Here’s the jOOQ equivalent: // We can still assign expressions to local variables Field\u003cInteger\u003e count = count().as(\"books\"); // And then use them in the query: ctx.select(BOOK.AUTHOR_ID, count) .from(BOOK) .groupBy(BOOK.AUTHOR_ID) .orderBy(count) .fetch(); Conclusion So, when you work with jOOQ and your query is sufficiently simple, then your question of How to write a derived table in jOOQ? Might be changed to: Did I need a derived table in the first place? That way, you can improve both your jOOQ query and your SQL query",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-11963\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eOne of the more frequent questions about jOOQ is how to write a derived table (or a CTE). The jOOQ manual shows \u003ca href=\"https://www.jooq.org/doc/latest/manual/sql-building/table-expressions/derived-tables/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/table-expressions/derived-tables/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ea simple example of a derived table\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eIn SQL:\u003c/strong\u003e\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT nested.*\nFROM (\n  SELECT AUTHOR_ID, count(*) books\n  FROM BOOK\n  GROUP BY AUTHOR_ID\n) nested\nORDER BY nested.books DESC\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003e\u003cstrong\u003eIn jOOQ:\u003c/strong\u003e\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// Declare the derived table up front:\nTable\u0026lt;?\u0026gt; nested =\n    select(BOOK.AUTHOR_ID, count().as(\u0026#34;books\u0026#34;))\n    .from(BOOK)\n    .groupBy(BOOK.AUTHOR_ID).asTable(\u0026#34;nested\u0026#34;);\n\n// Then use it in SQL:\nctx.select(nested.fields())\n   .from(nested)\n   .orderBy(nested.field(\u0026#34;books\u0026#34;))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd that’s pretty much it. The question usually arises from the fact that there’s a surprising lack of type safety when working with derived tables (or \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/with-clause/\" data-type=\"URL\" data-id=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-statements/with-clause/\" target=\"_blank\"\u003eCTE, which are not that much different\u003c/a\u003e). Two things have to be understood:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003eUnlike SQL, the Java language can reference an object that hasn’t been declared yet, lexically, so we have to declare the derived table \u003cem\u003ebefore \u003c/em\u003eusing it.\u003c/li\u003e\n\n\n\n\u003cli\u003eUnlike \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/why-you-should-use-jooq-with-code-generation/\" target=\"_blank\"\u003egenerated code\u003c/a\u003e from the catalog, a derived table is just an expression, and there isn’t really a good way to add attributes to this expression, based on the expression’s structure, at least not in Java. That means that columns of a derived table aren’t dereferenceable in a type safe way. You can, however, reuse expressions, as shown below:\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// Declare a field expression up front:\nField\u0026lt;Integer\u0026gt; count = count().as(\u0026#34;books\u0026#34;);\n\n// Then use it in the derived table:\nTable\u0026lt;?\u0026gt; nested =\n    select(BOOK.AUTHOR_ID, count)\n    .from(BOOK)\n    .groupBy(BOOK.AUTHOR_ID).asTable(\u0026#34;nested\u0026#34;);\n\n// And use it as well in the outer query, when dereferencing a column:\nctx.select(nested.fields())\n   .from(nested)\n   .orderBy(nested.field(count))\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eDid you really need the derived table?\u003c/h2\u003e\n\n\n\n\u003cp\u003eA lot of times when I answer s\u003ca rel=\"noreferrer noopener\" href=\"https://stackoverflow.com/q/75547771/521799\" data-type=\"URL\" data-id=\"https://stackoverflow.com/q/75547771/521799\" target=\"_blank\"\u003euch questions on Stack Overflow\u003c/a\u003e or elsewhere, it becomes apparent that the derived table wasn’t needed in the first place. In fact, this very example from the jOOQ manual didn’t need any derived table! The SQL query can be simplified to this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT AUTHOR_ID, count(*) books\nFROM BOOK\nGROUP BY AUTHOR_ID\nORDER BY books DESC\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNothing is lost by this simplification. Seeing when a simplification can take place might require some practice. It’s always good to be mindful of the \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/a-beginners-guide-to-the-true-order-of-sql-operations/\" data-type=\"URL\" data-id=\"https://blog.jooq.org/a-beginners-guide-to-the-true-order-of-sql-operations/\" target=\"_blank\"\u003elogical order of operations in SQL\u003c/a\u003e, to make sure the resulting query is equivalent. But when it is, then it’s much easier to translate to jOOQ, because now, we can use generated code again, everywhere, and don’t have to rely on the less type safe dereferencing of columns from derived tables. Here’s the jOOQ equivalent:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003e// We can still assign expressions to local variables\nField\u0026lt;Integer\u0026gt; count = count().as(\u0026#34;books\u0026#34;);\n\n// And then use them in the query:\nctx.select(BOOK.AUTHOR_ID, count)\n   .from(BOOK)\n   .groupBy(BOOK.AUTHOR_ID)\n   .orderBy(count)\n   .fetch();\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eSo, when you work with jOOQ and your query is sufficiently simple, then your question of\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eHow to write a derived table in jOOQ?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eMight be changed to:\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cp\u003eDid I need a derived table in the first place?\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eThat way, you can improve both your jOOQ query and your SQL query\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2023-02-24T09:18:48Z",
  "modifiedTime": "2023-02-24T09:18:48Z"
}
