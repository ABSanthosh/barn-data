{
  "id": "d6803ca2-bd00-4503-b1bc-e7e4aa062fb2",
  "title": "Codemods in other languages",
  "link": "https://martinfowler.com/articles/codemods-api-refactoring.html#CodemodsInOtherLanguages",
  "description": "",
  "author": "",
  "published": "2025-01-22T10:54:00-05:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": [
    "skip-home-page"
  ],
  "byline": "Juntao QIU | 邱俊涛",
  "length": 38226,
  "excerpt": "Using codemods to upgrade client code on API changes",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "As a library developer, you may create a popular utility that hundreds of thousands of developers rely on daily, such as lodash or React. Over time, usage patterns might emerge that go beyond your initial design. When this happens, you may need to extend an API by adding parameters or modifying function signatures to fix edge cases. The challenge lies in rolling out these breaking changes without disrupting your users’ workflows. This is where codemods come in—a powerful tool for automating large-scale code transformations, allowing developers to introduce breaking API changes, refactor legacy codebases, and maintain code hygiene with minimal manual effort. In this article, we’ll explore what codemods are and the tools you can use to create them, such as jscodeshift, hypermod.io, and codemod.com. We’ll walk through real-world examples, from cleaning up feature toggles to refactoring component hierarchies. You’ll also learn how to break down complex transformations into smaller, testable pieces—a practice known as codemod composition—to ensure flexibility and maintainability. By the end, you’ll see how codemods can become a vital part of your toolkit for managing large-scale codebases, helping you keep your code clean and maintainable while handling even the most challenging refactoring tasks. Breaking Changes in APIs Returning to the scenario of the library developer, after the initial release, new usage patterns emerge, prompting the need to extend an API—perhaps by adding a parameter or modifying a function signature to make it easier to use. For simple changes, a basic find-and-replace in the IDE might work. In more complex cases, you might resort to using tools like sed or awk. However, when your library is widely adopted, the scope of such changes becomes harder to manage. You can’t be sure how extensively the modification will impact your users, and the last thing you want is to break existing functionality that doesn’t need updating. A common approach is to announce the breaking change, release a new version, and ask users to migrate at their own pace. But this workflow, while familiar, often doesn't scale well, especially for major shifts. Consider React’s transition from class components to function components with hooks—a paradigm shift that took years for large codebases to fully adopt. By the time teams managed to migrate, more breaking changes were often already on the horizon. For library developers, this situation creates a burden. Maintaining multiple older versions to support users who haven’t migrated is both costly and time-consuming. For users, frequent changes risk eroding trust. They may hesitate to upgrade or start exploring more stable alternatives, which perpetuating the cycle. But what if you could help users manage these changes automatically? What if you could release a tool alongside your update that refactors their code for them—renaming functions, updating parameter order, and removing unused code without requiring manual intervention? That’s where codemods come in. Several libraries, including React and Next.js, have already embraced codemods to smooth the path for version bumps. For example, React provides codemods to handle the migration from older API patterns, like the old Context API, to newer ones. So, what exactly is the codemod we’re talking about here? What is a Codemod? A codemod (code modification) is an automated script used to transform code to follow new APIs, syntax, or coding standards. Codemods use Abstract Syntax Tree (AST) manipulation to apply consistent, large-scale changes across codebases. Initially developed at Facebook, codemods helped engineers manage refactoring tasks for large projects like React. As Facebook scaled, maintaining the codebase and updating APIs became increasingly difficult, prompting the development of codemods. Manually updating thousands of files across different repositories was inefficient and error-prone, so the concept of codemods—automated scripts that transform code—was introduced to tackle this problem. The process typically involves three main steps: Parsing the code into an AST, where each part of the code is represented as a tree structure. Modifying the tree by applying a transformation, such as renaming a function or changing parameters. Rewriting the modified tree back into the source code. By using this approach, codemods ensure that changes are applied consistently across every file in a codebase, reducing the chance of human error. Codemods can also handle complex refactoring scenarios, such as changes to deeply nested structures or removing deprecated API usage. If we visualize the process, it would look something like this: Figure 1: The three steps of a typical codemod process The idea of a program that can “understand” your code and then perform automatic transformations isn’t new. That’s how your IDE works when you run refactorings like Extract Function, Rename Variable, or Inline Function. Essentially, your IDE parses the source code into ASTs and applies predefined transformations to the tree, saving the result back into your files. For modern IDEs, many things happen under the hood to ensure changes are applied correctly and efficiently, such as determining the scope of the change and resolving conflicts like variable name collisions. Some refactorings even prompt you to input parameters, such as when using Change Function Declaration, where you can adjust the order of parameters or default values before finalizing the change. Use jscodeshift in JavaScript Codebases Let’s look at a concrete example to understand how we could run a codemod in a JavaScript project. The JavaScript community has several tools that make this work feasible, including parsers that convert source code into an AST, as well as transpilers that can transform the tree into other formats (this is how TypeScript works). Additionally, there are tools that help apply codemods to entire repositories automatically. One of the most popular tools for writing codemods is jscodeshift, a toolkit maintained by Facebook. It simplifies the creation of codemods by providing a powerful API to manipulate ASTs. With jscodeshift, developers can search for specific patterns in the code and apply transformations at scale. You can use jscodeshift to identify and replace deprecated API calls with updated versions across an entire project. Let’s break down a typical workflow for composing a codemod manually. Clean a Stale Feature Toggle Let’s start with a simple yet practical example to demonstrate the power of codemods. Imagine you’re using a feature toggle in your codebase to control the release of unfinished or experimental features. Once the feature is live in production and working as expected, the next logical step is to clean up the toggle and any related logic. For instance, consider the following code: const data = featureToggle('feature-new-product-list') ? { name: 'Product' } : undefined; Once the feature is fully released and no longer needs a toggle, this can be simplified to: const data = { name: 'Product' }; The task involves finding all instances of featureToggle in the codebase, checking whether the toggle refers to feature-new-product-list, and removing the conditional logic surrounding it. At the same time, other feature toggles (like feature-search-result-refinement, which may still be in development) should remain untouched. The codemod needs to understand the structure of the code to apply changes selectively. Understanding the AST Before we dive into writing the codemod, let’s break down how this specific code snippet looks in an AST. You can use tools like AST Explorer to visualize how source code and AST are mapped. It’s helpful to understand the node types you're interacting with before applying any changes. The image below shows the syntax tree in terms of ECMAScript syntax. It contains nodes like Identifier (for variables), StringLiteral (for the toggle name), and more abstract nodes like CallExpression and ConditionalExpression. Figure 2: The Abstract Syntax Tree representation of the feature toggle check In this AST representation, the variable data is assigned using a ConditionalExpression. The test part of the expression calls featureToggle('feature-new-product-list'). If the test returns true, the consequent branch assigns { name: 'Product' } to data. If false, the alternate branch assigns undefined. For a task with clear input and output, I prefer writing tests first, then implementing the codemod. I start by defining a negative case to ensure we don’t accidentally change things we want to leave untouched, followed by a real case that performs the actual conversion. I begin with a simple scenario, implement it, then add a variation (like checking if featureToggle is called inside an if statement), implement that case, and ensure all tests pass. This approach aligns well with Test-Driven Development (TDD), even if you don’t practice TDD regularly. Knowing exactly what the transformation's inputs and outputs are before coding improves safety and efficiency, especially when tweaking codemods. With jscodeshift, you can write tests to verify how the codemod behaves: const transform = require(\"../remove-feature-new-product-list\"); defineInlineTest( transform, {}, ` const data = featureToggle('feature-new-product-list') ? { name: 'Product' } : undefined; `, ` const data = { name: 'Product' }; `, \"delete the toggle feature-new-product-list in conditional operator\" ); The defineInlineTest function from jscodeshift allows you to define the input, expected output, and a string describing the test's intent. Now, running the test with a normal jest command will fail because the codemod isn’t written yet. The corresponding negative case would ensure the code remains unchanged for other feature toggles: defineInlineTest( transform, {}, ` const data = featureToggle('feature-search-result-refinement') ? { name: 'Product' } : undefined; `, ` const data = featureToggle('feature-search-result-refinement') ? { name: 'Product' } : undefined; `, \"do not change other feature toggles\" ); Writing the Codemod Let’s start by defining a simple transform function. Create a file called transform.js with the following code structure: module.exports = function(fileInfo, api, options) { const j = api.jscodeshift; const root = j(fileInfo.source); // manipulate the tree nodes here return root.toSource(); }; This function reads the file into a tree and uses jscodeshift’s API to query, modify, and update the nodes. Finally, it converts the AST back to source code with .toSource(). Now we can start implementing the transform steps: Find all instances of featureToggle. Verify that the argument passed is 'feature-new-product-list'. Replace the entire conditional expression with the consequent part, effectively removing the toggle. Here’s how we achieve this using jscodeshift: module.exports = function (fileInfo, api, options) { const j = api.jscodeshift; const root = j(fileInfo.source); // Find ConditionalExpression where the test is featureToggle('feature-new-product-list') root .find(j.ConditionalExpression, { test: { callee: { name: \"featureToggle\" }, arguments: [{ value: \"feature-new-product-list\" }], }, }) .forEach((path) =\u003e { // Replace the ConditionalExpression with the 'consequent' j(path).replaceWith(path.node.consequent); }); return root.toSource(); }; The codemod above: Finds ConditionalExpression nodes where the test calls featureToggle('feature-new-product-list'). Replaces the entire conditional expression with the consequent (i.e., { name: 'Product' }), removing the toggle logic and leaving simplified code behind. This example demonstrates how easy it is to create a useful transformation and apply it to a large codebase, significantly reducing manual effort. You’ll need to write more test cases to handle variations like if-else statements, logical expressions (e.g., !featureToggle('feature-new-product-list')), and so on to make the codemod robust in real-world scenarios. Once the codemod is ready, you can test it out on a target codebase, such as the one you're working on. jscodeshift provides a command-line tool that you can use to apply the codemod and report the results. $ jscodeshift -t transform-name src/ After validating the results, check that all functional tests still pass and that nothing breaks—even if you're introducing a breaking change. Once satisfied, you can commit the changes and raise a pull request as part of your normal workflow. Codemods Improve Code Quality and Maintainability Codemods aren’t just useful for managing breaking API changes—they can significantly improve code quality and maintainability. As codebases evolve, they often accumulate technical debt, including outdated feature toggles, deprecated methods, or tightly coupled components. Manually refactoring these areas can be time-consuming and error-prone. By automating refactoring tasks, codemods help keep your codebase clean and free of legacy patterns. Regularly applying codemods allows you to enforce new coding standards, remove unused code, and modernize your codebase without having to manually modify every file. Refactoring an Avatar Component Now, let’s look at a more complex example. Suppose you’re working with a design system that includes an Avatar component tightly coupled with a Tooltip. Whenever a user passes a name prop into the Avatar, it automatically wraps the avatar with a tooltip. Figure 3: A avatar component with a tooltip Here’s the current Avatar implementation: import { Tooltip } from \"@design-system/tooltip\"; const Avatar = ({ name, image }: AvatarProps) =\u003e { if (name) { return ( \u003cTooltip content={name}\u003e \u003cCircleImage image={image} /\u003e \u003c/Tooltip\u003e ); } return \u003cCircleImage image={image} /\u003e; }; The goal is to decouple the Tooltip from the Avatar component, giving developers more flexibility. Developers should be able to decide whether to wrap the Avatar in a Tooltip. In the refactored version, Avatar will simply render the image, and users can apply a Tooltip manually if needed. Here’s the refactored version of Avatar: const Avatar = ({ image }: AvatarProps) =\u003e { return \u003cCircleImage image={image} /\u003e; }; Now, users can manually wrap the Avatar with a Tooltip as needed: import { Tooltip } from \"@design-system/tooltip\"; import { Avatar } from \"@design-system/avatar\"; const UserProfile = () =\u003e { return ( \u003cTooltip content=\"Juntao Qiu\"\u003e \u003cAvatar image=\"/juntao.qiu.avatar.png\" /\u003e \u003c/Tooltip\u003e ); }; The challenge arises when there are hundreds of Avatar usages spread across the codebase. Manually refactoring each instance would be highly inefficient, so we can use a codemod to automate this process. Using tools like AST Explorer, we can inspect the component and see which nodes represent the Avatar usage we’re targeting. An Avatar component with both name and image props is parsed into an abstract syntax tree as shown below: Figure 4: AST of the Avatar component usage Writing the Codemod Let’s break down the transformation into smaller tasks: Find Avatar usage in the component tree. Check if the name prop is present. If not, do nothing. If present: Create a Tooltip node. Add the name to the Tooltip. Remove the name from Avatar. Add Avatar as a child of the Tooltip. Replace the original Avatar node with the new Tooltip. To begin, we’ll find all instances of Avatar (I’ll omit some of the tests, but you should write comparison tests first). defineInlineTest( { default: transform, parser: \"tsx\" }, {}, ` \u003cAvatar name=\"Juntao Qiu\" image=\"/juntao.qiu.avatar.png\" /\u003e `, ` \u003cTooltip content=\"Juntao Qiu\"\u003e \u003cAvatar image=\"/juntao.qiu.avatar.png\" /\u003e \u003c/Tooltip\u003e `, \"wrap avatar with tooltip when name is provided\" ); Similar to the featureToggle example, we can use root.find with search criteria to locate all Avatar nodes: root .find(j.JSXElement, { openingElement: { name: { name: \"Avatar\" } }, }) .forEach((path) =\u003e { // now we can handle each Avatar instance }); Next, we check if the name prop is present: root .find(j.JSXElement, { openingElement: { name: { name: \"Avatar\" } }, }) .forEach((path) =\u003e { const avatarNode = path.node; const nameAttr = avatarNode.openingElement.attributes.find( (attr) =\u003e attr.name.name === \"name\" ); if (nameAttr) { const tooltipElement = createTooltipElement( nameAttr.value.value, avatarNode ); j(path).replaceWith(tooltipElement); } }); For the createTooltipElement function, we use the jscodeshift API to create a new JSX node, with the name prop applied to the Tooltip and the Avatar component as a child. Finally, we call replaceWith to replace the current path. Here’s a preview of how it looks in Hypermod, where the codemod is written on the left. The top part on the right is the original code, and the bottom part is the transformed result: Figure 5: Run checks inside hypermod before apply it to your codebase This codemod searches for all instances of Avatar. If a name prop is found, it removes the name prop from Avatar, wraps the Avatar inside a Tooltip, and passes the name prop to the Tooltip. By now, I hope it’s clear that codemods are incredibly useful and that the workflow is intuitive, especially for large-scale changes where manual updates would be a huge burden. However, that's not the whole picture. In the next section, I’ll shed light on some of the challenges and how we can address these less-than-ideal aspects. Fixing Common Pitfalls of Codemods As a seasoned developer, you know the “happy path” is only a small part of the full picture. There are numerous scenarios to consider when writing a transformation script to handle code automatically. Developers write code in a variety of styles. For example, someone might import the Avatar component but give it a different name because they might have another Avatar component from a different package: import { Avatar as AKAvatar } from \"@design-system/avatar\"; const UserInfo = () =\u003e ( \u003cAKAvatar name=\"Juntao Qiu\" image=\"/juntao.qiu.avatar.png\" /\u003e ); A simple text search for Avatar won’t work in this case. You’ll need to detect the alias and apply the transformation using the correct name. Another example arises when dealing with Tooltip imports. If the file already imports Tooltip but uses an alias, the codemod must detect that alias and apply the changes accordingly. You can't assume that the component named Tooltip is always the one you’re looking for. In the feature toggle example, someone might use if(featureToggle('feature-new-product-list')), or assign the result of the toggle function to a variable before using it: const shouldEnableNewFeature = featureToggle('feature-new-product-list'); if (shouldEnableNewFeature) { //... } They might even use the toggle with other conditions or apply logical negation, making the logic more complex: const shouldEnableNewFeature = featureToggle('feature-new-product-list'); if (!shouldEnableNewFeature \u0026\u0026 someOtherLogic) { //... } These variations make it difficult to foresee every edge case, increasing the risk of unintentionally breaking something. Relying solely on the cases you can anticipate is not enough. You need thorough testing to avoid breaking unintended parts of the code. Leveraging Source Graphs and Test-Driven Codemods To handle these complexities, codemods should be used alongside other techniques. For instance, a few years ago, I participated in a design system components rewrite project at Atlassian. We addressed this issue by first searching the source graph, which contained the majority of internal component usage. This allowed us to understand how components were used, whether they were imported under different names, or whether certain public props were frequently used. After this search phase, we wrote our test cases upfront, ensuring we covered the majority of use cases, and then developed the codemod. In situations where we couldn't confidently automate the upgrade, we inserted comments or “TODOs” at the call sites. This allowed the developers running the script to handle specific cases manually. Usually, there were only a handful of such instances, so this approach still proved beneficial for upgrading versions. Utilizing Existing Code Standardization Tools As you can see, there are plenty of edge cases to handle, especially in codebases beyond your control—such as external dependencies. This complexity means that using codemods requires careful supervision and a review of the results. However, if your codebase has standardization tools in place, such as a linter that enforces a particular coding style, you can leverage these tools to reduce edge cases. By enforcing a consistent structure, tools like linters help narrow down the variations in code, making the transformation easier and minimizing unexpected issues. For instance, you could use linting rules to restrict certain patterns, such as avoiding nested conditional (ternary) operators or enforcing named exports over default exports. These rules help streamline the codebase, making codemods more predictable and effective. Additionally, breaking down complex transformations into smaller, more manageable ones allows you to tackle individual issues more precisely. As we'll soon see, composing smaller codemods can make handling complex changes more feasible. Codemod Composition Let’s revisit the feature toggle removal example discussed earlier. In the code snippet we have a toggle called feature-convert-new need to be removed: import { featureToggle } from \"./utils/featureToggle\"; const convertOld = (input: string) =\u003e { return input.toLowerCase(); }; const convertNew = (input: string) =\u003e { return input.toUpperCase(); }; const result = featureToggle(\"feature-convert-new\") ? convertNew(\"Hello, world\") : convertOld(\"Hello, world\"); console.log(result); The codemod for remove a given toggle works fine, and after running the codemod, we want the source to look like this: const convertNew = (input: string) =\u003e { return input.toUpperCase(); }; const result = convertNew(\"Hello, world\"); console.log(result); However, beyond removing the feature toggle logic, there are additional tasks to handle: Remove the unused convertOld function. Clean up the unused featureToggle import. Of course, you could write one big codemod to handle everything in a single pass and test it together. However, a more maintainable approach is to treat codemod logic like product code: break the task into smaller, independent pieces—just like how you would normally refactor production code. Breaking It Down We can break the big transformation down into smaller codemods and compose them. The advantage of this approach is that each transformation can be tested individually, covering different cases without interference. Moreover, it allows you to reuse and compose them for different purposes. For instance, you might break it down like this: A transformation to remove a specific feature toggle. Another transformation to clean up unused imports. A transformation to remove unused function declarations. By composing these, you can create a pipeline of transformations: import { removeFeatureToggle } from \"./remove-feature-toggle\"; import { removeUnusedImport } from \"./remove-unused-import\"; import { removeUnusedFunction } from \"./remove-unused-function\"; import { createTransformer } from \"./utils\"; const removeFeatureConvertNew = removeFeatureToggle(\"feature-convert-new\"); const transform = createTransformer([ removeFeatureConvertNew, removeUnusedImport, removeUnusedFunction, ]); export default transform; In this pipeline, the transformations work as follows: Remove the feature-convert-new toggle. Clean up the unused import statement. Remove the convertOld function since it’s no longer used. Figure 6: Compose transforms into a new transform You can also extract additional codemods as needed, combining them in various orders depending on the desired outcome. Figure 7: Put different transforms into a pipepline to form another transform The createTransformer Function The implementation of the createTransformer function is relatively straightforward. It acts as a higher-order function that takes a list of smaller transform functions, iterates through the list to apply them to the root AST, and finally converts the modified AST back into source code. import { API, Collection, FileInfo, JSCodeshift, Options } from \"jscodeshift\"; type TransformFunction = { (j: JSCodeshift, root: Collection): void }; const createTransformer = (transforms: TransformFunction[]) =\u003e (fileInfo: FileInfo, api: API, options: Options) =\u003e { const j = api.jscodeshift; const root = j(fileInfo.source); transforms.forEach((transform) =\u003e transform(j, root)); return root.toSource(options.printOptions || { quote: \"single\" }); }; export { createTransformer }; For example, you could have a transform function that inlines expressions assigning the feature toggle call to a variable, so in later transforms you don’t have to worry about those cases anymore: const shouldEnableNewFeature = featureToggle('feature-convert-new'); if (!shouldEnableNewFeature \u0026\u0026 someOtherLogic) { //... } Becomes this: if (!featureToggle('feature-convert-new') \u0026\u0026 someOtherLogic) { //... } Over time, you might build up a collection of reusable, smaller transforms, which can greatly ease the process of handling tricky edge cases. This approach proved highly effective in our work refining design system components. Once we converted one package—such as the button component—we had a few reusable transforms defined, like adding comments at the start of functions, removing deprecated props, or creating aliases when a package is already imported above. Each of these smaller transforms can be tested and used independently or combined for more complex transformations, which speeds up subsequent conversions significantly. As a result, our refinement work became more efficient, and these generic codemods are now applicable to other internal and even external React codebases. Since each transform is relatively standalone, you can fine-tune them without affecting other transforms or the more complex, composed ones. For instance, you might re-implement a transform to improve performance—like reducing the number of node-finding rounds—and with comprehensive test coverage, you can do this confidently and safely. Codemods in Other Languages While the examples we’ve explored so far focus on JavaScript and JSX using jscodeshift, codemods can also be applied to other languages. For instance, JavaParser offers a similar mechanism in Java, using AST manipulation to refactor Java code. Using JavaParser in a Java Codebase JavaParser can be useful for making breaking API changes or refactoring large Java codebases in a structured, automated way. Assume we have the following code in FeatureToggleExample.java, which checks the toggle feature-convert-new and branches accordingly: public class FeatureToggleExample { public void execute() { if (FeatureToggle.isEnabled(\"feature-convert-new\")) { newFeature(); } else { oldFeature(); } } void newFeature() { System.out.println(\"New Feature Enabled\"); } void oldFeature() { System.out.println(\"Old Feature\"); } } We can define a visitor to find if statements checking for FeatureToggle.isEnabled, and then replace them with the corresponding true branch—similar to how we handled the feature toggle codemod in JavaScript. // Visitor to remove feature toggles class FeatureToggleVisitor extends VoidVisitorAdapter\u003cVoid\u003e { @Override public void visit(IfStmt ifStmt, Void arg) { super.visit(ifStmt, arg); if (ifStmt.getCondition().isMethodCallExpr()) { MethodCallExpr methodCall = ifStmt.getCondition().asMethodCallExpr(); if (methodCall.getNameAsString().equals(\"isEnabled\") \u0026\u0026 methodCall.getScope().isPresent() \u0026\u0026 methodCall.getScope().get().toString().equals(\"FeatureToggle\")) { BlockStmt thenBlock = ifStmt.getThenStmt().asBlockStmt(); ifStmt.replace(thenBlock); } } } } This code defines a visitor pattern using JavaParser to traverse and manipulate the AST. The FeatureToggleVisitor looks for if statements that call FeatureToggle.isEnabled() and replaces the entire if statement with the true branch. You can also define visitors to find unused methods and remove them: class UnusedMethodRemover extends VoidVisitorAdapter\u003cVoid\u003e { private Set\u003cString\u003e calledMethods = new HashSet\u003c\u003e(); private List\u003cMethodDeclaration\u003e methodsToRemove = new ArrayList\u003c\u003e(); // Collect all called methods @Override public void visit(MethodCallExpr n, Void arg) { super.visit(n, arg); calledMethods.add(n.getNameAsString()); } // Collect methods to remove if not called @Override public void visit(MethodDeclaration n, Void arg) { super.visit(n, arg); String methodName = n.getNameAsString(); if (!calledMethods.contains(methodName) \u0026\u0026 !methodName.equals(\"main\")) { methodsToRemove.add(n); } } // After visiting, remove the unused methods public void removeUnusedMethods() { for (MethodDeclaration method : methodsToRemove) { method.remove(); } } } This code defines a visitor, UnusedMethodRemover, to detect and remove unused methods. It tracks all called methods in the calledMethods set and checks each method declaration. If a method isn’t called and isn’t main, it adds it to the list of methods to remove. Once all methods are processed, it removes any unused methods from the AST. Composing Java Visitors You can chain these visitors together and apply them to your codebase like so: public class FeatureToggleRemoverWithCleanup { public static void main(String[] args) { try { String filePath = \"src/test/java/com/example/Example.java\"; CompilationUnit cu = StaticJavaParser.parse(new FileInputStream(filePath)); // Apply transformations FeatureToggleVisitor toggleVisitor = new FeatureToggleVisitor(); cu.accept(toggleVisitor, null); UnusedMethodRemover remover = new UnusedMethodRemover(); cu.accept(remover, null); remover.removeUnusedMethods(); // Write the modified code back to the file try (FileOutputStream fos = new FileOutputStream(filePath)) { fos.write(cu.toString().getBytes()); } System.out.println(\"Code transformation completed successfully.\"); } catch (IOException e) { e.printStackTrace(); } } } Each visitor is a unit of transformation, and the visitor pattern in JavaParser makes it easy to compose them. OpenRewrite Another popular option for Java projects is OpenRewrite. It uses a different format of the source code tree called Lossless Semantic Trees (LSTs), which provide more detailed information compared to traditional AST (Abstract Syntax Tree) approaches used by tools like JavaParser or jscodeshift. While AST focuses on the syntactic structure, LSTs capture both syntax and semantic meaning, enabling more accurate and sophisticated transformations. OpenRewrite also has a robust ecosystem of open-source refactoring recipes for tasks such as framework migrations, security fixes, and maintaining stylistic consistency. This built-in library of recipes can save developers significant time by allowing them to apply standardized transformations across large codebases without needing to write custom scripts. For developers who need customized transformations, OpenRewrite allows you to create and distribute your own recipes, making it a highly flexible and extensible tool. It’s widely used in the Java community and is gradually expanding into other languages, thanks to its advanced capabilities and community-driven approach. Differences Between OpenRewrite and JavaParser or jscodeshift The key difference between OpenRewrite and tools like JavaParser or jscodeshift lies in their approach to code transformation: OpenRewrite’s Lossless Semantic Trees (LSTs) capture both the syntactic and semantic meaning of the code, enabling more accurate transformations. JavaParser and jscodeshift rely on traditional ASTs, which focus primarily on the syntactic structure. While powerful, they may not always capture the nuances of how the code behaves semantically. Additionally, OpenRewrite offers a large library of community-driven refactoring recipes, making it easier to apply common transformations without needing to write custom codemods from scratch. Other Tools for Codemods While jscodeshift and OpenRewrite are powerful tools, there are other options worth considering, depending on your needs and the ecosystem you're working in. Hypermod Hypermod introduces AI assistance to the codemod writing process. Instead of manually crafting the codemod logic, developers can describe the desired transformation in plain English, and Hypermod will generate the codemod using jscodeshift. This makes codemod creation more accessible, even for developers who may not be familiar with AST manipulation. You can compose, test, and deploy a codemod to any repository connected to Hypermod. It can run the codemod and generate a pull request with the proposed changes, allowing you to review and approve them. This integration makes the entire process from codemod development to deployment much more streamlined. Codemod.com Codemod.com is a community-driven platform where developers can share and discover codemods. If you need a specific codemod for a common refactoring task or migration, you can search for existing codemods. Alternatively, you can publish codemods you’ve created to help others in the developer community. If you're migrating an API and need a codemod to handle it, Codemod.com can save you time by offering pre-built codemods for many common transformations, reducing the need to write one from scratch. Conclusion Codemods are powerful tools that allow developers to automate code transformations, making it easier to manage API changes, refactor legacy code, and maintain consistency across large codebases with minimal manual intervention. By using tools like jscodeshift, Hypermod, or OpenRewrite, developers can streamline everything from minor syntax changes to major component rewrites, improving overall code quality and maintainability. However, while codemods offer significant benefits, they are not without challenges. One of the key concerns is handling edge cases, particularly when the codebase is diverse or publicly shared. Variations in coding styles, import aliases, or unexpected patterns can lead to issues that codemods may not handle automatically. These edge cases require careful planning, thorough testing, and, in some instances, manual intervention to ensure accuracy. To maximize the effectiveness of codemods, it’s crucial to break complex transformations into smaller, testable steps and to use code standardization tools where possible. Codemods can be highly effective, but their success depends on thoughtful design and understanding the limitations they may face in more varied or complex codebases.",
  "image": "https://martinfowler.com/articles/codemods-api-refactoring/card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eAs a library developer, you may create a popular utility that hundreds of\n    thousands of developers rely on daily, such as lodash or React. Over time,\n    usage patterns might emerge that go beyond your initial design. When this\n    happens, you may need to extend an API by adding parameters or modifying\n    function signatures to fix edge cases. The challenge lies in rolling out\n    these breaking changes without disrupting your users’ workflows.\u003c/p\u003e\n\n\u003cp\u003eThis is where \u003ci\u003ecodemods\u003c/i\u003e come in—a powerful tool for automating\n    large-scale code transformations, allowing developers to introduce breaking\n    API changes, refactor legacy codebases, and maintain code hygiene with\n    minimal manual effort.\u003c/p\u003e\n\n\u003cp\u003eIn this article, we’ll explore what codemods are and the tools you can\n    use to create them, such as \u003ca href=\"https://github.com/facebook/jscodeshift\"\u003ejscodeshift\u003c/a\u003e, \u003ca href=\"https://www.hypermod.io/\"\u003ehypermod.io\u003c/a\u003e, and \u003ca href=\"http://codemod.com/\"\u003ecodemod.com\u003c/a\u003e. We’ll walk through real-world examples,\n    from cleaning up feature toggles to refactoring component hierarchies.\n    You’ll also learn how to break down complex transformations into smaller,\n    testable pieces—a practice known as codemod composition—to ensure\n    flexibility and maintainability.\u003c/p\u003e\n\n\u003cp\u003eBy the end, you’ll see how codemods can become a vital part of your\n    toolkit for managing large-scale codebases, helping you keep your code clean\n    and maintainable while handling even the most challenging refactoring\n    tasks.\u003c/p\u003e\n\n\u003csection id=\"BreakingChangesInApis\"\u003e\n\u003ch2\u003eBreaking Changes in APIs\u003c/h2\u003e\n\n\u003cp\u003eReturning to the scenario of the library developer, after the initial\n      release, new usage patterns emerge, prompting the need to extend an\n      API—perhaps by adding a parameter or modifying a function signature to\n      make it easier to use.\u003c/p\u003e\n\n\u003cp\u003eFor simple changes, a basic find-and-replace in the IDE might work. In\n      more complex cases, you might resort to using tools like \u003ccode\u003esed\u003c/code\u003e\n      or \u003ccode\u003eawk\u003c/code\u003e. However, when your library is widely adopted, the\n      scope of such changes becomes harder to manage. You can’t be sure how\n      extensively the modification will impact your users, and the last thing\n      you want is to break existing functionality that doesn’t need\n      updating.\u003c/p\u003e\n\n\u003cp\u003eA common approach is to announce the breaking change, release a new\n      version, and ask users to migrate at their own pace. But this workflow,\n      while familiar, often doesn\u0026#39;t scale well, especially for major shifts.\n      Consider React’s transition from class components to function components\n      with hooks—a paradigm shift that took years for large codebases to fully\n      adopt. By the time teams managed to migrate, more breaking changes were\n      often already on the horizon.\u003c/p\u003e\n\n\u003cp\u003eFor library developers, this situation creates a burden. Maintaining\n      multiple older versions to support users who haven’t migrated is both\n      costly and time-consuming. For users, frequent changes risk eroding trust.\n      They may hesitate to upgrade or start exploring more stable alternatives,\n      which perpetuating the cycle.\u003c/p\u003e\n\n\u003cp\u003eBut what if you could help users manage these changes automatically?\n      What if you could release a tool alongside your update that refactors\n      their code for them—renaming functions, updating parameter order, and\n      removing unused code without requiring manual intervention?\u003c/p\u003e\n\n\u003cp\u003eThat’s where codemods come in. Several libraries, including React\n      and Next.js, have already embraced codemods to smooth the path for version\n      bumps. For example, React provides codemods to handle the migration from\n      older API patterns, like the old Context API, to newer ones.\u003c/p\u003e\n\n\u003cp\u003eSo, what exactly is the codemod we’re talking about here?\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"WhatIsACodemod\"\u003e\n\u003ch2\u003eWhat is a Codemod?\u003c/h2\u003e\n\n\u003cp\u003eA \u003cb\u003ecodemod\u003c/b\u003e (code modification) is an automated script used to transform\n      code to follow new APIs, syntax, or coding standards. Codemods use\n      Abstract Syntax Tree (AST) manipulation to apply consistent, large-scale\n      changes across codebases. Initially developed at Facebook, codemods helped\n      engineers manage refactoring tasks for large projects like React. As\n      Facebook scaled, maintaining the codebase and updating APIs became\n      increasingly difficult, prompting the development of codemods.\u003c/p\u003e\n\n\u003cp\u003eManually updating thousands of files across different repositories was\n      inefficient and error-prone, so the concept of codemods—automated scripts\n      that transform code—was introduced to tackle this problem.\u003c/p\u003e\n\n\u003cp\u003eThe process typically involves three main steps:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ci\u003eParsing\u003c/i\u003e the code into an AST, where each part of the code is\n        represented as a tree structure.\u003c/li\u003e\n\n\u003cli\u003e\u003ci\u003eModifying\u003c/i\u003e the tree by applying a transformation, such as renaming a\n        function or changing parameters.\u003c/li\u003e\n\n\u003cli\u003e\u003ci\u003eRewriting\u003c/i\u003e the modified tree back into the source code.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eBy using this approach, codemods ensure that changes are applied\n      consistently across every file in a codebase, reducing the chance of human\n      error. Codemods can also handle complex refactoring scenarios, such as\n      changes to deeply nested structures or removing deprecated API usage.\u003c/p\u003e\n\n\u003cp\u003eIf we visualize the process, it would look something like this:\u003c/p\u003e\n\n\u003cdiv id=\"codemod-process.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/codemod-process.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 1: The three steps of a typical codemod process\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThe idea of a program that can “understand” your code and then perform\n      automatic transformations isn’t new. That’s how your IDE works when you\n      run refactorings like \u003ca href=\"http://refactoring.com/catalog/extractFunction.html\"\u003e\u003cname\u003eExtract Function\u003c/name\u003e\u003c/a\u003e, \u003ca href=\"http://refactoring.com/catalog/renameVariable.html\"\u003e\u003cname\u003eRename Variable\u003c/name\u003e\u003c/a\u003e, or \u003ca href=\"http://refactoring.com/catalog/inlineFunction.html\"\u003e\u003cname\u003eInline Function\u003c/name\u003e\u003c/a\u003e.\n      Essentially, your IDE parses the source code into ASTs and applies\n      predefined transformations to the tree, saving the result back into your\n      files.\u003c/p\u003e\n\n\u003cp\u003eFor modern IDEs, many things happen under the hood to ensure changes\n      are applied correctly and efficiently, such as determining the scope of\n      the change and resolving conflicts like variable name collisions. Some\n      refactorings even prompt you to input parameters, such as when using\n      \u003ca href=\"http://refactoring.com/catalog/changeFunctionDeclaration.html\"\u003e\u003cname\u003eChange Function Declaration\u003c/name\u003e\u003c/a\u003e, where you can adjust the\n      order of parameters or default values before finalizing the change.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UseJscodeshiftInJavascriptCodebases\"\u003e\n\u003ch2\u003eUse jscodeshift in JavaScript Codebases\u003c/h2\u003e\n\n\u003cp\u003eLet’s look at a concrete example to understand how we could run a\n      codemod in a JavaScript project. The JavaScript community has several\n      tools that make this work feasible, including parsers that convert source\n      code into an AST, as well as transpilers that can transform the tree into\n      other formats (this is how TypeScript works). Additionally, there are\n      tools that help apply codemods to entire repositories automatically.\u003c/p\u003e\n\n\u003cp\u003eOne of the most popular tools for writing codemods is \u003ca href=\"https://github.com/facebook/jscodeshift\"\u003ejscodeshift\u003c/a\u003e, a toolkit maintained by Facebook.\n      It simplifies the creation of codemods by providing a powerful API to\n      manipulate ASTs. With jscodeshift, developers can search for specific\n      patterns in the code and apply transformations at scale.\u003c/p\u003e\n\n\u003cp\u003eYou can use \u003ccode\u003ejscodeshift\u003c/code\u003e to identify and replace deprecated API calls\n      with updated versions across an entire project.\u003c/p\u003e\n\n\u003cp\u003eLet’s break down a typical workflow for composing a codemod\n      manually.\u003c/p\u003e\n\n\u003csection id=\"feature-toggle-example\"\u003e\n\u003ch3\u003eClean a Stale Feature Toggle\u003c/h3\u003e\n\n\u003cp\u003eLet’s start with a simple yet practical example to demonstrate the\n        power of codemods. Imagine you’re using a \u003ca href=\"https://martinfowler.com/articles/feature-toggles.html\"\u003efeature\n        toggle\u003c/a\u003e in your\n        codebase to control the release of unfinished or experimental features.\n        Once the feature is live in production and working as expected, the next\n        logical step is to clean up the toggle and any related logic.\u003c/p\u003e\n\n\u003cp\u003eFor instance, consider the following code:\u003c/p\u003e\n\n\u003cpre\u003econst data = featureToggle(\u0026#39;feature-new-product-list\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n\u003c/pre\u003e\n\n\u003cp\u003eOnce the feature is fully released and no longer needs a toggle, this\n        can be simplified to:\u003c/p\u003e\n\n\u003cpre\u003econst data = { name: \u0026#39;Product\u0026#39; };\n\u003c/pre\u003e\n\n\u003cp\u003eThe task involves finding all instances of \u003ccode\u003efeatureToggle\u003c/code\u003e in the\n        codebase, checking whether the toggle refers to\n        \u003ccode\u003efeature-new-product-list\u003c/code\u003e, and removing the conditional logic surrounding\n        it. At the same time, other feature toggles (like\n        \u003ccode\u003efeature-search-result-refinement\u003c/code\u003e, which may still be in development)\n        should remain untouched. The codemod needs to \u003ci\u003eunderstand\u003c/i\u003e the structure\n        of the code to apply changes selectively.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UnderstandingTheAst\"\u003e\n\u003ch3\u003eUnderstanding the AST\u003c/h3\u003e\n\n\u003cp\u003eBefore we dive into writing the codemod, let’s break down how this\n        specific code snippet looks in an AST. You can use tools like \u003ca href=\"https://astexplorer.net/\"\u003eAST\n        Explorer\u003c/a\u003e to visualize how source code and AST\n        are mapped. It’s helpful to understand the node types you\u0026#39;re interacting\n        with before applying any changes.\u003c/p\u003e\n\n\u003cp\u003eThe image below shows the syntax tree in terms of ECMAScript syntax. It\n        contains nodes like \u003ccode\u003eIdentifier\u003c/code\u003e (for variables), \u003ccode\u003eStringLiteral\u003c/code\u003e (for the\n        toggle name), and more abstract nodes like \u003ccode\u003eCallExpression\u003c/code\u003e and\n        \u003ccode\u003eConditionalExpression\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv id=\"ast-feature-toggle.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/ast-feature-toggle.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 2: The Abstract Syntax Tree representation of the feature toggle check\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eIn this AST representation, the variable \u003ccode\u003edata\u003c/code\u003e is assigned using a\n        \u003ccode\u003eConditionalExpression\u003c/code\u003e. The \u003ci\u003etest\u003c/i\u003e part of the expression calls\n        \u003ccode\u003efeatureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e. If the test returns \u003ccode\u003etrue\u003c/code\u003e,\n        the \u003ci\u003econsequent\u003c/i\u003e branch assigns \u003ccode\u003e{ name: \u0026#39;Product\u0026#39; }\u003c/code\u003e to \u003ccode\u003edata\u003c/code\u003e. If\n        \u003ccode\u003efalse\u003c/code\u003e, the \u003ci\u003ealternate\u003c/i\u003e branch assigns \u003ccode\u003eundefined\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor a task with clear input and output, I prefer writing tests first,\n        then implementing the codemod. I start by defining a negative case to\n        ensure we don’t accidentally change things we want to leave untouched,\n        followed by a real case that performs the actual conversion. I begin with\n        a simple scenario, implement it, then add a variation (like checking if\n        featureToggle is called inside an if statement), implement that case, and\n        ensure all tests pass.\u003c/p\u003e\n\n\u003cp\u003eThis approach aligns well with \u003ca href=\"https://martinfowler.com/bliki/TestDrivenDevelopment.html\"\u003eTest-Driven Development (TDD)\u003c/a\u003e, even\n        if you don’t practice TDD regularly. Knowing exactly what the\n        transformation\u0026#39;s inputs and outputs are before coding improves safety and\n        efficiency, especially when tweaking codemods.\u003c/p\u003e\n\n\u003cp\u003eWith jscodeshift, you can write tests to verify how the codemod\n        behaves:\u003c/p\u003e\n\n\u003cpre\u003econst \u003cspan\u003etransform\u003c/span\u003e = require(\u0026#34;../remove-feature-new-product-list\u0026#34;);\n\ndefineInlineTest(\n  \u003cspan\u003etransform\u003c/span\u003e,\n  {},\n  `\n  const data = featureToggle(\u0026#39;feature-new-product-list\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  `\n  const data = { name: \u0026#39;Product\u0026#39; };\n  `,\n  \u0026#34;delete the toggle feature-new-product-list in conditional operator\u0026#34;\n);\n\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003edefineInlineTest\u003c/code\u003e function from jscodeshift allows you to define\n        the input, expected output, and a string describing the test\u0026#39;s intent.\n        Now, running the test with a normal \u003ccode\u003ejest\u003c/code\u003e command will fail because the\n        codemod isn’t written yet.\u003c/p\u003e\n\n\u003cp\u003eThe corresponding negative case would ensure the code remains \u003ci\u003eunchanged\u003c/i\u003e\n        for other feature toggles:\u003c/p\u003e\n\n\u003cpre\u003edefineInlineTest(\n  transform,\n  {},\n  `\n  const data = featureToggle(\u0026#39;feature-search-result-refinement\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  `\n  const data = featureToggle(\u0026#39;feature-search-result-refinement\u0026#39;) ? { name: \u0026#39;Product\u0026#39; } : undefined;\n  `,\n  \u0026#34;do not change other feature toggles\u0026#34;\n);\n\u003c/pre\u003e\n\u003c/section\u003e\n\n\u003csection id=\"WritingTheCodemod\"\u003e\n\u003ch3\u003eWriting the Codemod\u003c/h3\u003e\n\n\u003cp\u003eLet’s start by defining a simple \u003ci\u003etransform\u003c/i\u003e function. Create a file\n        called \u003ccode\u003etransform.js\u003c/code\u003e with the following code structure:\u003c/p\u003e\n\n\u003cpre\u003emodule.exports = function(fileInfo, api, options) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n\n  // manipulate the tree nodes here\n\n  return root.toSource();\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis function reads the file into a tree and uses jscodeshift’s API to\n        query, modify, and update the nodes. Finally, it converts the AST back to\n        source code with \u003ccode\u003e.toSource()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNow we can start implementing the transform steps:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eFind all instances of \u003ccode\u003efeatureToggle\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eVerify that the argument passed is \u003ccode\u003e\u0026#39;feature-new-product-list\u0026#39;\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eReplace the entire conditional expression with the \u003ci\u003econsequent\u003c/i\u003e part,\n          effectively removing the toggle.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eHere’s how we achieve this using \u003ccode\u003ejscodeshift\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003emodule.exports = function (fileInfo, api, options) {\n  const j = api.jscodeshift;\n  const root = j(fileInfo.source);\n\n  // Find ConditionalExpression where the test is featureToggle(\u0026#39;feature-new-product-list\u0026#39;)\n  root\n    .find(j.ConditionalExpression, {\n      test: {\n        callee: { name: \u0026#34;featureToggle\u0026#34; },\n        arguments: [{ value: \u0026#34;feature-new-product-list\u0026#34; }],\n      },\n    })\n    .forEach((path) =\u0026gt; {\n      // Replace the ConditionalExpression with the \u0026#39;consequent\u0026#39;\n      j(path).replaceWith(path.node.consequent);\n    });\n\n  return root.toSource();\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe codemod above:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFinds \u003ccode\u003eConditionalExpression\u003c/code\u003e nodes where the test calls\n          \u003ccode\u003efeatureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003eReplaces the entire conditional expression with the consequent (i.e., \u003ccode\u003e{\n          name: \u0026#39;Product\u0026#39; }\u003c/code\u003e), removing the toggle logic and leaving simplified code\n          behind.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis example demonstrates how easy it is to create a useful\n        transformation and apply it to a large codebase, significantly reducing\n        manual effort.\u003c/p\u003e\n\n\u003cp\u003eYou’ll need to write more test cases to handle variations like\n        \u003ccode\u003eif-else\u003c/code\u003e statements, logical expressions (e.g.,\n        \u003ccode\u003e!featureToggle(\u0026#39;feature-new-product-list\u0026#39;)\u003c/code\u003e), and so on to make the\n        codemod robust in real-world scenarios.\u003c/p\u003e\n\n\u003cp\u003eOnce the codemod is ready, you can test it out on a target codebase,\n        such as the one you\u0026#39;re working on. jscodeshift provides a command-line\n        tool that you can use to apply the codemod and report the results.\u003c/p\u003e\n\n\u003cpre\u003e$ jscodeshift -t transform-name src/\n\u003c/pre\u003e\n\n\u003cp\u003eAfter validating the results, check that all functional tests still\n        pass and that nothing breaks—even if you\u0026#39;re introducing a breaking change.\n        Once satisfied, you can commit the changes and raise a pull request as\n        part of your normal workflow.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"CodemodsImproveCodeQualityAndMaintainability\"\u003e\n\u003ch3\u003eCodemods Improve Code Quality and Maintainability\u003c/h3\u003e\n\n\u003cp\u003eCodemods aren’t just useful for managing breaking API changes—they can\n        significantly improve code quality and maintainability. As codebases\n        evolve, they often accumulate technical debt, including outdated feature\n        toggles, deprecated methods, or tightly coupled components. Manually\n        refactoring these areas can be time-consuming and error-prone.\u003c/p\u003e\n\n\u003cp\u003eBy automating refactoring tasks, codemods help keep your codebase clean\n        and free of legacy patterns. Regularly applying codemods allows you to\n        enforce new coding standards, remove unused code, and modernize your\n        codebase without having to manually modify every file.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"RefactoringAnAvatarComponent\"\u003e\n\u003ch3\u003eRefactoring an Avatar Component\u003c/h3\u003e\n\n\u003cp\u003eNow, let’s look at a more complex example. Suppose you’re working with\n        a design system that includes an \u003ccode\u003eAvatar\u003c/code\u003e component tightly coupled with a\n        \u003ccode\u003eTooltip\u003c/code\u003e. Whenever a user passes a \u003ccode\u003ename\u003c/code\u003e prop into the \u003ccode\u003eAvatar\u003c/code\u003e, it\n        automatically wraps the avatar with a tooltip.\u003c/p\u003e\n\n\u003cdiv id=\"avatar-section.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/avatar-section.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 3: A avatar component with a tooltip\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eHere’s the current \u003ccode\u003eAvatar\u003c/code\u003e implementation:\u003c/p\u003e\n\n\u003cpre\u003eimport { Tooltip } from \u0026#34;@design-system/tooltip\u0026#34;;\n\nconst Avatar = ({ name, image }: AvatarProps) =\u0026gt; {\n  if (name) {\n    return (\n      \u0026lt;Tooltip content={name}\u0026gt;\n        \u0026lt;CircleImage image={image} /\u0026gt;\n      \u0026lt;/Tooltip\u0026gt;\n    );\n  }\n\n  return \u0026lt;CircleImage image={image} /\u0026gt;;\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe goal is to decouple the \u003ccode\u003eTooltip\u003c/code\u003e from the \u003ccode\u003eAvatar\u003c/code\u003e component,\n        giving developers more flexibility. Developers should be able to decide\n        whether to wrap the \u003ccode\u003eAvatar\u003c/code\u003e in a \u003ccode\u003eTooltip\u003c/code\u003e. In the refactored version,\n        \u003ccode\u003eAvatar\u003c/code\u003e will simply render the image, and users can apply a \u003ccode\u003eTooltip\u003c/code\u003e\n        manually if needed.\u003c/p\u003e\n\n\u003cp\u003eHere’s the refactored version of \u003ccode\u003eAvatar\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003econst Avatar = ({ image }: AvatarProps) =\u0026gt; {\n  return \u0026lt;CircleImage image={image} /\u0026gt;;\n};\n\u003c/pre\u003e\n\n\u003cp\u003eNow, users can manually wrap the \u003ccode\u003eAvatar\u003c/code\u003e with a \u003ccode\u003eTooltip\u003c/code\u003e as\n        needed:\u003c/p\u003e\n\n\u003cpre\u003eimport { Tooltip } from \u0026#34;@design-system/tooltip\u0026#34;;\nimport { Avatar } from \u0026#34;@design-system/avatar\u0026#34;;\n\nconst UserProfile = () =\u0026gt; {\n  return (\n    \u0026lt;Tooltip content=\u0026#34;Juntao Qiu\u0026#34;\u0026gt;\n      \u0026lt;Avatar image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    \u0026lt;/Tooltip\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe challenge arises when there are hundreds of Avatar usages spread\n        across the codebase. Manually refactoring each instance would be highly\n        inefficient, so we can use a codemod to automate this process.\u003c/p\u003e\n\n\u003cp\u003eUsing tools like \u003ca href=\"https://astexplorer.net/\"\u003eAST Explorer\u003c/a\u003e, we can\n        inspect the component and see which nodes represent the \u003ccode\u003eAvatar\u003c/code\u003e usage\n        we’re targeting. An \u003ccode\u003eAvatar\u003c/code\u003e component with both \u003ccode\u003ename\u003c/code\u003e and \u003ccode\u003eimage\u003c/code\u003e props \n        is parsed into an abstract syntax tree as shown below:\u003c/p\u003e\n\n\u003cdiv id=\"avatar-ast.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/avatar-ast.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 4: AST of the Avatar component usage\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"WritingTheCodemod\"\u003e\n\u003ch3\u003eWriting the Codemod\u003c/h3\u003e\n\n\u003cp\u003eLet’s break down the transformation into smaller tasks:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eFind \u003ccode\u003eAvatar\u003c/code\u003e usage in the component tree.\u003c/li\u003e\n\n\u003cli\u003eCheck if the \u003ccode\u003ename\u003c/code\u003e prop is present.\u003c/li\u003e\n\n\u003cul\u003e\n\u003cli\u003e If not, do nothing.\u003c/li\u003e\n\n\u003cli\u003e If present:\u003c/li\u003e\n\n\u003cul\u003e\n\u003cli\u003e Create a \u003ccode\u003eTooltip\u003c/code\u003e node.\u003c/li\u003e\n\n\u003cli\u003e Add the \u003ccode\u003ename\u003c/code\u003e to the \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Remove the \u003ccode\u003ename\u003c/code\u003e from \u003ccode\u003eAvatar\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Add \u003ccode\u003eAvatar\u003c/code\u003e as a child of the \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e Replace the original \u003ccode\u003eAvatar\u003c/code\u003e node with the new \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/li\u003e\n\n\u003cul\u003e\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo begin, we’ll find all instances of Avatar (I’ll omit some of the\n        tests, but you should write comparison tests first).\u003c/p\u003e\n\n\u003cpre\u003edefineInlineTest(\n    { default: transform, \u003cspan\u003eparser\u003c/span\u003e: \u0026#34;tsx\u0026#34; },\n    {},\n    `\n    \u0026lt;Avatar name=\u0026#34;Juntao Qiu\u0026#34; image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    `,\n    `\n    \u0026lt;Tooltip content=\u0026#34;Juntao Qiu\u0026#34;\u0026gt;\n      \u0026lt;Avatar image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n    \u0026lt;/Tooltip\u0026gt;\n    `,\n    \u0026#34;wrap avatar with tooltip when name is provided\u0026#34;\n  );\n\u003c/pre\u003e\n\n\u003cp\u003eSimilar to the \u003ccode\u003efeatureToggle\u003c/code\u003e example, we can use \u003ccode\u003eroot.find\u003c/code\u003e with\n        search criteria to locate all Avatar nodes:\u003c/p\u003e\n\n\u003cpre\u003eroot\n  .find(j.JSXElement, {\n    openingElement: { name: { name: \u0026#34;Avatar\u0026#34; } },\n  })\n  .forEach((path) =\u0026gt; {\n    // now we can handle each Avatar instance\n  });\n\u003c/pre\u003e\n\n\u003cp\u003eNext, we check if the \u003ccode\u003ename\u003c/code\u003e prop is present:\u003c/p\u003e\n\n\u003cpre\u003eroot\n  .find(j.JSXElement, {\n    openingElement: { name: { name: \u0026#34;Avatar\u0026#34; } },\n  })\n  .forEach((path) =\u0026gt; {\n    const avatarNode = path.node;\n\n    const nameAttr = avatarNode.openingElement.attributes.find(\n      (attr) =\u0026gt; attr.name.name === \u0026#34;name\u0026#34;\n    );\n\n    if (nameAttr) {\n      const tooltipElement = createTooltipElement(\n        nameAttr.value.value,\n        avatarNode\n      );\n      j(path).\u003cspan\u003ereplaceWith\u003c/span\u003e(tooltipElement);\n    }\n  });\n\u003c/pre\u003e\n\n\u003cp\u003eFor the \u003ccode\u003ecreateTooltipElement\u003c/code\u003e function, we use the\n        jscodeshift API to create a new JSX node, with the \u003ccode\u003ename\u003c/code\u003e\n        prop applied to the \u003ccode\u003eTooltip\u003c/code\u003e and the \u003ccode\u003eAvatar\u003c/code\u003e\n        component as a child. Finally, we call \u003ccode\u003ereplaceWith\u003c/code\u003e to\n        replace the current \u003ccode\u003epath\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere’s a preview of how it looks in\n        \u003ca href=\"https://www.hypermod.io/\"\u003eHypermod\u003c/a\u003e, where the codemod is written on\n        the left. The top part on the right is the original code, and the bottom\n        part is the transformed result:\u003c/p\u003e\n\n\u003cdiv id=\"hypermod.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/hypermod.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 5: Run checks inside hypermod before apply it to your codebase\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis codemod searches for all instances of \u003ccode\u003eAvatar\u003c/code\u003e. If a\n        \u003ccode\u003ename\u003c/code\u003e prop is found, it removes the \u003ccode\u003ename\u003c/code\u003e prop\n        from \u003ccode\u003eAvatar\u003c/code\u003e, wraps the \u003ccode\u003eAvatar\u003c/code\u003e inside a\n        \u003ccode\u003eTooltip\u003c/code\u003e, and passes the \u003ccode\u003ename\u003c/code\u003e prop to the\n        \u003ccode\u003eTooltip\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBy now, I hope it’s clear that codemods are incredibly useful and\n        that the workflow is intuitive, especially for large-scale changes where\n        manual updates would be a huge burden. However, that\u0026#39;s not the whole\n        picture. In the next section, I’ll shed light on some of the challenges\n        and how we can address these less-than-ideal aspects.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"FixingCommonPitfallsOfCodemods\"\u003e\n\u003ch2\u003eFixing Common Pitfalls of Codemods\u003c/h2\u003e\n\n\u003cp\u003eAs a seasoned developer, you know the “happy path” is only a small part\n      of the full picture. There are numerous scenarios to consider when writing\n      a transformation script to handle code automatically.\u003c/p\u003e\n\n\u003cp\u003eDevelopers write code in a variety of styles. For example, someone\n      might import the \u003ccode\u003eAvatar\u003c/code\u003e component but give it a different name because\n      they might have another \u003ccode\u003eAvatar\u003c/code\u003e component from a different package:\u003c/p\u003e\n\n\u003cpre\u003eimport { Avatar as \u003cspan\u003eAKAvatar\u003c/span\u003e } from \u0026#34;@design-system/avatar\u0026#34;;\n\nconst UserInfo = () =\u0026gt; (\n  \u0026lt;\u003cspan\u003eAKAvatar\u003c/span\u003e name=\u0026#34;Juntao Qiu\u0026#34; image=\u0026#34;/juntao.qiu.avatar.png\u0026#34; /\u0026gt;\n);\n\u003c/pre\u003e\n\n\u003cp\u003eA simple text search for \u003ccode\u003eAvatar\u003c/code\u003e won’t work in this case. You’ll need\n      to detect the alias and apply the transformation using the correct\n      name.\u003c/p\u003e\n\n\u003cp\u003eAnother example arises when dealing with \u003ccode\u003eTooltip\u003c/code\u003e imports. If the file\n      already imports \u003ccode\u003eTooltip\u003c/code\u003e but uses an alias, the codemod must detect that\n      alias and apply the changes accordingly. You can\u0026#39;t assume that the\n      component named \u003ccode\u003eTooltip\u003c/code\u003e is always the one you’re looking for.\u003c/p\u003e\n\n\u003cp\u003eIn the \u003ca href=\"#feature-toggle-example\"\u003efeature toggle example\u003c/a\u003e, someone might use\n      \u003ccode\u003eif(featureToggle(\u0026#39;feature-new-product-list\u0026#39;))\u003c/code\u003e, or assign the result of\n      the toggle function to a variable before using it:\u003c/p\u003e\n\n\u003cpre\u003econst shouldEnableNewFeature = featureToggle(\u0026#39;feature-new-product-list\u0026#39;);\n\nif (shouldEnableNewFeature) {\n  //...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThey might even use the toggle with other conditions or apply logical\n      negation, making the logic more complex:\u003c/p\u003e\n\n\u003cpre\u003econst shouldEnableNewFeature = featureToggle(\u0026#39;feature-new-product-list\u0026#39;);\n\nif (!shouldEnableNewFeature \u0026amp;\u0026amp; someOtherLogic) {\n  //...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThese variations make it difficult to foresee every edge case,\n      increasing the risk of unintentionally breaking something. Relying solely\n      on the cases you can anticipate is not enough. You need thorough testing\n      to avoid breaking unintended parts of the code.\u003c/p\u003e\n\n\u003csection id=\"LeveragingSourceGraphsAndTest-drivenCodemods\"\u003e\n\u003ch3\u003eLeveraging Source Graphs and Test-Driven Codemods\u003c/h3\u003e\n\n\u003cp\u003eTo handle these complexities, codemods should be used alongside other\n        techniques. For instance, a few years ago, I participated in a design\n        system components rewrite project at Atlassian. We addressed this issue by\n        first searching the source graph, which contained the majority of internal\n        component usage. This allowed us to understand how components were used,\n        whether they were imported under different names, or whether certain\n        public props were frequently used. After this search phase, we wrote our\n        test cases upfront, ensuring we covered the majority of use cases, and\n        then developed the codemod.\u003c/p\u003e\n\n\u003cp\u003eIn situations where we couldn\u0026#39;t confidently automate the upgrade, we\n        inserted comments or “TODOs” at the call sites. This allowed the\n        developers running the script to handle specific cases manually. Usually,\n        there were only a handful of such instances, so this approach still proved\n        beneficial for upgrading versions.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UtilizingExistingCodeStandardizationTools\"\u003e\n\u003ch3\u003eUtilizing Existing Code Standardization Tools\u003c/h3\u003e\n\n\u003cp\u003eAs you can see, there are plenty of edge cases to handle, especially in\n        codebases beyond your control—such as external dependencies. This\n        complexity means that using codemods requires careful supervision and a\n        review of the results.\u003c/p\u003e\n\n\u003cp\u003eHowever, if your codebase has standardization tools in place, such as a\n        linter that enforces a particular coding style, you can leverage these\n        tools to reduce edge cases. By enforcing a consistent structure, tools\n        like linters help narrow down the variations in code, making the\n        transformation easier and minimizing unexpected issues.\u003c/p\u003e\n\n\u003cp\u003eFor instance, you could use linting rules to restrict certain patterns,\n        such as avoiding nested conditional (ternary) operators or enforcing named\n        exports over default exports. These rules help streamline the codebase,\n        making codemods more predictable and effective.\u003c/p\u003e\n\n\u003cp\u003eAdditionally, breaking down complex transformations into smaller, more\n        manageable ones allows you to tackle individual issues more precisely. As\n        we\u0026#39;ll soon see, composing smaller codemods can make handling complex\n        changes more feasible.\u003c/p\u003e\n\u003c/section\u003e\n\n\n\n\u003csection id=\"CodemodComposition\"\u003e\n\u003ch3\u003eCodemod Composition\u003c/h3\u003e\n\n\u003cp\u003eLet’s revisit the feature toggle removal example discussed earlier. In the code snippet \n        we have a toggle called \u003ccode\u003efeature-convert-new\u003c/code\u003e need to be removed:\u003c/p\u003e\n\n\u003cpre\u003eimport { featureToggle } from \u0026#34;./utils/featureToggle\u0026#34;;\n\nconst convertOld = (input: string) =\u0026gt; {\n  return input.toLowerCase();\n};\n\nconst convertNew = (input: string) =\u0026gt; {\n  return input.toUpperCase();\n};\n\nconst result = featureToggle(\u0026#34;feature-convert-new\u0026#34;)\n  ? convertNew(\u0026#34;Hello, world\u0026#34;)\n  : convertOld(\u0026#34;Hello, world\u0026#34;);\n\nconsole.log(result);\n\u003c/pre\u003e\n\n\u003cp\u003eThe codemod for remove a given toggle works fine, and after running the codemod, \n        we want the source to look like this:\u003c/p\u003e\n\n\u003cpre\u003econst convertNew = (input: string) =\u0026gt; {\n  return input.toUpperCase();\n};\n\nconst result = convertNew(\u0026#34;Hello, world\u0026#34;);\n\nconsole.log(result);\n\u003c/pre\u003e\n\n\u003cp\u003eHowever, beyond removing the feature toggle logic, there are additional tasks to\n        handle:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eRemove the unused \u003ccode\u003econvertOld\u003c/code\u003e function.\u003c/li\u003e\n\n\u003cli\u003eClean up the unused \u003ccode\u003efeatureToggle\u003c/code\u003e import.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOf course, you could write one big codemod to handle everything in a\n        single pass and test it together. However, a more maintainable approach is\n        to treat codemod logic like product code: break the task into smaller,\n        independent pieces—just like how you would normally refactor production\n        code.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"BreakingItDown\"\u003e\n\u003ch3\u003eBreaking It Down\u003c/h3\u003e\n\n\u003cp\u003eWe can break the big transformation down into smaller codemods and\n        compose them. The advantage of this approach is that each transformation\n        can be tested individually, covering different cases without interference.\n        Moreover, it allows you to reuse and compose them for different\n        purposes.\u003c/p\u003e\n\n\u003cp\u003eFor instance, you might break it down like this:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA transformation to remove a specific feature toggle.\u003c/li\u003e\n\n\u003cli\u003eAnother transformation to clean up unused imports.\u003c/li\u003e\n\n\u003cli\u003eA transformation to remove unused function declarations.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBy composing these, you can create a pipeline of transformations:\u003c/p\u003e\n\n\u003cpre\u003eimport { removeFeatureToggle } from \u0026#34;./remove-feature-toggle\u0026#34;;\nimport { removeUnusedImport } from \u0026#34;./remove-unused-import\u0026#34;;\nimport { removeUnusedFunction } from \u0026#34;./remove-unused-function\u0026#34;;\n\nimport { createTransformer } from \u0026#34;./utils\u0026#34;;\n\nconst removeFeatureConvertNew = removeFeatureToggle(\u0026#34;feature-convert-new\u0026#34;);\n\nconst transform = createTransformer([\n  removeFeatureConvertNew,\n  removeUnusedImport,\n  removeUnusedFunction,\n]);\n\nexport default transform;\n\u003c/pre\u003e\n\n\u003cp\u003eIn this pipeline, the transformations work as follows:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eRemove the \u003ccode\u003efeature-convert-new\u003c/code\u003e toggle.\u003c/li\u003e\n\n\u003cli\u003eClean up the unused \u003ccode\u003eimport\u003c/code\u003e statement.\u003c/li\u003e\n\n\u003cli\u003eRemove the \u003ccode\u003econvertOld\u003c/code\u003e function since it’s no longer used.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cdiv id=\"codemod-process-transforms-1.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/codemod-process-transforms-1.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 6: Compose transforms into a new transform\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eYou can also extract additional codemods as needed, combining them in\n        various orders depending on the desired outcome.\u003c/p\u003e\n\n\u003cdiv id=\"codemod-process-transforms-2.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/codemods-api-refactoring/codemod-process-transforms-2.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 7: Put different transforms into a pipepline to form another transform\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"TheCreatetransformerFunction\"\u003e\n\u003ch3\u003eThe \u003ccode\u003ecreateTransformer\u003c/code\u003e Function\u003c/h3\u003e\n\n\u003cp\u003eThe implementation of the \u003ccode\u003ecreateTransformer\u003c/code\u003e function is relatively\n        straightforward. It acts as a higher-order function that takes a list of\n        smaller transform functions, iterates through the list to apply them to\n        the root AST, and finally converts the modified AST back into source\n        code.\u003c/p\u003e\n\n\u003cpre\u003eimport { API, Collection, FileInfo, JSCodeshift, Options } from \u0026#34;jscodeshift\u0026#34;;\n\ntype TransformFunction = { (j: JSCodeshift, root: Collection): void };\n\nconst createTransformer =\n  (transforms: TransformFunction[]) =\u0026gt;\n  (fileInfo: FileInfo, api: API, options: Options) =\u0026gt; {\n    const j = api.jscodeshift;\n    const root = j(fileInfo.source);\n\n    transforms.forEach((transform) =\u0026gt; transform(j, root));\n    return root.toSource(options.printOptions || { quote: \u0026#34;single\u0026#34; });\n  };\n\nexport { createTransformer };\n\u003c/pre\u003e\n\n\u003cp\u003eFor example, you could have a transform function that inlines\n        expressions assigning the feature toggle call to a variable, so in later\n        transforms you don’t have to worry about those cases anymore:\u003c/p\u003e\n\n\u003cpre\u003econst shouldEnableNewFeature = featureToggle(\u0026#39;feature-convert-new\u0026#39;);\n\nif (!shouldEnableNewFeature \u0026amp;\u0026amp; someOtherLogic) {\n  //...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eBecomes this: \u003c/p\u003e\n\n\u003cpre\u003eif (!featureToggle(\u0026#39;feature-convert-new\u0026#39;) \u0026amp;\u0026amp; someOtherLogic) {\n  //...\n}\n\u003c/pre\u003e\n\n\u003cp\u003eOver time, you might build up a collection of reusable, smaller\n        transforms, which can greatly ease the process of handling tricky edge\n        cases. This approach proved highly effective in our work refining design\n        system components. Once we converted one package—such as the button\n        component—we had a few reusable transforms defined, like adding comments\n        at the start of functions, removing deprecated props, or creating aliases\n        when a package is already imported above.\u003c/p\u003e\n\n\u003cp\u003eEach of these smaller transforms can be tested and used independently\n        or combined for more complex transformations, which speeds up subsequent\n        conversions significantly. As a result, our refinement work became more\n        efficient, and these generic codemods are now applicable to other internal\n        and even external React codebases.\u003c/p\u003e\n\n\u003cp\u003eSince each transform is relatively standalone, you can fine-tune them\n        without affecting other transforms or the more complex, composed ones. For\n        instance, you might re-implement a transform to improve performance—like\n        reducing the number of node-finding rounds—and with comprehensive test\n        coverage, you can do this confidently and safely.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"CodemodsInOtherLanguages\"\u003e\n\u003ch2\u003eCodemods in Other Languages\u003c/h2\u003e\n\n\u003cp\u003eWhile the examples we’ve explored so far focus on JavaScript and JSX\n      using \u003ca href=\"https://github.com/facebook/jscodeshift\"\u003ejscodeshift\u003c/a\u003e, codemods can also be applied to other languages. For\n      instance, \u003ca href=\"https://javaparser.org/\"\u003eJavaParser\u003c/a\u003e offers a similar\n      mechanism in Java, using AST manipulation to refactor Java code.\u003c/p\u003e\n\n\u003csection id=\"UsingJavaparserInAJavaCodebase\"\u003e\n\u003ch3\u003eUsing JavaParser in a Java Codebase\u003c/h3\u003e\n\n\u003cp\u003eJavaParser can be useful for making breaking API changes or refactoring\n        large Java codebases in a structured, automated way.\u003c/p\u003e\n\n\u003cp\u003eAssume we have the following code in \u003ccode\u003eFeatureToggleExample.java\u003c/code\u003e, which\n        checks the toggle \u003ccode\u003efeature-convert-new\u003c/code\u003e and branches accordingly:\u003c/p\u003e\n\n\u003cpre\u003epublic class FeatureToggleExample {\n    public void execute() {\n        if (FeatureToggle.isEnabled(\u0026#34;feature-convert-new\u0026#34;)) {\n          newFeature();\n        } else {\n          oldFeature();\n        }\n    }\n\n    void newFeature() {\n        System.out.println(\u0026#34;New Feature Enabled\u0026#34;);\n    }\n\n    void oldFeature() {\n        System.out.println(\u0026#34;Old Feature\u0026#34;);\n    }\n}\u003c/pre\u003e\n\n\u003cp\u003eWe can define a visitor to find \u003ccode\u003eif\u003c/code\u003e statements checking for\n        \u003ccode\u003eFeatureToggle.isEnabled\u003c/code\u003e, and then replace them with the corresponding\n        true branch—similar to how we handled the feature toggle codemod in\n        JavaScript.\u003c/p\u003e\n\n\u003cpre\u003e// Visitor to remove feature toggles\nclass FeatureToggleVisitor extends VoidVisitorAdapter\u0026lt;Void\u0026gt; {\n    @Override\n    public void visit(IfStmt ifStmt, Void arg) {\n        super.visit(ifStmt, arg);\n        if (ifStmt.getCondition().isMethodCallExpr()) {\n            MethodCallExpr methodCall = ifStmt.getCondition().asMethodCallExpr();\n            if (methodCall.getNameAsString().equals(\u0026#34;isEnabled\u0026#34;) \u0026amp;\u0026amp;\n                methodCall.getScope().isPresent() \u0026amp;\u0026amp;\n                methodCall.getScope().get().toString().equals(\u0026#34;FeatureToggle\u0026#34;)) {\n\n                BlockStmt thenBlock = ifStmt.getThenStmt().asBlockStmt();\n                ifStmt.replace(thenBlock);\n            }\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis code defines a \u003ca href=\"https://www.amazon.com/gp/product/0201634988/ref=as_li_tl?ie=UTF8\u0026amp;camp=1789\u0026amp;creative=9325\u0026amp;creativeASIN=0201634988\u0026amp;linkCode=as2\u0026amp;tag=martinfowlerc-20\"\u003evisitor\u003c/a\u003e pattern using\n        JavaParser to traverse and manipulate the AST. The\n        \u003ccode\u003eFeatureToggleVisitor\u003c/code\u003e looks for \u003ccode\u003eif\u003c/code\u003e statements\n        that call \u003ccode\u003eFeatureToggle.isEnabled()\u003c/code\u003e and replaces the entire\n        \u003ccode\u003eif\u003c/code\u003e statement with the true branch.\u003c/p\u003e\n\n\u003cp\u003eYou can also define visitors to find unused methods and remove\n        them:\u003c/p\u003e\n\n\u003cpre\u003eclass UnusedMethodRemover extends VoidVisitorAdapter\u0026lt;Void\u0026gt; {\n    private Set\u0026lt;String\u0026gt; calledMethods = new HashSet\u0026lt;\u0026gt;();\n    private List\u0026lt;MethodDeclaration\u0026gt; methodsToRemove = new ArrayList\u0026lt;\u0026gt;();\n\n    // Collect all called methods\n    @Override\n    public void visit(MethodCallExpr n, Void arg) {\n        super.visit(n, arg);\n        calledMethods.add(n.getNameAsString());\n    }\n\n    // Collect methods to remove if not called\n    @Override\n    public void visit(MethodDeclaration n, Void arg) {\n        super.visit(n, arg);\n        String methodName = n.getNameAsString();\n        if (!calledMethods.contains(methodName) \u0026amp;\u0026amp; !methodName.equals(\u0026#34;main\u0026#34;)) {\n            methodsToRemove.add(n);\n        }\n    }\n\n    // After visiting, remove the unused methods\n    public void removeUnusedMethods() {\n        for (MethodDeclaration method : methodsToRemove) {\n            method.remove();\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis code defines a visitor, \u003ccode\u003eUnusedMethodRemover\u003c/code\u003e, to detect and\n        remove unused methods. It tracks all called methods in the \u003ccode\u003ecalledMethods\u003c/code\u003e\n        set and checks each method declaration. If a method isn’t called and isn’t\n        \u003ccode\u003emain\u003c/code\u003e, it adds it to the list of methods to remove. Once all methods are\n        processed, it removes any unused methods from the AST.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ComposingJavaVisitors\"\u003e\n\u003ch3\u003eComposing Java Visitors\u003c/h3\u003e\n\n\u003cp\u003eYou can chain these visitors together and apply them to your codebase\n        like so:\u003c/p\u003e\n\n\u003cpre\u003epublic class FeatureToggleRemoverWithCleanup {\n    public static void main(String[] args) {\n        try {\n            String filePath = \u0026#34;src/test/java/com/example/Example.java\u0026#34;;\n            CompilationUnit cu = StaticJavaParser.parse(new FileInputStream(filePath));\n\n            // Apply transformations\n            FeatureToggleVisitor toggleVisitor = new FeatureToggleVisitor();\n            cu.accept(toggleVisitor, null);\n\n            UnusedMethodRemover remover = new UnusedMethodRemover();\n            cu.accept(remover, null);\n            remover.removeUnusedMethods();\n\n            // Write the modified code back to the file\n            try (FileOutputStream fos = new FileOutputStream(filePath)) {\n                fos.write(cu.toString().getBytes());\n            }\n\n            System.out.println(\u0026#34;Code transformation completed successfully.\u0026#34;);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\u003c/pre\u003e\n\n\u003cp\u003eEach visitor is a unit of transformation, and the visitor pattern in\n        JavaParser makes it easy to compose them.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Openrewrite\"\u003e\n\u003ch2\u003eOpenRewrite\u003c/h2\u003e\n\n\u003cp\u003eAnother popular option for Java projects is \u003ca href=\"https://github.com/openrewrite\"\u003eOpenRewrite\u003c/a\u003e. It uses a different format of the\n      source code tree called Lossless Semantic Trees (LSTs), which\n      provide more detailed information compared to traditional AST (Abstract\n      Syntax Tree) approaches used by tools like JavaParser or jscodeshift.\n      While AST focuses on the syntactic structure, LSTs capture both syntax and\n      semantic meaning, enabling more accurate and sophisticated\n      transformations.\u003c/p\u003e\n\n\u003cp\u003eOpenRewrite also has a robust ecosystem of open-source refactoring\n      recipes for tasks such as framework migrations, security fixes, and\n      maintaining stylistic consistency. This built-in library of recipes can\n      save developers significant time by allowing them to apply standardized\n      transformations across large codebases without needing to write custom\n      scripts.\u003c/p\u003e\n\n\u003cp\u003eFor developers who need customized transformations, OpenRewrite allows\n      you to create and distribute your own recipes, making it a highly flexible\n      and extensible tool. It’s widely used in the Java community and is\n      gradually expanding into other languages, thanks to its advanced\n      capabilities and community-driven approach.\u003c/p\u003e\n\n\u003csection id=\"DifferencesBetweenOpenrewriteAndJavaparserOrJscodeshift\"\u003e\n\u003ch3\u003eDifferences Between OpenRewrite and JavaParser or jscodeshift\u003c/h3\u003e\n\n\u003cp\u003eThe key difference between OpenRewrite and tools like JavaParser or\n        jscodeshift lies in their approach to code transformation:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eOpenRewrite’s \u003cb\u003eLossless Semantic Trees (LSTs)\u003c/b\u003e capture both the\n          syntactic and semantic meaning of the code, enabling more accurate\n          transformations.\u003c/li\u003e\n\n\u003cli\u003eJavaParser and jscodeshift rely on traditional ASTs, which focus\n          primarily on the syntactic structure. While powerful, they may not always\n          capture the nuances of how the code behaves semantically.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAdditionally, OpenRewrite offers a large library of community-driven\n        refactoring recipes, making it easier to apply common transformations without\n        needing to write custom codemods from scratch.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"OtherToolsForCodemods\"\u003e\n\u003ch2\u003eOther Tools for Codemods\u003c/h2\u003e\n\n\u003cp\u003eWhile jscodeshift and OpenRewrite are powerful tools, there are\n      other options worth considering, depending on your needs and the ecosystem\n      you\u0026#39;re working in.\u003c/p\u003e\n\n\u003csection id=\"Hypermod\"\u003e\n\u003ch3\u003eHypermod\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.hypermod.io/\"\u003eHypermod\u003c/a\u003e introduces AI assistance to the codemod writing process.\n        Instead of manually crafting the codemod logic, developers can describe\n        the desired transformation in plain English, and Hypermod will generate\n        the codemod using jscodeshift. This makes codemod creation more\n        accessible, even for developers who may not be familiar with AST\n        manipulation.\u003c/p\u003e\n\n\u003cp\u003eYou can compose, test, and deploy a codemod to any repository\n        connected to Hypermod. It can run the codemod and generate a pull\n        request with the proposed changes, allowing you to review and approve\n        them. This integration makes the entire process from codemod development\n        to deployment much more streamlined.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Codemod.com\"\u003e\n\u003ch3\u003eCodemod.com\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"http://codemod.com/\"\u003eCodemod.com\u003c/a\u003e is a community-driven platform where developers\n        can share and discover codemods. If you need a specific codemod for a\n        common refactoring task or migration, you can search for existing\n        codemods. Alternatively, you can publish codemods you’ve created to help\n        others in the developer community.\u003c/p\u003e\n\n\u003cp\u003eIf you\u0026#39;re migrating an API and need a codemod to handle it,\n        Codemod.com can save you time by offering pre-built codemods for\n        many common transformations, reducing the need to write one from\n        scratch.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Conclusion\"\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eCodemods are powerful tools that allow developers to automate code\n      transformations, making it easier to manage API changes, refactor legacy\n      code, and maintain consistency across large codebases with minimal manual\n      intervention. By using tools like jscodeshift, Hypermod, or\n      OpenRewrite, developers can streamline everything from minor syntax\n      changes to major component rewrites, improving overall code quality and\n      maintainability.\u003c/p\u003e\n\n\u003cp\u003eHowever, while codemods offer significant benefits, they are not\n      without challenges. One of the key concerns is handling edge cases,\n      particularly when the codebase is diverse or publicly shared. Variations\n      in coding styles, import aliases, or unexpected patterns can lead to\n      issues that codemods may not handle automatically. These edge cases\n      require careful planning, thorough testing, and, in some instances, manual\n      intervention to ensure accuracy.\u003c/p\u003e\n\n\u003cp\u003eTo maximize the effectiveness of codemods, it’s crucial to break\n      complex transformations into smaller, testable steps and to use code\n      standardization tools where possible. Codemods can be highly effective,\n      but their success depends on thoughtful design and understanding the\n      limitations they may face in more varied or complex codebases.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "40 min read",
  "publishedTime": null,
  "modifiedTime": "2025-01-22T00:00:00Z"
}
