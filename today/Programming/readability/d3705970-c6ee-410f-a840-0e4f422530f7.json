{
  "id": "d3705970-c6ee-410f-a840-0e4f422530f7",
  "title": "Adding Zonal Resiliency to Etsy’s Kafka Cluster: Part 1",
  "link": "https://www.etsy.com/codeascraft/adding-zonal-resiliency-to-etsys-kafka-cluster-part-1?utm_source=OpenGraph\u0026utm_medium=PageTools\u0026utm_campaign=Share",
  "description": "In 2018, with its decision to choose Google Cloud Platform as its provider, Etsy began a long project of migration to the cloud. This wasn't just a question of moving out of our data center. Things like on-demand capacity scaling and multi-zone/region resilience don't just magically happen once you’re \"in the cloud.\" To get the full benefits, we undertook a major redesign to host our Kafka brokers (and clients) on Google’s managed Kubernetes (GKE). Fast forward a few years: we now have many more Kafka clients with streaming applications that power critical user-facing features, like search indexing. Our initial architecture, which saved on cost by operating (mostly) in a single availability zone, was beginning to look shaky. The consequences of a Kafka outage had grown, for example resulting in stale search results. This would have a negative impact on our buyers and sellers alike, and would mean a direct revenue loss to Etsy. We decided it was time to reevaluate. With some research and thinking, and a good bit of experimentation, we put together a plan to make our Kafka cluster resilient to zonal failures. For such an important production service, the migration had to be accomplished with zero downtime in production. This post will discuss how we accomplished that feat, and where we're looking to optimize costs following a successful rollout. Single-Zone Kafka Inter-zone network costs in Google Cloud can add up surprisingly quickly, even exceeding the costs of VMs and storage. Mindful of this, our original design operated the Kafka cluster in one zone only, as illustrated below: Figure 1. An illustration of our original single-zone architecture. The Kafka cluster operates entirely within zone “a”. Only a few critically important components, such as Zookeeper in this example, run in multiple zones.Those with keen eyes might have noticed the Persistent Disks drawn across a zone boundary. This is to indicate that we’re using Google’s Regional PDs, replicated to zones “a” and “b”. (Regular PDs, by contrast, are zonal resources, and can only be accessed from a GCE instance in the same zone.) Even though we weren’t willing to pay the network costs for operating Kafka in multiple zones at the time, we wanted at least some capability to handle Google Cloud zonal outages. The worst-case scenario in the design above is a “zone-a” outage taking down the entire Kafka cluster. Until the cluster came back up, consumers would be dealing with delayed data, and afterward they'd have to spend time processing the backlog. More concerning is that with the cluster unavailable producers would have nowhere to send their data. Our primary producer, Franz, has an in-memory buffer and unlimited retries as a hedge against the problem, but producer memory buffers aren't unlimited. In the event of a sustained zone outage our runbook documented a plan to have a team member manually relocate the Kafka brokers to zone-b, where disks and historical data have been safely stored. A quick response would be critical to prevent data loss, which might be a lot to ask of a possibly sleepy human. Multizone Kafka As Kafka's importance to the business grew–and even though the single-zone architecture hadn’t suffered an outage yet–so did our discomfort with the limitations of manual zone evacuation. So we worked out a design that would give the Kafka cluster zonal resilience: Figure 2. A multizone design for Kafka on GKE. Notice that persistent disks are no longer drawn across zone boundaries.The most crucial change is that our Kafka brokers are now running in three different zones. The GKE cluster was already regional, so we applied Kubernetes Pod Topology Spread Constraints with topologyKey: topology.kubernetes.io/zone to ensure an even distribution across zones. Less apparent is the fact that topic partition replicas also need to be evenly distributed. We achieve this by setting Kafka’s broker.rack configuration based on the zone where a broker is running. This way, in the event of an outage of any one zone, two out of three partition replicas are still available. With this physical data layout, we no longer need persistent disks to be regional, since Kafka is providing inter-zone replication for us. Zero-Downtime Migration Satisfied with the design, we still had the challenge of applying the changes to our production Kafka cluster without data loss, downtime, or negative impact to client applications. The first task was to move broker Pods to their correct zones. Simply applying the Topology Constraints alone resulted in Pods stuck in “Pending” state when they were recreated with the new configs. The problem was that the disks and PVCs for the pods are zonal resources that can only be accessed locally (and even regional disks are limited to just two zones). So we had to move the disks first, then the Pods could follow. One way to accomplish the move is by actually deleting and recreating the disks. Since we have a replication factor of three on all our topics, this is safe if we do it one disk at a time, and Kafka will re-replicate the missing data onto the blank disk. Testing showed, however, that completing the procedure for all brokers would take an unacceptably long time, on the order of weeks. Instead, we took advantage of Google’s disk snapshotting feature. Automated with some scripting, the main loop performs roughly the following steps: Create a “base” snapshot of the Kafka broker disk, while the broker is still up and running Halt the broker: kubectl delete statefulset --cascade=orphan kubectl delete pod Create the “final” snapshot of the same Kafka broker disk, referencing the base snapshot Create a brand new disk from the final snapshot, in the correct zone Delete the original disk Recreate the StatefulSet, which recreates the Pod and starts up the broker Wait until the cluster health returns to normal (under replicated partitions is zero) Repeat for each broker. The two-step base/final snapshot process is just an optimisation. The second snapshot is much faster than the first, which minimizes broker downtime, and also reduces the time for partition replication to catch up afterwards. Now that we’ve got brokers running in the correct zone location, what about partitions? Kafka doesn’t provide automatic partition relocation, and the broker.rack configuration only applies to newly created partitions. So this was a do-it-yourself situation, which at high level involved: Generating a list of topic-partitions needing relocation, based on the requirement that replicas need to be distributed evenly across all zones. After some scripting, this list contained 90% of the cluster’s partitions. Generating a new partition assignment plan in JSON form. Kafka provides some CLI tools for the job, but we used the SiftScience/kafka-assigner tool instead (with a few of the open PRs applied). This allowed us to minimize the amount of data movement, saving time and reducing load on the cluster. Applying partition assignments using the official “kafka-reassign-partitions” CLI tool. To prevent overwhelming the cluster, we throttled the data migration, going in small batches rather than all at once (we had something like 10k partitions to move), and grouping migrations by class of topic, large, small, or empty (with the empty ones probably available for deletion). It was delicate work that took days of manual effort and babysitting to complete, but the result was a completely successful, zero-downtime partition migration. Post Migration In 2021, a company-wide initiative to test and understand zonal resilience in a large number of Etsy's systems, led by Jeremy Tinley, gave us a perfect opportunity to put our multizone Kafka design through its paces. We performed our testing in production, like many other teams (staging environments not being 100% representative), and brought down an entire zone, a third of the Kafka cluster. As leader election and partition replicas became unavailable, client requests automatically switched to still-available brokers, and any impact turned out to be minimal and temporary. Some napkin math at the time of redesign led us to believe that we would see only minimal cost increases from our multizone setup. In particular, eliminating regional disks (the most expensive Google Cloud SKU in our single-zone design) in favor of Kafka replication would halve our significant storage expense. By current measurements, though, we've ended up with a roughly 20% increase in cost since migration, largely due to higher-than-anticipated inter-zone network costs. We expected some increase, of course: we wanted an increase, since the whole point of the new architecture is to make data available across zones. Ideally, we would only be traversing zone boundaries for replication, but in practice that ideal is hard to achieve. Kafka's follower fetching feature has helped us make progress on this front. By default, consumers read from the leader replica of a partition, where records are directly produced: but if you're willing to accept some replication latency (well within our application SLOs), follower fetching lets you consume data from same-zone replica partitions, eliminating extra hops across boundaries. The feature is enabled by specifying the client.rack configuration to consumers, and the RackAwareReplicaSelector class for the broker-side replica.selector.class config. This isn’t the only source of inter-zone traffic however, many of our client applications are not pure consumers but also produce data themselves, and when their data is written back to the Kafka cluster across zones. (We also have some consumers in different Google Cloud projects outside our team's control that we haven't been able to update yet.) Arguably, increased network costs are worth it to be insured against catastrophic zone failures. (Certainly there are some possibly sleepy humans who are glad they won't be called upon to manually evacuate a bad zone.) We think that with continued work we can bring our costs more in line with initial expectations. But even as things stand, the benefits of automatic and fast tolerance to zone outages are significant, and we'll pay for them happily.",
  "author": "Andrey Polyakov",
  "published": "Tue, 31 Jan 2023 15:36:33 -0500",
  "source": "https://codeascraft.com/feed/atom/",
  "categories": null,
  "byline": "By Andrey Polyakov, Kamya Shethia Jan 31, 2023",
  "length": 10255,
  "excerpt": "In 2018, with its decision to choose Google Cloud Platform as its provider, Etsy began a long project of migration to the cloud....",
  "siteName": "Etsy Engineering",
  "favicon": "",
  "text": "In 2018, with its decision to choose Google Cloud Platform as its provider, Etsy began a long project of migration to the cloud. This wasn't just a question of moving out of our data center. Things like on-demand capacity scaling and multi-zone/region resilience don't just magically happen once you’re \"in the cloud.\" To get the full benefits, we undertook a major redesign to host our Kafka brokers (and clients) on Google’s managed Kubernetes (GKE). Fast forward a few years: we now have many more Kafka clients with streaming applications that power critical user-facing features, like search indexing. Our initial architecture, which saved on cost by operating (mostly) in a single availability zone, was beginning to look shaky. The consequences of a Kafka outage had grown, for example resulting in stale search results. This would have a negative impact on our buyers and sellers alike, and would mean a direct revenue loss to Etsy. We decided it was time to reevaluate. With some research and thinking, and a good bit of experimentation, we put together a plan to make our Kafka cluster resilient to zonal failures. For such an important production service, the migration had to be accomplished with zero downtime in production. This post will discuss how we accomplished that feat, and where we're looking to optimize costs following a successful rollout. Single-Zone Kafka Inter-zone network costs in Google Cloud can add up surprisingly quickly, even exceeding the costs of VMs and storage. Mindful of this, our original design operated the Kafka cluster in one zone only, as illustrated below: Figure 1. An illustration of our original single-zone architecture. The Kafka cluster operates entirely within zone “a”. Only a few critically important components, such as Zookeeper in this example, run in multiple zones.Those with keen eyes might have noticed the Persistent Disks drawn across a zone boundary. This is to indicate that we’re using Google’s Regional PDs, replicated to zones “a” and “b”. (Regular PDs, by contrast, are zonal resources, and can only be accessed from a GCE instance in the same zone.) Even though we weren’t willing to pay the network costs for operating Kafka in multiple zones at the time, we wanted at least some capability to handle Google Cloud zonal outages. The worst-case scenario in the design above is a “zone-a” outage taking down the entire Kafka cluster. Until the cluster came back up, consumers would be dealing with delayed data, and afterward they'd have to spend time processing the backlog. More concerning is that with the cluster unavailable producers would have nowhere to send their data. Our primary producer, Franz, has an in-memory buffer and unlimited retries as a hedge against the problem, but producer memory buffers aren't unlimited. In the event of a sustained zone outage our runbook documented a plan to have a team member manually relocate the Kafka brokers to zone-b, where disks and historical data have been safely stored. A quick response would be critical to prevent data loss, which might be a lot to ask of a possibly sleepy human. Multizone Kafka As Kafka's importance to the business grew–and even though the single-zone architecture hadn’t suffered an outage yet–so did our discomfort with the limitations of manual zone evacuation. So we worked out a design that would give the Kafka cluster zonal resilience: Figure 2. A multizone design for Kafka on GKE. Notice that persistent disks are no longer drawn across zone boundaries.The most crucial change is that our Kafka brokers are now running in three different zones. The GKE cluster was already regional, so we applied Kubernetes Pod Topology Spread Constraints with topologyKey: topology.kubernetes.io/zone to ensure an even distribution across zones. Less apparent is the fact that topic partition replicas also need to be evenly distributed. We achieve this by setting Kafka’s broker.rack configuration based on the zone where a broker is running. This way, in the event of an outage of any one zone, two out of three partition replicas are still available. With this physical data layout, we no longer need persistent disks to be regional, since Kafka is providing inter-zone replication for us. Zero-Downtime Migration Satisfied with the design, we still had the challenge of applying the changes to our production Kafka cluster without data loss, downtime, or negative impact to client applications. The first task was to move broker Pods to their correct zones. Simply applying the Topology Constraints alone resulted in Pods stuck in “Pending” state when they were recreated with the new configs. The problem was that the disks and PVCs for the pods are zonal resources that can only be accessed locally (and even regional disks are limited to just two zones). So we had to move the disks first, then the Pods could follow. One way to accomplish the move is by actually deleting and recreating the disks. Since we have a replication factor of three on all our topics, this is safe if we do it one disk at a time, and Kafka will re-replicate the missing data onto the blank disk. Testing showed, however, that completing the procedure for all brokers would take an unacceptably long time, on the order of weeks. Instead, we took advantage of Google’s disk snapshotting feature. Automated with some scripting, the main loop performs roughly the following steps: Create a “base” snapshot of the Kafka broker disk, while the broker is still up and running Halt the broker: kubectl delete statefulset --cascade=orphan \u003ckafka-statefulset\u003e kubectl delete pod \u003ckafka-broker-pod\u003e Create the “final” snapshot of the same Kafka broker disk, referencing the base snapshot Create a brand new disk from the final snapshot, in the correct zone Delete the original disk Recreate the StatefulSet, which recreates the Pod and starts up the broker Wait until the cluster health returns to normal (under replicated partitions is zero) Repeat for each broker. The two-step base/final snapshot process is just an optimisation. The second snapshot is much faster than the first, which minimizes broker downtime, and also reduces the time for partition replication to catch up afterwards. Now that we’ve got brokers running in the correct zone location, what about partitions? Kafka doesn’t provide automatic partition relocation, and the broker.rack configuration only applies to newly created partitions. So this was a do-it-yourself situation, which at high level involved: Generating a list of topic-partitions needing relocation, based on the requirement that replicas need to be distributed evenly across all zones. After some scripting, this list contained 90% of the cluster’s partitions. Generating a new partition assignment plan in JSON form. Kafka provides some CLI tools for the job, but we used the SiftScience/kafka-assigner tool instead (with a few of the open PRs applied). This allowed us to minimize the amount of data movement, saving time and reducing load on the cluster. Applying partition assignments using the official “kafka-reassign-partitions” CLI tool. To prevent overwhelming the cluster, we throttled the data migration, going in small batches rather than all at once (we had something like 10k partitions to move), and grouping migrations by class of topic, large, small, or empty (with the empty ones probably available for deletion). It was delicate work that took days of manual effort and babysitting to complete, but the result was a completely successful, zero-downtime partition migration. Post Migration In 2021, a company-wide initiative to test and understand zonal resilience in a large number of Etsy's systems, led by Jeremy Tinley, gave us a perfect opportunity to put our multizone Kafka design through its paces. We performed our testing in production, like many other teams (staging environments not being 100% representative), and brought down an entire zone, a third of the Kafka cluster. As leader election and partition replicas became unavailable, client requests automatically switched to still-available brokers, and any impact turned out to be minimal and temporary. Some napkin math at the time of redesign led us to believe that we would see only minimal cost increases from our multizone setup. In particular, eliminating regional disks (the most expensive Google Cloud SKU in our single-zone design) in favor of Kafka replication would halve our significant storage expense. By current measurements, though, we've ended up with a roughly 20% increase in cost since migration, largely due to higher-than-anticipated inter-zone network costs. We expected some increase, of course: we wanted an increase, since the whole point of the new architecture is to make data available across zones. Ideally, we would only be traversing zone boundaries for replication, but in practice that ideal is hard to achieve. Kafka's follower fetching feature has helped us make progress on this front. By default, consumers read from the leader replica of a partition, where records are directly produced: but if you're willing to accept some replication latency (well within our application SLOs), follower fetching lets you consume data from same-zone replica partitions, eliminating extra hops across boundaries. The feature is enabled by specifying the client.rack configuration to consumers, and the RackAwareReplicaSelector class for the broker-side replica.selector.class config. This isn’t the only source of inter-zone traffic however, many of our client applications are not pure consumers but also produce data themselves, and when their data is written back to the Kafka cluster across zones. (We also have some consumers in different Google Cloud projects outside our team's control that we haven't been able to update yet.) Arguably, increased network costs are worth it to be insured against catastrophic zone failures. (Certainly there are some possibly sleepy humans who are glad they won't be called upon to manually evacuate a bad zone.) We think that with continued work we can bring our costs more in line with initial expectations. But even as things stand, the benefits of automatic and fast tolerance to zone outages are significant, and we'll pay for them happily.",
  "image": "https://i.etsystatic.com/inv/71f087/4580345676/inv_fullxfull.4580345676_iw2upmq3.jpg?version=0",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cdiv\u003e\n            \u003cp\u003e\u003cimg src=\"https://i.etsystatic.com/iusa/52f19d/56878306/iusa_75x75.56878306_kt2r.jpg?version=0\" alt=\"  image\" aria-label=\"  image\"/\u003e\n    \u003c/p\u003e\n\n\n    \u003c/div\u003e\n    \u003cp\u003eIn 2018, with its \u003ca href=\"https://www.etsy.com/ca/codeascraft/selecting-a-cloud-provider\"\u003edecision to choose Google Cloud Platform\u003c/a\u003e as its provider, Etsy began a long project of migration to the cloud. This wasn\u0026#39;t just a question of moving out of our data center. Things like on-demand capacity scaling and multi-zone/region resilience don\u0026#39;t just magically happen once you’re \u0026#34;in the cloud.\u0026#34; To get the full benefits, we undertook a major redesign to host our Kafka brokers (and clients) on Google’s managed Kubernetes (GKE).\u003c/p\u003e\n\u003cp\u003eFast forward a few years: we now have many more Kafka clients with streaming applications that power critical user-facing features, like search indexing. Our initial architecture, which saved on cost by operating (mostly) in a single availability zone, was beginning to look shaky. The consequences of a Kafka outage had grown, for example resulting in stale search results. This would have a negative impact on our buyers and sellers alike, and would mean a direct revenue loss to Etsy. We decided it was time to reevaluate.\u003c/p\u003e\n\u003cp\u003eWith some research and thinking, and a good bit of experimentation, we put together a plan to make our Kafka cluster resilient to zonal failures. For such an important production service, the migration had to be accomplished with zero downtime in production. This post will discuss how we accomplished that feat, and where we\u0026#39;re looking to optimize costs following a successful rollout.\u003c/p\u003e\n\u003ch2\u003eSingle-Zone Kafka\u003c/h2\u003e\n\u003cp\u003eInter-zone network costs in Google Cloud can add up surprisingly quickly, even exceeding the costs of VMs and storage. Mindful of this, our original design operated the Kafka cluster in one zone only, as illustrated below:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg alt=\"Single Zone Architecture\" src=\"https://i.etsystatic.com/inv/02187e/4628438279/inv_fullxfull.4628438279_l9w0ngdm.jpg?version=0\"/\u003e\u003cfigcaption\u003eFigure 1. An illustration of our original single-zone architecture. The Kafka cluster operates entirely within zone “a”. Only a few critically important components, such as Zookeeper in this example, run in multiple zones.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThose with keen eyes might have noticed the Persistent Disks drawn across a zone boundary. This is to indicate that we’re using \u003ca href=\"https://cloud.google.com/compute/docs/disks#repds\"\u003eGoogle’s Regional PDs\u003c/a\u003e, replicated to zones “a” and “b”. (Regular PDs, by contrast, are zonal resources, and can only be accessed from a GCE instance in the same zone.) Even though we weren’t willing to pay the network costs for operating Kafka in multiple zones at the time, we wanted at least some capability to handle Google Cloud zonal outages.\u003c/p\u003e\n\u003cp\u003eThe worst-case scenario in the design above is a “zone-a” outage taking down the entire Kafka cluster. Until the cluster came back up, consumers would be dealing with delayed data, and afterward they\u0026#39;d have to spend time processing the backlog. More concerning is that with the cluster unavailable producers would have nowhere to send their data. Our primary producer, Franz, has an in-memory buffer and unlimited retries as a hedge against the problem, but producer memory buffers aren\u0026#39;t unlimited. In the event of a sustained zone outage our runbook documented a plan to have a team member manually relocate the Kafka brokers to zone-b, where disks and historical data have been safely stored. A quick response would be critical to prevent data loss, which might be a lot to ask of a possibly sleepy human.\u003c/p\u003e\n\u003ch2\u003eMultizone Kafka\u003c/h2\u003e\n\u003cp\u003eAs Kafka\u0026#39;s importance to the business grew–and even though the single-zone architecture hadn’t suffered an outage yet–so did our discomfort with the limitations of manual zone evacuation. So we worked out a design that would give the Kafka cluster zonal resilience:\u003c/p\u003e\n\u003cfigure\u003e\u003cimg alt=\"Multizone Architecture\" src=\"https://i.etsystatic.com/inv/8eb276/4580201426/inv_fullxfull.4580201426_6ik2anvn.jpg?version=0\" title=\"Multizone Architecture\"/\u003e\u003cfigcaption\u003eFigure 2. A multizone design for Kafka on GKE. Notice that persistent disks are no longer drawn across zone boundaries.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThe most crucial change is that our Kafka brokers are now running in three different zones. The GKE cluster was already \u003ca href=\"https://cloud.google.com/kubernetes-engine/docs/concepts/regional-clusters\"\u003eregional\u003c/a\u003e, so we applied Kubernetes \u003ca href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/\"\u003ePod Topology Spread Constraints\u003c/a\u003e with \u003ccode\u003etopologyKey: topology.kubernetes.io/zone\u003c/code\u003e to ensure an even distribution across zones. Less apparent is the fact that topic partition replicas also need to be evenly distributed. We achieve this by setting Kafka’s \u003ca href=\"https://kafka.apache.org/documentation/#brokerconfigs_broker.rack\"\u003ebroker.rack\u003c/a\u003e configuration based on the zone where a broker is running. This way, in the event of an outage of any one zone, two out of three partition replicas are still available. With this physical data layout, we no longer need persistent disks to be regional, since Kafka is providing inter-zone replication for us.\u003c/p\u003e\n\u003ch2\u003eZero-Downtime Migration\u003c/h2\u003e\n\u003cp\u003eSatisfied with the design, we still had the challenge of applying the changes to our production Kafka cluster without data loss, downtime, or negative impact to client applications. The first task was to move broker Pods to their correct zones. Simply applying the Topology Constraints alone resulted in Pods stuck in “Pending” state when they were recreated with the new configs. The problem was that the disks and PVCs for the pods are zonal resources that can only be accessed locally (and even regional disks are limited to just two zones). So we had to move the disks first, then the Pods could follow.\u003c/p\u003e\n\u003cp\u003eOne way to accomplish the move is by actually deleting and recreating the disks. Since we have a replication factor of three on all our topics, this is safe if we do it one disk at a time, and Kafka will re-replicate the missing data onto the blank disk. Testing showed, however, that completing the procedure for all brokers would take an unacceptably long time, on the order of weeks.\u003c/p\u003e\n\u003cp\u003eInstead, we took advantage of \u003ca href=\"https://cloud.google.com/compute/docs/disks/create-snapshots\"\u003eGoogle’s disk snapshotting\u003c/a\u003e feature. Automated with some scripting, the main loop performs roughly the following steps:\u003c/p\u003e\n\u003col\u003e\u003cli\u003eCreate a “base” snapshot of the Kafka broker disk, \u003cem\u003ewhile the broker is still up and running\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eHalt the broker:\n\u003col\u003e\u003cli\u003e\u003ccode\u003ekubectl delete statefulset --cascade=orphan \u0026lt;kafka-statefulset\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekubectl delete pod \u0026lt;kafka-broker-pod\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\u003c/li\u003e\n\u003cli\u003eCreate the “final” snapshot of the same Kafka broker disk, referencing the base snapshot\u003c/li\u003e\n\u003cli\u003eCreate a brand new disk from the final snapshot, in the correct zone\u003c/li\u003e\n\u003cli\u003eDelete the original disk\u003c/li\u003e\n\u003cli\u003eRecreate the StatefulSet, which recreates the Pod and starts up the broker\u003c/li\u003e\n\u003cli\u003eWait until the cluster health returns to normal (under replicated partitions is zero)\u003c/li\u003e\n\u003cli\u003eRepeat for each broker.\u003c/li\u003e\n\u003c/ol\u003e\u003cp\u003eThe two-step base/final snapshot process is just an optimisation. The second snapshot is much faster than the first, which minimizes broker downtime, and also reduces the time for partition replication to catch up afterwards.\u003c/p\u003e\n\u003cp\u003eNow that we’ve got brokers running in the correct zone location, what about partitions? Kafka doesn’t provide automatic partition relocation, and the \u003ca href=\"https://kafka.apache.org/documentation/#brokerconfigs_broker.rack\"\u003ebroker.rack\u003c/a\u003e configuration only applies to newly created partitions. So this was a do-it-yourself situation, which at high level involved:\u003c/p\u003e\n\u003cul\u003e\u003cli\u003eGenerating a list of topic-partitions needing relocation, based on the requirement that replicas need to be distributed evenly across all zones. After some scripting, this list contained 90% of the cluster’s partitions.\u003c/li\u003e\n\u003cli\u003eGenerating a new partition assignment plan in JSON form. Kafka provides some CLI tools for the job, but we used the SiftScience/kafka-assigner tool instead (with a few of the open PRs applied). This allowed us to minimize the amount of data movement, saving time and reducing load on the cluster.\u003c/li\u003e\n\u003cli\u003eApplying partition assignments using the official “kafka-reassign-partitions” CLI tool. To prevent overwhelming the cluster, we throttled the data migration, going in small batches rather than all at once (we had something like 10k partitions to move), and grouping migrations by class of topic, large, small, or empty (with the empty ones probably available for deletion).\u003c/li\u003e\n\u003c/ul\u003e\u003cp\u003eIt was delicate work that took days of manual effort and babysitting to complete, but the result was a completely successful, zero-downtime partition migration.\u003c/p\u003e\n\u003ch2\u003ePost Migration\u003c/h2\u003e\n\u003cp\u003eIn 2021, a company-wide initiative to test and understand zonal resilience in a large number of Etsy\u0026#39;s systems, led by Jeremy Tinley, gave us a perfect opportunity to put our multizone Kafka design through its paces. We performed our testing in production, like many other teams (staging environments not being 100% representative), and brought down an entire zone, a third of the Kafka cluster. As leader election and partition replicas became unavailable, client requests automatically switched to still-available brokers, and any impact turned out to be minimal and temporary.\u003c/p\u003e\n\u003cp\u003eSome napkin math at the time of redesign led us to believe that we would see only minimal cost increases from our multizone setup. In particular, eliminating regional disks (the most expensive Google Cloud SKU in our single-zone design) in favor of Kafka replication would halve our significant storage expense. By current measurements, though, we\u0026#39;ve ended up with a roughly 20% increase in cost since migration, largely due to higher-than-anticipated inter-zone network costs.\u003c/p\u003e\n\u003cp\u003eWe expected some increase, of course: we wanted an increase, since the whole point of the new architecture is to make data available across zones. Ideally, we would only be traversing zone boundaries for replication, but in practice that ideal is hard to achieve. Kafka\u0026#39;s \u003ca href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-392%253A+Allow+consumers+to+fetch+from+closest+replica\"\u003efollower fetching\u003c/a\u003e feature has helped us make progress on this front. By default, consumers read from the leader replica of a partition, where records are directly produced: but if you\u0026#39;re willing to accept some replication latency (well within our application SLOs), follower fetching lets you consume data from same-zone replica partitions, eliminating extra hops across boundaries. The feature is enabled by specifying the \u003ca href=\"https://kafka.apache.org/documentation/#consumerconfigs_client.rack\"\u003eclient.rack\u003c/a\u003e configuration to consumers, and the RackAwareReplicaSelector class for the broker-side \u003ca href=\"https://kafka.apache.org/documentation/#brokerconfigs_replica.selector.class\"\u003ereplica.selector.class\u003c/a\u003e config. This isn’t the only source of inter-zone traffic however, many of our client applications are not pure consumers but also produce data themselves, and when their data is written back to the Kafka cluster across zones. (We also have some consumers in different Google Cloud projects outside our team\u0026#39;s control that we haven\u0026#39;t been able to update yet.)\u003c/p\u003e\n\u003cp\u003eArguably, increased network costs are worth it to be insured against catastrophic zone failures. (Certainly there are some possibly sleepy humans who are glad they won\u0026#39;t be called upon to manually evacuate a bad zone.) We think that with continued work we can bring our costs more in line with initial expectations. But even as things stand, the benefits of automatic and fast tolerance to zone outages are significant, and we\u0026#39;ll pay for them happily.\u003c/p\u003e\n    \n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-10-11T04:10:08Z",
  "modifiedTime": "2024-10-11T04:10:08Z"
}
