{
  "id": "a30da340-44cd-464f-9679-2ba165137544",
  "title": "Uncovering GStreamer secrets",
  "link": "https://github.blog/security/vulnerability-research/uncovering-gstreamer-secrets/",
  "description": "In this post, I’ll walk you through the vulnerabilities I uncovered in the GStreamer library and how I built a custom fuzzing generator to target MP4 files. The post Uncovering GStreamer secrets appeared first on The GitHub Blog.",
  "author": "Antonio Morales",
  "published": "Tue, 17 Dec 2024 13:51:51 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Security",
    "Vulnerability research",
    "fuzzing",
    "GitHub Security Lab",
    "open source"
  ],
  "byline": "Antonio Morales",
  "length": 15730,
  "excerpt": "In this post, I’ll walk you through the vulnerabilities I uncovered in the GStreamer library and how I built a custom fuzzing generator to target MP4 files.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "In this blog post, I’ll show the results of my recent security research on GStreamer, the open source multimedia framework at the core of GNOME’s multimedia functionality. I’ll also go through the approach I used to find some of the most elusive vulnerabilities, generating a custom input corpus from scratch to enhance fuzzing results. GStreamer GStreamer is an open source multimedia framework that provides extensive capabilities, including audio and video decoding, subtitle parsing, and media streaming, among others. It also supports a broad range of codecs, such as MP4, MKV, OGG, and AVI. GStreamer is distributed by default on any Linux distribution that uses GNOME as the desktop environment, including Ubuntu, Fedora, and openSUSE. It provides multimedia support for key applications like Nautilus (Ubuntu’s default file browser), GNOME Videos, and Rhythmbox. It’s also used by tracker-miners, the Ubuntu’s metadata indexer–an application that my colleague, Kev, was able to exploit last year. This makes GStreamer a very interesting target from a security perspective, as critical vulnerabilities in the library can open numerous attack vectors. That’s why I picked it as a target for my security research. It’s worth noting that GStreamer is a large library that includes more than 300 different sub-modules. For this research, I decided to focus on only the “Base” and “Good” plugins, which are included by default in the Ubuntu distribution. Results During my research I found a total of 29 new vulnerabilities in GStreamer, most of them in the MKV and MP4 formats. Below you can find a summary of the vulnerabilities I discovered: GHSL CVE DESCRIPTION GHSL-2024-094 CVE-2024-47537 OOB-write in isomp4/qtdemux.c GHSL-2024-115 CVE-2024-47538 Stack-buffer overflow in vorbis_handle_identification_packet GHSL-2024-116 CVE-2024-47607 Stack-buffer overflow in gst_opus_dec_parse_header GHSL-2024-117 CVE-2024-47615 OOB-Write in gst_parse_vorbis_setup_packet GHSL-2024-118 CVE-2024-47613 OOB-Write in gst_gdk_pixbuf_dec_flush GHSL-2024-166 CVE-2024-47606 Memcpy parameter overlap in qtdemux_parse_theora_extension leading to OOB-write GHSL-2024-195 CVE-2024-47539 OOB-write in convert_to_s334_1a GHSL-2024-197 CVE-2024-47540 Uninitialized variable in gst_matroska_demux_add_wvpk_header leading to function pointer ovewriting GHSL-2024-228 CVE-2024-47541 OOB-write in subparse/gstssaparse.c GHSL-2024-235 CVE-2024-47542 Null pointer dereference in id3v2_read_synch_uint GHSL-2024-236 CVE-2024-47543 OOB-read in qtdemux_parse_container GHSL-2024-238 CVE-2024-47544 Null pointer dereference in qtdemux_parse_sbgp GHSL-2024-242 CVE-2024-47545 Integer underflow in FOURCC_strf parsing leading to OOB-read GHSL-2024-243 CVE-2024-47546 Integer underflow in extract_cc_from_data leading to OOB-read GHSL-2024-244 CVE-2024-47596 OOB-read in FOURCC_SMI_ parsing GHSL-2024-245 CVE-2024-47597 OOB-read in qtdemux_parse_samples GHSL-2024-246 CVE-2024-47598 OOB-read in qtdemux_merge_sample_table GHSL-2024-247 CVE-2024-47599 Null pointer dereference in gst_jpeg_dec_negotiate GHSL-2024-248 CVE-2024-47600 OOB-read in format_channel_mask GHSL-2024-249 CVE-2024-47601 Null pointer dereference in gst_matroska_demux_parse_blockgroup_or_simpleblock GHSL-2024-250 CVE-2024-47602 Null pointer dereference in gst_matroska_demux_add_wvpk_header GHSL-2024-251 CVE-2024-47603 Null pointer dereference in gst_matroska_demux_update_tracks GHSL-2024-258 CVE-2024-47778 OOB-read in gst_wavparse_adtl_chunk GHSL-2024-259 CVE-2024-47777 OOB-read in gst_wavparse_smpl_chunk GHSL-2024-260 CVE-2024-47776 OOB-read in gst_wavparse_cue_chunk GHSL-2024-261 CVE-2024-47775 OOB-read in parse_ds64 GHSL-2024-262 CVE-2024-47774 OOB-read in gst_avi_subtitle_parse_gab2_chunk GHSL-2024-263 CVE-2024-47835 Null pointer dereference in parse_lrc GHSL-2024-280 CVE-2024-47834 Use-After-Free read in Matroska CodecPrivate Nowadays, coverage-guided fuzzers have become the “de facto” tools for finding vulnerabilities in C/C++ projects. Their ability to discover rare execution paths, combined with their ease of use, has made them the preferred choice among security researchers. The most common approach is to start with an initial input corpus, which is then successively mutated by the different mutators. The standard method to create this initial input corpus is to gather a large collection of sample files that provide a good representative coverage of the format you want to fuzz. But with multimedia files, this approach has a major drawback: media files are typically very large (often in the range of megabytes or gigabytes). So, using such large files as the initial input corpus greatly slows down the fuzzing process, as the fuzzer usually goes over every byte of the file. There are various minimization approaches that try to reduce file size, but they tend to be quite simplistic and often yield poor results. And, in the case of complex file formats, they can even break the file’s logic. It’s for this reason that for my GStreamer fuzzing journey, I opted for “generating” an initial input corpus from scratch. The alternative: corpus generators An alternative to gathering files is to create an input corpus from scratch. Or in other words, without using any preexisting files as examples. To do this, we need a way to transform the target file format into a program that generates files compliant with that format. Two possible solutions arise: Use a grammar-based generator. This category of generators makes use of formal grammars to define the file format, and subsequently generate the input corpus. In this category, we can mention tools like Grammarinator, an open source grammar-based fuzzer that creates test cases according to an input ANTLR v4 grammar. In this past blog post, I also explained how I used AFL++ Grammar-Mutator for fuzzing Apache HTTP server. To create a generator specifically for the target software. In this case, we rely on analyzing how the software parses the file format to create a compatible input generator. Of course, the second solution is more time-consuming, as we need not only to understand the file format structure but also to analyze how the target software works. But at the same time, it solves two problems in one shot: On one hand, we’ll generate much smaller files, drastically speeding up the fuzzing process speed. On the other hand, these “custom” files are likely to produce better code coverage and potentially uncover more vulnerabilities. This is the method I opted for and it allowed me to find some of the most interesting vulnerabilities in the MP4 and MKV parsers–vulnerabilities that until then, had not been detected by the fuzzer. Implementing an input corpus generator for MP4 In this section, I will explain how I created an input corpus generator for the MP4 format. I used the same approach for fuzzing the MKV format as well. MP4 format To start, I will show a brief description of the MP4 format. MP4, officially known as MPEG-4 Part 14, is one of the most widely used multimedia container formats today, due to its broad compatibility and widespread support across various platforms and devices. It supports packaging of multiple media types such as video, audio, images, and complex metadata. MP4 is basically an evolution of Apple’s QuickTime media format, which was standardized by ISO as MPEG-4. The .mp4 container format is specified by the “MPEG-4 Part 14: MP4 file format” section. MP4 files are structured as a series of “boxes” (or “atoms”), each containing specific multimedia data needed to construct the media. Each box has a designated type that describes its purpose. These boxes can also contain other nested boxes, creating a modular and hierarchical structure that simplifies parsing and manipulation. Each box/atom includes the following fields: Size: A 32-bit integer indicating the total size of the box in bytes, including the header and data. Type: A 4-character code (FourCC) that identifies the box’s purpose. Data: The actual content or payload of the box. Some boxes may also include: Extended size: A 64-bit integer that allows for boxes larger than 4GB. User type: A 16-byte (128-bit) UUID that enables the creation of custom boxes without conflicting with standard types. An MP4 file is typically structured in the following way: ftyp (File Type Box): Indicates the file type and compatibility. mdat (Media Data Box): Contains the actual media data (for example, audio and video frames). moov (Movie Box): Contains metadata for the entire presentation, including details about tracks and their structures: trak (Track Box): Represents individual tracks (for example, video, audio) within the file. udta (User Data Box): Stores user-defined data that may include additional metadata or custom information. Once we understand how an MP4 file is structured, we might ask ourselves, “Why are fuzzers not able to successfully mutate an MP4 file?” To answer this question, we need to take a look at how coverage-guided fuzzers mutate input files. Let’s take AFL–one of the most widely used fuzzers out there–as an example. AFL’s default mutators can be summarized as follows: Bit/Bytes mutators: These mutators flip some bits or bytes within the input file. They don’t change the file size. Block insertion/deletion: These mutators insert new data blocks or delete sections from the input file. They modify the file size. The main problem lies in the latter category of mutators. As soon as the fuzzer modifies the data within an mp4 box, the size field of the box should be also updated to reflect the new size. Furthermore, if the size of a box changes, the size fields of all its parent boxes must also be recalculated and updated accordingly. Implementing this functionality as a simple mutator can be quite complex, as it requires the fuzzer to track and update the implicit structure of the MP4 file. Generator implementation The algorithm I used for implementing my generator follows these steps: Step 1: Generating unlabelled trees Structurally, an MP4 file can be visualized as a tree-like structure, where each node corresponds to an MP4 box. Thus, the first step in our generator implementation involves creating a set of unlabelled trees. In this phase, we create trees with empty nodes that do not yet have a tag assigned. Each node represents a potential MP4 box. To make sure we have a variety of input samples, we generate trees with various structures and different node counts. In the following code snippet, we see the constructor of the RandomTree class, which generates a random tree structure with a specified total nodes (total_nodes): RandomTree::RandomTree(uint32_t total_nodes){ uint32_t curr_level = 0; //Root node new_node(-1, curr_level); curr_level++; uint32_t rem_nodes = total_nodes - 1; uint32_t current_node = 0; while(rem_nodes \u003e 0){ uint32_t num_children = rand_uint32(1, rem_nodes); uint32_t min_value = this-\u003elevels[curr_level-1].front(); uint32_t max_value = this-\u003elevels[curr_level-1].back(); for(int i=0; i\u003cnum_children; i++){ uint32_t parent_id = rand_uint32(min_value, max_value); new_node(parent_id, curr_level); } curr_level++; rem_nodes -= num_children; } } This code traverses the tree level by level (Level Order Traversal), adding a random number (rand_uint32) of children nodes (num_children). This approach of assigning a random number of child nodes to each parent node will generate highly diverse tree structures. After all children are added for the current level, curr_level is incremented to move to the next level. Once rem_nodes is 0, the RandomTree generation is complete, and we move on to generate another new RandomTree. Step 2: Assigning tags to nodes Once we have a set of unlabelled trees, we proceed to assign random tags to each node. These tags correspond to the four-character codes (FOURCCs) used to identify the types of MP4 boxes, such as moov, trak, or mdat. In the following code snippet, we see two different fourcc_info structs: FOURCC_LIST which represents the leaf nodes of the tree, and CONTAINER_LIST which represents the rest of the nodes. The fourcc_info struct includes the following fields: fourcc: A 4-byte FourCC ID description: A string describing the FourCC minimum_size: The minimum size of the data associated with this FourCC const fourcc_info CONTAINER_LIST[] = { {FOURCC_moov, \"movie\", 0,}, {FOURCC_vttc, \"VTTCueBox 14496-30\", 0}, {FOURCC_clip, \"clipping\", 0,}, {FOURCC_trak, \"track\", 0,}, {FOURCC_udta, \"user data\", 0,}, … const fourcc_info FOURCC_LIST[] = { {FOURCC_crgn, \"clipping region\", 0,}, {FOURCC_kmat, \"compressed matte\", 0,}, {FOURCC_elst, \"edit list\", 0,}, {FOURCC_load, \"track load settings\", 0,}, Then, the MP4_labeler constructor takes a RandomTree instance as input, iterates through its nodes, and assigns a label to each node based on whether it is a leaf (no children) or a container (has children): … MP4_labeler::MP4_labeler(RandomTree *in_tree) { … for(int i=1; i \u003c this-\u003etree-\u003esize(); i++){ Node \u0026node = this-\u003etree-\u003eget_node(i); … if(node.children().size() == 0){ //LEAF uint32_t random = rand_uint32(0, FOURCC_LIST_SIZE-1); fourcc = FOURCC_LIST[random].fourcc; … }else{ //CONTAINER uint32_t random = rand_uint32(0, CONTAINER_LIST_SIZE-1); fourcc = CONTAINER_LIST[random].fourcc; … } … node.set_label(label); } } After this stage, all nodes will have an assigned tag: Step 3: Adding random-size data fields The next step is to add a random-size data field to each node. This data simulates the content within each MP4 box. In the following code, at first we set the minimum size (min_size) of the padding specified in the selected fourcc_info from FOURCC_LIST. Then, we append padding number of null bytes (\\x00) to the label: if(node.children().size() == 0){ //LEAF … padding = FOURCC_LIST[random].min_size; random_data = rand_uint32(4, 16); }else{ //CONTAINER … padding = CONTAINER_LIST[random].min_size; random_data = 0; } … std::string label = uint32_to_string(fourcc); label += std::string(padding, '\\x00'); label += std::string(random_data, '\\x41'); By varying the data sizes, we make sure the fuzzer has sufficient space to inject data into the box data sections, without needing to modify the input file size. Step 4: Calculating box sizes Finally, we calculate the size of each box and recursively update the tree accordingly. The traverse method recursively traverses the tree structure serializing the node data and calculating the resulting size box (size). Then, it propagates size updates up the tree (traverse(child)) so that parent boxes include the sizes of their child boxes: std::string MP4_labeler::traverse(Node \u0026node){ … for(int i=0; i \u003c node.children().size(); i++){ Node \u0026child = tree-\u003eget_node(node.children()[i]); output += traverse(child); } uint32_t size; if(node.get_id() == 0){ size = 20; }else{ size = node.get_label().size() + output.size() + 4; } std::string label = node.get_label(); uint32_t label_size = label.size(); output = uint32_to_string_BE(size) + label + output; … } The number of generated input files can vary depending on the time and resources you can dedicate to fuzzing. In my case, I generated an input corpus of approximately 4 million files. Code You can find my C++ code example here. Acknowledgments A big thank you to the GStreamer developer team for their collaboration and responsiveness, and especially to Sebastian Dröge for his quick and effective bug fixes. I would also like to thank my colleague, Jonathan Evans, for managing the CVE assignment process. References https://www.mpeg.org/standards/MPEG-4/14/ https://gstreamer.freedesktop.org/ Written by",
  "image": "https://github.blog/wp-content/uploads/2024/02/Security-LightMode-1-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eIn this blog post, I’ll show the results of my recent security research on GStreamer, the open source multimedia framework at the core of GNOME’s multimedia functionality.\u003c/p\u003e\n\u003cp\u003eI’ll also go through the approach I used to find some of the most elusive vulnerabilities, generating a custom input corpus from scratch to enhance fuzzing results.\u003c/p\u003e\n\u003ch2 id=\"gstreamer\" id=\"gstreamer\"\u003eGStreamer\u003ca href=\"#gstreamer\" aria-label=\"GStreamer\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGStreamer is an open source multimedia framework that provides extensive capabilities, including audio and video decoding, subtitle parsing, and media streaming, among others. It also supports a broad range of codecs, such as MP4, MKV, OGG, and AVI.\u003c/p\u003e\n\u003cp\u003eGStreamer is distributed by default on any Linux distribution that uses GNOME as the desktop environment, including Ubuntu, Fedora, and openSUSE. It provides multimedia support for key applications like Nautilus (Ubuntu’s default file browser), GNOME Videos, and Rhythmbox. It’s also used by tracker-miners, the Ubuntu’s metadata indexer–an application \u003ca href=\"https://github.blog/security/vulnerability-research/coordinated-disclosure-1-click-rce-on-gnome-cve-2023-43641/\"\u003ethat my colleague, Kev, was able to exploit last year\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis makes GStreamer a very interesting target from a security perspective, as critical vulnerabilities in the library can open numerous attack vectors. That’s why I picked it as a target for my security research.\u003c/p\u003e\n\u003cp\u003eIt’s worth noting that GStreamer is a large library that includes more than 300 different sub-modules. For this research, I decided to focus on only the “Base” and “Good” plugins, which are included by default in the Ubuntu distribution.\u003c/p\u003e\n\u003ch2 id=\"results\" id=\"results\"\u003eResults\u003ca href=\"#results\" aria-label=\"Results\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDuring my research I found a total of 29 new vulnerabilities in GStreamer, most of them in the MKV and MP4 formats.\u003c/p\u003e\n\u003cp\u003eBelow you can find a summary of the vulnerabilities I discovered:\u003c/p\u003e\n\u003cdiv\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eGHSL\u003c/th\u003e\n\u003cth\u003eCVE\u003c/th\u003e\n\u003cth\u003eDESCRIPTION\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-094_Gstreamer/\"\u003eGHSL-2024-094\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47537\u003c/td\u003e\n\u003ctd\u003eOOB-write in isomp4/qtdemux.c\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-115_GHSL-2024-118_Gstreamer/\"\u003eGHSL-2024-115\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47538\u003c/td\u003e\n\u003ctd\u003eStack-buffer overflow in vorbis_handle_identification_packet\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-115_GHSL-2024-118_Gstreamer/\"\u003eGHSL-2024-116\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47607\u003c/td\u003e\n\u003ctd\u003eStack-buffer overflow in gst_opus_dec_parse_header\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-115_GHSL-2024-118_Gstreamer/\"\u003eGHSL-2024-117\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47615\u003c/td\u003e\n\u003ctd\u003eOOB-Write in gst_parse_vorbis_setup_packet\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-115_GHSL-2024-118_Gstreamer/\"\u003eGHSL-2024-118\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47613\u003c/td\u003e\n\u003ctd\u003eOOB-Write in gst_gdk_pixbuf_dec_flush\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-166_Gstreamer/\"\u003eGHSL-2024-166\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47606\u003c/td\u003e\n\u003ctd\u003eMemcpy parameter overlap in qtdemux_parse_theora_extension leading to OOB-write\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-195_Gstreamer/\"\u003eGHSL-2024-195\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47539\u003c/td\u003e\n\u003ctd\u003eOOB-write in convert_to_s334_1a\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-197_GStreamer/\"\u003eGHSL-2024-197\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47540\u003c/td\u003e\n\u003ctd\u003eUninitialized variable in gst_matroska_demux_add_wvpk_header leading to function pointer ovewriting\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-228_GStreamer/\"\u003eGHSL-2024-228\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47541\u003c/td\u003e\n\u003ctd\u003eOOB-write in subparse/gstssaparse.c\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-235_Gstreamer/\"\u003eGHSL-2024-235\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47542\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in id3v2_read_synch_uint\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-236_Gstreamer/\"\u003eGHSL-2024-236\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47543\u003c/td\u003e\n\u003ctd\u003eOOB-read in qtdemux_parse_container\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-238_Gstreamer/\"\u003eGHSL-2024-238\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47544\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in qtdemux_parse_sbgp\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-242_Gstreamer/\"\u003eGHSL-2024-242\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47545\u003c/td\u003e\n\u003ctd\u003eInteger underflow in FOURCC_strf parsing leading to OOB-read\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-243_Gstreamer/\"\u003eGHSL-2024-243\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47546\u003c/td\u003e\n\u003ctd\u003eInteger underflow in extract_cc_from_data leading to OOB-read\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-244_Gstreamer/\"\u003eGHSL-2024-244\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47596\u003c/td\u003e\n\u003ctd\u003eOOB-read in FOURCC_SMI_ parsing\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-245_Gstreamer/\"\u003eGHSL-2024-245\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47597\u003c/td\u003e\n\u003ctd\u003eOOB-read in qtdemux_parse_samples\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-246_Gstreamer/\"\u003eGHSL-2024-246\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47598\u003c/td\u003e\n\u003ctd\u003eOOB-read in qtdemux_merge_sample_table\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-247_Gstreamer/\"\u003eGHSL-2024-247\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47599\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in gst_jpeg_dec_negotiate\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-248_Gstreamer/\"\u003eGHSL-2024-248\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47600\u003c/td\u003e\n\u003ctd\u003eOOB-read in format_channel_mask\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-249_Gstreamer/\"\u003eGHSL-2024-249\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47601\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in gst_matroska_demux_parse_blockgroup_or_simpleblock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-250_Gstreamer/\"\u003eGHSL-2024-250\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47602\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in gst_matroska_demux_add_wvpk_header\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-251_Gstreamer/\"\u003eGHSL-2024-251\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47603\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in gst_matroska_demux_update_tracks\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-258_Gstreamer/\"\u003eGHSL-2024-258\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47778\u003c/td\u003e\n\u003ctd\u003eOOB-read in gst_wavparse_adtl_chunk\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-259_Gstreamer/\"\u003eGHSL-2024-259\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47777\u003c/td\u003e\n\u003ctd\u003eOOB-read in gst_wavparse_smpl_chunk\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-260_Gstreamer/\"\u003eGHSL-2024-260\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47776\u003c/td\u003e\n\u003ctd\u003eOOB-read in gst_wavparse_cue_chunk\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-261_Gstreamer/\"\u003eGHSL-2024-261\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47775\u003c/td\u003e\n\u003ctd\u003eOOB-read in parse_ds64\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-262_Gstreamer/\"\u003eGHSL-2024-262\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47774\u003c/td\u003e\n\u003ctd\u003eOOB-read in gst_avi_subtitle_parse_gab2_chunk\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-263_Gstreamer/\"\u003eGHSL-2024-263\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47835\u003c/td\u003e\n\u003ctd\u003eNull pointer dereference in parse_lrc\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-280_Gstreamer/\"\u003eGHSL-2024-280\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eCVE-2024-47834\u003c/td\u003e\n\u003ctd\u003eUse-After-Free read in Matroska CodecPrivate\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\u003c/div\u003e\n\n\u003cp\u003eNowadays, coverage-guided fuzzers have become the “de facto” tools for finding vulnerabilities in C/C++ projects. Their ability to discover rare execution paths, combined with their ease of use, has made them the preferred choice among security researchers.\u003c/p\u003e\n\u003cp\u003eThe most common approach is to start with an initial input corpus, which is then successively mutated by the different mutators. The standard method to create this initial input corpus is to gather a large collection of sample files that provide a good representative coverage of the format you want to fuzz.\u003c/p\u003e\n\u003cp\u003eBut with multimedia files, this approach has a major drawback: media files are typically very large (often in the range of megabytes or gigabytes). So, using such large files as the initial input corpus greatly slows down the fuzzing process, as the fuzzer usually goes over every byte of the file.\u003c/p\u003e\n\u003cp\u003eThere are various minimization approaches that try to reduce file size, but they tend to be quite simplistic and often yield poor results. And, in the case of complex file formats, they can even break the file’s logic.\u003c/p\u003e\n\u003cp\u003eIt’s for this reason that for my GStreamer fuzzing journey, I opted for “generating” an initial input corpus from scratch.\u003c/p\u003e\n\u003ch2 id=\"the-alternative-corpus-generators\" id=\"the-alternative-corpus-generators\"\u003eThe alternative: corpus generators\u003ca href=\"#the-alternative-corpus-generators\" aria-label=\"The alternative: corpus generators\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAn alternative to gathering files is to create an input corpus from scratch. Or in other words, without using any preexisting files as examples.\u003c/p\u003e\n\u003cp\u003eTo do this, we need a way to transform the target file format into a program that generates files compliant with that format. Two possible solutions arise:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eUse a grammar-based generator. This category of generators makes use of formal grammars to define the file format, and subsequently generate the input corpus. In this category, we can mention tools like \u003ca href=\"https://dl.acm.org/doi/10.1145/3278186.3278193\"\u003eGrammarinator\u003c/a\u003e, an open source grammar-based fuzzer that creates test cases according to an input ANTLR v4 grammar. In \u003ca href=\"https://securitylab.github.com/research/fuzzing-apache-1/\"\u003ethis past blog post\u003c/a\u003e, I also explained how I used \u003ca href=\"https://github.com/AFLplusplus/Grammar-Mutator\"\u003eAFL++ Grammar-Mutator\u003c/a\u003e for fuzzing Apache HTTP server.\u003c/li\u003e\n\u003cli\u003eTo create a generator specifically for the target software. In this case, we rely on analyzing how the software parses the file format to create a compatible input generator.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eOf course, the second solution is more time-consuming, as we need not only to understand the file format structure but also to analyze how the target software works.\u003c/p\u003e\n\u003cp\u003eBut at the same time, it solves two problems in one shot:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOn one hand, we’ll generate much smaller files, drastically speeding up the fuzzing process speed.\u003c/li\u003e\n\u003cli\u003eOn the other hand, these “custom” files are likely to produce better code coverage and potentially uncover more vulnerabilities.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is the method I opted for and it allowed me to find some of the most interesting vulnerabilities in the MP4 and MKV parsers–vulnerabilities that until then, had not been detected by the fuzzer.\u003c/p\u003e\n\u003ch2 id=\"implementing-an-input-corpus-generator-for-mp4\" id=\"implementing-an-input-corpus-generator-for-mp4\"\u003eImplementing an input corpus generator for MP4\u003ca href=\"#implementing-an-input-corpus-generator-for-mp4\" aria-label=\"Implementing an input corpus generator for MP4\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn this section, I will explain how I created an input corpus generator for the MP4 format. I used the same approach for fuzzing the MKV format as well.\u003c/p\u003e\n\u003ch3 id=\"mp4-format\" id=\"mp4-format\"\u003eMP4 format\u003ca href=\"#mp4-format\" aria-label=\"MP4 format\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eTo start, I will show a brief description of the MP4 format.\u003c/p\u003e\n\u003cp\u003eMP4, officially known as MPEG-4 Part 14, is one of the most widely used multimedia container formats today, due to its broad compatibility and widespread support across various platforms and devices. It supports packaging of multiple media types such as video, audio, images, and complex metadata.\u003c/p\u003e\n\u003cp\u003eMP4 is basically an evolution of Apple’s QuickTime media format, which was standardized by ISO as MPEG-4. The .mp4 container format is specified by the “MPEG-4 Part 14: MP4 file format” section.\u003c/p\u003e\n\u003cp\u003eMP4 files are structured as a series of “boxes” (or “atoms”), each containing specific multimedia data needed to construct the media. Each box has a designated type that describes its purpose.\u003c/p\u003e\n\u003cp\u003eThese boxes can also contain other nested boxes, creating a modular and hierarchical structure that simplifies parsing and manipulation.\u003c/p\u003e\n\u003cp\u003eEach \u003cstrong\u003ebox/atom\u003c/strong\u003e includes the following fields:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSize\u003c/strong\u003e: A 32-bit integer indicating the total size of the box in bytes, including the header and data.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eType\u003c/strong\u003e: A 4-character code (FourCC) that identifies the box’s purpose.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eData\u003c/strong\u003e: The actual content or payload of the box.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSome boxes may also include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eExtended size\u003c/strong\u003e: A 64-bit integer that allows for boxes larger than 4GB.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUser type\u003c/strong\u003e: A 16-byte (128-bit) UUID that enables the creation of custom boxes without conflicting with standard types.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/image1-4.png?w=730\u0026amp;resize=730%2C574\" alt=\"Mp4 box structure\" width=\"730\" height=\"574\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/image1-4.png?w=730 730w, https://github.blog/wp-content/uploads/2024/12/image1-4.png?w=300 300w\" sizes=\"auto, (max-width: 730px) 100vw, 730px\"/\u003e\u003c/p\u003e\n\u003cp\u003eAn MP4 file is typically structured in the following way:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eftyp\u003c/strong\u003e (File Type Box): Indicates the file type and compatibility.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emdat\u003c/strong\u003e (Media Data Box): Contains the actual media data (for example, audio and video frames).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emoov\u003c/strong\u003e (Movie Box): Contains metadata for the entire presentation, including details about tracks and their structures:\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etrak\u003c/strong\u003e (Track Box): Represents individual tracks (for example, video, audio) within the file.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eudta\u003c/strong\u003e (User Data Box): Stores user-defined data that may include additional metadata or custom information.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/image2-3.png?w=1024\u0026amp;resize=1024%2C441\" alt=\"Common MP4 file structure\" width=\"1024\" height=\"441\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/image2-3.png?w=1406 1406w, https://github.blog/wp-content/uploads/2024/12/image2-3.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/image2-3.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/image2-3.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eOnce we understand how an MP4 file is structured, we might ask ourselves, “Why are fuzzers not able to successfully mutate an MP4 file?”\u003c/p\u003e\n\u003cp\u003eTo answer this question, we need to take a look at how coverage-guided fuzzers mutate input files. Let’s take AFL–one of the most widely used fuzzers out there–as an example. AFL’s default mutators can be summarized as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBit/Bytes mutators: These mutators flip some bits or bytes within the input file. They don’t change the file size.\u003c/li\u003e\n\u003cli\u003eBlock insertion/deletion: These mutators insert new data blocks or delete sections from the input file. They modify the file size.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe main problem lies in the latter category of mutators. As soon as the fuzzer modifies the data within an mp4 box, the size field of the box should be also updated to reflect the new size. Furthermore, if the size of a box changes, the size fields of all its parent boxes must also be recalculated and updated accordingly.\u003c/p\u003e\n\u003cp\u003eImplementing this functionality as a simple mutator can be quite complex, as it requires the fuzzer to track and update the implicit structure of the MP4 file.\u003c/p\u003e\n\u003ch3 id=\"generator-implementation\" id=\"generator-implementation\"\u003eGenerator implementation\u003ca href=\"#generator-implementation\" aria-label=\"Generator implementation\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe algorithm I used for implementing my generator follows these steps:\u003c/p\u003e\n\u003ch4 id=\"step-1-generating-unlabelled-trees\" id=\"step-1-generating-unlabelled-trees\"\u003eStep 1: Generating unlabelled trees\u003ca href=\"#step-1-generating-unlabelled-trees\" aria-label=\"Step 1: Generating unlabelled trees\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eStructurally, an MP4 file can be visualized as a tree-like structure, where each node corresponds to an MP4 box. Thus, the first step in our generator implementation involves creating a set of unlabelled trees.\u003c/p\u003e\n\u003cp\u003eIn this phase, we create trees with empty nodes that do not yet have a tag assigned. Each node represents a potential MP4 box. To make sure we have a variety of input samples, we generate trees with various structures and different node counts.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=1024\u0026amp;resize=1024%2C255\" alt=\"3 different 9-node unlabelled trees\" width=\"1024\" height=\"255\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=1999 1999w, https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=1024 1024w, https://github.blog/wp-content/uploads/2024/12/image3-3.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eIn the following code snippet, we see the constructor of the \u003ccode\u003eRandomTree class\u003c/code\u003e, which generates a random tree structure with a specified total nodes (\u003ccode\u003etotal_nodes\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRandomTree::RandomTree(uint32_t total_nodes){\nuint32_t curr_level = 0;\n\n//Root node\nnew_node(-1, curr_level);\ncurr_level++;\n\nuint32_t rem_nodes = total_nodes - 1;\nuint32_t current_node = 0;\n\nwhile(rem_nodes \u0026gt; 0){\n\nuint32_t num_children = rand_uint32(1, rem_nodes);\nuint32_t min_value = this-\u0026gt;levels[curr_level-1].front();\nuint32_t max_value = this-\u0026gt;levels[curr_level-1].back();\n\nfor(int i=0; i\u0026lt;num_children; i++){\nuint32_t parent_id = rand_uint32(min_value, max_value);\nnew_node(parent_id, curr_level);\n}\n\ncurr_level++;\nrem_nodes -= num_children;\n}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code traverses the tree level by level (Level Order Traversal), adding a random number (\u003ccode\u003erand_uint32\u003c/code\u003e) of children nodes (\u003ccode\u003enum_children\u003c/code\u003e). This approach of assigning a random number of child nodes to each parent node will generate highly diverse tree structures.\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/Image3_2.png?w=1024\u0026amp;resize=1024%2C456\" alt=\"Random generation of child nodes\" width=\"1024\" height=\"456\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/Image3_2.png?w=1367 1367w, https://github.blog/wp-content/uploads/2024/12/Image3_2.png?w=300 300w, https://github.blog/wp-content/uploads/2024/12/Image3_2.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/Image3_2.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/p\u003e\n\u003cp\u003eAfter all children are added for the current level, \u003ccode\u003ecurr_level\u003c/code\u003e is incremented to move to the next level.\u003c/p\u003e\n\u003cp\u003eOnce \u003ccode\u003erem_nodes\u003c/code\u003e is 0, the \u003ccode\u003eRandomTree\u003c/code\u003e generation is complete, and we move on to generate another new \u003ccode\u003eRandomTree\u003c/code\u003e.\u003c/p\u003e\n\u003ch4 id=\"step-2-assigning-tags-to-nodes\" id=\"step-2-assigning-tags-to-nodes\"\u003eStep 2: Assigning tags to nodes\u003ca href=\"#step-2-assigning-tags-to-nodes\" aria-label=\"Step 2: Assigning tags to nodes\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eOnce we have a set of unlabelled trees, we proceed to assign random \u003ccode\u003etags\u003c/code\u003e to each node.\u003c/p\u003e\n\u003cp\u003eThese tags correspond to the four-character codes (FOURCCs) used to identify the types of MP4 boxes, such as \u003ccode\u003emoov\u003c/code\u003e, \u003ccode\u003etrak\u003c/code\u003e, or \u003ccode\u003emdat\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn the following code snippet, we see two different \u003ccode\u003efourcc_info\u003c/code\u003e structs: \u003ccode\u003eFOURCC_LIST\u003c/code\u003e which represents the leaf nodes of the tree, and \u003ccode\u003eCONTAINER_LIST\u003c/code\u003e which represents the rest of the nodes.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003efourcc_info\u003c/code\u003e struct includes the following fields:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003efourcc\u003c/em\u003e: A 4-byte FourCC ID\u003c/li\u003e\n\u003cli\u003e\u003cem\u003edescription\u003c/em\u003e: A string describing the FourCC\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eminimum_size\u003c/em\u003e: The minimum size of the data associated with this FourCC\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003econst fourcc_info CONTAINER_LIST[] = {\n\n{FOURCC_moov, \u0026#34;movie\u0026#34;, 0,},\n{FOURCC_vttc, \u0026#34;VTTCueBox 14496-30\u0026#34;, 0},\n{FOURCC_clip, \u0026#34;clipping\u0026#34;, 0,},\n{FOURCC_trak, \u0026#34;track\u0026#34;, 0,},\n{FOURCC_udta, \u0026#34;user data\u0026#34;, 0,},\n…\n\nconst fourcc_info FOURCC_LIST[] = {\n\n{FOURCC_crgn, \u0026#34;clipping region\u0026#34;, 0,},\n{FOURCC_kmat, \u0026#34;compressed matte\u0026#34;, 0,},\n{FOURCC_elst, \u0026#34;edit list\u0026#34;, 0,},\n{FOURCC_load, \u0026#34;track load settings\u0026#34;, 0,},\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen, the \u003ccode\u003eMP4_labeler\u003c/code\u003e constructor takes a \u003ccode\u003eRandomTree\u003c/code\u003e instance as input, iterates through its nodes, and assigns a label to each node based on whether it is a leaf (no children) or a container (has children):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e…\n\nMP4_labeler::MP4_labeler(RandomTree *in_tree) {\n…\nfor(int i=1; i \u0026lt; this-\u0026gt;tree-\u0026gt;size(); i++){\n\nNode \u0026amp;node = this-\u0026gt;tree-\u0026gt;get_node(i);\n…\nif(node.children().size() == 0){\n//LEAF\nuint32_t random = rand_uint32(0, FOURCC_LIST_SIZE-1);\nfourcc = FOURCC_LIST[random].fourcc;\n…\n}else{\n//CONTAINER\nuint32_t random = rand_uint32(0, CONTAINER_LIST_SIZE-1);\nfourcc = CONTAINER_LIST[random].fourcc;\n…\n}\n…\nnode.set_label(label);\n}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter this stage, all nodes will have an assigned tag:\u003c/p\u003e\n\u003cp\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" src=\"https://github.blog/wp-content/uploads/2024/12/image4-3.png?w=811\u0026amp;resize=811%2C1024\" alt=\"Labeled trees with MP4 box tags\" width=\"811\" height=\"1024\" loading=\"lazy\" srcset=\"https://github.blog/wp-content/uploads/2024/12/image4-3.png?w=847 847w, https://github.blog/wp-content/uploads/2024/12/image4-3.png?w=237 237w, https://github.blog/wp-content/uploads/2024/12/image4-3.png?w=768 768w, https://github.blog/wp-content/uploads/2024/12/image4-3.png?w=811 811w\" sizes=\"auto, (max-width: 811px) 100vw, 811px\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"step-3-adding-random-size-data-fields\" id=\"step-3-adding-random-size-data-fields\"\u003eStep 3: Adding random-size data fields\u003ca href=\"#step-3-adding-random-size-data-fields\" aria-label=\"Step 3: Adding random-size data fields\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eThe next step is to add a random-size data field to each node. This data simulates the content within each MP4 box.\u003cbr/\u003e\nIn the following code, at first we set the minimum size (\u003ccode\u003emin_size\u003c/code\u003e) of the padding specified in the selected \u003ccode\u003efourcc_info\u003c/code\u003e from \u003ccode\u003eFOURCC_LIST\u003c/code\u003e. Then, we append \u003ccode\u003epadding\u003c/code\u003e number of null bytes (\\x00) to the label:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif(node.children().size() == 0){\n//LEAF\n…\npadding = FOURCC_LIST[random].min_size;\nrandom_data = rand_uint32(4, 16);\n}else{\n//CONTAINER\n…\npadding = CONTAINER_LIST[random].min_size;\nrandom_data = 0;\n}\n…\nstd::string label = uint32_to_string(fourcc);\nlabel += std::string(padding, \u0026#39;\\x00\u0026#39;);\nlabel += std::string(random_data, \u0026#39;\\x41\u0026#39;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy varying the data sizes, we make sure the fuzzer has sufficient space to inject data into the box data sections, without needing to modify the input file size.\u003c/p\u003e\n\u003ch4 id=\"step-4-calculating-box-sizes\" id=\"step-4-calculating-box-sizes\"\u003eStep 4: Calculating box sizes\u003ca href=\"#step-4-calculating-box-sizes\" aria-label=\"Step 4: Calculating box sizes\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eFinally, we calculate the size of each box and recursively update the tree accordingly.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003etraverse\u003c/code\u003e method recursively traverses the tree structure serializing the node data and calculating the resulting size box (\u003ccode\u003esize)\u003c/code\u003e. Then, it propagates size updates up the tree (\u003ccode\u003etraverse(child)\u003c/code\u003e) so that parent boxes include the sizes of their child boxes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estd::string MP4_labeler::traverse(Node \u0026amp;node){\n…\nfor(int i=0; i \u0026lt; node.children().size(); i++){ Node \u0026amp;child = tree-\u0026gt;get_node(node.children()[i]);\n\noutput += traverse(child);\n}\n\nuint32_t size;\nif(node.get_id() == 0){\nsize = 20;\n}else{\nsize = node.get_label().size() + output.size() + 4;\n}\n\nstd::string label = node.get_label();\nuint32_t label_size = label.size();\n\noutput = uint32_to_string_BE(size) + label + output;\n…\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe number of generated input files can vary depending on the time and resources you can dedicate to fuzzing. In my case, I generated an input corpus of approximately 4 million files.\u003c/p\u003e\n\u003ch3 id=\"code\" id=\"code\"\u003eCode\u003ca href=\"#code\" aria-label=\"Code\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou can find my C++ code example \u003ca href=\"https://github.com/github/securitylab/tree/main/Fuzzing/GStreamer\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"acknowledgments\" id=\"acknowledgments\"\u003eAcknowledgments\u003ca href=\"#acknowledgments\" aria-label=\"Acknowledgments\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA big thank you to the GStreamer developer team for their collaboration and responsiveness, and especially to \u003ca href=\"https://github.com/sdroege\"\u003eSebastian Dröge\u003c/a\u003e for his quick and effective bug fixes.\u003c/p\u003e\n\u003cp\u003eI would also like to thank my colleague, \u003ca href=\"https://github.com/jonathanlevans\"\u003eJonathan Evans\u003c/a\u003e, for managing the CVE assignment process.\u003c/p\u003e\n\u003ch2 id=\"references\" id=\"references\"\u003eReferences\u003ca href=\"#references\" aria-label=\"References\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.mpeg.org/standards/MPEG-4/14/\"\u003ehttps://www.mpeg.org/standards/MPEG-4/14/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gstreamer.freedesktop.org/\"\u003ehttps://gstreamer.freedesktop.org/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/55253029?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/55253029?v=4\u0026amp;s=200\" alt=\"Antonio Morales\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2024-12-17T13:51:51Z",
  "modifiedTime": null
}
