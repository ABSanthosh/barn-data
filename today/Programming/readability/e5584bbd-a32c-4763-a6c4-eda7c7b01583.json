{
  "id": "e5584bbd-a32c-4763-a6c4-eda7c7b01583",
  "title": "Uber's Cloud Journey: Embracing ARM in an x86 World",
  "link": "https://www.infoq.com/news/2025/02/uber-arm-cloud/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Uber embarked on a strategic migration from on-premise data centers to Oracle Cloud Infrastructure (OCI) and Google Cloud Platform in February 2023. A key component of this migration was integrating ARM-based computers into their predominantly x86 fleet to reduce costs, improve price performance, and ensure hardware flexibility amid supply chain uncertainties. By Claudio Masolo",
  "author": "Claudio Masolo",
  "published": "Sat, 22 Feb 2025 09:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "Cloud Adoption",
    "Cloud",
    "ARM",
    "Cloud Computing",
    "DevOps",
    "news"
  ],
  "byline": "Claudio Masolo",
  "length": 5045,
  "excerpt": "Uber embarked on a strategic migration from on-premise data centers to Oracle Cloud Infrastructure (OCI) and Google Cloud Platform in February 2023. A key component of this migration was integrating A",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20250213201515/apple-touch-icon.png",
  "text": "Uber embarked on a strategic migration from on-premise data centers to Oracle Cloud Infrastructure (OCI) and Google Cloud Platform in February 2023. A key component of this migration was integrating ARM-based computers into their predominantly x86 fleet to reduce costs, improve price performance, and ensure hardware flexibility amid supply chain uncertainties. The x86 and ARM architectures represent fundamentally different philosophies in processor design, with their distinctions shaping the computing landscape for decades. While x86 (developed by Intel and AMD) follows a Complex Instruction Set Computing (CISC) approach that prioritizes backward compatibility and complex instructions executed in microcode, ARM embraces Reduced Instruction Set Computing (RISC) principles with simpler, fixed-length instructions that execute in a single cycle. This architectural difference manifests in practical terms: x86 processors typically deliver higher peak performance for computationally intensive tasks but consume more power, making them dominant in desktops and servers where electrical outlets are readily available; meanwhile, ARM processors excel in energy efficiency, offering better performance-per-watt ratios that have made them the architecture of choice for mobile devices, embedded systems, and increasingly for power-conscious data centers. The multi-architecture integration wasn't simply about deploying new hardware. For Uber's infrastructure team, it meant rethinking fundamental systems that had been exclusively x86-based for years. The journey revealed how deeply architecture assumptions can permeate every layer of a technology stack. At the foundation of this transition was Oracle Cloud Infrastructure's strategic embrace of Ampere Computing's ARM processors. These chips deliver remarkable energy efficiency – a trait ARM perfected in the mobile space now scaled to data center environments. For cloud providers, this translates to substantial power savings and increased compute density, reducing both energy costs and physical footprint requirements. For Uber, these advantages align perfectly with its sustainability goals. As the company works toward zero emissions, adopting energy-efficient computing infrastructure represents a meaningful step in reducing its environmental impact while simultaneously improving its cost structure. The transition began with host-level readiness – creating ARM-compatible images encompassing the operating system, kernel, and essential infrastructure components. Once hosts could boot, the team confronted their build pipeline, which revealed a complex web of dependencies. Uber's container system relied on Makisu, a tool optimized for x86 that couldn't cross-compile for ARM. Build pipeline for container images Rather than rewriting 5,000+ service build processes, the team employed a clever bootstrapping approach. They leveraged Google Bazel to build an ARM version of Makisu itself, which could then build other services natively. This seemingly straightforward task exposed circular dependencies: Makisu ran on Buildkite, which ran on Uber's Odin platform, which depended on host agents – all built with Makisu. Breaking this circular dependency required methodically rebuilding each layer using Bazel's multi-architecture capabilities. The team started with host agents, then rebuilt Odin's components, followed by Buildkite, and finally Makisu. This foundation enabled a distributed build pipeline that could generate unified multi-architecture container images. While this approach doubled build costs (with over 400,000 weekly container builds), the economics still favored ARM adoption. The distributed build system also provided a crucial advantage: it enabled gradual, controlled migration rather than an all-or-nothing approach. The deployment systems required similar enhancements. Uber implemented architecture-specific placement constraints and automatic fallback mechanisms that would revert to x86 if compatibility issues arose. These safeguards allowed the team to migrate services incrementally while maintaining production reliability. The successful deployment of their first ARM-based services marked a technical milestone, proving that multi-architecture infrastructure could work at Uber's scale. However, the journey from this initial success to migrating thousands of services requires additional strategies and tooling. As cloud providers expand their processor architecture options, organizations like Uber and Bitmovin demonstrate both the challenges and potential benefits of incorporating diverse computing architectures into large-scale infrastructure systems. Bitmovin's complete migration of their encoding services to ARM processors, alongside Uber's experiences, offers valuable insights into how companies can navigate architectural heterogeneity at massive scale. About the Author Claudio Masolo",
  "image": "https://res.infoq.com/news/2025/02/uber-arm-cloud/en/card_header_image/generatedCard-1740141457810.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eUber \u003ca href=\"https://www.uber.com/en-AU/blog/adopting-arm-at-scale-bootstrapping-infrastructure/\"\u003eembarked\u003c/a\u003e on a strategic migration from on-premise data centers to \u003ca href=\"https://www.oracle.com/cloud/\"\u003eOracle Cloud Infrastructure \u003c/a\u003e(OCI) and \u003ca href=\"https://cloud.google.com/?hl=en\"\u003eGoogle Cloud Platform\u003c/a\u003e in February 2023. A key component of this migration was integrating ARM-based computers into their predominantly x86 fleet to reduce costs, improve price performance, and ensure hardware flexibility amid supply chain uncertainties.\u003c/p\u003e\n\n\u003cp\u003eThe x86 and ARM architectures represent fundamentally different philosophies in processor design, with their distinctions shaping the computing landscape for decades. While x86 (developed by Intel and AMD) follows a \u003ca href=\"https://en.wikipedia.org/wiki/Complex_instruction_set_computer\"\u003eComplex Instruction Set Computing\u003c/a\u003e (CISC) approach that prioritizes backward compatibility and complex instructions executed in microcode, ARM embraces \u003ca href=\"https://en.wikipedia.org/wiki/Reduced_instruction_set_computer\"\u003eReduced Instruction Set Computing\u003c/a\u003e (RISC) principles with simpler, fixed-length instructions that execute in a single cycle.\u003c/p\u003e\n\n\u003cp\u003eThis architectural difference manifests in practical terms: x86 processors typically deliver higher peak performance for computationally intensive tasks but consume more power, making them dominant in desktops and servers where electrical outlets are readily available; meanwhile, ARM processors excel in energy efficiency, offering better performance-per-watt ratios that have made them the architecture of choice for mobile devices, embedded systems, and increasingly for power-conscious data centers.\u003c/p\u003e\n\n\u003cp\u003eThe multi-architecture integration wasn\u0026#39;t simply about deploying new hardware. For Uber\u0026#39;s infrastructure team, it meant rethinking fundamental systems that had been exclusively x86-based for years. The journey revealed how deeply architecture assumptions can permeate every layer of a technology stack.\u003c/p\u003e\n\n\u003cp\u003eAt the foundation of this transition was Oracle Cloud Infrastructure\u0026#39;s strategic embrace of Ampere Computing\u0026#39;s ARM processors. These chips deliver remarkable energy efficiency – a trait ARM perfected in the mobile space now scaled to data center environments. For cloud providers, this translates to substantial power savings and increased compute density, reducing both energy costs and physical footprint requirements.\u003c/p\u003e\n\n\u003cp\u003eFor Uber, these advantages align perfectly with its sustainability goals. As the company works toward zero emissions, adopting energy-efficient computing infrastructure represents a meaningful step in reducing its environmental impact while simultaneously improving its cost structure.\u003c/p\u003e\n\n\u003cp\u003eThe transition began with host-level readiness – creating ARM-compatible images encompassing the operating system, kernel, and essential infrastructure components. Once hosts could boot, the team confronted their build pipeline, which revealed a complex web of dependencies. Uber\u0026#39;s container system relied on \u003ca href=\"https://www.uber.com/en-IE/blog/makisu/\"\u003eMakisu\u003c/a\u003e, a tool optimized for x86 that couldn\u0026#39;t cross-compile for ARM.\u003c/p\u003e\n\n\n\n\u003ccenter\u003e\u003cimg alt=\"\" data-src=\"news/2025/02/uber-arm-cloud/en/resources/1distributedbuildpipeline-17394210469874-1740141998746.jpg\" src=\"https://imgopt.infoq.com/fit-in/3000x4000/filters:quality(85)/filters:no_upscale()/news/2025/02/uber-arm-cloud/en/resources/1distributedbuildpipeline-17394210469874-1740141998746.jpg\" rel=\"share\"/\u003e\u003c/center\u003e\n\n\u003cp\u003e\u003csmall\u003e\u003cbig\u003eBuild pipeline for container images\u003c/big\u003e\u003c/small\u003e\u003c/p\u003e\n\n\u003cp\u003eRather than rewriting 5,000+ service build processes, the team employed a clever bootstrapping approach. They leveraged \u003ca href=\"https://bazel.build/\"\u003eGoogle Bazel\u003c/a\u003e to build an ARM version of Makisu itself, which could then build other services natively. This seemingly straightforward task exposed circular dependencies: Makisu ran on Buildkite, which ran on Uber\u0026#39;s Odin platform, which depended on host agents – all built with Makisu.\u003c/p\u003e\n\n\u003cp\u003eBreaking this circular dependency required methodically rebuilding each layer using Bazel\u0026#39;s multi-architecture capabilities. The team started with host agents, then rebuilt Odin\u0026#39;s components, followed by Buildkite, and finally Makisu. This foundation enabled a distributed build pipeline that could generate unified multi-architecture container images.\u003c/p\u003e\n\n\u003cp\u003eWhile this approach doubled build costs (with over 400,000 weekly container builds), the economics still favored ARM adoption. The distributed build system also provided a crucial advantage: it enabled gradual, controlled migration rather than an all-or-nothing approach.\u003c/p\u003e\n\n\u003cp\u003eThe deployment systems required similar enhancements. Uber implemented architecture-specific placement constraints and automatic fallback mechanisms that would revert to x86 if compatibility issues arose. These safeguards allowed the team to migrate services incrementally while maintaining production reliability.\u003c/p\u003e\n\n\u003cp\u003eThe successful deployment of their first ARM-based services marked a technical milestone, proving that multi-architecture infrastructure could work at Uber\u0026#39;s scale. However, the journey from this initial success to migrating thousands of services requires additional strategies and tooling.\u003c/p\u003e\n\n\u003cp\u003eAs cloud providers expand their processor architecture options, organizations like Uber and Bitmovin demonstrate both the challenges and potential benefits of incorporating diverse computing architectures into large-scale infrastructure systems. Bitmovin\u0026#39;s complete \u003ca href=\"https://bitmovin.com/blog/x86-to-arm-part-1-library-dependencies\"\u003emigration of their encoding services\u003c/a\u003e to ARM processors, alongside Uber\u0026#39;s experiences, offers valuable insights into how companies can navigate architectural heterogeneity at massive scale.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Claudio-Masolo\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eClaudio Masolo\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-02-22T00:00:00Z",
  "modifiedTime": null
}
