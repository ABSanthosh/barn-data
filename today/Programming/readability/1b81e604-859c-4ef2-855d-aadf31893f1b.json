{
  "id": "1b81e604-859c-4ef2-855d-aadf31893f1b",
  "title": "Guide to Heaps in Python",
  "link": "https://stackabuse.com/guide-to-heaps-in-python/",
  "description": "Explore the intricacies of heaps, a tree-based data structure adept at maintaining order and hierarchy. Dive into Python's' heapq module, offering a rich set of functionalities for managing dynamic data sets where priority elements are frequently accessed. Learn how heaps stand out in the world of data structures and their seamless integration in Python.",
  "author": "Dimitrije Stamenic",
  "published": "Wed, 15 Nov 2023 19:21:52 GMT",
  "source": "https://stackabuse.com/rss/",
  "categories": [
    "python",
    "data structures"
  ],
  "byline": "Dimitrije Stamenic",
  "length": 15651,
  "excerpt": "Explore the intricacies of heaps, a tree-based data structure adept at maintaining order and hierarchy. Dive into Python's' heapq module, offering a rich set of functionalities for managing dynamic data sets where priority elements are frequently accessed. Learn how heaps stand out in the world of data structures and their seamless integration in Python.",
  "siteName": "Stack Abuse",
  "favicon": "",
  "text": "In this guide, we'll embark on a journey to understand heaps from the ground up. We'll start by demystifying what heaps are and their inherent properties. From there, we'll dive into Python's own implementation of heaps, the heapq module, and explore its rich set of functionalities. So, if you've ever wondered how to efficiently manage a dynamic set of data where the highest (or lowest) priority element is frequently needed, you're in for a treat. What is a Heap? The first thing you'd want to understand before diving into the usage of heaps is what is a heap. A heap stands out in the world of data structures as a tree-based powerhouse, particularly skilled at maintaining order and hierarchy. While it might resemble a binary tree to the untrained eye, the nuances in its structure and governing rules distinctly set it apart. One of the defining characteristics of a heap is its nature as a complete binary tree. This means that every level of the tree, except perhaps the last, is entirely filled. Within this last level, nodes populate from left to right. Such a structure ensures that heaps can be efficiently represented and manipulated using arrays or lists, with each element's position in the array mirroring its placement in the tree. The true essence of a heap, however, lies in its ordering. In a max heap, any given node's value surpasses or equals the values of its children, positioning the largest element right at the root. On the other hand, a min heap operates on the opposite principle: any node's value is either less than or equal to its children's values, ensuring the smallest element sits at the root. Advice: You can visualize a heap as a pyramid of numbers. For a max heap, as you ascend from the base to the peak, the numbers increase, culminating in the maximum value at the pinnacle. In contrast, a min heap starts with the minimum value at its peak, with numbers escalating as you move downwards. As we progress, we'll dive deeper into how these inherent properties of heaps enable efficient operations and how Python's heapq module seamlessly integrates heaps into our coding endeavors. Characteristics and Properties of Heaps Heaps, with their unique structure and ordering principles, bring forth a set of distinct characteristics and properties that make them invaluable in various computational scenarios. First and foremost, heaps are inherently efficient. Their tree-based structure, specifically the complete binary tree format, ensures that operations like insertion and extraction of priority elements (maximum or minimum) can be performed in logarithmic time, typically O(log n). This efficiency is a boon for algorithms and applications that require frequent access to priority elements. Another notable property of heaps is their memory efficiency. Since heaps can be represented using arrays or lists without the need for explicit pointers to child or parent nodes, they are space-saving. Each element's position in the array corresponds to its placement in the tree, allowing for predictable and straightforward traversal and manipulation. The ordering property of heaps, whether as a max heap or a min heap, ensures that the root always holds the element of highest priority. This consistent ordering is what allows for quick access to the top-priority element without having to search through the entire structure. Furthermore, heaps are versatile. While binary heaps (where each parent has at most two children) are the most common, heaps can be generalized to have more than two children, known as d-ary heaps. This flexibility allows for fine-tuning based on specific use cases and performance requirements. Lastly, heaps are self-adjusting. Whenever elements are added or removed, the structure rearranges itself to maintain its properties. This dynamic balancing ensures that the heap remains optimized for its core operations at all times. Advice: These properties made heap data structure a good fit for an efficient sorting algorithm - heap sort. To learn more about heap sort in Python, read our \"Heap Sort in Python\" article. As we delve deeper into Python's implementation and practical applications, the true potential of heaps will unfold before us. Types of Heaps Not all heaps are created equal. Depending on their ordering and structural properties, heaps can be categorized into different types, each with its own set of applications and advantages. The two main categories are max heap and min heap. The most distinguishing feature of a max heap is that the value of any given node is greater than or equal to the values of its children. This ensures that the largest element in the heap always resides at the root. Such a structure is particularly useful when there's a need to frequently access the maximum element, as in certain priority queue implementations. The counterpart to the max heap, a min heap ensures that the value of any given node is less than or equal to the values of its children. This positions the smallest element of the heap at the root. Min heaps are invaluable in scenarios where the least element is of prime importance, such as in algorithms that deal with real-time data processing. Beyond these primary categories, heaps can also be distinguished based on their branching factor: While binary heaps are the most common, with each parent having at most two children, the concept of heaps can be extended to nodes having more than two children. In a d-ary heap, each node has at most d children. This variation can be optimized for specific scenarios, like decreasing the height of the tree to speed up certain operations. Binomial Heap is a set of binomial trees that are defined recursively. Binomial heaps are used in priority queue implementations and offer efficient merge operations. Named after the famous Fibonacci sequence, the Fibonacci heap offers better-amortized running times for many operations compared to binary or binomial heaps. They're particularly useful in network optimization algorithms. Python's Heap Implementation - The heapq Module Python offers a built-in module for heap operations - the heapq module. This module provides a collection of heap-related functions that allow developers to transform lists into heaps and perform various heap operations without the need for a custom implementation. Let's dive into the nuances of this module and how it brings you the power of heaps. The heapq module doesn't provide a distinct heap data type. Instead, it offers functions that work on regular Python lists, transforming and treating them as binary heaps. This approach is both memory-efficient and integrates seamlessly with Python's existing data structures. That means that heaps are represented as lists in heapq. The beauty of this representation is its simplicity - the zero-based list index system serves as an implicit binary tree. For any given element at position i, its: Left Child is at position 2*i + 1 Right Child is at position 2*i + 2 Parent Node is at position (i-1)//2 This implicit structure ensures that there's no need for a separate node-based binary tree representation, making operations straightforward and memory usage minimal. Space Complexity: Heaps are typically implemented as binary trees but don't require storage of explicit pointers for child nodes. This makes them space-efficient with a space complexity of O(n) for storing n elements. It's essential to note that the heapq module creates min heaps by default. This means that the smallest element is always at the root (or the first position in the list). If you need a max heap, you'd have to invert order by multiplying elements by -1 or use a custom comparison function. Python's heapq module provides a suite of functions that allow developers to perform various heap operations on lists. Note: To use the heapq module in your application, you'll need to import it using simple import heapq. Check out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually learn it!In the following sections, we'll dive deep into each of these fundamental operations, exploring their mechanics and use cases. How to Transform a List into a Heap The heapify() function is the starting point for many heap-related tasks. It takes an iterable (typically a list) and rearranges its elements in-place to satisfy the properties of a min heap: import heapq data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] heapq.heapify(data) print(data) This will output a reordered list that represents a valid min heap: [1, 1, 2, 3, 3, 9, 4, 6, 5, 5, 5] Time Complexity: Converting an unordered list into a heap using the heapify function is an O(n) operation. This might seem counterintuitive, as one might expect it to be O(nlogn), but due to the tree structure's properties, it can be achieved in linear time. How to Add an Element to the Heap The heappush() function allows you to insert a new element into the heap while maintaining the heap's properties: import heapq heap = [] heapq.heappush(heap, 5) heapq.heappush(heap, 3) heapq.heappush(heap, 7) print(heap) Running the code will give you a list of elements maintaining the min heap property: [3, 5, 7] Time Complexity: The insertion operation in a heap, which involves placing a new element in the heap while maintaining the heap property, has a time complexity of O(logn). This is because, in the worst case, the element might have to travel from the leaf to the root. How to Remove and Return the Smallest Element from the Heap The heappop() function extracts and returns the smallest element from the heap (the root in a min heap). After removal, it ensures the list remains a valid heap: import heapq heap = [1, 3, 5, 7, 9] print(heapq.heappop(heap)) print(heap) Note: The heappop() is invaluable in algorithms that require processing elements in ascending order, like the Heap Sort algorithm, or when implementing priority queues where tasks are executed based on their urgency. This will output the smallest element and the remaining list: 1 [3, 7, 5, 9] Here, 1 is the smallest element from the heap, and the remaining list has maintained the heap property, even after we removed 1. Time Complexity: Removing the root element (which is the smallest in a min heap or largest in a max heap) and reorganizing the heap also takes O(logn) time. How to Push a New Item and Pop the Smallest Item The heappushpop() function is a combined operation that pushes a new item onto the heap and then pops and returns the smallest item from the heap: import heapq heap = [3, 5, 7, 9] print(heapq.heappushpop(heap, 4)) print(heap) This will output 3, the smallest element, and print out the new heap list that now includes 4 while maintaining the heap property: 3 [4, 5, 7, 9] Note: Using the heappushpop() function is more efficient than performing operations of pushing a new element and popping the smallest one separately. How to Replace the Smallest Item and Push a New Item The heapreplace() function pops the smallest element and pushes a new element onto the heap, all in one efficient operation: import heapq heap = [1, 5, 7, 9] print(heapq.heapreplace(heap, 4)) print(heap) This prints 1, the smallest element, and the list now includes 4 and maintains the heap property: 1 [4, 5, 7, 9] Note: heapreplace() is beneficial in streaming scenarios where you want to replace the current smallest element with a new value, such as in rolling window operations or real-time data processing tasks. Finding Multiple Extremes in Python's Heap nlargest(n, iterable[, key]) and nsmallest(n, iterable[, key]) functions are designed to retrieve multiple largest or smallest elements from an iterable. They can be more efficient than sorting the entire iterable when you only need a few extreme values. For example, say you have the following list and you want to find three smallest and three largest values in the list: data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] Here, nlargest() and nsmallest() functions can come in handy: import heapq data = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5] print(heapq.nlargest(3, data)) # Outputs [9, 6, 5] print(heapq.nsmallest(3, data)) # Outputs [1, 1, 2] This will give you two lists - one contains the three largest values and the other contains the three smallest values from the data list: [9, 6, 5] [1, 1, 2] How to Build Your Custom Heap While Python's heapq module provides a robust set of tools for working with heaps, there are scenarios where the default min heap behavior might not suffice. Whether you're looking to implement a max heap or need a heap that operates based on custom comparison functions, building a custom heap can be the answer. Let's explore how to tailor heaps to specific needs. Implementing a Max Heap using heapq By default, heapq creates min heaps. However, with a simple trick, you can use it to implement a max heap. The idea is to invert the order of elements by multiplying them by -1 before adding them to the heap: import heapq class MaxHeap: def __init__(self): self.heap = [] def push(self, val): heapq.heappush(self.heap, -val) def pop(self): return -heapq.heappop(self.heap) def peek(self): return -self.heap[0] With this approach, the largest number (in terms of absolute value) becomes the smallest, allowing the heapq functions to maintain a max heap structure. Heaps with Custom Comparison Functions Sometimes, you might need a heap that doesn't just compare based on the natural order of elements. For instance, if you're working with complex objects or have specific sorting criteria, a custom comparison function becomes essential. To achieve this, you can wrap elements in a helper class that overrides the comparison operators: import heapq class CustomElement: def __init__(self, obj, comparator): self.obj = obj self.comparator = comparator def __lt__(self, other): return self.comparator(self.obj, other.obj) def custom_heappush(heap, obj, comparator=lambda x, y: x \u003c y): heapq.heappush(heap, CustomElement(obj, comparator)) def custom_heappop(heap): return heapq.heappop(heap).obj With this setup, you can define any custom comparator function and use it with the heap.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eIn this guide, we\u0026#39;ll embark on a journey to understand heaps from the ground up. We\u0026#39;ll start by demystifying what heaps are and their inherent properties. From there, we\u0026#39;ll dive into Python\u0026#39;s own implementation of heaps, the \u003ccode\u003eheapq\u003c/code\u003e module, and explore its rich set of functionalities. So, if you\u0026#39;ve ever wondered how to efficiently manage a dynamic set of data where the highest (or lowest) priority element is frequently needed, you\u0026#39;re in for a treat.\u003c/p\u003e\n\u003ch3 id=\"whatisaheap\"\u003eWhat is a Heap?\u003c/h3\u003e\n\u003cp\u003eThe first thing you\u0026#39;d want to understand before diving into the usage of heaps is \u003cem\u003ewhat is a heap\u003c/em\u003e. A heap stands out in the world of data structures as a tree-based powerhouse, particularly skilled at \u003cstrong\u003emaintaining order and hierarchy\u003c/strong\u003e. While it might resemble a binary tree to the untrained eye, the nuances in its structure and governing rules distinctly set it apart.\u003c/p\u003e\n\u003cp\u003eOne of the defining characteristics of a heap is its nature as a \u003cem\u003e\u003cstrong\u003ecomplete binary tree\u003c/strong\u003e\u003c/em\u003e. This means that every level of the tree, except perhaps the last, is entirely filled. Within this last level, nodes populate from left to right. Such a structure ensures that heaps can be efficiently represented and manipulated using arrays or lists, with each element\u0026#39;s position in the array mirroring its placement in the tree.\u003c/p\u003e\n\n\u003cp\u003eThe true essence of a heap, however, lies in its \u003cem\u003e\u003cstrong\u003eordering\u003c/strong\u003e\u003c/em\u003e. In a \u003cem\u003emax heap\u003c/em\u003e, any given node\u0026#39;s value surpasses or equals the values of its children, positioning the largest element right at the root. On the other hand, a \u003cem\u003emin heap\u003c/em\u003e operates on the opposite principle: any node\u0026#39;s value is either less than or equal to its children\u0026#39;s values, ensuring the smallest element sits at the root.\u003c/p\u003e\n\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eAdvice:\u003c/strong\u003e You can visualize a heap as a \u003cem\u003epyramid of numbers\u003c/em\u003e. For a max heap, as you ascend from the base to the peak, the numbers increase, culminating in the maximum value at the pinnacle. In contrast, a min heap starts with the minimum value at its peak, with numbers escalating as you move downwards.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eAs we progress, we\u0026#39;ll dive deeper into how these inherent properties of heaps enable efficient operations and how Python\u0026#39;s \u003ccode\u003eheapq\u003c/code\u003e module seamlessly integrates heaps into our coding endeavors.\u003c/p\u003e\n\u003ch3 id=\"characteristicsandpropertiesofheaps\"\u003eCharacteristics and Properties of Heaps\u003c/h3\u003e\n\u003cp\u003eHeaps, with their unique structure and ordering principles, bring forth a set of distinct characteristics and properties that make them invaluable in various computational scenarios.\u003c/p\u003e\n\u003cp\u003eFirst and foremost, heaps are \u003cstrong\u003einherently efficient\u003c/strong\u003e. Their tree-based structure, specifically the complete binary tree format, ensures that operations like insertion and extraction of priority elements (maximum or minimum) can be performed in logarithmic time, typically \u003cem\u003eO(log n)\u003c/em\u003e. This efficiency is a boon for algorithms and applications that require frequent access to priority elements.\u003c/p\u003e\n\u003cp\u003eAnother notable property of heaps is their \u003cstrong\u003ememory efficiency\u003c/strong\u003e. Since heaps can be represented using arrays or lists without the need for explicit pointers to child or parent nodes, they are space-saving. Each element\u0026#39;s position in the array corresponds to its placement in the tree, allowing for predictable and straightforward traversal and manipulation.\u003c/p\u003e\n\u003cp\u003eThe ordering property of heaps, whether as a max heap or a min heap, ensures that \u003cstrong\u003ethe root always holds the element of highest priority\u003c/strong\u003e. This consistent ordering is what allows for quick access to the top-priority element without having to search through the entire structure.\u003c/p\u003e\n\u003cp\u003eFurthermore, heaps are \u003cstrong\u003eversatile\u003c/strong\u003e. While binary heaps (where each parent has at most two children) are the most common, heaps can be generalized to have more than two children, known as \u003cem\u003ed-ary heaps\u003c/em\u003e. This flexibility allows for fine-tuning based on specific use cases and performance requirements.\u003c/p\u003e\n\u003cp\u003eLastly, heaps are \u003cstrong\u003eself-adjusting\u003c/strong\u003e. Whenever elements are added or removed, the structure rearranges itself to maintain its properties. This dynamic balancing ensures that the heap remains optimized for its core operations at all times.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eAdvice:\u003c/strong\u003e These properties made heap data structure a good fit for an efficient sorting algorithm - heap sort. To learn more about heap sort in Python, read our \u003ca target=\"_blank\" href=\"https://stackabuse.com/heap-sort-in-python/\"\u003e\u0026#34;Heap Sort in Python\u0026#34;\u003c/a\u003e article.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eAs we delve deeper into Python\u0026#39;s implementation and practical applications, the true potential of heaps will unfold before us.\u003c/p\u003e\n\u003ch3 id=\"typesofheaps\"\u003eTypes of Heaps\u003c/h3\u003e\n\u003cp\u003eNot all heaps are created equal. Depending on their ordering and structural properties, heaps can be categorized into different types, each with its own set of applications and advantages. The two main categories are \u003cem\u003emax heap\u003c/em\u003e and \u003cem\u003emin heap\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe most distinguishing feature of a \u003cstrong\u003emax heap\u003c/strong\u003e is that the value of any given node is greater than or equal to the values of its children. This ensures that the largest element in the heap always resides at the root. Such a structure is particularly useful when there\u0026#39;s a need to frequently access the maximum element, as in certain priority queue implementations.\u003c/p\u003e\n\u003cp\u003eThe counterpart to the max heap, a \u003cstrong\u003emin heap\u003c/strong\u003e ensures that the value of any given node is less than or equal to the values of its children. This positions the smallest element of the heap at the root. Min heaps are invaluable in scenarios where the least element is of prime importance, such as in algorithms that deal with real-time data processing.\u003c/p\u003e\n\u003cp\u003eBeyond these primary categories, heaps can also be distinguished based on their branching factor:\u003c/p\u003e\n\u003cp\u003eWhile binary heaps are the most common, with each parent having at most two children, the concept of heaps can be extended to nodes having more than two children. In a \u003cstrong\u003ed-ary heap\u003c/strong\u003e, each node has at most \u003ccode\u003ed\u003c/code\u003e children. This variation can be optimized for specific scenarios, like decreasing the height of the tree to speed up certain operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBinomial Heap\u003c/strong\u003e is a set of binomial trees that are defined recursively. Binomial heaps are used in priority queue implementations and offer efficient merge operations.\u003c/p\u003e\n\u003cp\u003eNamed after the famous Fibonacci sequence, the \u003cstrong\u003eFibonacci heap\u003c/strong\u003e offers better-amortized running times for many operations compared to binary or binomial heaps. They\u0026#39;re particularly useful in network optimization algorithms.\u003c/p\u003e\n\u003ch3 id=\"pythonsheapimplementationtheheapqmodule\"\u003ePython\u0026#39;s Heap Implementation - The \u003cem\u003eheapq\u003c/em\u003e Module\u003c/h3\u003e\n\u003cp\u003ePython offers a built-in module for heap operations - the \u003ccode\u003eheapq\u003c/code\u003e module. This module provides a collection of heap-related functions that allow developers to transform lists into heaps and perform various heap operations without the need for a custom implementation. Let\u0026#39;s dive into the nuances of this module and how it brings you the power of heaps.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eheapq\u003c/code\u003e module doesn\u0026#39;t provide a distinct heap data type. Instead, it offers functions that work on regular Python lists, transforming and treating them as \u003cem\u003ebinary heaps\u003c/em\u003e.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis approach is both memory-efficient and integrates seamlessly with Python\u0026#39;s existing data structures.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat means that \u003cem\u003eheaps are represented as lists\u003c/em\u003e in \u003ccode\u003eheapq\u003c/code\u003e. The beauty of this representation is its simplicity - the zero-based list index system serves as an implicit binary tree. For any given element at position \u003ccode\u003ei\u003c/code\u003e, its:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLeft Child is at position \u003ccode\u003e2*i + 1\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eRight Child is at position \u003ccode\u003e2*i + 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eParent Node is at position \u003ccode\u003e(i-1)//2\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis implicit structure ensures that there\u0026#39;s no need for a separate node-based binary tree representation, making operations straightforward and memory usage minimal.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eSpace Complexity:\u003c/strong\u003e Heaps are typically implemented as binary trees but don\u0026#39;t require storage of explicit pointers for child nodes. This makes them space-efficient with a space complexity of \u003cem\u003eO(n)\u003c/em\u003e for storing n elements.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eIt\u0026#39;s essential to note that the \u003ccode\u003eheapq\u003c/code\u003e module \u003cstrong\u003ecreates min heaps by default\u003c/strong\u003e. This means that the smallest element is always at the root (or the first position in the list). If you need a max heap, you\u0026#39;d have to invert order by multiplying elements by \u003ccode\u003e-1\u003c/code\u003e or use a custom comparison function.\u003c/p\u003e\n\u003cp\u003ePython\u0026#39;s \u003ccode\u003eheapq\u003c/code\u003e module provides a suite of functions that allow developers to perform various heap operations on lists.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e To use the \u003ccode\u003eheapq\u003c/code\u003e module in your application, you\u0026#39;ll need to import it using simple  \u003ccode\u003eimport heapq\u003c/code\u003e.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cdiv data-nosnippet=\"\" id=\"ad-lead-magnet\"\u003e\u003cp\u003eCheck out our hands-on, practical guide to learning Git, with best-practices, industry-accepted standards, and included cheat sheet. Stop Googling Git commands and actually \u003cem\u003elearn\u003c/em\u003e it!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIn the following sections, we\u0026#39;ll dive deep into each of these fundamental operations, exploring their mechanics and use cases.\u003c/p\u003e\n\u003ch3 id=\"howtotransformalistintoaheap\"\u003eHow to Transform a List into a Heap\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eheapify()\u003c/code\u003e function is the starting point for many heap-related tasks. It takes an iterable (typically a list) and rearranges its elements in-place to satisfy the properties of a min heap:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\ndata = [\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e6\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e]\nheapq.heapify(data)\n\u003cspan\u003eprint\u003c/span\u003e(data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will output a reordered list that represents a valid min heap:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[1, 1, 2, 3, 3, 9, 4, 6, 5, 5, 5]\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eTime Complexity:\u003c/strong\u003e Converting an unordered list into a heap using the \u003ccode\u003eheapify\u003c/code\u003e function is an \u003cem\u003eO(n)\u003c/em\u003e operation. This might seem counterintuitive, as one might expect it to be \u003cem\u003eO(nlogn)\u003c/em\u003e, but due to the tree structure\u0026#39;s properties, it can be achieved in linear time.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"howtoaddanelementtotheheap\"\u003eHow to Add an Element to the Heap\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eheappush()\u003c/code\u003e function allows you to insert a new element into the heap while maintaining the heap\u0026#39;s properties:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\nheap = []\nheapq.heappush(heap, \u003cspan\u003e5\u003c/span\u003e)\nheapq.heappush(heap, \u003cspan\u003e3\u003c/span\u003e)\nheapq.heappush(heap, \u003cspan\u003e7\u003c/span\u003e)\n\u003cspan\u003eprint\u003c/span\u003e(heap)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning the code will give you a list of elements maintaining the min heap property:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[3, 5, 7]\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eTime Complexity:\u003c/strong\u003e The insertion operation in a heap, which involves placing a new element in the heap while maintaining the heap property, has a time complexity of \u003cem\u003eO(logn)\u003c/em\u003e. This is because, in the worst case, the element might have to travel from the leaf to the root.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"howtoremoveandreturnthesmallestelementfromtheheap\"\u003eHow to Remove and Return the Smallest Element from the Heap\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eheappop()\u003c/code\u003e function extracts and returns the smallest element from the heap (the root in a min heap). After removal, it ensures the list remains a valid heap:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\nheap = [\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e7\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e]\n\u003cspan\u003eprint\u003c/span\u003e(heapq.heappop(heap))\n\u003cspan\u003eprint\u003c/span\u003e(heap)\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e The \u003ccode\u003eheappop()\u003c/code\u003e is invaluable in algorithms that require processing elements in ascending order, like the Heap Sort algorithm, or when implementing priority queues where tasks are executed based on their urgency.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003cp\u003eThis will output the smallest element and the remaining list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n[3, 7, 5, 9]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, \u003ccode\u003e1\u003c/code\u003e is the smallest element from the \u003ccode\u003eheap\u003c/code\u003e, and the remaining list has maintained the heap property, even after we removed \u003ccode\u003e1\u003c/code\u003e.\u003c/p\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eTime Complexity:\u003c/strong\u003e Removing the root element (which is the smallest in a min heap or largest in a max heap) and reorganizing the heap also takes \u003cem\u003eO(logn)\u003c/em\u003e time.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"howtopushanewitemandpopthesmallestitem\"\u003eHow to Push a New Item and Pop the Smallest Item\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eheappushpop()\u003c/code\u003e function is a combined operation that pushes a new item onto the heap and then pops and returns the smallest item from the heap:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\nheap = [\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e7\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e]\n\u003cspan\u003eprint\u003c/span\u003e(heapq.heappushpop(heap, \u003cspan\u003e4\u003c/span\u003e)) \n\u003cspan\u003eprint\u003c/span\u003e(heap)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will output \u003ccode\u003e3\u003c/code\u003e, the smallest element, and print out the new \u003ccode\u003eheap\u003c/code\u003e list that now includes \u003ccode\u003e4\u003c/code\u003e while maintaining the heap property:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e3\n[4, 5, 7, 9]\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Using the \u003ccode\u003eheappushpop()\u003c/code\u003e function is more efficient than performing operations of pushing a new element and popping the smallest one separately.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"howtoreplacethesmallestitemandpushanewitem\"\u003eHow to Replace the Smallest Item and Push a New Item\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eheapreplace()\u003c/code\u003e function pops the smallest element and pushes a new element onto the heap, all in one efficient operation:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\nheap = [\u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e7\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e]\n\u003cspan\u003eprint\u003c/span\u003e(heapq.heapreplace(heap, \u003cspan\u003e4\u003c/span\u003e))\n\u003cspan\u003eprint\u003c/span\u003e(heap)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis prints \u003ccode\u003e1\u003c/code\u003e, the smallest element, and the list now includes 4 and maintains the heap property:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n[4, 5, 7, 9]\n\u003c/code\u003e\u003c/pre\u003e\n\n            \u003cdiv\u003e\n                    \n                        \n                        \n                    \u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003ccode\u003eheapreplace()\u003c/code\u003e is beneficial in streaming scenarios where you want to replace the current smallest element with a new value, such as in rolling window operations or real-time data processing tasks.\u003c/p\u003e\n                \u003c/div\u003e\n            \u003ch3 id=\"findingmultipleextremesinpythonsheap\"\u003eFinding Multiple Extremes in Python\u0026#39;s Heap\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enlargest(n, iterable[, key])\u003c/code\u003e and \u003ccode\u003ensmallest(n, iterable[, key])\u003c/code\u003e functions are designed to retrieve multiple largest or smallest elements from an iterable. They can be more efficient than sorting the entire iterable when you only need a few extreme values. For example, say you have the following list and you want to find three smallest and three largest values in the list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edata = [\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e6\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, \u003ccode\u003enlargest()\u003c/code\u003e and \u003ccode\u003ensmallest()\u003c/code\u003e functions can come in handy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\ndata = [\u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e4\u003c/span\u003e, \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e9\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e, \u003cspan\u003e6\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e, \u003cspan\u003e3\u003c/span\u003e, \u003cspan\u003e5\u003c/span\u003e]\n\u003cspan\u003eprint\u003c/span\u003e(heapq.nlargest(\u003cspan\u003e3\u003c/span\u003e, data))  \u003cspan\u003e# Outputs [9, 6, 5]\u003c/span\u003e\n\u003cspan\u003eprint\u003c/span\u003e(heapq.nsmallest(\u003cspan\u003e3\u003c/span\u003e, data))  \u003cspan\u003e# Outputs [1, 1, 2]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will give you two lists - one contains the three largest values and the other contains the three smallest values from the \u003ccode\u003edata\u003c/code\u003e list:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[9, 6, 5]\n[1, 1, 2]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"howtobuildyourcustomheap\"\u003eHow to Build Your Custom Heap\u003c/h3\u003e\n\u003cp\u003eWhile Python\u0026#39;s \u003ccode\u003eheapq\u003c/code\u003e module provides a robust set of tools for working with heaps, there are scenarios where the default min heap behavior might not suffice. Whether you\u0026#39;re looking to implement a max heap or need a heap that operates based on custom comparison functions, building a custom heap can be the answer. Let\u0026#39;s explore how to tailor heaps to specific needs.\u003c/p\u003e\n\u003ch4 id=\"implementingamaxheapusingheapq\"\u003eImplementing a Max Heap using \u003ccode\u003eheapq\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003eheapq\u003c/code\u003e creates \u003cem\u003emin heaps\u003c/em\u003e. However, with a simple trick, you can use it to implement a max heap. The idea is to invert the order of elements by multiplying them by \u003ccode\u003e-1\u003c/code\u003e before adding them to the heap:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\n\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMaxHeap\u003c/span\u003e:\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e):\u003c/span\u003e\n        self.heap = []\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003epush\u003c/span\u003e(\u003cspan\u003eself, val\u003c/span\u003e):\u003c/span\u003e\n        heapq.heappush(self.heap, -val)\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003epop\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e -heapq.heappop(self.heap)\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003epeek\u003c/span\u003e(\u003cspan\u003eself\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e -self.heap[\u003cspan\u003e0\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this approach, the largest number (in terms of absolute value) becomes the smallest, allowing the \u003ccode\u003eheapq\u003c/code\u003e functions to maintain a max heap structure.\u003c/p\u003e\n\u003ch4 id=\"heapswithcustomcomparisonfunctions\"\u003eHeaps with Custom Comparison Functions\u003c/h4\u003e\n\u003cp\u003eSometimes, you might need a heap that doesn\u0026#39;t just compare based on the natural order of elements. For instance, if you\u0026#39;re working with complex objects or have specific sorting criteria, a custom comparison function becomes essential.\u003c/p\u003e\n\u003cp\u003eTo achieve this, you can wrap elements in a helper class that overrides the comparison operators:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e heapq\n\n\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eCustomElement\u003c/span\u003e:\u003c/span\u003e\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__init__\u003c/span\u003e(\u003cspan\u003eself, obj, comparator\u003c/span\u003e):\u003c/span\u003e\n        self.obj = obj\n        self.comparator = comparator\n\n    \u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003e__lt__\u003c/span\u003e(\u003cspan\u003eself, other\u003c/span\u003e):\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e self.comparator(self.obj, other.obj)\n\n\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ecustom_heappush\u003c/span\u003e(\u003cspan\u003eheap, obj, comparator=\u003cspan\u003elambda\u003c/span\u003e x, y: x \u0026lt; y\u003c/span\u003e):\u003c/span\u003e\n    heapq.heappush(heap, CustomElement(obj, comparator))\n\n\u003cspan\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003ecustom_heappop\u003c/span\u003e(\u003cspan\u003eheap\u003c/span\u003e):\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e heapq.heappop(heap).obj\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this setup, you can define any custom comparator function and use it with the heap.\u003c/p\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "17 min read",
  "publishedTime": "2023-11-15T19:21:52Z",
  "modifiedTime": "2024-04-18T14:54:41Z"
}
