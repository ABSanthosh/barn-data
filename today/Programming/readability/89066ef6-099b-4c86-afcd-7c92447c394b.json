{
  "id": "89066ef6-099b-4c86-afcd-7c92447c394b",
  "title": "State of Kotlin Scripting 2024",
  "link": "https://blog.jetbrains.com/kotlin/2024/11/state-of-kotlin-scripting-2024/",
  "description": "TL;DR: Kotlin scripting remains an essential part of the Kotlin infrastructure. We continue to support it in the experimental state, and we are concluding certain experiments and reducing the number of scripting-related technologies that we provide and actively develop. Kotlin scripting is the technology that enables executing Kotlin code as scripts without prior compilation or […]",
  "author": "Anton Yalyshev",
  "published": "Tue, 19 Nov 2024 16:07:29 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "ecosystem",
    "news",
    "kotlin-scripting"
  ],
  "byline": "",
  "length": 11341,
  "excerpt": "This blog post explores the current state and future plans for Kotlin scripting.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains Ecosystem NewsState of Kotlin Scripting 2024 TL;DR: Kotlin scripting remains an essential part of the Kotlin infrastructure. We continue to support it in the experimental state, and we are concluding certain experiments and reducing the number of scripting-related technologies that we provide and actively develop. Kotlin scripting is the technology that enables executing Kotlin code as scripts without prior compilation or packaging into executables. In addition, several extension mechanisms exist to facilitate the usage of Kotlin for specific applications, such as configuring build tools. On top of that, REPL functionality, which is closely related to scripting, is available for Kotlin in various forms (including, for example, Kotlin Notebook). All these technologies can be found in Kotlin and other JetBrains projects. Some of them are well known, others are barely used, but all require a noticeable amount of attention from the team. The evolution of scripting in Kotlin Scripting was introduced into Kotlin long ago as an experiment to investigate new ways of using the language. Since then, the development has been driven by the demand of external and internal adopters, as well as some experiments born inside our team. Over time, we accumulated a lot of functionality related to scripting in our codebase, and the effort required to support it grew quite significantly. Therefore, at some point, we started to review the functionality we have, how it is used inside and outside of JetBrains, and how we can distill it into a reasonable minimal subset that we are willing to support and develop without breaking too many existing use cases. This blog post attempts to summarize our findings, explain our decisions, and outline the future directions in this area. We hope it will clarify the future of scripting in Kotlin and give the community a solid basis for making technical decisions.  While we already have a firm roadmap for the immediate future, we welcome and appreciate your feedback and ideas for further improvements. We are especially interested in hearing about any particular use cases for scripting that you may have. We encourage you to use comments here or create YouTrack issues describing your scenarios and how the announced changes may affect them. Your insights are invaluable to us and will play a crucial role in shaping our future plans for the language’s development. Contribute Your Feedback and Ideas Basic scripting We conducted some research into scripting usage in the past and concluded that besides a few main adoptions, like Gradle build scripts, there is a relatively small number of known uses for scripting and REPL. This might be attributable to various factors, but the result is nonetheless clear: The functionality is not as popular as we had anticipated. Some technological problems could (and will) be addressed, but there are some inherent issues with attempting to position Kotlin as a scripting language.  In particular, Kotlin is not an interpreted language, and it cannot achieve the user experience typical for dedicated scripting languages. To achieve the current script-like behavior, we compile the code under the hood. The compilation process is quite intensive because the Kotlin compiler was not designed for such scenarios.  That is why we made the following decision: Although we will continue to provide generalized support for scripting in Kotlin, which includes compilation and evaluation of basic `.kts` files, as well as custom scripting (more about this below), we are not prepared to recommend Kotlin scripting as a generally applicable scripting solution, for example, as a replacement for Bash or Python. On the other hand, we believe there are many new usage scenarios where, despite the known limitations, the use of Kotlin scripting could be beneficial. There are also several other potential use cases that we would like to explore further. Custom script types The most powerful scripting solutions require extension mechanisms that allow for the customization of script compilation and evaluation. One of the most prominent examples is Gradle Kotlin DSL, where the Custom Scripting API is used to bring Kotlin language with traditional Gradle DSL to build scripts. This brings us to the second decision: We will continue to support the Custom Scripting API (an unofficial name for a set of APIs for customizing script compilation and evaluation, as well as APIs for embedding script hosts into third-party applications). However, this comes with a few caveats: It will remain in the experimental state and may never become a stable part of the Kotlin ecosystem. So, things like documentation and IDE support for a generic custom script support may continue to lag behind. We are concentrating our efforts on improving user experience with a few known use cases, such as Gradle Kotlin DSL and select others. This means we might not be able to dedicate enough resources to support general cases. Main.kts In addition to the basic and custom scripting, we would like to continue supporting `.main.kts` scripts. The `.main.kts` scripts were initially developed to demonstrate the utility of the Custom Scripting API. However, with its support of dependencies and other features, it was adopted by many users as a default Kotlin scripting solution. Therefore, the next decision is: We will continue to develop the `.main.kts` script type, which is already helpful for simple automation tasks. We have plans to extend its functionality and streamline IDE support. Such scripts continue to be supported out of the box in the Kotlin compiler and the Kotlin plugin for IntelliJ IDEA. Kotlin REPL The default REPL implementation has been a part of the Kotlin compiler (`kotlinc`) and Kotlin plugin for IntelliJ IDEA since the first release. Still, the functionality is limited, and improving it was never a priority for the team. Therefore, the user experience is not on par with the general Kotlin user experience in IntelliJ IDEA. We made several attempts to spin off alternative REPL implementations (e.g. the Kotlin Interactive Shell), but unfortunately, these never gained enough traction. Meanwhile, we are improving the Kotlin Notebook plugin for IntelliJ IDEA, which offers a smooth, extensive, and interactive experience working in Kotlin. With Kotlin Notebook, you can develop and experiment with Kotlin code, receive immediate outputs, and visualize data. We believe that it is an excellent replacement for all our current REPL solutions.  Besides that, IntelliJ IDEA provides Kotlin Scratch files, where you can quickly prototype your code. Therefore: We plan to sunset the default REPL implementations in the Kotlin compiler and the IntelliJ IDEA plugin. CLI REPL (via `kotlinc`) will continue to function at least until the release of Kotlin 2.3, but its operation will be limited to compatibility mode, i.e. with the `-language-version 1.9` option set (and may require an opt-in flag starting from release 2.2).  The default Kotlin REPL in the IntelliJ IDEA plugin will be removed in one of the next IntelliJ IDEA releases.  We will continue to promote the Kotlin Notebook plugin and IDE Scratch files as solutions for interactive Kotlin development. This decision places some uncertainty on the external REPL implementations, like the Kotlin Interactive Shell. Although we plan to keep some REPL-related functionality in the compiler and Custom Scripting API (not least because solutions like Kotlin Notebook rely on them), with a final switch to the K2 compiler, a significant portion of this functionality will be changed or dropped, so it may require substantial effort to rewrite such implementations to the changed APIs.  Other technologies based on Kotlin scripting Besides these main areas, there are a few other related technologies and APIs for scripting that we are currently supporting. We believe the cases explicitly mentioned above cover a majority of possible user needs. Therefore, we plan to drop most other scripting-related components and libraries from the compiler and IntelliJ IDEA. In particular: JSR-223 support – considering that the original JSR is in the withdrawn state, we do not believe supporting the de-facto obsolete API makes sense. The existing implementation will continue to function at least until the release of Kotlin 2.3 in the language version 1.9 compatibility mode (but we may consider renaming the artifact to raise awareness of the planned changes), and it will be dropped after that. `KotlinScriptMojo` – a Maven plugin that supports script execution during the Maven build. We did not find evidence of enough usages to keep maintaining it, so we plan to drop it in one of the next Kotlin releases. `kotlin-scripting-ide-services` – a library for implementing code completion functionality, mainly for REPL implementations. It is currently used in projects like Kotlin Interactive. It is heavily based on the infrastructure of the pre-K2 compiler and cannot be easily ported to the K2 version. Therefore, it will most likely stop working around the release of Kotlin 2.3 and will be removed from the codebase. We may consider reimplementing similar functionality on top of K2 in the future, but for now, this is not something we are actively pursuing. Moving forward We hope the focused approach will allow us to move forward and provide a better experience with widely used scripting technologies. At the same time, it will free some resources for exciting language features and applications. We encourage you to share your use cases for scripting and appreciate your feedback on these changes and how they may affect your work. Share Your Feedback and Use Cases What else to read Kotlin Notebook – documentation Kotlin DSL Is Now the Default for New Gradle Builds Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2024/11/Social-share-image-1280x720-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/ecosystem/\"\u003eEcosystem\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/kotlin/category/news/\"\u003eNews\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eState of Kotlin Scripting 2024\u003c/h2\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://secure.gravatar.com/avatar/5183521bdb83978a1ff5d48b2b5bb26b?s=200\u0026amp;r=g\" width=\"200\" height=\"200\" alt=\"Anton Yalyshev\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://secure.gravatar.com/avatar/fa4388361e2946d077b094679292892f?s=200\u0026amp;r=g\" width=\"200\" height=\"200\" alt=\"Ilya Chernikov\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003e\u003cem\u003eTL;DR: Kotlin scripting remains an essential part of the Kotlin infrastructure. We continue to support it in the experimental state, and we are concluding certain experiments and reducing the number of scripting-related technologies that we provide and actively develop.\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eKotlin scripting is the technology that enables executing Kotlin code as scripts without prior compilation or packaging into executables. In addition, several extension mechanisms exist to facilitate the usage of Kotlin for specific applications, such as configuring build tools. On top of that, REPL functionality, which is closely related to scripting, is available for Kotlin in various forms (including, for example, \u003ca href=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" data-type=\"link\" data-id=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin Notebook\u003c/a\u003e).\u003c/p\u003e\n\n\n\n\u003cp\u003eAll these technologies can be found in Kotlin and other JetBrains projects. Some of them are well known, others are barely used, but all require a noticeable amount of attention from the team.\u003c/p\u003e\n\n\n\n\u003ch2\u003eThe evolution of scripting in Kotlin\u003c/h2\u003e\n\n\n\n\u003cp\u003eScripting was introduced into Kotlin long ago as an experiment to investigate new ways of using the language. Since then, the development has been driven by the demand of external and internal adopters, as well as some experiments born inside our team. Over time, we accumulated a lot of functionality related to scripting in our codebase, and the effort required to support it grew quite significantly. Therefore, at some point, we started to review the functionality we have, how it is used inside and outside of JetBrains, and how we can distill it into a reasonable minimal subset that we are willing to support and develop without breaking too many existing use cases.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis blog post attempts to summarize our findings, explain our decisions, and outline the future directions in this area. We hope it will clarify the future of scripting in Kotlin and give the community a solid basis for making technical decisions. \u003c/p\u003e\n\n\n\n\u003cp\u003eWhile we already have a firm roadmap for the immediate future, we welcome and appreciate your feedback and ideas for further improvements. We are especially interested in hearing about any particular use cases for scripting that you may have. We encourage you to use comments here or create \u003ca href=\"https://youtrack.jetbrains.com/issues/KT\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eYouTrack issues\u003c/a\u003e describing your scenarios and how the announced changes may affect them. Your insights are invaluable to us and will play a crucial role in shaping our future plans for the language’s development.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca title=\"Contribute Your Feedback and Ideas\" href=\"https://youtrack.jetbrains.com/issues/KT\" target=\"_blank\" rel=\"noopener\"\u003eContribute Your Feedback and Ideas\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eBasic scripting\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe conducted some research into scripting usage in the past and concluded that besides a few main adoptions, like Gradle build scripts, there is a relatively small number of known uses for scripting and REPL. This might be attributable to various factors, but the result is nonetheless clear: The functionality is not as popular as we had anticipated.\u003c/p\u003e\n\n\n\n\u003cp\u003eSome technological problems could (and will) be addressed, but there are some inherent issues with attempting to position Kotlin as a scripting language. \u003c/p\u003e\n\n\n\n\u003cp\u003eIn particular, Kotlin is not an interpreted language, and it cannot achieve the user experience typical for dedicated scripting languages. To achieve the current script-like behavior, we compile the code under the hood. The compilation process is quite intensive because the Kotlin compiler was not designed for such scenarios. \u003c/p\u003e\n\n\n\n\u003cp\u003eThat is why we made the following decision:\u003c/p\u003e\n\n\n\n\u003cp\u003eAlthough we will continue to provide generalized support for scripting in Kotlin, which includes compilation and evaluation of basic `.kts` files, as well as custom scripting (more about this below), we are not prepared to recommend Kotlin scripting as a generally applicable scripting solution, for example, as a replacement for Bash or Python.\u003c/p\u003e\n\n\n\n\u003cp\u003eOn the other hand, we believe there are many new usage scenarios where, despite the known limitations, the use of Kotlin scripting could be beneficial. There are also several other potential use cases that we would like to explore further.\u003c/p\u003e\n\n\n\n\u003ch2\u003eCustom script types\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe most powerful scripting solutions require extension mechanisms that allow for the customization of script compilation and evaluation. One of the most prominent examples is \u003ca href=\"https://docs.gradle.org/current/userguide/kotlin_dsl.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eGradle Kotlin DSL\u003c/a\u003e, where the Custom Scripting API is used to bring Kotlin language with traditional Gradle DSL to build scripts. This brings us to the second decision:\u003c/p\u003e\n\n\n\n\u003cp\u003eWe will continue to support the Custom Scripting API (an unofficial name for a set of APIs for customizing script compilation and evaluation, as well as APIs for embedding script hosts into third-party applications). However, this comes with a few caveats:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIt will remain in the experimental state and may never become a stable part of the Kotlin ecosystem. So, things like documentation and IDE support for a generic custom script support may continue to lag behind.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe are concentrating our efforts on improving user experience with a few known use cases, such as Gradle Kotlin DSL and select others. This means we might not be able to dedicate enough resources to support general cases.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eMain.kts\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn addition to the basic and custom scripting, we would like to continue supporting `.main.kts` scripts. The `.main.kts` scripts were initially developed to demonstrate the utility of the Custom Scripting API. However, with its support of dependencies and other features, it was adopted by many users as a default Kotlin scripting solution. Therefore, the next decision is:\u003c/p\u003e\n\n\n\n\u003cp\u003eWe will continue to develop the `.main.kts` script type, which is already helpful for simple automation tasks. We have plans to extend its functionality and streamline IDE support. Such scripts continue to be supported out of the box in the Kotlin compiler and the Kotlin plugin for IntelliJ IDEA.\u003c/p\u003e\n\n\n\n\u003ch2\u003eKotlin REPL\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe default REPL implementation has been a part of the Kotlin compiler (`kotlinc`) and Kotlin plugin for IntelliJ IDEA since the first release. Still, the functionality is limited, and improving it was never a priority for the team. Therefore, the user experience is not on par with the general Kotlin user experience in IntelliJ IDEA. We made several attempts to spin off alternative REPL implementations (e.g. the \u003ca href=\"https://github.com/Kotlin/kotlin-interactive-shell\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin Interactive Shell\u003c/a\u003e), but unfortunately, these never gained enough traction.\u003c/p\u003e\n\n\n\n\u003cp\u003eMeanwhile, we are improving the \u003ca href=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin Notebook\u003c/a\u003e plugin for IntelliJ IDEA, which offers a smooth, extensive, and interactive experience working in Kotlin. With Kotlin Notebook, you can develop and experiment with Kotlin code, receive immediate outputs, and visualize data. We believe that it is an excellent replacement for all our current REPL solutions. \u003c/p\u003e\n\n\n\n\u003cp\u003eBesides that, IntelliJ IDEA provides Kotlin \u003ca href=\"https://www.jetbrains.com/help/idea/scratches.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eScratch files\u003c/a\u003e, where you can quickly prototype your code. Therefore:\u003c/p\u003e\n\n\n\n\u003cp\u003eWe plan to sunset the default REPL implementations in the Kotlin compiler and the IntelliJ IDEA plugin.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCLI REPL (via `kotlinc`) will continue to function at least until the release of Kotlin 2.3, but its operation will be limited to compatibility mode, i.e. with the `-language-version 1.9` option set (and may require an opt-in flag starting from release 2.2). \u003c/li\u003e\n\n\n\n\u003cli\u003eThe default Kotlin REPL in the IntelliJ IDEA plugin will be removed in one of the next IntelliJ IDEA releases. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eWe will continue to promote the Kotlin Notebook plugin and IDE Scratch files as solutions for interactive Kotlin development.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis decision places some uncertainty on the external REPL implementations, like the Kotlin Interactive Shell. Although we plan to keep some REPL-related functionality in the compiler and Custom Scripting API (not least because solutions like Kotlin Notebook rely on them), with a final switch to the K2 compiler, a significant portion of this functionality will be changed or dropped, so it may require substantial effort to rewrite such implementations to the changed APIs. \u003c/p\u003e\n\n\n\n\u003ch2\u003eOther technologies based on Kotlin scripting\u003c/h2\u003e\n\n\n\n\u003cp\u003eBesides these main areas, there are a few other related technologies and APIs for scripting that we are currently supporting. We believe the cases explicitly mentioned above cover a majority of possible user needs. Therefore, we plan to drop most other scripting-related components and libraries from the compiler and IntelliJ IDEA. In particular:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJSR-223 support – considering that the original \u003ca href=\"https://jcp.org/en/jsr/detail?id=223\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eJSR\u003c/a\u003e is in the withdrawn state, we do not believe supporting the de-facto obsolete API makes sense. The existing implementation will continue to function at least until the release of Kotlin 2.3 in the language version 1.9 compatibility mode (but we may consider renaming the artifact to raise awareness of the planned changes), and it will be dropped after that.\u003c/li\u003e\n\n\n\n\u003cli\u003e`KotlinScriptMojo` – a Maven plugin that supports script execution during the Maven build. We did not find evidence of enough usages to keep maintaining it, so we plan to drop it in one of the next Kotlin releases.\u003c/li\u003e\n\n\n\n\u003cli\u003e`kotlin-scripting-ide-services` – a library for implementing code completion functionality, mainly for REPL implementations. It is currently used in projects like Kotlin Interactive. It is heavily based on the infrastructure of the pre-K2 compiler and cannot be easily ported to the K2 version. Therefore, it will most likely stop working around the release of Kotlin 2.3 and will be removed from the codebase. We may consider reimplementing similar functionality on top of K2 in the future, but for now, this is not something we are actively pursuing.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eMoving forward\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe hope the focused approach will allow us to move forward and provide a better experience with widely used scripting technologies. At the same time, it will free some resources for exciting language features and applications. We encourage you to share your use cases for scripting and appreciate your feedback on these changes and how they may affect your work.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003ca title=\"Share Your Feedback and Use Cases\" href=\"https://youtrack.jetbrains.com/issues/KT\" target=\"_blank\" rel=\"noopener\"\u003eShare Your Feedback and Use Cases\u003c/a\u003e\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat else to read\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" data-type=\"link\" data-id=\"https://kotlinlang.org/docs/kotlin-notebook-overview.html\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin Notebook – documentation\u003c/a\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/2023/04/kotlin-dsl-is-the-default-for-new-gradle-builds/\" data-type=\"link\" data-id=\"https://blog.jetbrains.com/kotlin/2023/04/kotlin-dsl-is-the-default-for-new-gradle-builds/\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eKotlin DSL Is Now the Default for New Gradle Builds\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
