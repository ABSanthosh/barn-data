{
  "id": "8b10d90b-2c1c-4e67-a92a-a79f4cd01b96",
  "title": "What Is New with Periskop in 2022",
  "link": "https://developers.soundcloud.com/blog/periskop-in-2022",
  "description": "In a previous blog post, we explained how we built an internal pull-based exception monitoring service called Periskop — which is heavily…",
  "author": "",
  "published": "Tue, 01 Feb 2022 00:00:00 GMT",
  "source": "https://developers.soundcloud.com/blog/blog.rss",
  "categories": null,
  "byline": "",
  "length": 5487,
  "excerpt": "We made some updates to Periskop, our internal pull-based exception monitoring service. To learn about what is new in 2022, read on.",
  "siteName": "",
  "favicon": "",
  "text": "In a previous blog post, we explained how we built an internal pull-based exception monitoring service called Periskop — which is heavily influenced by Prometheus — which we open sourced. The adoption of this tool at SoundCloud has proven successful during the past year. Currently, it’s a Golden Path tool in our observability stack, and it’s particularly key when an incident happens. Many teams started using Periskop as part of their debugging workflow — even those that still have to maintain legacy systems that don’t use SoundCloud’s default technical stack. This increased use encouraged us to improve Periskop by adding more functionality and releasing more open source projects for the Periskop ecosystem. In this post, we’ll discuss recent updates we made to Periskop and its ecosystem. Many of the new features explained here were mentioned in the previous blog post as part of future work. Official Website and New Organization We’re happy to announce that we have our static site pointing to http://periskop.io. We also moved all related Periskop repositories to a new GitHub organization called periskop-dev. The goal of this is to change the governance model to one that’s more community-centric and not exclusive to SoundCloud. This lines up with our mission of making Periskop the go-to tool for exception reporting in the cloud native ecosystem. Client Libraries Since we opened Periskop to the community, we wanted users of different languages to also use Periskop for their programs. Initially, we developed a client library for Scala, which is the technology we use the most internally. Later, we started adding more client libraries, and there are currently four: periskop-scala periskop-go periskop-python periskop-ruby The development of periskop-go was especially interesting, as Periskop uses it to scrape itself to capture any error that occurs during its execution. Persistence We built Periskop with simplicity in mind: deploy and run. Software that’s similar to Periskop — like Sentry — requires provisioning a database if you want to deploy the service internally to store all the exceptions. With Periskop, you can simply deploy using in-memory storage for the exceptions. This has the downside that if you redeploy your Periskop instance, the captured errors won’t persist. However, this usually isn’t a problem, since most of the time, if the scraped service had the errors reported in memory (via a client library), the errors would be scraped again. To solve this problem, we decided to extend Periskop, providing the ability to store exceptions in a persistent storage. Currently, Periskop can be configured to use persistent database systems such SQLite, MySQL, and PostgreSQL. Documentation on how to achieve this can be found in part of this README. Push Gateway We also wanted to provide push capabilities to Periskop. This is especially useful for shortlived processes like batch jobs or fork-based application servers. In the Prometheus documentation, you can find plenty of good examples and a detailed explanation as to why a push gateway is useful. The following graph shows the architecture of the push gateway. Basically, it’s a simple Go service that you can deploy as a sidecar container. Client libraries can use the push_to_gateway method pointing to the address and port where the service is deployed, pushing any exported metrics to the gateway. We use it in production for our monolith written in Rails with periskop-ruby. There’s Rack middleware, which handles exceptions that may happen during the execution of a request, and it pushes them to the attached push gateway of the deployed service. Service Discovery As we’re following the principle of Prometheus, but for exceptions, we also wanted to have the same service discovery mechanism that Prometheus has in place. This pull request shows how this was achieved and how we can configure Periskop to use Prometheus service discovery. User Experience Improvements We introduced several improvements to the UI that make Periskop more user friendly — especially when searching or filtering for a specific error during an outage. These are the main improvements: Search for errors — We had an initial search functionality that was only searching for the error name. We extended the search functionality to search any text within the reported errors. This is particularly useful when searching for a specific endpoint or for an error message. Filters and sorting — We added the ability to filter per severity type and sort errors per number of occurrences or the date of last occurrence. Thanks to Tiago Taquelim for the contributions! Mark errors as resolved — We also added the option to mark errors as resolved. This comes in handy if you fix a bug, you deploy it, and you don’t want it to be in the UI anymore. Prometheus Metrics Support All reported errors are instrumented using Prometheus metrics. In the documentation, there’s a basic example of an alerting definition for Alertmanager. What’s Coming Next Some of the ideas we have in mind for continued improvement and added features include: Built-in federation (hierarchical collection) Time series visualization More integrations (Backstage, Grafana) Support for more language and frameworks Labeling of errors Periskop is open source, and we’re happy to accept external contributions! If you find this project useful, we’d love to hear from you. Please drop us a line at our gitter chat.",
  "image": "https://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/647de/periskop_logo.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/81436/periskop_logo.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"Periskop\" title=\"Periskop\" src=\"https://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/8ff1e/periskop_logo.png\" srcset=\"https://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/9ec3c/periskop_logo.png 200w,\nhttps://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/c7805/periskop_logo.png 400w,\nhttps://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/8ff1e/periskop_logo.png 800w,\nhttps://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/6ff5e/periskop_logo.png 1200w,\nhttps://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/2f950/periskop_logo.png 1600w,\nhttps://developers.soundcloud.com/blog/static/3add9dc6c52ee89743575e673459c0a8/81436/periskop_logo.png 1630w\" sizes=\"(max-width: 800px) 100vw, 800px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eIn a previous \u003ca href=\"https://developers.soundcloud.com/blog/periskop-exception-monitoring-service\"\u003eblog post\u003c/a\u003e, we explained how we built an internal pull-based exception monitoring service called Periskop — which is heavily influenced by \u003ca href=\"https://prometheus.io/\"\u003ePrometheus\u003c/a\u003e — which we open sourced.\u003c/p\u003e\n\u003cp\u003eThe adoption of this tool at SoundCloud has proven successful during the past year. Currently, it’s a \u003ca href=\"https://developers.soundcloud.com/blog/did-i-break-you\"\u003eGolden Path\u003c/a\u003e tool in our \u003cstrong\u003eobservability\u003c/strong\u003e stack, and it’s particularly key when an incident happens. Many teams started using Periskop as part of their debugging workflow — even those that still have to maintain legacy systems that don’t use SoundCloud’s default technical stack.\u003c/p\u003e\n\u003cp\u003eThis increased use encouraged us to improve Periskop by adding more functionality and releasing more open source projects for the Periskop ecosystem.\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll discuss recent updates we made to Periskop and its ecosystem. Many of the new features explained here were mentioned in the previous blog post as part of future work.\u003c/p\u003e\n\u003ch2\u003eOfficial Website and New Organization\u003c/h2\u003e\n\u003cp\u003eWe’re happy to announce that we have our static site pointing to \u003ca href=\"http://periskop.io\"\u003ehttp://periskop.io\u003c/a\u003e. We also moved all related Periskop repositories to a new GitHub organization called \u003ca href=\"https://github.com/periskop-dev\"\u003eperiskop-dev\u003c/a\u003e. The goal of this is to change the governance model to one that’s more community-centric and not exclusive to SoundCloud. This lines up with our mission of making Periskop the go-to tool for exception reporting in the cloud native ecosystem.\u003c/p\u003e\n\u003ch2\u003eClient Libraries\u003c/h2\u003e\n\u003cp\u003eSince we opened Periskop to the community, we wanted users of different languages to also use Periskop for their programs. Initially, we developed a client library for Scala, which is the technology we use the most internally. Later, we started adding more client libraries, and there are currently four:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/periskop-dev/periskop-scala\"\u003eperiskop-scala\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/periskop-dev/periskop-go\"\u003eperiskop-go\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/periskop-dev/periskop-python\"\u003eperiskop-python\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/periskop-dev/periskop-ruby\"\u003eperiskop-ruby\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe development of periskop-go was especially interesting, as Periskop uses it to scrape itself to capture any error that occurs during its execution.\u003c/p\u003e\n\u003ch2\u003ePersistence\u003c/h2\u003e\n\u003cp\u003eWe built Periskop with simplicity in mind: deploy and run. Software that’s similar to Periskop — like \u003ca href=\"https://sentry.io\"\u003eSentry\u003c/a\u003e — requires provisioning a database if you want to deploy the service internally to store all the exceptions.\u003c/p\u003e\n\u003cp\u003eWith Periskop, you can simply deploy using in-memory storage for the exceptions. This has the downside that if you redeploy your Periskop instance, the captured errors won’t persist. However, this usually isn’t a problem, since most of the time, if the scraped service had the errors reported in memory (via a client library), the errors would be scraped again.\u003c/p\u003e\n\u003cp\u003eTo solve this problem, we decided to extend Periskop, providing the ability to store exceptions in a persistent storage. Currently, Periskop can be configured to use persistent database systems such SQLite, MySQL, and PostgreSQL. Documentation on how to achieve this can be found in part of this \u003ca href=\"https://github.com/periskop-dev/periskop#enable-persistance-storage\"\u003eREADME\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003ePush Gateway\u003c/h2\u003e\n\u003cp\u003eWe also wanted to provide \u003ca href=\"https://github.com/periskop-dev/periskop-pushgateway\"\u003epush\u003c/a\u003e capabilities to Periskop. This is especially useful for shortlived processes like batch jobs or fork-based application servers. In the \u003ca href=\"https://prometheus.io/docs/practices/pushing/\"\u003ePrometheus documentation\u003c/a\u003e, you can find plenty of good examples and a detailed explanation as to why a push gateway is useful.\u003c/p\u003e\n\u003cp\u003eThe following graph shows the architecture of the push gateway.\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003e\n      \u003ca href=\"https://developers.soundcloud.com/blog/static/1f59288cb3837b66689cfd2fbfea7fc1/899a8/pushgateway.png\" target=\"_blank\" rel=\"noopener\"\u003e\n    \u003cspan\u003e\u003c/span\u003e\n  \u003cimg alt=\"push gateway\" title=\"push gateway\" src=\"https://developers.soundcloud.com/blog/static/1f59288cb3837b66689cfd2fbfea7fc1/899a8/pushgateway.png\" srcset=\"https://developers.soundcloud.com/blog/static/1f59288cb3837b66689cfd2fbfea7fc1/9ec3c/pushgateway.png 200w,\nhttps://developers.soundcloud.com/blog/static/1f59288cb3837b66689cfd2fbfea7fc1/c7805/pushgateway.png 400w,\nhttps://developers.soundcloud.com/blog/static/1f59288cb3837b66689cfd2fbfea7fc1/899a8/pushgateway.png 585w\" sizes=\"(max-width: 585px) 100vw, 585px\" loading=\"lazy\"/\u003e\n  \u003c/a\u003e\n    \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eBasically, it’s a simple Go service that you can deploy as a \u003ca href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/sidecar\"\u003esidecar container\u003c/a\u003e. Client libraries can use the \u003ccode\u003epush_to_gateway\u003c/code\u003e method pointing to the address and port where the service is deployed, pushing any exported metrics to the gateway.\u003c/p\u003e\n\u003cp\u003eWe use it in production for our monolith written in Rails with periskop-ruby. There’s \u003ca href=\"https://github.com/rack/rack\"\u003eRack\u003c/a\u003e middleware, which handles exceptions that may happen during the execution of a request, and it pushes them to the attached push gateway of the deployed service.\u003c/p\u003e\n\u003ch2\u003eService Discovery\u003c/h2\u003e\n\u003cp\u003eAs we’re following the principle of \u003cem\u003ePrometheus, but for exceptions\u003c/em\u003e, we also wanted to have the same \u003ca href=\"https://prometheus.io/docs/prometheus/latest/http_sd/\"\u003eservice discovery\u003c/a\u003e mechanism that Prometheus has in place. This \u003ca href=\"https://github.com/periskop-dev/periskop/pull/113\"\u003epull request\u003c/a\u003e shows how this was achieved and how we can configure Periskop to use Prometheus service discovery.\u003c/p\u003e\n\u003ch2\u003eUser Experience Improvements\u003c/h2\u003e\n\u003cp\u003eWe introduced several improvements to the UI that make Periskop more user friendly — especially when searching or filtering for a specific error during an outage. These are the main improvements:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSearch for errors — We had an initial search functionality that was only searching for the error name. We extended the search functionality to search any text within the reported errors. This is particularly useful when searching for a specific endpoint or for an error message.\u003c/li\u003e\n\u003cli\u003eFilters and sorting — We added the ability to filter per severity type and sort errors per number of occurrences or the date of last occurrence. Thanks to \u003ca href=\"https://github.com/sikozonpc\"\u003eTiago Taquelim\u003c/a\u003e for the contributions!\u003c/li\u003e\n\u003cli\u003eMark errors as resolved — We also added the option to mark errors as resolved. This comes in handy if you fix a bug, you deploy it, and you don’t want it to be in the UI anymore.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePrometheus Metrics Support\u003c/h2\u003e\n\u003cp\u003eAll reported errors are instrumented using Prometheus metrics. In the \u003ca href=\"https://github.com/periskop-dev/periskop#alert-reported-exceptions\"\u003edocumentation\u003c/a\u003e, there’s a basic example of an alerting definition for \u003ca href=\"https://www.prometheus.io/docs/alerting/latest/alertmanager/\"\u003eAlertmanager\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eWhat’s Coming Next\u003c/h2\u003e\n\u003cp\u003eSome of the ideas we have in mind for continued improvement and added features include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBuilt-in federation (hierarchical collection)\u003c/li\u003e\n\u003cli\u003eTime series visualization\u003c/li\u003e\n\u003cli\u003eMore integrations (\u003ca href=\"https://backstage.io/\"\u003eBackstage\u003c/a\u003e, \u003ca href=\"https://grafana.com/oss/grafana/\"\u003eGrafana\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eSupport for more language and frameworks\u003c/li\u003e\n\u003cli\u003eLabeling of errors\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePeriskop is \u003ca href=\"https://github.com/periskop-dev/periskop\"\u003eopen source\u003c/a\u003e, and we’re happy to accept external contributions! If you find this project useful, we’d love to hear from you. Please drop us a line at our \u003ca href=\"https://gitter.im/soundcloud/periskop\"\u003egitter chat\u003c/a\u003e.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": null,
  "modifiedTime": null
}
