{
  "id": "d257056a-3df3-43b3-901d-071cbed9e45c",
  "title": "Using markup for fallbacks when fetching data",
  "link": "https://martinfowler.com/articles/data-fetch-spa.html#fallback-markup",
  "description": "",
  "author": "",
  "published": "2024-05-21T11:30:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": [
    "skip-home-page"
  ],
  "byline": "Juntao QIU | 邱俊涛",
  "length": 75052,
  "excerpt": "Five patterns to help Single Page Applications fetch data from remote sources",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "Today, most applications can send hundreds of requests for a single page. For example, my Twitter home page sends around 300 requests, and an Amazon product details page sends around 600 requests. Some of them are for static assets (JavaScript, CSS, font files, icons, etc.), but there are still around 100 requests for async data fetching - either for timelines, friends, or product recommendations, as well as analytics events. That’s quite a lot. The main reason a page may contain so many requests is to improve performance and user experience, specifically to make the application feel faster to the end users. The era of blank pages taking 5 seconds to load is long gone. In modern web applications, users typically see a basic page with style and other elements in less than a second, with additional pieces loading progressively. Take the Amazon product detail page as an example. The navigation and top bar appear almost immediately, followed by the product images, brief, and descriptions. Then, as you scroll, “Sponsored” content, ratings, recommendations, view histories, and more appear.Often, a user only wants a quick glance or to compare products (and check availability), making sections like “Customers who bought this item also bought” less critical and suitable for loading via separate requests. Breaking down the content into smaller pieces and loading them in parallel is an effective strategy, but it's far from enough in large applications. There are many other aspects to consider when it comes to fetch data correctly and efficiently. Data fetching is a chellenging, not only because the nature of async programming doesn't fit our linear mindset, and there are so many factors can cause a network call to fail, but also there are too many not-obvious cases to consider under the hood (data format, security, cache, token expiry, etc.). In this article, I would like to discuss some common problems and patterns you should consider when it comes to fetching data in your frontend applications. We'll begin with the Asynchronous State Handler pattern, which decouples data fetching from the UI, streamlining your application architecture. Next, we'll delve into Fallback Markup, enhancing the intuitiveness of your data fetching logic. To accelerate the initial data loading process, we'll explore strategies for avoiding Request Waterfall and implementing Parallel Data Fetching. Our discussion will then cover Code Splitting to defer loading non-critical application parts and Prefetching data based on user interactions to elevate the user experience. I believe discussing these concepts through a straightforward example is the best approach. I aim to start simply and then introduce more complexity in a manageable way. I also plan to keep code snippets, particularly for styling (I'm utilizing TailwindCSS for the UI, which can result in lengthy snippets in a React component), to a minimum. For those interested in the complete details, I've made them available in this repository. Advancements are also happening on the server side, with techniques like Streaming Server-Side Rendering and Server Components gaining traction in various frameworks. Additionally, a number of experimental methods are emerging. However, these topics, while potentially just as crucial, might be explored in a future article. For now, this discussion will concentrate solely on front-end data fetching patterns. It's important to note that the techniques we're covering are not exclusive to React or any specific frontend framework or library. I've chosen React for illustration purposes due to my extensive experience with it in recent years. However, principles like Code Splitting, Prefetching are applicable across frameworks like Angular or Vue.js. The examples I'll share are common scenarios you might encounter in frontend development, regardless of the framework you use. That said, let’s dive into the example we’re going to use throughout the article, a Profile screen of a Single-Page Application. It's a typical application you might have used before, or at least the scenario is typical. We need to fetch data from server side and then at frontend to build the UI dynamically with JavaScript. Introducing the application To begin with, on Profile we’ll show the user’s brief (including name, avatar, and a short description), and then we also want to show their connections (similar to followers on Twitter or LinkedIn connections). We'll need to fetch user and their connections data from remote service, and then assembling these data with UI on the screen. Figure 1: Profile screen The data are from two separate API calls, the user brief API /users/\u003cid\u003e returns user brief for a given user id, which is a simple object described as follows: { \"id\": \"u1\", \"name\": \"Juntao Qiu\", \"bio\": \"Developer, Educator, Author\", \"interests\": [ \"Technology\", \"Outdoors\", \"Travel\" ] } And the friend API /users/\u003cid\u003e/friends endpoint returns a list of friends for a given user, each list item in the response is the same as the above user data. The reason we have two endpoints instead of returning a friends section of the user API is that there are cases where one could have too many friends (say 1,000), but most people don't have many. This in-balance data structure can be pretty tricky, especially when we need to paginate. The point here is that there are cases we need to deal with multiple network requests. A brief introduction to relevant React concepts As this article leverages React to illustrate various patterns, I do not assume you know much about React. Rather than expecting you to spend a lot of time trying to find the right parts in the React documentation, I will briefly introduce those concepts we're going to utilize throughout this article. If you already understand what React components are, and the use of the useState and useEffect hooks, you may use this link to skip ahead to the next section. For those seeking a more thorough tutorial, the new React documentation is an excellent resource. What is a React Component? In React, components are the fundamental building blocks. To put it simply, a React component is a function that returns a piece of UI, which can be as straightforward as a fragment of HTML. Consider the creation of a component that renders a navigation bar: import React from 'react'; function Navigation() { return ( \u003cnav\u003e \u003col\u003e \u003cli\u003eHome\u003c/li\u003e \u003cli\u003eBlogs\u003c/li\u003e \u003cli\u003eBooks\u003c/li\u003e \u003c/ol\u003e \u003c/nav\u003e ); } At first glance, the mixture of JavaScript with HTML tags might seem strange (it's called JSX, a syntax extension to JavaScript. For those using TypeScript, a similar syntax called TSX is used). To make this code functional, a compiler is required to translate the JSX into valid JavaScript code. After being compiled by Babel, the code would roughly translate to the following: function Navigation() { return React.createElement( \"nav\", null, React.createElement( \"ol\", null, React.createElement(\"li\", null, \"Home\"), React.createElement(\"li\", null, \"Blogs\"), React.createElement(\"li\", null, \"Books\") ) ); } Note here the translated code has a function called React.createElement, which is a foundational function in React for creating elements. JSX written in React components is compiled down to React.createElement calls behind the scenes. The basic syntax of React.createElement is: React.createElement(type, [props], [...children]) type: A string (e.g., 'div', 'span') indicating the type of DOM node to create, or a React component (class or functional) for more sophisticated structures. props: An object containing properties passed to the element or component, including event handlers, styles, and attributes like className and id. children: These optional arguments can be additional React.createElement calls, strings, numbers, or any mix thereof, representing the element's children. For instance, a simple element can be created with React.createElement as follows: React.createElement('div', { className: 'greeting' }, 'Hello, world!'); This is analogous to the JSX version: \u003cdiv className=\"greeting\"\u003eHello, world!\u003c/div\u003e Beneath the surface, React invokes the native DOM API (e.g., document.createElement(“ol”)) to generate DOM elements as necessary. You can then assemble your custom components into a tree, similar to HTML code: import React from 'react'; import Navigation from './Navigation.tsx'; import Content from './Content.tsx'; import Sidebar from './Sidebar.tsx'; import ProductList from './ProductList.tsx'; function App() { return \u003cPage /\u003e; } function Page() { return \u003cContainer\u003e \u003cNavigation /\u003e \u003cContent\u003e \u003cSidebar /\u003e \u003cProductList /\u003e \u003c/Content\u003e \u003cFooter /\u003e \u003c/Container\u003e; } Ultimately, your application requires a root node to mount to, at which point React assumes control and manages subsequent renders and re-renders: import ReactDOM from \"react-dom/client\"; import App from \"./App.tsx\"; const root = ReactDOM.createRoot(document.getElementById('root')); root.render(\u003cApp /\u003e); Generating Dynamic Content with JSX The initial example demonstrates a straightforward use case, but let's explore how we can create content dynamically. For instance, how can we generate a list of data dynamically? In React, as illustrated earlier, a component is fundamentally a function, enabling us to pass parameters to it. import React from 'react'; function Navigation({ nav }) { return ( \u003cnav\u003e \u003col\u003e {nav.map(item =\u003e \u003cli key={item}\u003e{item}\u003c/li\u003e)} \u003c/ol\u003e \u003c/nav\u003e ); } In this modified Navigation component, we anticipate the parameter to be an array of strings. We utilize the map function to iterate over each item, transforming them into \u003cli\u003e elements. The curly braces {} signify that the enclosed JavaScript expression should be evaluated and rendered. For those curious about the compiled version of this dynamic content handling: function Navigation(props) { var nav = props.nav; return React.createElement( \"nav\", null, React.createElement( \"ol\", null, nav.map(function(item) { return React.createElement(\"li\", { key: item }, item); }) ) ); } Instead of invoking Navigation as a regular function, employing JSX syntax renders the component invocation more akin to writing markup, enhancing readability: // Instead of this Navigation([\"Home\", \"Blogs\", \"Books\"]) // We do this \u003cNavigation nav={[\"Home\", \"Blogs\", \"Books\"]} /\u003e Components in React can receive diverse data, known as props, to modify their behavior, much like passing arguments into a function (the distinction lies in using JSX syntax, making the code more familiar and readable to those with HTML knowledge, which aligns well with the skill set of most frontend developers). import React from 'react'; import Checkbox from './Checkbox'; import BookList from './BookList'; function App() { let showNewOnly = false; // This flag's value is typically set based on specific logic. const filteredBooks = showNewOnly ? booksData.filter(book =\u003e book.isNewPublished) : booksData; return ( \u003cdiv\u003e \u003cCheckbox checked={showNewOnly}\u003e Show New Published Books Only \u003c/Checkbox\u003e \u003cBookList books={filteredBooks} /\u003e \u003c/div\u003e ); } In this illustrative code snippet (non-functional but intended to demonstrate the concept), we manipulate the BookList component's displayed content by passing it an array of books. Depending on the showNewOnly flag, this array is either all available books or only those that are newly published, showcasing how props can be used to dynamically adjust component output. Managing Internal State Between Renders: useState Building user interfaces (UI) often transcends the generation of static HTML. Components frequently need to “remember” certain states and respond to user interactions dynamically. For instance, when a user clicks an “Add” button in a Product component, it's necessary to update the ShoppingCart component to reflect both the total price and the updated item list. In the previous code snippet, attempting to set the showNewOnly variable to true within an event handler does not achieve the desired effect: function App () { let showNewOnly = false; const handleCheckboxChange = () =\u003e { showNewOnly = true; // this doesn't work }; const filteredBooks = showNewOnly ? booksData.filter(book =\u003e book.isNewPublished) : booksData; return ( \u003cdiv\u003e \u003cCheckbox checked={showNewOnly} onChange={handleCheckboxChange}\u003e Show New Published Books Only \u003c/Checkbox\u003e \u003cBookList books={filteredBooks}/\u003e \u003c/div\u003e ); }; This approach falls short because local variables inside a function component do not persist between renders. When React re-renders this component, it does so from scratch, disregarding any changes made to local variables since these do not trigger re-renders. React remains unaware of the need to update the component to reflect new data. This limitation underscores the necessity for React's state. Specifically, functional components leverage the useState hook to remember states across renders. Revisiting the App example, we can effectively remember the showNewOnly state as follows: import React, { useState } from 'react'; import Checkbox from './Checkbox'; import BookList from './BookList'; function App () { const [showNewOnly, setShowNewOnly] = useState(false); const handleCheckboxChange = () =\u003e { setShowNewOnly(!showNewOnly); }; const filteredBooks = showNewOnly ? booksData.filter(book =\u003e book.isNewPublished) : booksData; return ( \u003cdiv\u003e \u003cCheckbox checked={showNewOnly} onChange={handleCheckboxChange}\u003e Show New Published Books Only \u003c/Checkbox\u003e \u003cBookList books={filteredBooks}/\u003e \u003c/div\u003e ); }; The useState hook is a cornerstone of React's Hooks system, introduced to enable functional components to manage internal state. It introduces state to functional components, encapsulated by the following syntax: const [state, setState] = useState(initialState); initialState: This argument is the initial value of the state variable. It can be a simple value like a number, string, boolean, or a more complex object or array. The initialState is only used during the first render to initialize the state. Return Value: useState returns an array with two elements. The first element is the current state value, and the second element is a function that allows updating this value. By using array destructuring, we assign names to these returned items, typically state and setState, though you can choose any valid variable names. state: Represents the current value of the state. It's the value that will be used in the component's UI and logic. setState: A function to update the state. This function accepts a new state value or a function that produces a new state based on the previous state. When called, it schedules an update to the component's state and triggers a re-render to reflect the changes. React treats state as a snapshot; updating it doesn't alter the existing state variable but instead triggers a re-render. During this re-render, React acknowledges the updated state, ensuring the BookList component receives the correct data, thereby reflecting the updated book list to the user. This snapshot-like behavior of state facilitates the dynamic and responsive nature of React components, enabling them to react intuitively to user interactions and other changes. Managing Side Effects: useEffect Before diving deeper into our discussion, it's crucial to address the concept of side effects. Side effects are operations that interact with the outside world from the React ecosystem. Common examples include fetching data from a remote server or dynamically manipulating the DOM, such as changing the page title. React is primarily concerned with rendering data to the DOM and does not inherently handle data fetching or direct DOM manipulation. To facilitate these side effects, React provides the useEffect hook. This hook allows the execution of side effects after React has completed its rendering process. If these side effects result in data changes, React schedules a re-render to reflect these updates. The useEffect Hook accepts two arguments: A function containing the side effect logic. An optional dependency array specifying when the side effect should be re-invoked. Omitting the second argument causes the side effect to run after every render. Providing an empty array [] signifies that your effect doesn’t depend on any values from props or state, thus not needing to re-run. Including specific values in the array means the side effect only re-executes if those values change. When dealing with asynchronous data fetching, the workflow within useEffect entails initiating a network request. Once the data is retrieved, it is captured via the useState hook, updating the component's internal state and preserving the fetched data across renders. React, recognizing the state update, undertakes another render cycle to incorporate the new data. Here's a practical example about data fetching and state management: import { useEffect, useState } from \"react\"; type User = { id: string; name: string; }; const UserSection = ({ id }) =\u003e { const [user, setUser] = useState\u003cUser | undefined\u003e(); useEffect(() =\u003e { const fetchUser = async () =\u003e { const response = await fetch(`/api/users/${id}`); const jsonData = await response.json(); setUser(jsonData); }; fetchUser(); }, [id]); return \u003cdiv\u003e \u003ch2\u003e{user?.name}\u003c/h2\u003e \u003c/div\u003e; }; In the code snippet above, within useEffect, an asynchronous function fetchUser is defined and then immediately invoked. This pattern is necessary because useEffect does not directly support async functions as its callback. The async function is defined to use await for the fetch operation, ensuring that the code execution waits for the response and then processes the JSON data. Once the data is available, it updates the component's state via setUser. The dependency array [id] at the end of the useEffect call ensures that the effect runs again only if id changes, which prevents unnecessary network requests on every render and fetches new user data when the id prop updates. This approach to handling asynchronous data fetching within useEffect is a standard practice in React development, offering a structured and efficient way to integrate async operations into the React component lifecycle. In addition, in practical applications, managing different states such as loading, error, and data presentation is essential too (we'll see it how it works in the following section). For example, consider implementing status indicators within a User component to reflect loading, error, or data states, enhancing the user experience by providing feedback during data fetching operations. Figure 2: Different statuses of a component This overview offers just a quick glimpse into the concepts utilized throughout this article. For a deeper dive into additional concepts and patterns, I recommend exploring the new React documentation or consulting other online resources. With this foundation, you should now be equipped to join me as we delve into the data fetching patterns discussed herein. Implement the Profile component Let’s create the Profile component to make a request and render the result. In typical React applications, this data fetching is handled inside a useEffect block. Here's an example of how this might be implemented: import { useEffect, useState } from \"react\"; const Profile = ({ id }: { id: string }) =\u003e { const [user, setUser] = useState\u003cUser | undefined\u003e(); useEffect(() =\u003e { const fetchUser = async () =\u003e { const response = await fetch(`/api/users/${id}`); const jsonData = await response.json(); setUser(jsonData); }; fetchUser(); }, [id]); return ( \u003cUserBrief user={user} /\u003e ); }; This initial approach assumes network requests complete instantaneously, which is often not the case. Real-world scenarios require handling varying network conditions, including delays and failures. To manage these effectively, we incorporate loading and error states into our component. This addition allows us to provide feedback to the user during data fetching, such as displaying a loading indicator or a skeleton screen if the data is delayed, and handling errors when they occur. Here’s how the enhanced component looks with added loading and error management: import { useEffect, useState } from \"react\"; import { get } from \"../utils.ts\"; import type { User } from \"../types.ts\"; const Profile = ({ id }: { id: string }) =\u003e { const [loading, setLoading] = useState\u003cboolean\u003e(false); const [error, setError] = useState\u003cError | undefined\u003e(); const [user, setUser] = useState\u003cUser | undefined\u003e(); useEffect(() =\u003e { const fetchUser = async () =\u003e { try { setLoading(true); const data = await get\u003cUser\u003e(`/users/${id}`); setUser(data); } catch (e) { setError(e as Error); } finally { setLoading(false); } }; fetchUser(); }, [id]); if (loading || !user) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } return ( \u003c\u003e {user \u0026\u0026 \u003cUserBrief user={user} /\u003e} \u003c/\u003e ); }; Now in Profile component, we initiate states for loading, errors, and user data with useState. Using useEffect, we fetch user data based on id, toggling loading status and handling errors accordingly. Upon successful data retrieval, we update the user state, else display a loading indicator. The get function, as demonstrated below, simplifies fetching data from a specific endpoint by appending the endpoint to a predefined base URL. It checks the response's success status and either returns the parsed JSON data or throws an error for unsuccessful requests, streamlining error handling and data retrieval in our application. Note it's pure TypeScript code and can be used in other non-React parts of the application. const baseurl = \"https://icodeit.com.au/api/v2\"; async function get\u003cT\u003e(url: string): Promise\u003cT\u003e { const response = await fetch(`${baseurl}${url}`); if (!response.ok) { throw new Error(\"Network response was not ok\"); } return await response.json() as Promise\u003cT\u003e; } React will try to render the component initially, but as the data user isn’t available, it returns “loading...” in a div. Then the useEffect is invoked, and the request is kicked off. Once at some point, the response returns, React re-renders the Profile component with user fulfilled, so you can now see the user section with name, avatar, and title. If we visualize the timeline of the above code, you will see the following sequence. The browser firstly downloads the HTML page, and then when it encounters script tags and style tags, it might stop and download these files, and then parse them to form the final page. Note that this is a relatively complicated process, and I’m oversimplifying here, but the basic idea of the sequence is correct. Figure 3: Fetching user data So React can start to render only when the JS are parsed and executed, and then it finds the useEffect for data fetching; it has to wait until the data is available for a re-render. Now in the browser, we can see a “loading...” when the application starts, and then after a few seconds (we can simulate such case by add some delay in the API endpoints) the user brief section shows up when data is loaded. Figure 4: User brief component This code structure (in useEffect to trigger request, and update states like loading and error correspondingly) is widely used across React codebases. In applications of regular size, it's common to find numerous instances of such same data-fetching logic dispersed throughout various components. Asynchronous State Handler Wrap asynchronous queries with meta-queries for the state of the query. Remote calls can be slow, and it's essential not to let the UI freeze while these calls are being made. Therefore, we handle them asynchronously and use indicators to show that a process is underway, which makes the user experience better - knowing that something is happening. Additionally, remote calls might fail due to connection issues, requiring clear communication of these failures to the user. Therefore, it's best to encapsulate each remote call within a handler module that manages results, progress updates, and errors. This module allows the UI to access metadata about the status of the call, enabling it to display alternative information or options if the expected results fail to materialize. A simple implementation could be a function getAsyncStates that returns these metadata, it takes a URL as its parameter and returns an object containing information essential for managing asynchronous operations. This setup allows us to appropriately respond to different states of a network request, whether it's in progress, successfully resolved, or has encountered an error. const { loading, error, data } = getAsyncStates(url); if (loading) { // Display a loading spinner } if (error) { // Display an error message } // Proceed to render using the data The assumption here is that getAsyncStates initiates the network request automatically upon being called. However, this might not always align with the caller's needs. To offer more control, we can also expose a fetch function within the returned object, allowing the initiation of the request at a more appropriate time, according to the caller's discretion. Additionally, a refetch function could be provided to enable the caller to re-initiate the request as needed, such as after an error or when updated data is required. The fetch and refetch functions can be identical in implementation, or refetch might include logic to check for cached results and only re-fetch data if necessary. const { loading, error, data, fetch, refetch } = getAsyncStates(url); const onInit = () =\u003e { fetch(); }; const onRefreshClicked = () =\u003e { refetch(); }; if (loading) { // Display a loading spinner } if (error) { // Display an error message } // Proceed to render using the data This pattern provides a versatile approach to handling asynchronous requests, giving developers the flexibility to trigger data fetching explicitly and manage the UI's response to loading, error, and success states effectively. By decoupling the fetching logic from its initiation, applications can adapt more dynamically to user interactions and other runtime conditions, enhancing the user experience and application reliability. Implementing Asynchronous State Handler in React with hooks The pattern can be implemented in different frontend libraries. For instance, we could distill this approach into a custom Hook in a React application for the Profile component: import { useEffect, useState } from \"react\"; import { get } from \"../utils.ts\"; const useUser = (id: string) =\u003e { const [loading, setLoading] = useState\u003cboolean\u003e(false); const [error, setError] = useState\u003cError | undefined\u003e(); const [user, setUser] = useState\u003cUser | undefined\u003e(); useEffect(() =\u003e { const fetchUser = async () =\u003e { try { setLoading(true); const data = await get\u003cUser\u003e(`/users/${id}`); setUser(data); } catch (e) { setError(e as Error); } finally { setLoading(false); } }; fetchUser(); }, [id]); return { loading, error, user, }; }; Please note that in the custom Hook, we don't have any JSX code - meaning it's totally UI free but sharable stateful logic. And the useUser launch data automatically when called. Within the Profile component, leveraging the useUser Hook simplifies its logic: import { useUser } from './useUser.ts'; import UserBrief from './UserBrief.tsx'; const Profile = ({ id }: { id: string }) =\u003e { const { loading, error, user } = useUser(id); if (loading || !user) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } if (error) { return \u003cdiv\u003eSomething went wrong...\u003c/div\u003e; } return ( \u003c\u003e {user \u0026\u0026 \u003cUserBrief user={user} /\u003e} \u003c/\u003e ); }; Generalizing Parameter Usage In most applications, fetching different types of data—from user details on a homepage to product lists in search results and recommendations beneath them—is a common requirement. Writing separate fetch functions for each type of data can be tedious and difficult to maintain. A better approach is to abstract this functionality into a generic, reusable hook that can handle various data types efficiently. Consider treating remote API endpoints as services, and use a generic useService hook that accepts a URL as a parameter while managing all the metadata associated with an asynchronous request: import { get } from \"../utils.ts\"; function useService\u003cT\u003e(url: string) { const [loading, setLoading] = useState\u003cboolean\u003e(false); const [error, setError] = useState\u003cError | undefined\u003e(); const [data, setData] = useState\u003cT | undefined\u003e(); const fetch = async () =\u003e { try { setLoading(true); const data = await get\u003cT\u003e(url); setData(data); } catch (e) { setError(e as Error); } finally { setLoading(false); } }; return { loading, error, data, fetch, }; } This hook abstracts the data fetching process, making it easier to integrate into any component that needs to retrieve data from a remote source. It also centralizes common error handling scenarios, such as treating specific errors differently: import { useService } from './useService.ts'; const { loading, error, data: user, fetch: fetchUser, } = useService(`/users/${id}`); By using useService, we can simplify how components fetch and handle data, making the codebase cleaner and more maintainable. Variation of the pattern A variation of the useUser would be expose the fetchUsers function, and it does not trigger the data fetching itself: import { useState } from \"react\"; const useUser = (id: string) =\u003e { // define the states const fetchUser = async () =\u003e { try { setLoading(true); const data = await get\u003cUser\u003e(`/users/${id}`); setUser(data); } catch (e) { setError(e as Error); } finally { setLoading(false); } }; return { loading, error, user, fetchUser, }; }; And then on the calling site, Profile component use useEffect to fetch the data and render different states. const Profile = ({ id }: { id: string }) =\u003e { const { loading, error, user, fetchUser } = useUser(id); useEffect(() =\u003e { fetchUser(); }, []); // render correspondingly }; The advantage of this division is the ability to reuse these stateful logics across different components. For instance, another component needing the same data (a user API call with a user ID) can simply import the useUser Hook and utilize its states. Different UI components might choose to interact with these states in various ways, perhaps using alternative loading indicators (a smaller spinner that fits to the calling component) or error messages, yet the fundamental logic of fetching data remains consistent and shared. When to use it Separating data fetching logic from UI components can sometimes introduce unnecessary complexity, particularly in smaller applications. Keeping this logic integrated within the component, similar to the css-in-js approach, simplifies navigation and is easier for some developers to manage. In my article, Modularizing React Applications with Established UI Patterns, I explored various levels of complexity in application structures. For applications that are limited in scope — with just a few pages and several data fetching operations — it's often practical and also recommended to maintain data fetching within the UI components. However, as your application scales and the development team grows, this strategy may lead to inefficiencies. Deep component trees can slow down your application (we will see examples as well as how to address them in the following sections) and generate redundant boilerplate code. Introducing an Asynchronous State Handler can mitigate these issues by decoupling data fetching from UI rendering, enhancing both performance and maintainability. It’s crucial to balance simplicity with structured approaches as your project evolves. This ensures your development practices remain effective and responsive to the application's needs, maintaining optimal performance and developer efficiency regardless of the project scale. Implement the Friends list Now let’s have a look at the second section of the Profile - the friend list. We can create a separate component Friends and fetch data in it (by using a useService custom hook we defined above), and the logic is pretty similar to what we see above in the Profile component. const Friends = ({ id }: { id: string }) =\u003e { const { loading, error, data: friends } = useService(`/users/${id}/friends`); // loading \u0026 error handling... return ( \u003cdiv\u003e \u003ch2\u003eFriends\u003c/h2\u003e \u003cdiv\u003e {friends.map((user) =\u003e ( // render user list ))} \u003c/div\u003e \u003c/div\u003e ); }; And then in the Profile component, we can use Friends as a regular component, and pass in id as a prop: const Profile = ({ id }: { id: string }) =\u003e { //... return ( \u003c\u003e {user \u0026\u0026 \u003cUserBrief user={user} /\u003e} \u003cFriends id={id} /\u003e \u003c/\u003e ); }; The code works fine, and it looks pretty clean and readable, UserBrief renders a user object passed in, while Friends manage its own data fetching and rendering logic altogether. If we visualize the component tree, it would be something like this: Figure 5: Component structure Both the Profile and Friends have logic for data fetching, loading checks, and error handling. Since there are two separate data fetching calls, and if we look at the request timeline, we will notice something interesting. Figure 6: Request waterfall The Friends component won't initiate data fetching until the user state is set. This is referred to as the Fetch-On-Render approach, where the initial rendering is paused because the data isn't available, requiring React to wait for the data to be retrieved from the server side. This waiting period is somewhat inefficient, considering that while React's rendering process only takes a few milliseconds, data fetching can take significantly longer, often seconds. As a result, the Friends component spends most of its time idle, waiting for data. This scenario leads to a common challenge known as the Request Waterfall, a frequent occurrence in frontend applications that involve multiple data fetching operations. Parallel Data Fetching Run remote data fetches in parallel to minimize wait time Imagine when we build a larger application that a component that requires data can be deeply nested in the component tree, to make the matter worse these components are developed by different teams, it’s hard to see whom we’re blocking. Figure 7: Request waterfall Request Waterfalls can degrade user experience, something we aim to avoid. Analyzing the data, we see that the user API and friends API are independent and can be fetched in parallel. Initiating these parallel requests becomes critical for application performance. One approach is to centralize data fetching at a higher level, near the root. Early in the application's lifecycle, we start all data fetches simultaneously. Components dependent on this data wait only for the slowest request, typically resulting in faster overall load times. We could use the Promise API Promise.all to send both requests for the user’s basic information and their friends list. Promise.all is a JavaScript method that allows for the concurrent execution of multiple promises. It takes an array of promises as input and returns a single Promise that resolves when all of the input promises have resolved, providing their results as an array. If any of the promises fail, Promise.all immediately rejects with the reason of the first promise that rejects. For instance, at the application's root, we can define a comprehensive data model: type ProfileState = { user: User; friends: User[]; }; const getProfileData = async (id: string) =\u003e Promise.all([ get\u003cUser\u003e(`/users/${id}`), get\u003cUser[]\u003e(`/users/${id}/friends`), ]); const App = () =\u003e { // fetch data at the very begining of the application launch const onInit = () =\u003e { const [user, friends] = await getProfileData(id); } // render the sub tree correspondingly } Implementing Parallel Data Fetching in React Upon application launch, data fetching begins, abstracting the fetching process from subcomponents. For example, in Profile component, both UserBrief and Friends are presentational components that react to the passed data. This way we could develop these component separately (adding styles for different states, for example). These presentational components normally are easy to test and modify as we have separate the data fetching and rendering. We can define a custom hook useProfileData that facilitates parallel fetching of data related to a user and their friends by using Promise.all. This method allows simultaneous requests, optimizing the loading process and structuring the data into a predefined format known as ProfileData. Here’s a breakdown of the hook implementation: import { useCallback, useEffect, useState } from \"react\"; type ProfileData = { user: User; friends: User[]; }; const useProfileData = (id: string) =\u003e { const [loading, setLoading] = useState\u003cboolean\u003e(false); const [error, setError] = useState\u003cError | undefined\u003e(undefined); const [profileState, setProfileState] = useState\u003cProfileData\u003e(); const fetchProfileState = useCallback(async () =\u003e { try { setLoading(true); const [user, friends] = await Promise.all([ get\u003cUser\u003e(`/users/${id}`), get\u003cUser[]\u003e(`/users/${id}/friends`), ]); setProfileState({ user, friends }); } catch (e) { setError(e as Error); } finally { setLoading(false); } }, [id]); return { loading, error, profileState, fetchProfileState, }; }; This hook provides the Profile component with the necessary data states (loading, error, profileState) along with a fetchProfileState function, enabling the component to initiate the fetch operation as needed. Note here we use useCallback hook to wrap the async function for data fetching. The useCallback hook in React is used to memoize functions, ensuring that the same function instance is maintained across component re-renders unless its dependencies change. Similar to the useEffect, it accepts the function and a dependency array, the function will only be recreated if any of these dependencies change, thereby avoiding unintended behavior in React's rendering cycle. The Profile component uses this hook and controls the data fetching timing via useEffect: const Profile = ({ id }: { id: string }) =\u003e { const { loading, error, profileState, fetchProfileState } = useProfileData(id); useEffect(() =\u003e { fetchProfileState(); }, [fetchProfileState]); if (loading) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } if (error) { return \u003cdiv\u003eSomething went wrong...\u003c/div\u003e; } return ( \u003c\u003e {profileState \u0026\u0026 ( \u003c\u003e \u003cUserBrief user={profileState.user} /\u003e \u003cFriends users={profileState.friends} /\u003e \u003c/\u003e )} \u003c/\u003e ); }; This approach is also known as Fetch-Then-Render, suggesting that the aim is to initiate requests as early as possible during page load. Subsequently, the fetched data is utilized to drive React's rendering of the application, bypassing the need to manage data fetching amidst the rendering process. This strategy simplifies the rendering process, making the code easier to test and modify. And the component structure, if visualized, would be like the following illustration Figure 8: Component structure after refactoring And the timeline is much shorter than the previous one as we send two requests in parallel. The Friends component can render in a few milliseconds as when it starts to render, the data is already ready and passed in. Figure 9: Parallel requests Note that the longest wait time depends on the slowest network request, which is much faster than the sequential ones. And if we could send as many of these independent requests at the same time at an upper level of the component tree, a better user experience can be expected. As applications expand, managing an increasing number of requests at root level becomes challenging. This is particularly true for components distant from the root, where passing down data becomes cumbersome. One approach is to store all data globally, accessible via functions (like Redux or the React Context API), avoiding deep prop drilling. When to use it Running queries in parallel is useful whenever such queries may be slow and don't significantly interfere with each others' performance. This is usually the case with remote queries. Even if the remote machine's I/O and computation is fast, there's always potential latency issues in the remote calls. The main disadvantage for parallel queries is setting them up with some kind of asynchronous mechanism, which may be difficult in some language environments. The main reason to not use parallel data fetching is when we don't know what data needs to be fetched until we've already fetched some data. Certain scenarios require sequential data fetching due to dependencies between requests. For instance, consider a scenario on a Profile page where generating a personalized recommendation feed depends on first acquiring the user's interests from a user API. Here's an example response from the user API that includes interests: { \"id\": \"u1\", \"name\": \"Juntao Qiu\", \"bio\": \"Developer, Educator, Author\", \"interests\": [ \"Technology\", \"Outdoors\", \"Travel\" ] } In such cases, the recommendation feed can only be fetched after receiving the user's interests from the initial API call. This sequential dependency prevents us from utilizing parallel fetching, as the second request relies on data obtained from the first. Given these constraints, it becomes important to discuss alternative strategies in asynchronous data management. One such strategy is Fallback Markup. This approach allows developers to specify what data is needed and how it should be fetched in a way that clearly defines dependencies, making it easier to manage complex data relationships in an application. Another example of when arallel Data Fetching is not applicable is that in scenarios involving user interactions that require real-time data validation. Consider the case of a list where each item has an “Approve” context menu. When a user clicks on the “Approve” option for an item, a dropdown menu appears offering choices to either “Approve” or “Reject.” If this item's approval status could be changed by another admin concurrently, then the menu options must reflect the most current state to avoid conflicting actions. Figure 10: The approval list that require in-time states To handle this, a service call is initiated each time the context menu is activated. This service fetches the latest status of the item, ensuring that the dropdown is constructed with the most accurate and current options available at that moment. As a result, these requests cannot be made in parallel with other data-fetching activities since the dropdown's contents depend entirely on the real-time status fetched from the server. Fallback Markup Specify fallback displays in the page markup This pattern leverages abstractions provided by frameworks or libraries to handle the data retrieval process, including managing states like loading, success, and error, behind the scenes. It allows developers to focus on the structure and presentation of data in their applications, promoting cleaner and more maintainable code. Let's take another look at the Friends component in the above section. It has to maintain three different states and register the callback in useEffect, setting the flag correctly at the right time, arrange the different UI for different states: const Friends = ({ id }: { id: string }) =\u003e { //... const { loading, error, data: friends, fetch: fetchFriends, } = useService(`/users/${id}/friends`); useEffect(() =\u003e { fetchFriends(); }, []); if (loading) { // show loading indicator } if (error) { // show error message component } // show the acutal friend list }; You will notice that inside a component we have to deal with different states, even we extract custom Hook to reduce the noise in a component, we still need to pay good attention to handling loading and error inside a component. These boilerplate code can be cumbersome and distracting, often cluttering the readability of our codebase. If we think of declarative API, like how we build our UI with JSX, the code can be written in the following manner that allows you to focus on what the component is doing - not how to do it: \u003cWhenError fallback={\u003cErrorMessage /\u003e}\u003e \u003cWhenInProgress fallback={\u003cLoading /\u003e}\u003e \u003cFriends /\u003e \u003c/WhenInProgress\u003e \u003c/WhenError\u003e In the above code snippet, the intention is simple and clear: when an error occurs, ErrorMessage is displayed. While the operation is in progress, Loading is shown. Once the operation completes without errors, the Friends component is rendered. And the code snippet above is pretty similiar to what already be implemented in a few libraries (including React and Vue.js). For example, the new Suspense in React allows developers to more effectively manage asynchronous operations within their components, improving the handling of loading states, error states, and the orchestration of concurrent tasks. Implementing Fallback Markup in React with Suspense Suspense in React is a mechanism for efficiently handling asynchronous operations, such as data fetching or resource loading, in a declarative manner. By wrapping components in a Suspense boundary, developers can specify fallback content to display while waiting for the component's data dependencies to be fulfilled, streamlining the user experience during loading states. While with the Suspense API, in the Friends you describe what you want to get and then render: import useSWR from \"swr\"; import { get } from \"../utils.ts\"; function Friends({ id }: { id: string }) { const { data: users } = useSWR(\"/api/profile\", () =\u003e get\u003cUser[]\u003e(`/users/${id}/friends`), { suspense: true, }); return ( \u003cdiv\u003e \u003ch2\u003eFriends\u003c/h2\u003e \u003cdiv\u003e {friends.map((user) =\u003e ( \u003cFriend user={user} key={user.id} /\u003e ))} \u003c/div\u003e \u003c/div\u003e ); } And declaratively when you use the Friends, you use Suspense boundary to wrap around the Friends component: \u003cSuspense fallback={\u003cFriendsSkeleton /\u003e}\u003e \u003cFriends id={id} /\u003e \u003c/Suspense\u003e Suspense manages the asynchronous loading of the Friends component, showing a FriendsSkeleton placeholder until the component's data dependencies are resolved. This setup ensures that the user interface remains responsive and informative during data fetching, improving the overall user experience. Use the pattern in Vue.js It's worth noting that Vue.js is also exploring a similar experimental pattern, where you can employ Fallback Markup using: \u003cSuspense\u003e \u003ctemplate #default\u003e \u003cAsyncComponent /\u003e \u003c/template\u003e \u003ctemplate #fallback\u003e Loading... \u003c/template\u003e \u003c/Suspense\u003e Upon the first render, \u003cSuspense\u003e attempts to render its default content behind the scenes. Should it encounter any asynchronous dependencies during this phase, it transitions into a pending state, where the fallback content is displayed instead. Once all the asynchronous dependencies are successfully loaded, \u003cSuspense\u003e moves to a resolved state, and the content initially intended for display (the default slot content) is rendered. Deciding Placement for the Loading Component You may wonder where to place the FriendsSkeleton component and who should manage it. Typically, without using Fallback Markup, this decision is straightforward and handled directly within the component that manages the data fetching: const Friends = ({ id }: { id: string }) =\u003e { // Data fetching logic here... if (loading) { // Display loading indicator } if (error) { // Display error message component } // Render the actual friend list }; In this setup, the logic for displaying loading indicators or error messages is naturally situated within the Friends component. However, adopting Fallback Markup shifts this responsibility to the component’s consumer: \u003cSuspense fallback={\u003cFriendsSkeleton /\u003e}\u003e \u003cFriends id={id} /\u003e \u003c/Suspense\u003e In real-world applications, the optimal approach to handling loading experiences depends significantly on the desired user interaction and the structure of the application. For instance, a hierarchical loading approach where a parent component ceases to show a loading indicator while its children components continue can disrupt the user experience. Thus, it's crucial to carefully consider at what level within the component hierarchy the loading indicators or skeleton placeholders should be displayed. Think of Friends and FriendsSkeleton as two distinct component states—one representing the presence of data, and the other, the absence. This concept is somewhat analogous to using a Special Case pattern in object-oriented programming, where FriendsSkeleton serves as the 'null' state handling for the Friends component. The key is to determine the granularity with which you want to display loading indicators and to maintain consistency in these decisions across your application. Doing so helps achieve a smoother and more predictable user experience. When to use it Using Fallback Markup in your UI simplifies code by enhancing its readability and maintainability. This pattern is particularly effective when utilizing standard components for various states such as loading, errors, skeletons, and empty views across your application. It reduces redundancy and cleans up boilerplate code, allowing components to focus solely on rendering and functionality. Fallback Markup, such as React's Suspense, standardizes the handling of asynchronous loading, ensuring a consistent user experience. It also improves application performance by optimizing resource loading and rendering, which is especially beneficial in complex applications with deep component trees. However, the effectiveness of Fallback Markup depends on the capabilities of the framework you are using. For example, React's implementation of Suspense for data fetching still requires third-party libraries, and Vue’s support for similar features is experimental. Moreover, while Fallback Markup can reduce complexity in managing state across components, it may introduce overhead in simpler applications where managing state directly within components could suffice. Additionally, this pattern may limit detailed control over loading and error states—situations where different error types need distinct handling might not be as easily managed with a generic fallback approach. Introducing UserDetailCard component Let’s say we need a feature that when users hover on top of a Friend, we show a popup so they can see more details about that user. Figure 11: Showing user detail card component when hover When the popup shows up, we need to send another service call to get the user details (like their homepage and number of connections, etc.). We will need to update the Friend component ((the one we use to render each item in the Friends list) ) to something like the following. import { Popover, PopoverContent, PopoverTrigger } from \"@nextui-org/react\"; import { UserBrief } from \"./user.tsx\"; import UserDetailCard from \"./user-detail-card.tsx\"; export const Friend = ({ user }: { user: User }) =\u003e { return ( \u003cPopover placement=\"bottom\" showArrow offset={10}\u003e \u003cPopoverTrigger\u003e \u003cbutton\u003e \u003cUserBrief user={user} /\u003e \u003c/button\u003e \u003c/PopoverTrigger\u003e \u003cPopoverContent\u003e \u003cUserDetailCard id={user.id} /\u003e \u003c/PopoverContent\u003e \u003c/Popover\u003e ); }; The UserDetailCard, is pretty similar to the Profile component, it sends a request to load data and then renders the result once it gets the response. export function UserDetailCard({ id }: { id: string }) { const { loading, error, detail } = useUserDetail(id); if (loading || !detail) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } return ( \u003cdiv\u003e {/* render the user detail*/} \u003c/div\u003e ); } We’re using Popover and the supporting components from nextui, which provides a lot of beautiful and out-of-box components for building modern UI. The only problem here, however, is that the package itself is relatively big, also not everyone uses the feature (hover and show details), so loading that extra large package for everyone isn’t ideal - it would be better to load the UserDetailCard on demand - whenever it’s required. Figure 12: Component structure with UserDetailCard Code Splitting Divide code into separate modules and dynamically load them as needed. Code Splitting addresses the issue of large bundle sizes in web applications by dividing the bundle into smaller chunks that are loaded as needed, rather than all at once. This improves initial load time and performance, especially important for large applications or those with many routes. This optimization is typically carried out at build time, where complex or sizable modules are segregated into distinct bundles. These are then dynamically loaded, either in response to user interactions or preemptively, in a manner that does not hinder the critical rendering path of the application. Leveraging the Dynamic Import Operator The dynamic import operator in JavaScript streamlines the process of loading modules. Though it may resemble a function call in your code, such as import(“./user-detail-card.tsx”), it's important to recognize that import is actually a keyword, not a function. This operator enables the asynchronous and dynamic loading of JavaScript modules. With dynamic import, you can load a module on demand. For example, we only load a module when a button is clicked: button.addEventListener(\"click\", (e) =\u003e { import(\"/modules/some-useful-module.js\") .then((module) =\u003e { module.doSomethingInteresting(); }) .catch(error =\u003e { console.error(\"Failed to load the module:\", error); }); }); The module is not loaded during the initial page load. Instead, the import() call is placed inside an event listener so it only be loaded when, and if, the user interacts with that button. You can use dynamic import operator in React and libraries like Vue.js. React simplifies the code splitting and lazy load through the React.lazy and Suspense APIs. By wrapping the import statement with React.lazy, and subsequently wrapping the component, for instance, UserDetailCard, with Suspense, React defers the component rendering until the required module is loaded. During this loading phase, a fallback UI is presented, seamlessly transitioning to the actual component upon load completion. import React, { Suspense } from \"react\"; import { Popover, PopoverContent, PopoverTrigger } from \"@nextui-org/react\"; import { UserBrief } from \"./user.tsx\"; const UserDetailCard = React.lazy(() =\u003e import(\"./user-detail-card.tsx\")); export const Friend = ({ user }: { user: User }) =\u003e { return ( \u003cPopover placement=\"bottom\" showArrow offset={10}\u003e \u003cPopoverTrigger\u003e \u003cbutton\u003e \u003cUserBrief user={user} /\u003e \u003c/button\u003e \u003c/PopoverTrigger\u003e \u003cPopoverContent\u003e \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e \u003cUserDetailCard id={user.id} /\u003e \u003c/Suspense\u003e \u003c/PopoverContent\u003e \u003c/Popover\u003e ); }; This snippet defines a Friend component displaying user details within a popover from Next UI, which appears upon interaction. It leverages React.lazy for code splitting, loading the UserDetailCard component only when needed. This lazy-loading, combined with Suspense, enhances performance by splitting the bundle and showing a fallback during the load. If we visualize the above code, it renders in the following sequence. Figure 13: Dynamic load component when needed Note that when the user hovers and we download the JavaScript bundle, there will be some extra time for the browser to parse the JavaScript. Once that part of the work is done, we can get the user details by calling /users/\u003cid\u003e/details API. Eventually, we can use that data to render the content of the popup UserDetailCard. When to use it Splitting out extra bundles and loading them on demand is a viable strategy, but it's crucial to consider how you implement it. Requesting and processing an additional bundle can indeed save bandwidth and lets users only load what they need. However, this approach might also slow down the user experience in certain scenarios. For example, if a user hovers over a button that triggers a bundle load, it could take a few seconds to load, parse, and execute the JavaScript necessary for rendering. Even though this delay occurs only during the first interaction, it might not provide the ideal experience. To improve perceived performance, effectively using React Suspense to display a skeleton or another loading indicator can help make the loading process seem quicker. Additionally, if the separate bundle is not significantly large, integrating it into the main bundle could be a more straightforward and cost-effective approach. This way, when a user hovers over components like UserBrief, the response can be immediate, enhancing the user interaction without the need for separate loading steps. Lazy load in other frontend libraries Again, this pattern is widely adopted in other frontend libraries as well. For example, you can use defineAsyncComponent in Vue.js to achieve the samiliar result - only load a component when you need it to render: \u003ctemplate\u003e \u003cPopover placement=\"bottom\" show-arrow offset=\"10\"\u003e \u003c!-- the rest of the template --\u003e \u003c/Popover\u003e \u003c/template\u003e \u003cscript\u003e import { defineAsyncComponent } from 'vue'; import Popover from 'path-to-popover-component'; import UserBrief from './UserBrief.vue'; const UserDetailCard = defineAsyncComponent(() =\u003e import('./UserDetailCard.vue')); // rendering logic \u003c/script\u003e The function defineAsyncComponent defines an async component which is lazy loaded only when it is rendered just like the React.lazy. As you might have already seen the noticed, we are running into a Request Waterfall here again: we load the JavaScript bundle first, and then when it execute it sequentially call user details API, which makes some extra waiting time. We could request the JavaScript bundle and the network request parallely. Meaning, whenever a Friend component is hovered, we can trigger a network request (for the data to render the user details) and cache the result, so that by the time when the bundle is downloaded, we can use the data to render the component immediately. Prefetching Prefetch data before it may be needed to reduce latency if it is. Prefetching involves loading resources or data ahead of their actual need, aiming to decrease wait times during subsequent operations. This technique is particularly beneficial in scenarios where user actions can be predicted, such as navigating to a different page or displaying a modal dialog that requires remote data. In practice, prefetching can be implemented using the native HTML \u003clink\u003e tag with a rel=”preload” attribute, or programmatically via the fetch API to load data or resources in advance. For data that is predetermined, the simplest approach is to use the \u003clink\u003e tag within the HTML \u003chead\u003e: \u003c!doctype html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003clink rel=\"preload\" href=\"/bootstrap.js\" as=\"script\"\u003e \u003clink rel=\"preload\" href=\"/users/u1\" as=\"fetch\" crossorigin=\"anonymous\"\u003e \u003clink rel=\"preload\" href=\"/users/u1/friends\" as=\"fetch\" crossorigin=\"anonymous\"\u003e \u003cscript type=\"module\" src=\"/app.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e With this setup, the requests for bootstrap.js and user API are sent as soon as the HTML is parsed, significantly earlier than when other scripts are processed. The browser will then cache the data, ensuring it is ready when your application initializes. However, it's often not possible to know the precise URLs ahead of time, requiring a more dynamic approach to prefetching. This is typically managed programmatically, often through event handlers that trigger prefetching based on user interactions or other conditions. For example, attaching a mouseover event listener to a button can trigger the prefetching of data. This method allows the data to be fetched and stored, perhaps in a local state or cache, ready for immediate use when the actual component or content requiring the data is interacted with or rendered. This proactive loading minimizes latency and enhances the user experience by having data ready ahead of time. document.getElementById('button').addEventListener('mouseover', () =\u003e { fetch(`/user/${user.id}/details`) .then(response =\u003e response.json()) .then(data =\u003e { sessionStorage.setItem('userDetails', JSON.stringify(data)); }) .catch(error =\u003e console.error(error)); }); And in the place that needs the data to render, it reads from sessionStorage when available, otherwise showing a loading indicator. Normally the user experiense would be much faster. Implementing Prefetching in React For example, we can use preload from the swr package (the function name is a bit misleading, but it is performing a prefetch here), and then register an onMouseEnter event to the trigger component of Popover, import { preload } from \"swr\"; import { getUserDetail } from \"../api.ts\"; const UserDetailCard = React.lazy(() =\u003e import(\"./user-detail-card.tsx\")); export const Friend = ({ user }: { user: User }) =\u003e { const handleMouseEnter = () =\u003e { preload(`/user/${user.id}/details`, () =\u003e getUserDetail(user.id)); }; return ( \u003cPopover placement=\"bottom\" showArrow offset={10}\u003e \u003cPopoverTrigger\u003e \u003cbutton onMouseEnter={handleMouseEnter}\u003e \u003cUserBrief user={user} /\u003e \u003c/button\u003e \u003c/PopoverTrigger\u003e \u003cPopoverContent\u003e \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e \u003cUserDetailCard id={user.id} /\u003e \u003c/Suspense\u003e \u003c/PopoverContent\u003e \u003c/Popover\u003e ); }; That way, the popup itself can have much less time to render, which brings a better user experience. Figure 14: Dynamic load with prefetch in parallel So when a user hovers on a Friend, we download the corresponding JavaScript bundle as well as download the data needed to render the UserDetailCard, and by the time UserDetailCard renders, it sees the existing data and renders immediately. Figure 15: Component structure with dynamic load As the data fetching and loading is shifted to Friend component, and for UserDetailCard, it reads from the local cache maintained by swr. import useSWR from \"swr\"; export function UserDetailCard({ id }: { id: string }) { const { data: detail, isLoading: loading } = useSWR( `/user/${id}/details`, () =\u003e getUserDetail(id) ); if (loading || !detail) { return \u003cdiv\u003eLoading...\u003c/div\u003e; } return ( \u003cdiv\u003e {/* render the user detail*/} \u003c/div\u003e ); } This component uses the useSWR hook for data fetching, making the UserDetailCard dynamically load user details based on the given id. useSWR offers efficient data fetching with caching, revalidation, and automatic error handling. The component displays a loading state until the data is fetched. Once the data is available, it proceeds to render the user details. In summary, we've already explored critical data fetching strategies: Asynchronous State Handler , Parallel Data Fetching , Fallback Markup , Code Splitting and Prefetching . Elevating requests for parallel execution enhances efficiency, though it's not always straightforward, especially when dealing with components developed by different teams without full visibility. Code splitting allows for the dynamic loading of non-critical resources based on user interaction, like clicks or hovers, utilizing prefetching to parallelize resource loading. When to use it Consider applying prefetching when you notice that the initial load time of your application is becoming slow, or there are many features that aren't immediately necessary on the initial screen but could be needed shortly after. Prefetching is particularly useful for resources that are triggered by user interactions, such as mouse-overs or clicks. While the browser is busy fetching other resources, such as JavaScript bundles or assets, prefetching can load additional data in advance, thus preparing for when the user actually needs to see the content. By loading resources during idle times, prefetching utilizes the network more efficiently, spreading the load over time rather than causing spikes in demand. It’s wise to follow a general guideline: don't implement complex patterns like prefetching until they are clearly needed. This might be the case if performance issues become apparent, especially during initial loads, or if a significant portion of your users access the app from mobile devices, which typically have less bandwidth and slower JavaScript engines. Also, consider that there are other performance optimization tactics such as caching at various levels, using CDNs for static assets, and ensuring assets are compressed. These methods can enhance performance with simpler configurations and without additional coding. The effectiveness of prefetching relies on accurately predicting user actions. Incorrect assumptions can lead to ineffective prefetching and even degrade the user experience by delaying the loading of actually needed resources. Choosing the right pattern Selecting the appropriate pattern for data fetching and rendering in web development is not one-size-fits-all. Often, multiple strategies are combined to meet specific requirements. For example, you might need to generate some content on the server side - using Server-Side Rendering techniques - supplemented by client-side Fetch-Then-Render for dynamic content. Furthermore, non-essential sections can be split into separate bundles for lazy loading, possibly with Prefetching triggered by user actions, such as hover or click. Consider the Jira issue page as an example. The top navigation and sidebar are static, loading first to give users immediate context. Early on, you're presented with the issue's title, description, and key details like the Reporter and Assignee. For less immediate information, such as the History section at an issue's bottom, it loads only upon user interaction, like clicking a tab. This utilizes lazy loading and data fetching to efficiently manage resources and enhance user experience. Figure 16: Using patterns together Moreover, certain strategies require additional setup compared to default, less optimized solutions. For instance, implementing Code Splitting requires bundler support. If your current bundler lacks this capability, an upgrade may be required, which could be impractical for older, less stable systems. We've covered a wide range of patterns and how they apply to various challenges. I realize there's quite a bit to take in, from code examples to diagrams. If you're looking for a more guided approach, I've put together a comprehensive tutorial on my website, or if you only want to have a look at the working code, they are all hosted in this github repo. Conclusion Data fetching is a nuanced aspect of development, yet mastering the appropriate techniques can vastly enhance our applications. As we conclude our journey through data fetching and content rendering strategies within the context of React, it's crucial to highlight our main insights: Asynchronous State Handler: Utilize custom hooks or composable APIs to abstract data fetching and state management away from your components. This pattern centralizes asynchronous logic, simplifying component design and enhancing reusability across your application. Fallback Markup: React's enhanced Suspense model supports a more declarative approach to fetching data asynchronously, streamlining your codebase. Parallel Data Fetching: Maximize efficiency by fetching data in parallel, reducing wait times and boosting the responsiveness of your application. Code Splitting: Employ lazy loading for non-essential components during the initial load, leveraging Suspense for graceful handling of loading states and code splitting, thereby ensuring your application remains performant. Prefetching: By preemptively loading data based on predicted user actions, you can achieve a smooth and fast user experience. While these insights were framed within the React ecosystem, it's essential to recognize that these patterns are not confined to React alone. They are broadly applicable and beneficial strategies that can—and should—be adapted for use with other libraries and frameworks. By thoughtfully implementing these approaches, developers can create applications that are not just efficient and scalable, but also offer a superior user experience through effective data fetching and content rendering practices.",
  "image": "https://martinfowler.com/logo-sq.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eToday, most applications can send hundreds of requests for a single page.\n    For example, my Twitter home page sends around 300 requests, and an Amazon\n    product details page sends around 600 requests. Some of them are for static\n    assets (JavaScript, CSS, font files, icons, etc.), but there are still\n    around 100 requests for async data fetching - either for timelines, friends,\n    or product recommendations, as well as analytics events. That’s quite a\n    lot.\u003c/p\u003e\n\n\u003cp\u003eThe main reason a page may contain so many requests is to improve\n    performance and user experience, specifically to make the application \u003ci\u003efeel\u003c/i\u003e\n    faster to the end users. The era of blank pages taking 5 seconds to load is\n    long gone. In modern web applications, users typically see a basic page with\n    style and other elements in less than a second, with additional pieces\n    loading progressively.\u003c/p\u003e\n\n\u003cp\u003eTake the Amazon product detail page as an example. The navigation and top\n    bar appear almost immediately, followed by the product images, brief, and\n    descriptions. Then, as you scroll, “Sponsored” content, ratings,\n    recommendations, view histories, and more appear.Often, a user only wants a\n    quick glance or to compare products (and check availability), making\n    sections like “Customers who bought this item also bought” less critical and\n    suitable for loading via separate requests.\u003c/p\u003e\n\n\u003cp\u003eBreaking down the content into smaller pieces and loading them in\n    parallel is an effective strategy, but it\u0026#39;s far from enough in large\n    applications. There are many other aspects to consider when it comes to\n    fetch data correctly and efficiently. Data fetching is a chellenging, not\n    only because the nature of async programming doesn\u0026#39;t fit our linear mindset,\n    and there are so many factors can cause a network call to fail, but also\n    there are too many not-obvious cases to consider under the hood (data\n    format, security, cache, token expiry, etc.).\u003c/p\u003e\n\n\u003cp\u003eIn this article, I would like to discuss some common problems and\n    patterns you should consider when it comes to fetching data in your frontend\n    applications.\u003c/p\u003e\n\n\u003cp\u003eWe\u0026#39;ll begin with the \u003ca href=\"#async-state-handler\"\u003eAsynchronous State Handler\u003c/a\u003e pattern, which decouples\n    data fetching from the UI, streamlining your application architecture. Next,\n    we\u0026#39;ll delve into \u003ca href=\"#fallback-markup\"\u003eFallback Markup\u003c/a\u003e, enhancing the intuitiveness of your data\n    fetching logic. To accelerate the initial data loading process, we\u0026#39;ll\n    explore strategies for avoiding \u003ca href=\"#request-waterfall\"\u003e Request\n    Waterfall\u003c/a\u003e and implementing \u003ca href=\"#parallel-data-fetching\"\u003eParallel Data Fetching\u003c/a\u003e. Our discussion will then cover \u003ca href=\"#code-splitting\"\u003eCode Splitting\u003c/a\u003e to defer\n    loading non-critical application parts and \u003ca href=\"#prefetching\"\u003ePrefetching\u003c/a\u003e data based on user\n    interactions to elevate the user experience.\u003c/p\u003e\n\n\u003cp\u003eI believe discussing these concepts through a straightforward example is\n    the best approach. I aim to start simply and then introduce more complexity\n    in a manageable way. I also plan to keep code snippets, particularly for\n    styling (I\u0026#39;m utilizing TailwindCSS for the UI, which can result in lengthy\n    snippets in a React component), to a minimum. For those interested in the\n    complete details, I\u0026#39;ve made them available \u003ca href=\"https://github.com/abruzzi/react-network-advanced-client-side\"\u003ein this\n    repository\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eAdvancements are also happening on the server side, with techniques like\n    Streaming Server-Side Rendering and Server Components gaining traction in\n    various frameworks. Additionally, a number of experimental methods are\n    emerging. However, these topics, while potentially just as crucial, might be\n    explored in a future article. For now, this discussion will concentrate\n    solely on front-end data fetching patterns.\u003c/p\u003e\n\n\u003cp\u003eIt\u0026#39;s important to note that the techniques we\u0026#39;re covering are not\n    exclusive to React or any specific frontend framework or library. I\u0026#39;ve\n    chosen React for illustration purposes due to my extensive experience with\n    it in recent years. However, principles like \u003ca href=\"#code-splitting\"\u003eCode Splitting\u003c/a\u003e,\n    \u003ca href=\"#prefetching\"\u003ePrefetching\u003c/a\u003e are\n    applicable across frameworks like Angular or Vue.js. The examples I\u0026#39;ll share\n    are common scenarios you might encounter in frontend development, regardless\n    of the framework you use.\u003c/p\u003e\n\n\u003cp\u003eThat said, let’s dive into the example we’re going to use throughout the\n    article, a \u003ccode\u003eProfile\u003c/code\u003e screen of a Single-Page Application. It\u0026#39;s a typical\n    application you might have used before, or at least the scenario is typical.\n    We need to fetch data from server side and then at frontend to build the UI\n    dynamically with JavaScript.\u003c/p\u003e\n\n\u003csection id=\"IntroducingTheApplication\"\u003e\n\u003ch2\u003eIntroducing the application\u003c/h2\u003e\n\n\u003cp\u003eTo begin with, on \u003ccode\u003eProfile\u003c/code\u003e we’ll show the user’s brief (including\n      name, avatar, and a short description), and then we also want to show\n      their connections (similar to followers on Twitter or LinkedIn\n      connections). We\u0026#39;ll need to fetch user and their connections data from\n      remote service, and then assembling these data with UI on the screen.\u003c/p\u003e\n\n\u003cdiv id=\"user-brief-and-friends.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/user-brief-and-friends.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 1: Profile screen\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThe data are from two separate API calls, the user brief API\n      \u003ccode\u003e/users/\u0026lt;id\u0026gt;\u003c/code\u003e returns user brief for a given user id, which is a simple\n      object described as follows:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;id\u0026#34;: \u0026#34;u1\u0026#34;,\n  \u0026#34;name\u0026#34;: \u0026#34;Juntao Qiu\u0026#34;,\n  \u0026#34;bio\u0026#34;: \u0026#34;Developer, Educator, Author\u0026#34;,\n  \u0026#34;interests\u0026#34;: [\n    \u0026#34;Technology\u0026#34;,\n    \u0026#34;Outdoors\u0026#34;,\n    \u0026#34;Travel\u0026#34;\n  ]\n}\n\u003c/pre\u003e\n\n\u003cp\u003eAnd the friend API \u003ccode\u003e/users/\u0026lt;id\u0026gt;/friends\u003c/code\u003e endpoint returns a list of\n      friends for a given user, each list item in the response is the same as\n      the above user data. The reason we have two endpoints instead of returning\n      a \u003ccode\u003efriends\u003c/code\u003e section of the user API is that there are cases where one\n      could have too many friends (say 1,000), but most people don\u0026#39;t have many.\n      This in-balance data structure can be pretty tricky, especially when we\n      need to paginate. The point here is that there are cases we need to deal\n      with multiple network requests.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ABriefIntroductionToRelevantReactConcepts\"\u003e\n\u003ch2\u003eA brief introduction to relevant React concepts\u003c/h2\u003e\n\n\u003cp\u003eAs this article leverages React to illustrate various patterns, I do\n      not assume you know much about React. Rather than expecting you to spend a lot\n      of time trying to find the right parts in the React documentation, I will\n      briefly introduce those concepts we\u0026#39;re going to utilize throughout this\n      article. If you already understand what React components are, and the\n      use of the \n      \u003ccode\u003euseState\u003c/code\u003e and \u003ccode\u003euseEffect\u003c/code\u003e hooks, you may \n      \u003ca href=\"#implement-profile\"\u003euse this link\u003c/a\u003e to skip ahead to the next\n      section. \u003c/p\u003e\n\n\u003cp\u003eFor those seeking a more thorough tutorial, the \u003ca href=\"https://react.dev/\"\u003enew React documentation\u003c/a\u003e is an excellent\n      resource.\u003c/p\u003e\n\n\u003csection id=\"WhatIsAReactComponent\"\u003e\n\u003ch3\u003eWhat is a React Component?\u003c/h3\u003e\n\n\u003cp\u003eIn React, components are the fundamental building blocks. To put it\n        simply, a React component is a function that returns a piece of UI,\n        which can be as straightforward as a fragment of HTML. Consider the\n        creation of a component that renders a navigation bar:\u003c/p\u003e\n\n\u003cpre\u003eimport React from \u0026#39;react\u0026#39;;\n\nfunction Navigation() {\n  return (\n    \u0026lt;nav\u0026gt;\n      \u0026lt;ol\u0026gt;\n        \u0026lt;li\u0026gt;Home\u0026lt;/li\u0026gt;\n        \u0026lt;li\u0026gt;Blogs\u0026lt;/li\u0026gt;\n        \u0026lt;li\u0026gt;Books\u0026lt;/li\u0026gt;\n      \u0026lt;/ol\u0026gt;\n    \u0026lt;/nav\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eAt first glance, the mixture of JavaScript with HTML tags might seem\n        strange (it\u0026#39;s called JSX, a syntax extension to JavaScript. For those\n        using TypeScript, a similar syntax called TSX is used). To make this\n        code functional, a compiler is required to translate the JSX into valid\n        JavaScript code. After being compiled by \u003ca href=\"https://babeljs.io/\"\u003eBabel\u003c/a\u003e,\n        the code would roughly translate to the following:\u003c/p\u003e\n\n\u003cpre\u003efunction Navigation() {\n  return React.createElement(\n    \u0026#34;nav\u0026#34;,\n    null,\n    React.createElement(\n      \u0026#34;ol\u0026#34;,\n      null,\n      React.createElement(\u0026#34;li\u0026#34;, null, \u0026#34;Home\u0026#34;),\n      React.createElement(\u0026#34;li\u0026#34;, null, \u0026#34;Blogs\u0026#34;),\n      React.createElement(\u0026#34;li\u0026#34;, null, \u0026#34;Books\u0026#34;)\n    )\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eNote here the translated code has a function called\n        \u003ccode\u003eReact.createElement\u003c/code\u003e, which is a foundational function in\n        React for creating elements. JSX written in React components is compiled\n        down to \u003ccode\u003eReact.createElement\u003c/code\u003e calls behind the scenes.\u003c/p\u003e\n\n\u003cp\u003eThe basic syntax of \u003ccode\u003eReact.createElement\u003c/code\u003e is:\u003c/p\u003e\n\n\u003cpre\u003eReact.createElement(type, [props], [...children])\n\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etype\u003c/code\u003e: A string (e.g., \u0026#39;div\u0026#39;, \u0026#39;span\u0026#39;) indicating the type of\n          DOM node to create, or a React component (class or functional) for\n          more sophisticated structures.\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003eprops\u003c/code\u003e: An object containing properties passed to the\n          element or component, including event handlers, styles, and attributes\n          like \u003ccode\u003eclassName\u003c/code\u003e and \u003ccode\u003eid\u003c/code\u003e.\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003echildren\u003c/code\u003e: These optional arguments can be additional\n          \u003ccode\u003eReact.createElement\u003c/code\u003e calls, strings, numbers, or any mix\n          thereof, representing the element\u0026#39;s children.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFor instance, a simple element can be created with\n        \u003ccode\u003eReact.createElement\u003c/code\u003e as follows:\u003c/p\u003e\n\n\u003cpre\u003eReact.createElement(\u0026#39;div\u0026#39;, { className: \u0026#39;greeting\u0026#39; }, \u0026#39;Hello, world!\u0026#39;);\n\u003c/pre\u003e\n\n\u003cp\u003eThis is analogous to the JSX version:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;div className=\u0026#34;greeting\u0026#34;\u0026gt;Hello, world!\u0026lt;/div\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eBeneath the surface, React invokes the native DOM API (e.g.,\n        \u003ccode\u003edocument.createElement(“ol”)\u003c/code\u003e) to generate DOM elements as necessary.\n        You can then assemble your custom components into a tree, similar to\n        HTML code:\u003c/p\u003e\n\n\u003cpre\u003eimport React from \u0026#39;react\u0026#39;;\nimport Navigation from \u0026#39;./Navigation.tsx\u0026#39;;\nimport Content from \u0026#39;./Content.tsx\u0026#39;;\nimport Sidebar from \u0026#39;./Sidebar.tsx\u0026#39;;\nimport ProductList from \u0026#39;./ProductList.tsx\u0026#39;;\n\nfunction App() {\n  return \u0026lt;Page /\u0026gt;;\n}\n\nfunction Page() {\n  return \u0026lt;Container\u0026gt;\n    \u0026lt;Navigation /\u0026gt;\n    \u0026lt;Content\u0026gt;\n      \u0026lt;Sidebar /\u0026gt;\n      \u0026lt;ProductList /\u0026gt;\n    \u0026lt;/Content\u0026gt;\n    \u0026lt;Footer /\u0026gt;\n  \u0026lt;/Container\u0026gt;;\n}\n\u003c/pre\u003e\n\n\u003cp\u003eUltimately, your application requires a root node to mount to, at\n        which point React assumes control and manages subsequent renders and\n        re-renders:\u003c/p\u003e\n\n\u003cpre\u003eimport ReactDOM from \u0026#34;react-dom/client\u0026#34;;\nimport App from \u0026#34;./App.tsx\u0026#34;;\n\nconst root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;));\nroot.render(\u0026lt;App /\u0026gt;);\n\u003c/pre\u003e\n\u003c/section\u003e\n\n\u003csection id=\"GeneratingDynamicContentWithJsx\"\u003e\n\u003ch3\u003eGenerating Dynamic Content with JSX\u003c/h3\u003e\n\n\u003cp\u003eThe initial example demonstrates a straightforward use case, but\n        let\u0026#39;s explore how we can create content dynamically. For instance, how\n        can we generate a list of data dynamically? In React, as illustrated\n        earlier, a component is fundamentally a function, enabling us to pass\n        parameters to it.\u003c/p\u003e\n\n\u003cpre\u003eimport React from \u0026#39;react\u0026#39;;\n\nfunction Navigation({ nav }) {\n  return (\n    \u0026lt;nav\u0026gt;\n      \u0026lt;ol\u0026gt;\n        {nav.map(item =\u0026gt; \u0026lt;li key={item}\u0026gt;{item}\u0026lt;/li\u0026gt;)}\n      \u0026lt;/ol\u0026gt;\n    \u0026lt;/nav\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIn this modified \u003ccode\u003eNavigation\u003c/code\u003e component, we anticipate the\n        parameter to be an array of strings. We utilize the \u003ccode\u003emap\u003c/code\u003e\n        function to iterate over each item, transforming them into\n        \u003ccode\u003e\u0026lt;li\u0026gt;\u003c/code\u003e elements. The curly braces \u003ccode\u003e{}\u003c/code\u003e signify\n        that the enclosed JavaScript expression should be evaluated and\n        rendered. For those curious about the compiled version of this dynamic\n        content handling:\u003c/p\u003e\n\n\u003cpre\u003efunction Navigation(props) {\n  var nav = props.nav;\n\n  return React.createElement(\n    \u0026#34;nav\u0026#34;,\n    null,\n    React.createElement(\n      \u0026#34;ol\u0026#34;,\n      null,\n      nav.map(function(item) {\n        return React.createElement(\u0026#34;li\u0026#34;, { key: item }, item);\n      })\n    )\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eInstead of invoking \u003ccode\u003eNavigation\u003c/code\u003e as a regular function,\n        employing JSX syntax renders the component invocation more akin to\n        writing markup, enhancing readability:\u003c/p\u003e\n\n\u003cpre\u003e// Instead of this\nNavigation([\u0026#34;Home\u0026#34;, \u0026#34;Blogs\u0026#34;, \u0026#34;Books\u0026#34;])\n\n// We do this\n\u0026lt;Navigation nav={[\u0026#34;Home\u0026#34;, \u0026#34;Blogs\u0026#34;, \u0026#34;Books\u0026#34;]} /\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eComponents in React can receive diverse data, known as props, to\n        modify their behavior, much like passing arguments into a function (the\n        distinction lies in using JSX syntax, making the code more familiar and\n        readable to those with HTML knowledge, which aligns well with the skill\n        set of most frontend developers).\u003c/p\u003e\n\n\u003cpre\u003eimport React from \u0026#39;react\u0026#39;;\nimport Checkbox from \u0026#39;./Checkbox\u0026#39;;\nimport BookList from \u0026#39;./BookList\u0026#39;;\n\nfunction App() {\n  let showNewOnly = false; // This flag\u0026#39;s value is typically set based on specific logic.\n\n  const filteredBooks = showNewOnly\n    ? booksData.filter(book =\u0026gt; book.isNewPublished)\n    : booksData;\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;Checkbox checked={showNewOnly}\u0026gt;\n        Show New Published Books Only\n      \u0026lt;/Checkbox\u0026gt;\n      \u0026lt;BookList books={filteredBooks} /\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIn this illustrative code snippet (non-functional but intended to\n        demonstrate the concept), we manipulate the \u003ccode\u003eBookList\u003c/code\u003e\n        component\u0026#39;s displayed content by passing it an array of books. Depending\n        on the \u003ccode\u003eshowNewOnly\u003c/code\u003e flag, this array is either all available\n        books or only those that are newly published, showcasing how props can\n        be used to dynamically adjust component output.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ManagingInternalStateBetweenRendersUsestate\"\u003e\n\u003ch3\u003eManaging Internal State Between Renders: useState\u003c/h3\u003e\n\n\u003cp\u003eBuilding user interfaces (UI) often transcends the generation of\n        static HTML. Components frequently need to “remember” certain states and\n        respond to user interactions dynamically. For instance, when a user\n        clicks an “Add” button in a Product component, it\u0026#39;s necessary to update\n        the ShoppingCart component to reflect both the total price and the\n        updated item list.\u003c/p\u003e\n\n\u003cp\u003eIn the previous code snippet, attempting to set the\n        \u003ccode\u003eshowNewOnly\u003c/code\u003e variable to \u003ccode\u003etrue\u003c/code\u003e within an event\n        handler does not achieve the desired effect:\u003c/p\u003e\n\n\u003cpre\u003efunction App () {\n  let showNewOnly = false;\n\n  const handleCheckboxChange = () =\u0026gt; {\n    showNewOnly = true; // this doesn\u0026#39;t work\n  };\n\n  const filteredBooks = showNewOnly\n    ? booksData.filter(book =\u0026gt; book.isNewPublished)\n    : booksData;\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;Checkbox checked={showNewOnly} onChange={handleCheckboxChange}\u0026gt;\n        Show New Published Books Only\n      \u0026lt;/Checkbox\u0026gt;\n\n      \u0026lt;BookList books={filteredBooks}/\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis approach falls short because local variables inside a function\n        component do not persist between renders. When React re-renders this\n        component, it does so from scratch, disregarding any changes made to\n        local variables since these do not trigger re-renders. React remains\n        unaware of the need to update the component to reflect new data.\u003c/p\u003e\n\n\u003cp\u003eThis limitation underscores the necessity for React\u0026#39;s\n        \u003ccode\u003estate\u003c/code\u003e. Specifically, functional components leverage the\n        \u003ccode\u003euseState\u003c/code\u003e hook to remember states across renders. Revisiting\n        the \u003ccode\u003eApp\u003c/code\u003e example, we can effectively remember the\n        \u003ccode\u003eshowNewOnly\u003c/code\u003e state as follows:\u003c/p\u003e\n\n\u003cpre\u003eimport React, { useState } from \u0026#39;react\u0026#39;;\nimport Checkbox from \u0026#39;./Checkbox\u0026#39;;\nimport BookList from \u0026#39;./BookList\u0026#39;;\n\nfunction App () {\n  const [showNewOnly, setShowNewOnly] = useState(false);\n\n  const handleCheckboxChange = () =\u0026gt; {\n    setShowNewOnly(!showNewOnly);\n  };\n\n  const filteredBooks = showNewOnly\n    ? booksData.filter(book =\u0026gt; book.isNewPublished)\n    : booksData;\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;Checkbox checked={showNewOnly} onChange={handleCheckboxChange}\u0026gt;\n        Show New Published Books Only\n      \u0026lt;/Checkbox\u0026gt;\n\n      \u0026lt;BookList books={filteredBooks}/\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003euseState\u003c/code\u003e hook is a cornerstone of React\u0026#39;s Hooks system,\n        introduced to enable functional components to manage internal state. It\n        introduces state to functional components, encapsulated by the following\n        syntax:\u003c/p\u003e\n\n\u003cpre\u003econst [state, setState] = useState(initialState);\n\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003einitialState\u003c/code\u003e: This argument is the initial\n          value of the state variable. It can be a simple value like a number,\n          string, boolean, or a more complex object or array. The\n          \u003ccode\u003einitialState\u003c/code\u003e is only used during the first render to\n          initialize the state.\u003c/li\u003e\n\n\u003cli\u003e\u003ci\u003eReturn Value\u003c/i\u003e: \u003ccode\u003euseState\u003c/code\u003e returns an array with\n          two elements. The first element is the current state value, and the\n          second element is a function that allows updating this value. By using\n          array destructuring, we assign names to these returned items,\n          typically \u003ccode\u003estate\u003c/code\u003e and \u003ccode\u003esetState\u003c/code\u003e, though you can\n          choose any valid variable names.\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003estate\u003c/code\u003e: Represents the current value of the\n          state. It\u0026#39;s the value that will be used in the component\u0026#39;s UI and\n          logic.\u003c/li\u003e\n\n\u003cli\u003e\u003ccode\u003esetState\u003c/code\u003e: A function to update the state. This function\n          accepts a new state value or a function that produces a new state based\n          on the previous state. When called, it schedules an update to the\n          component\u0026#39;s state and triggers a re-render to reflect the changes.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReact treats state as a snapshot; updating it doesn\u0026#39;t alter the\n        existing state variable but instead triggers a re-render. During this\n        re-render, React acknowledges the updated state, ensuring the\n        \u003ccode\u003eBookList\u003c/code\u003e component receives the correct data, thereby\n        reflecting the updated book list to the user. This snapshot-like\n        behavior of state facilitates the dynamic and responsive nature of React\n        components, enabling them to react intuitively to user interactions and\n        other changes.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ManagingSideEffectsUseeffect\"\u003e\n\u003ch3\u003eManaging Side Effects: useEffect\u003c/h3\u003e\n\n\u003cp\u003eBefore diving deeper into our discussion, it\u0026#39;s crucial to address the\n        concept of side effects. Side effects are operations that interact with\n        the outside world from the React ecosystem. Common examples include\n        fetching data from a remote server or dynamically manipulating the DOM,\n        such as changing the page title.\u003c/p\u003e\n\n\u003cp\u003eReact is primarily concerned with rendering data to the DOM and does\n        not inherently handle data fetching or direct DOM manipulation. To\n        facilitate these side effects, React provides the \u003ccode\u003euseEffect\u003c/code\u003e\n        hook. This hook allows the execution of side effects after React has\n        completed its rendering process. If these side effects result in data\n        changes, React schedules a re-render to reflect these updates.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003euseEffect\u003c/code\u003e Hook accepts two arguments:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA function containing the side effect logic.\u003c/li\u003e\n\n\u003cli\u003eAn optional dependency array specifying when the side effect should be\n          re-invoked.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOmitting the second argument causes the side effect to run after\n        every render. Providing an empty array \u003ccode\u003e[]\u003c/code\u003e signifies that your effect\n        doesn’t depend on any values from props or state, thus not needing to\n        re-run. Including specific values in the array means the side effect\n        only re-executes if those values change.\u003c/p\u003e\n\n\u003cp\u003eWhen dealing with asynchronous data fetching, the workflow within\n        \u003ccode\u003euseEffect\u003c/code\u003e entails initiating a network request. Once the data is\n        retrieved, it is captured via the \u003ccode\u003euseState\u003c/code\u003e hook, updating the\n        component\u0026#39;s internal state and preserving the fetched data across\n        renders. React, recognizing the state update, undertakes another render\n        cycle to incorporate the new data.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a practical example about data fetching and state\n        management:\u003c/p\u003e\n\n\u003cpre\u003eimport { useEffect, useState } from \u0026#34;react\u0026#34;;\n\ntype User = {\n  id: string;\n  name: string;\n};\n\nconst UserSection = ({ id }) =\u0026gt; {\n  const [user, setUser] = useState\u0026lt;User | undefined\u0026gt;();\n\n  useEffect(() =\u0026gt; {\n    const fetchUser = async () =\u0026gt; {\n      const response = await fetch(`/api/users/${id}`);\n      const jsonData = await response.json();\n      setUser(jsonData);\n    };\n\n    fetchUser();\n  }, [id]);\n\n  return \u0026lt;div\u0026gt;\n    \u0026lt;h2\u0026gt;{user?.name}\u0026lt;/h2\u0026gt;\n  \u0026lt;/div\u0026gt;;\n};\n\u003c/pre\u003e\n\n\u003cp\u003eIn the code snippet above, within \u003ccode\u003euseEffect\u003c/code\u003e, an\n        asynchronous function \u003ccode\u003efetchUser\u003c/code\u003e is defined and then\n        immediately invoked. This pattern is necessary because\n        \u003ccode\u003euseEffect\u003c/code\u003e does not directly support async functions as its\n        callback. The async function is defined to use \u003ccode\u003eawait\u003c/code\u003e for\n        the fetch operation, ensuring that the code execution waits for the\n        response and then processes the JSON data. Once the data is available,\n        it updates the component\u0026#39;s state via \u003ccode\u003esetUser\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe dependency array \u003ccode\u003e[id]\u003c/code\u003e at the end of the\n        \u003ccode\u003euseEffect\u003c/code\u003e call ensures that the effect runs again only if\n        \u003ccode\u003eid\u003c/code\u003e changes, which prevents unnecessary network requests on\n        every render and fetches new user data when the \u003ccode\u003eid\u003c/code\u003e prop\n        updates.\u003c/p\u003e\n\n\u003cp\u003eThis approach to handling asynchronous data fetching within\n        \u003ccode\u003euseEffect\u003c/code\u003e is a standard practice in React development, offering a\n        structured and efficient way to integrate async operations into the\n        React component lifecycle.\u003c/p\u003e\n\n\u003cp\u003eIn addition, in practical applications, managing different states\n        such as loading, error, and data presentation is essential too (we\u0026#39;ll\n        see it how it works in the following section). For example, consider\n        implementing status indicators within a User component to reflect\n        loading, error, or data states, enhancing the user experience by\n        providing feedback during data fetching operations.\u003c/p\u003e\n\n\u003cdiv id=\"status-of-profile-component.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/status-of-profile-component.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 2: Different statuses of a\n        component\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis overview offers just a quick glimpse into the concepts utilized\n        throughout this article. For a deeper dive into additional concepts and\n        patterns, I recommend exploring the \u003ca href=\"https://react.dev/\"\u003enew React\n        documentation\u003c/a\u003e or consulting other online resources.\n        With this foundation, you should now be equipped to join me as we delve\n        into the data fetching patterns discussed herein.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"implement-profile\"\u003e\n\u003ch2\u003eImplement the Profile component\u003c/h2\u003e\n\n\u003cp\u003eLet’s create the \u003ccode\u003eProfile\u003c/code\u003e component to make a request and\n      render the result. In typical React applications, this data fetching is\n      handled inside a \u003ccode\u003euseEffect\u003c/code\u003e block. Here\u0026#39;s an example of how\n      this might be implemented:\u003c/p\u003e\n\n\u003cpre\u003eimport { useEffect, useState } from \u0026#34;react\u0026#34;;\n\nconst Profile = ({ id }: { id: string }) =\u0026gt; {\n  const [user, setUser] = useState\u0026lt;User | undefined\u0026gt;();\n\n  useEffect(() =\u0026gt; {\n    const fetchUser = async () =\u0026gt; {\n      const response = await fetch(`/api/users/${id}`);\n      const jsonData = await response.json();\n      setUser(jsonData);\n    };\n\n    fetchUser();\n  }, [id]);\n\n  return (\n    \u0026lt;UserBrief user={user} /\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis initial approach assumes network requests complete\n      instantaneously, which is often not the case. Real-world scenarios require\n      handling varying network conditions, including delays and failures. To\n      manage these effectively, we incorporate loading and error states into our\n      component. This addition allows us to provide feedback to the user during\n      data fetching, such as displaying a loading indicator or a skeleton screen\n      if the data is delayed, and handling errors when they occur.\u003c/p\u003e\n\n\u003cp\u003eHere’s how the enhanced component looks with added loading and error\n      management:\u003c/p\u003e\n\n\u003cpre\u003eimport { useEffect, useState } from \u0026#34;react\u0026#34;;\nimport { get } from \u0026#34;../utils.ts\u0026#34;;\n\nimport type { User } from \u0026#34;../types.ts\u0026#34;;\n\nconst Profile = ({ id }: { id: string }) =\u0026gt; {\n  const [loading, setLoading] = useState\u0026lt;boolean\u0026gt;(false);\n  const [error, setError] = useState\u0026lt;Error | undefined\u0026gt;();\n  const [user, setUser] = useState\u0026lt;User | undefined\u0026gt;();\n\n  useEffect(() =\u0026gt; {\n    const fetchUser = async () =\u0026gt; {\n      try {\n        setLoading(true);\n        const data = await get\u0026lt;User\u0026gt;(`/users/${id}`);\n        setUser(data);\n      } catch (e) {\n        setError(e as Error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n  }, [id]);\n\n  if (loading || !user) {\n    return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;;\n  }\n\n  return (\n    \u0026lt;\u0026gt;\n      {user \u0026amp;\u0026amp; \u0026lt;UserBrief user={user} /\u0026gt;}\n    \u0026lt;/\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eNow in \u003ccode\u003eProfile\u003c/code\u003e component, we initiate states for loading,\n      errors, and user data with \u003ccode\u003euseState\u003c/code\u003e. Using\n      \u003ccode\u003euseEffect\u003c/code\u003e, we fetch user data based on \u003ccode\u003eid\u003c/code\u003e,\n      toggling loading status and handling errors accordingly. Upon successful\n      data retrieval, we update the user state, else display a loading\n      indicator.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eget\u003c/code\u003e function, as demonstrated below, simplifies\n      fetching data from a specific endpoint by appending the endpoint to a\n      predefined base URL. It checks the response\u0026#39;s success status and either\n      returns the parsed JSON data or throws an error for unsuccessful requests,\n      streamlining error handling and data retrieval in our application. Note\n      it\u0026#39;s pure TypeScript code and can be used in other non-React parts of the\n      application.\u003c/p\u003e\n\n\u003cpre\u003econst baseurl = \u0026#34;https://icodeit.com.au/api/v2\u0026#34;;\n\nasync function get\u0026lt;T\u0026gt;(url: string): Promise\u0026lt;T\u0026gt; {\n  const response = await fetch(`${baseurl}${url}`);\n\n  if (!response.ok) {\n    throw new Error(\u0026#34;Network response was not ok\u0026#34;);\n  }\n\n  return await response.json() as Promise\u0026lt;T\u0026gt;;\n}\n\u003c/pre\u003e\n\n\u003cp\u003eReact will try to render the component initially, but as the data\n      \u003ccode\u003euser\u003c/code\u003e isn’t available, it returns “loading...” in a\n      \u003ccode\u003ediv\u003c/code\u003e. Then the \u003ccode\u003euseEffect\u003c/code\u003e is invoked, and the\n      request is kicked off. Once at some point, the response returns, React\n      re-renders the \u003ccode\u003eProfile\u003c/code\u003e component with \u003ccode\u003euser\u003c/code\u003e\n      fulfilled, so you can now see the user section with name, avatar, and\n      title.\u003c/p\u003e\n\n\u003cp\u003eIf we visualize the timeline of the above code, you will see\n      the following sequence. The browser firstly downloads the HTML page, and\n      then when it encounters script tags and style tags, it might stop and\n      download these files, and then parse them to form the final page. Note\n      that this is a relatively complicated process, and I’m oversimplifying\n      here, but the basic idea of the sequence is correct.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-1-one-request-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-1-one-request-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 3: Fetching user\n      data\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eSo React can start to render only when the JS are parsed and executed,\n      and then it finds the \u003ccode\u003euseEffect\u003c/code\u003e for data fetching; it has to wait until\n      the data is available for a re-render.\u003c/p\u003e\n\n\u003cp\u003eNow in the browser, we can see a “loading...” when the application\n      starts, and then after a few seconds (we can simulate such case by add\n      some delay in the API endpoints) the user brief section shows up when data\n      is loaded.\u003c/p\u003e\n\n\u003cdiv id=\"user-brief.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/user-brief.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 4: User brief component\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThis code structure (in useEffect to trigger request, and update states\n      like \u003ccode\u003eloading\u003c/code\u003e and \u003ccode\u003eerror\u003c/code\u003e correspondingly) is\n      widely used across React codebases. In applications of regular size, it\u0026#39;s\n      common to find numerous instances of such same data-fetching logic\n      dispersed throughout various components.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"async-state-handler\"\u003e\n\u003ch2\u003eAsynchronous State Handler\u003c/h2\u003e\n\n\u003cp\u003eWrap asynchronous queries with meta-queries for the state of the\n      query.\u003c/p\u003e\n\n\u003cp\u003eRemote calls can be slow, and it\u0026#39;s essential not to let the UI freeze\n      while these calls are being made. Therefore, we handle them asynchronously\n      and use indicators to show that a process is underway, which makes the\n      user experience better - knowing that something is happening.\u003c/p\u003e\n\n\u003cp\u003eAdditionally, remote calls might fail due to connection issues,\n      requiring clear communication of these failures to the user. Therefore,\n      it\u0026#39;s best to encapsulate each remote call within a handler module that\n      manages results, progress updates, and errors. This module allows the UI\n      to access metadata about the status of the call, enabling it to display\n      alternative information or options if the expected results fail to\n      materialize.\u003c/p\u003e\n\n\u003cp\u003eA simple implementation could be a function \u003ccode\u003egetAsyncStates\u003c/code\u003e that\n      returns these metadata, it takes a URL as its parameter and returns an\n      object containing information essential for managing asynchronous\n      operations. This setup allows us to appropriately respond to different\n      states of a network request, whether it\u0026#39;s in progress, successfully\n      resolved, or has encountered an error.\u003c/p\u003e\n\n\u003cpre\u003econst { loading, error, data } = getAsyncStates(url);\n\nif (loading) {\n  // Display a loading spinner\n}\n\nif (error) {\n  // Display an error message\n}\n\n// Proceed to render using the data\n\u003c/pre\u003e\n\n\u003cp\u003eThe assumption here is that \u003ccode\u003egetAsyncStates\u003c/code\u003e initiates the\n      network request automatically upon being called. However, this might not\n      always align with the caller\u0026#39;s needs. To offer more control, we can also\n      expose a \u003ccode\u003efetch\u003c/code\u003e function within the returned object, allowing\n      the initiation of the request at a more appropriate time, according to the\n      caller\u0026#39;s discretion. Additionally, a \u003ccode\u003erefetch\u003c/code\u003e function could\n      be provided to enable the caller to re-initiate the request as needed,\n      such as after an error or when updated data is required. The\n      \u003ccode\u003efetch\u003c/code\u003e and \u003ccode\u003erefetch\u003c/code\u003e functions can be identical in\n      implementation, or \u003ccode\u003erefetch\u003c/code\u003e might include logic to check for\n      cached results and only re-fetch data if necessary.\u003c/p\u003e\n\n\u003cpre\u003econst { loading, error, data, fetch, refetch } = getAsyncStates(url);\n\nconst onInit = () =\u0026gt; {\n  fetch();\n};\n\nconst onRefreshClicked = () =\u0026gt; {\n  refetch();\n};\n\nif (loading) {\n  // Display a loading spinner\n}\n\nif (error) {\n  // Display an error message\n}\n\n// Proceed to render using the data\n\u003c/pre\u003e\n\n\u003cp\u003eThis pattern provides a versatile approach to handling asynchronous\n      requests, giving developers the flexibility to trigger data fetching\n      explicitly and manage the UI\u0026#39;s response to loading, error, and success\n      states effectively. By decoupling the fetching logic from its initiation,\n      applications can adapt more dynamically to user interactions and other\n      runtime conditions, enhancing the user experience and application\n      reliability.\u003c/p\u003e\n\n\u003csection id=\"ImplementingAsynchronousStateHandlerInReactWithHooks\"\u003e\n\u003ch3\u003eImplementing Asynchronous State Handler in React with hooks\u003c/h3\u003e\n\n\u003cp\u003eThe pattern can be implemented in different frontend libraries. For\n        instance, we could distill this approach into a custom Hook in a React\n        application for the Profile component:\u003c/p\u003e\n\n\u003cpre\u003eimport { useEffect, useState } from \u0026#34;react\u0026#34;;\nimport { get } from \u0026#34;../utils.ts\u0026#34;;\n\nconst useUser = (id: string) =\u0026gt; {\n  const [loading, setLoading] = useState\u0026lt;boolean\u0026gt;(false);\n  const [error, setError] = useState\u0026lt;Error | undefined\u0026gt;();\n  const [user, setUser] = useState\u0026lt;User | undefined\u0026gt;();\n\n  useEffect(() =\u0026gt; {\n    const fetchUser = async () =\u0026gt; {\n      try {\n        setLoading(true);\n        const data = await get\u0026lt;User\u0026gt;(`/users/${id}`);\n        setUser(data);\n      } catch (e) {\n        setError(e as Error);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUser();\n  }, [id]);\n\n  return {\n    loading,\n    error,\n    user,\n  };\n};\n\u003c/pre\u003e\n\n\u003cp\u003ePlease note that in the custom Hook, we don\u0026#39;t have any JSX code -\n        meaning it\u0026#39;s totally UI free but sharable stateful logic. And the\n        \u003ccode\u003euseUser\u003c/code\u003e launch data automatically when called. Within the Profile\n        component, leveraging the \u003ccode\u003euseUser\u003c/code\u003e Hook simplifies its logic:\u003c/p\u003e\n\n\u003cpre\u003eimport { useUser } from \u0026#39;./useUser.ts\u0026#39;;\nimport UserBrief from \u0026#39;./UserBrief.tsx\u0026#39;;\n\nconst Profile = ({ id }: { id: string }) =\u0026gt; {\n  const { loading, error, user } = useUser(id);\n\n  if (loading || !user) {\n    return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;;\n  }\n\n  if (error) {\n    return \u0026lt;div\u0026gt;Something went wrong...\u0026lt;/div\u0026gt;;\n  }\n\n  return (\n    \u0026lt;\u0026gt;\n      {user \u0026amp;\u0026amp; \u0026lt;UserBrief user={user} /\u0026gt;}\n    \u0026lt;/\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\u003c/section\u003e\n\n\u003csection id=\"GeneralizingParameterUsage\"\u003e\n\u003ch3\u003eGeneralizing Parameter Usage\u003c/h3\u003e\n\n\u003cp\u003eIn most applications, fetching different types of data—from user\n        details on a homepage to product lists in search results and\n        recommendations beneath them—is a common requirement. Writing separate\n        fetch functions for each type of data can be tedious and difficult to\n        maintain. A better approach is to abstract this functionality into a\n        generic, reusable hook that can handle various data types\n        efficiently.\u003c/p\u003e\n\n\u003cp\u003eConsider treating remote API endpoints as services, and use a generic\n        \u003ccode\u003euseService\u003c/code\u003e hook that accepts a URL as a parameter while managing all\n        the metadata associated with an asynchronous request:\u003c/p\u003e\n\n\u003cpre\u003eimport { get } from \u0026#34;../utils.ts\u0026#34;;\n\nfunction useService\u0026lt;T\u0026gt;(url: string) {\n  const [loading, setLoading] = useState\u0026lt;boolean\u0026gt;(false);\n  const [error, setError] = useState\u0026lt;Error | undefined\u0026gt;();\n  const [data, setData] = useState\u0026lt;T | undefined\u0026gt;();\n\n  const fetch = async () =\u0026gt; {\n    try {\n      setLoading(true);\n      const data = await get\u0026lt;T\u0026gt;(url);\n      setData(data);\n    } catch (e) {\n      setError(e as Error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return {\n    loading,\n    error,\n    data,\n    fetch,\n  };\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis hook abstracts the data fetching process, making it easier to\n        integrate into any component that needs to retrieve data from a remote\n        source. It also centralizes common error handling scenarios, such as\n        treating specific errors differently:\u003c/p\u003e\n\n\u003cpre\u003eimport { useService } from \u0026#39;./useService.ts\u0026#39;;\n\nconst {\n  loading,\n  error,\n  data: user,\n  fetch: fetchUser,\n} = useService(`/users/${id}`);\n\u003c/pre\u003e\n\n\u003cp\u003eBy using useService, we can simplify how components fetch and handle\n        data, making the codebase cleaner and more maintainable.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"VariationOfThePattern\"\u003e\n\u003ch3\u003eVariation of the pattern\u003c/h3\u003e\n\n\u003cp\u003eA variation of the \u003ccode\u003euseUser\u003c/code\u003e would be expose the\n        \u003ccode\u003efetchUsers\u003c/code\u003e function, and it does not trigger the data\n        fetching itself:\u003c/p\u003e\n\n\u003cpre\u003eimport { useState } from \u0026#34;react\u0026#34;;\n\nconst useUser = (id: string) =\u0026gt; {\n  // define the states\n\n  const fetchUser = async () =\u0026gt; {\n    try {\n      setLoading(true);\n      const data = await get\u0026lt;User\u0026gt;(`/users/${id}`);\n      setUser(data);\n    } catch (e) {\n      setError(e as Error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return {\n    loading,\n    error,\n    user,\n    fetchUser,\n  };\n};\n\u003c/pre\u003e\n\n\u003cp\u003eAnd then on the calling site, \u003ccode\u003eProfile\u003c/code\u003e component use\n        \u003ccode\u003euseEffect\u003c/code\u003e to fetch the data and render different\n        states.\u003c/p\u003e\n\n\u003cpre\u003econst Profile = ({ id }: { id: string }) =\u0026gt; {\n  const { loading, error, user, fetchUser } = useUser(id);\n\n  useEffect(() =\u0026gt; {\n    fetchUser();\n  }, []);\n\n  // render correspondingly\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe advantage of this division is the ability to reuse these stateful\n        logics across different components. For instance, another component\n        needing the same data (a user API call with a user ID) can simply import\n        the \u003ccode\u003euseUser\u003c/code\u003e Hook and utilize its states. Different UI\n        components might choose to interact with these states in various ways,\n        perhaps using alternative loading indicators (a smaller spinner that\n        fits to the calling component) or error messages, yet the fundamental\n        logic of fetching data remains consistent and shared.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"async-state-handler-when\"\u003e\n\u003ch3\u003eWhen to use it\u003c/h3\u003e\n\n\u003cp\u003eSeparating data fetching logic from UI components can sometimes\n        introduce unnecessary complexity, particularly in smaller applications.\n        Keeping this logic integrated within the component, similar to the\n        css-in-js approach, simplifies navigation and is easier for some\n        developers to manage. In my article, \u003ca href=\"https://martinfowler.com/articles/modularizing-react-apps.html\"\u003eModularizing\n        React Applications with Established UI Patterns\u003c/a\u003e, I explored\n        various levels of complexity in application structures. For applications\n        that are limited in scope — with just a few pages and several data\n        fetching operations — it\u0026#39;s often practical and also recommended to\n        maintain data fetching \u003ci\u003ewithin\u003c/i\u003e the UI components.\u003c/p\u003e\n\n\u003cp\u003eHowever, as your application scales and the development team grows,\n        this strategy may lead to inefficiencies. Deep component trees can slow\n        down your application (we will see examples as well as how to address\n        them in the following sections) and generate redundant boilerplate code.\n        Introducing an Asynchronous State Handler can mitigate these issues by\n        decoupling data fetching from UI rendering, enhancing both performance\n        and maintainability.\u003c/p\u003e\n\n\u003cp\u003eIt’s crucial to balance simplicity with structured approaches as your\n        project evolves. This ensures your development practices remain\n        effective and responsive to the application\u0026#39;s needs, maintaining optimal\n        performance and developer efficiency regardless of the project\n        scale.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ImplementTheFriendsList\"\u003e\n\u003ch2\u003eImplement the Friends list\u003c/h2\u003e\n\n\u003cp\u003eNow let’s have a look at the second section of the Profile - the friend\n      list. We can create a separate component \u003ccode\u003eFriends\u003c/code\u003e and fetch data in it\n      (by using a useService custom hook we defined above), and the logic is\n      pretty similar to what we see above in the \u003ccode\u003eProfile\u003c/code\u003e component.\u003c/p\u003e\n\n\u003cpre\u003econst Friends = ({ id }: { id: string }) =\u0026gt; {\n  const { loading, error, data: friends } = useService(`/users/${id}/friends`);\n\n  // loading \u0026amp; error handling...\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;h2\u0026gt;Friends\u0026lt;/h2\u0026gt;\n      \u0026lt;div\u0026gt;\n        {friends.map((user) =\u0026gt; (\n        // render user list\n        ))}\n      \u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eAnd then in the Profile component, we can use Friends as a regular\n      component, and pass in \u003ccode\u003eid\u003c/code\u003e as a prop:\u003c/p\u003e\n\n\u003cpre\u003econst Profile = ({ id }: { id: string }) =\u0026gt; {\n  //...\n\n  return (\n    \u0026lt;\u0026gt;\n      {user \u0026amp;\u0026amp; \u0026lt;UserBrief user={user} /\u0026gt;}\n      \u0026lt;Friends id={id} /\u0026gt;\n    \u0026lt;/\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe code works fine, and it looks pretty clean and readable,\n      \u003ccode\u003eUserBrief\u003c/code\u003e renders a \u003ccode\u003euser\u003c/code\u003e object passed in, while\n      \u003ccode\u003eFriends\u003c/code\u003e manage its own data fetching and rendering logic\n      altogether. If we visualize the component tree, it would be something like\n      this:\u003c/p\u003e\n\n\u003cdiv id=\"async-components-1-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/async-components-1-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 5: Component structure\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eBoth the \u003ccode\u003eProfile\u003c/code\u003e and \u003ccode\u003eFriends\u003c/code\u003e have logic for\n      data fetching, loading checks, and error handling. Since there are two\n      separate data fetching calls, and if we look at the request timeline, we\n      will notice something interesting.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-2-waterfall-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-2-waterfall-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 6: Request waterfall\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003eFriends\u003c/code\u003e component won\u0026#39;t initiate data fetching until the user\n      state is set. This is referred to as the \u003cb id=\"fetch-on-render\"\u003eFetch-On-Render\u003c/b\u003e approach,\n      where the initial rendering is paused because the data isn\u0026#39;t available,\n      requiring React to wait for the data to be retrieved from the server\n      side.\u003c/p\u003e\n\n\u003cp\u003eThis waiting period is somewhat inefficient, considering that while\n      React\u0026#39;s rendering process only takes a few milliseconds, data fetching can\n      take significantly longer, often seconds. As a result, the \u003ccode\u003eFriends\u003c/code\u003e\n      component spends most of its time idle, waiting for data. This scenario\n      leads to a common challenge known as the \u003cb id=\"request-waterfall\"\u003eRequest Waterfall\u003c/b\u003e, a frequent\n      occurrence in frontend applications that involve multiple data fetching\n      operations.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"parallel-data-fetching\"\u003e\n\u003ch2\u003eParallel Data Fetching\u003c/h2\u003e\n\n\u003cp\u003eRun remote data fetches in parallel to minimize wait time\u003c/p\u003e\n\n\u003cp\u003eImagine when we build a larger application that a component that\n      requires data can be deeply nested in the component tree, to make the\n      matter worse these components are developed by different teams, it’s hard\n      to see whom we’re blocking.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-3-waterfall-more-requests-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-3-waterfall-more-requests-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 7: Request waterfall\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\u003ca href=\"#request-waterfall\"\u003e Request Waterfalls\u003c/a\u003e can degrade user\n      experience, something we aim to avoid. Analyzing the data, we see that the\n      user API and friends API are independent and can be fetched in parallel.\n      Initiating these parallel requests becomes critical for application\n      performance.\u003c/p\u003e\n\n\u003cp\u003eOne approach is to centralize data fetching at a higher level, near the\n      root. Early in the application\u0026#39;s lifecycle, we start all data fetches\n      simultaneously. Components dependent on this data wait only for the\n      slowest request, typically resulting in faster overall load times.\u003c/p\u003e\n\n\u003cp\u003eWe could use the \u003cb\u003ePromise\u003c/b\u003e API \u003ccode\u003ePromise.all\u003c/code\u003e to send\n      both requests for the user’s basic information and their friends list.\n      \u003ccode\u003ePromise.all\u003c/code\u003e is a JavaScript method that allows for the\n      concurrent execution of multiple promises. It takes an array of promises\n      as input and returns a single Promise that resolves when all of the input\n      promises have resolved, providing their results as an array. If any of the\n      promises fail, \u003ccode\u003ePromise.all\u003c/code\u003e immediately rejects with the\n      reason of the first promise that rejects.\u003c/p\u003e\n\n\u003cp\u003eFor instance, at the application\u0026#39;s root, we can define a comprehensive\n      data model:\u003c/p\u003e\n\n\u003cpre\u003etype ProfileState = {\n  user: User;\n  friends: User[];\n};\n\nconst getProfileData = async (id: string) =\u0026gt;\n  Promise.all([\n    get\u0026lt;User\u0026gt;(`/users/${id}`),\n    get\u0026lt;User[]\u0026gt;(`/users/${id}/friends`),\n  ]);\n\nconst App = () =\u0026gt; {\n  // fetch data at the very begining of the application launch\n  const onInit = () =\u0026gt; {\n    const [user, friends] = await getProfileData(id);\n  }\n\n  // render the sub tree correspondingly\n}\n\u003c/pre\u003e\n\n\u003csection id=\"ImplementingParallelDataFetchingInReact\"\u003e\n\u003ch3\u003eImplementing Parallel Data Fetching in React\u003c/h3\u003e\n\n\u003cp\u003eUpon application launch, data fetching begins, abstracting the\n        fetching process from subcomponents. For example, in Profile component,\n        both UserBrief and Friends are presentational components that react to\n        the passed data. This way we could develop these component separately\n        (adding styles for different states, for example). These presentational\n        components normally are easy to test and modify as we have separate the\n        data fetching and rendering.\u003c/p\u003e\n\n\u003cp\u003eWe can define a custom hook \u003ccode\u003euseProfileData\u003c/code\u003e that facilitates\n        parallel fetching of data related to a user and their friends by using\n        \u003ccode\u003ePromise.all\u003c/code\u003e. This method allows simultaneous requests, optimizing the\n        loading process and structuring the data into a predefined format known\n        as \u003ccode\u003eProfileData\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere’s a breakdown of the hook implementation:\u003c/p\u003e\n\n\u003cpre\u003eimport { useCallback, useEffect, useState } from \u0026#34;react\u0026#34;;\n\ntype ProfileData = {\n  user: User;\n  friends: User[];\n};\n\nconst useProfileData = (id: string) =\u0026gt; {\n  const [loading, setLoading] = useState\u0026lt;boolean\u0026gt;(false);\n  const [error, setError] = useState\u0026lt;Error | undefined\u0026gt;(undefined);\n  const [profileState, setProfileState] = useState\u0026lt;ProfileData\u0026gt;();\n\n  const fetchProfileState = useCallback(async () =\u0026gt; {\n    try {\n      setLoading(true);\n      const [user, friends] = await Promise.all([\n        get\u0026lt;User\u0026gt;(`/users/${id}`),\n        get\u0026lt;User[]\u0026gt;(`/users/${id}/friends`),\n      ]);\n      setProfileState({ user, friends });\n    } catch (e) {\n      setError(e as Error);\n    } finally {\n      setLoading(false);\n    }\n  }, [id]);\n\n  return {\n    loading,\n    error,\n    profileState,\n    fetchProfileState,\n  };\n\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis hook provides the \u003ccode\u003eProfile\u003c/code\u003e component with the\n        necessary data states (\u003ccode\u003eloading\u003c/code\u003e, \u003ccode\u003eerror\u003c/code\u003e,\n        \u003ccode\u003eprofileState\u003c/code\u003e) along with a \u003ccode\u003efetchProfileState\u003c/code\u003e\n        function, enabling the component to initiate the fetch operation as\n        needed. Note here we use \u003ccode\u003euseCallback\u003c/code\u003e hook to wrap the async\n        function for data fetching. The useCallback hook in React is used to\n        memoize functions, ensuring that the same function instance is\n        maintained across component re-renders unless its dependencies change.\n        Similar to the useEffect, it accepts the function and a dependency\n        array, the function will only be recreated if any of these dependencies\n        change, thereby avoiding unintended behavior in React\u0026#39;s rendering\n        cycle.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eProfile\u003c/code\u003e component uses this hook and controls the data fetching\n        timing via \u003ccode\u003euseEffect\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003econst Profile = ({ id }: { id: string }) =\u0026gt; {\n  const { loading, error, profileState, fetchProfileState } = useProfileData(id);\n\n  useEffect(() =\u0026gt; {\n    fetchProfileState();\n  }, [fetchProfileState]);\n\n  if (loading) {\n    return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;;\n  }\n\n  if (error) {\n    return \u0026lt;div\u0026gt;Something went wrong...\u0026lt;/div\u0026gt;;\n  }\n\n  return (\n    \u0026lt;\u0026gt;\n      {profileState \u0026amp;\u0026amp; (\n        \u0026lt;\u0026gt;\n          \u0026lt;UserBrief user={profileState.user} /\u0026gt;\n          \u0026lt;Friends users={profileState.friends} /\u0026gt;\n        \u0026lt;/\u0026gt;\n      )}\n    \u0026lt;/\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis approach is also known as \u003cb id=\"fetch-then-render\"\u003eFetch-Then-Render\u003c/b\u003e, suggesting that the aim\n        is to initiate requests as early as possible during page load.\n        Subsequently, the fetched data is utilized to drive React\u0026#39;s rendering of\n        the application, bypassing the need to manage data fetching amidst the\n        rendering process. This strategy simplifies the rendering process,\n        making the code easier to test and modify.\u003c/p\u003e\n\n\u003cp\u003eAnd the component structure, if visualized, would be like the\n        following illustration\u003c/p\u003e\n\n\u003cdiv id=\"async-components-2-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/async-components-2-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 8: Component structure after refactoring\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eAnd the timeline is much shorter than the previous one as we send two\n        requests in parallel. The \u003ccode\u003eFriends\u003c/code\u003e component can render in a few\n        milliseconds as when it starts to render, the data is already ready and\n        passed in.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-4-parallel-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-4-parallel-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 9: Parallel requests\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eNote that the longest wait time depends on the slowest network\n        request, which is much faster than the sequential ones. And if we could\n        send as many of these independent requests at the same time at an upper\n        level of the component tree, a better user experience can be\n        expected.\u003c/p\u003e\n\n\u003cp\u003eAs applications expand, managing an increasing number of requests at\n        root level becomes challenging. This is particularly true for components\n        distant from the root, where passing down data becomes cumbersome. One\n        approach is to store all data globally, accessible via functions (like\n        Redux or the React Context API), avoiding deep prop drilling.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"parallel-data-fetching-when\"\u003e\n\u003ch3\u003eWhen to use it\u003c/h3\u003e\n\n\u003cp\u003eRunning queries in parallel is useful whenever such queries may be\n        slow and don\u0026#39;t significantly interfere with each others\u0026#39; performance.\n        This is usually the case with remote queries. Even if the remote\n        machine\u0026#39;s I/O and computation is fast, there\u0026#39;s always potential latency\n        issues in the remote calls. The main disadvantage for parallel queries\n        is setting them up with some kind of asynchronous mechanism, which may be\n        difficult in some language environments.\u003c/p\u003e\n\n\u003cp\u003eThe main reason to not use parallel data fetching is when we don\u0026#39;t\n        know what data needs to be fetched until we\u0026#39;ve already fetched some\n        data. Certain scenarios require sequential data fetching due to\n        dependencies between requests. For instance, consider a scenario on a\n        \u003ccode\u003eProfile\u003c/code\u003e page where generating a personalized recommendation feed\n        depends on first acquiring the user\u0026#39;s \u003cb\u003einterests\u003c/b\u003e from a user API.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s an example response from the user API that includes\n        interests:\u003c/p\u003e\n\n\u003cpre\u003e{\n  \u0026#34;id\u0026#34;: \u0026#34;u1\u0026#34;,\n  \u0026#34;name\u0026#34;: \u0026#34;Juntao Qiu\u0026#34;,\n  \u0026#34;bio\u0026#34;: \u0026#34;Developer, Educator, Author\u0026#34;,\n  \u0026#34;interests\u0026#34;: [\n    \u0026#34;Technology\u0026#34;,\n    \u0026#34;Outdoors\u0026#34;,\n    \u0026#34;Travel\u0026#34;\n  ]\n}\n\u003c/pre\u003e\n\n\u003cp\u003eIn such cases, the recommendation feed can only be fetched \u003cb\u003eafter\u003c/b\u003e\n        receiving the user\u0026#39;s interests from the initial API call. This\n        sequential dependency prevents us from utilizing parallel fetching, as\n        the second request relies on data obtained from the first.\u003c/p\u003e\n\n\u003cp\u003eGiven these constraints, it becomes important to discuss alternative\n        strategies in asynchronous data management. One such strategy is \n        \u003ca href=\"#fallback-markup\"\u003eFallback Markup\u003c/a\u003e. This approach allows developers to specify what\n        data is needed and how it should be fetched in a way that clearly\n        defines dependencies, making it easier to manage complex data\n        relationships in an application.\u003c/p\u003e\n\n\u003cp\u003eAnother example of when arallel Data Fetching is not applicable is\n        that in scenarios involving user interactions that require real-time\n        data validation.\u003c/p\u003e\n\n\u003cp\u003eConsider the case of a list where each item has an “Approve” context\n        menu. When a user clicks on the “Approve” option for an item, a dropdown\n        menu appears offering choices to either “Approve” or “Reject.” If this\n        item\u0026#39;s approval status could be changed by another admin concurrently,\n        then the menu options must reflect the most current state to avoid\n        conflicting actions.\u003c/p\u003e\n\n\u003cdiv id=\"approval-list.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/approval-list.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 10: The approval list that require in-time\n        states\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eTo handle this, a service call is initiated each time the context\n        menu is activated. This service fetches the latest status of the item,\n        ensuring that the dropdown is constructed with the most accurate and\n        current options available at that moment. As a result, these requests\n        cannot be made in parallel with other data-fetching activities since the\n        dropdown\u0026#39;s contents depend entirely on the real-time status fetched from\n        the server.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"fallback-markup\"\u003e\n\u003ch2\u003eFallback Markup\u003c/h2\u003e\n\n\u003cp\u003eSpecify fallback displays in the page markup\u003c/p\u003e\n\n\u003cp\u003eThis pattern leverages abstractions provided by frameworks or libraries\n      to handle the data retrieval process, including managing states like\n      loading, success, and error, behind the scenes. It allows developers to\n      focus on the structure and presentation of data in their applications,\n      promoting cleaner and more maintainable code.\u003c/p\u003e\n\n\u003cp\u003eLet\u0026#39;s take another look at the \u003ccode\u003eFriends\u003c/code\u003e component in the above\n      section. It has to maintain three different states and register the\n      callback in \u003ccode\u003euseEffect\u003c/code\u003e, setting the flag correctly at the right time,\n      arrange the different UI for different states:\u003c/p\u003e\n\n\u003cpre\u003econst Friends = ({ id }: { id: string }) =\u0026gt; {\n  //...\n  const {\n    loading,\n    error,\n    data: friends,\n    fetch: fetchFriends,\n  } = useService(`/users/${id}/friends`);\n\n  useEffect(() =\u0026gt; {\n    fetchFriends();\n  }, []);\n\n  if (loading) {\n    // show loading indicator\n  }\n\n  if (error) {\n    // show error message component\n  }\n\n  // show the acutal friend list\n};\n\u003c/pre\u003e\n\n\u003cp\u003eYou will notice that \u003cb\u003einside\u003c/b\u003e a component we have to deal with\n      different states, even we extract custom Hook to reduce the noise in a\n      component, we still need to pay good attention to handling\n      \u003ccode\u003eloading\u003c/code\u003e and \u003ccode\u003eerror\u003c/code\u003e inside a component. These\n      boilerplate code can be cumbersome and distracting, often cluttering the\n      readability of our codebase.\u003c/p\u003e\n\n\u003cp\u003eIf we think of declarative API, like how we build our UI with JSX, the\n      code can be written in the following manner that allows you to focus on\n      \u003cb\u003ewhat the component is doing - not how to do it\u003c/b\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;WhenError fallback={\u0026lt;ErrorMessage /\u0026gt;}\u0026gt;\n  \u0026lt;WhenInProgress fallback={\u0026lt;Loading /\u0026gt;}\u0026gt;\n    \u0026lt;Friends /\u0026gt;\n  \u0026lt;/WhenInProgress\u0026gt;\n\u0026lt;/WhenError\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eIn the above code snippet, the intention is simple and clear: when an\n      error occurs, \u003ccode\u003eErrorMessage\u003c/code\u003e is displayed. While the operation is in\n      progress, Loading is shown. Once the operation completes without errors,\n      the Friends component is rendered.\u003c/p\u003e\n\n\u003cp\u003eAnd the code snippet above is pretty similiar to what already be\n      implemented in a few libraries (including React and Vue.js). For example,\n      the new \u003ccode\u003eSuspense\u003c/code\u003e in React allows developers to more effectively manage\n      asynchronous operations within their components, improving the handling of\n      loading states, error states, and the orchestration of concurrent\n      tasks.\u003c/p\u003e\n\n\u003csection id=\"ImplementingFallbackMarkupInReactWithSuspense\"\u003e\n\u003ch3\u003eImplementing Fallback Markup in React with Suspense\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode\u003eSuspense\u003c/code\u003e in React is a mechanism for efficiently handling\n        asynchronous operations, such as data fetching or resource loading, in a\n        declarative manner. By wrapping components in a \u003ccode\u003eSuspense\u003c/code\u003e boundary,\n        developers can specify fallback content to display while waiting for the\n        component\u0026#39;s data dependencies to be fulfilled, streamlining the user\n        experience during loading states.\u003c/p\u003e\n\n\u003cp\u003eWhile with the Suspense API, in the \u003ccode\u003eFriends\u003c/code\u003e you describe what you\n        want to get and then render:\u003c/p\u003e\n\n\u003cpre\u003eimport useSWR from \u0026#34;swr\u0026#34;;\nimport { get } from \u0026#34;../utils.ts\u0026#34;;\n\nfunction Friends({ id }: { id: string }) {\n  const { data: users } = useSWR(\u0026#34;/api/profile\u0026#34;, () =\u0026gt; get\u0026lt;User[]\u0026gt;(`/users/${id}/friends`), {\n    suspense: true,\n  });\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;h2\u0026gt;Friends\u0026lt;/h2\u0026gt;\n      \u0026lt;div\u0026gt;\n        {friends.map((user) =\u0026gt; (\n          \u0026lt;Friend user={user} key={user.id} /\u0026gt;\n        ))}\n      \u0026lt;/div\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eAnd declaratively when you use the \u003ccode\u003eFriends\u003c/code\u003e, you use\n        \u003ccode\u003eSuspense\u003c/code\u003e boundary to wrap around the \u003ccode\u003eFriends\u003c/code\u003e\n        component:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;Suspense fallback={\u0026lt;FriendsSkeleton /\u0026gt;}\u0026gt;\n  \u0026lt;Friends id={id} /\u0026gt;\n\u0026lt;/Suspense\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eSuspense\u003c/code\u003e manages the asynchronous loading of the\n        \u003ccode\u003eFriends\u003c/code\u003e component, showing a \u003ccode\u003eFriendsSkeleton\u003c/code\u003e \n        placeholder until the component\u0026#39;s data dependencies are\n        resolved. This setup ensures that the user interface remains responsive\n        and informative during data fetching, improving the overall user\n        experience.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"UseThePatternInVue.js\"\u003e\n\u003ch3\u003eUse the pattern in Vue.js\u003c/h3\u003e\n\n\u003cp\u003eIt\u0026#39;s worth noting that Vue.js is also exploring a similar\n        experimental pattern, where you can employ Fallback Markup using:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;Suspense\u0026gt;\n  \u0026lt;template #default\u0026gt;\n    \u0026lt;AsyncComponent /\u0026gt;\n  \u0026lt;/template\u0026gt;\n  \u0026lt;template #fallback\u0026gt;\n    Loading...\n  \u0026lt;/template\u0026gt;\n\u0026lt;/Suspense\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eUpon the first render, \u003ccode\u003e\u0026lt;Suspense\u0026gt;\u003c/code\u003e attempts to render\n        its default content behind the scenes. Should it encounter any\n        asynchronous dependencies during this phase, it transitions into a\n        pending state, where the fallback content is displayed instead. Once all\n        the asynchronous dependencies are successfully loaded,\n        \u003ccode\u003e\u0026lt;Suspense\u0026gt;\u003c/code\u003e moves to a resolved state, and the content\n        initially intended for display (the default slot content) is\n        rendered.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"DecidingPlacementForTheLoadingComponent\"\u003e\n\u003ch3\u003eDeciding Placement for the Loading Component\u003c/h3\u003e\n\n\u003cp\u003eYou may wonder where to place the \u003ccode\u003eFriendsSkeleton\u003c/code\u003e\n        component and who should manage it. Typically, without using Fallback\n        Markup, this decision is straightforward and handled directly within the\n        component that manages the data fetching:\u003c/p\u003e\n\n\u003cpre\u003econst Friends = ({ id }: { id: string }) =\u0026gt; {\n  // Data fetching logic here...\n\n  if (loading) {\n    // Display loading indicator\n  }\n\n  if (error) {\n    // Display error message component\n  }\n\n  // Render the actual friend list\n};\n\u003c/pre\u003e\n\n\u003cp\u003eIn this setup, the logic for displaying loading indicators or error\n        messages is naturally situated within the \u003ccode\u003eFriends\u003c/code\u003e component. However,\n        adopting Fallback Markup  shifts this responsibility to the\n        component’s consumer:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;Suspense fallback={\u0026lt;FriendsSkeleton /\u0026gt;}\u0026gt;\n  \u0026lt;Friends id={id} /\u0026gt;\n\u0026lt;/Suspense\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eIn real-world applications, the optimal approach to handling loading\n        experiences depends significantly on the desired user interaction and\n        the structure of the application. For instance, a hierarchical loading\n        approach where a parent component ceases to show a loading indicator\n        while its children components continue can disrupt the user experience.\n        Thus, it\u0026#39;s crucial to carefully consider at what level within the\n        component hierarchy the loading indicators or skeleton placeholders\n        should be displayed.\u003c/p\u003e\n\n\u003cp\u003eThink of \u003ccode\u003eFriends\u003c/code\u003e and \u003ccode\u003eFriendsSkeleton\u003c/code\u003e as two\n        distinct component states—one representing the presence of data, and the\n        other, the absence. This concept is somewhat analogous to using a \u003ca href=\"https://martinfowler.com/eaaCatalog/specialCase.html\"\u003eSpecial Case\u003c/a\u003e pattern in object-oriented\n        programming, where \u003ccode\u003eFriendsSkeleton\u003c/code\u003e serves as the \u0026#39;null\u0026#39;\n        state handling for the \u003ccode\u003eFriends\u003c/code\u003e component.\u003c/p\u003e\n\n\u003cp\u003eThe key is to determine the granularity with which you want to\n        display loading indicators and to maintain consistency in these\n        decisions across your application. Doing so helps achieve a smoother and\n        more predictable user experience.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"fallback-markup-when\"\u003e\n\u003ch3\u003eWhen to use it\u003c/h3\u003e\n\n\u003cp\u003eUsing Fallback Markup in your UI simplifies code by enhancing its readability\n        and maintainability. This pattern is particularly effective when utilizing\n        standard components for various states such as loading, errors, skeletons, and\n        empty views across your application. It reduces redundancy and cleans up\n        boilerplate code, allowing components to focus solely on rendering and\n        functionality.\u003c/p\u003e\n\n\u003cp\u003eFallback Markup, such as React\u0026#39;s Suspense, standardizes the handling of\n        asynchronous loading, ensuring a consistent user experience. It also improves\n        application performance by optimizing resource loading and rendering, which is\n        especially beneficial in complex applications with deep component trees.\u003c/p\u003e\n\n\u003cp\u003eHowever, the effectiveness of Fallback Markup depends on the capabilities of\n        the framework you are using. For example, React\u0026#39;s implementation of Suspense for\n        data fetching still requires third-party libraries, and Vue’s support for\n        similar features is experimental. Moreover, while Fallback Markup can reduce\n        complexity in managing state across components, it may introduce overhead in\n        simpler applications where managing state directly within components could\n        suffice. Additionally, this pattern may limit detailed control over loading and\n        error states—situations where different error types need distinct handling might\n        not be as easily managed with a generic fallback approach.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"IntroducingUserdetailcardComponent\"\u003e\n\u003ch2\u003eIntroducing UserDetailCard component\u003c/h2\u003e\n\n\u003cp\u003eLet’s say we need a feature that when users hover on top of a \u003ccode\u003eFriend\u003c/code\u003e,\n      we show a popup so they can see more details about that user.\u003c/p\u003e\n\n\u003cdiv id=\"user-brief-and-friends-user-detail.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/user-brief-and-friends-user-detail.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 11: Showing user detail\n      card component when hover\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eWhen the popup shows up, we need to send another service call to get\n      the user details (like their homepage and number of connections, etc.). We\n      will need to update the \u003ccode\u003eFriend\u003c/code\u003e component ((the one we use to\n      render each item in the Friends list) ) to something like the\n      following.\u003c/p\u003e\n\n\u003cpre\u003eimport { Popover, PopoverContent, PopoverTrigger } from \u0026#34;@nextui-org/react\u0026#34;;\nimport { UserBrief } from \u0026#34;./user.tsx\u0026#34;;\n\nimport UserDetailCard from \u0026#34;./user-detail-card.tsx\u0026#34;;\n\nexport const Friend = ({ user }: { user: User }) =\u0026gt; {\n  return (\n    \u0026lt;Popover placement=\u0026#34;bottom\u0026#34; showArrow offset={10}\u0026gt;\n      \u0026lt;PopoverTrigger\u0026gt;\n        \u0026lt;button\u0026gt;\n          \u0026lt;UserBrief user={user} /\u0026gt;\n        \u0026lt;/button\u0026gt;\n      \u0026lt;/PopoverTrigger\u0026gt;\n      \u0026lt;PopoverContent\u0026gt;\n        \u0026lt;UserDetailCard id={user.id} /\u0026gt;\n      \u0026lt;/PopoverContent\u0026gt;\n    \u0026lt;/Popover\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eUserDetailCard\u003c/code\u003e, is pretty similar to the\n      \u003ccode\u003eProfile\u003c/code\u003e component, it sends a request to load data and then\n      renders the result once it gets the response.\u003c/p\u003e\n\n\u003cpre\u003eexport function UserDetailCard({ id }: { id: string }) {\n  const { loading, error, detail } = useUserDetail(id);\n\n  if (loading || !detail) {\n    return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;;\n  }\n\n  return (\n    \u0026lt;div\u0026gt;\n    {/* render the user detail*/}\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eWe’re using \u003ccode\u003ePopover\u003c/code\u003e and the supporting components from\n      \u003ccode\u003enextui\u003c/code\u003e, which provides a lot of beautiful and out-of-box\n      components for building modern UI. The only problem here, however, is that\n      the package itself is relatively big, also not everyone uses the feature\n      (hover and show details), so loading that extra large package for everyone\n      isn’t ideal - it would be better to load the \u003ccode\u003eUserDetailCard\u003c/code\u003e\n      on demand - whenever it’s required.\u003c/p\u003e\n\n\u003cdiv id=\"async-components-3-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/async-components-3-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 12: Component structure with\n      UserDetailCard\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"code-splitting\"\u003e\n\u003ch2\u003eCode Splitting\u003c/h2\u003e\n\n\u003cp\u003eDivide code into separate modules and dynamically load them as\n      needed.\u003c/p\u003e\n\n\u003cp\u003eCode Splitting addresses the issue of large bundle sizes in web\n      applications by dividing the bundle into smaller chunks that are loaded as\n      needed, rather than all at once. This improves initial load time and\n      performance, especially important for large applications or those with\n      many routes.\u003c/p\u003e\n\n\u003cp\u003eThis optimization is typically carried out at build time, where complex\n      or sizable modules are segregated into distinct bundles. These are then\n      dynamically loaded, either in response to user interactions or\n      preemptively, in a manner that does not hinder the critical rendering path\n      of the application.\u003c/p\u003e\n\n\u003csection id=\"LeveragingTheDynamicImportOperator\"\u003e\n\u003ch3\u003eLeveraging the Dynamic Import Operator\u003c/h3\u003e\n\n\u003cp\u003eThe dynamic import operator in JavaScript streamlines the process of\n        loading modules. Though it may resemble a function call in your code,\n        such as \u003ccode\u003eimport(“./user-detail-card.tsx”)\u003c/code\u003e, it\u0026#39;s important to\n        recognize that \u003ccode\u003eimport\u003c/code\u003e is actually a keyword, not a\n        function. This operator enables the asynchronous and dynamic loading of\n        JavaScript modules.\u003c/p\u003e\n\n\u003cp\u003eWith dynamic import, you can load a module on demand. For example, we\n        only load a module when a button is clicked:\u003c/p\u003e\n\n\u003cpre\u003ebutton.addEventListener(\u0026#34;click\u0026#34;, (e) =\u0026gt; {\n\n  import(\u0026#34;/modules/some-useful-module.js\u0026#34;)\n    .then((module) =\u0026gt; {\n      module.doSomethingInteresting();\n    })\n    .catch(error =\u0026gt; {\n      console.error(\u0026#34;Failed to load the module:\u0026#34;, error);\n    });\n});\n\u003c/pre\u003e\n\n\u003cp\u003eThe module is not loaded during the initial page load. Instead, the\n        \u003ccode\u003eimport()\u003c/code\u003e call is placed inside an event listener so it only\n        be loaded when, and if, the user interacts with that button.\u003c/p\u003e\n\n\u003cp\u003eYou can use dynamic import operator in React and libraries like\n        Vue.js. React simplifies the code splitting and lazy load through the\n        \u003ccode\u003eReact.lazy\u003c/code\u003e and \u003ccode\u003eSuspense\u003c/code\u003e APIs. By wrapping the\n        import statement with \u003ccode\u003eReact.lazy\u003c/code\u003e, and subsequently wrapping\n        the component, for instance, \u003ccode\u003eUserDetailCard\u003c/code\u003e, with\n        \u003ccode\u003eSuspense\u003c/code\u003e, React defers the component rendering until the\n        required module is loaded. During this loading phase, a fallback UI is\n        presented, seamlessly transitioning to the actual component upon load\n        completion.\u003c/p\u003e\n\n\u003cpre\u003eimport React, { Suspense } from \u0026#34;react\u0026#34;;\nimport { Popover, PopoverContent, PopoverTrigger } from \u0026#34;@nextui-org/react\u0026#34;;\nimport { UserBrief } from \u0026#34;./user.tsx\u0026#34;;\n\nconst UserDetailCard = React.lazy(() =\u0026gt; import(\u0026#34;./user-detail-card.tsx\u0026#34;));\n\nexport const Friend = ({ user }: { user: User }) =\u0026gt; {\n  return (\n    \u0026lt;Popover placement=\u0026#34;bottom\u0026#34; showArrow offset={10}\u0026gt;\n      \u0026lt;PopoverTrigger\u0026gt;\n        \u0026lt;button\u0026gt;\n          \u0026lt;UserBrief user={user} /\u0026gt;\n        \u0026lt;/button\u0026gt;\n      \u0026lt;/PopoverTrigger\u0026gt;\n      \u0026lt;PopoverContent\u0026gt;\n        \u0026lt;Suspense fallback={\u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;}\u0026gt;\n          \u0026lt;UserDetailCard id={user.id} /\u0026gt;\n        \u0026lt;/Suspense\u0026gt;\n      \u0026lt;/PopoverContent\u0026gt;\n    \u0026lt;/Popover\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThis snippet defines a \u003ccode\u003eFriend\u003c/code\u003e component displaying user\n        details within a popover from Next UI, which appears upon interaction.\n        It leverages \u003ccode\u003eReact.lazy\u003c/code\u003e for code splitting, loading the\n        \u003ccode\u003eUserDetailCard\u003c/code\u003e component only when needed. This\n        lazy-loading, combined with \u003ccode\u003eSuspense\u003c/code\u003e, enhances performance\n        by splitting the bundle and showing a fallback during the load.\u003c/p\u003e\n\n\u003cp\u003eIf we visualize the above code, it renders in the following\n        sequence.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-5-dynamic-load-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-5-dynamic-load-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 13: Dynamic load component\n        when needed\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eNote that when the user hovers and we download\n        the JavaScript bundle, there will be some extra time for the browser to\n        parse the JavaScript. Once that part of the work is done, we can get the\n        user details by calling \u003ccode\u003e/users/\u0026lt;id\u0026gt;/details\u003c/code\u003e API.\n        Eventually, we can use that data to render the content of the popup\n        \u003ccode\u003eUserDetailCard\u003c/code\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"code-splitting-when\"\u003e\n\u003ch3\u003eWhen to use it\u003c/h3\u003e\n\n\u003cp\u003eSplitting out extra bundles and loading them on demand is a viable\n        strategy, but it\u0026#39;s crucial to consider how you implement it. Requesting\n        and processing an additional bundle can indeed save bandwidth and lets\n        users only load what they need. However, this approach might also slow\n        down the user experience in certain scenarios. For example, if a user\n        hovers over a button that triggers a bundle load, it could take a few\n        seconds to load, parse, and execute the JavaScript necessary for\n        rendering. Even though this delay occurs only during the first\n        interaction, it might not provide the ideal experience.\u003c/p\u003e\n\n\u003cp\u003eTo improve perceived performance, effectively using React Suspense to\n        display a skeleton or another loading indicator can help make the\n        loading process seem quicker. Additionally, if the separate bundle is\n        not significantly large, integrating it into the main bundle could be a\n        more straightforward and cost-effective approach. This way, when a user\n        hovers over components like \u003ccode\u003eUserBrief\u003c/code\u003e, the response can be\n        immediate, enhancing the user interaction without the need for separate\n        loading steps.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"LazyLoadInOtherFrontendLibraries\"\u003e\n\u003ch3\u003eLazy load in other frontend libraries\u003c/h3\u003e\n\n\u003cp\u003eAgain, this pattern is widely adopted in other frontend libraries as\n        well. For example, you can use \u003ccode\u003edefineAsyncComponent\u003c/code\u003e in Vue.js to\n        achieve the samiliar result - only load a component when you need it to\n        render:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;template\u0026gt;\n  \u0026lt;Popover placement=\u0026#34;bottom\u0026#34; show-arrow offset=\u0026#34;10\u0026#34;\u0026gt;\n  \u0026lt;!-- the rest of the template --\u0026gt;\n  \u0026lt;/Popover\u0026gt;\n\u0026lt;/template\u0026gt;\n\n\u0026lt;script\u0026gt;\nimport { defineAsyncComponent } from \u0026#39;vue\u0026#39;;\nimport Popover from \u0026#39;path-to-popover-component\u0026#39;;\nimport UserBrief from \u0026#39;./UserBrief.vue\u0026#39;;\n\nconst UserDetailCard = defineAsyncComponent(() =\u0026gt; import(\u0026#39;./UserDetailCard.vue\u0026#39;));\n\n// rendering logic\n\u0026lt;/script\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eThe function \u003ccode\u003edefineAsyncComponent\u003c/code\u003e defines an async\n        component which is lazy loaded only when it is rendered just like the\n        \u003ccode\u003eReact.lazy\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs you might have already seen the noticed, we are running into a \u003ca href=\"#request-waterfall\"\u003e Request Waterfall\u003c/a\u003e here again: we load the\n        JavaScript bundle first, and then when it execute it sequentially call\n        user details API, which makes some extra waiting time. We could request\n        the JavaScript bundle and the network request parallely. Meaning,\n        whenever a \u003ccode\u003eFriend\u003c/code\u003e component is hovered, we can trigger a\n        network request (for the data to render the user details) and cache the\n        result, so that by the time when the bundle is downloaded, we can use\n        the data to render the component immediately.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"prefetching\"\u003e\n\u003ch2\u003ePrefetching\u003c/h2\u003e\n\n\u003cp\u003ePrefetch data before it may be needed to reduce latency if it is.\u003c/p\u003e\n\n\u003cp\u003ePrefetching involves loading resources or data ahead of their actual\n      need, aiming to decrease wait times during subsequent operations. This\n      technique is particularly beneficial in scenarios where user actions can\n      be predicted, such as navigating to a different page or displaying a modal\n      dialog that requires remote data.\u003c/p\u003e\n\n\u003cp\u003eIn practice, prefetching can be\n      implemented using the native HTML \u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e tag with a\n      \u003ccode\u003erel=”preload”\u003c/code\u003e attribute, or programmatically via the\n      \u003ccode\u003efetch\u003c/code\u003e API to load data or resources in advance. For data that\n      is predetermined, the simplest approach is to use the\n      \u003ccode\u003e\u0026lt;link\u0026gt;\u003c/code\u003e tag within the HTML \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;!doctype html\u0026gt;\n\u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\n  \u0026lt;head\u0026gt;\n    \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/bootstrap.js\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt;\n\n    \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/users/u1\u0026#34; as=\u0026#34;fetch\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\n    \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;/users/u1/friends\u0026#34; as=\u0026#34;fetch\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\n\n    \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n  \u0026lt;/head\u0026gt;\n  \u0026lt;body\u0026gt;\n    \u0026lt;div id=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;/body\u0026gt;\n\u0026lt;/html\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eWith this setup, the requests for \u003ccode\u003ebootstrap.js\u003c/code\u003e and user API are sent\n      as soon as the HTML is parsed, significantly earlier than when other\n      scripts are processed. The browser will then cache the data, ensuring it\n      is ready when your application initializes.\u003c/p\u003e\n\n\u003cp\u003eHowever, it\u0026#39;s often not possible to know the precise URLs ahead of\n      time, requiring a more dynamic approach to prefetching. This is typically\n      managed programmatically, often through event handlers that trigger\n      prefetching based on user interactions or other conditions.\u003c/p\u003e\n\n\u003cp\u003eFor example, attaching a \u003ccode\u003emouseover\u003c/code\u003e event listener to a button can\n      trigger the prefetching of data. This method allows the data to be fetched\n      and stored, perhaps in a local state or cache, ready for immediate use\n      when the actual component or content requiring the data is interacted with\n      or rendered. This proactive loading minimizes latency and enhances the\n      user experience by having data ready ahead of time.\u003c/p\u003e\n\n\u003cpre\u003edocument.getElementById(\u0026#39;button\u0026#39;).addEventListener(\u0026#39;mouseover\u0026#39;, () =\u0026gt; {\n  fetch(`/user/${user.id}/details`)\n    .then(response =\u0026gt; response.json())\n    .then(data =\u0026gt; {\n      sessionStorage.setItem(\u0026#39;userDetails\u0026#39;, JSON.stringify(data));\n    })\n    .catch(error =\u0026gt; console.error(error));\n});\n\u003c/pre\u003e\n\n\u003cp\u003eAnd in the place that needs the data to render, it reads from\n      \u003ccode\u003esessionStorage\u003c/code\u003e when available, otherwise showing a loading indicator.\n      Normally the user experiense would be much faster.\u003c/p\u003e\n\n\u003csection id=\"ImplementingPrefetchingInReact\"\u003e\n\u003ch3\u003eImplementing Prefetching in React\u003c/h3\u003e\n\n\u003cp\u003eFor example, we can use \u003ccode\u003epreload\u003c/code\u003e from the\n        \u003ccode\u003eswr\u003c/code\u003e package (the function name is a bit misleading, but it\n        is performing a prefetch here), and then register an\n        \u003ccode\u003eonMouseEnter\u003c/code\u003e event to the trigger component of\n        \u003ccode\u003ePopover\u003c/code\u003e,\u003c/p\u003e\n\n\u003cpre\u003eimport { preload } from \u0026#34;swr\u0026#34;;\nimport { getUserDetail } from \u0026#34;../api.ts\u0026#34;;\n\nconst UserDetailCard = React.lazy(() =\u0026gt; import(\u0026#34;./user-detail-card.tsx\u0026#34;));\n\nexport const Friend = ({ user }: { user: User }) =\u0026gt; {\n  const handleMouseEnter = () =\u0026gt; {\n    preload(`/user/${user.id}/details`, () =\u0026gt; getUserDetail(user.id));\n  };\n\n  return (\n    \u0026lt;Popover placement=\u0026#34;bottom\u0026#34; showArrow offset={10}\u0026gt;\n      \u0026lt;PopoverTrigger\u0026gt;\n        \u0026lt;button onMouseEnter={handleMouseEnter}\u0026gt;\n          \u0026lt;UserBrief user={user} /\u0026gt;\n        \u0026lt;/button\u0026gt;\n      \u0026lt;/PopoverTrigger\u0026gt;\n      \u0026lt;PopoverContent\u0026gt;\n        \u0026lt;Suspense fallback={\u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;}\u0026gt;\n          \u0026lt;UserDetailCard id={user.id} /\u0026gt;\n        \u0026lt;/Suspense\u0026gt;\n      \u0026lt;/PopoverContent\u0026gt;\n    \u0026lt;/Popover\u0026gt;\n  );\n};\n\u003c/pre\u003e\n\n\u003cp\u003eThat way, the popup itself can have much less time to render, which\n        brings a better user experience.\u003c/p\u003e\n\n\u003cdiv id=\"timeline-1-6-preload-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/timeline-1-6-preload-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 14: Dynamic load with prefetch\n        in parallel\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eSo when a user hovers on a \u003ccode\u003eFriend\u003c/code\u003e, we download the\n        corresponding JavaScript bundle as well as download the data needed to\n        render the UserDetailCard, and by the time \u003ccode\u003eUserDetailCard\u003c/code\u003e\n        renders, it sees the existing data and renders immediately.\u003c/p\u003e\n\n\u003cdiv id=\"async-components-4-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/async-components-4-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 15: Component structure with\n        dynamic load\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eAs the data fetching and loading is shifted to \u003ccode\u003eFriend\u003c/code\u003e\n        component, and for \u003ccode\u003eUserDetailCard\u003c/code\u003e, it reads from the local\n        cache maintained by \u003ccode\u003eswr\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003eimport useSWR from \u0026#34;swr\u0026#34;;\n\nexport function UserDetailCard({ id }: { id: string }) {\n  const { data: detail, isLoading: loading } = useSWR(\n    `/user/${id}/details`,\n    () =\u0026gt; getUserDetail(id)\n  );\n\n  if (loading || !detail) {\n    return \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;;\n  }\n\n  return (\n    \u0026lt;div\u0026gt;\n    {/* render the user detail*/}\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/pre\u003e\n\n\u003cp\u003eThis component uses the \u003ccode\u003euseSWR\u003c/code\u003e hook for data fetching,\n        making the \u003ccode\u003eUserDetailCard\u003c/code\u003e dynamically load user details\n        based on the given \u003ccode\u003eid\u003c/code\u003e. \u003ccode\u003euseSWR\u003c/code\u003e offers efficient\n        data fetching with caching, revalidation, and automatic error handling.\n        The component displays a loading state until the data is fetched. Once\n        the data is available, it proceeds to render the user details.\u003c/p\u003e\n\n\u003cp\u003eIn summary, we\u0026#39;ve already explored critical data fetching strategies:\n        \u003ca href=\"#async-state-handler\"\u003eAsynchronous State Handler\u003c/a\u003e , \u003ca href=\"#parallel-data-fetching\"\u003eParallel Data Fetching\u003c/a\u003e ,\n        \u003ca href=\"#fallback-markup\"\u003eFallback Markup\u003c/a\u003e , \u003ca href=\"#code-splitting\"\u003eCode Splitting\u003c/a\u003e and \u003ca href=\"#prefetching\"\u003ePrefetching\u003c/a\u003e . Elevating requests for parallel execution\n        enhances efficiency, though it\u0026#39;s not always straightforward, especially\n        when dealing with components developed by different teams without full\n        visibility. Code splitting allows for the dynamic loading of\n        non-critical resources based on user interaction, like clicks or hovers,\n        utilizing prefetching to parallelize resource loading.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"prefetching-when\"\u003e\n\u003ch3\u003eWhen to use it\u003c/h3\u003e\n\n\u003cp\u003eConsider applying prefetching when you notice that the initial load time of\n          your application is becoming slow, or there are many features that aren\u0026#39;t\n          immediately necessary on the initial screen but could be needed shortly after.\n          Prefetching is particularly useful for resources that are triggered by user\n          interactions, such as mouse-overs or clicks. While the browser is busy fetching\n          other resources, such as JavaScript bundles or assets, prefetching can load\n          additional data in advance, thus preparing for when the user actually needs to\n          see the content. By loading resources during idle times, prefetching utilizes the\n          network more efficiently, spreading the load over time rather than causing spikes\n          in demand.\u003c/p\u003e\n\n\u003cp\u003eIt’s wise to follow a general guideline: don\u0026#39;t implement complex patterns like\n        prefetching until they are clearly needed. This might be the case if performance\n        issues become apparent, especially during initial loads, or if a significant\n        portion of your users access the app from mobile devices, which typically have\n        less bandwidth and slower JavaScript engines. Also, consider that there are other\n        performance optimization tactics such as caching at various levels, using CDNs\n        for static assets, and ensuring assets are compressed. These methods can enhance\n        performance with simpler configurations and without additional coding. The\n        effectiveness of prefetching relies on accurately predicting user actions.\n        Incorrect assumptions can lead to ineffective prefetching and even degrade the\n        user experience by delaying the loading of actually needed resources.\u003c/p\u003e\n\u003c/section\u003e\n\u003c/section\u003e\n\n\u003csection id=\"ChoosingTheRightPattern\"\u003e\n\u003ch2\u003eChoosing the right pattern\u003c/h2\u003e\n\n\n\n\u003cp\u003eSelecting the appropriate pattern for data fetching and rendering in\n      web development is not one-size-fits-all. Often, multiple strategies are\n      combined to meet specific requirements. For example, you might need to\n      generate some content on the server side - using Server-Side Rendering\n      techniques - supplemented by client-side \u003ca href=\"#fetch-then-render\"\u003e\n      Fetch-Then-Render\u003c/a\u003e for dynamic\n      content. Furthermore, non-essential sections can be split into separate\n      bundles for lazy loading, possibly with \u003ca href=\"#prefetching\"\u003ePrefetching\u003c/a\u003e triggered by user\n      actions, such as hover or click.\u003c/p\u003e\n\n\u003cp\u003eConsider the Jira issue page as an example. The top navigation and\n      sidebar are static, loading first to give users immediate context. Early\n      on, you\u0026#39;re presented with the issue\u0026#39;s title, description, and key details\n      like the Reporter and Assignee. For less immediate information, such as\n      the History section at an issue\u0026#39;s bottom, it loads only upon user\n      interaction, like clicking a tab. This utilizes lazy loading and data\n      fetching to efficiently manage resources and enhance user experience.\u003c/p\u003e\n\n\u003cdiv id=\"multiple-patterns-trans.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/data-fetch-spa/multiple-patterns-trans.png\"/\u003e\u003c/p\u003e\u003cp\u003eFigure 16: Using patterns together\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003eMoreover, certain strategies require additional setup compared to\n      default, less optimized solutions. For instance, implementing \u003ca href=\"#code-splitting\"\u003eCode Splitting\u003c/a\u003e  requires bundler support. If your current bundler lacks this\n      capability, an upgrade may be required, which could be impractical for\n      older, less stable systems.\u003c/p\u003e\n\n\u003cp\u003eWe\u0026#39;ve covered a wide range of patterns and how they apply to various\n      challenges. I realize there\u0026#39;s quite a bit to take in, from code examples\n      to diagrams. If you\u0026#39;re looking for a more guided approach, I\u0026#39;ve put\n      together \u003ca href=\"https://www.icodeit.com.au/tutorials/advanced-network-patterns-react\"\u003ea comprehensive tutorial\u003c/a\u003e on my\n      website, or if you only want to have a look at the working code, they are\n      all hosted \u003ca href=\"https://github.com/abruzzi/react-network-advanced-client-side\"\u003ein this github repo\u003c/a\u003e.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Conclusion\"\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eData fetching is a nuanced aspect of development, yet mastering the\n      appropriate techniques can vastly enhance our applications. As we conclude\n      our journey through data fetching and content rendering strategies within\n      the context of React, it\u0026#39;s crucial to highlight our main insights:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003e\u003ca href=\"#async-state-handler\"\u003eAsynchronous State Handler\u003c/a\u003e\u003c/b\u003e: Utilize custom hooks or composable APIs to\n        abstract data fetching and state management away from your components. This\n        pattern centralizes asynchronous logic, simplifying component design and\n        enhancing reusability across your application.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003e\u003ca href=\"#fallback-markup\"\u003eFallback Markup\u003c/a\u003e\u003c/b\u003e: React\u0026#39;s enhanced Suspense model supports a more\n        declarative approach to fetching data asynchronously, streamlining your\n        codebase.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003e\u003ca href=\"#parallel-data-fetching\"\u003eParallel Data Fetching\u003c/a\u003e\u003c/b\u003e: Maximize efficiency by fetching data in\n        parallel, reducing wait times and boosting the responsiveness of your\n        application.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003e\u003ca href=\"#code-splitting\"\u003eCode Splitting\u003c/a\u003e\u003c/b\u003e: Employ lazy loading for non-essential\n        components during the initial load, leveraging Suspense for graceful\n        handling of loading states and code splitting, thereby ensuring your\n        application remains performant.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003e\u003ca href=\"#prefetching\"\u003ePrefetching\u003c/a\u003e\u003c/b\u003e: By preemptively loading data based on predicted user\n        actions, you can achieve a smooth and fast user experience.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWhile these insights were framed within the React ecosystem, it\u0026#39;s\n      essential to recognize that these patterns are not confined to React\n      alone. They are broadly applicable and beneficial strategies that can—and\n      should—be adapted for use with other libraries and frameworks. By\n      thoughtfully implementing these approaches, developers can create\n      applications that are not just efficient and scalable, but also offer a\n      superior user experience through effective data fetching and content\n      rendering practices.\u003c/p\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "78 min read",
  "publishedTime": null,
  "modifiedTime": "2024-05-29T00:00:00Z"
}
