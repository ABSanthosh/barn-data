{
  "id": "8af0fc5e-f233-4978-a4e9-f448f4545fc1",
  "title": "On let vs const",
  "link": "https://overreacted.io/on-let-vs-const/",
  "description": "So which one should I use?",
  "author": "",
  "published": "Sun, 22 Dec 2019 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 4116,
  "excerpt": "So which one should I use?",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "My previous post included this paragraph: let vs const vs var: Usually you want let. If you want to forbid assignment to this variable, you can use const. (Some codebases and coworkers are pedantic and force you to use const when there is only one assignment.) This turned out to be very controversial, sparking conversations on Twitter and Reddit. It seems that the majority view (or at least, the most vocally expressed view) is that one should use const wherever possible, only falling back to let where necessary, as can be enforced with the prefer-const ESLint rule. In this post, I will briefly summarize some of the arguments and counter-arguments I‚Äôve encountered, as well as my personal conclusion on this topic. Why prefer-const One Way to Do It: It is mental overhead to have to choose between let and const every time. A rule like ‚Äúalways use const where it works‚Äù lets you stop thinking about it and can be enforced by a linter. Reassignments May Cause Bugs: In a longer function, it can be easy to miss when a variable is reassigned. This may cause bugs. Particularly in closures, const gives you confidence you‚Äôll always ‚Äúsee‚Äù the same value. Learning About Mutation: Folks new to JavaScript often get confused thinking const implies immutability. However, one could argue that it‚Äôs important to learn the difference between variable mutation and assignment anyway, and preferring const forces you to confront this distinction early on. Meaningless Assignments: Sometimes, an assignment doesn‚Äôt make sense at all. For example, with React Hooks, the values you get from a Hook like useState are more like parameters. They flow in one direction. Seeing an error on their assignment helps you learn earlier about the React data flow. Performance Benefits: There are occasional claims that JavaScript engines could make code using const run faster due to the knowledge the variable won‚Äôt be reassigned. Why Not prefer-const Loss of Intent: If we force const everywhere it can work, we lose the ability to communicate whether it was important for something to not be reassigned. Confusion with Immutability: In every discussion about why you should prefer const, someone always confuses with immutability. This is unsurprising, as both assignment and mutation use the same = operator. In response, people are usually told that they should ‚Äújust learn the language‚Äù. However, the counter-argument is that if a feature that prevents mostly beginner mistakes is confusing to beginners, it isn‚Äôt very helpful. And unfortunately, it doesn‚Äôt help prevent mutation mistakes which span across modules and affect everyone. Pressure to Avoid Redeclaring: A const-first codebase creates a pressure to not use let for conditionally assigned variables. For example, you might write const a = cond ? b : c instead of an if condition, even if both b and c branches are convoluted and giving them explicit names is awkward. Reassignments May Not Cause Bugs: There are three common cases when reassignments cause bugs: when the scope is very large (such as module scope or huge functions), when the value is a parameter (so it‚Äôs unexpected that it would be equal to something other than what was passed), and when a variable is used in a nested function. However, in many codebases most variables won‚Äôt satisfy either of those cases, and parameters can‚Äôt be marked as constant at all. No Performance Benefits: It is my understanding that the engines are already aware of which variables are only assigned once ‚Äî even if you use var or let. If we insist on speculating, we could just as well speculate that extra checks can create performance cost rather than reduce it. But really, engines are smart. My Conclusion I don‚Äôt care. I would use whatever convention already exists in the codebase. If you care, use a linter that automates checking and fixing this so that changing let to const doesn‚Äôt become a delay in code review. Finally, remember that linters exist to serve you. If a linter rule annoys you and your team, delete it. It may not be worth it. Learn from your own mistakes.Discuss on ùïè¬†¬†¬∑¬†¬†Edit on GitHub",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eMy \u003ca href=\"https://overreacted.io/what-is-javascript-made-of/\"\u003eprevious post\u003c/a\u003e included this paragraph:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003elet\u003c/code\u003e vs \u003ccode\u003econst\u003c/code\u003e vs \u003ccode\u003evar\u003c/code\u003e\u003c/strong\u003e: Usually you want \u003ccode\u003elet\u003c/code\u003e. If you want to forbid assignment to this variable, you can use \u003ccode\u003econst\u003c/code\u003e. (Some codebases and coworkers are pedantic and force you to use \u003ccode\u003econst\u003c/code\u003e when there is only one assignment.)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis turned out to be very controversial, sparking conversations on Twitter and Reddit. It seems that the majority view (or at least, the most vocally expressed view) is that one should \u003cem\u003euse \u003ccode\u003econst\u003c/code\u003e wherever possible,\u003c/em\u003e only falling back to \u003ccode\u003elet\u003c/code\u003e where necessary, as can be enforced with the \u003ca target=\"_blank\" href=\"https://eslint.org/docs/rules/prefer-const\"\u003e\u003ccode\u003eprefer-const\u003c/code\u003e\u003c/a\u003e ESLint rule.\u003c/p\u003e\n\u003cp\u003eIn this post, I will briefly summarize some of the arguments and counter-arguments I‚Äôve encountered, as well as my personal conclusion on this topic.\u003c/p\u003e\n\u003ch2\u003eWhy \u003ccode\u003eprefer-const\u003c/code\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOne Way to Do It\u003c/strong\u003e: It is mental overhead to have to choose between \u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003econst\u003c/code\u003e every time. A rule like ‚Äúalways use \u003ccode\u003econst\u003c/code\u003e where it works‚Äù lets you stop thinking about it and can be enforced by a linter.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReassignments May Cause Bugs\u003c/strong\u003e: In a longer function, it can be easy to miss when a variable is reassigned. This may cause bugs. Particularly in closures, \u003ccode\u003econst\u003c/code\u003e gives you confidence you‚Äôll always ‚Äúsee‚Äù the same value.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLearning About Mutation\u003c/strong\u003e: Folks new to JavaScript often get confused thinking \u003ccode\u003econst\u003c/code\u003e implies immutability. However, one could argue that it‚Äôs important to learn the difference between variable mutation and assignment anyway, and preferring \u003ccode\u003econst\u003c/code\u003e forces you to confront this distinction early on.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMeaningless Assignments\u003c/strong\u003e: Sometimes, an assignment doesn‚Äôt make sense at all. For example, with React Hooks, the values you get from a Hook like \u003ccode\u003euseState\u003c/code\u003e are more like parameters. They flow in one direction. Seeing an error on their assignment helps you learn earlier about the React data flow.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePerformance Benefits\u003c/strong\u003e: There are occasional claims that JavaScript engines could make code using \u003ccode\u003econst\u003c/code\u003e run faster due to the knowledge the variable won‚Äôt be reassigned.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eWhy Not \u003ccode\u003eprefer-const\u003c/code\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLoss of Intent\u003c/strong\u003e: If we force \u003ccode\u003econst\u003c/code\u003e everywhere it can work, we lose the ability to communicate whether it was \u003cem\u003eimportant\u003c/em\u003e for something to not be reassigned.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConfusion with Immutability\u003c/strong\u003e: In every discussion about why you should prefer \u003ccode\u003econst\u003c/code\u003e, someone always confuses with immutability. This is unsurprising, as both assignment and mutation use the same \u003ccode\u003e=\u003c/code\u003e operator. In response, people are usually told that they should ‚Äújust learn the language‚Äù. However, the counter-argument is that if a feature that prevents mostly beginner mistakes is confusing to beginners, it isn‚Äôt very helpful. And unfortunately, it doesn‚Äôt help prevent mutation mistakes which span across modules and affect everyone.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePressure to Avoid Redeclaring\u003c/strong\u003e: A \u003ccode\u003econst\u003c/code\u003e-first codebase creates a pressure to not use \u003ccode\u003elet\u003c/code\u003e for conditionally assigned variables. For example, you might write \u003ccode\u003econst a = cond ? b : c\u003c/code\u003e instead of an \u003ccode\u003eif\u003c/code\u003e condition, even if both \u003ccode\u003eb\u003c/code\u003e and \u003ccode\u003ec\u003c/code\u003e branches are convoluted and giving them explicit names is awkward.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReassignments May Not Cause Bugs\u003c/strong\u003e: There are three common cases when reassignments cause bugs: when the scope is very large (such as module scope or huge functions), when the value is a parameter (so it‚Äôs unexpected that it would be equal to something other than what was passed), and when a variable is used in a nested function. However, in many codebases most variables won‚Äôt satisfy either of those cases, and parameters can‚Äôt be marked as constant at all.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNo Performance Benefits\u003c/strong\u003e: It is my understanding that the engines are already aware of which variables are only assigned once ‚Äî even if you use \u003ccode\u003evar\u003c/code\u003e or \u003ccode\u003elet\u003c/code\u003e. If we insist on speculating, we could just as well speculate that extra checks can \u003cem\u003ecreate\u003c/em\u003e performance cost rather than reduce it. But really, engines are smart.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMy Conclusion\u003c/h2\u003e\n\u003cp\u003eI don‚Äôt care.\u003c/p\u003e\n\u003cp\u003eI would use whatever convention already exists in the codebase.\u003c/p\u003e\n\u003cp\u003eIf you care, use a linter that automates checking and fixing this so that changing \u003ccode\u003elet\u003c/code\u003e to \u003ccode\u003econst\u003c/code\u003e doesn‚Äôt become a delay in code review.\u003c/p\u003e\n\u003cp\u003eFinally, remember that linters exist to serve \u003cem\u003eyou\u003c/em\u003e. If a linter rule annoys you and your team, delete it. It may not be worth it. Learn from your own mistakes.\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://x.com/search?q=https%3A%2F%2Foverreacted.io%2Fon-let-vs-const%2F\"\u003eDiscuss on ùïè\u003c/a\u003e¬†¬†¬∑¬†¬†\u003ca target=\"_blank\" href=\"https://github.com/gaearon/overreacted.io/edit/main/public/on-let-vs-const/index.md\"\u003eEdit on GitHub\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": null,
  "modifiedTime": null
}
