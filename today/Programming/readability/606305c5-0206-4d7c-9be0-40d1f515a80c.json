{
  "id": "606305c5-0206-4d7c-9be0-40d1f515a80c",
  "title": "The So-fine Real-time ML Paradigm",
  "link": "https://www.etsy.com/codeascraft/the-so-fine-real-time-ml-paradigm?utm_source=OpenGraph\u0026utm_medium=PageTools\u0026utm_campaign=Share",
  "description": "Introduction Each year, Etsy hosts an event known as “CodeMosaic” - an internal hackathon in which Etsy admin propose and build bold advances quickly in our technology across a number of different themes. People across Etsy source ideas, organize into teams, and then have 2-3 days to build innovative proofs-of-concept that might deliver big wins for Etsy’s buyers and sellers, or improve internal engineering systems and workflows. Besides being a ton of fun, CodeMosaic is a time for engineers to pilot novel ideas. Our team’s project this year was extremely ambitious - we wanted to build a system for stateful machine learning (ML) model training and online machine learning. While our ML pipelines are no stranger to streaming data, we currently don’t have any models that learn in an online context - that is, that can have their weights updated in near-real time. Stateful training updates an already-trained ML model artifact incrementally, sparing the cost of retraining models from scratch. Online learning updates model weights in production rather than via batch processes. Combined, the two approaches can be extremely powerful. A study conducted by Grubhub in 2021 reported that a shift to stateful online learning saw up to a 45x reduction in costs with a 20% increase in metrics, and I’m all about saving money to make money. Day 1 - Planning Of course, building such a complex system would be no easy task. The ML pipelines we use to generate training data from user actions require a number of offline, scheduled batch jobs. As a result it takes quite a while, 40 hours at a minimum, for user actions to be reflected in a model’s weights. To make this project a success over the course of three days, we needed to scope our work tightly across three streams: Real-time training data - the task here was to circumvent the batch jobs responsible for our current training data and get attributions (user actions) right from the source. A service to consume the data stream and learn incrementally - today, we heavily leverage TensorFlow for model training. We needed to be able to load a model's weights into memory, read data from a stream, update that model, and incrementally push it out to be served online. Evaluation - we'd have to make a case for our approach by validating its performance benefits over our current batch processes. No matter how much we limited the scope it wasn't going to be easy, but we broke into three subteams reflecting each track of work and began moving towards implementation. Day 2 - Implementation The real-time training data team began by looking far upstream of the batch jobs that compute training data - at Etsy’s Beacon Main Kafka stream, which contains bot-filtered events. By using Kafka SQL and some real-time calls to our streaming feature platform, Rivulet, we figured we could put together a realistic approach to solving this part of the problem. Of course, as with all hackathon ideas it was easier said than done. Much of our feature data uses the binary avro data format for serialization, and finding the proper schema for deserializing and joining this data was troublesome. The team spent most of the second day munging the data in an attempt to join all the proper sources across platforms. And though we weren't able to write the output to a new topic, the team actually did manage to join multiple data sources in a way that generated real-time training data! Meanwhile the team focusing on building the consumer service to actually learn from the model faced a different kind of challenge: decision making. What type of model were we going to use? Knowing we weren’t going to be able to use the actual training data stream yet - how would we mock it? Where and how often should we push new model artifacts out? After significant discussion, we decided to try using an Ad Ranking model as we had an Ads ML engineer in our group and the Ads models take a long time to train - meaning we could squeeze a lot of benefit out of them by implementing continuous training. The engineers in the group began to structure code that pulled an older Ads model into memory and made incremental updates to the weights to satisfy the second requirement. That meant that all we had left to handle was the most challenging task - evaluation. None of this architecture would mean anything if a model that was trained online performed worse than the model retrained daily in batch. Evaluating a model with more training training periods is also more difficult, as each period we’d need to run the model on some held-out data in order to get an accurate reading without data leakage. Instead of performing an extremely laborious and time-intensive evaluation for continuous training like the one outlined above, we chose to have a bit more fun with it. After all, it was a hackathon! What if we made it a competition? Pick a single high-performing Etsy ad and see which surfaced it first, our continuously trained model or the boring old batch-trained one? We figured if we could get a continuously trained model to recommend a high-performing ad sooner, we’d have done the job! So we set about searching for a high-performing Etsy ad and training data that would allow us to validate our work. Of course, by the time we were even deciding on an appropriate advertised listing, it was the end of day two, and it was pretty clear the idea wasn’t going to play out before it was time for presentations. But still a fun thought, right? Presentation takeaways and impact Day 3 gives you a small window for tidying up work and slides, followed by team presentations. At this point, we loosely had these three things: Training data from much earlier in our batch processing pipelines A Kafka consumer that could almost update a TensorFlow model incrementally A few click attributions and data for a specific listing In the hackathon spirit, we phoned it in and pivoted towards focusing on the theoretical of what we’d been able to achieve! The 1st important potential area of impact was cost savings. We estimated that removing the daily “cold-start” training and replacing it with continuous training would save about $212K annually in Google Cloud costs for the 4 models in ads alone. This is a huge potential win - especially when coupled with the likely metrics gains coming from more reactive models. After all, if we were able to get events to models 40 hours earlier, who knows how much better our ranking could get! Future directions and conclusion Like many hackathon projects, there's no shortage of hurdles getting this work into a production state. Aside from the infrastructure required to actually architect a continuous-training pipeline, we’d need a significant number of high-quality checks and balances to ensure that updating models in real-time didn’t lead to sudden degradations in performance. The amount of development, number of parties involved, and the breadth of expertise to get this into production would surely be extensive. However, as ML continues to mature, we should be able to enable more complex architectures with less overhead.",
  "author": "Kyle Gallatin",
  "published": "Tue, 5 Sep 2023 15:55:41 -0400",
  "source": "https://codeascraft.com/feed/atom/",
  "categories": null,
  "byline": "By Kyle Gallatin Sep 5, 2023",
  "length": 7139,
  "excerpt": "Introduction Each year, Etsy hosts an event known as “CodeMosaic” - an internal hackathon in which Etsy admin propose and...",
  "siteName": "Etsy Engineering",
  "favicon": "",
  "text": "Introduction Each year, Etsy hosts an event known as “CodeMosaic” - an internal hackathon in which Etsy admin propose and build bold advances quickly in our technology across a number of different themes. People across Etsy source ideas, organize into teams, and then have 2-3 days to build innovative proofs-of-concept that might deliver big wins for Etsy’s buyers and sellers, or improve internal engineering systems and workflows. Besides being a ton of fun, CodeMosaic is a time for engineers to pilot novel ideas. Our team’s project this year was extremely ambitious - we wanted to build a system for stateful machine learning (ML) model training and online machine learning. While our ML pipelines are no stranger to streaming data, we currently don’t have any models that learn in an online context - that is, that can have their weights updated in near-real time. Stateful training updates an already-trained ML model artifact incrementally, sparing the cost of retraining models from scratch. Online learning updates model weights in production rather than via batch processes. Combined, the two approaches can be extremely powerful. A study conducted by Grubhub in 2021 reported that a shift to stateful online learning saw up to a 45x reduction in costs with a 20% increase in metrics, and I’m all about saving money to make money. Day 1 - Planning Of course, building such a complex system would be no easy task. The ML pipelines we use to generate training data from user actions require a number of offline, scheduled batch jobs. As a result it takes quite a while, 40 hours at a minimum, for user actions to be reflected in a model’s weights. To make this project a success over the course of three days, we needed to scope our work tightly across three streams: Real-time training data - the task here was to circumvent the batch jobs responsible for our current training data and get attributions (user actions) right from the source. A service to consume the data stream and learn incrementally - today, we heavily leverage TensorFlow for model training. We needed to be able to load a model's weights into memory, read data from a stream, update that model, and incrementally push it out to be served online. Evaluation - we'd have to make a case for our approach by validating its performance benefits over our current batch processes. No matter how much we limited the scope it wasn't going to be easy, but we broke into three subteams reflecting each track of work and began moving towards implementation. Day 2 - Implementation The real-time training data team began by looking far upstream of the batch jobs that compute training data - at Etsy’s Beacon Main Kafka stream, which contains bot-filtered events. By using Kafka SQL and some real-time calls to our streaming feature platform, Rivulet, we figured we could put together a realistic approach to solving this part of the problem. Of course, as with all hackathon ideas it was easier said than done. Much of our feature data uses the binary avro data format for serialization, and finding the proper schema for deserializing and joining this data was troublesome. The team spent most of the second day munging the data in an attempt to join all the proper sources across platforms. And though we weren't able to write the output to a new topic, the team actually did manage to join multiple data sources in a way that generated real-time training data! Meanwhile the team focusing on building the consumer service to actually learn from the model faced a different kind of challenge: decision making. What type of model were we going to use? Knowing we weren’t going to be able to use the actual training data stream yet - how would we mock it? Where and how often should we push new model artifacts out? After significant discussion, we decided to try using an Ad Ranking model as we had an Ads ML engineer in our group and the Ads models take a long time to train - meaning we could squeeze a lot of benefit out of them by implementing continuous training. The engineers in the group began to structure code that pulled an older Ads model into memory and made incremental updates to the weights to satisfy the second requirement. That meant that all we had left to handle was the most challenging task - evaluation. None of this architecture would mean anything if a model that was trained online performed worse than the model retrained daily in batch. Evaluating a model with more training training periods is also more difficult, as each period we’d need to run the model on some held-out data in order to get an accurate reading without data leakage. Instead of performing an extremely laborious and time-intensive evaluation for continuous training like the one outlined above, we chose to have a bit more fun with it. After all, it was a hackathon! What if we made it a competition? Pick a single high-performing Etsy ad and see which surfaced it first, our continuously trained model or the boring old batch-trained one? We figured if we could get a continuously trained model to recommend a high-performing ad sooner, we’d have done the job! So we set about searching for a high-performing Etsy ad and training data that would allow us to validate our work. Of course, by the time we were even deciding on an appropriate advertised listing, it was the end of day two, and it was pretty clear the idea wasn’t going to play out before it was time for presentations. But still a fun thought, right? Presentation takeaways and impact Day 3 gives you a small window for tidying up work and slides, followed by team presentations. At this point, we loosely had these three things: Training data from much earlier in our batch processing pipelines A Kafka consumer that could almost update a TensorFlow model incrementally A few click attributions and data for a specific listing In the hackathon spirit, we phoned it in and pivoted towards focusing on the theoretical of what we’d been able to achieve! The 1st important potential area of impact was cost savings. We estimated that removing the daily “cold-start” training and replacing it with continuous training would save about $212K annually in Google Cloud costs for the 4 models in ads alone. This is a huge potential win - especially when coupled with the likely metrics gains coming from more reactive models. After all, if we were able to get events to models 40 hours earlier, who knows how much better our ranking could get! Future directions and conclusion Like many hackathon projects, there's no shortage of hurdles getting this work into a production state. Aside from the infrastructure required to actually architect a continuous-training pipeline, we’d need a significant number of high-quality checks and balances to ensure that updating models in real-time didn’t lead to sudden degradations in performance. The amount of development, number of parties involved, and the breadth of expertise to get this into production would surely be extensive. However, as ML continues to mature, we should be able to enable more complex architectures with less overhead.",
  "image": "https://i.etsystatic.com/inv/78b1ef/5224274892/inv_fullxfull.5224274892_sxeupbst.jpg?version=0",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cdiv\u003e\n            \u003cp\u003e\u003cimg src=\"https://i.etsystatic.com/iusa/68eb7f/81771345/iusa_75x75.81771345_sw34.jpg?version=0\" alt=\"  image\" aria-label=\"  image\"/\u003e\n    \u003c/p\u003e\n\n\n    \u003c/div\u003e\n    \u003ch2\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEach year, Etsy hosts an event known as  “CodeMosaic” - an internal hackathon in which Etsy admin propose and build bold advances quickly in our technology across a number of different themes.  People across Etsy source ideas, organize into teams, and then have 2-3 days to build innovative proofs-of-concept that might deliver big wins for Etsy’s buyers and sellers, or improve internal engineering systems and workflows.\u003c/p\u003e\n\u003cp\u003eBesides being a ton of fun, CodeMosaic is a time for engineers to pilot novel ideas. Our team’s project this year was extremely ambitious - we wanted to build a system for stateful machine learning (ML) model training and online machine learning. While our ML pipelines are no stranger to streaming data, we currently don’t have any models that learn in an online context - that is, that can have their weights updated in near-real time.\u003c/p\u003e\n\u003cp\u003eStateful training updates an already-trained ML model artifact incrementally, sparing the cost of retraining models from scratch. \u003cem\u003eOnline learning\u003c/em\u003e updates model weights in production rather than via batch processes. Combined, the two approaches can be extremely powerful. \u003ca href=\"https://arxiv.org/abs/2107.07106\"\u003eA study conducted by Grubhub in 2021\u003c/a\u003e reported that a shift to stateful online learning saw up to a 45x reduction in costs with a 20% increase in metrics, and I’m all about saving money to make money.\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg alt=\"Stateful continuous retraining and online learning\" src=\"https://i.etsystatic.com/inv/d8a51b/5272462297/inv_fullxfull.5272462297_1e6jr1i2.jpg?version=0\" title=\"Stateful continuous retraining and online learning\"/\u003e\n\u003c/figure\u003e\n\u003ch2\u003eDay 1 - Planning\u003c/h2\u003e\n\u003cp\u003eOf course, building such a complex system would be no easy task. The ML pipelines we use to generate training data from user actions require a number of offline, scheduled batch jobs. As a result it takes quite a while, 40 hours at a minimum, for user actions to be reflected in a model’s weights.\u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg alt=\"current pipeline\" src=\"https://i.etsystatic.com/inv/0d445c/5272464395/inv_fullxfull.5272464395_mtgyerd2.jpg?version=0\" title=\"current pipeline\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eTo make this project a success over the course of three days, we needed to scope our work tightly across three streams:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eReal-time training data\u003c/strong\u003e - the task here was to circumvent the batch jobs responsible for our current training data and get attributions (user actions) right from the source.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eA service to consume the data stream and learn incrementally\u003c/strong\u003e - today, we heavily leverage TensorFlow for model training. We needed to be able to load a model\u0026#39;s weights into memory, read data from a stream, update that model, and incrementally push it out to be served online. \u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEvaluation\u003c/strong\u003e - we\u0026#39;d have to make a case for our approach by validating its performance benefits over our current batch processes. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNo matter how much we limited the scope it wasn\u0026#39;t going to be easy, but we broke into three subteams reflecting each track of work and began moving towards implementation.\u003c/p\u003e\n\u003ch2\u003eDay 2 - Implementation\u003c/h2\u003e\n\u003cp\u003eThe real-time training data team began by looking far upstream of the batch jobs that compute training data - at Etsy’s Beacon Main Kafka stream, which contains bot-filtered events. By using Kafka SQL and some real-time calls to our streaming feature platform, Rivulet, we figured we could put together a realistic approach to solving this part of the problem.\u003c/p\u003e\n\u003cp\u003eOf course, as with all hackathon ideas it was easier said than done. Much of our feature data uses the binary avro data format for serialization, and finding the proper schema for deserializing and joining this data was troublesome. The team spent most of the second day munging the data in an attempt to join all the proper sources across platforms. And though we weren\u0026#39;t able to write the output to a new topic, the team actually did manage to join multiple data sources in a way that generated real-time training data!\u003c/p\u003e\n\u003cp\u003eMeanwhile the team focusing on building the consumer service to actually learn from the model faced a different kind of challenge: decision making. What type of model were we going to use? Knowing we weren’t going to be able to use the actual training data stream yet - how would we mock it? Where and how often should we push new model artifacts out? \u003c/p\u003e\n\u003cp\u003eAfter significant discussion, we decided to try using an Ad Ranking model as we had an Ads ML engineer in our group and the Ads models take a long time to train - meaning we could squeeze a lot of benefit out of them by implementing continuous training. The engineers in the group began to structure code that pulled an older Ads model into memory and made incremental updates to the weights to satisfy the second requirement. \u003c/p\u003e\n\u003cp\u003eThat meant that all we had left to handle was the most challenging task - evaluation. None of this architecture would mean anything if a model that was trained online performed worse than the model retrained daily in batch. Evaluating a model with more training training periods is also more difficult, as each period we’d need to run the model on some held-out data in order to get an accurate reading without data leakage. \u003c/p\u003e\n\u003cfigure\u003e\n\u003cimg alt=\"oof\" src=\"https://i.etsystatic.com/inv/171da0/5224262572/inv_fullxfull.5224262572_694cztlm.jpg?version=0\" title=\"oof\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eInstead of performing an extremely laborious and time-intensive evaluation for continuous training like the one outlined above, we chose to have a bit more fun with it. After all, it was a hackathon! What if we made it a competition? Pick a single high-performing Etsy ad and see which surfaced it first, our continuously trained model or the boring old batch-trained one?\u003c/p\u003e\n\u003cp\u003eWe figured if we could get a continuously trained model to recommend a high-performing ad sooner, we’d have done the job! So we set about searching for a high-performing Etsy ad and training data that would allow us to validate our work. \u003c/p\u003e\n\u003cp\u003eOf course, by the time we were even deciding on an appropriate advertised listing, it was the end of day two, and it was pretty clear the idea wasn’t going to play out before it was time for presentations. But still a fun thought, right?\u003c/p\u003e\n\u003ch2\u003ePresentation takeaways and impact\u003c/h2\u003e\n\u003cp\u003eDay 3 gives you a small window for tidying up work and slides, followed by team presentations. At this point, we loosely had these three things:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTraining data from much earlier in our batch processing pipelines\u003c/li\u003e\n\u003cli\u003eA Kafka consumer that could almost update a TensorFlow model incrementally \u003c/li\u003e\n\u003cli\u003eA few click attributions and data for a specific listing\u003c/li\u003e\n\u003c/ol\u003e\n\u003cfigure\u003e\n\u003cimg alt=\"final product\" src=\"https://i.etsystatic.com/inv/b8e099/5272467237/inv_fullxfull.5272467237_68m5p29m.jpg?version=0\" title=\"final product\"/\u003e\n\u003c/figure\u003e\n\u003cp\u003eIn the hackathon spirit, we phoned it in and pivoted towards focusing on the theoretical of what we’d been able to achieve!\u003c/p\u003e\n\u003cp\u003eThe 1st important potential area of impact was cost savings. We estimated that removing the daily “cold-start” training and replacing it with continuous training would save about \u003cstrong\u003e$212K annually in Google Cloud costs\u003c/strong\u003e for the 4 models in ads alone.\u003c/p\u003e\n\u003cp\u003eThis is a huge potential win - especially when coupled with the likely metrics gains coming from more reactive models. After all, if we were able to get events to models 40 hours earlier, who knows how much better our ranking could get! \u003c/p\u003e\n\u003ch2\u003eFuture directions and conclusion\u003c/h2\u003e\n\u003cp\u003eLike many hackathon projects, there\u0026#39;s no shortage of hurdles getting this work into a production state. Aside from the infrastructure required to actually architect a continuous-training pipeline, we’d need a significant number of high-quality checks and balances to ensure that updating models in real-time didn’t lead to sudden degradations in performance. The amount of development, number of parties involved, and the breadth of expertise to get this into production would surely be extensive. However, as ML continues to mature, we should be able to enable more complex architectures with less overhead.\u003c/p\u003e\n    \n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2024-10-11T04:10:07Z",
  "modifiedTime": "2024-10-11T04:10:07Z"
}
