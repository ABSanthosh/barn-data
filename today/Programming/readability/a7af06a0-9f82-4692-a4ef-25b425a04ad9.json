{
  "id": "a7af06a0-9f82-4692-a4ef-25b425a04ad9",
  "title": "How Meta built large-scale cryptographic monitoring",
  "link": "https://engineering.fb.com/2024/11/12/security/how-meta-built-large-scale-cryptographic-monitoring/",
  "description": "Cryptographic monitoring at scale has been instrumental in helping our engineers understand how cryptography is used at Meta. Monitoring has given us a distinct advantage in our efforts to proactively detect and remove weak cryptographic algorithms and has assisted with our general change safety and reliability efforts. We’re sharing insights into our own cryptographic monitoring [...] Read More... The post How Meta built large-scale cryptographic monitoring appeared first on Engineering at Meta.",
  "author": "",
  "published": "Tue, 12 Nov 2024 17:00:10 +0000",
  "source": "https://engineering.fb.com/feed/",
  "categories": [
    "Security"
  ],
  "byline": "By Hussain Humadi, Sasha Frolov, Rafael Misoczki, Dong Wu",
  "length": 13985,
  "excerpt": "Cryptographic monitoring at scale has been instrumental in helping our engineers understand how cryptography is used at Meta. Monitoring has given us a distinct advantage in our efforts to proactiv…",
  "siteName": "Engineering at Meta",
  "favicon": "",
  "text": "Cryptographic monitoring at scale has been instrumental in helping our engineers understand how cryptography is used at Meta. Monitoring has given us a distinct advantage in our efforts to proactively detect and remove weak cryptographic algorithms and has assisted with our general change safety and reliability efforts. We’re sharing insights into our own cryptographic monitoring system, including challenges faced in its implementation, with the hope of assisting others in the industry aiming to deploy cryptographic monitoring at a similar scale. Meta’s managed cryptographic library, FBCrypto, plays an important role within Meta’s infrastructure and is used by the majority of our core infrastructure services. Given this, having a robust monitoring system in place for FBCrypto has been instrumental in ensuring its reliability as well as in helping our engineers understand how cryptography is used at Meta so they can make informed development decisions. Monitoring the health of our library allows us to detect and revert bugs before they reach production services. The data from our monitoring service provides insight into the usage of FBCrypto, allowing us to make data-driven decisions when deciding what improvements to make to the library. For example, it helps us identify components that need more attention either because they are on a hot path or are less stable. Understanding exactly how clients are using said library is a common pain point in managing any widely distributed library. But the improved understanding of FBCrypto provided by our monitoring helps us maintain a high bar for security posture. Since there is a limit to how much data a symmetric cryptographic key can protect, logging allows us to detect key overuse and rotate keys proactively. It also helps us build an inventory of cryptography usage, making it easy to identify the callsites of weakened algorithms that need to be migrated – a very important task because we need to proactively switch from weakened algorithms to newer, more robust ones as cryptography strength decays over time. More generally, improved understanding helps us to make emergency algorithm migrations when a vulnerability of a primitive is discovered. More recently, this is aiding our efforts to ensure post-quantum readiness in our asymmetric use cases. The available data improves our decision-making process while prioritizing quantum-vulnerable use cases Effective cryptographic monitoring requires storing persisted logs of cryptographic events, upon which diagnostic and analytic tools can be used to gather further insights. Supporting logging at the scale of FBCrypto requires an implementation with unique performance considerations in mind. Given that FBCrypto is used along many high-volume and critical code paths, a naive logging implementation could easily overwhelm a standard logging infrastructure or cause significant performance regressions. This is true for most widely distributed libraries and is especially true in the field of cryptography, where the sheer volume of usage can come as a complete surprise to those unfamiliar with the space. For example, we recently disclosed that roughly 0.05% of CPU cycles at Meta are spent on X25519 key exchange.  Most of Meta’s logs are constructed and written via Scribe, Meta’s standard logging framework. From there, data persists in Scuba and Hive, Meta’s short-term and long term data stores, respectively. Typically, the Scribe API is called directly to construct a log for every “event” that needs to be logged. For FBCrypto, this would mean constructing a log for nearly every cryptographic operation that our library is used for. Unfortunately, given the sheer frequency of such operations, a solution like this would consume an unreasonable amount of write throughput and storage capacity. A common solution to this problem would be to introduce sampling (i.e., only log 1/X cryptographic operations, and increase X until we no longer have capacity concerns). However, we felt strongly about not introducing any sampling since doing so would result in most logs being omitted, giving us a less clear picture of the library’s usage. Instead, the logging uses a “buffering and flushing” strategy, in which cryptographic events are aggregated across time and flushed to a data store at a preconfigured interval. During the aggregation, a “count” is maintained for every unique event. When it comes time to flush, this count is exported along with the log to convey how often that particular event took place. Below is a rough illustration of what this looks like: In the above example, the key named “myKeyName” is used to perform encryption using the AES-GCM-SIV encryption algorithm (in practice we log more fields than just key name, method, and algorithm). The operation happens five times and is assigned on a count of five. Since machines often compute millions of cryptographic operations per day, this strategy can lead to significant compute savings in production.  A client-side view The aggregation and flushing is implemented within FBCrypto, so the logging and flushing code sits on the client hosts. When clients call a given cryptographic operation (e.g., “encrypt()”), the operation is performed and the log is added to our aggregated buffer. We refer to the object that holds the buffer as the “buffered logger.” Note that the logging does not change the interface of FBCrypto, so all of this is transparent to the clients of the library.  In multithreaded environments all threads will log to the same buffer. For this to be performant, we need to choose the right underlying data structure (see the section below on “Additional optimizations” for more details). While the aggregation works to reduce space and time overhead, the logs need to eventually be written to storage for further use. To do this, a background thread runs on the client host to periodically call the Scribe API to export the logs and flush the map’s contents.  Below is an overview of the overall flow:  Additional optimizations We had to make some additional optimizations to support cryptographic monitoring on Meta’s major products (Facebook, Whatsapp, Instagram, etc.). With careful design choices around the logging logic and data structures used, our cryptographic logging operates with no sampling and has had a negligible impact on compute performance across Meta’s fleet. Partially randomized flushing Due to the nature of our buffering and flushing strategy, certain clients who were running jobs that restarted large sets of machines at around the same time would have those machines’ logs get flushed at about the same time. This would result in “spiky” writes to the logging platform, followed by longer periods of underutilization between flushes. To normalize our write throughput, we distribute these spikes across time by applying a randomized delay on a per-host basis before logs are flushed for the first time. This leads to a more uniform flushing cadence, allowing for a more consistent load on Scribe.  The figure below demonstrates how this works: Derived crypto FBCrypto supports a feature called derived crypto, which allows “child” keysets to be derived from “parent” keysets by applying a key derivation function (KDF) to all the keys in the keyset with some salt. This feature is used by a few large-scale use cases that need to generate millions of keys. Our logging initially created a unique row in the buffered logger for every derived keyset, which used a lot of space and put increased load on backend data stores. To address this, we now aggregate the cryptographic operations of derived keys under the name of the parent key. This reduces our overall capacity needs without harming our ability to detect key overuse since, in the worst case, the aggregations would be a pessimistic counter for any given child key.  Thanks to this aggregation, we were able to cut down on the vast majority of our logging volume, compared to the space that would have been used with no aggregation.  The Folly library  Internally, our buffering makes use of the folly::ConcurrentHashMap, which is built to be performant under heavy writes in multithreaded environments, while still guaranteeing atomic accesses.   Unified offerings Meta’s existing infrastructure and its emphasis on unified offerings are key to supporting this at scale (see the Scribe logging framework and the FBCrypto library). These properties often mean that solutions only have to be implemented once in order for the entire company to benefit. This is especially true here. Most machines in Meta’s fleet can log to Scribe, giving us easy log ingestion support. Furthermore, the wide adoption of FBCrypto gives us insights into cryptographic operations without needing clients to migrate to a new library/API.  From an engineering perspective, this helps us overcome many hurdles that others in the industry might face. For example, it helps us avoid fragmentation that might require multiple custom solutions to be implemented, which would increase our engineering workload. The impact of cryptographic monitoring The insights from our cryptographic monitoring efforts have served multiple use cases across our security and infrastructure reliability efforts. Preemptively mitigating security vulnerabilities Thanks to our long retention window, we can monitor trends over time and use them for more predictive modeling and analysis. We can present our findings to cryptography experts, who can do further analysis and predict whether vulnerabilities may emerge. This allows us to preemptively identify clients using cryptography in risky ways and work with them to mitigate these issues before they become real security vulnerabilities.  This is particularly beneficial in preparation for the world of post-quantum cryptography (PQC), which requires us to find clients using vulnerable algorithms and ensure they are migrated off in a timely fashion.  We have also found that being able to preemptively detect these vulnerabilities well in advance has led to stronger support during cross-team collaborations. Thanks to the ample notice, teams can seamlessly integrate any necessary migration efforts into their roadmap with minimal interruption to their ongoing projects. Promoting infrastructure reliability Our root dataset has also served as a useful proxy for client health. This is partially thanks to the lack of sampling, as we can see the exact number of calls taking place, along with their respective success rates. This has been particularly important during large-scale migrations, where anomalous drops in success rate, call volume, etc., may indicate a bug in a new code path. Indeed, numerous detectors and alarms have been built off our dataset to help us perform big migrations safely. The dataset also contains library versioning information, so we can monitor what versions of our library are running across the fleet in real-time. This has been especially useful for rolling out new features, as we can see exactly which clients have picked up the latest changes. This allows us to move faster and more confidently, even when running large-scale migrations across the fleet.  Challenges to cryptographic monitoring Supporting cryptographic logging at Meta’s scale has had its own unique set of challenges. Capacity constraints Despite our optimizations, we have occasionally found ourselves putting increased load on Scribe (see point above about underestimating cryptographic usage) and have worked with the Scribe team to manage the unexpected increase in write throughput. Doing so has been relatively easy for the company, considering the design optimizations mentioned above. We also occasionally put an increased load on Scuba, which is optimized to be performant for real-time data (i.e., warm storage) and can be inefficient if used for larger datasets. To minimize compute costs, we also rely on Hive tables for longer-term storage (i.e., cold storage).  Flushing on shutdown Besides flushing the logs in the shared singleton map at a preconfigured time interval, client machines will also do one final flush to log all remaining contents of their log buffer to Scribe when a job is being shut down. We have found that operating in a “shutdown environment” can lead to a number of interesting scenarios, particularly when attempting to access Scribe and its dependencies. Many of these scenarios boil down to the nuances of folly::Singleton, which is Meta’s go-to library for managing singletons. Likewise, running something “on shutdown” in Java requires using only synchronous I/O code and operating quickly. Our next initiatives for cryptographic monitoring While our work thus far has been largely a success, there are many exciting avenues for improvements. For example, further optimizing Scribe throughput and Scuba storage utilization to make more efficient use of Meta’s infrastructure   We will also continue to leverage the logging data to further develop monitoring and data analytics to promote security and reliability. On the security side, this means continuing to take an inventory of use cases that would be vulnerable in a PQC world and migrate them to more resilient algorithms/configurations. In terms of reliability, it means gaining a better understanding of the end-to-end latency for cryptography use cases. Within all of this it’s also important that we continue driving the unification of cryptographic offerings and monitoring tooling. While FBCrypto provides a unified set of offerings, there are other cryptographic use cases across Meta that use a different set of tools for telemetry and data collection. More non-trivial work is needed to achieve full unification with all use cases. Acknowledgments This work could not have been accomplished without the critical efforts of numerous folks, particularly Grace Wu, Ilya Maykov, Isaac Elbaz, and the rest of the CryptoEng team at Meta.",
  "image": "https://engineering.fb.com/wp-content/uploads/2024/11/Eng-Blog-Self-Serve-Hero-Images-PRIVACY-103-Teale-x2_small.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\u003cul\u003e\n\u003cli aria-level=\"1\"\u003e\u003cspan\u003eCryptographic monitoring at scale has been instrumental in helping our engineers understand how cryptography is used at Meta.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cspan\u003eMonitoring has given us a distinct advantage in our efforts to proactively detect and remove weak cryptographic algorithms and has assisted with our general change safety and reliability efforts.\u003c/span\u003e\u003c/li\u003e\n\u003cli aria-level=\"1\"\u003e\u003cspan\u003eWe’re sharing insights into our own cryptographic monitoring system, including challenges faced in its implementation, with the hope of assisting others in the industry aiming to deploy cryptographic monitoring at a similar scale.\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cspan\u003eMeta’s managed cryptographic library, FBCrypto, plays an important role within Meta’s infrastructure and is used by the majority of our core infrastructure services. Given this, having a robust monitoring system in place for FBCrypto has been instrumental in ensuring its reliability as well as in helping our engineers understand how cryptography is used at Meta so they can make informed development decisions.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMonitoring the health of our library allows us to detect and revert bugs before they reach production services. The data from our monitoring service provides insight into the usage of FBCrypto, allowing us to make data-driven decisions when deciding what improvements to make to the library. For example, it helps us identify components that need more attention either because they are on a hot path or are less stable.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eUnderstanding exactly how clients are using said library is a common pain point in managing any widely distributed library. But the improved understanding of FBCrypto provided by our monitoring helps us maintain a high bar for security posture. Since there is a limit to how much data a symmetric cryptographic key can protect, logging allows us to detect key overuse and rotate keys proactively. It also helps us build an inventory of cryptography usage, making it easy to identify the callsites of weakened algorithms that need to be migrated – a very important task because we need to proactively switch from weakened algorithms to newer, more robust ones as cryptography strength decays over time.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMore generally, improved understanding helps us to make emergency algorithm migrations when a vulnerability of a primitive is discovered.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMore recently, this is aiding our efforts to ensure\u003c/span\u003e \u003ca href=\"https://engineering.fb.com/2024/05/22/security/post-quantum-readiness-tls-pqr-meta/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003epost-quantum readiness\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e in our asymmetric use cases. The available data improves our decision-making process while prioritizing quantum-vulnerable use cases\u003c/span\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cspan\u003eEffective cryptographic monitoring requires storing persisted logs of cryptographic events, upon which diagnostic and analytic tools can be used to gather further insights. Supporting logging at the scale of FBCrypto requires an implementation with unique performance considerations in mind. Given that FBCrypto is used along many high-volume and critical code paths, a naive logging implementation could easily overwhelm a standard logging infrastructure or cause significant performance regressions. This is true for most widely distributed libraries and is especially true in the field of cryptography, where the sheer volume of usage can come as a complete surprise to those unfamiliar with the space. For example, we recently disclosed that roughly 0.05% of CPU cycles at Meta are spent on X25519 key exchange. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eMost of Meta’s logs are constructed and written via\u003c/span\u003e \u003ca href=\"https://engineering.fb.com/2019/10/07/core-infra/scribe/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eScribe\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, Meta’s standard logging framework. From there, data persists in\u003c/span\u003e \u003ca href=\"https://research.facebook.com/publications/scuba-diving-into-data-at-facebook/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eScuba\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e and\u003c/span\u003e \u003ca href=\"https://research.facebook.com/publications/hive-a-warehousing-solution-over-a-map-reduce-framework/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eHive\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, Meta’s short-term and long term data stores, respectively.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTypically, the Scribe API is called directly to construct a log for every “event” that needs to be logged. For FBCrypto, this would mean constructing a log for nearly every cryptographic operation that our library is used for. Unfortunately, given the sheer frequency of such operations, a solution like this would consume an unreasonable amount of write throughput and storage capacity. A common solution to this problem would be to introduce sampling (i.e., only log 1/X cryptographic operations, and increase X until we no longer have capacity concerns). However, we felt strongly about not introducing any sampling since doing so would result in most logs being omitted, giving us a less clear picture of the library’s usage.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eInstead, the logging uses a “buffering and flushing” strategy, in which cryptographic events are aggregated across time and flushed to a data store at a preconfigured interval.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eDuring the aggregation, a “count” is maintained for every unique event. When it comes time to flush, this count is exported along with the log to convey how often that particular event took place. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eBelow is a rough illustration of what this looks like:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-1-e1731001505528.png?w=859\" alt=\"\" width=\"600\" height=\"450\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIn the above example, the key named “myKeyName” is used to perform encryption using the AES-GCM-SIV encryption algorithm (in practice we log more fields than just key name, method, and algorithm). The operation happens five times and is assigned on a count of five. Since machines often compute millions of cryptographic operations per day, this strategy can lead to significant compute savings in production. \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eA client-side view\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eThe aggregation and flushing is implemented within FBCrypto, so the logging and flushing code sits on the client hosts. When clients call a given cryptographic operation (e.g., “encrypt()”), the operation is performed and the log is added to our aggregated buffer. We refer to the object that holds the buffer as the “buffered logger.”\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eNote that the logging does not change the interface of FBCrypto, so all of this is transparent to the clients of the library. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?w=939\" alt=\"\" width=\"600\" height=\"338\" srcset=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png 939w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=580,326 580w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=916,516 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=768,433 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=96,54 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-2-e1731001623468.png?resize=192,108 192w\" sizes=\"(max-width: 992px) 100vw, 62vw\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eIn multithreaded environments all threads will log to the same buffer. For this to be performant, we need to choose the right underlying data structure (see the section below on \u003c/span\u003e\u003ci\u003e\u003cspan\u003e“Additional optimizations”\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e for more details).\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWhile the aggregation works to reduce space and time overhead, the logs need to eventually be written to storage for further use. To do this, a background thread runs on the client host to periodically call the Scribe API to export the logs and flush the map’s contents. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eBelow is an overview of the overall flow: \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?w=1024\" alt=\"\" width=\"600\" height=\"520\" srcset=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png 1478w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=916,793 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=768,665 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=1024,887 1024w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=96,83 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-3-cropped.png?resize=192,166 192w\" sizes=\"auto, (max-width: 992px) 100vw, 62vw\"/\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eAdditional optimizations\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eWe had to make some additional optimizations to support cryptographic monitoring on Meta’s major products (Facebook, Whatsapp, Instagram, etc.).\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWith careful design choices around the logging logic and data structures used, our cryptographic logging operates with \u003c/span\u003e\u003cb\u003eno sampling \u003c/b\u003e\u003cspan\u003eand has had a negligible impact on compute performance across Meta’s fleet.\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003ePartially randomized flushing\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eDue to the nature of our buffering and flushing strategy, certain clients who were running jobs that restarted large sets of machines at around the same time would have those machines’ logs get flushed at about the same time. This would result in “spiky” writes to the logging platform, followed by longer periods of underutilization between flushes. To normalize our write throughput, we distribute these spikes across time by applying a randomized delay on a per-host basis before logs are flushed for the first time. This leads to a more uniform flushing cadence, allowing for a more consistent load on Scribe. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe figure below demonstrates how this works:\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?w=1024\" alt=\"\" width=\"1024\" height=\"388\" srcset=\"https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png 1999w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=916,347 916w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=768,291 768w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=1024,388 1024w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=1536,582 1536w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=96,36 96w, https://engineering.fb.com/wp-content/uploads/2024/11/Cryptographic-monitoring_Meta-4.png?resize=192,73 192w\" sizes=\"auto, (max-width: 992px) 100vw, 62vw\"/\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003eDerived crypto\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eFBCrypto supports a feature called derived crypto, which allows “child” keysets to be derived from “parent” keysets by applying a key derivation function (KDF) to all the keys in the keyset with some salt. This feature is used by a few large-scale use cases that need to generate millions of keys.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eOur logging initially created a unique row in the buffered logger for every derived keyset, which used a lot of space and put increased load on backend data stores. To address this, we now aggregate the cryptographic operations of derived keys under the name of the parent key. This reduces our overall capacity needs without harming our ability to detect key overuse since, in the worst case, the aggregations would be a pessimistic counter for any given child key. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThanks to this aggregation, we were able to cut down on the vast majority of our logging volume, compared to the space that would have been used with no aggregation. \u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan\u003eThe Folly library \u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cspan\u003eInternally, our buffering makes use of the\u003c/span\u003e \u003ca href=\"https://github.com/facebook/folly/blob/main/folly/concurrency/ConcurrentHashMap.h\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003efolly::ConcurrentHashMap\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, which is built to be performant under heavy writes in multithreaded environments, while still guaranteeing atomic accesses.  \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eUnified offerings\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eMeta’s existing infrastructure and its emphasis on unified offerings are key to supporting this at scale (see the\u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2019/10/07/core-infra/scribe/\"\u003e \u003cspan\u003eScribe\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e logging framework and the FBCrypto library). These properties often mean that solutions only have to be implemented once in order for the entire company to benefit.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis is especially true here. Most machines in Meta’s fleet can log to Scribe, giving us easy log ingestion support. Furthermore, the wide adoption of FBCrypto gives us insights into cryptographic operations without needing clients to migrate to a new library/API. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eFrom an engineering perspective, this helps us overcome many hurdles that others in the industry might face. For example, it helps us avoid fragmentation that might require multiple custom solutions to be implemented, which would increase our engineering workload.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eThe impact of cryptographic monitoring\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThe insights from our cryptographic monitoring efforts have served multiple use cases across our security and infrastructure reliability efforts.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003ePreemptively mitigating security vulnerabilities\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eThanks to our long retention window, we can monitor trends over time and use them for more predictive modeling and analysis. We can present our findings to cryptography experts, who can do further analysis and predict whether vulnerabilities may emerge. This allows us to preemptively identify clients using cryptography in risky ways and work with them to mitigate these issues before they become real security vulnerabilities. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThis is particularly beneficial in preparation for the world of\u003c/span\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Post-quantum_cryptography\"\u003e \u003cspan\u003epost-quantum cryptography\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e (PQC), which requires us to find clients using vulnerable algorithms and ensure they are migrated off in a timely fashion. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe have also found that being able to preemptively detect these vulnerabilities well in advance has led to stronger support during cross-team collaborations. Thanks to the ample notice, teams can seamlessly integrate any necessary migration efforts into their roadmap with minimal interruption to their ongoing projects.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003ePromoting infrastructure reliability\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eOur root dataset has also served as a useful proxy for client health. This is partially thanks to the lack of sampling, as we can see the exact number of calls taking place, along with their respective success rates. This has been particularly important during large-scale migrations, where anomalous drops in success rate, call volume, etc., may indicate a bug in a new code path. Indeed, numerous detectors and alarms have been built off our dataset to help us perform big migrations safely.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eThe dataset also contains library versioning information, so we can monitor what versions of our library are running across the fleet in real-time. This has been especially useful for rolling out new features, as we can see exactly which clients have picked up the latest changes. This allows us to move faster and more confidently, even when running large-scale migrations across the fleet. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eChallenges to cryptographic monitoring\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eSupporting cryptographic logging at Meta’s scale has had its own unique set of challenges.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eCapacity constraints\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eDespite our optimizations, we have occasionally found ourselves putting increased load on Scribe (see point above about underestimating cryptographic usage) and have worked with the Scribe team to manage the unexpected increase in write throughput. Doing so has been relatively easy for the company, considering the design optimizations mentioned above.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe also occasionally put an increased load on\u003c/span\u003e \u003ca href=\"https://research.facebook.com/publications/scuba-diving-into-data-at-facebook/\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eScuba\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, which is optimized to be performant for real-time data (i.e., warm storage) and can be inefficient if used for larger datasets. To minimize compute costs, we also rely on\u003c/span\u003e\u003ca href=\"https://research.facebook.com/publications/hive-a-warehousing-solution-over-a-map-reduce-framework/\"\u003e \u003cspan\u003eHive\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e tables for longer-term storage (i.e., cold storage). \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eFlushing on shutdown\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eBesides flushing the logs in the shared singleton map at a preconfigured time interval, client machines will also do one final flush to log all remaining contents of their log buffer to Scribe when a job is being shut down. We have found that operating in a “shutdown environment” can lead to a number of interesting scenarios, particularly when attempting to access Scribe and its dependencies. Many of these scenarios boil down to the nuances of\u003c/span\u003e\u003ca href=\"https://github.com/facebook/folly/blob/main/folly/Singleton.h\"\u003e \u003cspan\u003efolly::Singleton\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e, which is Meta’s go-to library for managing singletons. Likewise, running something “on shutdown” in Java requires using only synchronous I/O code and operating quickly.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eOur next initiatives for cryptographic monitoring\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eWhile our work thus far has been largely a success, there are many exciting avenues for improvements. For example, further optimizing Scribe throughput and Scuba storage utilization to make more efficient use of Meta’s infrastructure  \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWe will also continue to leverage the logging data to further develop monitoring and data analytics to promote security and reliability. On the security side, this means continuing to take an inventory of use cases that would be vulnerable in a PQC world and migrate them to more resilient algorithms/configurations. In terms of reliability, it means gaining a better understanding of the end-to-end latency for cryptography use cases.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eWithin all of this it’s also important that we continue driving the unification of cryptographic offerings and monitoring tooling. While FBCrypto provides a unified set of offerings, there are other cryptographic use cases across Meta that use a different set of tools for telemetry and data collection. More non-trivial work is needed to achieve full unification with all use cases.\u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eAcknowledgments\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ci\u003e\u003cspan\u003eThis work could not have been accomplished without the critical efforts of numerous folks, particularly Grace Wu, Ilya Maykov, Isaac Elbaz, and the rest of the CryptoEng team at Meta.\u003c/span\u003e\u003c/i\u003e\u003c/p\u003e\n\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2024-11-12T17:00:10Z",
  "modifiedTime": "2024-11-12T18:19:36Z"
}
