{
  "id": "1ec479f3-5091-4cd4-83cb-c8081a2a8f4b",
  "title": "Building Custom Tooling with LLMs",
  "link": "https://martinfowler.com/articles/exploring-gen-ai/16-building-custom-tooling-with-llms.html",
  "description": "",
  "author": "",
  "published": "2025-05-14T10:10:00-04:00",
  "source": "https://martinfowler.com/feed.atom",
  "categories": null,
  "byline": "Unmesh Joshi",
  "length": 20729,
  "excerpt": "Notes from my Thoughtworks colleagues on AI-assisted software delivery",
  "siteName": "martinfowler.com",
  "favicon": "",
  "text": "Tools that treat diagrams as code, such as PlantUML, are invaluable for communicating complex system behavior. Their text-based format simplifies versioning, automation, and evolving architectural diagrams alongside code. In my work explaining distributed systems, PlantUML's sequence diagrams are particularly useful for capturing interactions precisely. However, I often wished for an extension to walk through these diagrams step-by-step, revealing interactions sequentially rather than showing the entire complex flow at once—like a slideshow for execution paths. This desire reflects a common developer scenario: wanting personalized extensions or internal tools for their own needs. Yet, extending established tools like PlantUML often involves significant initial setup—parsing hooks, build scripts, viewer code, packaging—enough “plumbing” to deter rapid prototyping. The initial investment required to begin can suppress good ideas. This is where Large Language Models (LLMs) prove useful. They can handle boilerplate tasks, freeing developers to focus on design and core logic. This article details how I used an LLM to build PlantUMLSteps, a small extension adding step-wise playback to PlantUML sequence diagrams. The goal isn't just the tool itself, but illustrating the process how syntax design, parsing, SVG generation, build automation, and an HTML viewer were iteratively developed through a conversation with an LLM, turning tedious tasks into manageable steps. Diagram as code - A PlantUML primer Before diving into the development process, let's briefly introduce PlantUML for those who might be unfamiliar. PlantUML is an open-source tool that allows you to create UML diagrams from a simple text-based description language. It supports various diagram types including sequence, class, activity, component, and state diagrams. The power of PlantUML lies in its ability to version control diagrams as plain text, integrate with documentation systems, and automate diagram generation within development pipelines. This is particularly valuable for technical documentation that needs to evolve alongside code. Here's a simple example of a sequence diagram in PlantUML syntax: @startuml hide footbox actor User participant System participant Database User -\u003e System: Login Request System --\u003e User: Login Form User -\u003e System: Submit Credentials System -\u003e Database: Verify Credentials Database --\u003e System: Validation Result System --\u003e User: Authentication Result User -\u003e System: Request Dashboard System -\u003e Database: Fetch User Data Database --\u003e System: User Data System --\u003e User: Dashboard View @enduml When processed by PlantUML, this text generates a visual sequence diagram showing the interaction between components. The code-like nature of PlantUML makes it easy to learn and use, especially for developers who are already comfortable with text-based tools. This simplicity is what makes PlantUML a perfect candidate for extension. With the right tooling, we can enhance its capabilities while maintaining its text-based workflow. Our goal for this project is to create a tool which can divide the sequence diagram into steps and generate a step by step view of the diagram. So for the above diagram, we should be able to view login, authentication and dashboard steps one by one. Step 2: Building the Parser Logic (and Debugging) “Now we need to parse the plantuml files and separate out step. Whenever we encounter a step marker, we create a step object and keep adding the next lines to it until we encounter another step marker or end of file. In case we encounter another step counter, we create new step object, it should have all the includes, actors and participants from the previous step. It should also have all the content of the previous step, unless the step metadata has 'newPage' attribute. If there are no step markers encountered, which is the case where we have files without steps, it should create a default step. Create a StepParser to parse given puml files and create list of steps.” Claude generated the initial code for a StepParser class and a Step model class to handle parsing PlantUML files with step markers. The initial implementation had some logical issues: Incorrect handling of step content inheritance when newPage attribute was false Improper handling of declarations (actors, participants) appearing before the first step marker Issues with creating a default step for files without markers The Cursor editor was running in Agent mode, so after running tests and identifying these issues through the failure messages, Claude provided a corrected version that properly handled: Content collected before the first step marker Inheritance of content from the immediately preceding step Global tracking of declarations across steps Proper creation of a default step for files without markers With these corrections, the parser successfully passed all tests. The next step was to generate a gradle task. We need gradle task which can process puml files in src/diagrams and its sub folders. For each file it should create a directory with the name of the file where it generates valid puml file for each step. It can generate that by just adding @startuml at the start and @enduml at the end of the step content. I'll help you create a Gradle task to process PlantUML files and generate step-by-step diagrams. First, let's create the task in build.gradle: // Process each .puml file in the input directory and its subdirectories fileTree(inputDir).include('**/*.puml').each { pumlFile -\u003e def relativePath = inputDir.toPath().relativize(pumlFile.toPath()).toString() def fileName = pumlFile.name.replace('.puml', '') def stepOutputDir = new File(outputDir, fileName) if (!stepOutputDir.exists()) { stepOutputDir.mkdirs() } // Run the generator for this file javaexec { classpath = sourceSets.main.runtimeClasspath mainClass = 'com.example.StepDiagramGenerator' args = [pumlFile.absolutePath, stepOutputDir.absolutePath] } Claude also helped generating a simple plantuml sequence diagram to test the gradle task. The same one that we used at the beginning of the article. The gradle task needed a class PlantUMLGenerator which can generate SVGs for each step. Cursor in the Agent mode generated the code for the class. It then ran the build to verify the task. Let's run a test to confirm our implementation works: cd /Users/unmeshjoshi/work/plantumlsequence \u0026\u0026 ./gradlew clean build Task :generateStepDiagrams Generated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-01-step-1-user-login.puml Generated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-02-step-2-authentication.puml Generated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-03-step-3-dashboard.puml Generated step flow summary: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/summary.puml BUILD SUCCESSFUL in 543ms 3 actionable tasks: 3 executed Step 3: Generating HTML Viewer for Step Sequence The next step was to generate a simple HTML viewer that can be used to view the step sequence. Now we need to generate a HTML viewer for the step files to be shown one by one. The HTML viewer can have a view area where we show the svg image generated for each step with the step name in the metadata for that step. We can have next and previous buttons to show next and previous step image. I'll help you create an HTML viewer for the step diagrams. We'll need to: Generate SVG files from the PlantUML files Create an HTML viewer with navigation controls Update the Gradle task to generate both PlantUML and SVG files, along with the HTML viewer First, let's create a simple HTML template for the viewer: .... The agent mode figured out a few issues with the template but auto-fixed it by running some corrective actions. This setup allowed us to quickly generate step diagrams from a single PlantUML file, and view them in a step by step manner. So the above diagram can be viewed as a sequence of following steps: The Code is the Source of Truth Where to go from here? While the prompts and the LLM assistant (in this case, interacting in an agent-like mode, utilizing models like Claude Sonnet) provided a remarkably effective way to generate a working first version of PlantUMLSteps, it's crucial to recognize the nature of this generated output. Prompts are not Deterministic: The prompts used in our conversation were effective for this interaction, but they cannot be treated as the ultimate 'source of truth'. The same prompts given to a different model, or even the same model at a later date, are not guaranteed to produce the exact same output due to the inherent variability in LLM generation. Code Requires Management: The generated code is the source of truth for the tool's functionality. As such, it needs to be treated like any other software artifact - checked into version control, reviewed, tested, and maintained. Review for Habitability: It's essential to revisit the LLM-generated code after the initial creation phase. Is it 'habitable'? That is, is it reasonably easy to read, understand, and modify by a human developer? While the LLM helped overcome initial hurdles and boilerplate, ensuring the long-term maintainability and clarity of the codebase often requires human review and potential refactoring. The goal is code that not only works but can also be evolved effectively over time. Prompting in natural language (like English) to generate code works well in the early phases of development—when you're exploring ideas, scaffolding functionality, or getting familiar with a new tool or framework. But as your system starts to take shape, the limits of vague or broad prompts become apparent. At this stage, what's needed is not more code generation, but conceptual modeling—using the constructs of your programming language or technology stack to accurately represent the domain. This stage needs deeper thinking to build abstractions, and an alignment between code structure and domain concepts—something only achievable through thoughtful design, not just prompting. If prompt-based code generation without review is called “vibe coding,” then the more disciplined approach can be called “AI-assisted structured coding.”. Beyond Code Generation: The Developer Insight in Refactoring The next step was to refactor the code to make it more readable and maintainable. Initially, the parse method was a long, monolithic function that handled everything from detecting step markers to managing declarations and content. The code was difficult to understand and maintain. The full code is available in this initial commit on GitHub. The `StepParser.java` parse method needs refactoring. It should represent concepts used in the requirement or domain concepts and follow standard clean code practices with intentional method names and code that reads like a DSL. This initial request was open-ended, indicating that the developer recognized the need for improvement but was looking for guidance on how to approach it. The LLM responded with a comprehensive refactoring that introduced several new classes and methods: - Introduced `PlantUmlDocument` to represent the document being parsed - Smaller, more focused methods with intention-revealing names - Better encapsulation of related behaviors - More expressive variable and method names /** * Represents a PlantUML document being parsed, managing state during parsing */ private class PlantUmlDocument { private final List steps = new ArrayList\u003c\u003e(); private final List declarations = new ArrayList\u003c\u003e(); private final List contentBeforeFirstStep = new ArrayList\u003c\u003e(); private Step currentStep = null; private boolean hasStepMarkers = false; public void beginNewStep(StepMetadata metadata) { hasStepMarkers = true; // Save the current step if it exists if (currentStep != null) { steps.add(currentStep); } // Create a new step currentStep = new Step(metadata.getName(), metadata.isNewPage(), metadata.getAttributes()); // Add all declarations to the new step currentStep.addAllDeclarations(declarations); // If this isn't a new page and we have previous steps, copy all content from previous steps if (!metadata.isNewPage() \u0026\u0026 !steps.isEmpty()) { carryOverPreviousStepsContent(); } } private void carryOverPreviousStepsContent() { for (Step previousStep : steps) { for (String contentLine : previousStep.getContent()) { currentStep.addContent(contentLine); } } } public void addDeclaration(String line) { declarations.add(line); if (currentStep != null) { currentStep.addDeclaration(line); } else { contentBeforeFirstStep.add(line); } } public void addContentLine(String line) { if (currentStep != null) { currentStep.addContent(line); } else if (!line.trim().isEmpty()) { contentBeforeFirstStep.add(line); } } public void finalizeDocument() { // Add the last step if it exists and hasn't been added yet if (currentStep != null) { steps.add(currentStep); } } The full code is available in this commit on GitHub. The `contentBeforeFirstStep` in `PlantUmlDocument.java` is used only for creating default step when there are no step markers? So we can possibly do two pass processing where we first check if there are step markers.. if there are.. we do step-based processing. Or else we just create a default step and add all declarations and content. That will remove the need to have `contentBeforeFirstStep` We can also possibily name PlantUmlDocument as `ParsedPumlFile` which represents the parsed puml file. The LLM implemented this suggestion with a two-pass approach. It also renamed the PlantUmlDocument as ParsedPumlFile. The full code is available in this commit on GitHub. `ParsedPumlFile` can be better represented as builder pattern. `StepBuilder` can be a builder for `Step` objects. This insight demonstrated the developer's ability to recognize design patterns, noting that the refactored class followed the Builder pattern. The final refactoring represents a significant improvement over the original code: class StepBuilder { private final List\u003cStep\u003e steps = new ArrayList\u003c\u003e(); private final List\u003cString\u003e globalDeclarations = new ArrayList\u003c\u003e(); private Step currentStep = null; public void startNewStep(StepMetadata metadata) { if (currentStep != null) { steps.add(currentStep); } currentStep = new Step(metadata); currentStep.addAllDeclarations(globalDeclarations); if (!metadata.isNewPage() \u0026\u0026 !steps.isEmpty()) { // Copy content from the previous step Step previousStep = steps.get(steps.size() - 1); for (String contentLine : previousStep.getContent()) { currentStep.addContent(contentLine); } } } public void addDeclaration(String declaration) { globalDeclarations.add(declaration); if (currentStep != null) { currentStep.addDeclaration(declaration); } } public void addContent(String content) { // If no step has been started yet, create a default step if (currentStep == null) { StepMetadata metadata = new StepMetadata(\"Default Step\", false, new HashMap\u003c\u003e()); startNewStep(metadata); } currentStep.addContent(content); } public List\u003cStep\u003e build() { if (currentStep != null) { steps.add(currentStep); } return new ArrayList\u003c\u003e(steps); } } The full code is available in this commit on GitHub. There are more improvements possible, but I have included a few to demonstrate the nature of collaboration between LLMs and developers. Conclusion Each part of this extension—comment syntax, Java parsing logic, HTML viewer, and Gradle wiring—started with a focused LLM prompt. Some parts required some expert developer guidance to LLM, but the key benefit was being able to explore and validate ideas without getting bogged down in boilerplate. LLMs are particularly helpful when you have a design in mind but are not getting started because of the efforts needed for setting up the scaffolding to try it out. They can help you generate working glue code, integrate libraries, and generate small UIs—leaving you to focus on whether the idea itself works. After the initial working version, it was important to have a developer to guide the LLM to improve the code, to make it more maintainable. It was critical for developers to: Ask insightful questions Challenge proposed implementations Suggest alternative approaches Apply software design principles This collaboration between the developer and the LLM is key to building maintainable and scalable systems. The LLM can help generate working code, but the developer is the one who can make it more readable, maintainable and scalable.",
  "image": "https://martinfowler.com/articles/exploring-gen-ai/donkey-card.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\n\u003cp\u003eTools that treat diagrams as code, such as PlantUML, are invaluable for communicating\n            complex system behavior. Their text-based format simplifies versioning, automation, and\n            evolving architectural diagrams alongside code. In my work explaining distributed\n            systems, PlantUML\u0026#39;s sequence diagrams are particularly useful for capturing interactions\n            precisely.\u003c/p\u003e\n\n\u003cp\u003eHowever, I often wished for an extension to walk through these diagrams step-by-step,\n            revealing interactions sequentially rather than showing the entire complex flow at\n            once—like a slideshow for execution paths. This desire reflects a common developer\n            scenario: wanting personalized extensions or internal tools for their own needs.\u003c/p\u003e\n\n\u003cp\u003eYet, extending established tools like PlantUML often involves significant initial\n            setup—parsing hooks, build scripts, viewer code, packaging—enough “plumbing” to\n            deter rapid prototyping. The initial investment required to begin can suppress good\n            ideas.\u003c/p\u003e\n\n\u003cp\u003eThis is where Large Language Models (LLMs) prove useful. They can handle boilerplate\n            tasks, freeing developers to focus on design and core logic. This article details how I\n            used an LLM to build \u003ccode\u003ePlantUMLSteps\u003c/code\u003e, a small extension adding step-wise\n            playback to PlantUML sequence diagrams. The goal isn\u0026#39;t just the tool itself, but\n            illustrating the process how syntax design, parsing, SVG generation, build automation,\n            and an HTML viewer were iteratively developed through a conversation with an LLM,\n            turning tedious tasks into manageable steps.\u003c/p\u003e\n\n\u003csection id=\"DiagramAsCode-APlantumlPrimer\"\u003e\n\u003ch2\u003eDiagram as code - A PlantUML primer\u003c/h2\u003e\n\n\u003cp\u003eBefore diving into the development process, let\u0026#39;s briefly introduce PlantUML\n                for those who might be unfamiliar. PlantUML is an open-source tool that allows\n                you to create UML diagrams from a simple text-based description language. It\n                supports\n                various diagram types including sequence, class, activity, component, and state\n                diagrams.\u003c/p\u003e\n\n\u003cp\u003eThe power of PlantUML lies in its ability to version control diagrams\n                as plain text, integrate with documentation systems, and automate diagram\n                generation within development pipelines. This is particularly valuable for\n                technical documentation that needs to evolve alongside code.\u003c/p\u003e\n\n\u003cp\u003eHere\u0026#39;s a simple example of a sequence diagram in PlantUML syntax:\u003c/p\u003e\n\n\u003cpre\u003e@startuml\n\nhide footbox\n\nactor User\nparticipant System\nparticipant Database\n\nUser -\u0026gt; System: Login Request\nSystem --\u0026gt; User: Login Form\n\nUser -\u0026gt; System: Submit Credentials\nSystem -\u0026gt; Database: Verify Credentials\nDatabase --\u0026gt; System: Validation Result\nSystem --\u0026gt; User: Authentication Result\n\nUser -\u0026gt; System: Request Dashboard\nSystem -\u0026gt; Database: Fetch User Data\nDatabase --\u0026gt; System: User Data\nSystem --\u0026gt; User: Dashboard View\n@enduml \u003c/pre\u003e\n\n\u003cp\u003eWhen processed by PlantUML, this text generates a visual sequence diagram showing the\n            interaction between components.\u003c/p\u003e\n\n\u003cdiv id=\"user-authentication.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/exploring-gen-ai/user-authentication.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\n\n                The code-like nature of PlantUML makes\n                it easy to learn and use, especially for developers who are already comfortable\n                with text-based tools.\u003c/p\u003e\n\n\u003cp\u003eThis simplicity is what makes PlantUML a perfect candidate for extension. With the\n                right tooling, we can enhance its capabilities while maintaining its text-based\n                workflow.\u003c/p\u003e\n\n\u003cp\u003e\n                Our goal for this project is to create a tool which can divide the\n                sequence diagram into steps and generate a step by step view of the diagram.\n                So for the above diagram, we should be able to view login, authentication and\n                dashboard\n                steps one by one.\n            \u003c/p\u003e\n\u003c/section\u003e\n\n\n\n\u003csection id=\"Step2BuildingTheParserLogicandDebugging\"\u003e\n\u003ch2\u003eStep 2: Building the Parser Logic (and Debugging)\u003c/h2\u003e\n\n\u003cp\u003e“Now we need to parse the plantuml files and separate out step. Whenever we\n                    encounter a step marker, we create a step object and keep adding the next lines\n                    to it until we encounter another step marker or end of file. In case we\n                    encounter another step counter, we create new step object, it should have all\n                    the includes, actors and participants from the previous step. It should also\n                    have all the content of the previous step, unless the step metadata has\n                    \u0026#39;newPage\u0026#39; attribute. If there are no step markers encountered, which is the case\n                    where we have files without steps, it should create a default step. Create a\n                    StepParser to parse given puml files and create list of steps.”\u003c/p\u003e\n\n\u003cp\u003eClaude generated the initial code for a StepParser class and a Step model class to\n                handle parsing PlantUML files with step markers. The initial implementation had some\n                logical issues:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIncorrect handling of step content inheritance when newPage attribute was false\u003c/li\u003e\n\n\u003cli\u003eImproper handling of declarations (actors, participants) appearing before the\n                    first step marker\u003c/li\u003e\n\n\u003cli\u003eIssues with creating a default step for files without markers\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe Cursor editor was running in Agent mode, so after running tests and identifying\n                these issues through the failure messages, Claude provided a corrected version that\n                properly handled:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eContent collected before the first step marker\u003c/li\u003e\n\n\u003cli\u003eInheritance of content from the immediately preceding step\u003c/li\u003e\n\n\u003cli\u003eGlobal tracking of declarations across steps\u003c/li\u003e\n\n\u003cli\u003eProper creation of a default step for files without markers\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWith these corrections, the parser successfully passed all tests.\u003c/p\u003e\n\n\u003cp\u003e The next step was to generate a gradle task. \u003c/p\u003e\n\n\u003cp\u003e\n                    We need gradle task which can process puml files in src/diagrams and its sub\n                folders. For each file it should create a directory with the name of the file where\n                it generates valid puml file for each step. It can generate that by just adding\n                @startuml at the start and @enduml at the end of the step content.\n\n             \u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cp\u003eI\u0026#39;ll help you create a Gradle task to process PlantUML files and generate\n                step-by-step diagrams. First, let\u0026#39;s create the task in\n                build.gradle:\u003c/p\u003e\n\n\u003cpre\u003e// Process each .puml file in the input directory and its subdirectories\nfileTree(inputDir).include(\u0026#39;**/*.puml\u0026#39;).each { pumlFile -\u0026gt;\n    def relativePath = inputDir.toPath().relativize(pumlFile.toPath()).toString()\n    def fileName = pumlFile.name.replace(\u0026#39;.puml\u0026#39;, \u0026#39;\u0026#39;)\n    def stepOutputDir = new File(outputDir, fileName)\n    \n    if (!stepOutputDir.exists()) {\n        stepOutputDir.mkdirs()\n    }\n    \n    // Run the generator for this file\n    javaexec {\n        classpath = sourceSets.main.runtimeClasspath\n        mainClass = \u0026#39;com.example.StepDiagramGenerator\u0026#39;\n        args = [pumlFile.absolutePath, stepOutputDir.absolutePath]\n    }\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e Claude also helped generating a simple plantuml sequence diagram to test the gradle\n                task. The same one that we used at the beginning of the article.\n            \u003c/p\u003e\n\n\u003cp\u003e\n            The gradle task needed a class PlantUMLGenerator which\n            can generate SVGs for each step.\n            Cursor in the Agent mode generated the code for the class.\n            \u003c/p\u003e\n\n\u003cp\u003e It then ran the build to verify the task. \u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003eLet\u0026#39;s run a test to confirm our implementation works: cd /Users/unmeshjoshi/work/plantumlsequence \u0026amp;\u0026amp; ./gradlew clean build\n                \nTask :generateStepDiagrams\nGenerated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-01-step-1-user-login.puml\nGenerated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-02-step-2-authentication.puml\nGenerated step diagram: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/step-03-step-3-dashboard.puml\nGenerated step flow summary: /Users/unmeshjoshi/work/plantumlsteps/build/generated-diagrams/user-authentication/summary.puml\n\n        BUILD SUCCESSFUL in 543ms\n        3 actionable tasks: 3 executed\n\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Step3GeneratingHtmlViewerForStepSequence\"\u003e\n\u003ch2\u003eStep 3: Generating HTML Viewer for Step Sequence\u003c/h2\u003e\n\n\u003cp\u003e The next step was to generate a simple HTML viewer that can be used to view the step\n                sequence. \u003c/p\u003e\n\n\u003cp\u003e\n                        Now we need to generate a HTML viewer for the step files to be shown one by one.\n                    The HTML viewer can have a view area where we show the svg image generated for each\n                    step with the step name in the metadata for that step. We can have next and previous\n                    buttons to show next and previous step image.\n                \u003c/p\u003e\n\n\u003cp\u003e\n                    I\u0026#39;ll help you create an HTML viewer for the step diagrams. We\u0026#39;ll need to: Generate\n                    SVG files from the PlantUML files Create an HTML viewer with navigation controls\n                    Update the Gradle task to generate both PlantUML and SVG files, along with the HTML\n                    viewer First, let\u0026#39;s create a simple HTML template for the viewer: \n                    ....\n             \n                \u003c/p\u003e\n\n\u003cp\u003e\n                The agent mode figured out a few issues with the template but auto-fixed it by\n                running some corrective actions.\n            \u003c/p\u003e\n\n\u003cp\u003e This setup allowed us to quickly generate step diagrams from a single PlantUML file,\n                and view them in a step by step manner. So the above diagram can be viewed as a\n                sequence of following steps:\u003c/p\u003e\n\n\u003cdiv id=\"user-authentication-step-1.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/exploring-gen-ai/user-authentication-step-1.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cdiv id=\"user-authentication-step-2.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/exploring-gen-ai/user-authentication-step-2.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003cdiv id=\"user-authentication-step-3.png\"\u003e\u003cp\u003e\u003cimg src=\"https://martinfowler.com/articles/exploring-gen-ai/user-authentication-step-3.png\"/\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\u003c/section\u003e\n\n\u003csection id=\"TheCodeIsTheSourceOfTruth\"\u003e\n\u003ch2\u003eThe Code is the Source of Truth\u003c/h2\u003e\n\n\u003cp\u003eWhere to go from here? \u003c/p\u003e\n\n\u003cp\u003eWhile the prompts and the LLM assistant (in this case, interacting in an agent-like\n                mode, utilizing models like Claude Sonnet) provided a remarkably effective way to\n                generate a working first version of \u003ccode\u003ePlantUMLSteps\u003c/code\u003e, it\u0026#39;s crucial to\n                recognize the nature of this generated output.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003ePrompts are not Deterministic:\u003c/b\u003e The prompts used in our conversation were\n                    effective for this interaction, but they cannot be treated as the ultimate\n                    \u0026#39;source of truth\u0026#39;. The same prompts given to a different model, or even the same\n                    model at a later date, are not guaranteed to produce the exact same output due\n                    to the inherent variability in LLM generation. \u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eCode Requires Management:\u003c/b\u003e The generated code is the source of truth for\n                    the tool\u0026#39;s functionality. As such, it needs to be treated like any other\n                    software artifact - checked into version control, reviewed, tested, and\n                    maintained.\u003c/li\u003e\n\n\u003cli\u003e\u003cb\u003eReview for Habitability:\u003c/b\u003e It\u0026#39;s essential to revisit the LLM-generated code\n                    after the initial creation phase. Is it \u0026#39;habitable\u0026#39;? That is, is it reasonably\n                    easy to read, understand, and modify by a human developer? While the LLM helped\n                    overcome initial hurdles and boilerplate, ensuring the long-term maintainability\n                    and clarity of the codebase often requires human review and potential\n                    refactoring. The goal is code that not only works but can also be evolved\n                    effectively over time.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\n                Prompting in natural language (like English) to generate code works well in the\n                early phases of development—when you\u0026#39;re exploring ideas, scaffolding functionality,\n                or getting familiar with a new tool or framework. But as your system starts to take\n                shape, the limits of vague or broad prompts become apparent. At this stage, what\u0026#39;s\n                needed is not more code generation, but conceptual modeling—using the constructs of\n                your programming language or technology stack to accurately represent the domain.\n                This stage needs deeper thinking to build abstractions, and an alignment between\n                code structure and domain concepts—something only achievable through thoughtful\n                design, not just prompting. If prompt-based code generation without \n                review is called “vibe coding,” then the more disciplined approach can be \n                called “AI-assisted structured coding.”. \n            \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"BeyondCodeGenerationTheDeveloperInsightInRefactoring\"\u003e\n\u003ch2\u003eBeyond Code Generation: The Developer Insight in Refactoring\u003c/h2\u003e\n\n\u003cp\u003e\n                The next step was to refactor the code to make it more readable and maintainable.\n            \u003c/p\u003e\n\n\u003cp\u003eInitially, the parse method was a long, monolithic function that handled everything\n                from\n                detecting step markers to managing declarations and content. The code was difficult\n                to\n                understand and maintain.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                The full code is available in\n                 \u003ca href=\"https://github.com/unmeshjoshi/PlantUmlSteps/commit/c50eafe0eef2dd97a56cd60a55baf69869994fc8#diff-01bd69bfbdde13cd432f55629e3c850c00ab6907b88cf8c5314a9aa645546ed3\"\u003e this initial commit on GitHub\u003c/a\u003e.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                The `StepParser.java` parse method needs refactoring. It should represent concepts\n                used in the requirement or domain concepts and follow standard clean code practices\n                with intentional method names and code that reads like a DSL.\n            \u003c/p\u003e\n\n\u003cp\u003eThis initial request was open-ended, indicating that the developer recognized the\n                need for improvement but was looking for guidance on how to approach it.\n                The LLM responded with a comprehensive refactoring that introduced several new\n                classes and methods:\n            \u003c/p\u003e\n\n\u003cdiv\u003e\n\u003cpre\u003e- Introduced `PlantUmlDocument` to represent the document being parsed\n- Smaller, more focused methods with intention-revealing names\n- Better encapsulation of related behaviors\n- More expressive variable and method names\n\n\n    /**\n     * Represents a PlantUML document being parsed, managing state during parsing\n     */\n    private class PlantUmlDocument {\n        private final List\u003cstep\u003e steps = new ArrayList\u0026lt;\u0026gt;();\n        private final List\u003cstring\u003e declarations = new ArrayList\u0026lt;\u0026gt;();\n        private final List\u003cstring\u003e contentBeforeFirstStep = new ArrayList\u0026lt;\u0026gt;();\n        private Step currentStep = null;\n        private boolean hasStepMarkers = false;\n        \n        public void beginNewStep(StepMetadata metadata) {\n            hasStepMarkers = true;\n            \n            // Save the current step if it exists\n            if (currentStep != null) {\n                steps.add(currentStep);\n            }\n            \n            // Create a new step\n            currentStep = new Step(metadata.getName(), metadata.isNewPage(), metadata.getAttributes());\n            \n            // Add all declarations to the new step\n            currentStep.addAllDeclarations(declarations);\n            \n            // If this isn\u0026#39;t a new page and we have previous steps, copy all content from previous steps\n            if (!metadata.isNewPage() \u0026amp;\u0026amp; !steps.isEmpty()) {\n                carryOverPreviousStepsContent();\n            }\n        }\n        \n        private void carryOverPreviousStepsContent() {\n            for (Step previousStep : steps) {\n                for (String contentLine : previousStep.getContent()) {\n                    currentStep.addContent(contentLine);\n                }\n            }\n        }\n        \n        public void addDeclaration(String line) {\n            declarations.add(line);\n            \n            if (currentStep != null) {\n                currentStep.addDeclaration(line);\n            } else {\n                contentBeforeFirstStep.add(line);\n            }\n        }\n        \n        public void addContentLine(String line) {\n            if (currentStep != null) {\n                currentStep.addContent(line);\n            } else if (!line.trim().isEmpty()) {\n                contentBeforeFirstStep.add(line);\n            }\n        }\n        \n        public void finalizeDocument() {\n            // Add the last step if it exists and hasn\u0026#39;t been added yet\n            if (currentStep != null) {\n                steps.add(currentStep);\n            }\n        }\n\u003c/string\u003e\u003c/string\u003e\u003c/step\u003e\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\n                The full code is available in\n                 \u003ca href=\"https://github.com/unmeshjoshi/PlantUmlSteps/commit/661002fcede7ec70eac2b41309fb9423d14c4ca1\"\u003e this commit on GitHub\u003c/a\u003e.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                The `contentBeforeFirstStep` in `PlantUmlDocument.java` is used only for creating\n                default step when there are no step markers?\n                So we can possibly\n                do two pass processing where we first check if there are step markers.. if there\n                are.. we do step-based processing. Or else we just create a default step and add all\n                declarations and content. That will remove the need to have `contentBeforeFirstStep`\n                We can also possibily name PlantUmlDocument as `ParsedPumlFile` which represents\n                the parsed puml file.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                The LLM implemented this suggestion with a two-pass approach. It also renamed the\n                 PlantUmlDocument as ParsedPumlFile.\n                 The full code is available in\n                 \u003ca href=\"https://github.com/unmeshjoshi/PlantUmlSteps/commit/f57500915039824fc2bf3f010f0dc914f363114f\"\u003e this commit on GitHub\u003c/a\u003e.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                `ParsedPumlFile` can be better represented as builder pattern.\n                `StepBuilder` can be a builder for `Step` objects.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                This insight demonstrated the developer\u0026#39;s ability to recognize design patterns,\n                noting that the refactored class followed the Builder pattern.\n            \u003c/p\u003e\n\n\u003cp\u003e The final refactoring represents a significant improvement over the original code: \u003c/p\u003e\n\n\u003cpre\u003eclass StepBuilder {\n    private final List\u0026lt;Step\u0026gt; steps = new ArrayList\u0026lt;\u0026gt;();\n    private final List\u0026lt;String\u0026gt; globalDeclarations = new ArrayList\u0026lt;\u0026gt;();\n    private Step currentStep = null;\n    \n    public void startNewStep(StepMetadata metadata) {\n        if (currentStep != null) {\n            steps.add(currentStep);\n        }\n        \n        currentStep = new Step(metadata);\n        currentStep.addAllDeclarations(globalDeclarations);\n        \n        if (!metadata.isNewPage() \u0026amp;\u0026amp; !steps.isEmpty()) {\n            // Copy content from the previous step\n            Step previousStep = steps.get(steps.size() - 1);\n            for (String contentLine : previousStep.getContent()) {\n                currentStep.addContent(contentLine);\n            }\n        }\n    }\n    \n    public void addDeclaration(String declaration) {\n        globalDeclarations.add(declaration);\n        \n        if (currentStep != null) {\n            currentStep.addDeclaration(declaration);\n        }\n    }\n    \n    public void addContent(String content) {\n        // If no step has been started yet, create a default step\n        if (currentStep == null) {\n            StepMetadata metadata = new StepMetadata(\u0026#34;Default Step\u0026#34;, false, new HashMap\u0026lt;\u0026gt;());\n            startNewStep(metadata);\n        }\n        \n        currentStep.addContent(content);\n    }\n    \n    public List\u0026lt;Step\u0026gt; build() {\n        if (currentStep != null) {\n            steps.add(currentStep);\n        }\n        \n        return new ArrayList\u0026lt;\u0026gt;(steps);\n    }\n} \n\u003c/pre\u003e\n\n\u003cp\u003e\n                The full code is available in\n                 \u003ca href=\"https://github.com/unmeshjoshi/PlantUmlSteps/commit/6b0a305d42da3df4d3d0b783926fa6e7b19045cd\"\u003e this commit on GitHub\u003c/a\u003e.\n            \u003c/p\u003e\n\n\u003cp\u003e\n                There are more improvements possible, \n                but I have included a few to demonstrate the nature of collaboration between LLMs\n                and developers.\n            \u003c/p\u003e\n\u003c/section\u003e\n\n\u003csection id=\"Conclusion\"\u003e\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003e Each part of this extension—comment syntax, Java parsing logic, HTML viewer, and\n                    Gradle wiring—started with a focused LLM prompt. Some parts required some expert\n                    developer guidance to LLM, but the key benefit was being able to explore and\n                    validate ideas without getting bogged down in boilerplate. LLMs are particularly\n                    helpful when you have a design in mind but are not getting started because of\n                    the efforts needed for setting up the scaffolding to try it out. They can help\n                    you generate working glue code, integrate libraries, and generate small\n                    UIs—leaving you to focus on whether the idea itself works. \n                \u003c/p\u003e\n\n\u003cp\u003e\n                    After the initial working version, it was important to have a developer to guide\n                    the LLM to improve the code, to make it more maintainable. It was critical\n                    for developers to:\n                \u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eAsk insightful questions\u003c/li\u003e\n\n\u003cli\u003eChallenge proposed implementations\u003c/li\u003e\n\n\u003cli\u003eSuggest alternative approaches\u003c/li\u003e\n\n\u003cli\u003eApply software design principles\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis collaboration between the developer and the LLM is key to building\n                        maintainable and scalable systems. The LLM can help generate working code,\n                        but the developer is the one who can make it more readable, maintainable and\n                        scalable.\n                    \u003c/p\u003e\n\u003c/section\u003e\n\n\u003chr/\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": null,
  "modifiedTime": "2025-05-14T00:00:00-04:00"
}
