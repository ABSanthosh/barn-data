{
  "id": "297310ba-d726-4939-a524-8cb06960f327",
  "title": "How Does the Development Mode Work?",
  "link": "https://overreacted.io/how-does-the-development-mode-work/",
  "description": "Dead code elimination by convention.",
  "author": "",
  "published": "Sun, 04 Aug 2019 00:00:00 GMT",
  "source": "https://overreacted.io/rss.xml",
  "categories": null,
  "byline": "",
  "length": 12683,
  "excerpt": "Dead code elimination by convention.",
  "siteName": "",
  "favicon": "https://overreacted.io/icon.png?e0852c1e2c7f0e65",
  "text": "If your JavaScript codebase is even moderately complex, you probably have a way to bundle and run different code in development and production. Bundling and running different code in development and production is powerful. In development mode, React includes many warnings that help you find problems before they lead to bugs. However, the code necessary to detect such mistakes often increases the bundle size and makes the app run slower. The slowdown is acceptable in development. In fact, running the code slower in development might even be beneficial because it partially compensates for the discrepancy between fast developer machines and an average consumer device. In production we don‚Äôt want to pay any of that cost. Hence, we omit these checks in production. How does that work? Let‚Äôs take a look. The exact way to run different code in development depends on your JavaScript build pipeline (and whether you have one). At Facebook it looks like this: if (__DEV__) { doSomethingDev(); } else { doSomethingProd(); } Here, __DEV__ isn‚Äôt a real variable. It‚Äôs a constant that gets substituted when the modules are stitched together for the browser. The result looks like this: // In development: if (true) { doSomethingDev(); // üëà } else { doSomethingProd(); } // In production: if (false) { doSomethingDev(); } else { doSomethingProd(); // üëà } In production, you‚Äôd also run a minifier (for example, terser) on the code. Most JavaScript minifiers do a limited form of dead code elimination, such as removing if (false) branches. So in production you‚Äôd only see: // In production (after minification): doSomethingProd(); (Note that there are significant limits on how effective dead code elimination can be with mainstream JavaScript tools, but that‚Äôs a separate topic.) While you might not be using a __DEV__ magic constant, if you use a popular JavaScript bundler like webpack, there‚Äôs probably some other convention you can follow. For example, it‚Äôs common to express the same pattern like this: if (process.env.NODE_ENV !== 'production') { doSomethingDev(); } else { doSomethingProd(); } That‚Äôs exactly the pattern used by libraries like React and Vue when you import them from npm using a bundler. (Single-file \u003cscript\u003e tag builds offer development and production versions as separate .js and .min.js files.) This particular convention originally comes from Node.js. In Node.js, there is a global process variable that exposes your system‚Äôs environment variables as properties on the process.env object. However, when you see this pattern in a front-end codebase, there isn‚Äôt usually any real process variable involved. ü§Ø Instead, the whole process.env.NODE_ENV expression gets substituted by a string literal at the build time, just like our magic __DEV__ variable: // In development: if ('development' !== 'production') { // true doSomethingDev(); // üëà } else { doSomethingProd(); } // In production: if ('production' !== 'production') { // false doSomethingDev(); } else { doSomethingProd(); // üëà } Because the whole expression is constant ('production' !== 'production' is guaranteed to be false), a minifier can also remove the other branch. // In production (after minification): doSomethingProd(); Mischief managed. Note that this wouldn‚Äôt work with more complex expressions: let mode = 'production'; if (mode !== 'production') { // üî¥ not guaranteed to be eliminated } JavaScript static analysis tools are not very smart due to the dynamic nature of the language. When they see variables like mode rather than static expressions like false or 'production' !== 'production', they often give up. Similarly, dead code elimination in JavaScript often doesn‚Äôt work well across the module boundaries when you use the top-level import statements: // üî¥ not guaranteed to be eliminated import {someFunc} from 'some-module'; if (false) { someFunc(); } So you need to write code in a very mechanical way that makes the condition definitely static, and ensure that all code you want to eliminate is inside of it. For all of this to work, your bundler needs to do the process.env.NODE_ENV replacement, and needs to know in which mode you want to build the project in. A few years ago, it used to be common to forget to configure the environment. You‚Äôd often see a project in development mode deployed to production. That‚Äôs bad because it makes the website load and run slower. In the last two years, the situation has significantly improved. For example, webpack added a simple mode option instead of manually configuring the process.env.NODE_ENV replacement. React DevTools also now displays a red icon on sites with development mode, making it easy to spot and even report. Opinionated setups like Create React App, Next/Nuxt, Vue CLI, Gatsby, and others make it even harder to mess up by separating the development builds and production builds into two separate commands. (For example, npm start and npm run build.) Typically, only a production build can be deployed, so the developer can‚Äôt make this mistake anymore. There is always an argument that maybe the production mode needs to be the default, and the development mode needs to be opt-in. Personally, I don‚Äôt find this argument convincing. People who benefit most from the development mode warnings are often new to the library. They wouldn‚Äôt know to turn it on, and would miss the many bugs that the warnings would have detected early. Yes, performance issues are bad. But so is shipping broken buggy experiences to the end users. For example, the React key warning helps prevent bugs like sending a message to the wrong person or buying the wrong product. Developing with this warning disabled is a significant risk for you and your users. If it‚Äôs off by default, then by the time you find the toggle and turn it on, you‚Äôll have too many warnings to clean up. So most people would toggle it back off. This is why it needs to be on from the start, rather than enabled later. Finally, even if development warnings were opt-in, and developers knew to turn them on early in development, we‚Äôd just go back to the original problem. Someone would accidentally leave them on when deploying to production! And we‚Äôre back to square one. Personally, I believe in tools that display and use the right mode depending on whether you‚Äôre debugging or deploying. Almost every other environment (whether mobile, desktop, or server) except the web browser has had a way to load and differentiate development and production builds for decades. Instead of libraries coming up with and relying on ad-hoc conventions, perhaps it‚Äôs time the JavaScript environments see this distinction as a first-class need. Enough with the philosophy! Let‚Äôs take another look at this code: if (process.env.NODE_ENV !== 'production') { doSomethingDev(); } else { doSomethingProd(); } You might be wondering: if there‚Äôs no real process object in front-end code, why do libraries like React and Vue rely on it in the npm builds? (To clarify this again: the \u003cscript\u003e tags you can load in the browser, offered by both React and Vue, don‚Äôt rely on this. Instead you have to manually pick between the development .js and the production .min.js files. The section below is only about using React or Vue with a bundler by importing them from npm.) Like many things in programming, this particular convention has mostly historical reasons. We are still using it because now it‚Äôs widely adopted by different tools. Switching to something else is costly and doesn‚Äôt buy much. So what‚Äôs the history behind it? Many years before the import and export syntax was standardized, there were several competing ways to express relationships between modules. Node.js popularized require() and module.exports, known as CommonJS. Code published on the npm registry early on was written for Node.js. Express was (and probably still is?) the most popular server-side framework for Node.js, and it used the NODE_ENV environment variable to enable production mode. Some other npm packages adopted the same convention. Early JavaScript bundlers like browserify wanted to make it possible to use code from npm in front-end projects. (Yes, back then almost nobody used npm for front-end! Can you imagine?) So they extended the same convention already present in the Node.js ecosystem to the front-end code. The original ‚Äúenvify‚Äù transform was released in 2013. React was open sourced around that time, and npm with browserify seemed like the best solution for bundling front-end CommonJS code during that era. React started providing npm builds (in addition to \u003cscript\u003e tag builds) from the very beginning. As React got popular, so did the practice of writing modular JavaScript with CommonJS modules and shipping front-end code via npm. React needed to remove development-only code in the production mode. Browserify already offered a solution to this problem, so React also adopted the convention of using process.env.NODE_ENV for its npm builds. With time, many other tools and libraries, including webpack and Vue, did the same. By 2019, browserify has lost quite a bit of mindshare. However, replacing process.env.NODE_ENV with 'development' or 'production' during a build step is a convention that is as popular as ever. (It would be interesting to see how adoption of ES Modules as a distribution format, rather than just the authoring format, changes the equation. Tell me on Twitter?) One thing that might still confuse you is that in React source code on GitHub, you‚Äôll see __DEV__ being used as a magic variable. But in the React code on npm, it uses process.env.NODE_ENV. How does that work? Historically, we‚Äôve used __DEV__ in the source code to match the Facebook source code. For a long time, React was directly copied into the Facebook codebase, so it needed to follow the same rules. For npm, we had a build step that literally replaced the __DEV__ checks with process.env.NODE_ENV !== 'production' right before publishing. This was sometimes a problem. Sometimes, a code pattern relying on some Node.js convention worked well on npm, but broke Facebook, or vice versa. Since React 16, we‚Äôve changed the approach. Instead, we now compile a bundle for each environment (including \u003cscript\u003e tags, npm, and the Facebook internal codebase). So even CommonJS code for npm is compiled to separate development and production bundles ahead of time. This means that while the React source code says if (__DEV__), we actually produce two bundles for every package. One is already precompiled with __DEV__ = true and another is precompiled with __DEV__ = false. The entry point for each package on npm ‚Äúdecides‚Äù which one to export. For example: if (process.env.NODE_ENV === 'production') { module.exports = require('./cjs/react.production.min.js'); } else { module.exports = require('./cjs/react.development.js'); } And that‚Äôs the only place where your bundler will interpolate either 'development' or 'production' as a string, and where your minifier will get rid of the development-only require. Both react.production.min.js and react.development.js don‚Äôt have any process.env.NODE_ENV checks anymore. This is great because when actually running on Node.js, accessing process.env is somewhat slow. Compiling bundles in both modes ahead of time also lets us optimize the file size much more consistently, regardless of which bundler or minifier you are using. And that‚Äôs how it really works! I wish there was a more first-class way to do it without relying on conventions, but here we are. It would be great if modes were a first-class concept in all JavaScript environments, and if there was some way for a browser to surface that some code is running in a development mode when it‚Äôs not supposed to. On the other hand, it is fascinating how a convention in a single project can propagate through the ecosystem. EXPRESS_ENV became NODE_ENV in 2010 and spread to front-end in 2013. Maybe the solution isn‚Äôt perfect, but for each project the cost of adopting it was lower than the cost of convincing everyone else to do something different. This teaches a valuable lesson about the top-down versus bottom-up adoption. Understanding how this dynamic plays out distinguishes successful standardization attempts from failures. Separating development and production modes is a very useful technique. I recommend using it in your libraries and the application code for the kinds of checks that are too expensive to do in production, but are valuable (and often critical!) to do in development. As with any powerful feature, there are some ways you can misuse it. This will be the topic of my next post!Discuss on ùïè¬†¬†¬∑¬†¬†Edit on GitHub",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eIf your JavaScript codebase is even moderately complex, \u003cstrong\u003eyou probably have a way to bundle and run different code in development and production\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eBundling and running different code in development and production is powerful. In development mode, React includes many warnings that help you find problems before they lead to bugs. However, the code necessary to detect such mistakes often increases the bundle size and makes the app run slower.\u003c/p\u003e\n\u003cp\u003eThe slowdown is acceptable in development. In fact, running the code slower in development \u003cem\u003emight even be beneficial\u003c/em\u003e because it partially compensates for the discrepancy between fast developer machines and an average consumer device.\u003c/p\u003e\n\u003cp\u003eIn production we don‚Äôt want to pay any of that cost. Hence, we omit these checks in production. How does that work? Let‚Äôs take a look.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eThe exact way to run different code in development depends on your JavaScript build pipeline (and whether you have one). At Facebook it looks like this:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e__DEV__\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere, \u003ccode\u003e__DEV__\u003c/code\u003e isn‚Äôt a real variable. It‚Äôs a constant that gets substituted when the modules are stitched together for the browser. The result looks like this:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In development:\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// üëà\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In production:\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// üëà\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIn production, you‚Äôd also run a minifier (for example, \u003ca target=\"_blank\" href=\"https://github.com/terser-js/terser\"\u003eterser\u003c/a\u003e) on the code. Most JavaScript minifiers do a limited form of \u003ca target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Dead_code_elimination\"\u003edead code elimination\u003c/a\u003e, such as removing \u003ccode\u003eif (false)\u003c/code\u003e branches. So in production you‚Äôd only see:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In production (after minification):\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003cem\u003e(Note that there are significant limits on how effective dead code elimination can be with mainstream JavaScript tools, but that‚Äôs a separate topic.)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eWhile you might not be using a \u003ccode\u003e__DEV__\u003c/code\u003e magic constant, if you use a popular JavaScript bundler like webpack, there‚Äôs probably some other convention you can follow. For example, it‚Äôs common to express the same pattern like this:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eNODE_ENV \u003c/span\u003e\u003cspan\u003e!==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003eThat‚Äôs exactly the pattern used by libraries like \u003ca target=\"_blank\" href=\"https://reactjs.org/docs/optimizing-performance.html#use-the-production-build\"\u003eReact\u003c/a\u003e and \u003ca target=\"_blank\" href=\"https://vuejs.org/v2/guide/deployment.html#Turn-on-Production-Mode\"\u003eVue\u003c/a\u003e when you import them from npm using a bundler.\u003c/strong\u003e (Single-file \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tag builds offer development and production versions as separate \u003ccode\u003e.js\u003c/code\u003e and \u003ccode\u003e.min.js\u003c/code\u003e files.)\u003c/p\u003e\n\u003cp\u003eThis particular convention originally comes from Node.js. In Node.js, there is a global \u003ccode\u003eprocess\u003c/code\u003e variable that exposes your system‚Äôs environment variables as properties on the \u003ca target=\"_blank\" href=\"https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_process_env\"\u003e\u003ccode\u003eprocess.env\u003c/code\u003e\u003c/a\u003e object. However, when you see this pattern in a front-end codebase, there isn‚Äôt usually any real \u003ccode\u003eprocess\u003c/code\u003e variable involved. ü§Ø\u003c/p\u003e\n\u003cp\u003eInstead, the whole \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e expression gets substituted by a string literal at the build time, just like our magic \u003ccode\u003e__DEV__\u003c/code\u003e variable:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In development:\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003edevelopment\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e!==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// true\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// üëà\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In production:\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e!==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// false\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e// üëà\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBecause the whole expression is constant (\u003ccode\u003e\u0026#39;production\u0026#39; !== \u0026#39;production\u0026#39;\u003c/code\u003e is guaranteed to be \u003ccode\u003efalse\u003c/code\u003e), a minifier can also remove the other branch.\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// In production (after minification):\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eMischief managed.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eNote that this \u003cstrong\u003ewouldn‚Äôt work\u003c/strong\u003e with more complex expressions:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003elet \u003c/span\u003e\u003cspan\u003emode\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emode \u003c/span\u003e\u003cspan\u003e!==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e// üî¥ not guaranteed to be eliminated\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eJavaScript static analysis tools are not very smart due to the dynamic nature of the language. When they see variables like \u003ccode\u003emode\u003c/code\u003e rather than static expressions like \u003ccode\u003efalse\u003c/code\u003e or \u003ccode\u003e\u0026#39;production\u0026#39; !== \u0026#39;production\u0026#39;\u003c/code\u003e, they often give up.\u003c/p\u003e\n\u003cp\u003eSimilarly, dead code elimination in JavaScript often doesn‚Äôt work well across the module boundaries when you use the top-level \u003ccode\u003eimport\u003c/code\u003e statements:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003e// üî¥ not guaranteed to be eliminated\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eimport\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003esomeFunc\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003efrom\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003esome-module\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e \u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003esomeFunc\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSo you need to write code in a very mechanical way that makes the condition \u003cem\u003edefinitely static\u003c/em\u003e, and ensure that \u003cem\u003eall code\u003c/em\u003e you want to eliminate is inside of it.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eFor all of this to work, your bundler needs to do the \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e replacement, and needs to know in which mode you \u003cem\u003ewant\u003c/em\u003e to build the project in.\u003c/p\u003e\n\u003cp\u003eA few years ago, it used to be common to forget to configure the environment. You‚Äôd often see a project in development mode deployed to production.\u003c/p\u003e\n\u003cp\u003eThat‚Äôs bad because it makes the website load and run slower.\u003c/p\u003e\n\u003cp\u003eIn the last two years, the situation has significantly improved. For example, webpack added a simple \u003ccode\u003emode\u003c/code\u003e option instead of manually configuring the \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e replacement. React DevTools also now displays a red icon on sites with development mode, making it easy to spot and even \u003ca target=\"_blank\" href=\"https://mobile.twitter.com/BestBuySupport/status/1027195363713736704\"\u003ereport\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://overreacted.io/how-does-the-development-mode-work/devmode.png\" alt=\"Development mode warning in React DevTools\"/\u003e\u003c/p\u003e\n\u003cp\u003eOpinionated setups like Create React App, Next/Nuxt, Vue CLI, Gatsby, and others make it even harder to mess up by separating the development builds and production builds into two separate commands. (For example, \u003ccode\u003enpm start\u003c/code\u003e and \u003ccode\u003enpm run build\u003c/code\u003e.) Typically, only a production build can be deployed, so the developer can‚Äôt make this mistake anymore.\u003c/p\u003e\n\u003cp\u003eThere is always an argument that maybe the \u003cem\u003eproduction\u003c/em\u003e mode needs to be the default, and the development mode needs to be opt-in. Personally, I don‚Äôt find this argument convincing. People who benefit most from the development mode warnings are often new to the library. \u003cem\u003eThey wouldn‚Äôt know to turn it on,\u003c/em\u003e and would miss the many bugs that the warnings would have detected early.\u003c/p\u003e\n\u003cp\u003eYes, performance issues are bad. But so is shipping broken buggy experiences to the end users. For example, the \u003ca target=\"_blank\" href=\"https://reactjs.org/docs/lists-and-keys.html#keys\"\u003eReact key warning\u003c/a\u003e helps prevent bugs like sending a message to the wrong person or buying the wrong product. Developing with this warning disabled is a significant risk for you \u003cem\u003eand\u003c/em\u003e your users. If it‚Äôs off by default, then by the time you find the toggle and turn it on, you‚Äôll have too many warnings to clean up. So most people would toggle it back off. This is why it needs to be on from the start, rather than enabled later.\u003c/p\u003e\n\u003cp\u003eFinally, even if development warnings were opt-in, and developers \u003cem\u003eknew\u003c/em\u003e to turn them on early in development, we‚Äôd just go back to the original problem. Someone would accidentally leave them on when deploying to production!\u003c/p\u003e\n\u003cp\u003eAnd we‚Äôre back to square one.\u003c/p\u003e\n\u003cp\u003ePersonally, I believe in \u003cstrong\u003etools that display and use the right mode depending on whether you‚Äôre debugging or deploying\u003c/strong\u003e. Almost every other environment (whether mobile, desktop, or server) except the web browser has had a way to load and differentiate development and production builds for decades.\u003c/p\u003e\n\u003cp\u003eInstead of libraries coming up with and relying on ad-hoc conventions, perhaps it‚Äôs time the JavaScript environments see this distinction as a first-class need.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eEnough with the philosophy!\u003c/p\u003e\n\u003cp\u003eLet‚Äôs take another look at this code:\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eNODE_ENV \u003c/span\u003e\u003cspan\u003e!==\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingDev\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003edoSomethingProd\u003c/span\u003e\u003cspan\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYou might be wondering: if there‚Äôs no real \u003ccode\u003eprocess\u003c/code\u003e object in front-end code, why do libraries like React and Vue rely on it in the npm builds?\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(To clarify this again: the \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tags you can load in the browser, offered by both React and Vue, don‚Äôt rely on this. Instead you have to manually pick between the development \u003ccode\u003e.js\u003c/code\u003e and the production \u003ccode\u003e.min.js\u003c/code\u003e files. The section below is only about using React or Vue with a bundler by \u003ccode\u003eimport\u003c/code\u003eing them from npm.)\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eLike many things in programming, this particular convention has mostly historical reasons. We are still using it because now it‚Äôs widely adopted by different tools. Switching to something else is costly and doesn‚Äôt buy much.\u003c/p\u003e\n\u003cp\u003eSo what‚Äôs the history behind it?\u003c/p\u003e\n\u003cp\u003eMany years before the \u003ccode\u003eimport\u003c/code\u003e and \u003ccode\u003eexport\u003c/code\u003e syntax was standardized, there were several competing ways to express relationships between modules. Node.js popularized \u003ccode\u003erequire()\u003c/code\u003e and \u003ccode\u003emodule.exports\u003c/code\u003e, known as \u003ca target=\"_blank\" href=\"https://en.wikipedia.org/wiki/CommonJS\"\u003eCommonJS\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCode published on the npm registry early on was written for Node.js. \u003ca target=\"_blank\" href=\"https://expressjs.com\"\u003eExpress\u003c/a\u003e was (and probably still is?) the most popular server-side framework for Node.js, and it \u003ca target=\"_blank\" href=\"https://expressjs.com/en/advanced/best-practice-performance.html#set-node_env-to-production\"\u003eused the \u003ccode\u003eNODE_ENV\u003c/code\u003e environment variable\u003c/a\u003e to enable production mode. Some other npm packages adopted the same convention.\u003c/p\u003e\n\u003cp\u003eEarly JavaScript bundlers like browserify wanted to make it possible to use code from npm in front-end projects. (Yes, \u003ca target=\"_blank\" href=\"https://blog.npmjs.org/post/101775448305/npm-and-front-end-packaging\"\u003eback then\u003c/a\u003e almost nobody used npm for front-end! Can you imagine?) So they extended the same convention already present in the Node.js ecosystem to the front-end code.\u003c/p\u003e\n\u003cp\u003eThe original ‚Äúenvify‚Äù transform was \u003ca target=\"_blank\" href=\"https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97\"\u003ereleased in 2013\u003c/a\u003e. React was open sourced around that time, and npm with browserify seemed like the best solution for bundling front-end CommonJS code during that era.\u003c/p\u003e\n\u003cp\u003eReact started providing npm builds (in addition to \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tag builds) from the very beginning. As React got popular, so did the practice of writing modular JavaScript with CommonJS modules and shipping front-end code via npm.\u003c/p\u003e\n\u003cp\u003eReact needed to remove development-only code in the production mode. Browserify already offered a solution to this problem, so React also adopted the convention of using \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e for its npm builds. With time, many other tools and libraries, including webpack and Vue, did the same.\u003c/p\u003e\n\u003cp\u003eBy 2019, browserify has lost quite a bit of mindshare. However, replacing \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e with \u003ccode\u003e\u0026#39;development\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;production\u0026#39;\u003c/code\u003e during a build step is a convention that is as popular as ever.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e(It would be interesting to see how adoption of ES Modules as a distribution format, rather than just the authoring format, changes the equation. Tell me on Twitter?)\u003c/em\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eOne thing that might still confuse you is that in React \u003cem\u003esource code\u003c/em\u003e on GitHub, you‚Äôll see \u003ccode\u003e__DEV__\u003c/code\u003e being used as a magic variable. But in the React code on npm, it uses \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e. How does that work?\u003c/p\u003e\n\u003cp\u003eHistorically, we‚Äôve used \u003ccode\u003e__DEV__\u003c/code\u003e in the source code to match the Facebook source code. For a long time, React was directly copied into the Facebook codebase, so it needed to follow the same rules. For npm, we had a build step that literally replaced the \u003ccode\u003e__DEV__\u003c/code\u003e checks with \u003ccode\u003eprocess.env.NODE_ENV !== \u0026#39;production\u0026#39;\u003c/code\u003e right before publishing.\u003c/p\u003e\n\u003cp\u003eThis was sometimes a problem. Sometimes, a code pattern relying on some Node.js convention worked well on npm, but broke Facebook, or vice versa.\u003c/p\u003e\n\u003cp\u003eSince React 16, we‚Äôve changed the approach. Instead, we now \u003ca target=\"_blank\" href=\"https://reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#compiling-flat-bundles\"\u003ecompile a bundle\u003c/a\u003e for each environment (including \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e tags, npm, and the Facebook internal codebase).  So even CommonJS code for npm is compiled to separate development and production bundles ahead of time.\u003c/p\u003e\n\u003cp\u003eThis means that while the React source code says \u003ccode\u003eif (__DEV__)\u003c/code\u003e, we actually produce \u003cem\u003etwo\u003c/em\u003e bundles for every package. One is already precompiled with \u003ccode\u003e__DEV__ = true\u003c/code\u003e and another is precompiled with \u003ccode\u003e__DEV__ = false\u003c/code\u003e. The entry point for each package on npm ‚Äúdecides‚Äù which one to export.\u003c/p\u003e\n\u003cp\u003e\u003ca target=\"_blank\" href=\"https://unpkg.com/browse/react@16.8.6/index.js\"\u003eFor example:\u003c/a\u003e\u003c/p\u003e\n\u003cdiv data-rehype-pretty-code-fragment=\"\"\u003e\u003cpre tabindex=\"0\" data-language=\"jsx\" data-theme=\"default\"\u003e\u003ccode data-language=\"jsx\" data-theme=\"default\"\u003e\u003cspan data-line=\"\"\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eprocess\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eenv\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eNODE_ENV \u003c/span\u003e\u003cspan\u003e===\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003eproduction\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003emodule\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexports\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e./cjs/react.production.min.js\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003eelse\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003emodule\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexports\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e./cjs/react.development.js\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan data-line=\"\"\u003e\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAnd that‚Äôs the only place where your bundler will interpolate either \u003ccode\u003e\u0026#39;development\u0026#39;\u003c/code\u003e or \u003ccode\u003e\u0026#39;production\u0026#39;\u003c/code\u003e as a string, and where your minifier will get rid of the development-only \u003ccode\u003erequire\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003ereact.production.min.js\u003c/code\u003e and \u003ccode\u003ereact.development.js\u003c/code\u003e don‚Äôt have any \u003ccode\u003eprocess.env.NODE_ENV\u003c/code\u003e checks anymore. This is great because \u003cem\u003ewhen actually running on Node.js\u003c/em\u003e, accessing \u003ccode\u003eprocess.env\u003c/code\u003e is \u003ca target=\"_blank\" href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html#better-server-side-rendering\"\u003esomewhat slow\u003c/a\u003e. Compiling bundles in both modes ahead of time also lets us optimize the file size \u003ca target=\"_blank\" href=\"https://reactjs.org/blog/2017/09/26/react-v16.0.html#reduced-file-size\"\u003emuch more consistently\u003c/a\u003e, regardless of which bundler or minifier you are using.\u003c/p\u003e\n\u003cp\u003eAnd that‚Äôs how it really works!\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eI wish there was a more first-class way to do it without relying on conventions, but here we are. It would be great if modes were a first-class concept in all JavaScript environments, and if there was some way for a browser to surface that some code is running in a development mode when it‚Äôs not supposed to.\u003c/p\u003e\n\u003cp\u003eOn the other hand, it is fascinating how a convention in a single project can propagate through the ecosystem. \u003ccode\u003eEXPRESS_ENV\u003c/code\u003e \u003ca target=\"_blank\" href=\"https://github.com/expressjs/express/commit/03b56d8140dc5c2b574d410bfeb63517a0430451\"\u003ebecame \u003ccode\u003eNODE_ENV\u003c/code\u003e\u003c/a\u003e in 2010 and \u003ca target=\"_blank\" href=\"https://github.com/hughsk/envify/commit/ae8aa26b759cd2115eccbed96f70e7bbdceded97\"\u003espread to front-end\u003c/a\u003e in 2013. Maybe the solution isn‚Äôt perfect, but for each project the cost of adopting it was lower than the cost of convincing everyone else to do something different. This teaches a valuable lesson about the top-down versus bottom-up adoption. Understanding how this dynamic plays out distinguishes successful standardization attempts from failures.\u003c/p\u003e\n\u003cp\u003eSeparating development and production modes is a very useful technique. I recommend using it in your libraries and the application code for the kinds of checks that are too expensive to do in production, but are valuable (and often critical!) to do in development.\u003c/p\u003e\n\u003cp\u003eAs with any powerful feature, there are some ways you can misuse it. This will be the topic of my next post!\u003c/p\u003e\u003chr/\u003e\u003cp\u003e\u003ca target=\"_blank\" href=\"https://x.com/search?q=https%3A%2F%2Foverreacted.io%2Fhow-does-the-development-mode-work%2F\"\u003eDiscuss on ùïè\u003c/a\u003e¬†¬†¬∑¬†¬†\u003ca target=\"_blank\" href=\"https://github.com/gaearon/overreacted.io/edit/main/public/how-does-the-development-mode-work/index.md\"\u003eEdit on GitHub\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
