{
  "id": "fb109196-68c8-4b9f-b642-d20247002bd4",
  "title": "The Performance Impact of SQL’s FILTER Clause",
  "link": "https://blog.jooq.org/the-performance-impact-of-sqls-filter-clause/",
  "description": "I’ve found an interesting question on Twitter, recently. Is there any performance impact of using FILTER in SQL (PostgreSQL, specifically), or is it just syntax sugar for a CASE expression in an aggregate function? As a quick reminder, FILTER is an awesome standard SQL extension to filter out values before aggregating them in SQL. This … Continue reading The Performance Impact of SQL’s FILTER Clause →",
  "author": "lukaseder",
  "published": "Mon, 06 Feb 2023 07:51:38 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "aggregate functions",
    "Benchmark",
    "FILTER",
    "performance",
    "PostgreSQL"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 7965,
  "excerpt": "The standard SQL FILTER clause is \"just\" syntax sugar for an equivalent CASE expression in an aggregate function. This article shows which performs better on PostgreSQL 15",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "I’ve found an interesting question on Twitter, recently. Is there any performance impact of using FILTER in SQL (PostgreSQL, specifically), or is it just syntax sugar for a CASE expression in an aggregate function? Is there a performance difference between CASE and FILTER scenario or it’s just a syntax sugar?— Ivan (@Ivan73965858) February 6, 2023 As a quick reminder, FILTER is an awesome standard SQL extension to filter out values before aggregating them in SQL. This is very useful when aggregating multiple things in a single query. These two are the same: SELECT fa.actor_id, -- These: SUM(length) FILTER (WHERE rating = 'R'), SUM(length) FILTER (WHERE rating = 'PG'), -- Are the same as these: SUM(CASE WHEN rating = 'R' THEN length END), SUM(CASE WHEN rating = 'PG' THEN length END) FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id GROUP BY fa.actor_id As of jOOQ 3.17, these SQL dialects are known to support FILTER natively: CockroachDB Firebird H2 HSQLDB PostgreSQL SQLite YugabyteDB Should it matter? But back to the question. Does it really matter in terms of performance? Should it? Obviously, it shouldn’t matter. The two types of aggregate function expressions can be proven to mean exactly the same thing. And in fact, that’s what jOOQ does if you’re using FILTER on any other SQL dialect. Put the above query in our SQL translation tool, translate to Oracle, for example, and you’ll be getting: SELECT fa.actor_id, sum(CASE WHEN rating = 'R' THEN length END), sum(CASE WHEN rating = 'PG' THEN length END), sum(CASE WHEN rating = 'R' THEN length END), sum(CASE WHEN rating = 'PG' THEN length END) FROM film_actor fa LEFT JOIN film f ON f.film_id = fa.film_id GROUP BY fa.actor_id The other way should be possible as well in an optimiser. Does it matter? But is this being done? Let’s try comparing the following 2 queries on PostgreSQL, against the sakila database: Query 1: SELECT fa.actor_id, SUM(length) FILTER (WHERE rating = 'R'), SUM(length) FILTER (WHERE rating = 'PG') FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id GROUP BY fa.actor_id Query 2: SELECT fa.actor_id, SUM(CASE WHEN rating = 'R' THEN length END), SUM(CASE WHEN rating = 'PG' THEN length END) FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id GROUP BY fa.actor_id I will be using this benchmark technique, and will post the benchmark code at the end of this blog post. The results of running each query 500x are clear (less time is better): Run 1, Statement 1: 00:00:00.786621 Run 1, Statement 2: 00:00:00.839966 Run 2, Statement 1: 00:00:00.775477 Run 2, Statement 2: 00:00:00.829746 Run 3, Statement 1: 00:00:00.774942 Run 3, Statement 2: 00:00:00.834745 Run 4, Statement 1: 00:00:00.776973 Run 4, Statement 2: 00:00:00.836655 Run 5, Statement 1: 00:00:00.775871 Run 5, Statement 2: 00:00:00.845209 There’s a consistent 8% performance penalty for using the CASE syntax, compared to the FILTER syntax on my machine, running PostgreSQL 15 in docker. The actual difference in a non-benchmark query may not be as impressive, or more impressive, depending on hardware and data sets. But clearly, one thing seems to be a bit better in this case than the other. Since these types of syntaxes are typically used in a reporting context, the differences can definitely matter. Adding an auxiliary predicate You might think there’s additional optimisation potential, if we make the predicates on the RATING column redundant, like this: Query 1: SELECT fa.actor_id, SUM(length) FILTER (WHERE rating = 'R'), SUM(length) FILTER (WHERE rating = 'PG') FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id AND rating IN ('R', 'PG') -- Redundant predicate here GROUP BY fa.actor_id Query 2: SELECT fa.actor_id, SUM(CASE WHEN rating = 'R' THEN length END), SUM(CASE WHEN rating = 'PG' THEN length END) FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id AND rating IN ('R', 'PG') GROUP BY fa.actor_id Note it has to be placed in the LEFT JOIN‘s ON clause, in order not to tamper with the results. It can’t be placed in the query’s WHERE clause. An explanation for this difference is here. What will the benchmark yield now? Run 1, Statement 1: 00:00:00.701943 Run 1, Statement 2: 00:00:00.747103 Run 2, Statement 1: 00:00:00.69377 Run 2, Statement 2: 00:00:00.746252 Run 3, Statement 1: 00:00:00.684777 Run 3, Statement 2: 00:00:00.745419 Run 4, Statement 1: 00:00:00.688584 Run 4, Statement 2: 00:00:00.740979 Run 5, Statement 1: 00:00:00.688878 Run 5, Statement 2: 00:00:00.742864 So, indeed, the redundant predicate improved things (in a perfect world, it shouldn’t, but here we are. The optimiser doesn’t optimise this as well as it could). But still, the FILTER clause outperforms CASE clause usage. Conclusion In a perfect world, two provably equivalent SQL syntaxes also perform the same way. But this isn’t always the case in the real world, where optimisers make tradeoffs between: Time spent optimising rare syntaxes Time spent executing queries In a previous blog post (which is probably outdated by now), I’ve shown a lot of these cases, where the optimisation decision doesn’t depend on any cost model and data sets and should always be done, ideally. There was a tendency of such optimisations being favoured by RDBMS that have an execution plan cache (e.g. Db2, Oracle, SQL Server), in case of which the optimisation needs to be done only once per cached plan, and then the plan can be reused. In RDBMS that don’t have such a cache, optimisation time is more costly per query, so less can be expected. I think this is a case where it’s worth looking into simple patterns of expressions in aggregate functions. AGG(CASE ..) is such a popular idiom, and 8% is quite the significant improvement, that I think PostgreSQL should fix this. We’ll see. In any case, since FILTER is already: Better performing Better looking You can safely switch to this nice standard SQL syntax already now. Benchmarking While in this case, the improvement is worth it irrespective of actual measurements (because performance can hardly be worse, and readability actually improves), always be careful with such benchmark results. Do measure things yourself, and if you cannot reproduce a performance problem, then don’t necessarily touch perfectly sound logic just because a blog post told you so. Benchmark code As promised, this was the benchmark code used for this blog post: DO $$ DECLARE v_ts TIMESTAMP; v_repeat CONSTANT INT := 500; rec RECORD; BEGIN -- Repeat the whole benchmark several times to avoid warmup penalty FOR r IN 1..5 LOOP v_ts := clock_timestamp(); FOR i IN 1..v_repeat LOOP FOR rec IN ( SELECT fa.actor_id, SUM(length) FILTER (WHERE rating = 'R'), SUM(length) FILTER (WHERE rating = 'PG') FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id AND rating IN ('R', 'PG') GROUP BY fa.actor_id ) LOOP NULL; END LOOP; END LOOP; RAISE INFO 'Run %, Statement 1: %', r, (clock_timestamp() - v_ts); v_ts := clock_timestamp(); FOR i IN 1..v_repeat LOOP FOR rec IN ( SELECT fa.actor_id, SUM(CASE WHEN rating = 'R' THEN length END), SUM(CASE WHEN rating = 'PG' THEN length END) FROM film_actor AS fa LEFT JOIN film AS f ON f.film_id = fa.film_id AND rating IN ('R', 'PG') GROUP BY fa.actor_id ) LOOP NULL; END LOOP; END LOOP; RAISE INFO 'Run %, Statement 2: %', r, (clock_timestamp() - v_ts); RAISE INFO ''; END LOOP; END$$; The benchmark technique is described here.",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-11926\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eI’ve found an interesting question on Twitter, recently. Is there any performance impact of using \u003ccode\u003eFILTER\u003c/code\u003e in SQL (PostgreSQL, specifically), or is it just syntax sugar for a \u003ccode\u003eCASE\u003c/code\u003e expression in an aggregate function?\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cdiv\u003e\n\u003cblockquote data-width=\"550\" data-dnt=\"true\"\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eIs there a performance difference between CASE and FILTER scenario or it’s just a syntax sugar?\u003c/p\u003e— Ivan (@Ivan73965858) \u003ca href=\"https://twitter.com/Ivan73965858/status/1622487080088600576?ref_src=twsrc%5Etfw\"\u003eFebruary 6, 2023\u003c/a\u003e\u003c/blockquote\u003e\n\u003c/div\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eAs a quick reminder, \u003ca href=\"https://blog.jooq.org/the-awesome-postgresql-9-4-sql2003-filter-clause-for-aggregate-functions/\" data-type=\"post\" data-id=\"4852\" target=\"_blank\" rel=\"noreferrer noopener\"\u003e\u003ccode\u003eFILTER\u003c/code\u003e is an awesome standard SQL extension to filter out values before aggregating them in SQL\u003c/a\u003e. This is very useful when \u003ca href=\"https://blog.jooq.org/how-to-calculate-multiple-aggregate-functions-in-a-single-query/\" data-type=\"post\" data-id=\"6908\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eaggregating multiple things in a single query\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eThese two are the same:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  fa.actor_id,\n\n  -- These:\n  SUM(length) FILTER (WHERE rating = \u0026#39;R\u0026#39;),\n  SUM(length) FILTER (WHERE rating = \u0026#39;PG\u0026#39;),\n\n  -- Are the same as these:\n  SUM(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n  SUM(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END)\nFROM film_actor AS fa \nLEFT JOIN film AS f \n  ON f.film_id = fa.film_id\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAs of jOOQ 3.17, these SQL dialects are known to support \u003ccode\u003eFILTER\u003c/code\u003e natively:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCockroachDB\u003c/li\u003e\n\n\n\n\u003cli\u003eFirebird\u003c/li\u003e\n\n\n\n\u003cli\u003eH2\u003c/li\u003e\n\n\n\n\u003cli\u003eHSQLDB\u003c/li\u003e\n\n\n\n\u003cli\u003ePostgreSQL\u003c/li\u003e\n\n\n\n\u003cli\u003eSQLite\u003c/li\u003e\n\n\n\n\u003cli\u003eYugabyteDB\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eShould it matter?\u003c/h2\u003e\n\n\n\n\u003cp\u003eBut back to the question. Does it really matter in terms of performance? Should it? Obviously, it shouldn’t matter. The two types of aggregate function expressions can be proven to mean exactly the same thing. And in fact, that’s what jOOQ does if you’re using \u003ccode\u003eFILTER\u003c/code\u003e on any other SQL dialect. Put the above query in our SQL translation tool, translate to Oracle, for example, and you’ll be getting:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  fa.actor_id,\n  sum(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n  sum(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END),\n  sum(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n  sum(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END)\nFROM film_actor fa\n  LEFT JOIN film f\n    ON f.film_id = fa.film_id\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe other way should be possible as well in an optimiser.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDoes it matter?\u003c/h2\u003e\n\n\n\n\u003cp\u003eBut is this being done? Let’s try comparing the following 2 queries on PostgreSQL, against the \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/sakila\" data-type=\"URL\" data-id=\"https://www.jooq.org/sakila\" target=\"_blank\"\u003esakila database\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eQuery 1\u003c/strong\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  fa.actor_id,\n  SUM(length) FILTER (WHERE rating = \u0026#39;R\u0026#39;),\n  SUM(length) FILTER (WHERE rating = \u0026#39;PG\u0026#39;)\nFROM film_actor AS fa \nLEFT JOIN film AS f \n  ON f.film_id = fa.film_id\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003e\u003cstrong\u003eQuery 2\u003c/strong\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  fa.actor_id,\n  SUM(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n  SUM(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END)\nFROM film_actor AS fa \nLEFT JOIN film AS f \n  ON f.film_id = fa.film_id\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eI will be using this \u003ca rel=\"noreferrer noopener\" href=\"https://www.jooq.org/benchmark\" data-type=\"URL\" data-id=\"https://www.jooq.org/benchmark\" target=\"_blank\"\u003ebenchmark technique\u003c/a\u003e, and will post the benchmark code at the end of this blog post. The results of running each query 500x are clear (less time is better):\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eRun 1, Statement 1: 00:00:00.786621\nRun 1, Statement 2: 00:00:00.839966\n\nRun 2, Statement 1: 00:00:00.775477\nRun 2, Statement 2: 00:00:00.829746\n\nRun 3, Statement 1: 00:00:00.774942\nRun 3, Statement 2: 00:00:00.834745\n\nRun 4, Statement 1: 00:00:00.776973\nRun 4, Statement 2: 00:00:00.836655\n\nRun 5, Statement 1: 00:00:00.775871\nRun 5, Statement 2: 00:00:00.845209\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThere’s a consistent 8% performance penalty for using the \u003ccode\u003eCASE\u003c/code\u003e syntax, compared to the \u003ccode\u003eFILTER\u003c/code\u003e syntax on my machine, running PostgreSQL 15 in docker. The actual difference in a non-benchmark query may not be as impressive, or more impressive, depending on hardware and data sets. But clearly, one thing seems to be a bit better in this case than the other.\u003c/p\u003e\n\n\n\n\u003cp\u003eSince these types of syntaxes are typically used in a reporting context, the differences can definitely matter.\u003c/p\u003e\n\n\n\n\u003ch2\u003eAdding an auxiliary predicate\u003c/h2\u003e\n\n\n\n\u003cp\u003eYou might think there’s additional optimisation potential, if we make the predicates on the \u003ccode\u003eRATING\u003c/code\u003e column redundant, like this:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eQuery 1:\u003c/strong\u003e\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  fa.actor_id,\n  SUM(length) FILTER (WHERE rating = \u0026#39;R\u0026#39;),\n  SUM(length) FILTER (WHERE rating = \u0026#39;PG\u0026#39;)\nFROM film_actor AS fa \nLEFT JOIN film AS f \n  ON f.film_id = fa.film_id\n  AND rating IN (\u0026#39;R\u0026#39;, \u0026#39;PG\u0026#39;) -- Redundant predicate here\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003e\u003cstrong\u003eQuery 2:\u003c/strong\u003e\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT \n  fa.actor_id,\n  SUM(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n  SUM(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END)\nFROM film_actor AS fa \nLEFT JOIN film AS f \n  ON f.film_id = fa.film_id\n  AND rating IN (\u0026#39;R\u0026#39;, \u0026#39;PG\u0026#39;)\nGROUP BY fa.actor_id\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNote it has to be placed in the \u003ccode\u003eLEFT JOIN\u003c/code\u003e‘s \u003ccode\u003eON\u003c/code\u003e clause, in order not to tamper with the results. It can’t be placed in the query’s \u003ccode\u003eWHERE\u003c/code\u003e clause. \u003ca href=\"https://blog.jooq.org/the-difference-between-sqls-join-on-clause-and-the-where-clause/\" data-type=\"post\" data-id=\"8029\" target=\"_blank\" rel=\"noreferrer noopener\"\u003eAn explanation for this difference is here\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003cp\u003eWhat will the benchmark yield now?\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eRun 1, Statement 1: 00:00:00.701943\nRun 1, Statement 2: 00:00:00.747103\n\nRun 2, Statement 1: 00:00:00.69377\nRun 2, Statement 2: 00:00:00.746252\n\nRun 3, Statement 1: 00:00:00.684777\nRun 3, Statement 2: 00:00:00.745419\n\nRun 4, Statement 1: 00:00:00.688584\nRun 4, Statement 2: 00:00:00.740979\n\nRun 5, Statement 1: 00:00:00.688878\nRun 5, Statement 2: 00:00:00.742864\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eSo, indeed, the redundant predicate improved things (in a perfect world, it shouldn’t, but here we are. The optimiser doesn’t optimise this as well as it could). But still, the \u003ccode\u003eFILTER\u003c/code\u003e clause outperforms \u003ccode\u003eCASE\u003c/code\u003e clause usage.\u003c/p\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn a perfect world, two provably equivalent SQL syntaxes also perform the same way. But this isn’t always the case in the real world, where optimisers make tradeoffs between:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eTime spent optimising rare syntaxes\u003c/li\u003e\n\n\n\n\u003cli\u003eTime spent executing queries\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn a previous blog post (which is probably outdated by now), I’ve shown a lot of these cases, \u003ca rel=\"noreferrer noopener\" href=\"https://blog.jooq.org/10-cool-sql-optimisations-that-do-not-depend-on-the-cost-model/\" data-type=\"post\" data-id=\"7286\" target=\"_blank\"\u003ewhere the optimisation decision doesn’t depend on any cost model and data sets and should always be done, ideally\u003c/a\u003e. There was a tendency of such optimisations being favoured by RDBMS that have an execution plan cache (e.g. Db2, Oracle, SQL Server), in case of which the optimisation needs to be done only once per cached plan, and then the plan can be reused. In RDBMS that don’t have such a cache, optimisation time is more costly per query, so less can be expected.\u003c/p\u003e\n\n\n\n\u003cp\u003eI think this is a case where it’s worth looking into simple patterns of expressions in aggregate functions. \u003ccode\u003eAGG(CASE ..)\u003c/code\u003e is such a popular idiom, and 8% is quite the significant improvement, that I think PostgreSQL should fix this. We’ll see. In any case, since \u003ccode\u003eFILTER\u003c/code\u003e is already:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eBetter performing\u003c/li\u003e\n\n\n\n\u003cli\u003eBetter looking\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eYou can safely switch to this nice standard SQL syntax already now.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBenchmarking\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhile in this case, the improvement is worth it irrespective of actual measurements (because performance can hardly be worse, and readability actually improves), always be careful with such benchmark results. Do measure things yourself, and if you cannot reproduce a performance problem, then don’t necessarily touch perfectly sound logic just because a blog post told you so.\u003c/p\u003e\n\n\n\n\u003ch2\u003eBenchmark code\u003c/h2\u003e\n\n\n\n\u003cp\u003eAs promised, this was the benchmark code used for this blog post:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eDO $$\nDECLARE\n  v_ts TIMESTAMP;\n  v_repeat CONSTANT INT := 500;\n  rec RECORD;\nBEGIN\n\n  -- Repeat the whole benchmark several times to avoid warmup penalty\n  FOR r IN 1..5 LOOP\n    v_ts := clock_timestamp();\n\n    FOR i IN 1..v_repeat LOOP\n      FOR rec IN (\n        SELECT \n          fa.actor_id,\n          SUM(length) FILTER (WHERE rating = \u0026#39;R\u0026#39;),\n          SUM(length) FILTER (WHERE rating = \u0026#39;PG\u0026#39;)\n        FROM film_actor AS fa \n        LEFT JOIN film AS f \n          ON f.film_id = fa.film_id\n          AND rating IN (\u0026#39;R\u0026#39;, \u0026#39;PG\u0026#39;)\n        GROUP BY fa.actor_id\n      ) LOOP\n        NULL;\n      END LOOP;\n    END LOOP;\n\n    RAISE INFO \u0026#39;Run %, Statement 1: %\u0026#39;, r, (clock_timestamp() - v_ts);\n    v_ts := clock_timestamp();\n\n    FOR i IN 1..v_repeat LOOP\n      FOR rec IN (\n        SELECT \n          fa.actor_id,\n          SUM(CASE WHEN rating = \u0026#39;R\u0026#39; THEN length END),\n          SUM(CASE WHEN rating = \u0026#39;PG\u0026#39; THEN length END)\n        FROM film_actor AS fa \n        LEFT JOIN film AS f \n          ON f.film_id = fa.film_id\n          AND rating IN (\u0026#39;R\u0026#39;, \u0026#39;PG\u0026#39;)\n        GROUP BY fa.actor_id\n      ) LOOP\n        NULL;\n      END LOOP;\n    END LOOP;\n\n    RAISE INFO \u0026#39;Run %, Statement 2: %\u0026#39;, r, (clock_timestamp() - v_ts);\n    RAISE INFO \u0026#39;\u0026#39;;\n  END LOOP;\nEND$$;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe \u003ca href=\"https://www.jooq.org/benchmark\" data-type=\"URL\" data-id=\"https://www.jooq.org/benchmark\" target=\"_blank\" rel=\"noreferrer noopener\"\u003ebenchmark technique is described here\u003c/a\u003e.\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2023-02-06T07:51:38Z",
  "modifiedTime": "2023-02-07T07:53:15Z"
}
