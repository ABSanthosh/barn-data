{
  "id": "72385365-6fa5-40ad-b0c5-c455eaac7266",
  "title": "Updating to .NET 8, updating to IHostBuilder, and running Playwright Tests within NUnit headless or headed on any OS",
  "link": "http://feeds.hanselman.com/~/873234002/0/scotthanselman~Updating-to-NET-updating-to-IHostBuilder-and-running-Playwright-Tests-within-NUnit-headless-or-headed-on-any-OS",
  "description": "I've been doing not just Unit Testing for my sites but full on Integration Testing and Browser Automation Testing as early as 2007 with Selenium. Lately, however, I've been using the faster and generally more compatible Playwright. It has one API and can test on Windows, Linux, Mac, locally, in a container (headless), in my CI/CD pipeline, on Azure DevOps, or in GitHub Actions. For me, it's that last moment of truth to make sure that the site runs completely from end to end. I can write those Playwright tests in something like TypeScript, and I could launch them with node, but I like running end unit tests and using that test runner and test harness as my jumping off point for my .NET applications. I'm used to right clicking and \"run unit tests\" or even better, right click and \"debug unit tests\" in Visual Studio or VS Code. This gets me the benefit of all of the assertions of a full unit testing framework, and all the benefits of using something like Playwright to automate my browser. In 2018 I was using WebApplicationFactory and some tricky hacks to basically spin up ASP.NET within .NET (at the time) Core 2.1 within the unit tests and then launching Selenium. This was kind of janky and would require to manually start a separate process and manage its life cycle. However, I kept on with this hack for a number of years basically trying to get the Kestrel Web Server to spin up inside of my unit tests. I've recently upgraded my main site and podcast site to .NET 8. Keep in mind that I've been moving my websites forward from early early versions of .NET to the most recent versions. The blog is happily running on Linux in a container on .NET 8, but its original code started in 2002 on .NET 1.1. Now that I'm on .NET 8, I scandalously discovered (as my unit tests stopped working) that the rest of the world had moved from IWebHostBuilder to IHostBuilder five version of .NET ago. Gulp. Say what you will, but the backward compatibility is impressive. As such my code for Program.cs changed from thispublic static void Main(string[] args){ CreateWebHostBuilder(args).Build().Run();}public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u003e WebHost.CreateDefaultBuilder(args) .UseStartup(); to this:public static void Main(string[] args){ CreateHostBuilder(args).Build().Run();}public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args). ConfigureWebHostDefaults(WebHostBuilder =\u003e WebHostBuilder.UseStartup()); Not a major change on the outside but tidies things up on the inside and sets me up with a more flexible generic host for my web app. My unit tests stopped working because my Kestral Web Server hack was no longer firing up my server. Here is an example of my goal from a Playwright perspective within a .NET NUnit test. [Test]public async Task DoesSearchWork(){ await Page.GotoAsync(Url); await Page.Locator(\"#topbar\").GetByRole(AriaRole.Link, new() { Name = \"episodes\" }).ClickAsync(); await Page.GetByPlaceholder(\"search and filter\").ClickAsync(); await Page.GetByPlaceholder(\"search and filter\").TypeAsync(\"wife\"); const string visibleCards = \".showCard:visible\"; var waiting = await Page.WaitForSelectorAsync(visibleCards, new PageWaitForSelectorOptions() { Timeout = 500 }); await Expect(Page.Locator(visibleCards).First).ToBeVisibleAsync(); await Expect(Page.Locator(visibleCards)).ToHaveCountAsync(5);} I love this. Nice and clean. Certainly here we are assuming that we have a URL in that first line, which will be localhost something, and then we assume that our web application has started up on its own. Here is the setup code that starts my new \"web application test builder factory,\" yeah, the name is stupid but it's descriptive. Note the OneTimeSetUp and the OneTimeTearDown. This starts my web app within the context of my TestHost. Note the :0 makes the app find a port which I then, sadly, have to dig out and put into the Url private for use within my Unit Tests. Note that the is in fact my Startup class within Startup.cs which hosts my app's pipeline and Configure and ConfigureServices get setup here so routing all works.private string Url;private WebApplication? _app = null;[OneTimeSetUp]public void Setup(){ var builder = WebApplicationTestBuilderFactory.CreateBuilder(); var startup = new Startup(builder.Environment); builder.WebHost.ConfigureKestrel(o =\u003e o.Listen(IPAddress.Loopback, 0)); startup.ConfigureServices(builder.Services); _app = builder.Build(); // listen on any local port (hence the 0) startup.Configure(_app, _app.Configuration); _app.Start(); //you are kidding me Url = _app.Services.GetRequiredService().Features.GetRequiredFeature().Addresses.Last();}[OneTimeTearDown]public async Task TearDown(){ await _app.DisposeAsync();} So what horrors are buried in WebApplicationTestBuilderFactory? The first bit is bad and we should fix it for .NET 9. The rest is actually every nice, with a hat tip to David Fowler for his help and guidance! This is the magic and the ick in one small helper class.public class WebApplicationTestBuilderFactory { public static WebApplicationBuilder CreateBuilder() where T : class { //This ungodly code requires an unused reference to the MvcTesting package that hooks up // MSBuild to create the manifest file that is read here. var testLocation = Path.Combine(AppContext.BaseDirectory, \"MvcTestingAppManifest.json\"); var json = JsonObject.Parse(File.ReadAllText(testLocation)); var asmFullName = typeof(T).Assembly.FullName ?? throw new InvalidOperationException(\"Assembly Full Name is null\"); var contentRootPath = json?[asmFullName]?.GetValue(); //spin up a real live web application inside TestHost.exe var builder = WebApplication.CreateBuilder( new WebApplicationOptions() { ContentRootPath = contentRootPath, ApplicationName = asmFullName }); return builder; }} The first 4 lines are nasty. Because the test runs in the context of a different directory and my website needs to run within the context of its own content root path, I have to force the content root path to be correct and the only way to do that is by getting the apps base directory from a file generated within MSBuild from the (aging) MvcTesting package. The package is not used, but by referencing it it gets into the build and makes that file that I then use to pull out the directory. If we can get rid of that \"hack\" and pull the directory from context elsewhere, then this helper function turns into a single line and .NET 9 gets WAY WAY more testable! Now I can run my Unit Tests AND Playwright Browser Integration Tests across all OS's, headed or headless, in docker or on the metal. The site is updated to .NET 8 and all is right with my code. Well, it runs at least. ;)© 2021 Scott Hanselman. All rights reserved.",
  "author": "Scott Hanselman",
  "published": "Thu, 07 Mar 2024 01:12:13 GMT",
  "source": "http://feeds.hanselman.com/ScottHanselman",
  "categories": [
    "ASP.NET",
    "DotNetCore"
  ],
  "byline": "Scott Hanselman",
  "length": 7529,
  "excerpt": "I've been doing not just Unit Testing for my sites but full on Integration ...",
  "siteName": "",
  "favicon": "https://images.hanselman.com/main/apple-touch-icon-114x114.png",
  "text": "I've been doing not just Unit Testing for my sites but full on Integration Testing and Browser Automation Testing as early as 2007 with Selenium. Lately, however, I've been using the faster and generally more compatible Playwright. It has one API and can test on Windows, Linux, Mac, locally, in a container (headless), in my CI/CD pipeline, on Azure DevOps, or in GitHub Actions. For me, it's that last moment of truth to make sure that the site runs completely from end to end. I can write those Playwright tests in something like TypeScript, and I could launch them with node, but I like running end unit tests and using that test runner and test harness as my jumping off point for my .NET applications. I'm used to right clicking and \"run unit tests\" or even better, right click and \"debug unit tests\" in Visual Studio or VS Code. This gets me the benefit of all of the assertions of a full unit testing framework, and all the benefits of using something like Playwright to automate my browser. In 2018 I was using WebApplicationFactory and some tricky hacks to basically spin up ASP.NET within .NET (at the time) Core 2.1 within the unit tests and then launching Selenium. This was kind of janky and would require to manually start a separate process and manage its life cycle. However, I kept on with this hack for a number of years basically trying to get the Kestrel Web Server to spin up inside of my unit tests. I've recently upgraded my main site and podcast site to .NET 8. Keep in mind that I've been moving my websites forward from early early versions of .NET to the most recent versions. The blog is happily running on Linux in a container on .NET 8, but its original code started in 2002 on .NET 1.1. Now that I'm on .NET 8, I scandalously discovered (as my unit tests stopped working) that the rest of the world had moved from IWebHostBuilder to IHostBuilder five version of .NET ago. Gulp. Say what you will, but the backward compatibility is impressive. As such my code for Program.cs changed from thispublic static void Main(string[] args){ CreateWebHostBuilder(args).Build().Run();}public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u003e WebHost.CreateDefaultBuilder(args) .UseStartup\u003cStartup\u003e(); to this:public static void Main(string[] args){ CreateHostBuilder(args).Build().Run();}public static IHostBuilder CreateHostBuilder(string[] args) =\u003e Host.CreateDefaultBuilder(args). ConfigureWebHostDefaults(WebHostBuilder =\u003e WebHostBuilder.UseStartup\u003cStartup\u003e()); Not a major change on the outside but tidies things up on the inside and sets me up with a more flexible generic host for my web app. My unit tests stopped working because my Kestral Web Server hack was no longer firing up my server. Here is an example of my goal from a Playwright perspective within a .NET NUnit test. [Test]public async Task DoesSearchWork(){ await Page.GotoAsync(Url); await Page.Locator(\"#topbar\").GetByRole(AriaRole.Link, new() { Name = \"episodes\" }).ClickAsync(); await Page.GetByPlaceholder(\"search and filter\").ClickAsync(); await Page.GetByPlaceholder(\"search and filter\").TypeAsync(\"wife\"); const string visibleCards = \".showCard:visible\"; var waiting = await Page.WaitForSelectorAsync(visibleCards, new PageWaitForSelectorOptions() { Timeout = 500 }); await Expect(Page.Locator(visibleCards).First).ToBeVisibleAsync(); await Expect(Page.Locator(visibleCards)).ToHaveCountAsync(5);} I love this. Nice and clean. Certainly here we are assuming that we have a URL in that first line, which will be localhost something, and then we assume that our web application has started up on its own. Here is the setup code that starts my new \"web application test builder factory,\" yeah, the name is stupid but it's descriptive. Note the OneTimeSetUp and the OneTimeTearDown. This starts my web app within the context of my TestHost. Note the :0 makes the app find a port which I then, sadly, have to dig out and put into the Url private for use within my Unit Tests. Note that the \u003cStartup\u003e is in fact my Startup class within Startup.cs which hosts my app's pipeline and Configure and ConfigureServices get setup here so routing all works.private string Url;private WebApplication? _app = null;[OneTimeSetUp]public void Setup(){ var builder = WebApplicationTestBuilderFactory.CreateBuilder\u003cStartup\u003e(); var startup = new Startup(builder.Environment); builder.WebHost.ConfigureKestrel(o =\u003e o.Listen(IPAddress.Loopback, 0)); startup.ConfigureServices(builder.Services); _app = builder.Build(); // listen on any local port (hence the 0) startup.Configure(_app, _app.Configuration); _app.Start(); //you are kidding me Url = _app.Services.GetRequiredService\u003cIServer\u003e().Features.GetRequiredFeature\u003cIServerAddressesFeature\u003e().Addresses.Last();}[OneTimeTearDown]public async Task TearDown(){ await _app.DisposeAsync();} So what horrors are buried in WebApplicationTestBuilderFactory? The first bit is bad and we should fix it for .NET 9. The rest is actually every nice, with a hat tip to David Fowler for his help and guidance! This is the magic and the ick in one small helper class.public class WebApplicationTestBuilderFactory { public static WebApplicationBuilder CreateBuilder\u003cT\u003e() where T : class { //This ungodly code requires an unused reference to the MvcTesting package that hooks up // MSBuild to create the manifest file that is read here. var testLocation = Path.Combine(AppContext.BaseDirectory, \"MvcTestingAppManifest.json\"); var json = JsonObject.Parse(File.ReadAllText(testLocation)); var asmFullName = typeof(T).Assembly.FullName ?? throw new InvalidOperationException(\"Assembly Full Name is null\"); var contentRootPath = json?[asmFullName]?.GetValue\u003cstring\u003e(); //spin up a real live web application inside TestHost.exe var builder = WebApplication.CreateBuilder( new WebApplicationOptions() { ContentRootPath = contentRootPath, ApplicationName = asmFullName }); return builder; }} The first 4 lines are nasty. Because the test runs in the context of a different directory and my website needs to run within the context of its own content root path, I have to force the content root path to be correct and the only way to do that is by getting the apps base directory from a file generated within MSBuild from the (aging) MvcTesting package. The package is not used, but by referencing it it gets into the build and makes that file that I then use to pull out the directory. If we can get rid of that \"hack\" and pull the directory from context elsewhere, then this helper function turns into a single line and .NET 9 gets WAY WAY more testable! Now I can run my Unit Tests AND Playwright Browser Integration Tests across all OS's, headed or headless, in docker or on the metal. The site is updated to .NET 8 and all is right with my code. Well, it runs at least. ;) About Scott Scott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author. About   Newsletter Hosting By",
  "image": "https://www.hanselman.com/blog/content/binary/Windows-Live-Writer/78fe85887e7e_1244B/image_8b82f0d7-a3bc-4403-96c3-9dd36fc46d1f.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n            \n            \u003cp\u003e\u003cimg title=\"All the Unit Tests pass\" alt=\"All the Unit Tests pass\" src=\"https://hanselmanblogcontent.azureedge.net/Windows-Live-Writer/78fe85887e7e_1244B/image_8b82f0d7-a3bc-4403-96c3-9dd36fc46d1f.png\" width=\"475\" height=\"437\"/\u003eI\u0026#39;ve been doing not just Unit Testing for my sites but full on Integration Testing and Browser Automation Testing as early as 2007 with Selenium. Lately, however, I\u0026#39;ve been using the faster and generally more compatible \u003ca href=\"https://playwright.dev/\"\u003ePlaywright\u003c/a\u003e. It has one API and can test on Windows, Linux, Mac, locally, in a container (headless), in my CI/CD pipeline, on Azure DevOps, or in GitHub Actions. \u003c/p\u003e \u003cp\u003eFor me, it\u0026#39;s that last moment of truth to make sure that the site runs completely from end to end.\u003c/p\u003e \u003cp\u003eI can write those Playwright tests in something like TypeScript, and I could launch them with node, but I like running end unit tests and using that test runner and test harness as my jumping off point for my .NET applications. I\u0026#39;m used to right clicking and \u0026#34;run unit tests\u0026#34; or even better, right click and \u0026#34;debug unit tests\u0026#34; in Visual Studio or VS Code. This gets me the benefit of all of the assertions of a full unit testing framework, and all the benefits of using something like Playwright to automate my browser. \u003c/p\u003e \u003cp\u003e\u003ca href=\"https://www.hanselman.com/blog/real-browser-integration-testing-with-selenium-standalone-chrome-and-aspnet-core-21\"\u003eIn 2018 I was using WebApplicationFactory\u003c/a\u003e and some tricky hacks to basically spin up ASP.NET within .NET (at the time) Core 2.1 within the unit tests and then launching Selenium. This was kind of janky and would require to manually start a separate process and manage its life cycle. However, I kept on with this hack for a number of years basically trying to get the Kestrel Web Server to spin up inside of my unit tests.\u003c/p\u003e \u003cp\u003eI\u0026#39;ve recently upgraded my main site and podcast site to .NET 8. Keep in mind that I\u0026#39;ve been moving my websites forward from early early versions of .NET to the most recent versions. The blog is happily running on Linux in a container on .NET 8, but its original code started in 2002 on .NET 1.1.\u003c/p\u003e \u003cp\u003eNow that I\u0026#39;m on .NET 8, I scandalously discovered (as my unit tests stopped working) \u003ca href=\"https://learn.microsoft.com/en-us/aspnet/core/migration/22-to-30?view=aspnetcore-3.1\u0026amp;tabs=visual-studio#hostbuilder-replaces-webhostbuilder\"\u003ethat the rest of the world had moved from IWebHostBuilder to IHostBuilder five version of .NET ago\u003c/a\u003e. Gulp. Say what you will, but the backward compatibility is impressive. \u003c/p\u003e \u003cp\u003eAs such my code for Program.cs changed from this\u003c/p\u003e\u003cpre\u003epublic static void Main(string[] args)\u003cbr/\u003e{\u003cbr/\u003e    CreateWebHostBuilder(args).Build().Run();\u003cbr/\u003e}\u003cp\u003epublic static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u0026gt;\u003cbr/\u003e    WebHost.CreateDefaultBuilder(args)\u003cbr/\u003e        .UseStartup\u0026lt;Startup\u0026gt;();\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eto this:\u003c/p\u003e\u003cpre\u003epublic static void Main(string[] args)\u003cbr/\u003e{\u003cbr/\u003e  CreateHostBuilder(args).Build().Run();\u003cbr/\u003e}\u003cp\u003epublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt;\u003cbr/\u003e  Host.CreateDefaultBuilder(args).\u003cbr/\u003e      ConfigureWebHostDefaults(WebHostBuilder =\u0026gt; WebHostBuilder.UseStartup\u0026lt;Startup\u0026gt;());\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eNot a major change on the outside but tidies things up on the inside and sets me up with \u003ca href=\"https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-3.1\"\u003ea more flexible generic host for my web app\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMy unit tests stopped working because my Kestral Web Server hack was no longer firing up my server. \u003c/p\u003e\n\u003cp\u003eHere is an example of my goal from a Playwright perspective within a .NET NUnit test. \u003c/p\u003e\u003cpre\u003e[Test]\u003cbr/\u003epublic async Task DoesSearchWork()\u003cbr/\u003e{\u003cbr/\u003e    await Page.GotoAsync(Url);\u003cp\u003e    await Page.Locator(\u0026#34;#topbar\u0026#34;).GetByRole(AriaRole.Link, new() { Name = \u0026#34;episodes\u0026#34; }).ClickAsync();\u003c/p\u003e\u003cp\u003e    await Page.GetByPlaceholder(\u0026#34;search and filter\u0026#34;).ClickAsync();\u003c/p\u003e\u003cp\u003e    await Page.GetByPlaceholder(\u0026#34;search and filter\u0026#34;).TypeAsync(\u0026#34;wife\u0026#34;);\u003c/p\u003e\u003cp\u003e    const string visibleCards = \u0026#34;.showCard:visible\u0026#34;;\u003c/p\u003e\u003cp\u003e    var waiting = await Page.WaitForSelectorAsync(visibleCards, new PageWaitForSelectorOptions() { Timeout = 500 });\u003c/p\u003e\u003cp\u003e    await Expect(Page.Locator(visibleCards).First).ToBeVisibleAsync();\u003c/p\u003e\u003cp\u003e    await Expect(Page.Locator(visibleCards)).ToHaveCountAsync(5);\u003cbr/\u003e}\n\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eI love this. Nice and clean. Certainly here we are assuming that we have a URL in that first line, which will be localhost something, and then we assume that our web application has started up on its own. \u003c/p\u003e\n\u003cp\u003eHere is the setup code that starts my new \u0026#34;web application test builder factory,\u0026#34; yeah, the name is stupid but it\u0026#39;s descriptive. Note the OneTimeSetUp and the OneTimeTearDown. This starts my web app within the context of my TestHost. Note the :0 makes the app find a port which I then, sadly, have to dig out and put into the Url private for use within my Unit Tests. Note that the \u0026lt;Startup\u0026gt; is in fact my Startup class within Startup.cs which hosts my app\u0026#39;s pipeline and Configure and ConfigureServices get setup here so routing all works.\u003c/p\u003e\u003cpre\u003eprivate string Url;\u003cbr/\u003eprivate WebApplication? _app = null;\u003cp\u003e[OneTimeSetUp]\u003cbr/\u003epublic void Setup()\u003cbr/\u003e{\u003cbr/\u003e    var builder = WebApplicationTestBuilderFactory.CreateBuilder\u0026lt;Startup\u0026gt;();\u003c/p\u003e\u003cp\u003e    var startup = new Startup(builder.Environment);\u003cbr/\u003e    builder.WebHost.ConfigureKestrel(o =\u0026gt; o.Listen(IPAddress.Loopback, 0));\u003cbr/\u003e    startup.ConfigureServices(builder.Services);\u003cbr/\u003e    _app = builder.Build();\u003c/p\u003e\u003cp\u003e    // listen on any local port (hence the 0)\u003cbr/\u003e    startup.Configure(_app, _app.Configuration);\u003cbr/\u003e    _app.Start();\u003c/p\u003e\u003cp\u003e    //you are kidding me\u003cbr/\u003e    Url = _app.Services.GetRequiredService\u0026lt;IServer\u0026gt;().Features.GetRequiredFeature\u0026lt;IServerAddressesFeature\u0026gt;().Addresses.Last();\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003e[OneTimeTearDown]\u003cbr/\u003epublic async Task TearDown()\u003cbr/\u003e{\u003cbr/\u003e    await _app.DisposeAsync();\u003cbr/\u003e}\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eSo what horrors are buried in WebApplicationTestBuilderFactory? The first bit is bad and we should fix it for .NET 9. The rest is actually every nice, with a hat tip to David Fowler for his help and guidance! This is the magic and the ick in one small helper class.\u003c/p\u003e\u003cpre\u003epublic class WebApplicationTestBuilderFactory \u003cbr/\u003e{\u003cbr/\u003e    public static WebApplicationBuilder CreateBuilder\u0026lt;T\u0026gt;() where T : class \u003cbr/\u003e    {\u003cbr/\u003e        //This ungodly code requires an unused reference to the MvcTesting package that hooks up\u003cbr/\u003e        //  MSBuild to create the manifest file that is read here.\u003cbr/\u003e        var testLocation = Path.Combine(AppContext.BaseDirectory, \u0026#34;MvcTestingAppManifest.json\u0026#34;);\u003cbr/\u003e        var json = JsonObject.Parse(File.ReadAllText(testLocation));\u003cbr/\u003e        var asmFullName = typeof(T).Assembly.FullName ?? throw new InvalidOperationException(\u0026#34;Assembly Full Name is null\u0026#34;);\u003cbr/\u003e        var contentRootPath = json?[asmFullName]?.GetValue\u0026lt;string\u0026gt;();\u003cp\u003e        //spin up a real live web application inside TestHost.exe\u003cbr/\u003e        var builder = WebApplication.CreateBuilder(\u003cbr/\u003e            new WebApplicationOptions()\u003cbr/\u003e            {\u003cbr/\u003e                ContentRootPath = contentRootPath,\u003cbr/\u003e                ApplicationName = asmFullName\u003cbr/\u003e            });\u003cbr/\u003e        return builder;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/pre\u003e\n\u003cp\u003eThe first 4 lines are nasty. Because the test runs in the context of a different directory and my website needs to run within the context of its own content root path, I have to force the content root path to be correct and the only way to do that is by getting the apps base directory from a file generated within MSBuild from the (aging) MvcTesting package. The package is not used, but by referencing it it gets into the build and makes that file that I then use to pull out the directory. \u003c/p\u003e\n\u003cp\u003eIf we can get rid of that \u0026#34;hack\u0026#34; and pull the directory from context elsewhere, then this helper function turns into a single line and .NET 9 gets WAY WAY more testable!\u003c/p\u003e\n\u003cp\u003eNow I can run my Unit Tests AND Playwright Browser Integration Tests across all OS\u0026#39;s, headed or headless, in docker or on the metal. The site is updated to .NET 8 and all is right with my code. Well, it runs at least. ;)\u003c/p\u003e\n\n\n\n            \u003cdiv\u003e\n                \u003cdiv\u003e\n                    \u003ch4\u003eAbout Scott\u003c/h4\u003e\n                    \u003cdiv\u003e\n                        \u003cp\u003eScott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author.\u003c/p\u003e\n                        \u003cp\u003e\u003ca href=\"https://facebook.com/shanselman\"\u003e\u003cimg src=\"http://images.hanselman.com/main/icon-fb.png\" alt=\"facebook\"/\u003e\u003c/a\u003e\n                        \u003ca href=\"https://twitter.com/shanselman\"\u003e\u003cimg src=\"http://images.hanselman.com/main/icon-twitter.png\" alt=\"twitter\"/\u003e\u003c/a\u003e\n                        \u003ca href=\"http://feeds.hanselman.com/ScottHanselman\"\u003e\u003cimg src=\"http://images.hanselman.com/main/icon-rss.png\" alt=\"subscribe\"/\u003e\u003c/a\u003e\u003cbr/\u003e\n                        \u003ca href=\"http://hanselman.com/about\"\u003eAbout\u003c/a\u003e   \u003ca href=\"http://www.hanselman.com/newsletter\"\u003eNewsletter\u003c/a\u003e\n                    \u003c/p\u003e\u003c/div\u003e\n                \u003c/div\u003e\n\n                \u003cdiv\u003e\n                    \u003cp\u003e\u003cstrong\u003eHosting By\u003c/strong\u003e\u003cbr/\u003e\n                        \u003ca rel=\"nofollow\" href=\"https://azure.microsoft.com/free\"\u003e\u003cimg alt=\"Hosted in an Azure App Service\" width=\"125\" height=\"125\" src=\"http://images.hanselman.com/main/azure-250x250.png\"/\u003e\u003c/a\u003e\n                    \u003c/p\u003e\n\n                \u003c/div\u003e\n            \u003c/div\u003e\n\n            \n\n\n            \n\n            \n        \u003c/section\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": null,
  "modifiedTime": null
}
