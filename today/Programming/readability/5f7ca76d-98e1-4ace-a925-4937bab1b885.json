{
  "id": "5f7ca76d-98e1-4ace-a925-4937bab1b885",
  "title": "OpenAI Releases Swarm, an Experimental Open-Source Framework for Multi-Agent Orchestration",
  "link": "https://www.infoq.com/news/2024/10/openai-swarm-orchestration/?utm_campaign=infoq_content\u0026utm_source=infoq\u0026utm_medium=feed\u0026utm_term=global",
  "description": "Recently released as an experimental tool, Swarm aims to allow developers investigate how they can have multiple agents coordinate with one another to execute tasks using routines and handoffs. By Sergio De Simone",
  "author": "Sergio De Simone",
  "published": "Sun, 20 Oct 2024 10:00:00 GMT",
  "source": "https://feed.infoq.com",
  "categories": [
    "OpenAI",
    "ChatGPT",
    "Agents",
    "AI, ML \u0026 Data Engineering",
    "news"
  ],
  "byline": "Sergio De Simone",
  "length": 4470,
  "excerpt": "Recently released as an experimental tool, Swarm aims to allow developers investigate how they can have multiple agents coordinate with one another to execute tasks using routines and handoffs.",
  "siteName": "InfoQ",
  "favicon": "https://cdn.infoq.com/statics_s1_20241001113528/apple-touch-icon.png",
  "text": "Recently released as an experimental tool, Swarm aims to allow developers investigate how they can have multiple agents coordinate with one another to execute tasks using routines and handoffs. Multi-agent systems are an approach to building more complex AI systems where a task is broken into subtasks. Each task is then assigned to a specialized agent that is able to choose the most appropriate strategy to solve it. For example, you could build a shopper agent with two sub-agents, one managing refunds and the other managing sales, with a third agent, a triage agent, determining which sub-agent should handle a new request. Swarm explores patterns that are lightweight, scalable, and highly customizable by design. Approaches similar to Swarm are best suited for situations dealing with a large number of independent capabilities and instructions that are difficult to encode into a single prompt. As mentioned, Swarm is based on the concepts of routines and handoffs. In this context, a routine is a set of steps and tools to execute them, while a handoff represents the action of an agent handing off a conversation to another agent. This implies loading the corresponding routine and provide it with all the context accumulated during the previous conversation. For example, the following snippet shows how you could define a sale and a refund agent: def execute_refund(item_name): return \"success\" refund_agent = Agent( name=\"Refund Agent\", instructions=\"You are a refund agent. Help the user with refunds.\", tools=[execute_refund], ) def place_order(item_name): return \"success\" sales_assistant = Agent( name=\"Sales Assistant\", instructions=\"You are a sales assistant. Sell the user a product.\", tools=[place_order], ) To manage handoffs, you can define a triage agent like in the following snippet which includes two functions, transfer_to_sales_agent, transfer_to_refund_agent that return their corresponding agent. You also need to add a transfer_to_triage_agent tool to our refund_agent and sales_assistant definitions. triage_agent = Agent( name=\"Triage Agent\", instructions=( \"Gather information to direct the customer to the right department.\" ), tools=[transfer_to_sales_agent, transfer_to_refund_agent], ) ... refund_agent = Agent( ... tools=[execute_refund, transfer_to_triage_agent], ) ... sales_assistant = Agent( ... tools=[place_order, transfer_to_triage_agent], ) The pattern described above, where you use a triage agent, is just one way to manage handoffs and Swarm supports the use of distinct solutions. Examples of alternative frameworks to create multi-agent systems are Microsoft's AutoGen, CrewAI, and AgentKit. Each of them takes a different stance about how to orchestrate agents and which aspects are essential to it. Multi-agent systems aim to enable the creation of more complex systems by working around some limitations of LLMs, like single-turn responses, lack of long-term memory, and reasoning depth. It is important to understand, though, that decomposing a complex agent into a multi-agent system is not necessarily an easy task. As Hacker News commenter ValentinA23 points out, the process \"is very time consuming though, as it requires experimenting to determine how best to divide one task into subtasks, including writing code to parse and sanitize each task output and plug it back into the rest of the agent graph though, as it requires experimenting to determine how best to divide one task into subtasks, including writing code to parse and sanitize each task output and plug it back into the rest of the agent graph\". Another Hacker News commenter, LASR, raises a concern that the distinct agents will diverge in time The problem with agents is divergence. Very quickly, an ensemble of agents will start doing their own things and itâ€™s impossible to get something that consistently gets to your desired state. Finally, Hacker News user dimitri-vs mentions that the fast evolution of current LLMs, e.g., GPT o1 and Sonnet 3.5, makes it so that \"it is much easier to swap in a single API call and modify one or two prompts than to rework a convoluted agentic approach. Especially when it's very clear that the same prompts can't be reused reliably between different models\". About the Author Sergio De Simone",
  "image": "https://res.infoq.com/news/2024/10/openai-swarm-orchestration/en/headerimage/openai-swarm-1729415240889.jpeg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\t\t\t\t\t\t\t\t\u003cp\u003eRecently released as an experimental tool, \u003ca href=\"https://github.com/openai/swarm\"\u003eSwarm aims to allow developers investigate how they can have multiple agents coordinate\u003c/a\u003e with one another to \u003ca href=\"https://cookbook.openai.com/examples/orchestrating_agents\"\u003eexecute tasks using \u003cem\u003eroutines\u003c/em\u003e and \u003cem\u003ehandoffs\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eMulti-agent systems are an approach to building more complex AI systems where a task is broken into subtasks. Each task is then assigned to a specialized agent that is able to choose the most appropriate strategy to solve it. For example, you could build a shopper agent with two sub-agents, one managing refunds and the other managing sales, with a third agent, a triage agent, determining which sub-agent should handle a new request.\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eSwarm explores patterns that are lightweight, scalable, and highly customizable by design. Approaches similar to Swarm are best suited for situations dealing with a large number of independent capabilities and instructions that are difficult to encode into a single prompt.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eAs mentioned, Swarm is based on the concepts of routines and handoffs. In this context, a routine is a set of steps and tools to execute them, while a handoff represents the action of an agent handing off a conversation to another agent. This implies loading the corresponding routine and provide it with all the context accumulated during the previous conversation. For example, the following snippet shows how you could define a sale and a refund agent:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003edef execute_refund(item_name):\n    return \u0026#34;success\u0026#34;\n\nrefund_agent = Agent(\n    name=\u0026#34;Refund Agent\u0026#34;,\n    instructions=\u0026#34;You are a refund agent. Help the user with refunds.\u0026#34;,\n    tools=[execute_refund],\n)\n\ndef place_order(item_name):\n    return \u0026#34;success\u0026#34;\n\nsales_assistant = Agent(\n    name=\u0026#34;Sales Assistant\u0026#34;,\n    instructions=\u0026#34;You are a sales assistant. Sell the user a product.\u0026#34;,\n    tools=[place_order],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTo manage handoffs, you can define a triage agent like in the following snippet which includes two functions, \u003ccode\u003etransfer_to_sales_agent\u003c/code\u003e, \u003ccode\u003etransfer_to_refund_agent\u003c/code\u003e that return their corresponding agent. You also need to add a \u003ccode\u003etransfer_to_triage_agent\u003c/code\u003e tool to our \u003ccode\u003erefund_agent\u003c/code\u003e and \u003ccode\u003esales_assistant\u003c/code\u003e definitions.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etriage_agent = Agent(\n    name=\u0026#34;Triage Agent\u0026#34;,\n    instructions=(\n        \u0026#34;Gather information to direct the customer to the right department.\u0026#34;\n    ),\n    tools=[transfer_to_sales_agent, transfer_to_refund_agent],\n)\n...\nrefund_agent = Agent(\n...\n    tools=[execute_refund, transfer_to_triage_agent],\n)\n...\nsales_assistant = Agent(\n...\n    tools=[place_order, transfer_to_triage_agent],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe pattern described above, where you use a triage agent, is just one way to manage handoffs and Swarm supports the use of distinct solutions.\u003c/p\u003e\n\n\u003cp\u003eExamples of alternative frameworks to create multi-agent systems are Microsoft\u0026#39;s \u003ca href=\"https://microsoft.github.io/autogen/0.2/\"\u003eAutoGen\u003c/a\u003e, \u003ca href=\"https://github.com/crewAIInc/crewAI\"\u003eCrewAI\u003c/a\u003e, and \u003ca href=\"https://github.com/BCG-X-Official/agentkit\"\u003eAgentKit\u003c/a\u003e. Each of them takes a different stance about how to orchestrate agents and which aspects are essential to it.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.infoq.com/presentations/ai-agent-llm/\"\u003eMulti-agent systems\u003c/a\u003e aim to enable the creation of more complex systems by working around some limitations of LLMs, like single-turn responses, lack of long-term memory, and reasoning depth.\u003c/p\u003e\n\n\u003cp\u003eIt is important to understand, though, that decomposing a complex agent into a multi-agent system is not necessarily an easy task. As Hacker News commenter ValentinA23 points out, \u003ca href=\"https://news.ycombinator.com/item?id=41819680\"\u003ethe process \u0026#34;is very time consuming\u003c/a\u003e though, as it requires experimenting to determine how best to divide one task into subtasks, including writing code to parse and sanitize each task output and plug it back into the rest of the agent graph though, as it requires experimenting to determine how best to divide one task into subtasks, including writing code to parse and sanitize each task output and plug it back into the rest of the agent graph\u0026#34;.\u003c/p\u003e\n\n\u003cp\u003eAnother Hacker News commenter, LASR, raises a concern that the distinct \u003ca href=\"https://news.ycombinator.com/item?id=41821063\"\u003eagents will diverge in time\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003eThe problem with agents is divergence. Very quickly, an ensemble of agents will start doing their own things and itâ€™s impossible to get something that consistently gets to your desired state.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eFinally, Hacker News user dimitri-vs mentions that the fast evolution of current LLMs, e.g., GPT o1 and Sonnet 3.5, makes it so that \u0026#34;\u003ca href=\"https://news.ycombinator.com/item?id=41823628\"\u003eit is much easier to swap in a single API call and modify one or two prompts than to rework a convoluted agentic approach\u003c/a\u003e. Especially when it\u0026#39;s very clear that the same prompts can\u0026#39;t be reused reliably between different models\u0026#34;.\u003c/p\u003e\n\n\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n  \n    \u003cdiv\u003e \n        \u003ch2\u003eAbout the Author\u003c/h2\u003e \n\n        \n            \n                \n            \n            \u003cdiv data-id=\"author-Sergio-De-Simone\"\u003e\n                    \u003ch4\u003e\u003cstrong\u003eSergio De Simone\u003c/strong\u003e\u003c/h4\u003e\n                    \n                \u003c/div\u003e\n        \n    \u003c/div\u003e\n\n\t\t\t\t\t\t\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2024-10-20T00:00:00Z",
  "modifiedTime": null
}
