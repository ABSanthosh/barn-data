{
  "id": "53e7fc46-9b19-432d-ad01-afdbe81a693b",
  "title": "Emulating Window Functions in MySQL 5.7",
  "link": "https://blog.jooq.org/emulating-window-functions-in-mysql-5-7/",
  "description": "One of MySQL 8’s biggest improvements is the support of window functions. As I always said in conferences, there’s SQL before window functions and SQL after window functions. Once you start using them, you’ll use them everywhere. Some of you poor souls are unfortunate enough to be stuck on MySQL 5.7, either of your own … Continue reading Emulating Window Functions in MySQL 5.7 →",
  "author": "lukaseder",
  "published": "Fri, 20 Jan 2023 11:07:00 +0000",
  "source": "https://blog.jooq.org/feed",
  "categories": [
    "sql",
    "DENSE_RANK",
    "emulations",
    "local variables",
    "MySQL 5.7",
    "RANK",
    "ROW_NUMBER",
    "Window Functions"
  ],
  "byline": "Published by lukaseder I made jOOQ View all posts by lukaseder",
  "length": 18283,
  "excerpt": "If you're stuck on MySQL 5.7 and cannot profit from MySQL 8.0's window function support, then this article will help you emulate window functions",
  "siteName": "Java, SQL and jOOQ.",
  "favicon": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=180%2C180\u0026ssl=1",
  "text": "One of MySQL 8’s biggest improvements is the support of window functions. As I always said in conferences, there’s SQL before window functions and SQL after window functions. Once you start using them, you’ll use them everywhere. Some of you poor souls are unfortunate enough to be stuck on MySQL 5.7, either of your own choosing, or because you’re using a clone / fork that is still 5.7 compatible. While for most people, this blog post is just for your amusement, or nostalgia, for some of you this post will be quite useful. A lot of Stack Overflow questions or blog posts out there show the same old trick using local variables. In a procedural context, local variables make perfect sense. For example, this statement batch. SET @c = (SELECT COUNT(*) FROM information_schema.tables); -- More processing -- Return the result: SELECT @c; A bit hairier is the fact that these local variables can be declared within a query, and incremented procedurally within a query: SELECT a, -- Use and increment your variable in SELECT @rn := @rn + 1 FROM ( SELECT 3 AS a UNION ALL SELECT 4 AS a ) AS t, -- Declare your variable in FROM (SELECT @rn := 0) r ORDER BY a; And boom, you have a ROW_NUMBER() OVER (ORDER BY a) window function! The result being: |a |@rn := @rn + 1||---|--------------||3 |1 ||4 |2 | This works quite incidentally, because the expression incrementing the row number “happens to” be evaluated in the desired order, row by row, because of the query’s ORDER BY a clause. Revert it: SELECT a, @rn := @rn + 1 FROM ( SELECT 3 AS a UNION ALL SELECT 4 AS a ) AS t, (SELECT @rn := 0) r ORDER BY a DESC; And you still get the desired result: |a |@rn := @rn + 1||---|--------------||4 |1 ||3 |2 | This is really hairy, because it violates the idea of SQL’s logical order of operations, which most RDBMS agree upon. It assumes ORDER BY “happens before” SELECT, just because the optimiser chooses to do things this way. You can tamper with the optimiser and break the “feature” easily, e.g. by adding DISTINCT: SELECT DISTINCT a, @rn := @rn + 1 FROM ( SELECT 3 AS a UNION ALL SELECT 4 AS a ) AS t, (SELECT @rn := 0) r ORDER BY a DESC; Now the result is no longer what we wanted (how could it possibly be?): |a |@rn := @rn + 1||---|--------------||4 |2 ||3 |1 | The reason is that DISTINCT is typically implemented using a sort or a hashmap, both will not preserve any ordering, and according to the aforementioned logical order of operations, this is perfectly fine, because ORDER BY is supposed to “happen after” SELECT and after DISTINCT, at least logically. But if you’re careful, and cover everything with enough tests, you could still use this trick. After all, being stuck with MySQL 5.7 is already painful enough, so why not treat yourself to an “almost window function”. Note: Just to indicate how much of a bad idea depending on this incidental feature is, MySQL 8.x now issues a deprecation warning:Setting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: ‘SET variable=expression, …’, or ‘SELECT expression(s) INTO variables(s)’. The main reason I’ve seen this syntax being used on Stack Overflow so far is to emulate ROW_NUMBER, so, I’d say, good riddance (now that MySQL 8 has window function support) PARTITION BY using ORDER BY What I haven’t seen much on Stack Overflow or in blogs, is PARTITION BY support. Most solutions I’ve seen use ORDER BY to implement partitioning, which is fine. For example: SELECT a, b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY b DESC) AS rn1, IF ( @prev = a, @rn := @rn + 1, CASE WHEN (@prev := a) IS NOT NULL OR TRUE THEN @rn := 1 END ) AS rn2 FROM ( SELECT 1 AS a, 3 AS b UNION ALL SELECT 2 AS a, 4 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 2 AS a, 6 AS b ) AS t, (SELECT @rn := 0, @prev := NULL) r ORDER BY a, b DESC; Producing: |a |b |rn1|rn2||---|---|---|---||1 |5 |1 |1 ||1 |3 |2 |2 ||2 |6 |1 |1 ||2 |4 |2 |2 | A few notes: The desired PARTITION BY and ORDER BY clauses both have to be reflected in the top level query. If you only wanted to ORDER BY b DESC, not ORDER BY a as well, tough luck. (If you want to play around with this, try removing the ROW_NUMBER() function, which also orders stuff by a, implicitly) I’ve tried to put all the variable assignment logic into a single expression in order to avoid any extra columns being generated. This makes the expression a bit more ugly than it needed to be. PARTITION BY using JSON A more robust, but perhaps slower approach to emulating PARTITION BY would be to maintain a JSON object that keeps track of each partition key’s ROW_NUMBER(), because why not? Behold this beauty: SELECT a, b, ROW_NUMBER() OVER (PARTITION BY a ORDER BY b DESC) AS rn1, json_extract( @rn := json_set( @rn, @path := concat('$.\"', a, '\"'), (coalesce(json_extract(@rn, @path), 0) + 1) ), @path ) AS rn2, @rn AS debug -- Added for debugging purposes only FROM ( SELECT 1 AS a, 3 AS b UNION ALL SELECT 2 AS a, 4 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 2 AS a, 6 AS b ) AS t, (SELECT @rn := '{}') r ORDER BY b DESC; Check out the results: |a |b |rn1|rn2|debug ||---|---|---|---|--------------------||2 |6 |1 |1.0|{\"1\": 2.0, \"2\": 1.0}||1 |5 |1 |1.0|{\"1\": 1.0} ||2 |4 |2 |2.0|{\"1\": 2.0, \"2\": 2.0}||1 |3 |2 |2.0|{\"1\": 2.0} | You can try this on MySQL 5.7 (removing the ROW_NUMBER(), of course), and you’ll see this works perfectly fine! How does it work? We start with an empty object {} in the FROM clause. On every row that is incidentally ordered by the ORDER BY b DESC clause, we’ll extract the row number value for the partition key PARTITION BY a. This is done with a dynamically created JSON path expression concat('$.\"', a, '\"'). For example: $.\"1\" or $.\"2\". At first, this value is NULL, of course, so we turn it to zero with COALESCE(\u003cexpr\u003e, 0). We add 1 to it Then we JSON_SET the value back into the object, assigning the result back to @rn. Then, we re-extract the value we’ve just calculated This could be simplified a bit if it wasn’t just a single expression, but since I’m thinking about implementing this emulation in jOOQ (see #14529), I wanted to do the exercise of keeping the projection unchanged (imagine, the jOOQ user writes ROW_NUMBER() with jOOQ, and wants this to “just work”). Caveats: If the PARTITION BY clause has multiple expressions, then the composite value would have to be used as a key, e.g. using some “impossible” concatenation token (a token that can’t appear in the data set), or a hash value (risking collisions, of course), or an additional lookup, making things quite complicated. The concat('$.\"', a, '\"') expression doesn’t properly quote a yet, in case it contains double quotes. If multiple distinct window function calculations with distinct ORDER BY clauses are required, then this approach won’t work as easily. It might be possible to calculate things with one derived table nest level per window function (?). However, multiple distinct PARTITION BY clauses are fine. Just generate a separate @rn variable per distinct PARTITION BY clause. The JSON document might lose data type information. For example, in JSON, numbers may be represented as floats, so if you require decimal precision, perhaps you should work with JSON strings instead, and cast things back and forth, always valuing correctness over performance. Do you think you’ve seen everything? Let’s do something even more hairy: DENSE_RANK with PARTITION BY We won’t stop here, because once we’ve chosen this crazy path, we might as well see it to the end. Let’s emulate DENSE_RANK(), which is a bit harder, making the SQL more “beautiful”: SELECT a, b, DENSE_RANK() OVER (PARTITION BY a ORDER BY b DESC) AS rn1, json_extract( @rn := json_set(@rn, @rnpath := concat('$.\"rn-', a, '\"'), (coalesce(json_extract(@rn, @rnpath), 0) + IF ( json_extract(@rn, @prepath := concat('$.\"pre-v-', a, '\"')) = b, 0, 1 )), @prepath, b ), @rnpath ) AS rn2, @rn AS debug FROM ( SELECT 1 AS a, 3 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 2 AS a, 6 AS b ) AS t, (SELECT @rn := '{}') r ORDER BY b DESC; Here’s the result: |a |b |rn1|rn2|debug ||---|---|---|---|------------------------------------------------------||2 |6 |1 |1.0|{\"rn-1\": 2.0, \"rn-2\": 1.0, \"pre-v-1\": 3, \"pre-v-2\": 6}||1 |5 |1 |1.0|{\"rn-1\": 1.0, \"pre-v-1\": 5} ||1 |5 |1 |1.0|{\"rn-1\": 1.0, \"pre-v-1\": 5} ||1 |3 |2 |2.0|{\"rn-1\": 2.0, \"pre-v-1\": 3} | How does it differ? We now have to remember not just the previous row number value per partition (\"rn-1\", \"rn-2\"), but also the previous value of b (the ORDER BY criteria) per partition (\"pre-v-1\", \"pre-v-2\"). Then, we increment the row number per partition only if the previous value is different from the current value Caveats: There can still be multiple PARTITION BY expressions, as well as path escaping problems, see caveats of ROW_NUMBER for details. If there are multiple ORDER BY columns, the \"pre-v-n\" values would have to remember their composite value, e.g. by nesting a JSON object. This is a bit simpler to take into account than multiple PARTITION BY expressions Hairy enough? Let’s go deeper RANK with PARTITION BY Who would have thought that RANK is harder than DENSE_RANK (see this article for a direct comparison of the functions). Now, in addition to remembering the previous ordering value per partition, we also need to remember the previous rank per partition (all the while continuing to count up the row number). Note, you can refactor this to something more readable if you remove the jOOQ imposed single expression restriction, but where’s the challenge in that, right? Here it is, bow before it in awe (or terror): SELECT a, b, RANK() OVER (PARTITION BY a ORDER BY b DESC) AS rn1, coalesce( json_extract( @rn := json_set(@rn, @rnpath := concat('$.\"rn-', a, '\"'), @currn := coalesce(json_extract(@rn, @rnpath), 0) + 1, @prevpath := concat('$.\"pre-v-', a, '\"'), b, @prernpath := concat('$.\"pre-rn-', a, '\"'), IF (json_extract(@rn, @prevpath) = b, coalesce(json_extract(@rn, @prernpath), @currn) div 1, @currn ) ), @prernpath ), @currn ) AS rn2, @rn AS debug FROM ( SELECT 1 AS a, 3 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 2 AS a, 6 AS b ) AS t, (SELECT @rn := '{}') r ORDER BY b DESC; It produces: |a |b |rn1|rn2|debug | |---|---|---|---|----------------------------------------------------------------------------------------| |2 |6 |1 |1.0|{\"rn-1\": 3.0, \"rn-2\": 1.0, \"pre-v-1\": 3, \"pre-v-2\": 6, \"pre-rn-1\": 3.0, \"pre-rn-2\": 1.0}| |1 |5 |1 |1.0|{\"rn-1\": 1.0, \"pre-v-1\": 5, \"pre-rn-1\": 1.0} | |1 |5 |1 |1.0|{\"rn-1\": 2.0, \"pre-v-1\": 5, \"pre-rn-1\": 1.0} | |1 |3 |3 |3.0|{\"rn-1\": 3.0, \"pre-v-1\": 3, \"pre-rn-1\": 3.0} | How does it work? “Simply”: We now have 3 variables: \"rn-x\" is again the original ROW_NUMBER () (because RANK() behaves like ROW_NUMBER(), unless there are ties in the ORDER BY clause) \"pre-v-x\" is the previous value of the ORDER BY expression. This is again required to detect ties. In case of a tie, the \"pre-rn-x\" needs to be returned. Otherwise, \"rn-x\" is returned, and \"pre-rn-x\" is set to its value. Caveats: The same as before PERCENT_RANK and CUME_DIST I’m not convinced that these can be emulated with the local variable based approach. In principle: PERCENT_RANK() OVER w is just (RANK() OVER w - 1) / (COUNT(*) OVER () - 1) CUME_DIST() OVER w is just (RANK() OVER w) / (COUNT(*) OVER ()) But as we’ll see below, it’s not possible (I think?) to emulate COUNT(*) OVER () using this local variable based approach. You could, maybe, do another round of calculations when wrapping things in a derived table, though. LEAD, LAG, etc. Some of these can also be emulated with the above technique, in particular the ones that are “backward looking”. LAG: For example, with LAG, we just have to remember again the \"pre-v-x\" for each partition, and produce it again on the current row. Depending on the LAG‘s OFFSET, we might need to keep around a JSON array of values, always appending the current value to the array, and removing the first value, like in a FIFO queue. LEAD: The forward looking functions just have to reverse the ORDER BY clause. For example, all LEAD functions can be implemented with LAG as well. FIRST_VALUE: This is a bit simpler than LAG, as we don’t have to keep an entire JSON array of values. We just remember the first one, and then keep reproducing this. LAST_VALUE is again just the inverse of FIRST_VALUE with reversed ORDER BY clause. NTH_VALUE needs a counter per partition, to be sure we catch the Nth value. Alternatively, we can again store everything in a JSON array until it reaches size N. IGNORE NULLS can be implemented by skipping all the NULL values from being entered into the aforementioned FIFO queue Things get a bit trickier when there is a RANGE or ROWS clause, in case of which the JSON array / FIFO queue has to be shifted. This affects FIRST_VALUE more than LEAD, I’d say. The actual implementation is left as an exercise to the user. (Probably about time to consider upgrading to MySQL 8, by now!) Aggregate functions All SQL aggregate functions can be turned into window functions by appending OVER (). For example: SUM(x) is an aggregate function, aggregating data per group generated by the GROUP BY clause, shared by the entire query. SUM(x) OVER () is the corresponding window function, aggregating data per partition generated by the PARTITION BY clause per window function (or rather, per explicit or implicit window specification) Since these previously discussed local variable based approaches are row-by-row based calculations, I don’t think it’s possible to emulate partition wide aggregate window functions, because these require being able to look at the entire partition, including rows that haven’t yet been projected. However (never give up!), some window frames can be emulated also for aggregate functions, especially the backward looking ones. For simplicity, I’ll just try emulating this: SUM(b) OVER ( PARTITION BY a ORDER BY b DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) Note: without explicit window frame, RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW is implicit, and that means that in order to include tied rows in the sum, we’d have to again be forward looking, which I don’t think is possible with the local variable row-by-row based approach. However, it might be possible to emulate alternative backward looking ROWS frames. That exercise is again left to the reader. So, let’s do this: SELECT a, b, SUM(b) OVER w AS sum1, json_extract( @w := json_set(@w, @spath := concat('$.\"s-', a, '\"'), (coalesce(json_extract(@w, @spath), 0) + b), @cpath := concat('$.\"c-', a, '\"'), (coalesce(json_extract(@w, @cpath), 0) + 1) ), @spath ) AS sum2, COUNT(*) OVER w AS cnt1, json_extract(@w, @cpath) AS cnt2, AVG(b) OVER w AS avg1, json_extract(@w, @spath) / json_extract(@w, @cpath) AS avg2, @w AS debug FROM ( SELECT 1 AS a, 3 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 1 AS a, 5 AS b UNION ALL SELECT 2 AS a, 6 AS b ) AS t, (SELECT @w := '{}') r WINDOW w AS ( PARTITION BY a ORDER BY b DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) ORDER BY b DESC; The output seems correct: |a |b |sum1|sum2|cnt1|cnt2|avg1 |avg2 |debug | |---|---|----|----|----|----|------|------------|-------------------------------------------------| |2 |6 |6 |6.0 |1 |1.0 |6 |6 |{\"c-1\": 3.0, \"c-2\": 1.0, \"s-1\": 13.0, \"s-2\": 6.0}| |1 |5 |5 |5.0 |1 |1.0 |5 |5 |{\"c-1\": 1.0, \"s-1\": 5.0} | |1 |5 |10 |10.0|2 |2.0 |5 |5 |{\"c-1\": 2.0, \"s-1\": 10.0} | |1 |3 |13 |13.0|3 |3.0 |4.3333|4.3333333333|{\"c-1\": 3.0, \"s-1\": 13.0} | Notes: I’ve stored all the window calculations in the same JSON object, assuming they all share the same window specification, so they can reuse their values (e.g. AVG(x) = SUM(x) / COUNT(x), and thus AVG(x) OVER w = SUM(x) OVER w / COUNT(x) OVER w) Other than that, things work pretty much just like for ROW_NUMBER() Conclusion This has been a fun blog post to write. I hope it was helpful to you either as an exercise to think about what window functions really do, or in the worst case, to help you poor soul actually implement things this way on MySQL 5.7. There have been a lot of caveats. This emulation approach doesn’t always work and makes (heavy) assumptions about your query. For example: You can’t use DISTINCT You can’t use arbitrary ORDER BY clauses that don’t match the window function’s You can’t use multiple window functions with different window specifications You can’t use forward looking window frames (including frameless aggregate window functions that aggregate the entire partition) There are probably more caveats that haven’t been discussed here. If you’re diligent, and test things heavily, however, you might be able to pull off using these approaches. Good luck (and don’t blame me 😅)",
  "image": "https://i0.wp.com/blog.jooq.org/wp-content/uploads/2021/08/jooq-logo-white-750x750-padded.png?fit=750%2C750\u0026ssl=1",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003carticle id=\"post-11851\"\u003e\n\t\n\t\n\t\u003cdiv\u003e\n\t\t\n\u003cp\u003eOne of MySQL 8’s biggest improvements is the support of \u003ca href=\"https://blog.jooq.org/probably-the-coolest-sql-feature-window-functions/\" data-type=\"post\" data-id=\"2593\"\u003ewindow functions\u003c/a\u003e. As I always said in conferences, there’s SQL before window functions and SQL after window functions. Once you start using them, you’ll use them everywhere.\u003c/p\u003e\n\n\n\n\u003cp\u003eSome of you poor souls are unfortunate enough to be stuck on MySQL 5.7, either of your own choosing, or because you’re using a clone / fork that is still 5.7 compatible. While for most people, this blog post is just for your amusement, or nostalgia, for some of you this post will be quite useful.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eA lot of \u003ca rel=\"noreferrer noopener\" href=\"https://stackoverflow.com/q/54239851/521799\" data-type=\"URL\" data-id=\"https://stackoverflow.com/q/54239851/521799\" target=\"_blank\"\u003eStack Overflow questions\u003c/a\u003e or blog posts out there show the same old trick using local variables. In a procedural context, local variables make perfect sense. For example, this statement batch.\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSET @c = (SELECT COUNT(*) FROM information_schema.tables);\n-- More processing\n-- Return the result:\nSELECT @c;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eA bit hairier is the fact that these local variables can be declared within a query, and incremented procedurally within a query:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, \n\n  -- Use and increment your variable in SELECT\n  @rn := @rn + 1\nFROM \n  (\n    SELECT 3 AS a UNION ALL\n    SELECT 4 AS a    \n  ) AS t, \n\n  -- Declare your variable in FROM\n  (SELECT @rn := 0) r\nORDER BY a;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd boom, you have a \u003ccode\u003eROW_NUMBER() OVER (ORDER BY a)\u003c/code\u003e window function! The result being:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |@rn := @rn + 1|\u003cbr/\u003e|---|--------------|\u003cbr/\u003e|3  |1             |\u003cbr/\u003e|4  |2             |\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis works quite incidentally, because the expression incrementing the row number “happens to” be evaluated in the desired order, row by row, because of the query’s \u003ccode\u003eORDER BY a\u003c/code\u003e clause. Revert it:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, @rn := @rn + 1\nFROM (\n  SELECT 3 AS a UNION ALL\n  SELECT 4 AS a    \n) AS t, (SELECT @rn := 0) r\nORDER BY a DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eAnd you still get the desired result:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |@rn := @rn + 1|\u003cbr/\u003e|---|--------------|\u003cbr/\u003e|4  |1             |\u003cbr/\u003e|3  |2             |\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis is really hairy, because it violates the idea of \u003ca href=\"https://blog.jooq.org/a-beginners-guide-to-the-true-order-of-sql-operations/\" data-type=\"post\" data-id=\"6620\"\u003eSQL’s logical order of operations\u003c/a\u003e, which most RDBMS agree upon. It assumes \u003ccode\u003eORDER BY\u003c/code\u003e “happens before” \u003ccode\u003eSELECT\u003c/code\u003e, just because the optimiser chooses to do things this way. You can tamper with the optimiser and break the “feature” easily, e.g. by adding \u003ccode\u003eDISTINCT\u003c/code\u003e:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT DISTINCT\n  a, @rn := @rn + 1\nFROM (\n  SELECT 3 AS a UNION ALL\n  SELECT 4 AS a    \n) AS t, (SELECT @rn := 0) r\nORDER BY a DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eNow the result is no longer what we wanted (how could it possibly be?):\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |@rn := @rn + 1|\u003cbr/\u003e|---|--------------|\u003cbr/\u003e|4  |2             |\u003cbr/\u003e|3  |1             |\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe reason is that \u003ccode\u003eDISTINCT\u003c/code\u003e is typically implemented using a sort or a hashmap, both will not preserve any ordering, and according to the aforementioned \u003ca href=\"https://blog.jooq.org/a-beginners-guide-to-the-true-order-of-sql-operations/\" data-type=\"post\" data-id=\"6620\"\u003elogical order of operations\u003c/a\u003e, this is perfectly fine, because \u003ccode\u003eORDER BY\u003c/code\u003e is \u003cem\u003esupposed to\u003c/em\u003e “happen after” \u003ccode\u003eSELECT\u003c/code\u003e and after \u003ccode\u003eDISTINCT\u003c/code\u003e, at least logically.\u003c/p\u003e\n\n\n\n\u003cp\u003eBut if you’re careful, and cover everything with enough tests, you could still use this trick. After all, being stuck with MySQL 5.7 is already painful enough, so why not treat yourself to an “almost window function”.\u003c/p\u003e\n\n\n\n\u003cblockquote\u003e\n\u003cdiv\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: Just to indicate how much of a bad idea depending on this incidental feature is, MySQL 8.x now issues a deprecation warning:\u003c/p\u003e\u003cp\u003e\u003cem\u003eSetting user variables within expressions is deprecated and will be removed in a future release. Consider alternatives: ‘SET variable=expression, …’, or ‘SELECT expression(s) INTO variables(s)’.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\n\n\n\n\u003cp\u003eThe main reason I’ve seen this syntax being used on Stack Overflow so far is to emulate \u003ccode\u003eROW_NUMBER\u003c/code\u003e, so, I’d say, good riddance (now that MySQL 8 has window function support)\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003ch2\u003ePARTITION BY using ORDER BY\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhat I haven’t seen much on Stack Overflow or in blogs, is \u003ccode\u003ePARTITION BY\u003c/code\u003e support. \u003ca rel=\"noreferrer noopener\" href=\"https://stackoverflow.com/q/58645949/521799\" data-type=\"URL\" data-id=\"https://stackoverflow.com/q/58645949/521799\" target=\"_blank\"\u003eMost solutions I’ve seen use \u003ccode\u003eORDER BY\u003c/code\u003e to implement partitioning\u003c/a\u003e, which is fine. For example:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, b,\n  ROW_NUMBER() OVER (PARTITION BY a ORDER BY b DESC) AS rn1,\n  IF (\n    @prev = a, \n    @rn := @rn + 1, \n    CASE WHEN (@prev := a) IS NOT NULL OR TRUE THEN @rn := 1 END\n  ) AS rn2\nFROM (\n  SELECT 1 AS a, 3 AS b UNION ALL\n  SELECT 2 AS a, 4 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 2 AS a, 6 AS b\n) AS t, (SELECT @rn := 0, @prev := NULL) r\nORDER BY a, b DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eProducing:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |b  |rn1|rn2|\u003cbr/\u003e|---|---|---|---|\u003cbr/\u003e|1  |5  |1  |1  |\u003cbr/\u003e|1  |3  |2  |2  |\u003cbr/\u003e|2  |6  |1  |1  |\u003cbr/\u003e|2  |4  |2  |2  |\u003c/pre\u003e\n\n\n\n\u003cp\u003eA few notes:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe desired \u003ccode\u003ePARTITION BY\u003c/code\u003e and \u003ccode\u003eORDER BY\u003c/code\u003e clauses \u003cem\u003eboth have to\u003c/em\u003e be reflected in the top level query. If you only wanted to \u003ccode\u003eORDER BY b DESC\u003c/code\u003e, not \u003ccode\u003eORDER BY a\u003c/code\u003e as well, tough luck. (If you want to play around with this, try removing the \u003ccode\u003eROW_NUMBER()\u003c/code\u003e function, which also orders stuff by \u003ccode\u003ea\u003c/code\u003e, implicitly)\u003c/li\u003e\n\n\n\n\u003cli\u003eI’ve tried to put all the variable assignment logic into a single expression in order to avoid any extra columns being generated. This makes the expression a bit more ugly than it needed to be.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003ePARTITION BY using JSON\u003c/h2\u003e\n\n\n\n\u003cp\u003eA more robust, but perhaps slower approach to emulating \u003ccode\u003ePARTITION BY\u003c/code\u003e would be to maintain a JSON object that keeps track of each partition key’s \u003ccode\u003eROW_NUMBER()\u003c/code\u003e, because why not?\u003c/p\u003e\n\n\n\n\u003cp\u003eBehold this beauty:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, b,\n  ROW_NUMBER() OVER (PARTITION BY a ORDER BY b DESC) AS rn1,\n  json_extract(\n    @rn := json_set(\n      @rn, @path := concat(\u0026#39;$.\u0026#34;\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;), \n      (coalesce(json_extract(@rn, @path), 0) + 1)\n    ), \n    @path\n  ) AS rn2,\n  @rn AS debug -- Added for debugging purposes only\nFROM (\n  SELECT 1 AS a, 3 AS b UNION ALL\n  SELECT 2 AS a, 4 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 2 AS a, 6 AS b\n) AS t, (SELECT @rn := \u0026#39;{}\u0026#39;) r\nORDER BY b DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eCheck out the results:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |b  |rn1|rn2|debug               |\u003cbr/\u003e|---|---|---|---|--------------------|\u003cbr/\u003e|2  |6  |1  |1.0|{\u0026#34;1\u0026#34;: 2.0, \u0026#34;2\u0026#34;: 1.0}|\u003cbr/\u003e|1  |5  |1  |1.0|{\u0026#34;1\u0026#34;: 1.0}          |\u003cbr/\u003e|2  |4  |2  |2.0|{\u0026#34;1\u0026#34;: 2.0, \u0026#34;2\u0026#34;: 2.0}|\u003cbr/\u003e|1  |3  |2  |2.0|{\u0026#34;1\u0026#34;: 2.0}          |\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou can try this on MySQL 5.7 (removing the \u003ccode\u003eROW_NUMBER()\u003c/code\u003e, of course), and you’ll see this works perfectly fine! How does it work?\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe start with an empty object \u003ccode\u003e{}\u003c/code\u003e in the \u003ccode\u003eFROM\u003c/code\u003e clause.\u003c/li\u003e\n\n\n\n\u003cli\u003eOn every row that is incidentally ordered by the \u003ccode\u003eORDER BY b DESC\u003c/code\u003e clause, we’ll extract the row number value for the partition key \u003ccode\u003ePARTITION BY a\u003c/code\u003e. This is done with a dynamically created JSON path expression \u003ccode\u003econcat(\u0026#39;$.\u0026#34;\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;)\u003c/code\u003e. For example: \u003ccode\u003e$.\u0026#34;1\u0026#34;\u003c/code\u003e or \u003ccode\u003e$.\u0026#34;2\u0026#34;\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eAt first, this value is \u003ccode\u003eNULL\u003c/code\u003e, of course, so we turn it to zero with \u003ccode\u003eCOALESCE(\u0026lt;expr\u0026gt;, 0)\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eWe add \u003ccode\u003e1\u003c/code\u003e to it\u003c/li\u003e\n\n\n\n\u003cli\u003eThen we \u003ccode\u003eJSON_SET\u003c/code\u003e the value back into the object, assigning the result back to \u003ccode\u003e@rn\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003eThen, we re-extract the value we’ve just calculated\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThis could be simplified a bit if it wasn’t just a single expression, but since I’m thinking about implementing this emulation in jOOQ (\u003ca rel=\"noreferrer noopener\" href=\"https://github.com/jOOQ/jOOQ/issues/14529\" data-type=\"URL\" data-id=\"https://github.com/jOOQ/jOOQ/issues/14529\" target=\"_blank\"\u003esee #14529\u003c/a\u003e), I wanted to do the exercise of keeping the projection unchanged (imagine, the jOOQ user writes \u003ccode\u003eROW_NUMBER()\u003c/code\u003e with jOOQ, and wants this to “just work”).\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eCaveats:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eIf the \u003ccode\u003ePARTITION BY\u003c/code\u003e clause has multiple expressions, then the composite value would have to be used as a key, e.g. using some “impossible” concatenation token (a token that can’t appear in the data set), or a hash value (risking collisions, of course), or an additional lookup, making things quite complicated.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe \u003ccode\u003econcat(\u0026#39;$.\u0026#34;\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;)\u003c/code\u003e expression doesn’t properly quote \u003ccode\u003ea\u003c/code\u003e yet, in case it contains double quotes.\u003c/li\u003e\n\n\n\n\u003cli\u003eIf multiple distinct window function calculations with distinct \u003ccode\u003eORDER BY\u003c/code\u003e clauses are required, then this approach won’t work as easily. It might be possible to calculate things with one derived table nest level per window function (?). However, multiple distinct \u003ccode\u003ePARTITION BY\u003c/code\u003e clauses are fine. Just generate a separate \u003ccode\u003e@rn\u003c/code\u003e variable per distinct \u003ccode\u003ePARTITION BY\u003c/code\u003e clause.\u003c/li\u003e\n\n\n\n\u003cli\u003eThe JSON document might lose data type information. For example, in JSON, numbers may be represented as floats, so if you require decimal precision, perhaps you should work with JSON strings instead, and cast things back and forth, always valuing correctness over performance.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eDo you think you’ve seen everything? Let’s do something even more hairy:\u003c/p\u003e\n\n\n\n\u003ch2\u003eDENSE_RANK with PARTITION BY\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe won’t stop here, because once we’ve chosen this crazy path, we might as well see it to the end. Let’s emulate \u003ccode\u003eDENSE_RANK()\u003c/code\u003e, which is a bit harder, making the SQL more “beautiful”:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, b,\n  DENSE_RANK() OVER (PARTITION BY a ORDER BY b DESC) AS rn1,\n  json_extract(\n    @rn := json_set(@rn, \n      @rnpath := concat(\u0026#39;$.\u0026#34;rn-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;), \n      (coalesce(json_extract(@rn, @rnpath), 0) + IF (\n        json_extract(@rn, @prepath := concat(\u0026#39;$.\u0026#34;pre-v-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;)) = b, \n        0, 1\n      )),\n      @prepath,\n      b\n    ), \n    @rnpath\n  ) AS rn2,\n  @rn AS debug\nFROM (\n  SELECT 1 AS a, 3 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 2 AS a, 6 AS b\n) AS t, (SELECT @rn := \u0026#39;{}\u0026#39;) r\nORDER BY b DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eHere’s the result:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |b  |rn1|rn2|debug                                                 |\u003cbr/\u003e|---|---|---|---|------------------------------------------------------|\u003cbr/\u003e|2  |6  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 2.0, \u0026#34;rn-2\u0026#34;: 1.0, \u0026#34;pre-v-1\u0026#34;: 3, \u0026#34;pre-v-2\u0026#34;: 6}|\u003cbr/\u003e|1  |5  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 1.0, \u0026#34;pre-v-1\u0026#34;: 5}                           |\u003cbr/\u003e|1  |5  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 1.0, \u0026#34;pre-v-1\u0026#34;: 5}                           |\u003cbr/\u003e|1  |3  |2  |2.0|{\u0026#34;rn-1\u0026#34;: 2.0, \u0026#34;pre-v-1\u0026#34;: 3}                           |\u003c/pre\u003e\n\n\n\n\u003cp\u003eHow does it differ?\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe now have to remember not just the previous row number value \u003cem\u003eper partition\u003c/em\u003e (\u003ccode\u003e\u0026#34;rn-1\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;rn-2\u0026#34;\u003c/code\u003e), but also the previous value of \u003ccode\u003eb\u003c/code\u003e (the \u003ccode\u003eORDER BY\u003c/code\u003e criteria) \u003cem\u003eper partition \u003c/em\u003e(\u003ccode\u003e\u0026#34;pre-v-1\u0026#34;\u003c/code\u003e, \u003ccode\u003e\u0026#34;pre-v-2\u0026#34;\u003c/code\u003e).\u003c/li\u003e\n\n\n\n\u003cli\u003eThen, we increment the row number per partition \u003cem\u003eonly if\u003c/em\u003e the previous value is different from the current value\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eCaveats:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThere can still be multiple \u003ccode\u003ePARTITION BY\u003c/code\u003e expressions, as well as path escaping problems, see caveats of \u003ccode\u003eROW_NUMBER\u003c/code\u003e for details.\u003c/li\u003e\n\n\n\n\u003cli\u003eIf there are multiple \u003ccode\u003eORDER BY\u003c/code\u003e columns, the \u003ccode\u003e\u0026#34;pre-v-n\u0026#34;\u003c/code\u003e values would have to remember their composite value, e.g. by nesting a JSON object. This is a bit simpler to take into account than multiple \u003ccode\u003ePARTITION BY\u003c/code\u003e expressions\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eHairy enough? Let’s go deeper\u003c/p\u003e\n\n\n\n\u003ch2\u003eRANK with PARTITION BY\u003c/h2\u003e\n\n\n\n\u003cp\u003eWho would have thought that \u003ccode\u003eRANK\u003c/code\u003e is harder than \u003ccode\u003eDENSE_RANK\u003c/code\u003e (\u003ca href=\"https://blog.jooq.org/the-difference-between-row_number-rank-and-dense_rank/\" data-type=\"post\" data-id=\"4326\"\u003esee this article for a direct comparison of the functions\u003c/a\u003e). Now, in addition to remembering the previous ordering value per partition, we also need to remember the previous rank per partition (all the while continuing to count up the row number).\u003c/p\u003e\n\n\n\n\u003cp\u003eNote, you can refactor this to something more readable if you remove the jOOQ imposed single expression restriction, but where’s the challenge in that, right? Here it is, bow before it in awe (or terror):\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, b,\n  RANK() OVER (PARTITION BY a ORDER BY b DESC) AS rn1,\n  coalesce(\n    json_extract(\n      @rn := json_set(@rn, \n        @rnpath := concat(\u0026#39;$.\u0026#34;rn-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;), \n        @currn := coalesce(json_extract(@rn, @rnpath), 0) + 1,\n        @prevpath := concat(\u0026#39;$.\u0026#34;pre-v-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;),\n        b,\n        @prernpath := concat(\u0026#39;$.\u0026#34;pre-rn-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;),\n        IF (json_extract(@rn, @prevpath) = b, \n          coalesce(json_extract(@rn, @prernpath), @currn) div 1,\n          @currn\n        )\n      ), \n      @prernpath\n    ), \n    @currn\n  ) AS rn2,\n  @rn AS debug\nFROM (\n  SELECT 1 AS a, 3 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 2 AS a, 6 AS b\n) AS t, (SELECT @rn := \u0026#39;{}\u0026#39;) r\nORDER BY b DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eIt produces:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |b  |rn1|rn2|debug                                                                                   |\n|---|---|---|---|----------------------------------------------------------------------------------------|\n|2  |6  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 3.0, \u0026#34;rn-2\u0026#34;: 1.0, \u0026#34;pre-v-1\u0026#34;: 3, \u0026#34;pre-v-2\u0026#34;: 6, \u0026#34;pre-rn-1\u0026#34;: 3.0, \u0026#34;pre-rn-2\u0026#34;: 1.0}|\n|1  |5  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 1.0, \u0026#34;pre-v-1\u0026#34;: 5, \u0026#34;pre-rn-1\u0026#34;: 1.0}                                            |\n|1  |5  |1  |1.0|{\u0026#34;rn-1\u0026#34;: 2.0, \u0026#34;pre-v-1\u0026#34;: 5, \u0026#34;pre-rn-1\u0026#34;: 1.0}                                            |\n|1  |3  |3  |3.0|{\u0026#34;rn-1\u0026#34;: 3.0, \u0026#34;pre-v-1\u0026#34;: 3, \u0026#34;pre-rn-1\u0026#34;: 3.0}                                            |\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eHow does it work? “Simply”:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eWe now have 3 variables:\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026#34;rn-x\u0026#34;\u003c/code\u003e is again the original \u003ccode\u003eROW_NUMBER ()\u003c/code\u003e (\u003ca href=\"https://blog.jooq.org/the-difference-between-row_number-rank-and-dense_rank/\" data-type=\"post\" data-id=\"4326\"\u003ebecause \u003ccode\u003eRANK()\u003c/code\u003e behaves like \u003ccode\u003eROW_NUMBER()\u003c/code\u003e, unless there are ties in the \u003ccode\u003eORDER BY\u003c/code\u003e clause\u003c/a\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003e\u0026#34;pre-v-x\u0026#34;\u003c/code\u003e is the previous value of the \u003ccode\u003eORDER BY\u003c/code\u003e expression. This is again required to detect ties. In case of a tie, the \u003ccode\u003e\u0026#34;pre-rn-x\u0026#34;\u003c/code\u003e needs to be returned. Otherwise, \u003ccode\u003e\u0026#34;rn-x\u0026#34;\u003c/code\u003e is returned, and \u003ccode\u003e\u0026#34;pre-rn-x\u0026#34;\u003c/code\u003e is set to its value.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eCaveats:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eThe same as before\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003ePERCENT_RANK and CUME_DIST\u003c/h2\u003e\n\n\n\n\u003cp\u003eI’m not convinced that these can be emulated with the local variable based approach. In principle:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePERCENT_RANK() OVER w\u003c/code\u003e is just \u003ccode\u003e(RANK() OVER w - 1) / (COUNT(*) OVER () - 1)\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eCUME_DIST() OVER w\u003c/code\u003e is just \u003ccode\u003e(RANK() OVER w) / (COUNT(*) OVER ())\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBut as we’ll see below, it’s not possible (I think?) to emulate \u003ccode\u003eCOUNT(*) OVER ()\u003c/code\u003e using this local variable based approach. You could, maybe, do another round of calculations when wrapping things in a derived table, though.\u003c/p\u003e\n\n\n\n\u003ch2\u003eLEAD, LAG, etc.\u003c/h2\u003e\n\n\n\n\u003cp\u003eSome of these can also be emulated with the above technique, in particular the ones that are “backward looking”.\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLAG\u003c/code\u003e: For example, with \u003ccode\u003eLAG\u003c/code\u003e, we just have to remember again the \u003ccode\u003e\u0026#34;pre-v-x\u0026#34;\u003c/code\u003e for each partition, and produce it again on the current row. Depending on the \u003ccode\u003eLAG\u003c/code\u003e‘s \u003ccode\u003eOFFSET\u003c/code\u003e, we might need to keep around a JSON array of values, always appending the current value to the array, and removing the first value, like in a FIFO queue.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eLEAD\u003c/code\u003e: The forward looking functions just have to reverse the \u003ccode\u003eORDER BY\u003c/code\u003e clause. For example, all \u003ccode\u003eLEAD\u003c/code\u003e functions can be implemented with \u003ccode\u003eLAG\u003c/code\u003e as well.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eFIRST_VALUE\u003c/code\u003e: This is a bit simpler than \u003ccode\u003eLAG\u003c/code\u003e, as we don’t have to keep an entire JSON array of values. We just remember the first one, and then keep reproducing this.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eLAST_VALUE\u003c/code\u003e is again just the inverse of \u003ccode\u003eFIRST_VALUE\u003c/code\u003e with reversed \u003ccode\u003eORDER BY\u003c/code\u003e clause.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eNTH_VALUE\u003c/code\u003e needs a counter per partition, to be sure we catch the Nth value. Alternatively, we can again store everything in a JSON array until it reaches size N.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eIGNORE NULLS\u003c/code\u003e can be implemented by skipping all the \u003ccode\u003eNULL\u003c/code\u003e values from being entered into the aforementioned FIFO queue\u003c/li\u003e\n\n\n\n\u003cli\u003eThings get a bit trickier when there is a \u003ccode\u003eRANGE\u003c/code\u003e or \u003ccode\u003eROWS\u003c/code\u003e clause, in case of which the JSON array / FIFO queue has to be shifted. This affects \u003ccode\u003eFIRST_VALUE\u003c/code\u003e more than \u003ccode\u003eLEAD\u003c/code\u003e, I’d say.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe actual implementation is left as an exercise to the user. (Probably about time to consider upgrading to MySQL 8, by now!)\u003c/p\u003e\n\n\n\n\u003ch2\u003eAggregate functions\u003c/h2\u003e\n\n\n\n\u003cp\u003eAll SQL aggregate functions can be turned into window functions by appending \u003ccode\u003eOVER ()\u003c/code\u003e. For example:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSUM(x)\u003c/code\u003e is an aggregate function, aggregating data per group generated by the \u003ccode\u003eGROUP BY\u003c/code\u003e clause, shared by the entire query.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eSUM(x) OVER ()\u003c/code\u003e is the corresponding window function, aggregating data per partition generated by the \u003ccode\u003ePARTITION BY\u003c/code\u003e clause per window function (\u003ca href=\"https://blog.jooq.org/how-to-reduce-syntactic-overhead-using-the-sql-window-clause/\" data-type=\"post\" data-id=\"7875\"\u003eor rather, per explicit or implicit window specification\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eSince these previously discussed local variable based approaches are row-by-row based calculations, I don’t think it’s possible to emulate partition wide aggregate window functions, because these require being able to look at the entire partition, including rows that haven’t yet been projected.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever (never give up!), some window frames can be emulated also for aggregate functions, especially the backward looking ones. For simplicity, I’ll just try emulating this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSUM(b) OVER (\n  PARTITION BY a\n  ORDER BY b DESC\n  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n)\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e without explicit window frame, \u003ccode\u003eRANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\u003c/code\u003e is implicit, and that means that in order to include tied rows in the sum, we’d have to again be forward looking, which I don’t think is possible with the local variable row-by-row based approach.\u003c/p\u003e\n\n\n\n\u003cp\u003eHowever, it might be possible to emulate alternative backward looking \u003ccode\u003eROWS\u003c/code\u003e frames. That exercise is again left to the reader.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n\u003cp\u003eSo, let’s do this:\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre title=\"\"\u003eSELECT\n  a, b,\n  SUM(b) OVER w AS sum1,\n  json_extract(\n    @w := json_set(@w, \n      @spath := concat(\u0026#39;$.\u0026#34;s-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;), \n      (coalesce(json_extract(@w, @spath), 0) + b),\n      @cpath := concat(\u0026#39;$.\u0026#34;c-\u0026#39;, a, \u0026#39;\u0026#34;\u0026#39;), \n      (coalesce(json_extract(@w, @cpath), 0) + 1)\n    ), \n    @spath\n  ) AS sum2,\n  COUNT(*) OVER w AS cnt1,\n  json_extract(@w, @cpath) AS cnt2,\n  AVG(b) OVER w AS avg1,\n  json_extract(@w, @spath) / json_extract(@w, @cpath) AS avg2,\n  @w AS debug\nFROM (\n  SELECT 1 AS a, 3 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 1 AS a, 5 AS b UNION ALL\n  SELECT 2 AS a, 6 AS b\n) AS t, (SELECT @w := \u0026#39;{}\u0026#39;) r\nWINDOW w AS (\n  PARTITION BY a \n  ORDER BY b DESC \n  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n)\nORDER BY b DESC;\n\u003c/pre\u003e\u003c/div\u003e\n\n\n\u003cp\u003eThe output seems correct:\u003c/p\u003e\n\n\n\n\u003cpre\u003e|a  |b  |sum1|sum2|cnt1|cnt2|avg1  |avg2        |debug                                            |\n|---|---|----|----|----|----|------|------------|-------------------------------------------------|\n|2  |6  |6   |6.0 |1   |1.0 |6     |6           |{\u0026#34;c-1\u0026#34;: 3.0, \u0026#34;c-2\u0026#34;: 1.0, \u0026#34;s-1\u0026#34;: 13.0, \u0026#34;s-2\u0026#34;: 6.0}|\n|1  |5  |5   |5.0 |1   |1.0 |5     |5           |{\u0026#34;c-1\u0026#34;: 1.0, \u0026#34;s-1\u0026#34;: 5.0}                         |\n|1  |5  |10  |10.0|2   |2.0 |5     |5           |{\u0026#34;c-1\u0026#34;: 2.0, \u0026#34;s-1\u0026#34;: 10.0}                        |\n|1  |3  |13  |13.0|3   |3.0 |4.3333|4.3333333333|{\u0026#34;c-1\u0026#34;: 3.0, \u0026#34;s-1\u0026#34;: 13.0}                        |\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eNotes:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eI’ve stored all the window calculations in the same JSON object, assuming they all share the same window specification, so they can reuse their values (e.g. \u003ccode\u003eAVG(x) = SUM(x) / COUNT(x)\u003c/code\u003e, and thus \u003ccode\u003eAVG(x) OVER w = SUM(x) OVER w / COUNT(x) OVER w\u003c/code\u003e)\u003c/li\u003e\n\n\n\n\u003cli\u003eOther than that, things work pretty much just like for \u003ccode\u003eROW_NUMBER()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eConclusion\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis has been a fun blog post to write. I hope it was helpful to you either as an exercise to think about what window functions really do, or in the worst case, to help you poor soul actually implement things this way on MySQL 5.7.\u003c/p\u003e\n\n\n\n\u003cp\u003eThere have been a lot of caveats. This emulation approach doesn’t always work and makes (heavy) assumptions about your query. For example:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou can’t use \u003ccode\u003eDISTINCT\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eYou can’t use arbitrary \u003ccode\u003eORDER BY\u003c/code\u003e clauses that don’t match the window function’s\u003c/li\u003e\n\n\n\n\u003cli\u003eYou can’t use multiple window functions with different window specifications\u003c/li\u003e\n\n\n\n\u003cli\u003eYou can’t use forward looking window frames (including frameless aggregate window functions that aggregate the entire partition)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThere are probably more caveats that haven’t been discussed here. If you’re diligent, and test things heavily, however, you might be able to pull off using these approaches. Good luck (and don’t blame me 😅)\u003c/p\u003e\n\t\u003c/div\u003e\n\t\n\n\t\t\t\n\t\t\u003c/article\u003e\u003c/div\u003e",
  "readingTime": "20 min read",
  "publishedTime": "2023-01-20T11:07:00Z",
  "modifiedTime": "2024-05-24T12:08:11Z"
}
