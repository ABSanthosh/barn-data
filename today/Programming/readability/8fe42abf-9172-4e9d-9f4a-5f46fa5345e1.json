{
  "id": "8fe42abf-9172-4e9d-9f4a-5f46fa5345e1",
  "title": "How the GitHub CLI can now enable triangular workflows",
  "link": "https://github.blog/open-source/git/how-the-github-cli-can-now-enable-triangular-workflows/",
  "description": "The GitHub CLI now supports common Git configurations for triangular workflows. Learn more about triangular workflows, how they work, and how to configure them for your Git workflows. Then, see how you can leverage these using the GitHub CLI. The post How the GitHub CLI can now enable triangular workflows appeared first on The GitHub Blog.",
  "author": "Tyler McGoffin",
  "published": "Fri, 25 Apr 2025 16:00:37 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Engineering",
    "Git",
    "Open Source",
    "GitHub CLI"
  ],
  "byline": "Tyler McGoffin",
  "length": 13593,
  "excerpt": "Learn more about triangular workflows, how they work, and how to configure them for your Git workflows. See how you can leverage them on the GitHub CLI.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Most developers are familiar with the standard Git workflow. You create a branch, make changes, and push those changes back to the same branch on the main repository. Git calls this a centralized workflow. It’s straightforward and works well for many projects. However, sometimes you might want to pull changes from a different branch directly into your feature branch to help you keep your branch updated without constantly needing to merge or rebase. However, you’ll still want to push local changes to your own branch. This is where triangular workflows come in. It’s possible that some of you have already used triangular workflows, even without knowing it. When you fork a repo, contribute to your fork, then open a pull request back to the original repo, you’re working in a triangular workflow. While this can work seamlessly on github.com, the process hasn’t always been seamless with the GitHub CLI. The GitHub CLI team has recently made improvements (released in v2.71.2) to better support these triangular workflows, ensuring that the gh pr commands work smoothly with your Git configurations. So, whether you’re working on a centralized workflow or a more complex triangular one, the GitHub CLI will be better equipped to handle your needs. If you’re already familiar with how Git handles triangular workflows, feel free to skip ahead to learn about how to use gh pr commands with triangular workflows. Otherwise, let’s get into the details of how Git and the GitHub CLI have historically differed, and how four-and-a-half years after it was first requested, we have finally unlocked managing pull requests using triangular workflows in the GitHub CLI. First, a lesson in Git fundamentals To provide a framework for what we set out to do, it’s important to first understand some Git basics. Git, at its core, is a way to store and catalog changes on a repository and communicate those changes between copies of that repository. This workflow typically looks like the diagram below: Figure 1: A typical git branch setup The building blocks of this diagram illustrate two important Git concepts you likely use every day, a ref and push/pull. Refs A ref is a reference to a repository and branch. It has two parts: the remote, usually a name like origin or upstream, and the branch. If the remote is the local repository, it is blank. So, in the example above, origin/branch in the purple box is a remote ref, referring to a branch named branch on the repository name origin, while branch in the green box is a local ref, referring to a branch named branch on the local machine. While working with GitHub, the remote ref is usually the repository you are hosting on GitHub. In the diagram above, you can consider the purple box GitHub and the green box your local machine. Pushing and pulling A push and a pull refer to the same action, but from two different perspectives. Whether you are pushing or pulling is determined by whether you are sending or receiving the changes. I can push a commit to your repo, or you can pull that commit from my repo, and the references to that action would be the same. To disambiguate this, we will refer to different refs as the headRef or baseRef, where the headRef is sending the changes (pushing them) and the baseRef is receiving the changes (pulling them). Figure 2: Disambiguating headRef and baseRef for push/pull operations When dealing with a branch, we’ll often refer to the headRef of its pull operations as its pullRef and the baseRef of its push operations as its pushRef. That’s because, in these instances, the working branch is the pull’s baseRef and the push’s headRef, so they’re already disambiguated. The @{push} revision syntax Turns out, Git has a handy built-in tool for referring to the pushRef for a branch: the @{push} revision syntax. You can usually determine a branch’s pushRef by running the following command: git rev-parse --abbrev-ref @{push} This will result in a human-readable ref, like origin/branch, if one can be determined. Pull Requests On GitHub, a pull request is a proposal to integrate changes from one ref to another. In particular, they act as a simple “pause” before performing the actual integration operation, often called a merge, when changes are being pushed from ref to another. This pause allows for humans (code reviews) and robots (GitHub Copilot reviews and GitHub Actions workflows) to check the code before the changes are integrated. The name pull request came from this language specifically: You are requesting that a ref pulls your changes into itself. Figure 3: Demonstrating how GitHub Pull Requests correspond to pushing and pulling Common Git workflows Now that you understand the basics, let’s talk about the workflows we typically use with Git every day. A centralized workflow is how most folks interact with Git and GitHub. In this configuration, any given branch is pushing and pulling from a remote ref with the same branch name. For most of us, this type of configuration is set up by default when we clone a repo and push a branch. It is the situation shown in Figure 1. In contrast, a triangular workflow pushes to and pulls from different refs. A common use case for this configuration is to pull directly from a remote repository’s default branch into your local feature branch, eliminating the need to run commands like git rebase \u003cdefault\u003e or git merge \u003cdefault\u003e on your feature branch to ensure the branch you’re working on is always up to date with the default branch. However, when pushing changes, this configuration will typically push to a remote ref with the same branch name as the feature branch. Figure 4: juxtaposing centralized workflows from triangular workflows. We complete the triangle when considering pull requests: the headRef is the pushRef for the local ref and the baseRef is the pullRef for the local branch: Figure 5: a triangular workflow We can go one step further and set up triangular workflows using different remotes as well. This most commonly occurs when you’re developing on a fork. In this situation, you usually give the fork and source remotes different names. I’ll use origin for the fork and upstream for the source, as these are common names used in these setups. This functions exactly the same as the triangular workflows above, but the remotes and branches on the pushRef and pullRef are different: Figure 6: juxtaposing triangular workflows and centralized workflows with different remotes such as with forks Using a Git configuration file for triangular workflows There are two primary ways that you can set up a triangular workflow using the Git configuration – typically defined in a `.git/config` or `.gitconfig` file. Before explaining these, let’s take a look at what the relevant bits of a typical configuration look like in a repo’s `.git/config` file for a centralized workflow: [remote “origin”] url = https://github.com/OWNER/REPO.git fetch = +refs/heads/*:refs/remotes/origin/* [branch “default”] remote = origin merge = refs/heads/default [branch “branch”] remote = origin merge = refs/heads/branch Figure 7: A typical Git configuration setup found in .git/config The [remote “origin”] part is naming the Git repository located at github.com/OWNER/REPO.git to origin, so we can reference it elsewhere by that name. We can see that reference being used in the specific [branch] configurations for both the default and branch branches in their remote keys. This key, in conjunction with the branch name, typically makes up the branch’s pushRef: in this example, it is origin/branch. The remote and merge keys are combined to make up the branch’s pullRef: in this example, it is origin/branch. Setting up a triangular branch workflow The simplest way to assemble a triangular workflow is to set the branch’s merge key to a different branch name, like so: [branch “branch”] remote = origin merge = refs/heads/default Figure 8: a triangular branch’s Git configuration found in .git/config This will result in the branch pullRef as origin/default, but pushRef as origin/branch, as shown in Figure 9. Figure 9: A triangular branch workflow Setting up a triangular fork workflow Working with triangular forks requires a bit more customization than triangular branches because we are dealing with multiple remotes. Thus, our remotes in the Git config will look different than the one shown previously in Figure 7: [remote “upstream”] url = https://github.com/ORIGINALOWNER/REPO.git fetch = +refs/heads/*:refs/remotes/upstream/* [remote “origin”] url = https://github.com/FORKOWNER/REPO.git fetch = +refs/heads/*:refs/remotes/origin/* Figure 10: a Git configuration for a multi-remote Git setup found in .git/config Upstream and origin are the most common names used in this construction, so I’ve used them here, but they can be named anything you want1. However, toggling a branch’s remote key between upstream and origin won’t actually set up a triangular fork workflow—it will just set up a centralized workflow with either of those remotes, like the centralized workflow shown in Figure 6. Luckily, there are two common Git configuration options to change this behavior. Setting a branch’s pushremote A branch’s configuration has a key called pushremote that does exactly what the name suggests: configures the remote that the branch will push to. A triangular fork workflow config using pushremote may look like this: [branch “branch”] remote = upstream merge = refs/heads/default pushremote = origin Figure 11: a triangular fork’s Git config using pushremote found in .git/config This assembles the triangular fork repo we see in Figure 12. The pullRef is upstream/default, as determined by combining the remote and merge keys, while the pushRef is origin/branch, as determined by combining the pushremote key and the branch name. Figure 12: A triangular fork workflow Setting a repo’s remote.pushDefault To configure all branches in a repository to have the same behavior as what you’re seeing in Figure 12, you can instead set the repository’s pushDefault. The config for this is below: [remote] pushDefault = origin [branch “branch”] remote = upstream merge = refs/heads/default Figure 13: a triangular fork’s Git config using remote.pushDefault found in .git/config This assembles the same triangular fork repo as shown in Figure 12 above, however this time the pushRef is determined by combining the remote.pushDefault key and the branch name, resulting in origin/branch. When using the branch’s pushremote and the repo’s remote.pushDefault keys together, Git will preferentially resolve the branch’s configuration over the repo’s, so the remote set on pushremote supersedes the remote set on remote.pushDefault. Updating the gh pr command set to reflect Git Previously, the gh pr command set did not resolve pushRefs and pullRefs in the same way that Git does. This was due to technical design decisions that made this change both difficult and complex. Instead of discussing that complexity—a big enough topic for a whole article in itself—I’m going to focus here on what you can now do with the updated gh pr command set. If you set up triangular Git workflows in the manner described above, we will automatically resolve gh pr commands in accordance with your Git configuration. To be slightly more specific, when trying to resolve a pull request for a branch, the GitHub CLI will respect whatever @{push} resolves to first, if it resolves at all. Then it will fall back to respect a branch’s pushremote, and if that isn’t set, finally look for a repo’s remote.pushDefault config settings. What this means is that the CLI is assuming your branch’s pullRef is the pull request’s baseRef and the branch’s pushRef is the pull requests headRef. In other words, if you’ve configured git pull and git push to work, then gh pr commands should just work.2 The diagram below, a general version of Figure 5, demonstrates this nicely: Figure 14: the triangular workflow supported by the GitHub CLI with respect to a branch’s pullRef and pushRef. This is the generalized version of Figure 5 Conclusion We’re constantly working to improve the GitHub CLI, and we’d like the behavior of the GitHub CLI to reasonably reflect the behavior of Git. This was a team effort—everyone contributed to understanding, reviewing, and testing the code to enable this enhanced gh pr command set functionality. It also couldn’t have happened without the support of our contributors, so we extend our thanks to them: @Frederick888 for opening the original pull request @benknoble for his support with pull request review and feedback @phil-blain for highlighting the configurations we’ve talked about here on the original issue @neutrinoceros and @rd-yan-farba for reporting a couple of bugs that the team fixed in v2.66.1 @pdunnavant for reporting the bug that we fixed in v2.71.1 @cs278 for reporting the bug that we fixed in v2.71.2. CLI native support for triangular workflows was 4.5 years in the making, and we’re proud to have been able to provide this update for the community. The GitHub CLI Team @andyfeller, @babakks, @bagtoad, @jtmcg, @mxie, @RyanHecht, and @williammartin Written by Tyler is a Sr. Software Engineer on the GitHub CLI team. He has an eclectic background in scientific research, education, game design/development, and software. His favorite part about his current job is being an open source maintainer and interacting with the community.",
  "image": "https://github.blog/wp-content/uploads/2024/04/1200x630-Collaboration-Unfurl-LIGHT-Logo.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eMost developers are familiar with the standard Git workflow. You create a branch, make changes, and push those changes back to the same branch on the main repository. Git calls this a centralized workflow. It’s straightforward and works well for many projects.\u003c/p\u003e\n\u003cp\u003eHowever, sometimes you might want to pull changes from a different branch directly into your feature branch to help you keep your branch updated without constantly needing to merge or rebase. However, you’ll still want to push local changes to your own branch. This is where triangular workflows come in.\u003c/p\u003e\n\u003cp\u003eIt’s possible that some of you have already used triangular workflows, even without knowing it. When you fork a repo, contribute to your fork, then open a pull request back to the original repo, you’re working in a triangular workflow. While this can work seamlessly on github.com, the process hasn’t always been seamless with the \u003ca href=\"https://cli.github.com/\"\u003eGitHub CLI\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe GitHub CLI team has recently made improvements (released in \u003ca href=\"https://github.com/cli/cli/releases/tag/v2.71.2\"\u003ev2.71.2\u003c/a\u003e) to better support these triangular workflows, ensuring that the \u003ccode\u003egh pr\u003c/code\u003e commands work smoothly with your Git configurations. So, whether you’re working on a centralized workflow or a more complex triangular one, the GitHub CLI will be better equipped to handle your needs.\u003c/p\u003e\n\u003cp\u003eIf you’re already familiar with how Git handles triangular workflows, feel free to skip ahead to learn about how to use \u003ccode\u003egh pr\u003c/code\u003e commands with triangular workflows. Otherwise, let’s get into the details of how Git and the GitHub CLI have historically differed, and how four-and-a-half years after it was first requested, we have finally unlocked managing pull requests using triangular workflows in the GitHub CLI.\u003c/p\u003e\n\u003ch2 id=\"first-a-lesson-in-git-fundamentals\" id=\"first-a-lesson-in-git-fundamentals\"\u003eFirst, a lesson in Git fundamentals\u003ca href=\"#first-a-lesson-in-git-fundamentals\" aria-label=\"First, a lesson in Git fundamentals\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTo provide a framework for what we set out to do, it’s important to first understand some Git basics. Git, at its core, is a way to store and catalog changes on a repository and communicate those changes between copies of that repository. This workflow typically looks like the diagram below:\u003c/p\u003e\n\u003cfigure id=\"attachment_86915\"\u003e\u003ca href=\"https://github.blog/wp-content/uploads/2025/03/triangular-image-1.png\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"457\" height=\"512\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/triangular-image-1.png?resize=457%2C512\" alt=\"Figure 1: A typical git branch setup\" srcset=\"https://github.blog/wp-content/uploads/2025/03/triangular-image-1.png?w=457 457w, https://github.blog/wp-content/uploads/2025/03/triangular-image-1.png?w=268 268w\" sizes=\"auto, (max-width: 457px) 100vw, 457px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 1: A typical git branch setup\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eThe building blocks of this diagram illustrate two important Git concepts you likely use every day, a \u003cstrong\u003eref\u003c/strong\u003e and \u003cstrong\u003epush/pull\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3 id=\"refs\" id=\"refs\"\u003eRefs\u003ca href=\"#refs\" aria-label=\"Refs\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003eref\u003c/strong\u003e is a reference to a repository and branch. It has two parts: the \u003cstrong\u003eremote\u003c/strong\u003e, usually a name like \u003cem\u003eorigin\u003c/em\u003e or \u003cem\u003eupstream\u003c/em\u003e, and the \u003cstrong\u003ebranch\u003c/strong\u003e. If the remote is the local repository, it is blank. So, in the example above, \u003cem\u003eorigin/branch\u003c/em\u003e in the purple box is a \u003cstrong\u003eremote ref\u003c/strong\u003e, referring to a branch named \u003cem\u003ebranch\u003c/em\u003e on the repository name \u003cem\u003eorigin\u003c/em\u003e, while \u003cem\u003ebranch\u003c/em\u003e in the green box is a \u003cstrong\u003elocal ref\u003c/strong\u003e, referring to a branch named \u003cem\u003ebranch\u003c/em\u003e on the local machine.\u003c/p\u003e\n\u003cp\u003eWhile working with GitHub, the remote ref is usually the repository you are hosting on GitHub. In the diagram above, you can consider the purple box GitHub and the green box your local machine.\u003c/p\u003e\n\u003ch3 id=\"pushing-and-pulling\" id=\"pushing-and-pulling\"\u003ePushing and pulling\u003ca href=\"#pushing-and-pulling\" aria-label=\"Pushing and pulling\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA \u003cstrong\u003epush\u003c/strong\u003e and a \u003cstrong\u003epull\u003c/strong\u003e refer to the same action, but from two different perspectives. Whether you are pushing or pulling is determined by whether you are sending or receiving the changes. I can push a commit to your repo, or you can pull that commit from my repo, and the references to that action would be the same.\u003c/p\u003e\n\u003cp\u003eTo disambiguate this, we will refer to different refs as the \u003cstrong\u003eheadRef\u003c/strong\u003e or \u003cstrong\u003ebaseRef\u003c/strong\u003e, where the \u003cstrong\u003eheadRef\u003c/strong\u003e is sending the changes (\u003cem\u003epushing\u003c/em\u003e them) and the \u003cstrong\u003ebaseRef\u003c/strong\u003e is receiving the changes (\u003cem\u003epulling\u003c/em\u003e them).\u003c/p\u003e\n\u003cfigure id=\"attachment_85923\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"864\" height=\"128\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/image2_e1d22b.png?resize=864%2C128\" alt=\"Figure 2: Disambiguating headRef and baseRef for push/pull operations.\" srcset=\"https://github.blog/wp-content/uploads/2025/03/image2_e1d22b.png?w=864 864w, https://github.blog/wp-content/uploads/2025/03/image2_e1d22b.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/image2_e1d22b.png?w=768 768w\" sizes=\"auto, (max-width: 864px) 100vw, 864px\"/\u003e\u003cfigcaption\u003eFigure 2: Disambiguating headRef and baseRef for push/pull operations\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWhen dealing with a branch, we’ll often refer to the headRef of its pull operations as its \u003cstrong\u003epullRef\u003c/strong\u003e and the baseRef of its push operations as its \u003cstrong\u003epushRef\u003c/strong\u003e. That’s because, in these instances, the working branch is the pull’s baseRef and the push’s headRef, so they’re already disambiguated.\u003c/p\u003e\n\u003ch4 id=\"the-push-revision-syntax\" id=\"the-push-revision-syntax\"\u003eThe \u003ccode\u003e@{push}\u003c/code\u003e revision syntax\u003ca href=\"#the-push-revision-syntax\" aria-label=\"The \u0026lt;code\u0026gt;@{push}\u0026lt;/code\u0026gt; revision syntax\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eTurns out, Git has a handy built-in tool for referring to the pushRef for a branch: the \u003ccode\u003e@{push}\u003c/code\u003e revision syntax. You can usually determine a branch’s pushRef by running the following command:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit rev-parse --abbrev-ref @{push}\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis will result in a human-readable ref, like \u003cstrong\u003eorigin/branch\u003c/strong\u003e, if one can be determined.\u003c/p\u003e\n\u003ch4 id=\"pull-requests\" id=\"pull-requests\"\u003ePull Requests\u003ca href=\"#pull-requests\" aria-label=\"Pull Requests\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eOn GitHub, a \u003cstrong\u003epull request\u003c/strong\u003e is a proposal to integrate changes from one ref to another. In particular, they act as a simple “pause” before performing the actual integration operation, often called a \u003cstrong\u003emerge\u003c/strong\u003e, when changes are being pushed from ref to another. This pause allows for humans (code reviews) and robots (GitHub Copilot reviews and GitHub Actions workflows) to check the code before the changes are integrated. The name \u003cem\u003epull request\u003c/em\u003e came from this language specifically: You are requesting that a ref pulls your changes into itself.\u003c/p\u003e\n\u003cfigure id=\"attachment_85924\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"864\" height=\"266\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/image3_6e731a.png?resize=864%2C266\" alt=\"Figure 3: Demonstrating how GitHub Pull Requests correspond to pushing and pulling.\" srcset=\"https://github.blog/wp-content/uploads/2025/03/image3_6e731a.png?w=864 864w, https://github.blog/wp-content/uploads/2025/03/image3_6e731a.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/image3_6e731a.png?w=768 768w\" sizes=\"auto, (max-width: 864px) 100vw, 864px\"/\u003e\u003cfigcaption\u003eFigure 3: Demonstrating how GitHub Pull Requests correspond to pushing and pulling\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2 id=\"common-git-workflows\" id=\"common-git-workflows\"\u003eCommon Git workflows\u003ca href=\"#common-git-workflows\" aria-label=\"Common Git workflows\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow that you understand the basics, let’s talk about the workflows we typically use with Git every day.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003ecentralized workflow\u003c/strong\u003e is how most folks interact with Git and GitHub. In this configuration, any given branch is pushing and pulling from a remote ref with the same branch name. For most of us, this type of configuration is set up by default when we clone a repo and push a branch. It is the situation shown in Figure 1.\u003c/p\u003e\n\u003cp\u003eIn contrast, a \u003cstrong\u003etriangular workflow\u003c/strong\u003e pushes to and pulls from \u003cem\u003edifferent\u003c/em\u003e refs. A common use case for this configuration is to pull directly from a remote repository’s default branch into your local feature branch, eliminating the need to run commands like \u003ccode\u003egit rebase \u0026lt;default\u0026gt;\u003c/code\u003e or \u003ccode\u003egit merge \u0026lt;default\u0026gt;\u003c/code\u003e on your feature branch to ensure the branch you’re working on is always up to date with the default branch. However, when pushing changes, this configuration will typically push to a remote ref with the same branch name as the feature branch.\u003c/p\u003e\n\u003cfigure id=\"attachment_86920\"\u003e\u003ca href=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1600\" height=\"703\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?resize=1600%2C703\" alt=\"Figure 4: juxtaposing centralized workflows from triangular workflows.\" srcset=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?w=300 300w, https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?w=768 768w, https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/04/triangular-image-4.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 4: juxtaposing centralized workflows from triangular workflows.\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe complete the triangle when considering pull requests: the \u003cstrong\u003eheadRef\u003c/strong\u003e is the \u003cstrong\u003epushRef\u003c/strong\u003e for the local ref and the \u003cstrong\u003ebaseRef\u003c/strong\u003e is the \u003cstrong\u003epullRef\u003c/strong\u003e for the local branch:\u003c/p\u003e\n\u003cfigure id=\"attachment_85926\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1549\" height=\"1069\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?resize=1549%2C1069\" alt=\"Figure 5: a triangular workflow\" srcset=\"https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?w=1549 1549w, https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?w=768 768w, https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/03/image5_9b14d8.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003cfigcaption\u003eFigure 5: a triangular workflow\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003eWe can go one step further and set up triangular workflows using \u003cem\u003edifferent\u003c/em\u003e remotes as well. This most commonly occurs when you’re developing on a fork. In this situation, you usually give the fork and source remotes different names. I’ll use \u003cem\u003eorigin\u003c/em\u003e for the fork and \u003cem\u003eupstream\u003c/em\u003e for the source, as these are common names used in these setups. This functions exactly the same as the triangular workflows above, but the \u003cstrong\u003eremotes\u003c/strong\u003e and \u003cstrong\u003ebranches\u003c/strong\u003e on the \u003cstrong\u003epushRef\u003c/strong\u003e and \u003cstrong\u003epullRef\u003c/strong\u003e are different:\u003c/p\u003e\n\u003cfigure id=\"attachment_86922\"\u003e\u003ca href=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1600\" height=\"704\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?resize=1600%2C704\" alt=\"Figure 6: juxtaposing triangular workflows and centralized workflows with different remotes such as with forks\" srcset=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?w=1600 1600w, https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?w=300 300w, https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?w=768 768w, https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/04/triangular-image-6.png?w=1536 1536w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 6: juxtaposing triangular workflows and centralized workflows with different remotes such as with forks\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch3 id=\"using-a-git-configuration-file-for-triangular-workflows\" id=\"using-a-git-configuration-file-for-triangular-workflows\"\u003eUsing a Git configuration file for triangular workflows\u003ca href=\"#using-a-git-configuration-file-for-triangular-workflows\" aria-label=\"Using a Git configuration file for triangular workflows\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere are two primary ways that you can set up a triangular workflow using the \u003ca href=\"https://git-scm.com/docs/git-config\"\u003eGit configuration – typically defined in a `.git/config` or `.gitconfig` file\u003c/a\u003e. Before explaining these, let’s take a look at what the relevant bits of a typical configuration look like in a repo’s `.git/config` file for a centralized workflow:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[remote “origin”] \n    url = https://github.com/OWNER/REPO.git \n    fetch = +refs/heads/*:refs/remotes/origin/*  \n[branch “default”]\n    remote = origin  \n    merge = refs/heads/default  \n[branch “branch”]\n    remote = origin \n    merge = refs/heads/branch\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eFigure 7: A typical Git configuration setup found in .git/config\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e[remote “origin”]\u003c/code\u003e part is naming the Git repository located at \u003ccode\u003egithub.com/OWNER/REPO.git\u003c/code\u003e to \u003cem\u003eorigin,\u003c/em\u003e so we can reference it elsewhere by that name. We can see that reference being used in the specific \u003ccode\u003e[branch]\u003c/code\u003e configurations for both the \u003cem\u003edefault\u003c/em\u003e and \u003cem\u003ebranch\u003c/em\u003e branches in their \u003ccode\u003eremote\u003c/code\u003e keys. This key, in conjunction with the branch name, typically makes up the branch’s \u003cstrong\u003epushRef\u003c/strong\u003e: in this example, it is \u003cem\u003eorigin/branch\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eremote\u003c/code\u003e and \u003ccode\u003emerge\u003c/code\u003e keys are combined to make up the branch’s \u003cstrong\u003epullRef\u003c/strong\u003e: in this example, it is \u003cem\u003eorigin/branch\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"setting-up-a-triangular-branch-workflow\" id=\"setting-up-a-triangular-branch-workflow\"\u003eSetting up a triangular branch workflow\u003ca href=\"#setting-up-a-triangular-branch-workflow\" aria-label=\"Setting up a triangular branch workflow\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe simplest way to assemble a triangular workflow is to set the branch’s \u003ccode\u003emerge\u003c/code\u003e key to a different branch name, like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[branch “branch”]\n    remote = origin\n    merge = refs/heads/default\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eFigure 8: a triangular branch’s Git configuration found in .git/config\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThis will result in the branch \u003cstrong\u003epullRef\u003c/strong\u003e as \u003cem\u003eorigin/default\u003c/em\u003e, but \u003cstrong\u003epushRef\u003c/strong\u003e as \u003cem\u003eorigin/branch\u003c/em\u003e, as shown in Figure 9.\u003c/p\u003e\n\u003cfigure id=\"attachment_86923\"\u003e\u003ca href=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1225\" height=\"1066\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png?resize=1225%2C1066\" alt=\"Figure 9: A triangular branch workflow\" srcset=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png?w=1225 1225w, https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png?w=300 300w, https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png?w=768 768w, https://github.blog/wp-content/uploads/2025/04/triangular-image-9.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 9: A triangular branch workflow\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch3 id=\"setting-up-a-triangular-fork-workflow\" id=\"setting-up-a-triangular-fork-workflow\"\u003eSetting up a triangular fork workflow\u003ca href=\"#setting-up-a-triangular-fork-workflow\" aria-label=\"Setting up a triangular fork workflow\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWorking with triangular forks requires a bit more customization than triangular branches because we are dealing with multiple remotes. Thus, our remotes in the Git config will look  different than the one shown previously in Figure 7:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[remote “upstream”]\n    url = https://github.com/ORIGINALOWNER/REPO.git \n    fetch = +refs/heads/*:refs/remotes/upstream/* \n[remote “origin”]\n    url = https://github.com/FORKOWNER/REPO.git  \n    fetch = +refs/heads/*:refs/remotes/origin/*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eFigure 10: a Git configuration for a multi-remote Git setup found in .git/config\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eUpstream\u003c/em\u003e and \u003cem\u003eorigin\u003c/em\u003e are the most common names used in this construction, so I’ve used them here, but they can be named anything you want\u003csup id=\"fnref-85920-1\"\u003e\u003ca href=\"#fn-85920-1\" title=\"Read footnote.\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, toggling a branch’s \u003ccode\u003eremote\u003c/code\u003e key between \u003cem\u003eupstream\u003c/em\u003e and \u003cem\u003eorigin\u003c/em\u003e won’t actually set up a triangular fork workflow—it will just set up a centralized workflow with either of those remotes, like the centralized workflow shown in Figure 6. Luckily, there are two common Git configuration options to change this behavior.\u003c/p\u003e\n\u003ch4 id=\"setting-a-branchs-pushremote\" id=\"setting-a-branchs-pushremote\"\u003eSetting a branch’s \u003ccode\u003epushremote\u003c/code\u003e\u003ca href=\"#setting-a-branchs-pushremote\" aria-label=\"Setting a branch’s \u0026lt;code\u0026gt;pushremote\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eA branch’s configuration has a key called \u003ccode\u003epushremote\u003c/code\u003e that does exactly what the name suggests: configures the remote that the branch will push to. A triangular fork workflow config using \u003ccode\u003epushremote\u003c/code\u003e may look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[branch “branch”]\n    remote = upstream  \n    merge = refs/heads/default  \n    pushremote = origin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eFigure 11: a triangular fork’s Git config using pushremote found in .git/config\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThis assembles the triangular fork repo we see in Figure 12. The \u003cstrong\u003epullRef\u003c/strong\u003e is \u003cem\u003eupstream/default\u003c/em\u003e, as determined by combining the \u003ccode\u003eremote\u003c/code\u003e and \u003ccode\u003emerge\u003c/code\u003e keys, while the \u003cstrong\u003epushRef\u003c/strong\u003e is \u003cem\u003eorigin/branch\u003c/em\u003e, as determined by combining the \u003ccode\u003epushremote\u003c/code\u003e key and the branch name.\u003c/p\u003e\n\u003cfigure id=\"attachment_86924\"\u003e\u003ca href=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"1226\" height=\"1067\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png?resize=1226%2C1067\" alt=\"Figure 12: A triangular fork workflow\" srcset=\"https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png?w=1226 1226w, https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png?w=300 300w, https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png?w=768 768w, https://github.blog/wp-content/uploads/2025/04/triangular-image-12.png?w=1024 1024w\" sizes=\"auto, (max-width: 1000px) 100vw, 1000px\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 12: A triangular fork workflow\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch4 id=\"setting-a-repos-remote-pushdefault\" id=\"setting-a-repos-remote-pushdefault\"\u003eSetting a repo’s \u003ccode\u003eremote.pushDefault\u003c/code\u003e\u003ca href=\"#setting-a-repos-remote-pushdefault\" aria-label=\"Setting a repo’s \u0026lt;code\u0026gt;remote.pushDefault\u0026lt;/code\u0026gt;\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eTo configure all branches in a repository to have the same behavior as what you’re seeing in Figure 12, you can instead set the repository’s \u003ccode\u003epushDefault\u003c/code\u003e. The config for this is below:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[remote] \n    pushDefault = origin \n[branch “branch”]\n    remote = upstream \n    merge = refs/heads/default\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eFigure 13: a triangular fork’s Git config using remote.pushDefault found in .git/config\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThis assembles the same triangular fork repo as shown in Figure 12 above, however this time the \u003cstrong\u003epushRef\u003c/strong\u003e is determined by combining the \u003ccode\u003eremote.pushDefault\u003c/code\u003e key and the branch name, resulting in \u003cem\u003eorigin/branch\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhen using the branch’s \u003ccode\u003epushremote\u003c/code\u003e and the repo’s \u003ccode\u003eremote.pushDefault\u003c/code\u003e keys together, Git will preferentially resolve the branch’s configuration over the repo’s, so the remote set on \u003ccode\u003epushremote\u003c/code\u003e supersedes the remote set on \u003ccode\u003eremote.pushDefault\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"updating-the-gh-pr-command-set-to-reflect-git\" id=\"updating-the-gh-pr-command-set-to-reflect-git\"\u003eUpdating the \u003ccode\u003egh pr\u003c/code\u003e command set to reflect Git\u003ca href=\"#updating-the-gh-pr-command-set-to-reflect-git\" aria-label=\"Updating the \u0026lt;code\u0026gt;gh pr\u0026lt;/code\u0026gt; command set to reflect Git\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePreviously, the \u003ccode\u003egh pr\u003c/code\u003e command set did not resolve \u003cstrong\u003epushRefs\u003c/strong\u003e and \u003cstrong\u003epullRefs\u003c/strong\u003e in the same way that Git does. This was due to technical design decisions that made this change both difficult and complex. Instead of discussing that complexity—a big enough topic for a whole article in itself—I’m going to focus here on what you can now \u003cem\u003edo\u003c/em\u003e with the updated \u003ccode\u003egh pr\u003c/code\u003e command set.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIf you set up triangular Git workflows in the manner described above, we will automatically resolve \u003ccode\u003egh pr\u003c/code\u003e commands in accordance with your Git configuration.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo be slightly more specific, when trying to resolve a pull request for a branch, the GitHub CLI will respect whatever \u003ccode\u003e@{push}\u003c/code\u003e resolves to first, if it resolves at all. Then it will fall back to respect a branch’s \u003ccode\u003epushremote,\u003c/code\u003e and if that isn’t set,  finally look for a repo’s \u003ccode\u003eremote.pushDefault\u003c/code\u003e config settings.\u003c/p\u003e\n\u003cp\u003eWhat this means is that the CLI is assuming your branch’s \u003cstrong\u003epullRef\u003c/strong\u003e is the pull request’s \u003cstrong\u003ebaseRef\u003c/strong\u003e and the branch’s \u003cstrong\u003epushRef\u003c/strong\u003e is the pull requests \u003cstrong\u003eheadRef\u003c/strong\u003e. In other words, if you’ve configured \u003ccode\u003egit pull\u003c/code\u003e and \u003ccode\u003egit push\u003c/code\u003e to work, then \u003ccode\u003egh pr\u003c/code\u003e commands should just work.\u003csup id=\"fnref-85920-2\"\u003e\u003ca href=\"#fn-85920-2\" title=\"Read footnote.\"\u003e2\u003c/a\u003e\u003c/sup\u003e The diagram below, a general version of Figure 5, demonstrates this nicely:\u003c/p\u003e\n\u003cfigure id=\"attachment_85930\"\u003e\u003cimg data-recalc-dims=\"1\" decoding=\"async\" width=\"965\" height=\"719\" loading=\"lazy\" src=\"https://github.blog/wp-content/uploads/2025/03/image9.png?resize=965%2C719\" alt=\"Figure 14: the triangular workflow supported by the GitHub CLI with respect to a branch’s pullRef and pushRef. This is the generalized version of Figure 5\" srcset=\"https://github.blog/wp-content/uploads/2025/03/image9.png?w=965 965w, https://github.blog/wp-content/uploads/2025/03/image9.png?w=300 300w, https://github.blog/wp-content/uploads/2025/03/image9.png?w=768 768w\" sizes=\"auto, (max-width: 965px) 100vw, 965px\"/\u003e\u003cfigcaption\u003eFigure 14: the triangular workflow supported by the GitHub CLI with respect to a branch’s pullRef and pushRef. This is the generalized version of Figure 5\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2 id=\"conclusion\" id=\"conclusion\"\u003eConclusion\u003ca href=\"#conclusion\" aria-label=\"Conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe’re constantly working to improve the GitHub CLI, and we’d like the behavior of the GitHub CLI to reasonably reflect the behavior of Git. This was a team effort—everyone contributed to understanding, reviewing, and testing the code to enable this enhanced \u003ccode\u003egh pr\u003c/code\u003e command set functionality.\u003c/p\u003e\n\u003cp\u003eIt also couldn’t have happened without the support of our contributors, so we extend our thanks to them:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@Frederick888\u003c/code\u003e for opening the \u003ca href=\"https://github.com/cli/cli/pull/9208\"\u003eoriginal pull request\u003c/a\u003e  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@benknoble\u003c/code\u003e for his support with pull request review and feedback  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@phil-blain\u003c/code\u003e for \u003ca href=\"https://github.com/cli/cli/issues/575#issuecomment-668213138\"\u003ehighlighting the configurations\u003c/a\u003e we’ve talked about here on the \u003ca href=\"https://github.com/cli/cli/issues/575\"\u003eoriginal issue\u003c/a\u003e  \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@neutrinoceros\u003c/code\u003e and \u003ccode\u003e@rd-yan-farba\u003c/code\u003e for reporting a \u003ca href=\"https://github.com/search?q=repo%3Acli%2Fcli+10352+10346\u0026amp;type=issues\"\u003ecouple of bugs\u003c/a\u003e that the team fixed in \u003ca href=\"https://github.com/cli/cli/releases/tag/v2.66.1\"\u003ev2.66.1\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@pdunnavant\u003c/code\u003e for \u003ca href=\"https://github.com/cli/cli/issues/10857\"\u003ereporting the bug\u003c/a\u003e that we fixed in v2.71.1\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@cs278\u003c/code\u003e for \u003ca href=\"https://github.com/cli/cli/issues/10862\"\u003ereporting the bug\u003c/a\u003e that we fixed in v2.71.2.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCLI native support for triangular workflows was 4.5 years in the making, and we’re proud to have been able to provide this update for the community.\u003c/p\u003e\n\u003cp\u003eThe GitHub CLI Team\u003cbr/\u003e\n\u003ccode\u003e@andyfeller\u003c/code\u003e, \u003ccode\u003e@babakks\u003c/code\u003e, \u003ccode\u003e@bagtoad\u003c/code\u003e, \u003ccode\u003e@jtmcg\u003c/code\u003e, \u003ccode\u003e@mxie\u003c/code\u003e, \u003ccode\u003e@RyanHecht\u003c/code\u003e, and \u003ccode\u003e@williammartin\u003c/code\u003e\u003c/p\u003e\n\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/5891697?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/5891697?v=4\u0026amp;s=200\" alt=\"Tyler McGoffin\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\t\t\t\t\n\t\t\t\t\t\u003cp\u003eTyler is a Sr. Software Engineer on the GitHub CLI team. He has an eclectic background in scientific research, education, game design/development, and software. His favorite part about his current job is being an open source maintainer and interacting with the community.\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003c/div\u003e",
  "readingTime": "15 min read",
  "publishedTime": "2025-04-25T16:00:37Z",
  "modifiedTime": "2025-04-25T16:43:30Z"
}
