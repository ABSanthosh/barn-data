{
  "id": "916d4e35-ff71-45eb-9070-100aac0b9458",
  "title": "Structuring Ktor Projects Using Domain-Driven Design (DDD) Concepts: A Step-by-Step Guide With a Minimalistic CRM",
  "link": "https://blog.jetbrains.com/kotlin/2025/04/domain-driven-design-guide/",
  "description": "In this guide, we’ll show you how to structure a project using domain-driven design (DDD) concepts, step by step, by building a minimalistic CRM system. Sample code for the article: https://github.com/antonarhipov/ktor-ddd-example  Ktor is a highly flexible framework that allows developers to structure their applications however they see fit. Unlike some opinionated frameworks (like Spring Boot), […]",
  "author": "Anton Arhipov",
  "published": "Wed, 30 Apr 2025 12:29:16 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "kotlin",
    "guide"
  ],
  "byline": "Anton Arhipov",
  "length": 19784,
  "excerpt": "In this guide, we’ll show you how to structure a project using domain-driven design (DDD) concepts, step by step, by building a minimalistic CRM system.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "A concise multiplatform language developed by JetBrains KotlinStructuring Ktor Projects Using Domain-Driven Design (DDD) Concepts: A Step-by-Step Guide With a Minimalistic CRM In this guide, we’ll show you how to structure a project using domain-driven design (DDD) concepts, step by step, by building a minimalistic CRM system. Sample code for the article: https://github.com/antonarhipov/ktor-ddd-example  Ktor is a highly flexible framework that allows developers to structure their applications however they see fit. Unlike some opinionated frameworks (like Spring Boot), Ktor does not enforce a predefined project structure, which can be both an advantage and a challenge. Many developers, especially those new to Ktor, often wonder: How should I structure my Ktor project for scalability, maintainability, and long-term growth? In this guide, we’ll answer that question step by step by building a minimalistic CRM system. This CRM will start as a simple Ktor application and gradually evolve into a well-structured, scalable project following best practices inspired by domain-driven design (DDD) and feature-based modularization. How we’ll approach this We’ll start with a simple, unstructured Ktor project and progressively refine it to have a well-structured, scalable architecture. Each step will introduce new concepts and improvements: Introduce domain models to define entities like Customer, Note, and Reminder. Define repositories and services to separate the business logic from the routes. Add a presentation layer with Ktor routes. Defining the domain model: Entities and value objects Our first step is to define the core domain model for our minimalistic CRM. In domain-driven design (DDD), we structure the domain layer around entities, value objects, and aggregates to model real-world concepts effectively. Defining entities Since we’re building a minimalistic CRM system, we need to define the fundamental building blocks: Customer: Represents a client with whom you interact. Contact: Represents a method to reach a customer. One customer can have multiple contacts. Note: Represents business information or interactions (can be tied to a customer or an order). Reminder: Represents an alert associated with a contact (and optionally linked to a note) to help you remember promises or follow-ups. // domain/customer/Customer.kt import java.time.LocalDateTime import java.util.UUID // A simple Value Object for unique identifiers @JvmInline value class CustomerId(val value: Long) @JvmInline value class ContactId(val value: Long) @JvmInline value class NoteId(val value: Long) data class Contact( val id: ContactId? = null, val name: String, val email: Email, val phone: String ) data class Note( val id: NoteId? = null, val content: String, val createdAt: LocalDateTime = LocalDateTime.now() ) data class Customer( val id: CustomerId? = null, val name: String, val contacts: List\u003cContact\u003e = emptyList(), val notes: List\u003cNote\u003e = emptyList() ) { fun withContact(contact: Contact): Customer { return copy(contacts = contacts + contact) } fun withNote(note: Note): Customer { return copy(notes = notes + note) } } Defining value objects Value objects are immutable and are defined solely by their attributes. They help encapsulate concepts such as identifiers or more complex attributes (e.g., an Email object with validation). In our example, the unique identifiers (like CustomerId) are implemented as value objects, ensuring immutability and encapsulation of identity details. You can further extend this idea by encapsulating additional business rules. For example: // Example: a more complex value object for // Email might include validation logic. @JvmInline value class Email(val address: String) { init { require(address.contains(\"@\")) { \"Invalid email address\" } } } Relationships and aggregates In domain-driven design (DDD), an aggregate is a cluster of domain objects that should be treated as a single unit when enforcing business rules. Each aggregate has a clearly defined boundary and a single aggregate root, which serves as the only entry point for modifying the aggregate’s state. In our initial model: Customer is the aggregate root, ensuring consistency and encapsulating its associated contacts and notes. All modifications to these related entities must go through the customer. Reminder is a separate entity linked to a customer (and optionally a note), but it has its own lifecycle and behaviors, making it an independent aggregate. Using aggregates helps enforce business rules and invariants. For example, defining customer as the aggregate root ensures that contacts are always managed in the context of their customer, preventing orphaned or inconsistent data. This is what the project structure looks like so far with the two aggregations defined above: ktor-crm/ └─ src/ └─ main/ └─ kotlin/ ├─ Application.kt // Ktor application entry point └─ domain/ ├─ customer/ │ └─ Customer.kt // Customer, Contact, Note └─ reminder/ └── Reminder.kt // Reminder In this first step of our guide, we defined the core domain elements for our minimalistic CRM: Entities: Customer, Contact, Note, and Reminder Value objects: CustomerId, ContactId, NoteId, and ReminderId (and potentially others like Email) These definitions set the stage for further expansion, such as implementing business logic within domain services, setting up repositories for persistence, and eventually wiring up these components in our Ktor application. Next, we can look at how to encapsulate business behaviors, and later, how these domain elements interact with the application layer in a modularized Ktor structure. Encapsulating business behaviors: Repositories, services, and domain events. In a DDD-inspired design, repositories, domain services, and domain events work together to implement your CRM’s use cases while maintaining clear separation of concerns. Repositories Repositories act as an abstraction layer between your domain model and the data persistence mechanism (like a database). They provide simple methods for retrieving, storing, and updating domain entities without exposing the underlying data access logic. interface CustomerRepository { fun findById(id: CustomerId): Customer? fun save(customer: Customer) // Additional methods like delete, update, list, etc. } The repository encapsulates all the queries and transactions needed to work with the domain model. For instance, when adding a new contact, the repository can ensure that the updated customer aggregate is properly stored. Our demo project uses a mock in-memory implementation of the repository interface. The real implementation depends on the technology and infrastructure used by your organization. In Ktor projects, you often see the Exposed database library used to implement this functionality. However, Ktor does not enforce any constraints on repository implementations, so you can choose to use any other data access libraries. Domain services Domain services encapsulate business logic that doesn’t naturally belong to an entity or value object. They coordinate complex operations that might involve multiple domain objects or aggregates. class CustomerService( private val customerRepository: CustomerRepository, private val eventPublisher: EventPublisher ) { fun createCustomer(name: String): Customer { val customer = Customer(name = name) customerRepository.save(customer) return customer } fun getCustomer(id: Long): Customer? { return customerRepository.findById(CustomerId(id)) } fun addContact(customerId: CustomerId, contact: Contact): Customer? { val customer = customerRepository.findById(customerId) ?: return null // Business logic to add a contact (could be a method on Customer entity) val updatedCustomer = customer.withContact(contact) customerRepository.save(updatedCustomer) // Publish a domain event to signal that a new contact has been added eventPublisher.publish(ContactAddedEvent(customerId, contact)) return updatedCustomer } fun addNote(customerId: CustomerId, note: Note): Customer? { val customer = customerRepository.findById(customerId) ?: return null val updatedCustomer = customer.withNote(note) customerRepository.save(updatedCustomer) // Publish a domain event to signal about a new note eventPublisher.publish(NoteAddedEvent(customerId, note)) return updatedCustomer } } The service: Fetches the current state of the customer. Applies business rules (e.g., adding a contact or note). Persists the updated state via the repository. Publishes a domain event to notify other parts of the system of the change. Domain events Domain events are messages that indicate something significant has occurred within the domain. They help decouple the direct consequences of a business operation from the triggering action. Other components can listen to these events and perform additional tasks (e.g., sending notifications, updating search indexes) without cluttering the core business logic. // DomainEvents.kt sealed interface DomainEvent data class ContactAddedEvent( val customerId: CustomerId, val contact: Contact ): DomainEvent data class NoteAddedEvent( val customerId: CustomerId, val note: Note ): DomainEvent Event publishing An EventPublisher interface can be used to publish these events. In a real-world application, this can be integrated with an event bus or messaging system: interface EventPublisher { fun publish(event: DomainEvent) } Benefits: Decoupling: Other parts of your application can subscribe to these events without the service needing to know about them. Extensibility: As your application evolves, additional behavior can be attached to these events without modifying the core business logic. Bringing it all together In our minimalistic CRM, when a user action triggers a use case (e.g., adding a new contact or note), the flow might look like this: User action:The client makes an API call to add a contact to a customer. Service coordination:The CustomerService retrieves the customer using the CustomerRepository, applies the business logic to add the contact, and saves the updated customer. Event publication:After saving, the service publishes a ContactAddedEvent through the EventPublisher. Other parts of the system (like notification modules or logging services) can listen to this event and react accordingly. This approach ensures that your domain logic remains clean, well-organized, and focused on business rules while delegating infrastructure and cross-cutting concerns to dedicated components. Now the project structure looks as follows: ktor-crm/ └─ src/ └─ main/ └─ kotlin/ └─ com/ └─ example/ ├─ Application.kt ├─ domain/ │ ├─ customer/ │ │ ├─ Customer.kt │ │ ├─ CustomerRepository.kt │ │ └─ CustomerService.kt │ └─ reminder / │ ├─ Reminder.kt │ ├─ ReminderRepository.kt │ └─ ReminderService.kt └─ events/ ├─ DomainEvents.kt └─ EventPublisher.kt Building the presentation layer with Ktor The code samples above didn’t use any external libraries or Ktor APIs because these are just implementation details. The conceptual framework of domain-driven design allowed us to structure the code so that we can plug in the necessary dependencies to create the application. Now we can move on and wire the services into the web server, exposing the REST API as a presentation layer. For this purpose, we will add the corresponding route definitions into the domain subpackages. // domain/customer/CustomerRoutes.kt fun Application.customerRoutes() { routing { val repository = InMemoryCustomerRepository() val eventPublisher = EventPublisherImpl() //TODO: use the service in the routes below val service = CustomerService(repository, eventPublisher) route(\"/customers\") { // Create customer post { val customer = call.receive\u003cCustomer\u003e() val createdCustomer = service.createCustomer(customer.name) call.respond(HttpStatusCode.Created, createdCustomer) } // Get customer by ID get(\"/{id}\") { val id = call.parameters[\"id\"]?.toLongOrNull() ?: return@get call.respondText( \"Missing or malformed id\", status = HttpStatusCode.BadRequest ) val customer = service.getCustomer(id) if (customer != null) { call.respond(customer) } else { call.respondText(\"Customer not found\", status = HttpStatusCode.NotFound) } } // Add contact to customer post(\"/{id}/contacts\") { val id = call.parameters[\"id\"]?.toLongOrNull() ?: return@post call.respondText( \"Missing or malformed id\", status = HttpStatusCode.BadRequest ) val contact = call.receive\u003cContact\u003e() val updatedCustomer = service.addContact(CustomerId(id), contact) if (updatedCustomer != null) { call.respond(updatedCustomer) } else { call.respondText(\"Customer not found\", status = HttpStatusCode.NotFound) } } // Add note to customer post(\"/{id}/notes\") { val id = call.parameters[\"id\"]?.toLongOrNull() ?: return@post call.respondText( \"Missing or malformed id\", status = HttpStatusCode.BadRequest ) val note = call.receive\u003cNote\u003e() val updatedCustomer = service.addNote(CustomerId(id), note) if (updatedCustomer != null) { call.respond(updatedCustomer) } else { call.respondText(\"Customer not found\", status = HttpStatusCode.NotFound) } } } } } // domain/reminder/ReminderRoutes.kt fun Application.reminderRoutes() { routing { val repository = InMemoryReminderRepository() val service = ReminderService(repository) route(\"/reminders\") { // Create a reminder post { val reminder = call.receive\u003cReminder\u003e() val createdReminder = service.createReminder( customerId = reminder.customerId, noteId = reminder.noteId?.value, remindAt = reminder.remindAt, message = reminder.message ) call.respond(HttpStatusCode.Created, createdReminder) } // Get reminder by ID get(\"/{id}\") { val id = call.parameters[\"id\"] ?: return@get call.respondText( \"Missing or malformed id\", status = HttpStatusCode.BadRequest ) val reminder = service.getReminder(id) if (reminder != null) { call.respond(reminder) } else { call.respondText(\"Reminder not found\", status = HttpStatusCode.NotFound) } } // Get reminders for a customer get(\"/customer/{customerId}\") { val customerId = call.parameters[\"customerId\"] ?: return@get call.respondText( \"Missing or malformed customerId\", status = HttpStatusCode.BadRequest ) val reminders = service.getRemindersForCustomer(CustomerId(customerId)) call.respond(reminders) } } } } You might have noticed that the repository and event publisher implementations are created manually. However, as the project grows, it might be more convenient to implement this using the dependency injection (DI) pattern instead. The subroutes for the corresponding domain objects and aggregates are defined as extension functions in their respective files. This is a common pattern when working with Ktor projects. These functions are called from within the Application.kt module function on the application startup: // Application.kt fun main() { embeddedServer(Netty, port = 8080, module = Application::module) .start(wait = true) } fun Application.module() { install(ContentNegotiation) { json() } routing { // Register routes from the domain subpackages customerRoutes() reminderRoutes() } } With the routing files, our project structure looks as follows: ktor-crm/ └─ src/ └─ main/ └─ kotlin/ └─ com/ └─ example/ ├─ Application.kt ├─ domain/ │ ├─ customer/ │ │ ├─ Customer.kt │ │ ├─ CustomerRepository.kt │ │ ├─ CustomerRoutes.kt │ │ └─ CustomerService.kt │ └─ reminder / │ ├─ Reminder.kt │ ├─ ReminderRepository.kt │ ├─ ReminderRoutes.kt │ └─ ReminderService.kt └─ events/ ├─ DomainEvents.kt └─ EventPublisher.kt At this point, we have integrated the business logic into the Ktor application, and the next step ise adding the infrastructural aspects, such as database configuration, authentication, etc.  Summary This article introduced key domain-driven design (DDD) concepts – like entities, value objects, repositories, and domain services – and demonstrated how to apply them in a Ktor project. We built a simple CRM system, organizing the code into well-defined domain subpackages (customers, reminders) with dedicated value classes and modular routes. This approach creates a clear, scalable, and maintainable codebase for your Ktor applications. The source code for the sample presented in this article is available at: https://github.com/antonarhipov/ktor-ddd-example  Subscribe to Kotlin Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/kt-social_share_blog_1280x720_en-6.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/kotlin/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/Kotlin-5.svg\" alt=\"Kotlin logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eA concise multiplatform language developed by JetBrains\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/kotlin/category/kotlin/\"\u003eKotlin\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eStructuring Ktor Projects Using Domain-Driven Design (DDD) Concepts: A Step-by-Step Guide With a Minimalistic CRM\u003c/h2\u003e                    \n                    \n\u003cp\u003eIn this guide, we’ll show you how to structure a project using domain-driven design (DDD) concepts, step by step, by building a minimalistic CRM system.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eSample code for the article: \u003c/strong\u003e\u003ca href=\"https://github.com/antonarhipov/ktor-ddd-example\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003ehttps://github.com/antonarhipov/ktor-ddd-example\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e \u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eKtor is a highly flexible framework that allows developers to structure their applications however they see fit. Unlike some opinionated frameworks (like Spring Boot), Ktor does not enforce a predefined project structure, which can be both an advantage and a challenge. Many developers, especially those new to Ktor, often wonder:\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cem\u003eHow should I structure my Ktor project for scalability, maintainability, and long-term growth?\u003c/em\u003e\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this guide, we’ll answer that question step by step by building a minimalistic CRM system. This CRM will start as a simple Ktor application and gradually evolve into a well-structured, scalable project following best practices inspired by domain-driven design (DDD) and feature-based modularization.\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow we’ll approach this\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe’ll start with a simple, unstructured Ktor project and progressively refine it to have a well-structured, scalable architecture. Each step will introduce new concepts and improvements:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eIntroduce domain models\u003c/strong\u003e to define entities like \u003ccode\u003eCustomer\u003c/code\u003e, \u003ccode\u003eNote\u003c/code\u003e, and \u003ccode\u003eReminder\u003c/code\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDefine repositories and services \u003c/strong\u003eto separate the business logic from the routes.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eAdd a presentation layer\u003c/strong\u003e with Ktor routes.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eDefining the domain model: Entities and value objects\u003c/h2\u003e\n\n\n\n\u003cp\u003eOur first step is to define the core domain model for our minimalistic CRM. In domain-driven design (DDD), we structure the domain layer around entities, value objects, and aggregates to model real-world concepts effectively.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDefining entities\u003c/h2\u003e\n\n\n\n\u003cp\u003eSince we’re building a minimalistic CRM system, we need to define the fundamental building blocks:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCustomer:\u003c/strong\u003e Represents a client with whom you interact.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eContact:\u003c/strong\u003e Represents a method to reach a customer. One customer can have multiple contacts.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eNote:\u003c/strong\u003e Represents business information or interactions (can be tied to a customer or an order).\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eReminder:\u003c/strong\u003e Represents an alert associated with a contact (and optionally linked to a note) to help you remember promises or follow-ups.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// domain/customer/Customer.kt\n\nimport java.time.LocalDateTime\nimport java.util.UUID\n\n// A simple Value Object for unique identifiers\n@JvmInline\nvalue class CustomerId(val value: Long)\n@JvmInline\nvalue class ContactId(val value: Long)\n@JvmInline\nvalue class NoteId(val value: Long)\n\n\ndata class Contact(\n   val id: ContactId? = null,\n   val name: String,\n   val email: Email, \n   val phone: String\n)\n\ndata class Note(\n   val id: NoteId? = null,\n   val content: String,\n   val createdAt: LocalDateTime = LocalDateTime.now()\n)\n\ndata class Customer(\n   val id: CustomerId? = null,\n   val name: String,\n   val contacts: List\u0026lt;Contact\u0026gt; = emptyList(),\n   val notes: List\u0026lt;Note\u0026gt; = emptyList()\n) {\n   fun withContact(contact: Contact): Customer {\n      return copy(contacts = contacts + contact)\n   }\n\n   fun withNote(note: Note): Customer {\n      return copy(notes = notes + note)\n   }\n}\u003c/pre\u003e\n\n\n\n\u003ch2\u003eDefining value objects\u003c/h2\u003e\n\n\n\n\u003cp\u003eValue objects are immutable and are defined solely by their attributes. They help encapsulate concepts such as identifiers or more complex attributes (e.g., an \u003ccode\u003eEmail\u003c/code\u003e object with validation). In our example, the unique identifiers (like \u003ccode\u003eCustomerId\u003c/code\u003e) are implemented as value objects, ensuring immutability and encapsulation of identity details.\u003c/p\u003e\n\n\n\n\u003cp\u003eYou can further extend this idea by encapsulating additional business rules. For example:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// Example: a more complex value object for \n// Email might include validation logic.\n@JvmInline\nvalue class Email(val address: String) {\n    init {\n        require(address.contains(\u0026#34;@\u0026#34;)) { \u0026#34;Invalid email address\u0026#34; }\n    }\n}\u003c/pre\u003e\n\n\n\n\u003ch2\u003eRelationships and aggregates\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn domain-driven design (DDD), an aggregate is a cluster of domain objects that should be treated as a single unit when enforcing business rules. Each aggregate has a clearly defined boundary and a single aggregate root, which serves as the only entry point for modifying the aggregate’s state.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn our initial model:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCustomer is the aggregate root, ensuring consistency and encapsulating its associated contacts and notes. All modifications to these related entities must go through the customer.\u003c/li\u003e\n\n\n\n\u003cli\u003eReminder is a separate entity linked to a customer (and optionally a note), but it has its own lifecycle and behaviors, making it an independent aggregate.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eUsing aggregates helps enforce business rules and invariants. For example, defining customer as the aggregate root ensures that contacts are always managed in the context of their customer, preventing orphaned or inconsistent data.\u003c/p\u003e\n\n\n\n\u003cp\u003eThis is what the project structure looks like so far with the two aggregations defined above:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"md\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ektor-crm/\n└─ src/\n   └─ main/\n      └─ kotlin/\n         ├─ Application.kt  // Ktor application entry point\n         └─ domain/\n            ├─ customer/\n            │  └─ Customer.kt  // Customer, Contact, Note \n            └─ reminder/\n               └── Reminder.kt  // Reminder\u003c/pre\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003cp\u003eIn this first step of our guide, we defined the core domain elements for our minimalistic CRM:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eEntities: \u003ccode\u003eCustomer\u003c/code\u003e, \u003ccode\u003eContact\u003c/code\u003e, \u003ccode\u003eNote\u003c/code\u003e, and \u003ccode\u003eReminder\u003c/code\u003e\u003c/li\u003e\n\n\n\n\u003cli\u003eValue objects: \u003ccode\u003eCustomerId\u003c/code\u003e, \u003ccode\u003eContactId\u003c/code\u003e, \u003ccode\u003eNoteId\u003c/code\u003e, and \u003ccode\u003eReminderId\u003c/code\u003e (and potentially others like \u003ccode\u003eEmail\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThese definitions set the stage for further expansion, such as implementing business logic within domain services, setting up repositories for persistence, and eventually wiring up these components in our Ktor application.\u003c/p\u003e\n\n\n\n\u003cp\u003eNext, we can look at how to encapsulate business behaviors, and later, how these domain elements interact with the application layer in a modularized Ktor structure.\u003c/p\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n\u003ch2\u003eEncapsulating business behaviors: Repositories, services, and domain events.\u003c/h2\u003e\n\n\n\n\u003cp\u003eIn a DDD-inspired design, repositories, domain services, and domain events work together to implement your CRM’s use cases while maintaining clear separation of concerns.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRepositories\u003c/h2\u003e\n\n\n\n\u003cp\u003eRepositories act as an abstraction layer between your domain model and the data persistence mechanism (like a database). They provide simple methods for retrieving, storing, and updating domain entities without exposing the underlying data access logic.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003einterface CustomerRepository {\n   fun findById(id: CustomerId): Customer?\n   fun save(customer: Customer)\n\n   // Additional methods like delete, update, list, etc.\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe repository encapsulates all the queries and transactions needed to work with the domain model. For instance, when adding a new contact, the repository can ensure that the updated customer aggregate is properly stored.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur \u003ca href=\"https://github.com/antonarhipov/ktor-ddd-example\" target=\"_blank\" rel=\"noopener\"\u003edemo project\u003c/a\u003e uses a mock in-memory implementation of the repository interface. The real implementation depends on the technology and infrastructure used by your organization. In Ktor projects, you often see the \u003ca href=\"https://www.jetbrains.com/exposed/\" target=\"_blank\" rel=\"noopener\"\u003eExposed\u003c/a\u003e database library used to implement this functionality. However, Ktor does not enforce any constraints on repository implementations, so you can choose to use any other data access libraries.\u003c/p\u003e\n\n\n\n\u003ch2\u003eDomain services\u003c/h2\u003e\n\n\n\n\u003cp\u003eDomain services encapsulate business logic that doesn’t naturally belong to an entity or value object. They coordinate complex operations that might involve multiple domain objects or aggregates.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eclass CustomerService(\n   private val customerRepository: CustomerRepository,\n   private val eventPublisher: EventPublisher\n) {\n\n   fun createCustomer(name: String): Customer {\n       val customer = Customer(name = name)\n       customerRepository.save(customer)\n       return customer\n   }\n\n   fun getCustomer(id: Long): Customer? {\n       return customerRepository.findById(CustomerId(id))\n   }\n\n   fun addContact(customerId: CustomerId, contact: Contact): Customer? {\n       val customer = customerRepository.findById(customerId)\n           ?: return null\n\n       // Business logic to add a contact (could be a method on Customer entity)\n       val updatedCustomer = customer.withContact(contact)\n       customerRepository.save(updatedCustomer)\n\n       // Publish a domain event to signal that a new contact has been added\n       eventPublisher.publish(ContactAddedEvent(customerId, contact))\n\n       return updatedCustomer\n   }\n\n\n   fun addNote(customerId: CustomerId, note: Note): Customer? {\n       val customer = customerRepository.findById(customerId)\n           ?: return null\n\n       val updatedCustomer = customer.withNote(note)\n       customerRepository.save(updatedCustomer)\n\n       // Publish a domain event to signal about a new note\n       eventPublisher.publish(NoteAddedEvent(customerId, note))\n\n       return updatedCustomer\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eThe service:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eFetches the current state of the customer.\u003c/li\u003e\n\n\n\n\u003cli\u003eApplies business rules (e.g., adding a contact or note).\u003c/li\u003e\n\n\n\n\u003cli\u003ePersists the updated state via the repository.\u003c/li\u003e\n\n\n\n\u003cli\u003ePublishes a domain event to notify other parts of the system of the change.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2\u003eDomain events\u003c/h2\u003e\n\n\n\n\u003cp\u003eDomain events are messages that indicate something significant has occurred within the domain. They help decouple the direct consequences of a business operation from the triggering action. Other components can listen to these events and perform additional tasks (e.g., sending notifications, updating search indexes) without cluttering the core business logic.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// DomainEvents.kt\nsealed interface DomainEvent\n\ndata class ContactAddedEvent(\n   val customerId: CustomerId,\n   val contact: Contact\n): DomainEvent\n\ndata class NoteAddedEvent(\n   val customerId: CustomerId,\n   val note: Note\n): DomainEvent\u003c/pre\u003e\n\n\n\n\u003ch2\u003eEvent publishing\u003c/h2\u003e\n\n\n\n\u003cp\u003eAn \u003ccode\u003eEventPublisher\u003c/code\u003e interface can be used to publish these events. In a real-world application, this can be integrated with an event bus or messaging system:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003einterface EventPublisher {\n   fun publish(event: DomainEvent)\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eBenefits:\u003c/strong\u003e\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDecoupling:\u003c/strong\u003e Other parts of your application can subscribe to these events without the service needing to know about them.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eExtensibility:\u003c/strong\u003e As your application evolves, additional behavior can be attached to these events without modifying the core business logic.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3\u003e\u003cstrong\u003eBringing it all together\u003c/strong\u003e\u003c/h3\u003e\n\n\n\n\u003cp\u003eIn our minimalistic CRM, when a user action triggers a use case (e.g., adding a new contact or note), the flow might look like this:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eUser action:\u003c/strong\u003e\u003cstrong\u003e\u003cbr/\u003e\u003c/strong\u003eThe client makes an API call to add a contact to a customer.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eService coordination:\u003cbr/\u003e\u003c/strong\u003eThe \u003ccode\u003eCustomerService\u003c/code\u003e retrieves the customer using the \u003ccode\u003eCustomerRepository\u003c/code\u003e, applies the business logic to add the contact, and saves the updated customer.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eEvent publication:\u003cbr/\u003e\u003c/strong\u003eAfter saving, the service publishes a \u003ccode\u003eContactAddedEvent\u003c/code\u003e through the \u003ccode\u003eEventPublisher\u003c/code\u003e. Other parts of the system (like notification modules or logging services) can listen to this event and react accordingly.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eThis approach ensures that your domain logic remains clean, well-organized, and focused on business rules while delegating infrastructure and cross-cutting concerns to dedicated components.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow the project structure looks as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"md\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ektor-crm/\n└─ src/\n   └─ main/\n      └─ kotlin/\n         └─ com/\n            └─ example/\n               ├─ Application.kt\n               ├─ domain/\n               │  ├─ customer/\n               │  │  ├─ Customer.kt\n               │  │  ├─ CustomerRepository.kt\n               │  │  └─ CustomerService.kt\n               │  └─ reminder /\n               │     ├─ Reminder.kt\n               │     ├─ ReminderRepository.kt\n               │     └─ ReminderService.kt\n               └─ events/ \n                  ├─ DomainEvents.kt\n                  └─ EventPublisher.kt\u003c/pre\u003e\n\n\n\n\u003ch2\u003eBuilding the presentation layer with Ktor\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe code samples above didn’t use any external libraries or Ktor APIs because these are just implementation details. The conceptual framework of domain-driven design allowed us to structure the code so that we can plug in the necessary dependencies to create the application.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow we can move on and wire the services into the web server, exposing the REST API as a presentation layer. For this purpose, we will add the corresponding \u003ca href=\"https://ktor.io/docs/server-routing.html\" target=\"_blank\" rel=\"noopener\"\u003eroute definitions\u003c/a\u003e into the domain subpackages.\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// domain/customer/CustomerRoutes.kt\nfun Application.customerRoutes() {\n   routing {\n       val repository = InMemoryCustomerRepository() \n       val eventPublisher = EventPublisherImpl()\n\n       //TODO: use the service in the routes below\n       val service = CustomerService(repository, eventPublisher)\n\n       route(\u0026#34;/customers\u0026#34;) {\n           // Create customer\n           post {\n               val customer = call.receive\u0026lt;Customer\u0026gt;()\n               val createdCustomer = service.createCustomer(customer.name)\n               call.respond(HttpStatusCode.Created, createdCustomer)\n           }\n\n           // Get customer by ID\n           get(\u0026#34;/{id}\u0026#34;) {\n               val id = call.parameters[\u0026#34;id\u0026#34;]?.toLongOrNull() ?: return@get call.respondText(\n                   \u0026#34;Missing or malformed id\u0026#34;,\n                   status = HttpStatusCode.BadRequest\n               )\n\n               val customer = service.getCustomer(id)\n               if (customer != null) {\n                   call.respond(customer)\n               } else {\n                   call.respondText(\u0026#34;Customer not found\u0026#34;, status = HttpStatusCode.NotFound)\n               }\n           }\n\n           // Add contact to customer\n           post(\u0026#34;/{id}/contacts\u0026#34;) {\n               val id = call.parameters[\u0026#34;id\u0026#34;]?.toLongOrNull() ?: return@post call.respondText(\n                   \u0026#34;Missing or malformed id\u0026#34;,\n                   status = HttpStatusCode.BadRequest\n               )\n\n               val contact = call.receive\u0026lt;Contact\u0026gt;()\n               val updatedCustomer = service.addContact(CustomerId(id), contact)\n\n               if (updatedCustomer != null) {\n                   call.respond(updatedCustomer)\n               } else {\n                   call.respondText(\u0026#34;Customer not found\u0026#34;, status = HttpStatusCode.NotFound)\n               }\n           }\n\n           // Add note to customer\n           post(\u0026#34;/{id}/notes\u0026#34;) {\n               val id = call.parameters[\u0026#34;id\u0026#34;]?.toLongOrNull() ?: return@post call.respondText(\n                   \u0026#34;Missing or malformed id\u0026#34;,\n                   status = HttpStatusCode.BadRequest\n               )\n\n               val note = call.receive\u0026lt;Note\u0026gt;()\n               val updatedCustomer = service.addNote(CustomerId(id), note)\n\n               if (updatedCustomer != null) {\n                   call.respond(updatedCustomer)\n               } else {\n                   call.respondText(\u0026#34;Customer not found\u0026#34;, status = HttpStatusCode.NotFound)\n               }\n           }\n       }\n   }\n}\n\n\n\n// domain/reminder/ReminderRoutes.kt\nfun Application.reminderRoutes() {\n   routing {\n       val repository = InMemoryReminderRepository()\n       val service = ReminderService(repository)\n\n       route(\u0026#34;/reminders\u0026#34;) {\n           // Create a reminder\n           post {\n               val reminder = call.receive\u0026lt;Reminder\u0026gt;()\n               val createdReminder = service.createReminder(\n                   customerId = reminder.customerId,\n                   noteId = reminder.noteId?.value,\n                   remindAt = reminder.remindAt,\n                   message = reminder.message\n               )\n               call.respond(HttpStatusCode.Created, createdReminder)\n           }\n\n           // Get reminder by ID\n           get(\u0026#34;/{id}\u0026#34;) {\n               val id = call.parameters[\u0026#34;id\u0026#34;] ?: return@get call.respondText(\n                   \u0026#34;Missing or malformed id\u0026#34;,\n                   status = HttpStatusCode.BadRequest\n               )\n\n               val reminder = service.getReminder(id)\n               if (reminder != null) {\n                   call.respond(reminder)\n               } else {\n                   call.respondText(\u0026#34;Reminder not found\u0026#34;, \nstatus = HttpStatusCode.NotFound)\n               }\n           }\n\n           // Get reminders for a customer\n           get(\u0026#34;/customer/{customerId}\u0026#34;) {\n               val customerId = call.parameters[\u0026#34;customerId\u0026#34;] \n?: return@get call.respondText(\n                 \t  \u0026#34;Missing or malformed customerId\u0026#34;,\n               \t    status = HttpStatusCode.BadRequest\n             \t\t  )\n\n               val reminders = service.getRemindersForCustomer(CustomerId(customerId))\n               call.respond(reminders)\n           }\n       }\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eYou might have noticed that the repository and event publisher implementations are created manually. However, as the project grows, it might be more convenient to implement this using the dependency injection (DI) pattern instead.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe subroutes for the corresponding domain objects and aggregates are defined as extension functions in their respective files. This is a common pattern when working with Ktor projects. These functions are called from within the Application.kt module function on the application startup:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e// Application.kt\nfun main() {\n   embeddedServer(Netty, port = 8080, module = Application::module)\n       .start(wait = true)\n}\n\nfun Application.module() {\n   install(ContentNegotiation) {\n       json()\n   }\n\n   routing {\n       // Register routes from the domain subpackages\n       customerRoutes() \n       reminderRoutes()\n   }\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eWith the routing files, our project structure looks as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"md\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003ektor-crm/\n└─ src/\n   └─ main/\n      └─ kotlin/\n         └─ com/\n            └─ example/\n               ├─ Application.kt\n               ├─ domain/\n               │  ├─ customer/\n               │  │  ├─ Customer.kt\n               │  │  ├─ CustomerRepository.kt\n               │  │  ├─ CustomerRoutes.kt\n               │  │  └─ CustomerService.kt\n               │  └─ reminder /\n               │     ├─ Reminder.kt\n               │     ├─ ReminderRepository.kt\n               │     ├─ ReminderRoutes.kt\n               │     └─ ReminderService.kt\n               └─ events/ \n                  ├─ DomainEvents.kt\n                  └─ EventPublisher.kt \u003c/pre\u003e\n\n\n\n\u003cp\u003eAt this point, we have integrated the business logic into the Ktor application, and the next step ise adding the infrastructural aspects, such as database configuration, authentication, etc. \u003c/p\u003e\n\n\n\n\u003ch2\u003eSummary\u003c/h2\u003e\n\n\n\n\u003cp\u003eThis article introduced key domain-driven design (DDD) concepts – like entities, value objects, repositories, and domain services – and demonstrated how to apply them in a Ktor project. We built a simple CRM system, organizing the code into well-defined domain subpackages (customers, reminders) with dedicated value classes and modular routes. This approach creates a clear, scalable, and maintainable codebase for your Ktor applications.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe source code for the sample presented in this article is available at: \u003ca href=\"https://github.com/antonarhipov/ktor-ddd-example\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/antonarhipov/ktor-ddd-example\u003c/a\u003e \u003c/p\u003e\n                    \n                                                                                                                                                                                                                            \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Kotlin Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "21 min read",
  "publishedTime": null,
  "modifiedTime": null
}
