{
  "id": "80537dc8-9a05-4a04-9812-09f495bca0b4",
  "title": "3 Fundamental Concepts to Fully Understand how the Fetch API Works",
  "link": "https://betterprogramming.pub/3-fundamental-concepts-to-fully-understand-how-the-fetch-api-works-3ee5d41f81a4?source=rss----d0b105d10f0a---4",
  "description": "Understanding the Fetch API can be challenging, particularly for those new to JavaScript’s unique approach to handling asynchronous…Continue reading on Better Programming »",
  "author": "Jay Cruz",
  "published": "Fri, 10 Nov 2023 17:30:24 GMT",
  "source": "https://medium.com/feed/better-programming",
  "categories": [
    "fetch-api",
    "software-development",
    "javascript",
    "web-development",
    "programming"
  ],
  "byline": "Jay Cruz",
  "length": 1120,
  "excerpt": "Understanding the Fetch API can be challenging, particularly for those new to JavaScript’s unique approach to handling asynchronous operations. Among the many features of modern JavaScript, the Fetch…",
  "siteName": "Better Programming",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "Generated with DALL-E 3Understanding the Fetch API can be challenging, particularly for those new to JavaScript’s unique approach to handling asynchronous operations. Among the many features of modern JavaScript, the Fetch API stands out for its ability to handle network requests elegantly. However, the syntax of chaining .then() methods can seem unusual at first glance. To fully grasp how the Fetch API works, it's vital to understand three core concepts:Synchronous vs asynchronous codeCallback functionsPromisesSynchronous vs Asynchronous CodeIn programming, synchronous code is executed in sequence. Each statement waits for the previous one to finish before executing. JavaScript, being single-threaded, runs code in a linear fashion. However, certain operations, like network requests, file system tasks, or timers, could block this thread, making the user experience unresponsive.Here’s a simple example of synchronous code:function doTaskOne() { console.log('Task 1 completed');}function doTaskTwo() { console.log('Task 2 completed');}doTaskOne();doTaskTwo();// Output:// Task 1 completed// Task 2 completed",
  "image": "https://miro.medium.com/v2/resize:fit:1024/1*FtWwyPg7HHUBk-TPPG4__w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv\u003e\u003ca href=\"https://medium.com/@jaycruz?source=post_page-----3ee5d41f81a4--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Jay Cruz\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*n2iymHhgli0PN84cjiI52w.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://betterprogramming.pub/?source=post_page-----3ee5d41f81a4--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Better Programming\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*QNoA3XlXLHz22zQazc0syg.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eGenerated with DALL-E 3\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"66f1\"\u003eUnderstanding the Fetch API can be challenging, particularly for those new to JavaScript’s unique approach to handling asynchronous operations. Among the many features of modern JavaScript, the Fetch API stands out for its ability to handle network requests elegantly. However, the syntax of chaining \u003ccode\u003e.then()\u003c/code\u003e methods can seem unusual at first glance. To fully grasp how the Fetch API works, it\u0026#39;s vital to understand three core concepts:\u003c/p\u003e\u003cul\u003e\u003cli id=\"8eee\"\u003e\u003ca href=\"https://medium.com/@jaycruz/synchronous-vs-asynchronous-code-in-javascript-8eefc678c1a5\" rel=\"noopener\"\u003e\u003cstrong\u003eSynchronous vs asynchronous code\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"39d7\"\u003e\u003ca href=\"https://medium.com/@jaycruz/the-callback-1be67ce1b71f\" rel=\"noopener\"\u003e\u003cstrong\u003eCallback functions\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\u003cli id=\"5f2e\"\u003e\u003cstrong\u003ePromises\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"12f9\"\u003eSynchronous vs Asynchronous Code\u003c/h2\u003e\u003cp id=\"40e7\"\u003eIn programming, synchronous code is executed in sequence. Each statement waits for the previous one to finish before executing. JavaScript, being single-threaded, runs code in a linear fashion. However, certain operations, like network requests, file system tasks, or timers, could block this thread, making the user experience unresponsive.\u003c/p\u003e\u003cp id=\"1cc6\"\u003eHere’s a simple example of synchronous code:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"c9fa\"\u003efunction doTaskOne() {\u003cbr/\u003e  console.log(\u0026#39;Task 1 completed\u0026#39;);\u003cbr/\u003e}\u003cp\u003efunction doTaskTwo() {\u003cbr/\u003e  console.log(\u0026#39;Task 2 completed\u0026#39;);\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003edoTaskOne();\u003cbr/\u003edoTaskTwo();\u003cbr/\u003e// Output:\u003cbr/\u003e// Task 1 completed\u003cbr/\u003e// Task 2 completed\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "2 min read",
  "publishedTime": "2023-11-07T16:55:40.598Z",
  "modifiedTime": null
}
