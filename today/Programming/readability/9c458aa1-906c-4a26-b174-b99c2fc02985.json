{
  "id": "9c458aa1-906c-4a26-b174-b99c2fc02985",
  "title": "Creating a custom video SeekBar on Android",
  "link": "https://buffer.com/resources/creating-a-custom-video-seekbar-on-android/",
  "description": "Don’t reinvent the wheel when you don’t need to! Re-use what you can. This post is an overview on creating a custom video SeekBar on Android.",
  "author": "Joe Birch",
  "published": "Fri, 08 Feb 2019 16:21:47 GMT",
  "source": "https://buffer.com/resources/overflow/rss/",
  "categories": [
    "Overflow"
  ],
  "byline": "Joe Birch",
  "length": 9508,
  "excerpt": "Don’t reinvent the wheel when you don’t need to! Re-use what you can. This post is an overview on creating a custom video SeekBar on Android.",
  "siteName": "Buffer: All-you-need social media toolkit for small businesses",
  "favicon": "https://buffer.com/static/icons/apple-touch-icon.png",
  "text": "Header Photo by Jakob Owens on UnsplashA new feature we’ve been building out required the use of a thumbnail picker for video files. After looking around for open-source implementations, it was clear that there wasn’t something that already existed which would fit in with our app – for this reason we needed to build our own video thumbnail picker component. This component, Thumby, can be found over on GitHub.In this article I want to dive into the iteration of this process, from reusing existing framework classes to building our own open-source solution.The requirementsWhen it comes to the selection of a thumbnail for a video, there were a couple of different requirements that we needed to bear in mind for the implementation:Open Thumbnail selection screen, passing Uri for chosen videoLoad a collection of thumbnails to the SeekBar as a backgroundLoad the current thumbnail into the SeekBar thumb backgroundUpdate the SeekBar thumb background as the user scrubs through the videoWhen chosen, finish the activity and pass the thumbnail location for retrievalThe SeekBar style component that we required in itself doesn’t come across as too complex, overall it would end up consisting of two core parts which were the video timeline (a background essentially made up of thumbnails) and a thumb which would be used by the user to scrub through the selected video:Customising the Android SeekBarI wanted to begin by attempting to customise the SeekBar widget from the Android framework – if we could use and tweak an existing implementation, then why recreate the wheel? We didn’t end up going with this approach as it didn’t turn out as great as I had hoped, but it was worth trying for an initial implementation.If you’re not familiar with the SeekBar component, it’s a component used to seek through media files – you’ll likely see one within the media player in your device. Within the framework, this component extends from the ProgressBar – the main different being the thumb which is used to perform the seek operation via a touch or key press event. In most cases the SeekBar does what you need it to do – you can sync it with some media source on the screen and then use the listeners of the SeekBar to receive seek position updates and have that reflected within the media source that you’re displaying. Although we’re not going to be displaying seekable media on the screen, we do need the functionality of being able to seek through the length of a media source, which the SeekBar is perfect for.Whilst we can check that functionality off of our list, we don’t actually need to show the SeekBar on the screen. Because it extends from the ProgressBar component we are displayed a determinate progress bar – this bar fills its progress as we seek. Whilst this is great for situations where you are actually seeking through media and require that form of progress indicator, we are not actually playing the media source here so do not require the ProgressBar to be displayed.progressDrawable = ColorDrawable(ContextCompat.getColor(context, android.R.color.transparent)) background = ColorDrawable(ContextCompat.getColor(context, android.R.color.transparent))Now that we have the progress state hidden, we need to make the thumb of the scrollbar display the current thumbnail. The thumb property of the SeekBar allows us to set a drawable instance to be shown within its content area, this is perfect because we intended on showing a square image for the current frame as the thumb. For this, we create a new instance of a BitmapDrawable and set it as the thumb of our SeekBar – at this point we almost have all that we need.thumb = BitmapDrawable(resources, addWhiteBorderToBitmap(bitmap, 4))The only issue with this is an offset which is automatically applied to the thumb. This offset exists so that the drawable is always placed centrally on the thumb, so not to interfere with any scrub positioning. By default this is set to the width of the thumb / 2 – whilst in most cases this is fine, if you are showing a video timeline underneath the SeekBar then this may cause some issues. If this is the case then you may need to assign some padding to each side of the SeekBar to ensure that your thumb aligns correctly with the background that it’s showing on-top of.With all of the above in place, this implementation mostly worked. We had our video timeline that showed a sliding thumb for the selected thumbnail at the current seek position. Whilst this worked, there were some issues with performance – and this solution isn’t very scalable. For example:With this approach you need the thumbnails pre-loaded so that they can be accessed by the thumbnail view within the SeekBar. Whilst you can fetch video thumbnails from the media store, hitting this every single time the SeekBar progress changes isn’t very efficient and will cause some lag in your layout.With the above in mind you also become a bit restricted when it comes to larger videos. For example, if the user loads in a video that is 8 minutes long you’re going to still want to show a regularly updated thumbnail on the SeekBar – otherwise it will appear as though the thumbnail isn’t changing. Without hitting the MediaStore for thumbnails every second within the progress, you’d have to keep a reference to all these thumbnails. And if you didn’t want to load them all upfront like that, then loading them on the fly in chunks would be a bit fiddly – what if the user skipped straight to 75% of the progress, and then back to 50%? There are a few situations that make that idea a bit complicated.Due to these restrictions, we decided that customising the SeekBar component wasn’t going to work for what we wanted. Whilst this didn’t work out, this didn’t take long at all to try out and extending from existing components is always favourable, as if done properly you avoid re-inventing the wheel and at the end the implementations will likely be easier to maintain for you and other developers.Creating a custom implementationBecause of the things mentioned above, we needed to put a custom seekbar solution in place for the our thumbnail selection. Now, the video timeline display worked fine from the previous implementation so we kept that – the only thing that needed to be changed was the seekbar with the dynamic preview.At the top of the thumbnail selection screen, we show a large thumbnail preview. The view that shows this is a TextureView in the form of a CenterCropVideoView – we have a custom view here so that we can have a center cropped video displayed on screen. Because we already have this implementation, it’s a perfect opportunity to reuse it as our custom seekbar thumb! It can get a bit complicated to paint a TextureView on a canvas, so to keep it simple the view is added to our layout and as touch events occur, the view is moved to match the current touch position. Once we have that touch position, we do a little bit of math to calculate where the view should be relative to spacing and whether the touch state falls within the background bounds. We then translate the x position of the view to the calculated value and then set update the current position of the video that is being displayed inside of that thumb view.The only other thing that we needed to imitate was the current progress of the SeekBar, this is so that we could use the progress of the custom seekbar to update the preview at the top of the screen. Again, this was just a little bit of math to imitate that functionality of the SeekBar (used from the extended ProgressBar).I don’t want to go into the implementation here as the code is open-sourced, but that is essentially all of the logic that is taking place here to complete the custom SeekBar solution. As you can see, we got pretty lucky here with being able to re-use our CenterCropVideoView within our custom seekbar. The code used to handle the thumb position was nothing trivial, meaning that for a small amount of work we were able to alleviate the downsides that came from the first solution outlined in this article. We no longer required to retrieve and keep a reference to the desired thumbnails, as the video within the CenterCropVideoView was handling the display of the current location for us.ConclusionThis brief write-up aimed to highlight two things:Don’t reinvent the wheel when you don’t need to! The Android framework has a lot to offer and in a lot of a cases, the first solution here would likely suffice. When it comes to implementation that require support for a lot more functionality, things can get complicated.Re-use what you can – if things don’t quite work out at first, it’s likely you don’t need to scrap what you have. Whilst we couldn’t directly use the SeekBar for our implementation, we were able to reuse the background of the video timeline as well as the CenterCropVideoView that we had in place. Meaning the re-implementation of the feature was more of just a tweak to change the views position on screen manually. This allowed us to keep things simple and move quick on getting the feature in place.Whilst we haven’t got too technical here, I hope sharing this process helps to provide some future thinking points for when you come to customising components within your app – keep it simple ? If you have any questions on the above or thoughts that you want to share then please do respond below!Try Buffer for free140,000+ small businesses like yours use Buffer to build their brand on social media every monthGet started now",
  "image": "https://buffer.com/resources/content/images/wp-content/uploads/2019/02/jakob-owens-199505-unsplash.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eHeader Photo by Jakob Owens on Unsplash\u003c/p\u003e\u003chr/\u003e\u003cp\u003eA new feature we’ve been building out required the use of a thumbnail picker for video files. After looking around for open-source implementations, it was clear that there wasn’t something that already existed which would fit in with our app – for this reason we needed to build our own video thumbnail picker component. This component, Thumby, \u003ca href=\"https://github.com/bufferapp/Thumby\"\u003ecan be found over on GitHub\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn this article I want to dive into the iteration of this process, from reusing existing framework classes to building our own open-source solution.\u003c/p\u003e\u003chr/\u003e\u003ch2 id=\"the-requirements\"\u003eThe requirements\u003c/h2\u003e\u003cp\u003eWhen it comes to the selection of a thumbnail for a video, there were a couple of different requirements that we needed to bear in mind for the implementation:\u003c/p\u003e\u003cul\u003e\u003cli\u003eOpen Thumbnail selection screen, passing Uri for chosen video\u003c/li\u003e\u003cli\u003eLoad a collection of thumbnails to the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e as a background\u003c/li\u003e\u003cli\u003eLoad the current thumbnail into the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e thumb background\u003c/li\u003e\u003cli\u003eUpdate the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e thumb background as the user scrubs through the video\u003c/li\u003e\u003cli\u003eWhen chosen, finish the activity and pass the thumbnail location for retrieval\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cimg src=\"https://buffer.com/resources/content/images/wp-content/uploads/2019/02/flow.png\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"664\" srcset=\"https://buffer.com/resources/content/images/size/w600/wp-content/uploads/2019/02/flow.png 600w, https://buffer.com/resources/content/images/size/w1000/wp-content/uploads/2019/02/flow.png 1000w, https://buffer.com/resources/content/images/size/w1600/wp-content/uploads/2019/02/flow.png 1600w, https://buffer.com/resources/content/images/wp-content/uploads/2019/02/flow.png 2048w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/figure\u003e\u003cp\u003eThe \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e style component that we required in itself doesn’t come across as too complex, overall it would end up consisting of two core parts which were the video timeline (a background essentially made up of thumbnails) and a thumb which would be used by the user to scrub through the selected video:\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://buffer.com/resources/content/images/wp-content/uploads/2019/02/det.png\" alt=\"\" loading=\"lazy\" width=\"2000\" height=\"911\" srcset=\"https://buffer.com/resources/content/images/size/w600/wp-content/uploads/2019/02/det.png 600w, https://buffer.com/resources/content/images/size/w1000/wp-content/uploads/2019/02/det.png 1000w, https://buffer.com/resources/content/images/size/w1600/wp-content/uploads/2019/02/det.png 1600w, https://buffer.com/resources/content/images/wp-content/uploads/2019/02/det.png 2094w\" sizes=\"(min-width: 720px) 720px\"/\u003e\u003c/figure\u003e\u003ch2 id=\"customising-the-android-seekbar\"\u003eCustomising the Android SeekBar\u003c/h2\u003e\u003cp\u003eI wanted to begin by attempting to customise the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e widget from the Android framework – if we could use and tweak an existing implementation, then why recreate the wheel? We didn’t end up going with this approach as it didn’t turn out as great as I had hoped, but it was worth trying for an initial implementation.\u003c/p\u003e\u003cp\u003eIf you’re not familiar with the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e component, it’s a component used to seek through media files – you’ll likely see one within the media player in your device. Within the framework, this component extends from the \u003ca href=\"https://developer.android.com/reference/android/widget/ProgressBar\"\u003eProgressBar\u003c/a\u003e – the main different being the thumb which is used to perform the seek operation via a touch or key press event. In most cases the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e does what you need it to do – you can sync it with some media source on the screen and then use the listeners of the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e to receive seek position updates and have that reflected within the media source that you’re displaying. Although we’re not going to be \u003cstrong\u003edisplaying\u003c/strong\u003e seekable media on the screen, we do need the functionality of being able to seek through the length of a media source, which the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e is perfect for.\u003c/p\u003e\u003cp\u003eWhilst we can check that functionality off of our list, we don’t actually need to show the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e on the screen. Because it extends from the \u003ca href=\"https://developer.android.com/reference/android/widget/ProgressBar\"\u003eProgressBar\u003c/a\u003e component we are displayed a determinate progress bar – this bar fills its progress as we seek. Whilst this is great for situations where you are actually seeking through media and require that form of progress indicator, we are not actually playing the media source here so do not require the \u003ca href=\"https://developer.android.com/reference/android/widget/ProgressBar\"\u003eProgressBar\u003c/a\u003e to be displayed.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprogressDrawable = ColorDrawable(ContextCompat.getColor(context, android.R.color.transparent))\nbackground = ColorDrawable(ContextCompat.getColor(context, android.R.color.transparent))\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow that we have the progress state hidden, we need to make the thumb of the scrollbar display the current thumbnail. The thumb property of the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e allows us to set a drawable instance to be shown within its content area, this is perfect because we intended on showing a square image for the current frame as the thumb. For this, we create a new instance of a BitmapDrawable and set it as the thumb of our \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e – at this point we almost have all that we need.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ethumb = BitmapDrawable(resources, addWhiteBorderToBitmap(bitmap, 4))\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe only issue with this is an offset which is automatically applied to the thumb. This offset exists so that the drawable is always placed centrally on the thumb, so not to interfere with any scrub positioning. By default this is set to the \u003cstrong\u003ewidth of the thumb / 2 \u003c/strong\u003e– whilst in most cases this is fine, if you are showing a video timeline underneath the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e then this may cause some issues. If this is the case then you may need to assign some padding to each side of the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e to ensure that your thumb aligns correctly with the background that it’s showing on-top of.\u003c/p\u003e\u003cp\u003eWith all of the above in place, this implementation \u003cstrong\u003emostly\u003c/strong\u003e worked. We had our video timeline that showed a sliding thumb for the selected thumbnail at the current seek position. Whilst this worked, there were some issues with performance – and this solution isn’t very scalable. For example:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWith this approach you need the thumbnails pre-loaded so that they can be accessed by the thumbnail view within the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e. Whilst you can fetch video thumbnails from the media store, hitting this every single time the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e progress changes isn’t very efficient and will cause some lag in your layout.\u003c/li\u003e\u003cli\u003eWith the above in mind you also become a bit restricted when it comes to larger videos. For example, if the user loads in a video that is 8 minutes long you’re going to still want to show a regularly updated thumbnail on the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e – otherwise it will appear as though the thumbnail isn’t changing. Without hitting the MediaStore for thumbnails every second within the progress, you’d have to keep a reference to all these thumbnails. And if you didn’t want to load them all upfront like that, then loading them on the fly in chunks would be a bit fiddly – what if the user skipped straight to 75% of the progress, and then back to 50%? There are a few situations that make that idea a bit complicated.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eDue to these restrictions, we decided that customising the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e component wasn’t going to work for what we wanted. Whilst this didn’t work out, this didn’t take long at all to try out and extending from existing components is always favourable, as if done properly you avoid re-inventing the wheel and at the end the implementations will likely be easier to maintain for you and other developers.\u003c/p\u003e\u003ch2 id=\"creating-a-custom-implementation\"\u003eCreating a custom implementation\u003c/h2\u003e\u003cp\u003eBecause of the things mentioned above, we needed to put a custom seekbar solution in place for the our thumbnail selection. Now, the video timeline display worked fine from the previous implementation so we kept that – the only thing that needed to be changed was the seekbar with the dynamic preview.\u003c/p\u003e\u003cp\u003eAt the top of the thumbnail selection screen, we show a large thumbnail preview. The view that shows this is a \u003ca href=\"https://developer.android.com/reference/android/view/TextureView\"\u003eTextureView\u003c/a\u003e in the form of a \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/CenterCropVideoView.kt\"\u003eCenterCropVideoView\u003c/a\u003e – we have a custom view here so that we can have a center cropped video displayed on screen. Because we already have this implementation, it’s a perfect opportunity to reuse it as our custom seekbar thumb! It can get a bit complicated to paint a \u003ca href=\"https://developer.android.com/reference/android/view/TextureView\"\u003eTextureView\u003c/a\u003e on a canvas, so to keep it simple the view is added to our layout and \u003ca href=\"https://developer.android.com/reference/android/view/TextureView\"\u003eas touch events occur\u003c/a\u003e, the view is moved to match the current touch position. Once we have that touch position, \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/ThumbnailTimeline.kt#L63\"\u003ewe do a little bit of math\u003c/a\u003e to calculate where the view should be relative to spacing and whether the touch state falls within the background bounds. We then \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/ThumbnailTimeline.kt#L76\"\u003etranslate the x position of the view\u003c/a\u003e to the calculated value and then set update the current position of the video that is being displayed inside of that thumb view.\u003c/p\u003e\u003cp\u003eThe only other thing that we needed to imitate was the current progress of the \u003ca href=\"https://developer.android.com/reference/android/widget/SeekBar\"\u003eSeekBar\u003c/a\u003e, this is so that we could use the progress of the custom seekbar to update the preview at the top of the screen. Again, this was just \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/ThumbnailTimeline.kt#L75\"\u003ea little bit of math\u003c/a\u003e to imitate that functionality of the SeekBar (used from the extended ProgressBar).\u003c/p\u003e\u003cp\u003eI don’t want to go into the implementation here as the code is open-sourced, but that is essentially all of the logic that is taking place here to complete the custom SeekBar solution. As you can see, we got pretty lucky here with being able to re-use our \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/CenterCropVideoView.kt\"\u003eCenterCropVideoView\u003c/a\u003e within our custom seekbar. The code used to handle the thumb position was nothing trivial, meaning that for a small amount of work we were able to alleviate the downsides that came from the first solution outlined in this article. We no longer required to retrieve and keep a reference to the desired thumbnails, as the video within the \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/CenterCropVideoView.kt\"\u003eCenterCropVideoView\u003c/a\u003e was handling the display of the current location for us.\u003c/p\u003e\u003chr/\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eThis brief write-up aimed to highlight two things:\u003c/p\u003e\u003cul\u003e\u003cli\u003eDon’t reinvent the wheel when you don’t need to! The Android framework has a lot to offer and in a lot of a cases, the first solution here would likely suffice. When it comes to implementation that require support for a lot more functionality, things can get complicated.\u003c/li\u003e\u003cli\u003eRe-use what you can – if things don’t quite work out at first, it’s likely you don’t need to scrap what you have. Whilst we couldn’t directly use the SeekBar for our implementation, we were able to reuse the background of the video timeline as well as the \u003ca href=\"https://github.com/bufferapp/Thumby/blob/master/app/src/main/java/org/buffer/android/thumby/CenterCropVideoView.kt\"\u003eCenterCropVideoView\u003c/a\u003e that we had in place. Meaning the re-implementation of the feature was more of just a tweak to change the views position on screen manually. This allowed us to keep things simple and move quick on getting the feature in place.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWhilst we haven’t got too technical here, I hope sharing this process helps to provide some future thinking points for when you come to customising components within your app – keep it simple ? If you have any questions on the above or thoughts that you want to share then please do respond below!\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"midpost-cta\"\u003e\u003ch3\u003eTry Buffer for free\u003c/h3\u003e\u003cp\u003e140,000+ small businesses like yours use Buffer to build their brand on social media every month\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://login.buffer.com/signup?product=buffer\u0026amp;plan=free\u0026amp;cycle=year\u0026amp;cta=bufferBlogLibrary-post-midCTA-signup-1\" role=\"button\"\u003eGet started now\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": null,
  "modifiedTime": null
}
