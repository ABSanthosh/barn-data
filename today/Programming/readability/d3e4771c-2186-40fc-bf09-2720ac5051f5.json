{
  "id": "d3e4771c-2186-40fc-bf09-2720ac5051f5",
  "title": "Rust vs Go: Which one to choose in 2025",
  "link": "https://blog.jetbrains.com/rust/2025/06/12/rust-vs-go/",
  "description": "The programming landscape continues to evolve, bringing forward languages like Rust and Go that not only challenge traditional paradigms but also cater to the sophisticated needs of modern computing. Both have carved significant niches for themselves, celebrated for their efficient handling of system-level operations and concurrency. Recent findings from the State of Developer Ecosystem Report […]",
  "author": "Ilia Afanasiev",
  "published": "Thu, 12 Jun 2025 13:16:42 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "articles-2",
    "news"
  ],
  "byline": "Ilia Afanasiev",
  "length": 25343,
  "excerpt": "Discover the key differences between Rust and Go in 2025. Compare performance, concurrency, ease of use, and more to choose the best programming language for your project.",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "Focus on what matters Articles NewsRust vs Go: Which one to choose in 2025 The programming landscape continues to evolve, bringing forward languages like Rust and Go that not only challenge traditional paradigms but also cater to the sophisticated needs of modern computing. Both have carved significant niches for themselves, celebrated for their efficient handling of system-level operations and concurrency. Recent findings from the State of Developer Ecosystem Report 2024 highlight the dynamic growth and adoption rates of these languages. Rust celebrated a remarkable milestone by setting a usage record among the year’s most popular languages and boasted a user base of approximately 2.27 million developers, with 709,000 using it as their primary language. Meanwhile, Go’s user base remains robust and steady, with its simplicity and concurrency features attracting consistent interest. Notably, about one in six Go users is contemplating a shift toward Rust. The choice between Rust and Go is pivotal and should be made with a thorough understanding of each language’s strengths and suitability to project requirements – whether it concerns performance, ease of use, or concurrent programming. In this article, we aim to equip you with the essential insights to help you make an informed decision between Rust and Go in 2025. Rust overview Rust development history Rust was initially conceived by Graydon Hoare in 2006 as a side project. Officially sponsored by Mozilla Research in 2009, Rust was designed to create a safer, concurrent, and practical language that could rival C++ in terms of performance while ensuring higher security and thread safety. It underwent numerous iterations and improvements, with the first stable release, Rust 1.0, launched in May 2015. The language has been developed with contributions from a dedicated and vibrant open-source community, continually evolving with robust compiler improvements and features aimed at ensuring safety and efficiency. Rust core philosophy The core philosophy behind Rust is to provide memory safety without using garbage collection and to support concurrency without data races. It achieves these through ‘ownership’ and ‘borrowing’ concepts, which are enforced at compile-time by the Rust compiler. This strict enforcement of memory safety rules ensures that Rust programs are free of null pointer dereferences, dangling pointers, and buffer overflows, which are common vulnerabilities in system-level programming languages like C and C++. Additionally, Rust emphasizes zero-cost abstractions, iterator chains, and type inference, which allows high-level programming without sacrificing performance. Popular Rust use cases Rust’s unique features make it particularly suitable for several crucial fields: Systems programming: Rust is popularly used for writing operating systems, embedded systems, and other foundational software where close control of hardware and system resources is crucial. Its ability to ensure memory safety and concurrency makes it an excellent choice for developing reliable and high-performance system-level software. Internet of Things (IoT): In IoT, devices often operate under resource constraints and require high-security measures. Rust’s efficient memory use and robustness help in building secure, fast, and reliable IoT applications. WebAssembly: Given its performance traits, Rust is also becoming a favored option for targeting WebAssembly, especially for web applications demanding high-speed performance beyond what traditional JavaScript can offer. This use-case is expanding as the web continues to evolve into a platform for more complex and performance-critical applications. Blockchain development: The demands for security and concurrency in blockchain development have also seen Rust being adopted here, where guaranteed memory safety and efficient execution are paramount. Cloud Infrastructure: Rust is increasingly popular for developing cloud infrastructure across major cloud providers like AWS, Azure, and GCP. Its memory safety features and concurrency support make it ideal for building high-performance, secure cloud services that can scale efficiently and handle heavy workloads. Network Programming: Rust is also favored for network programming applications owing to its performance and reliable concurrency model. It’s used to build network utilities and systems that require high-speed data processing and transfer with minimal latency, benefiting from Rust’s efficiency and robust error handling. Command-line Interfaces (CLIs): Rust is becoming a preferred choice for creating command-line interfaces due to its compilation to efficient binary code, which makes CLI tools fast and dependable. Developers value Rust for building CLI applications that require performance, precise error control, and support across multiple platforms. Go overview Go origins and development history Go, also known as Golang, was designed by Robert Griesemer, Rob Pike, and Ken Thompson at Google, and officially released in 2009. The driving force behind Go’s creation was addressing the scaling issues associated with software development at Google, which included slow build times, unwieldy codebases, and difficulties in managing dependencies while maintaining performance across large-scale distributed systems. Go was designed to combine the speed and ease of use of dynamically typed languages like Python with the performance and security advantages of statically typed languages like C++. Over the years, it has evolved with an emphasis on simplicity and efficiency, incorporating robust standard libraries and features that cater to concurrent processing and networking. Go core philosophy The core philosophy of Go revolves around simplicity, efficiency, and readability. It incorporates a minimalistic syntax with only a small number of keywords, making the code easy to write and read. Go’s design excludes many features of modern OOP languages like type inheritance and generics (although generics have been introduced in recent versions), which purists argue can lead to complex and hard-to-maintain code. A significant feature of Go is its built-in support for concurrent programming, embodied in goroutines (lightweight threads managed by the Go runtime) and channels (which help in managing goroutines). This built-in concurrency model enables developers to easily write programs that get the most out of multicore and networked machines, enhancing Go’s utility in back-end and server-side applications. Popular Go use cases Go’s simplicity and powerful concurrency tools have led to its widespread adoption across several key domains: Cloud infrastructure: Go’s efficient performance characteristics and robust standard library make it an ideal choice for building cloud services and infrastructure. Companies like Google, Dropbox, and Docker use Go to power large portions of their cloud computing solutions, benefiting from its easy maintenance and efficient scalability. Web servers and API services: Go is extensively used in developing web servers and RESTful services due to its strong HTTP support and efficient concurrent processing capabilities. Its standard library includes powerful tools for building networked services, which makes Go a preferred choice for backend development. Network programming: The simplicity in handling concurrency and the rich set of networking libraries make Go a strong candidate for developing network tools and programs that require high performance and scalability, such as database brokers, message queues, and more. DevOps tools: Due to its simplicity and fast execution, Go is commonly chosen for creating tools used in DevOps practices, such as Kubernetes and Terraform. These tools manage containerized applications and orchestrate complex cloud environments, benefiting from Go’s efficiency and ease of deployment. Command-line Interfaces (CLIs): Go’s ability to compile into a single binary across multiple platforms makes it an excellent choice for developing command-line tools that can be easily distributed and used across different operating systems without additional dependencies. Rust vs Go: Performance comparison When choosing a programming language for a project, understanding how each language performs under different scenarios can drastically impact the efficiency and success of the application. Below, we explore the performance nuances of Rust and Go using benchmark data and real-world examples, discussing specific trade-offs to help guide decisions based on project requirements such as system-level applications versus web development. Rust’s Low-level memory management: Rust provides control over memory allocation without a garbage collector, which means it can operate closer to the hardware and manipulate memory with high precision. This is beneficial for systems programming where low latency and high throughput are crucial. For instance, a benchmark by benchmarks game shows that Rust implementations tend to have lower memory use and are often faster in computation-heavy tasks compared to Go. For example, Servo, a high-performance browser engine developed by Mozilla, leverages Rust’s ability to manage memory efficiently to improve parallelism and ensure safety, significantly enhancing browsing speed. Speed and efficiency of Rust in systems programming: Rust’s zero-cost abstractions mean that abstractions cost nothing in terms of runtime performance. This makes Rust especially suitable for building performance-critical software such as game engines or simulation software where deterministic performance is key. For example, Veloren, an open-world game, utilizes Rust’s capability to handle complex calculations and graphics rendering efficiently without compromising on speed. Trade-offs: While Rust provides superior control and performance efficiency in system-level programming, its steep learning curve and strict compilation requirements can slow down development speed compared to Go, especially in projects where rapid development and iteration are crucial. Go’s garbage collection impact Go’s garbage collector is designed to maximize efficiency and minimize latency, providing a balance between performance and developer convenience. This is particularly visible in web environments where Go manages memory efficiently across thousands of lightweight goroutines. According to a TechEmpower benchmark, Go applications perform impressively well in web frameworks and platforms, often outperforming other compiled languages in concurrent access tests. For example, Docker, a popular containerization platform, utilizes Go primarily due to its simplicity and the efficiency of its concurrency model, enabling it to manage thousands of microservices efficiently. Strengths in Go’s concurrent programming Go’s built-in support for concurrency allows developers to easily implement scalable server-side applications. Its simplicity in managing multiple threads of execution without the overhead typical of more verbose threading models is a significant advantage in web services and cloud applications. Trade-offs: Although Go provides substantial ease of use and satisfactory performance for web servers and simpler backend services, it may not reach the performance extremities required in low-level system programming or where granular control over memory and processing is essential, areas where Rust excels. Rust vs Go: Ease of use Both Rust and Go have distinct learning curves and ecosystems tailored to their respective strengths and philosophies. Choosing between them should consider the proficiency of everyone in a team and the specific needs of the project. Let’s explore the differences between Rust and Go in terms of how user-friendly and accessible each language is, considering their syntax, core philosophies, and the tools that support their ecosystems. Rust’s steep learning curve Rust is known for its stringent compiler and its unique approach to memory management through ownership and borrowing concepts. While these features contribute significantly to Rust’s performance and safety guarantees, they also steepen the learning curve. New programmers might find Rust challenging as they need to adhere strictly to its rules to even compile the code, a stark contrast to more lenient languages. However, once mastered, these same features make Rust exceedingly reliable and secure, particularly in concurrent and system-level programming contexts.  For newcomers to Rust or those looking to deepen their understanding, helpful resources are available in our new blog post on How to Learn Rust in 2024. Challenges and benefits of learning Rust One of the main challenges of learning Rust is grappling with its borrow checker—a mechanism that ensures references do not outlive the data they refer to. While initially perplexing, mastering this feature teaches developers rigorous memory management, significantly reducing runtime errors and security vulnerabilities. The benefits of enduring Rust’s steep learning curve manifest as high performance, memory safety, and concurrency without fear of data races. Furthermore, the robust tool ecosystem, including the RustRover IDE, enhances the learning and development process. RustRover, for instance, assists with code completion, error handling, and debugging, which simplifies some of the complexities involved in Rust development. Go’s beginner-friendly learning curve Go boasts simplicity in its design, advocating for minimalistic syntax and a small set of keywords. This design philosophy not only makes Go easy to learn but also aims to maintain readability and maintainability of code, making it an ideal choice for beginners. The absence of complicated language constructs like generics (until recently) and the simplified approach to object-oriented programming make Go an easy language for newcomers to grasp. Popularity of Go among startups and tech giants Go’s simplicity combined with its powerful built-in concurrency model has made it incredibly popular among startups and large corporations like Google, Uber, and Twitch. These companies benefit from Go’s fast compilation and execution that scales efficiently with multicore processors and large software systems. The language’s design aligns well with modern software development requirements such as microservices architectures and cloud services. Furthermore, the development experience in Go is boosted by tools like GoLand IDE, which provides a rich set of features designed to improve productivity and simplify code management. GoLand offers excellent support for Go’s concurrency patterns, integrated testing, and seamless editing tools that help developers navigate and write Go code more efficiently. Rust vs Go: Concurrency and multithreading Both Rust and Go provide robust solutions for handling concurrency, each through distinct approaches and constructs. As multithreading becomes increasingly crucial in modern applications, understanding how each language facilitates concurrent operations, alongside their respective strengths and weaknesses, is vital for developers. Rust’s ownership model and safety in multithreading Ownership and memory safety Rust’s ownership model is a foundational aspect of its approach to memory safety and concurrency. This model divides data into distinct ownerships and borrowing, ensuring that only one function or thread can own a particular piece of data at a time. This strict model prevents data races at compile time—a common source of bugs in concurrent programming. Strengths: The primary strength of this model is its ability to provide guaranteed thread safety without needing a garbage collector. This can result in performance improvements, as the overhead of garbage collection is eliminated. Rust’s compile-time checks enforce that any borrow of data maintains synchronization with the owner’s lifetime, preventing hanging pointers and other common concurrency errors. Weaknesses: The strictness of the ownership rules can also be a limiting factor, as it imposes a steeper learning curve and can complicate the design of certain types of concurrent architectures where shared mutable state is necessary. Practical examples of using Rust in high-performance applications Rust is extensively used in scenarios where performance and safety are critical. Examples of real-world usage: Cloudflare: As a leader in internet infrastructure, Cloudflare utilizes Rust to develop several of their system-critical components that require high performance and reliability. Rust’s safety and concurrency features are crucial for Cloudflare’s need to process significant amounts of data with minimal latency, helping ensure robust, secure delivery of web content. More about their use of Rust can be explored through Cloudflare’s dedicated discussions on their blog. Servo Engine: Developed by Mozilla, the Servo engine is an experimental browser engine designed to take full advantage of Rust’s concurrency capabilities. It uses fine-grained parallelism to improve the performance of page loading and rendering tasks. ripgrep: This is a line-oriented search tool that recursively searches the current directory for a regex pattern. By leveraging Rust’s concurrency features, ripgrep outperforms similar tools by efficiently parallelizing the search process across available CPU cores. Goroutines and ease of concurrent programming in Go Go introduces goroutines as a core part of its language design, which are functions capable of running concurrently with others. A goroutine is a lightweight thread managed by the Go runtime. The use of goroutines simplifies the implementation of concurrent and parallel systems. Strengths: Goroutines are inexpensive to create and have little overhead, with each taking up only a few kilobytes in stack space. This allows the creation of thousands of goroutines if needed. The Go runtime handles the scheduling and coordination, simplifying the model for the developer. Weaknesses: While the simplicity of goroutines is beneficial, it can also lead to challenges, particularly in managing synchronization and shared state. Without careful design, concurrent programming in Go can result in race conditions and deadlock issues as applications scale. Common Go use cases in web services and cloud-based applications Go’s concurrency features make it particularly well-suited for building scalable web services and cloud applications. Examples include: Kubernetes: An open-source platform designed to automate deploying, scaling, and operating application containers, Kubernetes uses Go to handle large-scale, high-concurrency services. Docker: Docker utilizes Go for building and running containerized applications. Go’s simplicity and built-in support for concurrent operations enable Docker to manage services efficiently. Both Rust and Go provide powerful tools for building concurrent applications but do so in fundamentally different ways. Rust offers more stringent safety guarantees at the expense of a steeper learning curve, making it ideal for applications where safety is critical. Go offers a more straightforward approach to concurrency, making it better suited for applications that require rapid development and deployment with scalable performance. Understanding these differences should allow you to choose the right tool according to the specific demands and nature of your project. Rust vs Go: Ecosystem and community support The vitality of a programming language is often reflected by its ecosystem’s robustness and the vibrancy of its community. As Rust and Go continue to grow, both languages offer distinct advantages and challenges in terms of libraries, tools, and community engagement. Maturity of Rust libraries and tools Rust’s ecosystem, though younger than Go’s, has rapidly matured with a strong focus on safety and performance. The availability of robust tools like Cargo, Rust’s package manager and build system, simplifies dependency management and compilation tasks. Cargo integrates seamlessly with crates.io, a large repository of community-contributed libraries, known as ‘crates’, that extend Rust’s capabilities. Strengths: Rust’s tooling is designed to enforce strict code safety standards, which is critical in systems where reliability and security are paramount. The language ecosystem also benefits from an active development community that prioritizes these attributes. Weaknesses: Despite significant growth, the Rust ecosystem is still evolving, and on occasion, developers might find the available libraries less comprehensive compared to those available in more mature ecosystems like Go’s. This can sometimes result in needing to develop custom solutions, which may increase project timelines and complexity. Growth and support from Rust’s open-source community Rust has cultivated a passionate and rapidly growing open-source community, which contributes not only to the development of the language itself but also to a broad spectrum of community-driven projects. Strengths: The community’s commitment is demonstrated through consistent improvements to the language, high-quality documentation, and the development of new tools and libraries. The annual Rust Survey and RustConf are indicators of the community’s robust engagement and dedication to evolving the language in response to user needs. Weaknesses: As the community is still expanding, some areas of the ecosystem might lack the same level of support or as many expert resources as those available in older, larger developer communities. Go’s rich standard library and tools Go’s standard library is widely praised for its comprehensiveness and effectiveness, providing well-designed packages for a variety of common tasks such as HTTP server implementation, cryptography, and data manipulation. This richness allows developers to achieve more with the standard library alone, reducing the reliance on external libraries. Strengths: The rich set of tools and a comprehensive standard library simplify many programming tasks, enhancing Go’s usability and speeding up the development process. Tools like GoLang’s native testing toolkit and benchmarking tools integrate seamlessly into the developer workflow. Weaknesses: While Go’s standard library covers a broad range of functionality, its approach can sometimes be too simplistic for complex applications, which may necessitate additional customization or external packages. Industry adoption of Go Go has seen substantial industry adoption, with significant backing from tech giants such as Google, which designed the language. This corporate support not only validates the language’s capabilities but also ensures ongoing investment in its development. Strengths: High adoption rates in the tech industry, including by companies like Uber, Netflix, and Dropbox, contribute to a rich ecosystem of projects and third-party tools, fostering a reliable support network. This adoption speaks to its performance, scalability, and ease of use in production environments. Weaknesses: The popularity of Go in large-scale tech companies means there may sometimes be a bias towards solving problems at scale, which might not directly address the needs of smaller projects or teams. Rust and Go in 2025 By 2025, both Rust and Go offer strong ecosystems supported by vibrant communities. Rust’s focus on safety and performance makes it ideal for applications where these factors are critical, while Go’s simplicity and rich set of libraries make it excellent for quickly developing scalable applications. The choice between Rust and Go should consider the specific technical needs of the project, the desired timeline for development, and the type of community and corporate support that will best enhance the project’s success. Each ecosystem presents compelling strengths and some limitations, making it essential to align language choice with project goals and team skills in 2025. Subscribe to Rust Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/06/RR-social-BlogSocialShare-1280x720-2x-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/rust/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2020/07/RustRover.svg\" alt=\"Rust logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eFocus on what matters\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/rust/category/articles-2/\"\u003eArticles\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/rust/category/news/\"\u003eNews\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eRust vs Go: Which one to choose in 2025\u003c/h2\u003e                    \n                    \n\u003cp\u003eThe programming landscape continues to evolve, bringing forward languages like Rust and Go that not only challenge traditional paradigms but also cater to the sophisticated needs of modern computing. Both have carved significant niches for themselves, celebrated for their efficient handling of system-level operations and concurrency.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"2560\" height=\"1440\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/RR-social-BlogFeatured-1280x720-2x-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eRecent findings from the\u003ca href=\"https://www.jetbrains.com/lp/devecosystem-2024/\" target=\"_blank\" rel=\"noopener\"\u003e State of Developer Ecosystem Report 2024\u003c/a\u003e highlight the dynamic growth and adoption rates of these languages. Rust celebrated a remarkable milestone by setting a usage record among the year’s most popular languages and boasted a user base of approximately 2.27 million developers, with 709,000 using it as their primary language. Meanwhile, Go’s user base remains robust and steady, with its simplicity and concurrency features attracting consistent interest. Notably, about one in six Go users is contemplating a shift toward Rust.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1556\" height=\"1416\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/Screenshot-2025-06-10-at-12.21.15-PM.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eThe choice between Rust and Go is pivotal and should be made with a thorough understanding of each language’s strengths and suitability to project requirements – whether it concerns performance, ease of use, or concurrent programming. In this article, we aim to equip you with the essential insights to help you make an informed decision between Rust and Go in 2025.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRust overview\u003c/h2\u003e\n\n\n\n\u003ch3\u003eRust development history\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust was initially conceived by Graydon Hoare in 2006 as a side project. Officially sponsored by Mozilla Research in 2009, Rust was designed to create a safer, concurrent, and practical language that could rival C++ in terms of performance while ensuring higher security and thread safety. It underwent numerous iterations and improvements, with the first stable release, Rust 1.0, launched in May 2015. The language has been developed with contributions from a dedicated and vibrant open-source community, continually evolving with robust compiler improvements and features aimed at ensuring safety and efficiency.\u003c/p\u003e\n\n\n\n\u003ch3\u003eRust core philosophy\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe core philosophy behind Rust is to provide memory safety without using garbage collection and to support concurrency without data races. It achieves these through ‘ownership’ and ‘borrowing’ concepts, which are enforced at compile-time by the Rust compiler. This strict enforcement of memory safety rules ensures that Rust programs are free of null pointer dereferences, dangling pointers, and buffer overflows, which are common vulnerabilities in system-level programming languages like C and C++. Additionally, Rust emphasizes zero-cost abstractions, iterator chains, and type inference, which allows high-level programming without sacrificing performance.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePopular Rust use cases\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust’s unique features make it particularly suitable for \u003ca href=\"https://blog.jetbrains.com/rust/2025/05/13/is-rust-the-future-of-programming/#which-kinds-of-projects-do-you-develop-in-rust\"\u003eseveral crucial fields\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSystems programming:\u003c/strong\u003e Rust is popularly used for writing operating systems, embedded systems, and other foundational software where close control of hardware and system resources is crucial. Its ability to ensure memory safety and concurrency makes it an excellent choice for developing reliable and high-performance system-level software.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eInternet of Things (IoT):\u003c/strong\u003e In IoT, devices often operate under resource constraints and require high-security measures. Rust’s efficient memory use and robustness help in building secure, fast, and reliable IoT applications.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eWebAssembly:\u003c/strong\u003e Given its performance traits, Rust is also becoming a favored option for targeting WebAssembly, especially for web applications demanding high-speed performance beyond what traditional JavaScript can offer. This use-case is expanding as the web continues to evolve into a platform for more complex and performance-critical applications.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eBlockchain development:\u003c/strong\u003e The demands for security and concurrency in blockchain development have also seen Rust being adopted here, where guaranteed memory safety and efficient execution are paramount.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eCloud Infrastructure:\u003c/strong\u003e Rust is increasingly popular for developing cloud infrastructure across major cloud providers like AWS, Azure, and GCP. Its memory safety features and concurrency support make it ideal for building high-performance, secure cloud services that can scale efficiently and handle heavy workloads.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eNetwork Programming:\u003c/strong\u003e Rust is also favored for network programming applications owing to its performance and reliable concurrency model. It’s used to build network utilities and systems that require high-speed data processing and transfer with minimal latency, benefiting from Rust’s efficiency and robust error handling.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eCommand-line Interfaces (CLIs):\u003c/strong\u003e Rust is becoming a preferred choice for creating command-line interfaces due to its compilation to efficient binary code, which makes CLI tools fast and dependable. Developers value Rust for building CLI applications that require performance, precise error control, and support across multiple platforms.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"1700\" height=\"2088\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/11-2x-1.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eGo overview\u003c/h2\u003e\n\n\n\n\u003ch3\u003eGo origins and development history\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo, also known as Golang, was designed by Robert Griesemer, Rob Pike, and Ken Thompson at Google, and officially released in 2009. The driving force behind Go’s creation was addressing the scaling issues associated with software development at Google, which included slow build times, unwieldy codebases, and difficulties in managing dependencies while maintaining performance across large-scale distributed systems.\u003c/p\u003e\n\n\n\n\u003cp\u003eGo was designed to combine the speed and ease of use of dynamically typed languages like Python with the performance and security advantages of statically typed languages like C++. Over the years, it has evolved with an emphasis on simplicity and efficiency, incorporating robust standard libraries and features that cater to concurrent processing and networking.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGo core philosophy\u003c/h3\u003e\n\n\n\n\u003cp\u003eThe core philosophy of Go revolves around simplicity, efficiency, and readability. It incorporates a minimalistic syntax with only a small number of keywords, making the code easy to write and read. Go’s design excludes many features of modern OOP languages like type inheritance and generics (although generics have been introduced in recent versions), which purists argue can lead to complex and hard-to-maintain code. A significant feature of Go is its built-in support for concurrent programming, embodied in goroutines (lightweight threads managed by the Go runtime) and channels (which help in managing goroutines). This built-in concurrency model enables developers to easily write programs that get the most out of multicore and networked machines, enhancing Go’s utility in back-end and server-side applications.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePopular Go use cases\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s simplicity and powerful concurrency tools have led to its widespread adoption across \u003ca href=\"https://blog.jetbrains.com/research/2025/04/is-golang-still-growing-go-language-popularity-trends-in-2024/#go-developers\" data-type=\"link\" data-id=\"https://blog.jetbrains.com/research/2025/04/is-golang-still-growing-go-language-popularity-trends-in-2024/#go-developers\"\u003eseveral key domains\u003c/a\u003e:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCloud infrastructure:\u003c/strong\u003e Go’s efficient performance characteristics and robust standard library make it an ideal choice for building cloud services and infrastructure. Companies like Google, Dropbox, and Docker use Go to power large portions of their cloud computing solutions, benefiting from its easy maintenance and efficient scalability.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eWeb servers and API services:\u003c/strong\u003e Go is extensively used in developing web servers and RESTful services due to its strong HTTP support and efficient concurrent processing capabilities. Its standard library includes powerful tools for building networked services, which makes Go a preferred choice for backend development.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eNetwork programming:\u003c/strong\u003e The simplicity in handling concurrency and the rich set of networking libraries make Go a strong candidate for developing network tools and programs that require high performance and scalability, such as database brokers, message queues, and more.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDevOps tools:\u003c/strong\u003e Due to its simplicity and fast execution, Go is commonly chosen for creating tools used in DevOps practices, such as Kubernetes and Terraform. These tools manage containerized applications and orchestrate complex cloud environments, benefiting from Go’s efficiency and ease of deployment.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eCommand-line Interfaces (CLIs):\u003c/strong\u003e Go’s ability to compile into a single binary across multiple platforms makes it an excellent choice for developing command-line tools that can be easily distributed and used across different operating systems without additional dependencies.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1700\" height=\"1416\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/01-2x-1.webp\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eRust vs Go: Performance comparison\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen choosing a programming language for a project, understanding how each language performs under different scenarios can drastically impact the efficiency and success of the application. Below, we explore the performance nuances of Rust and Go using benchmark data and real-world examples, discussing specific trade-offs to help guide decisions based on project requirements such as system-level applications versus web development.\u003c/p\u003e\n\n\n\n\u003ch3\u003eRust’s Low-level memory management:\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust provides control over memory allocation without a garbage collector, which means it can operate closer to the hardware and manipulate memory with high precision. This is beneficial for systems programming where low latency and high throughput are crucial. For instance, a benchmark by\u003ca href=\"https://benchmarksgame-team.pages.debian.net/benchmarksgame/\" target=\"_blank\" rel=\"noopener\"\u003e benchmarks game\u003c/a\u003e shows that Rust implementations tend to have lower memory use and are often faster in computation-heavy tasks compared to Go.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, Servo, a high-performance browser engine developed by Mozilla, leverages Rust’s ability to manage memory efficiently to improve parallelism and ensure safety, significantly enhancing browsing speed.\u003c/p\u003e\n\n\n\n\u003ch3\u003eSpeed and efficiency of Rust in systems programming:\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust’s zero-cost abstractions mean that abstractions cost nothing in terms of runtime performance. This makes Rust especially suitable for building performance-critical software such as game engines or simulation software where deterministic performance is key. For example, Veloren, an open-world game, utilizes Rust’s capability to handle complex calculations and graphics rendering efficiently without compromising on speed.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eTrade-offs:\u003c/strong\u003e While Rust provides superior control and performance efficiency in system-level programming, its steep learning curve and strict compilation requirements can slow down development speed compared to Go, especially in projects where rapid development and iteration are crucial.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGo’s garbage collection impact\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s garbage collector is designed to maximize efficiency and minimize latency, providing a balance between performance and developer convenience. This is particularly visible in web environments where Go manages memory efficiently across thousands of lightweight goroutines. According to a \u003ca href=\"https://www.techempower.com/benchmarks/\" target=\"_blank\" rel=\"noopener\"\u003eTechEmpower benchmark\u003c/a\u003e, Go applications perform impressively well in web frameworks and platforms, often outperforming other compiled languages in concurrent access tests.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, Docker, a popular containerization platform, utilizes Go primarily due to its simplicity and the efficiency of its concurrency model, enabling it to manage thousands of microservices efficiently.\u003c/p\u003e\n\n\n\n\u003ch3\u003eStrengths in Go’s concurrent programming\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s built-in support for concurrency allows developers to easily implement scalable server-side applications. Its simplicity in managing multiple threads of execution without the overhead typical of more verbose threading models is a significant advantage in web services and cloud applications.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eTrade-offs:\u003c/strong\u003e Although Go provides substantial ease of use and satisfactory performance for web servers and simpler backend services, it may not reach the performance extremities required in low-level system programming or where granular control over memory and processing is essential, areas where Rust excels.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRust vs Go: Ease of use\u003c/h2\u003e\n\n\n\n\u003cp\u003eBoth Rust and Go have distinct learning curves and ecosystems tailored to their respective strengths and philosophies. Choosing between them should consider the proficiency of everyone in a team and the specific needs of the project. Let’s explore the differences between Rust and Go in terms of how user-friendly and accessible each language is, considering their syntax, core philosophies, and the tools that support their ecosystems.\u003c/p\u003e\n\n\n\n\u003ch3\u003eRust’s steep learning curve\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust is known for its stringent compiler and its unique approach to memory management through ownership and borrowing concepts. While these features contribute significantly to Rust’s performance and safety guarantees, they also steepen the learning curve. New programmers might find Rust challenging as they need to adhere strictly to its rules to even compile the code, a stark contrast to more lenient languages. However, once mastered, these same features make Rust exceedingly reliable and secure, particularly in concurrent and system-level programming contexts. \u003c/p\u003e\n\n\n\n\u003cp\u003eFor newcomers to Rust or those looking to deepen their understanding, helpful resources are available in our new blog post on \u003ca href=\"https://blog.jetbrains.com/rust/2024/09/20/how-to-learn-rust/\"\u003eHow to Learn Rust in 2024\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch3\u003eChallenges and benefits of learning Rust\u003c/h3\u003e\n\n\n\n\u003cp\u003eOne of the main challenges of learning Rust is grappling with its borrow checker—a mechanism that ensures references do not outlive the data they refer to. While initially perplexing, mastering this feature teaches developers rigorous memory management, significantly reducing runtime errors and security vulnerabilities.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe benefits of enduring Rust’s steep learning curve manifest as high performance, memory safety, and concurrency without fear of data races. Furthermore, the robust tool ecosystem, including the \u003ca href=\"https://www.jetbrains.com/rust/\" target=\"_blank\" rel=\"noopener\"\u003eRustRover IDE\u003c/a\u003e, enhances the learning and development process. RustRover, for instance, assists with code completion, error handling, and debugging, which simplifies some of the complexities involved in Rust development.\u003c/p\u003e\n\n\n    \n\n\n\n\n\n\n\n\u003ch3\u003eGo’s beginner-friendly learning curve\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo boasts simplicity in its design, advocating for minimalistic syntax and a small set of keywords. This design philosophy not only makes Go easy to learn but also aims to maintain readability and maintainability of code, making it an ideal choice for beginners. The absence of complicated language constructs like generics (until recently) and the simplified approach to object-oriented programming make Go an easy language for newcomers to grasp.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePopularity of Go among startups and tech giants\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s simplicity combined with its powerful built-in concurrency model has made it incredibly popular among startups and large corporations like Google, Uber, and Twitch. These companies benefit from Go’s fast compilation and execution that scales efficiently with multicore processors and large software systems. The language’s design aligns well with modern software development requirements such as microservices architectures and cloud services.\u003c/p\u003e\n\n\n\n\u003cp\u003eFurthermore, the development experience in Go is boosted by tools like \u003ca href=\"https://www.jetbrains.com/go/\" target=\"_blank\" rel=\"noopener\"\u003eGoLand IDE\u003c/a\u003e, which provides a rich set of features designed to improve productivity and simplify code management. GoLand offers excellent support for Go’s concurrency patterns, integrated testing, and seamless editing tools that help developers navigate and write Go code more efficiently.\u003c/p\u003e\n\n\n    \n\n\n\n\n\n\n\n\u003ch2\u003eRust vs Go: Concurrency and multithreading\u003c/h2\u003e\n\n\n\n\u003cp\u003eBoth Rust and Go provide robust solutions for handling concurrency, each through distinct approaches and constructs. As multithreading becomes increasingly crucial in modern applications, understanding how each language facilitates concurrent operations, alongside their respective strengths and weaknesses, is vital for developers.\u003c/p\u003e\n\n\n\n\u003ch3\u003eRust’s ownership model and safety in multithreading\u003c/h3\u003e\n\n\n\n\u003ch4\u003eOwnership and memory safety\u003c/h4\u003e\n\n\n\n\u003cp\u003eRust’s ownership model is a foundational aspect of its approach to memory safety and concurrency. This model divides data into distinct ownerships and borrowing, ensuring that only one function or thread can own a particular piece of data at a time. This strict model prevents data races at compile time—a common source of bugs in concurrent programming.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e The primary strength of this model is its ability to provide guaranteed thread safety without needing a garbage collector. This can result in performance improvements, as the overhead of garbage collection is eliminated. Rust’s compile-time checks enforce that any borrow of data maintains synchronization with the owner’s lifetime, preventing hanging pointers and other common concurrency errors.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses:\u003c/strong\u003e The strictness of the ownership rules can also be a limiting factor, as it imposes a steeper learning curve and can complicate the design of certain types of concurrent architectures where shared mutable state is necessary.\u003c/p\u003e\n\n\n\n\u003ch3\u003ePractical examples of using Rust in high-performance applications\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust is extensively used in scenarios where performance and safety are critical. Examples of real-world usage:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCloudflare: \u003c/strong\u003eAs a leader in internet infrastructure, Cloudflare utilizes Rust to develop several of their system-critical components that require high performance and reliability. Rust’s safety and concurrency features are crucial for Cloudflare’s need to process significant amounts of data with minimal latency, helping ensure robust, secure delivery of web content. More about their use of Rust can be explored through Cloudflare’s dedicated discussions on their \u003ca href=\"https://blog.cloudflare.com/tag/rust/\" target=\"_blank\" rel=\"noopener\"\u003eblog\u003c/a\u003e.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eServo Engine:\u003c/strong\u003e Developed by Mozilla, the Servo engine is an experimental browser engine designed to take full advantage of Rust’s concurrency capabilities. It uses fine-grained parallelism to improve the performance of page loading and rendering tasks.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eripgrep:\u003c/strong\u003e This is a line-oriented search tool that recursively searches the current directory for a regex pattern. By leveraging Rust’s concurrency features, ripgrep outperforms similar tools by efficiently parallelizing the search process across available CPU cores.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch3\u003eGoroutines and ease of concurrent programming in Go\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo introduces goroutines as a core part of its language design, which are functions capable of running concurrently with others. A goroutine is a lightweight thread managed by the Go runtime. The use of goroutines simplifies the implementation of concurrent and parallel systems.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e Goroutines are inexpensive to create and have little overhead, with each taking up only a few kilobytes in stack space. This allows the creation of thousands of goroutines if needed. The Go runtime handles the scheduling and coordination, simplifying the model for the developer.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses:\u003c/strong\u003e While the simplicity of goroutines is beneficial, it can also lead to challenges, particularly in managing synchronization and shared state. Without careful design, concurrent programming in Go can result in race conditions and deadlock issues as applications scale.\u003c/p\u003e\n\n\n\n\u003ch3\u003eCommon Go use cases in web services and cloud-based applications\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s concurrency features make it particularly well-suited for building scalable web services and cloud applications. Examples include:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eKubernetes:\u003c/strong\u003e An open-source platform designed to automate deploying, scaling, and operating application containers, Kubernetes uses Go to handle large-scale, high-concurrency services.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDocker:\u003c/strong\u003e Docker utilizes Go for building and running containerized applications. Go’s simplicity and built-in support for concurrent operations enable Docker to manage services efficiently.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eBoth Rust and Go provide powerful tools for building concurrent applications but do so in fundamentally different ways. Rust offers more stringent safety guarantees at the expense of a steeper learning curve, making it ideal for applications where safety is critical. Go offers a more straightforward approach to concurrency, making it better suited for applications that require rapid development and deployment with scalable performance. Understanding these differences should allow you to choose the right tool according to the specific demands and nature of your project.\u003c/p\u003e\n\n\n\n\u003ch2\u003eRust vs Go: Ecosystem and community support\u003c/h2\u003e\n\n\n\n\u003cp\u003eThe vitality of a programming language is often reflected by its ecosystem’s robustness and the vibrancy of its community. As Rust and Go continue to grow, both languages offer distinct advantages and challenges in terms of libraries, tools, and community engagement.\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"1492\" height=\"837\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/06/Rust-vs-Go-illustartion.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch3\u003eMaturity of Rust libraries and tools\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust’s ecosystem, though younger than Go’s, has rapidly matured with a strong focus on safety and performance. The availability of robust tools like Cargo, Rust’s package manager and build system, simplifies dependency management and compilation tasks. Cargo integrates seamlessly with crates.io, a large repository of community-contributed libraries, known as ‘crates’, that extend Rust’s capabilities.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e Rust’s tooling is designed to enforce strict code safety standards, which is critical in systems where reliability and security are paramount. The language ecosystem also benefits from an active development community that prioritizes these attributes.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses: \u003c/strong\u003eDespite significant growth, the Rust ecosystem is still evolving, and on occasion, developers might find the available libraries less comprehensive compared to those available in more mature ecosystems like Go’s. This can sometimes result in needing to develop custom solutions, which may increase project timelines and complexity.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGrowth and support from Rust’s open-source community\u003c/h3\u003e\n\n\n\n\u003cp\u003eRust has cultivated a passionate and rapidly growing open-source community, which contributes not only to the development of the language itself but also to a broad spectrum of community-driven projects.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e The community’s commitment is demonstrated through consistent improvements to the language, high-quality documentation, and the development of new tools and libraries. The annual Rust Survey and RustConf are indicators of the community’s robust engagement and dedication to evolving the language in response to user needs.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses:\u003c/strong\u003e As the community is still expanding, some areas of the ecosystem might lack the same level of support or as many expert resources as those available in older, larger developer communities.\u003c/p\u003e\n\n\n\n\u003ch3\u003eGo’s rich standard library and tools\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo’s standard library is widely praised for its comprehensiveness and effectiveness, providing well-designed packages for a variety of common tasks such as HTTP server implementation, cryptography, and data manipulation. This richness allows developers to achieve more with the standard library alone, reducing the reliance on external libraries.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e The rich set of tools and a comprehensive standard library simplify many programming tasks, enhancing Go’s usability and speeding up the development process. Tools like GoLang’s native testing toolkit and benchmarking tools integrate seamlessly into the developer workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses:\u003c/strong\u003e While Go’s standard library covers a broad range of functionality, its approach can sometimes be too simplistic for complex applications, which may necessitate additional customization or external packages.\u003c/p\u003e\n\n\n\n\u003ch3\u003eIndustry adoption of Go\u003c/h3\u003e\n\n\n\n\u003cp\u003eGo has seen substantial industry adoption, with significant backing from tech giants such as Google, which designed the language. This corporate support not only validates the language’s capabilities but also ensures ongoing investment in its development.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eStrengths:\u003c/strong\u003e High adoption rates in the tech industry, including by companies like Uber, Netflix, and Dropbox, contribute to a rich ecosystem of projects and third-party tools, fostering a reliable support network. This adoption speaks to its performance, scalability, and ease of use in production environments.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eWeaknesses:\u003c/strong\u003e The popularity of Go in large-scale tech companies means there may sometimes be a bias towards solving problems at scale, which might not directly address the needs of smaller projects or teams.\u003c/p\u003e\n\n\n\n\u003ch3\u003eRust and Go in 2025\u003c/h3\u003e\n\n\n\n\u003cp\u003eBy 2025, both Rust and Go offer strong ecosystems supported by vibrant communities. Rust’s focus on safety and performance makes it ideal for applications where these factors are critical, while Go’s simplicity and rich set of libraries make it excellent for quickly developing scalable applications. The choice between Rust and Go should consider the specific technical needs of the project, the desired timeline for development, and the type of community and corporate support that will best enhance the project’s success. Each ecosystem presents compelling strengths and some limitations, making it essential to align language choice with project goals and team skills in 2025.\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to Rust Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": null,
  "modifiedTime": null
}
