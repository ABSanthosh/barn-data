{
  "id": "5ee5aa23-2c0e-43b7-8a98-b6379e9de8c8",
  "title": "Read This Before Building Your First Zoom App",
  "link": "https://engineering.prezi.com/read-this-before-building-your-first-zoom-app-bd86c1d42cb3?source=rss----911e72786e31---4",
  "description": "",
  "author": "Attila Vágó",
  "published": "Mon, 09 Oct 2023 14:41:09 GMT",
  "source": "https://engineering.prezi.com/feed",
  "categories": [
    "software-development",
    "prezi",
    "coding",
    "software-architecture",
    "zoom"
  ],
  "byline": "Attila Vágó",
  "length": 11847,
  "excerpt": "I take it, if you’re reading this, you’ve made the decision or at the very least are toying with the idea of building a Zoom app. That’s great news for many Zoom users like myself who rely on the…",
  "siteName": "Prezi Engineering",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*U0lNGgJfm0Qo1ZfYDS36KA.png",
  "text": "Helping developers focus on delivering value, while architecting a better Zoom application.I take it, if you’re reading this, you’ve made the decision or at the very least are toying with the idea of building a Zoom app. That’s great news for many Zoom users like myself who rely on the additional functionality and features these apps give our daily in and out of meeting experiences, but as a software engineer, you might want to understand first just what kind of architectural and coding decisions you need to take to build the best possible app.Over the last year, we have built and released a Zoom app and added countless features, all of which taught us things we wish we knew upfront. In this article, I’ll share everything the team and I have bumped into along the way and, where appropriate, even provide code examples.A quick primer on the Layers APIThe best way to visualise what it really is, is to compare it to Photoshop. I know. It’s an unexpected comparison, but it makes a lot of sense. In Photoshop, everything is a layer. The same applies to Zoom’s Layers API. You have the background layer, you have the camera layer and finally at the top you get a web layer, and this final web layer is what makes the Layers API really cool and where the JS SDK runs.And now onto the meaty part of this article. Prepare for some aha moments and interesting snippets of code. For content, we have used React with hooks, a bit of Context API here and there, no state management libraries (Redux, yuck), Radix components for most of the UI. For tests, we went with Cypress, but more on that in a section of its own.External integrationsIt’s nigh on impossible these days to build a web app and not rely on some sort of external integration, even if that’s something as simple as pulling a library from a CDN that isn’t on your domain.Examples of whitelisted URLs in the Zoom app settings. Screenshot by author.While in the Marketplace app settings panel under App Credentials \u003e Domain Allow List you’ll find the option to add the required domains, you’ll quickly find that not every domain is treated the same way. Here are a few examples:google.com—straight up not allowed because it’s too broad. This one is important as it can affect your ability to easily integrate Login with Google, use YouTube in the app, etc.*.giphy.com—we found that the wildcard may or may not work, so we ended up adding all the 5 Giphy subdomains to the allow list like media0.giphy.com, media1.giphy.com, etc.img.icons8.com—this one isn’t disallowed, but it requires extra information as to why the app needs it.Unfortunately, you won’t always know what domains you will need to allow, so planning ahead may not be possible, but if it is, I would recommend adding all the required domains and subdomains to the Domain Allow List as soon as you can, as adding new ones also requires an app review by Zoom.Multiple contexts, two browsers with limitationsAnyone who isn’t familiar with CEF, should start reading up on it right away. The camera view on all operating systems uses CEF (Chromium Embedded Framework), that has a number of otherwise potentially very useful APIs disabled, like navigator.mediaDevices and all of its methods. This is also true for the inMeeting and inClient contexts, where on Mac it’s running the native browser, Safari. This means that getting extra control over audio and video or screen sharing isn’t possible. You also cannot throw popups and enable permissions to access various APIs like you would in the browser. In the camera view, even a simple alert('Y U No work?') won’t work.In terms of working with the various contexts, your app will want to have the context change in a state variable, so you can watch it in your useEffect. A mature app will end up looking something like this:useEffect(async () =\u003e { // initiate zoom SDK, determine contexts, and do other stuff}, [appContextChanged])if (component === 'Loading') { // Only display spinner in sidebar and not camera webview return !navigator.userAgentData || navigator.userAgentData.platform === '' ? ( \u003cSpinnerWrapper\u003e \u003cSpinner size={40} width={4} marginTop=\"0px\" /\u003e \u003c/SpinnerWrapper\u003e ) : ( ); } else if (component === 'camera') { return \u003cCameraView zoomSdk={zoomSdk} /\u003e; } else if (component === 'sidepanel') { return ( \u003cMeetingView zoomSdk={zoomSdk} initialCameraState={initialCameraState} /\u003e ); } else if (component === 'sandbox') { return \u003cSandbox /\u003e; } else if (component === 'preMeeting') { return \u003cPreMeeting appContextChanged={appContextChanged} zoomSdk={zoomSdk} /\u003e; } else if (component === 'unsupported') { return \u003cUnsupportedView /\u003e; }Watching appContextChanged is important, as we found that users often open the app from the main client rather than the meeting, which means, our UI had to update to accommodate that change. Of course, if you happen not to have a different UI for the two contexts, then you don’t have to, but I’d argue that you’re not taking advantage of the full capabilities of the Zoom SDK, as many APIs are not available in the main client, which in itself is a consideration to keep in mind.Inter-context communicationSpeaking of context, the Zoom SDK offers a handy postMessage method and, paired with the onMessage event, you essentially have a communication channel between the camera and the side panel, aka between CEF and Safari on a Mac for instance. That’s handy for countless things. You can send data, state changes, etc.It does, however, come with one important limitation: the payload cannot exceed 512 KB, and that’s not a lot. In our case, that meant that we couldn’t send blobs, Base64 or DataUri images across contexts. It also meant, we had to really be efficient with the data we were sending. In our app, at one point, we were sending all slide data to the camera. Imagine 100 slides’ data, especially when it includes rich text data in HTML strings. That quickly adds up, and we found that out once we added the import feature for PDFs and PPTs that for each page generates a slide on the fly. It quickly turned into a bottleneck that we had to work around.DebuggingThere is one unexpected positive use though for postMessage and onMessage. You can use these for debugging. Given the fact that the CEF view cannot be inspected in the browser as it runs in the camera, we had to get creative and send all error messages from the camera to the meeting view. Maybe not ideal, but it certainly works and saved us countless hours of debugging.It can be something as simple as telling the side-panel view that the camera is ready:zoomSdk.postMessage({ message: 'camera ready',});Or handling unhandled rejections like so:window.onunhandledrejection = event =\u003e { zoomSdk.postMessage({ message: `UNHANDLED PROMISE REJECTION: ${event.reason}`, });};Local storage isn’t quite…We all love local storage, don’t we? It’s very useful to keep track of certain app states, information, etc. As long as you don’t delete the browser or deliberately clear local storage, the data is reliably accessible. That’s not quite the case when building Zoom apps.Something we found out the hard way — but in hindsight it makes all the sense in the world — is that, once the user logs out of Zoom or switches to another user, that local storage is cleared, or to be more accurate, you’re getting a new instance of the embedded browser, so all that data is gone. Logging back in with the previous user also doesn’t bring back the data.What this all means for your app is that you’ll have no choice but to save some information into a database. That can be something as simple and easy to spin up like Firebase, but it is an extra lift, and you need to account for it. On that note, yes, Firebase is fully supported by Zoom apps.App stateSpeaking of state and data, while we didn’t use any state management libraries in our app, apart from React’s own context API, we did make another pragmatic decision around where to handle state. Given the fact that:local storage isn’t really persistentthere are two separate browsers that can only communicate via postMessageand we cannot really inspect the camera viewWe decided that all the app state variables should stay in the side-panel view. This decision effectively rendered the camera view a passive component that only reacts to messages it receives from the inMeeting context (side-panel).Sidebar sizeThe inMeeting context is basically the side-panel or sidebar view. By default, its width is practically a mobile screen viewport width. That’s great for many things, but every so often you might find wishing for more real-estate, which Zoom gives you through expandApp. In fact, you can even toggle programmatically between collapsed and expanded modes, like so:await zoomSdk.expandApp({ action: 'expand' | 'collapse',})There is but one twist to this, though. It’s either or. There is no in-between width or a set percentage / pixel width option. This means that your designs have to be clever enough to work around that limitation. We opted to stick to the collapse mode, as the expand mode would have been far too wide.MobileWithin the app settings under Features, you will also find a toggle for mobile. You will likely — but wrongly — assume that turning it on is all that’s required to have your app running on phones and tablets. Besides the additional information we had to provide for Apple devices, we also quickly found out that the Layers API is only partially supported on iOS, iPadOS, and Android. Given how many people use these devices nowadays, you need to account for this in your design, development, and app distribution strategy. We opted to stick to just desktop.Turning on mobile client support. Screenshot by author.TestingI briefly alluded to testing, but it deserves a couple more paragraphs. Honestly, this will probably be the biggest bottleneck you’ll have to account for, and there are several reasons for that:Your local browser sandbox is not a 1:1 replica of the app. It can’t be, as the browser can’t run Zoom’s APIs.Your Zoom environment due to the two separate browsers and multiple running contexts has its own limitations, many of which I have already mentioned.Testing in the client requires either each developer having a working local setup with nGrok, with multiple development copies of the app set up the exact same way, or a CI that generates builds on every push. The downside of the first approach is that it’s simply not scalable. Someone on the team will always have some tiny difference in their app settings in the Zoom Marketplace for things to fall over. The latter works, but it’s slow as you have to wait for every build to generate and in our case that took about 5 minutes / build, and when you do that 10–20 times a day, it adds up.Finally, automated testing can’t be done well / or at all on the native instance, as the flow includes logging into an account, adding an app, running it, then removing the app. Just logging in requires verification via a code sent through email, so we found that certain tests had to stay manual and done every day to avoid surprises.It’s safe to say that developers in our team spent about 10–20% of their time with testing complexities.App reviewsWhile in our experience, app reviews by Zoom were always swift — up to 48 hours — you will want to strategise what changes you make and when in the app settings on the Zoom Marketplace. All changes require a manual review by Zoom, so perhaps try to add as many APIs, events and whitelisted URLs as you can upfront. Work closely with your product manager and UX designer, and add everything you need before the story even gets into your backlog to save time while in development.",
  "image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*CagTotjAHmqlmknU",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003ch2 id=\"2188\"\u003eHelping developers focus on delivering value, while architecting a better Zoom application.\u003c/h2\u003e\u003cdiv\u003e\u003ca href=\"https://attilavago.medium.com/?source=post_page-----bd86c1d42cb3--------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Attila Vágó\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*Ilzy6aGvG__n7QzdkiL41A.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003ca href=\"https://engineering.prezi.com/?source=post_page-----bd86c1d42cb3--------------------------------\" rel=\"noopener  ugc nofollow\"\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003cp\u003e\u003cimg alt=\"Prezi Engineering\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*ecIYF5KMJj1G4-_pkFWy0g.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv\u003e\u003cp id=\"b84c\"\u003e\u003cspan\u003eI\u003c/span\u003e take it, if you’re reading this, you’ve made the decision or at the very least are toying with the idea of building a Zoom app. That’s great news for many Zoom users like myself who rely on the additional functionality and features these apps give our daily in and out of meeting experiences, but as a software engineer, you might want to understand first just what kind of architectural and coding decisions you need to take to build the best possible app.\u003c/p\u003e\u003cp id=\"d1d7\"\u003eOver the last year, we have \u003ca href=\"https://marketplace.zoom.us/apps/mj3SAtlRRgmXxenmORfKag\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ebuilt and released a Zoom app\u003c/a\u003e and added countless features, all of which taught us things we wish we knew upfront. In this article, I’ll share everything the team and I have bumped into along the way and, where appropriate, even provide code examples.\u003c/p\u003e\u003ch2 id=\"8674\"\u003eA quick primer on the Layers API\u003c/h2\u003e\u003cp id=\"c367\"\u003eThe best way to visualise what it really is, is to compare it to Photoshop. I know. It’s an unexpected comparison, but it makes a lot of sense. In Photoshop, everything is a layer. The same applies to Zoom’s Layers API. You have the background layer, you have the camera layer and finally at the top you get a web layer, and this final web layer is what makes the Layers API really cool and where \u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe JS SDK\u003c/a\u003e runs.\u003c/p\u003e\u003cp id=\"2a70\"\u003eAnd now onto the meaty part of this article. Prepare for some aha moments and interesting snippets of code. For content, we have used React with hooks, a bit of Context API here and there, no state management libraries (Redux, yuck), Radix components for most of the UI. For tests, we went with Cypress, but more on that in a section of its own.\u003c/p\u003e\u003ch2 id=\"488d\"\u003eExternal integrations\u003c/h2\u003e\u003cp id=\"f536\"\u003eIt’s nigh on impossible these days to build a web app and not rely on some sort of external integration, even if that’s something as simple as pulling a library from a CDN that isn’t on your domain.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eExamples of whitelisted URLs in the Zoom app settings. Screenshot by author.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9b7d\"\u003eWhile in the Marketplace app settings panel under App Credentials \u0026gt; Domain Allow List you’ll find the option to add the required domains, you’ll quickly find that not every domain is treated the same way. Here are a few examples:\u003c/p\u003e\u003cul\u003e\u003cli id=\"435e\"\u003e\u003ccode\u003egoogle.com\u003c/code\u003e—straight up not allowed because it’s too broad. This one is important as it can affect your ability to easily integrate Login with Google, use YouTube in the app, etc.\u003c/li\u003e\u003cli id=\"d398\"\u003e\u003ccode\u003e*.giphy.com\u003c/code\u003e—we found that the wildcard may or may not work, so we ended up adding all the 5 Giphy subdomains to the allow list like \u003ccode\u003emedia0.giphy.com\u003c/code\u003e, \u003ccode\u003emedia1.giphy.com\u003c/code\u003e, etc.\u003c/li\u003e\u003cli id=\"c222\"\u003e\u003ccode\u003eimg.icons8.com\u003c/code\u003e—this one isn’t disallowed, but it requires extra information as to why the app needs it.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2bda\"\u003eUnfortunately, you won’t always know what domains you will need to allow, so planning ahead may not be possible, but if it is, I would recommend adding all the required domains and subdomains to the Domain Allow List as soon as you can, as adding new ones also requires an app review by Zoom.\u003c/p\u003e\u003ch2 id=\"dcc4\"\u003eMultiple contexts, two browsers with limitations\u003c/h2\u003e\u003cp id=\"fae6\"\u003eAnyone who isn’t familiar with \u003ca href=\"https://github.com/chromiumembedded\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eCEF, should start reading up on it right away\u003c/a\u003e. The camera view on all operating systems uses CEF (Chromium Embedded Framework), that has a number of otherwise potentially very useful APIs disabled, like \u003ccode\u003enavigator.mediaDevices\u003c/code\u003e and all of its methods. This is also true for the \u003ccode\u003einMeeting\u003c/code\u003e and \u003ccode\u003einClient\u003c/code\u003e contexts, where on Mac it’s running the native browser, Safari. This means that getting extra control over audio and video or screen sharing isn’t possible. You also cannot throw popups and enable permissions to access various APIs like you would in the browser. In the camera view, even a simple \u003ccode\u003ealert(\u0026#39;Y U No work?\u0026#39;)\u003c/code\u003e won’t work.\u003c/p\u003e\u003cp id=\"68ff\"\u003eIn terms of working with the various contexts, your app will want to have the context change in a state variable, so you can watch it in your \u003ccode\u003euseEffect\u003c/code\u003e. A mature app will end up looking something like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d64c\"\u003euseEffect(async () =\u0026gt; {\u003cbr/\u003e // initiate zoom SDK, determine contexts, and do other stuff\u003cbr/\u003e}, [appContextChanged])\u003cp\u003eif (component === \u0026#39;Loading\u0026#39;) {\u003cbr/\u003e        // Only display spinner in sidebar and not camera webview\u003cbr/\u003e        return !navigator.userAgentData || navigator.userAgentData.platform === \u0026#39;\u0026#39; ? (\u003cbr/\u003e            \u0026lt;SpinnerWrapper\u0026gt;\u003cbr/\u003e                \u0026lt;Spinner size={40} width={4} marginTop=\u0026#34;0px\u0026#34; /\u0026gt;\u003cbr/\u003e            \u0026lt;/SpinnerWrapper\u0026gt;\u003cbr/\u003e        ) : (\u003c/p\u003e\u003cp\u003e        );\u003cbr/\u003e    } else if (component === \u0026#39;camera\u0026#39;) {\u003cbr/\u003e        return \u0026lt;CameraView zoomSdk={zoomSdk} /\u0026gt;;\u003cbr/\u003e    } else if (component === \u0026#39;sidepanel\u0026#39;) {\u003cbr/\u003e        return (\u003cbr/\u003e                \u0026lt;MeetingView zoomSdk={zoomSdk} initialCameraState={initialCameraState} /\u0026gt;\u003cbr/\u003e        );\u003cbr/\u003e    } else if (component === \u0026#39;sandbox\u0026#39;) {\u003cbr/\u003e        return \u0026lt;Sandbox /\u0026gt;;\u003cbr/\u003e    } else if (component === \u0026#39;preMeeting\u0026#39;) {\u003cbr/\u003e        return \u0026lt;PreMeeting appContextChanged={appContextChanged} zoomSdk={zoomSdk} /\u0026gt;;\u003cbr/\u003e    } else if (component === \u0026#39;unsupported\u0026#39;) {\u003cbr/\u003e        return \u0026lt;UnsupportedView /\u0026gt;;\u003cbr/\u003e    }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"9d49\"\u003eWatching \u003ccode\u003eappContextChanged\u003c/code\u003e is important, as we found that users often open the app from the main client rather than the meeting, which means, our UI had to update to accommodate that change. Of course, if you happen not to have a different UI for the two contexts, then you don’t have to, but I’d argue that you’re not taking advantage of the full capabilities of the Zoom SDK, as many APIs are not available in the main client, which in itself is a consideration to keep in mind.\u003c/p\u003e\u003ch2 id=\"8764\"\u003eInter-context communication\u003c/h2\u003e\u003cp id=\"c88e\"\u003eSpeaking of context, the Zoom SDK offers \u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#postMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ea handy \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#postMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003epostMessage\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#postMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e method\u003c/a\u003e and, paired with \u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#onMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ethe \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#onMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eonMessage\u003c/a\u003e\u003c/code\u003e\u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#onMessage\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e event\u003c/a\u003e, you essentially have a communication channel between the camera and the side panel, aka between CEF and Safari on a Mac for instance. That’s handy for countless things. You can send data, state changes, etc.\u003c/p\u003e\u003cp id=\"be2a\"\u003eIt does, however, come with one important limitation: the payload cannot exceed 512 KB, and that’s not a lot. In our case, that meant that we couldn’t send blobs, Base64 or DataUri images across contexts. It also meant, we had to really be efficient with the data we were sending. In our app, at one point, we were sending all slide data to the camera. Imagine 100 slides’ data, especially when it includes rich text data in HTML strings. That quickly adds up, and we found that out once we added the import feature for PDFs and PPTs that for each page generates a slide on the fly. It quickly turned into a bottleneck that we had to work around.\u003c/p\u003e\u003ch2 id=\"2667\"\u003eDebugging\u003c/h2\u003e\u003cp id=\"5871\"\u003eThere is one unexpected positive use though for \u003ccode\u003epostMessage\u003c/code\u003e and \u003ccode\u003eonMessage\u003c/code\u003e. You can use these for debugging. Given the fact that the CEF view cannot be inspected in the browser as it runs in the camera, we had to get creative and send all error messages from the camera to the meeting view. Maybe not ideal, but it certainly works and saved us countless hours of debugging.\u003c/p\u003e\u003cp id=\"7d82\"\u003eIt can be something as simple as telling the side-panel view that the camera is ready:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dbba\"\u003ezoomSdk.postMessage({\u003cbr/\u003e    message: \u0026#39;camera ready\u0026#39;,\u003cbr/\u003e});\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f9fc\"\u003eOr handling unhandled rejections like so:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"47e8\"\u003ewindow.onunhandledrejection = event =\u0026gt; {\u003cbr/\u003e            zoomSdk.postMessage({\u003cbr/\u003e                message: `UNHANDLED PROMISE REJECTION: ${event.reason}`,\u003cbr/\u003e       });\u003cbr/\u003e};\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"18b4\"\u003eLocal storage isn’t quite…\u003c/h2\u003e\u003cp id=\"f38b\"\u003eWe all love local storage, don’t we? It’s very useful to keep track of certain app states, information, etc. As long as you don’t delete the browser or deliberately clear local storage, the data is reliably accessible. That’s not quite the case when building Zoom apps.\u003c/p\u003e\u003cp id=\"7982\"\u003eSomething we found out the hard way — but in hindsight it makes all the sense in the world — is that, once the user logs out of Zoom or switches to another user, that local storage is cleared, or to be more accurate, you’re getting a new instance of the embedded browser, so all that data is gone. Logging back in with the previous user also doesn’t bring back the data.\u003c/p\u003e\u003cp id=\"adba\"\u003eWhat this all means for your app is that you’ll have no choice but to save some information into a database. That can be something as simple and easy to spin up like Firebase, but it is an extra lift, and you need to account for it. On that note, yes, Firebase is fully supported by Zoom apps.\u003c/p\u003e\u003ch2 id=\"f82e\"\u003eApp state\u003c/h2\u003e\u003cp id=\"551f\"\u003eSpeaking of state and data, while we didn’t use any state management libraries in our app, apart from React’s own context API, we did make another pragmatic decision around where to handle state. Given the fact that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"6f15\"\u003elocal storage isn’t really persistent\u003c/li\u003e\u003cli id=\"30bb\"\u003ethere are two separate browsers that can only communicate via \u003ccode\u003epostMessage\u003c/code\u003e\u003c/li\u003e\u003cli id=\"e36c\"\u003eand we cannot really inspect the camera view\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"829b\"\u003eWe decided that all the app state variables should stay in the side-panel view. This decision effectively rendered the camera view a passive component that only reacts to messages it receives from the \u003ccode\u003einMeeting\u003c/code\u003e context (side-panel).\u003c/p\u003e\u003ch2 id=\"8abe\"\u003eSidebar size\u003c/h2\u003e\u003cp id=\"a46b\"\u003eThe \u003ccode\u003einMeeting\u003c/code\u003e context is basically the side-panel or sidebar view. By default, its width is practically a mobile screen viewport width. That’s great for many things, but every so often you might find wishing for more real-estate, which \u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#expandApp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZoom gives you through \u003c/a\u003e\u003ccode\u003e\u003ca href=\"https://appssdk.zoom.us/classes/ZoomSdk.ZoomSdk.html#expandApp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eexpandApp\u003c/a\u003e\u003c/code\u003e. In fact, you can even toggle programmatically between collapsed and expanded modes, like so:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"fa64\"\u003eawait zoomSdk.expandApp({\u003cbr/\u003e     action: \u0026#39;expand\u0026#39; | \u0026#39;collapse\u0026#39;,\u003cbr/\u003e})\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"dc59\"\u003eThere is but one twist to this, though. It’s either or. There is no in-between width or a set percentage / pixel width option. This means that your designs have to be clever enough to work around that limitation. We opted to stick to the \u003ccode\u003ecollapse\u003c/code\u003e mode, as the \u003ccode\u003eexpand\u003c/code\u003e mode would have been far too wide.\u003c/p\u003e\u003ch2 id=\"3225\"\u003eMobile\u003c/h2\u003e\u003cp id=\"26c1\"\u003eWithin the app settings under Features, you will also find a toggle for mobile. You will likely — but wrongly — assume that turning it on is all that’s required to have your app running on phones and tablets. Besides the additional information we had to provide for Apple devices, we also quickly found out that the Layers API is only partially supported on iOS, iPadOS, and Android. Given how many people use these devices nowadays, you need to account for this in your design, development, and app distribution strategy. We opted to stick to just desktop.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eTurning on mobile client support. Screenshot by author.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"3e28\"\u003eTesting\u003c/h2\u003e\u003cp id=\"22c3\"\u003eI briefly alluded to testing, but it deserves a couple more paragraphs. Honestly, this will probably be the biggest bottleneck you’ll have to account for, and there are several reasons for that:\u003c/p\u003e\u003cul\u003e\u003cli id=\"2f4b\"\u003eYour local browser sandbox is not a 1:1 replica of the app. It can’t be, as the browser can’t run Zoom’s APIs.\u003c/li\u003e\u003cli id=\"86fb\"\u003eYour Zoom environment due to the two separate browsers and multiple running contexts has its own limitations, many of which I have already mentioned.\u003c/li\u003e\u003cli id=\"60b0\"\u003eTesting in the client requires either each developer having a working local setup with nGrok, with multiple development copies of the app set up the exact same way, or a CI that generates builds on every push. The downside of the first approach is that it’s simply not scalable. Someone on the team will always have some tiny difference in their app settings in the Zoom Marketplace for things to fall over. The latter works, but it’s slow as you have to wait for every build to generate and in our case that took about 5 minutes / build, and when you do that 10–20 times a day, it adds up.\u003c/li\u003e\u003cli id=\"573b\"\u003eFinally, automated testing can’t be done well / or at all on the native instance, as the flow includes logging into an account, adding an app, running it, then removing the app. Just logging in requires verification via a code sent through email, so we found that certain tests had to stay manual and done every day to avoid surprises.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3eba\"\u003eIt’s safe to say that developers in our team spent about 10–20% of their time with testing complexities.\u003c/p\u003e\u003ch2 id=\"6c89\"\u003eApp reviews\u003c/h2\u003e\u003cp id=\"3ebd\"\u003eWhile in our experience, app reviews by Zoom were always swift — up to 48 hours — you will want to strategise what changes you make and when in the app settings on the Zoom Marketplace. All changes require a manual review by Zoom, so perhaps try to add as many APIs, events and whitelisted URLs as you can upfront. Work closely with your product manager and UX designer, and add everything you need before the story even gets into your backlog to save time while in development.\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2023-10-09T14:41:09.172Z",
  "modifiedTime": null
}
