{
  "id": "2ccf247a-4a4e-4362-b0ce-cdf1d9c3b387",
  "title": "Java 24: Build Games, Prototypes, Utilities, and More—With Less Boilerplate",
  "link": "https://blog.jetbrains.com/idea/2025/02/java-24-build-games-prototypes-utilities-and-more-with-less-boilerplate/",
  "description": "At ten, I sat in my school’s computer lab, in awe of a line drawing on the screen—my own code had brought it to life. “Yay! I coded that! I can code anything!”, I thought. My teacher, surprised, asked, “Wow! You did that?” It felt like magic, but it was more than that—I realized I […]",
  "author": "Mala Gupta",
  "published": "Tue, 25 Feb 2025 12:31:20 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "idea",
    "implicit-classes",
    "java",
    "java-24"
  ],
  "byline": "Mala Gupta",
  "length": 10872,
  "excerpt": "At ten, I sat in my school’s computer lab, in awe of a line drawing on the screen—my own code had brought it to life. “Yay! I coded that! I can code anything!”, I thought. My teacher, surprised, asked",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "IntelliJ IDEA – the IDE for Professional Development in Java and Kotlin IntelliJ IDEAJava 24: Build Games, Prototypes, Utilities, and More—With Less Boilerplate At ten, I sat in my school’s computer lab, in awe of a line drawing on the screen—my own code had brought it to life. “Yay! I coded that! I can code anything!”, I thought. My teacher, surprised, asked, “Wow! You did that?” It felt like magic, but it was more than that—I realized I could turn ideas into reality through code. At that moment, I knew I was going to be a developer. Now, imagine sparking that same excitement for new Java developers with simple, fun programs (such as games)—made easier by Java’s modern features that cut boilerplate code. These new features are not just for beginners; experienced developers can write cleaner, faster code for tasks like building prototypes, filtering logs, scraping stock prices, or creating powerful utilities. Newer features, such as, Simple Source Files \u0026 Instance Main Methods (JEP 495) and Module Import Declarations (JEP 494) cut down unnecessary complexity. In this blog post, I’ll demonstrate these features through practical use cases. If you’re new to simple source files and instance main methods, check out my introductory blog post on this topic.  Let’s get started. 1. Build Games and create interesting graphics In this section, I’ll talk about building classic games and generating patterns, such as: Drawing Concentric circles – A fun animation to watch in action. Hangman – Guess a word, one letter at a time. Treasure hunt – Find the location of the hidden treasure. Rock-Papper-Scissors – Who hasn’t played this classic? Dots and Boxes – Join lines to complete boxes and claim territory. The gif below shows these games and patterns in action. If you like them, feel free to try them out using the source code hosted here. I deliberately didn’t include the full source code for all these games in this blog post, as it’s quite lengthy and could distract from the main point I’m trying to make. I’ve included these games to highlight how easy it is to get started with Java—and how you can build games like these and much more. Some of these games are terminal-based, such as Hangman and Treasure Hunt (implicit classes), while others have a Swing-based UI (regular classes). If you ask me, my favorite game during my growing-up years was Dots and Boxes—I have fond memories of playing it with my friends at school in a notebook. The codebase of these games demonstrates that implicit classes and instance main methods can be used not just to get started but also to build much more complex applications. These classes aren’t overly simple; they include sophisticated algorithm implementations using control flow statements. Speaking of algorithms, I don’t think the code for the Dots and Boxes game currently implements a strong algorithm for the computer opponent. I’m accepting pull requests if you’d like to try improving it—the game is hosted here. 2. Processing log files Imagine you need to extract error messages (containing the text ‘ERROR’) from a log file and save them to a separate file for later review. Here’s a section of the log file, with the target lines highlighted: You could accomplish this task by using (just) the following executable code: void main() throws IOException { List\u003cString\u003e errors = Files.readAllLines(Path.of(\"src/main/logs/app.log\")) .stream() .filter(line -\u003e line.contains(\"ERROR\")) .collect(Collectors.toList()); Files.write(Path.of(\"src/main/logs/error.log\"), errors); } The following gif shows the contents of app.log, execution of the preceding code in IntelliJ IDEA (.java file without declaration of a class) and the contents of the newly created file, that is, errors.log: Reading a file, filtering its contents, and creating another file—all with just a few lines of code. Isn’t that great? This example reads a .log file, but you could easily adapt it to read other formats, such as .csv, .json, and more. The next section covers what happens behind the scenes and why. If you’re already familiar with these details, feel free to skip ahead to the next practical example. Behind the scenes As a developer, the code shown in the previous section offers multiple benefits: You can focus on the logic of reading app.log and creating error.log. You no longer need to create an explicit enclosing class to execute this code. It is automatically defined in an implicit class (similar to how a default package works) The signature of the implicit main method is shorter. You don’t need to write explicit import statements for Java I/O classes. This also applies to all classes or interfaces from the java.base module, as an implicit class automatically imports any package exported by java.base (on demand). Overall, the code is shorter, making it easier to read and write.  If you prefer command prompt, you could also avail the benefits of skipping compilation of this class and execute the code using the command java \u003cname of your source file\u003e. If you are using your favorite IDE, such as IntelliJ IDEA, you can execute your code using a single click by using the Run feature (by either using the icon or the related shortcut). Are you wondering how the code will change without these newer Java features-implicit class, instance main method, and module import declaration). IntelliJ IDEA includes context actions to convert an implicit class to a regular class and vice versa.  The following gif shows what happens when you convert the preceding code implicit class to a regular class by using the context action ‘Convert implicitly declared class into a regular class’ on method main(): You might wonder how significant these changes are and why you would even want to convert an implicit class to a regular class. Converting an implicit class to a regular class makes sense when you’re ready to work with classes more formally, integrate the code into another project, or package it for reuse. The conversion might not seem like a big change at first, especially since it imports the java.base module by default, instead of importing individual classes or interfaces from packages like io, nio, or util, as shown below: import java.io.IOException; import java.nio.file.Files; import java.nio.file.Path; import java.util.List; import java.util.stream.Collectors; The module java.base is automatically imported in implicit classes, so they don’t need import statements for using the classes and interfaces mentioned in the preceding code. Just in case you are curious to find out which modules are exported by the module java.base, you could access that information by navigating to its declaration, as shown in the following gif: Importing a single module vc. Loading individual classes and interfaces also lowers the cognitive load when you are reading and writing your code.  3. Building utilities, such as a Stock Price Scraper Imagine you need to look up some stock prices. You could access a website to do so, or, you could also spin up a single method (defined in an implicit class) to do that, as follows: import org.jsoup.Jsoup; import org.jsoup.nodes.Document; void main() throws IOException { Document doc = Jsoup.connect(\"https://finance.yahoo.com/quote/AAPL\") .get(); String stockPrice = doc.select(\".price\").text(); println(\"Stock Price: \" + stockPrice); } Here’s the output of executing this code snippet: I created an additional method in the same source file to format the text received from the pinging the website: public static String formatAndDisplayStockPrice(String stockPrice) { if (stockPrice == null || stockPrice.isEmpty()) { System.out.println(\"No stock price data available.\"); return null; } String[] parts = stockPrice.split(\"\\\\s+\"); StringBuilder formattedOutput = new StringBuilder(); try { formattedOutput.append(String.format(\"\"\" ---------- Stock Price Information ---------- Stock Price (At close): %s Change: %s (%s%%) Closing Time: %s %s %s %s After Hours Price: %s Change (After hours): %s (%s) After Hours Time: %s %s %s ----------- Additional Information ----------- \"\"\", parts[2], parts[3], parts[4], parts[6], parts[7], parts[8], parts[9], parts[10], parts[11], parts[12], parts[14], parts[15], parts[16])); for (int i = 17; i \u003c parts.length; i++) { formattedOutput.append(String.format(\"Metric %d: %s%n\", (i - 16), parts[i])); } } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"Unexpected format in stock price data. Raw data: \" + stockPrice); } return formattedOutput.toString(); } To enable your runtime to find the classes imported from the packages org.jsoup and org.jsoup.nodes, you can either add them to your classpath or include them as dependencies in your Maven or Gradle build configuration. The examples shown in this blog post are just the tip of the iceberg—you can create many other utilities using these features. Summary Newer features in Java 24, such as, Simple Source Files \u0026 Instance Main Methods (JEP 495) and Module Import Declarations (JEP 494) aren't just about cutting down boilerplate code. They also reduce the cognitive load of getting started with Java, making it easier to dive into coding—whether you're creating fun games, building practical scripts, or developing prototypes and utilities faster. If you haven’t tried these features yet, you’re missing out on a lot of fun! Subscribe to IntelliJ IDEA Blog updates Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/02/jb-social_share_blog_1280x720_en-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/idea/\"\u003e\n                            \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2019/01/IntelliJ-IDEA-1.svg\" alt=\"Idea logo\"/\u003e\n                                                                                                \n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eIntelliJ IDEA – the IDE for Professional Development in Java and Kotlin\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/idea/category/idea/\"\u003eIntelliJ IDEA\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"major-updates\"\u003eJava 24: Build Games, Prototypes, Utilities, and More—With Less Boilerplate\u003c/h2\u003e                    \n                    \n\u003cp\u003eAt ten, I sat in my school’s computer lab, in awe of a line drawing on the screen—my own code had brought it to life. \u003cem\u003e“Yay! I coded that! I can code anything!”\u003c/em\u003e, I thought. My teacher, surprised, asked, \u003cem\u003e“Wow! You did that?” \u003c/em\u003eIt felt like magic, but it was more than that—I realized I could turn ideas into reality through code. At that moment, I knew I was going to be a developer.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow, imagine sparking that same excitement for new Java developers with simple, fun programs (such as games)—made easier by Java’s modern features that cut boilerplate code. These new features are not just for beginners; experienced developers can write cleaner, faster code for tasks like building prototypes, filtering logs, scraping stock prices, or creating powerful utilities.\u003c/p\u003e\n\n\n\n\u003cp\u003eNewer features, such as, \u003ca href=\"https://openjdk.org/jeps/495\" target=\"_blank\" rel=\"noopener\"\u003eSimple Source Files \u0026amp; Instance Main Methods (JEP 495)\u003c/a\u003e and \u003ca href=\"https://openjdk.org/jeps/494\" target=\"_blank\" rel=\"noopener\"\u003eModule Import Declarations (JEP 494)\u003c/a\u003e cut down unnecessary complexity. In this blog post, I’ll demonstrate these features through practical use cases. If you’re new to simple source files and instance main methods, check out my \u003ca href=\"https://blog.jetbrains.com/idea/2024/02/helloworld-and-main-meet-minimalistic/\"\u003eintroductory blog post\u003c/a\u003e on this topic. \u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s get started.\u003c/p\u003e\n\n\n\u003ch2\u003e1. Build Games and create interesting graphics\u003c/h2\u003e\n\n\n\u003cp\u003eIn this section, I’ll talk about building classic games and generating patterns, such as: \u003c/p\u003e\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/ConcentricCirclesDrawOnClick.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eDrawing Concentric circles\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e – A fun animation to watch in action.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/HangmanGame.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eHangman\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e – Guess a word, one letter at a time.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/TreasureHunt.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eTreasure hunt\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e – Find the location of the hidden treasure.\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/RockPaperScissorsSwingUI.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eRock-Papper-Scissors\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e – Who hasn’t played this classic?\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/DotsAndBoxes.java\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003eDots and Boxes\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e – Join lines to complete boxes and claim territory.\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cspan\u003eThe gif below shows these games and patterns in action. If you like them, feel free to try them out using the source code hosted \u003c/span\u003e\u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24\" target=\"_blank\" rel=\"noopener\"\u003e\u003cspan\u003ehere\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e. I deliberately didn’t include the full source code for all these games in this blog post, as it’s quite lengthy and could distract from the main point I’m trying to make.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eI’ve included these games to highlight how easy it is to get started with Java—and how you can build games like these and much more.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/games2.gif\" alt=\"\" width=\"2496\" height=\"1812\"/\u003e\u003c/p\u003e\n\n\n\u003cp\u003eSome of these games are terminal-based, such as Hangman and Treasure Hunt (implicit classes), while others have a Swing-based UI (regular classes). If you ask me, my favorite game during my growing-up years was Dots and Boxes—I have fond memories of playing it with my friends at school in a notebook.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe codebase of these games demonstrates that implicit classes and instance main methods can be used not just to get started but also to build much more complex applications. These classes aren’t overly simple; they include sophisticated algorithm implementations using control flow statements.\u003c/p\u003e\n\n\n\n\u003cp\u003eSpeaking of algorithms, I don’t think the code for the Dots and Boxes game currently implements a strong algorithm for the computer opponent. I’m accepting pull requests if you’d like to try improving it—the game is hosted \u003ca href=\"https://github.com/malagupta/HelloWorldProjJava24/blob/master/src/DotsAndBoxes.java\" target=\"_blank\" rel=\"noopener\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\n\u003ch2\u003e2. Processing log files\u003c/h2\u003e\n\n\n\u003cp\u003eImagine you need to extract error messages (containing the text ‘ERROR’) from a log file and save them to a separate file for later review. Here’s a section of the log file, with the target lines highlighted:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/log-file.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou could accomplish this task by using (just) the following executable code:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003evoid main() throws IOException {\n    List\u0026lt;String\u0026gt; errors = Files.readAllLines(Path.of(\u0026#34;src/main/logs/app.log\u0026#34;))\n                               .stream()\n                               .filter(line -\u0026gt; line.contains(\u0026#34;ERROR\u0026#34;))\n                               .collect(Collectors.toList());\n    Files.write(Path.of(\u0026#34;src/main/logs/error.log\u0026#34;), errors);\n}\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe following gif shows the contents of app.log, execution of the preceding code in IntelliJ IDEA (.java file without declaration of a class) and the contents of the newly created file, that is, errors.log:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/log-file.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eReading a file, filtering its contents, and creating another file—all with just a few lines of code. Isn’t that great? This example reads a .log file, but you could easily adapt it to read other formats, such as .csv, .json, and more.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe next section covers what happens behind the scenes and why. If you’re already familiar with these details, feel free to skip ahead to the next practical example.\u003c/p\u003e\n\n\n\u003ch3\u003eBehind the scenes\u003c/h3\u003e\n\n\n\u003cp\u003eAs a developer, the code shown in the previous section offers multiple benefits:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eYou can focus on the logic of reading app.log and creating error.log.\u003c/li\u003e\n\n\n\n\u003cli\u003eYou no longer need to create an explicit enclosing class to execute this code. It is automatically defined in an implicit class (similar to how a default package works)\u003c/li\u003e\n\n\n\n\u003cli\u003eThe signature of the implicit main method is shorter.\u003c/li\u003e\n\n\n\n\u003cli\u003eYou don’t need to write explicit import statements for Java I/O classes. This also applies to all classes or interfaces from the java.base module, as an implicit class automatically imports any package exported by java.base (on demand).\u003c/li\u003e\n\n\n\n\u003cli\u003eOverall, the code is shorter, making it easier to read and write. \u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf you prefer command prompt, you could also avail the benefits of skipping compilation of this class and execute the code using the command java \u0026lt;name of your source file\u0026gt;. If you are using your favorite IDE, such as IntelliJ IDEA, you can execute your code using a single click by using the Run feature (by either using the icon or the related shortcut).\u003c/p\u003e\n\n\n\n\u003cp\u003eAre you wondering how the code will change without these newer Java features-implicit class, instance main method, and module import declaration). IntelliJ IDEA includes context actions to convert an implicit class to a regular class and vice versa. \u003c/p\u003e\n\n\n\n\u003cp\u003eThe following gif shows what happens when you convert the preceding code implicit class to a regular class by using the context action ‘Convert implicitly declared class into a regular class’ on method main():\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"2481\" height=\"1812\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/convert-reg-class-module.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eYou might wonder how significant these changes are and why you would even want to convert an implicit class to a regular class. Converting an implicit class to a regular class makes sense when you’re ready to work with classes more formally, integrate the code into another project, or package it for reuse.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe conversion might not seem like a big change at first, especially since it imports the java.base module by default, instead of importing individual classes or interfaces from packages like io, nio, or util, as shown below:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe module java.base is automatically imported in implicit classes, so they don’t need import statements for using the classes and interfaces mentioned in the preceding code. Just in case you are curious to find out which modules are exported by the module java.base, you could access that information by navigating to its declaration, as shown in the following gif:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" width=\"2496\" height=\"1812\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/java-base-mod.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eImporting a single module vc. Loading individual classes and interfaces also lowers the cognitive load when you are reading and writing your code. \u003c/p\u003e\n\n\n\n\u003ch2\u003e3. Building utilities, such as a Stock Price Scraper\u003c/h2\u003e\n\n\n\n\u003cp\u003eImagine you need to look up some stock prices. You could access a website to do so, or, you could also spin up a single method (defined in an implicit class) to do that, as follows:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003eimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\n\nvoid main() throws IOException {\n    Document doc = Jsoup.connect(\u0026#34;https://finance.yahoo.com/quote/AAPL\u0026#34;)\n                        .get();\n    String stockPrice = doc.select(\u0026#34;.price\u0026#34;).text();\n    println(\u0026#34;Stock Price: \u0026#34; + stockPrice);\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eHere’s the output of executing this code snippet:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" loading=\"lazy\" width=\"2496\" height=\"1812\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/02/stock-prices.gif\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003eI created an additional method in the same source file to format the text received from the pinging the website:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"generic\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003epublic static String formatAndDisplayStockPrice(String stockPrice) {\n    if (stockPrice == null || stockPrice.isEmpty()) {\n        System.out.println(\u0026#34;No stock price data available.\u0026#34;);\n        return null;\n    }\n    String[] parts = stockPrice.split(\u0026#34;\\\\s+\u0026#34;);\n    StringBuilder formattedOutput = new StringBuilder();\n    try {\n        formattedOutput.append(String.format(\u0026#34;\u0026#34;\u0026#34;\n            ---------- Stock Price Information ----------\n            Stock Price (At close): %s\n            Change: %s (%s%%)\n            Closing Time: %s %s %s %s\n            After Hours Price: %s\n            Change (After hours): %s (%s)\n            After Hours Time: %s %s %s\n            ----------- Additional Information -----------\n            \u0026#34;\u0026#34;\u0026#34;, parts[2], parts[3], parts[4], parts[6], parts[7], parts[8],\n                 parts[9], parts[10], parts[11], parts[12], parts[14], parts[15], parts[16]));\n        for (int i = 17; i \u0026lt; parts.length; i++) {\n            formattedOutput.append(String.format(\u0026#34;Metric %d: %s%n\u0026#34;, (i - 16), parts[i]));\n        }\n    } catch (ArrayIndexOutOfBoundsException e) {\n        System.out.println(\u0026#34;Unexpected format in stock price data. Raw data: \u0026#34; + stockPrice);\n    }\n    return formattedOutput.toString();\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eTo enable your runtime to find the classes imported from the packages org.jsoup\u003c/p\u003e\n\n\n\n\u003cp\u003eand org.jsoup.nodes, you can either add them to your classpath or include them as dependencies in your Maven or Gradle build configuration.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe examples shown in this blog post are just the tip of the iceberg—you can create many other utilities using these features.\u003c/p\u003e\n\n\n\n\u003ch2\u003e\u003cstrong\u003eSummary\u003c/strong\u003e\u003c/h2\u003e\n\n\n\n\u003cp\u003eNewer features in Java 24, such as, \u003ca href=\"https://openjdk.org/jeps/495\" target=\"_blank\" rel=\"noopener\"\u003eSimple Source Files \u0026amp; Instance Main Methods (JEP 495)\u003c/a\u003e and \u003ca href=\"https://openjdk.org/jeps/494\" target=\"_blank\" rel=\"noopener\"\u003eModule Import Declarations (JEP 494)\u003c/a\u003e aren\u0026#39;t just about cutting down boilerplate code. They also reduce the cognitive load of getting started with Java, making it easier to dive into coding—whether you\u0026#39;re creating fun games, building practical scripts, or developing prototypes and utilities faster.\u003c/p\u003e\n\n\n\n\u003cp\u003eIf you haven’t tried these features yet, you’re missing out on a lot of fun!\u003c/p\u003e\n                    \n                                                                \n                                                                                                                                \u003cdiv\u003e\n                                \u003cdiv\u003e\n                                                                            \u003ch4\u003eSubscribe to IntelliJ IDEA Blog updates\u003c/h4\u003e\n                                                                                                            \n                                \u003c/div\u003e\n                                \n                                \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg\" alt=\"image description\"/\u003e\n                                                                    \u003c/p\u003e\n                            \u003c/div\u003e\n                                                            \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": null,
  "modifiedTime": null
}
