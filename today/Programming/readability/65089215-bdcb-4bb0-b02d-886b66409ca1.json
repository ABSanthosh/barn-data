{
  "id": "65089215-bdcb-4bb0-b02d-886b66409ca1",
  "title": "Meta’s Full-stack HHVM optimizations for GenAI",
  "link": "https://engineering.fb.com/2025/05/20/web/metas-full-stack-hhvm-optimizations-for-genai/",
  "description": "As Meta has launched new, innovative products leveraging generative AI (GenAI), we need to make sure the underlying infrastructure components evolve along with it. Applying infrastructure knowledge and optimizations have allowed us to adapt to changing product requirements, delivering a better product along the way. Ultimately, our infrastructure systems need to balance our need to [...] Read More... The post Meta’s Full-stack HHVM optimizations for GenAI appeared first on Engineering at Meta.",
  "author": "",
  "published": "Tue, 20 May 2025 16:00:29 +0000",
  "source": "https://engineering.fb.com/feed/",
  "categories": [
    "Data Infrastructure",
    "DevInfra",
    "Production Engineering",
    "Web"
  ],
  "byline": "By Phil Lopreiato, Zach Zundel",
  "length": 6091,
  "excerpt": "As Meta has launched new, innovative products leveraging generative AI (GenAI), we need to make sure the underlying infrastructure components evolve along with it. Applying infrastructure knowledge…",
  "siteName": "Engineering at Meta",
  "favicon": "",
  "text": "As Meta has launched new, innovative products leveraging generative AI (GenAI), we need to make sure the underlying infrastructure components evolve along with it. Applying infrastructure knowledge and optimizations have allowed us to adapt to changing product requirements, delivering a better product along the way. Ultimately, our infrastructure systems need to balance our need to ship high-quality experiences with a need to run systems sustainability. Splitting GenAI inference traffic out into a dedicated WWW tenant, which allows specialized runtime and warm-up configuration, has enabled us to meet both of those goals while delivering a 30% improvement in latency.  Who we are As the Web Foundation team, we operate Meta’s monolithic web tier, running Hack. The team is composed of cross-functional engineers who make sure the infrastructure behind the web tier is healthy and well designed. We jump into incident response, work on some of the most complex areas of the infrastructure, and help build whatever we need to keep the site happily up and running. To accomplish this, we have established a series of best practices on being a “good citizen” of the shared tier. We need to ensure that all requests comply with these guidelines to prevent issues from spilling over and affecting other teams’ products. One core rule is the request runtime—limiting a request to 30 seconds of execution. This is a consequence of the HHVM (HipHop Virtual Machine) runtime—each request has a corresponding worker thread, of which there is a finite number. To ensure there are always threads available to serve incoming requests, we need to balance the resources available on each host with its expected throughput. If requests are taking too long, there will be fewer available threads to process new requests, leading to user-visible unavailability.  The changing landscape Classically, webservers at Meta are optimized for serving front-end requests—rendering webpages and serving GraphQL queries. These requests’ latency is typically measured in hundreds of milliseconds to seconds (substantially below the 30-second limit), which enables hosts to process approximately 500 queries per second. Additionally, a web server will spend about two-thirds of its time doing input/output (I/O), and the remaining third doing CPU work. This fact has influenced the design of the Hack language, which supports asyncio, a type of cooperative multi-tasking, and all the core libraries support these primitives to increase performance and decrease the amount of time the CPU is sitting idle, waiting for I/O. GenAI products, especially LLMs, have a different set of requirements. These are driven by the core inference flow: The model responds with a stream of tokens that can take seconds or minutes to complete. A user may see this as a chatbot “typing” a response. This isn’t an effect to make our products seem friendlier; it’s the speed at which our models think! After a user submits a query to the model, we need to start streaming these responses back to the user as fast as possible. On top of that, the total latency of the request is now substantially longer (measured in seconds). These properties have two effects on the infrastructure—minimal overhead on the critical path before calling the LLM, and a long duration for the rest of the request, most of which is spent waiting on I/O. (See Figures 1 and 2 below). Figure 1: Percent of time spent on I/O, typical requests (~70%) vs. GenAI (~90%). Figure 2: Overall request latency CDF; typical requests vs. GenAI. A series of optimizations This shift in requirements allowed Web Foundation to reexamine the rules of running the monolithic web tier. We then launched a dedicated web tenant (a standalone deployment of WWW) that allowed custom configuration, which we could better tune to the needs of the workload. Request timeout First, running on an isolated web tier allowed us to increase the runtime limit for GenAI requests. This is a straightforward change, but it allowed us to isolate the longer-running traffic to avoid adverse impacts on the rest of the production tier. This way, we can avoid requests timing out if inference takes longer than 30 seconds. Thread-pool sizing Running requests for longer means there is reduced availability of worker threads (which, remember, map 1:1 with processed requests). Since webservers have a finite amount of memory, we can divide the total memory available by the per-request memory limit to get a peak number of active requests; this in turn tells us how many requests we can execute simultaneously. We ended up running with approximately 1000 threads on GenAI hosts, as compared to a couple of hundred on normal webservers. JIT cache and “jumpstart” HHVM is a just-in-time (JIT) interpreted language, which means the first time a given function executes, the machine needs to compile it to lower-level machine code for execution. Additionally, a technique called Jump-Start allows a webserver to seed its JIT cache with outputs from a previously warmed server. By allowing GenAI hosts to use Jump-Start profiles from the main web tier, we are able to greatly speed up execution, even if the code overlap is not identical.  Request warm-up HHVM also supports the execution of dummy requests at server startup, which we can execute, and then we can discard the results. The intent here is to warm non-code caches within the webserver. Configuration values and service discovery info are normally fetched inline the first time they are needed and then cached within the webserver. By fetching and caching this information in warm-up requests, we prevent our users from observing the latency of these initial fetches.  Shadow traffic Finally, Meta heavily uses real-time configuration to control feature rollouts, which means that jumpstart profiles consumed at startup time might not cover all future code paths the server will execute. To maintain coverage in the steady state, we also added request shadowing, so we can ensure that gating changes are still covered in the JIT cache.",
  "image": "https://engineering.fb.com/wp-content/uploads/2023/10/Eng-Blog-Self-Serve-Hero-Images-DEBUGGING-201-Teale.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\n\t\t\u003cp\u003e\u003cspan\u003eAs Meta has launched new, innovative products leveraging generative AI (GenAI), we need to make sure the underlying infrastructure components evolve along with it. Applying infrastructure knowledge and optimizations have allowed us to adapt to changing product requirements, delivering a better product along the way. Ultimately, our infrastructure systems need to balance our need to ship high-quality experiences with a need to run systems sustainability. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eSplitting GenAI inference traffic out into a dedicated WWW tenant, which allows specialized runtime and warm-up configuration, has enabled us to meet both of those goals while delivering a 30% improvement in latency. \u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003ciframe title=\"Splitting the Monolith | Phil Lopreiato \u0026amp; Zach Zundel\" width=\"1778\" height=\"1000\" src=\"https://www.youtube.com/embed/QBIqvBy3lqg?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eWho we are\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eAs the Web Foundation team, we operate Meta’s monolithic web tier, running \u003c/span\u003e\u003ca href=\"https://hacklang.org/\"\u003e\u003cspan\u003eHack\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e. The team is composed of \u003c/span\u003e\u003cspan\u003ecross-functional engineers who make sure the infrastructure behind the web tier is healthy and well designed. \u003c/span\u003e\u003cspan\u003eWe jump into incident response, work on some of the most complex areas of the infrastructure, and help build whatever we need to keep the site happily up and running.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eTo accomplish this, we have established a series of best practices on being a “good citizen” of the shared tier. We need to ensure that all requests comply with these guidelines to prevent issues from spilling over and affecting other teams’ products. One core rule is the request runtime—limiting a request to 30 seconds of execution. This is a consequence of the \u003c/span\u003e\u003ca href=\"https://docs.hhvm.com/hhvm/\"\u003e\u003cspan\u003eHHVM (\u003c/span\u003e\u003cspan\u003eHipHop Virtual Machine) \u003c/span\u003e\u003cspan\u003eruntime\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e—each request has a corresponding worker thread, of which there is a finite number. To ensure there are always threads available to serve incoming requests, we need to balance the resources available on each host with its expected throughput. If requests are taking too long, there will be fewer available threads to process new requests, leading to user-visible unavailability. \u003c/span\u003e\u003c/p\u003e\n\u003ch2\u003e\u003cspan\u003eThe changing landscape\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eClassically, webservers at Meta are optimized for serving front-end requests—rendering webpages and serving GraphQL queries. These requests’ latency is typically measured in hundreds of milliseconds to seconds (substantially below the 30-second limit), which enables hosts to process approximately 500 queries per second.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eAdditionally, a web server will spend about two-thirds of its time doing input/output (I/O), and the remaining third doing CPU work. This fact has influenced the design of the Hack language, which supports \u003c/span\u003e\u003cspan\u003easyncio\u003c/span\u003e\u003cspan\u003e, a type of cooperative multi-tasking, and all the core libraries support these primitives to increase performance and decrease the amount of time the CPU is sitting idle, waiting for I/O.\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan\u003eGenAI products, especially LLMs, have a different set of requirements. These are driven by the core inference flow: The model responds with a stream of tokens that can take seconds or minutes to complete. A user may see this as a chatbot “typing” a response. This isn’t an effect to make our products seem friendlier; it’s the speed at which our models think! After a user submits a query to the model, we need to start streaming these responses back to the user as fast as possible. On top of that, the total latency of the request is now substantially longer (measured in seconds). These properties have two effects on the infrastructure—minimal overhead on the critical path before calling the LLM, and a long duration for the rest of the request, most of which is spent waiting on I/O. (See Figures 1 and 2 below).\u003c/span\u003e\u003c/p\u003e\n\u003cfigure id=\"attachment_22500\" aria-describedby=\"caption-attachment-22500\"\u003e\u003cimg decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?w=1024\" alt=\"\" width=\"600\" height=\"288\" srcset=\"https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png 1419w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?resize=916,440 916w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?resize=768,369 768w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?resize=1024,491 1024w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?resize=96,46 96w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-figure-1.png?resize=192,92 192w\" sizes=\"(max-width: 992px) 100vw, 62vw\"/\u003e\u003cfigcaption id=\"caption-attachment-22500\"\u003eFigure 1: Percent of time spent on I/O, typical requests (~70%) vs. GenAI (~90%).\u003c/figcaption\u003e\u003c/figure\u003e\n\n\u003cfigure id=\"attachment_22501\" aria-describedby=\"caption-attachment-22501\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?w=1024\" alt=\"\" width=\"600\" height=\"395\" srcset=\"https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png 1314w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?resize=916,602 916w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?resize=768,505 768w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?resize=1024,673 1024w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?resize=96,63 96w, https://engineering.fb.com/wp-content/uploads/2025/05/Meta-GenAI-HHVM-image3.png?resize=192,126 192w\" sizes=\"auto, (max-width: 992px) 100vw, 62vw\"/\u003e\u003cfigcaption id=\"caption-attachment-22501\"\u003eFigure 2: Overall request latency CDF; typical requests vs. GenAI.\u003c/figcaption\u003e\u003c/figure\u003e\n\u003ch2\u003e\u003cspan\u003eA series of optimizations\u003c/span\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cspan\u003eThis shift in requirements allowed Web Foundation to reexamine the rules of running the monolithic web tier. We then launched a dedicated web tenant (a standalone deployment of WWW) that allowed custom configuration, which we could better tune to the needs of the workload.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eRequest timeout\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eFirst, running on an isolated web tier allowed us to increase the runtime limit for GenAI requests. This is a straightforward change, but it allowed us to isolate the longer-running traffic to avoid adverse impacts on the rest of the production tier. This way, we can avoid requests timing out if inference takes longer than 30 seconds.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eThread-pool sizing\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eRunning requests for longer means there is reduced availability of worker threads (which, remember, map 1:1 with processed requests). Since webservers have a finite amount of memory, we can divide the total memory available by the per-request memory limit to get a peak number of active requests; this in turn tells us how many requests we can execute simultaneously. We ended up running with approximately 1000 threads on GenAI hosts, as compared to a couple of hundred on normal webservers.\u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eJIT cache and “jumpstart”\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eHHVM is a just-in-time (JIT) interpreted language, which means the first time a given function executes, the machine needs to compile it to lower-level machine code for execution. Additionally, a technique called \u003c/span\u003e\u003ca href=\"https://engineering.fb.com/2021/03/03/developer-tools/hhvm-jump-start/\"\u003e\u003cspan\u003eJump-Start\u003c/span\u003e\u003c/a\u003e\u003cspan\u003e allows a webserver to seed its JIT cache with outputs from a previously warmed server. By allowing GenAI hosts to use Jump-Start profiles from the main web tier, we are able to greatly speed up execution, even if the code overlap is not identical. \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eRequest warm-up\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eHHVM also supports the execution of dummy requests at server startup, which we can execute, and then we can discard the results. The intent here is to warm non-code caches within the webserver. Configuration values and service discovery info are normally fetched inline the first time they are needed and then cached within the webserver. By fetching and caching this information in warm-up requests, we prevent our users from observing the latency of these initial fetches. \u003c/span\u003e\u003c/p\u003e\n\u003ch3\u003e\u003cspan\u003eShadow traffic\u003c/span\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cspan\u003eFinally, Meta heavily uses real-time configuration to control feature rollouts, which means that jumpstart profiles consumed at startup time might not cover all \u003c/span\u003e\u003ci\u003e\u003cspan\u003efuture\u003c/span\u003e\u003c/i\u003e\u003cspan\u003e code paths the server will execute. To maintain coverage in the steady state, we also added request shadowing, so we can ensure that gating changes are still covered in the JIT cache.\u003c/span\u003e\u003c/p\u003e\n\n\t\t\n\t\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2025-05-20T16:00:29Z",
  "modifiedTime": "2025-05-20T03:54:00Z"
}
