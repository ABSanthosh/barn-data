{
  "id": "5ae8aaf3-8852-4092-85a6-7ff497e811af",
  "title": "Bringing Fuzz Testing to Kotlin with kotlinx.fuzz",
  "link": "https://blog.jetbrains.com/research/2025/04/kotlinxfuzz-kotlin-fuzzing/",
  "description": "Identifying edge cases for testing can be a challenging task, often leaving hidden bugs and vulnerabilities undetected. Fuzz testing (fuzzing) addresses this challenge by automatically generating tests with random or invalid inputs, enabling developers to uncover unexpected exceptions and failure scenarios. Thanks to its effectiveness in detecting critical software flaws, fuzzing has gained widespread use […]",
  "author": "Galina Ryazanskaya",
  "published": "Fri, 04 Apr 2025 13:55:24 +0000",
  "source": "https://blog.jetbrains.com/feed",
  "categories": [
    "jetbrains",
    "kotlin",
    "research",
    "testing",
    "fuzz-testing",
    "kotlinx-fuzz"
  ],
  "byline": "",
  "length": 12159,
  "excerpt": "Identifying edge cases for testing can be a challenging task, often leaving hidden bugs and vulnerabilities undetected. Fuzz testing (fuzzing) addresses this challenge by automatically generating test",
  "siteName": "The JetBrains Blog",
  "favicon": "https://blog.jetbrains.com/wp-content/uploads/2024/01/cropped-mstile-310x310-1-180x180.png",
  "text": "JetBrains Research Research is crucial for progress and innovation, which is why at JetBrains we are passionate about both scientific and market research JetBrains Kotlin Research Testing Identifying edge cases for testing can be a challenging task, often leaving hidden bugs and vulnerabilities undetected. Fuzz testing (fuzzing) addresses this challenge by automatically generating tests with random or invalid inputs, enabling developers to uncover unexpected exceptions and failure scenarios. Thanks to its effectiveness in detecting critical software flaws, fuzzing has gained widespread use across various programming languages. However, it remains relatively underutilized in Kotlin. This is why our Programming Languages and Program Analysis Lab at JetBrains Research has dedicated its efforts to developing kotlinx.fuzz, a fuzzer for Kotlin libraries. Since Kotlin compiles to JVM bytecode, fuzz testing systems for Kotlin can be built using existing Java fuzzers. This concept is the foundation of our current prototype. Why fuzz testing matters Fuzz testing is a powerful technique capable of exposing undetected errors and vulnerabilities. Research has shown it to be highly effective in detecting critical software flaws. Google’s OSS-Fuzz has discovered over 40,000 bugs in open-source projects, while studies like these highlight how coverage-guided fuzzing significantly enhances bug detection in large-scale systems. Despite its success in other ecosystems (like C/C++ and Rust), fuzzing has not seen wide adoption in Kotlin development. Our goal with kotlinx.fuzz is to bridge this gap by introducing an efficient and scalable fuzzing framework specifically designed for Kotlin projects. In this blog post, we start with an illustration of fuzz testing with kotlinx.fuzz, followed by an explanation of how it works and a few examples of what we were able to achieve using it. Then we’ll cover our plans for the future and ways you can contribute. Fuzz testing with kotlinx.fuzz Let’s start with an example from the Kotlin standard library to showcase what fuzz testing your code with kotlinx.fuzz might look like and walk through all the steps it involves. Analyze code  Before you begin fuzz testing, you should decide what it is that you want to fuzz. Fuzzing every single function in your program is not very efficient because it requires a lot of time and effort when analyzing the bugs. You’re better off selecting a few target functions that will be the main entry points for the fuzzer and starting with the functions that you expect to be used most frequently. Let’s say we want to fuzz test the Duration class from the Kotlin standard library, focusing on the parseIsoStringOrNull method. It is designed to parse a time duration from a string in the ISO-8601 format. If the string represents a valid time, it returns a Duration instance. Otherwise, it returns null. Let’s write a fuzz test that checks its correctness! Design a fuzz test After you select a target that you want to test, the next step is to decide how you are going to fuzz it. You need to decide what scenarios you want to test and how to generate all of the necessary data using a fuzzer. In our example, parseIsoStringOrNull just takes a string in an ISO format. Let’s start from the simplest case and write a fuzz test that generates a random string and passes it to the target: @KFuzzTest fun testDuration(f: KFuzzer) { val isoString = f.asciiString(10) val duration = Duration.parseIsoStringOrNull(isoString) println(\"$isoString -\u003e $duration\") } As you can see, our fuzz test looks very similar to a usual unit test. However, instead of working with the fixed set of input data that the developer manually encodes, we take a Fuzzer as an argument and generate input data with its help. We can then use the fuzzer to re-run this test many times, each time slightly tweaking the value returned by the asciiString call. Choose an oracle After creating this test, you can run it for some time and manually analyze the results. However, these results take a lot of effort to read through and make sense of. To fully leverage the power of fuzzing, you need to come up with an oracle – a way to automatically check if the execution result is correct. An oracle can be as simple or as complicated as you want, however, the quality of the oracle decides what types of bugs you will be able to find. The simplest oracle is just an exception – you can test that your program does not throw any unexpected exceptions. In some cases, you can also perform more complicated checks. For example, if you are fuzzing a JSON parsing library, you can do an inverse check: toJSON(fromJSON(string)) == string. In our example, we can use the Java standard library, which has a method with exactly the same functionality (at least, according to the documentation). This is what our final fuzz test looks like: @KFuzzTest fun testDuration(f: KFuzzer) { val isoString = f.asciiString(10) val duration = Duration.parseIsoStringOrNull(isoString) val javaDuration = try { java.time.Duration.parse(isoString) } catch (_: Throwable) { null } assertEquals(javaDuration?.toKotlinDuration(), duration) } This will help us ensure that the behavior of the Kotlin and the Java function are the same, find all of the mismatches, and analyze why they occur. Configure and run the tests Before you run the test, there are some things that you may want to configure. For example, you can indicate what parts of your project the fuzzer should target, how long you want to run fuzz tests, and where and how it should store the results. Here is an example of a simple configuration: fuzzConfig { instrument = listOf(\"kotlin.time.**\") maxFuzzTimePerTarget = 10.minutes coverage { reportTypes = setOf(CoverageReportType.HTML, CoverageReportType.CSV) } } Check out our documentation for more details on the possible configurations. Now you can finally start the fuzz test: ~/example » ./gradlew fuzz Analyze the results After the fuzzer finishes, you can focus on analyzing the results and see what bugs were detected. There are two main results that we recommend focusing on: Coverage. build/fuzz/jacoco-report will contain JaCoCo coverage reports in the configured formats. We recommend analyzing the coverage to understand if the fuzzer was able to cover all of the parts of your program that you wanted to test.  Bugs. build/fuzz/reproducers will contain all of the crashes found by the fuzzer. You can analyze them by running the fuzzer in regression mode (./gradlew regression). Additionally, you can debug each crash by running your fuzz test in an IDE. In our example test, running it for just 30 minutes covers a large portion of the parseIsoStringOrNull method and gives us a few interesting results: Java correctly parses \"Pt+0,s\" into an empty duration, while Kotlin fails. Conversely, Kotlin correctly parses \"PT+-2H\" into negative 2 hours, while Java fails. Naturally, we reported the bugs we’ve found so they could be fixed! This example showcases that even if your library passes all unit and integration tests, fuzzing can reveal subtle parsing errors, unexpected crashes, or corner cases you never thought of, helping you ship more reliable software. Even this simple fuzz test was able to find two edge cases that highlighted issues in both the Kotlin and Java standard libraries. What kotlinx.fuzz provides We launched the kotlinx.fuzz project to explore the applicability of fuzzing for detecting bugs in Kotlin programs. By building our system on top of an existing Java fuzzer, Jazzer, we were able to leverage a tool already capable of fuzzing and finding bugs in JVM programs, and thus in Kotlin programs as well. However, as a standalone tool, it has some limitations that may impede its adoption for fuzz testing in Kotlin.  Jazzer’s main limitations are related to the user experience. In our opinion, while it provides a good foundation, Jazzer is inconvenient to run, configure, and analyze results. It provides a basic command-line interface and a limited integration with JUnit. Additionally, it sometimes falls short when working with Kotlin. For example, it fails to correctly collect coverage for certain Kotlin-specific features and fails to consider nullability when working in auto-fuzz mode. Thus, we decided to focus on Jazzer’s strengths and develop a new infrastructure around it to overcome its weaknesses. In the kotlinx.fuzz system, we addressed the key issues by providing additional features: An intuitive API for writing fuzz tests in Kotlin (showcased above). A Gradle plugin that allows configuring and running fuzz tests easily. A custom JUnit engine for easy IDE integration. Bugs that kotlinx.fuzz helped us find Using our system, we analyzed several Kotlinx libraries and discovered a number of interesting bugs and insights. Extensive fuzzing experiments on libraries such as kotlinx.serialization and kotlinx.collections.immutable allowed us to uncover several non-trivial errors, including:  Stack overflow in kotlinx.serialization.cbor, which is an error in the decoding of concise binary object representation that leads to infinite recursion, causing a stack overflow. Persistent ordered sets equality in kotlinx.collections.immutable, a bug in persistent set operations where removing elements leads to inconsistent results. Invalid serialization in kotlinx.serialization.json, in which setting classDiscriminator to an existing JSON name causes an undetected name conflict, resulting in incorrect serialization. If you are interested in more details, check out all of our findings on our Trophy List page. What’s next for kotlinx.fuzz Having successfully addressed several key usability issues, we will continue improving kotlinx.fuzz and enhancing the overall user experience. Our goal is to provide greater user control over fuzz test reporting and configurability for individual tests. Our development is now focusing on introducing major new features to extend the functionality of our fuzzer. First, we aim to develop a feature that generates regular tests based on crashes and failures detected by the fuzzer. Second, we plan to implement more powerful crash deduplication mechanisms that can group errors by their underlying causes. Finally, we intend to create a new, Kotlin-specific tool for automatic fuzz test generation, enabling users to harness the power of fuzzing with minimal manual input while also allowing for more user control. How you can use fuzz testing in your Kotlin project We believe that fuzz testing can be a powerful tool in detecting bugs and vulnerabilities in your codebase. We invite Kotlin developers and library maintainers to try out kotlinx.fuzz, provide feedback, and contribute to its development. Our GitHub repository can help you get started, and we will be happy to receive your comments and feedback. Your insights can help us make fuzz testing a staple in Kotlin development! Discover more",
  "image": "https://blog.jetbrains.com/wp-content/uploads/2025/04/jb-featured_blog_1280x720_en.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\"\u003e\n    \u003cdiv\u003e\n                        \u003ca href=\"https://blog.jetbrains.com/research/\"\u003e\n                                                                                                                            \u003ch2\u003eJetBrains Research\u003c/h2\u003e\n                                                                                    \u003c/a\u003e\n                                                    \u003cp\u003eResearch is crucial for progress and innovation, which is why at JetBrains we are passionate about both scientific and market research\u003c/p\u003e\n                                            \u003c/div\u003e\n                            \u003csection data-clarity-region=\"article\"\u003e\n                \u003cdiv\u003e\n                    \t\t\t\t\u003cp\u003e\u003ca href=\"https://blog.jetbrains.com/research/category/jetbrains/\"\u003eJetBrains\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/research/category/kotlin/\"\u003eKotlin\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/research/category/research/\"\u003eResearch\u003c/a\u003e\n\t\t\t\u003ca href=\"https://blog.jetbrains.com/research/category/testing/\"\u003eTesting\u003c/a\u003e\u003c/p\u003e                    \u003cdiv\u003e\n                            \u003cp\u003e\u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2023/08/photo_2023-08-18-16.54.43-2-200x200.jpeg\" width=\"200\" height=\"200\" alt=\"Galina Ryazanskaya\" loading=\"lazy\"/\u003e\n                                                                                                                    \u003cimg src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/azat.jpeg\" width=\"200\" height=\"200\" alt=\"Azat Abdullin\" loading=\"lazy\"/\u003e\n                                                                                                \u003c/p\u003e\n                            \n                        \u003c/div\u003e\n                    \n\u003cp\u003eIdentifying edge cases for testing can be a challenging task, often leaving hidden bugs and vulnerabilities undetected. Fuzz testing (fuzzing) addresses this challenge by automatically generating tests with random or invalid inputs, enabling developers to uncover unexpected exceptions and failure scenarios. Thanks to its effectiveness in detecting critical software flaws, fuzzing has gained widespread use across various programming languages. However, it remains relatively underutilized in Kotlin. This is why our \u003ca href=\"https://lp.jetbrains.com/research/applied-program-analysis/\" target=\"_blank\" rel=\"noopener\"\u003eProgramming Languages and Program Analysis Lab\u003c/a\u003e at JetBrains Research has dedicated its efforts to developing \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz\" target=\"_blank\" rel=\"noopener\"\u003e\u003cstrong\u003ekotlinx.fuzz\u003c/strong\u003e\u003c/a\u003e, a fuzzer for Kotlin libraries. Since Kotlin compiles to JVM bytecode, fuzz testing systems for Kotlin can be built using existing Java fuzzers. This concept is the foundation of our current prototype.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhy fuzz testing matters\u003c/h2\u003e\n\n\n\n\u003cp\u003eFuzz testing is a powerful technique capable of exposing undetected errors and vulnerabilities. Research has shown it to be highly effective in detecting critical software flaws. Google’s \u003ca href=\"https://github.com/google/oss-fuzz\" target=\"_blank\" rel=\"noopener\"\u003eOSS-Fuzz\u003c/a\u003e has discovered over 40,000 bugs in open-source projects, while studies like \u003ca href=\"https://dl.acm.org/doi/abs/10.1145/2976749.2978428\" target=\"_blank\" rel=\"noopener\"\u003ethese\u003c/a\u003e highlight how coverage-guided fuzzing significantly enhances bug detection in large-scale systems.\u003c/p\u003e\n\n\n\n\u003cp\u003eDespite its success in other ecosystems (like C/C++ and Rust), fuzzing has not seen wide adoption in Kotlin development. Our goal with kotlinx.fuzz is to bridge this gap by introducing an efficient and scalable fuzzing framework specifically designed for Kotlin projects.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this blog post, we start with an illustration of fuzz testing with kotlinx.fuzz, followed by an explanation of how it works and a few examples of what we were able to achieve using it. Then we’ll cover our plans for the future and ways you can contribute.\u003c/p\u003e\n\n\n\n\u003ch2\u003eFuzz testing with kotlinx.fuzz\u003c/h2\u003e\n\n\n\n\u003cp\u003eLet’s start with an example from the Kotlin standard library to showcase what fuzz testing your code with kotlinx.fuzz might look like and walk through all the steps it involves.\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eAnalyze code \u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eBefore you begin fuzz testing, you should decide what it is that you want to fuzz. Fuzzing every single function in your program is not very efficient because it requires a lot of time and effort when analyzing the bugs. You’re better off selecting a few target functions that will be the main entry points for the fuzzer and starting with the functions that you expect to be used most frequently. Let’s say we want to fuzz test the \u003ccode\u003eDuration\u003c/code\u003e \u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.time/-duration/\" data-type=\"link\" data-id=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.time/-duration/\" target=\"_blank\" rel=\"noopener\"\u003eclass\u003c/a\u003e from the Kotlin standard library, focusing on the \u003ccode\u003eparseIsoStringOrNull\u003c/code\u003e \u003ca href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.time/-duration/-companion/parse-iso-string-or-null.html\" data-type=\"link\" data-id=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.time/-duration/-companion/parse-iso-string-or-null.html\" target=\"_blank\" rel=\"noopener\"\u003emethod\u003c/a\u003e. It is designed to parse a time duration from a string in the ISO-8601 format. If the string represents a valid time, it returns a \u003ccode\u003eDuration\u003c/code\u003e instance. Otherwise, it returns \u003ccode\u003enull\u003c/code\u003e. Let’s write a fuzz test that checks its correctness!\u003c/p\u003e\n\n\n\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003eDesign a fuzz test\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eAfter you select a target that you want to test, the next step is to decide how you are going to fuzz it. You need to decide what scenarios you want to test and how to generate all of the necessary data using a fuzzer. In our example, \u003ccode\u003eparseIsoStringOrNull\u003c/code\u003e just takes a string in an ISO format. Let’s start from the simplest case and write a fuzz test that generates a random string and passes it to the target:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@KFuzzTest\nfun testDuration(f: KFuzzer) {\n    val isoString = f.asciiString(10)\n    val duration = Duration.parseIsoStringOrNull(isoString)\n    println(\u0026#34;$isoString -\u0026gt; $duration\u0026#34;)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eAs you can see, our fuzz test looks very similar to a usual unit test. However, instead of working with the fixed set of input data that the developer manually encodes, we take a \u003ccode\u003eFuzzer\u003c/code\u003e as an argument and generate input data with its help. We can then use the fuzzer to re-run this test many times, each time slightly tweaking the value returned by the \u003ccode\u003easciiString\u003c/code\u003e call.\u003c/p\u003e\n\n\n\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003eChoose an oracle\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eAfter creating this test, you can run it for some time and manually analyze the results. However, these results take a lot of effort to read through and make sense of. To fully leverage the power of fuzzing, you need to come up with an oracle – a way to automatically check if the execution result is correct. An oracle can be as simple or as complicated as you want, however, the quality of the oracle decides what types of bugs you will be able to find. The simplest oracle is just an exception – you can test that your program does not throw any unexpected exceptions. In some cases, you can also perform more complicated checks. For example, if you are fuzzing a JSON parsing library, you can do an inverse check: \u003ccode\u003etoJSON(fromJSON(string)) == string\u003c/code\u003e. In our example, we can use the Java standard library, which has a \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-\" target=\"_blank\" rel=\"noopener\"\u003emethod\u003c/a\u003e with exactly the same functionality (at least, according to the documentation). This is what our final fuzz test looks like:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"kotlin\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e@KFuzzTest\nfun testDuration(f: KFuzzer) {\n    val isoString = f.asciiString(10)\n    val duration = Duration.parseIsoStringOrNull(isoString)\n\n    val javaDuration = try {\n        java.time.Duration.parse(isoString)\n    } catch (_: Throwable) { null }\n\n    assertEquals(javaDuration?.toKotlinDuration(), duration)\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eThis will help us ensure that the behavior of the Kotlin and the Java function are the same, find all of the mismatches, and analyze why they occur.\u003c/p\u003e\n\n\n\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cstrong\u003eConfigure and run the tests\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eBefore you run the test, there are some things that you may want to configure. For example, you can indicate what parts of your project the fuzzer should target, how long you want to run fuzz tests, and where and how it should store the results. Here is an example of a simple configuration:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"raw\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003efuzzConfig {\n    instrument = listOf(\u0026#34;kotlin.time.**\u0026#34;)\n    maxFuzzTimePerTarget = 10.minutes\n    coverage {\n        reportTypes = setOf(CoverageReportType.HTML, CoverageReportType.CSV)\n    }\n}\n\u003c/pre\u003e\n\n\n\n\u003cp\u003eCheck out our \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz/blob/main/docs/Configuration.md\" target=\"_blank\" rel=\"noopener\"\u003edocumentation\u003c/a\u003e for more details on the possible configurations.\u003c/p\u003e\n\n\n\n\u003cp\u003eNow you can finally start the fuzz test:\u003c/p\u003e\n\n\n\n\u003cpre data-enlighter-language=\"bash\" data-enlighter-theme=\"\" data-enlighter-highlight=\"\" data-enlighter-linenumbers=\"\" data-enlighter-lineoffset=\"\" data-enlighter-title=\"\" data-enlighter-group=\"\"\u003e~/example » ./gradlew fuzz\u003c/pre\u003e\n\n\n\n\u003col start=\"5\"\u003e\n\u003cli\u003e\u003cstrong\u003eAnalyze the results\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eAfter the fuzzer finishes, you can focus on analyzing the results and see what bugs were detected. There are two main results that we recommend focusing on:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCoverage\u003c/strong\u003e. \u003ccode\u003ebuild/fuzz/jacoco-report\u003c/code\u003e will contain JaCoCo coverage reports in the configured formats. We recommend analyzing the coverage to understand if the fuzzer was able to cover all of the parts of your program that you wanted to test. \u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eBugs\u003c/strong\u003e. \u003ccode\u003ebuild/fuzz/reproducers\u003c/code\u003e will contain all of the crashes found by the fuzzer. You can analyze them by running the fuzzer in regression mode (\u003ccode\u003e./gradlew regression\u003c/code\u003e). Additionally, you can debug each crash by running your fuzz test in an IDE.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIn our example test, running it for just 30 minutes covers a large portion of the parseIsoStringOrNull method and gives us a few interesting results:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eJava correctly parses \u003ccode\u003e\u0026#34;Pt+0,s\u0026#34;\u003c/code\u003e into an empty duration, while Kotlin fails.\u003c/li\u003e\n\n\n\n\u003cli\u003eConversely, Kotlin correctly parses \u003ccode\u003e\u0026#34;PT+-2H\u0026#34;\u003c/code\u003e into negative 2 hours, while Java fails.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eNaturally, we \u003ca href=\"https://github.com/Kotlin/kotlinx-datetime/issues/443\" target=\"_blank\" rel=\"noopener\"\u003ereported\u003c/a\u003e the bugs we’ve found so they could be \u003ca href=\"https://github.com/JetBrains/kotlin/pull/5370\" target=\"_blank\" rel=\"noopener\"\u003efixed\u003c/a\u003e!\u003c/p\u003e\n\n\n\n\u003cp\u003eThis example showcases that even if your library passes all unit and integration tests, fuzzing can reveal subtle parsing errors, unexpected crashes, or corner cases you never thought of, helping you ship more reliable software. Even this simple fuzz test was able to find two edge cases that highlighted issues in both the Kotlin and Java standard libraries.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat kotlinx.fuzz provides\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe launched the kotlinx.fuzz project to explore the applicability of fuzzing for detecting bugs in Kotlin programs. By building our system on top of an existing Java fuzzer, Jazzer, we were able to leverage a tool already capable of fuzzing and finding bugs in JVM programs, and thus in Kotlin programs as well. However, as a standalone tool, it has some limitations that may impede its adoption for fuzz testing in Kotlin. \u003c/p\u003e\n\n\n\n\u003cp\u003eJazzer’s main limitations are related to the user experience. In our opinion, while it provides a good foundation, Jazzer is inconvenient to run, configure, and analyze results. It provides a basic command-line interface and a limited integration with JUnit. Additionally, it sometimes falls short when working with Kotlin. For example, it fails to correctly collect coverage for certain Kotlin-specific features and fails to consider nullability when working in auto-fuzz mode. Thus, we decided to focus on Jazzer’s strengths and develop a new infrastructure around it to overcome its weaknesses.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn the kotlinx.fuzz system, we addressed the key issues by providing additional features:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eAn intuitive API for writing fuzz tests in Kotlin (showcased above).\u003c/li\u003e\n\n\n\n\u003cli\u003eA Gradle plugin that allows configuring and running fuzz tests easily.\u003c/li\u003e\n\n\n\n\u003cli\u003eA custom JUnit engine for easy IDE integration.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cfigure\u003e\u003cimg decoding=\"async\" fetchpriority=\"high\" width=\"1224\" height=\"582\" src=\"https://blog.jetbrains.com/wp-content/uploads/2025/04/ide-tests.png\" alt=\"\"/\u003e\u003c/figure\u003e\n\n\n\n\u003ch2\u003eBugs that kotlinx.fuzz helped us find\u003c/h2\u003e\n\n\n\n\u003cp\u003eUsing our system, we analyzed several Kotlinx libraries and discovered a number of interesting bugs and insights. Extensive fuzzing experiments on libraries such as \u003cem\u003ekotlinx.serialization\u003c/em\u003e and \u003cem\u003ekotlinx.collections.immutable\u003c/em\u003e allowed us to uncover several non-trivial errors, including: \u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/issues/2886\" target=\"_blank\" rel=\"noopener\"\u003eStack overflow in kotlinx.serialization.cbor\u003c/a\u003e, which is an error in the decoding of concise binary object representation that leads to infinite recursion, causing a stack overflow.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.collections.immutable/issues/204\" target=\"_blank\" rel=\"noopener\"\u003ePersistent ordered sets equality in kotlinx.collections.immutable\u003c/a\u003e, a bug in persistent set operations where removing elements leads to inconsistent results.\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ca href=\"https://github.com/Kotlin/kotlinx.serialization/issues/2885#issue-2742832022\" target=\"_blank\" rel=\"noopener\"\u003eInvalid serialization in kotlinx.serialization.json\u003c/a\u003e, in which setting \u003ccode\u003eclassDiscriminator\u003c/code\u003e to an existing JSON name causes an undetected name conflict, resulting in incorrect serialization.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eIf you are interested in more details, check out all of our findings on our \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz/blob/main/docs/Trophy%20list.md\" target=\"_blank\" rel=\"noopener\"\u003eTrophy List\u003c/a\u003e page.\u003c/p\u003e\n\n\n\n\u003ch2\u003eWhat’s next for kotlinx.fuzz\u003c/h2\u003e\n\n\n\n\u003cp\u003eHaving successfully addressed several key usability issues, we will continue improving kotlinx.fuzz and enhancing the overall user experience. Our goal is to provide greater user control over fuzz test reporting and configurability for individual tests.\u003c/p\u003e\n\n\n\n\u003cp\u003eOur development is now focusing on introducing major new features to extend the functionality of our fuzzer. First, we aim to develop a feature that generates regular tests based on crashes and failures detected by the fuzzer. Second, we plan to implement more powerful crash deduplication mechanisms that can group errors by their underlying causes. Finally, we intend to create a new, Kotlin-specific tool for automatic fuzz test generation, enabling users to harness the power of fuzzing with minimal manual input while also allowing for more user control.\u003c/p\u003e\n\n\n\n\u003ch2\u003eHow you can use fuzz testing in your Kotlin project\u003c/h2\u003e\n\n\n\n\u003cp\u003eWe believe that fuzz testing can be a powerful tool in detecting bugs and vulnerabilities in your codebase. We invite Kotlin developers and library maintainers to try out kotlinx.fuzz, provide feedback, and contribute to its development. Our \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz\" target=\"_blank\" rel=\"noopener\"\u003eGitHub repository\u003c/a\u003e can help you \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz/tree/main/docs\" target=\"_blank\" rel=\"noopener\"\u003eget started\u003c/a\u003e, and we will be happy to \u003ca href=\"https://github.com/JetBrains-Research/kotlinx.fuzz/issues\" target=\"_blank\" rel=\"noopener\"\u003ereceive\u003c/a\u003e your comments and feedback. Your insights can help us make fuzz testing a staple in Kotlin development!\u003c/p\u003e\n                    \n                                                                                                                                                                                                                                    \u003c/div\u003e\n                \u003ca href=\"#\"\u003e\u003c/a\u003e\n                \n                \n            \u003c/section\u003e\n                    \u003cdiv\u003e\n                \u003cp\u003e\n                    \u003ch2\u003eDiscover more\u003c/h2\u003e\n                \u003c/p\u003e\n                \n            \u003c/div\u003e\n                \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": null,
  "modifiedTime": null
}
