{
  "id": "12b4d388-9dcc-41b1-9a5c-8f1fd6e8b91c",
  "title": "DNS rebinding attacks explained: The lookup is coming from inside the house!",
  "link": "https://github.blog/security/application-security/dns-rebinding-attacks-explained-the-lookup-is-coming-from-inside-the-house/",
  "description": "DNS rebinding attack without CORS against local network web applications. Explore the topic further and see how it can be used to exploit vulnerabilities in the real-world. The post DNS rebinding attacks explained: The lookup is coming from inside the house! appeared first on The GitHub Blog.",
  "author": "Jaroslav Lobacevski",
  "published": "Tue, 03 Jun 2025 16:00:00 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "Application security",
    "Security",
    "GitHub Security Lab"
  ],
  "byline": "Jaroslav Lobacevski",
  "length": 12244,
  "excerpt": "DNS rebinding attack without CORS against local network web applications. See how this can be used to exploit vulnerabilities in the real-world.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "My colleague Kevin Stubbs mentioned the topic of DNS rebinding attacks in a  previous blog post. No worries if you haven’t read it yet though—in this article, we’ll walk you through the concept of DNS rebinding from scratch, demystify how it works, and explore why it’s a serious browser-based security issue. We’ll start by revisiting the same-origin policy, a fundamental part of web security, and show how DNS rebinding bypasses it. You’ll see real-world scenarios where attackers can use this technique to access internal applications running on your local machine or network, even if those apps aren’t meant to be publicly available. We’ll dive into a real vulnerability in the Deluge BitTorrent client, explaining exactly how DNS rebinding could have been used to read arbitrary files from a local system. Finally, we’ll go over practical steps you can take to protect yourself or your application from this often-overlooked but potent attack vector. Same-origin policy Same-origin policy (SOP) is a cornerstone of browser security introduced in 1995 by Netscape. The idea behind it is simple: Scripts from webpages of one origin should not be able to access data from a webpage of another origin. For example, nobody wants arbitrary webpages to be able to read their currently logged-in webmail. So that websites can be distinguishable from the next, they’re each defined with a combination of protocol (schema), host (DNS name), and a port number. Any mismatch in these three parts makes the origin different.  For example, for the webpage: https://www.somedomain.com/sub/page.html possible origin comparisons are the following: URLOutcomeReasonhttps://www.somedomain.com:81/sub/page.htmlDifferentThe port 81 doesn’t match 443 (the default for https)https://somedomain.com/sub/page.htmlDifferentExact www.somedomain.com match is requiredhttp://www.somedomain.com:443/sub/page.htmlDifferentThe schema (protocol) HTTP doesn’t match HTTPShttps://www.somedomain.com/admin/login.htmlSameOnly the path differs The attack: DNS rebinding People tend to think running something on localhost completely shields it from the external world. While they understand that they can access what is running on the local machine from their local browser, they miss that the browser may also become the gateway through which unsolicited visitors get access to the web applications on the same machine or local network.  Unfortunately, there is a disconnect between the browser security mechanism and networking protocols. If the resolved IP address of the webpage host changes, the browser doesn’t take it into account and treats the webpage as if its origin didn’t change. This can be abused by attackers.  For example, if an attacker owns the domain name somesite.com and delegates it to a DNS server that is under attacker control, they may initially respond to a DNS lookup with a public IP address, such as 172.217. 22.14, and then switch subsequent lookups to a local network IP address, such as 192.168.0.1 or 127.0.0.1 (i.e. localhost). Javascript loaded from the original somesite.com will run client-side in the browser, and all further requests from it to somesite.com will be directed to the new, now local, IP address. From then on, documents loaded from different IP addresses—but resolved from the same hosts—will be considered to be of the same origin. This gives the attackers the ability to interact with the victim’s local network via Javascript running in the victim’s browser. This makes any web application that runs locally on the same machine or local network as the victim’s browser accessible to the scripts loaded from somesite.com too.  One catch is that if the web application requires authentication, its cookies are not made available to the attacker. Since the targeted user originally opened somesite.com—and even though subsequent Javascript requests are directed to the new, attacker rebound, IP address—the browser still operates in the context of the somesite.com origin. That means the victim’s browser will not use stored authentication or session context for the locally targeted service name. Other scenarios could include attackers abusing local VPN routes that are available to the targeted user, allowing access to corporate intranet web applications, for example. The response: caching  Browsers try to resist DNS rebinding like this by caching DNS responses, but the defense is far from perfect. Some browsers have implemented Local Network Access (also known as CORS-RFC1918), a new draft W3C specification. It closed some avenues, but still left some bypasses, such as 0.0.0.0 IP address on Linux and MacOS, so the DNS rebinding behavior is very browser and operating system (OS) dependent. There are so many layers involved (browser DNS cache, OS DNS cache, DNS nameservers) that the attack is often considered unreliable and not taken as a real threat. However, there are also tools that can automate attacks such as Tavis Ormandy’s Simple DNS Rebinding Service or NCCGroup’s Singularity of Origin. A real-world vulnerability Now let’s dive into technicalities of a real-world vulnerability found in BitTorrent client Deluge (fixed in v2.2.0) and how DNS rebinding could have been used to exploit it. The Deluge BitTorrent client supports starting two services on system boot: daemon and WebUI. The WebUI web application service may also be started by enabling the WebUI plugin (installed, but disabled by default) in the preferences dialog of the Deluge client. It is also convenient to run the WebUI application permanently on a server in the local network. We found a path traversal in an unauthenticated endpoint of the web application that allowed for arbitrary file read. def render(self, request): log.debug('Requested path: %s', request.lookup_path) lookup_path = request.lookup_path.decode() for script_type in ('dev', 'debug', 'normal'): scripts = self.__scripts[script_type]['scripts'] for pattern in scripts: if not lookup_path.startswith(pattern): # \u003c-- [1] continue filepath = scripts[pattern] if isinstance(filepath, tuple): filepath = filepath[0] path = filepath + lookup_path[len(pattern) :] # \u003c-- [2] if not os.path.isfile(path): continue log.debug('Serving path: %s', path) mime_type = mimetypes.guess_type(path) # \u003c-- [4] request.setHeader(b'content-type', mime_type[0].encode()) # \u003c-- [5] with open(path, 'rb') as _file: # \u003c-- [3] data = _file.read() return data The /js endpoint of the WebUI component didn’t require authentication, since its purpose is to serve JavaScript files for the UI. The request.lookup_path was validated to start with a known keyword [1], but it could have been bypassed with /js/known_keyword/../... The path traversal happened in [2], when the path was concatenated and later used to read a file [3]. The only limitation was the mimetypes.guess_type call at [4], because, in case it returned a mime type None, request.setHeader at [5] throws an exception. The path traversal allowed for unauthenticated read of any file on the system as long as its MIME type was recognized. Even if attackers constrain themselves to Deluge-only files, Deluge uses files with .conf extensions to store configuration settings with sensitive information. This extension is identified as text/plain by mimetypes.guess_type. A request to /js/deluge-all%2F..%2F..%2F..%2F..%2F..%2F..%2F.config%2Fdeluge%2Fweb.conf, for example, would return such information as the WebUI admin password SHA1 with salt and a list of sessions. The sessions are written to the file only on service shutdown, and, after the default 1 hour expiration, are not updated. But with some luck, attackers could find a valid session there to authenticate themselves to the service. Otherwise, they would need to brute force the password hash. Since Deluge doesn’t use a slow password hashing algorithm, they could do it very quickly for simple or short passwords. Once attackers obtain an authenticated session, they could use the exploitation technique from CVE-2017-7178 to download, install, and run a malicious plugin on the vulnerable machine by using the /json endpoint Web API. Exploiting it If Deluge WebUI is hosted externally, the exploitation would be straightforward. However, even if the service is accessible only locally, since it is an unauthenticated endpoint, attackers could use a DNS rebinding attack to access the service from a specially crafted web site. For browsers that implement CORS-RFC1918, which segments address ranges into different address spaces (loopback, local network, and public network addresses), attackers could use a known Linux and MacOS bypass—the non-routable 0.0.0.0 IP address—to access the local service. For the sake of simplicity, let’s assume attackers know the port of the vulnerable application (8112 by default for Deluge WebUI), though discovering that the port can be automated with Singularity. A Deluge WebUI user opens a web page with multiple IFrames by visiting the malicious somesite.com. Each frame fetches http://sub.somesite.com:8182/attack.html. In order to bypass SOP, the port number must be the same as the attacked application. The DNS resolver the attackers control may respond alternately with 0.0.0.0, and the real IP address of the server with a very low time to live (TTL). When the DNS resolves with the real IP address, the browser fetches a page with a script that waits for the DNS entry to expire by checking if they can request and read http://sub.somesite.com:8182/js/deluge-all/..%2F..%2F..%2F..%2F..%2F..%2F.config%2Fdeluge%2Fweb.conf. If the attack succeeds, the script will have exfiltrated the configuration file. For the full source of attack.html please check this advisory. How to proactively protect yourself from DNS attacks DNS rebinding doesn’t work for HTTPS services. Once a transport layer security (TLS) session is established with somesite.com, the browser validates the subject of the certificate against the domain. After the IP address changes, the browser needs to establish a new session, but it will fail, because the certificate of the locally deployed web application won’t match the domain name. As already mentioned, the authentication cookies for somesite.com won’t be accepted by the locally deployed web application. So be sure to use strong authentication, even if it is over unencrypted HTTP. Check the Host header of the request and deny if it doesn’t strictly match an allow list of expected values. A rebounded request will contain the host somesite.com header value. Take this with you Running web applications locally is a common practice by developers. However, a permanently deployed local network web application that doesn’t require authentication and TLS (i.e. no HTTPS encryption) is a red flag. DNS rebinding attacks are a vivid example of how seemingly isolated local services can be exposed through browser behavior and weak network assumptions. Never assume a service is safe just because it’s “only running locally.” Always enforce strong, password-based authentication—even for internal services or development tools. Any local service without rigorous access control may be exposed through a victim’s browser. Validate the Host header. Use HTTPS wherever possible.  DNS rebinding demonstrates that assumptions about network boundaries and browser security can be dangerously misleading. Be sure to include DNS rebinding into your threat model when developing your next web application.  Written by Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more Enterprise content Executive insights, curated just for you Get started",
  "image": "https://github.blog/wp-content/uploads/2024/02/Security-DarkMode-2-2.png?fit=1200%2C630",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eMy colleague Kevin Stubbs mentioned the topic of DNS rebinding attacks in a  \u003ca href=\"https://github.blog/security/application-security/localhost-dangers-cors-and-dns-rebinding/\"\u003eprevious\u003c/a\u003e blog post. No worries if you haven’t read it yet though—in this article, we’ll walk you through the concept of DNS rebinding from scratch, demystify how it works, and explore why it’s a serious browser-based security issue.\u003c/p\u003e\n\n\n\n\u003cp\u003eWe’ll start by revisiting the same-origin policy, a fundamental part of web security, and show how DNS rebinding bypasses it. You’ll see real-world scenarios where attackers can use this technique to access internal applications running on your local machine or network, even if those apps aren’t meant to be publicly available. We’ll dive into a real vulnerability in the Deluge BitTorrent client, explaining exactly how DNS rebinding could have been used to read arbitrary files from a local system. Finally, we’ll go over practical steps you can take to protect yourself or your application from this often-overlooked but potent attack vector.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"h-same-origin-policy\"\u003eSame-origin policy\u003c/h2\u003e\n\n\n\n\u003cp\u003eSame-origin policy (SOP) is a cornerstone of browser security introduced in 1995 by Netscape. The idea behind it is simple: Scripts from webpages of one origin should not be able to access data from a webpage of another origin. For example, nobody wants arbitrary webpages to be able to read their currently logged-in webmail. So that websites can be distinguishable from the next, they’re each defined with a combination of protocol (schema), host (DNS name), and a port number. Any mismatch in these three parts makes the origin different. \u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, for the webpage: \u003ccode\u003ehttps://www.somedomain.com/sub/page.html\u003c/code\u003e possible origin comparisons are the following:\u003c/p\u003e\n\n\n\n\u003cfigure\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003cstrong\u003eURL\u003c/strong\u003e\u003c/th\u003e\u003cth\u003e\u003cstrong\u003eOutcome\u003c/strong\u003e\u003c/th\u003e\u003cth\u003e\u003cstrong\u003eReason\u003c/strong\u003e\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehttps://www.somedomain.com:81/sub/page.html\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eDifferent\u003c/td\u003e\u003ctd\u003eThe port 81 doesn’t match 443 (the default for https)\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehttps://somedomain.com/sub/page.html\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eDifferent\u003c/td\u003e\u003ctd\u003eExact \u003ccode\u003ewww.somedomain.com\u003c/code\u003e match is required\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehttp://www.somedomain.com:443/sub/page.html\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eDifferent\u003c/td\u003e\u003ctd\u003eThe schema (protocol) HTTP doesn’t match HTTPS\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\u003ccode\u003ehttps://www.somedomain.com/admin/login.html\u003c/code\u003e\u003c/td\u003e\u003ctd\u003eSame\u003c/td\u003e\u003ctd\u003eOnly the path differs\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003ch2 id=\"the-attack-dns-rebinding\"\u003eThe attack: DNS rebinding\u003c/h2\u003e\n\n\n\n\u003cp\u003ePeople tend to think running something on localhost completely shields it from the external world. While they understand that they can access what is running on the local machine from their local browser, they miss that the browser may also become the gateway through which unsolicited visitors get access to the web applications on the same machine or local network. \u003c/p\u003e\n\n\n\n\u003cp\u003eUnfortunately, there is a disconnect between the browser security mechanism and networking protocols. If the resolved IP address of the webpage host changes, the browser doesn’t take it into account and treats the webpage as if its origin didn’t change. This can be abused by attackers. \u003c/p\u003e\n\n\n\n\u003cp\u003eFor example, if an attacker owns the domain name \u003ccode\u003esomesite.com\u003c/code\u003e and delegates it to a DNS server that is under attacker control, they may initially respond to a DNS lookup with a public IP address, such as 172.217. 22.14, and then switch subsequent lookups to a local network IP address, such as 192.168.0.1 or 127.0.0.1 (i.e. localhost). Javascript loaded from the original \u003ccode\u003esomesite.com\u003c/code\u003e will run client-side in the browser, and all further requests from it to \u003ccode\u003esomesite.com\u003c/code\u003e will be directed to the new, now local, IP address. From then on, documents loaded from different IP addresses—but resolved from the same hosts—will be considered to be of the same origin. This gives the attackers the ability to interact with the victim’s local network via Javascript running in the victim’s browser. This makes any web application that runs locally on the same machine or local network as the victim’s browser accessible to the scripts loaded from \u003ccode\u003esomesite.com\u003c/code\u003e too. \u003c/p\u003e\n\n\n\n\u003cp\u003eOne catch is that if the web application requires authentication, its cookies are not made available to the attacker. Since the targeted user originally opened \u003ccode\u003esomesite.com\u003c/code\u003e—and even though subsequent Javascript requests are directed to the new, attacker rebound, IP address—the browser still operates in the context of the \u003ccode\u003esomesite.com\u003c/code\u003e origin. That means the victim’s browser will not use stored authentication or session context for the locally targeted service name.\u003c/p\u003e\n\n\n\n\u003cp\u003eOther scenarios could include attackers abusing local VPN routes that are available to the targeted user, allowing access to corporate intranet web applications, for example.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"the-response-caching\"\u003eThe response: caching \u003c/h2\u003e\n\n\n\n\u003cp\u003eBrowsers try to resist DNS rebinding like this by caching DNS responses, but the defense is far from perfect. Some browsers have implemented \u003ca href=\"https://wicg.github.io/local-network-access/\"\u003eLocal Network Access\u003c/a\u003e (also known as CORS-RFC1918), a new draft W3C specification. It closed some avenues, but still left some bypasses, such as 0.0.0.0 IP address on Linux and MacOS, so the DNS rebinding behavior is very browser and operating system (OS) dependent. There are so many layers involved (browser DNS cache, OS DNS cache, DNS nameservers) that the attack is often considered unreliable and not taken as a real threat. However, there are also tools that can automate attacks such as Tavis Ormandy’s \u003ca href=\"https://github.com/taviso/rbndr\"\u003eSimple DNS Rebinding Service\u003c/a\u003e or NCCGroup’s \u003ca href=\"https://github.com/nccgroup/singularity\"\u003eSingularity of Origin\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"a-real-world-vulnerability\"\u003eA real-world vulnerability\u003c/h2\u003e\n\n\n\n\u003cp\u003eNow let’s dive into technicalities of a real-world vulnerability found in BitTorrent client \u003ca href=\"https://deluge-torrent.org/\"\u003eDeluge\u003c/a\u003e (fixed in v2.2.0) and how DNS rebinding could have been used to exploit it.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe Deluge BitTorrent client supports starting \u003ca href=\"https://deluge.readthedocs.io/en/latest/how-to/index.html#deluge-as-a-service\"\u003etwo services \u003c/a\u003eon system boot: daemon and WebUI. The WebUI web application service may also be started by enabling the WebUI plugin (installed, but disabled by default) in the preferences dialog of the Deluge client. It is also convenient to run the WebUI application permanently on a server in the local network. We found a path traversal in an unauthenticated endpoint of the web application that allowed for arbitrary file read.\u003c/p\u003e\n\n\n\n\u003cpre\u003e\u003ccode\u003edef render(self, request):\n\tlog.debug(\u0026#39;Requested path: %s\u0026#39;, request.lookup_path)\n\tlookup_path = request.lookup_path.decode()\n\tfor script_type in (\u0026#39;dev\u0026#39;, \u0026#39;debug\u0026#39;, \u0026#39;normal\u0026#39;):\n\t\tscripts = self.__scripts[script_type][\u0026#39;scripts\u0026#39;]\n\t\tfor pattern in scripts:\n\t\t\tif not lookup_path.startswith(pattern): # \u0026lt;-- [1]\n\t\t\t\tcontinue\n\n\t\t\tfilepath = scripts[pattern]\n\t\t\tif isinstance(filepath, tuple):\n\t\t\t\tfilepath = filepath[0]\n\n\t\t\tpath = filepath + lookup_path[len(pattern) :] # \u0026lt;-- [2]\n\n\t\t\tif not os.path.isfile(path):\n\t\t\t\tcontinue\n\n\t\t\tlog.debug(\u0026#39;Serving path: %s\u0026#39;, path)\n\t\t\tmime_type = mimetypes.guess_type(path) # \u0026lt;-- [4]\n\n\t\t\trequest.setHeader(b\u0026#39;content-type\u0026#39;, mime_type[0].encode()) # \u0026lt;-- [5]\n\t\t\twith open(path, \u0026#39;rb\u0026#39;) as _file: # \u0026lt;-- [3]\n\t\t\t\tdata = _file.read()\n\t\t\treturn data\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\u003cp\u003eThe \u003ccode\u003e/js\u003c/code\u003e \u003ca href=\"https://github.com/deluge-torrent/deluge/blob/7660e2e5cab82167ff95f9f555fcfe9421e554f4/deluge/ui/web/server.py#L422-L445\"\u003eendpoint\u003c/a\u003e of the WebUI component didn’t require authentication, since its purpose is to serve JavaScript files for the UI. The \u003ccode\u003erequest.lookup_path\u003c/code\u003e was validated to start with a known keyword [1], but it could have been bypassed with \u003ccode\u003e/js/known_keyword/../...\u003c/code\u003e The path traversal happened in [2], when the path was concatenated and later used to read a file [3]. The only limitation was the \u003ccode\u003emimetypes.guess_type\u003c/code\u003e call at [4], because, in case it returned a mime type \u003ccode\u003eNone\u003c/code\u003e, \u003ccode\u003erequest.setHeader\u003c/code\u003e at [5] throws an exception.\u003c/p\u003e\n\n\n\n\u003cp\u003eThe path traversal allowed for unauthenticated read of any file on the system as long as its MIME type was recognized.\u003c/p\u003e\n\n\n\n\u003cp\u003eEven if attackers constrain themselves to Deluge-only files, Deluge uses files with \u003ccode\u003e.conf\u003c/code\u003e extensions to store configuration settings with sensitive information. This extension is identified as \u003ccode\u003etext/plain\u003c/code\u003e by \u003ccode\u003emimetypes.guess_type\u003c/code\u003e. A request to \u003ccode\u003e/js/deluge-all%2F..%2F..%2F..%2F..%2F..%2F..%2F.config%2Fdeluge%2Fweb.conf\u003c/code\u003e, for example, would return such information as the WebUI admin password SHA1 with salt and a list of sessions. The sessions are written to the file only on service shutdown, and, after the default 1 hour expiration, are not updated. But with some luck, attackers could find a valid session there to authenticate themselves to the service. Otherwise, they would need to brute force the password hash. Since Deluge doesn’t use a \u003ca href=\"https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#password-hashing-algorithms\"\u003eslow password hashing algorithm\u003c/a\u003e, they could do it very quickly for simple or short passwords.\u003c/p\u003e\n\n\n\n\u003cp\u003eOnce attackers obtain an authenticated session, they could use the exploitation technique from \u003ca href=\"https://seclists.org/fulldisclosure/2017/Mar/6\"\u003eCVE-2017-7178\u003c/a\u003e to download, install, and run a malicious plugin on the vulnerable machine by using the \u003ccode\u003e/json\u003c/code\u003e endpoint Web API.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"exploiting-it\"\u003eExploiting it\u003c/h2\u003e\n\n\n\n\u003cp\u003eIf Deluge WebUI is \u003ca href=\"https://deluge-torrent.org/userguide/webui/reverseproxy/\"\u003ehosted externally\u003c/a\u003e, the exploitation would be straightforward. However, even if the service is accessible only locally, since it is an unauthenticated endpoint, attackers could use a DNS rebinding attack to access the service from a specially crafted web site. For browsers that implement CORS-RFC1918, which segments address ranges into different address spaces (loopback, local network, and public network addresses), attackers could use a known Linux and MacOS bypass—the non-routable \u003ca href=\"https://www.nccgroup.com/us/research-blog/state-of-dns-rebinding-in-2023/\"\u003e0.0.0.0 IP address\u003c/a\u003e—to access the local service.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the sake of simplicity, let’s assume attackers know the port of the vulnerable application (8112 by default for Deluge WebUI), though discovering that the port can be automated with \u003ca href=\"https://github.com/nccgroup/singularity\"\u003eSingularity\u003c/a\u003e. A Deluge WebUI user opens a web page with multiple IFrames by visiting the malicious \u003ccode\u003esomesite.com\u003c/code\u003e. Each frame fetches \u003ccode\u003ehttp://sub.somesite.com:8182/attack.html\u003c/code\u003e. In order to bypass SOP, the port number must be the same as the attacked application. The DNS resolver the attackers control may respond alternately with 0.0.0.0, and the real IP address of the server with a very low time to live (TTL). When the DNS resolves with the real IP address, the browser fetches a page with a script that waits for the DNS entry to expire by checking if they can request and read \u003ccode\u003ehttp://sub.somesite.com:8182/js/deluge-all/..%2F..%2F..%2F..%2F..%2F..%2F.config%2Fdeluge%2Fweb.conf\u003c/code\u003e. If the attack succeeds, the script will have exfiltrated the configuration file.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor the full source of \u003ccode\u003eattack.html\u003c/code\u003e please check this \u003ca href=\"https://securitylab.github.com/advisories/GHSL-2024-188_GHSL-2024-191_Deluge/\"\u003eadvisory\u003c/a\u003e.\u003c/p\u003e\n\n\n\n\u003ch2 id=\"how-to-proactively-protect-yourself-from-dns-attacks\"\u003eHow to proactively protect yourself from DNS attacks\u003c/h2\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eDNS rebinding doesn’t work for HTTPS services. Once a transport layer security (TLS) session is established with \u003ccode\u003esomesite.com\u003c/code\u003e, the browser validates the subject of the certificate against the domain. After the IP address changes, the browser needs to establish a new session, but it will fail, because the certificate of the locally deployed web application won’t match the domain name.\u003c/li\u003e\n\n\n\n\u003cli\u003eAs already mentioned, the authentication cookies for \u003ccode\u003esomesite.com\u003c/code\u003e won’t be accepted by the locally deployed web application. So be sure to use strong authentication, even if it is over unencrypted HTTP.\u003c/li\u003e\n\n\n\n\u003cli\u003eCheck the Host header of the request and deny if it doesn’t strictly match an allow list of expected values. A rebounded request will contain the host \u003ccode\u003esomesite.com\u003c/code\u003e header value.\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003ch2 id=\"take-this-with-you\"\u003eTake this with you\u003c/h2\u003e\n\n\n\n\u003cp\u003eRunning web applications locally is a common practice by developers. However, a permanently deployed local network web application that doesn’t require authentication and TLS (i.e. no HTTPS encryption) is a red flag. DNS rebinding attacks are a vivid example of how seemingly isolated local services can be exposed through browser behavior and weak network assumptions.\u003c/p\u003e\n\n\n\n\u003cp\u003eNever assume a service is safe just because it’s “only running locally.” Always enforce strong, password-based authentication—even for internal services or development tools. Any local service without rigorous access control may be exposed through a victim’s browser. Validate the \u003ccode\u003eHost\u003c/code\u003e header. Use HTTPS wherever possible. \u003c/p\u003e\n\n\n\n\u003cp\u003eDNS rebinding demonstrates that assumptions about network boundaries and browser security can be dangerously misleading. Be sure to include DNS rebinding into your threat model when developing your next web application. \u003c/p\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/26652396?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/26652396?v=4\u0026amp;s=200\" alt=\"Jaroslav Lobacevski\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.com/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2022/05/careers.svg\" width=\"44\" height=\"44\" alt=\"Enterprise content\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tEnterprise content\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eExecutive insights, curated just for you\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Get started; ref_location:bottom recirculation;\" href=\"https://github.com/solutions/executive-insights\" target=\"_blank\" aria-label=\"Get started\"\u003e\n\t\t\t\t\tGet started\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": "2025-06-03T16:00:00Z",
  "modifiedTime": null
}
