{
  "id": "593a4eb5-3b2b-4313-9a25-982aca76709f",
  "title": "5 ways to transform your workflow using GitHub Copilot and MCP",
  "link": "https://github.blog/ai-and-ml/github-copilot/5-ways-to-transform-your-workflow-using-github-copilot-and-mcp/",
  "description": "Learn how to streamline your development workflow with five different MCP use cases. The post 5 ways to transform your workflow using GitHub Copilot and MCP appeared first on The GitHub Blog.",
  "author": "Klint Finley",
  "published": "Wed, 02 Jul 2025 17:44:02 +0000",
  "source": "https://github.blog/feed/",
  "categories": [
    "AI \u0026 ML",
    "GitHub Copilot",
    "agent mode",
    "MCP"
  ],
  "byline": "Klint Finley",
  "length": 9338,
  "excerpt": "Learn how to streamline your development workflow with five different MCP use cases.",
  "siteName": "The GitHub Blog",
  "favicon": "https://github.blog/wp-content/uploads/2019/01/cropped-github-favicon-512.png?fit=192%2C192",
  "text": "Traditional AI coding assistants typically operate in isolation, limited to the code in your current workspace. Now with the introduction of the Model Context Protocol (MCP), AI development workflows are further evolving to incorporate more tools and context.  MCP can enable AI assistants to interact with external systems like knowledge bases, data stores, and testing applications. The real value of MCP integration is that you can now perform tasks that previously required multiple tools, context switching, and manual effort—all directly in your IDE. That means you can save time, maintain focus, and ship code faster. In this article, we’ll explore five practical ways MCP integrations with GitHub Copilot can streamline your workflow. We’ll follow a realistic scenario: implementing a secure JWT (JSON Web Token) authentication system for a web application, illustrating an end-to-end workflow with MCP. Let’s jump in.  1. Using MCP to bridge design and development with Figma  The gap between design and development has long been a source of friction in product teams. MCP provides a standardized way for GitHub Copilot to securely access and interpret design specifications directly.  Instead of manually translating design details into code, MCP enables Copilot to automatically retrieve exact design parameters—such as colors, spacing, typography, and component states—and generate accurate, ready-to-use code. This integration reduces guesswork and streamlines the handoff between designers and developers. We’ll start developing our new JWT authentication system by taking a look at the user-facing side. Let’s say the design team updated the authentication UI components in Figma, including login forms, error states, loading spinners, and success messages. Now, you need to implement these changes to match the new design system. Start by asking Copilot, “What are the latest design updates for the login form and authentication components?” It will then retrieve specs for the elements that need to change. Then you can prompt it to create React components for each element: LoginForm with exact spacing, colors, typography AuthErrorMessage component with proper error styling TokenRefreshNotification component Copilot will then give you ready-to-use code that maintains consistency with the design specifications from Figma. 2. Tap into your Obsidian knowledge base with MCP When implementing complex features like JWT authentication, you often need to reference past decisions, architectural notes, and research findings scattered across your knowledge base. The unofficial, community-maintained Obsidian MCP server bridges this gap by connecting GitHub Copilot directly to your Obsidian vault. Let’s say you’re implementing JWT token validation and need to understand your team’s previous security decisions. You tell Copilot: “Search for all files where JWT or token validation is mentioned and explain the context.” With that, Copilot can: Search across all Markdown files in your vault for relevant security patterns Retrieve contents from specific architecture decision records (ADR) Access meeting notes from previous security reviews Pull implementation guidelines from your team’s coding standards You might follow up with the following prompt: “Get the contents of the last architecture call note about authentication and summarize the key decisions.” Copilot will locate the relevant file and extract the critical information you need to inform your implementation approach. Once you’ve gathered the necessary context, you can ask Copilot to synthesize this information: “Create a new note called ‘jwt-implementation-summary.md’ that combines our authentication standards with the new JWT approach.” Copilot will create this documentation directly in your vault, helping maintain your team’s knowledge base. Setup note: This integration requires the community “Obsidian Local REST API” plugin and an API key. With your research complete and documented, you can proceed to test your application. 3. Test your code with Playwright Integrating MCP with Playwright transforms test creation from a manual, error-prone process into a simple, guided experience. Modern web applications often involve complex user journeys, asynchronous operations, and dynamic content. Authentication flows are particularly challenging to test comprehensively. Continuing with our JWT authentication system, you need to test the complete authentication flow including login, token refresh, and secure route access. To do this, you’ll start by giving Copilot a prompt like this: “Test the JWT authentication flow including login, automatic token refresh, and access to protected routes.” From there, Copilot will analyze your authentication implementation and generate comprehensive test coverage. But it doesn’t stop there. Copilot then runs the tests with Playwright and provides immediate feedback on failures, suggesting fixes for common issues, like timing problems or selector changes. 4. File pull requests faster Pull requests are the cornerstone of collaborative development. GitHub’s remote MCP server, now in public beta for VS Code or Visual Studio, helps transform the process into an intelligent, automated workflow. Turning back to our JWT authentication example, you can prompt Copilot: “Create a pull request for my authentication feature changes” Copilot will then analyze: Code changes across multiple files   Related issues and project context   Team review patterns and expertise areas   Previous similar implementations Copilot returns Markdown with an overview, changes made, a testing strategy, and even related issues. It will then suggest appropriate reviewers for each aspect of the change based on code ownership, expertise mapping, and current workload. Once your application is deployed, you can move on to monitoring it. 5. Monitor application performance With the core authentication logic handled, now it’s time to ensure that our application performs well by monitoring how it behaves in production. Using MCP to connect to Grafana through the open-source Grafana MCP server makes this easier—though setup requires a few configuration steps. Let’s say you need to analyze the JWT authentication system’s latency metrics and error rates. You tell Copilot: “Show me auth latency and error-rate panels for the auth-service dashboard for the last 6 hours.” After configuring the Grafana MCP server with your API key and host URL, Copilot can then query your Grafana instance to: Examine authentication latency metrics and p95 response times Analyze error rates for login endpoints over time Review existing alert rules for authentication services Identify patterns in failed authentication attempts Copilot returns panel data as base64-encoded images and can extract raw time-series data when needed. If you need a longer time range, you can specify: “Show me the same metrics for the last 24 hours” and Copilot will adjust the query parameters accordingly. For more advanced monitoring workflows, you can enable write operations by launching the server with the --enable-write flag and an Editor-role API key. This allows Copilot to create new alert rules or modify dashboard configurations based on your authentication metrics analysis. Learn more about the Grafana MCP server \u003e What’s next? Before diving into these powerful integrations, you’ll need to configure your development environment. Here’s how: Install MCP extensions: Enable MCP support in your IDE through official extensions Configure API access: Set up authentication for each service (GitHub, Obsidian, Figma, etc.) Define context boundaries: Establish what information should be accessible to AI Security considerations: Implement proper access controls and data privacy measures A few best practices: Start small: Begin with one integration and gradually expand your usage Maintain documentation: Keep your knowledge bases and documentation current for optimal AI assistance Regularly review Copilot’s outputs: Periodically audit AI-generated suggestions to ensure quality and security Build team alignment: Ensure your team understands and adopts consistent MCP usage patterns The five integration patterns we’ve explored represent just the beginning of what’s possible. As MCP’s ecosystem grows, new tools and integrations will continue to expand what’s possible. Get started with our remote MCP server \u003e Written by Explore more from GitHub Docs Everything you need to master GitHub, all in one place. Go to Docs GitHub Build what’s next on GitHub, the place for anyone from anywhere to build anything. Start building Customer stories Meet the companies and engineering teams that build with GitHub. Learn more GitHub Universe 2025 Last chance: Save $700 on your IRL pass to Universe and join us on Oct. 28-29 in San Francisco. Register now \u003e",
  "image": "https://github.blog/wp-content/uploads/2025/06/wallpaper-copilot-generic-logo-dark.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003csection\u003e\n\t\n\u003cp\u003eTraditional AI coding assistants typically operate in isolation, limited to the code in your current workspace. Now with the introduction of the Model Context Protocol (MCP), AI development workflows are further evolving to incorporate more tools and context. \u003c/p\u003e\n\n\n\n\u003cp\u003eMCP can enable AI assistants to interact with external systems like knowledge bases, data stores, and testing applications.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eThe real value of MCP integration is that you can now perform tasks that previously required multiple tools, context switching, and manual effort—all directly in your IDE. That means you can save time, maintain focus, and ship code faster.\u003c/p\u003e\n\n\n\n\u003cp\u003eIn this article, we’ll explore five practical ways MCP integrations with GitHub Copilot can streamline your workflow. We’ll follow a realistic scenario: implementing a secure JWT (JSON Web Token) authentication system for a web application, illustrating an end-to-end workflow with MCP.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s jump in. \u003c/p\u003e\n\n\n\n\u003ch2 id=\"1-using-mcp-to-bridge-design-and-development-with-figma\"\u003e1. Using MCP to bridge design and development with Figma \u003c/h2\u003e\n\n\n\n\u003cp\u003eThe gap between design and development has long been a source of friction in product teams. MCP provides a standardized way for GitHub Copilot to securely access and interpret design specifications directly. \u003c/p\u003e\n\n\n\n\u003cp\u003eInstead of manually translating design details into code, MCP enables Copilot to automatically retrieve exact design parameters—such as colors, spacing, typography, and component states—and generate accurate, ready-to-use code. This integration reduces guesswork and streamlines the handoff between designers and developers.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003cp\u003eWe’ll start developing our new JWT authentication system by taking a look at the user-facing side. Let’s say the design team updated the authentication UI components in Figma, including login forms, error states, loading spinners, and success messages. Now, you need to implement these changes to match the new design system.\u003c/p\u003e\n\n\n\n\u003cp\u003eStart by asking Copilot, “What are the latest design updates for the login form and authentication components?” It will then retrieve specs for the elements that need to change. Then you can prompt it to create React components for each element:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLoginForm\u003c/code\u003e with exact spacing, colors, typography\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eAuthErrorMessage\u003c/code\u003e component with proper error styling\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003ccode\u003eTokenRefreshNotification\u003c/code\u003e component\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCopilot will then give you ready-to-use code that maintains consistency with the design specifications from Figma.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch2 id=\"2-tap-into-your-obsidian-knowledge-base-with-mcp\"\u003e2. Tap into your Obsidian knowledge base with MCP\u003c/h2\u003e\n\n\n\n\u003cp\u003eWhen implementing complex features like JWT authentication, you often need to reference past decisions, architectural notes, and research findings scattered across your knowledge base. The unofficial, community-maintained Obsidian MCP server bridges this gap by connecting GitHub Copilot directly to your Obsidian vault.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s say you’re implementing JWT token validation and need to understand your team’s previous security decisions. You tell Copilot: “Search for all files where JWT or token validation is mentioned and explain the context.”\u003c/p\u003e\n\n\n\n\u003cp\u003eWith that, Copilot can:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eSearch across all Markdown files in your vault for relevant security patterns\u003c/li\u003e\n\n\n\n\u003cli\u003eRetrieve contents from specific architecture decision records (ADR)\u003c/li\u003e\n\n\n\n\u003cli\u003eAccess meeting notes from previous security reviews\u003c/li\u003e\n\n\n\n\u003cli\u003ePull implementation guidelines from your team’s coding standards\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eYou might follow up with the following prompt: “Get the contents of the last architecture call note about authentication and summarize the key decisions.” Copilot will locate the relevant file and extract the critical information you need to inform your implementation approach.\u003c/p\u003e\n\n\n\n\u003cp\u003eOnce you’ve gathered the necessary context, you can ask Copilot to synthesize this information: “Create a new note called ‘jwt-implementation-summary.md’ that combines our authentication standards with the new JWT approach.” Copilot will create this documentation directly in your vault, helping maintain your team’s knowledge base.\u003c/p\u003e\n\n\n\n\u003cp\u003e\u003cstrong\u003eSetup note\u003c/strong\u003e: This integration requires the community “Obsidian Local REST API” plugin and an API key.\u003c/p\u003e\n\n\n\n\u003cp\u003eWith your research complete and documented, you can proceed to test your application.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch2 id=\"3-test-your-code-with-playwright\"\u003e3. Test your code with Playwright\u003c/h2\u003e\n\n\n\n\u003cp\u003eIntegrating MCP with Playwright transforms test creation from a manual, error-prone process into a simple, guided experience.\u003c/p\u003e\n\n\n\n\u003cp\u003eModern web applications often involve complex user journeys, asynchronous operations, and dynamic content. Authentication flows are particularly challenging to test comprehensively.\u003c/p\u003e\n\n\n\n\u003cp\u003eContinuing with our JWT authentication system, you need to test the complete authentication flow including login, token refresh, and secure route access. To do this, you’ll start by giving Copilot a prompt like this: “Test the JWT authentication flow including login, automatic token refresh, and access to protected routes.”\u003c/p\u003e\n\n\n\n\u003cp\u003eFrom there, Copilot will analyze your authentication implementation and generate comprehensive test coverage. But it doesn’t stop there. Copilot then runs the tests with Playwright and provides immediate feedback on failures, suggesting fixes for common issues, like timing problems or selector changes.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch2 id=\"4-file-pull-requests-faster\"\u003e4. File pull requests faster\u003c/h2\u003e\n\n\n\n\u003cp\u003ePull requests are the cornerstone of collaborative development. GitHub’s remote MCP server, \u003ca href=\"https://github.blog/changelog/2025-06-12-remote-github-mcp-server-is-now-available-in-public-preview/\"\u003enow in public beta for VS Code or Visual Studio\u003c/a\u003e, helps transform the process into an intelligent, automated workflow.\u003c/p\u003e\n\n\n\n\u003cp\u003eTurning back to our JWT authentication example, you can prompt Copilot: “Create a pull request for my authentication feature changes”\u003c/p\u003e\n\n\n\n\u003cp\u003eCopilot will then analyze:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eCode changes across multiple files  \u003c/li\u003e\n\n\n\n\u003cli\u003eRelated issues and project context  \u003c/li\u003e\n\n\n\n\u003cli\u003eTeam review patterns and expertise areas  \u003c/li\u003e\n\n\n\n\u003cli\u003ePrevious similar implementations\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCopilot returns Markdown with an overview, changes made, a testing strategy, and even related issues.\u003c/p\u003e\n\n\n\n\u003cp\u003eIt will then suggest appropriate reviewers for each aspect of the change based on code ownership, expertise mapping, and current workload.\u003c/p\u003e\n\n\n\n\u003cp\u003eOnce your application is deployed, you can move on to monitoring it.\u003c/p\u003e\n\n\n\n\n\n\n\n\u003ch2 id=\"5-monitor-application-performance\"\u003e5. Monitor application performance\u003c/h2\u003e\n\n\n\n\u003cp\u003eWith the core authentication logic handled, now it’s time to ensure that our application performs well by monitoring how it behaves in production. Using MCP to connect to Grafana through the open-source Grafana MCP server makes this easier—though setup requires a few configuration steps.\u003c/p\u003e\n\n\n\n\u003cp\u003eLet’s say you need to analyze the JWT authentication system’s latency metrics and error rates. You tell Copilot: “Show me auth latency and error-rate panels for the auth-service dashboard for the last 6 hours.”\u003c/p\u003e\n\n\n\n\u003cp\u003eAfter configuring the Grafana MCP server with your API key and host URL, Copilot can then query your Grafana instance to:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003eExamine authentication latency metrics and p95 response times\u003c/li\u003e\n\n\n\n\u003cli\u003eAnalyze error rates for login endpoints over time\u003c/li\u003e\n\n\n\n\u003cli\u003eReview existing alert rules for authentication services\u003c/li\u003e\n\n\n\n\u003cli\u003eIdentify patterns in failed authentication attempts\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eCopilot returns panel data as base64-encoded images and can extract raw time-series data when needed. If you need a longer time range, you can specify: “Show me the same metrics for the last 24 hours” and Copilot will adjust the query parameters accordingly.\u003c/p\u003e\n\n\n\n\u003cp\u003eFor more advanced monitoring workflows, you can enable write operations by launching the server with the \u003ccode\u003e--enable-write\u003c/code\u003e flag and an Editor-role API key. This allows Copilot to create new alert rules or modify dashboard configurations based on your authentication metrics analysis.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eLearn more \u003c/strong\u003eabout the \u003ca href=\"https://github.com/grafana/mcp-grafana\"\u003eGrafana MCP server \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\n\n\u003ch2 id=\"whats-next\"\u003eWhat’s next?\u003c/h2\u003e\n\n\n\n\u003cp\u003eBefore diving into these powerful integrations, you’ll need to configure your development environment. Here’s how:\u003c/p\u003e\n\n\n\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eInstall MCP extensions\u003c/strong\u003e: Enable MCP support in your IDE through official extensions\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eConfigure API access\u003c/strong\u003e: Set up authentication for each service (GitHub, Obsidian, Figma, etc.)\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eDefine context boundaries\u003c/strong\u003e: Establish what information should be accessible to AI\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eSecurity considerations\u003c/strong\u003e: Implement proper access controls and data privacy measures\u003c/li\u003e\n\u003c/ol\u003e\n\n\n\n\u003cp\u003eA few best practices:\u003c/p\u003e\n\n\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStart small\u003c/strong\u003e: Begin with one integration and gradually expand your usage\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eMaintain documentation\u003c/strong\u003e: Keep your knowledge bases and documentation current for optimal AI assistance\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eRegularly review Copilot’s outputs\u003c/strong\u003e: Periodically audit AI-generated suggestions to ensure quality and security\u003c/li\u003e\n\n\n\n\u003cli\u003e\u003cstrong\u003eBuild team alignment\u003c/strong\u003e: Ensure your team understands and adopts consistent MCP usage patterns\u003c/li\u003e\n\u003c/ul\u003e\n\n\n\n\u003cp\u003eThe five integration patterns we’ve explored represent just the beginning of what’s possible. As MCP’s ecosystem grows, new tools and integrations will continue to expand what’s possible.\u003c/p\u003e\n\n\n\n\u003cdiv\u003e\n\u003cp\u003e\u003cstrong\u003eGet started\u003c/strong\u003e with our \u003ca href=\"https://docs.github.com/en/copilot/tutorials/enhancing-copilot-agent-mode-with-mcp\"\u003eremote MCP server \u0026gt;\u003c/a\u003e\u003c/p\u003e\n\u003c/div\u003e\n\n\t\n\n\t\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tWritten by\t\u003c/h2\u003e\n\t\n\t\t\t\u003carticle\u003e\n\t\u003cdiv\u003e\n\t\t\t\t\u003cpicture\u003e\n\t\t\t\t\t\u003csource srcset=\"https://avatars.githubusercontent.com/u/957053?v=4\u0026amp;s=200\" width=\"120\" height=\"120\" media=\"(min-width: 768px)\"/\u003e\n\t\t\t\t\t\u003cimg src=\"https://avatars.githubusercontent.com/u/957053?v=4\u0026amp;s=200\" alt=\"Klint Finley\" width=\"80\" height=\"80\" loading=\"lazy\" decoding=\"async\"/\u003e\n\t\t\t\t\u003c/picture\u003e\n\t\t\t\u003c/div\u003e\n\u003c/article\u003e\n\t\u003c/div\u003e\n\u003c/section\u003e\u003cdiv\u003e\n\t\u003ch2\u003e\n\t\tExplore more from GitHub\t\u003c/h2\u003e\n\t\u003cdiv\u003e\n\t\t\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg\" width=\"44\" height=\"44\" alt=\"Docs\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tDocs\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eEverything you need to master GitHub, all in one place.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Go to Docs; ref_location:bottom recirculation;\" href=\"https://docs.github.com/\" target=\"_blank\" aria-label=\"Go to Docs\"\u003e\n\t\t\t\t\tGo to Docs\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg\" width=\"44\" height=\"44\" alt=\"GitHub\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eBuild what’s next on GitHub, the place for anyone from anywhere to build anything.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Start building; ref_location:bottom recirculation;\" href=\"https://github.com/\" target=\"_blank\" aria-label=\"Start building\"\u003e\n\t\t\t\t\tStart building\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg\" width=\"44\" height=\"44\" alt=\"Customer stories\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tCustomer stories\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eMeet the companies and engineering teams that build with GitHub.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Learn more; ref_location:bottom recirculation;\" href=\"https://github.com/customer-stories\" target=\"_blank\" aria-label=\"Learn more\"\u003e\n\t\t\t\t\tLearn more\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\u003cdiv\u003e\n\t\t\u003cp\u003e\u003cimg src=\"https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg\" width=\"44\" height=\"44\" alt=\"GitHub Universe 2025\"/\u003e\u003c/p\u003e\u003ch3\u003e\n\t\t\tGitHub Universe 2025\t\t\u003c/h3\u003e\n\t\t\u003cp\u003eLast chance: Save $700 on your IRL pass to Universe and join us on Oct. 28-29 in San Francisco.\u003c/p\u003e\n\t\t\t\t\t\u003cp\u003e\n\t\t\t\t\u003ca data-analytics-click=\"Blog, click on module, text: Register now \u0026gt;; ref_location:bottom recirculation;\" href=\"https://githubuniverse.com/?utm_source=Blog\u0026amp;utm_medium=GitHub\u0026amp;utm_campaign=module\" target=\"_blank\" aria-label=\"Register now \u0026gt;\"\u003e\n\t\t\t\t\tRegister now \u0026gt;\t\t\t\t\t\t\t\t\t\t\t\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 16 16\" width=\"16\" height=\"16\"\u003e\u003cpath fill-rule=\"evenodd\" d=\"M10.604 1h4.146a.25.25 0 01.25.25v4.146a.25.25 0 01-.427.177L13.03 4.03 9.28 7.78a.75.75 0 01-1.06-1.06l3.75-3.75-1.543-1.543A.25.25 0 0110.604 1zM3.75 2A1.75 1.75 0 002 3.75v8.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 12.25v-3.5a.75.75 0 00-1.5 0v3.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-8.5a.25.25 0 01.25-.25h3.5a.75.75 0 000-1.5h-3.5z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n\t\t\t\t\t\t\t\t\t\u003c/a\u003e\n\t\t\t\u003c/p\u003e\n\t\t\t\u003c/div\u003e\n\t\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2025-07-02T17:44:02Z",
  "modifiedTime": "2025-07-02T17:44:03Z"
}
