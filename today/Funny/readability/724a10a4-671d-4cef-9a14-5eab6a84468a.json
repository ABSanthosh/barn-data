{
  "id": "724a10a4-671d-4cef-9a14-5eab6a84468a",
  "title": "CodeSOD: Not Exactly Gems",
  "link": "https://thedailywtf.com/articles/not-exactly-gems",
  "description": "Sammy's company \"jumped on the Ruby on Rails bandwagon since there was one on which to jump\", and are still very much a Rails shop. The company has been around for thirty years, and in that time has seen plenty of ups and downs. During one of those \"ups\", management decided they needed to scale up, both in terms of staffing and in terms of client base- so they hired an offshore team to promote international business and add to their staffing. A \"down\" followed not long after, and the offshore team was disbanded. So Sammy inherited the code. I know I'm generally negative on ORM systems, and that includes Rails, but I want to stress: they're fine if you stay on the happy path. If your data access patterns are simple (which most applications are just basic CRUD!) there's nothing wrong with using an ORM. But if you're doing that, you need to use the ORM. Which is not what the offshore team did. For example: class Request \u003c ActiveRecord::Base def self.get_this_years_request_ids(facility_id) # There are several other methods that are *exactly* the same, except for the year requests = Request.where(\"requests.id in (select t.id from requests as t # what is the purpose of this subquery? where t.unit_id=token_requests.unit_id and t.facility_id=token_requests.facility_id and t.survey_type = '#{TokenRequest::SURVEY_TYPE}' # why is SURVEY_TYPE a constant? and EXTRACT( YEAR FROM created_at) = EXTRACT(YEAR FROM current_timestamp) order by t.id desc) and token_requests.facility_id = #{facility_id.to_i} # so we get all the requests by year, then by by ??? and token_requests.survey_type = '#{Request::SURVEY_TYPE}'\") Comments from Sammy. Now, if we just look at the signature of the method, it seems like this should be a pretty straightforward query: get all of the request IDs for a given facility ID, within a certain time range. And Sammy has helpfully provided a version of this code which does the same thing, but in a more \"using the tools correctly\" way: def self.request_ids_for_year(facility_id,year = Time.now.year) token_requests = TokenRequest.where( :facility_id=\u003efacility_id, :survey_type=\u003eTokenRequest::SURVEY_TYPE, :created_at=\u003e(DateTime.new(year.to_i).beginning_of_year .. DateTime.new(year.to_i).end_of_year)) Now, I don't know Ruby well enough to be sure, but the DateTime.new(year.to_i) whiffs a bit of some clumsy date handling, but that may be a perfectly cromulent idiom in Ruby. But this code is pretty clear about what it's doing: finding request objects for a given facility within a given year. Why one uses Request and the other uses TokenRequest is a mystery to me- I' m going to suspect some bad normalization in the database or errors in how Sammy anonymized the code. That's neither here nor there. Once we've gotten our list of requests, we need to process them to output them. Here's how the offshore code converted the list into a comma delimited string, wrapped in parentheses. string_token_request_ids = \"(-1)\" if token_requests \u0026\u0026 token_requests.length \u003e 0 for token_request in token_requests if string_token_request_ids != \"\" string_token_request_ids = string_token_request_ids + \",\" end string_token_request_ids = string_token_request_ids + token_request.id.to_s end string_token_request_ids = \"(\" + string_token_request_ids + \")\" end end end Look, if the problem is to \"join a string with delimiters\" and you write code that looks like this, just delete your hard drive and start over. You need extra help. We start by defaulting to (-1) which is presumably a \"no results\" indicator. But if we have results, we'll iterate across those results. If our result string is non-empty (which it definitely is non-empty), we append a comma (giving us (-1),). Then we append the current token ID, giving us (-1),5, for example. Once we've exhausted all the returned IDs, we wrap the whole thing in parentheses. So, this code is wrong- it's only supposed to return (-1) when there are no results, but as written, it embeds that in the results. Presumably the consuming code is able to handle that error gracefully, since the entire project works. Sammy provides us a more idiomatic (and readable) version of the code which also works correctly: return \"(#{token_requests.count \u003e 0 ? token_requests.map(\u0026:id).join(',') : '(-1)'})\" I'll be honest, I hate the fact that this is returning a stringly-typed list of integers, but since I don't know the context, I'll let that slide. At the very least, this is a better example of what joining a list of values into a string should look like. Sammy writes: It seems these devs never took the time to learn the language. After asking around a bit, I found out they all came from a Java background. Most of this code seems to be from a VB playbook, though. That's a huge and undeserved insult to Visual Basic programmers, Sammy. Even they're not that bad. .comment{border:none;} [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "author": "Remy Porter",
  "published": "Thu, 06 Feb 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 5314,
  "excerpt": "Sammy's company \"jumped on the Ruby on Rails bandwagon since there was one on which to jump\", and are still very much a Rails shop. The company has been around for thirty years, and in that time has seen plenty of ups and downs. During one of those \"ups\", management decided they needed to scale up, both in terms of staffing and in terms of client base- so they hired an offshore team to promote international business and add to their staffing. A \"down\" followed not long after, and the offshore team was disbanded. So Sammy inherited the code.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Sammy's company \"jumped on the Ruby on Rails bandwagon since there was one on which to jump\", and are still very much a Rails shop. The company has been around for thirty years, and in that time has seen plenty of ups and downs. During one of those \"ups\", management decided they needed to scale up, both in terms of staffing and in terms of client base- so they hired an offshore team to promote international business and add to their staffing. A \"down\" followed not long after, and the offshore team was disbanded. So Sammy inherited the code. I know I'm generally negative on ORM systems, and that includes Rails, but I want to stress: they're fine if you stay on the happy path. If your data access patterns are simple (which most applications are just basic CRUD!) there's nothing wrong with using an ORM. But if you're doing that, you need to use the ORM. Which is not what the offshore team did. For example: class Request \u003c ActiveRecord::Base def self.get_this_years_request_ids(facility_id) # There are several other methods that are *exactly* the same, except for the year requests = Request.where(\"requests.id in (select t.id from requests as t # what is the purpose of this subquery? where t.unit_id=token_requests.unit_id and t.facility_id=token_requests.facility_id and t.survey_type = '#{TokenRequest::SURVEY_TYPE}' # why is SURVEY_TYPE a constant? and EXTRACT( YEAR FROM created_at) = EXTRACT(YEAR FROM current_timestamp) order by t.id desc) and token_requests.facility_id = #{facility_id.to_i} # so we get all the requests by year, then by by ??? and token_requests.survey_type = '#{Request::SURVEY_TYPE}'\") Comments from Sammy. Now, if we just look at the signature of the method, it seems like this should be a pretty straightforward query: get all of the request IDs for a given facility ID, within a certain time range. And Sammy has helpfully provided a version of this code which does the same thing, but in a more \"using the tools correctly\" way: def self.request_ids_for_year(facility_id,year = Time.now.year) token_requests = TokenRequest.where( :facility_id=\u003efacility_id, :survey_type=\u003eTokenRequest::SURVEY_TYPE, :created_at=\u003e(DateTime.new(year.to_i).beginning_of_year .. DateTime.new(year.to_i).end_of_year)) Now, I don't know Ruby well enough to be sure, but the DateTime.new(year.to_i) whiffs a bit of some clumsy date handling, but that may be a perfectly cromulent idiom in Ruby. But this code is pretty clear about what it's doing: finding request objects for a given facility within a given year. Why one uses Request and the other uses TokenRequest is a mystery to me- I' m going to suspect some bad normalization in the database or errors in how Sammy anonymized the code. That's neither here nor there. Once we've gotten our list of requests, we need to process them to output them. Here's how the offshore code converted the list into a comma delimited string, wrapped in parentheses. string_token_request_ids = \"(-1)\" if token_requests \u0026\u0026 token_requests.length \u003e 0 for token_request in token_requests if string_token_request_ids != \"\" string_token_request_ids = string_token_request_ids + \",\" end string_token_request_ids = string_token_request_ids + token_request.id.to_s end string_token_request_ids = \"(\" + string_token_request_ids + \")\" end end end Look, if the problem is to \"join a string with delimiters\" and you write code that looks like this, just delete your hard drive and start over. You need extra help. We start by defaulting to (-1) which is presumably a \"no results\" indicator. But if we have results, we'll iterate across those results. If our result string is non-empty (which it definitely is non-empty), we append a comma (giving us (-1),). Then we append the current token ID, giving us (-1),5, for example. Once we've exhausted all the returned IDs, we wrap the whole thing in parentheses. So, this code is wrong- it's only supposed to return (-1) when there are no results, but as written, it embeds that in the results. Presumably the consuming code is able to handle that error gracefully, since the entire project works. Sammy provides us a more idiomatic (and readable) version of the code which also works correctly: return \"(#{token_requests.count \u003e 0 ? token_requests.map(\u0026:id).join(',') : '(-1)'})\" I'll be honest, I hate the fact that this is returning a stringly-typed list of integers, but since I don't know the context, I'll let that slide. At the very least, this is a better example of what joining a list of values into a string should look like. Sammy writes: It seems these devs never took the time to learn the language. After asking around a bit, I found out they all came from a Java background. Most of this code seems to be from a VB playbook, though. That's a huge and undeserved insult to Visual Basic programmers, Sammy. Even they're not that bad. [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eSammy\u003c/strong\u003e\u0026#39;s company \u0026#34;jumped on the Ruby on Rails bandwagon since there was one on which to jump\u0026#34;, and are still very much a Rails shop. The company has been around for thirty years, and in that time has seen plenty of ups and downs. During one of those \u0026#34;ups\u0026#34;, management decided they needed to scale up, both in terms of staffing \u003cem\u003eand\u003c/em\u003e in terms of client base- so they hired an offshore team to promote international business and add to their staffing.\u003c/p\u003e\n\u003cp\u003eA \u0026#34;down\u0026#34; followed not long after, and the offshore team was disbanded. So Sammy inherited the code.\u003c/p\u003e\n\u003cp\u003eI know I\u0026#39;m generally negative on ORM systems, and that includes Rails, but I want to stress: they\u0026#39;re \u003cem\u003efine\u003c/em\u003e if you stay on the happy path. If your data access patterns are simple (which most applications are just basic \u003cabbr title=\"Create Read Update Delete\"\u003eCRUD\u003c/abbr\u003e!) there\u0026#39;s nothing wrong with using an ORM. But if you\u0026#39;re doing that, you \u003cem\u003eneed to use\u003c/em\u003e the ORM. Which is not what the offshore team did. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eRequest\u003c/span\u003e \u0026lt; \u003cspan\u003eActiveRecord::Base\u003c/span\u003e\n  \u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e.get_this_years_request_ids(facility_id)  \u003cspan\u003e# There are several other methods that are *exactly* the same, except for the year\u003c/span\u003e\n\n      requests = Request.where(\u003cspan\u003e\u0026#34;requests.id in (select t.id from requests as t                    # what is the purpose of this subquery?\n              where t.unit_id=token_requests.unit_id and t.facility_id=token_requests.facility_id\n              and t.survey_type = \u0026#39;\u003cspan\u003e#{TokenRequest::\u003cspan\u003eSURVEY_TYPE\u003c/span\u003e}\u003c/span\u003e\u0026#39;                                  # why is SURVEY_TYPE a constant?\n              and EXTRACT( YEAR FROM created_at) = EXTRACT(YEAR FROM current_timestamp)          \n                 order by t.id desc) and token_requests.facility_id = \u003cspan\u003e#{facility_id.to_i}\u003c/span\u003e         # so we get all the requests by year, then by by ???\n                 and token_requests.survey_type = \u0026#39;\u003cspan\u003e#{Request::\u003cspan\u003eSURVEY_TYPE\u003c/span\u003e}\u003c/span\u003e\u0026#39;\u0026#34;\u003c/span\u003e)               \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eComments from Sammy.\u003c/p\u003e\n\u003cp\u003eNow, if we just look at the signature of the method, it seems like this should be a pretty straightforward query: get all of the request IDs for a given facility ID, within a certain time range.\u003c/p\u003e\n\u003cp\u003eAnd Sammy has helpfully provided a version of this code which does the same thing, but in a more \u0026#34;using the tools correctly\u0026#34; way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003edef\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e.request_ids_for_year(facility_id,year = Time.now.year)\n   \n    token_requests = TokenRequest.where(\n                              \u003cspan\u003e:facility_id=\u0026gt;facility_id\u003c/span\u003e,\n                              \u003cspan\u003e:survey_type=\u0026gt;TokenRequest\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e:SURVEY_TYPE\u003c/span\u003e,\n                              \u003cspan\u003e:created_at=\u0026gt;\u003c/span\u003e(\u003cspan\u003eDateTime\u003c/span\u003e.new(year.to_i).beginning_of_year .. \u003cspan\u003eDateTime\u003c/span\u003e.new(year.to_i).end_of_year))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, I don\u0026#39;t know Ruby well enough to be sure, but the \u003ccode\u003eDateTime.new(year.to_i)\u003c/code\u003e whiffs a bit of some clumsy date handling, but that may be a perfectly cromulent idiom in Ruby. But this code is pretty clear about what it\u0026#39;s doing: finding request objects for a given facility within a given year. Why one uses \u003ccode\u003eRequest\u003c/code\u003e and the other uses \u003ccode\u003eTokenRequest\u003c/code\u003e is a mystery to me- I\u0026#39;\tm going to suspect some bad normalization in the database or errors in how Sammy anonymized the code. That\u0026#39;s neither here nor there.\u003c/p\u003e\n\u003cp\u003eOnce we\u0026#39;ve gotten our list of requests, we need to process them to output them. Here\u0026#39;s how the offshore code converted the list into a comma delimited string, wrapped in parentheses.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\tstring_token_request_ids = \u003cspan\u003e\u0026#34;(-1)\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eif\u003c/span\u003e token_requests \u0026amp;\u0026amp; token_requests.length \u0026gt; \u003cspan\u003e0\u003c/span\u003e\n      \u003cspan\u003efor\u003c/span\u003e token_request \u003cspan\u003ein\u003c/span\u003e token_requests\n        \u003cspan\u003eif\u003c/span\u003e string_token_request_ids != \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e\n          string_token_request_ids = string_token_request_ids + \u003cspan\u003e\u0026#34;,\u0026#34;\u003c/span\u003e\n        \u003cspan\u003eend\u003c/span\u003e\n        string_token_request_ids = string_token_request_ids + token_request.id.to_s\n      \u003cspan\u003eend\u003c/span\u003e\n        string_token_request_ids = \u003cspan\u003e\u0026#34;(\u0026#34;\u003c/span\u003e + string_token_request_ids + \u003cspan\u003e\u0026#34;)\u0026#34;\u003c/span\u003e\n    \u003cspan\u003eend\u003c/span\u003e\n  \u003cspan\u003eend\u003c/span\u003e\n\u003cspan\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLook, if the problem is to \u0026#34;join a string with delimiters\u0026#34; and you write code that looks like this, just delete your hard drive and start over. You need extra help.\u003c/p\u003e\n\u003cp\u003eWe start by defaulting to \u003ccode\u003e(-1)\u003c/code\u003e which is presumably a \u0026#34;no results\u0026#34; indicator. But if we have results, we\u0026#39;ll iterate across those results. If our result string is non-empty (which it definitely is non-empty), we append a comma (giving us \u003ccode\u003e(-1),\u003c/code\u003e). Then we append the current token ID, giving us \u003ccode\u003e(-1),5\u003c/code\u003e, for example. Once we\u0026#39;ve exhausted all the returned IDs, we wrap the whole thing in parentheses.\u003c/p\u003e\n\u003cp\u003eSo, this code is \u003cem\u003ewrong\u003c/em\u003e- it\u0026#39;s only supposed to return \u003ccode\u003e(-1)\u003c/code\u003e when there are no results, but as written, it embeds that in the results. Presumably the consuming code is able to handle that error gracefully, since the entire project \u003cem\u003eworks\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eSammy provides us a more idiomatic (and readable) version of the code which also works correctly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e\u0026#34;(\u003cspan\u003e#{token_requests.count \u0026gt; \u003cspan\u003e0\u003c/span\u003e ? token_requests.map(\u0026amp;\u003cspan\u003e:id\u003c/span\u003e).join(\u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e) : \u003cspan\u003e\u0026#39;(-1)\u0026#39;\u003c/span\u003e}\u003c/span\u003e)\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI\u0026#39;ll be honest, I hate the fact that this is returning a stringly-typed list of integers, but since I don\u0026#39;t know the context, I\u0026#39;ll let that slide. At the very least, this is a better example of what joining a list of values into a string \u003cem\u003eshould\u003c/em\u003e look like.\u003c/p\u003e\n\u003cp\u003eSammy writes:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt seems these devs never took the time to learn the language. After asking around a bit, I found out they all came from a Java background. Most of this code seems to be from a VB playbook, though.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat\u0026#39;s a huge and undeserved insult to Visual Basic programmers, Sammy. Even they\u0026#39;re not that bad.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eUtilize BuildMaster\u003c/a\u003e to release your software with confidence, at the pace your business demands. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eDownload\u003c/a\u003e today!  \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "6 min read",
  "publishedTime": "2025-02-06T06:30:00Z",
  "modifiedTime": null
}
