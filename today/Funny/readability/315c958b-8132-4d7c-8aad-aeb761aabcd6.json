{
  "id": "315c958b-8132-4d7c-8aad-aeb761aabcd6",
  "title": "CodeSOD: Pulling at the Start of a Thread",
  "link": "https://thedailywtf.com/articles/pulling-at-the-start-of-a-thread",
  "description": "For testing networking systems, load simulators are useful: send a bunch of realistic looking traffic and see what happens as you increase the amount of sent traffic. These sorts of simulators often rely on being heavily multithreaded, since one computer can, if pushed, generate a lot of network traffic. Thus, when Jonas inherited a heavily multithreaded system for simulating load, that wasn't a surprise. The surprise was that the developer responsible for it didn't really understand threading in Java. Probably in other languages too, but in this case, Java was what they were using. public void startTraffic() { Configuration.instance.inititiateStatistics(); Statistics.instance.addStatisticListener(gui); if (t != null) { if (t.isAlive()) { t.destroy(); } } t = new Thread(this); t.start(); } Look, this is not a good way to manage threads in Java. I don't know if I'd call it a WTF, but it's very much a \"baby's first threading\" approach. There are better abstractions around threads that would avoid the need to manage thread instances directly. I certainly don't love situations where a Runnable also manages its own thread instance. This is almost certainly a race condition, but I don't know if this function is called from multiple threads (but I suspect it might be). But what's more interesting is where this code gets called. You see, starting a thread could trigger an exception, so you need to handle that: public void run() { while (true) { try { loaderMain.startTraffic(); break; } catch (Exception e) { System.out.println(\"Exception in main loader thread!\"); e.printStackTrace(); } } } Inside of an infinite loop, we try to start traffic. If we succeed, we break out of the loop. If we fail, well, we try and try again and again and again and again and again and again… Jonas writes: Since I'm the only one that dares to wade through the opaque mess of code that somehow, against all odds, manages to work most of the time, I get to fix it whenever it presents strange behavior. I suspect it's going to present much more strange behavior in the future. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "author": "Remy Porter",
  "published": "Thu, 01 May 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2882,
  "excerpt": "For testing networking systems, load simulators are useful: send a bunch of realistic looking traffic and see what happens as you increase the amount of sent traffic. These sorts of simulators often rely on being heavily multithreaded, since one computer can, if pushed, generate a lot of network traffic. Thus, when Jonas inherited a heavily multithreaded system for simulating load, that wasn't a surprise. The surprise was that the developer responsible for it didn't really understand threading in Java. Probably in other languages too, but in this case, Java was what they were using.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-05-01 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. For testing networking systems, load simulators are useful: send a bunch of realistic looking traffic and see what happens as you increase the amount of sent traffic. These sorts of simulators often rely on being heavily multithreaded, since one computer can, if pushed, generate a lot of network traffic. Thus, when Jonas inherited a heavily multithreaded system for simulating load, that wasn't a surprise. The surprise was that the developer responsible for it didn't really understand threading in Java. Probably in other languages too, but in this case, Java was what they were using. public void startTraffic() { Configuration.instance.inititiateStatistics(); Statistics.instance.addStatisticListener(gui); if (t != null) { if (t.isAlive()) { t.destroy(); } } t = new Thread(this); t.start(); } Look, this is not a good way to manage threads in Java. I don't know if I'd call it a WTF, but it's very much a \"baby's first threading\" approach. There are better abstractions around threads that would avoid the need to manage thread instances directly. I certainly don't love situations where a Runnable also manages its own thread instance. This is almost certainly a race condition, but I don't know if this function is called from multiple threads (but I suspect it might be). But what's more interesting is where this code gets called. You see, starting a thread could trigger an exception, so you need to handle that: public void run() { while (true) { try { loaderMain.startTraffic(); break; } catch (Exception e) { System.out.println(\"Exception in main loader thread!\"); e.printStackTrace(); } } } Inside of an infinite loop, we try to start traffic. If we succeed, we break out of the loop. If we fail, well, we try and try again and again and again and again and again and again… Jonas writes: Since I'm the only one that dares to wade through the opaque mess of code that somehow, against all odds, manages to work most of the time, I get to fix it whenever it presents strange behavior. I suspect it's going to present much more strange behavior in the future. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-05-01\"\u003e2025-05-01\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10904\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eFor testing networking systems, load simulators are useful: send a bunch of realistic looking traffic and see what happens as you increase the amount of sent traffic. These sorts of simulators often rely on being heavily multithreaded, since one computer can, if pushed, generate a lot of network traffic.\u003c/p\u003e\n\u003cp\u003eThus, when \u003cstrong\u003eJonas\u003c/strong\u003e inherited a heavily multithreaded system for simulating load, \u003cem\u003ethat\u003c/em\u003e wasn\u0026#39;t a surprise. The surprise was that the developer responsible for it didn\u0026#39;t really understand threading in Java. Probably in other languages too, but in this case, Java was what they were using.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e        \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003estartTraffic\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        {\n            Configuration.instance.inititiateStatistics();\n            Statistics.instance.addStatisticListener(gui);\n           \n            \u003cspan\u003eif\u003c/span\u003e (t != \u003cspan\u003enull\u003c/span\u003e)\n            {\n                \u003cspan\u003eif\u003c/span\u003e (t.isAlive())\n                {\n                    t.destroy();\n                }\n            }\n           \n            t = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eThread\u003c/span\u003e(\u003cspan\u003ethis\u003c/span\u003e);\n            t.start();\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLook, this is \u003cem\u003enot\u003c/em\u003e a good way to manage threads in Java. I don\u0026#39;t know if I\u0026#39;d call it a WTF, but it\u0026#39;s very much a \u0026#34;baby\u0026#39;s first threading\u0026#34; approach. There are better abstractions around threads that would avoid the need to manage thread instances directly. I certainly don\u0026#39;t love situations where a \u003ccode\u003eRunnable\u003c/code\u003e also manages its own thread instance.\u003c/p\u003e\n\u003cp\u003eThis is almost certainly a race condition, but I don\u0026#39;t know if this function is called from multiple threads (but I suspect it might be).\u003c/p\u003e\n\u003cp\u003eBut what\u0026#39;s more interesting is where this code gets called. You see, starting a thread \u003cem\u003ecould\u003c/em\u003e trigger an exception, so you need to handle that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e        \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        {\n            \u003cspan\u003ewhile\u003c/span\u003e (\u003cspan\u003etrue\u003c/span\u003e)\n            {\n                \u003cspan\u003etry\u003c/span\u003e\n                {\n                    loaderMain.startTraffic();\n                    \u003cspan\u003ebreak\u003c/span\u003e;\n                }\n                \u003cspan\u003ecatch\u003c/span\u003e (Exception e)\n                {\n                    System.out.println(\u003cspan\u003e\u0026#34;Exception in main loader thread!\u0026#34;\u003c/span\u003e);\n                    e.printStackTrace();\n                }\n            }\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInside of an infinite loop, we try to start traffic. If we succeed, we break out of the loop. If we fail, well, we try and try again and again and again and again and again and again…\u003c/p\u003e\n\u003cp\u003eJonas writes:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSince I\u0026#39;m the only one that dares to wade through the opaque mess of code that somehow, against all odds, manages to work most of the time, I get to fix it whenever it presents strange behavior.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI suspect it\u0026#39;s going to present much more strange behavior in the future.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tProGet’s got you covered with security and access controls on your NuGet feeds. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=GotYouCoveredFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-05-01T06:30:00Z",
  "modifiedTime": null
}
