{
  "id": "e3623fe9-fe46-4504-bc6b-77192c6e0b24",
  "title": "CodeSOD: Join Us in this Query",
  "link": "https://thedailywtf.com/articles/join-us-in-this-query",
  "description": "Today's anonymous submitter worked for a \"large, US-based, e-commerce company.\" This particular company was, some time back, looking to save money, and like so many companies do, that meant hiring offshore contractors. Now, I want to stress, there's certainly nothing magical about national borders which turns software engineers into incompetents. The reality is simply that contractors never have their client's best interests at heart; they only want to be good enough to complete their contract. This gets multiplied by the contracting firm's desire to maximize their profits by keeping their contractors as booked as possible. And it gets further multiplied by the remoteness and siloing of the interaction, especially across timezones. Often, the customer sends out requirements, and three months later gets a finished feature, with no more contact than that- and it never goes well. All that said, let's look at some SQL Server code. It's long, so we'll take it in chunks. -- =============================================================================== -- Author : Ignacius Ignoramus -- Create date: 04-12-2020 -- Description: SP of Getting Discrepancy of Allocation Reconciliation Snapshot -- =============================================================================== That the comment reinforces that this is an \"SP\", aka stored procedure, is already not my favorite thing to see. The description is certainly made up of words, and I think I get the gist. ALTER PROCEDURE [dbo].[Discrepency] ( @startDate DATETIME, @endDate DATETIME ) AS BEGIN Nothing really to see here; it's easy to see that we're going to run a query for a date range. That's fine and common. DECLARE @tblReturn TABLE ( intOrderItemId INT ) Hmm. T-SQL lets you define table variables, which are exactly what they sound like. It's a local variable in this procedure, that acts like a table. You can insert/update/delete/query it. The vague name is a little sketch, and the fact that it holds only one field also makes me go \"hmmm\", but this isn't bad. DECLARE @tblReturn1 TABLE ( intOrderItemId INT ) Uh oh. DECLARE @tblReturn2 TABLE ( intOrderItemId INT ) Oh no. DECLARE @tblReturn3 TABLE ( intOrderItemId INT ) Oh no no no. DECLARE @tblReturn4 TABLE ( intOrderItemId INT ) This doesn't bode well. So they've declared five variables called tblReturn, that all hold the same data structure. What happens next? This next block is gonna be long. INSERT INTO @tblReturn --(intOrderItemId) VALUES (@_ordersToBeAllocated) /* OrderItemsPlaced */ select intOrderItemId from CompanyDatabase..Orders o inner join CompanyDatabase..OrderItems oi on oi.intOrderId = o.intOrderId where o.dtmTimeStamp between @startDate and @endDate AND intOrderItemId Not In ( /* _itemsOnBackorder */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and oi.strstatus='backordered' ) AND intOrderItemId Not In ( /* _itemsOnHold */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='ONHOLD' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /* _itemsOnReview */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='REVIEW' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /*_itemsOnPending*/ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='PENDING' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /*_itemsCancelled */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and oi.strstatus='CANCELLED' ) We insert into @tblReturn the result of a query, and this query relies heavily on using a big pile of subqueries to decide if a record should be included in the output- but these subqueries all query the same tables as the root query. I'm fairly certain this could be a simple join with a pretty readable where clause, but I'm also not going to sit here and rewrite it right now, we've got a lot more query to look at. INSERT INTO @tblReturn1 /* _backOrderItemsReleased */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..orders o on o.intorderid = oi.intorderid where oi.intOrderItemid in ( select intRecordID from CompanyDatabase..StatusChangeLog where strRecordType = 'OrderItem' and strOldStatus in ('BACKORDERED') and strNewStatus in ('NEW', 'RECYCLED') and dtmTimeStamp between @startDate and @endDate ) and o.dtmTimeStamp \u003c @startDate UNION ( /*_pendingHoldItemsReleased*/ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..orders o on o.intorderid = oi.intorderid where oi.intOrderID in ( select intRecordID from CompanyDatabase..StatusChangeLog where strRecordType = 'Order' and strOldStatus in ('REVIEW', 'ONHOLD', 'PENDING') and strNewStatus in ('NEW', 'PROCESSING') and dtmTimeStamp between @startDate and @endDate ) and o.dtmTimeStamp \u003c @startDate ) UNION /* _reallocationsowingtonostock */ ( select oi.intOrderItemID from CompanyDatabase.dbo.StatusChangeLog inner join CompanyDatabase.dbo.OrderItems oi on oi.intOrderItemID = CompanyDatabase.dbo.StatusChangeLog.intRecordID inner join CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId where strOldStatus = 'RECYCLED' and strNewStatus = 'ALLOCATED' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003e @endDate and strRecordType = 'OrderItem' and intRecordId in ( select intRecordId from CompanyDatabase.dbo.StatusChangeLog where strOldStatus = 'ALLOCATED' and strNewStatus = 'RECYCLED' and strRecordType = 'OrderItem' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp between @startDate and @endDate ) ) Okay, just some unions with more subquery filtering. More of the same. It's the next one that makes this special. INSERT INTO @tblReturn2 SELECT intOrderItemId FROM @tblReturn UNION SELECT intOrderItemId FROM @tblReturn1 Ah, here's the stuff. This is just bonkers. If the goal is to combine the results of these queries into a single table, you could just insert into one table the whole time. But we know that there are 5 of these tables, so why are we only going through the first two to combine them at this point? INSERT INTO @tblReturn3 /* _factoryAllocation*/ select oi.intOrderItemId from CompanyDatabase..Shipments s inner join CompanyDatabase..ShipmentItems si on si.intShipmentID = s.intShipmentID inner join Common.CompanyDatabase.Stores stores on stores.intStoreID = s.intLocationID inner join CompanyDatabase..OrderItems oi on oi.intOrderItemId = si.intOrderItemId inner join CompanyDatabase..Orders o on o.intOrderId = s.intOrderId where s.dtmTimestamp \u003e= @endDate and stores.strLocationType = 'FACTORY' UNION ( /*_storeAllocations*/ select oi.intOrderItemId from CompanyDatabase..Shipments s inner join CompanyDatabase..ShipmentItems si on si.intShipmentID = s.intShipmentID inner join Common.CompanyDatabase.Stores stores on stores.intStoreID = s.intLocationID inner join CompanyDatabase..OrderItems oi on oi.intOrderItemId = si.intOrderItemId inner join CompanyDatabase..Orders o on o.intOrderId = s.intOrderId where s.dtmTimestamp \u003e= @endDate and stores.strLocationType \u003c\u003e 'FACTORY' ) UNION ( /* _ordersWithAllocationProblems */ select oi.intOrderItemId from CompanyDatabase.dbo.StatusChangeLog inner join CompanyDatabase.dbo.OrderItems oi on oi.intOrderItemID = CompanyDatabase.dbo.StatusChangeLog.intRecordID inner join CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId where strRecordType = 'orderitem' and strNewStatus = 'PROBLEM' and strOldStatus = 'NEW' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003e @endDate and o.dtmTimestamp \u003c @endDate ) Okay, @tblReturn3 is more of the same. Nothing more to really add. INSERT INTO @tblReturn4 SELECT intOrderItemId FROM @tblReturn2 WHERE intOrderItemId NOT IN(SELECT intOrderItemId FROM @tblReturn3 ) Ooh, but here we see something a bit different- we're taking the set difference between @tblReturn2 and @tblReturn3. This would almost make sense if there weren't already set operations in T-SQL which would handle all of this. Which brings us, finally, to the last query in the whole thing: SELECT o.intOrderId ,oi.intOrderItemId ,o.dtmDate ,oi.strDescription ,o.strFirstName + o.strLastName AS 'Name' ,o.strEmail ,o.strBillingCountry ,o.strShippingCountry FROM CompanyDatabase.dbo.OrderItems oi INNER JOIN CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId WHERE oi.intOrderItemId IN (SELECT intOrderItemId FROM @tblReturn4) END At the end of all this, I've determined a few things. First, the developer responsible didn't understand table variables. Second,they definitely didn't understand joins. Third, they had no sense of the overall workflow of this query and just sorta fumbled through until they got results that the client said were okay. And somehow, this pile of trash made it through a code review by internal architects and got deployed to production, where it promptly became the worst performing query in their application. Correction: the worst performing query thus far. [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "author": "Remy Porter",
  "published": "Wed, 02 Apr 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 10393,
  "excerpt": "Today's anonymous submitter worked for a \"large, US-based, e-commerce company.\" This particular company was, some time back, looking to save money, and like so many companies do, that meant hiring offshore contractors. Now, I want to stress, there's certainly nothing magical about national borders which turns software engineers into incompetents. The reality is simply that contractors never have their client's best interests at heart; they only want to be good enough to complete their contract. This gets multiplied by the contracting firm's desire to maximize their profits by keeping their contractors as booked as possible. And it gets further multiplied by the remoteness and siloing of the interaction, especially across timezones. Often, the customer sends out requirements, and three months later gets a finished feature, with no more contact than that- and it never goes well.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Today's anonymous submitter worked for a \"large, US-based, e-commerce company.\" This particular company was, some time back, looking to save money, and like so many companies do, that meant hiring offshore contractors. Now, I want to stress, there's certainly nothing magical about national borders which turns software engineers into incompetents. The reality is simply that contractors never have their client's best interests at heart; they only want to be good enough to complete their contract. This gets multiplied by the contracting firm's desire to maximize their profits by keeping their contractors as booked as possible. And it gets further multiplied by the remoteness and siloing of the interaction, especially across timezones. Often, the customer sends out requirements, and three months later gets a finished feature, with no more contact than that- and it never goes well. All that said, let's look at some SQL Server code. It's long, so we'll take it in chunks. -- =============================================================================== -- Author : Ignacius Ignoramus -- Create date: 04-12-2020 -- Description: SP of Getting Discrepancy of Allocation Reconciliation Snapshot -- =============================================================================== That the comment reinforces that this is an \"SP\", aka stored procedure, is already not my favorite thing to see. The description is certainly made up of words, and I think I get the gist. ALTER PROCEDURE [dbo].[Discrepency] ( @startDate DATETIME, @endDate DATETIME ) AS BEGIN Nothing really to see here; it's easy to see that we're going to run a query for a date range. That's fine and common. DECLARE @tblReturn TABLE ( intOrderItemId INT ) Hmm. T-SQL lets you define table variables, which are exactly what they sound like. It's a local variable in this procedure, that acts like a table. You can insert/update/delete/query it. The vague name is a little sketch, and the fact that it holds only one field also makes me go \"hmmm\", but this isn't bad. DECLARE @tblReturn1 TABLE ( intOrderItemId INT ) Uh oh. DECLARE @tblReturn2 TABLE ( intOrderItemId INT ) Oh no. DECLARE @tblReturn3 TABLE ( intOrderItemId INT ) Oh no no no. DECLARE @tblReturn4 TABLE ( intOrderItemId INT ) This doesn't bode well. So they've declared five variables called tblReturn, that all hold the same data structure. What happens next? This next block is gonna be long. INSERT INTO @tblReturn --(intOrderItemId) VALUES (@_ordersToBeAllocated) /* OrderItemsPlaced */ select intOrderItemId from CompanyDatabase..Orders o inner join CompanyDatabase..OrderItems oi on oi.intOrderId = o.intOrderId where o.dtmTimeStamp between @startDate and @endDate AND intOrderItemId Not In ( /* _itemsOnBackorder */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and oi.strstatus='backordered' ) AND intOrderItemId Not In ( /* _itemsOnHold */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='ONHOLD' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /* _itemsOnReview */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='REVIEW' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /*_itemsOnPending*/ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and o.strstatus='PENDING' and oi.strStatus \u003c\u003e 'BACKORDERED' ) AND intOrderItemId Not In ( /*_itemsCancelled */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..Orders o on o.intOrderId = oi.intOrderId where o.dtmTimeStamp between @startDate and @endDate and oi.strstatus='CANCELLED' ) We insert into @tblReturn the result of a query, and this query relies heavily on using a big pile of subqueries to decide if a record should be included in the output- but these subqueries all query the same tables as the root query. I'm fairly certain this could be a simple join with a pretty readable where clause, but I'm also not going to sit here and rewrite it right now, we've got a lot more query to look at. INSERT INTO @tblReturn1 /* _backOrderItemsReleased */ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..orders o on o.intorderid = oi.intorderid where oi.intOrderItemid in ( select intRecordID from CompanyDatabase..StatusChangeLog where strRecordType = 'OrderItem' and strOldStatus in ('BACKORDERED') and strNewStatus in ('NEW', 'RECYCLED') and dtmTimeStamp between @startDate and @endDate ) and o.dtmTimeStamp \u003c @startDate UNION ( /*_pendingHoldItemsReleased*/ select intOrderItemId from CompanyDatabase..OrderItems oi inner join CompanyDatabase..orders o on o.intorderid = oi.intorderid where oi.intOrderID in ( select intRecordID from CompanyDatabase..StatusChangeLog where strRecordType = 'Order' and strOldStatus in ('REVIEW', 'ONHOLD', 'PENDING') and strNewStatus in ('NEW', 'PROCESSING') and dtmTimeStamp between @startDate and @endDate ) and o.dtmTimeStamp \u003c @startDate ) UNION /* _reallocationsowingtonostock */ ( select oi.intOrderItemID from CompanyDatabase.dbo.StatusChangeLog inner join CompanyDatabase.dbo.OrderItems oi on oi.intOrderItemID = CompanyDatabase.dbo.StatusChangeLog.intRecordID inner join CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId where strOldStatus = 'RECYCLED' and strNewStatus = 'ALLOCATED' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003e @endDate and strRecordType = 'OrderItem' and intRecordId in ( select intRecordId from CompanyDatabase.dbo.StatusChangeLog where strOldStatus = 'ALLOCATED' and strNewStatus = 'RECYCLED' and strRecordType = 'OrderItem' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp between @startDate and @endDate ) ) Okay, just some unions with more subquery filtering. More of the same. It's the next one that makes this special. INSERT INTO @tblReturn2 SELECT intOrderItemId FROM @tblReturn UNION SELECT intOrderItemId FROM @tblReturn1 Ah, here's the stuff. This is just bonkers. If the goal is to combine the results of these queries into a single table, you could just insert into one table the whole time. But we know that there are 5 of these tables, so why are we only going through the first two to combine them at this point? INSERT INTO @tblReturn3 /* _factoryAllocation*/ select oi.intOrderItemId from CompanyDatabase..Shipments s inner join CompanyDatabase..ShipmentItems si on si.intShipmentID = s.intShipmentID inner join Common.CompanyDatabase.Stores stores on stores.intStoreID = s.intLocationID inner join CompanyDatabase..OrderItems oi on oi.intOrderItemId = si.intOrderItemId inner join CompanyDatabase..Orders o on o.intOrderId = s.intOrderId where s.dtmTimestamp \u003e= @endDate and stores.strLocationType = 'FACTORY' UNION ( /*_storeAllocations*/ select oi.intOrderItemId from CompanyDatabase..Shipments s inner join CompanyDatabase..ShipmentItems si on si.intShipmentID = s.intShipmentID inner join Common.CompanyDatabase.Stores stores on stores.intStoreID = s.intLocationID inner join CompanyDatabase..OrderItems oi on oi.intOrderItemId = si.intOrderItemId inner join CompanyDatabase..Orders o on o.intOrderId = s.intOrderId where s.dtmTimestamp \u003e= @endDate and stores.strLocationType \u003c\u003e 'FACTORY' ) UNION ( /* _ordersWithAllocationProblems */ select oi.intOrderItemId from CompanyDatabase.dbo.StatusChangeLog inner join CompanyDatabase.dbo.OrderItems oi on oi.intOrderItemID = CompanyDatabase.dbo.StatusChangeLog.intRecordID inner join CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId where strRecordType = 'orderitem' and strNewStatus = 'PROBLEM' and strOldStatus = 'NEW' and CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003e @endDate and o.dtmTimestamp \u003c @endDate ) Okay, @tblReturn3 is more of the same. Nothing more to really add. INSERT INTO @tblReturn4 SELECT intOrderItemId FROM @tblReturn2 WHERE intOrderItemId NOT IN(SELECT intOrderItemId FROM @tblReturn3 ) Ooh, but here we see something a bit different- we're taking the set difference between @tblReturn2 and @tblReturn3. This would almost make sense if there weren't already set operations in T-SQL which would handle all of this. Which brings us, finally, to the last query in the whole thing: SELECT o.intOrderId ,oi.intOrderItemId ,o.dtmDate ,oi.strDescription ,o.strFirstName + o.strLastName AS 'Name' ,o.strEmail ,o.strBillingCountry ,o.strShippingCountry FROM CompanyDatabase.dbo.OrderItems oi INNER JOIN CompanyDatabase.dbo.Orders o on o.intOrderId = oi.intOrderId WHERE oi.intOrderItemId IN (SELECT intOrderItemId FROM @tblReturn4) END At the end of all this, I've determined a few things. First, the developer responsible didn't understand table variables. Second,they definitely didn't understand joins. Third, they had no sense of the overall workflow of this query and just sorta fumbled through until they got results that the client said were okay. And somehow, this pile of trash made it through a code review by internal architects and got deployed to production, where it promptly became the worst performing query in their application. Correction: the worst performing query thus far. [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eToday\u0026#39;s anonymous submitter worked for a \u0026#34;large, US-based, e-commerce company.\u0026#34; This particular company was, some time back, looking to save money, and like so many companies do, that meant hiring offshore contractors.\u003c/p\u003e\n\u003cp\u003eNow, I want to stress, there\u0026#39;s certainly nothing magical about national borders which turns software engineers into incompetents. The reality is simply that \u003cem\u003econtractors\u003c/em\u003e never have their client\u0026#39;s best interests at heart; they only want to be \u003cem\u003egood enough\u003c/em\u003e to complete their contract. This gets multiplied by the contracting firm\u0026#39;s desire to maximize their profits by keeping their contractors as booked as possible. And it gets further multiplied by the remoteness and siloing of the interaction, especially across timezones. Often, the customer sends out requirements, and three months later gets a finished feature, with no more contact than that- and it never goes well.\u003c/p\u003e\n\u003cp\u003eAll that said, let\u0026#39;s look at some SQL Server code. It\u0026#39;s long, so we\u0026#39;ll take it in chunks.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e-- ===============================================================================\u003c/span\u003e\n\u003cspan\u003e-- Author     : Ignacius Ignoramus\u003c/span\u003e\n\u003cspan\u003e-- Create date: 04-12-2020\u003c/span\u003e\n\u003cspan\u003e-- Description:\tSP of Getting Discrepancy of Allocation Reconciliation Snapshot\u003c/span\u003e\n\u003cspan\u003e-- ===============================================================================\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat the comment reinforces that this is an \u0026#34;SP\u0026#34;, aka stored procedure, is already not my favorite thing to see. The description is certainly made up of words, and I think I get the gist.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eALTER\u003c/span\u003e \u003cspan\u003ePROCEDURE\u003c/span\u003e [dbo].[Discrepency]\n\t(\n\t\t\u003cspan\u003e@startDate\u003c/span\u003e DATETIME,\n\t\t\u003cspan\u003e@endDate\u003c/span\u003e DATETIME\n\t)\n\u003cspan\u003eAS\u003c/span\u003e\n\n\u003cspan\u003eBEGIN\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNothing really to see here; it\u0026#39;s easy to see that we\u0026#39;re going to run a query for a date range. That\u0026#39;s fine and common.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eDECLARE\u003c/span\u003e \u003cspan\u003e@tblReturn\u003c/span\u003e \u003cspan\u003eTABLE\u003c/span\u003e\n\t(\n\t\tintOrderItemId\t   \u003cspan\u003eINT\u003c/span\u003e\n\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHmm. T-SQL lets you define table variables, which are exactly what they sound like. It\u0026#39;s a local variable in this procedure, that acts like a table. You can insert/update/delete/query it. The vague name is a little sketch, and the fact that it holds only one field also makes me go \u0026#34;hmmm\u0026#34;, but this isn\u0026#39;t \u003cem\u003ebad\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eDECLARE\u003c/span\u003e \u003cspan\u003e@tblReturn1\u003c/span\u003e \u003cspan\u003eTABLE\u003c/span\u003e\n\t(\n\t\tintOrderItemId\t   \u003cspan\u003eINT\u003c/span\u003e\n\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUh oh.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eDECLARE\u003c/span\u003e \u003cspan\u003e@tblReturn2\u003c/span\u003e \u003cspan\u003eTABLE\u003c/span\u003e\n\t(\n\t\tintOrderItemId\t   \u003cspan\u003eINT\u003c/span\u003e\n\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh no.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eDECLARE\u003c/span\u003e \u003cspan\u003e@tblReturn3\u003c/span\u003e \u003cspan\u003eTABLE\u003c/span\u003e\n\t(\n\t\tintOrderItemId\t   \u003cspan\u003eINT\u003c/span\u003e\n\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOh no no no.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eDECLARE\u003c/span\u003e \u003cspan\u003e@tblReturn4\u003c/span\u003e \u003cspan\u003eTABLE\u003c/span\u003e\n\t(\n\t\tintOrderItemId\t   \u003cspan\u003eINT\u003c/span\u003e\n\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis doesn\u0026#39;t bode well.\u003c/p\u003e\n\u003cp\u003eSo they\u0026#39;ve declared five variables called \u003ccode\u003etblReturn\u003c/code\u003e, that all hold the same data structure.\u003c/p\u003e\n\u003cp\u003eWhat happens next? This next block is gonna be long.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t\u003cspan\u003eINSERT\u003c/span\u003e \u003cspan\u003eINTO\u003c/span\u003e \u003cspan\u003e@tblReturn\u003c/span\u003e \u003cspan\u003e--(intOrderItemId) VALUES (@_ordersToBeAllocated)\u003c/span\u003e\n\n\t\u003cspan\u003e/* OrderItemsPlaced */\u003c/span\u003e\t\t\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e \t\t\n\t\tintOrderItemId\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..Orders o\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..OrderItems oi \u003cspan\u003eon\u003c/span\u003e oi.intOrderId \u003cspan\u003e=\u003c/span\u003e o.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e\n\n\n\t\t\u003cspan\u003eAND\u003c/span\u003e intOrderItemId \u003cspan\u003eNot\u003c/span\u003e \u003cspan\u003eIn\u003c/span\u003e \n\t\t(\n\n\t\t\u003cspan\u003e/* _itemsOnBackorder */\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e oi.strstatus\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;backordered\u0026#39;\u003c/span\u003e \n\t\t)\n\n\t\t\u003cspan\u003eAND\u003c/span\u003e intOrderItemId \u003cspan\u003eNot\u003c/span\u003e \u003cspan\u003eIn\u003c/span\u003e \n\t\t(\n\n\t\t\u003cspan\u003e/* _itemsOnHold */\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e o.strstatus\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;ONHOLD\u0026#39;\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e oi.strStatus \u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#39;BACKORDERED\u0026#39;\u003c/span\u003e \n\t\t)\n\n\t\t\u003cspan\u003eAND\u003c/span\u003e intOrderItemId \u003cspan\u003eNot\u003c/span\u003e \u003cspan\u003eIn\u003c/span\u003e \n\t\t(\n\n\t\t\u003cspan\u003e/* _itemsOnReview */\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e  intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e \n\t\t\u003cspan\u003eand\u003c/span\u003e o.strstatus\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;REVIEW\u0026#39;\u003c/span\u003e \n\t\t\u003cspan\u003eand\u003c/span\u003e oi.strStatus \u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#39;BACKORDERED\u0026#39;\u003c/span\u003e\n\t\t)\n\n\t\t\u003cspan\u003eAND\u003c/span\u003e intOrderItemId \u003cspan\u003eNot\u003c/span\u003e \u003cspan\u003eIn\u003c/span\u003e \n\t\t(\n\n\t\t\u003cspan\u003e/*_itemsOnPending*/\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e  intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e o.strstatus\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;PENDING\u0026#39;\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e oi.strStatus \u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#39;BACKORDERED\u0026#39;\u003c/span\u003e\n\t\t)\n\n\t\t\u003cspan\u003eAND\u003c/span\u003e intOrderItemId \u003cspan\u003eNot\u003c/span\u003e \u003cspan\u003eIn\u003c/span\u003e \n\t\t(\n\n\t\t\u003cspan\u003e/*_itemsCancelled */\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e  intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e oi.strstatus\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e\u0026#39;CANCELLED\u0026#39;\u003c/span\u003e \n\t\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe insert into \u003ccode\u003e@tblReturn\u003c/code\u003e  the result of a query, and this query relies heavily on using a big pile of subqueries to decide if a record should be included in the output- but these subqueries all query \u003cem\u003ethe same tables\u003c/em\u003e as the root query. I\u0026#39;m fairly certain this could be a simple join with a pretty readable \u003ccode\u003ewhere\u003c/code\u003e clause, but I\u0026#39;m also not going to sit here and rewrite it right now, we\u0026#39;ve got a lot more query to look at.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eINSERT\u003c/span\u003e \u003cspan\u003eINTO\u003c/span\u003e \u003cspan\u003e@tblReturn1\u003c/span\u003e\n\n\t\t\n\t\t\u003cspan\u003e/* _backOrderItemsReleased */\u003c/span\u003e\t\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e  intOrderItemId\t\t\t\n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..orders o \u003cspan\u003eon\u003c/span\u003e o.intorderid \u003cspan\u003e=\u003c/span\u003e oi.intorderid\n\t\t\u003cspan\u003ewhere\u003c/span\u003e oi.intOrderItemid \u003cspan\u003ein\u003c/span\u003e (\n\t\t\t  \u003cspan\u003eselect\u003c/span\u003e intRecordID \n\t\t\t  \u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..StatusChangeLog\n\t\t\t  \u003cspan\u003ewhere\u003c/span\u003e strRecordType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;OrderItem\u0026#39;\u003c/span\u003e\n\t\t\t  \u003cspan\u003eand\u003c/span\u003e strOldStatus \u003cspan\u003ein\u003c/span\u003e (\u003cspan\u003e\u0026#39;BACKORDERED\u0026#39;\u003c/span\u003e)\n\t\t\t  \u003cspan\u003eand\u003c/span\u003e strNewStatus \u003cspan\u003ein\u003c/span\u003e (\u003cspan\u003e\u0026#39;NEW\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;RECYCLED\u0026#39;\u003c/span\u003e)\n\t\t\t  \u003cspan\u003eand\u003c/span\u003e dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e  \n\t\t)\n\t\t\u003cspan\u003eand\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e\n\t\t\n\n\t\t\u003cspan\u003eUNION\u003c/span\u003e\n\t\t(\n\t\t\t\u003cspan\u003e/*_pendingHoldItemsReleased*/\u003c/span\u003e\n\n\t\t\t\u003cspan\u003eselect\u003c/span\u003e  intOrderItemId\t\t\t\t\t\n\t\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..OrderItems oi\n\t\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..orders o \u003cspan\u003eon\u003c/span\u003e o.intorderid \u003cspan\u003e=\u003c/span\u003e oi.intorderid\n\t\t\t\u003cspan\u003ewhere\u003c/span\u003e oi.intOrderID \u003cspan\u003ein\u003c/span\u003e (\n\t\t\t\t  \u003cspan\u003eselect\u003c/span\u003e intRecordID \n\t\t\t\t  \u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..StatusChangeLog\n\t\t\t\t  \u003cspan\u003ewhere\u003c/span\u003e strRecordType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;Order\u0026#39;\u003c/span\u003e\n\t\t\t\t  \u003cspan\u003eand\u003c/span\u003e strOldStatus \u003cspan\u003ein\u003c/span\u003e (\u003cspan\u003e\u0026#39;REVIEW\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;ONHOLD\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;PENDING\u0026#39;\u003c/span\u003e)\n\t\t\t\t  \u003cspan\u003eand\u003c/span\u003e strNewStatus \u003cspan\u003ein\u003c/span\u003e (\u003cspan\u003e\u0026#39;NEW\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;PROCESSING\u0026#39;\u003c/span\u003e)\n\t\t\t\t  \u003cspan\u003eand\u003c/span\u003e dtmTimeStamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e  \n\t\t\t)\n\t\t\t\u003cspan\u003eand\u003c/span\u003e o.dtmTimeStamp \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e\n\t\t\t\n\t\t)\n\n\t\t\u003cspan\u003eUNION\u003c/span\u003e\n\n\t\t\u003cspan\u003e/* _reallocationsowingtonostock */\u003c/span\u003e\t\n\t\t(\n\t\t\t\u003cspan\u003eselect\u003c/span\u003e oi.intOrderItemID\t\t\t\t   \t \n\t\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog \n\t\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase.dbo.OrderItems oi \u003cspan\u003eon\u003c/span\u003e oi.intOrderItemID \u003cspan\u003e=\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog.intRecordID\n\t\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase.dbo.Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId  \n\n\t\t\t\u003cspan\u003ewhere\u003c/span\u003e strOldStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;RECYCLED\u0026#39;\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e strNewStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;ALLOCATED\u0026#39;\u003c/span\u003e \n\t\t\t\u003cspan\u003eand\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e@endDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e \n\t\t\tstrRecordType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;OrderItem\u0026#39;\u003c/span\u003e\n\t\t\t\u003cspan\u003eand\u003c/span\u003e intRecordId \u003cspan\u003ein\u003c/span\u003e \n\t\t\t(\n\t\t\t  \u003cspan\u003eselect\u003c/span\u003e intRecordId \u003cspan\u003efrom\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog \n\t\t\t  \u003cspan\u003ewhere\u003c/span\u003e strOldStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;ALLOCATED\u0026#39;\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e strNewStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;RECYCLED\u0026#39;\u003c/span\u003e \n\t\t\t  \u003cspan\u003eand\u003c/span\u003e strRecordType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;OrderItem\u0026#39;\u003c/span\u003e\n\t\t\t  \u003cspan\u003eand\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003cspan\u003ebetween\u003c/span\u003e \u003cspan\u003e@startDate\u003c/span\u003e \u003cspan\u003eand\u003c/span\u003e  \u003cspan\u003e@endDate\u003c/span\u003e  \n\t\t\t)  \n\t\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOkay, just some unions with more subquery filtering. More of the same. It\u0026#39;s the next one that makes this special.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eINSERT\u003c/span\u003e \u003cspan\u003eINTO\u003c/span\u003e \u003cspan\u003e@tblReturn2\u003c/span\u003e\n\n\t\u003cspan\u003eSELECT\u003c/span\u003e intOrderItemId \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003e@tblReturn\u003c/span\u003e \n\t\n\t\u003cspan\u003eUNION\u003c/span\u003e\n\n\t\u003cspan\u003eSELECT\u003c/span\u003e intOrderItemId \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003e@tblReturn1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAh, here\u0026#39;s the stuff. This is just bonkers. If the goal is to combine the results of these queries into a single table, you could just \u003cem\u003einsert into one table\u003c/em\u003e the whole time.\u003c/p\u003e\n\u003cp\u003eBut we know that there are 5 of these tables, so why are we only going through the first two to combine them at this point?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003eINSERT\u003c/span\u003e \u003cspan\u003eINTO\u003c/span\u003e \u003cspan\u003e@tblReturn3\u003c/span\u003e\n\n\t\t\u003cspan\u003e/* _factoryAllocation*/\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e \n\t\toi.intOrderItemId                              \n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..Shipments s \n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..ShipmentItems si \u003cspan\u003eon\u003c/span\u003e si.intShipmentID \u003cspan\u003e=\u003c/span\u003e s.intShipmentID\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e Common.CompanyDatabase.Stores stores \u003cspan\u003eon\u003c/span\u003e stores.intStoreID \u003cspan\u003e=\u003c/span\u003e s.intLocationID\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..OrderItems oi \u003cspan\u003eon\u003c/span\u003e oi.intOrderItemId \u003cspan\u003e=\u003c/span\u003e si.intOrderItemId                                      \n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e s.intOrderId  \n\t\t\u003cspan\u003ewhere\u003c/span\u003e s.dtmTimestamp \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e stores.strLocationType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;FACTORY\u0026#39;\u003c/span\u003e\n\t\t\n\t\t\u003cspan\u003eUNION\u003c/span\u003e \n\t\t(\n\t \t  \u003cspan\u003e/*_storeAllocations*/\u003c/span\u003e\n\n\t\t\u003cspan\u003eselect\u003c/span\u003e oi.intOrderItemId                               \n\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase..Shipments s \n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..ShipmentItems si \u003cspan\u003eon\u003c/span\u003e si.intShipmentID \u003cspan\u003e=\u003c/span\u003e s.intShipmentID\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e Common.CompanyDatabase.Stores stores \u003cspan\u003eon\u003c/span\u003e stores.intStoreID \u003cspan\u003e=\u003c/span\u003e s.intLocationID\n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..OrderItems oi \u003cspan\u003eon\u003c/span\u003e oi.intOrderItemId \u003cspan\u003e=\u003c/span\u003e si.intOrderItemId                                      \n\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase..Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e s.intOrderId\n\t\t\u003cspan\u003ewhere\u003c/span\u003e s.dtmTimestamp \u003cspan\u003e\u0026gt;=\u003c/span\u003e \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\u003cspan\u003eand\u003c/span\u003e stores.strLocationType \u003cspan\u003e\u0026lt;\u0026gt;\u003c/span\u003e \u003cspan\u003e\u0026#39;FACTORY\u0026#39;\u003c/span\u003e\n\t\t)\n\n\t\t\u003cspan\u003eUNION\u003c/span\u003e\n\t\t(\n\t\t\u003cspan\u003e/* _ordersWithAllocationProblems */\u003c/span\u003e\n    \t\n\t\t\t\u003cspan\u003eselect\u003c/span\u003e oi.intOrderItemId\n\t\t\t\u003cspan\u003efrom\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog\n\t\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase.dbo.OrderItems oi \u003cspan\u003eon\u003c/span\u003e oi.intOrderItemID \u003cspan\u003e=\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog.intRecordID\n\t\t\t\u003cspan\u003einner\u003c/span\u003e \u003cspan\u003ejoin\u003c/span\u003e CompanyDatabase.dbo.Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\t\t\u003cspan\u003ewhere\u003c/span\u003e strRecordType \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;orderitem\u0026#39;\u003c/span\u003e\n\t\t\t\u003cspan\u003eand\u003c/span\u003e strNewStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;PROBLEM\u0026#39;\u003c/span\u003e\n\t\t\t\u003cspan\u003eand\u003c/span\u003e strOldStatus \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#39;NEW\u0026#39;\u003c/span\u003e\n\t\t\t\u003cspan\u003eand\u003c/span\u003e CompanyDatabase.dbo.StatusChangeLog.dtmTimestamp \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t\t\u003cspan\u003eand\u003c/span\u003e o.dtmTimestamp \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003e@endDate\u003c/span\u003e\n\t\t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOkay, \u003ccode\u003e@tblReturn3\u003c/code\u003e is more of the same. Nothing more to really add.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\t \u003cspan\u003eINSERT\u003c/span\u003e \u003cspan\u003eINTO\u003c/span\u003e \u003cspan\u003e@tblReturn4\u003c/span\u003e\n\t\n\t \u003cspan\u003eSELECT\u003c/span\u003e intOrderItemId \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003e@tblReturn2\u003c/span\u003e \u003cspan\u003eWHERE\u003c/span\u003e\n\t intOrderItemId \u003cspan\u003eNOT\u003c/span\u003e \u003cspan\u003eIN\u003c/span\u003e(\u003cspan\u003eSELECT\u003c/span\u003e intOrderItemId \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003e@tblReturn3\u003c/span\u003e )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOoh, but here we see something a bit different- we\u0026#39;re taking the set difference between \u003ccode\u003e@tblReturn2\u003c/code\u003e and \u003ccode\u003e@tblReturn3\u003c/code\u003e. This would almost make sense if there weren\u0026#39;t already set operations in T-SQL which would handle all of this.\u003c/p\u003e\n\u003cp\u003eWhich brings us, finally, to the last query in the whole thing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eSELECT\u003c/span\u003e \n\t o.intOrderId\n\t,oi.intOrderItemId\n\t,o.dtmDate\n\t,oi.strDescription\n\t,o.strFirstName \u003cspan\u003e+\u003c/span\u003e o.strLastName \u003cspan\u003eAS\u003c/span\u003e \u003cspan\u003e\u0026#39;Name\u0026#39;\u003c/span\u003e\n\t,o.strEmail\n\t,o.strBillingCountry\n\t,o.strShippingCountry\n\t\u003cspan\u003eFROM\u003c/span\u003e CompanyDatabase.dbo.OrderItems oi\n\t\u003cspan\u003eINNER\u003c/span\u003e \u003cspan\u003eJOIN\u003c/span\u003e CompanyDatabase.dbo.Orders o \u003cspan\u003eon\u003c/span\u003e o.intOrderId \u003cspan\u003e=\u003c/span\u003e oi.intOrderId\n\t\u003cspan\u003eWHERE\u003c/span\u003e oi.intOrderItemId \u003cspan\u003eIN\u003c/span\u003e (\u003cspan\u003eSELECT\u003c/span\u003e intOrderItemId \u003cspan\u003eFROM\u003c/span\u003e \u003cspan\u003e@tblReturn4\u003c/span\u003e)\n\u003cspan\u003eEND\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt the end of all this, I\u0026#39;ve determined a few things.\u003c/p\u003e\n\u003cp\u003eFirst, the developer responsible didn\u0026#39;t understand table variables. Second,they definitely didn\u0026#39;t understand joins. Third, they had no sense of the overall workflow of this query and just sorta fumbled through until they got results that the client said were okay.\u003c/p\u003e\n\u003cp\u003eAnd somehow, this pile of trash made it through a code review by internal architects and got deployed to production, where it promptly became the worst performing query in their application. Correction: the worst performing query \u003cem\u003ethus far\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eUtilize BuildMaster\u003c/a\u003e to release your software with confidence, at the pace your business demands. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eDownload\u003c/a\u003e today!  \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2025-04-02T06:30:00Z",
  "modifiedTime": null
}
