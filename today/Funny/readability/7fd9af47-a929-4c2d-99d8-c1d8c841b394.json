{
  "id": "7fd9af47-a929-4c2d-99d8-c1d8c841b394",
  "title": "CodeSOD: A Pair of Loops",
  "link": "https://thedailywtf.com/articles/a-pair-of-loops",
  "description": "Alexandra inherited a codebase that, if we're being kind, could be called \"verbose\". Individual functions routinely cross into multiple thousands of lines, with the longest single function hitting 4,000 lines of code. Very little of this is because the problems being solved are complicated, and much more of it is because people don't understand how anything works. For example, in this C++ code, they have a vector of strings. The goal is to create a map where the keys are the strings from the vector, and the values are more strings, derived from a function call. Essentially, what they wanted was: for (std::string val : invec) { umap[val] = lookupValue(val); } This would have been the sane, obvious way to do things. That's not what they did. unordered_map func(vector invec) { unordered_map umap; vector idxvec; for(string name : invec) { umap[name] = \"\"; idxvec.push_back(make_pair(name, \u0026umap[name])); } for(auto thingy : idxvec) { //actual work, including assigning the string thingy.get\u003c1\u003e() = lookupValue(thingy.get\u003c0\u003e()); } return umap; } I won't pick on names here, as they're clearly anonymized. But let's take a look at the approach they used. They create their map, and then create a new vector- a vector which is a pair- a string and a pointer to a string. Already, I'm confused by why any of this is happening, but let's press on and hope it becomes clear. We iterate across our input vector, which this I get. Then we create a key in the map and give it an empty string as a value. Then we create a pair out of our key and our pointer to that empty string. That's how we populate our idxvec vector. Once we've looped across all the values once, we do it again. This time, we pull out those pairs, and set the value at the pointer equal to the string returned by lookup value. Which leads us all to our favorite letter of the alphabet: WHY? I don't know. I also am hesitant to comment to much on the memory management and ownership issues here, as with the anonymization, there may be some reference management that got lost. But the fact that we're using bare pointers certainly makes this code more fraught than it needed to be. And, given how complex the STL data structures can be, I think we can also agree that passing around bare pointers to memory inside those structures is a recipe for disaster, even in simple cases like this. What I really enjoy is that they create a vector of pairs, without ever seeming to understand that a list of pairs is essentially what a map is. In conclusion: can we at least agree that, from now on, we won't iterate across the same values twice? I think about 15% of WTFs would go away if we all followed that rule. Oh, wait, no. People who could understand rules like that aren't the ones writing this kind of code. Forget I said anything. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Mon, 02 Dec 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3238,
  "excerpt": "Alexandra inherited a codebase that, if we're being kind, could be called \"verbose\". Individual functions routinely cross into multiple thousands of lines, with the longest single function hitting 4,000 lines of code. Very little of this is because the problems being solved are complicated, and much more of it is because people don't understand how anything works.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Alexandra inherited a codebase that, if we're being kind, could be called \"verbose\". Individual functions routinely cross into multiple thousands of lines, with the longest single function hitting 4,000 lines of code. Very little of this is because the problems being solved are complicated, and much more of it is because people don't understand how anything works. For example, in this C++ code, they have a vector of strings. The goal is to create a map where the keys are the strings from the vector, and the values are more strings, derived from a function call. Essentially, what they wanted was: for (std::string val : invec) { umap[val] = lookupValue(val); } This would have been the sane, obvious way to do things. That's not what they did. unordered_map\u003cstring, string\u003e func(vector\u003cstring\u003e invec) { unordered_map\u003cstring, string\u003e umap; vector\u003cpair\u003cstring, string*\u003e idxvec; for(string name : invec) { umap[name] = \"\"; idxvec.push_back(make_pair(name, \u0026umap[name])); } for(auto thingy : idxvec) { //actual work, including assigning the string thingy.get\u003c1\u003e() = lookupValue(thingy.get\u003c0\u003e()); } return umap; } I won't pick on names here, as they're clearly anonymized. But let's take a look at the approach they used. They create their map, and then create a new vector- a vector which is a pair\u003cstring, string*\u003e- a string and a pointer to a string. Already, I'm confused by why any of this is happening, but let's press on and hope it becomes clear. We iterate across our input vector, which this I get. Then we create a key in the map and give it an empty string as a value. Then we create a pair out of our key and our pointer to that empty string. That's how we populate our idxvec vector. Once we've looped across all the values once, we do it again. This time, we pull out those pairs, and set the value at the pointer equal to the string returned by lookup value. Which leads us all to our favorite letter of the alphabet: WHY? I don't know. I also am hesitant to comment to much on the memory management and ownership issues here, as with the anonymization, there may be some reference management that got lost. But the fact that we're using bare pointers certainly makes this code more fraught than it needed to be. And, given how complex the STL data structures can be, I think we can also agree that passing around bare pointers to memory inside those structures is a recipe for disaster, even in simple cases like this. What I really enjoy is that they create a vector of pairs, without ever seeming to understand that a list of pairs is essentially what a map is. In conclusion: can we at least agree that, from now on, we won't iterate across the same values twice? I think about 15% of WTFs would go away if we all followed that rule. Oh, wait, no. People who could understand rules like that aren't the ones writing this kind of code. Forget I said anything. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eAlexandra\u003c/strong\u003e inherited a codebase that, if we\u0026#39;re being kind, could be called \u0026#34;verbose\u0026#34;. Individual functions routinely cross into multiple thousands of lines, with the longest single function hitting 4,000 lines of code.\u003c/p\u003e\n\u003cp\u003eVery little of this is because the problems being solved are complicated, and much more of it is because people don\u0026#39;t understand how anything works.\u003c/p\u003e\n\u003cp\u003eFor example, in this C++ code, they have a vector of strings. The goal is to create a map where the keys are the strings from the vector, and the values are more strings, derived from a function call.\u003c/p\u003e\n\u003cp\u003eEssentially, what they wanted was:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efor (std::string val : invec)\n{\n    umap[val] = lookupValue(val);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis would have been the sane, obvious way to do things. That\u0026#39;s not what they did.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eunordered_map\u0026lt;string, string\u0026gt; func(vector\u0026lt;string\u0026gt; invec)\n{\n    unordered_map\u0026lt;string, string\u0026gt; umap;\n    vector\u0026lt;pair\u0026lt;string, string*\u0026gt; idxvec;\n    for(string name : invec)\n    {\n        umap[name] = \u0026#34;\u0026#34;;\n        idxvec.push_back(make_pair(name, \u0026amp;umap[name]));\n    }   \n\n    for(auto thingy : idxvec)\n    {\n        //actual work, including assigning the string\n        thingy.get\u0026lt;1\u0026gt;() = lookupValue(thingy.get\u0026lt;0\u0026gt;()); \n    }\n    return umap;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI won\u0026#39;t pick on names here, as they\u0026#39;re clearly anonymized. But let\u0026#39;s take a look at the approach they used.\u003c/p\u003e\n\u003cp\u003eThey create their map, and then create a new vector- a vector which is a \u003ccode\u003epair\u0026lt;string, string*\u0026gt;\u003c/code\u003e- a string and a \u003cem\u003epointer\u003c/em\u003e to a string. Already, I\u0026#39;m confused by why any of this is happening, but let\u0026#39;s press on and hope it becomes clear.\u003c/p\u003e\n\u003cp\u003eWe iterate across our input vector, which this I get. Then we create a key in the map and give it an empty string as a value. \u003cem\u003eThen\u003c/em\u003e we create a pair out of our key and our \u003cem\u003epointer\u003c/em\u003e to that empty string. That\u0026#39;s how we populate our \u003ccode\u003eidxvec\u003c/code\u003e vector.\u003c/p\u003e\n\u003cp\u003eOnce we\u0026#39;ve looped across all the values once, we do it again. This time, we pull out those pairs, and set the value at the pointer equal to the string returned by lookup value.\u003c/p\u003e\n\u003cp\u003eWhich leads us all to our favorite letter of the alphabet: WHY?\u003c/p\u003e\n\u003cp\u003eI don\u0026#39;t know. I also am hesitant to comment to much on the memory management and ownership issues here, as with the anonymization, there may be some reference management that got lost. But the fact that we\u0026#39;re using bare pointers certainly makes this code more fraught than it needed to be. And, given how complex the STL data structures can be, I think we can also agree that passing around bare pointers to memory inside those structures is a recipe for disaster, even in simple cases like this.\u003c/p\u003e\n\u003cp\u003eWhat I really enjoy is that they create a vector of pairs, without ever seeming to understand that a list of pairs \u003cem\u003eis essentially what a map is\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn conclusion: can we at least agree that, from now on, we won\u0026#39;t iterate across the same values twice? I think about 15% of WTFs would go away if we all followed that rule.\u003c/p\u003e\n\u003cp\u003eOh, wait, no. People who could understand rules like that aren\u0026#39;t the ones writing this kind of code. Forget I said anything.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-12-02T06:30:00Z",
  "modifiedTime": null
}
