{
  "id": "59305ddf-3f84-4873-a9ae-ac0ade2d5d1d",
  "title": "CodeSOD: Format Identified",
  "link": "https://thedailywtf.com/articles/format-identified",
  "description": "Many nations have some form of national identification number, especially around taxes. Argentina is no exception. Their \"CUIT\" (Clave Única de Identificación Tributaria) and \"CUIL\" (Código Único de Identificación Laboral) are formatted as \"##-########-#\". Now, as datasets often don't store things in their canonical representation, Nick's co-worker was given a task: \"given a list of numbers, reformat them to look like CUIT/CUIL. That co-worker went off for five days, and produced this Java function. public String normalizarCuitCuil(String cuitCuilOrigen){ String valorNormalizado = new String(); if (cuitCuilOrigen == null || \"\".equals(cuitCuilOrigen) || cuitCuilOrigen.length() \u003c MINIMA_CANTIDAD_ACEPTADA_DE_CARACTERES_PARA_NORMALIZAR){ valorNormalizado = \"\"; }else{ StringBuilder numerosDelCuitCuil = new StringBuilder(13); cuitCuilOrigen = cuitCuilOrigen.trim(); // Se obtienen solo los números: Matcher buscadorDePatron = patternNumeros.matcher(cuitCuilOrigen); while (buscadorDePatron.find()){ numerosDelCuitCuil.append(buscadorDePatron.group()); } // Se le agregan los guiones: valorNormalizado = numerosDelCuitCuil.toString().substring(0,2) + \"-\" + numerosDelCuitCuil.toString().substring(2,numerosDelCuitCuil.toString().length()-1) + \"-\" + numerosDelCuitCuil.toString().substring(numerosDelCuitCuil.toString().length()-1, numerosDelCuitCuil.toString().length()); } return valorNormalizado; } We start with a basic sanity check that the string exists and is long enough. If it isn't, we return an empty string, which already annoys me, because an empty result is not a good way to communicate \"I failed to parse\". But assuming we have data, we construct a string builder and trim whitespace. And already we have a problem: we already validated that the string was long enough, but if the string contained more trailing whitespace than a newline, we're looking at a problem. Now, maybe we can assume the data is good, but the next line implies that we can't rely on that- they create a regex matcher to identify numeric values, and for each numeric value they find, they append it to our StringBuilder. This implies that the string may contain non-numeric values which need to be rejected, which means our length validation was still wrong. So either the data is clean and we're overvalidating, or the data is dirty and we're validating in the wrong order. But all of that's a preamble to a terrible abuse of string builders, where they discard all the advantages of using a StringBuilder by calling toString again and again and again. Now, maybe the function caches results or the compiler can optimize it, but the result is a particularly unreadable blob of slicing code. Now, this is ugly, but at least it works, assuming the input data is good. It definitely should never pass a code review, but it's not the kind of bad code that leaves one waking up in the middle of the night in a cold sweat. No, what gets me about this is that it took five days to write. And according to Nick, the responsible developer wasn't just slacking off or going to meetings the whole time, they were at their desk poking at their Java IDE and looking confused for all five days. And of course, because it took so long to write the feature, management didn't want to waste more time on kicking it back via a code review. So voila: it got forced through and released to production since it passed testing. .comment { border: none; } [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "author": "Remy Porter",
  "published": "Wed, 28 May 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 4007,
  "excerpt": "Many nations have some form of national identification number, especially around taxes. Argentina is no exception. Their \"CUIT\" (Clave Única de Identificación Tributaria) and \"CUIL\" (Código Único de Identificación Laboral) are formatted as \"##-########-#\".",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-05-28 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Many nations have some form of national identification number, especially around taxes. Argentina is no exception. Their \"CUIT\" (Clave Única de Identificación Tributaria) and \"CUIL\" (Código Único de Identificación Laboral) are formatted as \"##-########-#\". Now, as datasets often don't store things in their canonical representation, Nick's co-worker was given a task: \"given a list of numbers, reformat them to look like CUIT/CUIL. That co-worker went off for five days, and produced this Java function. public String normalizarCuitCuil(String cuitCuilOrigen){ String valorNormalizado = new String(); if (cuitCuilOrigen == null || \"\".equals(cuitCuilOrigen) || cuitCuilOrigen.length() \u003c MINIMA_CANTIDAD_ACEPTADA_DE_CARACTERES_PARA_NORMALIZAR){ valorNormalizado = \"\"; }else{ StringBuilder numerosDelCuitCuil = new StringBuilder(13); cuitCuilOrigen = cuitCuilOrigen.trim(); // Se obtienen solo los números: Matcher buscadorDePatron = patternNumeros.matcher(cuitCuilOrigen); while (buscadorDePatron.find()){ numerosDelCuitCuil.append(buscadorDePatron.group()); } // Se le agregan los guiones: valorNormalizado = numerosDelCuitCuil.toString().substring(0,2) + \"-\" + numerosDelCuitCuil.toString().substring(2,numerosDelCuitCuil.toString().length()-1) + \"-\" + numerosDelCuitCuil.toString().substring(numerosDelCuitCuil.toString().length()-1, numerosDelCuitCuil.toString().length()); } return valorNormalizado; } We start with a basic sanity check that the string exists and is long enough. If it isn't, we return an empty string, which already annoys me, because an empty result is not a good way to communicate \"I failed to parse\". But assuming we have data, we construct a string builder and trim whitespace. And already we have a problem: we already validated that the string was long enough, but if the string contained more trailing whitespace than a newline, we're looking at a problem. Now, maybe we can assume the data is good, but the next line implies that we can't rely on that- they create a regex matcher to identify numeric values, and for each numeric value they find, they append it to our StringBuilder. This implies that the string may contain non-numeric values which need to be rejected, which means our length validation was still wrong. So either the data is clean and we're overvalidating, or the data is dirty and we're validating in the wrong order. But all of that's a preamble to a terrible abuse of string builders, where they discard all the advantages of using a StringBuilder by calling toString again and again and again. Now, maybe the function caches results or the compiler can optimize it, but the result is a particularly unreadable blob of slicing code. Now, this is ugly, but at least it works, assuming the input data is good. It definitely should never pass a code review, but it's not the kind of bad code that leaves one waking up in the middle of the night in a cold sweat. No, what gets me about this is that it took five days to write. And according to Nick, the responsible developer wasn't just slacking off or going to meetings the whole time, they were at their desk poking at their Java IDE and looking confused for all five days. And of course, because it took so long to write the feature, management didn't want to waste more time on kicking it back via a code review. So voila: it got forced through and released to production since it passed testing. [Advertisement] Keep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-05-28\"\u003e2025-05-28\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10924\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eMany nations have some form of national identification number, especially around taxes. Argentina is no exception.\u003c/p\u003e\n\u003cp\u003eTheir \u0026#34;CUIT\u0026#34; (Clave Única de Identificación Tributaria) and \u0026#34;CUIL\u0026#34; (Código Único de Identificación Laboral) are formatted as \u0026#34;##-########-#\u0026#34;.\u003c/p\u003e\n\u003cp\u003eNow, as datasets often don\u0026#39;t store things in their canonical representation, \u003cstrong\u003eNick\u003c/strong\u003e\u0026#39;s co-worker was given a task: \u0026#34;given a list of numbers, reformat them to look like CUIT/CUIL. That co-worker went off for five days, and produced this Java function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003epublic\u003c/span\u003e String \u003cspan\u003enormalizarCuitCuil\u003c/span\u003e\u003cspan\u003e(String cuitCuilOrigen)\u003c/span\u003e{\n\t\u003cspan\u003eString\u003c/span\u003e \u003cspan\u003evalorNormalizado\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e();\n\t\n\t\u003cspan\u003eif\u003c/span\u003e (cuitCuilOrigen == \u003cspan\u003enull\u003c/span\u003e || \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e.equals(cuitCuilOrigen) || cuitCuilOrigen.length() \u0026lt; MINIMA_CANTIDAD_ACEPTADA_DE_CARACTERES_PARA_NORMALIZAR){\n\t\tvalorNormalizado = \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n\t}\u003cspan\u003eelse\u003c/span\u003e{\n\t\t\u003cspan\u003eStringBuilder\u003c/span\u003e \u003cspan\u003enumerosDelCuitCuil\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eStringBuilder\u003c/span\u003e(\u003cspan\u003e13\u003c/span\u003e);\n\t\tcuitCuilOrigen = cuitCuilOrigen.trim();\n\t\t\n\t\t\u003cspan\u003e// Se obtienen solo los números:\u003c/span\u003e\n\t\t\u003cspan\u003eMatcher\u003c/span\u003e \u003cspan\u003ebuscadorDePatron\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e  patternNumeros.matcher(cuitCuilOrigen);\n\t\t\u003cspan\u003ewhile\u003c/span\u003e (buscadorDePatron.find()){\n\t\t\tnumerosDelCuitCuil.append(buscadorDePatron.group());\n\t\t}\n\t\t\n\t\t\u003cspan\u003e// Se le agregan los guiones:\u003c/span\u003e\n\t\tvalorNormalizado = numerosDelCuitCuil.toString().substring(\u003cspan\u003e0\u003c/span\u003e,\u003cspan\u003e2\u003c/span\u003e) \n\t\t\t\t\t\t\t+ \u003cspan\u003e\u0026#34;-\u0026#34;\u003c/span\u003e\n\t\t\t\t\t\t\t+ numerosDelCuitCuil.toString().substring(\u003cspan\u003e2\u003c/span\u003e,numerosDelCuitCuil.toString().length()-\u003cspan\u003e1\u003c/span\u003e) \n\t\t\t\t\t\t\t+ \u003cspan\u003e\u0026#34;-\u0026#34;\u003c/span\u003e\n\t\t\t\t\t\t\t+ numerosDelCuitCuil.toString().substring(numerosDelCuitCuil.toString().length()-\u003cspan\u003e1\u003c/span\u003e, numerosDelCuitCuil.toString().length());\n\t\t\n\t}\n\t\u003cspan\u003ereturn\u003c/span\u003e valorNormalizado;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe start with a basic sanity check that the string exists and is long enough. If it isn\u0026#39;t, we return an empty string, which already annoys me, because an empty result is not a good way to communicate \u0026#34;I failed to parse\u0026#34;.\u003c/p\u003e\n\u003cp\u003eBut assuming we have data, we construct a string builder and trim whitespace. And already we have a problem: we already validated that the string was long enough, but if the string contained more trailing whitespace than a newline, we\u0026#39;re looking at a problem. Now, maybe we can assume the data is good, but the next line implies that we can\u0026#39;t rely on that- they create a regex matcher to identify numeric values, and for each numeric value they find, they append it to our \u003ccode\u003eStringBuilder\u003c/code\u003e. This implies that the string may contain non-numeric values which need to be rejected, which means our length validation was still wrong.\u003c/p\u003e\n\u003cp\u003eSo either the data is clean and we\u0026#39;re overvalidating, or the data is dirty and we\u0026#39;re validating in the wrong order.\u003c/p\u003e\n\u003cp\u003eBut all of that\u0026#39;s a preamble to a terrible abuse of string builders, where they discard all the advantages of using a \u003ccode\u003eStringBuilder\u003c/code\u003e by calling \u003ccode\u003etoString\u003c/code\u003e again and again and again. Now, maybe the function caches results or the compiler can optimize it, but the result is a particularly unreadable blob of slicing code.\u003c/p\u003e\n\u003cp\u003eNow, this is ugly, but at least it works, assuming the input data is good. It definitely should never pass a code review, but it\u0026#39;s not the kind of bad code that leaves one waking up in the middle of the night in a cold sweat.\u003c/p\u003e\n\u003cp\u003eNo, what gets me about this is that it took \u003cem\u003efive days to write\u003c/em\u003e. And according to Nick, the responsible developer wasn\u0026#39;t just slacking off or going to meetings the whole time, they were at their desk poking at their Java IDE and looking confused for all five days.\u003c/p\u003e\n\u003cp\u003eAnd of course, because it took so long to write the feature, management didn\u0026#39;t want to waste more time on kicking it back via a code review. So voila: it got forced through and released to production since it passed testing.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep all your packages and Docker containers in one place, scan for vulnerabilities, and control who can access different feeds. ProGet installs in minutes and has a powerful free version with a lot of great features that you can upgrade when ready.\u003ca href=\"https://inedo.com/proget?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-05-28T06:30:00Z",
  "modifiedTime": null
}
