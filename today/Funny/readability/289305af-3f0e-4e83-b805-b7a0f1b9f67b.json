{
  "id": "289305af-3f0e-4e83-b805-b7a0f1b9f67b",
  "title": "CodeSOD: Querieous Strings",
  "link": "https://thedailywtf.com/articles/querieous-strings",
  "description": "When processing HTTP requests, you frequently need to check the parameters which were sent along with that request. Those parameters are generally passed as stringly-typed key/value pairs. None of this is news to anyone. What is news, however, is how Brodey's co-worker indexed the key/value pairs. For i As Integer = 0 To (Request.Params().Count - 1) If (parameters.GetKey(i).ToString() \u003c\u003e \"Lang\") Then If (parameters.GetKey(i).Equals(\"ID\")) OrElse (parameters.GetKey(i).Equals(\"new\")) OrElse _ (parameters.GetKey(i).Equals(\"open\")) OrElse (parameters.GetKey(i).Equals(\"FID\")) _ OrElse (parameters.GetKey(i).Equals(\"enabled\")) OrElse (parameters.GetKey(i).Equals(\"my\")) OrElse _ (parameters.GetKey(i).Equals(\"msgType\")) OrElse (parameters.GetKey(i).Equals(\"Type\")) _ OrElse (parameters.GetKey(i).Equals(\"EID\")) OrElse (parameters.GetKey(i).Equals(\"Title\")) OrElse _ (parameters.GetKey(i).Equals(\"ERROR\")) Then URLParams \u0026= \"\u0026\" \u0026 parameters.GetKey(i).ToString() URLParams \u0026= \"=\" \u0026 parameters(i).ToString() End If End If Next The goal of this code is to take a certain set of keys and construct a URLParams string which represents those key/values as an HTTP query string. The first thing to get out of the way: .NET has a QueryString type that handles the construction of the query string for you (including escaping), so that you don't need to do any string concatenation. But the real WTF is everything surrounding that. We opt to iterate across every key- not just the ones we care about- and use the GetKey(i) function to check each individual key in an extensive chain of OrElse statements. The obvious and simpler approach would have been to iterate across an array of the keys I care about- ID, new, FID, enabled, my, msgType, Type, EID, Title, ERROR- and simply check if they were in the Request. I suppose the only silver lining here is that they thought to use the OrElse operator- which is a short-circuiting \"or\" operation, like you'd expect in just about any other language, instead of Or, which doesn't short circuit (pulling double duty as both a bitwise Or and a logical Or, because Visual Basic wants to contribute some WTFs). [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Wed, 23 Oct 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2699,
  "excerpt": "When processing HTTP requests, you frequently need to check the parameters which were sent along with that request. Those parameters are generally passed as stringly-typed key/value pairs. None of this is news to anyone. What is news, however, is how Brodey's co-worker indexed the key/value pairs.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2024-10-23 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. When processing HTTP requests, you frequently need to check the parameters which were sent along with that request. Those parameters are generally passed as stringly-typed key/value pairs. None of this is news to anyone. What is news, however, is how Brodey's co-worker indexed the key/value pairs. For i As Integer = 0 To (Request.Params().Count - 1) If (parameters.GetKey(i).ToString() \u003c\u003e \"Lang\") Then If (parameters.GetKey(i).Equals(\"ID\")) OrElse (parameters.GetKey(i).Equals(\"new\")) OrElse _ (parameters.GetKey(i).Equals(\"open\")) OrElse (parameters.GetKey(i).Equals(\"FID\")) _ OrElse (parameters.GetKey(i).Equals(\"enabled\")) OrElse (parameters.GetKey(i).Equals(\"my\")) OrElse _ (parameters.GetKey(i).Equals(\"msgType\")) OrElse (parameters.GetKey(i).Equals(\"Type\")) _ OrElse (parameters.GetKey(i).Equals(\"EID\")) OrElse (parameters.GetKey(i).Equals(\"Title\")) OrElse _ (parameters.GetKey(i).Equals(\"ERROR\")) Then URLParams \u0026= \"\u0026\" \u0026 parameters.GetKey(i).ToString() URLParams \u0026= \"=\" \u0026 parameters(i).ToString() End If End If Next The goal of this code is to take a certain set of keys and construct a URLParams string which represents those key/values as an HTTP query string. The first thing to get out of the way: .NET has a QueryString type that handles the construction of the query string for you (including escaping), so that you don't need to do any string concatenation. But the real WTF is everything surrounding that. We opt to iterate across every key- not just the ones we care about- and use the GetKey(i) function to check each individual key in an extensive chain of OrElse statements. The obvious and simpler approach would have been to iterate across an array of the keys I care about- ID, new, FID, enabled, my, msgType, Type, EID, Title, ERROR- and simply check if they were in the Request. I suppose the only silver lining here is that they thought to use the OrElse operator- which is a short-circuiting \"or\" operation, like you'd expect in just about any other language, instead of Or, which doesn't short circuit (pulling double duty as both a bitwise Or and a logical Or, because Visual Basic wants to contribute some WTFs). [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-10-23\"\u003e2024-10-23\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10765\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eWhen processing HTTP requests, you frequently need to check the parameters which were sent along with that request. Those parameters are generally passed as stringly-typed key/value pairs. None of this is news to anyone.\u003c/p\u003e\n\u003cp\u003eWhat is news, however, is how \u003cstrong\u003eBrodey\u003c/strong\u003e\u0026#39;s co-worker indexed the key/value pairs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eFor\u003c/span\u003e i As Integer = \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003eTo\u003c/span\u003e (\u003cspan\u003eRequest\u003c/span\u003e.Params().Count - \u003cspan\u003e1\u003c/span\u003e)\n    \u003cspan\u003eIf\u003c/span\u003e (parameters.GetKey(i).\u003cspan\u003eTo\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e() \u0026lt;\u0026gt; \u003cspan\u003e\u0026#34;Lang\u0026#34;\u003c/span\u003e) \u003cspan\u003eThen\u003c/span\u003e\n        \u003cspan\u003eIf\u003c/span\u003e (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;ID\u0026#34;\u003c/span\u003e)) OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;new\u0026#34;\u003c/span\u003e)) OrElse _\n             (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;open\u0026#34;\u003c/span\u003e)) OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;FID\u0026#34;\u003c/span\u003e)) _\n         OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;enabled\u0026#34;\u003c/span\u003e)) OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;my\u0026#34;\u003c/span\u003e)) OrElse _\n         (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;msgType\u0026#34;\u003c/span\u003e)) OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;Type\u0026#34;\u003c/span\u003e)) _\n         OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;EID\u0026#34;\u003c/span\u003e)) OrElse (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;Title\u0026#34;\u003c/span\u003e)) OrElse _\n         (parameters.GetKey(i).Equals(\u003cspan\u003e\u0026#34;ERROR\u0026#34;\u003c/span\u003e)) \u003cspan\u003eThen\u003c/span\u003e\n            URLParams \u0026amp;= \u003cspan\u003e\u0026#34;\u0026amp;\u0026#34;\u003c/span\u003e \u0026amp; parameters.GetKey(i).\u003cspan\u003eTo\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e()\n            URLParams \u0026amp;= \u003cspan\u003e\u0026#34;=\u0026#34;\u003c/span\u003e \u0026amp; parameters(i).\u003cspan\u003eTo\u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e()\n        \u003cspan\u003eEnd\u003c/span\u003e \u003cspan\u003eIf\u003c/span\u003e\n    \u003cspan\u003eEnd\u003c/span\u003e \u003cspan\u003eIf\u003c/span\u003e\n\u003cspan\u003eNext\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe goal of this code is to take a certain set of keys and construct a \u003ccode\u003eURLParams\u003c/code\u003e string which represents those key/values as an HTTP query string. The first thing to get out of the way: .NET has a \u003ccode\u003eQueryString\u003c/code\u003e type that handles the construction of the query string for you (including escaping), so that you don\u0026#39;t need to do any string concatenation.\u003c/p\u003e\n\u003cp\u003eBut the real WTF is everything surrounding that. We opt to iterate across every key- not just the ones we care about- and use the \u003ccode\u003eGetKey(i)\u003c/code\u003e function to check each individual key in an extensive chain of \u003ccode\u003eOrElse\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eThe obvious and simpler approach would have been to iterate across an array of the keys I care about- \u003ccode\u003eID, new, FID, enabled, my, msgType, Type, EID, Title, ERROR\u003c/code\u003e- and simply check if they were in the \u003ccode\u003eRequest\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eI suppose the only silver lining here is that they thought to use the \u003ccode\u003eOrElse\u003c/code\u003e operator- which is a short-circuiting \u0026#34;or\u0026#34; operation, like you\u0026#39;d expect in just about any other language, instead of \u003ccode\u003eOr\u003c/code\u003e, which \u003cem\u003edoesn\u0026#39;t\u003c/em\u003e short circuit (pulling double duty as both a bitwise \u003ccode\u003eOr\u003c/code\u003e and a logical \u003ccode\u003eOr\u003c/code\u003e, because Visual Basic wants to contribute some WTFs).\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-10-23T06:30:00Z",
  "modifiedTime": null
}
