{
  "id": "66b23794-cbb0-4197-9d09-6a089a8772d2",
  "title": "CodeSOD: Integral to a Database Read",
  "link": "https://thedailywtf.com/articles/integral-to-a-database-read",
  "description": "One of the key points of confusion for people unfamiliar with Java is the distinction between true object types, like Integer, and \"primitive\" types, like int. This is made worse by the collection types, like ArrayList, which needs to hold a true object type, but can't hold a primitive. A generic ArrayList is valid, but ArrayList won't compile. Fortunately for everyone, Java automatically \"boxes\" types- at least since Java 5, way back in 2004- so integerList.add(5) and int n = integerList.get(0) will both work just fine. Somebody should have told that to Alice's co-worker, who spends a lot of code to do some type gymnastics that they shouldn't have: try { ps = conn.prepareStatement(SQL_GET_LOT_WORKUP_STATUSES); ps.setLong(1, _lotId); rs = ps.executeQuery(); while (rs.next()) { result.add(new Integer(rs.getInt(1))); } } finally { CloseUtil.close(ps,rs); } // instatiate a the array _workupStatuses = new int[result.size()]; // convert the integers to ints for (int h=0; h This runs a query against the database, and then iterates across the result to populate a List type with integers, and right away we're getting into confused territory. rs.getInt returns an int primitive, which they manually box with new Integer, and stuff into the List. And look, I wouldn't really call that a WTF, but it's what they do next that leaves me scratching my head. They initialize a private member, _workupStatuses to a new array of ints. Then they copy every integer from the result collection into the array, first by casting the get return value to Integer, then by pulling off the intValue. In the end, this whole dance happens because Java ResultSet types open cursors on the database side and thus don't have the capacity to tell you how many rows they returned. You need to iterate across each record until it runs out of results. That's why they populate an intermediate list. Then they can check the size and create an array, but that itself is a big why. I'm not going to say that using arrays in Java is an instant anti-pattern, but it's always something to be suspicious of, especially when you're holding result sets. It's probably a premature optimization: the key performance distance is on insertions where an ArrayList may need to resize and copy its internal backing store. My suspicion, however, is that this code falls into the category of \"C programmer forced to do Java\". They're comfortable with an array of integers, which is covers 90% of the data types you use in C but a dynamic, complicated data structure is horrifying to them. So they use it when they absolutely have to, and then throw it away as quickly as they can to get back to what they're familiar with. .comment { border: none; } [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Thu, 05 Jun 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3265,
  "excerpt": "One of the key points of confusion for people unfamiliar with Java is the distinction between true object types, like Integer, and \"primitive\" types, like int. This is made worse by the collection types, like ArrayList, which needs to hold a true object type, but can't hold a primitive. A generic ArrayList\u003cInteger\u003e is valid, but ArrayList\u003cint\u003e won't compile. Fortunately for everyone, Java automatically \"boxes\" types- at least since Java 5, way back in 2004- so integerList.add(5) and int n = integerList.get(0) will both work just fine. Somebody should have told that to Alice's co-worker, who spends a lot of code to do some type gymnastics that they shouldn't have:",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-06-05 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. One of the key points of confusion for people unfamiliar with Java is the distinction between true object types, like Integer, and \"primitive\" types, like int. This is made worse by the collection types, like ArrayList, which needs to hold a true object type, but can't hold a primitive. A generic ArrayList\u003cInteger\u003e is valid, but ArrayList\u003cint\u003e won't compile. Fortunately for everyone, Java automatically \"boxes\" types- at least since Java 5, way back in 2004- so integerList.add(5) and int n = integerList.get(0) will both work just fine. Somebody should have told that to Alice's co-worker, who spends a lot of code to do some type gymnastics that they shouldn't have: try { ps = conn.prepareStatement(SQL_GET_LOT_WORKUP_STATUSES); ps.setLong(1, _lotId); rs = ps.executeQuery(); while (rs.next()) { result.add(new Integer(rs.getInt(1))); } } finally { CloseUtil.close(ps,rs); } // instatiate a the array _workupStatuses = new int[result.size()]; // convert the integers to ints for (int h=0; h\u003cresult.size(); h++) { _workupStatuses[h] = ((Integer)result.get(h)).intValue(); } This runs a query against the database, and then iterates across the result to populate a List type with integers, and right away we're getting into confused territory. rs.getInt returns an int primitive, which they manually box with new Integer, and stuff into the List. And look, I wouldn't really call that a WTF, but it's what they do next that leaves me scratching my head. They initialize a private member, _workupStatuses to a new array of ints. Then they copy every integer from the result collection into the array, first by casting the get return value to Integer, then by pulling off the intValue. In the end, this whole dance happens because Java ResultSet types open cursors on the database side and thus don't have the capacity to tell you how many rows they returned. You need to iterate across each record until it runs out of results. That's why they populate an intermediate list. Then they can check the size and create an array, but that itself is a big why. I'm not going to say that using arrays in Java is an instant anti-pattern, but it's always something to be suspicious of, especially when you're holding result sets. It's probably a premature optimization: the key performance distance is on insertions where an ArrayList may need to resize and copy its internal backing store. My suspicion, however, is that this code falls into the category of \"C programmer forced to do Java\". They're comfortable with an array of integers, which is covers 90% of the data types you use in C but a dynamic, complicated data structure is horrifying to them. So they use it when they absolutely have to, and then throw it away as quickly as they can to get back to what they're familiar with. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-06-05\"\u003e2025-06-05\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10930\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eOne of the key points of confusion for people unfamiliar with Java is the distinction between true object types, like \u003ccode\u003eInteger\u003c/code\u003e, and \u0026#34;primitive\u0026#34; types, like \u003ccode\u003eint\u003c/code\u003e. This is made worse by the collection types, like \u003ccode\u003eArrayList\u003c/code\u003e, which needs to hold a true object type, but can\u0026#39;t hold a primitive. A generic \u003ccode\u003eArrayList\u0026lt;Integer\u0026gt;\u003c/code\u003e is valid, but \u003ccode\u003eArrayList\u0026lt;int\u0026gt;\u003c/code\u003e won\u0026#39;t compile. Fortunately for everyone, Java automatically \u0026#34;boxes\u0026#34; types- at least since Java 5, way back in 2004- so \u003ccode\u003eintegerList.add(5)\u003c/code\u003e and \u003ccode\u003eint n = integerList.get(0)\u003c/code\u003e will both work just fine.\u003c/p\u003e\n\u003cp\u003eSomebody should have told that to \u003cstrong\u003eAlice\u003c/strong\u003e\u0026#39;s co-worker, who spends a lot of code to do some type gymnastics that they shouldn\u0026#39;t have:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etry\u003c/span\u003e {\n\t\tps = conn.prepareStatement(SQL_GET_LOT_WORKUP_STATUSES);\n\t\tps.setLong(\u003cspan\u003e1\u003c/span\u003e, _lotId);\n\n\t\trs = ps.executeQuery();\n\n\t\t\u003cspan\u003ewhile\u003c/span\u003e (rs.next()) {\n\t\t\t\tresult.add(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eInteger\u003c/span\u003e(rs.getInt(\u003cspan\u003e1\u003c/span\u003e)));\n\t\t}\n}\n\u003cspan\u003efinally\u003c/span\u003e {\n\t\tCloseUtil.close(ps,rs);\n}\n\n\u003cspan\u003e// instatiate a the array\u003c/span\u003e\n_workupStatuses = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e[result.size()];\n\n\u003cspan\u003e// convert the integers to ints\u003c/span\u003e\n\u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003eint\u003c/span\u003e h=\u003cspan\u003e0\u003c/span\u003e; h\u0026lt;result.size(); h++) {\n\t\t_workupStatuses[h] = ((Integer)result.get(h)).intValue();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis runs a query against the database, and then iterates across the result to populate a \u003ccode\u003eList\u003c/code\u003e type with integers, and right away we\u0026#39;re getting into confused territory. \u003ccode\u003ers.getInt\u003c/code\u003e returns an \u003ccode\u003eint\u003c/code\u003e primitive, which they manually box with \u003ccode\u003enew Integer\u003c/code\u003e, and stuff into the \u003ccode\u003eList\u003c/code\u003e. And look, I wouldn\u0026#39;t really call that a WTF, but it\u0026#39;s what they do next that leaves me scratching my head.\u003c/p\u003e\n\u003cp\u003eThey initialize a private member, \u003ccode\u003e_workupStatuses\u003c/code\u003e to a new array of \u003ccode\u003eint\u003c/code\u003es. Then they copy every integer from the \u003ccode\u003eresult\u003c/code\u003e collection into the array, first by casting the \u003ccode\u003eget\u003c/code\u003e return value to \u003ccode\u003eInteger\u003c/code\u003e, then by pulling off the \u003ccode\u003eintValue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn the end, this whole dance happens because Java \u003ccode\u003eResultSet\u003c/code\u003e types open cursors on the database side and thus don\u0026#39;t have the capacity to tell you how many rows they returned. You need to iterate across each record until it runs out of results. That\u0026#39;s why they populate an intermediate list. Then they can check the \u003ccode\u003esize\u003c/code\u003e and create an array, but that itself is a big \u003cem\u003ewhy\u003c/em\u003e. I\u0026#39;m not going to say that using arrays in Java is an instant anti-pattern, but it\u0026#39;s always something to be suspicious of, especially when you\u0026#39;re holding result sets. It\u0026#39;s \u003cem\u003eprobably\u003c/em\u003e a premature optimization: the key performance distance is on \u003cem\u003einsertions\u003c/em\u003e where an \u003ccode\u003eArrayList\u003c/code\u003e may need to resize and copy its internal backing store.\u003c/p\u003e\n\u003cp\u003eMy suspicion, however, is that this code falls into the category of \u0026#34;C programmer forced to do Java\u0026#34;. They\u0026#39;re comfortable with an array of integers, which is covers 90% of the data types you use in C but a dynamic, complicated data structure is horrifying to them. So they use it when they absolutely have to, and then throw it away as quickly as they can to get back to what they\u0026#39;re familiar with.\u003c/p\u003e\n\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-06-05T06:30:00Z",
  "modifiedTime": null
}
