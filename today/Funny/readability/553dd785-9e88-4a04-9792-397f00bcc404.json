{
  "id": "553dd785-9e88-4a04-9792-397f00bcc404",
  "title": "CodeSOD: Buff Reading",
  "link": "https://thedailywtf.com/articles/buff-reading",
  "description": "Frank inherited some code that reads URLs from a file, and puts them into a collection. This is a delightfully simple task. What could go wrong? static String[] readFile(String filename) { String record = null; Vector vURLs = new Vector(); int recCnt = 0; try { FileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr); record = new String(); while ((record = br.readLine()) != null) { vURLs.add(new String(record)); //System.out.println(recCnt + \": \" + vURLs.get(recCnt)); recCnt++; } } catch (IOException e) { // catch possible io errors from readLine() System.out.println(\"IOException error reading \" + filename + \" in readURLs()!\\n\"); e.printStackTrace(); } System.out.println(\"Reading URLs ...\\n\"); int arrCnt = 0; String[] sURLs = new String[vURLs.size()]; Enumeration eURLs = vURLs.elements(); for (Enumeration e = vURLs.elements() ; e.hasMoreElements() ;) { sURLs[arrCnt] = (String)e.nextElement(); System.out.println(arrCnt + \": \" + sURLs[arrCnt]); arrCnt++; } if (recCnt != arrCnt++) { System.out.println(\"WARNING: The number of URLs in the input file does not match the number of URLs in the array!\\n\\n\"); } return sURLs; } // end of readFile() So, we start by using a FileReader and a BufferedReader, which is the basic pattern any Java tutorial on file handling will tell you to do. What I see here is that the developer responsible didn't fully understand how strings work in Java. They initialize record to a new String() only to immediately discard that reference in their while loop. They also copy the record by doing a new String which is utterly unnecessary. As they load the Vector of strings, they also increment a recCount variable, which is superfluous since the collection can tell you how many elements are in it. Once the Vector is populated, they need to copy all this data into a String[]. Instead of using the toArray function, which is built in and does that, they iterate across the Vector and put each element into the array. As they build the array, they increment an arrCnt variable. Then, they do a check: if (recCnt != arrCnt++). Look at that line. Look at the post-increment on arrCnt, despite never using arrCnt again. Why is that there? Just for fun, apparently. Why is this check even there? The only way it's possible for the counts to not match is if somehow an exception was thrown after vURLs.add(new String(record)); but before recCount++, which doesn't seem likely. Certainly, if it happens, there's something worse going on. Now, I'm going to be generous and assume that this code predates Java 8- it just looks old. But it's worth noting that in Java 8, the BufferedReader class got a lines() function which returns a Stream that can be converted directly toArray, making all of this code superfluous, but also, so much of this code is just superfluous anyway. Anyway, for a fun game, start making the last use of every variable be a post-increment before it goes out of scope. See how many code reviews you can sneak it through! .comment { border: none; } [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "author": "Remy Porter",
  "published": "Wed, 21 May 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3606,
  "excerpt": "Frank inherited some code that reads URLs from a file, and puts them into a collection. This is a delightfully simple task. What could go wrong? static String[] readFile(String filename) { String record = null; Vector vURLs = new Vector(); int recCnt = 0; try { FileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr); record = new String(); while ((record = br.readLine()) != null) { vURLs.add(new String(record)); //System.out.println(recCnt + \": \" + vURLs.get(recCnt)); recCnt++; } } catch (IOException e) { // catch possible io errors from readLine() System.out.println(\"IOException error reading \" + filename + \" in readURLs()!\\n\"); e.printStackTrace(); } System.out.println(\"Reading URLs ...\\n\"); int arrCnt = 0; String[] sURLs = new String[vURLs.size()]; Enumeration eURLs = vURLs.elements(); for (Enumeration e = vURLs.elements() ; e.hasMoreElements() ;) { sURLs[arrCnt] = (String)e.nextElement(); System.out.println(arrCnt + \": \" + sURLs[arrCnt]); arrCnt++; } if (recCnt != arrCnt++) { System.out.println(\"WARNING: The number of URLs in the input file does not match the number of URLs in the array!\\n\\n\"); } return sURLs; } // end of readFile()",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2025-05-21 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Frank inherited some code that reads URLs from a file, and puts them into a collection. This is a delightfully simple task. What could go wrong? static String[] readFile(String filename) { String record = null; Vector vURLs = new Vector(); int recCnt = 0; try { FileReader fr = new FileReader(filename); BufferedReader br = new BufferedReader(fr); record = new String(); while ((record = br.readLine()) != null) { vURLs.add(new String(record)); //System.out.println(recCnt + \": \" + vURLs.get(recCnt)); recCnt++; } } catch (IOException e) { // catch possible io errors from readLine() System.out.println(\"IOException error reading \" + filename + \" in readURLs()!\\n\"); e.printStackTrace(); } System.out.println(\"Reading URLs ...\\n\"); int arrCnt = 0; String[] sURLs = new String[vURLs.size()]; Enumeration eURLs = vURLs.elements(); for (Enumeration e = vURLs.elements() ; e.hasMoreElements() ;) { sURLs[arrCnt] = (String)e.nextElement(); System.out.println(arrCnt + \": \" + sURLs[arrCnt]); arrCnt++; } if (recCnt != arrCnt++) { System.out.println(\"WARNING: The number of URLs in the input file does not match the number of URLs in the array!\\n\\n\"); } return sURLs; } // end of readFile() So, we start by using a FileReader and a BufferedReader, which is the basic pattern any Java tutorial on file handling will tell you to do. What I see here is that the developer responsible didn't fully understand how strings work in Java. They initialize record to a new String() only to immediately discard that reference in their while loop. They also copy the record by doing a new String which is utterly unnecessary. As they load the Vector of strings, they also increment a recCount variable, which is superfluous since the collection can tell you how many elements are in it. Once the Vector is populated, they need to copy all this data into a String[]. Instead of using the toArray function, which is built in and does that, they iterate across the Vector and put each element into the array. As they build the array, they increment an arrCnt variable. Then, they do a check: if (recCnt != arrCnt++). Look at that line. Look at the post-increment on arrCnt, despite never using arrCnt again. Why is that there? Just for fun, apparently. Why is this check even there? The only way it's possible for the counts to not match is if somehow an exception was thrown after vURLs.add(new String(record)); but before recCount++, which doesn't seem likely. Certainly, if it happens, there's something worse going on. Now, I'm going to be generous and assume that this code predates Java 8- it just looks old. But it's worth noting that in Java 8, the BufferedReader class got a lines() function which returns a Stream\u003cString\u003e that can be converted directly toArray, making all of this code superfluous, but also, so much of this code is just superfluous anyway. Anyway, for a fun game, start making the last use of every variable be a post-increment before it goes out of scope. See how many code reviews you can sneak it through! [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2025-05-21\"\u003e2025-05-21\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10919\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eFrank\u003c/strong\u003e inherited some code that reads URLs from a file, and puts them into a collection. This is a delightfully simple task. What could go wrong?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estatic\u003c/span\u003e String[]  readFile(String filename) {\n    \u003cspan\u003eString\u003c/span\u003e \u003cspan\u003erecord\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enull\u003c/span\u003e;\n    \u003cspan\u003eVector\u003c/span\u003e \u003cspan\u003evURLs\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eVector\u003c/span\u003e();\n    \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003erecCnt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e;\n\n    \u003cspan\u003etry\u003c/span\u003e {\n        \u003cspan\u003eFileReader\u003c/span\u003e \u003cspan\u003efr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eFileReader\u003c/span\u003e(filename);\n        \u003cspan\u003eBufferedReader\u003c/span\u003e \u003cspan\u003ebr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBufferedReader\u003c/span\u003e(fr);\n\n        record = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e();\n\n        \u003cspan\u003ewhile\u003c/span\u003e ((record = br.readLine()) != \u003cspan\u003enull\u003c/span\u003e) {\n            vURLs.add(\u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e(record));\n            \u003cspan\u003e//System.out.println(recCnt + \u0026#34;: \u0026#34; + vURLs.get(recCnt));\u003c/span\u003e\n            recCnt++;\n        }\n    } \u003cspan\u003ecatch\u003c/span\u003e (IOException e) {\n        \u003cspan\u003e// catch possible io errors from readLine()\u003c/span\u003e\n        System.out.println(\u003cspan\u003e\u0026#34;IOException error reading \u0026#34;\u003c/span\u003e + filename + \u003cspan\u003e\u0026#34; in readURLs()!\\n\u0026#34;\u003c/span\u003e);\n        e.printStackTrace();\n    }\n\n    System.out.println(\u003cspan\u003e\u0026#34;Reading URLs ...\\n\u0026#34;\u003c/span\u003e);\n\n    \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003earrCnt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e;\n    String[] sURLs = \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eString\u003c/span\u003e[vURLs.size()];\n    \u003cspan\u003eEnumeration\u003c/span\u003e \u003cspan\u003eeURLs\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e vURLs.elements();\n\n    \u003cspan\u003efor\u003c/span\u003e (\u003cspan\u003eEnumeration\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e vURLs.elements() ; e.hasMoreElements() ;) {\n        sURLs[arrCnt] = (String)e.nextElement();\n        System.out.println(arrCnt + \u003cspan\u003e\u0026#34;: \u0026#34;\u003c/span\u003e + sURLs[arrCnt]);\n        arrCnt++;\n    }\n\n    \u003cspan\u003eif\u003c/span\u003e (recCnt != arrCnt++) {\n        System.out.println(\u003cspan\u003e\u0026#34;WARNING: The number of URLs in the input file does not match the number of URLs in the array!\\n\\n\u0026#34;\u003c/span\u003e);\n    }\n\n    \u003cspan\u003ereturn\u003c/span\u003e sURLs;\n} \u003cspan\u003e// end of readFile()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo, we start by using a \u003ccode\u003eFileReader\u003c/code\u003e and a \u003ccode\u003eBufferedReader\u003c/code\u003e, which is the basic pattern any Java tutorial on file handling will tell you to do.\u003c/p\u003e\n\u003cp\u003eWhat I see here is that the developer responsible didn\u0026#39;t fully understand how strings work in Java. They initialize \u003ccode\u003erecord\u003c/code\u003e to a \u003ccode\u003enew String()\u003c/code\u003e only to immediately discard that reference in their while loop. They also copy the \u003ccode\u003erecord\u003c/code\u003e by doing a \u003ccode\u003enew String\u003c/code\u003e which is utterly unnecessary.\u003c/p\u003e\n\u003cp\u003eAs they load the \u003ccode\u003eVector\u003c/code\u003e of strings, they also increment a \u003ccode\u003erecCount\u003c/code\u003e variable, which is superfluous since the collection can tell you how many elements are in it.\u003c/p\u003e\n\u003cp\u003eOnce the \u003ccode\u003eVector\u003c/code\u003e is populated, they need to copy all this data into a \u003ccode\u003eString[]\u003c/code\u003e. Instead of using the \u003ccode\u003etoArray\u003c/code\u003e function, which is built in and does that, they iterate across the \u003ccode\u003eVector\u003c/code\u003e and put each element into the array.\u003c/p\u003e\n\u003cp\u003eAs they build the array, they increment an \u003ccode\u003earrCnt\u003c/code\u003e variable. Then, they do a check: \u003ccode\u003eif (recCnt != arrCnt++)\u003c/code\u003e. Look at that line. Look at the post-increment on \u003ccode\u003earrCnt\u003c/code\u003e, despite never using \u003ccode\u003earrCnt\u003c/code\u003e again. Why is that there? Just for fun, apparently. Why is this check even there?\u003c/p\u003e\n\u003cp\u003eThe only way it\u0026#39;s possible for the counts to \u003cem\u003enot\u003c/em\u003e match is if somehow an exception was thrown \u003cem\u003eafter\u003c/em\u003e \u003ccode\u003evURLs.add(new String(record));\u003c/code\u003e but before \u003ccode\u003erecCount++\u003c/code\u003e, which doesn\u0026#39;t seem likely. Certainly, if it happens, there\u0026#39;s something worse going on.\u003c/p\u003e\n\u003cp\u003eNow, I\u0026#39;m going to be generous and assume that this code predates Java 8- it just looks old. But it\u0026#39;s worth noting that in Java 8, the \u003ccode\u003eBufferedReader\u003c/code\u003e class got a \u003ccode\u003elines()\u003c/code\u003e function which returns a \u003ccode\u003eStream\u0026lt;String\u0026gt;\u003c/code\u003e that can be converted directly \u003ccode\u003etoArray\u003c/code\u003e, making all of this code superfluous, but also, so much of this code is just superfluous \u003cem\u003eanyway\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAnyway, for a fun game, start making the last use of every variable be a post-increment before it goes out of scope. See how many code reviews you can sneak it through!\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eUtilize BuildMaster\u003c/a\u003e to release your software with confidence, at the pace your business demands. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eDownload\u003c/a\u003e today!  \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-05-21T06:30:00Z",
  "modifiedTime": null
}
