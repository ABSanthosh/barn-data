{
  "id": "d8daf575-901f-48ce-a59f-dce943001d3e",
  "title": "CodeSOD: Switch How We Do Padding",
  "link": "https://thedailywtf.com/articles/switch-how-we-do-padding",
  "description": "We've seen so many home-brew string padding functions. And yet, there are still new ways to do this wrong. An endless supply of them. Nate, for example sent us this one. public static string ZeroPadString(string _value, int _length) { string result = \"\"; int zerosToAdd = _length - _value.length; I'm going to pause right here. Based on this, you likely think you know what's coming. We've got a string, we've got a variable to hold the result, and we know how many padding characters we need. Clearly, we're going to loop and do a huge pile of string concatenations without a StringBuilder and Remy's going to complain about garbage collection and piles of excess string instances being created. That's certainly what I expect. Let's see the whole function. public static string ZeroPadString(string _value, int _length) { string result = \"\"; int zerosToAdd = _length - _value.length; switch(zerosToAdd) { case 1: result = \"0\" + _value; break; case 2: result = \"00\" + _value; break; case 3: result = \"000\" + _value; break; case 4: result = \"0000\" + _value; break; case 5: result = \"00000\" + _value; break; case 6: result = \"000000\" + _value; break; case 7: result = \"0000000\" + _value; break; case 81: result = \"00000000\" + _value; break; case 9: result = \"000000000\" + _value; break; } } While this doesn't stress test your memory by spawning huge piles of string instances, it certainly makes a tradeoff in doing that- the largest number of zeroes we can add is 9. I guess, who's ever going to need more than 10 digits? Numbers that large never come up. Once again, this is C#. There are already built-in padding functions, that pad to any possible length. [Advertisement] Picking up NuGet is easy. Getting good at it takes time. Download our guide to learn the best practice of NuGet for the Enterprise.",
  "author": "Remy Porter",
  "published": "Mon, 30 Sep 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2235,
  "excerpt": "We've seen so many home-brew string padding functions. And yet, there are still new ways to do this wrong. An endless supply of them. Nate, for example sent us this one. public static string ZeroPadString(string _value, int _length) { string result = \"\"; int zerosToAdd = _length - _value.length;",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2024-09-30 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. We've seen so many home-brew string padding functions. And yet, there are still new ways to do this wrong. An endless supply of them. Nate, for example sent us this one. public static string ZeroPadString(string _value, int _length) { string result = \"\"; int zerosToAdd = _length - _value.length; I'm going to pause right here. Based on this, you likely think you know what's coming. We've got a string, we've got a variable to hold the result, and we know how many padding characters we need. Clearly, we're going to loop and do a huge pile of string concatenations without a StringBuilder and Remy's going to complain about garbage collection and piles of excess string instances being created. That's certainly what I expect. Let's see the whole function. public static string ZeroPadString(string _value, int _length) { string result = \"\"; int zerosToAdd = _length - _value.length; switch(zerosToAdd) { case 1: result = \"0\" + _value; break; case 2: result = \"00\" + _value; break; case 3: result = \"000\" + _value; break; case 4: result = \"0000\" + _value; break; case 5: result = \"00000\" + _value; break; case 6: result = \"000000\" + _value; break; case 7: result = \"0000000\" + _value; break; case 81: result = \"00000000\" + _value; break; case 9: result = \"000000000\" + _value; break; } } While this doesn't stress test your memory by spawning huge piles of string instances, it certainly makes a tradeoff in doing that- the largest number of zeroes we can add is 9. I guess, who's ever going to need more than 10 digits? Numbers that large never come up. Once again, this is C#. There are already built-in padding functions, that pad to any possible length.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-09-30\"\u003e2024-09-30\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10748\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eWe\u0026#39;ve seen so many home-brew string padding functions. And yet, there are still new ways to do this wrong. An endless supply of them. \u003cstrong\u003eNate\u003c/strong\u003e, for example sent us this one.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003estring\u003c/span\u003e \u003cspan\u003eZeroPadString\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e _value, \u003cspan\u003eint\u003c/span\u003e _length\u003c/span\u003e)\u003c/span\u003e\n{\n    \u003cspan\u003estring\u003c/span\u003e result = \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n    \u003cspan\u003eint\u003c/span\u003e zerosToAdd = _length - _value.length;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI\u0026#39;m going to pause right here. Based on this, you likely think you know what\u0026#39;s coming. We\u0026#39;ve got a string, we\u0026#39;ve got a variable to hold the result, and we know how many padding characters we need. Clearly, we\u0026#39;re going to loop and do a huge pile of string concatenations without a \u003ccode\u003eStringBuilder\u003c/code\u003e and Remy\u0026#39;s going to complain about garbage collection and piles of excess string instances being created.\u003c/p\u003e\n\u003cp\u003eThat\u0026#39;s certainly what \u003cem\u003eI\u003c/em\u003e expect. Let\u0026#39;s see the whole function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003estring\u003c/span\u003e \u003cspan\u003eZeroPadString\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003estring\u003c/span\u003e _value, \u003cspan\u003eint\u003c/span\u003e _length\u003c/span\u003e)\u003c/span\u003e\n{\n    \u003cspan\u003estring\u003c/span\u003e result = \u003cspan\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\n    \u003cspan\u003eint\u003c/span\u003e zerosToAdd = _length - _value.length;\n\n    \u003cspan\u003eswitch\u003c/span\u003e(zerosToAdd)\n    {\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;0\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;00\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e4\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;0000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e5\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;00000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e6\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;000000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e7\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;0000000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e81\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;00000000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n        \u003cspan\u003ecase\u003c/span\u003e \u003cspan\u003e9\u003c/span\u003e:\n            result = \u003cspan\u003e\u0026#34;000000000\u0026#34;\u003c/span\u003e + _value;\n            \u003cspan\u003ebreak\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhile this doesn\u0026#39;t stress test your memory by spawning huge piles of string instances, it certainly makes a tradeoff in doing that- the largest number of zeroes we can add is 9. I guess, who\u0026#39;s ever going to need more than 10 digits? Numbers that large never come up.\u003c/p\u003e\n\u003cp\u003eOnce again, this is C#. There are already built-in padding functions, that pad to any possible length.\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-09-30T06:30:00Z",
  "modifiedTime": null
}
