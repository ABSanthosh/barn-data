{
  "id": "b53ed472-e7a0-4258-a8c5-154449904818",
  "title": "Best of…: Best of 2024: A Bit About the HP3000",
  "link": "https://thedailywtf.com/articles/best-of-2024-a-bit-about-the-hp3000",
  "description": "As we enter that little gap between Christmas and New Year's, we explore some of the highlights of 2024. We start with this historical computing story. And unlike the subject, this shipped ready to read (and reprint). --Remy Today's anonymously submitted story is a case where the WTF isn't the code itself, per se. This arguably could be a CodeSOD, and we'll get to the code, but there's so much more to the story. Our submitter, let's call them Janice, used to work for a financial institution with a slew of legacy systems. One such system was an HP3000 minicomputer. \"Mini\", of course, meant \"refrigerator sized\". The HP3000 itself is an interesting, if peripheral story, because it's one of the tales of a product launch going incredibly wrong. Let's talk a little history. We start with the HP2100 in 1966, which Hewlett Packard did nothing to design, and instead purchased the company that designed it. The core innovation of the HP2100 was that it was architecturally similar to a PDP-8, but supported full 16-bit memory, instead of PDP's 12-bit. HP didn't really know what they had bought- they marketed it as a \"test and instrumentation\" system, and were surprised when businesses purchased it for back office operations. They ended up with one of the most popular minicomputers for office use, despite it not being designed for that purpose. Thus began the projects \"Alpha\" and \"Omega\". Alpha was a hardware refresh of the 2100, with a better memory model. Omega was a ground-up redesign for 32-bit memory, which would allow it to support a whopping 4MB of RAM. There was just one problem with the Omega design: they didn't have funding to actually finish it. The project was killed in 1970, which threw some of the staff into \"wear black armbands to work\" levels of mourning. Unfortunately, while work was done on Omega, the scope of Alpha crept, which resulted in another project management wasn't sure could be delivered. But the market was there for a time-sharing minicomputer, so they pressed on despite the concerns. The HP2000-line had time sharing system that used multiple processors. There was a front-end processor which handled user interactions. Then there was the actual CPU, which ran programs. This meant that time-sharing was simplified- the CPU just ran programs in a round-robin fashion, and didn't have to worry about pesky things like user inputs. Essentially, it was really just a batch processing system with a multi-user front-end. The designers of Alpha wanted to support full multiprogramming, instead of this hybrid-ish model. But they also needed to support traditional batch processing, as well as real-time execution. So the team split up to build the components of the \"Multi-Programming Executive\" module, which would allow all of these features. The Alpha, which was still 16-bit, didn't have the luxurious 4MB of RAM- it had 128kB. The MPE used much more memory than 128kB. This led to a massive crunch as the programmers worked to shrink MPE into something usable, while marketing looked at the deadlines and said, \"We were supposed to be selling this thing months ago!\" The result was a massive war between engineering and marketing, where marketing gave customers promises about what the performance would be, engineering told marketing what the actual performance would be (significantly worse than what marketing was promising), and then management would demand engineering \"prove\" that marketing's over-promises could be met. The initial ship-date was November, 1972, and by god, they shipped on time. Nothing actually worked, but they shipped. The first computer out the door was returned almost immediately. It could only handle two simultaneous users before slowing to a crawl, and crashed every ten minutes. By December, HP had gotten that to \"crashes every two hours\". They kept shipping machines even as they had to cut features and reliability promises. Those frequent crashes also concealed another bug: after running for 24 days, the HP3000's clock would overflow (2^31 milliseconds) and the clock would magically reverse by 25 days. As one sysop of a purchased HP3000 put it: \"The original designers of MPE never thought the OS would stay up for 25+ days in a row\". After a bunch of management shuffling, the titular Packard of Hewlett Packard sent a memo: production was stopping and all sold computers were being recalled. Customers were offered HP2000s in its place, or they could wait until fall 1973 for a revised version- that would only support 4-6 users, far fewer than marketing's initial promises of 64. This pleased no one, and it's reported that some customers cried over the disappointment. With sales paused, the entire computer underwent a design overhaul. The resulting machine was faster and cheaper and could actually handle 8 simultaneous users. One year after the botched launch, the HP3000 went back on the market, and ended up being a full success. It was so successful, HP continued supporting the HP3000 until 2010, which is where Janice enters our story. Circa 2006, she needed to update some Pascal code. That code used a lot of bit-masks to handle flags, which is normally a pretty easy function in Pascal- the language has a standard set of bitwise operations. So Janice was surprised to see: FUNCTION BITON(A , B : INTEGER): BOOLEAN; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE BITON:=FALSE; END; IF ((B DIV C) MOD 2) = 1 THEN BITON:=TRUE ELSE BITON:=FALSE; END; FUNCTION SETBITON(A, B : INTEGER) : INTEGER; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE C:=0; END; IF NOT BITON(A,B) THEN SETBITON:=B + C ELSE SETBITON:=B; END; FUNCTION SETBITOFF(A, B : INTEGER) : INTEGER; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE C:=0; END; IF BITON(A,B) THEN SETBITOFF:=B - C ELSE SETBITOFF:=B; END; FUNCTION LAND(A,B : INTEGER) : INTEGER; VAR I : INTEGER; BEGIN I:=0; REPEAT IF BITON(I,A) THEN IF BITON(I,B) THEN A:=SETBITON(I,A) ELSE A:=SETBITOFF(I,A) ELSE A:=SETBITOFF(I,A); I:=I + 1; UNTIL I \u003e 15; LAND:=A; END; This is a set of hand-reinvented bitwise operations, culminating in an LAND, which does a bitwise and (not a logical and, which makes it annoyingly misnamed). I wouldn't call the code a horrible approach to doing this, even if it's definitely an inefficient approach (and when you're running a 33 year old computer, efficiency matters), but absent built-in bitwise operations, I can't see a lot of other options. The biggest problem is that LAND will set bits on that are already on, which is unnecessary- an AND should really only ever turn bits off. Which, as it turns out, is the root WTF. The developer responsible wasn't ignorant about bitwise operations. The version of Pascal that shipped on the HP3000 simply didn't have any. No and, or, not, or xor. Not even a shift-left or shift-right operation. In any case, this is what happens when I start doing research on a story and end up getting sucked down a rabbit hole. As always, while Wikipedia's true value is as a bibliography. A lot of those links have much more detail, but I hope this quick overview was an interesting story. [Advertisement] Keep the plebs out of prod. Restrict NuGet feed privileges with ProGet. Learn more.",
  "author": "Remy Porter",
  "published": "Thu, 26 Dec 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Best of…"
  ],
  "byline": "Remy Porter",
  "length": 9051,
  "excerpt": "As we enter that little gap between Christmas and New Year's, we explore some of the highlights of 2024. We start with this historical computing story. And unlike the subject, this shipped ready to read (and reprint). --Remy Today's anonymously submitted story is a case where the WTF isn't the code itself, per se. This arguably could be a CodeSOD, and we'll get to the code, but there's so much more to the story. Our submitter, let's call them Janice, used to work for a financial institution with a slew of legacy systems. One such system was an HP3000 minicomputer. \"Mini\", of course, meant \"refrigerator sized\".",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "As we enter that little gap between Christmas and New Year's, we explore some of the highlights of 2024. We start with this historical computing story. And unlike the subject, this shipped ready to read (and reprint). --Remy Today's anonymously submitted story is a case where the WTF isn't the code itself, per se. This arguably could be a CodeSOD, and we'll get to the code, but there's so much more to the story. Our submitter, let's call them Janice, used to work for a financial institution with a slew of legacy systems. One such system was an HP3000 minicomputer. \"Mini\", of course, meant \"refrigerator sized\". The HP3000 itself is an interesting, if peripheral story, because it's one of the tales of a product launch going incredibly wrong. Let's talk a little history. We start with the HP2100 in 1966, which Hewlett Packard did nothing to design, and instead purchased the company that designed it. The core innovation of the HP2100 was that it was architecturally similar to a PDP-8, but supported full 16-bit memory, instead of PDP's 12-bit. HP didn't really know what they had bought- they marketed it as a \"test and instrumentation\" system, and were surprised when businesses purchased it for back office operations. They ended up with one of the most popular minicomputers for office use, despite it not being designed for that purpose. Thus began the projects \"Alpha\" and \"Omega\". Alpha was a hardware refresh of the 2100, with a better memory model. Omega was a ground-up redesign for 32-bit memory, which would allow it to support a whopping 4MB of RAM. There was just one problem with the Omega design: they didn't have funding to actually finish it. The project was killed in 1970, which threw some of the staff into \"wear black armbands to work\" levels of mourning. Unfortunately, while work was done on Omega, the scope of Alpha crept, which resulted in another project management wasn't sure could be delivered. But the market was there for a time-sharing minicomputer, so they pressed on despite the concerns. The HP2000-line had time sharing system that used multiple processors. There was a front-end processor which handled user interactions. Then there was the actual CPU, which ran programs. This meant that time-sharing was simplified- the CPU just ran programs in a round-robin fashion, and didn't have to worry about pesky things like user inputs. Essentially, it was really just a batch processing system with a multi-user front-end. The designers of Alpha wanted to support full multiprogramming, instead of this hybrid-ish model. But they also needed to support traditional batch processing, as well as real-time execution. So the team split up to build the components of the \"Multi-Programming Executive\" module, which would allow all of these features. The Alpha, which was still 16-bit, didn't have the luxurious 4MB of RAM- it had 128kB. The MPE used much more memory than 128kB. This led to a massive crunch as the programmers worked to shrink MPE into something usable, while marketing looked at the deadlines and said, \"We were supposed to be selling this thing months ago!\" The result was a massive war between engineering and marketing, where marketing gave customers promises about what the performance would be, engineering told marketing what the actual performance would be (significantly worse than what marketing was promising), and then management would demand engineering \"prove\" that marketing's over-promises could be met. The initial ship-date was November, 1972, and by god, they shipped on time. Nothing actually worked, but they shipped. The first computer out the door was returned almost immediately. It could only handle two simultaneous users before slowing to a crawl, and crashed every ten minutes. By December, HP had gotten that to \"crashes every two hours\". They kept shipping machines even as they had to cut features and reliability promises. Those frequent crashes also concealed another bug: after running for 24 days, the HP3000's clock would overflow (2^31 milliseconds) and the clock would magically reverse by 25 days. As one sysop of a purchased HP3000 put it: \"The original designers of MPE never thought the OS would stay up for 25+ days in a row\". After a bunch of management shuffling, the titular Packard of Hewlett Packard sent a memo: production was stopping and all sold computers were being recalled. Customers were offered HP2000s in its place, or they could wait until fall 1973 for a revised version- that would only support 4-6 users, far fewer than marketing's initial promises of 64. This pleased no one, and it's reported that some customers cried over the disappointment. With sales paused, the entire computer underwent a design overhaul. The resulting machine was faster and cheaper and could actually handle 8 simultaneous users. One year after the botched launch, the HP3000 went back on the market, and ended up being a full success. It was so successful, HP continued supporting the HP3000 until 2010, which is where Janice enters our story. Circa 2006, she needed to update some Pascal code. That code used a lot of bit-masks to handle flags, which is normally a pretty easy function in Pascal- the language has a standard set of bitwise operations. So Janice was surprised to see: FUNCTION BITON(A , B : INTEGER): BOOLEAN; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE BITON:=FALSE; END; IF ((B DIV C) MOD 2) = 1 THEN BITON:=TRUE ELSE BITON:=FALSE; END; FUNCTION SETBITON(A, B : INTEGER) : INTEGER; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE C:=0; END; IF NOT BITON(A,B) THEN SETBITON:=B + C ELSE SETBITON:=B; END; FUNCTION SETBITOFF(A, B : INTEGER) : INTEGER; VAR C : INTEGER; BEGIN CASE A OF 15 : C:=1; 14 : C:=2; 13 : C:=4; 12 : C:=8; 11 : C:=16; 10 : C:=32; 9 : C:=64; 8 : C:=128; 7 : C:=256; 6 : C:=512; 5 : C:=1024; 4 : C:=2048; 3 : C:=4096; 2 : C:=8192; 1 : C:=16384; 0 : C:=32768; OTHERWISE C:=0; END; IF BITON(A,B) THEN SETBITOFF:=B - C ELSE SETBITOFF:=B; END; FUNCTION LAND(A,B : INTEGER) : INTEGER; VAR I : INTEGER; BEGIN I:=0; REPEAT IF BITON(I,A) THEN IF BITON(I,B) THEN A:=SETBITON(I,A) ELSE A:=SETBITOFF(I,A) ELSE A:=SETBITOFF(I,A); I:=I + 1; UNTIL I \u003e 15; LAND:=A; END; This is a set of hand-reinvented bitwise operations, culminating in an LAND, which does a bitwise and (not a logical and, which makes it annoyingly misnamed). I wouldn't call the code a horrible approach to doing this, even if it's definitely an inefficient approach (and when you're running a 33 year old computer, efficiency matters), but absent built-in bitwise operations, I can't see a lot of other options. The biggest problem is that LAND will set bits on that are already on, which is unnecessary- an AND should really only ever turn bits off. Which, as it turns out, is the root WTF. The developer responsible wasn't ignorant about bitwise operations. The version of Pascal that shipped on the HP3000 simply didn't have any. No and, or, not, or xor. Not even a shift-left or shift-right operation. In any case, this is what happens when I start doing research on a story and end up getting sucked down a rabbit hole. As always, while Wikipedia's true value is as a bibliography. A lot of those links have much more detail, but I hope this quick overview was an interesting story. [Advertisement] Keep the plebs out of prod. Restrict NuGet feed privileges with ProGet. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cblockquote\u003eAs we enter that little gap between Christmas and New Year\u0026#39;s, we explore some of the highlights of 2024. We start with \u003ca href=\"https://thedailywtf.com/articles/a-bit-about-the-hp3000\"\u003ethis historical computing story\u003c/a\u003e. And unlike the subject, this shipped ready to read (and reprint). --\u003cstrong\u003eRemy\u003c/strong\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eToday\u0026#39;s anonymously submitted story is a case where the WTF isn\u0026#39;t the code itself, per se. This arguably could be a CodeSOD, and we\u0026#39;ll get to the code, but there\u0026#39;s so much more to the story.\u003c/p\u003e\n\u003cp\u003eOur submitter, let\u0026#39;s call them \u003cstrong\u003eJanice\u003c/strong\u003e, used to work for a financial institution with a slew of legacy systems. One such system was an HP3000 minicomputer. \u0026#34;Mini\u0026#34;, of course, meant \u0026#34;refrigerator sized\u0026#34;.\u003c/p\u003e\n\u003cp\u003eThe HP3000 itself is an interesting, if peripheral story, because it\u0026#39;s one of the tales of a product launch going \u003cem\u003eincredibly wrong\u003c/em\u003e. Let\u0026#39;s talk a little history.\u003c/p\u003e\n\u003cp\u003eWe start with the HP2100 in 1966, which Hewlett Packard did nothing to design, and instead purchased the company that designed it. The core innovation of the HP2100 was that it was architecturally similar to a PDP-8, but supported full 16-bit memory, instead of PDP\u0026#39;s 12-bit.\u003c/p\u003e\n\u003cp\u003eHP didn\u0026#39;t really know what they had bought- they marketed it as a \u0026#34;test and instrumentation\u0026#34; system, and were surprised when businesses purchased it for back office operations. They ended up with one of the most popular minicomputers for office use, despite it not being designed for that purpose.\u003c/p\u003e\n\u003cp\u003eThus began the projects \u0026#34;Alpha\u0026#34; and \u0026#34;Omega\u0026#34;. Alpha was a hardware refresh of the 2100, with a better memory model. Omega was a ground-up redesign for 32-bit memory, which would allow it to support a whopping 4MB of RAM. There was just one problem with the Omega design: \u003cem\u003ethey didn\u0026#39;t have funding to actually finish it\u003c/em\u003e. The project was killed in 1970, which threw some of the staff into \u0026#34;wear black armbands to work\u0026#34; levels of mourning.\u003c/p\u003e\n\u003cp\u003eUnfortunately, while work was done on Omega, the scope of Alpha crept, which resulted in another project management wasn\u0026#39;t sure could be delivered. But the market was there for a time-sharing minicomputer, so they pressed on despite the concerns.\u003c/p\u003e\n\u003cp\u003eThe HP2000-line had time sharing system that used multiple processors. There was a front-end processor which handled user interactions. Then there was the actual CPU, which ran programs. This meant that time-sharing was simplified- the CPU just ran programs in a round-robin fashion, and didn\u0026#39;t have to worry about pesky things like user inputs. Essentially, it was really just a batch processing system with a multi-user front-end.\u003c/p\u003e\n\u003cp\u003eThe designers of Alpha wanted to support \u003cem\u003efull\u003c/em\u003e multiprogramming, instead of this hybrid-ish model. But they also needed to support traditional batch processing, as well as real-time execution. So the team split up to build the components of the \u0026#34;Multi-Programming Executive\u0026#34; module, which would allow all of these features.\u003c/p\u003e\n\u003cp\u003eThe Alpha, which was still 16-bit, didn\u0026#39;t have the luxurious 4MB of RAM- it had 128kB. The MPE used much more memory than 128kB. This led to a massive crunch as the programmers worked to shrink MPE into something usable, while marketing looked at the deadlines and said, \u0026#34;We were supposed to be selling this thing months ago!\u0026#34;\u003c/p\u003e\n\u003cp\u003eThe result was a massive war between engineering and marketing, where marketing gave customers promises about what the performance would be, engineering told marketing what the \u003cem\u003eactual\u003c/em\u003e performance would be (significantly worse than what marketing was promising), and then management would demand engineering \u0026#34;prove\u0026#34; that marketing\u0026#39;s over-promises could be met.\u003c/p\u003e\n\u003cp\u003eThe initial ship-date was November, 1972, and by god, they shipped on time. Nothing actually worked, \u003cem\u003ebut they shipped\u003c/em\u003e. The first computer out the door was returned almost immediately. It could only handle two simultaneous users before slowing to a crawl, and crashed every ten minutes. By December, HP had gotten that to \u0026#34;crashes every two hours\u0026#34;. They kept shipping machines even as they had to cut features and reliability promises.\u003c/p\u003e\n\u003cp\u003eThose frequent crashes also concealed another bug: after running for 24 days, the HP3000\u0026#39;s clock would overflow (\u003ccode\u003e2^31\u003c/code\u003e milliseconds) and the clock would magically reverse by 25 days. As one sysop of a purchased HP3000 put it: \u0026#34;The original designers of MPE never thought the OS would stay up for 25+ days in a row\u0026#34;.\u003c/p\u003e\n\u003cp\u003eAfter a bunch of management shuffling, the titular Packard of Hewlett Packard sent a memo: production was stopping and all sold computers were being recalled. Customers were offered HP2000s in its place, or they could wait until fall 1973 for a revised version- that would only support 4-6 users, far fewer than marketing\u0026#39;s initial promises of 64. This pleased no one, and it\u0026#39;s reported that some customers cried over the disappointment.\u003c/p\u003e\n\u003cp\u003eWith sales paused, the entire computer underwent a design overhaul. The resulting machine was faster \u003cem\u003eand\u003c/em\u003e cheaper and could actually handle 8 simultaneous users. One year after the botched launch, the HP3000 went back on the market, and ended up being a full success.\u003c/p\u003e\n\u003cp\u003eIt was so successful, HP continued supporting the HP3000 until 2010, which is where Janice enters our story. Circa 2006, she needed to update some Pascal code. That code used a lot of bit-masks to handle flags, which is \u003cem\u003enormally\u003c/em\u003e a pretty easy function in Pascal- the language has a standard set of bitwise operations. So Janice was surprised to see:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003eFUNCTION\u003c/span\u003e \u003cspan\u003eBITON\u003c/span\u003e\u003cspan\u003e(A , B : INTEGER)\u003c/span\u003e:\u003c/span\u003e BOOLEAN;\n\u003cspan\u003eVAR\u003c/span\u003e\n        C : INTEGER;\n\u003cspan\u003eBEGIN\u003c/span\u003e\n        \u003cspan\u003eCASE\u003c/span\u003e A \u003cspan\u003eOF\u003c/span\u003e\n                \u003cspan\u003e15\u003c/span\u003e : C:=\u003cspan\u003e1\u003c/span\u003e;\n                \u003cspan\u003e14\u003c/span\u003e : C:=\u003cspan\u003e2\u003c/span\u003e;\n                \u003cspan\u003e13\u003c/span\u003e : C:=\u003cspan\u003e4\u003c/span\u003e;\n                \u003cspan\u003e12\u003c/span\u003e : C:=\u003cspan\u003e8\u003c/span\u003e;\n                \u003cspan\u003e11\u003c/span\u003e : C:=\u003cspan\u003e16\u003c/span\u003e;\n                \u003cspan\u003e10\u003c/span\u003e : C:=\u003cspan\u003e32\u003c/span\u003e;\n                \u003cspan\u003e9\u003c/span\u003e : C:=\u003cspan\u003e64\u003c/span\u003e;\n                \u003cspan\u003e8\u003c/span\u003e : C:=\u003cspan\u003e128\u003c/span\u003e;\n                \u003cspan\u003e7\u003c/span\u003e : C:=\u003cspan\u003e256\u003c/span\u003e;\n                \u003cspan\u003e6\u003c/span\u003e : C:=\u003cspan\u003e512\u003c/span\u003e;\n                \u003cspan\u003e5\u003c/span\u003e : C:=\u003cspan\u003e1024\u003c/span\u003e;\n                \u003cspan\u003e4\u003c/span\u003e : C:=\u003cspan\u003e2048\u003c/span\u003e;\n                \u003cspan\u003e3\u003c/span\u003e : C:=\u003cspan\u003e4096\u003c/span\u003e;\n                \u003cspan\u003e2\u003c/span\u003e : C:=\u003cspan\u003e8192\u003c/span\u003e;\n                \u003cspan\u003e1\u003c/span\u003e : C:=\u003cspan\u003e16384\u003c/span\u003e;\n                \u003cspan\u003e0\u003c/span\u003e : C:=\u003cspan\u003e32768\u003c/span\u003e;\n        \u003cspan\u003eOTHERWISE\u003c/span\u003e\n                BITON:=FALSE;\n        \u003cspan\u003eEND\u003c/span\u003e;\n        \u003cspan\u003eIF\u003c/span\u003e ((B \u003cspan\u003eDIV\u003c/span\u003e C) \u003cspan\u003eMOD\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e) = \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003eTHEN\u003c/span\u003e\n                BITON:=TRUE\n        \u003cspan\u003eELSE\u003c/span\u003e\n                BITON:=FALSE;\n\u003cspan\u003eEND\u003c/span\u003e;\n\n\u003cspan\u003e\u003cspan\u003eFUNCTION\u003c/span\u003e \u003cspan\u003eSETBITON\u003c/span\u003e\u003cspan\u003e(A, B : INTEGER)\u003c/span\u003e :\u003c/span\u003e INTEGER;\n\u003cspan\u003eVAR\u003c/span\u003e\n        C : INTEGER;\n\u003cspan\u003eBEGIN\u003c/span\u003e\n        \u003cspan\u003eCASE\u003c/span\u003e A \u003cspan\u003eOF\u003c/span\u003e\n                \u003cspan\u003e15\u003c/span\u003e : C:=\u003cspan\u003e1\u003c/span\u003e;\n                \u003cspan\u003e14\u003c/span\u003e : C:=\u003cspan\u003e2\u003c/span\u003e;\n                \u003cspan\u003e13\u003c/span\u003e : C:=\u003cspan\u003e4\u003c/span\u003e;\n                \u003cspan\u003e12\u003c/span\u003e : C:=\u003cspan\u003e8\u003c/span\u003e;\n                \u003cspan\u003e11\u003c/span\u003e : C:=\u003cspan\u003e16\u003c/span\u003e;\n                \u003cspan\u003e10\u003c/span\u003e : C:=\u003cspan\u003e32\u003c/span\u003e;\n                \u003cspan\u003e9\u003c/span\u003e : C:=\u003cspan\u003e64\u003c/span\u003e;\n                \u003cspan\u003e8\u003c/span\u003e : C:=\u003cspan\u003e128\u003c/span\u003e;\n                \u003cspan\u003e7\u003c/span\u003e : C:=\u003cspan\u003e256\u003c/span\u003e;\n                \u003cspan\u003e6\u003c/span\u003e : C:=\u003cspan\u003e512\u003c/span\u003e;\n                \u003cspan\u003e5\u003c/span\u003e : C:=\u003cspan\u003e1024\u003c/span\u003e;\n                \u003cspan\u003e4\u003c/span\u003e : C:=\u003cspan\u003e2048\u003c/span\u003e;\n                \u003cspan\u003e3\u003c/span\u003e : C:=\u003cspan\u003e4096\u003c/span\u003e;\n                \u003cspan\u003e2\u003c/span\u003e : C:=\u003cspan\u003e8192\u003c/span\u003e;\n                \u003cspan\u003e1\u003c/span\u003e : C:=\u003cspan\u003e16384\u003c/span\u003e;\n                \u003cspan\u003e0\u003c/span\u003e : C:=\u003cspan\u003e32768\u003c/span\u003e;\n        \u003cspan\u003eOTHERWISE\u003c/span\u003e\n                C:=\u003cspan\u003e0\u003c/span\u003e;\n        \u003cspan\u003eEND\u003c/span\u003e;\n        \u003cspan\u003eIF\u003c/span\u003e \u003cspan\u003eNOT\u003c/span\u003e BITON(A,B) \u003cspan\u003eTHEN\u003c/span\u003e\n                SETBITON:=B + C\n        \u003cspan\u003eELSE\u003c/span\u003e\n                SETBITON:=B;\n\u003cspan\u003eEND\u003c/span\u003e;\n\n\u003cspan\u003e\u003cspan\u003eFUNCTION\u003c/span\u003e \u003cspan\u003eSETBITOFF\u003c/span\u003e\u003cspan\u003e(A, B : INTEGER)\u003c/span\u003e :\u003c/span\u003e INTEGER;\n\u003cspan\u003eVAR\u003c/span\u003e\n        C : INTEGER;\n\u003cspan\u003eBEGIN\u003c/span\u003e\n        \u003cspan\u003eCASE\u003c/span\u003e A \u003cspan\u003eOF\u003c/span\u003e\n                \u003cspan\u003e15\u003c/span\u003e : C:=\u003cspan\u003e1\u003c/span\u003e;\n                \u003cspan\u003e14\u003c/span\u003e : C:=\u003cspan\u003e2\u003c/span\u003e;\n                \u003cspan\u003e13\u003c/span\u003e : C:=\u003cspan\u003e4\u003c/span\u003e;\n                \u003cspan\u003e12\u003c/span\u003e : C:=\u003cspan\u003e8\u003c/span\u003e;\n                \u003cspan\u003e11\u003c/span\u003e : C:=\u003cspan\u003e16\u003c/span\u003e;\n                \u003cspan\u003e10\u003c/span\u003e : C:=\u003cspan\u003e32\u003c/span\u003e;\n                \u003cspan\u003e9\u003c/span\u003e : C:=\u003cspan\u003e64\u003c/span\u003e;\n                \u003cspan\u003e8\u003c/span\u003e : C:=\u003cspan\u003e128\u003c/span\u003e;\n                \u003cspan\u003e7\u003c/span\u003e : C:=\u003cspan\u003e256\u003c/span\u003e;\n                \u003cspan\u003e6\u003c/span\u003e : C:=\u003cspan\u003e512\u003c/span\u003e;\n                \u003cspan\u003e5\u003c/span\u003e : C:=\u003cspan\u003e1024\u003c/span\u003e;\n                \u003cspan\u003e4\u003c/span\u003e : C:=\u003cspan\u003e2048\u003c/span\u003e;\n                \u003cspan\u003e3\u003c/span\u003e : C:=\u003cspan\u003e4096\u003c/span\u003e;\n                \u003cspan\u003e2\u003c/span\u003e : C:=\u003cspan\u003e8192\u003c/span\u003e;\n                \u003cspan\u003e1\u003c/span\u003e : C:=\u003cspan\u003e16384\u003c/span\u003e;\n                \u003cspan\u003e0\u003c/span\u003e : C:=\u003cspan\u003e32768\u003c/span\u003e;\n        \u003cspan\u003eOTHERWISE\u003c/span\u003e\n                C:=\u003cspan\u003e0\u003c/span\u003e;\n        \u003cspan\u003eEND\u003c/span\u003e;\n        \u003cspan\u003eIF\u003c/span\u003e BITON(A,B) \u003cspan\u003eTHEN\u003c/span\u003e\n                SETBITOFF:=B - C\n        \u003cspan\u003eELSE\u003c/span\u003e\n                SETBITOFF:=B;\n\u003cspan\u003eEND\u003c/span\u003e;\n\n\u003cspan\u003e\u003cspan\u003eFUNCTION\u003c/span\u003e \u003cspan\u003eLAND\u003c/span\u003e\u003cspan\u003e(A,B : INTEGER)\u003c/span\u003e :\u003c/span\u003e INTEGER;\n\u003cspan\u003eVAR\u003c/span\u003e\n        I : INTEGER;\n\u003cspan\u003eBEGIN\u003c/span\u003e\n        I:=\u003cspan\u003e0\u003c/span\u003e;\n        \u003cspan\u003eREPEAT\u003c/span\u003e\n                \u003cspan\u003eIF\u003c/span\u003e BITON(I,A) \u003cspan\u003eTHEN\u003c/span\u003e\n                        \u003cspan\u003eIF\u003c/span\u003e BITON(I,B) \u003cspan\u003eTHEN\u003c/span\u003e\n                                A:=SETBITON(I,A)\n                        \u003cspan\u003eELSE\u003c/span\u003e\n                                A:=SETBITOFF(I,A)\n                \u003cspan\u003eELSE\u003c/span\u003e\n                        A:=SETBITOFF(I,A);\n                I:=I + \u003cspan\u003e1\u003c/span\u003e;\n        \u003cspan\u003eUNTIL\u003c/span\u003e I \u0026gt; \u003cspan\u003e15\u003c/span\u003e;\n        LAND:=A;\n\u003cspan\u003eEND\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a set of hand-reinvented bitwise operations, culminating in an \u003ccode\u003eLAND\u003c/code\u003e, which does a bitwise and (not a logical and, which makes it annoyingly misnamed). I wouldn\u0026#39;t call the code a \u003cem\u003ehorrible\u003c/em\u003e approach to doing this, even if it\u0026#39;s definitely an \u003cem\u003einefficient\u003c/em\u003e approach (and when you\u0026#39;re running a 33 year old computer, efficiency matters), but absent built-in bitwise operations, I can\u0026#39;t see a lot of other options. The biggest problem is that \u003ccode\u003eLAND\u003c/code\u003e will set bits on that are already on, which is unnecessary- an \u003ccode\u003eAND\u003c/code\u003e should really only ever turn bits \u003cem\u003eoff\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhich, as it turns out, is the root WTF. The developer responsible wasn\u0026#39;t ignorant about bitwise operations. The version of Pascal that shipped on the HP3000 simply didn\u0026#39;t have any. No \u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e, or \u003ccode\u003exor\u003c/code\u003e. Not even a shift-left or shift-right operation.\u003c/p\u003e\n\u003cp\u003eIn any case, this is what happens when I start doing research on a story and end up getting sucked down a rabbit hole. As always, while Wikipedia\u0026#39;s true value is \u003ca href=\"https://en.wikipedia.org/w/index.php?title=HP_3000\u0026amp;useskin=vector#Bibliography\"\u003eas a bibliography\u003c/a\u003e. A lot of those links have much more detail, but I hope this quick overview was an interesting story.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tKeep the plebs out of prod. Restrict NuGet feed privileges with ProGet. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=PlebsFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2024-12-26T06:30:00Z",
  "modifiedTime": null
}
