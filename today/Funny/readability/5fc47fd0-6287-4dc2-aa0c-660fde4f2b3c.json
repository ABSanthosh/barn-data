{
  "id": "5fc47fd0-6287-4dc2-aa0c-660fde4f2b3c",
  "title": "CodeSOD: Expressing a Leak",
  "link": "https://thedailywtf.com/articles/expressing-a-leak",
  "description": "We previously discussed some whitespacing choices in a C++ codebase. Tim promised that there were more WTFs lurking in there, and has delivered one. Let's start with this class constructor: QBatch_arithExpr::QBatch_arithExpr(QBatch_unOp, const QBatch_snippet \u0026, const QBatch_snippet \u0026); You'll notice that this takes a parameter of type QBatch_unOp. What is that type? Well, it's an enumerated type describing the kind of operation this arithExpr represents. That is to say, they're not using real inheritance, but instead switching on the QBatch_unOp value to decide which code branch to execute- hand-made, home-grown artisanal inheritance. And while there are legitimate reasons to avoid inheritance, this is a clear case of \"is-a\" relationships, and it would allow compile-time checking of how you combine your types. Tim also points out the use of the \"repugnant west const\", which is maybe a strong way to word it, but definitely using only \"east const\" makes it a lot easier to understand what the const operator does. It's worth noting that in this example, the second parameters is a const reference (not a reference to a const value). Now, they are using inheritance, just not in that specific case: class QBatch_paramExpr : public QBatch_snippet {...}; There's nothing particularly wrong with this, but we're going to use this parameter expression in a moment. QBatch_arithExpr* Foo(QBatch_snippet *expr) { // snip QBatch_arithExpr *derefExpr = new QBatch_arithExpr(enum_tag1, *(new QBatch_paramExpr(paramId))); assert(derefExpr); return new QBatch_arithExpr(enum_tag2, *expr, *derefExpr); } Honestly, in C++ code, seeing a pile of \"*\" operators and raw pointers is a sign that something's gone wrong, and this is no exception. Let's start with calling the QBatch_arithExpr constructor- we pass it *(new QBatch_paramExpr(paramId)), which is a multilayered \"oof\". First, the new operator will heap allocate and construct an object, and return a pointer to that object. We then dereference that pointer, and pass the value as a reference to the constructor. This is an automatic memory leak; because we never trap the pointer, we never have the opportunity to release that memory. Remember kids, in C/C++ you need clear ownership semantics and someone needs to be responsible for deallocating all of the allocated memory- every new needs a delete, in this case. Now, new QBatch_arithExpr(...) will also return a pointer, which we put in derefExpr. We then assert on that pointer, confirming that it isn't null. Which… it can't be. A constructor may fail and throw an exception, but you'll never get a null (now, I'm sure a sufficiently motivated programmer can mix nothrow and -fno-exceptions to get constructors to return null, but that's not happening here, and shouldn't happen anywhere). Then we dereference that pointer and pass it to QBatch_arithExpr- creating another memory leak. Two memory leaks in three lines of code, where one line is an assert, is fairly impressive. Elsewhere in the code, shared_pointer objects are used, wit their names aliased to readable types, aka QBatch_arithExpr::Ptr, and if that pattern were followed here, the memory leaks would go away. As Tim puts it: \"Some folks never quite escaped their Java background,\" and in this case, I think it shows. Objects are allocated with new, but never deleted, as if there's some magical garbage collector which is going to find the unused objects and free them. [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "author": "Remy Porter",
  "published": "Wed, 12 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3624,
  "excerpt": "We previously discussed some whitespacing choices in a C++ codebase. Tim promised that there were more WTFs lurking in there, and has delivered one. Let's start with this class constructor:",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "We previously discussed some whitespacing choices in a C++ codebase. Tim promised that there were more WTFs lurking in there, and has delivered one. Let's start with this class constructor: QBatch_arithExpr::QBatch_arithExpr(QBatch_unOp, const QBatch_snippet \u0026, const QBatch_snippet \u0026); You'll notice that this takes a parameter of type QBatch_unOp. What is that type? Well, it's an enumerated type describing the kind of operation this arithExpr represents. That is to say, they're not using real inheritance, but instead switching on the QBatch_unOp value to decide which code branch to execute- hand-made, home-grown artisanal inheritance. And while there are legitimate reasons to avoid inheritance, this is a clear case of \"is-a\" relationships, and it would allow compile-time checking of how you combine your types. Tim also points out the use of the \"repugnant west const\", which is maybe a strong way to word it, but definitely using only \"east const\" makes it a lot easier to understand what the const operator does. It's worth noting that in this example, the second parameters is a const reference (not a reference to a const value). Now, they are using inheritance, just not in that specific case: class QBatch_paramExpr : public QBatch_snippet {...}; There's nothing particularly wrong with this, but we're going to use this parameter expression in a moment. QBatch_arithExpr* Foo(QBatch_snippet *expr) { // snip QBatch_arithExpr *derefExpr = new QBatch_arithExpr(enum_tag1, *(new QBatch_paramExpr(paramId))); assert(derefExpr); return new QBatch_arithExpr(enum_tag2, *expr, *derefExpr); } Honestly, in C++ code, seeing a pile of \"*\" operators and raw pointers is a sign that something's gone wrong, and this is no exception. Let's start with calling the QBatch_arithExpr constructor- we pass it *(new QBatch_paramExpr(paramId)), which is a multilayered \"oof\". First, the new operator will heap allocate and construct an object, and return a pointer to that object. We then dereference that pointer, and pass the value as a reference to the constructor. This is an automatic memory leak; because we never trap the pointer, we never have the opportunity to release that memory. Remember kids, in C/C++ you need clear ownership semantics and someone needs to be responsible for deallocating all of the allocated memory- every new needs a delete, in this case. Now, new QBatch_arithExpr(...) will also return a pointer, which we put in derefExpr. We then assert on that pointer, confirming that it isn't null. Which… it can't be. A constructor may fail and throw an exception, but you'll never get a null (now, I'm sure a sufficiently motivated programmer can mix nothrow and -fno-exceptions to get constructors to return null, but that's not happening here, and shouldn't happen anywhere). Then we dereference that pointer and pass it to QBatch_arithExpr- creating another memory leak. Two memory leaks in three lines of code, where one line is an assert, is fairly impressive. Elsewhere in the code, shared_pointer objects are used, wit their names aliased to readable types, aka QBatch_arithExpr::Ptr, and if that pattern were followed here, the memory leaks would go away. As Tim puts it: \"Some folks never quite escaped their Java background,\" and in this case, I think it shows. Objects are allocated with new, but never deleted, as if there's some magical garbage collector which is going to find the unused objects and free them. [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eWe previously discussed some \u003ca href=\"https://thedailywtf.com/articles/whitespace-a-frontier\"\u003ewhitespacing choices\u003c/a\u003e in a C++ codebase. \u003cstrong\u003eTim\u003c/strong\u003e promised that there were more WTFs lurking in there, and has delivered one.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s start with this class constructor:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eQBatch_arithExpr::QBatch_arithExpr(QBatch_unOp, const QBatch_snippet \u0026amp;, const QBatch_snippet \u0026amp;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou\u0026#39;ll notice that this takes a parameter of type \u003ccode\u003eQBatch_unOp\u003c/code\u003e. What is that type? Well, it\u0026#39;s an enumerated type describing the kind of operation this \u003ccode\u003earithExpr\u003c/code\u003e represents. That is to say, they\u0026#39;re not using real inheritance, but instead \u003ccode\u003eswitch\u003c/code\u003eing on the \u003ccode\u003eQBatch_unOp\u003c/code\u003e value to decide which code branch to execute- hand-made, home-grown artisanal inheritance. And while there are legitimate reasons to avoid inheritance, this is a clear case of \u0026#34;is-a\u0026#34; relationships, and it would allow compile-time checking of how you combine your types.\u003c/p\u003e\n\u003cp\u003eTim also points out the use of the \u0026#34;repugnant \u003ca href=\"https://hackingcpp.com/cpp/design/east_vs_west_const.html\"\u003ewest const\u003c/a\u003e\u0026#34;, which is maybe a strong way to word it, but definitely using only \u0026#34;east const\u0026#34; makes it a lot easier to understand what the const operator does. It\u0026#39;s worth noting that in this example, the second parameters is a \u003ccode\u003econst\u003c/code\u003e reference (not a reference to a \u003ccode\u003econst\u003c/code\u003e value).\u003c/p\u003e\n\u003cp\u003eNow, they are using inheritance, just not in that specific case:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass QBatch_paramExpr : public QBatch_snippet {...};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere\u0026#39;s nothing particularly wrong with this, but we\u0026#39;re going to use this parameter expression in a moment.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eQBatch_arithExpr* Foo(QBatch_snippet *expr) {\n  // snip\n  QBatch_arithExpr *derefExpr = new QBatch_arithExpr(enum_tag1, *(new QBatch_paramExpr(paramId)));\n  assert(derefExpr);\n  return new QBatch_arithExpr(enum_tag2, *expr, *derefExpr);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHonestly, in C++ code, seeing a pile of \u0026#34;*\u0026#34; operators and raw pointers is a sign that something\u0026#39;s gone wrong, and this is no exception.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s start with calling the \u003ccode\u003eQBatch_arithExpr\u003c/code\u003e constructor- we pass it \u003ccode\u003e*(new QBatch_paramExpr(paramId))\u003c/code\u003e, which is a multilayered \u0026#34;oof\u0026#34;. First, the \u003ccode\u003enew\u003c/code\u003e operator will heap allocate and construct an object, and return a \u003cem\u003epointer\u003c/em\u003e to that object. We then dereference that pointer, and pass the value as a reference to the constructor. This is an automatic memory leak; because we never trap the pointer, we never have the opportunity to release that memory. Remember kids, in C/C++ you need clear ownership semantics and someone needs to be responsible for deallocating all of the allocated memory- every \u003ccode\u003enew\u003c/code\u003e needs a \u003ccode\u003edelete\u003c/code\u003e, in this case.\u003c/p\u003e\n\u003cp\u003eNow, \u003ccode\u003enew QBatch_arithExpr(...)\u003c/code\u003e will also return a pointer, which we put in \u003ccode\u003ederefExpr\u003c/code\u003e. We then \u003ccode\u003eassert\u003c/code\u003e on that pointer, confirming that it isn\u0026#39;t null. Which… it can\u0026#39;t be. A constructor may fail and throw an exception, but you\u0026#39;ll never get a null (now, I\u0026#39;m sure a sufficiently motivated programmer can mix \u003ccode\u003enothrow\u003c/code\u003e and \u003ccode\u003e-fno-exceptions\u003c/code\u003e to get constructors to return null, but that\u0026#39;s not happening here, and shouldn\u0026#39;t happen anywhere).\u003c/p\u003e\n\u003cp\u003eThen we dereference that pointer and pass it to \u003ccode\u003eQBatch_arithExpr\u003c/code\u003e- creating \u003cem\u003eanother memory leak\u003c/em\u003e. Two memory leaks in three lines of code, where one line is an \u003ccode\u003eassert\u003c/code\u003e, is fairly impressive.\u003c/p\u003e\n\u003cp\u003eElsewhere in the code, \u003ccode\u003eshared_pointer\u003c/code\u003e objects are used, wit their names aliased to readable types, aka \u003ccode\u003eQBatch_arithExpr::Ptr\u003c/code\u003e, and if that pattern were followed here, the memory leaks would go away.\u003c/p\u003e\n\u003cp\u003eAs Tim puts it: \u0026#34;Some folks never quite escaped their Java background,\u0026#34; and in this case, I think it shows. Objects are allocated with \u003ccode\u003enew\u003c/code\u003e, but never \u003ccode\u003edelete\u003c/code\u003ed, as if there\u0026#39;s some magical garbage collector which is going to find the unused objects and free them.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eBuildMaster\u003c/a\u003e allows you to create a self-service release management platform that allows different teams to manage their applications. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eExplore how!\u003c/a\u003e \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-12T06:30:00Z",
  "modifiedTime": null
}
