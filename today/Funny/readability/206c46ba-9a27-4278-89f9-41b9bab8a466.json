{
  "id": "206c46ba-9a27-4278-89f9-41b9bab8a466",
  "title": "CodeSOD: Pay for this Later",
  "link": "https://thedailywtf.com/articles/pay-for-this-later",
  "description": "Ross needed to write software to integrate with a credit card payment gateway. The one his company chose was relatively small, and only served a handful of countries- but it covered the markets they cared about and the transaction fees were cheap. They used XML for data interchange, and while they had no published schema document, they did have some handy-dandy sample code which let you parse their XML messages. $response = curl_exec($ch); $authecode = fetch_data($response, '', ''); $responsecode = fetch_data($response, '', ''); $retrunamount = fetch_data($response, '', ''); $trxnnumber = fetch_data($response, '', ''); $trxnstatus = fetch_data($response, '', ''); $trxnresponsemessage = fetch_data($response, '', ''); Well, this looks… worrying. At first glance, I wonder if we're going to have to kneel before Z̸̭͖͔͂̀ā̸̡͖͕͊l̴̜͕͋͌̕g̸͉̳͂͊ȯ̷͙͂̐. What exactly does fetch_data actually do? function fetch_data($string, $start_tag, $end_tag) { $position = stripos($string, $start_tag); $str = substr($string, $position); $str_second = substr($str, strlen($start_tag)); $second_positon = stripos($str_second, $end_tag); $str_third = substr($str_second, 0, $second_positon); $fetch_data = trim($str_third); return $fetch_data; } Phew, no regular expressions, just… lots of substrings. This parses the XML document with no sense of the document's structure- it literally just searches for specific tags, grabs whatever is between them, and calls it done. Nested tags? Attributes? Self-closing tags? Forget about it. Since it doesn't enforce that your open and closing tags match, it also lets you grab arbitrary (and invalid) document fragments- fetch_data($response, \"\", \"\"), for example. And it's not like this needs to be implemented from scratch- PHP has built-in XML parsing classes. We could argue that by limiting ourselves to a subset of XML (which I can only hope this document does) and doing basic string parsing, we've built a much simpler approach, but I suspect that after doing a big pile of linear searches through the document, we're not really going to see any performance benefits from this version- and maintenance is going to be a nightmare, as it's so fragile and won't work for many very valid XML documents. It's always amazing when TRWTF is neither PHP nor XML but… whatever this is. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "author": "Remy Porter",
  "published": "Mon, 11 Nov 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2971,
  "excerpt": "Ross needed to write software to integrate with a credit card payment gateway. The one his company chose was relatively small, and only served a handful of countries- but it covered the markets they cared about and the transaction fees were cheap. They used XML for data interchange, and while they had no published schema document, they did have some handy-dandy sample code which let you parse their XML messages. $response = curl_exec($ch); $authecode = fetch_data($response, '\u003cauthCode\u003e', '\u003c/authCode\u003e'); $responsecode = fetch_data($response, '\u003cresponsecode\u003e', '\u003c/responsecode\u003e'); $retrunamount = fetch_data($response, '\u003creturnamount\u003e', '\u003c/returnamount\u003e'); $trxnnumber = fetch_data($response, '\u003ctrxnnumber\u003e', '\u003c/trxnnumber\u003e'); $trxnstatus = fetch_data($response, '\u003ctrxnstatus\u003e', '\u003c/trxnstatus\u003e'); $trxnresponsemessage = fetch_data($response, '\u003ctrxnresponsemessage\u003e', '\u003c/trxnresponsemessage\u003e');",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2024-11-11 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Ross needed to write software to integrate with a credit card payment gateway. The one his company chose was relatively small, and only served a handful of countries- but it covered the markets they cared about and the transaction fees were cheap. They used XML for data interchange, and while they had no published schema document, they did have some handy-dandy sample code which let you parse their XML messages. $response = curl_exec($ch); $authecode = fetch_data($response, '\u003cauthCode\u003e', '\u003c/authCode\u003e'); $responsecode = fetch_data($response, '\u003cresponsecode\u003e', '\u003c/responsecode\u003e'); $retrunamount = fetch_data($response, '\u003creturnamount\u003e', '\u003c/returnamount\u003e'); $trxnnumber = fetch_data($response, '\u003ctrxnnumber\u003e', '\u003c/trxnnumber\u003e'); $trxnstatus = fetch_data($response, '\u003ctrxnstatus\u003e', '\u003c/trxnstatus\u003e'); $trxnresponsemessage = fetch_data($response, '\u003ctrxnresponsemessage\u003e', '\u003c/trxnresponsemessage\u003e'); Well, this looks… worrying. At first glance, I wonder if we're going to have to kneel before Z̸̭͖͔͂̀ā̸̡͖͕͊l̴̜͕͋͌̕g̸͉̳͂͊ȯ̷͙͂̐. What exactly does fetch_data actually do? function fetch_data($string, $start_tag, $end_tag) { $position = stripos($string, $start_tag); $str = substr($string, $position); $str_second = substr($str, strlen($start_tag)); $second_positon = stripos($str_second, $end_tag); $str_third = substr($str_second, 0, $second_positon); $fetch_data = trim($str_third); return $fetch_data; } Phew, no regular expressions, just… lots of substrings. This parses the XML document with no sense of the document's structure- it literally just searches for specific tags, grabs whatever is between them, and calls it done. Nested tags? Attributes? Self-closing tags? Forget about it. Since it doesn't enforce that your open and closing tags match, it also lets you grab arbitrary (and invalid) document fragments- fetch_data($response, \"\u003cfooTag\u003e\", \"\u003cbarTag\u003e\"), for example. And it's not like this needs to be implemented from scratch- PHP has built-in XML parsing classes. We could argue that by limiting ourselves to a subset of XML (which I can only hope this document does) and doing basic string parsing, we've built a much simpler approach, but I suspect that after doing a big pile of linear searches through the document, we're not really going to see any performance benefits from this version- and maintenance is going to be a nightmare, as it's so fragile and won't work for many very valid XML documents. It's always amazing when TRWTF is neither PHP nor XML but… whatever this is. [Advertisement] Plan Your .NET 9 Migration with ConfidenceYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. Download Free Guide Now!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-11-11\"\u003e2024-11-11\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10778\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eRoss\u003c/strong\u003e needed to write software to integrate with a credit card payment gateway. The one his company chose was relatively small, and only served a handful of countries- but it covered the markets they cared about and the transaction fees were cheap. They used XML for data interchange, and while they had no published schema document, they did have some handy-dandy sample code which let you parse their XML messages.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e$response\u003c/span\u003e = \u003cspan\u003ecurl_exec\u003c/span\u003e(\u003cspan\u003e$ch\u003c/span\u003e);\n\u003cspan\u003e$authecode\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;authCode\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/authCode\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003cspan\u003e$responsecode\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;responsecode\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/responsecode\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003cspan\u003e$retrunamount\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;returnamount\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/returnamount\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003cspan\u003e$trxnnumber\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;trxnnumber\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/trxnnumber\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003cspan\u003e$trxnstatus\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;trxnstatus\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/trxnstatus\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003cspan\u003e$trxnresponsemessage\u003c/span\u003e = \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e$response\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;trxnresponsemessage\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan\u003e\u0026#39;\u0026lt;/trxnresponsemessage\u0026gt;\u0026#39;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWell, this looks… worrying. At first glance, I wonder if we\u0026#39;re going to have to kneel before \u003ca href=\"https://stackoverflow.com/a/1732454\"\u003eZ̸̭͖͔͂̀ā̸̡͖͕͊l̴̜͕͋͌̕g̸͉̳͂͊ȯ̷͙͂̐\u003c/a\u003e. What exactly does \u003ccode\u003efetch_data\u003c/code\u003e actually do?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003efetch_data\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003e$string\u003c/span\u003e, \u003cspan\u003e$start_tag\u003c/span\u003e, \u003cspan\u003e$end_tag\u003c/span\u003e\u003c/span\u003e)\n\u003c/span\u003e{\n\n  \u003cspan\u003e$position\u003c/span\u003e = \u003cspan\u003estripos\u003c/span\u003e(\u003cspan\u003e$string\u003c/span\u003e, \u003cspan\u003e$start_tag\u003c/span\u003e);\n  \u003cspan\u003e$str\u003c/span\u003e = \u003cspan\u003esubstr\u003c/span\u003e(\u003cspan\u003e$string\u003c/span\u003e, \u003cspan\u003e$position\u003c/span\u003e);\n  \u003cspan\u003e$str_second\u003c/span\u003e = \u003cspan\u003esubstr\u003c/span\u003e(\u003cspan\u003e$str\u003c/span\u003e, \u003cspan\u003estrlen\u003c/span\u003e(\u003cspan\u003e$start_tag\u003c/span\u003e));\n  \u003cspan\u003e$second_positon\u003c/span\u003e = \u003cspan\u003estripos\u003c/span\u003e(\u003cspan\u003e$str_second\u003c/span\u003e, \u003cspan\u003e$end_tag\u003c/span\u003e);\n  \u003cspan\u003e$str_third\u003c/span\u003e = \u003cspan\u003esubstr\u003c/span\u003e(\u003cspan\u003e$str_second\u003c/span\u003e, \u003cspan\u003e0\u003c/span\u003e, \u003cspan\u003e$second_positon\u003c/span\u003e);\n  \u003cspan\u003e$fetch_data\u003c/span\u003e = \u003cspan\u003etrim\u003c/span\u003e(\u003cspan\u003e$str_third\u003c/span\u003e);\n  \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e$fetch_data\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePhew, no regular expressions, just… lots of substrings. This parses the XML document with no sense of the document\u0026#39;s structure- it literally just searches for specific tags, grabs whatever is between them, and calls it done. Nested tags? Attributes? Self-closing tags? Forget about it. Since it doesn\u0026#39;t enforce that your open and closing tags match, it also lets you grab arbitrary (and invalid) document fragments- \u003ccode\u003efetch_data($response, \u0026#34;\u0026lt;fooTag\u0026gt;\u0026#34;, \u0026#34;\u0026lt;barTag\u0026gt;\u0026#34;)\u003c/code\u003e, for example.\u003c/p\u003e\n\u003cp\u003eAnd it\u0026#39;s not like this needs to be implemented from scratch- PHP has built-in XML parsing classes. We could argue that by limiting ourselves to a subset of XML (which I can only hope this document does) and doing basic string parsing, we\u0026#39;ve built a much simpler approach, but I suspect that after doing a big pile of linear searches through the document, we\u0026#39;re not really going to see any performance benefits from this version- and \u003cem\u003emaintenance\u003c/em\u003e is going to be a nightmare, as it\u0026#39;s so fragile and won\u0026#39;t work for many very valid XML documents.\u003c/p\u003e\n\u003cp\u003eIt\u0026#39;s always amazing when TRWTF is neither PHP nor XML but… whatever \u003cem\u003ethis\u003c/em\u003e is.\u003c/p\u003e\n\u003cp\u003e\n\t[Advertisement] \u003cb\u003ePlan Your .NET 9 Migration with Confidence\u003c/b\u003e\u003cbr/\u003eYour journey to .NET 9 is more than just one decision.Avoid migration migraines with the advice in this free guide. \u003cb\u003e\u003ca href=\"https://inedo.com/support/whitepapers/dotnet-guide?utm_campaign=dotnet\u0026amp;utm_source=tdwtf-footer\"\u003eDownload Free Guide Now!\u003c/a\u003e\u003c/b\u003e\n\u003c/p\u003e\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2024-11-11T06:30:00Z",
  "modifiedTime": null
}
