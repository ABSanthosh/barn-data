{
  "id": "0e12165a-fddd-4500-a021-f15a85f6fa1e",
  "title": "CodeSOD: Secure Cryptography",
  "link": "https://thedailywtf.com/articles/secure-cryptography",
  "description": "Governments have a difficult relationship with cryptography. Certainly, they benefit from having secure, reliable and fast encryption. Arguably, their citizens also benefit- I would argue that being able to, say, handle online banking transactions securely is a net positive. But it creates a prisoner's dilemma: malicious individuals may conceal their activity behind encryption. From the perspective of a state authority, this is bad. Thus, you get the regular calls for a cryptosystem which allows secure communications but also allows the state to snoop on those messages. Of course, if you intentionally weaken a cryptographic system so that some people can bypass it, you've created a system which anyone can bypass. You can't have secure encryption which also allows snooping, any more than you can have an even prime number larger than two. This leaves us in a situation where mathematicians and cryptography experts are shouting, \"This isn't possible!\" and cops and politicians are shouting \"JUST NERD HARDER!\" back. Well, today's anonymous submitter found a crypto library which promises to allow secure communications and allow nation states to break that encryption. They've nerded harder! Let's take a look at some of their C code. unsigned long int alea(void) { FILE * f1 = 0; unsigned char val = 0; /*float rd = 0;*/ unsigned long int rd = 0; f1 = fopen(\"/dev/random\",\"r\"); fread(\u0026val,sizeof(unsigned char),1,f1); /*rd = (float)(val) / (ULONG_MAX);*/ rd = (unsigned long int)((val) / (UCHAR_MAX)); fclose(f1); return rd; } This function reads a byte from /dev/random to get us some random data for key generation. Unfortunately, it's using the XKCD algorithm: this function always returns 0. Note that they divide val by UCHAR_MAX before casting val to an unsigned long int. Which, there's also the issue here that 8 bits of entropy are always going to be 8 bits of entropy- casting it to an unsigned long int isn't going to be any more random than just passing back the 8-bits, because you only read 8 bits of randomness. There's also no reason why they couldn't have simply read an unsigned long's worth of random data. I appreciate the comment which indicates that rd used to be a floating point number. It doesn't make this code any better, but it's nice to see that they keep trying. Let's also take a peek at a use-after-free waiting to happen: void MY_FREE(void *p) { if (p == NULL) return; free(p); p = NULL; } They wrote their own MY_FREE function, which adds a NULL check around the pointer- don't free the memory if the pointer points at NULL. Nothing wrong with that (though this is better enforced structurally with clear ownership of memory, and not through conditional checks, so actually, yes, there's something wrong with that). After we free the memory pointed to by the pointer, we set the pointer equal to NULL. Except we don't. We set the local variable to NULL. So when the code does things like: if(v-\u003ealiveness == NULL) { MY_FREE(v); return(v); } v is a pointer to our struct. If the aliveness value is NULL, we want to delete that data from memory, so we call MY_FREE, and then we return our pointer to the struct- which is unchanged and definitely not null. It's pointing to what is now freed memory. If anyone touches it, the whole program blows up. Here's the upshot: it's almost a guarantee that this program has undefined behavior in there, someplace. This means the compiler is free to do anything, include implement a dual custody cryptographic algorithm which is magically secure and prevents abuse by state actors. It's as likely as nasal demons. .comment { border: none; } [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "author": "Remy Porter",
  "published": "Tue, 24 Sep 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3839,
  "excerpt": "Governments have a difficult relationship with cryptography. Certainly, they benefit from having secure, reliable and fast encryption. Arguably, their citizens also benefit- I would argue that being able to, say, handle online banking transactions securely is a net positive. But it creates a prisoner's dilemma: malicious individuals may conceal their activity behind encryption. From the perspective of a state authority, this is bad. Thus, you get the regular calls for a cryptosystem which allows secure communications but also allows the state to snoop on those messages. Of course, if you intentionally weaken a cryptographic system so that some people can bypass it, you've created a system which anyone can bypass. You can't have secure encryption which also allows snooping, any more than you can have an even prime number larger than two.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Governments have a difficult relationship with cryptography. Certainly, they benefit from having secure, reliable and fast encryption. Arguably, their citizens also benefit- I would argue that being able to, say, handle online banking transactions securely is a net positive. But it creates a prisoner's dilemma: malicious individuals may conceal their activity behind encryption. From the perspective of a state authority, this is bad. Thus, you get the regular calls for a cryptosystem which allows secure communications but also allows the state to snoop on those messages. Of course, if you intentionally weaken a cryptographic system so that some people can bypass it, you've created a system which anyone can bypass. You can't have secure encryption which also allows snooping, any more than you can have an even prime number larger than two. This leaves us in a situation where mathematicians and cryptography experts are shouting, \"This isn't possible!\" and cops and politicians are shouting \"JUST NERD HARDER!\" back. Well, today's anonymous submitter found a crypto library which promises to allow secure communications and allow nation states to break that encryption. They've nerded harder! Let's take a look at some of their C code. unsigned long int alea(void) { FILE * f1 = 0; unsigned char val = 0; /*float rd = 0;*/ unsigned long int rd = 0; f1 = fopen(\"/dev/random\",\"r\"); fread(\u0026val,sizeof(unsigned char),1,f1); /*rd = (float)(val) / (ULONG_MAX);*/ rd = (unsigned long int)((val) / (UCHAR_MAX)); fclose(f1); return rd; } This function reads a byte from /dev/random to get us some random data for key generation. Unfortunately, it's using the XKCD algorithm: this function always returns 0. Note that they divide val by UCHAR_MAX before casting val to an unsigned long int. Which, there's also the issue here that 8 bits of entropy are always going to be 8 bits of entropy- casting it to an unsigned long int isn't going to be any more random than just passing back the 8-bits, because you only read 8 bits of randomness. There's also no reason why they couldn't have simply read an unsigned long's worth of random data. I appreciate the comment which indicates that rd used to be a floating point number. It doesn't make this code any better, but it's nice to see that they keep trying. Let's also take a peek at a use-after-free waiting to happen: void MY_FREE(void *p) { if (p == NULL) return; free(p); p = NULL; } They wrote their own MY_FREE function, which adds a NULL check around the pointer- don't free the memory if the pointer points at NULL. Nothing wrong with that (though this is better enforced structurally with clear ownership of memory, and not through conditional checks, so actually, yes, there's something wrong with that). After we free the memory pointed to by the pointer, we set the pointer equal to NULL. Except we don't. We set the local variable to NULL. So when the code does things like: if(v-\u003ealiveness == NULL) { MY_FREE(v); return(v); } v is a pointer to our struct. If the aliveness value is NULL, we want to delete that data from memory, so we call MY_FREE, and then we return our pointer to the struct- which is unchanged and definitely not null. It's pointing to what is now freed memory. If anyone touches it, the whole program blows up. Here's the upshot: it's almost a guarantee that this program has undefined behavior in there, someplace. This means the compiler is free to do anything, include implement a dual custody cryptographic algorithm which is magically secure and prevents abuse by state actors. It's as likely as nasal demons. [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eGovernments have a difficult relationship with cryptography. Certainly, \u003cem\u003ethey\u003c/em\u003e benefit from having secure, reliable and fast encryption. Arguably, their citizens also benefit- I would argue that being able to, say, handle online banking transactions securely is a net positive. But it creates a prisoner\u0026#39;s dilemma: malicious individuals may conceal their activity behind encryption. From the perspective of a state authority, this is \u003cem\u003ebad\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThus, you get the regular calls for a cryptosystem which allows secure communications \u003cem\u003ebut also\u003c/em\u003e allows the state to snoop on those messages. Of course, if you intentionally weaken a cryptographic system so that \u003cem\u003esome people\u003c/em\u003e can bypass it, you\u0026#39;ve created a system which \u003cem\u003eanyone\u003c/em\u003e can bypass. You can\u0026#39;t have secure encryption which \u003cem\u003ealso\u003c/em\u003e allows snooping, any more than you can have an even prime number larger than two.\u003c/p\u003e\n\u003cp\u003eThis leaves us in a situation where mathematicians and cryptography experts are shouting, \u0026#34;This isn\u0026#39;t possible!\u0026#34; and cops and politicians are shouting \u0026#34;JUST NERD HARDER!\u0026#34; back.\u003c/p\u003e\n\u003cp\u003eWell, today\u0026#39;s anonymous submitter found a crypto library which promises to allow secure communications \u003cem\u003eand\u003c/em\u003e allow nation states to break that encryption. They\u0026#39;ve nerded harder! Let\u0026#39;s take a look at some of their C code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e \u003cspan\u003ealea\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003evoid\u003c/span\u003e)\u003c/span\u003e\n{\n    FILE * f1 = \u003cspan\u003e0\u003c/span\u003e;\n    \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e val = \u003cspan\u003e0\u003c/span\u003e;\n    \u003cspan\u003e/*float rd = 0;*/\u003c/span\u003e\n    \u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e rd = \u003cspan\u003e0\u003c/span\u003e;\n\n    f1 = fopen(\u003cspan\u003e\u0026#34;/dev/random\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;r\u0026#34;\u003c/span\u003e);\n    fread(\u0026amp;val,\u003cspan\u003esizeof\u003c/span\u003e(\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003echar\u003c/span\u003e),\u003cspan\u003e1\u003c/span\u003e,f1);\n    \u003cspan\u003e/*rd = (float)(val) / (ULONG_MAX);*/\u003c/span\u003e\n    rd = (\u003cspan\u003eunsigned\u003c/span\u003e \u003cspan\u003elong\u003c/span\u003e \u003cspan\u003eint\u003c/span\u003e)((val) / (UCHAR_MAX));\n    fclose(f1);\n\n    \u003cspan\u003ereturn\u003c/span\u003e rd;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function reads a byte from \u003ccode\u003e/dev/random\u003c/code\u003e to get us some random data for key generation. Unfortunately, \u003ca href=\"https://xkcd.com/221/\"\u003eit\u0026#39;s using the XKCD\u003c/a\u003e algorithm: this function always returns 0. Note that they divide \u003ccode\u003eval\u003c/code\u003e by \u003ccode\u003eUCHAR_MAX\u003c/code\u003e \u003cem\u003ebefore\u003c/em\u003e casting \u003ccode\u003eval\u003c/code\u003e to an \u003ccode\u003eunsigned long int\u003c/code\u003e. Which, there\u0026#39;s also the issue here that 8 bits of entropy are always going to be 8 bits of entropy- casting it to an \u003ccode\u003eunsigned long int\u003c/code\u003e isn\u0026#39;t going to be any more random than just passing back the 8-bits, because \u003cem\u003eyou only read 8 bits of randomness\u003c/em\u003e. There\u0026#39;s also no reason why they couldn\u0026#39;t have simply \u003cem\u003eread an unsigned long\u0026#39;s worth of random data\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eI appreciate the comment which indicates that \u003ccode\u003erd\u003c/code\u003e used to be a floating point number. It doesn\u0026#39;t make this code any better, but it\u0026#39;s nice to see that they keep trying.\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s also take a peek at a use-after-free waiting to happen:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evoid\u003c/span\u003e \u003cspan\u003eMY_FREE\u003c/span\u003e\u003cspan\u003e(\u003cspan\u003evoid\u003c/span\u003e *p)\u003c/span\u003e\n{\n   \u003cspan\u003eif\u003c/span\u003e (p == \u003cspan\u003eNULL\u003c/span\u003e)\n      \u003cspan\u003ereturn\u003c/span\u003e;\n\n   \u003cspan\u003efree\u003c/span\u003e(p);\n   p = \u003cspan\u003eNULL\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThey wrote their own \u003ccode\u003eMY_FREE\u003c/code\u003e function, which adds a \u003ccode\u003eNULL\u003c/code\u003e check around the pointer- don\u0026#39;t free the memory if the pointer points at \u003ccode\u003eNULL\u003c/code\u003e. Nothing wrong with that (though this is better enforced structurally with clear ownership of memory, and not through conditional checks, so actually, yes, there\u0026#39;s something wrong with that). After we \u003ccode\u003efree\u003c/code\u003e the memory pointed to by the pointer, we set the pointer equal to \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExcept we don\u0026#39;t. We set the local variable to \u003ccode\u003eNULL\u003c/code\u003e. So when the code does things like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  \u003cspan\u003eif\u003c/span\u003e(v-\u0026gt;aliveness == \u003cspan\u003eNULL\u003c/span\u003e)\n   {\n    MY_FREE(v);\n    \u003cspan\u003ereturn\u003c/span\u003e(v);\n   }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ev\u003c/code\u003e is a pointer to our struct. If the \u003ccode\u003ealiveness\u003c/code\u003e value is \u003ccode\u003eNULL\u003c/code\u003e, we want to delete that data from memory, so we call \u003ccode\u003eMY_FREE\u003c/code\u003e, and then we return our pointer to the struct- which is \u003cem\u003eunchanged\u003c/em\u003e and definitely not null. It\u0026#39;s pointing to what is now \u003cem\u003efreed\u003c/em\u003e memory. If anyone touches it, the whole program blows up.\u003c/p\u003e\n\u003cp\u003eHere\u0026#39;s the upshot: it\u0026#39;s almost a guarantee that this program has undefined behavior in there, someplace. This means the compiler is free to do anything, include \u003cem\u003eimplement a dual custody cryptographic algorithm which is magically secure and prevents abuse by state actors\u003c/em\u003e. It\u0026#39;s as likely as \u003ca href=\"https://en.wikichip.org/wiki/nasal_demons\"\u003enasal demons\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eBuildMaster\u003c/a\u003e allows you to create a self-service release management platform that allows different teams to manage their applications. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eExplore how!\u003c/a\u003e \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2024-09-24T06:30:00Z",
  "modifiedTime": null
}
