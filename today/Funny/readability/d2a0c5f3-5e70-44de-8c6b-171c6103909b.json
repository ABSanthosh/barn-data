{
  "id": "d2a0c5f3-5e70-44de-8c6b-171c6103909b",
  "title": "Over Extended Methods",
  "link": "https://thedailywtf.com/articles/over-extended-methods",
  "description": "Jenny had been perfectly happy working on a series of projects for her company, before someone said, \"Hey, we need you to build a desktop GUI for an existing API.\" The request wasn't the problem, per se. The API, on the other hand, absolutely was. The application Jenny was working on represented a billing contract for materials consumed at a factory. Essentially, the factory built a bunch of individual parts, and then assembled them into a finished product. They only counted the finished product, but needed to itemize the billing down to not only the raw materials that went into the finished product, the intermediate parts, but also the toilet paper put in the bathrooms. All the costs of operating the factory were derived from the units shipped out. This meant that the contract itself was a fairly complicated tree structure. Jenny's application was meant to both visualize and allow users to edit that tree structure to update the billing contract in sane, and predictable ways, so that it could be reviewed and approved and when the costs of toilet paper went up, those costs could be accurately passed on to the customer. Now, all the contract management was already implemented and lived library that itself called back into a database. Jenny just needed to wire it up to a desktop UI. Part of the requirements were that line items in the tree needed to have a special icon displayed next to them under two conditions: if one of their ancestors in the tree had been changed since the last released contract, or if they child was marked as \"inherit from parent\". The wrapper library wasn't documented, so Jenny asked the obvious question: \"What's the interface for this?\" The library team replied with this: IModelInheritFromParent : INotifyPropertyChanged { bool InheritFromParent {get; set;} } \"That covers the inheritance field,\" Jenny said, \"but that doesn't tell me if the ancestor has been modified.\" \"Oh, don't worry,\" the devs replied, \"there's an extension method for that.\" public bool GetChangedIndicator(this IModelTypeA); Extension methods in C# are just a way to use syntactic sugar to \"add\" methods to a class: IModelTypeA does not have a GetChangedIndicator method, but because of the this keyword, it's an extension method and we can now invoke aInstance.GetChangedIndicator(). It's how many built-in .Net APIs work, but like most forms of syntactic sugar, while it can be good, it usually makes code harder to understand, harder to test, and harder to debug. But Jenny's main complaint was this: \"You can't raise an event or something? I'm going to need to poll?\" \"Yes, you're going to need to poll.\" Jenny didn't like the idea of polling the (slow) database, so at first, she tried to run the polling in a background thread so it wouldn't block the UI. Unfortunately for her, the library was very much not threadsafe, so that blew up. She ended up needing to poll on the main UI thread, which meant the application would frequently stall while users were working. She did her best to minimize it, but it was impossible to eliminate. But worse than that, each contract item may implement one of four interfaces, which meant there were four versions of the extension method: public bool GetChangedIndicator(this IModelTypeA); public bool GetChangedIndicator(this IModelTypeB); public bool GetChangedIndicator(this IModelTypeC); public bool GetChangedIndicator(this IModelTypeD); To \"properly\" perform the check, Jenny would have to check which casts were valid for a given item, cast it, and then invoke GetChangedIndicator. It's worth noting that had they just used regular inheritance instead of extension methods, this wouldn't have been necessary at all. Using the \"fun\" syntactic sugar made the code more complicated for no benefit. This left Jenny with another question: \"What if an item implements more than one of these interfaces? What if the extension methods disagree on if the item is changed?\" \"Good question,\" the team responsible for the library replied. \"That should almost never happen.\" Jenny quit not long after this. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "author": "Remy Porter",
  "published": "Thu, 20 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Feature Articles"
  ],
  "byline": "Remy Porter",
  "length": 4189,
  "excerpt": "Jenny had been perfectly happy working on a series of projects for her company, before someone said, \"Hey, we need you to build a desktop GUI for an existing API.\" The request wasn't the problem, per se. The API, on the other hand, absolutely was.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Jenny had been perfectly happy working on a series of projects for her company, before someone said, \"Hey, we need you to build a desktop GUI for an existing API.\" The request wasn't the problem, per se. The API, on the other hand, absolutely was. The application Jenny was working on represented a billing contract for materials consumed at a factory. Essentially, the factory built a bunch of individual parts, and then assembled them into a finished product. They only counted the finished product, but needed to itemize the billing down to not only the raw materials that went into the finished product, the intermediate parts, but also the toilet paper put in the bathrooms. All the costs of operating the factory were derived from the units shipped out. This meant that the contract itself was a fairly complicated tree structure. Jenny's application was meant to both visualize and allow users to edit that tree structure to update the billing contract in sane, and predictable ways, so that it could be reviewed and approved and when the costs of toilet paper went up, those costs could be accurately passed on to the customer. Now, all the contract management was already implemented and lived library that itself called back into a database. Jenny just needed to wire it up to a desktop UI. Part of the requirements were that line items in the tree needed to have a special icon displayed next to them under two conditions: if one of their ancestors in the tree had been changed since the last released contract, or if they child was marked as \"inherit from parent\". The wrapper library wasn't documented, so Jenny asked the obvious question: \"What's the interface for this?\" The library team replied with this: IModelInheritFromParent : INotifyPropertyChanged { bool InheritFromParent {get; set;} } \"That covers the inheritance field,\" Jenny said, \"but that doesn't tell me if the ancestor has been modified.\" \"Oh, don't worry,\" the devs replied, \"there's an extension method for that.\" public bool GetChangedIndicator(this IModelTypeA); Extension methods in C# are just a way to use syntactic sugar to \"add\" methods to a class: IModelTypeA does not have a GetChangedIndicator method, but because of the this keyword, it's an extension method and we can now invoke aInstance.GetChangedIndicator(). It's how many built-in .Net APIs work, but like most forms of syntactic sugar, while it can be good, it usually makes code harder to understand, harder to test, and harder to debug. But Jenny's main complaint was this: \"You can't raise an event or something? I'm going to need to poll?\" \"Yes, you're going to need to poll.\" Jenny didn't like the idea of polling the (slow) database, so at first, she tried to run the polling in a background thread so it wouldn't block the UI. Unfortunately for her, the library was very much not threadsafe, so that blew up. She ended up needing to poll on the main UI thread, which meant the application would frequently stall while users were working. She did her best to minimize it, but it was impossible to eliminate. But worse than that, each contract item may implement one of four interfaces, which meant there were four versions of the extension method: public bool GetChangedIndicator(this IModelTypeA); public bool GetChangedIndicator(this IModelTypeB); public bool GetChangedIndicator(this IModelTypeC); public bool GetChangedIndicator(this IModelTypeD); To \"properly\" perform the check, Jenny would have to check which casts were valid for a given item, cast it, and then invoke GetChangedIndicator. It's worth noting that had they just used regular inheritance instead of extension methods, this wouldn't have been necessary at all. Using the \"fun\" syntactic sugar made the code more complicated for no benefit. This left Jenny with another question: \"What if an item implements more than one of these interfaces? What if the extension methods disagree on if the item is changed?\" \"Good question,\" the team responsible for the library replied. \"That should almost never happen.\" Jenny quit not long after this. [Advertisement] ProGet’s got you covered with security and access controls on your NuGet feeds. Learn more.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eJenny\u003c/strong\u003e had been perfectly happy working on a series of projects for her company, before someone said, \u0026#34;Hey, we need you to build a desktop GUI for an existing API.\u0026#34;\u003c/p\u003e\n\u003cp\u003eThe request wasn\u0026#39;t the problem, per se. The API, on the other hand, absolutely was.\u003c/p\u003e\n\u003cp\u003eThe application Jenny was working on represented a billing contract for materials consumed at a factory. Essentially, the factory built a bunch of individual parts, and then assembled them into a finished product. They only \u003cem\u003ecounted\u003c/em\u003e the finished product, but needed to itemize the billing down to not only the raw materials that went into the finished product, the intermediate parts, but also the toilet paper put in the bathrooms. All the costs of operating the factory were derived from the units shipped out.\u003c/p\u003e\n\u003cp\u003eThis meant that the contract itself was a fairly complicated tree structure. Jenny\u0026#39;s application was meant to both visualize and allow users to edit that tree structure to update the billing contract in sane, and predictable ways, so that it could be reviewed and approved and when the costs of toilet paper went up, those costs could be accurately passed on to the customer.\u003c/p\u003e\n\u003cp\u003eNow, all the contract management was already implemented and lived library that itself called back into a database. Jenny just needed to wire it up to a desktop UI. Part of the requirements were that line items in the tree needed to have a special icon displayed next to them under two conditions: if one of their ancestors in the tree had been changed since the last released contract, or if they child was marked as \u0026#34;inherit from parent\u0026#34;.\u003c/p\u003e\n\u003cp\u003eThe wrapper library wasn\u0026#39;t documented, so Jenny asked the obvious question: \u0026#34;What\u0026#39;s the interface for this?\u0026#34;\u003c/p\u003e\n\u003cp\u003eThe library team replied with this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eIModelInheritFromParent : INotifyPropertyChanged\n{\n        \u003cspan\u003ebool\u003c/span\u003e InheritFromParent {\u003cspan\u003eget\u003c/span\u003e; \u003cspan\u003eset\u003c/span\u003e;}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u0026#34;That covers the inheritance field,\u0026#34; Jenny said, \u0026#34;but that doesn\u0026#39;t tell me if the ancestor has been modified.\u0026#34;\u003c/p\u003e\n\u003cp\u003e\u0026#34;Oh, don\u0026#39;t worry,\u0026#34; the devs replied, \u0026#34;there\u0026#39;s an extension method for that.\u0026#34;\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eGetChangedIndicator\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003ethis\u003c/span\u003e IModelTypeA\u003c/span\u003e)\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eExtension methods in C# are just a way to use syntactic sugar to \u0026#34;add\u0026#34; methods to a class: \u003ccode\u003eIModelTypeA\u003c/code\u003e does not have a \u003ccode\u003eGetChangedIndicator\u003c/code\u003e method, but because of the \u003ccode\u003ethis\u003c/code\u003e keyword, it\u0026#39;s an extension method and we can now invoke \u003ccode\u003eaInstance.GetChangedIndicator()\u003c/code\u003e. It\u0026#39;s how many built-in .Net APIs work, but like most forms of syntactic sugar, while it \u003cem\u003ecan\u003c/em\u003e be good, it usually makes code harder to understand, harder to test, and harder to debug.\u003c/p\u003e\n\u003cp\u003eBut Jenny\u0026#39;s main complaint was this: \u0026#34;You can\u0026#39;t raise an event or something? I\u0026#39;m going to need to poll?\u0026#34;\u003c/p\u003e\n\u003cp\u003e\u0026#34;Yes, you\u0026#39;re going to need to poll.\u0026#34;\u003c/p\u003e\n\u003cp\u003eJenny didn\u0026#39;t like the idea of polling the (slow) database, so at first, she tried to run the polling in a background thread so it wouldn\u0026#39;t block the UI. Unfortunately for her, the library was very much not threadsafe, so that blew up. She ended up needing to poll on the main UI thread, which meant the application would frequently stall while users were working. She did her best to minimize it, but it was impossible to eliminate.\u003c/p\u003e\n\u003cp\u003eBut worse than that, each contract item may implement one of four interfaces, which meant there were four versions of the extension method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eGetChangedIndicator\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003ethis\u003c/span\u003e IModelTypeA\u003c/span\u003e)\u003c/span\u003e;\n\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eGetChangedIndicator\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003ethis\u003c/span\u003e IModelTypeB\u003c/span\u003e)\u003c/span\u003e;\n\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eGetChangedIndicator\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003ethis\u003c/span\u003e IModelTypeC\u003c/span\u003e)\u003c/span\u003e;\n\u003cspan\u003e\u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003ebool\u003c/span\u003e \u003cspan\u003eGetChangedIndicator\u003c/span\u003e(\u003cspan\u003e\u003cspan\u003ethis\u003c/span\u003e IModelTypeD\u003c/span\u003e)\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo \u0026#34;properly\u0026#34; perform the check, Jenny would have to check which casts were valid for a given item, cast it, and then invoke \u003ccode\u003eGetChangedIndicator\u003c/code\u003e. It\u0026#39;s worth noting that had they just used regular inheritance instead of extension methods, this wouldn\u0026#39;t have been necessary at all. Using the \u0026#34;fun\u0026#34; syntactic sugar made the code more complicated for no benefit.\u003c/p\u003e\n\u003cp\u003eThis left Jenny with another question: \u0026#34;What if an item implements more than one of these interfaces? What if the extension methods disagree on if the item is changed?\u0026#34;\u003c/p\u003e\n\u003cp\u003e\u0026#34;Good question,\u0026#34; the team responsible for the library replied. \u0026#34;That should almost never happen.\u0026#34;\u003c/p\u003e\n\u003cp\u003eJenny quit not long after this.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/proget-icon.png\"/\u003e [Advertisement] \n\tProGet’s got you covered with security and access controls on your NuGet feeds. \u003ca href=\"https://inedo.com/proget/private-nuget-server?utm_source=tdwtf\u0026amp;utm_medium=footer\u0026amp;utm_content=GotYouCoveredFooter\u0026amp;utm_campaign=Cyclops2020\"\u003eLearn more.\u003c/a\u003e\n\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-20T06:30:00Z",
  "modifiedTime": null
}
