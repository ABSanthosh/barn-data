{
  "id": "40e8e3c0-55ea-4429-8f24-163dce256d98",
  "title": "CodeSOD: Nobody's BFF",
  "link": "https://thedailywtf.com/articles/nobody-s-bff",
  "description": "Legacy systems are hard to change, and even harder to eliminate. You can't simply do nothing though; as technology and user expectations change, you need to find ways to modernize and adapt the legacy system. That's what happened to Alicia's team. They had a gigantic, spaghetti-coded, monolithic application that was well past drinking age and had a front-end to match. Someone decided that they couldn't touch the complex business logic, but what they could do was replace the frontend code by creating an adapter service; the front end would call into this adapter, and the adapter would execute the appropriate methods in the backend. Some clever coder named this \"Backend for Frontend\" or \"BFF\". It was not anyone's BFF. For starters, this system didn't actually allow you to just connect a UI to the backend. No, that'd be too easy. This system was actually a UI generator. The way this works is that you feed it a schema file, written in JSON. This file specifies what input elements you want, some hints for layout, what validation you want the UI to perform, and even what CSS classes you want. Then you compile this as part of a gigantic .NET application, and deploy it, and then you can see your new UI. No one likes using it. No one is happy that it exists. Everyone wishes that they could just write frontends like normal people, and not use this awkward schema language. All that is to say, when Alicia's co-worker stood up shortly before lunch, said, \"I'm taking off the rest of the day, BFF has broken me,\" it wasn't particularly shocking to hear- or even the first time that'd happened. Alicia, not heeding the warning inherent in that statement, immediately tracked down that dev's last work, and tried to understand what had been so painful. \"minValue\": 1900, \"maxValue\": 99, This, of course, had to be a bug. Didn't it? How could the maxValue be lower than the minValue? Let's look at the surrounding context. { \"type\": \"eventValueBetweenValuesValidator\", \"eventType\": \"CalendarYear\", \"minValue\": 1900, \"maxValue\": 99, \"isCalendarBasedMaxValue\": true, \"message\": \"CalendarYear must be between {% raw %}{{minValue}}{% endraw %} and {% raw %}{{maxValue}}{% endraw %}.\" } I think this should make it perfectly clear what's happening. Oh, it doesn't? Look at the isCalendarBasedMaxValue field. It's true. There, that should explain everything. No, it doesn't? You're just more confused? The isCalendarBasedMaxValue says that the maxValue field should not be treated as a literal value, but instead, is the number of years in the future relative to the current year which are considered valid. This schema definition says \"accept all years between 1900 and 2124 (at the time of this writing).\" Next year, that top value goes up to 2125. Then 2126. And so on. As features go, it's not a terrible feature. But the implementation of the feature is incredibly counter-intuitive. At the end of the day, this is just bad naming: (ab)using min/max to do something that isn't really a min/max validation is the big issue here. Alicia writes: I couldn't come up with something more counterintuitive if I tried. Oh, don't sell yourself short, Alicia. I'm sure you could write something far, far worse if you tried. The key thing here is that clearly, nobody tried- they just sorta let things happen and definitely didn't think too hard about it. [Advertisement] Picking up NuGet is easy. Getting good at it takes time. Download our guide to learn the best practice of NuGet for the Enterprise.",
  "author": "Remy Porter",
  "published": "Mon, 31 Mar 2025 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 3386,
  "excerpt": "Legacy systems are hard to change, and even harder to eliminate. You can't simply do nothing though; as technology and user expectations change, you need to find ways to modernize and adapt the legacy system. That's what happened to Alicia's team. They had a gigantic, spaghetti-coded, monolithic application that was well past drinking age and had a front-end to match. Someone decided that they couldn't touch the complex business logic, but what they could do was replace the frontend code by creating an adapter service; the front end would call into this adapter, and the adapter would execute the appropriate methods in the backend.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "Legacy systems are hard to change, and even harder to eliminate. You can't simply do nothing though; as technology and user expectations change, you need to find ways to modernize and adapt the legacy system. That's what happened to Alicia's team. They had a gigantic, spaghetti-coded, monolithic application that was well past drinking age and had a front-end to match. Someone decided that they couldn't touch the complex business logic, but what they could do was replace the frontend code by creating an adapter service; the front end would call into this adapter, and the adapter would execute the appropriate methods in the backend. Some clever coder named this \"Backend for Frontend\" or \"BFF\". It was not anyone's BFF. For starters, this system didn't actually allow you to just connect a UI to the backend. No, that'd be too easy. This system was actually a UI generator. The way this works is that you feed it a schema file, written in JSON. This file specifies what input elements you want, some hints for layout, what validation you want the UI to perform, and even what CSS classes you want. Then you compile this as part of a gigantic .NET application, and deploy it, and then you can see your new UI. No one likes using it. No one is happy that it exists. Everyone wishes that they could just write frontends like normal people, and not use this awkward schema language. All that is to say, when Alicia's co-worker stood up shortly before lunch, said, \"I'm taking off the rest of the day, BFF has broken me,\" it wasn't particularly shocking to hear- or even the first time that'd happened. Alicia, not heeding the warning inherent in that statement, immediately tracked down that dev's last work, and tried to understand what had been so painful. \"minValue\": 1900, \"maxValue\": 99, This, of course, had to be a bug. Didn't it? How could the maxValue be lower than the minValue? Let's look at the surrounding context. { \"type\": \"eventValueBetweenValuesValidator\", \"eventType\": \"CalendarYear\", \"minValue\": 1900, \"maxValue\": 99, \"isCalendarBasedMaxValue\": true, \"message\": \"CalendarYear must be between {% raw %}{{minValue}}{% endraw %} and {% raw %}{{maxValue}}{% endraw %}.\" } I think this should make it perfectly clear what's happening. Oh, it doesn't? Look at the isCalendarBasedMaxValue field. It's true. There, that should explain everything. No, it doesn't? You're just more confused? The isCalendarBasedMaxValue says that the maxValue field should not be treated as a literal value, but instead, is the number of years in the future relative to the current year which are considered valid. This schema definition says \"accept all years between 1900 and 2124 (at the time of this writing).\" Next year, that top value goes up to 2125. Then 2126. And so on. As features go, it's not a terrible feature. But the implementation of the feature is incredibly counter-intuitive. At the end of the day, this is just bad naming: (ab)using min/max to do something that isn't really a min/max validation is the big issue here. Alicia writes: I couldn't come up with something more counterintuitive if I tried. Oh, don't sell yourself short, Alicia. I'm sure you could write something far, far worse if you tried. The key thing here is that clearly, nobody tried- they just sorta let things happen and definitely didn't think too hard about it.",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003eLegacy systems are hard to change, and even harder to eliminate. You can\u0026#39;t simply do \u003cem\u003enothing\u003c/em\u003e though; as technology and user expectations change, you need to find ways to modernize and adapt the legacy system.\u003c/p\u003e\n\u003cp\u003eThat\u0026#39;s what happened to \u003cstrong\u003eAlicia\u003c/strong\u003e\u0026#39;s team. They had a gigantic, spaghetti-coded, monolithic application that was well past drinking age and had a front-end to match. Someone decided that they couldn\u0026#39;t touch the complex business logic, but what they could do was replace the frontend code by creating an adapter service; the front end would call into this adapter, and the adapter would execute the appropriate methods in the backend.\u003c/p\u003e\n\u003cp\u003eSome clever coder named this \u0026#34;Backend for Frontend\u0026#34; or \u0026#34;BFF\u0026#34;.\u003c/p\u003e\n\u003cp\u003eIt was \u003cem\u003enot\u003c/em\u003e anyone\u0026#39;s BFF. For starters, this system didn\u0026#39;t actually allow you to just connect a UI to the backend. No, that\u0026#39;d be too easy. This system was actually a UI \u003cem\u003egenerator\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe way this works is that you feed it a schema file, written in JSON. This file specifies what input elements you want, some hints for layout, what validation you want the UI to perform, and even what CSS classes you want. Then you compile this as part of a gigantic .NET application, and deploy it, and then you can see your new UI.\u003c/p\u003e\n\u003cp\u003eNo one likes using it. No one is happy that it exists. Everyone wishes that they could just write frontends like normal people, and not use this awkward schema language.\u003c/p\u003e\n\u003cp\u003eAll that is to say, when Alicia\u0026#39;s co-worker stood up shortly before lunch, said, \u0026#34;I\u0026#39;m taking off the rest of the day, BFF has broken me,\u0026#34; it wasn\u0026#39;t particularly shocking to hear- or even the first time that\u0026#39;d happened.\u003c/p\u003e\n\u003cp\u003eAlicia, not heeding the warning inherent in that statement, immediately tracked down that dev\u0026#39;s last work, and tried to understand what had been so painful.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    \u003cspan\u003e\u0026#34;minValue\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1900\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;maxValue\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e99\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis, of course, had to be a bug. Didn\u0026#39;t it? How could the \u003ccode\u003emaxValue\u003c/code\u003e be lower than the \u003ccode\u003eminValue\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eLet\u0026#39;s look at the surrounding context.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;type\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;eventValueBetweenValuesValidator\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;eventType\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;CalendarYear\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;minValue\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1900\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;maxValue\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e99\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;isCalendarBasedMaxValue\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n    \u003cspan\u003e\u0026#34;message\u0026#34;\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;CalendarYear must be between {% raw %}{{minValue}}{% endraw %} and {% raw %}{{maxValue}}{% endraw %}.\u0026#34;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI think this should make it perfectly clear what\u0026#39;s happening. Oh, it doesn\u0026#39;t? Look at the \u003ccode\u003eisCalendarBasedMaxValue\u003c/code\u003e field. It\u0026#39;s true. There, that should explain everything. No, it doesn\u0026#39;t? You\u0026#39;re just more confused?\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eisCalendarBasedMaxValue\u003c/code\u003e says that the \u003ccode\u003emaxValue\u003c/code\u003e field should not be treated as a literal value, but instead, is the number of years in the future relative to the \u003cem\u003ecurrent year\u003c/em\u003e which are considered valid. This schema definition says \u0026#34;accept all years between 1900 and 2124 (at the time of this writing).\u0026#34; Next year, that top value goes up to 2125. Then 2126. And so on.\u003c/p\u003e\n\u003cp\u003eAs features go, it\u0026#39;s not a terrible feature. But the implementation of the feature is incredibly counter-intuitive. At the end of the day, this is just bad naming: (ab)using min/max to do something that isn\u0026#39;t really a min/max validation is the big issue here.\u003c/p\u003e\n\u003cp\u003eAlicia writes:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI couldn\u0026#39;t come up with something more counterintuitive if I tried.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOh, don\u0026#39;t sell yourself short, Alicia. I\u0026#39;m sure you could write something far, far worse if you tried. The key thing here is that clearly, nobody \u003cem\u003etried\u003c/em\u003e- they just sorta let things happen and definitely didn\u0026#39;t think too hard about it.\u003c/p\u003e\n\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "4 min read",
  "publishedTime": "2025-03-31T06:30:00Z",
  "modifiedTime": null
}
