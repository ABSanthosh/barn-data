{
  "id": "9c9d8d54-3e51-48cd-99e6-927b1b4518be",
  "title": "CodeSOD: Magical Bytes",
  "link": "https://thedailywtf.com/articles/magical-bytes",
  "description": "\"Magic bytes\" are a common part of a file header. The first few bytes of a file can often be used to identify what type of file it is. For example, a bitmap file starts with \"BM\", and a PGM file always starts with \"PN\" where \"N\" is a number between 1 and 6, describing the specific variant in use, and WAV files start with \"RIFF\". Many files have less human-readable magic bytes, like the ones Christer was working with. His team was working on software to manipulate a variety of different CAD file types. One thing this code needed to do is identify when the loaded file was a CAD file, but not the specific UFF file type they were looking for. In this case, they need to check that the file does not start with 0xabb0, 0xabb1, or 0xabb3. It was trivially easy to write up a validation check to ensure that the files had the correct magic bytes. And yet, there is no task so easy that someone can't fall flat on their face while doing it. This is how Christer's co-worker solved this problem: const uint16_t *id = (uint16_t*)data.GetBuffer(); if (*id == 0xabb0 || *id == 0xABB0 || *id == 0xabb1 || *id == 0xABB1 || *id == 0xabb3 || *id == 0xABB3) { return 0; } Here we have a case of someone who isn't clear on the difference between hexadecimal numbers and strings. Now, you (and the compiler) might think that 0xABB0 and 0xabb0 are, quite clearly, the same thing. But you don't understand the power of lowercase numbers. Here we have an entirely new numbering system where 0xABB0 and 0xabb0 are not equal, which also means 0xABB0 - 0xabb0 is non-zero. An entirely new field of mathematics lies before us, with new questions to be asked. If 0xABB0 \u003c 0xABB1, is 0xABB0 \u003c 0xabb1 also true? From this little code sample, we can't make any inferences, but these questions give us a rich field of useless mathematics to write papers about. The biggest question of all, is that we know how to write lowercase numbers for A-F, but how do we write a lowercase 3? [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "author": "Remy Porter",
  "published": "Mon, 25 Nov 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "CodeSOD"
  ],
  "byline": "Remy Porter",
  "length": 2386,
  "excerpt": "\"Magic bytes\" are a common part of a file header. The first few bytes of a file can often be used to identify what type of file it is. For example, a bitmap file starts with \"BM\", and a PGM file always starts with \"PN\" where \"N\" is a number between 1 and 6, describing the specific variant in use, and WAV files start with \"RIFF\". Many files have less human-readable magic bytes, like the ones Christer was working with. His team was working on software to manipulate a variety of different CAD file types. One thing this code needed to do is identify when the loaded file was a CAD file, but not the specific UFF file type they were looking for. In this case, they need to check that the file does not start with 0xabb0, 0xabb1, or 0xabb3. It was trivially easy to write up a validation check to ensure that the files had the correct magic bytes. And yet, there is no task so easy that someone can't fall flat on their face while doing it.",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in CodeSOD on 2024-11-25 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. \"Magic bytes\" are a common part of a file header. The first few bytes of a file can often be used to identify what type of file it is. For example, a bitmap file starts with \"BM\", and a PGM file always starts with \"PN\" where \"N\" is a number between 1 and 6, describing the specific variant in use, and WAV files start with \"RIFF\". Many files have less human-readable magic bytes, like the ones Christer was working with. His team was working on software to manipulate a variety of different CAD file types. One thing this code needed to do is identify when the loaded file was a CAD file, but not the specific UFF file type they were looking for. In this case, they need to check that the file does not start with 0xabb0, 0xabb1, or 0xabb3. It was trivially easy to write up a validation check to ensure that the files had the correct magic bytes. And yet, there is no task so easy that someone can't fall flat on their face while doing it. This is how Christer's co-worker solved this problem: const uint16_t *id = (uint16_t*)data.GetBuffer(); if (*id == 0xabb0 || *id == 0xABB0 || *id == 0xabb1 || *id == 0xABB1 || *id == 0xabb3 || *id == 0xABB3) { return 0; } Here we have a case of someone who isn't clear on the difference between hexadecimal numbers and strings. Now, you (and the compiler) might think that 0xABB0 and 0xabb0 are, quite clearly, the same thing. But you don't understand the power of lowercase numbers. Here we have an entirely new numbering system where 0xABB0 and 0xabb0 are not equal, which also means 0xABB0 - 0xabb0 is non-zero. An entirely new field of mathematics lies before us, with new questions to be asked. If 0xABB0 \u003c 0xABB1, is 0xABB0 \u003c 0xabb1 also true? From this little code sample, we can't make any inferences, but these questions give us a rich field of useless mathematics to write papers about. The biggest question of all, is that we know how to write lowercase numbers for A-F, but how do we write a lowercase 3? [Advertisement] BuildMaster allows you to create a self-service release management platform that allows different teams to manage their applications. Explore how!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/code-sod\"\u003eCodeSOD\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-11-25\"\u003e2024-11-25\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10788\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u0026#34;Magic bytes\u0026#34; are a common part of a file header. The first few bytes of a file can often be used to identify what type of file it is. For example, a bitmap file starts with \u0026#34;BM\u0026#34;, and a PGM file always starts with \u0026#34;PN\u0026#34; where \u0026#34;N\u0026#34; is a number between 1 and 6, describing the specific variant in use, and WAV files start with \u0026#34;RIFF\u0026#34;. \u003c/p\u003e\n\u003cp\u003eMany files have less human-readable magic bytes, like the ones \u003cstrong\u003eChrister\u003c/strong\u003e was working with. His team was working on software to manipulate a variety of different CAD file types. One thing this code needed to do is identify when the loaded file was a CAD file, but not the specific UFF file type they were looking for. In this case, they need to check that the file \u003cem\u003edoes not\u003c/em\u003e start with \u003ccode\u003e0xabb0\u003c/code\u003e, \u003ccode\u003e0xabb1\u003c/code\u003e, or \u003ccode\u003e0xabb3\u003c/code\u003e. It was trivially easy to write up a validation check to ensure that the files had the correct magic bytes. And yet, there is no task so easy that someone can\u0026#39;t fall flat on their face while doing it.\u003c/p\u003e\n\u003cp\u003eThis is how Christer\u0026#39;s co-worker solved this problem:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst uint16_t *id = (uint16_t*)data.GetBuffer();\nif (*id == 0xabb0 || *id == 0xABB0 || *id == 0xabb1 || *id == 0xABB1 || *id == 0xabb3 || *id == 0xABB3)\n{\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we have a case of someone who isn\u0026#39;t clear on the difference between hexadecimal numbers and strings. Now, you (and the compiler) might think that \u003ccode\u003e0xABB0\u003c/code\u003e and \u003ccode\u003e0xabb0\u003c/code\u003e are, quite clearly, \u003cem\u003ethe same thing\u003c/em\u003e. But you don\u0026#39;t understand the power of lowercase numbers. Here we have an entirely new numbering system where \u003ccode\u003e0xABB0\u003c/code\u003e and \u003ccode\u003e0xabb0\u003c/code\u003e are not equal, which also means \u003ccode\u003e0xABB0 - 0xabb0\u003c/code\u003e is \u003cem\u003enon-zero\u003c/em\u003e. An entirely new field of mathematics lies before us, with new questions to be asked. If \u003ccode\u003e0xABB0 \u0026lt; 0xABB1\u003c/code\u003e, is \u003ccode\u003e0xABB0 \u0026lt; 0xabb1\u003c/code\u003e also true? From this little code sample, we can\u0026#39;t make any inferences, but these questions give us a rich field of useless mathematics to write papers about.\u003c/p\u003e\n\u003cp\u003eThe biggest question of all, is that we know how to write lowercase numbers for \u003ccode\u003eA-F\u003c/code\u003e, but how do we write a lowercase 3?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eBuildMaster\u003c/a\u003e allows you to create a self-service release management platform that allows different teams to manage their applications. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Self_Service\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eExplore how!\u003c/a\u003e \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-11-25T06:30:00Z",
  "modifiedTime": null
}
