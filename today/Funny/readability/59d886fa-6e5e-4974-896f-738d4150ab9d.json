{
  "id": "59d886fa-6e5e-4974-896f-738d4150ab9d",
  "title": "Representative Line: Ripping Away the Mask",
  "link": "https://thedailywtf.com/articles/ripping-away-the-mask",
  "description": "Jason was investigating a bug in a bitmask. It should have been set to 0b11, but someone had set it to just plain decimal 11. The line responsible looked like this: byte number = (byte) 11; This code takes the decimal number 11, casts it to a byte, and stores it in a byte, leaving us with the decimal number 11. Curious, Jason checked the blame and saw that one of their senior-most devs was responsible. Figuring this was a good opportunity to poke a little fun at the dev for a silly mistake like this, Jason sent them a message about the difficulties of telling apart decimal values and binary values when the decimal value only contained ones and zeroes. \"What are you talking about?\" the dev replied back. \"The (byte) operator tells the compiler that the number is in binary.\" Concerned by that reply, Jason started checking the rest of the code. And sure enough, many places in the code, the senior dev had followed this convention. Many of them were wrong, and just hadn't turned into a bug yet. One of two were coincidentally setting the important bits anyway. Now, in a vague \"defense\" of what the senior dev was trying to do, C doesn't have a standard way of specifying binary literals. GCC and Clang both have a non-standard extension which lets you do 0b11, but that's not standard. So I understand the instinct- \"there should be an easy way to do this,\" even if anyone with more than a week's experience *should have known better*. But the real moral of the story is: don't use bitmasks without also using constants. It never should have been written with literals, it should have been written as byte number = FLAG_A | FLAG_B. The #define for the flags could be integer constants, or if you're feeling spicy about it, bitshift operations: #define FLAG_A = (1 \u003c\u003c 1). Then you don't need binary literals, and also your code is actually readable for humans. It was difficult to track down all the places where this misguided convention for binary literals was followed, as it was hard to tell the difference between that and a legitimate cast to byte. Fortunately, there weren't that many places where bitmasks were getting set. [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "author": "Remy Porter",
  "published": "Mon, 14 Oct 2024 06:30:00 GMT",
  "source": "http://syndication.thedailywtf.com/TheDailyWtf",
  "categories": [
    "Representative Line"
  ],
  "byline": "Remy Porter",
  "length": 2542,
  "excerpt": "Jason was investigating a bug in a bitmask. It should have been set to 0b11, but someone had set it to just plain decimal 11. The line responsible looked like this: byte number = (byte) 11;",
  "siteName": "The Daily WTF",
  "favicon": "",
  "text": "by in Representative Line on 2024-10-14 Edit Remy PorterComputers were a mistake, which is why I'm trying to shoot them into space. Editor-in-Chief for TDWTF. Jason was investigating a bug in a bitmask. It should have been set to 0b11, but someone had set it to just plain decimal 11. The line responsible looked like this: byte number = (byte) 11; This code takes the decimal number 11, casts it to a byte, and stores it in a byte, leaving us with the decimal number 11. Curious, Jason checked the blame and saw that one of their senior-most devs was responsible. Figuring this was a good opportunity to poke a little fun at the dev for a silly mistake like this, Jason sent them a message about the difficulties of telling apart decimal values and binary values when the decimal value only contained ones and zeroes. \"What are you talking about?\" the dev replied back. \"The (byte) operator tells the compiler that the number is in binary.\" Concerned by that reply, Jason started checking the rest of the code. And sure enough, many places in the code, the senior dev had followed this convention. Many of them were wrong, and just hadn't turned into a bug yet. One of two were coincidentally setting the important bits anyway. Now, in a vague \"defense\" of what the senior dev was trying to do, C doesn't have a standard way of specifying binary literals. GCC and Clang both have a non-standard extension which lets you do 0b11, but that's not standard. So I understand the instinct- \"there should be an easy way to do this,\" even if anyone with more than a week's experience *should have known better*. But the real moral of the story is: don't use bitmasks without also using constants. It never should have been written with literals, it should have been written as byte number = FLAG_A | FLAG_B. The #define for the flags could be integer constants, or if you're feeling spicy about it, bitshift operations: #define FLAG_A = (1 \u003c\u003c 1). Then you don't need binary literals, and also your code is actually readable for humans. It was difficult to track down all the places where this misguided convention for binary literals was followed, as it was hard to tell the difference between that and a legitimate cast to byte. Fortunately, there weren't that many places where bitmasks were getting set. [Advertisement] Utilize BuildMaster to release your software with confidence, at the pace your business demands. Download today!",
  "image": "https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemscope=\"\" itemtype=\"http://schema.org/Article\" id=\"article-page\"\u003e\n\n        \n        \u003cp\u003e\u003cspan\u003eby \n            in \u003ca itemprop=\"articleSection\" href=\"https://thedailywtf.com/series/representative-line\"\u003eRepresentative Line\u003c/a\u003e\n            on \u003cspan itemprop=\"datePublished\" content=\"2024-10-14\"\u003e2024-10-14\u003c/span\u003e\n            \u003ca href=\"https://thedailywtf.com/admin/article/edit/10759\" rel=\"nofollow\"\u003eEdit\u003c/a\u003e\n        \u003c/span\u003e\u003c/p\u003e\n        \u003cdiv itemprop=\"author\" itemscope=\"\" itemtype=\"http://schema.org/Person\"\u003e\n            \u003cp\u003e\u003cimg itemprop=\"image\" src=\"https://s3.amazonaws.com/remy.jetpackshark.com/remy-thumb.jpg\"/\u003e\n            \u003ca itemprop=\"name\" href=\"https://thedailywtf.com/authors/remy-porter\"\u003eRemy Porter\u003c/a\u003e\u003c/p\u003e\u003cp itemprop=\"description\"\u003eComputers were a mistake, which is why I\u0026#39;m trying to shoot them into space. Editor-in-Chief for TDWTF.\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv itemprop=\"articleBody\"\u003e\n            \u003cp\u003e\u003cstrong\u003eJason\u003c/strong\u003e was investigating a bug in a bitmask. It \u003cem\u003eshould\u003c/em\u003e have been set to \u003ccode\u003e0b11\u003c/code\u003e, but someone had set it to just plain decimal \u003ccode\u003e11\u003c/code\u003e. The line responsible looked like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebyte number = (byte) \u003cspan\u003e11\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code takes the decimal number 11, casts it to a byte, and stores it in a byte, leaving us with the decimal number 11.\u003c/p\u003e\n\u003cp\u003eCurious, Jason checked the blame and saw that one of their senior-most devs was responsible. Figuring this was a good opportunity to poke a little fun at the dev for a silly mistake like this, Jason sent them a message about the difficulties of telling apart decimal values and binary values when the decimal value only contained ones and zeroes.\u003c/p\u003e\n\u003cp\u003e\u0026#34;What are you talking about?\u0026#34; the dev replied back. \u0026#34;The \u003ccode\u003e(byte)\u003c/code\u003e operator tells the compiler that the number \u003cem\u003eis\u003c/em\u003e in binary.\u0026#34;\u003c/p\u003e\n\u003cp\u003eConcerned by that reply, Jason started checking the rest of the code. And sure enough, many places in the code, the senior dev had followed this convention. Many of them were wrong, and just hadn\u0026#39;t turned into a bug yet. One of two were coincidentally setting the important bits \u003cem\u003eanyway\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eNow, in a vague \u0026#34;defense\u0026#34; of what the senior dev was trying to do, C doesn\u0026#39;t have a standard way of specifying binary literals. GCC and Clang both have a non-standard extension which lets you do \u003ccode\u003e0b11\u003c/code\u003e, but that\u0026#39;s not \u003cem\u003estandard\u003c/em\u003e. So I understand the instinct- \u0026#34;there should be an easy way to do this,\u0026#34; even if anyone with more than a week\u0026#39;s experience *should have known better*.\u003c/p\u003e\n\u003cp\u003eBut the real moral of the story is: \u003cem\u003edon\u0026#39;t use bitmasks without also using constants\u003c/em\u003e. It never should have been written with literals, it should have been written as \u003ccode\u003ebyte number = FLAG_A | FLAG_B\u003c/code\u003e. The \u003ccode\u003e#define\u003c/code\u003e for the flags could be integer constants, or if you\u0026#39;re feeling spicy about it, bitshift operations: \u003ccode\u003e#define FLAG_A = (1 \u0026lt;\u0026lt; 1)\u003c/code\u003e. Then you don\u0026#39;t \u003cem\u003eneed\u003c/em\u003e binary literals, and also your code is actually readable for humans.\u003c/p\u003e\n\u003cp\u003eIt was difficult to track down all the places where this misguided convention for binary literals was followed, as it was hard to tell the difference between that and a legitimate cast to \u003ccode\u003ebyte\u003c/code\u003e. Fortunately, there weren\u0026#39;t \u003cem\u003ethat\u003c/em\u003e many places where bitmasks were getting set.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://thedailywtf.com/images/inedo/buildmaster-icon.png\"/\u003e [Advertisement] \n\t\u003ca href=\"https://inedo.com/BuildMaster?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eUtilize BuildMaster\u003c/a\u003e to release your software with confidence, at the pace your business demands. \u003ca href=\"https://inedo.com/BuildMaster/download?utm_source=tdwtf\u0026amp;utm_medium=footerad\u0026amp;utm_term=2018\u0026amp;utm_content=Confidence\u0026amp;utm_campaign=Buildmaster_Footer\"\u003eDownload\u003c/a\u003e today!  \n\u003c/p\u003e\n\n\n        \u003c/div\u003e\n\n        \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "3 min read",
  "publishedTime": "2024-10-14T06:30:00Z",
  "modifiedTime": null
}
