{
  "id": "dfd5de40-7a8a-4aef-9e78-4bd5acb871a0",
  "title": "Regexes Got Good: The History And Future Of Regular Expressions In JavaScript",
  "link": "https://smashingmagazine.com/2024/08/history-future-regular-expressions-javascript/",
  "description": "Although JavaScript regexes used to be underpowered compared to other modern flavors, numerous improvements in recent years mean that’s no longer true. Steven Levithan evaluates the history and present state of regular expressions in JavaScript with tips to make your regexes more readable, maintainable, and resilient.",
  "author": "Steven Levithan",
  "published": "Tue, 20 Aug 2024 15:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 20141,
  "excerpt": "Although JavaScript regexes used to be underpowered compared to other modern flavors, numerous improvements in recent years mean that’s no longer true. Steven Levithan evaluates the history and present state of regular expressions in JavaScript with tips to make your regexes more readable, maintainable, and resilient.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "15 min readJavaScript, Coding, TechniquesAlthough JavaScript regexes used to be underpowered compared to other modern flavors, numerous improvements in recent years mean that’s no longer true. Steven Levithan evaluates the history and present state of regular expressions in JavaScript with tips to make your regexes more readable, maintainable, and resilient.Modern JavaScript regular expressions have come a long way compared to what you might be familiar with. Regexes can be an amazing tool for searching and replacing text, but they have a longstanding reputation (perhaps outdated, as I’ll show) for being difficult to write and understand.This is especially true in JavaScript-land, where regexes languished for many years, comparatively underpowered compared to their more modern counterparts in PCRE, Perl, .NET, Java, Ruby, C++, and Python. Those days are over.In this article, I’ll recount the history of improvements to JavaScript regexes (spoiler: ES2018 and ES2024 changed the game), show examples of modern regex features in action, introduce you to a lightweight JavaScript library that makes JavaScript stand alongside or surpass other modern regex flavors, and end with a preview of active proposals that will continue to improve regexes in future versions of JavaScript (with some of them already working in your browser today).ECMAScript 3, standardized in 1999, introduced Perl-inspired regular expressions to the JavaScript language. Although it got enough things right to make regexes pretty useful (and mostly compatible with other Perl-inspired flavors), there were some big omissions, even then. And while JavaScript waited 10 years for its next standardized version with ES5, other programming languages and regex implementations added useful new features that made their regexes more powerful and readable.But that was then.Did you know that nearly every new version of JavaScript has made at least minor improvements to regular expressions?Let’s take a look at them.Don’t worry if it’s hard to understand what some of the following features mean — we’ll look more closely at several of the key features afterward.ES5 (2009) fixed unintuitive behavior by creating a new object every time regex literals are evaluated and allowed regex literals to use unescaped forward slashes within character classes (/[/]/).ES6/ES2015 added two new regex flags: y (sticky), which made it easier to use regexes in parsers, and u (unicode), which added several significant Unicode-related improvements along with strict errors. It also added the RegExp.prototype.flags getter, support for subclassing RegExp, and the ability to copy a regex while changing its flags.ES2018 was the edition that finally made JavaScript regexes pretty good. It added the s (dotAll) flag, lookbehind, named capture, and Unicode properties (via \\p{...} and \\P{...}, which require ES6’s flag u). All of these are extremely useful features, as we’ll see.ES2020 added the string method matchAll, which we’ll also see more of shortly.ES2022 added flag d (hasIndices), which provides start and end indices for matched substrings.And finally, ES2024 added flag v (unicodeSets) as an upgrade to ES6’s flag u. The v flag adds a set of multicharacter “properties of strings” to \\p{...}, multicharacter elements within character classes via \\p{...} and \\q{...}, nested character classes, set subtraction [A--B] and intersection [A\u0026\u0026B], and different escaping rules within character classes. It also fixed case-insensitive matching for Unicode properties within negated sets [^...].As for whether you can safely use these features in your code today, the answer is yes! The latest of these features, flag v, is supported in Node.js 20 and 2023-era browsers. The rest are supported in 2021-era browsers or earlier.Each edition from ES2019 to ES2023 also added additional Unicode properties that can be used via \\p{...} and \\P{...}. And to be a completionist, ES2021 added string method replaceAll — although, when given a regex, the only difference from ES3’s replace is that it throws if not using flag g.Aside: What Makes a Regex Flavor Good?With all of these changes, how do JavaScript regular expressions now stack up against other flavors? There are multiple ways to think about this, but here are a few key aspects:Performance.This is an important aspect but probably not the main one since mature regex implementations are generally pretty fast. JavaScript is strong on regex performance (at least considering V8’s Irregexp engine, used by Node.js, Chromium-based browsers, and even Firefox; and JavaScriptCore, used by Safari), but it uses a backtracking engine that is missing any syntax for backtracking control — a major limitation that makes ReDoS vulnerability more common.Support for advanced features that handle common or important use cases.Here, JavaScript stepped up its game with ES2018 and ES2024. JavaScript is now best in class for some features like lookbehind (with its infinite-length support) and Unicode properties (with multicharacter “properties of strings,” set subtraction and intersection, and script extensions). These features are either not supported or not as robust in many other flavors.Ability to write readable and maintainable patterns.Here, native JavaScript has long been the worst of the major flavors since it lacks the x (“extended”) flag that allows insignificant whitespace and comments. Additionally, it lacks regex subroutines and subroutine definition groups (from PCRE and Perl), a powerful set of features that enable writing grammatical regexes that build up complex patterns via composition.So, it’s a bit of a mixed bag.JavaScript regexes have become exceptionally powerful, but they’re still missing key features that could make regexes safer, more readable, and more maintainable (all of which hold some people back from using this power).The good news is that all of these holes can be filled by a JavaScript library, which we’ll see later in this article.Using JavaScript’s Modern Regex FeaturesLet’s look at a few of the more useful modern regex features that you might be less familiar with. You should know in advance that this is a moderately advanced guide. If you’re relatively new to regex, here are some excellent tutorials you might want to start with:RegexLearn and RegexOne are interactive tutorials that include practice problems.JavaScript.info’s regular expressions chapter is a detailed and JavaScript-specific guide.Demystifying Regular Expressions (video) is an excellent presentation for beginners by Lea Verou at HolyJS 2017.Learn Regular Expressions In 20 Minutes (video) is a live syntax walkthrough in a regex tester.Named CaptureOften, you want to do more than just check whether a regex matches — you want to extract substrings from the match and do something with them in your code. Named capturing groups allow you to do this in a way that makes your regexes and code more readable and self-documenting.The following example matches a record with two date fields and captures the values:const record = 'Admitted: 2024-01-01\\nReleased: 2024-01-03'; const re = /^Admitted: (?\u003cadmitted\u003e\\d{4}-\\d{2}-\\d{2})\\nReleased: (?\u003creleased\u003e\\d{4}-\\d{2}-\\d{2})$/; const match = record.match(re); console.log(match.groups); /* → { admitted: '2024-01-01', released: '2024-01-03' } */ Don’t worry — although this regex might be challenging to understand, later, we’ll look at a way to make it much more readable. The key things here are that named capturing groups use the syntax (?\u003cname\u003e...), and their results are stored on the groups object of matches.You can also use named backreferences to rematch whatever a named capturing group matched via \\k\u003cname\u003e, and you can use the values within search and replace as follows:// Change 'FirstName LastName' to 'LastName, FirstName' const name = 'Shaquille Oatmeal'; name.replace(/(?\u003cfirst\u003e\\w+) (?\u003clast\u003e\\w+)/, '$\u003clast\u003e, $\u003cfirst\u003e'); // → 'Oatmeal, Shaquille' For advanced regexers who want to use named backreferences within a replacement callback function, the groups object is provided as the last argument. Here’s a fancy example:function fahrenheitToCelsius(str) { const re = /(?\u003cdegrees\u003e-?\\d+(\\.\\d+)?)F\\b/g; return str.replace(re, (...args) =\u003e { const groups = args.at(-1); return Math.round((groups.degrees - 32) * 5/9) + 'C'; }); } fahrenheitToCelsius('98.6F'); // → '37C' fahrenheitToCelsius('May 9 high is 40F and low is 21F'); // → 'May 9 high is 4C and low is -6C' LookbehindLookbehind (introduced in ES2018) is the complement to lookahead, which has always been supported by JavaScript regexes. Lookahead and lookbehind are assertions (similar to ^ for the start of a string or \\b for word boundaries) that don’t consume any characters as part of the match. Lookbehinds succeed or fail based on whether their subpattern can be found immediately before the current match position.For example, the following regex uses a lookbehind (?\u003c=...) to match the word “cat” (only the word “cat”) if it’s preceded by “fat ”:const re = /(?\u003c=fat )cat/g; 'cat, fat cat, brat cat'.replace(re, 'pigeon'); // → 'cat, fat pigeon, brat cat' You can also use negative lookbehind — written as (?\u003c!...) — to invert the assertion. That would make the regex match any instance of “cat” that’s not preceded by “fat ”.const re = /(?\u003c!fat )cat/g; 'cat, fat cat, brat cat'.replace(re, 'pigeon'); // → 'pigeon, fat cat, brat pigeon' JavaScript’s implementation of lookbehind is one of the very best (matched only by .NET). Whereas other regex flavors have inconsistent and complex rules for when and whether they allow variable-length patterns inside lookbehind, JavaScript allows you to look behind for any subpattern.The matchAll MethodJavaScript’s String.prototype.matchAll was added in ES2020 and makes it easier to operate on regex matches in a loop when you need extended match details. Although other solutions were possible before, matchAll is often easier, and it avoids gotchas, such as the need to guard against infinite loops when looping over the results of regexes that might return zero-length matches.Since matchAll returns an iterator (rather than an array), it’s easy to use it in a for...of loop.const re = /(?\u003cchar1\u003e\\w)(?\u003cchar2\u003e\\w)/g; for (const match of str.matchAll(re)) { const {char1, char2} = match.groups; // Print each complete match and matched subpatterns console.log(`Matched \"${match[0]}\" with \"${char1}\" and \"${char2}\"`); } Note: matchAll requires its regexes to use flag g (global). Also, as with other iterators, you can get all of its results as an array using Array.from or array spreading.const matches = [...str.matchAll(/./g)]; Unicode PropertiesUnicode properties (added in ES2018) give you powerful control over multilingual text, using the syntax \\p{...} and its negated version \\P{...}. There are hundreds of different properties you can match, which cover a wide variety of Unicode categories, scripts, script extensions, and binary properties.Note: For more details, check out the documentation on MDN.Unicode properties require using the flag u (unicode) or v (unicodeSets).Flag vFlag v (unicodeSets) was added in ES2024 and is an upgrade to flag u — you can’t use both at the same time. It’s a best practice to always use one of these flags to avoid silently introducing bugs via the default Unicode-unaware mode. The decision on which to use is fairly straightforward. If you’re okay with only supporting environments with flag v (Node.js 20 and 2023-era browsers), then use flag v; otherwise, use flag u.Flag v adds support for several new regex features, with the coolest probably being set subtraction and intersection. This allows using A--B (within character classes) to match strings in A but not in B or using A\u0026\u0026B to match strings in both A and B. For example:// Matches all Greek symbols except the letter 'π' /[\\p{Script_Extensions=Greek}--π]/v // Matches only Greek letters /[\\p{Script_Extensions=Greek}\u0026\u0026\\p{Letter}]/v For more details about flag v, including its other new features, check out this explainer from the Google Chrome team.A Word on Matching EmojiEmoji are 🤩🔥😎👌, but how emoji get encoded in text is complicated. If you’re trying to match them with a regex, it’s important to be aware that a single emoji can be composed of one or many individual Unicode code points. Many people (and libraries!) who roll their own emoji regexes miss this point (or implement it poorly) and end up with bugs.The following details for the emoji “👩🏻‍🏫” (Woman Teacher: Light Skin Tone) show just how complicated emoji can be:// Code unit length '👩🏻‍🏫'.length; // → 7 // Each astral code point (above \\uFFFF) is divided into high and low surrogates // Code point length [...'👩🏻‍🏫'].length; // → 4 // These four code points are: \\u{1F469} \\u{1F3FB} \\u{200D} \\u{1F3EB} // \\u{1F469} combined with \\u{1F3FB} is '👩🏻' // \\u{200D} is a Zero-Width Joiner // \\u{1F3EB} is '🏫' // Grapheme cluster length (user-perceived characters) [...new Intl.Segmenter().segment('👩🏻‍🏫')].length; // → 1 Fortunately, JavaScript added an easy way to match any individual, complete emoji via \\p{RGI_Emoji}. Since this is a fancy “property of strings” that can match more than one code point at a time, it requires ES2024’s flag v.If you want to match emojis in environments without v support, check out the excellent libraries emoji-regex and emoji-regex-xs.Making Your Regexes More Readable, Maintainable, and ResilientDespite the improvements to regex features over the years, native JavaScript regexes of sufficient complexity can still be outrageously hard to read and maintain.Regular Expressions are SO EASY!!!! pic.twitter.com/q4GSpbJRbZ— Garabato Kid (@garabatokid) July 5, 2019ES2018’s named capture was a great addition that made regexes more self-documenting, and ES6’s String.raw tag allows you to avoid escaping all your backslashes when using the RegExp constructor. But for the most part, that’s it in terms of readability.However, there’s a lightweight and high-performance JavaScript library named regex (by yours truly) that makes regexes dramatically more readable. It does this by adding key missing features from Perl-Compatible Regular Expressions (PCRE) and outputting native JavaScript regexes. You can also use it as a Babel plugin, which means that regex calls are transpiled at build time, so you get a better developer experience without users paying any runtime cost.PCRE is a popular C library used by PHP for its regex support, and it’s available in countless other programming languages and tools.Let’s briefly look at some of the ways the regex library, which provides a template tag named regex, can help you write complex regexes that are actually understandable and maintainable by mortals. Note that all of the new syntax described below works identically in PCRE.Insignificant Whitespace and CommentsBy default, regex allows you to freely add whitespace and line comments (starting with #) to your regexes for readability.import {regex} from 'regex'; const date = regex` # Match a date in YYYY-MM-DD format (?\u003cyear\u003e \\d{4}) - # Year part (?\u003cmonth\u003e \\d{2}) - # Month part (?\u003cday\u003e \\d{2}) # Day part `; This is equivalent to using PCRE’s xx flag.Subroutines and Subroutine Definition GroupsSubroutines are written as \\g\u003cname\u003e (where name refers to a named group), and they treat the referenced group as an independent subpattern that they try to match at the current position. This enables subpattern composition and reuse, which improves readability and maintainability.For example, the following regex matches an IPv4 address such as “192.168.12.123”:import {regex} from 'regex'; const ipv4 = regex`\\b (?\u003cbyte\u003e 25[0-5] | 2[0-4]\\d | 1\\d\\d | [1-9]?\\d) # Match the remaining 3 dot-separated bytes (\\. \\g\u003cbyte\u003e){3} \\b`; You can take this even further by defining subpatterns for use by reference only via subroutine definition groups. Here’s an example that improves the regex for admittance records that we saw earlier in this article:const record = 'Admitted: 2024-01-01\\nReleased: 2024-01-03'; const re = regex` ^ Admitted:\\ (?\u003cadmitted\u003e \\g\u003cdate\u003e) \\n Released:\\ (?\u003creleased\u003e \\g\u003cdate\u003e) $ (?(DEFINE) (?\u003cdate\u003e \\g\u003cyear\u003e-\\g\u003cmonth\u003e-\\g\u003cday\u003e) (?\u003cyear\u003e \\d{4}) (?\u003cmonth\u003e \\d{2}) (?\u003cday\u003e \\d{2}) ) `; const match = record.match(re); console.log(match.groups); /* → { admitted: '2024-01-01', released: '2024-01-03' } */ A Modern Regex Baselineregex includes the v flag by default, so you never forget to turn it on. And in environments without native v, it automatically switches to flag u while applying v’s escaping rules, so your regexes are forward and backward-compatible.It also implicitly enables the emulated flags x (insignificant whitespace and comments) and n (“named capture only” mode) by default, so you don’t have to continually opt into their superior modes. And since it’s a raw string template tag, you don’t have to escape your backslashes \\\\\\\\ like with the RegExp constructor.Atomic Groups and Possessive Quantifiers Can Prevent Catastrophic BacktrackingAtomic groups and possessive quantifiers are another powerful set of features added by the regex library. Although they’re primarily about performance and resilience against catastrophic backtracking (also known as ReDoS or “regular expression denial of service,” a serious issue where certain regexes can take forever when searching particular, not-quite-matching strings), they can also help with readability by allowing you to write simpler patterns.Note: You can learn more in the regex documentation.What’s Next? Upcoming JavaScript Regex ImprovementsThere are a variety of active proposals for improving regexes in JavaScript. Below, we’ll look at the three that are well on their way to being included in future editions of the language.Duplicate Named Capturing GroupsThis is a Stage 3 (nearly finalized) proposal. Even better is that, as of recently, it works in all major browsers.When named capturing was first introduced, it required that all (?\u003cname\u003e...) captures use unique names. However, there are cases when you have multiple alternate paths through a regex, and it would simplify your code to reuse the same group names in each alternative.For example:/(?\u003cyear\u003e\\d{4})-\\d\\d|\\d\\d-(?\u003cyear\u003e\\d{4})/ This proposal enables exactly this, preventing a “duplicate capture group name” error with this example. Note that names must still be unique within each alternative path.Pattern Modifiers (aka Flag Groups)This is another Stage 3 proposal. It’s already supported in Chrome/Edge 125 and Opera 111, and it’s coming soon for Firefox. No word yet on Safari.Pattern modifiers use (?ims:...), (?-ims:...), or (?im-s:...) to turn the flags i, m, and s on or off for only certain parts of a regex.For example:/hello-(?i:world)/ // Matches 'hello-WORLD' but not 'HELLO-WORLD' Escape Regex Special Characters with RegExp.escapeThis proposal recently reached Stage 3 and has been a long time coming. It isn’t yet supported in any major browsers. The proposal does what it says on the tin, providing the function RegExp.escape(str), which returns the string with all regex special characters escaped so you can match them literally.If you need this functionality today, the most widely-used package (with more than 500 million monthly npm downloads) is escape-string-regexp, an ultra-lightweight, single-purpose utility that does minimal escaping. That’s great for most cases, but if you need assurance that your escaped string can safely be used at any arbitrary position within a regex, escape-string-regexp recommends the regex library that we’ve already looked at in this article. The regex library uses interpolation to escape embedded strings in a context-aware way.ConclusionSo there you have it: the past, present, and future of JavaScript regular expressions.If you want to journey even deeper into the lands of regex, check out Awesome Regex for a list of the best regex testers, tutorials, libraries, and other resources. And for a fun regex crossword puzzle, try your hand at regexle.May your parsing be prosperous and your regexes be readable. (gg, yk)",
  "image": "https://files.smashing.media/articles/history-future-regular-expressions-javascript/history-future-regular-expressions-javascript.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e15 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/javascript\"\u003eJavaScript\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eAlthough JavaScript regexes used to be underpowered compared to other modern flavors, numerous improvements in recent years mean that’s no longer true. Steven Levithan evaluates the history and present state of regular expressions in JavaScript with tips to make your regexes more readable, maintainable, and resilient.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eModern JavaScript regular expressions have come a long way compared to what you might be familiar with. Regexes can be \u003cstrong\u003ean amazing tool for searching and replacing text\u003c/strong\u003e, but they have a longstanding reputation (perhaps outdated, as I’ll show) for being difficult to write and understand.\u003c/p\u003e\u003cp\u003eThis is especially true in JavaScript-land, where regexes languished for many years, comparatively underpowered compared to their more modern counterparts in PCRE, Perl, .NET, Java, Ruby, C++, and Python. Those days are over.\u003c/p\u003e\u003cp\u003eIn this article, I’ll recount the history of improvements to JavaScript regexes (spoiler: ES2018 and ES2024 changed the game), show examples of modern regex features in action, introduce you to a lightweight \u003ca href=\"https://github.com/slevithan/regex\"\u003eJavaScript library\u003c/a\u003e that makes JavaScript stand alongside or surpass other modern regex flavors, and end with a preview of active proposals that will continue to improve regexes in future versions of JavaScript (with some of them already working in your browser today).\u003c/p\u003e\u003cp\u003eECMAScript 3, standardized in 1999, introduced Perl-inspired regular expressions to the JavaScript language. Although it got enough things right to make regexes pretty useful (and mostly compatible with other Perl-inspired flavors), there were some big omissions, even then. And while JavaScript waited 10 years for its next standardized version with ES5, other programming languages and regex implementations added useful new features that made their regexes more powerful and readable.\u003c/p\u003e\u003cp\u003eBut that was then.\u003c/p\u003e\u003cblockquote\u003eDid you know that nearly every new version of JavaScript has made at least minor improvements to regular expressions?\u003c/blockquote\u003e\u003cp\u003eLet’s take a look at them.\u003c/p\u003e\u003cp\u003eDon’t worry if it’s hard to understand what some of the following features mean — we’ll look more closely at several of the key features afterward.\u003c/p\u003e\u003cul\u003e\u003cli\u003eES5 (2009) fixed unintuitive behavior by creating a new object every time regex literals are evaluated and allowed regex literals to use unescaped forward slashes within character classes (\u003ccode\u003e/[/]/\u003c/code\u003e).\u003c/li\u003e\u003cli\u003eES6/ES2015 added two new regex flags: \u003ccode\u003ey\u003c/code\u003e (\u003ccode\u003esticky\u003c/code\u003e), which made it easier to use regexes in parsers, and \u003ccode\u003eu\u003c/code\u003e (\u003ccode\u003eunicode\u003c/code\u003e), which added several significant Unicode-related improvements along with strict errors. It also added the \u003ccode\u003eRegExp.prototype.flags\u003c/code\u003e getter, support for subclassing \u003ccode\u003eRegExp\u003c/code\u003e, and the ability to copy a regex while changing its flags.\u003c/li\u003e\u003cli\u003eES2018 was the edition that finally made JavaScript regexes pretty good. It added the \u003ccode\u003es\u003c/code\u003e (\u003ccode\u003edotAll\u003c/code\u003e) flag, lookbehind, named capture, and Unicode properties (via \u003ccode\u003e\\p{...}\u003c/code\u003e and \u003ccode\u003e\\P{...}\u003c/code\u003e, which require ES6’s flag \u003ccode\u003eu\u003c/code\u003e). All of these are extremely useful features, as we’ll see.\u003c/li\u003e\u003cli\u003eES2020 added the string method \u003ccode\u003ematchAll\u003c/code\u003e, which we’ll also see more of shortly.\u003c/li\u003e\u003cli\u003eES2022 added flag \u003ccode\u003ed\u003c/code\u003e (\u003ccode\u003ehasIndices\u003c/code\u003e), which provides start and end indices for matched substrings.\u003c/li\u003e\u003cli\u003eAnd finally, ES2024 added flag \u003ccode\u003ev\u003c/code\u003e (\u003ccode\u003eunicodeSets\u003c/code\u003e) as an upgrade to ES6’s flag \u003ccode\u003eu\u003c/code\u003e. The \u003ccode\u003ev\u003c/code\u003e flag adds a set of multicharacter “properties of strings” to \u003ccode\u003e\\p{...}\u003c/code\u003e, multicharacter elements within character classes via \u003ccode\u003e\\p{...}\u003c/code\u003e and \u003ccode\u003e\\q{...}\u003c/code\u003e, nested character classes, set subtraction \u003ccode\u003e[A--B]\u003c/code\u003e and intersection \u003ccode\u003e[A\u0026amp;\u0026amp;B]\u003c/code\u003e, and different escaping rules within character classes. It also fixed case-insensitive matching for Unicode properties within negated sets \u003ccode\u003e[^...]\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAs for whether you can safely use these features in your code today, the answer is yes! The latest of these features, flag \u003ccode\u003ev\u003c/code\u003e, is supported in Node.js 20 and \u003ca href=\"https://caniuse.com/mdn-javascript_builtins_regexp_unicodesets\"\u003e2023-era\u003c/a\u003e browsers. The rest are supported in 2021-era browsers or earlier.\u003c/p\u003e\u003cp\u003eEach edition from ES2019 to ES2023 also added additional Unicode properties that can be used via \u003ccode\u003e\\p{...}\u003c/code\u003e and \u003ccode\u003e\\P{...}\u003c/code\u003e. And to be a completionist, ES2021 added string method \u003ccode\u003ereplaceAll\u003c/code\u003e — although, when given a regex, the only difference from ES3’s \u003ccode\u003ereplace\u003c/code\u003e is that it throws if not using flag \u003ccode\u003eg\u003c/code\u003e.\u003c/p\u003e\u003ch3 id=\"aside-what-makes-a-regex-flavor-good\"\u003eAside: What Makes a Regex Flavor Good?\u003c/h3\u003e\u003cp\u003eWith all of these changes, how do JavaScript regular expressions now stack up against other flavors? There are multiple ways to think about this, but here are a few key aspects:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003ePerformance.\u003c/strong\u003e\u003cbr/\u003eThis is an important aspect but probably not the main one since mature regex implementations are generally pretty fast. JavaScript is strong on regex performance (at least considering V8’s Irregexp engine, used by Node.js, Chromium-based browsers, and \u003ca href=\"https://hacks.mozilla.org/2020/06/a-new-regexp-engine-in-spidermonkey/\"\u003eeven Firefox\u003c/a\u003e; and JavaScriptCore, used by Safari), but it uses a backtracking engine that is missing any syntax for backtracking control — a major limitation that makes ReDoS vulnerability more common.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSupport for advanced features\u003c/strong\u003e that handle common or important use cases.\u003cbr/\u003eHere, JavaScript stepped up its game with ES2018 and ES2024. JavaScript is now best in class for some features like lookbehind (with its infinite-length support) and Unicode properties (with multicharacter “properties of strings,” set subtraction and intersection, and script extensions). These features are either not supported or not as robust in many other flavors.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAbility to write readable and maintainable patterns.\u003c/strong\u003e\u003cbr/\u003eHere, native JavaScript has long been the worst of the major flavors since it lacks the \u003ccode\u003ex\u003c/code\u003e (“extended”) flag that allows insignificant whitespace and comments. Additionally, it lacks regex subroutines and subroutine definition groups (from PCRE and Perl), a powerful set of features that enable writing grammatical regexes that build up complex patterns via composition.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSo, it’s a bit of a mixed bag.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aJavaScript%20regexes%20have%20become%20exceptionally%20powerful,%20but%20they%e2%80%99re%20still%20missing%20key%20features%20that%20could%20make%20regexes%20safer,%20more%20readable,%20and%20more%20maintainable%20%28all%20of%20which%20hold%20some%20people%20back%20from%20using%20this%20power%29.%0a\u0026amp;url=https://smashingmagazine.com%2f2024%2f08%2fhistory-future-regular-expressions-javascript%2f\"\u003eJavaScript regexes have become exceptionally powerful, but they’re still missing key features that could make regexes safer, more readable, and more maintainable (all of which hold some people back from using this power).\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eThe good news is that all of these holes can be filled by a JavaScript library, which we’ll see later in this article.\u003c/p\u003e\u003ch2 id=\"using-javascript-s-modern-regex-features\"\u003eUsing JavaScript’s Modern Regex Features\u003c/h2\u003e\u003cp\u003eLet’s look at a few of the more useful modern regex features that you might be less familiar with. You should know in advance that this is \u003cstrong\u003ea moderately advanced guide\u003c/strong\u003e. If you’re relatively new to regex, here are some excellent tutorials you might want to start with:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://regexlearn.com/\"\u003eRegexLearn\u003c/a\u003e and \u003ca href=\"https://regexone.com/\"\u003eRegexOne\u003c/a\u003e are interactive tutorials that include practice problems.\u003c/li\u003e\u003cli\u003eJavaScript.info’s \u003ca href=\"https://javascript.info/regular-expressions\"\u003eregular expressions\u003c/a\u003e chapter is a detailed and JavaScript-specific guide.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=M7vDtxaD7ZU\"\u003eDemystifying Regular Expressions\u003c/a\u003e (video) is an excellent presentation for beginners by Lea Verou at HolyJS 2017.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=rhzKDrUiJVk\"\u003eLearn Regular Expressions In 20 Minutes\u003c/a\u003e (video) is a live syntax walkthrough in a regex tester.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"named-capture\"\u003eNamed Capture\u003c/h3\u003e\u003cp\u003eOften, you want to do more than just check whether a regex matches — you want to extract substrings from the match and do something with them in your code. Named capturing groups allow you to do this in a way that makes your regexes and code \u003cstrong\u003emore readable\u003c/strong\u003e and \u003cstrong\u003eself-documenting\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eThe following example matches a record with two date fields and captures the values:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst record = \u0026#39;Admitted: 2024-01-01\\nReleased: 2024-01-03\u0026#39;;\nconst re = /^Admitted: (?\u0026lt;admitted\u0026gt;\\d{4}-\\d{2}-\\d{2})\\nReleased: (?\u0026lt;released\u0026gt;\\d{4}-\\d{2}-\\d{2})$/;\nconst match = record.match(re);\nconsole.log(match.groups);\n/* → {\n  admitted: \u0026#39;2024-01-01\u0026#39;,\n  released: \u0026#39;2024-01-03\u0026#39;\n} */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eDon’t worry — although this regex might be challenging to understand, later, we’ll look at a way to make it much more readable. The key things here are that named capturing groups use the syntax \u003ccode\u003e(?\u0026lt;name\u0026gt;...)\u003c/code\u003e, and their results are stored on the \u003ccode\u003egroups\u003c/code\u003e object of matches.\u003c/p\u003e\u003cp\u003eYou can also use named backreferences to rematch whatever a named capturing group matched via \u003ccode\u003e\\k\u0026lt;name\u0026gt;\u003c/code\u003e, and you can use the values within search and replace as follows:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Change \u0026#39;FirstName LastName\u0026#39; to \u0026#39;LastName, FirstName\u0026#39;\nconst name = \u0026#39;Shaquille Oatmeal\u0026#39;;\nname.replace(/(?\u0026lt;first\u0026gt;\\w+) (?\u0026lt;last\u0026gt;\\w+)/, \u0026#39;$\u0026lt;last\u0026gt;, $\u0026lt;first\u0026gt;\u0026#39;);\n// → \u0026#39;Oatmeal, Shaquille\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor advanced regexers who want to use named backreferences within a replacement callback function, the \u003ccode\u003egroups\u003c/code\u003e object is provided as the last argument. Here’s a fancy example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunction fahrenheitToCelsius(str) {\n  const re = /(?\u0026lt;degrees\u0026gt;-?\\d+(\\.\\d+)?)F\\b/g;\n  return str.replace(re, (...args) =\u0026gt; {\n    const groups = args.at(-1);\n    return Math.round((groups.degrees - 32) * 5/9) + \u0026#39;C\u0026#39;;\n  });\n}\nfahrenheitToCelsius(\u0026#39;98.6F\u0026#39;);\n// → \u0026#39;37C\u0026#39;\nfahrenheitToCelsius(\u0026#39;May 9 high is 40F and low is 21F\u0026#39;);\n// → \u0026#39;May 9 high is 4C and low is -6C\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"lookbehind\"\u003eLookbehind\u003c/h3\u003e\u003cp\u003eLookbehind (introduced in ES2018) is the complement to \u003cem\u003elookahead\u003c/em\u003e, which has always been supported by JavaScript regexes. Lookahead and lookbehind are \u003cem\u003eassertions\u003c/em\u003e (similar to \u003ccode\u003e^\u003c/code\u003e for the start of a string or \u003ccode\u003e\\b\u003c/code\u003e for word boundaries) that don’t consume any characters as part of the match. Lookbehinds succeed or fail based on whether their subpattern can be found immediately before the current match position.\u003c/p\u003e\u003cp\u003eFor example, the following regex uses a lookbehind \u003ccode\u003e(?\u0026lt;=...)\u003c/code\u003e to match the word “cat” (\u003cem\u003eonly\u003c/em\u003e the word “cat”) if it’s preceded by “fat ”:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst re = /(?\u0026lt;=fat )cat/g;\n\u0026#39;cat, fat cat, brat cat\u0026#39;.replace(re, \u0026#39;pigeon\u0026#39;);\n// → \u0026#39;cat, fat pigeon, brat cat\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can also use \u003cem\u003enegative\u003c/em\u003e lookbehind — written as \u003ccode\u003e(?\u0026lt;!...)\u003c/code\u003e — to invert the assertion. That would make the regex match any instance of “cat” that’s \u003cem\u003enot\u003c/em\u003e preceded by “fat ”.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst re = /(?\u0026lt;!fat )cat/g;\n\u0026#39;cat, fat cat, brat cat\u0026#39;.replace(re, \u0026#39;pigeon\u0026#39;);\n// → \u0026#39;pigeon, fat cat, brat pigeon\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eJavaScript’s implementation of lookbehind is one of the very best (matched only by .NET). Whereas other regex flavors have inconsistent and complex rules for when and whether they allow variable-length patterns inside lookbehind, JavaScript allows you to look behind for any subpattern.\u003c/p\u003e\u003ch3 id=\"the-matchall-method\"\u003eThe \u003ccode\u003ematchAll\u003c/code\u003e Method\u003c/h3\u003e\u003cp\u003eJavaScript’s \u003ccode\u003eString.prototype.matchAll\u003c/code\u003e was added in ES2020 and makes it easier to operate on regex matches in a loop when you need extended match details. Although other solutions were possible before, \u003ccode\u003ematchAll\u003c/code\u003e is often easier, and it avoids gotchas, such as the need to guard against infinite loops when looping over the results of regexes that might return zero-length matches.\u003c/p\u003e\u003cp\u003eSince \u003ccode\u003ematchAll\u003c/code\u003e returns an iterator (rather than an array), it’s easy to use it in a \u003ccode\u003efor...of\u003c/code\u003e loop.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst re = /(?\u0026lt;char1\u0026gt;\\w)(?\u0026lt;char2\u0026gt;\\w)/g;\nfor (const match of str.matchAll(re)) {\n  const {char1, char2} = match.groups;\n  // Print each complete match and matched subpatterns\n  console.log(`Matched \u0026#34;${match[0]}\u0026#34; with \u0026#34;${char1}\u0026#34; and \u0026#34;${char2}\u0026#34;`);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003e\u003ccode\u003ematchAll\u003c/code\u003e requires its regexes to use flag \u003ccode\u003eg\u003c/code\u003e (\u003ccode\u003eglobal\u003c/code\u003e). Also, as with other iterators, you can get all of its results as an array using \u003ccode\u003eArray.from\u003c/code\u003e or array spreading.\u003c/em\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst matches = [...str.matchAll(/./g)];\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"unicode-properties\"\u003eUnicode Properties\u003c/h3\u003e\u003cp\u003eUnicode properties (added in ES2018) give you powerful control over multilingual text, using the syntax \u003ccode\u003e\\p{...}\u003c/code\u003e and its negated version \u003ccode\u003e\\P{...}\u003c/code\u003e. There are hundreds of different properties you can match, which cover a wide variety of Unicode categories, scripts, script extensions, and binary properties.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eFor more details, check out the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape\"\u003edocumentation on MDN\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eUnicode properties require using the flag \u003ccode\u003eu\u003c/code\u003e (\u003ccode\u003eunicode\u003c/code\u003e) or \u003ccode\u003ev\u003c/code\u003e (\u003ccode\u003eunicodeSets\u003c/code\u003e).\u003c/p\u003e\u003ch3 id=\"flag-v\"\u003eFlag \u003ccode\u003ev\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eFlag \u003ccode\u003ev\u003c/code\u003e (\u003ccode\u003eunicodeSets\u003c/code\u003e) was added in ES2024 and is an upgrade to flag \u003ccode\u003eu\u003c/code\u003e — you can’t use both at the same time. It’s a best practice to always use one of these flags to avoid silently introducing bugs via the default Unicode-unaware mode. The decision on which to use is fairly straightforward. If you’re okay with only supporting environments with flag \u003ccode\u003ev\u003c/code\u003e (Node.js 20 and 2023-era browsers), then use flag \u003ccode\u003ev\u003c/code\u003e; otherwise, use flag \u003ccode\u003eu\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eFlag \u003ccode\u003ev\u003c/code\u003e adds support for several new regex features, with the coolest probably being set subtraction and intersection. This allows using \u003ccode\u003eA--B\u003c/code\u003e (within character classes) to match strings in \u003cem\u003eA\u003c/em\u003e but not in \u003cem\u003eB\u003c/em\u003e or using \u003ccode\u003eA\u0026amp;\u0026amp;B\u003c/code\u003e to match strings in both \u003cem\u003eA\u003c/em\u003e and \u003cem\u003eB\u003c/em\u003e. For example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Matches all Greek symbols except the letter \u0026#39;π\u0026#39;\n/[\\p{Script_Extensions=Greek}--π]/v\n\n// Matches only Greek letters\n/[\\p{Script_Extensions=Greek}\u0026amp;\u0026amp;\\p{Letter}]/v\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor more details about flag \u003ccode\u003ev\u003c/code\u003e, including its other new features, check out this \u003ca href=\"https://v8.dev/features/regexp-v-flag\"\u003eexplainer\u003c/a\u003e from the Google Chrome team.\u003c/p\u003e\u003ch4 id=\"a-word-on-matching-emoji\"\u003eA Word on Matching Emoji\u003c/h4\u003e\u003cp\u003eEmoji are 🤩🔥😎👌, but how emoji get encoded in text is complicated. If you’re trying to match them with a regex, it’s important to be aware that \u003cstrong\u003ea single emoji can be composed of one or many individual Unicode code points\u003c/strong\u003e. Many people (and libraries!) who roll their own emoji regexes miss this point (or implement it poorly) and end up with bugs.\u003c/p\u003e\u003cp\u003eThe following details for the emoji “👩🏻‍🏫” (\u003cem\u003eWoman Teacher: Light Skin Tone\u003c/em\u003e) show just how complicated emoji can be:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// Code unit length\n\u0026#39;👩🏻‍🏫\u0026#39;.length;\n// → 7\n// Each astral code point (above \\uFFFF) is divided into high and low surrogates\n\n// Code point length\n[...\u0026#39;👩🏻‍🏫\u0026#39;].length;\n// → 4\n// These four code points are: \\u{1F469} \\u{1F3FB} \\u{200D} \\u{1F3EB}\n// \\u{1F469} combined with \\u{1F3FB} is \u0026#39;👩🏻\u0026#39;\n// \\u{200D} is a Zero-Width Joiner\n// \\u{1F3EB} is \u0026#39;🏫\u0026#39;\n\n// Grapheme cluster length (user-perceived characters)\n[...new Intl.Segmenter().segment(\u0026#39;👩🏻‍🏫\u0026#39;)].length;\n// → 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFortunately, JavaScript added an easy way to match any individual, complete emoji via \u003ccode\u003e\\p{RGI_Emoji}\u003c/code\u003e. Since this is a fancy “property of strings” that can match more than one code point at a time, it requires ES2024’s flag \u003ccode\u003ev\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eIf you want to match emojis in environments without \u003ccode\u003ev\u003c/code\u003e support, check out the excellent libraries \u003ca href=\"https://github.com/mathiasbynens/emoji-regex\"\u003eemoji-regex\u003c/a\u003e and \u003ca href=\"https://github.com/slevithan/emoji-regex-xs\"\u003eemoji-regex-xs\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"making-your-regexes-more-readable-maintainable-and-resilient\"\u003eMaking Your Regexes More Readable, Maintainable, and Resilient\u003c/h2\u003e\u003cp\u003eDespite the improvements to regex features over the years, native JavaScript regexes of sufficient complexity can still be outrageously hard to read and maintain.\u003c/p\u003e\u003cblockquote\u003e\u003cp lang=\"en\" dir=\"ltr\"\u003eRegular Expressions are SO EASY!!!! \u003ca href=\"https://t.co/q4GSpbJRbZ\"\u003epic.twitter.com/q4GSpbJRbZ\u003c/a\u003e\u003c/p\u003e— Garabato Kid (@garabatokid) \u003ca href=\"https://twitter.com/garabatokid/status/1147063121678389253?ref_src=twsrc%5Etfw\"\u003eJuly 5, 2019\u003c/a\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cbr/\u003eES2018’s named capture was a great addition that made regexes more self-documenting, and ES6’s \u003ccode\u003eString.raw\u003c/code\u003e tag allows you to avoid escaping all your backslashes when using the \u003ccode\u003eRegExp\u003c/code\u003e constructor. But for the most part, that’s it in terms of readability.\u003c/p\u003e\u003cp\u003eHowever, there’s a lightweight and high-performance \u003ca href=\"https://github.com/slevithan/regex\"\u003eJavaScript library\u003c/a\u003e named \u003ccode\u003eregex\u003c/code\u003e (by yours truly) that makes regexes dramatically more readable. It does this by adding key missing features from Perl-Compatible Regular Expressions (PCRE) and outputting native JavaScript regexes. You can also use it as a Babel plugin, which means that \u003ccode\u003eregex\u003c/code\u003e calls are transpiled at build time, so you get a better developer experience without users paying any runtime cost.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/PCRE2Project/pcre2\"\u003ePCRE\u003c/a\u003e is a popular C library used by PHP for its regex support, and it’s available in countless other programming languages and tools.\u003c/p\u003e\u003cp\u003eLet’s briefly look at some of the ways the \u003ccode\u003eregex\u003c/code\u003e library, which provides a template tag named \u003ccode\u003eregex\u003c/code\u003e, can help you write complex regexes that are actually understandable and maintainable by mortals. Note that all of the new syntax described below works identically in PCRE.\u003c/p\u003e\u003ch3 id=\"insignificant-whitespace-and-comments\"\u003eInsignificant Whitespace and Comments\u003c/h3\u003e\u003cp\u003eBy default, \u003ccode\u003eregex\u003c/code\u003e allows you to freely add whitespace and line comments (starting with \u003ccode\u003e#\u003c/code\u003e) to your regexes for readability.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport {regex} from \u0026#39;regex\u0026#39;;\nconst date = regex`\n  # Match a date in YYYY-MM-DD format\n  (?\u0026lt;year\u0026gt;  \\d{4}) - # Year part\n  (?\u0026lt;month\u0026gt; \\d{2}) - # Month part\n  (?\u0026lt;day\u0026gt;   \\d{2})   # Day part\n`;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis is equivalent to using PCRE’s \u003ccode\u003exx\u003c/code\u003e flag.\u003c/p\u003e\u003ch3 id=\"subroutines-and-subroutine-definition-groups\"\u003eSubroutines and Subroutine Definition Groups\u003c/h3\u003e\u003cp\u003eSubroutines are written as \u003ccode\u003e\\g\u0026lt;name\u0026gt;\u003c/code\u003e (where \u003cem\u003ename\u003c/em\u003e refers to a named group), and they treat the referenced group as an independent subpattern that they try to match at the current position. This enables subpattern composition and reuse, which improves readability and maintainability.\u003c/p\u003e\u003cp\u003eFor example, the following regex matches an IPv4 address such as “192.168.12.123”:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport {regex} from \u0026#39;regex\u0026#39;;\nconst ipv4 = regex`\\b\n  (?\u0026lt;byte\u0026gt; 25[0-5] | 2[0-4]\\d | 1\\d\\d | [1-9]?\\d)\n  # Match the remaining 3 dot-separated bytes\n  (\\. \\g\u0026lt;byte\u0026gt;){3}\n\\b`;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou can take this even further by defining subpatterns for use by reference only via subroutine definition groups. Here’s an example that improves the regex for admittance records that we saw earlier in this article:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst record = \u0026#39;Admitted: 2024-01-01\\nReleased: 2024-01-03\u0026#39;;\nconst re = regex`\n  ^ Admitted:\\ (?\u0026lt;admitted\u0026gt; \\g\u0026lt;date\u0026gt;) \\n\n    Released:\\ (?\u0026lt;released\u0026gt; \\g\u0026lt;date\u0026gt;) $\n\n  (?(DEFINE)\n    (?\u0026lt;date\u0026gt;  \\g\u0026lt;year\u0026gt;-\\g\u0026lt;month\u0026gt;-\\g\u0026lt;day\u0026gt;)\n    (?\u0026lt;year\u0026gt;  \\d{4})\n    (?\u0026lt;month\u0026gt; \\d{2})\n    (?\u0026lt;day\u0026gt;   \\d{2})\n  )\n`;\nconst match = record.match(re);\nconsole.log(match.groups);\n/* → {\n  admitted: \u0026#39;2024-01-01\u0026#39;,\n  released: \u0026#39;2024-01-03\u0026#39;\n} */\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"a-modern-regex-baseline\"\u003eA Modern Regex Baseline\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eregex\u003c/code\u003e includes the \u003ccode\u003ev\u003c/code\u003e flag by default, so you never forget to turn it on. And in environments without native \u003ccode\u003ev\u003c/code\u003e, it automatically switches to flag \u003ccode\u003eu\u003c/code\u003e while applying \u003ccode\u003ev\u003c/code\u003e’s escaping rules, so your regexes are forward and backward-compatible.\u003c/p\u003e\u003cp\u003eIt also implicitly enables the emulated flags \u003ccode\u003ex\u003c/code\u003e (insignificant whitespace and comments) and \u003ccode\u003en\u003c/code\u003e (“named capture only” mode) by default, so you don’t have to continually opt into their superior modes. And since it’s a raw string template tag, you don’t have to escape your backslashes \u003ccode\u003e\\\\\\\\\u003c/code\u003e like with the \u003ccode\u003eRegExp\u003c/code\u003e constructor.\u003c/p\u003e\u003ch3 id=\"atomic-groups-and-possessive-quantifiers-can-prevent-catastrophic-backtracking\"\u003eAtomic Groups and Possessive Quantifiers Can Prevent Catastrophic Backtracking\u003c/h3\u003e\u003cp\u003eAtomic groups and possessive quantifiers are another powerful set of features added by the \u003ccode\u003eregex\u003c/code\u003e library. Although they’re primarily about performance and resilience against catastrophic backtracking (also known as ReDoS or “regular expression denial of service,” a serious issue where certain regexes can take forever when searching particular, not-quite-matching strings), they can also help with readability by allowing you to write simpler patterns.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eYou can learn more in the \u003ccode\u003eregex\u003c/code\u003e \u003ca href=\"https://github.com/slevithan/regex#atomic-groups\"\u003edocumentation\u003c/a\u003e.\u003c/em\u003e\u003c/p\u003e\u003ch2 id=\"what-s-next-upcoming-javascript-regex-improvements\"\u003eWhat’s Next? Upcoming JavaScript Regex Improvements\u003c/h2\u003e\u003cp\u003eThere are a variety of active proposals for improving regexes in JavaScript. Below, we’ll look at the three that are well on their way to being included in future editions of the language.\u003c/p\u003e\u003ch3 id=\"duplicate-named-capturing-groups\"\u003eDuplicate Named Capturing Groups\u003c/h3\u003e\u003cp\u003eThis is a Stage 3 (nearly finalized) \u003ca href=\"https://github.com/tc39/proposal-duplicate-named-capturing-groups\"\u003eproposal\u003c/a\u003e. Even better is that, as of recently, it works in all major browsers.\u003c/p\u003e\u003cp\u003eWhen named capturing was first introduced, it required that all \u003ccode\u003e(?\u0026lt;name\u0026gt;...)\u003c/code\u003e captures use unique names. However, there are cases when you have multiple alternate paths through a regex, and it would simplify your code to reuse the same group names in each alternative.\u003c/p\u003e\u003cp\u003eFor example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/(?\u0026lt;year\u0026gt;\\d{4})-\\d\\d|\\d\\d-(?\u0026lt;year\u0026gt;\\d{4})/\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis proposal enables exactly this, preventing a “duplicate capture group name” error with this example. Note that names must still be unique \u003cem\u003ewithin\u003c/em\u003e each alternative path.\u003c/p\u003e\u003ch3 id=\"pattern-modifiers-aka-flag-groups\"\u003ePattern Modifiers (aka Flag Groups)\u003c/h3\u003e\u003cp\u003eThis is another Stage 3 \u003ca href=\"https://github.com/tc39/proposal-regexp-modifiers\"\u003eproposal\u003c/a\u003e. It’s already supported in Chrome/Edge 125 and Opera 111, and it’s coming \u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1899813\"\u003esoon\u003c/a\u003e for Firefox. No word \u003ca href=\"https://bugs.webkit.org/show_bug.cgi?id=275672\"\u003eyet\u003c/a\u003e on Safari.\u003c/p\u003e\u003cp\u003ePattern modifiers use \u003ccode\u003e(?ims:...)\u003c/code\u003e, \u003ccode\u003e(?-ims:...)\u003c/code\u003e, or \u003ccode\u003e(?im-s:...)\u003c/code\u003e to turn the flags \u003ccode\u003ei\u003c/code\u003e, \u003ccode\u003em\u003c/code\u003e, and \u003ccode\u003es\u003c/code\u003e on or off for only certain parts of a regex.\u003c/p\u003e\u003cp\u003eFor example:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/hello-(?i:world)/\n// Matches \u0026#39;hello-WORLD\u0026#39; but not \u0026#39;HELLO-WORLD\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"escape-regex-special-characters-with-regexp-escape\"\u003eEscape Regex Special Characters with \u003ccode\u003eRegExp.escape\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eThis \u003ca href=\"https://github.com/tc39/proposal-regex-escaping\"\u003eproposal\u003c/a\u003e recently reached Stage 3 and has been a long time coming. It isn’t yet supported in any major browsers. The proposal does what it says on the tin, providing the function \u003ccode\u003eRegExp.escape(str)\u003c/code\u003e, which returns the string with all regex special characters escaped so you can match them literally.\u003c/p\u003e\u003cp\u003eIf you need this functionality today, the most widely-used package (with more than 500 million monthly npm downloads) is \u003ca href=\"https://github.com/sindresorhus/escape-string-regexp\"\u003eescape-string-regexp\u003c/a\u003e, an ultra-lightweight, single-purpose utility that does minimal escaping. That’s great for most cases, but if you need assurance that your escaped string can safely be used at any arbitrary position within a regex, \u003ccode\u003eescape-string-regexp\u003c/code\u003e recommends the \u003ccode\u003eregex\u003c/code\u003e library that we’ve already looked at in this article. The \u003ccode\u003eregex\u003c/code\u003e library uses interpolation to escape embedded strings in a \u003ca href=\"https://github.com/slevithan/regex#interpolating-escaped-strings\"\u003econtext-aware way\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eSo there you have it: the past, present, and future of JavaScript regular expressions.\u003c/p\u003e\u003cp\u003eIf you want to journey even deeper into the lands of regex, check out \u003ca href=\"https://github.com/slevithan/awesome-regex\"\u003eAwesome Regex\u003c/a\u003e for a list of the best regex testers, tutorials, libraries, and other resources. And for a fun regex crossword puzzle, try your hand at \u003ca href=\"https://regexle.com/\"\u003eregexle\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eMay your parsing be prosperous and your regexes be readable.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": "2024-08-20T15:00:00Z",
  "modifiedTime": "2024-08-20T15:00:00Z"
}
