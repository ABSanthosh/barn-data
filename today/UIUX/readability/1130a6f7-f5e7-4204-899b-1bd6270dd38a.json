{
  "id": "1130a6f7-f5e7-4204-899b-1bd6270dd38a",
  "title": "Vibe coding tips for product designers",
  "link": "https://uxdesign.cc/9-vibe-coding-tips-for-product-designers-by-benhur-cb19ce37facf?source=rss----138adf9c44c---4",
  "description": "",
  "author": "Benhur Senabathi",
  "published": "Mon, 24 Mar 2025 22:57:42 GMT",
  "source": "https://uxdesign.cc/feed",
  "categories": [
    "ux",
    "prototyping",
    "programming",
    "ai",
    "product-design"
  ],
  "byline": "Benhur Senabathi",
  "length": 10573,
  "excerpt": "9 tips to get you ready and going to build that prototype using AI tools. Written for designers by designer.",
  "siteName": "UX Collective",
  "favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*dn6MbbIIlwobt0jnUcrt_Q.png",
  "text": "Vibe coding tips for product designersVibe coding is not there yet for production-ready code. This article will focus on how product designers can get the most out of the new generation of AI IDE tools that have LLMs integrated in them for prototyping and building smaller, less complex apps.Image from flux model — Krea AIStart in a simple tool and jump to cursor or windsurfTools like Bolt, v0, and Lovable are the best when it comes to starting a project (except if you’re building in Swift for iOS). It creates a repository of necessary files, runs all the necessary project setup commands, and creates the dependencies for front-end and back-end. This initial setup is often the most intimidating barrier that prevents designers from venturing into coding,g and these tools can automate most of the challenges at this stage.Lovable/v0/Bolt: Ideal for design-focused work with strong UI capabilities for building landing pages, small flows with mock data and quick prototypes of your idea — uses Tailwind, Shadcn or other source libraries and design systems.Cursor/Windsurf: Best for complex projects where you want to build a prototype with more logic, data, API and algorithms.Once you’re happy with the initial draft, You can export the code from these tools to build it more on Cursor / Windsurf.Use powerful models to break down PRD.PRD — Product Requirements Document outlines the requirements, features, functionality, and behavior of a product. When building a feature, asking the LLM to break it down into smaller steps so its easier to implement them is key.Got a big, complex feature that you want to build? Imagine how you would explain it to your colleague. You will try to break it down into multiple parts of the journey, break it down into flows, into screens and into elements. This is the level of detail that should get you to “one-shot” features; which means, you get a highly usable output with the first attempt or prompt.The first prompt is the most important in Cursor as it sets the base for whole context and knowledge foundation for the AI model. Use powerful models like Claude Sonnet or ChatGPT 4.5 (as of writing) to explain what you are trying to build, why it will be useful, and how you want it broken down. Precisely like how you would explain it to another human.This prompting technique from Twitter user (https://x.com/benhylak) works really well in most scenarios to build PRD. You can also have a look at the original post.Credits (https://x.com/benhylak)Know thyself — Know your code.In the initial stages, as you use Cursor, try to read some code. Ask the AI tool what a few code snippet does even if you don’t understand it. Try to get familiar with the codebase. You can ask Cursor something like,“What are the most important functions and code snippets for me to get familiar with the codebase”?You can also select a chunk of code and chat with AI asking more questions about it. I would recommend doing this as it helps you troubleshoot easily as your project grows with more complex features.Selecting a chunk of code to chat with AIAt that stage, knowing your codebase will help you overcome blockers by guiding the AI toward the solution rather than hoping for the best while going back and forth in circles (what I call the ‘prompt circus’) without making progress.Prompting techniquesThis is the most important tip. If you don’t want to read the rest, make sure to just read this one.When building out a feature, ask the AI to ask clarifying questions after every prompt. This helps build additional context. It’s like talking to a colleague once again, the back-and-forth questioning and answering helps build context around the problem, feature for you and the AI model which makes the results much more correct without having to troubleshoot too much.Another prompt for bug fixing is, before trying to code, reflect on 5–7 different sources of the problem, distill those down to 1–2 most likely sources, and then add logs to validate your assumptions before we move onto implementing the actual code fix. This prompt works really well when you’re getting stuck with errors and the AI keeps circling back or breaking your code / deleting important parts (Hence its very important to know your code).Use your design tool knowledge: When trying to make front-end changes, try to be very specific. For example: Don’t just say “move the button to the centre with some spacing from text field” but say “Move the button relative to the text field component and space it 4px from the left. It should be fixed in its width”.Use @. In Cursor and Windsurf, for example: You can reference exact files or even folders by typing @fileorfoldername. This approach offers several advantages: it helps the AI narrow its context to specific files and conserves your credits.Linking a file in Cursor / Windsurf chat windowUse @web or paste web links to give more context to the AI. If you’ve found a good solution online for your problem or if the language has proper syntax that’s published online (like Apple developer guidelines for Swift and SwiftUI), you can link this in your prompt to help it solve a problem.Lighter context window gets faster solutions.A context window in AI is like the model’s short-term memory. It refers to the amount of information (text, image, code) that the AI can “see” and remember and work with.Creating a new chat window once context becomes too long — Windsurf IDEThe lighter this is, the faster and cheaper it is to get good quality solutions. Always try to create a new chat by clicking on the + on top in Cursor or Windsurf when your chat starts to get longer or when you’ve successfully completed a feature and, the next feature or implementation doesn’t require context from this current chat window.Learn to use Git.Just like how we use version control and have branching systems in figma (if you’ve been working with a design system), learning to version control and perform big changes in a branch on your code is very important. It takes less than 5 seconds to do this once you’re set up with Github and Cursor and I recommend to do this as often as possible after every feature implementation or bug fixes that you’re happy with.This ensures, in the worst-case scenario, your AI deletes something important, you can always go back to an older version and prevent lots of heartache (speaking from experience as someone who didn’t know to use it properly before).Don’t overthink. You can do all of this on Cursor directly. The below points are more than enough for a good start and will help you revert back in case something goes wrong.Commit changes after each successful feature implementation.Write descriptive commit messages that explain what changed and why so you know which implementation to roll back to when things go wrong.Committing and saving changes in local repository. You can then connect your Github and push changesUse overarching rules and project documentation.On Cursor and Windsurf you can set high-level rules. This ensures that every prompt you make will consider this master rule and try to accommodate this (I’ve found it doesn’t work sometimes but mostly it does)Project documentation is extremely important from the start. This tip works well with “Know your code” tip as you start to build a mini database of valuable information in markdown (md) files. I generally ask Claude Sonnet or Cursor to create a database.md, appflow.md and more (according to my project) and ask it to fill it with the codebase as a guide. This md files are made to be human readable which is useful to help you get acquainted with the code.Both human and AI readable that contains project informationYou can then reference these files using @filename prompting technique. So the flow becomesStart a new composer (at this point, the AI has very little context on what you are trying to do)Type your prompt with good context setting (as discussed previously)Use @ to reference your project documentation along with any files if you can map them.Once you are done with the implementation, make sure to tell the AI to update the relevant markdown files with the new implementation logic and guidance. This ensures our project documentation always stays up-to date and is the source of truth if we want to reference and learn more about our codebaseProject documentation becomes important the more features you are piling up and more logic your app has to depend on. At some point, the AI model will struggle going through all your files and becomes “lazy” with less context window. At this point, referencing project documentation has worked really well for me.Bringing custom design from figma to code.Many of us, we want to vibe code with our own design that we sketched on figma. To get here, I’ve found to shift the mindset from thinking of figma as a sketch book and switch to a very production focussed mindset. Name layers, create auto-layouts (most important tip for getting good code when you use dev mode), name your components, Create clean, logical hierarchies in your layers, add proper constraints.figma dev mode code to AI toolsYou can use dev mode to export code and then bring this into cursor and ask the AI to integrate the feature with the custom UI. This takes a few trial and error iterations.You can also use plugins with open AI and Anthropic APIs to achieve this code export and then paste the exported code into cursor to integrate in your project / feature (You can find how to do this online).Iterate using specific UI focussed prompts once you get the basic UI / code in place.For small changes, tweak it manually. Don’t use AI.Tweaking smaller changes manually is faster, Use your design knowledge. Instead of trying to prompt everything, once you’ve built a good understanding of your project space, you can change values for UI iterations (shadows, color hex values, gradients, corner radius and more) by yourself and look at the preview to finalise your decision. This saves massive time and even credits instead of asking the AI to “Change the corner radius from 24 to 28” when the context window is already less and the AI is struggling to keep up with new requests. It might also mess up and change unintended code which could break your app.This is by no means an exhaustive list. These are just some lessons I learned over the last few months as I tried these tools to build complex prototypes and ship products. There’s still so much to learn and improve in terms of workflow. Hope these help on your vibe coding journey.And remember to have fun!",
  "image": "https://miro.medium.com/v2/resize:fit:1200/1*hSKUALKiTraD1Um_3Odicw.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003e\u003ch2 id=\"3a71\" data-testid=\"storyTitle\"\u003eVibe coding tips for product designers\u003c/h2\u003e\u003c/p\u003e\u003cdiv\u003e\u003ch2 id=\"4042\"\u003eVibe coding is not there yet for production-ready code. This article will focus on how product designers can get the most out of the new generation of AI IDE tools that have LLMs integrated in them for prototyping and building smaller, less complex apps.\u003c/h2\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://imbenhur.medium.com/?source=post_page---byline--cb19ce37facf---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Benhur Senabathi\" src=\"https://miro.medium.com/v2/resize:fill:88:88/1*_hArM3e9Sk4WQvpafq6eaw.jpeg\" width=\"44\" height=\"44\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca href=\"https://uxdesign.cc/?source=post_page---byline--cb19ce37facf---------------------------------------\" rel=\"noopener follow\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"UX Collective\" src=\"https://miro.medium.com/v2/resize:fill:48:48/1*mDhF9X4VO0rCrJvWFatyxg.png\" width=\"24\" height=\"24\" loading=\"lazy\" data-testid=\"publicationPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cfigure\u003e\u003cfigcaption\u003eImage from flux model — Krea AI\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"2290\"\u003eStart in a simple tool and jump to cursor or windsurf\u003c/h2\u003e\u003cp id=\"9a2b\"\u003eTools like Bolt, v0, and Lovable are the best when it comes to starting a project (except if you’re building in Swift for iOS). It creates a repository of necessary files, runs all the necessary project setup commands, and creates the dependencies for front-end and back-end. This initial setup is often the most intimidating barrier that prevents designers from venturing into coding,g and these tools can automate most of the challenges at this stage.\u003c/p\u003e\u003cul\u003e\u003cli id=\"6386\"\u003eLovable/v0/Bolt: Ideal for design-focused work with strong UI capabilities for building landing pages, small flows with mock data and quick prototypes of your idea — uses Tailwind, Shadcn or other source libraries and design systems.\u003c/li\u003e\u003cli id=\"83d6\"\u003eCursor/Windsurf: Best for complex projects where you want to build a prototype with more logic, data, API and algorithms.\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"99ca\"\u003eOnce you’re happy with the initial draft, You can export the code from these tools to build it more on Cursor / Windsurf.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"7283\"\u003eUse powerful models to break down PRD.\u003c/h2\u003e\u003cp id=\"008f\"\u003ePRD — Product Requirements Document outlines the requirements, features, functionality, and behavior of a product. When building a feature, asking the LLM to break it down into smaller steps so its easier to implement them is key.\u003c/p\u003e\u003cp id=\"12d0\"\u003eGot a big, complex feature that you want to build? Imagine how you would explain it to your colleague. You will try to break it down into multiple parts of the journey, break it down into flows, into screens and into elements. This is the level of detail that should get you to “one-shot” features; which means, you get a highly usable output with the first attempt or prompt.\u003c/p\u003e\u003cp id=\"66e2\"\u003eThe first prompt is the most important in Cursor as it sets the base for whole context and knowledge foundation for the AI model. Use powerful models like Claude Sonnet or ChatGPT 4.5 (as of writing) to explain what you are trying to build, why it will be useful, and how you want it broken down. Precisely like how you would explain it to another human.\u003c/p\u003e\u003cp id=\"e4ad\"\u003eThis prompting technique from Twitter user (\u003ca href=\"https://x.com/benhylak\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://x.com/benhylak\u003c/a\u003e) works really well in most scenarios to build PRD. You can also have a look at the original \u003ca href=\"https://www.latent.space/p/o1-skill-issue\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003epost\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCredits (\u003ca href=\"https://x.com/benhylak\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://x.com/benhylak\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"358d\"\u003eKnow thyself — Know your code.\u003c/h2\u003e\u003cp id=\"0c47\"\u003eIn the initial stages, as you use Cursor, try to read some code. Ask the AI tool what a few code snippet does even if you don’t understand it. Try to get familiar with the codebase. You can ask Cursor something like,\u003c/p\u003e\u003cblockquote\u003e\u003cp id=\"c60d\"\u003e“What are the most important functions and code snippets for me to get familiar with the codebase”?\u003c/p\u003e\u003c/blockquote\u003e\u003cp id=\"5cea\"\u003eYou can also select a chunk of code and chat with AI asking more questions about it. I would recommend doing this as it helps you troubleshoot easily as your project grows with more complex features.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eSelecting a chunk of code to chat with AI\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"9339\"\u003eAt that stage, knowing your codebase will help you overcome blockers by guiding the AI toward the solution rather than hoping for the best while going back and forth in circles (what I call the ‘prompt circus’) without making progress.\u003c/p\u003e\u003ch2 id=\"3370\"\u003ePrompting techniques\u003c/h2\u003e\u003ch2 id=\"3bc9\"\u003eThis is the most important tip. If you don’t want to read the rest, make sure to just read this one.\u003c/h2\u003e\u003col\u003e\u003cli id=\"6747\"\u003eWhen building out a feature, ask the AI to \u003cstrong\u003eask clarifying questions\u003c/strong\u003e after every prompt. This helps build additional context. It’s like talking to a colleague once again, the back-and-forth questioning and answering helps build context around the problem, feature for you and the AI model which makes the results much more correct without having to troubleshoot too much.\u003c/li\u003e\u003cli id=\"d271\"\u003eAnother prompt for bug fixing is, \u003cstrong\u003ebefore trying to code, reflect on 5–7 different sources of the problem, distill those down to 1–2 most likely sources, and then add logs to validate your assumptions before we move onto implementing the actual code fix.\u003c/strong\u003e This prompt works really well when you’re getting stuck with errors and the AI keeps circling back or breaking your code / deleting important parts (Hence its very important to know your code).\u003c/li\u003e\u003cli id=\"e291\"\u003eUse your design tool knowledge: When trying to make front-end changes, try to be very specific. For example: \u003cstrong\u003eDon’t just say “move the button to the centre with some spacing from text field” but say “Move the button relative to the text field component and space it 4px from the left. It should be fixed in its width”.\u003c/strong\u003e\u003c/li\u003e\u003cli id=\"292c\"\u003eUse @. In Cursor and Windsurf, for example: \u003cstrong\u003eYou can reference exact files or even folders by typing @fileorfoldername.\u003c/strong\u003e This approach offers several advantages: it helps the AI narrow its context to specific files and conserves your credits.\u003c/li\u003e\u003c/ol\u003e\u003cfigure\u003e\u003cfigcaption\u003eLinking a file in Cursor / Windsurf chat window\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"c6bc\"\u003eUse @web or paste web links to give more context to the AI. If you’ve found a good solution online for your problem or if the language has proper syntax that’s published online (like Apple developer guidelines for Swift and SwiftUI), you can link this in your prompt to help it solve a problem.\u003c/p\u003e\u003ch2 id=\"4806\"\u003eLighter context window gets faster solutions.\u003c/h2\u003e\u003cp id=\"1eed\"\u003eA context window in AI is like the model’s short-term memory. It refers to the amount of information (text, image, code) that the AI can “see” and remember and work with.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eCreating a new chat window once context becomes too long — Windsurf IDE\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"f953\"\u003eThe lighter this is, the faster and cheaper it is to get good quality solutions. Always try to create a new chat by clicking on the + on top in Cursor or Windsurf when your chat starts to get longer or when you’ve successfully completed a feature and, the next feature or implementation doesn’t require context from this current chat window.\u003c/p\u003e\u003ch2 id=\"90a4\"\u003eLearn to use Git.\u003c/h2\u003e\u003cp id=\"b520\"\u003eJust like how we use version control and have branching systems in figma (if you’ve been working with a design system), learning to version control and perform big changes in a branch on your code is very important. It takes less than 5 seconds to do this once you’re set up with Github and Cursor and I recommend to do this as often as possible after every feature implementation or bug fixes that you’re happy with.\u003c/p\u003e\u003cp id=\"3530\"\u003eThis ensures, in the worst-case scenario, your AI deletes something important, you can always go back to an older version and prevent lots of heartache (speaking from experience as someone who didn’t know to use it properly before).\u003c/p\u003e\u003cp id=\"f819\"\u003eDon’t overthink. You can do all of this on Cursor directly. The below points are more than enough for a good start and will help you revert back in case something goes wrong.\u003c/p\u003e\u003cul\u003e\u003cli id=\"30bd\"\u003eCommit changes after each successful feature implementation.\u003c/li\u003e\u003cli id=\"b4fa\"\u003eWrite descriptive commit messages that explain what changed and why so you know which implementation to roll back to when things go wrong.\u003c/li\u003e\u003c/ul\u003e\u003cfigure\u003e\u003cfigcaption\u003eCommitting and saving changes in local repository. You can then connect your Github and push changes\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"a374\"\u003eUse overarching rules and project documentation.\u003c/h2\u003e\u003cp id=\"0481\"\u003eOn Cursor and Windsurf you can set high-level rules. This ensures that every prompt you make will consider this master rule and try to accommodate this (I’ve found it doesn’t work sometimes but mostly it does)\u003c/p\u003e\u003cp id=\"9759\"\u003eProject documentation is extremely important from the start. This tip works well with “Know your code” tip as you start to build a mini database of valuable information in markdown (md) files. I generally ask Claude Sonnet or Cursor to create a database.md, appflow.md and more (according to my project) and ask it to fill it with the codebase as a guide. This md files are made to be human readable which is useful to help you get acquainted with the code.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003eBoth human and AI readable that contains project information\u003c/figcaption\u003e\u003c/figure\u003e\u003cp id=\"ce94\"\u003eYou can then reference these files using \u003ca href=\"http://twitter.com/filename\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@filename\u003c/a\u003e prompting technique. So the flow becomes\u003c/p\u003e\u003col\u003e\u003cli id=\"8a83\"\u003eStart a new composer (at this point, the AI has very little context on what you are trying to do)\u003c/li\u003e\u003cli id=\"1c0c\"\u003eType your prompt with good context setting (as discussed previously)\u003c/li\u003e\u003cli id=\"9d2e\"\u003eUse @ to reference your project documentation along with any files if you can map them.\u003c/li\u003e\u003cli id=\"7489\"\u003eOnce you are done with the implementation, make sure to tell the AI to update the relevant markdown files with the new implementation logic and guidance. This ensures our project documentation always stays up-to date and is the source of truth if we want to reference and learn more about our codebase\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"c290\"\u003eProject documentation becomes important the more features you are piling up and more logic your app has to depend on. At some point, the AI model will struggle going through all your files and becomes “lazy” with less context window. At this point, referencing project documentation has worked really well for me.\u003c/p\u003e\u003ch2 id=\"8031\"\u003eBringing custom design from figma to code.\u003c/h2\u003e\u003cp id=\"0adf\"\u003eMany of us, we want to vibe code with our own design that we sketched on figma. To get here, I’ve found to shift the mindset from thinking of figma as a sketch book and switch to a very production focussed mindset. Name layers, create auto-layouts (most important tip for getting good code when you use dev mode), name your components, Create clean, logical hierarchies in your layers, add proper constraints.\u003c/p\u003e\u003cfigure\u003e\u003cfigcaption\u003efigma dev mode code to AI tools\u003c/figcaption\u003e\u003c/figure\u003e\u003cul\u003e\u003cli id=\"78b1\"\u003eYou can use dev mode to export code and then bring this into cursor and ask the AI to integrate the feature with the custom UI. This takes a few trial and error iterations.\u003c/li\u003e\u003cli id=\"5569\"\u003eYou can also use plugins with open AI and Anthropic APIs to achieve this code export and then paste the exported code into cursor to integrate in your project / feature (You can find how to do this online).\u003c/li\u003e\u003cli id=\"4c9c\"\u003eIterate using specific UI focussed prompts once you get the basic UI / code in place.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"f736\"\u003eFor small changes, tweak it manually. Don’t use AI.\u003c/h2\u003e\u003cp id=\"d478\"\u003eTweaking smaller changes manually is faster, Use your design knowledge. Instead of trying to prompt everything, once you’ve built a good understanding of your project space, you can change values for UI iterations (shadows, color hex values, gradients, corner radius and more) by yourself and look at the preview to finalise your decision. This saves massive time and even credits instead of asking the AI to “Change the corner radius from 24 to 28” when the context window is already less and the AI is struggling to keep up with new requests. It might also mess up and change unintended code which could break your app.\u003c/p\u003e\u003cp id=\"486a\"\u003eThis is by no means an exhaustive list. These are just some lessons I learned over the last few months as I tried these tools to build complex prototypes and ship products. There’s still so much to learn and improve in terms of workflow. Hope these help on your vibe coding journey.\u003c/p\u003e\u003cp id=\"63ae\"\u003eAnd remember to have fun!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "12 min read",
  "publishedTime": "2025-03-24T22:57:42.507Z",
  "modifiedTime": null
}
