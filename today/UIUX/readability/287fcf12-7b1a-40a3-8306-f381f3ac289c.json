{
  "id": "287fcf12-7b1a-40a3-8306-f381f3ac289c",
  "title": "Sticky Headers And Full-Height Elements: A Tricky Combination",
  "link": "https://smashingmagazine.com/2024/09/sticky-headers-full-height-elements-tricky-combination/",
  "description": "Sticky positioning is one of those CSS features that’s pretty delicate and can be negated by a lot of things, so here’s another one to add to your mental catalog: Sticky elements don’t play nicely if they have to coordinate with other elements to make up a combined height, like `100vh`. Philip Braunen explores why this happens and presents a solution to fix it.",
  "author": "Philip Braunen",
  "published": "Thu, 05 Sep 2024 09:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 10085,
  "excerpt": "Sticky positioning is one of those CSS features that’s pretty delicate and can be negated by a lot of things, so here’s another one to add to your mental catalog: Sticky elements don’t play nicely if they have to coordinate with other elements to make up a combined height, like `100vh`. Philip Braunen explores why this happens and presents a solution to fix it.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "8 min readCSS, Tools, TechniquesSticky positioning is one of those CSS features that’s pretty delicate and can be negated by a lot of things, so here’s another one to add to your mental catalog: Sticky elements don’t play nicely if they have to coordinate with other elements to make up a combined height, like 100vh. Philip Braunen explores why this happens and presents a solution to fix it.I was recently asked by a student to help with a seemingly simple problem. She’d been working on a website for a coffee shop that sports a sticky header, and she wanted the hero section right underneath that header to span the rest of the available vertical space in the viewport.Here’s a visual demo of the desired effect for clarity.Looks like it should be easy enough, right? I was sure (read: overconfident) that the problem would only take a couple of minutes to solve, only to find it was a much deeper well than I’d assumed.Before we dive in, let’s take a quick look at the initial markup and CSS to see what we’re working with:\u003cbody\u003e \u003cheader class=\"header\"\u003eHeader Content\u003c/header\u003e \u003csection class=\"hero\"\u003eHero Content\u003c/section\u003e \u003cmain class=\"main\"\u003eMain Content\u003c/main\u003e \u003c/body\u003e .header { position: sticky; top: 0; /* Offset, otherwise it won't stick! */ } /* etc. */ With those declarations, the .header will stick to the top of the page. And yet the .hero element below it remains intrinsically sized. This is what we want to change.The Low-Hanging FruitThe first impulse you might have, as I did, is to enclose the header and hero in some sort of parent container and give that container 100vh to make it span the viewport. After that, we could use Flexbox to distribute the children and make the hero grow to fill the remaining space.\u003cbody\u003e \u003cdiv class=\"container\"\u003e \u003cheader class=\"header\"\u003eHeader Content\u003c/header\u003e \u003csection class=\"hero\"\u003eHero Content\u003c/section\u003e \u003c/div\u003e \u003cmain class=\"main\"\u003eMain Content\u003c/main\u003e \u003c/body\u003e .container { height: 100vh; display: flex; flex-direction: column; } .hero { flex-grow: 1; } /* etc. */ This looks correct at first glance, but watch what happens when scrolling past the hero.See the Pen [Attempt #1: Container + Flexbox [forked]](https://codepen.io/smashingmag/pen/yLdQgQo) by Philip.See the Pen Attempt #1: Container + Flexbox [forked] by Philip.The sticky header gets trapped in its parent container! But.. why?If you’re anything like me, this behavior is unintuitive, at least initially. You may have heard that sticky is a combination of relative and fixed positioning, meaning it participates in the normal flow of the document but only until it hits the edges of its scrolling container, at which point it becomes fixed. While viewing sticky as a combination of other values can be a useful mnemonic, it fails to capture one important difference between sticky and fixed elements:A position: fixed element doesn’t care about the parent it’s nested in or any of its ancestors. It will break out of the normal flow of the document and place itself directly offset from the viewport, as though glued in place a certain distance from the edge of the screen.Conversely, a position: sticky element will be pushed along with the edges of the viewport (or next closest scrolling container), but it will never escape the boundaries of its direct parent. Well, at least if you don’t count visually transform-ing it. So a better way to think about it might be, to steal from Chris Coyier, that “position: sticky is, in a sense, a locally scoped position: fixed.” This is an intentional design decision, one that allows for section-specific sticky headers like the ones made famous by alphabetical lists in mobile interfaces.See the Pen [Sticky Section Headers [forked]](https://codepen.io/smashingmag/pen/OJeaWrM) by Philip.See the Pen Sticky Section Headers [forked] by Philip.Okay, so this approach is a no-go for our predicament. We need to find a solution that doesn’t involve a container around the header.Fixed, But Not SolvedMaybe we can make our lives a bit simpler. Instead of a container, what if we gave the .header element a fixed height of, say, 150px? Then, all we have to do is define the .hero element’s height as height: calc(100vh - 150px).See the Pen [Attempt #2: Fixed Height + Calc() [forked]](https://codepen.io/smashingmag/pen/yLdQgGz) by Philip.See the Pen Attempt #2: Fixed Height + Calc() [forked] by Philip.This approach kinda works, but the downsides are more insidious than our last attempt because they may not be immediately apparent. You probably noticed that the header is too tall, and we’d wanna do some math to decide on a better height.Thinking ahead a bit,What if the .header’s children need to wrap or rearrange themselves at different screen sizes or grow to maintain legibility on mobile?What if JavaScript is manipulating the contents?All of these things could subtly change the .header’s ideal size, and chasing the right height values for each scenario has the potential to spiral into a maintenance nightmare of unmanageable breakpoints and magic numbers — especially if we consider this needs to be done not only for the .header but also the .hero element that depends on it.I would argue that this workaround also just feels wrong. Fixed heights break one of the main affordances of CSS layout — the way elements automatically grow and shrink to adapt to their contents — and not relying on this usually makes our lives harder, not simpler.So, we’re left with…A Novel ApproachNow that we’ve figured out the constraints we’re working with, another way to phrase the problem is that we want the .header and .hero to collectively span 100vh without sizing the elements explicitly or wrapping them in a container. Ideally, we’d find something that already is 100vh and align them to that. This is where it dawned on me that display: grid may provide just what we need!Let’s try this: We declare display: grid on the body element and add another element before the .header that we’ll call .above-the-fold-spacer. This new element gets a height of 100vh and spans the grid’s entire width. Next, we’ll tell our spacer that it should take up two grid rows and we’ll anchor it to the top of the page.This element must be entirely empty because we don’t ever want it to be visible or to register to screen readers. We’re merely using it as a crutch to tell the grid how to behave.\u003cbody\u003e \u003c!-- This spacer provides the height we want --\u003e \u003cdiv class=\"above-the-fold-spacer\"\u003e\u003c/div\u003e \u003c!-- These two elements will place themselves on top of the spacer --\u003e \u003cheader class=\"header\"\u003eHeader Content\u003c/header\u003e \u003csection class=\"hero\"\u003eHero Content\u003c/section\u003e \u003c!-- The rest of the page stays unaffected --\u003e \u003cmain class=\"main\"\u003eMain Content\u003c/main\u003e \u003c/body\u003e body { display: grid; } .above-the-fold-spacer { height: 100vh; /* Span from the first to the last grid column line */ /* (Negative numbers count from the end of the grid) */ grid-column: 1 / -1; /* Start at the first grid row line, and take up 2 rows */ grid-row: 1 / span 2; } /* etc. */ This is the magic ingredient.By adding the spacer, we’ve created two grid rows that together take up exactly 100vh. Now, all that’s left to do, in essence, is to tell the .header and .hero elements to align themselves to those existing rows. We do have to tell them to start at the same grid column line as the .above-the-fold-spacer element so that they won’t try to sit next to it. But with that done… ta-da!See the Pen [The Solution: Grid Alignment [forked]](https://codepen.io/smashingmag/pen/YzoRNdo) by Philip.See the Pen The Solution: Grid Alignment [forked] by Philip.The reason this works is that a grid container can have multiple children occupying the same cell overlaid on top of each other. In a situation like that, the tallest child element defines the grid row’s overall height — or, in this case, the combined height of the two rows (100vh).To control how exactly the two visible elements divvy up the available space between themselves, we can use the grid-template-rows property. I made it so that the first row uses min-content rather than 1fr. This is necessary so that the .header doesn’t take up the same amount of space as the .hero but instead only takes what it needs and lets the hero have the rest.Here’s our full solution: body { display: grid; grid-template-rows: min-content 1fr; } .above-the-fold-spacer { height: 100vh; grid-column: 1 / -1; grid-row: 1 / span 2; } .header { position: sticky; top: 0; grid-column-start: 1; grid-row-start: 1; } .hero { grid-column-start: 1; grid-row-start: 2; } And voila: A sticky header of arbitrary size above a hero that grows to fill the remaining visible space!Caveats and Final ThoughtsIt’s worth noting that the HTML order of the elements matters here. If we define .above-the-fold-spacer after our .hero section, it will overlay and block access to the elements underneath. We can work around this by declaring either order: -1, z-index: -1, or visibility: hidden.Keep in mind that this is a simple example. If you were to add a sidebar to the left of your page, for example, you’d need to adjust at which column the elements start. Still, in the majority of cases, using a CSS Grid approach is likely to be less troublesome than the Sisyphean task of manually managing and coordinating the height values of multiple elements.Another upside of this approach is that it’s adaptable. If you decide you want a group of three elements to take up the screen’s height rather than two, then you’d make the invisible spacer span three rows and assign the visible elements to the appropriate one. Even if the hero element’s content causes its height to exceed 100vh, the grid adapts without breaking anything. It’s even well-supported in all modern browsers.The more I think about this technique, the more I’m persuaded that it’s actually quite clean. Then again, you know how lawyers can talk themselves into their own arguments? If you can think of an even simpler solution I’ve overlooked, feel free to reach out and let me know! (gg, yk)",
  "image": "https://files.smashing.media/articles/sticky-headers-full-height-elements-tricky-combination/sticky-headers-full-height-elements-tricky-combination.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e8 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/css\"\u003eCSS\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/tools\"\u003eTools\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eSticky positioning is one of those CSS features that’s pretty delicate and can be negated by a lot of things, so here’s another one to add to your mental catalog: Sticky elements don’t play nicely if they have to coordinate with other elements to make up a combined height, like \u003ccode\u003e100vh\u003c/code\u003e. Philip Braunen explores why this happens and presents a solution to fix it.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eI was recently asked by a student to help with a \u003cem\u003eseemingly\u003c/em\u003e simple problem. She’d been working on a website for a coffee shop that sports a sticky header, and she wanted the hero section right underneath that header to span the rest of the available vertical space in the viewport.\u003c/p\u003e\u003cp\u003eHere’s a visual demo of the desired effect for clarity.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp\u003eLooks like it should be easy enough, right? I was sure (read: overconfident) that the problem would only take a couple of minutes to solve, only to find it was a much deeper well than I’d assumed.\u003c/p\u003e\u003cp\u003eBefore we dive in, let’s take a quick look at the initial markup and CSS to see what we’re working with:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;body\u0026gt;\n  \u0026lt;header class=\u0026#34;header\u0026#34;\u0026gt;Header Content\u0026lt;/header\u0026gt;\n  \u0026lt;section class=\u0026#34;hero\u0026#34;\u0026gt;Hero Content\u0026lt;/section\u0026gt;\n  \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt;Main Content\u0026lt;/main\u0026gt;\n\u0026lt;/body\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e.header {\n  position: sticky;\n  top: 0; /* Offset, otherwise it won\u0026#39;t stick! */\n}\n\n/* etc. */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith those declarations, the \u003ccode\u003e.header\u003c/code\u003e will stick to the top of the page. And yet the \u003ccode\u003e.hero\u003c/code\u003e element below it remains intrinsically sized. This is what we want to change.\u003c/p\u003e\u003ch2 id=\"the-low-hanging-fruit\"\u003eThe Low-Hanging Fruit\u003c/h2\u003e\u003cp\u003eThe first impulse you might have, as I did, is to enclose the header and hero in some sort of parent container and give that container \u003ccode\u003e100vh\u003c/code\u003e to make it span the viewport. After that, we could use Flexbox to distribute the children and make the hero grow to fill the remaining space.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;body\u0026gt;\n  \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt;\n    \u0026lt;header class=\u0026#34;header\u0026#34;\u0026gt;Header Content\u0026lt;/header\u0026gt;\n    \u0026lt;section class=\u0026#34;hero\u0026#34;\u0026gt;Hero Content\u0026lt;/section\u0026gt;\n  \u0026lt;/div\u0026gt;\n  \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt;Main Content\u0026lt;/main\u0026gt;\n\u0026lt;/body\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e.container {\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n}\n\n.hero {\n  flex-grow: 1;\n}\n\n/* etc. */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis looks correct at first glance, but watch what happens when scrolling past the hero.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"yLdQgQo\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Attempt #1: Container + Flexbox [forked]](https://codepen.io/smashingmag/pen/yLdQgQo) by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/yLdQgQo\"\u003eAttempt #1: Container + Flexbox [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eThe sticky header gets trapped in its parent container!\u003c/strong\u003e But.. \u003cem\u003ewhy\u003c/em\u003e?\u003c/p\u003e\u003cp\u003eIf you’re anything like me, this behavior is unintuitive, at least initially. You may have heard that \u003ca href=\"https://css-tricks.com/almanac/properties/p/position/#aa-values\"\u003e\u003ccode\u003esticky\u003c/code\u003e is a combination of \u003ccode\u003erelative\u003c/code\u003e and \u003ccode\u003efixed\u003c/code\u003e positioning\u003c/a\u003e, meaning it participates in the normal flow of the document but only until it hits the edges of its scrolling container, at which point it becomes \u003ccode\u003efixed\u003c/code\u003e. While viewing \u003ccode\u003esticky\u003c/code\u003e as a combination of other values can be a useful mnemonic, it fails to capture one important difference between \u003ccode\u003esticky\u003c/code\u003e and \u003ccode\u003efixed\u003c/code\u003e elements:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA \u003ccode\u003eposition: fixed\u003c/code\u003e element doesn’t care about the parent it’s nested in or any of its ancestors.\u003c/strong\u003e It will break out of the normal flow of the document and place itself directly offset from the viewport, as though glued in place a certain distance from the edge of the screen.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eConversely, a \u003ccode\u003eposition: sticky\u003c/code\u003e element will be pushed along with the edges of the viewport (or next closest scrolling container), but it will never escape the boundaries of its direct parent.\u003c/strong\u003e Well, at least if you don’t count visually \u003ccode\u003etransform\u003c/code\u003e-ing it. So a better way to think about it might be, \u003ca href=\"https://css-tricks.com/sticky-as-a-local-fixed/\"\u003eto steal from Chris Coyier\u003c/a\u003e, that \u003cspan\u003e“\u003ccode\u003eposition: sticky\u003c/code\u003e\u003c/span\u003e is, in a sense, a locally scoped \u003ccode\u003eposition: fixed\u003c/code\u003e.” This is an intentional design decision, one that allows for section-specific sticky headers like the ones made famous by alphabetical lists in mobile interfaces.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"OJeaWrM\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Sticky Section Headers [forked]](https://codepen.io/smashingmag/pen/OJeaWrM) by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/OJeaWrM\"\u003eSticky Section Headers [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eOkay, so this approach is a no-go for our predicament. We need to find a solution that doesn’t involve a container around the header.\u003c/p\u003e\u003ch2 id=\"fixed-but-not-solved\"\u003eFixed, But Not Solved\u003c/h2\u003e\u003cp\u003eMaybe we can make our lives a bit simpler. Instead of a container, what if we gave the \u003ccode\u003e.header\u003c/code\u003e element a \u003cem\u003efixed\u003c/em\u003e height of, say, \u003ccode\u003e150px\u003c/code\u003e? Then, all we have to do is define the \u003ccode\u003e.hero\u003c/code\u003e element’s height as \u003ccode\u003eheight: calc(100vh - 150px)\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"yLdQgGz\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Attempt #2: Fixed Height + Calc() [forked]](https://codepen.io/smashingmag/pen/yLdQgGz) by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/yLdQgGz\"\u003eAttempt #2: Fixed Height + Calc() [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThis approach \u003cem\u003ekinda\u003c/em\u003e works, but the downsides are more insidious than our last attempt because they may not be immediately apparent. You probably noticed that the header is too tall, and we’d wanna do some math to decide on a better height.\u003c/p\u003e\u003cp\u003eThinking ahead a bit,\u003c/p\u003e\u003cul\u003e\u003cli\u003eWhat if the \u003ccode\u003e.header\u003c/code\u003e’s children need to wrap or rearrange themselves at different screen sizes or grow to maintain legibility on mobile?\u003c/li\u003e\u003cli\u003eWhat if JavaScript is manipulating the contents?\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAll of these things could subtly change the \u003ccode\u003e.header\u003c/code\u003e’s ideal size, and chasing the right height values for each scenario has the potential to spiral into a maintenance nightmare of unmanageable breakpoints and magic numbers — especially if we consider this needs to be done not only for the \u003ccode\u003e.header\u003c/code\u003e but also the \u003ccode\u003e.hero\u003c/code\u003e element that depends on it.\u003c/p\u003e\u003cp\u003eI would argue that this workaround also just \u003cem\u003efeels\u003c/em\u003e wrong. Fixed heights break one of the main affordances of CSS layout — the way elements automatically grow and shrink to adapt to their contents — and not relying on this usually makes our lives \u003cem\u003eharder\u003c/em\u003e, not simpler.\u003c/p\u003e\u003cp\u003eSo, we’re left with…\u003c/p\u003e\u003ch2 id=\"a-novel-approach\"\u003eA Novel Approach\u003c/h2\u003e\u003cp\u003eNow that we’ve figured out the constraints we’re working with, another way to phrase the problem is that we want the \u003ccode\u003e.header\u003c/code\u003e and \u003ccode\u003e.hero\u003c/code\u003e to \u003cem\u003ecollectively\u003c/em\u003e span \u003ccode\u003e100vh\u003c/code\u003e without sizing the elements explicitly or wrapping them in a container. Ideally, we’d find \u003cem\u003esomething\u003c/em\u003e that already is \u003ccode\u003e100vh\u003c/code\u003e and align them to that. This is where it dawned on me that \u003ccode\u003edisplay: grid\u003c/code\u003e may provide just what we need!\u003c/p\u003e\u003cp\u003eLet’s try this: We declare \u003ccode\u003edisplay: grid\u003c/code\u003e on the \u003ccode\u003ebody\u003c/code\u003e element and add another element before the \u003ccode\u003e.header\u003c/code\u003e that we’ll call \u003ccode\u003e.above-the-fold-spacer\u003c/code\u003e. This new element gets a height of \u003ccode\u003e100vh\u003c/code\u003e and spans the grid’s entire width. Next, we’ll tell our spacer that it should take up two grid rows and we’ll anchor it to the top of the page.\u003c/p\u003e\u003cp\u003eThis element must be entirely empty because we don’t ever want it to be visible or to register to screen readers. We’re merely using it as a crutch to tell the grid how to behave.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;body\u0026gt;\n  \u0026lt;!-- This spacer provides the height we want --\u0026gt;\n  \u0026lt;div class=\u0026#34;above-the-fold-spacer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n\n  \u0026lt;!-- These two elements will place themselves on top of the spacer --\u0026gt;\n  \u0026lt;header class=\u0026#34;header\u0026#34;\u0026gt;Header Content\u0026lt;/header\u0026gt;\n  \u0026lt;section class=\u0026#34;hero\u0026#34;\u0026gt;Hero Content\u0026lt;/section\u0026gt;\n\n  \u0026lt;!-- The rest of the page stays unaffected --\u0026gt;\n  \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt;Main Content\u0026lt;/main\u0026gt;\n\u0026lt;/body\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode\u003ebody {\n  display: grid;\n}\n\n.above-the-fold-spacer {\n  height: 100vh;\n  /* Span from the first to the last grid column line */\n  /* (Negative numbers count from the end of the grid) */\n  grid-column: 1 / -1;\n  /* Start at the first grid row line, and take up 2 rows */\n  grid-row: 1 / span 2; \n}\n\n/* etc. */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cem\u003eThis\u003c/em\u003e is the magic ingredient.\u003c/p\u003e\u003cp\u003eBy adding the spacer, we’ve created two grid rows that \u003cem\u003etogether\u003c/em\u003e take up exactly \u003ccode\u003e100vh\u003c/code\u003e. Now, all that’s left to do, in essence, is to tell the \u003ccode\u003e.header\u003c/code\u003e and \u003ccode\u003e.hero\u003c/code\u003e elements to align themselves to those existing rows. We do have to tell them to start at the same grid column line as the \u003ccode\u003e.above-the-fold-spacer\u003c/code\u003e element so that they won’t try to sit next to it. But with that done… \u003cem\u003eta-da!\u003c/em\u003e\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"YzoRNdo\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [The Solution: Grid Alignment [forked]](https://codepen.io/smashingmag/pen/YzoRNdo) by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/YzoRNdo\"\u003eThe Solution: Grid Alignment [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/Phendan\"\u003ePhilip\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThe reason this works is that \u003cstrong\u003ea grid container can have multiple children occupying the same cell overlaid on top of each other\u003c/strong\u003e. In a situation like that, the tallest child element defines the grid row’s overall height — or, in this case, the combined height of the two rows (\u003ccode\u003e100vh\u003c/code\u003e).\u003c/p\u003e\u003cp\u003eTo control how exactly the two visible elements divvy up the available space between themselves, we can use the \u003ccode\u003egrid-template-rows\u003c/code\u003e property. I made it so that the first row uses \u003ccode\u003emin-content\u003c/code\u003e rather than \u003ccode\u003e1fr\u003c/code\u003e. This is necessary so that the \u003ccode\u003e.header\u003c/code\u003e doesn’t take up the same amount of space as the \u003ccode\u003e.hero\u003c/code\u003e but instead only takes what it needs and lets the hero have the rest.\u003c/p\u003e\u003cp\u003eHere’s our full solution:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nbody {\n  display: grid;\n  grid-template-rows: min-content 1fr;\n}\n\n.above-the-fold-spacer {\n  height: 100vh;\n  grid-column: 1 / -1;\n  grid-row: 1 / span 2;\n}\n\n.header {\n  position: sticky;\n  top: 0;\n  grid-column-start: 1;\n  grid-row-start: 1;\n}\n\n.hero {\n  grid-column-start: 1;\n  grid-row-start: 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd voila: A sticky header of arbitrary size above a hero that grows to fill the remaining visible space!\u003c/p\u003e\u003ch2 id=\"caveats-and-final-thoughts\"\u003eCaveats and Final Thoughts\u003c/h2\u003e\u003cp\u003eIt’s worth noting that \u003cstrong\u003ethe HTML order of the elements matters here\u003c/strong\u003e. If we define \u003ccode\u003e.above-the-fold-spacer\u003c/code\u003e after our \u003ccode\u003e.hero\u003c/code\u003e section, it will overlay and block access to the elements underneath. We can work around this by declaring either \u003ccode\u003eorder: -1\u003c/code\u003e, \u003ccode\u003ez-index: -1\u003c/code\u003e, or \u003ccode\u003evisibility: hidden\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eKeep in mind that this is a simple example. If you were to add a sidebar to the left of your page, for example, you’d need to adjust at which column the elements start. Still, in the majority of cases, using a CSS Grid approach is likely to be less troublesome than the Sisyphean task of manually managing and coordinating the height values of multiple elements.\u003c/p\u003e\u003cp\u003eAnother upside of this approach is that it’s \u003cstrong\u003eadaptable\u003c/strong\u003e. If you decide you want a group of three elements to take up the screen’s height rather than two, then you’d make the invisible spacer span three rows and assign the visible elements to the appropriate one. Even if the hero element’s content causes its height to exceed \u003ccode\u003e100vh\u003c/code\u003e, the grid adapts without breaking anything. It’s even well-supported in all modern browsers.\u003c/p\u003e\u003cp\u003eThe more I think about this technique, the more I’m persuaded that it’s actually quite clean. Then again, you know how lawyers can talk themselves into their own arguments? If you can think of an even simpler solution I’ve overlooked, feel free to reach out and let me know!\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2024-09-05T09:00:00Z",
  "modifiedTime": "2024-09-05T09:00:00Z"
}
