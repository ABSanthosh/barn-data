{
  "id": "22070d39-5e9c-490b-b7f8-751451627da0",
  "title": "The Case For Minimal WordPress Setups: A Contrarian View On Theme Frameworks",
  "link": "https://smashingmagazine.com/2025/03/case-minimal-wordpress-setups-contrarian-view-theme-frameworks/",
  "description": "Modern frameworks are supposed to help speed up development while providing modern tools and a developer-friendly workflow. In reality, Kevin Leary has found that they cause far more problems than they solve. This ultimately leads to the big question: why are modern theme frameworks so popular, and do they really benefit developers in the long run?",
  "author": "Kevin Leary",
  "published": "Mon, 03 Mar 2025 08:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 17885,
  "excerpt": "Modern frameworks are supposed to help speed up development while providing modern tools and a developer-friendly workflow. In reality, Kevin Leary has found that they cause far more problems than they solve. This ultimately leads to the big question: why are modern theme frameworks so popular, and do they really benefit developers in the long run?",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "13 min readWordPress, Frameworks, Workflow, Case StudiesModern frameworks are supposed to help speed up development while providing modern tools and a developer-friendly workflow. In theory, this is great and makes a lot of sense. In reality, Kevin Leary has found that they cause far more problems than they solve. This ultimately leads to the big question: why are modern theme frameworks so popular, and do they really benefit developers in the long run?When it comes to custom WordPress development, theme frameworks like Sage and Genesis have become a go-to solution, particularly for many agencies that rely on frameworks as an efficient starting point for client projects. They promise modern standards, streamlined workflows, and maintainable codebases. At face value, these frameworks seem to be the answer to building high-end, bespoke WordPress websites. However, my years of inheriting these builds as a freelance developer tell a different story — one rooted in the reality of long-term maintenance, scalability, and developer onboarding.As someone who specializes in working with professional websites, I’m frequently handed projects originally built by agencies using these frameworks. This experience has given me a unique perspective on the real-world implications of these tools over time. While they may look great in an initial pitch, their complexities often create friction for future developers, maintenance teams, and even the businesses they serve.This is not to say frameworks like Sage or Genesis are without merit, but they are far from the universal “best practice” they’re often touted to be.Below, I’ll share the lessons I’ve learned from inheriting and working with these setups, the challenges I’ve faced, and why I believe a minimal WordPress approach often provides a better path forward.Why Agencies Use FrameworksFrameworks are designed to make WordPress development faster, cleaner, and optimized for current best practices. Agencies are drawn to these tools for several reasons:Current code standardsFrameworks like Sage adopt PSR-2 standards, composer-based dependency management, and MVC-like abstractions.Reusable componentsSage’s Blade templating encourages modularity, while Genesis relies on hooks for extensive customization.Streamlined design toolsIntegration with Tailwind CSS, SCSS, and Webpack (or newer tools like Bud) allows rapid prototyping.Optimized performanceFrameworks are typically designed with lightweight, bloat-free themes in mind.Team productivityBy creating a standardized approach, these frameworks promise efficiency for larger teams with multiple contributors.On paper, these benefits make frameworks an enticing choice for agencies. They simplify the initial build process and cater to developers accustomed to working with modern PHP practices and JavaScript-driven tooling. But whenever I inherit these projects years later, the cracks in the foundation begin to show.The Reality of Maintaining Framework-Based BuildsWhile frameworks have their strengths, my firsthand experience reveals recurring issues that arise when it’s time to maintain or extend these builds. These challenges aren’t theoretical — they are issues I’ve encountered repeatedly when stepping into an existing framework-based site.1. Abstraction Creates FrictionOne of the selling points of frameworks is their use of abstractions, such as Blade templating and controller-to-view separation. While these patterns make sense in theory, they often lead to unnecessary complexity in practice.For instance, Blade templates abstract PHP logic from WordPress’s traditional theme hierarchy. This means errors like syntax issues don’t provide clear stack traces pointing to the actual view file — rather, they reference compiled templates. Debugging becomes a scavenger hunt, especially for developers unfamiliar with Sage’s structure.One example is a popular news outlet with millions of monthly visitors. When I first inherited their Sage-based theme, I had to bypass their Lando/Docker environment to use my own minimal Nginx localhost setup. The theme was incompatible with standard WordPress workflows, and I had to modify build scripts to support a traditional installation. Once I resolved the environment issues, I realized their build process was incredibly slow, with hot module replacement only partially functional (Blade template changes wouldn’t reload). Each save took 4–5 seconds to compile.Faced with a decision to either upgrade to Sage 10 or rebuild the critical aspects, I opted for the latter. We drastically improved performance by replacing the Sage build with a simple Laravel Mix process. The new build process was reduced from thousands of lines to 80, significantly improving developer workflow. Any new developer could now understand the setup quickly, and future debugging would be far simpler.2. Inflexible PatternsWhile Sage encourages “best practices,” these patterns can feel rigid and over-engineered for simple tasks. Customizing basic WordPress features — like adding a navigation menu or tweaking a post query — requires following the framework’s prescribed patterns. This introduces a learning curve for developers who aren’t deeply familiar with Sage, and slows down progress for minor adjustments.Traditional WordPress theme structures, by contrast, are intuitive and widely understood. Any WordPress developer, regardless of background, can jump into a classic theme and immediately know where to look for templates, logic, and customizations. Sage’s abstraction layers, while well-meaning, limit accessibility to a smaller, more niche group of developers.3. Hosting Compatibility IssuesWhen working with Sage, issues with hosting environments are inevitable. For example, Sage’s use of Laravel Blade compiles templates into cached PHP files, often stored in directories like /wp-content/cache. Strict file system rules on managed hosting platforms, like WP Engine, can block these writes, leading to white screens or broken templates after deployment.This was precisely the issue I faced with a custom agency-built theme using the Sage theme on WPEngine.” Every Git deployment resulted in a white screen of death due to PHP errors caused by Blade templates failing to save in the intended cache directory. The solution, recommended by WP Engine support, was to use the system’s /tmp directory. While this workaround prevented deployment errors, it undermined the purpose of cached templates, as temporary files are cleared by PHP’s garbage collection. Debugging and implementing this solution consumed significant time — time that could have been avoided had the theme been designed with hosting compatibility in mind.4. Breaking Changes And Upgrade WoesUpgrading from Sage 9 to Sage 10 — or even from older versions of Roots — often feels like a complete rebuild. These breaking changes create friction for businesses that want long-term stability. Clients, understandably, are unwilling to pay for what amounts to refactoring without a visible return on investment. As a result, these sites stagnate, locked into outdated versions of the framework, creating problems with dependency management (e.g., Composer packages, Node.js versions) and documentation mismatches.One agency subcontract I worked on recently gave me insight into Sage 10’s latest approach. Even on small microsites with minimal custom logic, I found the Bud-based build system sluggish, with watch processes taking over three seconds to reload.For developers accustomed to faster workflows, this is unacceptable. Additionally, Sage 10 introduced new patterns and directives that departed significantly from Sage 9, adding a fresh learning curve. While I understand the appeal of mirroring Laravel’s structure, I couldn’t shake the feeling that this complexity was unnecessary for WordPress. By sticking to simpler approaches, the footprint could be smaller, the performance faster, and the maintenance much easier.The Cost Of Over-EngineeringThe issues above boil down to one central theme: over-engineering.Frameworks like Sage introduce complexity that, while beneficial in theory, often outweighs the practical benefits for most WordPress projects.When you factor in real-world constraints — like tight budgets, frequent developer turnover, and the need for intuitive codebases — the case for a minimal approach becomes clear.Minimal WordPress setups embrace simplicity:No abstraction for abstraction’s sakeTraditional WordPress theme hierarchy is straightforward, predictable, and accessible to a broad developer audience.Reduced tooling overheadAvoiding reliance on tools like Webpack or Blade removes potential points of failure and speeds up workflows.Future-proofingA standard theme structure remains compatible with WordPress core updates and developer expectations, even a decade later.In my experience, minimal setups foster easier collaboration and faster problem-solving. They focus on solving the problem rather than adhering to overly opinionated patterns.Real World ExampleLike many things, this all sounds great and makes sense in theory, but what does it look like in practice? Seeing is believing, so I’ve created a minimal theme that exemplifies some of the concepts I’ve described here. This theme is a work in progress, and there are plenty of areas where it needs work. It provides the top features that custom WordPress developers seem to want most in a theme framework.View Code in GitHub →Modern FeaturesBefore we dive in, I’ll list out some of the key benefits of what’s going on in this theme. Above all of these, working minimally and keeping things simple and easy to understand is by far the largest benefit, in my opinion.A watch task that compiles and reloads in under 100ms;Sass for CSS preprocessing coupled with CSS written in BEM syntax;Native ES modules;Composer package management;Twig view templating;View-controller pattern;Namespaced PHP for isolation;Built-in support for the Advanced Custom Fields plugin;Global context variables for common WordPress data: site_url, site_description, site_url, theme_dir, theme_url, primary_nav, ACF custom fields, the_title(), the_content().Templating LanguageTwig is included with this theme, and it is used to load a small set of commonly used global context variables such as theme URL, theme directory, site name, site URL, and so on. It also includes some core functions as well, like the_content(), the_title(), and others you’d routinely often use during the process of creating a custom theme. These global context variables and functions are available for all URLs.While it could be argued that Twig is an unnecessary additional abstraction layer when we’re trying to establish a minimal WordPress setup, I chose to include it because this type of abstraction is included in Sage. But it’s also for a few other important reasons:Old,Dependable, andStable.You won’t need to worry about any future breaking changes in future versions, and it’s widely in use today. All the features I commonly see used in Sage Blade templates can easily be handled with Twig similarly. There really isn’t anything you can do with Blade that isn’t possible with Twig.Blade is a great templating language, but it’s best suited for Laravel, in my opinion. BladeOne does provide a good way to use it as a standalone templating engine, but even then, it’s still not as performant under pressure as Twig. Twig’s added performance, when used with small, efficient contexts, allows us to avoid the complexity that comes with caching view output. Compile-on-the-fly Twig is very close to the same speed as raw PHP in this use case.Most importantly, Twig was built to be portable. It can be installed with composer and used within the theme with just 55 lines of code.Now, in a real project, this would probably be more than 55 lines, but either way, it is, without a doubt, much easier to understand and work with than Blade. Blade was built for use in Laravel, and it’s just not nearly as portable. It will be significantly easier to identify issues, track them down with a direct stack trace, and fix them with Twig.The view context in this theme is deliberately kept sparse, during a site build you’ll add what you specifically need for a particular site. A lean context for your views helps with performance and workflow.Models \u0026 ControllersThe template hierarchy follows the patterns of good ol’ WordPress, and while some developers don’t like this, it is undoubtedly the most widely accepted and commonly understood standard. Each standard theme file uses a model where you define your data structures with PHP and hand off the theme as the context to a .twig view file.Developers like the structure of separating server-side logic from a template, and in a classic MVC/MVVC pattern, we have our model, view, and controller. Here, I’m using the standard WordPress theme templates as models.Currently, template files include some useful basics. You’re likely familiar with these standard templates, but I’ll list them here for posterity:404.php: Displays a custom “Page Not Found” message when a visitor tries to access a page that doesn’t exist.archive.php: Displays a list of posts from a particular archive, such as a category, date, or tag archive.author.php: Displays a list of posts by a specific author, along with the author’s information.category.php: Displays a list of posts from a specific category.footer.php: Contains the footer section of the theme, typically including closing HTML tags and widgets or navigation in the footer area.front-page.php: The template used for the site’s front page, either static or a blog, depending on the site settings.functions.php: Adds custom functionality to the theme, such as registering menus and widgets or adding theme support for features like custom logos or post thumbnails.header.php: Contains the header section of the theme, typically including the site’s title, meta tags, and navigation menu.index.php: The fallback template for all WordPress pages is used if no other more specific template (like category.php or single.php) is available.page.php: Displays individual static pages, such as “About” or “Contact” pages.screenshot.png: An image of the theme’s design is shown in the WordPress theme selector to give users a preview of the theme’s appearance.search.php: Displays the results of a search query, showing posts or pages that match the search terms entered by the user.single.php: Displays individual posts, often used for blog posts or custom post types.tag.php: Displays a list of posts associated with a specific tag.Extremely Fast Build Process For SCSS And JavaScriptThe build is curiously different in this theme, but out of the box, you can compile SCSS to CSS, work with native JavaScript modules, and have a live reload watch process with a tiny footprint. Look inside the bin/*.js files, and you’ll see everything that’s happening.There are just two commands here, and all web developers should be familiar with them:WatchWhile developing, it will reload or inject JavaScript and CSS changes into the browser automatically using a Browsersync.BuildThis task compiles all top-level *.scss files efficiently. There’s room for improvement, but keep in mind this theme serves as a concept.Now for a curveball: there is no compile process for JavaScript. File changes will still be injected into the browser with hot module replacement during watch mode, but we don’t need to compile anything.WordPress will load theme JavaScript as native ES modules, using WordPress 6.5’s support for ES modules. My reasoning is that many sites now pass through Cloudflare, so modern compression is handled for JavaScript automatically. Many specialized WordPress hosts do this as well. When comparing minification to GZIP, it’s clear that minification provides trivial gains in file reduction. The vast majority of file reduction is provided by CDN and server compression. Based on this, I believe the benefits of a fast workflow far outweigh the additional overhead of pulling in build steps for webpack, Rollup, or other similar packaging tools.We’re fortunate that the web fully supports ES modules today, so there is really no reason why we should need to compile JavaScript at all if we’re not using a JavaScript framework like Vue, React, or Svelte.A Contrarian ApproachMy perspective and the ideas I’ve shared here are undoubtedly contrarian. Like anything alternative, this is bound to ruffle some feathers. Frameworks like Sage are celebrated in developer circles, with strong communities behind them. For certain use cases — like large-scale, enterprise-level projects with dedicated development teams — they may indeed be the right fit.For the vast majority of WordPress projects I encounter, the added complexity creates more problems than it solves. As developers, our goal should be to build solutions that are not only functional and performant but also maintainable and approachable for the next person who inherits them.Simplicity, in my view, is underrated in modern web development. A minimal WordPress setup, tailored to the specific needs of the project without unnecessary abstraction, is often the leaner, more sustainable choice.ConclusionInheriting framework-based projects has taught me invaluable lessons about the real-world impact of theme frameworks. While they may impress in an initial pitch or during development, the long-term consequences of added complexity often outweigh the benefits. By adopting a minimal WordPress approach, we can build sites that are easier to maintain, faster to onboard new developers, and more resilient to change.Modern tools have their place, but minimalism never goes out of style. When you choose simplicity, you choose a codebase that works today, tomorrow, and years down the line. Isn’t that what great web development is all about? (gg, yk)",
  "image": "https://files.smashing.media/articles/case-minimal-wordpress-setups-contrarian-view-theme-frameworks/case-minimal-wordpress-setups-contrarian-view-theme-frameworks.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e13 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/wordpress\"\u003eWordPress\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/frameworks\"\u003eFrameworks\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/workflow\"\u003eWorkflow\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/case-studies\"\u003eCase Studies\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eModern frameworks are supposed to help speed up development while providing modern tools and a developer-friendly workflow. In theory, this is great and makes a lot of sense. In reality, Kevin Leary has found that they cause far more problems than they solve. This ultimately leads to the big question: why are modern theme frameworks so popular, and do they really benefit developers in the long run?\u003c/section\u003e\u003c/p\u003e\u003cp\u003eWhen it comes to custom WordPress development, theme frameworks like \u003ca href=\"https://roots.io/sage/\"\u003eSage\u003c/a\u003e and \u003ca href=\"https://www.studiopress.com/themes/genesis/\"\u003eGenesis\u003c/a\u003e have become a go-to solution, particularly for many agencies that rely on frameworks as an efficient starting point for client projects. They promise modern standards, streamlined workflows, and maintainable codebases. At face value, these frameworks seem to be the answer to building high-end, bespoke WordPress websites. However, my years of inheriting these builds as a freelance developer tell a different story — one rooted in the reality of long-term maintenance, scalability, and developer onboarding.\u003c/p\u003e\u003cp\u003eAs someone who specializes in working with professional websites, I’m frequently handed projects originally built by agencies using these frameworks. This experience has given me a \u003cstrong\u003eunique perspective on the real-world implications of these tools\u003c/strong\u003e over time. While they may look great in an initial pitch, their complexities often create friction for future developers, maintenance teams, and even the businesses they serve.\u003c/p\u003e\u003cblockquote\u003eThis is not to say frameworks like Sage or Genesis are without merit, but they are far from the universal “best practice” they’re often touted to be.\u003c/blockquote\u003e\u003cp\u003eBelow, I’ll share the \u003cstrong\u003elessons\u003c/strong\u003e I’ve learned from inheriting and working with these setups, the \u003cstrong\u003echallenges\u003c/strong\u003e I’ve faced, and why I believe a minimal WordPress approach often provides a better path forward.\u003c/p\u003e\u003ch2 id=\"why-agencies-use-frameworks\"\u003eWhy Agencies Use Frameworks\u003c/h2\u003e\u003cp\u003eFrameworks are designed to make WordPress development faster, cleaner, and optimized for current best practices. Agencies are drawn to these tools for several reasons:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCurrent code standards\u003c/strong\u003e\u003cbr/\u003eFrameworks like Sage adopt PSR-2 standards, composer-based dependency management, and MVC-like abstractions.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eReusable components\u003c/strong\u003e\u003cbr/\u003eSage’s Blade templating encourages modularity, while Genesis relies on hooks for extensive customization.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eStreamlined design tools\u003c/strong\u003e\u003cbr/\u003eIntegration with Tailwind CSS, SCSS, and Webpack (or newer tools like Bud) allows rapid prototyping.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eOptimized performance\u003c/strong\u003e\u003cbr/\u003eFrameworks are typically designed with lightweight, bloat-free themes in mind.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eTeam productivity\u003c/strong\u003e\u003cbr/\u003eBy creating a standardized approach, these frameworks promise efficiency for larger teams with multiple contributors.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOn paper, these benefits make frameworks an enticing choice for agencies. They simplify the initial build process and cater to developers accustomed to working with modern PHP practices and JavaScript-driven tooling. But whenever I inherit these projects years later, the cracks in the foundation begin to show.\u003c/p\u003e\u003ch2 id=\"the-reality-of-maintaining-framework-based-builds\"\u003eThe Reality of Maintaining Framework-Based Builds\u003c/h2\u003e\u003cp\u003eWhile frameworks have their strengths, my firsthand experience reveals recurring issues that arise when it’s time to maintain or extend these builds. These challenges aren’t theoretical — they are issues I’ve encountered repeatedly when stepping into an existing framework-based site.\u003c/p\u003e\u003ch3 id=\"1-abstraction-creates-friction\"\u003e1. Abstraction Creates Friction\u003c/h3\u003e\u003cp\u003eOne of the selling points of frameworks is their use of abstractions, such as Blade templating and controller-to-view separation. While these patterns make sense in theory, they often lead to \u003cstrong\u003eunnecessary complexity\u003c/strong\u003e in practice.\u003c/p\u003e\u003cp\u003eFor instance, Blade templates abstract PHP logic from WordPress’s traditional theme hierarchy. This means errors like syntax issues don’t provide clear stack traces pointing to the actual view file — rather, they reference compiled templates. \u003cstrong\u003eDebugging becomes a scavenger hunt\u003c/strong\u003e, especially for developers unfamiliar with Sage’s structure.\u003c/p\u003e\u003cp\u003eOne example is a popular news outlet with millions of monthly visitors. When I first inherited their Sage-based theme, I had to bypass their Lando/Docker environment to use my own minimal Nginx localhost setup. The theme was incompatible with standard WordPress workflows, and I had to modify build scripts to support a traditional installation. Once I resolved the environment issues, I realized their build process was incredibly slow, with hot module replacement only partially functional (Blade template changes wouldn’t reload). Each save took 4–5 seconds to compile.\u003c/p\u003e\u003cp\u003eFaced with a decision to either upgrade to Sage 10 or rebuild the critical aspects, I opted for the latter. We drastically improved performance by replacing the Sage build with a simple Laravel Mix process. The new build process was reduced from thousands of lines to 80, significantly improving developer workflow. Any new developer could now understand the setup quickly, and future debugging would be far simpler.\u003c/p\u003e\u003ch3 id=\"2-inflexible-patterns\"\u003e2. Inflexible Patterns\u003c/h3\u003e\u003cp\u003eWhile Sage encourages “best practices,” these patterns can feel rigid and over-engineered for simple tasks. Customizing basic WordPress features — like adding a navigation menu or tweaking a post query — requires following the framework’s prescribed patterns. This \u003cstrong\u003eintroduces a learning curve\u003c/strong\u003e for developers who aren’t deeply familiar with Sage, and \u003cstrong\u003eslows down progress for minor adjustments\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eTraditional WordPress theme structures, by contrast, are intuitive and widely understood. Any WordPress developer, regardless of background, can jump into a classic theme and immediately know where to look for templates, logic, and customizations. Sage’s abstraction layers, while well-meaning, limit accessibility to a smaller, more niche group of developers.\u003c/p\u003e\u003ch3 id=\"3-hosting-compatibility-issues\"\u003e3. Hosting Compatibility Issues\u003c/h3\u003e\u003cp\u003eWhen working with Sage, issues with hosting environments are inevitable. For example, Sage’s use of Laravel Blade compiles templates into cached PHP files, often stored in directories like \u003ccode\u003e/wp-content/cache\u003c/code\u003e. Strict file system rules on managed hosting platforms, like WP Engine, can block these writes, leading to \u003cstrong\u003ewhite screens\u003c/strong\u003e or \u003cstrong\u003ebroken templates after deployment\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eThis was precisely the issue I faced with a custom agency-built theme using the Sage theme on WPEngine.” Every Git deployment resulted in a white screen of death due to PHP errors caused by Blade templates failing to save in the intended cache directory. The solution, recommended by WP Engine support, was to use the system’s \u003ccode\u003e/tmp\u003c/code\u003e directory. While this workaround prevented deployment errors, it undermined the purpose of cached templates, as temporary files are cleared by PHP’s garbage collection. Debugging and implementing this solution consumed significant time — time that could have been avoided had the theme been designed with hosting compatibility in mind.\u003c/p\u003e\u003ch3 id=\"4-breaking-changes-and-upgrade-woes\"\u003e4. Breaking Changes And Upgrade Woes\u003c/h3\u003e\u003cp\u003eUpgrading from Sage 9 to Sage 10 — or even from older versions of Roots — often feels like a complete rebuild. These breaking changes create friction for businesses that want long-term stability. Clients, understandably, are unwilling to pay for what amounts to refactoring without a visible return on investment. As a result, these sites stagnate, locked into outdated versions of the framework, creating \u003cstrong\u003eproblems with dependency management\u003c/strong\u003e (e.g., Composer packages, Node.js versions) and \u003cstrong\u003edocumentation mismatches\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eOne agency subcontract I worked on recently gave me insight into Sage 10’s latest approach. Even on small microsites with minimal custom logic, I found the Bud-based build system sluggish, with watch processes taking over three seconds to reload.\u003c/p\u003e\u003cp\u003eFor developers accustomed to faster workflows, this is unacceptable. Additionally, Sage 10 introduced new patterns and directives that departed significantly from Sage 9, adding a fresh learning curve. While I understand the appeal of mirroring Laravel’s structure, I couldn’t shake the feeling that this complexity was unnecessary for WordPress. By sticking to simpler approaches, the footprint could be smaller, the performance faster, and the maintenance much easier.\u003c/p\u003e\u003ch2 id=\"the-cost-of-over-engineering\"\u003eThe Cost Of Over-Engineering\u003c/h2\u003e\u003cp\u003eThe issues above boil down to one central theme: \u003cstrong\u003eover-engineering\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eFrameworks like Sage introduce complexity that, while beneficial in theory, often outweighs the practical benefits for most WordPress projects.\u003c/p\u003e\u003cp\u003eWhen you factor in real-world constraints — like tight budgets, frequent developer turnover, and the need for intuitive codebases — \u003cstrong\u003ethe case for a minimal approach\u003c/strong\u003e becomes clear.\u003c/p\u003e\u003cp\u003eMinimal WordPress setups embrace simplicity:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eNo abstraction for abstraction’s sake\u003c/strong\u003e\u003cbr/\u003eTraditional WordPress theme hierarchy is straightforward, predictable, and accessible to a broad developer audience.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eReduced tooling overhead\u003c/strong\u003e\u003cbr/\u003eAvoiding reliance on tools like Webpack or Blade removes potential points of failure and speeds up workflows.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFuture-proofing\u003c/strong\u003e\u003cbr/\u003eA standard theme structure remains compatible with WordPress core updates and developer expectations, even a decade later.\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aIn%20my%20experience,%20minimal%20setups%20foster%20easier%20collaboration%20and%20faster%20problem-solving.%20They%20focus%20on%20solving%20the%20problem%20rather%20than%20adhering%20to%20overly%20opinionated%20patterns.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f03%2fcase-minimal-wordpress-setups-contrarian-view-theme-frameworks%2f\"\u003eIn my experience, minimal setups foster easier collaboration and faster problem-solving. They focus on solving the problem rather than adhering to overly opinionated patterns.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"real-world-example\"\u003eReal World Example\u003c/h2\u003e\u003cp\u003eLike many things, this all sounds great and makes sense in \u003cem\u003etheory,\u003c/em\u003e but what does it look like in practice? Seeing is believing, so I’ve created a minimal theme that exemplifies some of the concepts I’ve described here. This theme is a work in progress, and there are plenty of areas where it needs work. It provides the top features that custom WordPress developers seem to want most in a theme framework.\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/Kevinlearynet/basic-wp/tree/7a2925258fe1e037a5c1d8ff093374fc01dcc16b\"\u003eView Code in GitHub →\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"modern-features\"\u003eModern Features\u003c/h3\u003e\u003cp\u003eBefore we dive in, I’ll list out some of the key benefits of what’s going on in this theme. Above all of these, \u003cstrong\u003eworking minimally\u003c/strong\u003e and \u003cstrong\u003ekeeping things simple and easy to understand\u003c/strong\u003e is by far the largest benefit, in my opinion.\u003c/p\u003e\u003cul\u003e\u003cli\u003eA watch task that compiles and reloads in under 100ms;\u003c/li\u003e\u003cli\u003eSass for CSS preprocessing coupled with CSS written in \u003ca href=\"https://www.smashingmagazine.com/2018/06/bem-for-beginners/\"\u003eBEM syntax\u003c/a\u003e;\u003c/li\u003e\u003cli\u003eNative ES modules;\u003c/li\u003e\u003cli\u003eComposer package management;\u003c/li\u003e\u003cli\u003eTwig view templating;\u003c/li\u003e\u003cli\u003eView-controller pattern;\u003c/li\u003e\u003cli\u003eNamespaced PHP for isolation;\u003c/li\u003e\u003cli\u003eBuilt-in support for the \u003ca href=\"https://wordpress.org/plugins/advanced-custom-fields/\"\u003eAdvanced Custom Fields\u003c/a\u003e plugin;\u003c/li\u003e\u003cli\u003eGlobal context variables for common WordPress data: \u003ccode\u003esite_url\u003c/code\u003e, \u003ccode\u003esite_description\u003c/code\u003e, \u003ccode\u003esite_url\u003c/code\u003e, \u003ccode\u003etheme_dir\u003c/code\u003e, \u003ccode\u003etheme_url\u003c/code\u003e, \u003ccode\u003eprimary_nav\u003c/code\u003e, ACF custom fields, \u003ccode\u003ethe_title()\u003c/code\u003e, \u003ccode\u003ethe_content()\u003c/code\u003e.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"templating-language\"\u003eTemplating Language\u003c/h3\u003e\u003cp\u003eTwig is included with this theme, and it is used to load a small set of commonly used global context variables such as theme URL, theme directory, site name, site URL, and so on. It also includes some core functions as well, like \u003ccode\u003ethe_content()\u003c/code\u003e, \u003ccode\u003ethe_title()\u003c/code\u003e, and others you’d routinely often use during the process of creating a custom theme. These global context variables and functions are available for all URLs.\u003c/p\u003e\u003cp\u003eWhile it could be argued that Twig is an unnecessary additional abstraction layer when we’re trying to establish a minimal WordPress setup, I chose to include it because this type of abstraction is included in Sage. But it’s also for a few other important reasons:\u003c/p\u003e\u003cul\u003e\u003cli\u003eOld,\u003c/li\u003e\u003cli\u003eDependable, and\u003c/li\u003e\u003cli\u003eStable.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYou won’t need to worry about any future breaking changes in future versions, and it’s widely in use today. All the features I commonly see used in Sage Blade templates can easily be handled with Twig similarly. There really isn’t anything you can do with Blade that isn’t possible with Twig.\u003c/p\u003e\u003cp\u003eBlade is a great templating language, but it’s best suited for Laravel, in my opinion. BladeOne does provide a good way to use it as a standalone templating engine, but even then, it’s still not as performant under pressure as Twig. Twig’s added performance, when used with small, efficient contexts, allows us to avoid the complexity that comes with caching view output. Compile-on-the-fly Twig is very close to the same speed as raw PHP in this use case.\u003c/p\u003e\u003cp\u003eMost importantly, \u003cstrong\u003eTwig was built to be portable\u003c/strong\u003e. It can be installed with composer and used within the theme with just \u003ca href=\"https://github.com/Kevinlearynet/basic-wp/blob/7a2925258fe1e037a5c1d8ff093374fc01dcc16b/lib/helpers.php#L10-L65\"\u003e55 lines of code\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eNow, in a real project, this would probably be more than 55 lines, but either way, it is, without a doubt, much easier to understand and work with than Blade. Blade was built for use in Laravel, and it’s just not nearly as portable. It will be significantly easier to identify issues, track them down with a direct stack trace, and fix them with Twig.\u003c/p\u003e\u003cp\u003eThe view context in this theme is deliberately kept sparse, during a site build you’ll add what you specifically need for a particular site. A lean context for your views helps with performance and workflow.\u003c/p\u003e\u003ch3 id=\"models-controllers\"\u003eModels \u0026amp; Controllers\u003c/h3\u003e\u003cp\u003eThe template hierarchy follows the patterns of good ol’ WordPress, and while some developers don’t like this, it is undoubtedly the most widely accepted and commonly understood standard. Each standard theme file uses a model where you define your data structures with PHP and hand off the theme as the context to a \u003ccode\u003e.twig\u003c/code\u003e view file.\u003c/p\u003e\u003cp\u003eDevelopers like the structure of separating server-side logic from a template, and in a classic MVC/MVVC pattern, we have our model, view, and controller. Here, I’m using the standard WordPress theme templates as models.\u003c/p\u003e\u003cp\u003eCurrently, template files include some useful basics. You’re likely familiar with these standard templates, but I’ll list them here for posterity:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e404.php\u003c/code\u003e\u003c/strong\u003e: Displays a custom “Page Not Found” message when a visitor tries to access a page that doesn’t exist.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003earchive.php\u003c/code\u003e\u003c/strong\u003e: Displays a list of posts from a particular archive, such as a category, date, or tag archive.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eauthor.php\u003c/code\u003e\u003c/strong\u003e: Displays a list of posts by a specific author, along with the author’s information.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ecategory.php\u003c/code\u003e\u003c/strong\u003e: Displays a list of posts from a specific category.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efooter.php\u003c/code\u003e\u003c/strong\u003e: Contains the footer section of the theme, typically including closing HTML tags and widgets or navigation in the footer area.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efront-page.php\u003c/code\u003e\u003c/strong\u003e: The template used for the site’s front page, either static or a blog, depending on the site settings.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efunctions.php\u003c/code\u003e\u003c/strong\u003e: Adds custom functionality to the theme, such as registering menus and widgets or adding theme support for features like custom logos or post thumbnails.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eheader.php\u003c/code\u003e\u003c/strong\u003e: Contains the header section of the theme, typically including the site’s title, meta tags, and navigation menu.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eindex.php\u003c/code\u003e\u003c/strong\u003e: The fallback template for all WordPress pages is used if no other more specific template (like \u003ccode\u003ecategory.php\u003c/code\u003e or \u003ccode\u003esingle.php\u003c/code\u003e) is available.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epage.php\u003c/code\u003e\u003c/strong\u003e: Displays individual static pages, such as “About” or “Contact” pages.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003escreenshot.png\u003c/code\u003e\u003c/strong\u003e: An image of the theme’s design is shown in the WordPress theme selector to give users a preview of the theme’s appearance.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esearch.php\u003c/code\u003e\u003c/strong\u003e: Displays the results of a search query, showing posts or pages that match the search terms entered by the user.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003esingle.php\u003c/code\u003e\u003c/strong\u003e: Displays individual posts, often used for blog posts or custom post types.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etag.php\u003c/code\u003e\u003c/strong\u003e: Displays a list of posts associated with a specific tag.\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"extremely-fast-build-process-for-scss-and-javascript\"\u003eExtremely Fast Build Process For SCSS And JavaScript\u003c/h3\u003e\u003cp\u003eThe build is curiously different in this theme, but out of the box, you can compile SCSS to CSS, work with native JavaScript modules, and have a live reload watch process with a tiny footprint. Look inside the \u003ccode\u003ebin/*.js\u003c/code\u003e files, and you’ll see everything that’s happening.\u003c/p\u003e\u003cp\u003eThere are just two commands here, and all web developers should be familiar with them:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eWatch\u003c/strong\u003e\u003cbr/\u003eWhile developing, it will reload or inject JavaScript and CSS changes into the browser automatically using a Browsersync.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eBuild\u003c/strong\u003e\u003cbr/\u003eThis task compiles all top-level \u003ccode\u003e*.scss\u003c/code\u003e files efficiently. There’s room for improvement, but keep in mind this theme serves as a concept.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eNow for a curveball: there is \u003cstrong\u003eno compile process for JavaScript.\u003c/strong\u003e File changes will still be injected into the browser with hot module replacement during watch mode, but we don’t need to compile anything.\u003c/p\u003e\u003cp\u003eWordPress will load theme JavaScript as native ES modules, using \u003ca href=\"https://www.kevinleary.net/blog/wordpress-asset-loading/\"\u003eWordPress 6.5’s support for ES modules\u003c/a\u003e. My reasoning is that many sites now pass through Cloudflare, so modern compression is handled for JavaScript automatically. Many specialized WordPress hosts do this as well. When comparing minification to GZIP, it’s clear that minification provides trivial gains in file reduction. The vast majority of file reduction is provided by CDN and server compression. Based on this, I believe the benefits of a fast workflow far outweigh the additional overhead of pulling in build steps for webpack, Rollup, or other similar packaging tools.\u003c/p\u003e\u003cp\u003eWe’re fortunate that the web fully supports ES modules today, so there is really no reason why we should need to compile JavaScript at all if we’re not using a JavaScript framework like Vue, React, or Svelte.\u003c/p\u003e\u003ch2 id=\"a-contrarian-approach\"\u003eA Contrarian Approach\u003c/h2\u003e\u003cp\u003eMy perspective and the ideas I’ve shared here are undoubtedly contrarian. Like anything alternative, this is bound to ruffle some feathers. Frameworks like Sage are celebrated in developer circles, with strong communities behind them. For certain use cases — like large-scale, enterprise-level projects with dedicated development teams — they may indeed be the right fit.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aFor%20the%20vast%20majority%20of%20WordPress%20projects%20I%20encounter,%20the%20added%20complexity%20creates%20more%20problems%20than%20it%20solves.%20As%20developers,%20our%20goal%20should%20be%20to%20build%20solutions%20that%20are%20not%20only%20functional%20and%20performant%20but%20also%20maintainable%20and%20approachable%20for%20the%20next%20person%20who%20inherits%20them.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f03%2fcase-minimal-wordpress-setups-contrarian-view-theme-frameworks%2f\"\u003eFor the vast majority of WordPress projects I encounter, the added complexity creates more problems than it solves. As developers, our goal should be to build solutions that are not only functional and performant but also maintainable and approachable for the next person who inherits them.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eSimplicity, in my view, is underrated in modern web development. A minimal WordPress setup, tailored to the specific needs of the project without unnecessary abstraction, is often the leaner, more sustainable choice.\u003c/p\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eInheriting framework-based projects has taught me invaluable lessons about the real-world impact of theme frameworks. While they may impress in an initial pitch or during development, the long-term consequences of added complexity often outweigh the benefits. By adopting a minimal WordPress approach, we can build sites that are \u003cstrong\u003eeasier to maintain\u003c/strong\u003e, \u003cstrong\u003efaster to onboard new developers\u003c/strong\u003e, and \u003cstrong\u003emore resilient to change\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eModern tools have their place, but minimalism never goes out of style. When you choose simplicity, you choose a codebase that works today, tomorrow, and years down the line. Isn’t that what great web development is all about?\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-03-03T08:00:00Z",
  "modifiedTime": "2025-03-03T08:00:00Z"
}
