{
  "id": "c8d55b33-0e04-454e-88e2-cf415ad36248",
  "title": "How OWASP Helps You Secure Your Full-Stack Web Applications",
  "link": "https://smashingmagazine.com/2025/02/how-owasp-helps-secure-full-stack-web-applications/",
  "description": "The OWASP vulnerabilities list is the perfect starting point for web developers looking to strengthen their security expertise. Let’s discover how these vulnerabilities materialize in full-stack web applications and how to prevent them.",
  "author": "Eric Burel",
  "published": "Tue, 18 Feb 2025 08:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 17562,
  "excerpt": "The OWASP vulnerabilities list is the perfect starting point for web developers looking to strengthen their security expertise. Let’s discover how these vulnerabilities materialize in full-stack web applications and how to prevent them.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "14 min readPrivacy, Apps, ToolsThe OWASP vulnerabilities list is the perfect starting point for web developers looking to strengthen their security expertise. Let’s discover how these vulnerabilities materialize in full-stack web applications and how to prevent them.Security can be an intimidating topic for web developers. The vocabulary is rich and full of acronyms. Trends evolve quickly as hackers and analysts play a perpetual cat-and-mouse game. Vulnerabilities stem from little details we cannot afford to spend too much time on during our day-to-day operations.JavaScript developers already have a lot to take with the emergence of a new wave of innovative architectures, such as React Server Components, Next.js App Router, or Astro islands.So, let’s have a focused approach. What we need is to be able to detect and palliate the most common security issues. A top ten of the most common vulnerabilities would be ideal.Meet The OWASP Top 10Guess what: there happens to be such a top ten of the most common vulnerabilities, curated by experts in the field!It is provided by the OWASP Foundation, and it’s an extremely valuable resource for getting started with security.OWASP stands for “Open Worldwide Application Security Project.” It’s a nonprofit foundation whose goal is to make software more secure globally. It supports many open-source projects and produces high-quality education resources, including the OWASP top 10 vulnerabilities list.We will dive through each item of the OWASP top 10 to understand how to recognize these vulnerabilities in a full-stack application.Note: I will use Next.js as an example, but this knowledge applies to any similar full-stack architecture, even outside of the JavaScript ecosystem.Let’s start our countdown towards a safer web!Number 10: Server-Side Request Forgery (SSRF)You may have heard about Server-Side Rendering, aka SSR. Well, you can consider SSRF to be its evil twin acronym.Server-Side Request Forgery can be summed up as letting an attacker fire requests using your backend server. Besides hosting costs that may rise up, the main problem is that the attacker will benefit from your server’s level of accreditation. In a complex architecture, this means being able to target your internal private services using your own corrupted server.SSR is good, but SSRF is bad! (Large preview)Here is an example. Our app lets a user input a URL and summarizes the content of the target page server-side using an AI SDK. A mischievous user passes localhost:3000 as the URL instead of a website they’d like to summarize. Your server will fire a request against itself or any other service running on port 3000 in your backend infrastructure. This is a severe SSRF vulnerability!You’ll want to be careful when firing requests based on user inputs, especially server-side.Number 9: Security Logging And Monitoring FailuresI wish we could establish a telepathic connection with our beloved Node.js server running in the backend. Instead, the best thing we have to see what happens in the cloud is a dreadful stream of unstructured pieces of text we name “logs.”Yet we will have to deal with that, not only for debugging or performance optimization but also because logs are often the only information you’ll get to discover and remediate a security issue.As a starter, you might want to focus on logging the most important transactions of your application exactly like you would prioritize writing end-to-end tests. In most applications, this means login, signup, payouts, mail sending, and so on. In a bigger company, a more complete telemetry solution is a must-have, such as Open Telemetry, Sentry, or Datadog.If you are using React Server Components, you may need to set up a proper logging strategy anyway since it’s not possible to debug them directly from the browser as we used to do for Client components.Number 8: Software And Data Integrity FailuresThe OWASP top 10 vulnerabilities tend to have various levels of granularity, and this one is really a big family. I’d like to focus on supply chain attacks, as they have gained a lot of popularity over the years.You may have heard about the Log4J vulnerability. It was very publicized, very critical, and very exploited by hackers. It’s a massive supply chain attack.In the JavaScript ecosystem, you most probably install your dependencies using NPM. Before picking dependencies, you might want to craft yourself a small list of health indicators.Is the library maintained and tested with proper code?Does it play a critical role in my application?Who is the main contributor?Did I spell it right when installing?For more serious business, you might want to consider setting up a Supply Chain Analysis (SCA) solution; GitHub’s Dependabot is a free one, and Snyk and Datadog are other famous actors.Number 7: Identification And Authentication FailuresHere is a stereotypical vulnerability belonging to this category: your admin password is leaked. A hacker finds it. Boom, game over.Password management procedures are beyond the scope of this article, but in the context of full-stack web development, let’s dive deep into how we can prevent brute force attacks using Next.js edge middlewares.Middlewares are tiny proxies written in JavaScript. They process requests in a way that is supposed to be very, very fast, faster than a normal Node.js endpoint, for example. They are a good fit for handling low-level processing, like blocking malicious IPs or redirecting users towards the correct translation of a page.One interesting use case is rate limiting. You can quickly improve the security of your applications by limiting people’s ability to spam your POST endpoints, especially login and signup.You may go even further by setting up a Web Applications Firewall (WAF). A WAF lets developers implement elaborate security rules. This is not something you would set up directly in your application but rather at the host level. For instance, Vercel has released its own WAF in 2024.Number 6: Vulnerable And Outdated ComponentsWe have discussed supply chain attacks earlier. Outdated components are a variation of this vulnerability, where you actually are the person to blame. Sorry about that.Security vulnerabilities are often discovered ahead of time by diligent security analysts before a mean attacker can even start thinking about exploiting them. Thanks, analysts friends! When this happens, they fill out a Common Vulnerabilities and Exposure and store that in a public database.The remedy is the same as for supply chain attacks: set up an SCA solution like Dependabot that will regularly check for the use of vulnerable packages in your application.Your app depends on many packages. Sadly, some of them are probably affected by vulnerabilities that can spread to your application. (Large preview)Halfway breakI just want to mention at this point how much progress we have made since the beginning of this article. To sum it up:We know how to recognize an SSRF. This is a nasty vulnerability, and it is easy to accidentally introduce while crafting a super cool feature.We have identified monitoring and dependency analysis solutions as important pieces of “support” software for securing applications.We have figured out a good use case for Next.js edge middlewares: rate limiting our authentication endpoints to prevent brute force attacks.It’s a good time to go grab a tea or coffee. But after that, come back with us because we are going to discover the five most common vulnerabilities affecting web applications!Number 5: Security MisconfigurationThere are so many configurations that we can mismanage. But let’s focus on the most insightful ones for a web developer learning about security: HTTP headers.You can use HTTP response headers to pass on a lot of information to the user’s browser about what’s possible or not on your website.For example, by narrowing down the “Permissions-Policy” headers, you can claim that your website will never require access to the user’s camera. This is an extremely powerful protection mechanism in case of a script injection attack (XSS). Even if the hacker manages to run a malicious script in the victim’s browser, the latter will not allow the script to access the camera.I invite you to observe the security configuration of any template or boilerplate that you use to craft your own websites. Do you understand them properly? Can you improve them? Answering these questions will inevitably lead you to vastly increase the safety of your websites!Number 4: Insecure DesignI find this one funny, although a bit insulting for us developers.Bad code is literally the fourth most common cause of vulnerabilities in web applications! You can’t just blame your infrastructure team anymore.Design is actually not just about code but about the way we use our programming tools to produce software artifacts.Bad design can create vulnerabilities that are very hard to detect. The cure is good design, and good design is a lot of learning. Keep reading curated learning resources, and everything will be ok! (Large preview)In the context of full-stack JavaScript frameworks, I would recommend learning how to use them idiomatically, the same way you’d want to learn a foreign language. It’s not just about translating what you already know word-by-word. You need to get a grasp of how a native speaker would phrase their thoughts.Learning idiomatic Next.js is really, really hard. Trust me, I teach this framework to web developers. Next is all about client and server logic hybridization, and some patterns may not even transfer to competing frameworks with a different architecture like Astro.js or Remix.Hopefully, the Next.js core team has produced many free learning resources, including articles and documentation specifically focusing on security.I recommend reading Sebastian Markbåge’s famous article “How to Think About Security in Next.js” as a starting point. If you use Next.js in a professional setting, consider organizing proper training sessions before you start working on high-stakes projects.Number 3: InjectionInjections are the epitome of vulnerabilities, the quintessence of breaches, and the paragon of security issues. SQL injections are typically very famous, but JavaScript injections are also quite common. Despite being well-known vulnerabilities, injections are still in the top 3 in the OWASP ranking!Injections are the reason why forcing a React component to render HTML is done through an unwelcoming `dangerouslySetInnerHTML` function.React doesn’t want you to include user input that could contain a malicious script.The screenshot below is a demonstration of an injection using images. It could target a message board, for instance. The attacker misused the image posting system. They passed a URL that points towards an API GET endpoint instead of an actual image. Whenever your website’s users see this post in their browser, an authenticated request is fired against your backend, triggering a payment!As a bonus, having a GET endpoint that triggers side-effects such as payment also constitutes a risk of Cross-Site Request Forgery (CSRF, which happens to be SSRF client-side cousin).This image will trigger payments using the end user’s identity when displayed! The mistake lies in using a GET endpoint to trigger payments instead of a POST endpoint. (Large preview)Even experienced developers can be caught off-guard. Are you aware that dynamic route parameters are user inputs? For instance, [language]/page.jsx in a Next.js or Astro app. I often see clumsy attack attempts when logging them, like “language” being replaced by a path traversal like ../../../../passwords.txt.Zod is a very popular library for running server-side data validation of user inputs. You can add a transform step to sanitize inputs included in database queries, or that could land in places where they end up being executed as code.Number 2: Cryptographic FailuresA typical discussion between two developers that are in deep, deep trouble:— We have leaked our database and encryption key. What algorithm was used to encrypt the password again? AES-128 or SHA-512?— I don’t know, aren’t they the same thing? They transform passwords into gibberish, right?— Alright. We are in deep, deep trouble.This vulnerability mostly concerns backend developers who have to deal with sensitive personal identifiers (PII) or passwords.To be honest, I don’t know much about these algorithms; I studied computer science way too long ago.The only thing I remember is that you need non-reversible algorithms to encrypt passwords, aka hashing algorithms. The point is that if the encrypted passwords are leaked, and the encryption key is also leaked, it will still be super hard to hack an account (you can’t just reverse the encryption).In the State of JavaScript survey, we use passwordless authentication with an email magic link and one-way hash emails, so even as admins, we cannot guess a user’s email in our database.A hashed email generated when a user creates an account: it can’t be reversed even when possessing the encryption key. (Large preview)And number 1 is…Such suspense! We are about to discover that the top 1 vulnerability in the world of web development is…Broken Access Control! Tada.Yeah, the name is not super insightful, so let me rephrase it. It’s about people being able to access other people’s accounts or people being able to access resources they are not allowed to. That’s more impressive when put this way.A while ago, I wrote an article about the fact that checking authorization within a layout may leave page content unprotected in Next.js. It’s not a flaw in the framework’s design but a consequence of how React Server Components have a different model than their client counterparts, which then affects how the layout works in Next.Here is a demo of how you can implement a paywall in Next.js that doesn’t protect anything.// app/layout.jsx // Using cookie-based authentication as usual async function checkPaid() { const token = cookies.get(\"auth_token\"); return await db.hasPayments(token); } // Running the payment check in a layout to apply it to all pages // Sadly, this is not how Next.js works! export default async function Layout() { // ❌ this won't work as expected!! const hasPaid = await checkPaid(); if (!hasPaid) redirect(\"/subscribe\"); // then render the underlying page return \u003cdiv\u003e{children}\u003c/div\u003e; } // ❌ this can be accessed directly // by adding “RSC=1” to the request that fetches it! export default function Page() { return \u003cdiv\u003ePAID CONTENT\u003c/div\u003e } What We Have Learned From The Top 5 VulnerabilitiesMost common vulnerabilities are tightly related to application design issues:Copy-pasting configuration without really understanding it.Having an improper understanding of the framework we use in inner working. Next.js is a complex beast and doesn’t make our life easier on this point!Picking an algorithm that is not suited for a given task.These vulnerabilities are tough ones because they confront us to our own limits as web developers. Nobody is perfect, and the most experienced developers will inevitably write vulnerable code at some point in their lives without even noticing.How to prevent that? By not staying alone! When in doubt, ask around fellow developers; there are great chances that someone has faced the same issues and can lead you to the right solutions.Where To Head Now?First, I must insist that you have already done a great job of improving the security of your applications by reading this article. Congratulations!Most hackers rely on a volume strategy and are not particularly skilled, so they are really in pain when confronted with educated developers who can spot and fix the most common vulnerabilities.By discovering how the OWASP top 10 can affect full-stack JavaScript applications, you’ve just made hackers’ lives much harder! (Large preview)From there, I can suggest a few directions to get even better at securing your web applications:Try to apply the OWASP top 10 to an application you know well, either a personal project, your company’s codebase, or an open-source solution.Give a shot at some third-party security tools. They tend to overflow developers with too much information but keep in mind that most actors in the field of security are aware of this issue and work actively to provide more focused vulnerability alerts.I’ve added my favorite security-related resources at the end of the article, so you’ll have plenty to read!Thanks for reading, and stay secure!Resources For Further LearningAn interactive demo of an SSRF in a Next.js app and how to fix itOWASP Top 10An SSRF vulnerability that affected Next.js image optimization systemObserve React Server Components using Open TelemetryOpenTelemetry and open source Telemtry standardLog4J vulnerabilitySetting up rate limiting in a middleware using a Redis serviceVercel WAF annoucementMitre CVE databaseAn interactive demo of a CSRF vulnerability in a Next.js app and how to fix itA super complete guide on authentication specifically targeting web appsServer form validation with zod in Next.js (Astro has it built-in)Sanitization with zodSecure statically rendered paid content in Next.js and how layouts are a bad place to run authentication checksSmashing Magazine articles related to security (almost 50 matches at the time of writing!)This article is inspired by my talk at React Advanced London 2024, “Securing Server-Rendered Applications: Next.js case,” which is available to watch as a replay online. (yk)",
  "image": "https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/how-owasp-helps-secure-full-stack-web-applications.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e14 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/privacy\"\u003ePrivacy\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/apps\"\u003eApps\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/tools\"\u003eTools\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eThe OWASP vulnerabilities list is the perfect starting point for web developers looking to strengthen their security expertise. Let’s discover how these vulnerabilities materialize in full-stack web applications and how to prevent them.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eSecurity can be an intimidating topic for web developers. The vocabulary is rich and full of acronyms. Trends evolve quickly as hackers and analysts play a perpetual cat-and-mouse game. Vulnerabilities stem from little details we cannot afford to spend too much time on during our day-to-day operations.\u003c/p\u003e\u003cp\u003eJavaScript developers already have a lot to take with the emergence of a new wave of innovative architectures, such as React Server Components, Next.js App Router, or Astro islands.\u003c/p\u003e\u003cp\u003eSo, let’s have a focused approach. What we need is to be able to \u003cstrong\u003edetect\u003c/strong\u003e and \u003cstrong\u003epalliate the most common security issues\u003c/strong\u003e. A top ten of the most common vulnerabilities would be ideal.\u003c/p\u003e\u003ch2 id=\"meet-the-owasp-top-10\"\u003eMeet The OWASP Top 10\u003c/h2\u003e\u003cp\u003eGuess what: there happens to be such a top ten of the most common vulnerabilities, curated by experts in the field!\u003c/p\u003e\u003cp\u003eIt is provided by the \u003cstrong\u003eOWASP Foundation\u003c/strong\u003e, and it’s an extremely valuable resource for getting started with security.\u003c/p\u003e\u003cp\u003eOWASP stands for “Open Worldwide Application Security Project.” It’s a nonprofit foundation whose goal is to make software more secure globally. It supports many open-source projects and produces high-quality education resources, including the OWASP top 10 vulnerabilities list.\u003c/p\u003e\u003cp\u003eWe will dive through each item of the OWASP top 10 to understand \u003cem\u003ehow\u003c/em\u003e to recognize these vulnerabilities in a full-stack application.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eI will use Next.js as an example, but this knowledge applies to any similar full-stack architecture, even outside of the JavaScript ecosystem.\u003c/em\u003e\u003c/p\u003e\u003cp\u003eLet’s start our countdown towards a safer web!\u003c/p\u003e\u003ch2 id=\"number-10-server-side-request-forgery-ssrf\"\u003eNumber 10: Server-Side Request Forgery (SSRF)\u003c/h2\u003e\u003cp\u003eYou may have heard about Server-Side Rendering, aka SSR. Well, you can consider SSRF to be its evil twin acronym.\u003c/p\u003e\u003cp\u003eServer-Side Request Forgery can be summed up as \u003cstrong\u003eletting an attacker fire requests using your backend server\u003c/strong\u003e. Besides hosting costs that may rise up, the main problem is that the attacker will benefit from your server’s level of accreditation. In a complex architecture, this means being able to target your internal private services using your own corrupted server.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"501\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg\" sizes=\"100vw\" alt=\"SSR is good vs SSRF is bad\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eSSR is good, but SSRF is bad! (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/ssr-good-ssrf-bad.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eHere is an example. Our app lets a user input a URL and summarizes the content of the target page server-side using an AI SDK. A mischievous user passes \u003ccode\u003elocalhost:3000\u003c/code\u003e as the URL instead of a website they’d like to summarize. Your server will fire a request against itself or any other service running on port 3000 in your backend infrastructure. This is a severe SSRF vulnerability!\u003c/p\u003e\u003cp\u003eYou’ll want to be careful when firing requests based on user inputs, especially server-side.\u003c/p\u003e\u003ch2 id=\"number-9-security-logging-and-monitoring-failures\"\u003eNumber 9: Security Logging And Monitoring Failures\u003c/h2\u003e\u003cp\u003eI wish we could establish a telepathic connection with our beloved Node.js server running in the backend. Instead, the best thing we have to see what happens in the cloud is a dreadful stream of unstructured pieces of text we name “logs.”\u003c/p\u003e\u003cp\u003eYet we will have to deal with that, not only for debugging or performance optimization but also because \u003cstrong\u003elogs are often the only information you’ll get to discover and remediate a security issue\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eAs a starter, you might want to focus on logging the most important transactions of your application exactly like you would prioritize writing end-to-end tests. In most applications, this means login, signup, payouts, mail sending, and so on. In a bigger company, a more complete telemetry solution is a must-have, such as Open Telemetry, Sentry, or Datadog.\u003c/p\u003e\u003cp\u003eIf you are using React Server Components, you may need to set up a proper logging strategy anyway since it’s not possible to debug them directly from the browser as we used to do for Client components.\u003c/p\u003e\u003ch2 id=\"number-8-software-and-data-integrity-failures\"\u003eNumber 8: Software And Data Integrity Failures\u003c/h2\u003e\u003cp\u003eThe OWASP top 10 vulnerabilities tend to have various levels of granularity, and this one is really a big family. I’d like to focus on \u003cstrong\u003esupply chain attacks\u003c/strong\u003e, as they have gained a lot of popularity over the years.\u003c/p\u003e\u003cp\u003eYou may have heard about the \u003cstrong\u003eLog4J vulnerability\u003c/strong\u003e. It was very publicized, very critical, and very exploited by hackers. It’s a massive supply chain attack.\u003c/p\u003e\u003cp\u003eIn the JavaScript ecosystem, you most probably install your dependencies using NPM. Before picking dependencies, you might want to craft yourself a small list of health indicators.\u003c/p\u003e\u003cul\u003e\u003cli\u003eIs the library maintained and tested with proper code?\u003c/li\u003e\u003cli\u003eDoes it play a critical role in my application?\u003c/li\u003e\u003cli\u003eWho is the main contributor?\u003c/li\u003e\u003cli\u003eDid I spell it right when installing?\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor more serious business, you might want to consider setting up a \u003cstrong\u003eSupply Chain Analysis (SCA)\u003c/strong\u003e solution; GitHub’s Dependabot is a free one, and Snyk and Datadog are other famous actors.\u003c/p\u003e\u003ch2 id=\"number-7-identification-and-authentication-failures\"\u003eNumber 7: Identification And Authentication Failures\u003c/h2\u003e\u003cp\u003eHere is a stereotypical vulnerability belonging to this category: your admin password is leaked. A hacker finds it. Boom, game over.\u003c/p\u003e\u003cp\u003ePassword management procedures are beyond the scope of this article, but in the context of full-stack web development, let’s dive deep into how we can prevent brute force attacks using Next.js edge middlewares.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMiddlewares\u003c/strong\u003e are tiny proxies written in JavaScript. They process requests in a way that is supposed to be very, very fast, faster than a normal Node.js endpoint, for example. They are a good fit for handling \u003cstrong\u003elow-level processing\u003c/strong\u003e, like blocking malicious IPs or redirecting users towards the correct translation of a page.\u003c/p\u003e\u003cp\u003eOne interesting use case is \u003cstrong\u003erate limiting\u003c/strong\u003e. You can quickly improve the security of your applications by limiting people’s ability to spam your POST endpoints, especially login and signup.\u003c/p\u003e\u003cp\u003eYou may go even further by setting up a \u003cstrong\u003eWeb Applications Firewall (WAF)\u003c/strong\u003e. A WAF lets developers implement elaborate security rules. This is not something you would set up directly in your application but rather at the host level. For instance, Vercel has released its own WAF in 2024.\u003c/p\u003e\u003ch2 id=\"number-6-vulnerable-and-outdated-components\"\u003eNumber 6: Vulnerable And Outdated Components\u003c/h2\u003e\u003cp\u003eWe have discussed supply chain attacks earlier. Outdated components are a variation of this vulnerability, where you actually are the person to blame. Sorry about that.\u003c/p\u003e\u003cp\u003eSecurity vulnerabilities are often discovered ahead of time by diligent security analysts before a mean attacker can even start thinking about exploiting them. Thanks, analysts friends! When this happens, they fill out a \u003cstrong\u003eCommon Vulnerabilities and Exposure\u003c/strong\u003e and store that in a public database.\u003c/p\u003e\u003cp\u003eThe remedy is the same as for supply chain attacks: set up an SCA solution like Dependabot that will regularly check for the use of vulnerable packages in your application.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"501\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg\" sizes=\"100vw\" alt=\"A visualization showing that an app depends on packages and some of them can be vulnerable\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eYour app depends on many packages. Sadly, some of them are probably affected by vulnerabilities that can spread to your application. (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/vulnerable-components.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"halfway-break\"\u003eHalfway break\u003c/h2\u003e\u003cp\u003eI just want to mention at this point how much progress we have made since the beginning of this article. To sum it up:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWe know how to recognize an SSRF. This is a nasty vulnerability, and it is easy to accidentally introduce while crafting a super cool feature.\u003c/li\u003e\u003cli\u003eWe have identified monitoring and dependency analysis solutions as important pieces of “support” software for securing applications.\u003c/li\u003e\u003cli\u003eWe have figured out a good use case for Next.js edge middlewares: rate limiting our authentication endpoints to prevent brute force attacks.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIt’s a good time to go grab a tea or coffee. But after that, come back with us because we are going to discover the five most common vulnerabilities affecting web applications!\u003c/p\u003e\u003ch2 id=\"number-5-security-misconfiguration\"\u003eNumber 5: Security Misconfiguration\u003c/h2\u003e\u003cp\u003eThere are so many configurations that we can mismanage. But let’s focus on the most insightful ones for a web developer learning about security: \u003cstrong\u003eHTTP headers\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eYou can use HTTP response headers to pass on a lot of information to the user’s browser about what’s possible or not on your website.\u003c/p\u003e\u003cp\u003eFor example, by narrowing down the “Permissions-Policy” headers, you can claim that your website will never require access to the user’s camera. This is an extremely powerful protection mechanism in case of a \u003cstrong\u003escript injection attack (XSS)\u003c/strong\u003e. Even if the hacker manages to run a malicious script in the victim’s browser, the latter will not allow the script to access the camera.\u003c/p\u003e\u003cp\u003eI invite you to observe the security configuration of any template or boilerplate that you use to craft your own websites. \u003cem\u003eDo you understand them properly?\u003c/em\u003e \u003cem\u003eCan you improve them?\u003c/em\u003e Answering these questions will inevitably lead you to vastly increase the safety of your websites!\u003c/p\u003e\u003ch2 id=\"number-4-insecure-design\"\u003eNumber 4: Insecure Design\u003c/h2\u003e\u003cp\u003eI find this one funny, although a bit insulting for us developers.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aBad%20code%20is%20literally%20the%20fourth%20most%20common%20cause%20of%20vulnerabilities%20in%20web%20applications!%20You%20can%e2%80%99t%20just%20blame%20your%20infrastructure%20team%20anymore.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f02%2fhow-owasp-helps-secure-full-stack-web-applications%2f\"\u003eBad code is literally the fourth most common cause of vulnerabilities in web applications! You can’t just blame your infrastructure team anymore.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eDesign is actually not just about code but about \u003cstrong\u003ethe way we use our programming tools\u003c/strong\u003e to produce software artifacts.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg\" sizes=\"100vw\" alt=\"A visualization with bad design\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eBad design can create vulnerabilities that are very hard to detect. The cure is good design, and good design is a lot of learning. Keep reading curated learning resources, and everything will be ok! (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/bad-design.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIn the context of full-stack JavaScript frameworks, I would recommend learning how to use them \u003cstrong\u003eidiomatically\u003c/strong\u003e, the same way you’d want to learn a foreign language. It’s not just about translating what you already know word-by-word. You need to get a grasp of how a native speaker would phrase their thoughts.\u003c/p\u003e\u003cp\u003eLearning idiomatic Next.js is really, really hard. Trust me, I teach this framework to web developers. Next is all about client and server logic hybridization, and some patterns may not even transfer to competing frameworks with a different architecture like Astro.js or Remix.\u003c/p\u003e\u003cp\u003eHopefully, the Next.js core team has produced many free learning resources, including articles and documentation specifically focusing on security.\u003c/p\u003e\u003cp\u003eI recommend reading Sebastian Markbåge’s famous article “\u003ca href=\"https://nextjs.org/blog/security-nextjs-server-components-actions\"\u003eHow to Think About Security in Next.js\u003c/a\u003e” as a starting point. If you use Next.js in a professional setting, consider organizing proper training sessions before you start working on high-stakes projects.\u003c/p\u003e\u003ch2 id=\"number-3-injection\"\u003eNumber 3: Injection\u003c/h2\u003e\u003cp\u003eInjections are the epitome of vulnerabilities, the quintessence of breaches, and the paragon of security issues. SQL injections are typically very famous, but JavaScript injections are also quite common. Despite being well-known vulnerabilities, injections are still in the top 3 in the OWASP ranking!\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003ca aria-label=\"Share on Twitter\" href=\"https://twitter.com/share?text=%0aInjections%20are%20the%20reason%20why%20forcing%20a%20React%20component%20to%20render%20HTML%20is%20done%20through%20an%20unwelcoming%20%60dangerouslySetInnerHTML%60%20function.%0a\u0026amp;url=https://smashingmagazine.com%2f2025%2f02%2fhow-owasp-helps-secure-full-stack-web-applications%2f\"\u003eInjections are the reason why forcing a React component to render HTML is done through an unwelcoming `dangerouslySetInnerHTML` function.\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eReact doesn’t want you to include user input that could contain a malicious script.\u003c/p\u003e\u003cp\u003eThe screenshot below is a demonstration of an injection using images. It could target a message board, for instance. The attacker misused the image posting system. They passed a URL that points towards an API GET endpoint instead of an actual image. Whenever your website’s users see this post in their browser, an authenticated request is fired against your backend, triggering a payment!\u003c/p\u003e\u003cp\u003eAs a bonus, having a GET endpoint that triggers side-effects such as payment also constitutes a risk of \u003cstrong\u003eCross-Site Request Forgery\u003c/strong\u003e (CSRF, which happens to be SSRF client-side cousin).\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"375\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png\" sizes=\"100vw\" alt=\"Cross-Site Request Forgery example\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eThis image will trigger payments using the end user’s identity when displayed! The mistake lies in using a GET endpoint to trigger payments instead of a POST endpoint. (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/csrf-hacked.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eEven experienced developers can be caught off-guard. Are you aware that dynamic route parameters are user inputs? For instance, \u003ccode\u003e[language]/page.jsx\u003c/code\u003e in a Next.js or Astro app. I often see clumsy attack attempts when logging them, like “language” being replaced by a path traversal like \u003ccode\u003e../../../../passwords.txt\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eZod\u003c/strong\u003e is a very popular library for running server-side data validation of user inputs. You can add a transform step to sanitize inputs included in database queries, or that could land in places where they end up being executed as code.\u003c/p\u003e\u003ch2 id=\"number-2-cryptographic-failures\"\u003eNumber 2: Cryptographic Failures\u003c/h2\u003e\u003cp\u003eA typical discussion between two developers that are in deep, deep trouble:\u003c/p\u003e\u003cblockquote\u003e— We have leaked our database and encryption key. What algorithm was used to encrypt the password again? AES-128 or SHA-512?\u003cbr/\u003e— I don’t know, aren’t they the same thing? They transform passwords into gibberish, right?\u003cbr/\u003e— Alright. We are in deep, deep trouble.\u003c/blockquote\u003e\u003cp\u003eThis vulnerability mostly concerns backend developers who have to deal with \u003cstrong\u003esensitive personal identifiers (PII)\u003c/strong\u003e or \u003cstrong\u003epasswords\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eTo be honest, I don’t know much about these algorithms; I studied computer science way too long ago.\u003c/p\u003e\u003cp\u003eThe only thing I remember is that you need \u003cstrong\u003enon-reversible algorithms to encrypt passwords\u003c/strong\u003e, aka hashing algorithms. The point is that if the encrypted passwords are leaked, and the encryption key is also leaked, it will still be super hard to hack an account (you can’t just reverse the encryption).\u003c/p\u003e\u003cp\u003eIn the State of JavaScript survey, we use passwordless authentication with an email magic link and one-way hash emails, so even as admins, we cannot guess a user’s email in our database.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"177\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png\" sizes=\"100vw\" alt=\"A hashed email\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eA hashed email generated when a user creates an account: it can’t be reversed even when possessing the encryption key. (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/encrypted-email.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"and-number-1-is\"\u003eAnd number 1 is…\u003c/h2\u003e\u003cp\u003eSuch suspense! We are about to discover that the top 1 vulnerability in the world of web development is…\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBroken Access Control!\u003c/strong\u003e Tada.\u003c/p\u003e\u003cp\u003eYeah, the name is not super insightful, so let me rephrase it. It’s about people being able to access other people’s accounts or people being able to access resources they are not allowed to. That’s more impressive when put this way.\u003c/p\u003e\u003cp\u003eA while ago, I wrote an article about the fact that \u003ca href=\"https://www.ericburel.tech/blog/static-paid-content-app-router\"\u003e\u003cstrong\u003echecking authorization within a layout may leave page content unprotected in Next.js\u003c/strong\u003e\u003c/a\u003e. It’s not a flaw in the framework’s design but a consequence of how React Server Components have a different model than their client counterparts, which then affects how the layout works in Next.\u003c/p\u003e\u003cp\u003eHere is a demo of how you can implement a paywall in Next.js that doesn’t protect anything.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// app/layout.jsx\n// Using cookie-based authentication as usual\nasync function checkPaid() {\n  const token = cookies.get(\u0026#34;auth_token\u0026#34;);\n  return await db.hasPayments(token);\n}\n// Running the payment check in a layout to apply it to all pages\n// Sadly, this is not how Next.js works!\nexport default async function Layout() {\n  // ❌ this won\u0026#39;t work as expected!!\n  const hasPaid = await checkPaid();\n  if (!hasPaid) redirect(\u0026#34;/subscribe\u0026#34;);\n  // then render the underlying page\n  return \u0026lt;div\u0026gt;{children}\u0026lt;/div\u0026gt;;\n}\n// ❌ this can be accessed directly\n// by adding “RSC=1” to the request that fetches it!\nexport default function Page() {\n  return \u0026lt;div\u0026gt;PAID CONTENT\u0026lt;/div\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"what-we-have-learned-from-the-top-5-vulnerabilities\"\u003eWhat We Have Learned From The Top 5 Vulnerabilities\u003c/h2\u003e\u003cp\u003eMost common vulnerabilities are tightly related to application design issues:\u003c/p\u003e\u003cul\u003e\u003cli\u003eCopy-pasting configuration without really understanding it.\u003c/li\u003e\u003cli\u003eHaving an improper understanding of the framework we use in inner working. Next.js is a complex beast and doesn’t make our life easier on this point!\u003c/li\u003e\u003cli\u003ePicking an algorithm that is not suited for a given task.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese vulnerabilities are tough ones because they confront us to our own limits as web developers. Nobody is perfect, and the most experienced developers will inevitably write vulnerable code at some point in their lives without even noticing.\u003c/p\u003e\u003cp\u003eHow to prevent that? By not staying alone! When in doubt, ask around fellow developers; there are great chances that someone has faced the same issues and can lead you to the right solutions.\u003c/p\u003e\u003ch2 id=\"where-to-head-now\"\u003eWhere To Head Now?\u003c/h2\u003e\u003cp\u003eFirst, I must insist that you have already done a great job of improving the security of your applications by reading this article. Congratulations!\u003c/p\u003e\u003cp\u003eMost hackers rely on a volume strategy and are not particularly skilled, so they are really in pain when confronted with educated developers who can spot and fix the most common vulnerabilities.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"500\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg\" sizes=\"100vw\" alt=\"OWASP top 10\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eBy discovering how the OWASP top 10 can affect full-stack JavaScript applications, you’ve just made hackers’ lives much harder! (\u003ca href=\"https://files.smashing.media/articles/how-owasp-helps-secure-full-stack-web-applications/owasp.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eFrom there, I can suggest a few directions to get even better at securing your web applications:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eTry to apply the OWASP top 10 to an application you know well\u003c/strong\u003e, either a personal project, your company’s codebase, or an open-source solution.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eGive a shot at some third-party security tools.\u003c/strong\u003e They tend to overflow developers with too much information but keep in mind that most actors in the field of security are aware of this issue and work actively to provide more focused vulnerability alerts.\u003c/li\u003e\u003cli\u003eI’ve added my favorite \u003cstrong\u003esecurity-related resources\u003c/strong\u003e at the end of the article, so you’ll have plenty to read!\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThanks for reading, and stay secure!\u003c/p\u003e\u003ch3 id=\"resources-for-further-learning\"\u003eResources For Further Learning\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://nextpatterns.dev/p/security/ssrf-server-action\"\u003eAn interactive demo of an SSRF in a Next.js app and how to fix it\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://owasp.org/www-project-top-ten/\"\u003eOWASP Top 10\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.assetnote.io/resources/research/digging-for-ssrf-in-nextjs-apps\"\u003eAn SSRF vulnerability that affected Next.js image optimization system\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.dash0.com/blog/how-to-inspect-react-server-component-activity-with-next-js\"\u003eObserve React Server Components using Open Telemetry\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://opentelemetry.io/\"\u003eOpenTelemetry and open source Telemtry standard\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.ibm.com/think/topics/log4j\"\u003eLog4J vulnerability\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://upstash.com/blog/edge-rate-limiting\"\u003eSetting up rate limiting in a middleware using a Redis service\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://vercel.com/blog/introducing-the-vercel-waf\"\u003eVercel WAF annoucement\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://cve.mitre.org/\"\u003eMitre CVE database\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://nextpatterns.dev/p/security/csrf-image\"\u003eAn interactive demo of a CSRF vulnerability in a Next.js app and how to fix it\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/\"\u003eA super complete guide on authentication specifically targeting web apps\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations#server-side-form-validation\"\u003eServer form validation with zod in Next.js\u003c/a\u003e (Astro has it built-in)\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/colinhacks/zod/discussions/1358\"\u003eSanitization with zod\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.ericburel.tech/blog/static-paid-content-app-router\"\u003eSecure statically rendered paid content in Next.js and how layouts are a bad place to run authentication checks\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.smashingmagazine.com/search/?q=security\"\u003eSmashing Magazine articles related to security\u003c/a\u003e (almost 50 matches at the time of writing!)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cem\u003eThis article is inspired by my talk at React Advanced London 2024, “\u003ca href=\"https://gitnation.com/contents/securing-server-rendered-applications-nextjs-case\"\u003eSecuring Server-Rendered Applications: Next.js case\u003c/a\u003e,” which is available to watch as a replay online.\u003c/em\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "19 min read",
  "publishedTime": "2025-02-18T08:00:00Z",
  "modifiedTime": "2025-02-18T08:00:00Z"
}
