{
  "id": "a89cb3d1-ad4f-4d00-a14b-501608acb4ae",
  "title": "Handling JavaScript Event Listeners With Parameters",
  "link": "https://smashingmagazine.com/2025/07/handling-javascript-event-listeners-parameters/",
  "description": "Event listeners are essential for interactivity in JavaScript, but they can quietly cause memory leaks if not removed properly. And what if your event listener needs parameters? That’s where things get interesting. Amejimaobari Ollornwi shares which JavaScript features make handling parameters with event handlers both possible and well-supported.",
  "author": "Amejimaobari Ollornwi",
  "published": "Mon, 21 Jul 2025 10:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 6800,
  "excerpt": "Event listeners are essential for interactivity in JavaScript, but they can quietly cause memory leaks if not removed properly. And what if your event listener needs parameters? That’s where things get interesting. Amejimaobari Ollornwi shares which JavaScript features make handling parameters with event handlers both possible and well-supported.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "5 min readJavaScript, Coding, TechniquesEvent listeners are essential for interactivity in JavaScript, but they can quietly cause memory leaks if not removed properly. And what if your event listener needs parameters? That’s where things get interesting. Amejimaobari Ollornwi shares which JavaScript features make handling parameters with event handlers both possible and well-supported.JavaScript event listeners are very important, as they exist in almost every web application that requires interactivity. As common as they are, it is also essential for them to be managed properly. Improperly managed event listeners can lead to memory leaks and can sometimes cause performance issues in extreme cases.Here’s the real problem: JavaScript event listeners are often not removed after they are added. And when they are added, they do not require parameters most of the time — except in rare cases, which makes them a little trickier to handle.A common scenario where you may need to use parameters with event handlers is when you have a dynamic list of tasks, where each task in the list has a “Delete” button attached to an event handler that uses the task’s ID as a parameter to remove the task. In a situation like this, it is a good idea to remove the event listener once the task has been completed to ensure that the deleted element can be successfully cleaned up, a process known as garbage collection.A Common Mistake When Adding Event ListenersA very common mistake when adding parameters to event handlers is calling the function with its parameters inside the addEventListener() method. This is what I mean:button.addEventListener('click', myFunction(param1, param2)); The browser responds to this line by immediately calling the function, irrespective of whether or not the click event has happened. In other words, the function is invoked right away instead of being deferred, so it never fires when the click event actually occurs.You may also receive the following console error in some cases:Uncaught TypeError: Failed to execute. addEventListener on EventTarget: parameter is not of type Object. (Large preview)This error makes sense because the second parameter of the addEventListener method can only accept a JavaScript function, an object with a handleEvent() method, or simply null. A quick and easy way to avoid this error is by changing the second parameter of the addEventListener method to an arrow or anonymous function.button.addEventListener('click', (event) =\u003e { myFunction(event, param1, param2); // Runs on click }); The only hiccup with using arrow and anonymous functions is that they cannot be removed with the traditional removeEventListener() method; you will have to make use of AbortController, which may be overkill for simple cases. AbortController shines when you have multiple event listeners to remove at once.For simple cases where you have just one or two event listeners to remove, the removeEventListener() method still proves useful. However, in order to make use of it, you’ll need to store your function as a reference to the listener.Using Parameters With Event HandlersThere are several ways to include parameters with event handlers. However, for the purpose of this demonstration, we are going to constrain our focus to the following two:Option 1: Arrow And Anonymous FunctionsUsing arrow and anonymous functions is the fastest and easiest way to get the job done.To add an event handler with parameters using arrow and anonymous functions, we’ll first need to call the function we’re going to create inside the arrow function attached to the event listener:const button = document.querySelector(\"#myButton\"); button.addEventListener(\"click\", (event) =\u003e { handleClick(event, \"hello\", \"world\"); }); After that, we can create the function with parameters:function handleClick(event, param1, param2) { console.log(param1, param2, event.type, event.target); } Note that with this method, removing the event listener requires the AbortController. To remove the event listener, we create a new AbortController object and then retrieve the AbortSignal object from it:const controller = new AbortController(); const { signal } = controller; Next, we can pass the signal from the controller as an option in the removeEventListener() method:button.addEventListener(\"click\", (event) =\u003e { handleClick(event, \"hello\", \"world\"); }, { signal }); Now we can remove the event listener by calling AbortController.abort():controller.abort() Option 2: ClosuresClosures in JavaScript are another feature that can help us with event handlers. Remember the mistake that produced a type error? That mistake can also be corrected with closures. Specifically, with closures, a function can access variables from its outer scope.In other words, we can access the parameters we need in the event handler from the outer function:function createHandler(message, number) { // Event handler return function (event) { console.log(`${message} ${number} - Clicked element:`, event.target); }; } const button = document.querySelector(\"#myButton\"); button.addEventListener(\"click\", createHandler(\"Hello, world!\", 1)); } This establishes a function that returns another function. The function that is created is then called as the second parameter in the addEventListener() method so that the inner function is returned as the event handler. And with the power of closures, the parameters from the outer function will be made available for use in the inner function.Notice how the event object is made available to the inner function. This is because the inner function is what is being attached as the event handler. The event object is passed to the function automatically because it’s the event handler.To remove the event listener, we can use the AbortController like we did before. However, this time, let’s see how we can do that using the removeEventListener() method instead.In order for the removeEventListener method to work, a reference to the createHandler function needs to be stored and used in the addEventListener method:function createHandler(message, number) { return function (event) { console.log(`${message} ${number} - Clicked element:`, event.target); }; } const handler = createHandler(\"Hello, world!\", 1); button.addEventListener(\"click\", handler); Now, the event listener can be removed like this:button.removeEventListener(\"click\", handler); ConclusionIt is good practice to always remove event listeners whenever they are no longer needed to prevent memory leaks. Most times, event handlers do not require parameters; however, in rare cases, they do. Using JavaScript features like closures, AbortController, and removeEventListener, handling parameters with event handlers is both possible and well-supported. (gg, yk)",
  "image": "https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/handling-javascript-event-listeners-parameters.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e5 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/javascript\"\u003eJavaScript\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/techniques\"\u003eTechniques\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eEvent listeners are essential for interactivity in JavaScript, but they can quietly cause memory leaks if not removed properly. And what if your event listener needs parameters? That’s where things get interesting. Amejimaobari Ollornwi shares which JavaScript features make handling parameters with event handlers both possible and well-supported.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eJavaScript event listeners are very important, as they exist in almost every web application that requires interactivity. As common as they are, it is also essential for them to be managed properly. Improperly managed event listeners can lead to memory leaks and can sometimes cause performance issues in extreme cases.\u003c/p\u003e\u003cp\u003eHere’s the real problem: \u003cstrong\u003eJavaScript event listeners are often not removed after they are added.\u003c/strong\u003e And when they are added, they do not require parameters most of the time — except in rare cases, which makes them a little trickier to handle.\u003c/p\u003e\u003cp\u003eA common scenario where you may need to use parameters with event handlers is when you have a dynamic list of tasks, where each task in the list has a “Delete” button attached to an event handler that uses the task’s ID as a parameter to remove the task. In a situation like this, it is a good idea to remove the event listener once the task has been completed to ensure that the deleted element can be successfully cleaned up, a process known as \u003ca href=\"https://javascript.info/garbage-collection\"\u003egarbage collecti\u003c/a\u003e\u003ca href=\"https://javascript.info/garbage-collection\"\u003eon\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"a-common-mistake-when-adding-event-listeners\"\u003eA Common Mistake When Adding Event Listeners\u003c/h2\u003e\u003cp\u003eA very common mistake when adding parameters to event handlers is calling the function with its parameters inside the \u003ccode\u003eaddEventListener()\u003c/code\u003e method. This is what I mean:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebutton.addEventListener(\u0026#39;click\u0026#39;, myFunction(param1, param2));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe browser responds to this line by immediately calling the function, irrespective of whether or not the click event has happened. In other words, the function is invoked right away instead of being deferred, so it never fires when the click event actually occurs.\u003c/p\u003e\u003cp\u003eYou may also receive the following console error in some cases:\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"75\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png\" sizes=\"100vw\" alt=\"Uncaught TypeError\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eUncaught TypeError: Failed to execute. \u003ccode\u003eaddEventListener\u003c/code\u003e on \u003ccode\u003eEventTarget\u003c/code\u003e: parameter is not of type \u003ccode\u003eObject\u003c/code\u003e. (\u003ca href=\"https://files.smashing.media/articles/handling-javascript-event-listeners-parameters/1-uncaught-typeerror.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThis error makes sense because the second parameter of the \u003ccode\u003eaddEventListener\u003c/code\u003e method \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#listener\"\u003ecan only accept\u003c/a\u003e a JavaScript function, an object with a \u003ccode\u003ehandleEvent()\u003c/code\u003e method, or simply \u003ccode\u003enull\u003c/code\u003e. A quick and easy way to avoid this error is by changing the second parameter of the \u003ccode\u003eaddEventListener\u003c/code\u003e method to an arrow or anonymous function.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebutton.addEventListener(\u0026#39;click\u0026#39;, (event) =\u0026gt; {\n  myFunction(event, param1, param2); // Runs on click\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe only hiccup with using arrow and anonymous functions is that they cannot be removed with the traditional \u003ccode\u003eremoveEventListener()\u003c/code\u003e method; you will have to make use of \u003ccode\u003eAbortController\u003c/code\u003e, which may be overkill for simple cases. \u003ccode\u003eAbortController\u003c/code\u003e shines when you have multiple event listeners to remove at once.\u003c/p\u003e\u003cp\u003eFor simple cases where you have just one or two event listeners to remove, the \u003ccode\u003eremoveEventListener()\u003c/code\u003e method still proves useful. However, in order to make use of it, you’ll need to store your function as a reference to the listener.\u003c/p\u003e\u003ch2 id=\"using-parameters-with-event-handlers\"\u003eUsing Parameters With Event Handlers\u003c/h2\u003e\u003cp\u003eThere are several ways to include parameters with event handlers. However, for the purpose of this demonstration, we are going to constrain our focus to the following two:\u003c/p\u003e\u003ch3 id=\"option-1-arrow-and-anonymous-functions\"\u003eOption 1: Arrow And Anonymous Functions\u003c/h3\u003e\u003cp\u003eUsing arrow and anonymous functions is the fastest and easiest way to get the job done.\u003c/p\u003e\u003cp\u003eTo add an event handler with parameters using arrow and anonymous functions, we’ll first need to call the function we’re going to create inside the arrow function attached to the event listener:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst button = document.querySelector(\u0026#34;#myButton\u0026#34;);\n\nbutton.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; {\n  handleClick(event, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;);\n});\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter that, we can create the function with parameters:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunction handleClick(event, param1, param2) {\n  console.log(param1, param2, event.type, event.target);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNote that with this method, removing the event listener requires the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\"\u003e\u003ccode\u003eAbortController\u003c/code\u003e\u003c/a\u003e. To remove the event listener, we create a new \u003ccode\u003eAbortController\u003c/code\u003e object and then retrieve the \u003ccode\u003eAbortSignal\u003c/code\u003e object from it:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econst controller = new AbortController();\nconst { signal } = controller;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext, we can pass the \u003ccode\u003esignal\u003c/code\u003e from the \u003ccode\u003econtroller\u003c/code\u003e as an option in the \u003ccode\u003eremoveEventListener()\u003c/code\u003e method:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebutton.addEventListener(\u0026#34;click\u0026#34;, (event) =\u0026gt; {\n  handleClick(event, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;);\n}, { signal });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we can remove the event listener by calling \u003ccode\u003eAbortController.abort()\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003econtroller.abort()\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"option-2-closures\"\u003eOption 2: Closures\u003c/h3\u003e\u003cp\u003eClosures in JavaScript are another feature that can help us with event handlers. Remember the mistake that produced a type error? That mistake can also be corrected with closures. Specifically, with closures, a function can access variables from its outer scope.\u003c/p\u003e\u003cp\u003eIn other words, we can access the parameters we need in the event handler from the outer function:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003efunction createHandler(message, number) {\n  // Event handler\n  return function (event) {\n  console.log(`${message} ${number} - Clicked element:`, event.target);\n    };\n  }\n\n  const button = document.querySelector(\u0026#34;#myButton\u0026#34;);\n  button.addEventListener(\u0026#34;click\u0026#34;, createHandler(\u0026#34;Hello, world!\u0026#34;, 1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis establishes a function that returns another function. The function that is created is then called as the second parameter in the \u003ccode\u003eaddEventListener()\u003c/code\u003e method so that the inner function is returned as the event handler. And with the power of closures, the parameters from the outer function will be made available for use in the inner function.\u003c/p\u003e\u003cp\u003eNotice how the \u003ccode\u003eevent\u003c/code\u003e object is made available to the inner function. This is because the inner function is what is being attached as the event handler. The event object is passed to the function automatically because it’s the event handler.\u003c/p\u003e\u003cp\u003eTo remove the event listener, we can use the \u003ccode\u003eAbortController\u003c/code\u003e like we did before. However, this time, let’s see how we can do that using the \u003ccode\u003eremoveEventListener()\u003c/code\u003e method instead.\u003c/p\u003e\u003cp\u003eIn order for the \u003ccode\u003eremoveEventListener\u003c/code\u003e method to work, a reference to the \u003ccode\u003ecreateHandler\u003c/code\u003e function needs to be stored and used in the \u003ccode\u003eaddEventListener\u003c/code\u003e method:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003efunction createHandler(message, number) {\n  return function (event) {\n    console.log(`${message} ${number} - Clicked element:`, event.target);\n  };\n}\nconst handler = createHandler(\u0026#34;Hello, world!\u0026#34;, 1);\nbutton.addEventListener(\u0026#34;click\u0026#34;, handler);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow, the event listener can be removed like this:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebutton.removeEventListener(\u0026#34;click\u0026#34;, handler);\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eIt is good practice to always remove event listeners whenever they are no longer needed to prevent memory leaks. Most times, event handlers do not require parameters; however, in rare cases, they do. Using JavaScript features like closures, \u003ccode\u003eAbortController\u003c/code\u003e, and \u003ccode\u003eremoveEventListener\u003c/code\u003e, handling parameters with event handlers is both possible and well-supported.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "8 min read",
  "publishedTime": "2025-07-21T10:00:00Z",
  "modifiedTime": "2025-07-21T10:00:00Z"
}
