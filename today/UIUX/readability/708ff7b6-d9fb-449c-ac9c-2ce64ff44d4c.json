{
  "id": "708ff7b6-d9fb-449c-ac9c-2ce64ff44d4c",
  "title": "Tight Mode: Why Browsers Produce Different Performance Results",
  "link": "https://smashingmagazine.com/2025/01/tight-mode-why-browsers-produce-different-performance-results/",
  "description": "We know that browsers do all sorts of different things under the hood. One of those things is the way they not only *fetch* resources like images and scripts from the server but how they [prioritize those resources](https://www.debugbear.com/blog/request-priorities?utm_campaign=sm-7). Chrome and Safari have implemented a “Tight Mode” that constrains which resources are loaded and in what order, but they each take drastically different approaches to it. With so little information about Tight Mode available, this article attempts a high-level explanation of what it is, what triggers it, and how it is treated differently in major browsers.",
  "author": "Geoff Graham",
  "published": "Thu, 09 Jan 2025 13:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 11985,
  "excerpt": "We know that browsers do all sorts of different things under the hood. One of those things is the way they not only *fetch* resources like images and scripts from the server but how they [prioritize those resources](https://www.debugbear.com/blog/request-priorities?utm_campaign=sm-7). Chrome and Safari have implemented a “Tight Mode” that constrains which resources are loaded and in what order, but they each take drastically different approaches to it. With so little information about Tight Mode available, this article attempts a high-level explanation of what it is, what triggers it, and how it is treated differently in major browsers.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "9 min readPerformance, Optimization, ToolsWe know that browsers do all sorts of different things under the hood. One of those things is the way they not only fetch resources like images and scripts from the server but how they prioritize those resources. Chrome and Safari have implemented a “Tight Mode” that constrains which resources are loaded and in what order, but they each take drastically different approaches to it. With so little information about Tight Mode available, this article attempts a high-level explanation of what it is, what triggers it, and how it is treated differently in major browsers.I was chatting with DebugBear’s Matt Zeunert and, in the process, he casually mentioned this thing called Tight Mode when describing how browsers fetch and prioritize resources. I wanted to nod along like I knew what he was talking about but ultimately had to ask: What the heck is “Tight” mode?What I got back were two artifacts, one of them being the following video of Akamai web performance expert Robin Marx speaking at We Love Speed in France a few weeks ago:The other artifact is a Google document originally published by Patrick Meenan in 2015 but updated somewhat recently in November 2023. Patrick’s blog has been inactive since 2014, so I’ll simply drop a link to the Google document for you to review.That’s all I have and what I can find on the web about this thing called Tight Mode that appears to have so much influence on the way the web works. Robin acknowledged the lack of information about it in his presentation, and the amount of first-person research in his talk is noteworthy and worth calling out because it attempts to describe and illustrate how different browsers fetch different resources with different prioritization. Given the dearth of material on the topic, I decided to share what I was able to take away from Robin’s research and Patrick’s updated article.It’s The First of Two PhasesThe fact that Patrick’s original publication date falls in 2015 makes it no surprise that we’re talking about something roughly 10 years old at this point. The 2023 update to the publication is already fairly old in “web years,” yet Tight Mode is still nowhere when I try looking it up.So, how do we define Tight Mode? This is how Patrick explains it:“Chrome loads resources in 2 phases. “Tight mode” is the initial phase and constraints [sic] loading lower-priority resources until the body is attached to the document (essentially, after all blocking scripts in the head have been executed).”— Patrick MeenanOK, so we have this two-part process that Chrome uses to fetch resources from the network and the first part is focused on anything that isn’t a “lower-priority resource.” We have ways of telling browsers which resources we think are low priority in the form of the Fetch Priority API and lazy-loading techniques that asynchronously load resources when they enter the viewport on scroll — all of which Robin covers in his presentation. But Tight Mode has its own way of determining what resources to load first.Figure 1: Chrome loads resources in two phases, the first of which is called “Tight Mode.” (Large preview)Tight Mode discriminates resources, taking anything and everything marked as High and Medium priority. Everything else is constrained and left on the outside, looking in until the body is firmly attached to the document, signaling that blocking scripts have been executed. It’s at that point that resources marked with Low priority are allowed in the door during the second phase of loading.There’s a big caveat to that, but we’ll get there. The important thing to note is that…Chrome And Safari Enforce Tight ModeYes, both Chrome and Safari have some working form of Tight Mode running in the background. That last image illustrates Chrome’s Tight Mode. Let’s look at Safari’s next and compare the two.Figure 2: Comparing Tight Mode in Chrome with Tight Mode in Safari. Notice that Chrome allows five images marked with High priority to slip out of Tight Mode. (Large preview)Look at that! Safari discriminates High-priority resources in its initial fetch, just like Chrome, but we get wildly different loading behavior between the two browsers. Notice how Safari appears to exclude the first five PNG images marked with Medium priority where Chrome allows them. In other words, Safari makes all Medium- and Low-priority resources wait in line until all High-priority items are done loading, even though we’re working with the exact same HTML. You might say that Safari’s behavior makes the most sense, as you can see in that last image that Chrome seemingly excludes some High-priority resources out of Tight Mode. There’s clearly some tomfoolery happening there that we’ll get to.Where’s Firefox in all this? It doesn’t take any extra tightening measures when evaluating the priority of the resources on a page. We might consider this the “classic” waterfall approach to fetching and loading resources.Figure 3: Chrome and Safari have implemented Tight Mode while Firefox maintains a simple waterfall.(Large preview)Chrome And Safari Trigger Tight Mode DifferentlyRobin makes this clear as day in his talk. Chrome and Safari are both Tight Mode proponents, yet trigger it under differing circumstances that we can outline like this:ChromeSafariTight Mode triggeredWhile blocking JS in the \u003chead\u003e is busy.While blocking JS or CSS anywhere is busy.Notice that Chrome only looks at the document \u003chead\u003e when prioritizing resources, and only when it involves JavaScript. Safari, meanwhile, also looks at JavaScript, but CSS as well, and anywhere those things might be located in the document — regardless of whether it’s in the \u003chead\u003e or \u003cbody\u003e. That helps explain why Chrome excludes images marked as High priority in Figure 2 from its Tight Mode implementation — it only cares about JavaScript in this context.So, even if Chrome encounters a script file with fetchpriority=\"high\" in the document body, the file is not considered a “High” priority and it will be loaded after the rest of the items. Safari, meanwhile, honors fetchpriority anywhere in the document. This helps explain why Chrome leaves two scripts on the table, so to speak, in Figure 2, while Safari appears to load them during Tight Mode.That’s not to say Safari isn’t doing anything weird in its process. Given the following markup:\u003chead\u003e \u003c!-- two high-priority scripts --\u003e \u003cscript src=\"script-1.js\"\u003e\u003c/script\u003e \u003cscript src=\"script-1.js\"\u003e\u003c/script\u003e \u003c!-- two low-priority scripts --\u003e \u003cscript src=\"script-3.js\" defer\u003e\u003c/script\u003e \u003cscript src=\"script-4.js\" defer\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- five low-priority scripts --\u003e \u003cimg src=\"image-1.jpg\"\u003e \u003cimg src=\"image-2.jpg\"\u003e \u003cimg src=\"image-3.jpg\"\u003e \u003cimg src=\"image-4.jpg\"\u003e \u003cimg src=\"image-5.jpg\"\u003e \u003c/body\u003e …you might expect that Safari would delay the two Low-priority scripts in the \u003chead\u003e until the five images in the \u003cbody\u003e are downloaded. But that’s not the case. Instead, Safari loads those two scripts during its version of Tight Mode.Figure 4: Safari treats deferred scripts in the \u003chead\u003e with High priority. (Large preview)Chrome And Safari ExceptionsI mentioned earlier that Low-priority resources are loaded in during the second phase of loading after Tight Mode has been completed. But I also mentioned that there’s a big caveat to that behavior. Let’s touch on that now.According to Patrick’s article, we know that Tight Mode is “the initial phase and constraints loading lower-priority resources until the body is attached to the document (essentially, after all blocking scripts in the head have been executed).” But there’s a second part to that definition that I left out:“In tight mode, low-priority resources are only loaded if there are less than two in-flight requests at the time that they are discovered.”A-ha! So, there is a way for low-priority resources to load in Tight Mode. It’s when there are less than two “in-flight” requests happening when they’re detected.Wait, what does “in-flight” even mean?That’s what’s meant by less than two High- or Medium-priority items being requested. Robin demonstrates this by comparing Chrome to Safari under the same conditions, where there are only two High-priority scripts and ten regular images in the mix:\u003chead\u003e \u003c!-- two high-priority scripts --\u003e \u003cscript src=\"script-1.js\"\u003e\u003c/script\u003e \u003cscript src=\"script-1.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ten low-priority images --\u003e \u003cimg src=\"image-1.jpg\"\u003e \u003cimg src=\"image-2.jpg\"\u003e \u003cimg src=\"image-3.jpg\"\u003e \u003cimg src=\"image-4.jpg\"\u003e \u003cimg src=\"image-5.jpg\"\u003e \u003c!-- rest of images --\u003e \u003cimg src=\"image-10.jpg\"\u003e \u003c/body\u003e Let’s look at what Safari does first because it’s the most straightforward approach:(Large preview)Nothing tricky about that, right? The two High-priority scripts are downloaded first and the 10 images flow in right after. Now let’s look at Chrome:(Large preview)We have the two High-priority scripts loaded first, as expected. But then Chrome decides to let in the first five images with Medium priority, then excludes the last five images with Low priority. What. The. Heck.The reason is a noble one: Chrome wants to load the first five images because, presumably, the Largest Contentful Paint (LCP) is often going to be one of those images and Chrome is hedging bets that the web will be faster overall if it automatically handles some of that logic. Again, it’s a noble line of reasoning, even if it isn’t going to be 100% accurate. It does muddy the waters, though, and makes understanding Tight Mode a lot harder when we see Medium- and Low-priority items treated as High-priority citizens.Even muddier is that Chrome appears to only accept up to two Medium-priority resources in this discriminatory process. The rest are marked with Low priority.That’s what we mean by “less than two in-flight requests.” If Chrome sees that only one or two items are entering Tight Mode, then it automatically prioritizes up to the first five non-critical images as an LCP optimization effort.Truth be told, Safari does something similar, but in a different context. Instead of accepting Low-priority items when there are less than two in-flight requests, Safari accepts both Medium and Low priority in Tight Mode and from anywhere in the document regardless of whether they are located in the \u003chead\u003e or not. The exception is any asynchronous or deferred script because, as we saw earlier, those get loaded right away anyway.How To Manipulate Tight ModeThis might make for a great follow-up article, but this is where I’ll refer you directly to Robin’s video because his first-person research is worth consuming directly. But here’s the gist:We have these high-level features that can help influence priority, including resource hints (i.e., preload and preconnect), the Fetch Priority API, and lazy-loading techniques.We can indicate fetchpriority=\"high\" and fetchpriority=\"low\" on items.\u003cimg src=\"lcp-image.jpg\" fetchpriority=\"high\"\u003e \u003clink rel=\"preload\" href=\"defer.js\" as=\"script\" fetchpriority=\"low\" Using fetchpriority=\"high\" is one way we can get items lower in the source included in Tight Mode. Using fetchpriority=\"low is one way we can get items higher in the source excluded from Tight Mode.For Chrome, this works on images, asynchronous/deferred scripts, and scripts located at the bottom of the \u003cbody\u003e.For Safari, this only works on images.Again, watch Robin’s talk for the full story starting around the 28:32 marker.That’s Tight… ModeIt’s bonkers to me that there is so little information about Tight Mode floating around the web. I would expect something like this to be well-documented somewhere, certainly over at Chrome Developers or somewhere similar, but all we have is a lightweight Google Doc and a thorough presentation to paint a picture of how two of the three major browsers fetch and prioritize resources. Let me know if you have additional information that you’ve either published or found — I’d love to include them in the discussion. (yk)",
  "image": "https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/tight-mode-why-browsers-produce-different-performance-results.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e9 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/performance\"\u003ePerformance\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/optimization\"\u003eOptimization\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/tools\"\u003eTools\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eWe know that browsers do all sorts of different things under the hood. One of those things is the way they not only \u003cem\u003efetch\u003c/em\u003e resources like images and scripts from the server but how they \u003ca href=\"https://www.debugbear.com/blog/request-priorities?utm_campaign=sm-7\"\u003eprioritize those resources\u003c/a\u003e. Chrome and Safari have implemented a “Tight Mode” that constrains which resources are loaded and in what order, but they each take drastically different approaches to it. With so little information about Tight Mode available, this article attempts a high-level explanation of what it is, what triggers it, and how it is treated differently in major browsers.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eI was chatting with \u003ca href=\"https://www.debugbear.com?utm_campaign=sm-7\"\u003eDebug\u003c/a\u003e\u003ca href=\"https://www.debugbear.com\"\u003eB\u003c/a\u003e\u003ca href=\"https://www.debugbear.com\"\u003eear\u003c/a\u003e’s Matt Zeunert and, in the process, he casually mentioned this thing called \u003cstrong\u003eTight Mode\u003c/strong\u003e when describing how browsers fetch and prioritize resources. I wanted to nod along like I knew what he was talking about but ultimately had to ask: \u003cem\u003eWhat the heck is “Tight” mode?\u003c/em\u003e\u003c/p\u003e\u003cp\u003eWhat I got back were two artifacts, one of them being the following video of Akamai web performance expert Robin Marx speaking at We Love Speed in France a few weeks ago:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp\u003eThe other artifact is a Google document originally published by \u003ca href=\"https://blog.patrickmeenan.com\"\u003ePatrick Meenan\u003c/a\u003e in 2015 but updated somewhat recently in November 2023. Patrick’s blog has been inactive since 2014, so I’ll simply \u003ca href=\"https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc/edit?tab=t.0#\"\u003edrop a link to the Google document for you to review\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThat’s all I have and what I can find on the web about this thing called Tight Mode that appears to have so much influence on the way the web works. Robin acknowledged the lack of information about it in his presentation, and the amount of first-person research in his talk is noteworthy and worth calling out because it attempts to describe and illustrate how different browsers fetch different resources with different prioritization. Given the dearth of material on the topic, I decided to share what I was able to take away from Robin’s research and Patrick’s updated article.\u003c/p\u003e\u003ch2 id=\"it-s-the-first-of-two-phases\"\u003eIt’s The First of Two Phases\u003c/h2\u003e\u003cp\u003eThe fact that Patrick’s original publication date falls in 2015 makes it no surprise that we’re talking about something roughly 10 years old at this point. The 2023 update to the publication is already fairly old in “web years,” yet Tight Mode is still nowhere when I try looking it up.\u003c/p\u003e\u003cp\u003eSo, how do we define Tight Mode? This is how Patrick explains it:\u003c/p\u003e\u003cblockquote\u003e“Chrome loads resources in 2 phases. “Tight mode” is the initial phase and constraints [sic] loading lower-priority resources until the body is attached to the document (essentially, after all blocking scripts in the head have been executed).”\u003cp\u003e— Patrick Meenan\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eOK, so we have this two-part process that Chrome uses to fetch resources from the network and the first part is focused on anything that isn’t a “lower-priority resource.” We have ways of telling browsers which resources \u003cem\u003ewe\u003c/em\u003e think are low priority in the form of the \u003ca href=\"https://web.dev/articles/fetch-priority\"\u003eFetch Priority API\u003c/a\u003e and lazy-loading techniques that asynchronously load resources when they enter the viewport on scroll — all of which Robin covers in his presentation. But Tight Mode has its own way of determining what resources to load first.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"448\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png\" sizes=\"100vw\" alt=\"Chrome Tight Mode screenshot\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 1: Chrome loads resources in two phases, the first of which is called “Tight Mode.” (\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/1-chrome-tight-mode.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eTight Mode discriminates resources, taking anything and everything marked as High and Medium priority. Everything else is constrained and left on the outside, looking in until the body is firmly attached to the document, signaling that blocking scripts have been executed. It’s at that point that resources marked with Low priority are allowed in the door during the second phase of loading.\u003c/p\u003e\u003cp\u003eThere’s a big caveat to that, but we’ll get there. The important thing to note is that…\u003c/p\u003e\u003ch2 id=\"chrome-and-safari-enforce-tight-mode\"\u003eChrome And Safari Enforce Tight Mode\u003c/h2\u003e\u003cp\u003eYes, both Chrome and Safari have some working form of Tight Mode running in the background. That last image illustrates Chrome’s Tight Mode. Let’s look at Safari’s next and compare the two.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"450\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png\" sizes=\"100vw\" alt=\"A screenshot comparing Tight Mode in Chrome with Tight Mode in Safari.\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 2: Comparing Tight Mode in Chrome with Tight Mode in Safari. Notice that Chrome allows five images marked with High priority to slip out of Tight Mode. (\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/2-tight-mode-chrome-vs-safari.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eLook at that! Safari discriminates High-priority resources in its initial fetch, just like Chrome, but we get wildly different loading behavior between the two browsers. Notice how Safari appears to exclude the first five PNG images marked with Medium priority where Chrome allows them. In other words, Safari makes all Medium- and Low-priority resources wait in line until all High-priority items are done loading, even though we’re working with the exact same HTML. You might say that Safari’s behavior makes the most sense, as you can see in that last image that Chrome seemingly excludes some High-priority resources out of Tight Mode. There’s clearly some tomfoolery happening there that we’ll get to.\u003c/p\u003e\u003cp\u003eWhere’s Firefox in all this? It doesn’t take any extra tightening measures when evaluating the priority of the resources on a page. We might consider this the “classic” waterfall approach to fetching and loading resources.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"447\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png\" sizes=\"100vw\" alt=\"Comparison of Chrome, Safari, and Firefox Tight Mode\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 3: Chrome and Safari have implemented Tight Mode while Firefox maintains a simple waterfall.(\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/3-tight-mode-chtome-safari-firefox.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"chrome-and-safari-trigger-tight-mode-differently\"\u003eChrome And Safari Trigger Tight Mode Differently\u003c/h2\u003e\u003cp\u003eRobin makes this clear as day in his talk. Chrome and Safari are both Tight Mode proponents, yet trigger it under differing circumstances that we can outline like this:\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003eChrome\u003c/th\u003e\u003cth\u003eSafari\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eTight Mode triggered\u003c/td\u003e\u003ctd\u003eWhile blocking JS in the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e is busy.\u003c/td\u003e\u003ctd\u003eWhile blocking JS or CSS anywhere is busy.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eNotice that Chrome only looks at the document \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e when prioritizing resources, and \u003cstrong\u003eonly when it involves JavaScript\u003c/strong\u003e. Safari, meanwhile, also looks at JavaScript, but CSS as well, and anywhere those things might be located in the document — regardless of whether it’s in the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e or \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e. That helps explain why Chrome excludes images marked as High priority in Figure 2 from its Tight Mode implementation — it only cares about JavaScript in this context.\u003c/p\u003e\u003cp\u003eSo, even if Chrome encounters a script file with \u003ccode\u003efetchpriority=\u0026#34;high\u0026#34;\u003c/code\u003e in the document body, the file is not considered a “High” priority and it will be loaded after the rest of the items. Safari, meanwhile, honors \u003ccode\u003efetchpriority\u003c/code\u003e anywhere in the document. This helps explain why Chrome leaves two scripts on the table, so to speak, in Figure 2, while Safari appears to load them during Tight Mode.\u003c/p\u003e\u003cp\u003eThat’s not to say Safari isn’t doing anything weird in its process. Given the following markup:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;head\u0026gt;\n  \u0026lt;!-- two high-priority scripts --\u0026gt;\n  \u0026lt;script src=\u0026#34;script-1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n  \u0026lt;script src=\u0026#34;script-1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n\n  \u0026lt;!-- two low-priority scripts --\u0026gt;\n  \u0026lt;script src=\u0026#34;script-3.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt;\n  \u0026lt;script src=\u0026#34;script-4.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt;\n\u0026lt;/head\u0026gt;\n\u0026lt;body\u0026gt;\n  \u0026lt;!-- five low-priority scripts --\u0026gt;\n  \u0026lt;img src=\u0026#34;image-1.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-2.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-3.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-4.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-5.jpg\u0026#34;\u0026gt;\n\u0026lt;/body\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e…you might expect that Safari would delay the two Low-priority scripts in the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e until the five images in the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e are downloaded. But that’s not the case. Instead, Safari loads those two scripts during its version of Tight Mode.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"452\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png\" sizes=\"100vw\" alt=\"Safari deferred scripts\"/\u003e\u003c/a\u003e\u003cfigcaption\u003eFigure 4: Safari treats deferred scripts in the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e with High priority. (\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/4-safari-deferred-scripts-head.png\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"chrome-and-safari-exceptions\"\u003eChrome And Safari Exceptions\u003c/h2\u003e\u003cp\u003eI mentioned earlier that Low-priority resources are loaded in during the second phase of loading after Tight Mode has been completed. But I also mentioned that there’s a big caveat to that behavior. Let’s touch on that now.\u003c/p\u003e\u003cp\u003eAccording to Patrick’s article, we know that Tight Mode is “the initial phase and constraints loading lower-priority resources until the body is attached to the document (essentially, after all blocking scripts in the head have been executed).” But there’s a second part to that definition that I left out:\u003c/p\u003e\u003cblockquote\u003e“In tight mode, low-priority resources are only loaded if there are less than two in-flight requests at the time that they are discovered.”\u003c/blockquote\u003e\u003cp\u003eA-ha! So, there \u003cem\u003eis\u003c/em\u003e a way for low-priority resources to load in Tight Mode. It’s when there are less than two “in-flight” requests happening when they’re detected.\u003c/p\u003e\u003cp\u003eWait, what does “in-flight” even mean?\u003c/p\u003e\u003cp\u003eThat’s what’s meant by less than two High- or Medium-priority items being requested. Robin demonstrates this by comparing Chrome to Safari under the same conditions, where there are only two High-priority scripts and ten regular images in the mix:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;head\u0026gt;\n  \u0026lt;!-- two high-priority scripts --\u0026gt;\n  \u0026lt;script src=\u0026#34;script-1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n  \u0026lt;script src=\u0026#34;script-1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\n\u0026lt;/head\u0026gt;\n\u0026lt;body\u0026gt;\n  \u0026lt;!-- ten low-priority images --\u0026gt;\n  \u0026lt;img src=\u0026#34;image-1.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-2.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-3.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-4.jpg\u0026#34;\u0026gt;\n  \u0026lt;img src=\u0026#34;image-5.jpg\u0026#34;\u0026gt;\n  \u0026lt;!-- rest of images --\u0026gt;\n  \u0026lt;img src=\u0026#34;image-10.jpg\u0026#34;\u0026gt;\n\u0026lt;/body\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s look at what Safari does first because it’s the most straightforward approach:\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" height=\"231\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg\" sizes=\"100vw\" alt=\"Safari Tight Mode\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/5-safari-tight-mode.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eNothing tricky about that, right? The two High-priority scripts are downloaded first and the 10 images flow in right after. Now let’s look at Chrome:\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg\"\u003e\u003cimg loading=\"lazy\" decoding=\"async\" fetchpriority=\"low\" width=\"800\" srcset=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg 400w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_800/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg 800w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1200/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg 1200w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg 1600w,\nhttps://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg 2000w\" src=\"https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_400/https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg\" sizes=\"100vw\" alt=\"Chrome Tight Mode\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/tight-mode-why-browsers-produce-different-performance-results/6-chrome-tight-mode.jpg\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eWe have the two High-priority scripts loaded first, as expected. But then Chrome decides to let in the first five images with Medium priority, then excludes the last five images with Low priority. What. The. Heck.\u003c/p\u003e\u003cp\u003eThe reason is a noble one: Chrome wants to load the first five images because, presumably, the \u003ca href=\"https://www.debugbear.com/docs/metrics/largest-contentful-paint?utm_campaign=sm-7\"\u003eLargest Contentful Paint\u003c/a\u003e (LCP) is often going to be one of those images and Chrome is hedging bets that the web will be faster overall if it automatically handles some of that logic. Again, it’s a noble line of reasoning, even if it isn’t going to be 100% accurate. It does muddy the waters, though, and makes understanding Tight Mode a lot harder when we see Medium- and Low-priority items treated as High-priority citizens.\u003c/p\u003e\u003cp\u003eEven muddier is that Chrome appears to only accept up to two Medium-priority resources in this discriminatory process. The rest are marked with Low priority.\u003c/p\u003e\u003cp\u003eThat’s what we mean by “less than two in-flight requests.” If Chrome sees that only one or two items are entering Tight Mode, then \u003cstrong\u003eit automatically prioritizes up to the first five non-critical images\u003c/strong\u003e as an LCP optimization effort.\u003c/p\u003e\u003cp\u003eTruth be told, Safari does something similar, but in a different context. Instead of accepting Low-priority items when there are less than two in-flight requests, Safari accepts both Medium and Low priority in Tight Mode and from anywhere in the document regardless of whether they are located in the \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e or not. The exception is any asynchronous or deferred script because, as we saw earlier, those get loaded right away anyway.\u003c/p\u003e\u003ch2 id=\"how-to-manipulate-tight-mode\"\u003eHow To Manipulate Tight Mode\u003c/h2\u003e\u003cp\u003eThis might make for a great follow-up article, but this is where I’ll refer you directly to Robin’s video because his first-person research is worth consuming directly. But here’s the gist:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWe have these high-level features that can help influence priority, including \u003cstrong\u003eresource hints\u003c/strong\u003e (i.e., \u003ccode\u003epreload\u003c/code\u003e and \u003ccode\u003epreconnect\u003c/code\u003e), the \u003ca href=\"https://www.debugbear.com/blog/fetchpriority-attribute?utm_campaign=sm-7\"\u003e\u003cstrong\u003eFetch Priority API\u003c/strong\u003e\u003c/a\u003e, and \u003cstrong\u003elazy-loading techniques\u003c/strong\u003e.\u003c/li\u003e\u003cli\u003eWe can indicate \u003ccode\u003efetchpriority=\u003c/code\u003e\u003ccode\u003e\u0026#34;\u003c/code\u003e\u003ccode\u003ehigh\u003c/code\u003e\u003ccode\u003e\u0026#34;\u003c/code\u003e and \u003ccode\u003efetchpriority=\u0026#34;low\u0026#34;\u003c/code\u003e on items.\u003c/li\u003e\u003c/ul\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;img src=\u0026#34;lcp-image.jpg\u0026#34; fetchpriority=\u0026#34;high\u0026#34;\u0026gt;\n\u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;defer.js\u0026#34; as=\u0026#34;script\u0026#34; fetchpriority=\u0026#34;low\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\u003cli\u003eUsing \u003ccode\u003efetchpriority=\u0026#34;high\u0026#34;\u003c/code\u003e is one way we can get items lower in the source included in Tight Mode. Using \u003ccode\u003efetchpriority=\u0026#34;low\u003c/code\u003e is one way we can get items higher in the source excluded from Tight Mode.\u003c/li\u003e\u003cli\u003eFor Chrome, this works on images, asynchronous/deferred scripts, and scripts located at the bottom of the \u003ccode\u003e\u0026lt;body\u0026gt;\u003c/code\u003e.\u003c/li\u003e\u003cli\u003eFor Safari, this only works on images.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAgain, watch Robin’s talk for the full story \u003ca href=\"https://youtu.be/p0lFyPuH8Zs?feature=shared\u0026amp;t=1712\"\u003estarting around the 28:32 marker\u003c/a\u003e.\u003c/p\u003e\u003ch2 id=\"that-s-tight-mode\"\u003eThat’s Tight… Mode\u003c/h2\u003e\u003cp\u003eIt’s bonkers to me that there is so little information about Tight Mode floating around the web. I would expect something like this to be well-documented somewhere, certainly over at Chrome Developers or somewhere similar, but all we have is a lightweight Google Doc and a thorough presentation to paint a picture of how two of the three major browsers fetch and prioritize resources. Let me know if you have additional information that you’ve either published or found — I’d love to include them in the discussion.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-01-09T13:00:00Z",
  "modifiedTime": "2025-01-09T13:00:00Z"
}
