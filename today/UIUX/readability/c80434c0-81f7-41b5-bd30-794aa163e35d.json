{
  "id": "c80434c0-81f7-41b5-bd30-794aa163e35d",
  "title": "Creating The “Moving Highlight” Navigation Bar With JavaScript And CSS",
  "link": "https://smashingmagazine.com/2025/06/creating-moving-highlight-navigation-bar-javascript-css/",
  "description": "In this tutorial, Blake Lundquist walks us through two methods of creating the “moving-highlight” navigation pattern using only plain JavaScript and CSS. The first technique uses the `getBoundingClientRect` method to explicitly animate the border between navigation bar items when they are clicked. The second approach achieves the same functionality using the new View Transition API.",
  "author": "Blake Lundquist",
  "published": "Wed, 11 Jun 2025 13:00:00 GMT",
  "source": "https://www.smashingmagazine.com/feed",
  "categories": null,
  "byline": "About The Author",
  "length": 11880,
  "excerpt": "In this tutorial, Blake Lundquist walks us through two methods of creating the “moving-highlight” navigation pattern using only plain JavaScript and CSS. The first technique uses the `getBoundingClientRect` method to explicitly animate the border between navigation bar items when they are clicked. The second approach achieves the same functionality using the new View Transition API.",
  "siteName": "Smashing Magazine",
  "favicon": "https://smashingmagazine.com/images/favicon/apple-touch-icon.png",
  "text": "8 min readJavaScript, Animation, CodingIn this tutorial, Blake Lundquist walks us through two methods of creating the “moving-highlight” navigation pattern using only plain JavaScript and CSS. The first technique uses the getBoundingClientRect method to explicitly animate the border between navigation bar items when they are clicked. The second approach achieves the same functionality using the new View Transition API.I recently came across an old jQuery tutorial demonstrating a “moving highlight” navigation bar and decided the concept was due for a modern upgrade. With this pattern, the border around the active navigation item animates directly from one element to another as the user clicks on menu items. In 2025, we have much better tools to manipulate the DOM via vanilla JavaScript. New features like the View Transition API make progressive enhancement more easily achievable and handle a lot of the animation minutiae.(Large preview)In this tutorial, I will demonstrate two methods of creating the “moving highlight” navigation bar using plain JavaScript and CSS. The first example uses the getBoundingClientRect method to explicitly animate the border between navigation bar items when they are clicked. The second example achieves the same functionality using the new View Transition API.The Initial MarkupLet’s assume that we have a single-page application where content changes without the page being reloaded. The starting HTML and CSS are your standard navigation bar with an additional div element containing an id of #highlight. We give the first navigation item a class of .active.See the Pen [Moving Highlight Navbar Starting Markup [forked]](https://codepen.io/smashingmag/pen/EajQyBW) by Blake Lundquist.See the Pen Moving Highlight Navbar Starting Markup [forked] by Blake Lundquist.For this version, we will position the #highlight element around the element with the .active class to create a border. We can utilize absolute positioning and animate the element across the navigation bar to create the desired effect. We’ll hide it off-screen initially by adding left: -200px and include transition styles for all properties so that any changes in the position and size of the element will happen gradually.#highlight { z-index: 0; position: absolute; height: 100%; width: 100px; left: -200px; border: 2px solid green; box-sizing: border-box; transition: all 0.2s ease; } Add A Boilerplate Event Handler For Click InteractionsWe want the highlight element to animate when a user changes the .active navigation item. Let’s add a click event handler to the nav element, then filter for events caused only by elements matching our desired selector. In this case, we only want to change the .active nav item if the user clicks on a link that does not already have the .active class.Initially, we can call console.log to ensure the handler fires only when expected:const navbar = document.querySelector('nav'); navbar.addEventListener('click', function (event) { // return if the clicked element doesn't have the correct selector if (!event.target.matches('nav a:not(active)')) { return; } console.log('click'); }); Open your browser console and try clicking different items in the navigation bar. You should only see \"click\" being logged when you select a new item in the navigation bar.Now that we know our event handler is working on the correct elements let’s add code to move the .active class to the navigation item that was clicked. We can use the object passed into the event handler to find the element that initialized the event and give that element a class of .active after removing it from the previously active item.const navbar = document.querySelector('nav'); navbar.addEventListener('click', function (event) { // return if the clicked element doesn't have the correct selector if (!event.target.matches('nav a:not(active)')) { return; } - console.log('click'); + document.querySelector('nav a.active').classList.remove('active'); + event.target.classList.add('active'); }); Our #highlight element needs to move across the navigation bar and position itself around the active item. Let’s write a function to calculate a new position and width. Since the #highlight selector has transition styles applied, it will move gradually when its position changes.Using getBoundingClientRect, we can get information about the position and size of an element. We calculate the width of the active navigation item and its offset from the left boundary of the parent element. Then, we assign styles to the highlight element so that its size and position match.// handler for moving the highlight const moveHighlight = () =\u003e { const activeNavItem = document.querySelector('a.active'); const highlighterElement = document.querySelector('#highlight'); const width = activeNavItem.offsetWidth; const itemPos = activeNavItem.getBoundingClientRect(); const navbarPos = navbar.getBoundingClientRect() const relativePosX = itemPos.left - navbarPos.left; const styles = { left: `${relativePosX}px`, width: `${width}px`, }; Object.assign(highlighterElement.style, styles); } Let’s call our new function when the click event fires:navbar.addEventListener('click', function (event) { // return if the clicked element doesn't have the correct selector if (!event.target.matches('nav a:not(active)')) { return; } document.querySelector('nav a.active').classList.remove('active'); event.target.classList.add('active'); + moveHighlight(); }); Finally, let’s also call the function immediately so that the border moves behind our initial active item when the page first loads:// handler for moving the highlight const moveHighlight = () =\u003e { // ... } // display the highlight when the page loads moveHighlight(); Now, the border moves across the navigation bar when a new item is selected. Try clicking the different navigation links to animate the navigation bar.See the Pen [Moving Highlight Navbar [forked]](https://codepen.io/smashingmag/pen/WbvMxqV) by Blake Lundquist.See the Pen Moving Highlight Navbar [forked] by Blake Lundquist.That only took a few lines of vanilla JavaScript and could easily be extended to account for other interactions, like mouseover events. In the next section, we will explore refactoring this feature using the View Transition API.Using The View Transition APIThe View Transition API provides functionality to create animated transitions between website views. Under the hood, the API creates snapshots of “before” and “after” views and then handles transitioning between them. View transitions are useful for creating animations between documents, providing the native-app-like user experience featured in frameworks like Astro. However, the API also provides handlers meant for SPA-style applications. We will use it to reduce the JavaScript needed in our implementation and more easily create fallback functionality.For this approach, we no longer need a separate #highlight element. Instead, we can style the .active navigation item directly using pseudo-selectors and let the View Transition API handle the animation between the before-and-after UI states when a new navigation item is clicked.We’ll start by getting rid of the #highlight element and its associated CSS and replacing it with styles for the nav a::after pseudo-selector:\u003cnav\u003e - \u003cdiv id=\"highlight\"\u003e\u003c/div\u003e \u003ca href=\"#\" class=\"active\"\u003eHome\u003c/a\u003e \u003ca href=\"#services\"\u003eServices\u003c/a\u003e \u003ca href=\"#about\"\u003eAbout\u003c/a\u003e \u003ca href=\"#contact\"\u003eContact\u003c/a\u003e \u003c/nav\u003e - #highlight { - z-index: 0; - position: absolute; - height: 100%; - width: 0; - left: 0; - box-sizing: border-box; - transition: all 0.2s ease; - } + nav a::after { + content: \" \"; + position: absolute; + left: 0; + top: 0; + width: 100%; + height: 100%; + border: none; + box-sizing: border-box; + } For the .active class, we include the view-transition-name property, thus unlocking the magic of the View Transition API. Once we trigger the view transition and change the location of the .active navigation item in the DOM, “before” and “after” snapshots will be taken, and the browser will animate the border across the bar. We’ll give our view transition the name of highlight, but we could theoretically give it any name.nav a.active::after { border: 2px solid green; view-transition-name: highlight; } Once we have a selector that contains a view-transition-name property, the only remaining step is to trigger the transition using the startViewTransition method and pass in a callback function.const navbar = document.querySelector('nav'); // Change the active nav item on click navbar.addEventListener('click', async function (event) { if (!event.target.matches('nav a:not(.active)')) { return; } document.startViewTransition(() =\u003e { document.querySelector('nav a.active').classList.remove('active'); event.target.classList.add('active'); }); }); Above is a revised version of the click handler. Instead of doing all the calculations for the size and position of the moving border ourselves, the View Transition API handles all of it for us. We only need to call document.startViewTransition and pass in a callback function to change the item that has the .active class!Adjusting The View TransitionAt this point, when clicking on a navigation link, you’ll notice that the transition works, but some strange sizing issues are visible.(Large preview)This sizing inconsistency is caused by aspect ratio changes during the course of the view transition. We won’t go into detail here, but Jake Archibald has a detailed explanation you can read for more information. In short, to ensure the height of the border stays uniform throughout the transition, we need to declare an explicit height for the ::view-transition-old and ::view-transition-new pseudo-selectors representing a static snapshot of the old and new view, respectively.::view-transition-old(highlight) { height: 100%; } ::view-transition-new(highlight) { height: 100%; } Let’s do some final refactoring to tidy up our code by moving the callback to a separate function and adding a fallback for when view transitions aren’t supported:const navbar = document.querySelector('nav'); // change the item that has the .active class applied const setActiveElement = (elem) =\u003e { document.querySelector('nav a.active').classList.remove('active'); elem.classList.add('active'); } // Start view transition and pass in a callback on click navbar.addEventListener('click', async function (event) { if (!event.target.matches('nav a:not(.active)')) { return; } // Fallback for browsers that don't support View Transitions: if (!document.startViewTransition) { setActiveElement(event.target); return; } document.startViewTransition(() =\u003e setActiveElement(event.target)); }); Here’s our view transition-powered navigation bar! Observe the smooth transition when you click on the different links.See the Pen [Moving Highlight Navbar with View Transition [forked]](https://codepen.io/smashingmag/pen/ogXELKE) by Blake Lundquist.See the Pen Moving Highlight Navbar with View Transition [forked] by Blake Lundquist.ConclusionAnimations and transitions between website UI states used to require many kilobytes of external libraries, along with verbose, confusing, and error-prone code, but vanilla JavaScript and CSS have since incorporated features to achieve native-app-like interactions without breaking the bank. We demonstrated this by implementing the “moving highlight” navigation pattern using two approaches: CSS transitions combined with the getBoundingClientRect() method and the View Transition API.ResourcesgetBoundingClientRect() method documentationView Transition API documentation“View Transitions: Handling Aspect Ratio Changes” by Jake Archibald (gg, yk)",
  "image": "https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/creating-moving-highlight-navigation-bar-javascript-css.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article__content\"\u003e\u003cul\u003e\u003cli\u003e8 min read\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://smashingmagazine.com/category/javascript\"\u003eJavaScript\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/animation\"\u003eAnimation\u003c/a\u003e,\n\u003ca href=\"https://smashingmagazine.com/category/coding\"\u003eCoding\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003csection aria-label=\"Quick summary\"\u003eIn this tutorial, Blake Lundquist walks us through two methods of creating the “moving-highlight” navigation pattern using only plain JavaScript and CSS. The first technique uses the \u003ccode\u003egetBoundingClientRect\u003c/code\u003e method to explicitly animate the border between navigation bar items when they are clicked. The second approach achieves the same functionality using the new View Transition API.\u003c/section\u003e\u003c/p\u003e\u003cp\u003eI recently came across an old jQuery tutorial demonstrating a \u003cstrong\u003e“moving highlight” navigation bar\u003c/strong\u003e and decided the concept was due for a modern upgrade. With this pattern, the border around the active navigation item animates directly from one element to another as the user clicks on menu items. In 2025, we have much better tools to manipulate the DOM via vanilla JavaScript. New features like the \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\"\u003eView Transition API\u003c/a\u003e make progressive enhancement more easily achievable and handle a lot of the animation minutiae.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/1-moving-highlight-navigation-bar.gif\"\u003e\u003cimg src=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/1-moving-highlight-navigation-bar.gif\" width=\"800\" height=\"131\" alt=\"An example of a “moving highlight” navigation bar\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/1-moving-highlight-navigation-bar.gif\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eIn this tutorial, I will demonstrate two methods of creating the “moving highlight” navigation bar using plain JavaScript and CSS. The first example uses the \u003ccode\u003egetBoundingClientRect\u003c/code\u003e method to explicitly animate the border between navigation bar items when they are clicked. The second example achieves the same functionality using the new View Transition API.\u003c/p\u003e\u003ch2 id=\"the-initial-markup\"\u003eThe Initial Markup\u003c/h2\u003e\u003cp\u003eLet’s assume that we have a single-page application where content changes without the page being reloaded. The starting HTML and CSS are your standard navigation bar with an additional \u003ccode\u003ediv\u003c/code\u003e element containing an \u003ccode\u003eid\u003c/code\u003e of \u003ccode\u003e#highlight\u003c/code\u003e. We give the first navigation item a class of \u003ccode\u003e.active\u003c/code\u003e.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"EajQyBW\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Moving Highlight Navbar Starting Markup [forked]](https://codepen.io/smashingmag/pen/EajQyBW) by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/EajQyBW\"\u003eMoving Highlight Navbar Starting Markup [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eFor this version, we will position the \u003ccode\u003e#highlight\u003c/code\u003e element around the element with the \u003ccode\u003e.active\u003c/code\u003e class to create a border. We can utilize \u003ccode\u003eabsolute\u003c/code\u003e positioning and animate the element across the navigation bar to create the desired effect. We’ll hide it off-screen initially by adding \u003ccode\u003eleft: -200px\u003c/code\u003e and include \u003ccode\u003etransition\u003c/code\u003e styles for all properties so that any changes in the position and size of the element will happen gradually.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#highlight {\n  z-index: 0;\n  position: absolute;\n  height: 100%;\n  width: 100px;\n  left: -200px;\n  border: 2px solid green;\n  box-sizing: border-box;\n  transition: all 0.2s ease;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"add-a-boilerplate-event-handler-for-click-interactions\"\u003eAdd A Boilerplate Event Handler For Click Interactions\u003c/h2\u003e\u003cp\u003eWe want the highlight element to animate when a user changes the \u003ccode\u003e.active\u003c/code\u003e navigation item. Let’s add a \u003ccode\u003eclick\u003c/code\u003e event handler to the \u003ccode\u003enav\u003c/code\u003e element, then filter for events caused only by elements matching our desired selector. In this case, we only want to change the \u003ccode\u003e.active\u003c/code\u003e nav item if the user clicks on a link that does not already have the \u003ccode\u003e.active\u003c/code\u003e class.\u003c/p\u003e\u003cp\u003eInitially, we can call \u003ccode\u003econsole.log\u003c/code\u003e to ensure the handler fires only when expected:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst navbar = document.querySelector(\u0026#39;nav\u0026#39;);\n\nnavbar.addEventListener(\u0026#39;click\u0026#39;, function (event) {\n  // return if the clicked element doesn\u0026#39;t have the correct selector\n  if (!event.target.matches(\u0026#39;nav a:not(active)\u0026#39;)) {\n    return;\n  }\n  \n  console.log(\u0026#39;click\u0026#39;);\n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOpen your browser console and try clicking different items in the navigation bar. You should only see \u003ccode\u003e\u0026#34;click\u0026#34;\u003c/code\u003e being logged when you select a new item in the navigation bar.\u003c/p\u003e\u003cp\u003eNow that we know our event handler is working on the correct elements let’s add code to move the \u003ccode\u003e.active\u003c/code\u003e class to the navigation item that was clicked. We can use the object passed into the event handler to find the element that initialized the event and give that element a class of \u003ccode\u003e.active\u003c/code\u003e after removing it from the previously active item.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst navbar = document.querySelector(\u0026#39;nav\u0026#39;);\n\nnavbar.addEventListener(\u0026#39;click\u0026#39;, function (event) {\n  // return if the clicked element doesn\u0026#39;t have the correct selector\n  if (!event.target.matches(\u0026#39;nav a:not(active)\u0026#39;)) {\n    return;\n  }\n  \n-  console.log(\u0026#39;click\u0026#39;);\n+  document.querySelector(\u0026#39;nav a.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;);\n+  event.target.classList.add(\u0026#39;active\u0026#39;);\n  \n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eOur \u003ccode\u003e#highlight\u003c/code\u003e element needs to move across the navigation bar and position itself around the active item. Let’s write a function to calculate a new position and width. Since the \u003ccode\u003e#highlight\u003c/code\u003e selector has \u003ccode\u003etransition\u003c/code\u003e styles applied, it will move gradually when its position changes.\u003c/p\u003e\u003cp\u003eUsing \u003ccode\u003egetBoundingClientRect\u003c/code\u003e, we can get information about the position and size of an element. We calculate the width of the active navigation item and its offset from the left boundary of the parent element. Then, we assign styles to the highlight element so that its size and position match.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e// handler for moving the highlight\nconst moveHighlight = () =\u0026gt; {\n  const activeNavItem = document.querySelector(\u0026#39;a.active\u0026#39;);\n  const highlighterElement = document.querySelector(\u0026#39;#highlight\u0026#39;);\n  \n  const width = activeNavItem.offsetWidth;\n\n  const itemPos = activeNavItem.getBoundingClientRect();\n  const navbarPos = navbar.getBoundingClientRect()\n  const relativePosX = itemPos.left - navbarPos.left;\n\n  const styles = {\n    left: `${relativePosX}px`,\n    width: `${width}px`,\n  };\n\n  Object.assign(highlighterElement.style, styles);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet’s call our new function when the click event fires:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003enavbar.addEventListener(\u0026#39;click\u0026#39;, function (event) {\n  // return if the clicked element doesn\u0026#39;t have the correct selector\n  if (!event.target.matches(\u0026#39;nav a:not(active)\u0026#39;)) {\n    return;\n  }\n  \n  document.querySelector(\u0026#39;nav a.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;);\n  event.target.classList.add(\u0026#39;active\u0026#39;);\n  \n+  moveHighlight();\n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFinally, let’s also call the function immediately so that the border moves behind our initial active item when the page first loads:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// handler for moving the highlight\nconst moveHighlight = () =\u0026gt; {\n // ...\n}\n\n// display the highlight when the page loads\nmoveHighlight();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, the border moves across the navigation bar when a new item is selected. Try clicking the different navigation links to animate the navigation bar.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"WbvMxqV\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Moving Highlight Navbar [forked]](https://codepen.io/smashingmag/pen/WbvMxqV) by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/WbvMxqV\"\u003eMoving Highlight Navbar [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThat only took a few lines of vanilla JavaScript and could easily be extended to account for other interactions, like \u003ccode\u003emouseover\u003c/code\u003e events. In the next section, we will explore refactoring this feature using the View Transition API.\u003c/p\u003e\u003ch2 id=\"using-the-view-transition-api\"\u003eUsing The View Transition API\u003c/h2\u003e\u003cp\u003eThe View Transition API provides functionality to create animated transitions between website views. Under the hood, the API creates snapshots of “before” and “after” views and then handles transitioning between them. View transitions are useful for creating animations between documents, providing the \u003cstrong\u003enative-app-like user experience\u003c/strong\u003e featured in frameworks like \u003ca href=\"https://docs.astro.build/en/guides/view-transitions/\"\u003eAstro\u003c/a\u003e. However, the API also provides handlers meant for \u003cstrong\u003eSPA-style applications\u003c/strong\u003e. We will use it to reduce the JavaScript needed in our implementation and more easily create fallback functionality.\u003c/p\u003e\u003cp\u003eFor this approach, we no longer need a separate \u003ccode\u003e#highlight\u003c/code\u003e element. Instead, we can style the \u003ccode\u003e.active\u003c/code\u003e navigation item directly using pseudo-selectors and let the View Transition API handle the animation between the before-and-after UI states when a new navigation item is clicked.\u003c/p\u003e\u003cp\u003eWe’ll start by getting rid of the \u003ccode\u003e#highlight\u003c/code\u003e element and its associated CSS and replacing it with styles for the \u003ccode\u003enav a::after\u003c/code\u003e pseudo-selector:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;nav\u0026gt;\n  - \u0026lt;div id=\u0026#34;highlight\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\n  \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;active\u0026#34;\u0026gt;Home\u0026lt;/a\u0026gt;\n  \u0026lt;a href=\u0026#34;#services\u0026#34;\u0026gt;Services\u0026lt;/a\u0026gt;\n  \u0026lt;a href=\u0026#34;#about\u0026#34;\u0026gt;About\u0026lt;/a\u0026gt;\n  \u0026lt;a href=\u0026#34;#contact\u0026#34;\u0026gt;Contact\u0026lt;/a\u0026gt;\n\u0026lt;/nav\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e- #highlight {\n-  z-index: 0;\n-  position: absolute;\n-  height: 100%;\n-  width: 0;\n-  left: 0;\n-  box-sizing: border-box;\n-  transition: all 0.2s ease;\n- }\n\n+ nav a::after {\n+  content: \u0026#34; \u0026#34;;\n+  position: absolute;\n+  left: 0;\n+  top: 0;\n+  width: 100%;\n+  height: 100%;\n+  border: none;\n+  box-sizing: border-box;\n+ }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor the \u003ccode\u003e.active\u003c/code\u003e class, we include the \u003ccode\u003eview-transition-name\u003c/code\u003e property, thus unlocking the magic of the View Transition API. Once we trigger the view transition and change the location of the \u003ccode\u003e.active\u003c/code\u003e navigation item in the DOM, “before” and “after” snapshots will be taken, and the browser will animate the border across the bar. We’ll give our view transition the name of \u003ccode\u003ehighlight\u003c/code\u003e, but we could theoretically give it any name.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003enav a.active::after {\n  border: 2px solid green;\n  view-transition-name: highlight;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eOnce we have a selector that contains a \u003ccode\u003eview-transition-name\u003c/code\u003e property, the only remaining step is to trigger the transition using the \u003ccode\u003estartViewTransition\u003c/code\u003e method and pass in a callback function.\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst navbar = document.querySelector(\u0026#39;nav\u0026#39;);\n\n// Change the active nav item on click\nnavbar.addEventListener(\u0026#39;click\u0026#39;, async  function (event) {\n\n  if (!event.target.matches(\u0026#39;nav a:not(.active)\u0026#39;)) {\n    return;\n  }\n  \n  document.startViewTransition(() =\u0026gt; {\n    document.querySelector(\u0026#39;nav a.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;);\n\n    event.target.classList.add(\u0026#39;active\u0026#39;);\n  });\n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAbove is a revised version of the \u003ccode\u003eclick\u003c/code\u003e handler. Instead of doing all the calculations for the size and position of the moving border ourselves, the View Transition API handles all of it for us. We only need to call \u003ccode\u003edocument.startViewTransition\u003c/code\u003e and pass in a callback function to change the item that has the \u003ccode\u003e.active\u003c/code\u003e class!\u003c/p\u003e\u003ch2 id=\"adjusting-the-view-transition\"\u003eAdjusting The View Transition\u003c/h2\u003e\u003cp\u003eAt this point, when clicking on a navigation link, you’ll notice that the transition works, but some strange sizing issues are visible.\u003c/p\u003e\u003cfigure\u003e\u003ca href=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/2-view-transition-sizing-issues.gif\"\u003e\u003cimg src=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/2-view-transition-sizing-issues-800px.gif\" width=\"800\" height=\"163\" alt=\"The view transition with sizing issues\"/\u003e\u003c/a\u003e\u003cfigcaption\u003e(\u003ca href=\"https://files.smashing.media/articles/creating-moving-highlight-navigation-bar-vanilla-javascript/2-view-transition-sizing-issues.gif\"\u003eLarge preview\u003c/a\u003e)\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003eThis sizing inconsistency is caused by aspect ratio changes during the course of the view transition. We won’t go into detail here, but \u003ca href=\"https://jakearchibald.com/2024/view-transitions-handling-aspect-ratio-changes/\"\u003eJake Archibald has a detailed explanation you can read\u003c/a\u003e for more information. In short, to ensure the height of the border stays uniform throughout the transition, we need to declare an explicit \u003ccode\u003eheight\u003c/code\u003e for the \u003ccode\u003e::view-transition-old\u003c/code\u003e and \u003ccode\u003e::view-transition-new\u003c/code\u003e pseudo-selectors representing a static snapshot of the old and new view, respectively.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e::view-transition-old(highlight) {\n  height: 100%;\n}\n\n::view-transition-new(highlight) {\n  height: 100%;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s do some final refactoring to tidy up our code by moving the callback to a separate function and adding a fallback for when view transitions aren’t supported:\u003c/p\u003e\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003econst navbar = document.querySelector(\u0026#39;nav\u0026#39;);\n\n// change the item that has the .active class applied\nconst setActiveElement = (elem) =\u0026gt; {\n  document.querySelector(\u0026#39;nav a.active\u0026#39;).classList.remove(\u0026#39;active\u0026#39;);\n  elem.classList.add(\u0026#39;active\u0026#39;);\n}\n\n// Start view transition and pass in a callback on click\nnavbar.addEventListener(\u0026#39;click\u0026#39;, async  function (event) {\n  if (!event.target.matches(\u0026#39;nav a:not(.active)\u0026#39;)) {\n    return;\n  }\n\n  // Fallback for browsers that don\u0026#39;t support View Transitions:\n  if (!document.startViewTransition) {\n    setActiveElement(event.target);\n    return;\n  }\n  \n  document.startViewTransition(() =\u0026gt; setActiveElement(event.target));\n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eHere’s our view transition-powered navigation bar! Observe the smooth transition when you click on the different links.\u003c/p\u003e\u003cfigure\u003e\u003cp data-height=\"480\" data-theme-id=\"light\" data-slug-hash=\"ogXELKE\" data-user=\"smashingmag\" data-default-tab=\"result\"\u003eSee the Pen [Moving Highlight Navbar with View Transition [forked]](https://codepen.io/smashingmag/pen/ogXELKE) by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/p\u003e\u003cfigcaption\u003eSee the Pen \u003ca href=\"https://codepen.io/smashingmag/pen/ogXELKE\"\u003eMoving Highlight Navbar with View Transition [forked]\u003c/a\u003e by \u003ca href=\"https://codepen.io/blakeeric\"\u003eBlake Lundquist\u003c/a\u003e.\u003c/figcaption\u003e\u003c/figure\u003e\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\u003cp\u003eAnimations and transitions between website UI states used to require many kilobytes of external libraries, along with verbose, confusing, and error-prone code, but vanilla JavaScript and CSS have since incorporated features to achieve \u003cstrong\u003enative-app-like interactions without breaking the bank\u003c/strong\u003e. We demonstrated this by implementing the “moving highlight” navigation pattern using two approaches: CSS transitions combined with the \u003ccode\u003egetBoundingClientRect()\u003c/code\u003e method and the View Transition API.\u003c/p\u003e\u003ch3 id=\"resources\"\u003eResources\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\"\u003e\u003ccode\u003egetBoundingClientRect()\u003c/code\u003e method documentation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API\"\u003eView Transition API documentation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e“\u003ca href=\"https://jakearchibald.com/2024/view-transitions-handling-aspect-ratio-changes/\"\u003eView Transitions: Handling Aspect Ratio Changes\u003c/a\u003e” by Jake Archibald\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://www.smashingmagazine.com/images/logo/logo--red.png\" alt=\"Smashing Editorial\" width=\"35\" height=\"46\" loading=\"lazy\" decoding=\"async\"/\u003e\n\u003cspan\u003e(gg, yk)\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2025-06-11T13:00:00Z",
  "modifiedTime": "2025-06-11T13:00:00Z"
}
