{
  "id": "ac8c0b8c-8e8a-4d31-a638-12b0361db4af",
  "title": "Demystifying Git Submodules",
  "link": "https://www.cyberdemon.org/2024/03/20/submodules.html",
  "description": "Article URL: https://www.cyberdemon.org/2024/03/20/submodules.html Comments URL: https://news.ycombinator.com/item?id=42291833 Points: 3 # Comments: 0",
  "author": "signa11",
  "published": "Mon, 02 Dec 2024 00:19:16 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 14680,
  "excerpt": "Demystifying git submodules by showing exactly how they work.",
  "siteName": "cyberdemon.org",
  "favicon": "",
  "text": "Throughout my career, I have found git submodules to be a pain. Because I did not understand them, I kept getting myself into frustrating situations. So, I finally sat down and learned how git tracks submodules. Turns out, it’s not complex at all. It’s just different from how git tracks regular files. It’s just one more thing you have to learn. In this article, I’ll explain exactly what I needed to know in order to work with submodules without inflicting self-damage. (This article doesn’t discuss whether submodules are good/bad, or if you should use them or not – a valid discussion, but out of scope.) The lay of the land This article will make more sense if we use concrete examples. Allow me to describe a toy webapp we’re building. Call this repo webapp. Here are the contents of the repo. $ [/webapp] ls .git/ README.md tests/ Say you want to import some library. It lives in its own repo, library. $ [/library] ls .git/ README.md my_cool_functions.py Shortly, I’ll explain how submodules work. But, first, let me dramatically re-enact something that has happened to me multiple times. This is what it looks like to use submodules without understanding them. A day in the life of someone who doesn’t understand submodules Ah, 2012. What a time to be a “full-stack engineer”! I wonder what contributions await me on the main branch! (For the sake of readability, in this article, instead of using real commit SHAs, I’m going to use fake descriptive ones.) Let’s pull to make sure I’m up-to-date with the remote. $ [/webapp] git pull remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (1/1), done. remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0 Unpacking objects: 100% (2/2), 237 bytes | 118.00 KiB/s, done. From https://github.com/dmazin/webapp webapp_old_commit_sha..webapp_new_commit_sha main -\u003e origin/main Updating webapp_old_commit_sha..webapp_new_commit_sha Fast-forward library | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) After I pull, I like to confirm that my working tree is clean. $ [/webapp] git st ## main...origin/main M library What’s this? I’ve made modifications to library? I never touch that directory. It’s weird that I’ve modified a directory. Usually git just says I’ve modified a specific file. Well, what does git diff have to say? $ [/webapp] git diff diff --git a/library b/library index library_old_commit_sha..library_new_commit_sha 160000 --- a/library +++ b/library @@ -1 +1 @@ -Subproject commit library_new_commit_sha +Subproject commit library_old_commit_sha Apparently, I deleted Subproject commit library_new_commit_sha and added Subproject commit library_old_commit_sha. Surely I didn’t do that. That’s weird, let me do a hard reset. $ [/webapp] git reset --hard origin/main HEAD is now at webapp_new_commit_sha point submodule to newest commit Did it make the git diff go away? $ [/webapp] git st ## main...origin/main M library It did not! I am really confused now! Well, the usual way I make local modifications go away is git reset --hard, and that didn’t work. The other way is to commit the changes. (Sometimes, people don’t even notice the diff above, and accidentally do this.) My future self: Don’t do it! If you git add that change, you’ll be rolling back a change someone else made! What’s going on, of course, is that library is a submodule, and you have to do special stuff to deal with them. Let’s dive into submodules. What’s a submodule? A git submodule is a full repo that’s been nested inside another repo. Any repo can be a submodule of another. So, library is a full repo that has been nested inside webapp as a submodule. That doesn’t seem so confusing, does it? However, there are two important, and tricky, facts about submodules. These facts are why so many people trip up on submodules. 1. A submodule is always pinned to a specific commit You know how package managers let you be fuzzy when specifying a package version (“get me any version of requests so long as it’s 2.x.x”), or to pin an exact version (“use requests 2.31.0 exactly”)? Submodules can only be pinned to a specific commit. This is because a submodule isn’t a package; it’s code that you have embedded in another repo, and git wants you to be precise. We’ll see exactly how this pinning works shortly. 2. git does not automatically download or update submodules If you clone webapp afresh, git will not automatically download library for you (unless you clone using git clone --recursive) Similarly, if a collaborator pins webapp to a new commit of library, and you git pull webapp, git will not automatically update library for you. This is actually what’s happening in the dramatic re-enactment above. Let me rewind a little bit to show what happened. What happens when someone updates a submodule? In the beginning, webapp pointed to webapp_old_commit_sha, which pinned library to library_old_commit_sha. (Think of HEAD as “current commit”.) Then, my collaborator made changes to library. Remember, library is a full repo, so after they did their work, they did what you always do after you make changes: they committed and pushed the new commit, library_new_commit_sha. They weren’t done, though. webapp must point to a specific commit of library, so in order to use library_new_commit_sha, my collaborator then pushed a new commit to webpapp, webapp_new_commit_sha, which points to library_new_commit_sha. Here’s the thing, though! git does not automatically update submodules, so library still points to library_old_commit_sha. I think this will be a lot less confusing if we look at exactly how git tracks submodules. Commercial interruption If you’re enjoying yourself, may I ask if you’d like to follow me via RSS feed, Mastodon, or Telegram channel? Thanks! How git tracks submodules How does git pin a submodule to a specific commit? The latest commit of webapp is webapp_new_commit_sha. Let’s inspect that commit. A commit is just a file on disk. However, it’s optimized/compressed, so we use a built-in utility to view it. Here’s what the commit stores. $ [/webapp] git cat-file -p `webapp_new_commit_sha` tree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4 parent webapp_old_commit_sha author Dmitry Mazin \u003cdm@cyberdemon.org\u003e 1708717288 +0000 committer Dmitry Mazin \u003cdm@cyberdemon.org\u003e 1708717288 +0000 point submodule to newest commit What we care about is tree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4. The tree object represents the directory listing of your repo. When you think trees, think directories. Let’s inspect the tree object. $ [/webapp] git cat-file -p 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4 100644 blob 6feaf03c7a9c805ff734a90a245a417e6a6c099b .gitmodules 100644 blob a72832b303c4d4f1833da79fc8a566e8a0eb37af README.md 040000 tree a425c23ded8892f901dee7fbc8d4c5714bdcc40d tests 160000 commit library_new_commit_sha library Note how tests is a tree (just like directories can hold directories, trees can point to trees). But library is a… commit?! 160000 commit library_new_commit_sha library That weirdness, right there, is precisely how git knows library points to library_new_commit_sha. In other words, the way git implements submodules is by doing a weird trick where a tree points to a commit. Let’s use this knowledge to understand the git diff from earlier. Understanding git diff Here’s the diff again. $ [/webapp] git diff diff --git a/library b/library index library_old_commit_sha..library_new_commit_sha 160000 --- a/library +++ b/library @@ -1 +1 @@ -Subproject commit library_new_commit_sha +Subproject commit library_old_commit_sha It’s confusing that it’s saying that I modified library. I didn’t modify it, someone else did! Usually, I think of git diff as “here are the changes I have made”. But this isn’t exactly correct. When you invoke git diff, you’re asking git to tell you the difference between your working tree (that is, your unstaged, uncommitted local changes) and the most recent commit of your branch (webapp_new_commit_sha). When you look at it that way, the above git diff starts to make sense. In webapp_new_commit_sha, library points to library_new_commit_sha, but in our working tree, library still points to library_old_commit_sha. git has no idea which change happened first. It only knows that your working tree is different from the commit. And, so it tells you: library_new_commit_sha is saying that library should point to library_new_commit_sha, but it doesn’t. Understanding the above took the pain out of submodules for me. However, I still haven’t told you how to update a submodule. How to update a submodule We now understand that we need to point library to library_new_commit_sha. How? Because library is a full repo, I could just cd into it and literally check out that commit: $ [/webapp] cd library $ [/library] git checkout library_new_commit_sha Previous HEAD position was library_old_commit_sha README HEAD is now at library_new_commit_sha add some cool functions If we go back into webapp, we’ll see that git st/git diff finally look clean. $ [/webapp] git st ## main...origin/main # (no output) $ [/webapp] git diff # (no output) However, you don’t actually need to do the above. How to really update a submodule From webapp, we can invoke git submodule update. This updates all of a repo’s submodules. People often use certain flags with git submodule update, so let’s understand them. Initialize a submodule: git submodule update --init Remember how I said that if you git clone webapp, git won’t actually download the contents of library? What you’re supposed to do is, after cloning webapp: Run git submodule init to initialize the submodules. This doesn’t actually download them, though 🙃️. Run git submodule update to actually pull the submodules. This is kind of a silly dance, so git lets you just do git submodule update --init. This initializes any submodules and updates them in one step. I always pass --init because there is no harm in doing so. You can skip --init by cloning with --recursive: that is, you could have done git clone webapp --recursive. I never remember to do this, though. Plus, you end up having to do git update submodule anyway. Update submodules of submodules: git submodule update --recursive Submodules can nest other submodules. Yeah. So, to take care of updating submodules all the way down, pretty much just always pass --recursive to git submodule update. So, the command I always end up using is git submodule update --init --recursive. Make git automatically update submodules: git config submodule.recurse true submodule.recurse true makes submodules automatically update when you git pull, git checkout, etc. In other words, it makes submodules automatically point to whatever they are supposed to point to. It’s only available in git 2.14 and newer. That makes running git submodule update unnecessary. I don’t use this setting, because I’m not sure if there are drawbacks or not. Plus, I work on submodules enough that I think it could cause conflicts. Let me know if you’re aware of shortcomings, or if you’ve been using this setting forever without issue! This setting definitely does not apply to git clone. So you still need to do git clone --recursive or init/update submodules using the commands above. Recap I think I can summarize submodules pretty simply. It’s possible to embed a repo within another repo. This is called a submodule. Each commit of the outer repo always specifies an exact commit that submodule. This is done by the outer commit -\u003e tree -\u003e submodule commit link. When you check out commits, git doesn’t automatically update submodules for you. You have to do that using git submodule update. And there we have it! Further topics in submodules The above is enough to hopefully take the confusion out of submodules. However, there are more common commands and configs that I’d like to explain. How to add a submodule: git submodule add Let’s say that I start webapp fresh, and I have not added library to it yet. To add library, I’d do git submodule add https://github.com/dmazin/library.git library. This will add (or update) the .gitmodules file of webapp, download library, and point webapp at the latest commit of library. Remember, this actually modifies webapp, so you need to commit after that. But you thankfully don’t need to do git submodule update after doing git submodule add or anything. What do I do after I’ve modified a submodule? Remember that library is a full repo, so if you want to make changes to it, you can. Just make changes and commit them to the main branch. But how do you make webapp point at the new commit? There are a couple ways. Without a command You can go into webapp, then cd library, and just do git pull in there. When you cd back into webapp, if you git diff you’ll see that webapp points to the newest branch of library. You can commit that. Using git submodule update --remote -- library This tells git “make the submodule point to the latest remote commit”. Since you have pushed the latest commit of library to library’s remote, this will make webapp point to that commit. But note that git submodule update --remote will do this to all your submodules. You likely do not want that. For that reason, you have to do git submodule update --remote -- library to limit this to library only. (If you’re thrown off by the fact that you have to do -- library – yeah, it’s kind of weird.) Because --remote might accidentally update all the submodules, honestly I usually do the “without a command” method. The .gitmodules file How does git know where to download library from? git uses a file called .gitmodules to track the basic facts of a submodule, like the repo URL. $ [/webapp] cat .gitmodules [submodule \"library\"] path = library url = https://github.com/dmazin/library.git The nice thing about .gitmodules is that it’s a regular file, tracked the regular way in git. That makes it not confusing. (What I don’t understand is, why git didn’t just put the submodule commit right in .gitmodules? The commits of webapp would still be able to specify exact commits of library to use. What am I missing?) Making submodules use branches other than main If you want to, you can make library track whatever branch you want. Otherwise, it defaults to whatever the “main” branch is. [submodule \"library\"] path = library url = https://github.com/dmazin/library.git branch = staging Thanks for reading!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThroughout my career, I have found git submodules to be a pain. Because I did not understand them, I kept getting myself into frustrating situations.\u003c/p\u003e\n\n\u003cp\u003eSo, I finally sat down and learned how git tracks submodules. Turns out, it’s not complex at all. It’s just different from how git tracks regular files. It’s just one more thing you have to learn.\u003c/p\u003e\n\n\u003cp\u003eIn this article, I’ll explain exactly what I needed to know in order to work with submodules without inflicting self-damage.\u003c/p\u003e\n\n\u003cp\u003e(This article doesn’t discuss whether submodules are good/bad, or if you should use them or not – a valid discussion, but out of scope.)\u003c/p\u003e\n\n\u003ch2 id=\"the-lay-of-the-land\"\u003eThe lay of the land\u003c/h2\u003e\n\u003cp\u003eThis article will make more sense if we use concrete examples.\u003c/p\u003e\n\n\u003cp\u003eAllow me to describe a toy webapp we’re building. Call this repo \u003ccode\u003ewebapp\u003c/code\u003e. Here are the contents of the repo.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] ls\n\n.git/\nREADME.md\ntests/\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSay you want to import some library. It lives in its own repo, \u003ccode\u003elibrary\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/library] ls\n\n.git/\nREADME.md\nmy_cool_functions.py\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eShortly, I’ll explain how submodules work. But, first, let me dramatically re-enact something that has happened to me multiple times. This is what it looks like to use submodules without understanding them.\u003c/p\u003e\n\n\u003ch2 id=\"a-day-in-the-life-of-someone-who-doesnt-understand-submodules\"\u003eA day in the life of someone who doesn’t understand submodules\u003c/h2\u003e\n\u003cp\u003eAh, 2012. What a time to be a “full-stack engineer”! I wonder what contributions await me on the main branch!\u003c/p\u003e\n\n\u003cp\u003e(For the sake of readability, in this article, instead of using real commit SHAs, I’m going to use fake descriptive ones.)\u003c/p\u003e\n\n\u003cp\u003eLet’s pull to make sure I’m up-to-date with the remote.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e$ \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e/webapp] git pull\n\nremote: Enumerating objects: 3, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Counting objects: 100% \u003cspan\u003e(\u003c/span\u003e3/3\u003cspan\u003e)\u003c/span\u003e, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Compressing objects: 100% \u003cspan\u003e(\u003c/span\u003e1/1\u003cspan\u003e)\u003c/span\u003e, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Total 2 \u003cspan\u003e(\u003c/span\u003edelta 1\u003cspan\u003e)\u003c/span\u003e, reused 2 \u003cspan\u003e(\u003c/span\u003edelta 1\u003cspan\u003e)\u003c/span\u003e, pack-reused 0\nUnpacking objects: 100% \u003cspan\u003e(\u003c/span\u003e2/2\u003cspan\u003e)\u003c/span\u003e, 237 bytes | 118.00 KiB/s, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nFrom https://github.com/dmazin/webapp\n   webapp_old_commit_sha..webapp_new_commit_sha  main -\u0026gt; origin/main\nUpdating webapp_old_commit_sha..webapp_new_commit_sha\nFast-forward\n library | 2 +-\n 1 file changed, 1 insertion\u003cspan\u003e(\u003c/span\u003e+\u003cspan\u003e)\u003c/span\u003e, 1 deletion\u003cspan\u003e(\u003c/span\u003e-\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAfter I pull, I like to confirm that my working tree is clean.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n M library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhat’s this? I’ve made modifications to \u003ccode\u003elibrary\u003c/code\u003e? I never touch that directory.\u003c/p\u003e\n\n\u003cp\u003eIt’s weird that I’ve modified a \u003cem\u003edirectory\u003c/em\u003e. Usually git just says I’ve modified a specific \u003cem\u003efile\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eWell, what does \u003ccode\u003egit diff\u003c/code\u003e have to say?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git diff\n\ndiff --git a/library b/library\nindex library_old_commit_sha..library_new_commit_sha 160000\n--- a/library\n+++ b/library\n@@ -1 +1 @@\n-Subproject commit library_new_commit_sha\n+Subproject commit library_old_commit_sha\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eApparently, I deleted \u003ccode\u003eSubproject commit library_new_commit_sha\u003c/code\u003e and added \u003ccode\u003eSubproject commit library_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSurely I didn’t do that. That’s weird, let me do a hard reset.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git reset --hard origin/main\n\nHEAD is now at webapp_new_commit_sha point submodule to newest commit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eDid it make the git diff go away?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n M library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt did not! I am really confused now!\u003c/p\u003e\n\n\u003cp\u003eWell, the usual way I make local modifications go away is \u003ccode\u003egit reset --hard\u003c/code\u003e, and that didn’t work. The other way is to commit the changes.\u003c/p\u003e\n\n\u003cp\u003e(Sometimes, people don’t even notice the diff above, and accidentally do this.)\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eMy future self\u003c/strong\u003e: \u003cem\u003eDon’t do it! If you \u003ccode\u003egit add\u003c/code\u003e that change, you’ll be rolling back a change someone else made!\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eWhat’s going on, of course, is that \u003ccode\u003elibrary\u003c/code\u003e is a submodule, and you have to do special stuff to deal with them.\u003c/p\u003e\n\n\u003cp\u003eLet’s dive into submodules.\u003c/p\u003e\n\n\u003ch2 id=\"whats-a-submodule\"\u003eWhat’s a submodule?\u003c/h2\u003e\n\u003cp\u003eA git submodule is a full repo that’s been nested inside another repo. Any repo can be a submodule of another.\u003c/p\u003e\n\n\u003cp\u003eSo, \u003ccode\u003elibrary\u003c/code\u003e is a full repo that has been nested inside \u003ccode\u003ewebapp\u003c/code\u003e as a submodule.\u003c/p\u003e\n\n\u003cp\u003eThat doesn’t seem so confusing, does it? However, there are two important, and tricky, facts about submodules. These facts are why so many people trip up on submodules.\u003c/p\u003e\n\n\u003ch3 id=\"1-a-submodule-is-always-pinned-to-a-specific-commit\"\u003e1. A submodule is always pinned to a specific commit\u003c/h3\u003e\n\u003cp\u003eYou know how package managers let you be  fuzzy when specifying a package version (“get me any version of \u003ccode\u003erequests\u003c/code\u003e so long as it’s 2.x.x”), or to pin an exact version (“use \u003ccode\u003erequests\u003c/code\u003e 2.31.0 exactly”)?\u003c/p\u003e\n\n\u003cp\u003eSubmodules can \u003cem\u003eonly\u003c/em\u003e be pinned to a specific commit. This is because a submodule isn’t a package; it’s code that you have embedded in another repo, and git wants you to be precise.\u003c/p\u003e\n\n\u003cp\u003eWe’ll see exactly how this pinning works shortly.\u003c/p\u003e\n\n\u003ch3 id=\"2-git-does-not-automatically-download-or-update-submodules\"\u003e2. git does not automatically download or update submodules\u003c/h3\u003e\n\u003cp\u003eIf you clone \u003ccode\u003ewebapp\u003c/code\u003e afresh, git \u003cem\u003ewill not\u003c/em\u003e automatically download \u003ccode\u003elibrary\u003c/code\u003e for you (unless you clone using \u003ccode\u003egit clone --recursive\u003c/code\u003e)\u003c/p\u003e\n\n\u003cp\u003eSimilarly, if a collaborator pins \u003ccode\u003ewebapp\u003c/code\u003e to a new commit of \u003ccode\u003elibrary\u003c/code\u003e, and you \u003ccode\u003egit pull\u003c/code\u003e \u003ccode\u003ewebapp\u003c/code\u003e, git \u003cem\u003ewill not\u003c/em\u003e automatically update \u003ccode\u003elibrary\u003c/code\u003e for you.\u003c/p\u003e\n\n\u003cp\u003eThis is actually what’s happening in the dramatic re-enactment above. Let me rewind a little bit to show what happened.\u003c/p\u003e\n\n\u003ch2 id=\"what-happens-when-someone-updates-a-submodule\"\u003eWhat happens when someone updates a submodule?\u003c/h2\u003e\n\u003cp\u003eIn the beginning, \u003ccode\u003ewebapp\u003c/code\u003e pointed to \u003ccode\u003ewebapp_old_commit_sha\u003c/code\u003e, which pinned \u003ccode\u003elibrary\u003c/code\u003e to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules1.png\" alt=\"Hand-drawn diagram of two git repositories, webapp and library. It shows that the old_sha commit of the webapp repo points to the old_sha commit of the library repo. The old_sha commit of the webapp repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. The old_sha commit of the library repo also has a purple border around it, saying \u0026#39;HEAD\u0026#39;.\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e(Think of \u003ccode\u003eHEAD\u003c/code\u003e as “current commit”.)\u003c/p\u003e\n\n\u003cp\u003eThen, my collaborator made changes to \u003ccode\u003elibrary\u003c/code\u003e. Remember, \u003ccode\u003elibrary\u003c/code\u003e is a full repo, so after they did their work, they did what you always do after you make changes: they committed and pushed the new commit, \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThey weren’t done, though. \u003ccode\u003ewebapp\u003c/code\u003e must point to a specific commit of \u003ccode\u003elibrary\u003c/code\u003e, so in order to use \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, my collaborator then pushed a new commit to \u003ccode\u003ewebpapp\u003c/code\u003e, \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e, which points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere’s the thing, though! \u003cem\u003egit does not automatically update submodules\u003c/em\u003e, so \u003ccode\u003elibrary\u003c/code\u003e still points to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules2.png\" alt=\"Hand-drawn diagram of two git repositories, webapp and library. It shows that the old_sha commit of the webapp repo points to the old_sha commit of the library repo. The new_sha commit of the webapp repo points to the new_sha of the library repo. The new_sha commit of the webapp repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. The old_sha commit of the library repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. A red arrow points to the purple border around old_sha in the library repo. The red arrow is linked to a speech bubble which says, \u0026#39;library still points at old_sha!\u0026#39;\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eI think this will be a lot less confusing if we look at exactly how git tracks submodules.\u003c/p\u003e\n\n\u003ch2 id=\"commercial-interruption\"\u003eCommercial interruption\u003c/h2\u003e\n\u003cp\u003eIf you’re enjoying yourself, may I ask if you’d like to follow me via \u003ca href=\"https://www.cyberdemon.org/feed.xml\"\u003eRSS feed\u003c/a\u003e, \u003ca href=\"https://file-explorers.club/@dmitry\"\u003eMastodon\u003c/a\u003e, or \u003ca href=\"https://t.me/cyberdemon6\"\u003eTelegram channel\u003c/a\u003e? Thanks!\u003c/p\u003e\n\n\u003ch2 id=\"how-git-tracks-submodules\"\u003eHow git tracks submodules\u003c/h2\u003e\n\u003ch3 id=\"how-does-git-pin-a-submodule-to-a-specific-commit\"\u003eHow does git pin a submodule to a specific commit?\u003c/h3\u003e\n\u003cp\u003eThe latest commit of \u003ccode\u003ewebapp\u003c/code\u003e is \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e. Let’s inspect that commit.\u003c/p\u003e\n\n\u003cp\u003eA commit is just a file on disk. However, it’s optimized/compressed, so we use a built-in utility to view it. Here’s what the commit stores.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git cat-file -p `webapp_new_commit_sha`\n\ntree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\nparent webapp_old_commit_sha\nauthor Dmitry Mazin \u0026lt;dm@cyberdemon.org\u0026gt; 1708717288 +0000\ncommitter Dmitry Mazin \u0026lt;dm@cyberdemon.org\u0026gt; 1708717288 +0000\n\npoint submodule to newest commit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhat we care about is \u003ccode\u003etree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\u003c/code\u003e. The \u003cem\u003etree\u003c/em\u003e object represents the directory listing of your repo. When you think trees, think directories.\u003c/p\u003e\n\n\u003cp\u003eLet’s inspect the tree object.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git cat-file -p 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\n\n100644 blob     6feaf03c7a9c805ff734a90a245a417e6a6c099b    .gitmodules\n100644 blob     a72832b303c4d4f1833da79fc8a566e8a0eb37af    README.md\n040000 tree     a425c23ded8892f901dee7fbc8d4c5714bdcc40d    tests\n160000 commit   library_new_commit_sha                      library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNote how \u003ccode\u003etests\u003c/code\u003e is a \u003ccode\u003etree\u003c/code\u003e (just like directories can hold directories, trees can point to trees).\u003c/p\u003e\n\n\u003cp\u003eBut \u003ccode\u003elibrary\u003c/code\u003e is a… commit?!\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e160000 commit   library_new_commit_sha                      library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat weirdness, right there, is precisely how git knows \u003ccode\u003elibrary\u003c/code\u003e points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn other words, the way git implements submodules is by doing a weird trick where a tree points to a \u003cem\u003ecommit\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules3.png\" alt=\"Hand-drawn diagram showing the text \u0026#39;webapp_new_commit_sha\u0026#39; connected, via arrow, to \u0026#39;tree a425\u0026#39; which is itself connected, via arrow, to \u0026#39;library_new_commit_sha\u0026#39;\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eLet’s use this knowledge to understand the \u003ccode\u003egit diff\u003c/code\u003e from earlier.\u003c/p\u003e\n\n\u003ch2 id=\"understanding-git-diff\"\u003eUnderstanding git diff\u003c/h2\u003e\n\u003cp\u003eHere’s the diff again.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git diff\n\ndiff --git a/library b/library\nindex library_old_commit_sha..library_new_commit_sha 160000\n--- a/library\n+++ b/library\n@@ -1 +1 @@\n-Subproject commit library_new_commit_sha\n+Subproject commit library_old_commit_sha\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt’s confusing that it’s saying that \u003cstrong\u003eI\u003c/strong\u003e modified \u003ccode\u003elibrary\u003c/code\u003e. I didn’t modify it, someone else did!\u003c/p\u003e\n\n\u003cp\u003eUsually, I think of \u003ccode\u003egit diff\u003c/code\u003e as “here are the changes I have made”. But this isn’t exactly correct.\u003c/p\u003e\n\n\u003cp\u003eWhen you invoke \u003ccode\u003egit diff\u003c/code\u003e, you’re asking git to tell you the difference between your working tree (that is, your unstaged, uncommitted local changes) and the most recent commit of your branch (\u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eWhen you look at it that way, the above git diff starts to make sense. In \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e, \u003ccode\u003elibrary\u003c/code\u003e points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, but in our working tree, \u003ccode\u003elibrary\u003c/code\u003e still points to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003egit has no idea which change happened first. It only knows that your working tree is different from the commit. And, so it tells you: \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e is saying that library should point to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, but it doesn’t.\u003c/p\u003e\n\n\u003cp\u003eUnderstanding the above took the pain out of submodules for me. However, I still haven’t told you how to update a submodule.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-update-a-submodule\"\u003eHow to update a submodule\u003c/h2\u003e\n\u003cp\u003eWe now understand that we need to point \u003ccode\u003elibrary\u003c/code\u003e to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e. How?\u003c/p\u003e\n\n\u003cp\u003eBecause \u003ccode\u003elibrary\u003c/code\u003e is a full repo, I could just \u003ccode\u003ecd\u003c/code\u003e into it and literally check out that commit:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] cd library\n\n$ [/library] git checkout library_new_commit_sha\n\nPrevious HEAD position was library_old_commit_sha README\nHEAD is now at library_new_commit_sha add some cool functions\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf we go back into \u003ccode\u003ewebapp\u003c/code\u003e, we’ll see that \u003ccode\u003egit st\u003c/code\u003e/\u003ccode\u003egit diff\u003c/code\u003e finally look clean.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n# (no output)\n\n$ [/webapp] git diff\n\n# (no output)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHowever, you don’t actually need to do the above.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-really-update-a-submodule\"\u003eHow to really update a submodule\u003c/h2\u003e\n\u003cp\u003eFrom \u003ccode\u003ewebapp\u003c/code\u003e, we can invoke \u003ccode\u003egit submodule update\u003c/code\u003e. This updates \u003cem\u003eall\u003c/em\u003e of a repo’s submodules.\u003c/p\u003e\n\n\u003cp\u003ePeople often use certain flags with \u003ccode\u003egit submodule update\u003c/code\u003e, so let’s understand them.\u003c/p\u003e\n\n\u003ch3 id=\"initialize-a-submodule-git-submodule-update---init\"\u003eInitialize a submodule: \u003ccode\u003egit submodule update --init\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eRemember how I said that if you \u003ccode\u003egit clone webapp\u003c/code\u003e, git won’t actually download the contents of \u003ccode\u003elibrary\u003c/code\u003e?\u003c/p\u003e\n\n\u003cp\u003eWhat you’re supposed to do is, after cloning webapp:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eRun \u003ccode\u003egit submodule init\u003c/code\u003e to initialize the submodules. This doesn’t actually download them, though 🙃️.\u003c/li\u003e\n  \u003cli\u003eRun \u003ccode\u003egit submodule update\u003c/code\u003e to actually pull the submodules.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThis is kind of a silly dance, so git lets you just do \u003ccode\u003egit submodule update --init\u003c/code\u003e. This initializes any submodules and updates them in one step. I \u003cem\u003ealways\u003c/em\u003e pass \u003ccode\u003e--init\u003c/code\u003e because there is no harm in doing so.\u003c/p\u003e\n\n\u003cp\u003eYou can skip \u003ccode\u003e--init\u003c/code\u003e by cloning with \u003ccode\u003e--recursive\u003c/code\u003e: that is, you could have done \u003ccode\u003egit clone webapp --recursive\u003c/code\u003e. I never remember to do this, though. Plus, you end up having to do \u003ccode\u003egit update submodule\u003c/code\u003e anyway.\u003c/p\u003e\n\n\u003ch3 id=\"update-submodules-of-submodules-git-submodule-update---recursive\"\u003eUpdate submodules of submodules: \u003ccode\u003egit submodule update --recursive\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eSubmodules can nest other submodules. Yeah.\u003c/p\u003e\n\n\u003cp\u003eSo, to take care of updating submodules \u003cem\u003eall the way down\u003c/em\u003e, pretty much just always pass \u003ccode\u003e--recursive\u003c/code\u003e to \u003ccode\u003egit submodule update\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSo, the command I always end up using is \u003ccode\u003egit submodule update --init --recursive\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch3 id=\"make-git-automatically-update-submodules-git-config-submodulerecurse-true\"\u003eMake git automatically update submodules: \u003ccode\u003egit config submodule.recurse true\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esubmodule.recurse true\u003c/code\u003e makes submodules automatically update when you \u003ccode\u003egit pull\u003c/code\u003e, \u003ccode\u003egit checkout\u003c/code\u003e, etc. In other words, it makes submodules automatically point to whatever they are supposed to point to. It’s only available in git 2.14 and newer.\u003c/p\u003e\n\n\u003cp\u003eThat makes running \u003ccode\u003egit submodule update\u003c/code\u003e unnecessary.\u003c/p\u003e\n\n\u003cp\u003eI don’t use this setting, because I’m not sure if there are drawbacks or not. Plus, I work on submodules enough that I think it could cause conflicts. Let me know if you’re aware of shortcomings, or if you’ve been using this setting forever without issue!\u003c/p\u003e\n\n\u003cp\u003eThis setting definitely does \u003cem\u003enot\u003c/em\u003e apply to \u003ccode\u003egit clone\u003c/code\u003e. So you still need to do \u003ccode\u003egit clone --recursive\u003c/code\u003e or init/update submodules using the commands above.\u003c/p\u003e\n\n\u003ch2 id=\"recap\"\u003eRecap\u003c/h2\u003e\n\u003cp\u003eI think I can summarize submodules pretty simply.\u003c/p\u003e\n\n\u003cp\u003eIt’s possible to embed a repo within another repo. This is called a submodule.\u003c/p\u003e\n\n\u003cp\u003eEach commit of the outer repo always specifies an \u003cem\u003eexact\u003c/em\u003e commit that submodule. This is done by the \u003ccode\u003eouter commit -\u0026gt; tree -\u0026gt; submodule commit\u003c/code\u003e link.\u003c/p\u003e\n\n\u003cp\u003eWhen you check out commits, git doesn’t automatically update submodules for you. You have to do that using \u003ccode\u003egit submodule update\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAnd there we have it!\u003c/p\u003e\n\n\u003ch2 id=\"further-topics-in-submodules\"\u003eFurther topics in submodules\u003c/h2\u003e\n\u003cp\u003eThe above is enough to hopefully take the confusion out of submodules. However, there are more common commands and configs that I’d like to explain.\u003c/p\u003e\n\n\u003ch3 id=\"how-to-add-a-submodule-git-submodule-add\"\u003eHow to add a submodule: \u003ccode\u003egit submodule add\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eLet’s say that I start \u003ccode\u003ewebapp\u003c/code\u003e fresh, and I have not added \u003ccode\u003elibrary\u003c/code\u003e to it yet.\u003c/p\u003e\n\n\u003cp\u003eTo add \u003ccode\u003elibrary\u003c/code\u003e, I’d do \u003ccode\u003egit submodule add https://github.com/dmazin/library.git library\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis will add (or update) the \u003ccode\u003e.gitmodules\u003c/code\u003e file of \u003ccode\u003ewebapp\u003c/code\u003e, download \u003ccode\u003elibrary\u003c/code\u003e, and point \u003ccode\u003ewebapp\u003c/code\u003e at the latest commit of \u003ccode\u003elibrary\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eRemember, this actually modifies \u003ccode\u003ewebapp\u003c/code\u003e, so you need to commit after that. But you thankfully don’t need to do \u003ccode\u003egit submodule update\u003c/code\u003e after doing \u003ccode\u003egit submodule add\u003c/code\u003e or anything.\u003c/p\u003e\n\n\u003ch3 id=\"what-do-i-do-after-ive-modified-a-submodule\"\u003eWhat do I do after I’ve modified a submodule?\u003c/h3\u003e\n\u003cp\u003eRemember that \u003ccode\u003elibrary\u003c/code\u003e is a full repo, so if you want to make changes to it, you can. Just make changes and commit them to the main branch.\u003c/p\u003e\n\n\u003cp\u003eBut how do you make \u003ccode\u003ewebapp\u003c/code\u003e point at the new commit? There are a couple ways.\u003c/p\u003e\n\n\u003ch4 id=\"without-a-command\"\u003eWithout a command\u003c/h4\u003e\n\u003cp\u003eYou can go into \u003ccode\u003ewebapp\u003c/code\u003e, then \u003ccode\u003ecd library\u003c/code\u003e, and just do \u003ccode\u003egit pull\u003c/code\u003e in there. When you \u003ccode\u003ecd\u003c/code\u003e back into \u003ccode\u003ewebapp\u003c/code\u003e, if you \u003ccode\u003egit diff\u003c/code\u003e you’ll see that \u003ccode\u003ewebapp\u003c/code\u003e points to the newest branch of \u003ccode\u003elibrary\u003c/code\u003e. You can commit that.\u003c/p\u003e\n\n\u003ch4 id=\"using-git-submodule-update---remote----library\"\u003eUsing \u003ccode\u003egit submodule update --remote -- library\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eThis tells git “make the submodule point to the latest remote commit”. Since you have pushed the latest commit of library to library’s remote, this will make \u003ccode\u003ewebapp\u003c/code\u003e point to that commit.\u003c/p\u003e\n\n\u003cp\u003eBut note that \u003ccode\u003egit submodule update --remote\u003c/code\u003e will do this to \u003cem\u003eall\u003c/em\u003e your submodules. You likely do not want that.\u003c/p\u003e\n\n\u003cp\u003eFor that reason, you have to do \u003ccode\u003egit submodule update --remote -- library\u003c/code\u003e to limit this to library only. (If you’re thrown off by the fact that you have to do \u003ccode\u003e-- library\u003c/code\u003e – yeah, it’s kind of weird.)\u003c/p\u003e\n\n\u003cp\u003eBecause \u003ccode\u003e--remote\u003c/code\u003e might accidentally update all the submodules, honestly I usually do the “without a command” method.\u003c/p\u003e\n\n\u003ch3 id=\"the-gitmodules-file\"\u003eThe .gitmodules file\u003c/h3\u003e\n\u003cp\u003eHow does git know where to download \u003ccode\u003elibrary\u003c/code\u003e from?\ngit uses a file called \u003ccode\u003e.gitmodules\u003c/code\u003e to track the basic facts of a submodule, like the repo URL.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] cat .gitmodules\n\n[submodule \u0026#34;library\u0026#34;]\n        path = library\n        url = https://github.com/dmazin/library.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe nice thing about \u003ccode\u003e.gitmodules\u003c/code\u003e is that it’s a regular file, tracked the regular way in git. That makes it not confusing.\u003c/p\u003e\n\n\u003cp\u003e(What I don’t understand is, why git didn’t just put the submodule commit right in .gitmodules? The commits of \u003ccode\u003ewebapp\u003c/code\u003e would \u003cem\u003estill\u003c/em\u003e be able to specify exact commits of \u003ccode\u003elibrary\u003c/code\u003e to use. What am I missing?)\u003c/p\u003e\n\n\u003ch3 id=\"making-submodules-use-branches-other-than-main\"\u003eMaking submodules use branches other than main\u003c/h3\u003e\n\u003cp\u003eIf you want to, you can make \u003ccode\u003elibrary\u003c/code\u003e track whatever branch you want. Otherwise, it defaults to whatever the “main” branch is.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e[submodule \u0026#34;library\u0026#34;]\n        path = library\n        url = https://github.com/dmazin/library.git\n        branch = staging\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThanks for reading!\u003c/p\u003e\n\n    \n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
