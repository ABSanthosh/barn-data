{
  "id": "ac8c0b8c-8e8a-4d31-a638-12b0361db4af",
  "title": "Demystifying Git Submodules",
  "link": "https://www.cyberdemon.org/2024/03/20/submodules.html",
  "description": "Article URL: https://www.cyberdemon.org/2024/03/20/submodules.html Comments URL: https://news.ycombinator.com/item?id=42291833 Points: 3 # Comments: 0",
  "author": "signa11",
  "published": "Mon, 02 Dec 2024 00:19:16 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 14680,
  "excerpt": "Demystifying git submodules by showing exactly how they work.",
  "siteName": "cyberdemon.org",
  "favicon": "",
  "text": "Throughout my career, I have found git submodules to be a pain. Because I did not understand them, I kept getting myself into frustrating situations. So, I finally sat down and learned how git tracks submodules. Turns out, it‚Äôs not complex at all. It‚Äôs just different from how git tracks regular files. It‚Äôs just one more thing you have to learn. In this article, I‚Äôll explain exactly what I needed to know in order to work with submodules without inflicting self-damage. (This article doesn‚Äôt discuss whether submodules are good/bad, or if you should use them or not ‚Äì a valid discussion, but out of scope.) The lay of the land This article will make more sense if we use concrete examples. Allow me to describe a toy webapp we‚Äôre building. Call this repo webapp. Here are the contents of the repo. $ [/webapp] ls .git/ README.md tests/ Say you want to import some library. It lives in its own repo, library. $ [/library] ls .git/ README.md my_cool_functions.py Shortly, I‚Äôll explain how submodules work. But, first, let me dramatically re-enact something that has happened to me multiple times. This is what it looks like to use submodules without understanding them. A day in the life of someone who doesn‚Äôt understand submodules Ah, 2012. What a time to be a ‚Äúfull-stack engineer‚Äù! I wonder what contributions await me on the main branch! (For the sake of readability, in this article, instead of using real commit SHAs, I‚Äôm going to use fake descriptive ones.) Let‚Äôs pull to make sure I‚Äôm up-to-date with the remote. $ [/webapp] git pull remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Compressing objects: 100% (1/1), done. remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0 Unpacking objects: 100% (2/2), 237 bytes | 118.00 KiB/s, done. From https://github.com/dmazin/webapp webapp_old_commit_sha..webapp_new_commit_sha main -\u003e origin/main Updating webapp_old_commit_sha..webapp_new_commit_sha Fast-forward library | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) After I pull, I like to confirm that my working tree is clean. $ [/webapp] git st ## main...origin/main M library What‚Äôs this? I‚Äôve made modifications to library? I never touch that directory. It‚Äôs weird that I‚Äôve modified a directory. Usually git just says I‚Äôve modified a specific file. Well, what does git diff have to say? $ [/webapp] git diff diff --git a/library b/library index library_old_commit_sha..library_new_commit_sha 160000 --- a/library +++ b/library @@ -1 +1 @@ -Subproject commit library_new_commit_sha +Subproject commit library_old_commit_sha Apparently, I deleted Subproject commit library_new_commit_sha and added Subproject commit library_old_commit_sha. Surely I didn‚Äôt do that. That‚Äôs weird, let me do a hard reset. $ [/webapp] git reset --hard origin/main HEAD is now at webapp_new_commit_sha point submodule to newest commit Did it make the git diff go away? $ [/webapp] git st ## main...origin/main M library It did not! I am really confused now! Well, the usual way I make local modifications go away is git reset --hard, and that didn‚Äôt work. The other way is to commit the changes. (Sometimes, people don‚Äôt even notice the diff above, and accidentally do this.) My future self: Don‚Äôt do it! If you git add that change, you‚Äôll be rolling back a change someone else made! What‚Äôs going on, of course, is that library is a submodule, and you have to do special stuff to deal with them. Let‚Äôs dive into submodules. What‚Äôs a submodule? A git submodule is a full repo that‚Äôs been nested inside another repo. Any repo can be a submodule of another. So, library is a full repo that has been nested inside webapp as a submodule. That doesn‚Äôt seem so confusing, does it? However, there are two important, and tricky, facts about submodules. These facts are why so many people trip up on submodules. 1. A submodule is always pinned to a specific commit You know how package managers let you be fuzzy when specifying a package version (‚Äúget me any version of requests so long as it‚Äôs 2.x.x‚Äù), or to pin an exact version (‚Äúuse requests 2.31.0 exactly‚Äù)? Submodules can only be pinned to a specific commit. This is because a submodule isn‚Äôt a package; it‚Äôs code that you have embedded in another repo, and git wants you to be precise. We‚Äôll see exactly how this pinning works shortly. 2. git does not automatically download or update submodules If you clone webapp afresh, git will not automatically download library for you (unless you clone using git clone --recursive) Similarly, if a collaborator pins webapp to a new commit of library, and you git pull webapp, git will not automatically update library for you. This is actually what‚Äôs happening in the dramatic re-enactment above. Let me rewind a little bit to show what happened. What happens when someone updates a submodule? In the beginning, webapp pointed to webapp_old_commit_sha, which pinned library to library_old_commit_sha. (Think of HEAD as ‚Äúcurrent commit‚Äù.) Then, my collaborator made changes to library. Remember, library is a full repo, so after they did their work, they did what you always do after you make changes: they committed and pushed the new commit, library_new_commit_sha. They weren‚Äôt done, though. webapp must point to a specific commit of library, so in order to use library_new_commit_sha, my collaborator then pushed a new commit to webpapp, webapp_new_commit_sha, which points to library_new_commit_sha. Here‚Äôs the thing, though! git does not automatically update submodules, so library still points to library_old_commit_sha. I think this will be a lot less confusing if we look at exactly how git tracks submodules. Commercial interruption If you‚Äôre enjoying yourself, may I ask if you‚Äôd like to follow me via RSS feed, Mastodon, or Telegram channel? Thanks! How git tracks submodules How does git pin a submodule to a specific commit? The latest commit of webapp is webapp_new_commit_sha. Let‚Äôs inspect that commit. A commit is just a file on disk. However, it‚Äôs optimized/compressed, so we use a built-in utility to view it. Here‚Äôs what the commit stores. $ [/webapp] git cat-file -p `webapp_new_commit_sha` tree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4 parent webapp_old_commit_sha author Dmitry Mazin \u003cdm@cyberdemon.org\u003e 1708717288 +0000 committer Dmitry Mazin \u003cdm@cyberdemon.org\u003e 1708717288 +0000 point submodule to newest commit What we care about is tree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4. The tree object represents the directory listing of your repo. When you think trees, think directories. Let‚Äôs inspect the tree object. $ [/webapp] git cat-file -p 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4 100644 blob 6feaf03c7a9c805ff734a90a245a417e6a6c099b .gitmodules 100644 blob a72832b303c4d4f1833da79fc8a566e8a0eb37af README.md 040000 tree a425c23ded8892f901dee7fbc8d4c5714bdcc40d tests 160000 commit library_new_commit_sha library Note how tests is a tree (just like directories can hold directories, trees can point to trees). But library is a‚Ä¶ commit?! 160000 commit library_new_commit_sha library That weirdness, right there, is precisely how git knows library points to library_new_commit_sha. In other words, the way git implements submodules is by doing a weird trick where a tree points to a commit. Let‚Äôs use this knowledge to understand the git diff from earlier. Understanding git diff Here‚Äôs the diff again. $ [/webapp] git diff diff --git a/library b/library index library_old_commit_sha..library_new_commit_sha 160000 --- a/library +++ b/library @@ -1 +1 @@ -Subproject commit library_new_commit_sha +Subproject commit library_old_commit_sha It‚Äôs confusing that it‚Äôs saying that I modified library. I didn‚Äôt modify it, someone else did! Usually, I think of git diff as ‚Äúhere are the changes I have made‚Äù. But this isn‚Äôt exactly correct. When you invoke git diff, you‚Äôre asking git to tell you the difference between your working tree (that is, your unstaged, uncommitted local changes) and the most recent commit of your branch (webapp_new_commit_sha). When you look at it that way, the above git diff starts to make sense. In webapp_new_commit_sha, library points to library_new_commit_sha, but in our working tree, library still points to library_old_commit_sha. git has no idea which change happened first. It only knows that your working tree is different from the commit. And, so it tells you: library_new_commit_sha is saying that library should point to library_new_commit_sha, but it doesn‚Äôt. Understanding the above took the pain out of submodules for me. However, I still haven‚Äôt told you how to update a submodule. How to update a submodule We now understand that we need to point library to library_new_commit_sha. How? Because library is a full repo, I could just cd into it and literally check out that commit: $ [/webapp] cd library $ [/library] git checkout library_new_commit_sha Previous HEAD position was library_old_commit_sha README HEAD is now at library_new_commit_sha add some cool functions If we go back into webapp, we‚Äôll see that git st/git diff finally look clean. $ [/webapp] git st ## main...origin/main # (no output) $ [/webapp] git diff # (no output) However, you don‚Äôt actually need to do the above. How to really update a submodule From webapp, we can invoke git submodule update. This updates all of a repo‚Äôs submodules. People often use certain flags with git submodule update, so let‚Äôs understand them. Initialize a submodule: git submodule update --init Remember how I said that if you git clone webapp, git won‚Äôt actually download the contents of library? What you‚Äôre supposed to do is, after cloning webapp: Run git submodule init to initialize the submodules. This doesn‚Äôt actually download them, though üôÉÔ∏è. Run git submodule update to actually pull the submodules. This is kind of a silly dance, so git lets you just do git submodule update --init. This initializes any submodules and updates them in one step. I always pass --init because there is no harm in doing so. You can skip --init by cloning with --recursive: that is, you could have done git clone webapp --recursive. I never remember to do this, though. Plus, you end up having to do git update submodule anyway. Update submodules of submodules: git submodule update --recursive Submodules can nest other submodules. Yeah. So, to take care of updating submodules all the way down, pretty much just always pass --recursive to git submodule update. So, the command I always end up using is git submodule update --init --recursive. Make git automatically update submodules: git config submodule.recurse true submodule.recurse true makes submodules automatically update when you git pull, git checkout, etc. In other words, it makes submodules automatically point to whatever they are supposed to point to. It‚Äôs only available in git 2.14 and newer. That makes running git submodule update unnecessary. I don‚Äôt use this setting, because I‚Äôm not sure if there are drawbacks or not. Plus, I work on submodules enough that I think it could cause conflicts. Let me know if you‚Äôre aware of shortcomings, or if you‚Äôve been using this setting forever without issue! This setting definitely does not apply to git clone. So you still need to do git clone --recursive or init/update submodules using the commands above. Recap I think I can summarize submodules pretty simply. It‚Äôs possible to embed a repo within another repo. This is called a submodule. Each commit of the outer repo always specifies an exact commit that submodule. This is done by the outer commit -\u003e tree -\u003e submodule commit link. When you check out commits, git doesn‚Äôt automatically update submodules for you. You have to do that using git submodule update. And there we have it! Further topics in submodules The above is enough to hopefully take the confusion out of submodules. However, there are more common commands and configs that I‚Äôd like to explain. How to add a submodule: git submodule add Let‚Äôs say that I start webapp fresh, and I have not added library to it yet. To add library, I‚Äôd do git submodule add https://github.com/dmazin/library.git library. This will add (or update) the .gitmodules file of webapp, download library, and point webapp at the latest commit of library. Remember, this actually modifies webapp, so you need to commit after that. But you thankfully don‚Äôt need to do git submodule update after doing git submodule add or anything. What do I do after I‚Äôve modified a submodule? Remember that library is a full repo, so if you want to make changes to it, you can. Just make changes and commit them to the main branch. But how do you make webapp point at the new commit? There are a couple ways. Without a command You can go into webapp, then cd library, and just do git pull in there. When you cd back into webapp, if you git diff you‚Äôll see that webapp points to the newest branch of library. You can commit that. Using git submodule update --remote -- library This tells git ‚Äúmake the submodule point to the latest remote commit‚Äù. Since you have pushed the latest commit of library to library‚Äôs remote, this will make webapp point to that commit. But note that git submodule update --remote will do this to all your submodules. You likely do not want that. For that reason, you have to do git submodule update --remote -- library to limit this to library only. (If you‚Äôre thrown off by the fact that you have to do -- library ‚Äì yeah, it‚Äôs kind of weird.) Because --remote might accidentally update all the submodules, honestly I usually do the ‚Äúwithout a command‚Äù method. The .gitmodules file How does git know where to download library from? git uses a file called .gitmodules to track the basic facts of a submodule, like the repo URL. $ [/webapp] cat .gitmodules [submodule \"library\"] path = library url = https://github.com/dmazin/library.git The nice thing about .gitmodules is that it‚Äôs a regular file, tracked the regular way in git. That makes it not confusing. (What I don‚Äôt understand is, why git didn‚Äôt just put the submodule commit right in .gitmodules? The commits of webapp would still be able to specify exact commits of library to use. What am I missing?) Making submodules use branches other than main If you want to, you can make library track whatever branch you want. Otherwise, it defaults to whatever the ‚Äúmain‚Äù branch is. [submodule \"library\"] path = library url = https://github.com/dmazin/library.git branch = staging Thanks for reading!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThroughout my career, I have found git submodules to be a pain. Because I did not understand them, I kept getting myself into frustrating situations.\u003c/p\u003e\n\n\u003cp\u003eSo, I finally sat down and learned how git tracks submodules. Turns out, it‚Äôs not complex at all. It‚Äôs just different from how git tracks regular files. It‚Äôs just one more thing you have to learn.\u003c/p\u003e\n\n\u003cp\u003eIn this article, I‚Äôll explain exactly what I needed to know in order to work with submodules without inflicting self-damage.\u003c/p\u003e\n\n\u003cp\u003e(This article doesn‚Äôt discuss whether submodules are good/bad, or if you should use them or not ‚Äì a valid discussion, but out of scope.)\u003c/p\u003e\n\n\u003ch2 id=\"the-lay-of-the-land\"\u003eThe lay of the land\u003c/h2\u003e\n\u003cp\u003eThis article will make more sense if we use concrete examples.\u003c/p\u003e\n\n\u003cp\u003eAllow me to describe a toy webapp we‚Äôre building. Call this repo \u003ccode\u003ewebapp\u003c/code\u003e. Here are the contents of the repo.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] ls\n\n.git/\nREADME.md\ntests/\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eSay you want to import some library. It lives in its own repo, \u003ccode\u003elibrary\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/library] ls\n\n.git/\nREADME.md\nmy_cool_functions.py\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eShortly, I‚Äôll explain how submodules work. But, first, let me dramatically re-enact something that has happened to me multiple times. This is what it looks like to use submodules without understanding them.\u003c/p\u003e\n\n\u003ch2 id=\"a-day-in-the-life-of-someone-who-doesnt-understand-submodules\"\u003eA day in the life of someone who doesn‚Äôt understand submodules\u003c/h2\u003e\n\u003cp\u003eAh, 2012. What a time to be a ‚Äúfull-stack engineer‚Äù! I wonder what contributions await me on the main branch!\u003c/p\u003e\n\n\u003cp\u003e(For the sake of readability, in this article, instead of using real commit SHAs, I‚Äôm going to use fake descriptive ones.)\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs pull to make sure I‚Äôm up-to-date with the remote.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e$ \u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e/webapp] git pull\n\nremote: Enumerating objects: 3, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Counting objects: 100% \u003cspan\u003e(\u003c/span\u003e3/3\u003cspan\u003e)\u003c/span\u003e, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Compressing objects: 100% \u003cspan\u003e(\u003c/span\u003e1/1\u003cspan\u003e)\u003c/span\u003e, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nremote: Total 2 \u003cspan\u003e(\u003c/span\u003edelta 1\u003cspan\u003e)\u003c/span\u003e, reused 2 \u003cspan\u003e(\u003c/span\u003edelta 1\u003cspan\u003e)\u003c/span\u003e, pack-reused 0\nUnpacking objects: 100% \u003cspan\u003e(\u003c/span\u003e2/2\u003cspan\u003e)\u003c/span\u003e, 237 bytes | 118.00 KiB/s, \u003cspan\u003edone\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\nFrom https://github.com/dmazin/webapp\n   webapp_old_commit_sha..webapp_new_commit_sha  main -\u0026gt; origin/main\nUpdating webapp_old_commit_sha..webapp_new_commit_sha\nFast-forward\n library | 2 +-\n 1 file changed, 1 insertion\u003cspan\u003e(\u003c/span\u003e+\u003cspan\u003e)\u003c/span\u003e, 1 deletion\u003cspan\u003e(\u003c/span\u003e-\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eAfter I pull, I like to confirm that my working tree is clean.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n M library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhat‚Äôs this? I‚Äôve made modifications to \u003ccode\u003elibrary\u003c/code\u003e? I never touch that directory.\u003c/p\u003e\n\n\u003cp\u003eIt‚Äôs weird that I‚Äôve modified a \u003cem\u003edirectory\u003c/em\u003e. Usually git just says I‚Äôve modified a specific \u003cem\u003efile\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eWell, what does \u003ccode\u003egit diff\u003c/code\u003e have to say?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git diff\n\ndiff --git a/library b/library\nindex library_old_commit_sha..library_new_commit_sha 160000\n--- a/library\n+++ b/library\n@@ -1 +1 @@\n-Subproject commit library_new_commit_sha\n+Subproject commit library_old_commit_sha\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eApparently, I deleted \u003ccode\u003eSubproject commit library_new_commit_sha\u003c/code\u003e and added \u003ccode\u003eSubproject commit library_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSurely I didn‚Äôt do that. That‚Äôs weird, let me do a hard reset.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git reset --hard origin/main\n\nHEAD is now at webapp_new_commit_sha point submodule to newest commit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eDid it make the git diff go away?\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n M library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt did not! I am really confused now!\u003c/p\u003e\n\n\u003cp\u003eWell, the usual way I make local modifications go away is \u003ccode\u003egit reset --hard\u003c/code\u003e, and that didn‚Äôt work. The other way is to commit the changes.\u003c/p\u003e\n\n\u003cp\u003e(Sometimes, people don‚Äôt even notice the diff above, and accidentally do this.)\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eMy future self\u003c/strong\u003e: \u003cem\u003eDon‚Äôt do it! If you \u003ccode\u003egit add\u003c/code\u003e that change, you‚Äôll be rolling back a change someone else made!\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eWhat‚Äôs going on, of course, is that \u003ccode\u003elibrary\u003c/code\u003e is a submodule, and you have to do special stuff to deal with them.\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs dive into submodules.\u003c/p\u003e\n\n\u003ch2 id=\"whats-a-submodule\"\u003eWhat‚Äôs a submodule?\u003c/h2\u003e\n\u003cp\u003eA git submodule is a full repo that‚Äôs been nested inside another repo. Any repo can be a submodule of another.\u003c/p\u003e\n\n\u003cp\u003eSo, \u003ccode\u003elibrary\u003c/code\u003e is a full repo that has been nested inside \u003ccode\u003ewebapp\u003c/code\u003e as a submodule.\u003c/p\u003e\n\n\u003cp\u003eThat doesn‚Äôt seem so confusing, does it? However, there are two important, and tricky, facts about submodules. These facts are why so many people trip up on submodules.\u003c/p\u003e\n\n\u003ch3 id=\"1-a-submodule-is-always-pinned-to-a-specific-commit\"\u003e1. A submodule is always pinned to a specific commit\u003c/h3\u003e\n\u003cp\u003eYou know how package managers let you be  fuzzy when specifying a package version (‚Äúget me any version of \u003ccode\u003erequests\u003c/code\u003e so long as it‚Äôs 2.x.x‚Äù), or to pin an exact version (‚Äúuse \u003ccode\u003erequests\u003c/code\u003e 2.31.0 exactly‚Äù)?\u003c/p\u003e\n\n\u003cp\u003eSubmodules can \u003cem\u003eonly\u003c/em\u003e be pinned to a specific commit. This is because a submodule isn‚Äôt a package; it‚Äôs code that you have embedded in another repo, and git wants you to be precise.\u003c/p\u003e\n\n\u003cp\u003eWe‚Äôll see exactly how this pinning works shortly.\u003c/p\u003e\n\n\u003ch3 id=\"2-git-does-not-automatically-download-or-update-submodules\"\u003e2. git does not automatically download or update submodules\u003c/h3\u003e\n\u003cp\u003eIf you clone \u003ccode\u003ewebapp\u003c/code\u003e afresh, git \u003cem\u003ewill not\u003c/em\u003e automatically download \u003ccode\u003elibrary\u003c/code\u003e for you (unless you clone using \u003ccode\u003egit clone --recursive\u003c/code\u003e)\u003c/p\u003e\n\n\u003cp\u003eSimilarly, if a collaborator pins \u003ccode\u003ewebapp\u003c/code\u003e to a new commit of \u003ccode\u003elibrary\u003c/code\u003e, and you \u003ccode\u003egit pull\u003c/code\u003e \u003ccode\u003ewebapp\u003c/code\u003e, git \u003cem\u003ewill not\u003c/em\u003e automatically update \u003ccode\u003elibrary\u003c/code\u003e for you.\u003c/p\u003e\n\n\u003cp\u003eThis is actually what‚Äôs happening in the dramatic re-enactment above. Let me rewind a little bit to show what happened.\u003c/p\u003e\n\n\u003ch2 id=\"what-happens-when-someone-updates-a-submodule\"\u003eWhat happens when someone updates a submodule?\u003c/h2\u003e\n\u003cp\u003eIn the beginning, \u003ccode\u003ewebapp\u003c/code\u003e pointed to \u003ccode\u003ewebapp_old_commit_sha\u003c/code\u003e, which pinned \u003ccode\u003elibrary\u003c/code\u003e to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules1.png\" alt=\"Hand-drawn diagram of two git repositories, webapp and library. It shows that the old_sha commit of the webapp repo points to the old_sha commit of the library repo. The old_sha commit of the webapp repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. The old_sha commit of the library repo also has a purple border around it, saying \u0026#39;HEAD\u0026#39;.\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e(Think of \u003ccode\u003eHEAD\u003c/code\u003e as ‚Äúcurrent commit‚Äù.)\u003c/p\u003e\n\n\u003cp\u003eThen, my collaborator made changes to \u003ccode\u003elibrary\u003c/code\u003e. Remember, \u003ccode\u003elibrary\u003c/code\u003e is a full repo, so after they did their work, they did what you always do after you make changes: they committed and pushed the new commit, \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThey weren‚Äôt done, though. \u003ccode\u003ewebapp\u003c/code\u003e must point to a specific commit of \u003ccode\u003elibrary\u003c/code\u003e, so in order to use \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, my collaborator then pushed a new commit to \u003ccode\u003ewebpapp\u003c/code\u003e, \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e, which points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere‚Äôs the thing, though! \u003cem\u003egit does not automatically update submodules\u003c/em\u003e, so \u003ccode\u003elibrary\u003c/code\u003e still points to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules2.png\" alt=\"Hand-drawn diagram of two git repositories, webapp and library. It shows that the old_sha commit of the webapp repo points to the old_sha commit of the library repo. The new_sha commit of the webapp repo points to the new_sha of the library repo. The new_sha commit of the webapp repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. The old_sha commit of the library repo has a purple border around it, saying \u0026#39;HEAD\u0026#39;. A red arrow points to the purple border around old_sha in the library repo. The red arrow is linked to a speech bubble which says, \u0026#39;library still points at old_sha!\u0026#39;\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eI think this will be a lot less confusing if we look at exactly how git tracks submodules.\u003c/p\u003e\n\n\u003ch2 id=\"commercial-interruption\"\u003eCommercial interruption\u003c/h2\u003e\n\u003cp\u003eIf you‚Äôre enjoying yourself, may I ask if you‚Äôd like to follow me via \u003ca href=\"https://www.cyberdemon.org/feed.xml\"\u003eRSS feed\u003c/a\u003e, \u003ca href=\"https://file-explorers.club/@dmitry\"\u003eMastodon\u003c/a\u003e, or \u003ca href=\"https://t.me/cyberdemon6\"\u003eTelegram channel\u003c/a\u003e? Thanks!\u003c/p\u003e\n\n\u003ch2 id=\"how-git-tracks-submodules\"\u003eHow git tracks submodules\u003c/h2\u003e\n\u003ch3 id=\"how-does-git-pin-a-submodule-to-a-specific-commit\"\u003eHow does git pin a submodule to a specific commit?\u003c/h3\u003e\n\u003cp\u003eThe latest commit of \u003ccode\u003ewebapp\u003c/code\u003e is \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e. Let‚Äôs inspect that commit.\u003c/p\u003e\n\n\u003cp\u003eA commit is just a file on disk. However, it‚Äôs optimized/compressed, so we use a built-in utility to view it. Here‚Äôs what the commit stores.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git cat-file -p `webapp_new_commit_sha`\n\ntree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\nparent webapp_old_commit_sha\nauthor Dmitry Mazin \u0026lt;dm@cyberdemon.org\u0026gt; 1708717288 +0000\ncommitter Dmitry Mazin \u0026lt;dm@cyberdemon.org\u0026gt; 1708717288 +0000\n\npoint submodule to newest commit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eWhat we care about is \u003ccode\u003etree 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\u003c/code\u003e. The \u003cem\u003etree\u003c/em\u003e object represents the directory listing of your repo. When you think trees, think directories.\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs inspect the tree object.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git cat-file -p 92018fc6ac6e71ea3dfb57e2fab9d3fe23b6fdf4\n\n100644 blob     6feaf03c7a9c805ff734a90a245a417e6a6c099b    .gitmodules\n100644 blob     a72832b303c4d4f1833da79fc8a566e8a0eb37af    README.md\n040000 tree     a425c23ded8892f901dee7fbc8d4c5714bdcc40d    tests\n160000 commit   library_new_commit_sha                      library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eNote how \u003ccode\u003etests\u003c/code\u003e is a \u003ccode\u003etree\u003c/code\u003e (just like directories can hold directories, trees can point to trees).\u003c/p\u003e\n\n\u003cp\u003eBut \u003ccode\u003elibrary\u003c/code\u003e is a‚Ä¶ commit?!\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e160000 commit   library_new_commit_sha                      library\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThat weirdness, right there, is precisely how git knows \u003ccode\u003elibrary\u003c/code\u003e points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn other words, the way git implements submodules is by doing a weird trick where a tree points to a \u003cem\u003ecommit\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://www.cyberdemon.org/assets/submodules3.png\" alt=\"Hand-drawn diagram showing the text \u0026#39;webapp_new_commit_sha\u0026#39; connected, via arrow, to \u0026#39;tree a425\u0026#39; which is itself connected, via arrow, to \u0026#39;library_new_commit_sha\u0026#39;\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eLet‚Äôs use this knowledge to understand the \u003ccode\u003egit diff\u003c/code\u003e from earlier.\u003c/p\u003e\n\n\u003ch2 id=\"understanding-git-diff\"\u003eUnderstanding git diff\u003c/h2\u003e\n\u003cp\u003eHere‚Äôs the diff again.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git diff\n\ndiff --git a/library b/library\nindex library_old_commit_sha..library_new_commit_sha 160000\n--- a/library\n+++ b/library\n@@ -1 +1 @@\n-Subproject commit library_new_commit_sha\n+Subproject commit library_old_commit_sha\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIt‚Äôs confusing that it‚Äôs saying that \u003cstrong\u003eI\u003c/strong\u003e modified \u003ccode\u003elibrary\u003c/code\u003e. I didn‚Äôt modify it, someone else did!\u003c/p\u003e\n\n\u003cp\u003eUsually, I think of \u003ccode\u003egit diff\u003c/code\u003e as ‚Äúhere are the changes I have made‚Äù. But this isn‚Äôt exactly correct.\u003c/p\u003e\n\n\u003cp\u003eWhen you invoke \u003ccode\u003egit diff\u003c/code\u003e, you‚Äôre asking git to tell you the difference between your working tree (that is, your unstaged, uncommitted local changes) and the most recent commit of your branch (\u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eWhen you look at it that way, the above git diff starts to make sense. In \u003ccode\u003ewebapp_new_commit_sha\u003c/code\u003e, \u003ccode\u003elibrary\u003c/code\u003e points to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, but in our working tree, \u003ccode\u003elibrary\u003c/code\u003e still points to \u003ccode\u003elibrary_old_commit_sha\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003egit has no idea which change happened first. It only knows that your working tree is different from the commit. And, so it tells you: \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e is saying that library should point to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e, but it doesn‚Äôt.\u003c/p\u003e\n\n\u003cp\u003eUnderstanding the above took the pain out of submodules for me. However, I still haven‚Äôt told you how to update a submodule.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-update-a-submodule\"\u003eHow to update a submodule\u003c/h2\u003e\n\u003cp\u003eWe now understand that we need to point \u003ccode\u003elibrary\u003c/code\u003e to \u003ccode\u003elibrary_new_commit_sha\u003c/code\u003e. How?\u003c/p\u003e\n\n\u003cp\u003eBecause \u003ccode\u003elibrary\u003c/code\u003e is a full repo, I could just \u003ccode\u003ecd\u003c/code\u003e into it and literally check out that commit:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] cd library\n\n$ [/library] git checkout library_new_commit_sha\n\nPrevious HEAD position was library_old_commit_sha README\nHEAD is now at library_new_commit_sha add some cool functions\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eIf we go back into \u003ccode\u003ewebapp\u003c/code\u003e, we‚Äôll see that \u003ccode\u003egit st\u003c/code\u003e/\u003ccode\u003egit diff\u003c/code\u003e finally look clean.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] git st\n\n## main...origin/main\n# (no output)\n\n$ [/webapp] git diff\n\n# (no output)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eHowever, you don‚Äôt actually need to do the above.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-really-update-a-submodule\"\u003eHow to really update a submodule\u003c/h2\u003e\n\u003cp\u003eFrom \u003ccode\u003ewebapp\u003c/code\u003e, we can invoke \u003ccode\u003egit submodule update\u003c/code\u003e. This updates \u003cem\u003eall\u003c/em\u003e of a repo‚Äôs submodules.\u003c/p\u003e\n\n\u003cp\u003ePeople often use certain flags with \u003ccode\u003egit submodule update\u003c/code\u003e, so let‚Äôs understand them.\u003c/p\u003e\n\n\u003ch3 id=\"initialize-a-submodule-git-submodule-update---init\"\u003eInitialize a submodule: \u003ccode\u003egit submodule update --init\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eRemember how I said that if you \u003ccode\u003egit clone webapp\u003c/code\u003e, git won‚Äôt actually download the contents of \u003ccode\u003elibrary\u003c/code\u003e?\u003c/p\u003e\n\n\u003cp\u003eWhat you‚Äôre supposed to do is, after cloning webapp:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eRun \u003ccode\u003egit submodule init\u003c/code\u003e to initialize the submodules. This doesn‚Äôt actually download them, though üôÉÔ∏è.\u003c/li\u003e\n  \u003cli\u003eRun \u003ccode\u003egit submodule update\u003c/code\u003e to actually pull the submodules.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThis is kind of a silly dance, so git lets you just do \u003ccode\u003egit submodule update --init\u003c/code\u003e. This initializes any submodules and updates them in one step. I \u003cem\u003ealways\u003c/em\u003e pass \u003ccode\u003e--init\u003c/code\u003e because there is no harm in doing so.\u003c/p\u003e\n\n\u003cp\u003eYou can skip \u003ccode\u003e--init\u003c/code\u003e by cloning with \u003ccode\u003e--recursive\u003c/code\u003e: that is, you could have done \u003ccode\u003egit clone webapp --recursive\u003c/code\u003e. I never remember to do this, though. Plus, you end up having to do \u003ccode\u003egit update submodule\u003c/code\u003e anyway.\u003c/p\u003e\n\n\u003ch3 id=\"update-submodules-of-submodules-git-submodule-update---recursive\"\u003eUpdate submodules of submodules: \u003ccode\u003egit submodule update --recursive\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eSubmodules can nest other submodules. Yeah.\u003c/p\u003e\n\n\u003cp\u003eSo, to take care of updating submodules \u003cem\u003eall the way down\u003c/em\u003e, pretty much just always pass \u003ccode\u003e--recursive\u003c/code\u003e to \u003ccode\u003egit submodule update\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSo, the command I always end up using is \u003ccode\u003egit submodule update --init --recursive\u003c/code\u003e.\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch3 id=\"make-git-automatically-update-submodules-git-config-submodulerecurse-true\"\u003eMake git automatically update submodules: \u003ccode\u003egit config submodule.recurse true\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003esubmodule.recurse true\u003c/code\u003e makes submodules automatically update when you \u003ccode\u003egit pull\u003c/code\u003e, \u003ccode\u003egit checkout\u003c/code\u003e, etc. In other words, it makes submodules automatically point to whatever they are supposed to point to. It‚Äôs only available in git 2.14 and newer.\u003c/p\u003e\n\n\u003cp\u003eThat makes running \u003ccode\u003egit submodule update\u003c/code\u003e unnecessary.\u003c/p\u003e\n\n\u003cp\u003eI don‚Äôt use this setting, because I‚Äôm not sure if there are drawbacks or not. Plus, I work on submodules enough that I think it could cause conflicts. Let me know if you‚Äôre aware of shortcomings, or if you‚Äôve been using this setting forever without issue!\u003c/p\u003e\n\n\u003cp\u003eThis setting definitely does \u003cem\u003enot\u003c/em\u003e apply to \u003ccode\u003egit clone\u003c/code\u003e. So you still need to do \u003ccode\u003egit clone --recursive\u003c/code\u003e or init/update submodules using the commands above.\u003c/p\u003e\n\n\u003ch2 id=\"recap\"\u003eRecap\u003c/h2\u003e\n\u003cp\u003eI think I can summarize submodules pretty simply.\u003c/p\u003e\n\n\u003cp\u003eIt‚Äôs possible to embed a repo within another repo. This is called a submodule.\u003c/p\u003e\n\n\u003cp\u003eEach commit of the outer repo always specifies an \u003cem\u003eexact\u003c/em\u003e commit that submodule. This is done by the \u003ccode\u003eouter commit -\u0026gt; tree -\u0026gt; submodule commit\u003c/code\u003e link.\u003c/p\u003e\n\n\u003cp\u003eWhen you check out commits, git doesn‚Äôt automatically update submodules for you. You have to do that using \u003ccode\u003egit submodule update\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAnd there we have it!\u003c/p\u003e\n\n\u003ch2 id=\"further-topics-in-submodules\"\u003eFurther topics in submodules\u003c/h2\u003e\n\u003cp\u003eThe above is enough to hopefully take the confusion out of submodules. However, there are more common commands and configs that I‚Äôd like to explain.\u003c/p\u003e\n\n\u003ch3 id=\"how-to-add-a-submodule-git-submodule-add\"\u003eHow to add a submodule: \u003ccode\u003egit submodule add\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eLet‚Äôs say that I start \u003ccode\u003ewebapp\u003c/code\u003e fresh, and I have not added \u003ccode\u003elibrary\u003c/code\u003e to it yet.\u003c/p\u003e\n\n\u003cp\u003eTo add \u003ccode\u003elibrary\u003c/code\u003e, I‚Äôd do \u003ccode\u003egit submodule add https://github.com/dmazin/library.git library\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis will add (or update) the \u003ccode\u003e.gitmodules\u003c/code\u003e file of \u003ccode\u003ewebapp\u003c/code\u003e, download \u003ccode\u003elibrary\u003c/code\u003e, and point \u003ccode\u003ewebapp\u003c/code\u003e at the latest commit of \u003ccode\u003elibrary\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eRemember, this actually modifies \u003ccode\u003ewebapp\u003c/code\u003e, so you need to commit after that. But you thankfully don‚Äôt need to do \u003ccode\u003egit submodule update\u003c/code\u003e after doing \u003ccode\u003egit submodule add\u003c/code\u003e or anything.\u003c/p\u003e\n\n\u003ch3 id=\"what-do-i-do-after-ive-modified-a-submodule\"\u003eWhat do I do after I‚Äôve modified a submodule?\u003c/h3\u003e\n\u003cp\u003eRemember that \u003ccode\u003elibrary\u003c/code\u003e is a full repo, so if you want to make changes to it, you can. Just make changes and commit them to the main branch.\u003c/p\u003e\n\n\u003cp\u003eBut how do you make \u003ccode\u003ewebapp\u003c/code\u003e point at the new commit? There are a couple ways.\u003c/p\u003e\n\n\u003ch4 id=\"without-a-command\"\u003eWithout a command\u003c/h4\u003e\n\u003cp\u003eYou can go into \u003ccode\u003ewebapp\u003c/code\u003e, then \u003ccode\u003ecd library\u003c/code\u003e, and just do \u003ccode\u003egit pull\u003c/code\u003e in there. When you \u003ccode\u003ecd\u003c/code\u003e back into \u003ccode\u003ewebapp\u003c/code\u003e, if you \u003ccode\u003egit diff\u003c/code\u003e you‚Äôll see that \u003ccode\u003ewebapp\u003c/code\u003e points to the newest branch of \u003ccode\u003elibrary\u003c/code\u003e. You can commit that.\u003c/p\u003e\n\n\u003ch4 id=\"using-git-submodule-update---remote----library\"\u003eUsing \u003ccode\u003egit submodule update --remote -- library\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eThis tells git ‚Äúmake the submodule point to the latest remote commit‚Äù. Since you have pushed the latest commit of library to library‚Äôs remote, this will make \u003ccode\u003ewebapp\u003c/code\u003e point to that commit.\u003c/p\u003e\n\n\u003cp\u003eBut note that \u003ccode\u003egit submodule update --remote\u003c/code\u003e will do this to \u003cem\u003eall\u003c/em\u003e your submodules. You likely do not want that.\u003c/p\u003e\n\n\u003cp\u003eFor that reason, you have to do \u003ccode\u003egit submodule update --remote -- library\u003c/code\u003e to limit this to library only. (If you‚Äôre thrown off by the fact that you have to do \u003ccode\u003e-- library\u003c/code\u003e ‚Äì yeah, it‚Äôs kind of weird.)\u003c/p\u003e\n\n\u003cp\u003eBecause \u003ccode\u003e--remote\u003c/code\u003e might accidentally update all the submodules, honestly I usually do the ‚Äúwithout a command‚Äù method.\u003c/p\u003e\n\n\u003ch3 id=\"the-gitmodules-file\"\u003eThe .gitmodules file\u003c/h3\u003e\n\u003cp\u003eHow does git know where to download \u003ccode\u003elibrary\u003c/code\u003e from?\ngit uses a file called \u003ccode\u003e.gitmodules\u003c/code\u003e to track the basic facts of a submodule, like the repo URL.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e$ [/webapp] cat .gitmodules\n\n[submodule \u0026#34;library\u0026#34;]\n        path = library\n        url = https://github.com/dmazin/library.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe nice thing about \u003ccode\u003e.gitmodules\u003c/code\u003e is that it‚Äôs a regular file, tracked the regular way in git. That makes it not confusing.\u003c/p\u003e\n\n\u003cp\u003e(What I don‚Äôt understand is, why git didn‚Äôt just put the submodule commit right in .gitmodules? The commits of \u003ccode\u003ewebapp\u003c/code\u003e would \u003cem\u003estill\u003c/em\u003e be able to specify exact commits of \u003ccode\u003elibrary\u003c/code\u003e to use. What am I missing?)\u003c/p\u003e\n\n\u003ch3 id=\"making-submodules-use-branches-other-than-main\"\u003eMaking submodules use branches other than main\u003c/h3\u003e\n\u003cp\u003eIf you want to, you can make \u003ccode\u003elibrary\u003c/code\u003e track whatever branch you want. Otherwise, it defaults to whatever the ‚Äúmain‚Äù branch is.\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e[submodule \u0026#34;library\u0026#34;]\n        path = library\n        url = https://github.com/dmazin/library.git\n        branch = staging\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThanks for reading!\u003c/p\u003e\n\n    \n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
