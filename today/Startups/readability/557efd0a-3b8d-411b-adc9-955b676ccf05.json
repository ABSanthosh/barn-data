{
  "id": "557efd0a-3b8d-411b-adc9-955b676ccf05",
  "title": "Designing a Fast Concurrent Hash Table",
  "link": "https://ibraheem.ca/posts/designing-papaya/",
  "description": "Article URL: https://ibraheem.ca/posts/designing-papaya/ Comments URL: https://news.ycombinator.com/item?id=41798475 Points: 96 # Comments: 16",
  "author": "burntsushi",
  "published": "Thu, 10 Oct 2024 13:15:28 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Ibraheem Ahmed",
  "length": 20633,
  "excerpt": "I recently released papaya, a fast and feature-complete concurrent hash table for Rust. In this post I want to dive into the design and research that went into creating it, as well as why you might consider using it over existing solutions.",
  "siteName": "Ibraheem Ahmed",
  "favicon": "https://ibraheem.ca/logo.png",
  "text": "I recently released papaya, a fast and feature-complete concurrent hash table for Rust. In this post I want to dive into the design and research that went into creating it, as well as why you might consider using it over existing solutions. If you're looking for an overview of papaya, you might find it more useful to consult the documentation. Philosophy Concurrent hash tables are a well explored topic, both in academic literature and open-source implementations. In some ways, they are the holy grail of concurrent data structures. On the other hand, a concurrent hash table is an inelegant blob of shared mutable data, often a marker of a poorly architectured program. Hash tables in general have many unfortunate properties, most of which are exacerbated in a concurrent context. However, despite their downsides, hash tables can be a necessary evil, especially for read-heavy use cases where alternative data structures are not competitive in terms of performance. There are a few important properties that a concurrent hash table cares about: Read throughput/latency Write throughput/latency Memory usage Concurrent hash tables fall into a large spectrum depending on which of the above properties are prioritized. papaya cares a lot more about readers than writers. Reads should be extremely low latency and never blocked by a slow writer. However, it also cares a lot about predictable latency in general. While write throughput may not be exceptional, neither readers nor writers should ever suffer from latency spikes. In general, use cases that care about write throughput are likely better served by alternative data structures such as hash tries, which deserve more experimentation. papaya aims to instead serve read-heavy workloads. Another huge consideration was to have an easy to use API. While papaya may use locks internally, with careful consideration, the API is lock-free and impossible to deadlock. Basic Design Consider a basic RwLock\u003cHashMap\u003cK, V\u003e\u003e. There are a few glaring issues with this, the primary one being that every write operation takes exclusive access of the hash map. Not only is this very expensive to synchronize, it also means that readers cannot proceed in the face of even a single writer. However, even in a read-heavy or read-only workload, a RwLock is far from ideal. With a reader-writer lock, readers can execute in parallel. However, the lock is still a single-point of contention, even for readers. This means that every read operation will attempt to take exclusive access of the lock state to acquire the lock, resulting in an exorbitant amount of cache-coherency traffic and bringing scalability to a halt. This makes using reader-writer locks impractical for any scalable data-structure. There is a small improvement we can make to greatly improve scalability: sharding. Instead of forcing every core to acquire the same lock, we can shard keys across multiple maps with a Box\u003c[RwLock\u003cHashMap\u003cK, V\u003e\u003e]\u003e, deciding which keys go into which map based on their hash. Now, with a sufficient number of shards, the contention is distributed across multiple locks. This is the strategy dashmap uses. Sharding reduces contention, but it's far from ideal. Readers are still required to modify shared memory. That memory is less shared, but it's still shared, and writes to shared memory are expensive. Additionally, write operations still block readers, meaning even a small number of writers can greatly affect overall scalability. Locks in general pose a significant problem for read latency distributions in that a single slow writer can result in latency spikes for all readers. So how do we do better? The simplest lock-free hash table looks something like this: struct HashMap\u003cK, V\u003e { buckets: AtomicPtr\u003c[AtomicPtr\u003cNode\u003cK, V\u003e\u003e]\u003e } struct Node\u003cK, V\u003e { key: K, value: V, next: AtomicPtr\u003cNode\u003cK, V\u003e\u003e, } There's a couple important layers here. The entire table is wrapped around an atomic pointer, allowing it to be atomically swapped out during a resize. Additionally, every key-value pair is behind an atomic pointer, with collisions forming a concurrent linked-list. The use of atomic pointers is important. Most CPUs only support reading values up to 128-bits atomically, without tearing 1. To support keys and values of arbitrary size, entries need to be allocated. This allows us to swap the pointer atomically. Note that allocating every entry is a large fundamental design decision. It means sacrificing write throughput under heavy write load due to allocator pressure. However, this tradeoff is worth it, as it allows readers to access the table concurrently with writers. This is the design taken by C#'s ConcurrentDictionary. However, it introduces another crucial issue. Now that every key-value pair is allocated, readers have to go through a pointer to access the key while iterating over the linked-list, implying a cache-miss. The cost of a cache-miss is even more severe in a concurrent setting as entries are being modified by writers, resulting in contention. We want to access as little shared memory as possible. Cache locality is also the reason most modern hash tables opt for open addressing over closed chaining. With open addressing, each bucket contains a single key-value pair. Instead of using a linked-list to resolve collisions, writers probe subsequent buckets until an empty one is found. When readers encounter an empty bucket in the sequence, they can stop probing knowing the key is not in the map. This allows the entire table to be represent by a flat [(K, V)], making access extremely cache-friendly. At first glance, open addressing in a concurrent settings doesn't seem to provide much benefit, because entries are allocated anyways. struct HashMap\u003cK, V\u003e { buckets: AtomicPtr\u003c[AtomicPtr\u003c(K, V)\u003e]\u003e } However, it opens the door for a crucial optimization. Along with the entries array, we can include a second array known as a metadata table. Each key-value pair has a corresponding byte of metadata containing a subset of its hash. struct HashMap\u003cK, V\u003e { table: AtomicPtr\u003cTable\u003cK, V\u003e\u003e } struct Table\u003cK, V\u003e { metadata: [AtomicU8], entries: [AtomicPtr\u003c(K, V)\u003e], } A metadata table allows reads to be extremely cache-efficient as they can probe the metadata instead of the entries. Note that because we only have 8 bits of metadata, there are still chances of false positives, but it's still a massive improvement. Metadata tables are present in most modern hash tables, including swiss tables, the basis of std::collections::HashMap. They are even more crucial in a concurrent hash table as entries are allocated, making probing through entries directly impractical. Probing Strategy One of the biggest decisions to make with an open addressing table is the probing strategy. The probing strategy decides the order in which buckets are probed if the initial bucket is full. While there are many interesting strategies such as cuckoo, robin-hood, or hopscotch hashing, these are expensive to implementing concurrently requiring extra synchronization, especially with a metadata table. On the other hand, the existence of a metadata table means that probing becomes relatively cheap, and so a simpler probing strategy makes more sense. For example, hashbrown uses a hybrid linear and quadratic probing strategy. Groups of 16 metadata entries are probed in parallel using a SIMD routine, while group-wise probing is quadratic. This allows for cache-efficient probing while avoiding primary clustering, a common pitfall of linear probing. Unfortunately, there is an issue with SIMD probing in a concurrent hash table — atomic loads must be aligned. This means we can't simply load the next 16 entries from the probing position, we have to load aligned groups. Unfortunately, it turns out that SIMD probing is not worth it when this alignment is required in my testing. In fact, swiss tables saw a 20% performance improvement when switching to unaligned reads due to increased entropy from the hash bits. For this reason, papaya sticks to a traditional quadratic probing strategy, as well as a power-of-two capacity for the typical fast modulo. Load Factor There is another important part of a hash table, its load factor. The load factor determines when the hash table is too full and should resize. Determining whether the load factor has been reached requires keep track of the number of entries in the hash table. However, maintaining a counter is very expensive in a concurrent setting as it forms another singular point of contention! While the counter is only accessed by writers, it still affects performance quite severely. There are a couple of ways to work around this problem. The most obvious is to shard the length counter. While this reduces the contention when incrementing the counter, it makes accessing the total length even more expensive. papaya uses a sharded counter and exposes the length for convenience, but accessing all counter shards on every write is infeasible. One solution is to rely instead of a probabilistic counter for resizing, similar to HyperLogLog. However, papaya takes a different approach, inspired by this article. Instead of setting a load factor, the hash table sets a maximum probe limit based on the capacity of the table. Once the limit is reached, the table is resized. The probe limit is based on log2 of the table's capacity, which tends to a ~80% load factor. I'd be interested in a formalization of probe limits and their relationship to load factor, but this number seems to work very consistently in practice, and avoids the need to synchronize a concurrent counter. Deletion In open addressing, you can't simply unlink a value from the linked-list chain to delete it. Instead, you typically put down a marker value known as a tombstone. There are more complex deletion schemes such as backshift deletion, but these are difficult to implement concurrently without introducing extra synchronization. Tombstones are a bit unfortunate as they result in longer probe sequences. However, if an insert encounters a tombstone in its probe sequence, the entry can be reused for the new key. This somewhat mitigates the issue. However, concurrent deletions pose a problem with a metadata table. Imagine the following sequence of events: Thread 1 inserts key \"a\" Thread 2 deletes key \"a\" Thread 2 inserts key \"b\" in the same slot Thread 2 writes metadata 0b01 Thread 1 writes metadata 0b10 late Synchronizing the entry and its metadata are in separate locations, making them difficult to synchronize when slots are reused. One solution is to store a lock for each entry that is taken when storing an entry and its metadata. This ensures synchronization but is a significant slowdown for writers. However, there is another option. Instead of using a lock, we can eliminate the problem entirely by not allowing entries to be reused after being deleted. This means that there is only one metadata value written to a given slot, so we don't have to worry about synchronization. This approach is taken by Cliff Click's famous lock-free hash table, although it uses it to synchronize keys and values instead of metadata. However, it is a pretty significant tradeoff, as it means workloads that insert and delete a lot of keys have to resize much more often to free up entries. We'll talk more about resizing later. Memory Reclamation We've been overlooking a large problem up till now, memory reclamation. Concurrent deletion becomes a lot more difficult in a lock-free environment. In particular, there is no obvious way of telling when it is safe to free an object, as arbitrary readers may be concurrently accessing it. The obvious solution to this problem is some form of reference counting. Unfortunately, reference counting is similar in cost to a reader-writer lock in that every access requires modifying shared memory. In particular, this is disastrous for synchronizing access to the table itself as it creates a single point of contention for all operations. There are many algorithms to solve this problem. One popular scheme is hazard pointers, which forces threads to announce access to a given object through a thread-local list of pointers. While this can be very memory efficient, it is also quite expensive for readers. Another algorithm is epoch-based reclamation. Instead of keeping track of individual objects, threads keep track of which epoch they are in, based on a global epoch counter that is incremented occasionally. Objects are retired in a given epoch, and once all threads have moved on from that epoch, they are safe to reclaim. EBR is very lightweight. However, it is not as memory efficient as other algorithms as it tracks objects in batches. While this may be an acceptable tradeoff for the improved performance, EBR has a few other downsides. The biggest downside with EBR and related schemes is that reclamation is not very predictable. A batch of objects can only be reclaimed once all threads have moved on from the epoch. This means that to reclaim a batch, you must check the status of all active threads, which is very expensive and requires accessing thread-local shared memory. This results in a tradeoff between reclamation balancing and performance depending on how often reclamation is attempted. For example, the crossbeam-epoch crate checks for garbage every 128 operations. Importantly, the check must be performed by both readers and writers, causing reclamation to trigger unpredictably and leading to poor latency distributions. Because papaya allocates every entry and does not reuse tombstones, memory efficiency is a very important factor. Unfortunately, existing memory reclamation algorithms were not up to par in my testing. A few years ago, I stumbled across hyaline, an algorithm that solves a lot of these issues, which has since been implemented in the seize crate. In hyaline, the expensive cross-thread check is performed when a batch of objects is retired. The batch is propagated to all active threads just once. After this initial retirement phase, the batch is reclaimed using reference counting. This reclamation process is much more predictable, as threads can check for new garbage before every single operation without sacrificing performance. In practice, it tends to outperforms EBR due to the parallelism gains from workload balancing. Hyaline also solves another problem with EBR, robustness. In EBR, a single slow thread can prevent the reclamation of all objects in a given epoch. Hyaline counteracts this by keeping track of the epoch an object is created in, filtering out slow threads when reclaiming new objects. These additional properties make hyaline a perfect fit for papaya. Resizing Once a hash table gets too full it needs to resize, relocating all keys and values to a larger table. In a concurrent setting, this can be quite expensive. To reduce the cost of resizing, multiple threads can help out with the migration and copy entries in parallel. There many tradeoffs to be made when implementing concurrent resizing. Ideally, readers should be unaffected by resizing. This would require all writers to complete the migration before making progress, allowing for a single source of truth for readers. However, resizing can be slow, introducing latency spikes for writers. For a large table, resizing can take hundreds of milliseconds or even seconds to complete. This is an unacceptable amount of latency for a large number of applications. To avoid latency spikes, we can implement incremental resizing, where entries are incrementally copied over to the new table instead of blocking. This is an approach taken even by single-threaded hash tables, such as the griddle crate. Managing the state of two tables concurrently is tricky, but papaya implements a migration algorithm that allows concurrent updates to the old table and atomic copies to the new table. This does mean that during migration, many operations have to check both the new and old tables when searching for an entry. However, this is typically an acceptable tradeoff as resize operations are generally uncommon and slightly increased latency for a short period of time is better than extreme latency spikes. Incremental resizing also counteracts the effect of permanent tombstones, as the cost of resizing is amortized. However, for flexibility, papaya supports both resizing modes as an option. When write throughput or read latency is the primary concern, blocking resizes can be used instead. Note that resizing is the only case where papaya is not lock-free. Allocating the next table involves taking a lock to prevent excessive allocator pressure. Additionally, a write operation may block if its key is in the process of being copied to the new table. papaya uses a hybrid spinning strategy before falling back to blocking in this case. However, note that copying an entry does not involve allocating and is typically very fast. Blocking was an intentional design decision as true lock-free resizing is very expensive, but care was taken to mitigate any issues that might arise from blocking. Additional Features Along with all the performance characteristics mentioned above, papaya has some unique features. Because papaya does not contain locks, performing complex operations is more challenging. Instead, papaya exposes a number of atomic operations. The most powerful of these is HashMap::compute, which allows updating an entry using a compare-and-swap (CAS) function: let map = papaya::HashMap::new(); let compute = |entry| match entry { // Remove the value if it is even. Some((_key, value)) if value % 2 == 0 =\u003e { Operation::Remove } // Increment the value if it is odd. Some((_key, value)) =\u003e { Operation::Insert(value + 1) } // Do nothing if the key does not exist None =\u003e Operation::Abort(()), }; map.pin().compute('A', compute); This allows performing complex operations despite the lack of locks. Another unique feature of papaya is async support. One of the biggest downsides of dashmap is that it uses synchronous locks and so holding a reference to an item from a Dashmap will lead to a deadlock. Because papaya has a lock-free API, deadlocking is impossible. However, accessing the map still requires acquiring a guard for memory reclamation, i.e. the call to pin in the above example. This guard is !Send as it is tied to the current thread's memory reclamation state. However, papaya also exposes owned guards, which are Send and Sync, independent of any given thread. These are more expensive to create, but are allowed to be held across .await points when using a work-stealing scheduler: async fn run(map: Arc\u003cHashMap\u003ci32, String\u003e\u003e) { tokio::spawn(async move { let map = map.pin_owned(); // \u003c-- for (key, value) in map.iter() { tokio::fs::write(\"db.txt\", format!(\"{key}: {value}\\n\")).await; } }); } Async support is something I am very excited about and is not present in any existing concurrent hash tables that I am aware of. Comparisons There are a number of existing concurrent hash table crates. However, most of them lack in terms of read throughput and predictable latency compared to papaya. Additionally, async support is a difficult feature to find. However, there are cases where you might want to consider a different crate. dashmap has a very simple design built on top of hashbrown. It also closely mirrors the API of std::collections::HashMap. For write-heavy workloads, it may provide better performance. It is also lower overhead in terms of memory usage. scc is similar to dashmap but shards bucket locks even more aggressively. For write-heavy workloads it should probably be your first choice, although the code itself seemed quite complicated and difficult to audit. flurry is a closed-addressing table with striped locks but lock-free reads. However, it suffers from performance and memory usage issues due to allocator pressure. papaya should outperform flurry in general for most workloads. evmap is great for extremely read-heavy use cases. However, it is eventually consistent, and writes are relatively expensive. Scalability suffers under load even for 99% read-heavy workloads. leapfrog provides excellent performance but is limited to 64-bit Copy values. This limitation is common in academic literature, and leapfrog falls back to spinlocks for arbitrary value types, which is unfortunate for a general purpose map. Consult the benchmarks for more information, but as always, take them with a grain of salt. Always measure for your own workload.",
  "image": "https://ibraheem.ca/logo.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"content\"\u003e\n    \n    \u003cp\u003eI recently released \u003ca href=\"https://github.com/ibraheemdev/papaya\"\u003epapaya\u003c/a\u003e, a fast and feature-complete concurrent hash table for Rust. In this post I want to dive into the design and research that went into creating it, as well as why you might consider using it over existing solutions. If you\u0026#39;re looking for an overview of papaya, you might find it more useful to \u003ca href=\"https://docs.rs/papaya\"\u003econsult the documentation\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"philosophy\"\u003e\u003ca href=\"#philosophy\" aria-label=\"Anchor link for: philosophy\"\u003ePhilosophy\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eConcurrent hash tables are a well explored topic, both in academic literature and open-source implementations. In some ways, they are the holy grail of concurrent data structures. On the other hand, a concurrent hash table is an inelegant blob of shared mutable data, often a marker of a poorly architectured program. Hash tables in general have many unfortunate properties, most of which are exacerbated in a concurrent context. However, despite their downsides, hash tables can be a necessary evil, especially for read-heavy use cases where alternative data structures are not competitive in terms of performance.\u003c/p\u003e\n\u003cp\u003eThere are a few important properties that a concurrent hash table cares about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRead throughput/latency\u003c/li\u003e\n\u003cli\u003eWrite throughput/latency\u003c/li\u003e\n\u003cli\u003eMemory usage\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConcurrent hash tables fall into a large spectrum depending on which of the above properties are prioritized. papaya cares a lot more about readers than writers. Reads should be extremely low latency and never blocked by a slow writer. However, it also cares a lot about predictable latency in general. While write throughput may not be exceptional, neither readers nor writers should ever suffer from latency spikes.\u003c/p\u003e\n\u003cp\u003eIn general, use cases that care about write throughput are likely better served by alternative data structures such as \u003ca href=\"https://arxiv.org/abs/1709.06056\"\u003ehash tries\u003c/a\u003e, which deserve more experimentation. papaya aims to instead serve read-heavy workloads.\u003c/p\u003e\n\u003cp\u003eAnother huge consideration was to have an easy to use API. While papaya may use locks internally, with careful consideration, the API is lock-free and impossible to deadlock.\u003c/p\u003e\n\u003ch2 id=\"basic-design\"\u003e\u003ca href=\"#basic-design\" aria-label=\"Anchor link for: basic-design\"\u003eBasic Design\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eConsider a basic \u003ccode\u003eRwLock\u0026lt;HashMap\u0026lt;K, V\u0026gt;\u0026gt;\u003c/code\u003e. There are a few glaring issues with this, the primary one being that every write operation takes exclusive access of the hash map. Not only is this very expensive to synchronize, it also means that readers cannot proceed in the face of even a single writer.\u003c/p\u003e\n\u003cp\u003eHowever, even in a read-heavy or read-only workload, a \u003ccode\u003eRwLock\u003c/code\u003e is far from ideal. With a reader-writer lock, readers can execute in parallel. However, the lock is still a single-point of contention, even for readers. This means that every read operation will attempt to take exclusive access of the lock state to acquire the lock, resulting in an exorbitant amount of cache-coherency traffic and bringing scalability to a halt. This makes using reader-writer locks impractical for any scalable data-structure.\u003c/p\u003e\n\u003cp\u003eThere is a small improvement we can make to greatly improve scalability: sharding. Instead of forcing every core to acquire the same lock, we can shard keys across multiple maps with a \u003ccode\u003eBox\u0026lt;[RwLock\u0026lt;HashMap\u0026lt;K, V\u0026gt;\u0026gt;]\u0026gt;\u003c/code\u003e, deciding which keys go into which map based on their hash. Now, with a sufficient number of shards, the contention is distributed across multiple locks. This is the strategy \u003ca href=\"https://github.com/xacrimon/dashmap\"\u003edashmap\u003c/a\u003e uses.\u003c/p\u003e\n\u003cp\u003eSharding reduces contention, but it\u0026#39;s far from ideal. Readers are still required to modify shared memory. That memory is less shared, but it\u0026#39;s still shared, and writes to shared memory are expensive. Additionally, write operations still block readers, meaning even a small number of writers can greatly affect overall scalability. Locks in general pose a significant problem for read latency distributions in that a single slow writer can result in latency spikes for all readers.\u003c/p\u003e\n\u003cp\u003eSo how do we do better? The simplest lock-free hash table looks something like this:\u003c/p\u003e\n\u003cpre data-lang=\"rust\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003eHashMap\u0026lt;K, V\u0026gt; {\n\u003c/span\u003e\u003cspan\u003e    buckets: AtomicPtr\u0026lt;[AtomicPtr\u0026lt;Node\u0026lt;K, V\u0026gt;\u0026gt;]\u0026gt;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003eNode\u0026lt;K, V\u0026gt; {\n\u003c/span\u003e\u003cspan\u003e    key: K,\n\u003c/span\u003e\u003cspan\u003e    value: V,\n\u003c/span\u003e\u003cspan\u003e    next: AtomicPtr\u0026lt;Node\u0026lt;K, V\u0026gt;\u0026gt;,\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere\u0026#39;s a couple important layers here. The entire table is wrapped around an atomic pointer, allowing it to be atomically swapped out during a resize. Additionally, every key-value pair is behind an atomic pointer, with collisions forming a concurrent linked-list.\u003c/p\u003e\n\u003cp\u003eThe use of atomic pointers is important. Most CPUs only support reading values up to 128-bits atomically, without tearing \u003csup\u003e\u003ca href=\"#0\"\u003e1\u003c/a\u003e\u003c/sup\u003e. To support keys and values of arbitrary size, entries need to be allocated. This allows us to swap the \u003cem\u003epointer\u003c/em\u003e atomically.\u003c/p\u003e\n\u003cp\u003eNote that allocating every entry is a large fundamental design decision. It means sacrificing write throughput under heavy write load due to allocator pressure. However, this tradeoff is worth it, as it allows readers to access the table concurrently with writers. This is the design taken by C#\u0026#39;s \u003ca href=\"https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2?view=net-8.0\"\u003e\u003ccode\u003eConcurrentDictionary\u003c/code\u003e\u003c/a\u003e. However, it introduces another crucial issue.\u003c/p\u003e\n\u003cp\u003eNow that every key-value pair is allocated, readers have to go through a pointer to access the key while iterating over the linked-list, implying a cache-miss. The cost of a cache-miss is even more severe in a concurrent setting as entries are being modified by writers, resulting in contention. We want to access as little shared memory as possible.\u003c/p\u003e\n\u003cp\u003eCache locality is also the reason most modern hash tables opt for \u003cem\u003eopen addressing\u003c/em\u003e over closed chaining. With open addressing, each bucket contains a single key-value pair. Instead of using a linked-list to resolve collisions, writers \u003cem\u003eprobe\u003c/em\u003e subsequent buckets until an empty one is found. When readers encounter an empty bucket in the sequence, they can stop probing knowing the key is not in the map. This allows the entire table to be represent by a flat \u003ccode\u003e[(K, V)]\u003c/code\u003e, making access extremely cache-friendly.\u003c/p\u003e\n\u003cp\u003eAt first glance, open addressing in a concurrent settings doesn\u0026#39;t seem to provide much benefit, because entries are allocated anyways.\u003c/p\u003e\n\u003cpre data-lang=\"rust\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003eHashMap\u0026lt;K, V\u0026gt; {\n\u003c/span\u003e\u003cspan\u003e    buckets: AtomicPtr\u0026lt;[AtomicPtr\u0026lt;(K, V)\u0026gt;]\u0026gt;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, it opens the door for a crucial optimization. Along with the entries array, we can include a second array known as a metadata table. Each key-value pair has a corresponding byte of metadata containing a subset of its hash.\u003c/p\u003e\n\u003cpre data-lang=\"rust\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003eHashMap\u0026lt;K, V\u0026gt; {\n\u003c/span\u003e\u003cspan\u003e    table: AtomicPtr\u0026lt;Table\u0026lt;K, V\u0026gt;\u0026gt;\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003estruct \u003c/span\u003e\u003cspan\u003eTable\u0026lt;K, V\u0026gt; {\n\u003c/span\u003e\u003cspan\u003e    metadata: [AtomicU8],\n\u003c/span\u003e\u003cspan\u003e    entries: [AtomicPtr\u0026lt;(K, V)\u0026gt;],\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA metadata table allows reads to be extremely cache-efficient as they can probe the metadata instead of the entries. Note that because we only have 8 bits of metadata, there are still chances of false positives, but it\u0026#39;s still a massive improvement.\u003c/p\u003e\n\u003cp\u003eMetadata tables are present in most modern hash tables, including \u003ca href=\"https://abseil.io/about/design/swisstables\"\u003eswiss tables\u003c/a\u003e, the basis of \u003ccode\u003estd::collections::HashMap\u003c/code\u003e. They are even \u003cem\u003emore\u003c/em\u003e crucial in a concurrent hash table as entries are allocated, making probing through entries directly impractical.\u003c/p\u003e\n\u003ch2 id=\"probing-strategy\"\u003e\u003ca href=\"#probing-strategy\" aria-label=\"Anchor link for: probing-strategy\"\u003eProbing Strategy\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOne of the biggest decisions to make with an open addressing table is the probing strategy. The probing strategy decides the order in which buckets are probed if the initial bucket is full. While there are many interesting strategies such as \u003ca href=\"https://en.wikipedia.org/wiki/Cuckoo_hashing\"\u003ecuckoo\u003c/a\u003e, \u003ca href=\"https://programming.guide/robin-hood-hashing.html\"\u003erobin-hood\u003c/a\u003e, or \u003ca href=\"https://en.wikipedia.org/wiki/Hopscotch_hashing\"\u003ehopscotch\u003c/a\u003e hashing, these are expensive to implementing concurrently requiring extra synchronization, especially with a metadata table.\u003c/p\u003e\n\u003cp\u003eOn the other hand, the existence of a metadata table means that probing becomes relatively cheap, and so a simpler probing strategy makes more sense. For example, \u003ca href=\"https://github.com/rust-lang/hashbrown\"\u003ehashbrown\u003c/a\u003e uses a hybrid linear and quadratic probing strategy. Groups of 16 metadata entries are probed in parallel using a SIMD routine, while group-wise probing is quadratic. This allows for cache-efficient probing while avoiding \u003ca href=\"https://en.wikipedia.org/wiki/Primary_clustering\"\u003eprimary clustering\u003c/a\u003e, a common pitfall of linear probing.\u003c/p\u003e\n\u003cp\u003eUnfortunately, there is an issue with SIMD probing in a concurrent hash table — atomic loads must be aligned. This means we can\u0026#39;t simply load the next 16 entries from the probing position, we have to load aligned groups. Unfortunately, it turns out that SIMD probing is not worth it when this alignment is required in my testing. In fact, swiss tables saw a 20% performance improvement when switching to unaligned reads due to increased entropy from the hash bits. For this reason, papaya sticks to a traditional quadratic probing strategy, as well as a power-of-two capacity for the typical fast modulo.\u003c/p\u003e\n\u003ch2 id=\"load-factor\"\u003e\u003ca href=\"#load-factor\" aria-label=\"Anchor link for: load-factor\"\u003eLoad Factor\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere is another important part of a hash table, its load factor. The load factor determines when the hash table is too full and should resize. Determining whether the load factor has been reached requires keep track of the number of entries in the hash table. However, maintaining a counter is very expensive in a concurrent setting as it forms another singular point of contention! While the counter is only accessed by writers, it still affects performance quite severely.\u003c/p\u003e\n\u003cp\u003eThere are a couple of ways to work around this problem. The most obvious is to shard the length counter. While this reduces the contention when incrementing the counter, it makes accessing the total length even more expensive. papaya uses a sharded counter and exposes the length for convenience, but accessing all counter shards on every write is infeasible.\u003c/p\u003e\n\u003cp\u003eOne solution is to rely instead of a probabilistic counter for resizing, similar to \u003ca href=\"https://en.wikipedia.org/wiki/HyperLogLog\"\u003eHyperLogLog\u003c/a\u003e. However, papaya takes a different approach, inspired by \u003ca href=\"https://probablydance.com/2017/02/26/i-wrote-the-fastest-hashtable/\"\u003ethis article\u003c/a\u003e. Instead of setting a load factor, the hash table sets a maximum \u003cem\u003eprobe limit\u003c/em\u003e based on the capacity of the table. Once the limit is reached, the table is resized. The probe limit is based on \u003ccode\u003elog2\u003c/code\u003e of the table\u0026#39;s capacity, which tends to a ~80% load factor. I\u0026#39;d be interested in a formalization of probe limits and their relationship to load factor, but this number seems to work very consistently in practice, and avoids the need to synchronize a concurrent counter.\u003c/p\u003e\n\u003ch2 id=\"deletion\"\u003e\u003ca href=\"#deletion\" aria-label=\"Anchor link for: deletion\"\u003eDeletion\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn open addressing, you can\u0026#39;t simply unlink a value from the linked-list chain to delete it. Instead, you typically put down a marker value known as a \u003cem\u003etombstone\u003c/em\u003e. There are more complex deletion schemes such as \u003ca href=\"https://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/\"\u003ebackshift deletion\u003c/a\u003e, but these are difficult to implement concurrently without introducing extra synchronization.\u003c/p\u003e\n\u003cp\u003eTombstones are a bit unfortunate as they result in longer probe sequences. However, if an insert encounters a tombstone in its probe sequence, the entry can be reused for the new key. This somewhat mitigates the issue.\u003c/p\u003e\n\u003cp\u003eHowever, concurrent deletions pose a problem with a metadata table. Imagine the following sequence of events:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThread 1 inserts key \u003ccode\u003e\u0026#34;a\u0026#34;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThread 2 deletes key \u003ccode\u003e\u0026#34;a\u0026#34;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThread 2 inserts key \u003ccode\u003e\u0026#34;b\u0026#34;\u003c/code\u003e in the same slot\u003c/li\u003e\n\u003cli\u003eThread 2 writes metadata \u003ccode\u003e0b01\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eThread 1 writes metadata \u003ccode\u003e0b10\u003c/code\u003e late\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSynchronizing the entry and its metadata are in separate locations, making them difficult to synchronize when slots are reused. One solution is to store a lock for each entry that is taken when storing an entry and its metadata. This ensures synchronization but is a significant slowdown for writers.\u003c/p\u003e\n\u003cp\u003eHowever, there is another option. Instead of using a lock, we can eliminate the problem entirely by not allowing entries to be reused after being deleted. This means that there is only one metadata value written to a given slot, so we don\u0026#39;t have to worry about synchronization. This approach is taken by Cliff Click\u0026#39;s \u003ca href=\"https://www.youtube.com/watch?v=HJ-719EGIts\"\u003efamous lock-free hash table\u003c/a\u003e, although it uses it to synchronize keys and values instead of metadata. However, it is a pretty significant tradeoff, as it means workloads that insert and delete a lot of keys have to resize much more often to free up entries. We\u0026#39;ll talk more about resizing later.\u003c/p\u003e\n\u003ch2 id=\"memory-reclamation\"\u003e\u003ca href=\"#memory-reclamation\" aria-label=\"Anchor link for: memory-reclamation\"\u003eMemory Reclamation\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe\u0026#39;ve been overlooking a large problem up till now, memory reclamation. Concurrent deletion becomes a lot more difficult in a lock-free environment. In particular, there is no obvious way of telling when it is safe to free an object, as arbitrary readers may be concurrently accessing it.\u003c/p\u003e\n\u003cp\u003eThe obvious solution to this problem is some form of reference counting. Unfortunately, reference counting is similar in cost to a reader-writer lock in that every access requires modifying shared memory. In particular, this is disastrous for synchronizing access to the table itself as it creates a single point of contention for all operations.\u003c/p\u003e\n\u003cp\u003eThere are many algorithms to solve this problem. One popular scheme is \u003ca href=\"https://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf\"\u003ehazard pointers\u003c/a\u003e, which forces threads to announce access to a given object through a thread-local list of pointers. While this can be very memory efficient, it is also quite expensive for readers.\u003c/p\u003e\n\u003cp\u003eAnother algorithm is \u003ca href=\"https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf\"\u003eepoch-based reclamation\u003c/a\u003e. Instead of keeping track of individual objects, threads keep track of which \u003cem\u003eepoch\u003c/em\u003e they are in, based on a global epoch counter that is incremented occasionally. Objects are retired in a given epoch, and once all threads have moved on from that epoch, they are safe to reclaim.\u003c/p\u003e\n\u003cp\u003eEBR is very lightweight. However, it is not as memory efficient as other algorithms as it tracks objects in \u003cem\u003ebatches\u003c/em\u003e. While this may be an acceptable tradeoff for the improved performance, EBR has a few other downsides.\u003c/p\u003e\n\u003cp\u003eThe biggest downside with EBR and related schemes is that reclamation is not very predictable. A batch of objects can only be reclaimed once all threads have moved on from the epoch. This means that to reclaim a batch, you must check the status of all active threads, which is very expensive and requires accessing thread-local shared memory. This results in a tradeoff between reclamation balancing and performance depending on how often reclamation is attempted. For example, the \u003ca href=\"https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-epoch\"\u003ecrossbeam-epoch\u003c/a\u003e crate checks for garbage every 128 operations. Importantly, the check must be performed by both readers and writers, causing reclamation to trigger unpredictably and leading to poor latency distributions.\u003c/p\u003e\n\u003cp\u003eBecause papaya allocates every entry and does not reuse tombstones, memory efficiency is a very important factor. Unfortunately, existing memory reclamation algorithms were not up to par in my testing.\u003c/p\u003e\n\u003cp\u003eA few years ago, I stumbled across \u003ca href=\"https://arxiv.org/pdf/1905.07903\"\u003ehyaline\u003c/a\u003e, an algorithm that solves a lot of these issues, which has since been implemented in the \u003ca href=\"https://github.com/ibraheemdev/seize\"\u003eseize\u003c/a\u003e crate. In hyaline, the expensive cross-thread check is performed when a batch of objects is \u003cem\u003eretired\u003c/em\u003e. The batch is propagated to all active threads just once. After this initial retirement phase, the batch is reclaimed using reference counting. This reclamation process is much more predictable, as threads can check for new garbage before every single operation without sacrificing performance. In practice, it tends to outperforms EBR due to the parallelism gains from workload balancing.\u003c/p\u003e\n\u003cp\u003eHyaline also solves another problem with EBR, robustness. In EBR, a single slow thread can prevent the reclamation of all objects in a given epoch. Hyaline counteracts this by keeping track of the epoch an object is created in, filtering out slow threads when reclaiming new objects. These additional properties make hyaline a perfect fit for papaya.\u003c/p\u003e\n\u003ch2 id=\"resizing\"\u003e\u003ca href=\"#resizing\" aria-label=\"Anchor link for: resizing\"\u003eResizing\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOnce a hash table gets too full it needs to resize, relocating all keys and values to a larger table. In a concurrent setting, this can be quite expensive. To reduce the cost of resizing, multiple threads can help out with the migration and copy entries in parallel.\u003c/p\u003e\n\u003cp\u003eThere many tradeoffs to be made when implementing concurrent resizing. Ideally, readers should be unaffected by resizing. This would require all writers to complete the migration before making progress, allowing for a single source of truth for readers. However, resizing can be slow, introducing latency spikes for writers. For a large table, resizing can take hundreds of milliseconds or even \u003cem\u003eseconds\u003c/em\u003e to complete. This is an unacceptable amount of latency for a large number of applications.\u003c/p\u003e\n\u003cp\u003eTo avoid latency spikes, we can implement \u003cem\u003eincremental resizing\u003c/em\u003e, where entries are incrementally copied over to the new table instead of blocking. This is an approach taken even by single-threaded hash tables, such as the \u003ca href=\"https://crates.io/crates/griddle\"\u003egriddle\u003c/a\u003e crate.\u003c/p\u003e\n\u003cp\u003eManaging the state of two tables concurrently is tricky, but papaya implements a migration algorithm that allows concurrent updates to the old table and atomic copies to the new table. This does mean that during migration, many operations have to check both the new and old tables when searching for an entry. However, this is typically an acceptable tradeoff as resize operations are generally uncommon and slightly increased latency for a short period of time is better than extreme latency spikes.\u003c/p\u003e\n\u003cp\u003eIncremental resizing also counteracts the effect of permanent tombstones, as the cost of resizing is amortized. However, for flexibility, papaya supports both resizing modes as an option. When write throughput or read latency is the primary concern, blocking resizes can be used instead.\u003c/p\u003e\n\u003cp\u003eNote that resizing is the only case where papaya is not lock-free. Allocating the next table involves taking a lock to prevent excessive allocator pressure. Additionally, a write operation may block if its key is in the process of being copied to the new table. papaya uses a hybrid spinning strategy before falling back to blocking in this case. However, note that copying an entry does not involve allocating and is typically very fast. Blocking was an intentional design decision as true lock-free resizing is very expensive, but care was taken to mitigate any issues that might arise from blocking.\u003c/p\u003e\n\u003ch2 id=\"additional-features\"\u003e\u003ca href=\"#additional-features\" aria-label=\"Anchor link for: additional-features\"\u003eAdditional Features\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAlong with all the performance characteristics mentioned above, papaya has some unique features. \u003c/p\u003e\n\u003cp\u003eBecause papaya does not contain locks, performing complex operations is more challenging. Instead, papaya exposes a number of atomic operations. The most powerful of these is \u003ca href=\"https://docs.rs/papaya/latest/papaya/struct.HashMap.html#method.compute\"\u003e\u003ccode\u003eHashMap::compute\u003c/code\u003e\u003c/a\u003e, which allows updating an entry using a compare-and-swap (CAS) function:\u003c/p\u003e\n\u003cpre data-lang=\"rust\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e map \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003epapaya::HashMap::new();\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003elet \u003c/span\u003e\u003cspan\u003ecompute \u003c/span\u003e\u003cspan\u003e= \u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003eentry\u003c/span\u003e\u003cspan\u003e| \u003c/span\u003e\u003cspan\u003ematch\u003c/span\u003e\u003cspan\u003e entry {\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Remove the value if it is even.\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eSome\u003c/span\u003e\u003cspan\u003e((_key, value)) \u003c/span\u003e\u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e value \u003c/span\u003e\u003cspan\u003e% \u003c/span\u003e\u003cspan\u003e2 \u003c/span\u003e\u003cspan\u003e== \u003c/span\u003e\u003cspan\u003e0 \u003c/span\u003e\u003cspan\u003e=\u0026gt; \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e        Operation::Remove\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Increment the value if it is odd.\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eSome\u003c/span\u003e\u003cspan\u003e((_key, value)) \u003c/span\u003e\u003cspan\u003e=\u0026gt; \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e        Operation::Insert(value \u003c/span\u003e\u003cspan\u003e+ \u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e// Do nothing if the key does not exist\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eNone \u003c/span\u003e\u003cspan\u003e=\u0026gt; \u003c/span\u003e\u003cspan\u003eOperation::Abort(()),\n\u003c/span\u003e\u003cspan\u003e};\n\u003c/span\u003e\u003cspan\u003e\n\u003c/span\u003e\u003cspan\u003emap.\u003c/span\u003e\u003cspan\u003epin\u003c/span\u003e\u003cspan\u003e().\u003c/span\u003e\u003cspan\u003ecompute\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;A\u0026#39;\u003c/span\u003e\u003cspan\u003e, compute);\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis allows performing complex operations despite the lack of locks.\u003c/p\u003e\n\u003cp\u003eAnother unique feature of papaya is async support. One of the biggest downsides of \u003ca href=\"https://github.com/xacrimon/dashmap\"\u003edashmap\u003c/a\u003e is that it uses synchronous locks and so holding a reference to an item from a \u003ccode\u003eDashmap\u003c/code\u003e will lead to a deadlock. Because papaya has a lock-free API, deadlocking is impossible. However, accessing the map still requires \u003ca href=\"https://docs.rs/papaya/latest/papaya/#usage\"\u003eacquiring a guard\u003c/a\u003e for memory reclamation, i.e. the call to \u003ccode\u003epin\u003c/code\u003e in the above example. This guard is \u003ccode\u003e!Send\u003c/code\u003e as it is tied to the current thread\u0026#39;s memory reclamation state. However, papaya also exposes \u003ca href=\"https://docs.rs/papaya/latest/papaya/struct.HashMap.html#method.pin_owned\"\u003eowned guards\u003c/a\u003e, which are \u003ccode\u003eSend\u003c/code\u003e and \u003ccode\u003eSync\u003c/code\u003e, independent of any given thread. These are more expensive to create, but are allowed to be held across \u003ccode\u003e.await\u003c/code\u003e points when using a work-stealing scheduler:\u003c/p\u003e\n\u003cpre data-lang=\"rust\"\u003e\u003ccode data-lang=\"rust\"\u003e\u003cspan\u003easync \u003c/span\u003e\u003cspan\u003efn \u003c/span\u003e\u003cspan\u003erun\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e: Arc\u0026lt;HashMap\u0026lt;\u003c/span\u003e\u003cspan\u003ei32\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003eString\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;) {\n\u003c/span\u003e\u003cspan\u003e    tokio::spawn(async \u003c/span\u003e\u003cspan\u003emove \u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003elet\u003c/span\u003e\u003cspan\u003e map \u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e map.\u003c/span\u003e\u003cspan\u003epin_owned\u003c/span\u003e\u003cspan\u003e(); \u003c/span\u003e\u003cspan\u003e// \u0026lt;--\n\u003c/span\u003e\u003cspan\u003e        \u003c/span\u003e\u003cspan\u003efor \u003c/span\u003e\u003cspan\u003e(key, value) \u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e\u003cspan\u003e map.\u003c/span\u003e\u003cspan\u003eiter\u003c/span\u003e\u003cspan\u003e() {\n\u003c/span\u003e\u003cspan\u003e            tokio::fs::write(\u003c/span\u003e\u003cspan\u003e\u0026#34;db.txt\u0026#34;\u003c/span\u003e\u003cspan\u003e, format!(\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e{key}\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e{value}\\n\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003e)).await;\n\u003c/span\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003cspan\u003e    });\n\u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAsync support is something I am very excited about and is not present in any existing concurrent hash tables that I am aware of.\u003c/p\u003e\n\u003ch2 id=\"comparisons\"\u003e\u003ca href=\"#comparisons\" aria-label=\"Anchor link for: comparisons\"\u003eComparisons\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere are a number of existing concurrent hash table crates. However, most of them lack in terms of read throughput and predictable latency compared to papaya. Additionally, async support is a difficult feature to find. However, there are cases where you might want to consider a different crate.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/xacrimon/dashmap\"\u003edashmap\u003c/a\u003e has a very simple design built on top of \u003ca href=\"https://github.com/rust-lang/hashbrown\"\u003ehashbrown\u003c/a\u003e. It also closely mirrors the API of \u003ccode\u003estd::collections::HashMap\u003c/code\u003e. For write-heavy workloads, it may provide better performance. It is also lower overhead in terms of memory usage.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/wvwwvwwv/scalable-concurrent-containers\"\u003escc\u003c/a\u003e is similar to dashmap but shards bucket locks even more aggressively. For write-heavy workloads it should probably be your first choice, although the code itself seemed quite complicated and difficult to audit.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jonhoo/flurry\"\u003eflurry\u003c/a\u003e is a closed-addressing table with striped locks but lock-free reads. However, it suffers from performance and memory usage issues due to allocator pressure. papaya should outperform flurry in general for most workloads.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jonhoo/evmap\"\u003eevmap\u003c/a\u003e is great for \u003cem\u003eextremely\u003c/em\u003e read-heavy use cases. However, it is eventually consistent, and writes are relatively expensive. Scalability suffers under load even for 99% read-heavy workloads.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/robclu/leapfrog\"\u003eleapfrog\u003c/a\u003e provides excellent performance but is limited to 64-bit \u003ccode\u003eCopy\u003c/code\u003e values. This limitation is common in academic literature, and leapfrog falls back to spinlocks for arbitrary value types, which is unfortunate for a general purpose map.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConsult the \u003ca href=\"https://github.com/ibraheemdev/papaya/blob/master/BENCHMARKS.md\"\u003ebenchmarks\u003c/a\u003e for more information, but as always, take them with a grain of salt. Always measure for your own workload.\u003c/p\u003e\n\u003chr/\u003e\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "22 min read",
  "publishedTime": null,
  "modifiedTime": null
}
