{
  "id": "f4637a0b-6d4d-4a11-a5de-1cea0e4b6346",
  "title": "Proposal: JavaScript Structs",
  "link": "https://github.com/tc39/proposal-structs",
  "description": "Article URL: https://github.com/tc39/proposal-structs Comments URL: https://news.ycombinator.com/item?id=41787041 Points: 126 # Comments: 148",
  "author": "Kholin",
  "published": "Wed, 09 Oct 2024 12:15:57 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "tc39",
  "length": 21273,
  "excerpt": "JavaScript Structs: Fixed Layout Objects. Contribute to tc39/proposal-structs development by creating an account on GitHub.",
  "siteName": "GitHub",
  "favicon": "https://github.com/fluidicon.png",
  "text": "JavaScript Structs: Fixed Layout Objects and Some Synchronization Primitives Stage: 1 Author: Shu-yu Guo (@syg) Champion: Shu-yu Guo (@syg), Ron Buckton (@rbuckton) Introduction This proposal introduces four (4) logical features: Structs, or unshared structs, which are fixed-layout objects. They behave like class instances, with more restrictions that are beneficial for optimizations and analysis. Shared Structs, which are further restricted structs that can be shared and accessed in parallel by multiple agents. They enable shared memory multithreading. Mutex and Condition, which are higher level abstractions for synchronizing access to shared memory. Unsafe Blocks, which are syntactic guardrails to lexically scope where racy accesses to shared structs are allowed. This proposal is intended to be minimal, but still useful by itself, without follow-up proposals. The motivations are: Enable new, high-performance applications to be written in JavaScript and on the web by unlocking shared memory multithreading. Give developers an alternative to classes that favors a higher performance ceiling and statically analyzability over flexbility. Like other shared memory features in JavaScript, it is high in expressive power and high in difficulty to use correctly. This proposal is both intended as an incremental step towards higher-level, easier-to-use (e.g. data-race free by construction) parallelism abstractions as well as an escape hatch for expert programmers who need the expressivity. The two design principles that this proposal follows for shared memory are: Syntax that looks atomic ought to be atomic. (For example, the dot operator on shared structs should only access an existing field and does not tear.) There are no references from shared objects to non-shared objects. The shared and non-shared heaps are conceptually separate, with direct references only going one way. Structs Unshared structs are a refinement on JavaScript classes. They are declarative, like classes, but layout of struct instances are fixed. Structs have the following properties: They are created with integrity level sealed. In other words, they have a fixed layout. Specifically, they cannot be extended with new properties. The value in their [[Prototype]] cannot change. Every syntactically declared field is writable, enumerable, and non-configurable. They have \"one-shot initialization\". Once a struct instance is accessible to JavaScript code, all their fields, including those of their superclasses, are already initialized to undefined. Struct constructor methods have a usable this value, which is the one-shot initialize instance, on entry. As a result, return override is not expressible. super() is still allowed, but not required. They can only extend other structs. The struct constructor itself is also sealed. Struct methods are non-generic. Their this value must be an instance of the struct or of a subclass. Struct declarations use the struct keyword, and share their syntax with class declarations. Some examples: struct Box { constructor(x) { this.x = x; } x; } let box = new Box(0); box.x = 42; // x is declared assertThrows(() =\u003e { box.y = 8.8; }); // structs are sealed assertThrows(() =\u003e { box.__proto__ = {}; }); // structs are sealed struct Point extends Box { // allowed because Box is also a struct constructor(x, y) { this.y = y; // the this value is immediately usable super(x); // calls the super constructor return {}; // the return value is discarded, no return override } distance(other) { return Math.sqrt((other.x - this.x) ** 2 + (other.y - this.y) ** 2); } y; } let p = new Point(1, 2); let fake = { x: 4, y: 5 }; // methods are non-generic assertThrows(() =\u003e Point.prototype.distance.call(fake, p)); p.distance(fake); // allowed, the receiver is a Point Shared Structs Shared structs are structs with even more restricted behavior, so as to make them amenable to be shared between different agents. Their fields can be accessed in parallel by multiple agents. Shared structs, in addition to the properties listed for structs above, have the following additional properties: They can only extend other shared structs. They have a null prototype. They cannot contain instance methods or instance private names. Their instances can be communicated to other agents without copying. Their fields can only reference primitives or other shared structs. That is, they cannot point to unshared values. They cannot be frozen, because that would change their shape, which must be immutable to be amenable for sharing. // main.js shared struct SharedBox { x; } let sharedBox = new SharedBox(); let sharedBox2 = new SharedBox(); unsafe { sharedBox.x = 42; // x is declared and rhs is primitive sharedBox.x = sharedBox2; // x is declared and rhs is shared assertThrows(() =\u003e { sharedBox.x = {}; }) // rhs is not a shared struct } // can programmatically test if a value can be shared assert(Reflect.canBeShared(sharedBox2)); assert(!Reflect.canBeShared({})); let worker = new Worker('worker.js'); worker.postMessage({ sharedBox }); unsafe { sharedBox.x = \"main\"; // x is declared and rhs is primitive console.log(sharedBox.x); } // worker.js onmessage = function(e) { let sharedBox = e.data.sharedBox; unsafe { sharedBox.x = \"worker\"; // x is declared and rhs is primitive console.log(sharedBox.x); } }; The above program is permitted to print out any interleaving: main main main worker worker worker worker main Shared Arrays Shared Arrays are a fixed-length arrays that may be shared across agents. They are a special case of shared structs. There is no special syntax for Shared Arrays. They have a read-only length property. let sharedArray = new SharedArray(100); unsafe { assert(sharedArray.length === 100); for (i = 0; i \u003c sharedArray.length; i++) { // like shared structs, all elements are initialized to undefined assert(sharedArray[i] === undefined); } } let worker = new Worker('worker_array.js'); worker.postMessage({ sharedArray }); unsafe { sharedArray[0] = \"main\"; console.log(sharedArray[0]); } // worker_array.js onmessage = function(e) { let sharedArray = e.data.sharedArray; unsafe { sharedArray[0] = \"worker\"; console.log(sharedArray[0]); } }; Like the shared struct example, the above program is also permitted to print out any interleaving: main main main worker worker worker worker main Memory Model By default, field accesses on shared structs are unordered. Sequentially consistent accesses are performed via the following new overloads on existing Atomics static methods. The following pseudocode describes the new overloads. class Atomics { // ... existing stuff // Performs a seq-cst load on struct[fieldName]. static load(struct, fieldName); // Performs a seq-cst store of value in struct[fieldName]. static store(struct, fieldName, value); // Performs a seq-cst exchange on struct[fieldName] with newValue. // // newValue must be a primitive or a shared struct. // // Returns the old value. static exchange(struct, fieldName, newValue); // Performs a seq-cst compare-exchange on struct[fieldName]. // // If the existing value in struct[fieldName] is expected, replace it with // replacement. // // replacement must be a primitive or a shared struct. // // Returns the value in struct[fieldName] before the replacement, // regardless of whether the value was exchanged. static compareExchange(struct, fieldName, expected, replacement); } Shared struct field accesses can never tear, regardless of the memory order. That is, a read of a shared struct field sees exactly one write of a shared struct field, never a mix of multiple writes. Mutex and Condition Higher-level synchronization primitives are needed to aid in writing threadsafe code. This proposal adds Atomics.Mutex and Atomics.Condition. Atomics.Mutex Atomics.Mutex is a non-recursive mutex. The mutex itself is a shared struct with no fields. It is used via static methods on Atomics.Mutex. (If per-Realm prototypes become part of this proposal, those static methods will become prototype methods.) The following pseudocode describes the API. shared struct Atomics.Mutex { // Creates a new mutex. constructor(); // Attempt to acquire the lock on mutex. // // If the mutex is already locked, this blocks the agent until the lock is // acquired. // // If unlockToken is not undefined, it must be an empty UnlockToken. // // If unlockToken is undefined, returns a new UnlockToken. // Otherwise return the unlockToken that was passed in. static lock(mutex: Mutex, unlockToken: UnlockToken|undefined = undefined) : UnlockedToken; // Attempt to acquire the lock on mutex. // // If timeout is not Infinity, only block for timeout milliseconds. If // the operation timed out without acquiring the lock, returns // null. // // If timeout is 0, returns immediately without blocking if the lock // cannot be acquired. // // unlockToken behaves as it does in the lock method. static lockIfAvailable(mutex: Mutex, timeout: Number, unlockToken: UnlockToken|undefined = undefined) : UnlockToken|null; } A mutex can only be unlocked via UnlockTokens, which are unlock capabilities. These tokens are ordinary objects, not shared structs. For high-performance applications, an application can allocate an empty UnlockToken and reuse it. This API is inspired by Rust and aims to minimize misuse (e.g. double unlocks). class Atomics.Mutex.UnlockToken { // Creates an empty UnlockToken. constructor(); // Returns true if this token is non-empty. get locked(): bool; // If this token is non-empty, unlock the underlying mutex and returns true. // Otherwise returns false. unlock(): bool; // Like unlock, but returns undefined instead of bool. [Symbol.dispose](): undefined; } For example, shared struct MicrosoftSharePoint { x; y; mutex; } let point = new MicrosoftSharePoint(); point.mutex = new Atomics.Mutex(); let worker = new Worker('worker_mutex.js'); worker.postMessage({ point }); // assume this agent can block unsafe { using lock = Atomics.Mutex.lock(point.mutex); point.x = \"main\"; point.y = \"main\"; } unsafe { using lock = Atomics.Mutex.lock(point.mutex); console.log(point.x, point.y); } // worker_mutex.js onmessage = function(e) { let point = e.data.point; unsafe { using lock = Atomics.Mutex.lock(point.mutex); point.x = \"worker\"; point.y = \"worker\"; } }; The above program prints one of the following: main main worker worker That is, because point the x and y fields are accessed under lock, no agent can observe a mix of main and worker values. Atomics.Condition Atomics.Condition is a condition variable. It is a shared struct with no fields. It is used via static methods on Atomics.Condition. (If per-Realm prototypes become part of this proposal, those static methods will become prototype methods.) The following pseudocode describes the API. shared struct Atomics.Condition { // Creates a new condition variable. constructor(); // Atomically unlocks the unlockToken and blocks the current agent until cv // is notified. // // unlockToken must not be empty. // // When the agent is resumed, the lock underlying mutex in unlockToken is // reacquired, blocking if necessary. // // Returns undefined. static wait(cv: Condition, unlockToken: UnlockToken): undefined // Atomically unlocks the unlockToken and blocks the current agent until cv // is notified or timed out. // // unlockToken must not be empty. // // timeout is in milliseconds. // // If predicate is not undefined, this method returns after predicate returns // true, or if timed out. If timed out, the final return value of the // predicate is returned. Whenever the predicate is executing, the lock on the // underlying mutex of unlockToken is acquired. // // If predicate is undefined, returns true if the wait was notified, and false // if timed out. static waitFor(cv: Condition, unlockToken: UnlockToken, timeout: Number, predicate: Callable|undefined): bool // Notifies count waiters waiting on the condition variable cv. // // Returns the number of waiters that were notified. static notify(cv: Condition, count: Number = Infinity) : Number; } Unsafe Blocks Correct multithreaded programs are difficult to write, because races are subtle and difficult to reason about. To decrease the likelihood of incorrect programs, accesses to shared structs are only allowed when lexically contained with in an unsafe { } block. Note that SharedArrayBuffer access remains allowed in all contexts for backwards compatibilty. The unsafe keyword is a clear signal of intent that a developer is choosing to work with shared memory multithreaded code. The presence of an unsafe block is an indication to code reviewers that special care must be taken during review. It also is acts as a syntactic marker that future tooling (linters, type checkers, etc.) could use to identify data races. An unsafe {} block is otherwise treated the same as a normal Block. Its only distinction is that it explicitly labels code within the block as potentially containing non-thread-safe (e.g., \"unsafe\") code. The general expectation is that any thread safety concerns should be addressed by the developer as control flow exits the unsafe block. For example, you could utilize using to synchronize access to a shared struct via a lock: shared struct Counter { value = 0; } // normal JS code, outside of an \"unsafe\" context const ctr = new Counter(); // allocations allowed assertThrows(() =\u003e ctr.value = 1); // error (writes shared memory) assertThrows(() =\u003e ctr.value); // error (reads shared memory) // \"unsafe\" JS code unsafe { ctr.value = 1; // ok ctr.value; // ok } function incrementCounter(ctr, mutex) { unsafe { using lck = Atomics.Mutex.lock(mutex); ctr.value++; } } Here, when the control enters the unsafe block, we allocate a lock against the provided mutex via a using declaration. As control exits the unsafe block, the lock tracked by using is released. Lexically Scoped The unsafe keyword is a syntactic marker that applies to lexically scoped reads and writes of the fields of a shared struct instance. Within an unsafe block, any lexically scoped accesses are permitted, even if they are nested within another function declared in the same block. This special lexical context shares some surface level similarities with the lexical scoping rules for private names, or the runtime semantics of \"use strict\". Since unsafe is lexically scoped, it does not carry over to the invocation of functions declared outside of an unsafe context: function increment(ctr) { ctr.value++; // error due to illegal read/write of `ctr.value` outside of `unsafe` } unsafe { const ctr = new Counter(); increment(ctr); } Thread-safe code may execute unsafe code without restriction, and unsafe code may do likewise. As unsafe already indicates a transition boundary between thread-safe and unsafe code, there is no need to declare all calling code unsafe as you might need to do for async/await. The unsafe keyword itself does not entail any implicit synchronization or coordination as that would be in opposition to our performance goals. Instead, the onus is on developers to be cognizant of thread safety concerns when they define an unsafe block. As such, a developer can choose the coordination mechanism that best suits the needs of their application, be that a Mutex, a lock-free concurrent deque, etc. Open Questions Attaching methods to shared structs Because functions are deeply unshareable, shared structs currently do not have methods. However, this is a severe ergonomic pain point. It is also counter to encapsulation, which may have real harm in encouraging more thread-unsafe code. The current direction being explored to enable methods, which is undergoing discussion, is to give shared structs the following additional features: A per-Realm prototype object, which is an ordinary object and thus can contain methods. This corresponds to making the [[Prototype]] internal field on shared structs thread-local storage. A correlation mechanism to correlate evaluations of the same \"logical\" shared struct declaration across different agents. This is an involved topic and has its own document. See ATTACHING-BEHAVIOR.md. Future Work Asynchronous locking and waiting Asynchronous locking is planned upcoming work but is out of scope of this proposal. See ASYNC-LOCKING-WAITING.md for lockAsync and waitAsync. WasmGC interoperability The WasmGC proposal adds fixed layout, garbage-collected objects to Wasm. While the details of the type system of these objects are yet to be nailed down, interoperability with JavaScript is a requirement. WasmGC objects have opaque storage and are not aliased by linear memory, so they cannot be exposed as all Wasm memory is exposed today via ArrayBuffers. We propose structs to be the reflection of WasmGC objects in JS. WasmGC objects exposed to JS should behave the same as structs, modulo extra type checking that WasmGC require that JS structs do not. JS structs is also a good foundation for reflecting into Wasm as WasmGC objects, but that is currently left as future work as it may need a typed field extensions to be worthwhile. Further, WasmGC itself will eventually have multithreading. It behooves us to maintain a single memory model between JavaScript and Wasm as we have today, even with higher-level object abstractions. Out-of-Scope Value semantics, immutability, and operator overloading This proposal does not intend to explore the space of objects with value semantics, including immutability and operator overloading. Structs have identity like other objects and are designed to be used like other objects. Value semantics is a sufficient departure that it may be better solved with other proposals that focus on that space. Sophisticated type systems This proposal does not intend to explore sophisticated type and runtime guard systems. It is even more minimal than the closest spiritual ancestor, the Typed Objects proposal, in that we do not propose integral types for sized fields. (Typed and sized fields are reserved for future work.) Binary data overlay views This proposal does not intend to explore the space of overlaying structured views on binary data in an ArrayBuffer. This is a requirement arising from the desire for WasmGC integration, and WasmGC objects are similarly opaque. Structured overlays are fundamentally about aliasing memory, which we feel is both a different problem domain, has significant performance downsides, and sufficiently solvable today in userland. For example, see buffer-backed objects. Notably, structured overlays in JavaScript essentially involves allocating unshared wrappers per agent. If an application has shared state with a complex structure, such as a large object graph, recreating that structure via a set of wrappers per agent negates the memory use benefits of shared memory. Structured overlays would work for specific application architectures where the structure of the shared state itself is simple, like a byte buffer. Implementation guidance Immutable shapes Structs are declared with fixed layout up front. Engines should make an immutable shape for such objects. Optimizers can optimize field accesses without worrying about deopts. Shared structs: make sure fields are pointer-width and aligned Shared structs should store fields such that underlying architectures can perform atomic stores and loads. This usually eans the fields should be at least pointer-width and aligned. Shared structs: strings will be difficult Except for strings, sharing primitives in the engine is usually trivial, especially for NaN-boxing implementations. Strings in production engines have in-place mutation to transition representation in order to optimize for different use ases (e.g. ropes, slices, canonicalized, etc). Sharing strings will likely be the most challenging part of the mplementation. It is possible to support sharing strings by copying-on-sharing, but may be too slow. If possible, lockfree mplementations of in-place mutations above is ideal. Synchronization primitives: they must be moving GC-safe Production engines use moving garbage collectors, such as generational collectors and compacting collectors. If JS ynchronization primitives are implemented under the hood as OS-level synchronization primitives, those primitives most ikely depend on an unchanging address in memory and are not moving GC-safe. Engines can choose to pin these objects and make them immovable. Engines can also choose to implement synchronization primitives entirely in userspace. For example, WebKit's ParkingLot](https://webkit.org/blog/6161/locking-in-webkit/) is a userspace implementation of Linux futexes. This may have other benefits, such as improved and tuneable performance.",
  "image": "https://opengraph.githubassets.com/bd9f7b0d8944c494d0f97fa4b6b6b7c0b13b0f5983927ddab767798779e10bb2/tc39/proposal-structs",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv data-hpc=\"true\"\u003e\u003carticle itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eJavaScript Structs: Fixed Layout Objects and Some Synchronization Primitives\u003c/h2\u003e\u003ca id=\"user-content-javascript-structs-fixed-layout-objects-and-some-synchronization-primitives\" aria-label=\"Permalink: JavaScript Structs: Fixed Layout Objects and Some Synchronization Primitives\" href=\"#javascript-structs-fixed-layout-objects-and-some-synchronization-primitives\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eStage: 1\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAuthor: Shu-yu Guo (@syg)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eChampion: Shu-yu Guo (@syg), Ron Buckton (@rbuckton)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eIntroduction\u003c/h2\u003e\u003ca id=\"user-content-introduction\" aria-label=\"Permalink: Introduction\" href=\"#introduction\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis proposal introduces four (4) logical features:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003e\u003ca href=\"#structs\"\u003e\u003cstrong\u003eStructs\u003c/strong\u003e\u003c/a\u003e, or unshared structs, which are fixed-layout objects. They behave like \u003ccode\u003eclass\u003c/code\u003e instances, with more restrictions that are beneficial for optimizations and analysis.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#shared-structs\"\u003e\u003cstrong\u003eShared Structs\u003c/strong\u003e\u003c/a\u003e, which are further restricted structs that can be shared and accessed in parallel by multiple agents. They enable shared memory multithreading.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mutex-and-condition\"\u003e\u003cstrong\u003eMutex and Condition\u003c/strong\u003e\u003c/a\u003e, which are higher level abstractions for synchronizing access to shared memory.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#unsafe-blocks\"\u003e\u003cstrong\u003eUnsafe Blocks\u003c/strong\u003e\u003c/a\u003e, which are syntactic guardrails to lexically scope where racy accesses to shared structs are allowed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eThis proposal is intended to be minimal, but still useful by itself, without follow-up proposals.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe motivations are:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eEnable new, high-performance applications to be written in JavaScript and on the web by unlocking shared memory multithreading.\u003c/li\u003e\n\u003cli\u003eGive developers an alternative to \u003ccode\u003eclass\u003c/code\u003ees that favors a higher performance ceiling and statically analyzability over flexbility.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eLike other shared memory features in JavaScript, it is high in expressive power and high in difficulty to use correctly. This proposal is both intended as an incremental step towards higher-level, easier-to-use (e.g. data-race free by construction) parallelism abstractions as well as an escape hatch for expert programmers who need the expressivity.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe two design principles that this proposal follows for shared memory are:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eSyntax that looks atomic ought to be atomic. (For example, the dot operator on shared structs should only access an existing field and does not tear.)\u003c/li\u003e\n\u003cli\u003eThere are no references from shared objects to non-shared objects. The shared and non-shared heaps are conceptually separate, with direct references only going one way.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eStructs\u003c/h3\u003e\u003ca id=\"user-content-structs\" aria-label=\"Permalink: Structs\" href=\"#structs\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eUnshared structs are a refinement on JavaScript \u003ccode\u003eclass\u003c/code\u003ees. They are declarative, like classes, but layout of struct instances are fixed.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eStructs have the following properties:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eThey are created with \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\" rel=\"nofollow\"\u003eintegrity level sealed\u003c/a\u003e. In other words, they have a fixed layout. Specifically, they cannot be extended with new properties. The value in their [[Prototype]] cannot change. Every syntactically declared field is writable, enumerable, and non-configurable.\u003c/li\u003e\n\u003cli\u003eThey have \u0026#34;one-shot initialization\u0026#34;. Once a struct instance is accessible to JavaScript code, all their fields, including those of their superclasses, are already initialized to \u003ccode\u003eundefined\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eStruct \u003ccode\u003econstructor\u003c/code\u003e methods have a usable \u003ccode\u003ethis\u003c/code\u003e value, which is the one-shot initialize instance, on entry. As a result, return override is not expressible. \u003ccode\u003esuper()\u003c/code\u003e is still allowed, but not required.\u003c/li\u003e\n\u003cli\u003eThey can only extend other structs.\u003c/li\u003e\n\u003cli\u003eThe struct constructor itself is also sealed.\u003c/li\u003e\n\u003cli\u003eStruct methods are non-generic. Their this value must be an instance of the struct or of a subclass.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eStruct declarations use the \u003ccode\u003estruct\u003c/code\u003e keyword, and share their syntax with \u003ccode\u003eclass\u003c/code\u003e declarations.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eSome examples:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"struct Box {\n  constructor(x) { this.x = x; }\n  x;\n}\n\nlet box = new Box(0);\nbox.x = 42;  // x is declared\nassertThrows(() =\u0026gt; { box.y = 8.8; });        // structs are sealed\nassertThrows(() =\u0026gt; { box.__proto__ = {}; }); // structs are sealed\"\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eBox\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003econstructor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ebox\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eBox\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003ebox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// x is declared\u003c/span\u003e\n\u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ebox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e8.8\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e        \u003cspan\u003e// structs are sealed\u003c/span\u003e\n\u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ebox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e__proto__\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// structs are sealed\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"struct Point extends Box { // allowed because Box is also a struct\n  constructor(x, y) {\n    this.y = y;  // the this value is immediately usable\n    super(x);    // calls the super constructor\n    return {};   // the return value is discarded, no return override\n  }\n\n  distance(other) {\n    return Math.sqrt((other.x - this.x) ** 2 +\n                     (other.y - this.y) ** 2);\n  }\n\n  y;\n}\n\nlet p = new Point(1, 2);\nlet fake = { x: 4, y: 5 };\n// methods are non-generic\nassertThrows(() =\u0026gt; Point.prototype.distance.call(fake, p));\np.distance(fake); // allowed, the receiver is a Point\"\u003e\u003cpre\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003ePoint\u003c/span\u003e \u003cspan\u003eextends\u003c/span\u003e \u003cspan\u003eBox\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e// allowed because Box is also a struct\u003c/span\u003e\n  \u003cspan\u003econstructor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// the this value is immediately usable\u003c/span\u003e\n    \u003cspan\u003esuper\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e    \u003cspan\u003e// calls the super constructor\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e   \u003cspan\u003e// the return value is discarded, no return override\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eother\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eMath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esqrt\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eother\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e\n                     \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eother\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e**\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003ePoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003efake\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e: \u003cspan\u003e4\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e: \u003cspan\u003e5\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e// methods are non-generic\u003c/span\u003e\n\u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003ePoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprototype\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecall\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efake\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003ep\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edistance\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efake\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// allowed, the receiver is a Point\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eShared Structs\u003c/h3\u003e\u003ca id=\"user-content-shared-structs\" aria-label=\"Permalink: Shared Structs\" href=\"#shared-structs\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eShared structs are structs with even more restricted behavior, so as to make them amenable to be shared between different agents. Their fields can be accessed in parallel by multiple agents.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eShared structs, in addition to the properties listed for structs above, have the following additional properties:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eThey can only extend other shared structs.\u003c/li\u003e\n\u003cli\u003eThey have a \u003ccode\u003enull\u003c/code\u003e prototype.\u003c/li\u003e\n\u003cli\u003eThey cannot contain instance methods or instance private names.\u003c/li\u003e\n\u003cli\u003eTheir instances can be communicated to other agents without copying.\u003c/li\u003e\n\u003cli\u003eTheir fields can only reference primitives or other shared structs. That is, they cannot point to unshared values.\u003c/li\u003e\n\u003cli\u003eThey cannot be frozen, because that would change their shape, which must be immutable to be amenable for sharing.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"// main.js\nshared struct SharedBox {\n  x;\n}\n\nlet sharedBox = new SharedBox();\nlet sharedBox2 = new SharedBox();\n\nunsafe {\n  sharedBox.x = 42;          // x is declared and rhs is primitive\n  sharedBox.x = sharedBox2;  // x is declared and rhs is shared\n  assertThrows(() =\u0026gt; { sharedBox.x = {}; }) // rhs is not a shared struct\n}\n\n// can programmatically test if a value can be shared\nassert(Reflect.canBeShared(sharedBox2));\nassert(!Reflect.canBeShared({}));\n\nlet worker = new Worker(\u0026#39;worker.js\u0026#39;);\nworker.postMessage({ sharedBox });\n\nunsafe {\n  sharedBox.x = \u0026#34;main\u0026#34;;      // x is declared and rhs is primitive\n  console.log(sharedBox.x);\n}\"\u003e\u003cpre\u003e\u003cspan\u003e// main.js\u003c/span\u003e\n\u003cspan\u003eshared\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eSharedBox\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esharedBox\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eSharedBox\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esharedBox2\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eSharedBox\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e42\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e          \u003cspan\u003e// x is declared and rhs is primitive\u003c/span\u003e\n  \u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003esharedBox2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// x is declared and rhs is shared\u003c/span\u003e\n  \u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// rhs is not a shared struct\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// can programmatically test if a value can be shared\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eReflect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecanBeShared\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedBox2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\u003cspan\u003eReflect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecanBeShared\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eworker\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eWorker\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;worker.js\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eworker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epostMessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e sharedBox \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;main\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e      \u003cspan\u003e// x is declared and rhs is primitive\u003c/span\u003e\n  \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"// worker.js\nonmessage = function(e) {\n  let sharedBox = e.data.sharedBox;\n  unsafe {\n    sharedBox.x = \u0026#34;worker\u0026#34;;  // x is declared and rhs is primitive\n    console.log(sharedBox.x);\n  }\n};\"\u003e\u003cpre\u003e\u003cspan\u003e// worker.js\u003c/span\u003e\n\u003cspan\u003eonmessage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esharedBox\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;worker\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// x is declared and rhs is primitive\u003c/span\u003e\n    \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedBox\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThe above program is permitted to print out any interleaving:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003emain main\u003c/li\u003e\n\u003cli\u003emain worker\u003c/li\u003e\n\u003cli\u003eworker worker\u003c/li\u003e\n\u003cli\u003eworker main\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch4 tabindex=\"-1\" dir=\"auto\"\u003eShared Arrays\u003c/h4\u003e\u003ca id=\"user-content-shared-arrays\" aria-label=\"Permalink: Shared Arrays\" href=\"#shared-arrays\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eShared Arrays are a fixed-length arrays that may be shared across agents. They are a special case of shared structs. There is no special syntax for Shared Arrays. They have a read-only \u003ccode\u003elength\u003c/code\u003e property.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"let sharedArray = new SharedArray(100);\nunsafe {\n  assert(sharedArray.length === 100);\n  for (i = 0; i \u0026lt; sharedArray.length; i++) {\n    // like shared structs, all elements are initialized to undefined\n    assert(sharedArray[i] === undefined);\n  }\n}\n\nlet worker = new Worker(\u0026#39;worker_array.js\u0026#39;);\nworker.postMessage({ sharedArray });\n\nunsafe {\n  sharedArray[0] = \u0026#34;main\u0026#34;;\n  console.log(sharedArray[0]);\n}\"\u003e\u003cpre\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esharedArray\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eSharedArray\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e100\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elength\u003c/span\u003e \u003cspan\u003e===\u003c/span\u003e \u003cspan\u003e100\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elength\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e// like shared structs, all elements are initialized to undefined\u003c/span\u003e\n    \u003cspan\u003eassert\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e===\u003c/span\u003e \u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eworker\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eWorker\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;worker_array.js\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eworker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epostMessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e sharedArray \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;main\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"// worker_array.js\nonmessage = function(e) {\n  let sharedArray = e.data.sharedArray;\n  unsafe {\n    sharedArray[0] = \u0026#34;worker\u0026#34;;\n    console.log(sharedArray[0]);\n  }\n};\"\u003e\u003cpre\u003e\u003cspan\u003e// worker_array.js\u003c/span\u003e\n\u003cspan\u003eonmessage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esharedArray\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;worker\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esharedArray\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eLike the shared struct example, the above program is also permitted to print out any interleaving:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003emain main\u003c/li\u003e\n\u003cli\u003emain worker\u003c/li\u003e\n\u003cli\u003eworker worker\u003c/li\u003e\n\u003cli\u003eworker main\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e\u003ch4 tabindex=\"-1\" dir=\"auto\"\u003eMemory Model\u003c/h4\u003e\u003ca id=\"user-content-memory-model\" aria-label=\"Permalink: Memory Model\" href=\"#memory-model\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBy default, field accesses on shared structs are unordered. Sequentially consistent accesses are performed via the following new overloads on existing \u003ccode\u003eAtomics\u003c/code\u003e static methods.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe following pseudocode describes the new overloads.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"class Atomics {\n  // ... existing stuff\n\n  // Performs a seq-cst load on struct[fieldName].\n  static load(struct, fieldName);\n\n  // Performs a seq-cst store of value in struct[fieldName].\n  static store(struct, fieldName, value);\n\n  // Performs a seq-cst exchange on struct[fieldName] with newValue.\n  //\n  // newValue must be a primitive or a shared struct.\n  //\n  // Returns the old value.\n  static exchange(struct, fieldName, newValue);\n\n  // Performs a seq-cst compare-exchange on struct[fieldName].\n  //\n  // If the existing value in struct[fieldName] is expected, replace it with\n  // replacement.\n  //\n  // replacement must be a primitive or a shared struct.\n  //\n  // Returns the value in struct[fieldName] before the replacement,\n  // regardless of whether the value was exchanged.\n  static compareExchange(struct, fieldName, expected, replacement);\n}\"\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// ... existing stuff\u003c/span\u003e\n\n  \u003cspan\u003e// Performs a seq-cst load on struct[fieldName].\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eload\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efieldName\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Performs a seq-cst store of value in struct[fieldName].\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003estore\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efieldName\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Performs a seq-cst exchange on struct[fieldName] with newValue.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// newValue must be a primitive or a shared struct.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// Returns the old value.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003eexchange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efieldName\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Performs a seq-cst compare-exchange on struct[fieldName].\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If the existing value in struct[fieldName] is expected, replace it with\u003c/span\u003e\n  \u003cspan\u003e// replacement.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// replacement must be a primitive or a shared struct.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// Returns the value in struct[fieldName] before the replacement,\u003c/span\u003e\n  \u003cspan\u003e// regardless of whether the value was exchanged.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003ecompareExchange\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003estruct\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efieldName\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eexpected\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ereplacement\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eShared struct field accesses can never tear, regardless of the memory order. That is, a read of a shared struct field sees exactly one write of a shared struct field, never a mix of multiple writes.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eMutex and Condition\u003c/h3\u003e\u003ca id=\"user-content-mutex-and-condition\" aria-label=\"Permalink: Mutex and Condition\" href=\"#mutex-and-condition\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eHigher-level synchronization primitives are needed to aid in writing threadsafe code. This proposal adds \u003ccode\u003eAtomics.Mutex\u003c/code\u003e and \u003ccode\u003eAtomics.Condition\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch4 tabindex=\"-1\" dir=\"auto\"\u003eAtomics.Mutex\u003c/h4\u003e\u003ca id=\"user-content-atomicsmutex\" aria-label=\"Permalink: Atomics.Mutex\" href=\"#atomicsmutex\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ccode\u003eAtomics.Mutex\u003c/code\u003e is a non-recursive mutex. The mutex itself is a shared struct with no fields. It is used via static methods on \u003ccode\u003eAtomics.Mutex\u003c/code\u003e. (If \u003ca href=\"#attaching-methods-to-shared-structs\"\u003eper-Realm prototypes\u003c/a\u003e become part of this proposal, those static methods will become prototype methods.)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe following pseudocode describes the API.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"shared struct Atomics.Mutex {\n  // Creates a new mutex.\n  constructor();\n\n  // Attempt to acquire the lock on mutex.\n  //\n  // If the mutex is already locked, this blocks the agent until the lock is\n  // acquired.\n  //\n  // If unlockToken is not undefined, it must be an empty UnlockToken.\n  //\n  // If unlockToken is undefined, returns a new UnlockToken.\n  // Otherwise return the unlockToken that was passed in.\n  static lock(mutex: Mutex,\n              unlockToken: UnlockToken|undefined = undefined)\n             : UnlockedToken;\n\n  // Attempt to acquire the lock on mutex.\n  //\n  // If timeout is not Infinity, only block for timeout milliseconds. If\n  // the operation timed out without acquiring the lock, returns\n  // null.\n  //\n  // If timeout is 0, returns immediately without blocking if the lock\n  // cannot be acquired.\n  //\n  // unlockToken behaves as it does in the lock method.\n  static lockIfAvailable(mutex: Mutex,\n                         timeout: Number,\n                         unlockToken: UnlockToken|undefined = undefined)\n                        : UnlockToken|null;\n}\"\u003e\u003cpre\u003e\u003cspan\u003eshared\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// Creates a new mutex.\u003c/span\u003e\n  \u003cspan\u003econstructor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Attempt to acquire the lock on mutex.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If the mutex is already locked, this blocks the agent until the lock is\u003c/span\u003e\n  \u003cspan\u003e// acquired.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If unlockToken is not undefined, it must be an empty UnlockToken.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If unlockToken is undefined, returns a new UnlockToken.\u003c/span\u003e\n  \u003cspan\u003e// Otherwise return the unlockToken that was passed in.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003elock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e: \u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n              \u003cspan\u003eunlockToken\u003c/span\u003e: \u003cspan\u003eUnlockToken\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003eundefined\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n             : \u003cspan\u003eUnlockedToken\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Attempt to acquire the lock on mutex.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If timeout is not Infinity, only block for timeout milliseconds. If\u003c/span\u003e\n  \u003cspan\u003e// the operation timed out without acquiring the lock, returns\u003c/span\u003e\n  \u003cspan\u003e// null.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If timeout is 0, returns immediately without blocking if the lock\u003c/span\u003e\n  \u003cspan\u003e// cannot be acquired.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// unlockToken behaves as it does in the lock method.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003elockIfAvailable\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e: \u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                         \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003eNumber\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                         \u003cspan\u003eunlockToken\u003c/span\u003e: \u003cspan\u003eUnlockToken\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003eundefined\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                        : \u003cspan\u003eUnlockToken\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003enull\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eA mutex can only be unlocked via \u003ccode\u003eUnlockToken\u003c/code\u003es, which are unlock capabilities. These tokens are ordinary objects, not shared structs. For high-performance applications, an application can allocate an empty \u003ccode\u003eUnlockToken\u003c/code\u003e and reuse it. This API is inspired by Rust and aims to minimize misuse (e.g. double unlocks).\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"class Atomics.Mutex.UnlockToken {\n  // Creates an empty UnlockToken.\n  constructor();\n\n  // Returns true if this token is non-empty.\n  get locked(): bool;\n\n  // If this token is non-empty, unlock the underlying mutex and returns true.\n  // Otherwise returns false.\n  unlock(): bool;\n\n  // Like unlock, but returns undefined instead of bool.\n  [Symbol.dispose](): undefined;\n}\"\u003e\u003cpre\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eUnlockToken\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// Creates an empty UnlockToken.\u003c/span\u003e\n  \u003cspan\u003econstructor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Returns true if this token is non-empty.\u003c/span\u003e\n  \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003elocked\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e: \u003cspan\u003ebool\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// If this token is non-empty, unlock the underlying mutex and returns true.\u003c/span\u003e\n  \u003cspan\u003e// Otherwise returns false.\u003c/span\u003e\n  \u003cspan\u003eunlock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e: \u003cspan\u003ebool\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Like unlock, but returns undefined instead of bool.\u003c/span\u003e\n  \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eSymbol\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edispose\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e: \u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eFor example,\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"shared struct MicrosoftSharePoint {\n  x;\n  y;\n  mutex;\n}\n\nlet point = new MicrosoftSharePoint();\npoint.mutex = new Atomics.Mutex();\n\nlet worker = new Worker(\u0026#39;worker_mutex.js\u0026#39;);\nworker.postMessage({ point });\n\n// assume this agent can block\nunsafe {\n  using lock = Atomics.Mutex.lock(point.mutex);\n  point.x = \u0026#34;main\u0026#34;;\n  point.y = \u0026#34;main\u0026#34;;\n}\n\nunsafe {\n  using lock = Atomics.Mutex.lock(point.mutex);\n  console.log(point.x, point.y);\n}\"\u003e\u003cpre\u003e\u003cspan\u003eshared\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eMicrosoftSharePoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eMicrosoftSharePoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eworker\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eWorker\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#39;worker_mutex.js\u0026#39;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eworker\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epostMessage\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e point \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003e// assume this agent can block\u003c/span\u003e\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003elock\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;main\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;main\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003elock\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"// worker_mutex.js\nonmessage = function(e) {\n  let point = e.data.point;\n  unsafe {\n    using lock = Atomics.Mutex.lock(point.mutex);\n    point.x = \u0026#34;worker\u0026#34;;\n    point.y = \u0026#34;worker\u0026#34;;\n  }\n};\"\u003e\u003cpre\u003e\u003cspan\u003e// worker_mutex.js\u003c/span\u003e\n\u003cspan\u003eonmessage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ee\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003elock\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;worker\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u0026#34;worker\u0026#34;\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThe above program prints one of the following:\u003c/p\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003emain main\u003c/li\u003e\n\u003cli\u003eworker worker\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003eThat is, because point the \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e fields are accessed under lock, no agent can observe a mix of main and worker values.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch4 tabindex=\"-1\" dir=\"auto\"\u003eAtomics.Condition\u003c/h4\u003e\u003ca id=\"user-content-atomicscondition\" aria-label=\"Permalink: Atomics.Condition\" href=\"#atomicscondition\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ccode\u003eAtomics.Condition\u003c/code\u003e is a condition variable. It is a shared struct with no fields. It is used via static methods on \u003ccode\u003eAtomics.Condition\u003c/code\u003e. (If \u003ca href=\"#attaching-methods-to-shared-structs\"\u003eper-Realm prototypes\u003c/a\u003e become part of this proposal, those static methods will become prototype methods.)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe following pseudocode describes the API.\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"shared struct Atomics.Condition {\n  // Creates a new condition variable.\n  constructor();\n\n  // Atomically unlocks the unlockToken and blocks the current agent until cv\n  // is notified.\n  //\n  // unlockToken must not be empty.\n  //\n  // When the agent is resumed, the lock underlying mutex in unlockToken is\n  // reacquired, blocking if necessary.\n  //\n  // Returns undefined.\n  static wait(cv: Condition,\n              unlockToken: UnlockToken): undefined\n\n  // Atomically unlocks the unlockToken and blocks the current agent until cv\n  // is notified or timed out.\n  //\n  // unlockToken must not be empty.\n  //\n  // timeout is in milliseconds.\n  //\n  // If predicate is not undefined, this method returns after predicate returns\n  // true, or if timed out. If timed out, the final return value of the\n  // predicate is returned. Whenever the predicate is executing, the lock on the\n  // underlying mutex of unlockToken is acquired.\n  //\n  // If predicate is undefined, returns true if the wait was notified, and false\n  // if timed out.\n  static waitFor(cv: Condition,\n                 unlockToken: UnlockToken,\n                 timeout: Number,\n                 predicate: Callable|undefined): bool\n\n  // Notifies count waiters waiting on the condition variable cv.\n  //\n  // Returns the number of waiters that were notified.\n  static notify(cv: Condition,\n                count: Number = Infinity)\n               : Number;\n}\"\u003e\u003cpre\u003e\u003cspan\u003eshared\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eCondition\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// Creates a new condition variable.\u003c/span\u003e\n  \u003cspan\u003econstructor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n  \u003cspan\u003e// Atomically unlocks the unlockToken and blocks the current agent until cv\u003c/span\u003e\n  \u003cspan\u003e// is notified.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// unlockToken must not be empty.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// When the agent is resumed, the lock underlying mutex in unlockToken is\u003c/span\u003e\n  \u003cspan\u003e// reacquired, blocking if necessary.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// Returns undefined.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003ewait\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecv\u003c/span\u003e: \u003cspan\u003eCondition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n              \u003cspan\u003eunlockToken\u003c/span\u003e: \u003cspan\u003eUnlockToken\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e: \u003cspan\u003eundefined\u003c/span\u003e\n\n  \u003cspan\u003e// Atomically unlocks the unlockToken and blocks the current agent until cv\u003c/span\u003e\n  \u003cspan\u003e// is notified or timed out.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// unlockToken must not be empty.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// timeout is in milliseconds.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If predicate is not undefined, this method returns after predicate returns\u003c/span\u003e\n  \u003cspan\u003e// true, or if timed out. If timed out, the final return value of the\u003c/span\u003e\n  \u003cspan\u003e// predicate is returned. Whenever the predicate is executing, the lock on the\u003c/span\u003e\n  \u003cspan\u003e// underlying mutex of unlockToken is acquired.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// If predicate is undefined, returns true if the wait was notified, and false\u003c/span\u003e\n  \u003cspan\u003e// if timed out.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003ewaitFor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecv\u003c/span\u003e: \u003cspan\u003eCondition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                 \u003cspan\u003eunlockToken\u003c/span\u003e: \u003cspan\u003eUnlockToken\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                 \u003cspan\u003etimeout\u003c/span\u003e: \u003cspan\u003eNumber\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                 \u003cspan\u003epredicate\u003c/span\u003e: \u003cspan\u003eCallable\u003c/span\u003e\u003cspan\u003e|\u003c/span\u003e\u003cspan\u003eundefined\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e: \u003cspan\u003ebool\u003c/span\u003e\n\n  \u003cspan\u003e// Notifies count waiters waiting on the condition variable cv.\u003c/span\u003e\n  \u003cspan\u003e//\u003c/span\u003e\n  \u003cspan\u003e// Returns the number of waiters that were notified.\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003enotify\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecv\u003c/span\u003e: \u003cspan\u003eCondition\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n                \u003cspan\u003ecount\u003c/span\u003e: \u003cspan\u003eNumber\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eInfinity\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n               : \u003cspan\u003eNumber\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eUnsafe Blocks\u003c/h3\u003e\u003ca id=\"user-content-unsafe-blocks\" aria-label=\"Permalink: Unsafe Blocks\" href=\"#unsafe-blocks\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eCorrect multithreaded programs are difficult to write, because races are subtle and difficult to reason about. To decrease the likelihood of incorrect programs, accesses to shared structs are only allowed when lexically contained with in an \u003ccode\u003eunsafe { }\u003c/code\u003e block. Note that SharedArrayBuffer access remains allowed in all contexts for backwards compatibilty.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003eunsafe\u003c/code\u003e keyword is a clear signal of intent that a developer is choosing to work with shared memory multithreaded code. The presence of an \u003ccode\u003eunsafe\u003c/code\u003e block is an indication to code reviewers that special care must be taken during review. It also is acts as a syntactic marker that future tooling (linters, type checkers, etc.) could use to identify data races.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAn \u003ccode\u003eunsafe {}\u003c/code\u003e block is otherwise treated the same as a normal Block. Its only distinction is that it explicitly labels code within the block as potentially containing non-thread-safe (e.g., \u0026#34;unsafe\u0026#34;) code. The general expectation is that any thread safety concerns should be addressed by the developer as control flow exits the unsafe block. For example, you could utilize using to synchronize access to a shared struct via a lock:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"shared struct Counter {\n  value = 0;\n}\n\n// normal JS code, outside of an \u0026#34;unsafe\u0026#34; context\nconst ctr = new Counter(); // allocations allowed\nassertThrows(() =\u0026gt; ctr.value = 1); // error (writes shared memory)\nassertThrows(() =\u0026gt; ctr.value);     // error (reads shared memory)\n\n// \u0026#34;unsafe\u0026#34; JS code\nunsafe {\n  ctr.value = 1; // ok\n  ctr.value;     // ok\n}\n\nfunction incrementCounter(ctr, mutex) {\n  unsafe {\n    using lck = Atomics.Mutex.lock(mutex);\n    ctr.value++;\n  }\n}\"\u003e\u003cpre\u003e\u003cspan\u003eshared\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eCounter\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003e// normal JS code, outside of an \u0026#34;unsafe\u0026#34; context\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ectr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eCounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// allocations allowed\u003c/span\u003e\n\u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// error (writes shared memory)\u003c/span\u003e\n\u003cspan\u003eassertThrows\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u0026gt;\u003c/span\u003e \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e     \u003cspan\u003e// error (reads shared memory)\u003c/span\u003e\n\n\u003cspan\u003e// \u0026#34;unsafe\u0026#34; JS code\u003c/span\u003e\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// ok\u003c/span\u003e\n  \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e     \u003cspan\u003e// ok\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\n\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eincrementCounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003eunsafe\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eusing\u003c/span\u003e \u003cspan\u003elck\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAtomics\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eMutex\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elock\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emutex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n    \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eHere, when the control enters the \u003ccode\u003eunsafe\u003c/code\u003e block, we allocate a lock against the provided mutex via a \u003ccode\u003eusing\u003c/code\u003e declaration. As control exits the \u003ccode\u003eunsafe\u003c/code\u003e block, the lock tracked by using is released.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch4 tabindex=\"-1\" dir=\"auto\"\u003eLexically Scoped\u003c/h4\u003e\u003ca id=\"user-content-lexically-scoped\" aria-label=\"Permalink: Lexically Scoped\" href=\"#lexically-scoped\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ccode\u003eunsafe\u003c/code\u003e keyword is a syntactic marker that applies to lexically scoped reads and writes of the fields of a shared struct instance. Within an \u003ccode\u003eunsafe\u003c/code\u003e block, any lexically scoped accesses are permitted, even if they are nested within another function declared in the same block. This special lexical context shares some surface level similarities with the lexical scoping rules for private names, or the runtime semantics of \u0026#34;use strict\u0026#34;.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eSince \u003ccode\u003eunsafe\u003c/code\u003e is lexically scoped, it does not carry over to the invocation of functions declared outside of an \u003ccode\u003eunsafe\u003c/code\u003e context:\u003c/p\u003e\n\u003cdiv dir=\"auto\" data-snippet-clipboard-copy-content=\"function increment(ctr) {\n  ctr.value++; // error due to illegal read/write of `ctr.value` outside of `unsafe`\n}\nunsafe {\n  const ctr = new Counter();\n  increment(ctr);\n}\"\u003e\u003cpre\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// error due to illegal read/write of `ctr.value` outside of `unsafe`\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003eunsafe\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003econst\u003c/span\u003e \u003cspan\u003ectr\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003eCounter\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eincrement\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ectr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003eThread-safe code may execute \u003ccode\u003eunsafe\u003c/code\u003e code without restriction, and \u003ccode\u003eunsafe\u003c/code\u003e code may do likewise. As \u003ccode\u003eunsafe\u003c/code\u003e already indicates a transition boundary between thread-safe and \u003ccode\u003eunsafe\u003c/code\u003e code, there is no need to declare all calling code \u003ccode\u003eunsafe\u003c/code\u003e as you might need to do for \u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e. The \u003ccode\u003eunsafe\u003c/code\u003e keyword itself does not entail any implicit synchronization or coordination as that would be in opposition to our performance goals. Instead, the onus is on developers to be cognizant of thread safety concerns when they define an \u003ccode\u003eunsafe\u003c/code\u003e block. As such, a developer can choose the coordination mechanism that best suits the needs of their application, be that a \u003ccode\u003eMutex\u003c/code\u003e, a lock-free concurrent deque, etc.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eOpen Questions\u003c/h2\u003e\u003ca id=\"user-content-open-questions\" aria-label=\"Permalink: Open Questions\" href=\"#open-questions\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eAttaching methods to shared structs\u003c/h3\u003e\u003ca id=\"user-content-attaching-methods-to-shared-structs\" aria-label=\"Permalink: Attaching methods to shared structs\" href=\"#attaching-methods-to-shared-structs\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eBecause functions are deeply unshareable, shared structs currently do not have methods. However, this is a severe ergonomic pain point. It is also counter to encapsulation, which may have real harm in encouraging more thread-unsafe code. The current direction being explored to enable methods, which is undergoing discussion, is to give shared structs the following additional features:\u003c/p\u003e\n\u003col dir=\"auto\"\u003e\n\u003cli\u003eA per-Realm prototype object, which is an ordinary object and thus can contain methods. This corresponds to making the [[Prototype]] internal field on shared structs thread-local storage.\u003c/li\u003e\n\u003cli\u003eA correlation mechanism to correlate evaluations of the same \u0026#34;logical\u0026#34; shared struct declaration across different agents.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp dir=\"auto\"\u003eThis is an involved topic and has its own document. See \u003ca href=\"https://github.com/tc39/proposal-structs/blob/main/ATTACHING-BEHAVIOR.md\"\u003eATTACHING-BEHAVIOR.md\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eFuture Work\u003c/h2\u003e\u003ca id=\"user-content-future-work\" aria-label=\"Permalink: Future Work\" href=\"#future-work\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eAsynchronous locking and waiting\u003c/h3\u003e\u003ca id=\"user-content-asynchronous-locking-and-waiting\" aria-label=\"Permalink: Asynchronous locking and waiting\" href=\"#asynchronous-locking-and-waiting\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eAsynchronous locking is planned upcoming work but is out of scope of this proposal. See \u003ca href=\"https://github.com/tc39/proposal-structs/blob/main/ASYNC-LOCKING-WAITING.md\"\u003eASYNC-LOCKING-WAITING.md\u003c/a\u003e for \u003ccode\u003elockAsync\u003c/code\u003e and \u003ccode\u003ewaitAsync\u003c/code\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eWasmGC interoperability\u003c/h2\u003e\u003ca id=\"user-content-wasmgc-interoperability\" aria-label=\"Permalink: WasmGC interoperability\" href=\"#wasmgc-interoperability\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThe \u003ca href=\"https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md\"\u003eWasmGC proposal\u003c/a\u003e adds fixed layout, garbage-collected objects to Wasm. While the details of the type system of these objects are yet to be nailed down, interoperability with JavaScript is a requirement.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWasmGC objects have opaque storage and are not aliased by linear memory, so they cannot be exposed as all Wasm memory is exposed today via \u003ccode\u003eArrayBuffer\u003c/code\u003es. We propose structs to be the reflection of WasmGC objects in JS.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eWasmGC objects exposed to JS should behave the same as structs, modulo extra type checking that WasmGC require that JS structs do not. JS structs is also a good foundation for reflecting into Wasm as WasmGC objects, but that is currently left as future work as it may need a typed field extensions to be worthwhile.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eFurther, WasmGC itself will eventually have multithreading. It behooves us to maintain a single memory model between JavaScript and Wasm as we have today, even with higher-level object abstractions.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eOut-of-Scope\u003c/h2\u003e\u003ca id=\"user-content-out-of-scope\" aria-label=\"Permalink: Out-of-Scope\" href=\"#out-of-scope\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eValue semantics, immutability, and operator overloading\u003c/h3\u003e\u003ca id=\"user-content-value-semantics-immutability-and-operator-overloading\" aria-label=\"Permalink: Value semantics, immutability, and operator overloading\" href=\"#value-semantics-immutability-and-operator-overloading\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis proposal does not intend to explore the space of objects with value semantics, including immutability and operator overloading. Structs have identity like other objects and are designed to be used like other objects. Value semantics is a sufficient departure that it may be better solved with other proposals that focus on that space.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eSophisticated type systems\u003c/h3\u003e\u003ca id=\"user-content-sophisticated-type-systems\" aria-label=\"Permalink: Sophisticated type systems\" href=\"#sophisticated-type-systems\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis proposal does not intend to explore sophisticated type and runtime guard systems. It is even more minimal than the closest spiritual ancestor, the \u003ca href=\"https://github.com/tschneidereit/proposal-typed-objects/blob/main/explainer.md\"\u003eTyped Objects proposal\u003c/a\u003e, in that we do not propose integral types for sized fields. (Typed and sized fields are reserved for future work.)\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eBinary data overlay views\u003c/h3\u003e\u003ca id=\"user-content-binary-data-overlay-views\" aria-label=\"Permalink: Binary data overlay views\" href=\"#binary-data-overlay-views\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eThis proposal does not intend to explore the space of overlaying structured views on binary data in an \u003ccode\u003eArrayBuffer\u003c/code\u003e. This is a requirement arising from the desire for WasmGC integration, and WasmGC objects are similarly opaque.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eStructured overlays are fundamentally about aliasing memory, which we feel is both a different problem domain, has significant performance downsides, and sufficiently solvable today in userland. For example, see \u003ca href=\"https://github.com/GoogleChromeLabs/buffer-backed-object\"\u003ebuffer-backed objects\u003c/a\u003e.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eNotably, structured overlays in JavaScript essentially involves allocating unshared wrappers \u003cem\u003eper agent\u003c/em\u003e. If an application has shared state with a complex structure, such as a large object graph, recreating that structure via a set of wrappers per agent negates the memory use benefits of \u003cem\u003eshared\u003c/em\u003e memory. Structured overlays would work for specific application architectures where the structure of the shared state itself is simple, like a byte buffer.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch2 tabindex=\"-1\" dir=\"auto\"\u003eImplementation guidance\u003c/h2\u003e\u003ca id=\"user-content-implementation-guidance\" aria-label=\"Permalink: Implementation guidance\" href=\"#implementation-guidance\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eImmutable shapes\u003c/h3\u003e\u003ca id=\"user-content-immutable-shapes\" aria-label=\"Permalink: Immutable shapes\" href=\"#immutable-shapes\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eStructs are declared with fixed layout up front. Engines should make an immutable shape for such objects. Optimizers can optimize field accesses without worrying about deopts.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eShared structs: make sure fields are pointer-width and aligned\u003c/h3\u003e\u003ca id=\"user-content-shared-structs-make-sure-fields-are-pointer-width-and-aligned\" aria-label=\"Permalink: Shared structs: make sure fields are pointer-width and aligned\" href=\"#shared-structs-make-sure-fields-are-pointer-width-and-aligned\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eShared structs should store fields such that underlying architectures can perform atomic stores and loads. This usually eans the fields should be at least pointer-width and aligned.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eShared structs: strings will be difficult\u003c/h3\u003e\u003ca id=\"user-content-shared-structs-strings-will-be-difficult\" aria-label=\"Permalink: Shared structs: strings will be difficult\" href=\"#shared-structs-strings-will-be-difficult\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eExcept for strings, sharing primitives in the engine is usually trivial, especially for NaN-boxing implementations.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eStrings in production engines have in-place mutation to transition representation in order to optimize for different use ases (e.g. ropes, slices, canonicalized, etc). Sharing strings will likely be the most challenging part of the mplementation.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eIt is possible to support sharing strings by copying-on-sharing, but may be too slow. If possible, lockfree mplementations of in-place mutations above is ideal.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" dir=\"auto\"\u003eSynchronization primitives: they must be moving GC-safe\u003c/h3\u003e\u003ca id=\"user-content-synchronization-primitives-they-must-be-moving-gc-safe\" aria-label=\"Permalink: Synchronization primitives: they must be moving GC-safe\" href=\"#synchronization-primitives-they-must-be-moving-gc-safe\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eProduction engines use moving garbage collectors, such as generational collectors and compacting collectors. If JS ynchronization primitives are implemented under the hood as OS-level synchronization primitives, those primitives most ikely depend on an unchanging address in memory and are \u003cem\u003enot\u003c/em\u003e moving GC-safe.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eEngines can choose to pin these objects and make them immovable.\u003c/p\u003e\n\u003cp dir=\"auto\"\u003eEngines can also choose to implement synchronization primitives entirely in userspace. For example, WebKit\u0026#39;s \u003ccode\u003eParkingLot\u003c/code\u003e](\u003ca href=\"https://webkit.org/blog/6161/locking-in-webkit/\" rel=\"nofollow\"\u003ehttps://webkit.org/blog/6161/locking-in-webkit/\u003c/a\u003e) is a userspace implementation of Linux futexes. This may have other benefits, such as improved and tuneable performance.\u003c/p\u003e\n\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": null,
  "modifiedTime": null
}
