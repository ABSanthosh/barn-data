{
  "id": "b507ca4c-9d2d-4fb0-9461-ae8c651a55c7",
  "title": "How to Create HTML/ZIP/PNG Polyglot Files",
  "link": "https://gildas-lormeau.github.io/Polyglot-HTML-ZIP-PNG/SUMMARY.html",
  "description": "Article URL: https://gildas-lormeau.github.io/Polyglot-HTML-ZIP-PNG/SUMMARY.html Comments URL: https://news.ycombinator.com/item?id=42526926 Points: 22 # Comments: 1",
  "author": "gildas",
  "published": "Fri, 27 Dec 2024 23:10:54 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 5661,
  "excerpt": "Learn how to create HTML/ZIP/PNG polyglot files in JavaScript",
  "siteName": "Polyglot-HTML-ZIP-PNG",
  "favicon": "",
  "text": "How to Create HTML/ZIP/PNG Polyglot Files This article is a summary of the presentation available here. The resulting demo file can be downloaded at the end of the article. The repository can be found at https://github.com/gildas-lormeau/Polyglot-HTML-ZIP-PNG. Introduction SingleFile, a tool for web archiving, commonly stores web page resources as data URIs. However, this approach can be inefficient for large resources. A more elegant solution emerges through combining the ZIP format’s flexible structure with HTML. We’ll then take it a step further by encapsulating this entire structure within a PNG file. The Power of ZIP The ZIP format provides an organized structure for storing multiple files. It is based on a structure with file entries followed by a central directory. The central directory acts as a table of contents, containing headers with metadata about each file entry. These headers include crucial information such as file names, sizes, checksums, and file entry offsets. What makes ZIP particularly versatile is its flexibility with data placement. The format enables data to be prepended before the ZIP content by setting an offset greater than 0 for the first file entry, while allowing up to 64KB of data to be appended afterward (i.e. ZIP comment). This feature makes it well-suited for creating polyglot files. Creating HTML/ZIP Polyglot Files Based on this knowledge, we can create a self-extracting archive that works in web browsers. The page to be displayed and its resources are stored in a ZIP file. By storing the ZIP data in an HTML comment, we can create a self-extracting page that extracts and displays the contents of the ZIP file. Here is the basic structure of the self-extracting page: \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=utf-8\u003e \u003ctitle\u003ePlease wait...\u003c/title\u003e \u003cscript src=lib/zip.min.js\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003ePlease wait...\u003c/p\u003e \u003c!-- [ZIP data] --\u003e \u003cscript\u003e\u003c!-- Content of assets/main.js --\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e The assets/main.js script on this “bootstrap page” reads the ZIP data by calling fetch(””) and uses the lib/zip.min.js JavaScript library to extract it. This bootstrap page is then replaced by the extracted page with its resources. However, there’s a problem: due to the same-origin policy, retrieving ZIP data directly with fetch(””) fails when the page is opened from the filesystem (except in Firefox). Reading ZIP Data from the DOM To overcome the filesystem limitation, we can read ZIP data directly from the DOM. This approach requires careful handling of character encoding. The bootstrap page is now encoded in windows-1252, which allows data to be read from the DOM with minimum degradation. Some encoding challenges emerge: DOM text content gets decoded to UTF-16 instead of windows-1252 The NULL character (U+0000) gets decoded to the replacement character (U+FFFD) Carriage returns (\\r) and carriage return + line feeds (\\r\\n) get decoded to line feeds (\\n) The first 2 points can be fixed by using an association table to convert characters to windows-1252. For the last point, “consolidation data” in a JSON script tag is added in the bootstrap page. This data tracks the offsets of carriage returns and carriage return + line feeds, and enables accurate reconstruction of the original content when extracting the ZIP data. Here is the resulting structure: \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=windows-1252\u003e \u003ctitle\u003ePlease wait...\u003c/title\u003e \u003cscript src=lib/zip.min.js\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003ePlease wait...\u003c/p\u003e \u003c!-- [ZIP data] --\u003e \u003cscript text=application/json\u003e [consolidation data] \u003c/script\u003e \u003cscript\u003e\u003c!-- Content of assets/main.js --\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Adding PNG to the Mix The PNG format consists of a signature followed by chunks. Each chunk contains these fieds: Length (4 bytes) Type identifier (4 bytes) e.g., IHDR (header), IDAT (data), IEND (end of file), tEXt (custom data)… Data content (n bytes) CRC32 checksum (4 bytes) Here is the minimum structure of a PNG file: PNG signature (8 bytes) IHDR chunk (13 bytes) One or more IDAT chunks IEND chunk (12 bytes) The Final Form: HTML/ZIP/PNG Polyglot Files The ultimate implementation combines all three formats into a single file. The HTML format’s fault tolerance allows for this complex structure. However, this approach introduces new challenges: The signature, the IHDR and the IEND chunks become visible as text nodes briefly and should be removed as soon as the page is parsed The displayed page is rendered in quirks mode, requiring specific handling through document.write() and related methods to parse the displayed page Here is the resulting structure viewed as PNG chunks: [PNG signature] [IHDR chunk] [tEXt chunk \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=windows-1252\u003e \u003ctitle\u003ePlease wait...\u003c/title\u003e \u003cscript src=lib/zip.min.js\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003ePlease wait...\u003c/p\u003e \u003c!-- ] [IDAT chunk(s)] [tEXt chunk --\u003e \u003c!-- [ZIP data] --\u003e \u003cscript text=application/json\u003e [consolidation data] \u003c/script\u003e \u003cscript\u003e\u003c!-- Content of assets/main.js --\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ] [IEND chunk] Optimization Through Image Reuse The final optimization removes the main image (i.e. the logo of RennesJS) from the ZIP file and reuses the page, interpreted as a PNG file, to replace it in the displayed page. Resulting File Download demo.png.zip.html (a bug in “Archive Utility” on macOS prevents it from decompressing the resulting file, you can use unzip to get around this issue).",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n      \n      \n      \n\n      \u003ch2 id=\"how-to-create-htmlzippng-polyglot-files\"\u003eHow to Create HTML/ZIP/PNG Polyglot Files\u003c/h2\u003e\n\n\u003cp\u003eThis article is a summary of the presentation available \u003ca href=\"https://gildas-lormeau.github.io/Polyglot-HTML-ZIP-PNG/\"\u003ehere\u003c/a\u003e. The resulting demo file can be downloaded at the end of the article. The repository can be found at \u003ca href=\"https://github.com/gildas-lormeau/Polyglot-HTML-ZIP-PNG\"\u003ehttps://github.com/gildas-lormeau/Polyglot-HTML-ZIP-PNG\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/gildas-lormeau/SingleFile\"\u003eSingleFile\u003c/a\u003e, a tool for web archiving, commonly stores web page resources as data URIs. However, this approach can be inefficient for large resources. A more elegant solution emerges through combining the ZIP format’s flexible structure with HTML. We’ll then take it a step further by encapsulating this entire structure within a PNG file.\u003c/p\u003e\n\n\u003ch2 id=\"the-power-of-zip\"\u003eThe Power of ZIP\u003c/h2\u003e\n\n\u003cp\u003eThe ZIP format provides an organized structure for storing multiple files. It is based on a structure with file entries followed by a central directory. The central directory acts as a table of contents, containing headers with metadata about each file entry. These headers include crucial information such as file names, sizes, checksums, and file entry offsets. What makes ZIP particularly versatile is its flexibility with data placement. The format enables data to be prepended before the ZIP content by setting an offset greater than 0 for the first file entry, while allowing up to 64KB of data to be appended afterward (i.e. ZIP comment). This feature makes it well-suited for creating polyglot files.\u003c/p\u003e\n\n\u003ch2 id=\"creating-htmlzip-polyglot-files\"\u003eCreating HTML/ZIP Polyglot Files\u003c/h2\u003e\n\n\u003cp\u003eBased on this knowledge, we can create a self-extracting archive that works in web browsers. The page to be displayed and its resources are stored in a ZIP file. By storing the ZIP data in an HTML comment, we can create a self-extracting page that extracts and displays the contents of the ZIP file.\u003c/p\u003e\n\n\u003cp\u003eHere is the basic structure of the self-extracting page:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;!doctype html\u0026gt;\u003c/span\u003e\n\u003cspan\u003e\u0026lt;html\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;head\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;meta\u003c/span\u003e \u003cspan\u003echarset=\u003c/span\u003e\u003cspan\u003eutf-8\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;title\u0026gt;\u003c/span\u003ePlease wait...\u003cspan\u003e\u0026lt;/title\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;script \u003c/span\u003e\u003cspan\u003esrc=\u003c/span\u003e\u003cspan\u003elib/zip.min.js\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026lt;/script\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/head\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;body\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;p\u0026gt;\u003c/span\u003ePlease wait...\u003cspan\u003e\u0026lt;/p\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;!-- [ZIP data] --\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;script\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;!--\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e \u003cspan\u003eof\u003c/span\u003e \u003cspan\u003eassets\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejs\u003c/span\u003e \u003cspan\u003e--\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/body\u0026gt;\u003c/span\u003e\n\u003cspan\u003e\u0026lt;/html\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003eThe \u003ccode\u003eassets/main.js\u003c/code\u003e script on this “bootstrap page” reads the ZIP data by calling \u003ccode\u003efetch(””)\u003c/code\u003e and uses the \u003ccode\u003elib/zip.min.js\u003c/code\u003e JavaScript library to extract it. This bootstrap page is then replaced by the extracted page with its resources. However, there’s a problem: due to the same-origin policy, retrieving ZIP data directly with \u003ccode\u003efetch(””)\u003c/code\u003e fails when the page is opened from the filesystem (except in Firefox).\u003c/p\u003e\n\n\u003ch2 id=\"reading-zip-data-from-the-dom\"\u003eReading ZIP Data from the DOM\u003c/h2\u003e\n\n\u003cp\u003eTo overcome the filesystem limitation, we can read ZIP data directly from the DOM. This approach requires careful handling of character encoding. The bootstrap page is now encoded in \u003ccode\u003ewindows-1252\u003c/code\u003e, which allows data to be read from the DOM with minimum degradation. Some encoding challenges emerge:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eDOM text content gets decoded to \u003ccode\u003eUTF-16\u003c/code\u003e instead of \u003ccode\u003ewindows-1252\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eThe \u003ccode\u003eNULL\u003c/code\u003e character (\u003ccode\u003eU+0000\u003c/code\u003e) gets decoded to the replacement character (\u003ccode\u003eU+FFFD\u003c/code\u003e)\u003c/li\u003e\n  \u003cli\u003eCarriage returns (\u003ccode\u003e\\r\u003c/code\u003e) and carriage return + line feeds (\u003ccode\u003e\\r\\n\u003c/code\u003e) get decoded to line feeds (\u003ccode\u003e\\n\u003c/code\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe first 2 points can be fixed by using an association table to convert characters to \u003ccode\u003ewindows-1252\u003c/code\u003e. For the last point, “consolidation data” in a JSON script tag is added in the bootstrap page. This data tracks the offsets of carriage returns and carriage return + line feeds, and enables accurate reconstruction of the original content when extracting the ZIP data.\u003c/p\u003e\n\n\u003cp\u003eHere is the resulting structure:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e\u0026lt;!doctype html\u0026gt;\u003c/span\u003e\n\u003cspan\u003e\u0026lt;html\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;head\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;meta\u003c/span\u003e \u003cspan\u003echarset=\u003c/span\u003e\u003cspan\u003ewindows-1252\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;title\u0026gt;\u003c/span\u003ePlease wait...\u003cspan\u003e\u0026lt;/title\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;script \u003c/span\u003e\u003cspan\u003esrc=\u003c/span\u003e\u003cspan\u003elib/zip.min.js\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026lt;/script\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/head\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;body\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;p\u0026gt;\u003c/span\u003ePlease wait...\u003cspan\u003e\u0026lt;/p\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;!-- [ZIP data] --\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;script \u003c/span\u003e\u003cspan\u003etext=\u003c/span\u003e\u003cspan\u003eapplication/json\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003econsolidation\u003c/span\u003e \u003cspan\u003edata\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\n    \u003cspan\u003e\u0026lt;script\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;!--\u003c/span\u003e \u003cspan\u003eContent\u003c/span\u003e \u003cspan\u003eof\u003c/span\u003e \u003cspan\u003eassets\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ejs\u003c/span\u003e \u003cspan\u003e--\u0026gt;\u003c/span\u003e\u003cspan\u003e\u0026lt;/script\u0026gt;\u003c/span\u003e\n  \u003cspan\u003e\u0026lt;/body\u0026gt;\u003c/span\u003e\n\u003cspan\u003e\u0026lt;/html\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2 id=\"adding-png-to-the-mix\"\u003eAdding PNG to the Mix\u003c/h2\u003e\n\n\u003cp\u003eThe PNG format consists of a signature followed by chunks. Each chunk contains these fieds:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eLength (4 bytes)\u003c/li\u003e\n  \u003cli\u003eType identifier (4 bytes) e.g., \u003ccode\u003eIHDR\u003c/code\u003e (header), \u003ccode\u003eIDAT\u003c/code\u003e (data), \u003ccode\u003eIEND\u003c/code\u003e (end of file), \u003ccode\u003etEXt\u003c/code\u003e (custom data)…\u003c/li\u003e\n  \u003cli\u003eData content (n bytes)\u003c/li\u003e\n  \u003cli\u003eCRC32 checksum (4 bytes)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHere is the minimum structure of a PNG file:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003ePNG signature (8 bytes)\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eIHDR\u003c/code\u003e chunk (13 bytes)\u003c/li\u003e\n  \u003cli\u003eOne or more \u003ccode\u003eIDAT\u003c/code\u003e chunks\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003eIEND\u003c/code\u003e chunk (12 bytes)\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"the-final-form-htmlzippng-polyglot-files\"\u003eThe Final Form: HTML/ZIP/PNG Polyglot Files\u003c/h2\u003e\n\n\u003cp\u003eThe ultimate implementation combines all three formats into a single file. The HTML format’s fault tolerance allows for this complex structure. However, this approach introduces new challenges:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003eThe signature, the \u003ccode\u003eIHDR\u003c/code\u003e and the \u003ccode\u003eIEND\u003c/code\u003e chunks become visible as text nodes briefly and should be removed as soon as the page is parsed\u003c/li\u003e\n  \u003cli\u003eThe displayed page is rendered in quirks mode, requiring specific handling through \u003ccode\u003edocument.write()\u003c/code\u003e and related methods to parse the displayed page\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eHere is the resulting structure viewed as PNG chunks:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e[PNG signature]\n[IHDR chunk]\n[tEXt chunk\n  \u0026lt;!doctype html\u0026gt;\n  \u0026lt;html\u0026gt;\n    \u0026lt;head\u0026gt;\n      \u0026lt;meta charset=windows-1252\u0026gt;\n      \u0026lt;title\u0026gt;Please wait...\u0026lt;/title\u0026gt;\n      \u0026lt;script src=lib/zip.min.js\u0026gt;\u0026lt;/script\u0026gt;\n    \u0026lt;/head\u0026gt;\n    \u0026lt;body\u0026gt;\n      \u0026lt;p\u0026gt;Please wait...\u0026lt;/p\u0026gt;\n      \u0026lt;!-- \n]\n[IDAT chunk(s)]\n[tEXt chunk\n      --\u0026gt;\n      \u0026lt;!-- [ZIP data] --\u0026gt;\n      \u0026lt;script text=application/json\u0026gt;\n      [consolidation data]\n      \u0026lt;/script\u0026gt;\n      \u0026lt;script\u0026gt;\u0026lt;!-- Content of assets/main.js --\u0026gt;\u0026lt;/script\u0026gt;\n    \u0026lt;/body\u0026gt;\n  \u0026lt;/html\u0026gt;\n]\n[IEND chunk]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\n\u003ch2 id=\"optimization-through-image-reuse\"\u003eOptimization Through Image Reuse\u003c/h2\u003e\n\n\u003cp\u003eThe final optimization removes the main image (i.e. the logo of RennesJS) from the ZIP file and reuses the page, interpreted as a PNG file, to replace it in the displayed page.\u003c/p\u003e\n\n\u003ch2 id=\"resulting-file\"\u003eResulting File\u003c/h2\u003e\n\n\u003cp\u003eDownload \u003ca href=\"https://github.com/gildas-lormeau/Polyglot-HTML-ZIP-PNG/raw/main/demo.png.zip.html\"\u003edemo.png.zip.html\u003c/a\u003e (a bug in “Archive Utility” on macOS prevents it from decompressing the resulting file, you can use unzip to get around this issue).\u003c/p\u003e\n\n\n      \n      \n      \n    \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": null,
  "modifiedTime": null
}
