{
  "id": "4a5afc4f-aca0-439d-a5bd-eaa422f560ba",
  "title": "The Physics of Magic Windows (2021)",
  "link": "https://mattferraro.dev/posts/caustics-engineering",
  "description": "Article URL: https://mattferraro.dev/posts/caustics-engineering Comments URL: https://news.ycombinator.com/item?id=41842775 Points: 21 # Comments: 2",
  "author": "mhb",
  "published": "Mon, 14 Oct 2024 22:25:47 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 21840,
  "excerpt": "I recently made a physical object that defies all intuition. It's a square of acrylic, smooth on both sides, totally transparent...",
  "siteName": "",
  "favicon": "",
  "text": "August 18, 2021I recently made a physical object that defies all intuition. It's a square of acrylic, smooth on both sides, totally transparent. A tiny window.But it has the magic property that if you shine a flashlight on it, it forms an image:And if you take it out in the sun, it produces this 3D hologram:This post describes the math that went into making the object, and how you can create your own.But first: How is this even possible?Let's focus on the 2D image before talking about the hologram.The physical phenomenon we're looking at is called a caustic.Caustics are the bright patches of light we see when illuminating a transparent object. All the photons that don't pass directly through the object are what form the object's shadow. All those photons still have to go somewhere; they contribute to the caustic pattern.The most interesting aspect of caustics is that they arise from even the tiniest of variations in surface flatness. Even the gentlest waves on the surface of a pool form powerful lenses that cast intense caustics on the floor below.The reason my acrylic square can form an image is because I've distributed just the right amount of concavity and convexity into the surface so that the refracted light forms a caustic image.To gain some intuition for how it is done, consider a traditional convex lens:This lens forms the simplest possible caustic. If all the incoming light is from a single, very distant light source like the Sun, this lens focuses all of its incoming light into a single point. The caustic image from this lens is dark everywhere with one very bright spot in the center.Zooming in on one small section of the lens we notice a few properties:The overall thickness of the lens does not have a direct impact on the outgoing ray angle. We could add material to the left side of this lens and nothing would change. The first transition, from air to glass, can be entirely ignored.The angle between the incoming light rays and the glass-air boundary has a strong effect on the refracted ray angle.Whether two rays converge or diverge is controlled by how curved the lens is where the glass meets the airIn other words, the height of the glass h(x) is not on its own important. But the slope of the glass, \\frac{\\mathrm{d}h}{\\mathrm{d}x}, gives us the outgoing ray angle via Snell's law. Where rays converge the image is brighter than the light source. Where rays diverge the image is darker. Therefore the brightness of the image (at that point, where the rays fall) is related to \\frac{\\mathrm{d}^2h}{\\mathrm{d}x^2}.The thickness of my acrylic slab varies across the entire xy plane, so I'll call it h(x,y) and we'll think of it as a heightmap.By controlling \\nabla h = (\\frac{\\partial h}{\\partial x}, \\frac{\\partial h}{\\partial y}), and \\nabla ^2 h = (\\frac{\\partial ^2 h}{\\partial x^2} + \\frac{\\partial ^2 h}{\\partial y^2}), we can steer all of our incoming light to the correct locations in the image, while contributing the right brightness to make it recognizable. By making some simplifying assumptions we can guarantee that the resulting heightmap will be smooth and continuous.For the Magic Window shown above, the total height variation over the 10cm \\times 10cm surface is about 2.0mm.See how the slight variations in surface height distort the straight line of the floor moulding? Our Magic Window works like any other lens—by bending light.Table of ContentsFormulating the ProblemSteps to a SolutionMorphing the CellsComputing the LossStepping to Reduce LossSnell's Law and Normal VectorsFinding the HeightmapManufacturingAcknowledgementsMy CodeLicensingContact meOne Last ThingFormulating the ProblemWe want to find a heightmap h(x,y) whose caustic image has brightness b(u,v), equal to some input image. To achieve this we can imagine a grid of cells, akin to pixels, on the surface of the acrylic lens. Here each \"pixel\" on the lens corresponds to a pixel in the image. Image pixels and their corresponding lens-space \"pixels\" are labeled with shared (i, j) coordinates.Remember that (i, j) are integers labeling the column and row of the pixel, whereas (x, y) and (u, v) are real numbers measured in something like meters or inches.Steps to a SolutionStep 1: We morph the cells on the lens, making them bigger or smaller, so that the area of lens cell (i, j) is proportional to the brightness of image cell (i, j). The resulting lens grid is no longer square—lots of warping and skew have to be introduced to maintain continuity. This step is by far the hardest part and must be solved iteratively.Step 2: For each cell (i, j) we need to find the angle from the lens cell to image cell and use Snell's law to find the required surface normal. This step is straightforward geometry.Step 3: Integrate all the surface normals to find a continuous heightmap h(x,y). We're back to iterative methods here, but if we apply certain contraints to how we solve step 1, this step is actually fast and easy.Morphing the CellsFor an image with n \\times n pixels, the lens grid will need (n+1) \\times (n+1) points, so that each cell in the lens grid is defined by four points. Technically we should adopt yet another coordinate system to label the points in the lens grid since they are distinct from the cells in the lens grid, but I think it's easier to just reuse (i, j) and we can say that for grid cell (i, j), the point in the upper left is defined as grid point (i, j).This leaves us with one row and one column of extra grid points along the bottom and right edges, but that will be trivial to deal with when it comes up.Each point in the lens grid (i,j) has an (x, y) coordinate. A point's (i, j) coordinates never change but the (x, y) coordinates will change as we morph the cells more and more.Computing the LossGiven the (x, y) locations of all the lens grid points, simple geometry lets us calculate the area of each lens grid cell. Of course at first every cell has the same area, but that will change as soon as we start morphing things.The condition we want is that every lens grid cell (i, j) has an area which scales with the brightness of image pixel b(i, j).Area and brightness are not compatible units so it is helpful to normalize cell area by the full window area, and pixel brightness by total image brightness, so that each is measured in a unitless \"percentage\".\\tag{1.0} \\frac{A_{ij}}{\\Sigma A} = \\frac{b_{ij}}{\\Sigma b}Intuitively, this means:If a single pixel contributes x\\% of the brightness of the entire image, the corresponding window cell should take up x\\% of the area of the entire window.Equation (1.0) is the goal, but it will not be not be true until after we've morphed the window grid. Until we've done that, we need to compute a loss function which tells us how badly we're missing our target. Something like:\\tag{1.1} L = \\frac{b_{ij}}{\\Sigma b} - \\frac{A_{ij}}{\\Sigma A}In code:# In Julia-flavored psuedocode img = read_image(\"cat.png\") brightness = convert_to_grayscale(img) total_brightness = sum(brightness) brightness = brightness ./ total_brightness w = .1 # meters h = .1 # meters area_total = w * h loss = compute_pixel_area(grid) ./ area_total - brightness Where I've colorized the loss function so that red areas indicate regions where our grid cells need to grow and blue regions indicate where our grid cells need to shrink.This image is the loss function L and I'll refer to it a lot. Stepping to Reduce LossThe loss image can be thought of as a scalar field L(x, y). The gradient of a scalar field yields a vector field, which we could call \\nabla L(x,y). We can step each grid point slowly in the direction of the gradient field, and in doing so the cells that are too small will get bigger and the cells that are too big will get smaller. Our loss will shrink, and we'll create our image!The first thing to do is compute \\nabla L and look at the vector field:Crap.\\nabla L is a very poorly behaved vector field. It is noisy, discontinuous, and in many places equal to zero.Almost everywhere, neighboring points need to step in drastically different directions. This creates a situation where improving one cell's loss will necessarily worsen its neighbor's losses, which means that in practice this method can never converge. It's a dead end.Instead let's draw an analogy to Computational Fluid Dynamics. We need to dilate certain cells and shrink others according to a brightness function. This is similar to modeling compressible air flow where each cell has pressure defined as a pressure function.If every cell in a 2D grid has some initial pressure, how does the system relax over time? The regions with high pressure expand and the regions of low pressure contract, with regions of middling pressure getting shoved around in a sort of global tug-of-war. Clearly, our problem is analogous.So, how is this problem solved in CFD simulations? A standard approach is to define a Velocity Potential called \\Phi (read: phi). The Velocity Potential \\Phi is a scalar field defined at each cell. Its units are meters^2 / second which at first glance is not very easy to interpret. But the reason \\Phi is convenient is that its spatial derivatives are measured in meters/second. In other words, the gradient of \\Phi gives a vector whose units are velocity:\\tag{1.2} \\nabla \\Phi = \\left( \\frac{\\partial{\\Phi}}{\\partial{x}}, \\frac{\\partial{\\Phi}}{\\partial{y}} \\right) = \\vec{v}Here is an example \\Phi. It is just some scalar field best viewed as a heightmap.And here is the gradient of that same \\Phi. These vectors are velocity vectors that point uphill. If we were performing Computational Fluid Dynamics, these vectors would indicate how fluid might flow from regions of high pressure to regions of low pressure. Notice how well behaved this vector field is! There is gentle variation across the field but any two neighbors are very similar to each other. None of the arrows pierce the boundary.In our case we don't have fluid pressure, we have light pressure. Regions in our image which are too bright have high light pressure, which is quantified in our loss function L.If we can somehow use L to find a \\Phi that describes our light pressure distribution, all we need to do is calculate \\vec{v} = \\nabla \\Phi and we'll be able to morph all of our lens grid points according to \\vec{v} to decrease our loss!So how do we find a suitable \\Phi? Well, the property we know about each cell is its loss, which encodes how much that cell needs to grow or shrink. This property, how much a cell grows or shrinks over time as it moves with a velocity field, is called the divergence of that field.Divergence is written as \\nabla \\cdot, so in our case, we know that we need to find a velocity field \\vec{v} whose divergence equals the loss:\\tag{1.3} \\nabla \\cdot \\vec{v} = L(x, y)Unfortunately there is no \"inverse divergence\" operator so we cannot easily invert this equation to find \\vec{v} directly. But we can plug equation (1.2) in to equation (1.3) to yield:\\tag{1.4} \\nabla \\cdot \\nabla \\Phi = L(x, y)Which we read as The divergence of the gradient of the potential field \\Phi equals the loss.This equation comes up surprisingly frequently in many branches of physics and math. It is usually written in a more convenient shorthand:\\tag{1.5} \\nabla ^2 \\Phi = LWhich you may recognize as Poisson's Equation!This is fantastic news because Poisson's equation is extremely easy to solve! If you aren't familiar with it, just think of this step like inverting a big matrix, or numerically integrating an ODE, or finding the square root of a real number. It's an intricate, tedious task that would be painful to do with a paper and pencil, but it's the kind of thing computers are really good at.Now that we've written down the problem as Poisson's Equation, it is as good as solved. We can use any off the shelf solver, plug in our known L(x, y) using Neumann boundary conditions and boom, and out pops \\Phi(x,y) as if by magic.Can you figure out why the cat appears so clearly in this 3D rendering of \\Phi? What controls the brightness of each pixel in a render like this?We plug \\Phi in to Equation (1.2) to find \\vec{v} and we take a look at the vector field:Disappointingly, it does not look like a kitty to me.And technically we need to march our points in the direction of negative \\nabla L if we want to decrease L. Here's -\\nabla L:But the good news is that this vector field is smooth and well-behaved. We simply march the grid points along this vector field and we'll get exactly what we need. If you squint you can almost see how the bright background will expand and the cat's dark fur will shrink.We step all the lens grid points forward some small amount in the direction of -\\vec{v}. After morphing the grid a tiny amount we recompute the loss function L, find a new \\Phi and new -\\vec{v}, and take another small step.# In Julia-flavored psuedocode image = read_image(\"cat.png\") gray = convert_to_grayscale(image) grid = create_initial_grid(gray.size + 1) L = compute_loss(gray, grid) while max(L) \u003e 0.01 ϕ = poisson_solver(L, \"neumann\", 0) v = compute_gradient(ϕ) grid = step_grid(grid, -v) L = compute_loss(gray, grid) end After three or four iterations the loss gets very small and we've got our morphed cells!Look at how this cat's chin ballooned out but her nose and forehead shrunk. Her left ear is noticably longer and thinner because the bright background had to grow to take up more light. Her pupils went from oblong to sharp.Note that image on the right is just a screenshot of Fusion360's default mesh rendering with the wireframe turned on:The reason it is darker in some areas is because the mesh is more tightly packed in those areas. Let's zoom in on the eye:Look at how detailed that is! We've managed to capture even the bright reflections in her eyes. Zooming in further to just the pupil:We can see the fine structure of the grid cells. Our formulation of the problem is only concerned with cells as quadralaterals. The triangles you see are just an artifact of converting our quadralateral grid into a triangle mesh more suitable for other software to deal with.So again, in summary:If we follow these steps we will successfully morph our grid points. Now we've got to do some geometry!Snell's Law and Normal VectorsSnell's law tells us how light bends when passing from one material to another. \\tag{2.0} \\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} = \\frac{n_1}{n_2}Where n_1 = 1.49 is the Refractive Index of acrylic and n_2 = 1 is the refractive index of air. If we know \\theta_2, Snell's Law gives us \\theta_1.Snell's law is not some arbitrary axiom of physics. It is a direct consequence of Fermat's Principle of Least Time, which is a fascinating and critical link between ray optics and wave optics. But that's a topic for another day.In our case, each lens cell (i, j) has migrated to position (x, y), and it needs to send its light to the image plane at (u, v), which sits some distance away d.We start by defining a 3D normal vector \\vec{N}(x, y) which everywhere points normal to our heightmap h(x, y).Normal vectors always point perpendicular to the surface they start on. They generally encode meaning in their direction, not their length, so we're free to scale them to any length that is convenient for our purposes. Very often people choose to make their Normal vectors of length 1.But if we normalize \\vec{N} so that its z coordinate is -1, we can write it:\\tag{2.1} \\vec{N} = (\\frac{\\partial{h}}{\\partial{x}}, \\frac{\\partial{h}}{\\partial{y}}, -1)If you consider just the x and y components, we recognize that\\tag{2.2} \\vec{N}_{xy} = \\nabla hWhich is a property often used in computer graphics applications, as well as geospatial applications involving Digital Elevation Models.Using Snell's Law, a small angle approximation, and a lot of tedious geometry, we find the x and y components of the normal vector \\vec{N}:\\tag{2.3} N_x(i, j) = \\tan \\frac{\\tan^{-1} \\left( \\frac{u - x} {d} \\right)} {(n_1 - n_2)}\\tag{2.4} N_y(i, j) = \\tan \\frac{\\tan^{-1} \\left( \\frac{v - y} {d} \\right)} {(n_1 - n_2)}There is nothing interesting about this derivation so I've skipped it here.Finding the HeightmapAt this point we have our morphed grid cells and we've found all our surface normals. All we have to do is find a heightmap h(x,y) that has the required surface normals.Unfortunately, this is not a problem that is solvable in the general case.We could try to integrate the normals manually, starting at one corner and working our way down the grid, but this method does not usually result in a physically realizable object. If the integral of the normals running left to right pulls your surface up, but the integral of the normals running top to bottom pulls your surface down, there is just no solution that results in a solid, unbroken surface.A much better approach is to reach back to equation (2.2), repeated here:\\tag{2.2} \\vec{N}_{xy} = \\nabla hAnd to take the divergence of both sides:\\tag{2.5} \\nabla \\cdot \\vec{N}_{xy} = \\nabla \\cdot \\nabla hDo you recognize the form of this equation? Adopting shorthand and swapping sides:\\tag{2.6} \\nabla ^2 h = \\nabla \\cdot \\vec{N}_{xy}We arrive at yet another instance of Poisson's Equation! We found \\vec{N}_{xy} in the previous section, and calculating the divergence of a known vector field is easy:\\tag{2.7} \\nabla \\cdot \\vec{N}_{xy} = \\left( \\frac{\\partial}{\\partial{x}}, \\frac{\\partial}{\\partial{y}} \\right) \\cdot (\\vec{N}_x, \\vec{N}_y) = \\frac{\\partial{\\vec{N}_x}}{\\partial{x}} + \\frac{\\partial{\\vec{N}_y}}{\\partial{y}}In code it looks like:δx = (Nx[i+1, j] - Nx[i, j]) δy = (Ny[i, j+1] - Ny[i, j]) divergence[i, j] = δx + δy All that's left is to plug our known \\nabla \\cdot \\vec{N}_{xy} in to a Poisson solver with Neumann boundary conditions and out pops h(x, y), ready to use!Well, there's one thing left to improve. By modifying the height of each point we've actually changed the distance from each lens point to the image, so the lens-image distance is no longer a constant d it is actually a function D(x,y). With our heightmap in hand we can easily calculate:\\tag{2.8} D(x,y) = d - h(x,y)And repeat the process by calculating new normals using D(x,y) instead of d, which lets us create a new heightmap.We can loop this process and measure changes to ensure convergence, but in practice just 2 or 3 iterations is all you need:# In Julia-flavored psuedocode d = .2 # meters D = d .* array_of_ones(n, n) for i in 1:3 Nx, Ny = compute_normals(grid, D) divergence = compute_divergence(Nx, Ny) h = poisson_solver(divergence, \"neumann\", 0) D = copy(h) end The resulting heightmap can be converted to a solid object by adopting a triangular grid and closing off the back surface.Note that the image looks mirrored when looking at it head on. That's because the heightmap forms the back surface of the Magic Window. The front surface is factory flat.The height differences are subtle but certainly enough to get the job done.ManufacturingThe process of manufacturing our Magic Window is identical to carving any other 2.5D object.We bring our object into Fusion360 or any other CAM software. We set up a roughing toolpath left to right, and a finishing toolpath top to bottom just like you find in most tutorials.Any old CNC router or mill will work. I designed and built my own router last year. If you want to do the same I recommend you start here.I used a \\frac{1}{4} inch diameter, ball-nosed, carbide bit for both roughing and finishing passes, which took 10 minutes and 90 minutes respectively.After carving the surface finish is rough and transluscent. We need to wet sand using 200, 400, 600, 1000 and 1500 grit sandpapers, then finish with a soft rag and some automotive polish. Sanding and polishing takes about half an hour for a 10 cm \\times 10 cm Magic Window.AcknowledgementsAll of the math for this post came from Poisson-Based Continuous Surface Generation for Goal-Based Caustics, a phenomenal 2014 paper by Yue et al. If you continue this work in some way, please cite them.My CodeMy source code is available here. I am a novice at programming in Julia so if you have suggestions for how to improve this code, please reach out or make a pull request!Caveats: There are a lot of issues with my code. I confuse x and y in several places. I have extra negative signs that I inserted that make the code work but I don't know why. My units and notation are inconsistent throughout. The original paper suggests a better way of calculating loss but I didn't implement it because the naive way was easier, yet I rolled my own mesh utilities and Poisson solver because I enjoyed the challenge.In short: To me this code is a fun side project. If you want to build a business off of this code you should probably hire someone who knows how to program professionally in Julia.LicensingI've posted all my code under the MIT license. Please feel free to use this code for anything you want, including hobbyist, educational, and commercial uses. I only ask that if you make something, please show me!Except where otherwise attributed, all images in this blog post and the blog post itself are my own work that I license as CC-BY.The cat in this post is named Mitski and she approves of you using her image as the new standard reference image for image processing papers. It's time to let Lenna retire.If you use my code to make your own Magic Windows, I'd love to see them! I'm on Twitter at @mferraro89. Email me at mattferraro.dev@gmail.com and I will gladly help if you get stuck!One Last ThingI know what you're thinking. What about the hologram?!Does the math above imply that a hologram will always be created, or is this one cat hologram just an incredible coincidence?Well you see, I've discovered a truly marvelous proof of this, which this website's margin is unfortunately too narrow to contain :)",
  "image": "https://mattferraro.dev/images/caustics-engineering/2D_image.jpg",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003carticle\u003e\u003cp\u003e\u003ctime datetime=\"2021-08-18\"\u003eAugust 18, 2021\u003c/time\u003e\u003c/p\u003e\u003cp\u003eI recently made a physical object that defies all intuition. It\u0026#39;s a square of acrylic, smooth on both sides, totally transparent. A tiny window.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Clear Acrylic\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwindow_clear.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eBut it has the magic property that if you shine a flashlight on it, it forms an image:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"2D Image of Cat\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2F2D_image.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAnd if you take it out in the sun, it produces this 3D hologram:\u003c/p\u003e\u003cvideo width=\"100%\" height=\"auto\" autoplay=\"\" muted=\"\" controls=\"\" loop=\"\"\u003e\u003csource src=\"https://mattferraro.dev/images/caustics-engineering/3dcat.mp4\" type=\"video/mp4\"/\u003e\u003c/video\u003e\u003cp\u003eThis post describes the math that went into making the object, and how you can create your own.\u003c/p\u003e\u003ch2 id=\"but-first-how-is-this-even-possible\"\u003eBut first: How is this even possible?\u003c/h2\u003e\u003cp\u003eLet\u0026#39;s focus on the 2D image before talking about the hologram.\u003c/p\u003e\u003cp\u003eThe physical phenomenon we\u0026#39;re looking at is called a \u003cem\u003ecaustic\u003c/em\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Example Caustic\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fglass_caustic_pd.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eCaustics are the bright patches of light we see when illuminating a transparent object. All the photons that don\u0026#39;t pass directly through the object are what form the object\u0026#39;s shadow. All those photons still have to go somewhere; they contribute to the caustic pattern.\u003c/p\u003e\u003cp\u003eThe most interesting aspect of caustics is that they arise from even the tiniest of variations in surface flatness. Even the gentlest waves on the surface of a pool form powerful lenses that cast intense caustics on the floor below.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Water Caustics\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fwater_caustics_cc.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe reason my acrylic square can form an image is because I\u0026#39;ve distributed just the right amount of concavity and convexity into the surface so that the refracted light forms a caustic image.\u003c/p\u003e\u003cp\u003eTo gain some intuition for how it is done, consider a traditional convex lens:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Parabolic Lens\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ftraditional_lens_2.svg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ftraditional_lens_2.svg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ftraditional_lens_2.svg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis lens forms the simplest possible caustic. If all the incoming light is from a single, very distant light source like the Sun, this lens focuses all of its incoming light into a single point. The caustic image from this lens is dark everywhere with one very bright spot in the center.\u003c/p\u003e\u003cp\u003eZooming in on one small section of the lens we notice a few properties:\u003c/p\u003e\u003col\u003e\u003cli\u003eThe overall thickness of the lens does not have a direct impact on the outgoing ray angle. We could add material to the left side of this lens and nothing would change. The first transition, from air to glass, can be entirely ignored.\u003c/li\u003e\u003cli\u003eThe angle between the incoming light rays and the glass-air boundary has a strong effect on the refracted ray angle.\u003c/li\u003e\u003cli\u003eWhether two rays converge or diverge is controlled by how \u003cem\u003ecurved\u003c/em\u003e the lens is where the glass meets the air\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eIn other words, the height of the glass \u003cspan\u003eh(x)\u003c/span\u003e is not on its own important. But the slope of the glass, \u003cspan\u003e\\frac{\\mathrm{d}h}{\\mathrm{d}x}\u003c/span\u003e, gives us the outgoing ray angle via Snell\u0026#39;s law. Where rays converge the image is brighter than the light source. Where rays diverge the image is darker. Therefore the brightness of the image (at that point, where the rays fall) is related to \u003cspan\u003e\\frac{\\mathrm{d}^2h}{\\mathrm{d}x^2}\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eThe thickness of my acrylic slab varies across the entire \u003cspan\u003exy\u003c/span\u003e plane, so I\u0026#39;ll call it \u003cspan\u003eh(x,y)\u003c/span\u003e and we\u0026#39;ll think of it as a \u003cstrong\u003eheightmap\u003c/strong\u003e.\u003c/p\u003e\u003cp\u003eBy controlling \u003cspan\u003e\\nabla h = (\\frac{\\partial h}{\\partial x}, \\frac{\\partial h}{\\partial y}\u003c/span\u003e), and \u003cspan\u003e\\nabla ^2 h = (\\frac{\\partial ^2 h}{\\partial x^2} + \\frac{\\partial ^2 h}{\\partial y^2})\u003c/span\u003e, we can steer all of our incoming light to the correct locations in the image, while contributing the right brightness to make it recognizable. By making some simplifying assumptions we can guarantee that the resulting heightmap will be smooth and continuous.\u003c/p\u003e\u003cp\u003eFor the Magic Window shown above, the total height variation over the \u003cspan\u003e10cm \\times 10cm\u003c/span\u003e surface is about \u003cspan\u003e2.0mm\u003c/span\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Slight Refraction\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fslight_refraction.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fslight_refraction.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fslight_refraction.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eSee how the slight variations in surface height distort the straight line of the floor moulding? Our Magic Window works like any other lens—by bending light.\u003c/p\u003e\u003ch2 id=\"table-of-contents\"\u003eTable of Contents\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#formulating-the-problem\"\u003eFormulating the Problem\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#steps-to-a-solution\"\u003eSteps to a Solution\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#morphing-the-cells\"\u003eMorphing the Cells\u003c/a\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#computing-the-loss\"\u003eComputing the Loss\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#stepping-to-reduce-loss\"\u003eStepping to Reduce Loss\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#snells-law-and-normal-vectors\"\u003eSnell\u0026#39;s Law and Normal Vectors\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#finding-the-heightmap\"\u003eFinding the Heightmap\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#manufacturing\"\u003eManufacturing\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#acknowledgements\"\u003eAcknowledgements\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#my-code\"\u003eMy Code\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#licensing\"\u003eLicensing\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#contact-me\"\u003eContact me\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#one-last-thing\"\u003eOne Last Thing\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"formulating-the-problem\"\u003eFormulating the Problem\u003c/h2\u003e\u003cp\u003eWe want to find a heightmap \u003cspan\u003eh(x,y)\u003c/span\u003e whose caustic image has brightness \u003cspan\u003eb(u,v)\u003c/span\u003e, equal to some input image. To achieve this we can imagine a grid of cells, akin to pixels, on the surface of the acrylic lens. Here each \u0026#34;pixel\u0026#34; on the lens corresponds to a pixel in the image. Image pixels and their corresponding lens-space \u0026#34;pixels\u0026#34; are labeled with shared \u003cspan\u003e(i, j)\u003c/span\u003e coordinates.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Diagram\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram.png\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram.png\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram.png\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eRemember that \u003cspan\u003e(i, j)\u003c/span\u003e are integers labeling the column and row of the pixel, whereas \u003cspan\u003e(x, y)\u003c/span\u003e and \u003cspan\u003e(u, v)\u003c/span\u003e are real numbers measured in something like meters or inches.\u003c/p\u003e\u003ch2 id=\"steps-to-a-solution\"\u003eSteps to a Solution\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003eStep 1:\u003c/strong\u003e We morph the cells on the lens, making them bigger or smaller, so that the area of lens cell \u003cspan\u003e(i, j)\u003c/span\u003e is proportional to the brightness of image cell \u003cspan\u003e(i, j)\u003c/span\u003e. The resulting lens grid is no longer square—lots of warping and skew have to be introduced to maintain continuity. This step is by far the hardest part and must be solved iteratively.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStep 2:\u003c/strong\u003e For each cell \u003cspan\u003e(i, j)\u003c/span\u003e we need to find the angle from the lens cell to image cell and use Snell\u0026#39;s law to find the required surface normal. This step is straightforward geometry.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStep 3:\u003c/strong\u003e Integrate all the surface normals to find a continuous heightmap \u003cspan\u003eh(x,y)\u003c/span\u003e. We\u0026#39;re back to iterative methods here, but if we apply certain contraints to how we solve step 1, this step is actually fast and easy.\u003c/p\u003e\u003ch2 id=\"morphing-the-cells\"\u003eMorphing the Cells\u003c/h2\u003e\u003cp\u003eFor an image with \u003cspan\u003en \\times n\u003c/span\u003e pixels, the lens grid will need \u003cspan\u003e(n+1) \\times (n+1)\u003c/span\u003e points, so that each cell in the lens grid is defined by four points. Technically we should adopt yet another coordinate system to label the \u003cem\u003epoints\u003c/em\u003e in the lens grid since they are distinct from the \u003cem\u003ecells\u003c/em\u003e in the lens grid, but I think it\u0026#39;s easier to just reuse \u003cspan\u003e(i, j)\u003c/span\u003e and we can say that for grid cell \u003cspan\u003e(i, j)\u003c/span\u003e, the point in the upper left is defined as grid point \u003cspan\u003e(i, j)\u003c/span\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Diagram 2\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram2.png\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram2.png\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fdiagram2.png\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis leaves us with one row and one column of extra grid points along the bottom and right edges, but that will be trivial to deal with when it comes up.\u003c/p\u003e\u003cp\u003eEach \u003cem\u003epoint\u003c/em\u003e in the lens grid \u003cspan\u003e(i,j)\u003c/span\u003e has an \u003cspan\u003e(x, y)\u003c/span\u003e coordinate. A point\u0026#39;s \u003cspan\u003e(i, j)\u003c/span\u003e coordinates never change but the \u003cspan\u003e(x, y)\u003c/span\u003e coordinates will change as we morph the cells more and more.\u003c/p\u003e\u003ch2 id=\"computing-the-loss\"\u003eComputing the Loss\u003c/h2\u003e\u003cp\u003eGiven the \u003cspan\u003e(x, y)\u003c/span\u003e locations of all the lens grid points, simple geometry lets us calculate the area of each lens grid cell. Of course at first every cell has the same area, but that will change as soon as we start morphing things.\u003c/p\u003e\u003cp\u003eThe condition we want is that every lens grid \u003cem\u003ecell\u003c/em\u003e \u003cspan\u003e(i, j)\u003c/span\u003e has an \u003cem\u003earea\u003c/em\u003e which scales with the \u003cem\u003ebrightness\u003c/em\u003e of image pixel \u003cspan\u003eb(i, j)\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eArea and brightness are not compatible units so it is helpful to normalize cell area by the full window area, and pixel brightness by total image brightness, so that each is measured in a unitless \u0026#34;percentage\u0026#34;.\u003c/p\u003e\u003cp\u003e\\tag{1.0}\n\\frac{A_{ij}}{\\Sigma A} = \\frac{b_{ij}}{\\Sigma b}\u003c/p\u003e\u003cp\u003eIntuitively, this means:\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eIf a single pixel contributes \u003cspan\u003ex\\%\u003c/span\u003e of the brightness of the entire image, the corresponding window cell should take up \u003cspan\u003ex\\%\u003c/span\u003e of the area of the entire window.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eEquation \u003cspan\u003e(1.0)\u003c/span\u003e is the goal, but it will not be not be true until after we\u0026#39;ve morphed the window grid. Until we\u0026#39;ve done that, we need to compute a loss function which tells us how badly we\u0026#39;re missing our target. Something like:\u003c/p\u003e\u003cp\u003e\\tag{1.1}\nL = \\frac{b_{ij}}{\\Sigma b} - \\frac{A_{ij}}{\\Sigma A}\u003c/p\u003e\u003cp\u003eIn code:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# In Julia-flavored psuedocode\u003c/span\u003e\nimg \u003cspan\u003e=\u003c/span\u003e read_image\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cat.png\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\nbrightness \u003cspan\u003e=\u003c/span\u003e convert_to_grayscale\u003cspan\u003e(\u003c/span\u003eimg\u003cspan\u003e)\u003c/span\u003e\ntotal_brightness \u003cspan\u003e=\u003c/span\u003e sum\u003cspan\u003e(\u003c/span\u003ebrightness\u003cspan\u003e)\u003c/span\u003e\nbrightness \u003cspan\u003e=\u003c/span\u003e brightness \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e total_brightness\n\nw \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.1\u003c/span\u003e \u003cspan\u003e# meters\u003c/span\u003e\nh \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.1\u003c/span\u003e \u003cspan\u003e# meters\u003c/span\u003e\narea_total \u003cspan\u003e=\u003c/span\u003e w \u003cspan\u003e*\u003c/span\u003e h\nloss \u003cspan\u003e=\u003c/span\u003e compute_pixel_area\u003cspan\u003e(\u003c/span\u003egrid\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e area_total \u003cspan\u003e-\u003c/span\u003e brightness\n\u003c/code\u003e\u003c/pre\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Image and Loss Function\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fimage_and_loss.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fimage_and_loss.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fimage_and_loss.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWhere I\u0026#39;ve colorized the loss function so that red areas indicate regions where our grid cells need to grow and blue regions indicate where our grid cells need to shrink.\u003c/p\u003e\u003cp\u003eThis image is the loss function \u003cspan\u003eL\u003c/span\u003e and I\u0026#39;ll refer to it a lot. \u003c/p\u003e\u003ch2 id=\"stepping-to-reduce-loss\"\u003eStepping to Reduce Loss\u003c/h2\u003e\u003cp\u003eThe loss image can be thought of as a scalar field \u003cspan\u003eL(x, y)\u003c/span\u003e. The gradient of a scalar field yields a vector field, which we could call \u003cspan\u003e\\nabla L(x,y)\u003c/span\u003e. We can step each grid point slowly in the direction of the gradient field, and in doing so the cells that are too small will get bigger and the cells that are too big will get smaller. Our loss will shrink, and we\u0026#39;ll create our image!\u003c/p\u003e\u003cp\u003eThe first thing to do is compute \u003cspan\u003e\\nabla L\u003c/span\u003e and look at the vector field:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Gradient of L as a vector field\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fgrad_L.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fgrad_L.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fgrad_L.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eCrap.\u003c/p\u003e\u003cp\u003e\u003cspan\u003e\\nabla L\u003c/span\u003e is a very poorly behaved vector field. It is noisy, discontinuous, and in many places equal to zero.\u003c/p\u003e\u003cp\u003eAlmost everywhere, neighboring points need to step in drastically different directions. This creates a situation where improving one cell\u0026#39;s loss will necessarily worsen its neighbor\u0026#39;s losses, which means that in practice this method can never converge. It\u0026#39;s a dead end.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eInstead let\u0026#39;s draw an analogy to Computational Fluid Dynamics. We need to dilate certain cells and shrink others according to a brightness function. This is similar to modeling compressible air flow where each cell has pressure defined as a pressure function.\u003c/p\u003e\u003cp\u003eIf every cell in a 2D grid has some initial pressure, how does the system relax over time? The regions with high pressure expand and the regions of low pressure contract, with regions of middling pressure getting shoved around in a sort of global tug-of-war. Clearly, our problem is analogous.\u003c/p\u003e\u003cp\u003eSo, how is this problem solved in CFD simulations? A standard approach is to define a \u003cstrong\u003eVelocity Potential\u003c/strong\u003e called \u003cspan\u003e\\Phi\u003c/span\u003e (read: \u003cem\u003ephi\u003c/em\u003e). The Velocity Potential \u003cspan\u003e\\Phi\u003c/span\u003e is a scalar field defined at each cell. Its units are \u003cspan\u003emeters^2 / second\u003c/span\u003e which at first glance is not very easy to interpret. But the reason \u003cspan\u003e\\Phi\u003c/span\u003e is convenient is that its spatial derivatives are measured in \u003cspan\u003emeters/second\u003c/span\u003e. In other words, the gradient of \u003cspan\u003e\\Phi\u003c/span\u003e gives a vector whose units are velocity:\u003c/p\u003e\u003cp\u003e\\tag{1.2}\n\\nabla \\Phi = \\left( \\frac{\\partial{\\Phi}}{\\partial{x}}, \\frac{\\partial{\\Phi}}{\\partial{y}} \\right) = \\vec{v}\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Phi\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_phi.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_phi.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_phi.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eHere is an example \u003cspan\u003e\\Phi\u003c/span\u003e. It is just some scalar field best viewed as a heightmap.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Gradient of Phi\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAnd here is the gradient of that same \u003cspan\u003e\\Phi\u003c/span\u003e. These vectors are velocity vectors that point uphill. If we were performing Computational Fluid Dynamics, these vectors would indicate how fluid might flow from regions of high pressure to regions of low pressure. \u003c/p\u003e\u003cp\u003eNotice how well behaved this vector field is! There is gentle variation across the field but any two neighbors are very similar to each other. None of the arrows pierce the boundary.\u003c/p\u003e\u003cp\u003eIn our case we don\u0026#39;t have fluid pressure, we have light pressure. Regions in our image which are too bright have high light pressure, which is quantified in our loss function \u003cspan\u003eL\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eIf we can somehow use \u003cspan\u003eL\u003c/span\u003e to find a \u003cspan\u003e\\Phi\u003c/span\u003e that describes our light pressure distribution, all we need to do is calculate \u003cspan\u003e\\vec{v} = \\nabla \\Phi\u003c/span\u003e and we\u0026#39;ll be able to morph all of our lens grid points according to \u003cspan\u003e\\vec{v}\u003c/span\u003e to decrease our loss!\u003c/p\u003e\u003cp\u003eSo how do we find a suitable \u003cspan\u003e\\Phi\u003c/span\u003e? Well, the property we know about each cell is its loss, which encodes how much that cell needs to grow or shrink. \u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eThis property, how much a cell grows or shrinks over time as it moves with a velocity field, is called the \u003cstrong\u003edivergence\u003c/strong\u003e of that field.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eDivergence is written as \u003cspan\u003e\\nabla \\cdot\u003c/span\u003e, so in our case, we know that we need to find a velocity field \u003cspan\u003e\\vec{v}\u003c/span\u003e whose divergence equals the loss:\u003c/p\u003e\u003cp\u003e\\tag{1.3}\n\\nabla \\cdot \\vec{v} = L(x, y)\u003c/p\u003e\u003cp\u003eUnfortunately there is no \u0026#34;inverse divergence\u0026#34; operator so we cannot easily invert this equation to find \u003cspan\u003e\\vec{v}\u003c/span\u003e directly. But we \u003cem\u003ecan\u003c/em\u003e plug equation \u003cspan\u003e(1.2)\u003c/span\u003e in to equation \u003cspan\u003e(1.3)\u003c/span\u003e to yield:\u003c/p\u003e\u003cp\u003e\\tag{1.4}\n\\nabla \\cdot \\nabla \\Phi = L(x, y)\u003c/p\u003e\u003cp\u003eWhich we read as \u003cem\u003eThe divergence of the gradient of the potential field \u003cspan\u003e\\Phi\u003c/span\u003e equals the loss\u003c/em\u003e.\u003c/p\u003e\u003cp\u003eThis equation comes up surprisingly frequently in many branches of physics and math. It is usually written in a more convenient shorthand:\u003c/p\u003e\u003cp\u003e\\tag{1.5}\n\\nabla ^2 \\Phi = L\u003c/p\u003e\u003cp\u003eWhich you may recognize as \u003ca href=\"https://mattferraro.dev/posts/poissons-equation\"\u003ePoisson\u0026#39;s Equation\u003c/a\u003e!\u003c/p\u003e\u003cp\u003eThis is fantastic news because Poisson\u0026#39;s equation is \u003ca href=\"https://mattferraro.dev/posts/poissons-equation#how-do-i-solve-it\"\u003eextremely easy\u003c/a\u003e to solve! If you aren\u0026#39;t familiar with it, just think of this step like inverting a big matrix, or numerically integrating an ODE, or finding the square root of a real number. It\u0026#39;s an intricate, tedious task that would be painful to do with a paper and pencil, but it\u0026#39;s the kind of thing computers are \u003cem\u003ereally\u003c/em\u003e good at.\u003c/p\u003e\u003cp\u003eNow that we\u0026#39;ve written down the problem as Poisson\u0026#39;s Equation, it is as good as solved. We can use any off the shelf solver, plug in our known \u003cspan\u003eL(x, y)\u003c/span\u003e using Neumann boundary conditions and boom, and out pops \u003cspan\u003e\\Phi(x,y)\u003c/span\u003e as if by magic.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Phi\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fclearly_cat_phi.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fclearly_cat_phi.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fclearly_cat_phi.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eCan you figure out why the cat appears so clearly in this 3D rendering of \u003cspan\u003e\\Phi\u003c/span\u003e? What controls the brightness of each pixel in a render like this?\u003c/p\u003e\u003cp\u003eWe plug \u003cspan\u003e\\Phi\u003c/span\u003e in to Equation \u003cspan\u003e(1.2)\u003c/span\u003e to find \u003cspan\u003e\\vec{v}\u003c/span\u003e and we take a look at the vector field:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Gradient of Phi\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fexample_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eDisappointingly, it does not look like a kitty to me.\u003c/p\u003e\u003cp\u003eAnd technically we need to march our points in the direction of \u003cem\u003enegative\u003c/em\u003e \u003cspan\u003e\\nabla L\u003c/span\u003e if we want to \u003cem\u003edecrease\u003c/em\u003e \u003cspan\u003eL\u003c/span\u003e. Here\u0026#39;s \u003cspan\u003e-\\nabla L\u003c/span\u003e:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Negative Gradient of Phi\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fnegative_grad_phi.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fnegative_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fnegative_grad_phi.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eBut the good news is that this vector field is smooth and well-behaved. We simply march the grid points along this vector field and we\u0026#39;ll get exactly what we need. \u003c/p\u003e\u003cp\u003eIf you squint you can almost see how the bright background will expand and the cat\u0026#39;s dark fur will shrink.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Image and Vector Field\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe step all the lens grid points forward some small amount in the direction of \u003cspan\u003e-\\vec{v}\u003c/span\u003e. After morphing the grid a tiny amount we recompute the loss function \u003cspan\u003eL\u003c/span\u003e, find a new \u003cspan\u003e\\Phi\u003c/span\u003e and new \u003cspan\u003e-\\vec{v}\u003c/span\u003e, and take another small step.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# In Julia-flavored psuedocode\u003c/span\u003e\nimage \u003cspan\u003e=\u003c/span\u003e read_image\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;cat.png\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\ngray \u003cspan\u003e=\u003c/span\u003e convert_to_grayscale\u003cspan\u003e(\u003c/span\u003eimage\u003cspan\u003e)\u003c/span\u003e\ngrid \u003cspan\u003e=\u003c/span\u003e create_initial_grid\u003cspan\u003e(\u003c/span\u003egray\u003cspan\u003e.\u003c/span\u003esize \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\nL \u003cspan\u003e=\u003c/span\u003e compute_loss\u003cspan\u003e(\u003c/span\u003egray\u003cspan\u003e,\u003c/span\u003e grid\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003ewhile\u003c/span\u003e max\u003cspan\u003e(\u003c/span\u003eL\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e0.01\u003c/span\u003e\n    ϕ \u003cspan\u003e=\u003c/span\u003e poisson_solver\u003cspan\u003e(\u003c/span\u003eL\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;neumann\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    v \u003cspan\u003e=\u003c/span\u003e compute_gradient\u003cspan\u003e(\u003c/span\u003eϕ\u003cspan\u003e)\u003c/span\u003e\n    grid \u003cspan\u003e=\u003c/span\u003e step_grid\u003cspan\u003e(\u003c/span\u003egrid\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003ev\u003cspan\u003e)\u003c/span\u003e\n    L \u003cspan\u003e=\u003c/span\u003e compute_loss\u003cspan\u003e(\u003c/span\u003egray\u003cspan\u003e,\u003c/span\u003e grid\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter three or four iterations the loss gets very small and we\u0026#39;ve got our morphed cells!\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Grid After Warping\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side_warped.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side_warped.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fside_by_side_warped.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eLook at how this cat\u0026#39;s chin ballooned out but her nose and forehead shrunk. Her left ear is noticably longer and thinner because the bright background had to grow to take up more light. Her pupils went from oblong to sharp.\u003c/p\u003e\u003cp\u003eNote that image on the right is just a screenshot of Fusion360\u0026#39;s default mesh rendering with the wireframe turned on:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Screenshot of Fusion360\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2FFusion360.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2FFusion360.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2FFusion360.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe reason it is darker in some areas is because the mesh is more tightly packed in those areas. Let\u0026#39;s zoom in on the eye:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Zoom in on the Eye\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_eye.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_eye.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_eye.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eLook at how detailed that is! We\u0026#39;ve managed to capture even the bright reflections in her eyes. Zooming in further to just the pupil:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Zoom in on the Pupil\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_pupil.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_pupil.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fzoom_pupil.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eWe can see the fine structure of the grid cells. Our formulation of the problem is only concerned with cells as quadralaterals. The triangles you see are just an artifact of converting our quadralateral grid into a triangle mesh more suitable for other software to deal with.\u003c/p\u003e\u003cp\u003eSo again, in summary:\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Overall Flow\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Foverall_flow.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Foverall_flow.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Foverall_flow.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eIf we follow these steps we will successfully morph our grid points. Now we\u0026#39;ve got to do some geometry!\u003c/p\u003e\u003ch2 id=\"snells-law-and-normal-vectors\"\u003eSnell\u0026#39;s Law and Normal Vectors\u003c/h2\u003e\u003cp\u003eSnell\u0026#39;s law tells us how light bends when passing from one material to another. \u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Snell\u0026#39;s Law\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsnells_law_2.svg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsnells_law_2.svg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsnells_law_2.svg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\\tag{2.0}\n\\frac{\\sin(\\theta_2)}{\\sin(\\theta_1)} = \\frac{n_1}{n_2}\u003c/p\u003e\u003cp\u003eWhere \u003cspan\u003en_1 = 1.49\u003c/span\u003e is the \u003ca href=\"https://en.wikipedia.org/wiki/Refractive_index\"\u003eRefractive Index\u003c/a\u003e of acrylic and \u003cspan\u003en_2 = 1\u003c/span\u003e is the refractive index of air. If we know \u003cspan\u003e\\theta_2\u003c/span\u003e, Snell\u0026#39;s Law gives us \u003cspan\u003e\\theta_1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eSnell\u0026#39;s law is not some arbitrary axiom of physics. It is a direct consequence of Fermat\u0026#39;s \u003ca href=\"https://en.wikipedia.org/wiki/Fermat%27s_principle\"\u003ePrinciple of Least Time\u003c/a\u003e, which is a fascinating and critical link between ray optics and wave optics. But that\u0026#39;s a topic for another day.\u003c/p\u003e\u003cp\u003eIn our case, each lens cell \u003cspan\u003e(i, j)\u003c/span\u003e has migrated to position \u003cspan\u003e(x, y)\u003c/span\u003e, and it needs to send its light to the image plane at \u003cspan\u003e(u, v)\u003c/span\u003e, which sits some distance away \u003cspan\u003ed\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eWe start by defining a 3D normal vector \u003cspan\u003e\\vec{N}(x, y)\u003c/span\u003e which everywhere points normal to our heightmap \u003cspan\u003eh(x, y)\u003c/span\u003e.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Example Surface Normals\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsurface_normals.svg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsurface_normals.svg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fsurface_normals.svg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNormal vectors always point perpendicular to the surface they start on. They generally encode meaning in their direction, not their length, so we\u0026#39;re free to scale them to any length that is convenient for our purposes. Very often people choose to make their Normal vectors of length \u003cspan\u003e1\u003c/span\u003e.\u003c/p\u003e\u003cp\u003eBut if we normalize \u003cspan\u003e\\vec{N}\u003c/span\u003e so that its \u003cspan\u003ez\u003c/span\u003e coordinate is \u003cspan\u003e-1\u003c/span\u003e, we can write it:\u003c/p\u003e\u003cp\u003e\\tag{2.1}\n\\vec{N} = (\\frac{\\partial{h}}{\\partial{x}}, \\frac{\\partial{h}}{\\partial{y}}, -1)\u003c/p\u003e\u003cp\u003eIf you consider just the \u003cspan\u003ex\u003c/span\u003e and \u003cspan\u003ey\u003c/span\u003e components, we recognize that\u003c/p\u003e\u003cp\u003e\\tag{2.2}\n\\vec{N}_{xy} = \\nabla h\u003c/p\u003e\u003cp\u003eWhich is a property often used in computer graphics applications, as well as geospatial applications involving \u003ca href=\"https://en.wikipedia.org/wiki/Digital_elevation_model\"\u003eDigital Elevation Models\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eUsing Snell\u0026#39;s Law, a small angle approximation, and a lot of tedious geometry, we find the \u003cspan\u003ex\u003c/span\u003e and \u003cspan\u003ey\u003c/span\u003e components of the normal vector \u003cspan\u003e\\vec{N}\u003c/span\u003e:\u003c/p\u003e\u003cp\u003e\\tag{2.3}\nN_x(i, j) = \\tan \\frac{\\tan^{-1} \\left( \\frac{u - x} {d} \\right)} {(n_1 - n_2)}\u003c/p\u003e\u003cp\u003e\\tag{2.4}\nN_y(i, j) = \\tan \\frac{\\tan^{-1} \\left( \\frac{v - y} {d} \\right)} {(n_1 - n_2)}\u003c/p\u003e\u003cp\u003eThere is nothing interesting about this derivation so I\u0026#39;ve skipped it here.\u003c/p\u003e\u003ch2 id=\"finding-the-heightmap\"\u003eFinding the Heightmap\u003c/h2\u003e\u003cp\u003eAt this point we have our morphed grid cells and we\u0026#39;ve found all our surface normals. All we have to do is find a heightmap \u003cspan\u003eh(x,y)\u003c/span\u003e that has the required surface normals.\u003c/p\u003e\u003cp\u003eUnfortunately, this is not a problem that is solvable in the general case.\u003c/p\u003e\u003cp\u003eWe could try to integrate the normals manually, starting at one corner and working our way down the grid, but this method does not usually result in a physically realizable object. \u003c/p\u003e\u003cp\u003eIf the integral of the normals running left to right pulls your surface up, but the integral of the normals running top to bottom pulls your surface down, there is just no solution that results in a solid, unbroken surface.\u003c/p\u003e\u003cp\u003eA much better approach is to reach back to equation \u003cspan\u003e(2.2)\u003c/span\u003e, repeated here:\u003c/p\u003e\u003cp\u003e\\tag{2.2}\n\\vec{N}_{xy} = \\nabla h\u003c/p\u003e\u003cp\u003eAnd to take the divergence of both sides:\u003c/p\u003e\u003cp\u003e\\tag{2.5}\n\\nabla \\cdot \\vec{N}_{xy} = \\nabla \\cdot \\nabla h\u003c/p\u003e\u003cp\u003eDo you recognize the form of this equation? Adopting shorthand and swapping sides:\u003c/p\u003e\u003cp\u003e\\tag{2.6}\n\\nabla ^2 h = \\nabla \\cdot \\vec{N}_{xy}\u003c/p\u003e\u003cp\u003eWe arrive at yet another instance of \u003ca href=\"https://mattferraro.dev/posts/poissons-equation\"\u003ePoisson\u0026#39;s Equation\u003c/a\u003e! We found \u003cspan\u003e\\vec{N}_{xy}\u003c/span\u003e in the previous section, and calculating the divergence of a known vector field is easy:\u003c/p\u003e\u003cp\u003e\\tag{2.7}\n\\nabla \\cdot \\vec{N}_{xy} = \\left( \\frac{\\partial}{\\partial{x}}, \\frac{\\partial}{\\partial{y}} \\right) \\cdot (\\vec{N}_x, \\vec{N}_y) = \\frac{\\partial{\\vec{N}_x}}{\\partial{x}} + \\frac{\\partial{\\vec{N}_y}}{\\partial{y}}\u003c/p\u003e\u003cp\u003eIn code it looks like:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eδx \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eNx\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e j\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Nx\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e,\u003c/span\u003e j\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\nδy \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eNy\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e,\u003c/span\u003e j\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e Ny\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e,\u003c/span\u003e j\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\ndivergence\u003cspan\u003e[\u003c/span\u003ei\u003cspan\u003e,\u003c/span\u003e j\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e δx \u003cspan\u003e+\u003c/span\u003e δy\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAll that\u0026#39;s left is to plug our known \u003cspan\u003e\\nabla \\cdot \\vec{N}_{xy}\u003c/span\u003e in to a Poisson solver with Neumann boundary conditions and out pops \u003cspan\u003eh(x, y)\u003c/span\u003e, ready to use!\u003c/p\u003e\u003cp\u003eWell, there\u0026#39;s one thing left to improve. By modifying the height of each point we\u0026#39;ve actually changed the distance from each lens point to the image, so the lens-image distance is no longer a constant \u003cspan\u003ed\u003c/span\u003e it is actually a function \u003cspan\u003eD(x,y)\u003c/span\u003e. With our heightmap in hand we can easily calculate:\u003c/p\u003e\u003cp\u003e\\tag{2.8}\nD(x,y) = d - h(x,y)\u003c/p\u003e\u003cp\u003eAnd repeat the process by calculating new normals using \u003cspan\u003eD(x,y)\u003c/span\u003e instead of \u003cspan\u003ed\u003c/span\u003e, which lets us create a new heightmap.\u003c/p\u003e\u003cp\u003eWe can loop this process and measure changes to ensure convergence, but in practice just 2 or 3 iterations is all you need:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e# In Julia-flavored psuedocode\u003c/span\u003e\nd \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e.2\u003c/span\u003e \u003cspan\u003e# meters\u003c/span\u003e\nD \u003cspan\u003e=\u003c/span\u003e d \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e array_of_ones\u003cspan\u003e(\u003c/span\u003en\u003cspan\u003e,\u003c/span\u003e n\u003cspan\u003e)\u003c/span\u003e\n\n\u003cspan\u003efor\u003c/span\u003e i \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e3\u003c/span\u003e\n    Nx\u003cspan\u003e,\u003c/span\u003e Ny \u003cspan\u003e=\u003c/span\u003e compute_normals\u003cspan\u003e(\u003c/span\u003egrid\u003cspan\u003e,\u003c/span\u003e D\u003cspan\u003e)\u003c/span\u003e\n    divergence \u003cspan\u003e=\u003c/span\u003e compute_divergence\u003cspan\u003e(\u003c/span\u003eNx\u003cspan\u003e,\u003c/span\u003e Ny\u003cspan\u003e)\u003c/span\u003e\n    h \u003cspan\u003e=\u003c/span\u003e poisson_solver\u003cspan\u003e(\u003c/span\u003edivergence\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e\u0026#34;neumann\u0026#34;\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    D \u003cspan\u003e=\u003c/span\u003e copy\u003cspan\u003e(\u003c/span\u003eh\u003cspan\u003e)\u003c/span\u003e\n\u003cspan\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe resulting heightmap can be converted to a solid object by adopting a triangular grid and closing off the back surface.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Final Object\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_1.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_1.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_1.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eNote that the image looks mirrored when looking at it head on. That\u0026#39;s because the heightmap forms the \u003cem\u003eback\u003c/em\u003e surface of the Magic Window. The front surface is factory flat.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Final Object\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_2.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_2.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinal_object_2.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe height differences are subtle but certainly enough to get the job done.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Finished Product\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinished_product.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinished_product.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Ffinished_product.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"manufacturing\"\u003eManufacturing\u003c/h2\u003e\u003cp\u003eThe process of manufacturing our Magic Window is identical to carving any other 2.5D object.\u003c/p\u003e\u003cp\u003eWe bring our object into Fusion360 or any other CAM software. We set up a roughing toolpath left to right, and a finishing toolpath top to bottom just like you find in most tutorials.\u003c/p\u003e\u003cp\u003eAny old CNC router or mill will work. I designed and built my own router last year. If you want to do the same I recommend you start \u003ca href=\"https://mattferraro.dev/posts/cnc-router\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eI used a \u003cspan\u003e\\frac{1}{4}\u003c/span\u003e inch diameter, ball-nosed, carbide bit for both roughing and finishing passes, which took 10 minutes and 90 minutes respectively.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"On the Router\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fon_the_router.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fon_the_router.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fon_the_router.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003cp\u003eAfter carving the surface finish is rough and transluscent. We need to wet sand using \u003cspan\u003e200, 400, 600, 1000\u003c/span\u003e and \u003cspan\u003e1500\u003c/span\u003e grit sandpapers, then finish with a soft rag and some automotive polish. Sanding and polishing takes about half an hour for a \u003cspan\u003e10 cm \\times 10 cm\u003c/span\u003e Magic Window.\u003c/p\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"After Sanding\" srcset=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fafter_sanding.jpg\u0026amp;w=640\u0026amp;q=90 1x, https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fafter_sanding.jpg\u0026amp;w=1920\u0026amp;q=90 2x\" src=\"https://mattferraro.dev/_next/image?url=%2Fimages%2Fcaustics-engineering%2Fafter_sanding.jpg\u0026amp;w=1920\u0026amp;q=90\" decoding=\"async\" data-nimg=\"intrinsic\" loading=\"lazy\" data-old-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003ch2 id=\"acknowledgements\"\u003eAcknowledgements\u003c/h2\u003e\u003cp\u003eAll of the math for this post came from \u003ca href=\"http://nishitalab.org/user/egaku/tog14/yue-continuous-caustics-lens.pdf\"\u003ePoisson-Based Continuous Surface Generation for Goal-Based Caustics\u003c/a\u003e, a phenomenal 2014 paper by Yue et al. If you continue this work in some way, please cite them.\u003c/p\u003e\u003ch2 id=\"my-code\"\u003eMy Code\u003c/h2\u003e\u003cp\u003eMy source code is available \u003ca href=\"https://github.com/MattFerraro/causticsEngineering\"\u003ehere\u003c/a\u003e. I am a novice at programming in Julia so if you have suggestions for how to improve this code, please reach out or make a pull request!\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eCaveats\u003c/strong\u003e: There are a lot of issues with my code. I confuse \u003cspan\u003ex\u003c/span\u003e and \u003cspan\u003ey\u003c/span\u003e in several places. I have extra negative signs that I inserted that make the code work but I don\u0026#39;t know why. My units and notation are inconsistent throughout. The original paper suggests a better way of calculating loss but I didn\u0026#39;t implement it because the naive way was easier, yet I rolled my own mesh utilities and Poisson solver because I enjoyed the challenge.\u003c/p\u003e\u003cp\u003eIn short: To me this code is a fun side project. If you want to build a business off of this code you should probably hire someone who knows how to program professionally in Julia.\u003c/p\u003e\u003ch2 id=\"licensing\"\u003eLicensing\u003c/h2\u003e\u003cp\u003eI\u0026#39;ve posted all my code under the MIT license. Please feel free to use this code for anything you want, including hobbyist, educational, and commercial uses. I only ask that if you make something, please show me!\u003c/p\u003e\u003cp\u003eExcept where otherwise attributed, all images in this blog post and the blog post itself are my own work that I license as \u003ca href=\"https://creativecommons.org/licenses/by/2.0/\"\u003eCC-BY\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe cat in this post is named Mitski and she approves of you using her image as the new standard reference image for image processing papers. It\u0026#39;s time to let Lenna \u003ca href=\"https://en.wikipedia.org/wiki/Lenna#Criticism\"\u003eretire\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIf you use my code to make your own Magic Windows, I\u0026#39;d love to see them! I\u0026#39;m on Twitter at \u003ca href=\"https://twitter.com/mferraro89\"\u003e@mferraro89\u003c/a\u003e. Email me at \u003ca href=\"mailto:mattferraro.dev@gmail.com\"\u003emattferraro.dev@gmail.com\u003c/a\u003e and I will gladly help if you get stuck!\u003c/p\u003e\u003ch2 id=\"one-last-thing\"\u003eOne Last Thing\u003c/h2\u003e\u003cp\u003eI know what you\u0026#39;re thinking. \u003cem\u003eWhat about the hologram?!\u003c/em\u003e\u003c/p\u003e\u003cp\u003eDoes the math above imply that a hologram will always be created, or is this one cat hologram just an incredible coincidence?\u003c/p\u003e\u003cp\u003eWell you see, I\u0026#39;ve discovered a truly marvelous proof of this, which this website\u0026#39;s margin is unfortunately too narrow to contain :)\u003c/p\u003e\u003c/article\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "23 min read",
  "publishedTime": null,
  "modifiedTime": null
}
