{
  "id": "f4bbcb5a-68e3-4e4d-aa46-9ac410132a87",
  "title": "Parser Combinators Beat Regexes",
  "link": "https://entropicthoughts.com/parser-combinators-beat-regexes",
  "description": "Article URL: https://entropicthoughts.com/parser-combinators-beat-regexes Comments URL: https://news.ycombinator.com/item?id=43638422 Points: 26 # Comments: 9",
  "author": "mooreds",
  "published": "Wed, 09 Apr 2025 21:53:05 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "kqr",
  "length": 12954,
  "excerpt": "Someone online was solving Advent of Code problems, and had a question about last years’ day 3. They had a working solution using regular expressions (regexes) on String values, but they wanted to use ByteString values instead for performance reasons. They were surprised, however, that there seems to be a lack of community cohesion around regex libraries in Haskell.",
  "siteName": "",
  "favicon": "https://entropicthoughts.com/image/favicon/apple-touch-icon.png",
  "text": "Someone online was solving Advent of Code problems, and had a question about last years’ day 3. They had a working solution using regular expressions (regexes) on String values, but they wanted to use ByteString values instead for performance reasons. They were surprised, however, that there seems to be a lack of community cohesion around regex libraries in Haskell. There’s a reason for that. We generally don’t use regexes in Haskell. We use parser combinators instead, because they are almost always better. In other languages, it would be considered overkill to write a full parser when a simple regex can do the same thing. In Haskell, writing a parser is no big deal. We just do it and move on with our lives. The regex solution The first part of the Advent of Code problem is well suited for a regex-based solution. Here’s what such a solution might look like in Haskell. It uses the pcre-heavy Haskell library which in turn calls out to the system-wide pcre C library for actually compiling and running the regex. In[1]: {-# LANGUAGE QuasiQuotes #-} module Main where import Data.ByteString (ByteString) import qualified Data.ByteString.Char8 as Char8 import Data.Monoid (Sum (..)) import qualified Text.Regex.PCRE.Heavy as Re import Text.Regex.PCRE.Heavy (re) test_input :: ByteString test_input = Char8.pack \"xmul(2,4)%\u0026mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))\" regex_matches :: ByteString -\u003e Int regex_matches input = let -- Get a list of regex matches with numbers extracted. -- The 're' quasi-quoter compiles the regex at compile -- time, avoiding the runtime cost of that. hits = Re.scan [re|mul\\((\\d+),(\\d+)\\)|] input -- Take one hit and compute its product, converting the -- stringified numbers into actual numbers, then wrapping -- it up as a term in a sum. compute (_, [a, b]) = Sum (read (Char8.unpack a) * read (Char8.unpack b)) in -- Fold up all terms in the sum into a single number. getSum (foldMap compute hits) main :: IO () main = do print (regex_matches test_input) This does the job and returns the expected sum of 161. If we run this on just under a megabyte of input data, it takes 19 seconds on my machine, spending almost all of that time inside the pcre library.11 Though this is a little strange, because if I do the same thing in Perl, it takes 0.02 seconds. I wish I had time to investigate what goes wrong. But the main thing I dislike about this is that there’s a very strong implicit contract between the regex and the compute function. The compute function assumes that there were exactly two capturing groups and that they are strings that can safely be converted to integers. This is true, but there’s nothing in the code making that guarantee. If those assumptions become violated a year from now, that would not be a compiler error but an exception that interrupts the production service at 3 am the day before an important customer meeting. The parser solution For the sort of problem we are facing here, the parser-based solution does look more complicated at first glance. Part of the reason is that the regex library comes with a method that gets all matches, regardless of their position in the input. Parser combinators are meant to be written to consume all of the input, so we have to manually write the parser code that iterates the input and finds the next match. This solution uses the attoparsec library, which is made to work with ByteString values specifically, since the person who asked the question seemed to care about performance. In[2]: module Main where import Control.Applicative ((\u003c|\u003e)) import qualified Data.Attoparsec.ByteString.Char8 as Parser import Data.ByteString (ByteString) import qualified Data.ByteString.Char8 as Char8 import qualified Data.Either as Either test_input :: ByteString test_input = Char8.pack \"xmul(2,4)%\u0026mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))\" parser_matches :: ByteString -\u003e Int parser_matches input = let -- Parse a mul instruction. Starts by reading the opening -- sequence, then the first value, then the separator, -- then the second value, then the terminator. Finally, -- it returns the product of the pair of values. mul = do Parser.string (Char8.pack \"mul(\") first \u003c- Parser.decimal Parser.char ',' second \u003c- Parser.decimal Parser.char ')' pure (first * second) -- Parse the next mul instruction. Start by trying to -- parse a mul instruction immediately. If that fails, -- instead (1) advance the parser one step, and -- (2) try again. next = mul \u003c|\u003e do Parser.anyChar next -- Scan the entire input for all mul instructions, -- returning the sum of their products. scan = do muls \u003c- Parser.many1 next pure (sum muls) in -- Run the parser over the input, -- handling a parse error by throwing -- an exception. Either.fromRight (error \"Failed to parse input.\") (Parser.parseOnly scan input) main :: IO () main = do print (parser_matches test_input) This is written in what one might call direct, monadic style, doing just what was requested in the first part of the Advent of Code puzzle, using do notation for sequencing. We could rewrite it to be neater, but we will resist refactoring for now; we never know what twist in the requirements will be introduced in the second part of an Advent of Code puzzle. (The curious can check the refactoring out in the appendix.) This did involve more up-front writing, but there are some benefits. Granted, we use Either.fromRight to throw away all the useful error reporting we could get from attoparsec, but if we didn’t do that we would get more useful error messages when things went wrong. We also didn’t have to manually convert strings to integers, or blindly hope that the right number of integers were parsed. The compiler checks all those assumptions for us. When we run this on the same megabyte of input, it takes 0.07 seconds. This is within a magnitude of the Perl regex, but we get all the benefits of a more expressive language too. As we will see shortly, another big benefit of parsers is that they are more flexible to adapt to future requirements. Making the parser stateful The next part of the Advent of Code puzzle involves interpreting instructions called do() and don't() which turn on and off the contributions of mul instructions to the sum. As we parse, we now need to keep track of one bit of state. This is a nightmare for regexes to deal with, because they recognise regular languages, and regular languages are literally stateless languages.22 There’s more nuance, of course, but as a first approximation. Technically regular languages are those that can be recognised by a finite state automaton, and if there are a finite number of states (as there are in this case) then all of them can be encoded in an fsa but let’s not get pedantic here. But with the parser-based solution, we can lift it into a state transformer, and we get a stateful parser.33 Note that in a serious application, we might have lexing and parsing as separate steps, but parser combinators give us the freedom to combine both steps for tiny parsers like this. In[3]: module Main where import Control.Applicative (asum, (\u003c|\u003e)) import qualified Control.Monad.State.Class as State import qualified Control.Monad.State.Strict as State import qualified Data.Attoparsec.ByteString.Char8 as Parser import Data.Bool (bool) import Data.ByteString (ByteString) import qualified Data.ByteString as ByteString import qualified Data.ByteString.Char8 as Char8 import qualified Data.Either as Either test_input :: ByteString test_input = Char8.pack \"xmul(2,4)\u0026mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))\" parser_matches :: ByteString -\u003e Int parser_matches input = let -- Upon successfully parsing a do instruction, -- enable contribution of mul instructions. enable = do State.lift (Parser.string (Char8.pack \"do()\")) State.put True -- Upon successfully parsing a don't instruction, -- disable contribution of mul instructions. disable = do State.lift (Parser.string (Char8.pack \"don't()\")) State.put False -- Parse a mul instruction just as before, except -- now lifted into a stateful operation. mul = State.lift $ do Parser.string (Char8.pack \"mul(\") first \u003c- Parser.decimal Parser.char ',' second \u003c- Parser.decimal Parser.char ')' pure (first * second) -- If a do or don't instruction is parsed, -- continue searching for the next mul. -- -- If a mul is encountered, check the value of -- the state. If muls are enabled, leave it -- unaltered (id), but if muls are disabled, -- force its value to be zero (const 0). -- -- If no instruction is recognised, step -- forward one character and try again. next = asum [ enable *\u003e next , disable *\u003e next , bool (const 0) id \u003c$\u003e State.get \u003c*\u003e mul , State.lift Parser.anyChar *\u003e next ] scan = sum \u003c$\u003e Parser.many1 next in -- Start off evaluation with mul contributions enabled. Either.fromRight (error \"Failed to parse input.\") $ Parser.parseOnly (State.evalStateT scan True) input main :: IO () main = do print (parser_matches test_input) One has to be a little careful when making specifically attoparsec parsers stateful, because attoparsec is very happy to backtrack in the input on failure, but it will not undo the state changes that were caused by the initial parsing attempt. Thus, when making attoparsec parsers stateful, we have to write them such that they never backtrack past a state change.44 One could imagine an attoparsec primitive called something like cut (inspired by Prolog) which stops backtracking past a certain point. This could be used in combination with state changes to make sure the parser never backtracks past that change. Such a primitive would be fairly easy to write but it needs to be supplied by the library – it cannot be written by library users. On the positive side, avoiding long sequences of backtracking is also good for memory usage and performance, so we should do that anyway. The alert reader might notice that we used the parser result to store the value of the sum, but stored the contribution bit in the state. We could have done it any other way. We could store both sum and bit in state, or both in the result, or the other way around with the sum in the state and the bit in the result. This was just the quickest way I could think of to get it up and running. Haskell makes it cheap and safe to refactor later. The above runs in 0.12 seconds on about a megabyte of input. I won’t even try to write a regex-based solution for the second part, but I’m fairly confident it would be slower, less flexible, and more difficult to maintain. Appendix A: Refactoring the direct, monadic parser The mul instruction is really an instance of a more general “delimited pair of values” parser. We can extract this into its own function. In[4]: pair :: Parser open -\u003e Parser sep -\u003e Parser close -\u003e Parser value -\u003e Parser (value, value) pair open sep close value = liftA2 (,) (open *\u003e value) (sep *\u003e value \u003c* close) This takes three parsers for the opening sequence, separator, and closing sequence, and then a parser for the actual values, and constructs a parser that returns a pair of values. We can use this to parse the mul instruction, but also any other instruction based on a pair of values. Similarly, we were missing a function that returns all matches for a parser, regardless of where in the input they were located. The regex library had that function, but it does not come out of the box with attoparsec. We can make that. In[5]: scan_all :: Parser a -\u003e Parser [a] scan_all p = let next = p \u003c|\u003e Parser.anyChar *\u003e next in Parser.many1 next With these parts of the code broken out into their own functions, the final parser can be written in a more applicative style as In[6]: parser_matches :: ByteString -\u003e Int parser_matches input = let mul = uncurry (*) \u003c$\u003e pair (Parser.string (Char8.pack \"mul(\")) (Parser.char ',') (Parser.char ')') Parser.decimal result = sum \u003c$\u003e scan_all mul in Either.fromRight (error \"Failed to parse input.\") (Parser.parseOnly result input) This reads quite nicely: the result parser is the sum of all mul instructions, which are specified as the product of a pair of values with specific delimiters.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n                \u003cp\u003e\nSomeone online was solving Advent of Code problems, and had a question about\n\u003ca href=\"https://adventofcode.com/2024/day/3\"\u003elast years’ day 3\u003c/a\u003e. They had a working solution using regular expressions\n(regexes) on \u003ccode\u003eString\u003c/code\u003e values, but they wanted to use \u003ccode\u003eByteString\u003c/code\u003e values instead\nfor performance reasons. They were surprised, however, that there seems to be a\nlack of community cohesion around regex libraries in Haskell.\n\u003c/p\u003e\n\n\u003cp\u003e\nThere’s a reason for that. We generally don’t use regexes in Haskell. We use\nparser combinators instead, because they are almost always better. In other\nlanguages, it would be considered overkill to write a full parser when a simple\nregex can do the same thing. In Haskell, writing a parser is no big deal. We\njust do it and move on with our lives.\n\u003c/p\u003e\n\u003csection id=\"outline-container-the-regex-solution\"\u003e\n\u003ch2 id=\"the-regex-solution\"\u003eThe regex solution\u003c/h2\u003e\n\u003cdiv id=\"text-org923fa84\"\u003e\n\u003cp\u003e\nThe first part of the Advent of Code problem is well suited for a regex-based\nsolution. Here’s what such a solution might look like in Haskell. It uses the\n\u003ci\u003epcre-heavy\u003c/i\u003e Haskell library which in turn calls out to the system-wide \u003cabbr\u003epcre\u003c/abbr\u003e\nC library for actually compiling and running the regex.\n\u003c/p\u003e\n\n\u003cp\u003e\u003clabel\u003eIn[1]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003e{-# LANGUAGE QuasiQuotes #-}\u003c/span\u003e\n\n\u003cspan\u003emodule\u003c/span\u003e \u003cspan\u003eMain\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e\n\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eData.ByteString\u003c/span\u003e       (\u003cspan\u003eByteString\u003c/span\u003e)\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.ByteString.Char8\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eChar8\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eData.Monoid\u003c/span\u003e           (\u003cspan\u003eSum\u003c/span\u003e (\u003cspan\u003e..\u003c/span\u003e))\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eText.Regex.PCRE.Heavy\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eRe\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eText.Regex.PCRE.Heavy\u003c/span\u003e (re)\n\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e Char8.pack \u003cspan\u003e\u0026#34;xmul(2,4)%\u0026amp;mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eregex_matches\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n\u003cspan\u003eregex_matches\u003c/span\u003e input \u003cspan\u003e=\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eGet a list of regex matches with numbers extracted.\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eThe \u0026#39;re\u0026#39; quasi-quoter compiles the regex at compile\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003etime, avoiding the runtime cost of that.\u003c/span\u003e\n    hits \u003cspan\u003e=\u003c/span\u003e Re.scan [re\u003cspan\u003e|mul\\((\\d+),(\\d+)\\)|\u003c/span\u003e] input\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eTake one hit and compute its product, converting the\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003estringified numbers into actual numbers, then wrapping\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eit up as a term in a sum.\u003c/span\u003e\n    compute (\u003cspan\u003e_\u003c/span\u003e, [a, b]) \u003cspan\u003e=\u003c/span\u003e\n      \u003cspan\u003eSum\u003c/span\u003e (read (Char8.unpack a) \u003cspan\u003e*\u003c/span\u003e read (Char8.unpack b))\n  \u003cspan\u003ein\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eFold up all terms in the sum into a single number.\u003c/span\u003e\n    getSum (foldMap compute hits)\n\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eIO\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n  print (regex_matches test_input)\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nThis does the job and returns the expected sum of 161. If we run this on just\nunder a megabyte of input data, it takes 19 seconds on my machine, spending\nalmost all of that time inside the \u003cabbr\u003epcre\u003c/abbr\u003e library.\u003clabel for=\"fn.1\"\u003e1\u003c/label\u003e\u003cspan\u003e\u003csup\u003e1\u003c/sup\u003e Though this is a little\nstrange, because if I do the same thing in Perl, it takes 0.02 seconds. I wish I\nhad time to investigate what goes wrong.\u003c/span\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\nBut the main thing I dislike about this is that there’s a very strong implicit\ncontract between the regex and the \u003ccode\u003ecompute\u003c/code\u003e function. The \u003ccode\u003ecompute\u003c/code\u003e function\nassumes that there were exactly two capturing groups and that they are strings\nthat can safely be converted to integers. This is true, but there’s nothing in\nthe code making that guarantee. If those assumptions become violated a year from\nnow, that would not be a compiler error but an exception that interrupts the\nproduction service at 3 \u003cabbr\u003eam\u003c/abbr\u003e the day before an important customer meeting.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"outline-container-the-parser-solution\"\u003e\n\u003ch2 id=\"the-parser-solution\"\u003eThe parser solution\u003c/h2\u003e\n\u003cdiv id=\"text-orgbc5cd54\"\u003e\n\u003cp\u003e\nFor the sort of problem we are facing here, the parser-based solution does look\nmore complicated at first glance. Part of the reason is that the regex library\ncomes with a method that gets all matches, regardless of their position in the\ninput. Parser combinators are meant to be written to consume all of the input,\nso we have to manually write the parser code that iterates the input and finds\nthe next match.\n\u003c/p\u003e\n\n\u003cp\u003e\nThis solution uses the \u003ci\u003eattoparsec\u003c/i\u003e library, which is made to work with\n\u003ccode\u003eByteString\u003c/code\u003e values specifically, since the person who asked the question seemed\nto care about performance.\n\u003c/p\u003e\n\n\n\u003cp\u003e\u003clabel\u003eIn[2]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003emodule\u003c/span\u003e \u003cspan\u003eMain\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e\n\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eControl.Applicative\u003c/span\u003e              ((\u003cspan\u003e\u0026lt;|\u0026gt;\u003c/span\u003e))\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.Attoparsec.ByteString.Char8\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eData.ByteString\u003c/span\u003e                  (\u003cspan\u003eByteString\u003c/span\u003e)\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.ByteString.Char8\u003c/span\u003e            \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eChar8\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.Either\u003c/span\u003e                      \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eEither\u003c/span\u003e\n\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e Char8.pack \u003cspan\u003e\u0026#34;xmul(2,4)%\u0026amp;mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eparser_matches\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n\u003cspan\u003eparser_matches\u003c/span\u003e input \u003cspan\u003e=\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eParse a mul instruction. Starts by reading the opening\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003esequence, then the first value, then the separator,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003ethen the second value, then the terminator. Finally,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eit returns the product of the pair of values.\u003c/span\u003e\n    mul \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n      Parser.string (Char8.pack \u003cspan\u003e\u0026#34;mul(\u0026#34;\u003c/span\u003e)\n      first \u003cspan\u003e\u0026lt;-\u003c/span\u003e Parser.decimal\n      Parser.char \u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\n      second \u003cspan\u003e\u0026lt;-\u003c/span\u003e Parser.decimal\n      Parser.char \u003cspan\u003e\u0026#39;)\u0026#39;\u003c/span\u003e\n      pure (first \u003cspan\u003e*\u003c/span\u003e second)\n\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eParse the next mul instruction. Start by trying to\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eparse a mul instruction immediately. If that fails,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003einstead (1) advance the parser one step, and\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003e(2) try again.\u003c/span\u003e\n    next \u003cspan\u003e=\u003c/span\u003e\n      mul \u003cspan\u003e\u0026lt;|\u0026gt;\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n        Parser.anyChar\n        next\n\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eScan the entire input for all mul instructions,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003ereturning the sum of their products.\u003c/span\u003e\n    scan \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n      muls \u003cspan\u003e\u0026lt;-\u003c/span\u003e Parser.many1 next\n      pure (sum muls)\n\n  \u003cspan\u003ein\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eRun the parser over the input,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003ehandling a parse error by throwing\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003ean exception.\u003c/span\u003e\n    Either.fromRight (error \u003cspan\u003e\u0026#34;Failed to parse input.\u0026#34;\u003c/span\u003e)\n      (Parser.parseOnly scan input)\n\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eIO\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n  print (parser_matches test_input)\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nThis is written in what one might call \u003ci\u003edirect, monadic\u003c/i\u003e style, doing just what\nwas requested in the first part of the Advent of Code puzzle, using \u003ccode\u003edo\u003c/code\u003e\nnotation for sequencing. We could rewrite it to be neater, but we will resist\nrefactoring for now; we never know what twist in the requirements will be\nintroduced in the second part of an Advent of Code puzzle. (The curious can\ncheck the refactoring out in the appendix.)\n\u003c/p\u003e\n\n\u003cp\u003e\nThis did involve more up-front writing, but there are some benefits. Granted, we\nuse \u003ccode\u003eEither.fromRight\u003c/code\u003e to throw away all the useful error reporting we could get\nfrom \u003ci\u003eattoparsec\u003c/i\u003e, but if we didn’t do that we would get more useful error\nmessages when things went wrong. We also didn’t have to manually convert strings\nto integers, or blindly hope that the right number of integers were parsed. The\ncompiler checks all those assumptions for us.\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\nWhen we run this on the same megabyte of input, it takes 0.07 seconds. This is\nwithin a magnitude of the Perl regex, but we get all the benefits of a more\nexpressive language too. As we will see shortly, another big benefit of parsers\nis that they are more flexible to adapt to future requirements.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"outline-container-making-the-parser-stateful\"\u003e\n\u003ch2 id=\"making-the-parser-stateful\"\u003eMaking the parser stateful\u003c/h2\u003e\n\u003cdiv id=\"text-org5596867\"\u003e\n\u003cp\u003e\nThe next part of the Advent of Code puzzle involves interpreting instructions\ncalled \u003ccode\u003edo()\u003c/code\u003e and \u003ccode\u003edon\u0026#39;t()\u003c/code\u003e which turn on and off the contributions of \u003ccode\u003emul\u003c/code\u003e\ninstructions to the sum. As we parse, we now need to keep track of one bit of\nstate. This is a nightmare for regexes to deal with, because they recognise\nregular languages, and regular languages are literally stateless\nlanguages.\u003clabel for=\"fn.2\"\u003e2\u003c/label\u003e\u003cspan\u003e\u003csup\u003e2\u003c/sup\u003e There’s more nuance, of course, but as a first approximation.\nTechnically regular languages are those that can be recognised by a finite state\nautomaton, and if there are a finite number of states (as there are in this\ncase) then all of them can be encoded in an \u003cabbr\u003efsa\u003c/abbr\u003e but let’s not get pedantic\nhere.\u003c/span\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\nBut with the parser-based solution, we can lift it into a state transformer, and\nwe get a stateful parser.\u003clabel for=\"fn.3\"\u003e3\u003c/label\u003e\u003cspan\u003e\u003csup\u003e3\u003c/sup\u003e Note that in a serious application, we might have\nlexing and parsing as separate steps, but parser combinators give us the freedom\nto combine both steps for tiny parsers like this.\u003c/span\u003e\n\u003c/p\u003e\n\n\u003cp\u003e\u003clabel\u003eIn[3]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003emodule\u003c/span\u003e \u003cspan\u003eMain\u003c/span\u003e \u003cspan\u003ewhere\u003c/span\u003e\n\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eControl.Applicative\u003c/span\u003e              (asum, (\u003cspan\u003e\u0026lt;|\u0026gt;\u003c/span\u003e))\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eControl.Monad.State.Class\u003c/span\u003e        \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eState\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eControl.Monad.State.Strict\u003c/span\u003e       \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eState\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.Attoparsec.ByteString.Char8\u003c/span\u003e \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eData.Bool\u003c/span\u003e                        (bool)\n\u003cspan\u003eimport\u003c/span\u003e           \u003cspan\u003eData.ByteString\u003c/span\u003e                  (\u003cspan\u003eByteString\u003c/span\u003e)\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.ByteString\u003c/span\u003e                  \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.ByteString.Char8\u003c/span\u003e            \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eChar8\u003c/span\u003e\n\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003equalified\u003c/span\u003e \u003cspan\u003eData.Either\u003c/span\u003e                      \u003cspan\u003eas\u003c/span\u003e \u003cspan\u003eEither\u003c/span\u003e\n\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e\n\u003cspan\u003etest_input\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e Char8.pack \u003cspan\u003e\u0026#34;xmul(2,4)\u0026amp;mul[3,7]!^don\u0026#39;t()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))\u0026#34;\u003c/span\u003e\n\n\u003cspan\u003eparser_matches\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n\u003cspan\u003eparser_matches\u003c/span\u003e input \u003cspan\u003e=\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eUpon successfully parsing a do instruction,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eenable contribution of mul instructions.\u003c/span\u003e\n    enable \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n      State.lift (Parser.string (Char8.pack \u003cspan\u003e\u0026#34;do()\u0026#34;\u003c/span\u003e))\n      State.put \u003cspan\u003eTrue\u003c/span\u003e\n\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eUpon successfully parsing a don\u0026#39;t instruction,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003edisable contribution of mul instructions.\u003c/span\u003e\n    disable \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n      State.lift (Parser.string (Char8.pack \u003cspan\u003e\u0026#34;don\u0026#39;t()\u0026#34;\u003c/span\u003e))\n      State.put \u003cspan\u003eFalse\u003c/span\u003e\n\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eParse a mul instruction just as before, except\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003enow lifted into a stateful operation.\u003c/span\u003e\n    mul \u003cspan\u003e=\u003c/span\u003e State.lift \u003cspan\u003e$\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n      Parser.string (Char8.pack \u003cspan\u003e\u0026#34;mul(\u0026#34;\u003c/span\u003e)\n      first \u003cspan\u003e\u0026lt;-\u003c/span\u003e Parser.decimal\n      Parser.char \u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e\n      second \u003cspan\u003e\u0026lt;-\u003c/span\u003e Parser.decimal\n      Parser.char \u003cspan\u003e\u0026#39;)\u0026#39;\u003c/span\u003e\n      pure (first \u003cspan\u003e*\u003c/span\u003e second)\n\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eIf a do or don\u0026#39;t instruction is parsed,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003econtinue searching for the next mul.\u003c/span\u003e\n    \u003cspan\u003e--\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eIf a mul is encountered, check the value of\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003ethe state. If muls are enabled, leave it\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eunaltered (id), but if muls are disabled,\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eforce its value to be zero (const 0).\u003c/span\u003e\n    \u003cspan\u003e--\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eIf no instruction is recognised, step\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eforward one character and try again.\u003c/span\u003e\n    next \u003cspan\u003e=\u003c/span\u003e asum\n      [ enable \u003cspan\u003e*\u0026gt;\u003c/span\u003e next\n      , disable \u003cspan\u003e*\u0026gt;\u003c/span\u003e next\n      , bool (const 0) id \u003cspan\u003e\u0026lt;$\u0026gt;\u003c/span\u003e State.get \u003cspan\u003e\u0026lt;*\u0026gt;\u003c/span\u003e mul\n      , State.lift Parser.anyChar \u003cspan\u003e*\u0026gt;\u003c/span\u003e next\n      ]\n\n    scan \u003cspan\u003e=\u003c/span\u003e sum \u003cspan\u003e\u0026lt;$\u0026gt;\u003c/span\u003e Parser.many1 next\n\n  \u003cspan\u003ein\u003c/span\u003e\n    \u003cspan\u003e-- \u003c/span\u003e\u003cspan\u003eStart off evaluation with mul contributions enabled.\u003c/span\u003e\n    Either.fromRight (error \u003cspan\u003e\u0026#34;Failed to parse input.\u0026#34;\u003c/span\u003e) \u003cspan\u003e$\u003c/span\u003e\n      Parser.parseOnly (State.evalStateT scan \u003cspan\u003eTrue\u003c/span\u003e) input\n\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eIO\u003c/span\u003e \u003cspan\u003e()\u003c/span\u003e\n\u003cspan\u003emain\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003edo\u003c/span\u003e\n  print (parser_matches test_input)\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nOne has to be a little careful when making specifically \u003ci\u003eattoparsec\u003c/i\u003e parsers\nstateful, because attoparsec is very happy to backtrack in the input on failure,\nbut it will not undo the state changes that were caused by the initial parsing\nattempt. Thus, when making attoparsec parsers stateful, we have to write them\nsuch that they never backtrack past a state change.\u003clabel for=\"fn.4\"\u003e4\u003c/label\u003e\u003cspan\u003e\u003csup\u003e4\u003c/sup\u003e One could imagine an\nattoparsec primitive called something like \u003ccode\u003ecut\u003c/code\u003e (inspired by Prolog) which\nstops backtracking past a certain point. This could be used in combination with\nstate changes to make sure the parser never backtracks past that change. Such a\nprimitive would be fairly easy to write but it needs to be supplied by the\nlibrary – it cannot be written by library users.\u003c/span\u003e On the positive side, avoiding\nlong sequences of backtracking is also good for memory usage and performance, so\nwe should do that anyway.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe alert reader might notice that we used the parser result to store the value\nof the sum, but stored the contribution bit in the state. We could have done it any\nother way. We could store both sum and bit in state, or both in the result, or\nthe other way around with the sum in the state and the bit in the result. This\nwas just the quickest way I could think of to get it up and running. Haskell\nmakes it cheap and safe to refactor later.\n\u003c/p\u003e\n\n\u003cp\u003e\nThe above runs in 0.12 seconds on about a megabyte of input. I won’t even try to\nwrite a regex-based solution for the second part, but I’m fairly confident it\nwould be slower, less flexible, and more difficult to maintain.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\u003csection id=\"outline-container-appendix-a--refactoring-the-direct--monadic-parser\"\u003e\n\u003ch2 id=\"appendix-a--refactoring-the-direct--monadic-parser\"\u003eAppendix A: Refactoring the direct, monadic parser\u003c/h2\u003e\n\u003cdiv id=\"text-org73fd703\"\u003e\n\u003cp\u003e\nThe \u003ccode\u003emul\u003c/code\u003e instruction is really an instance of a more general “delimited pair of\nvalues” parser. We can extract this into its own function.\n\u003c/p\u003e\n\n\u003cp\u003e\u003clabel\u003eIn[4]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003epair\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e open \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e sep \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e close \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e value \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e (value, value)\n\u003cspan\u003epair\u003c/span\u003e open sep close value \u003cspan\u003e=\u003c/span\u003e\n  liftA2 \u003cspan\u003e(,)\u003c/span\u003e (open \u003cspan\u003e*\u0026gt;\u003c/span\u003e value) (sep \u003cspan\u003e*\u0026gt;\u003c/span\u003e value \u003cspan\u003e\u0026lt;*\u003c/span\u003e close)\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nThis takes three parsers for the opening sequence, separator, and closing\nsequence, and then a parser for the actual values, and constructs a parser that\nreturns a pair of values. We can use this to parse the \u003ccode\u003emul\u003c/code\u003e instruction, but\nalso any other instruction based on a pair of values.\n\u003c/p\u003e\n\n\u003cp\u003e\nSimilarly, we were missing a function that returns all matches for a parser,\nregardless of where in the input they were located. The regex library had that\nfunction, but it does not come out of the box with \u003ci\u003eattoparsec\u003c/i\u003e. We can make that.\n\u003c/p\u003e\n\n\u003cp\u003e\u003clabel\u003eIn[5]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003escan_all\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e a \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eParser\u003c/span\u003e [a]\n\u003cspan\u003escan_all\u003c/span\u003e p \u003cspan\u003e=\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e next \u003cspan\u003e=\u003c/span\u003e p \u003cspan\u003e\u0026lt;|\u0026gt;\u003c/span\u003e Parser.anyChar \u003cspan\u003e*\u0026gt;\u003c/span\u003e next\n  \u003cspan\u003ein\u003c/span\u003e Parser.many1 next\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nWith these parts of the code broken out into their own functions, the final\nparser can be written in a more \u003ci\u003eapplicative\u003c/i\u003e style as\n\u003c/p\u003e\n\n\u003cp\u003e\u003clabel\u003eIn[6]:\u003c/label\u003e\u003c/p\u003e\u003cdiv\u003e\n\u003cpre\u003e\u003cspan\u003eparser_matches\u003c/span\u003e \u003cspan\u003e::\u003c/span\u003e \u003cspan\u003eByteString\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\n\u003cspan\u003eparser_matches\u003c/span\u003e input \u003cspan\u003e=\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e\n    mul \u003cspan\u003e=\u003c/span\u003e uncurry (\u003cspan\u003e*\u003c/span\u003e) \u003cspan\u003e\u0026lt;$\u0026gt;\u003c/span\u003e pair\n      (Parser.string (Char8.pack \u003cspan\u003e\u0026#34;mul(\u0026#34;\u003c/span\u003e))\n      (Parser.char \u003cspan\u003e\u0026#39;,\u0026#39;\u003c/span\u003e)\n      (Parser.char \u003cspan\u003e\u0026#39;)\u0026#39;\u003c/span\u003e)\n      Parser.decimal\n\n    result \u003cspan\u003e=\u003c/span\u003e sum \u003cspan\u003e\u0026lt;$\u0026gt;\u003c/span\u003e scan_all mul\n  \u003cspan\u003ein\u003c/span\u003e\n    Either.fromRight (error \u003cspan\u003e\u0026#34;Failed to parse input.\u0026#34;\u003c/span\u003e)\n      (Parser.parseOnly result input)\n\u003c/pre\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\nThis reads quite nicely: the result parser is the sum of all \u003ccode\u003emul\u003c/code\u003e instructions,\nwhich are specified as the product of a pair of values with specific delimiters.\n\u003c/p\u003e\n\u003c/div\u003e\n\u003c/section\u003e\n\n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "14 min read",
  "publishedTime": null,
  "modifiedTime": null
}
