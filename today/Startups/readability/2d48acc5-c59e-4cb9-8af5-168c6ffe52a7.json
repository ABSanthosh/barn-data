{
  "id": "2d48acc5-c59e-4cb9-8af5-168c6ffe52a7",
  "title": "Wasmer 5.0",
  "link": "https://wasmer.io/posts/introducing-wasmer-v5",
  "description": "Article URL: https://wasmer.io/posts/introducing-wasmer-v5 Comments URL: https://news.ycombinator.com/item?id=41990326 Points: 107 # Comments: 23",
  "author": "syrusakbary",
  "published": "Tue, 29 Oct 2024 23:02:07 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 6444,
  "excerpt": "We are thrilled to announce the release of **Wasmer 5.0**, the latest milestone in our journey to make WebAssembly the greatest tool for executing softw...",
  "siteName": "",
  "favicon": "",
  "text": "We are thrilled to announce the release of Wasmer 5.0, the latest milestone in our journey to make WebAssembly the greatest tool for executing software anywhere. This announcement comes packed with awesome new features: Experimental support for more backends: V8, Wasmi and WAMR iOS support Leaner codebase Enhanced Performance Upgraded Compilers (now using LLVM 18 and latest Cranelift) Do you like the new features? Don't wait and give us a ⭐️ on Github! github.com/wasmerio/wasmer Key Highlights New experimental backends Some time ago we asked in Wasmer’s Community which backend would you like to see Wasmer support next. The responses were overwhelming: V8 (the engine behind Google’s Chrome Javascript runtime) was the most voted backend, with 56% of the votes. We learned from the poll results that interpreter support was also a desire from the community. Well, the day has come. We have added support for more backends: V8, Wasmi and also WAMR. All of them are integrated via the Wasm-C-API , as they all share this external interface in common. Thanks to the latest additions, now any interpreter or runtime that supports the Wasm-C-API spec can be easily integrated into Wasmer. We expect that the V8 integration will allow bringing a great debugging experience via the V8 debugger and Chrome Devtools. But not only that, having V8 as a backend also means supporting WebAssembly Exceptions and Garbage Collection under the hood. Stay tuned for more news on this front soon. As of today, Wasmer supports the following backends, so you can run WebAssembly using the Wasmer API in the following contexts: Natively (via Wasmer native compilers) Singlepass (singlepass feature): ideal for blockchains Cranelift (cranelift feature): ideal for development LLVM (llvm feature): ideal for production workloads Browser: the browser’s underlying Wasm engine (web feature) See https://github.com/wasmerio/wasmer-js for more info. JavascriptCore: JavascriptCore engine from Apple. Ideal if you want to use a lightweight and incredibly performant runtime in macOS (jsc feature) V8: Google’s JS V8 engine, ideal if you want to use Wasmer in iOS or Android (v8 feature) Wasmi: one of the most optimal Rust WebAssembly interpreters. Ideal if you want to use Wasm in nostd environments or blockchains with a pure Rust codebase (wasmi feature) WAMR: (wamr feature) ideal for iOS So… how fast are each of the backends? Benchmarking the backends We have run an extensive set of benchmarks based on Wasmi’s great benchmarking blogpost to see how each of these backends behave for diverse scenarios. Here are our findings! Full iOS Support via WAMR, Wasmi and V8 bindings For the first time, Wasmer brings WebAssembly to iOS devices through a new interpreted mode. About a year ago we added support for JavacriptCore in Wasmer, with the hope that it would enable a fast runtime on iOS (since the JIT would be unrestricted). Unfortunately, iOS capped the ability of using WebAssembly via JavascriptCore (since iOS 14). Leveraging the capabilities of V8, Wasmi and WebAssembly Micro Runtime (WAMR), developers can now run WebAssembly modules seamlessly on iOS thanks to Wasmer 5.0. No changes needed on their codebase. This opens up a world of possibilities for mobile development, enabling high-performance applications on Apple's ecosystem. We want to thank Holochain as this work wouldn’t be possible without our partnership. Leaner codebase For the release of Wasmer 5.0 we have put an special emphasis on making Wasmer codebase as lean as possible, so we can develop new features even faster. As part of this effort, we realized that: Emscripten bindings have been mostly unused in the last two years, mainly influenced by these two factors: Emscripten emits code using WASI systemcalls under the hood when possible, removing the need for having special bindings for Emscripten WASIX helps to bridge the gap of the WASI systemcalls that are not supported (threads, longjmp/setjmp, fork, …) Some of the dependencies Wasmer used have been long unmaintained, or duplicated by newer and safer crates Because of that, we decided to drop support for Emscripten and trimmed up the dependencies resulting in a net result of 20k lines of code deleted in the Wasmer codebase. Enhanced Performance Module deserialization now is up to 50% faster (that is, when you call Module::deserialize or when you run a module via wasmer run). Performance is at the heart of Wasmer, and version 5.0 takes it to the next level. These improvements are leveraging essential updates on rkyv: the zero-copy deserialization library that we use to deserialize our Modules. Here’s a benchmark of all the backends using latest Wasmer vs the latest release. Upgraded Compilers: Cranelift and LLVM 18 The latest Cranelift integration results in significant runtime speed improvements, making your WebAssembly modules execute faster than ever before. Wasmer 5.0 now includes the most recent version of LLVM (18), ensuring that developers have access to the latest optimizations from the toolchain. The LLVM upgrade enhances compatibility and performance, providing a robust foundation for compiling and running complex WebAssembly modules. On top of that, Wasmer 5.0 also ships with experimental LoongAarch64 support. We have also benchmarked coremark with the latest version of the compilers to see how they compare: LLVM and Cranelift are about 8% faster in Wasmer v5.0 compared to v4.4.0 Getting Started with Wasmer 5.0 Ready to dive in? Here's how you can start exploring the new features: Download Wasmer 5.0: Get the latest version from our official website. Update Your Projects: Upgrade your existing Wasmer projects to leverage the new capabilities. Explore the Documentation: Visit our updated docs for detailed guides and tutorials. Join the Community: Connect with other developers on our Discord server and share your experiences. Looking Ahead Wasmer 5.0 is a significant step forward in our mission to empower developers thanks of the exciting possibilities that WebAssembly brings to the table. With iOS support, our pluggable backend architecture and the enhanced performance, the possibilities are now endless. We can't wait to see what you'll build next with Wasmer. Stay Updated Website: wasmer.io GitHub: github.com/wasmerio/wasmer Twitter: @wasmerio Discord: Join our community Thank you everyone for being part of the Wasmer journey!",
  "image": "https://cdn.wasmer.io/original_images/wasmer-5.0.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cp\u003eWe are thrilled to announce the release of \u003cstrong\u003eWasmer 5.0\u003c/strong\u003e, the latest milestone in our journey to make WebAssembly the greatest tool for executing software anywhere.\u003c/p\u003e\n\u003cp\u003eThis announcement comes packed with awesome new features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExperimental support for more backends: \u003cstrong\u003eV8\u003c/strong\u003e, \u003cstrong\u003eWasmi\u003c/strong\u003e and \u003cstrong\u003eWAMR\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eiOS\u003c/strong\u003e support\u003c/li\u003e\n\u003cli\u003eLeaner codebase\u003c/li\u003e\n\u003cli\u003eEnhanced Performance\u003c/li\u003e\n\u003cli\u003eUpgraded Compilers (now using LLVM 18 and latest Cranelift)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDo you like the new features? Don\u0026#39;t wait and give us a ⭐️ on Github! \u003ca href=\"https://github.com/wasmerio/wasmer\"\u003egithub.com/wasmerio/wasmer\u003c/a\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2\u003eKey Highlights\u003c/h2\u003e\n\u003ch2\u003eNew experimental backends\u003c/h2\u003e\n\u003cp\u003eSome time ago \u003ca href=\"https://github.com/wasmerio/wasmer/discussions/3839\"\u003ewe asked in Wasmer’s Community\u003c/a\u003e which backend would you like to see Wasmer support next.\u003c/p\u003e\n\u003cp\u003eThe responses were overwhelming: V8 (the engine behind Google’s Chrome Javascript runtime) was the most voted backend, with 56% of the votes. We learned from the poll results that interpreter support was also a desire from the community.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-backend-poll.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer Backend Community Poll\"/\u003e\u003c/p\u003e\n\u003cp\u003eWell, the day has come. We have added support for more backends: V8, Wasmi and also WAMR. All of them are integrated via the \u003ca href=\"https://github.com/WebAssembly/wasm-c-api\"\u003eWasm-C-API\u003c/a\u003e , as they all share this external interface in common.\u003c/p\u003e\n\u003cp\u003eThanks to the latest additions, now any interpreter or runtime that supports the Wasm-C-API spec can be easily integrated into Wasmer.\u003c/p\u003e\n\u003cp\u003eWe expect that the V8 integration will allow bringing a great debugging experience via the V8 debugger and \u003ca href=\"https://developer.chrome.com/docs/devtools/\"\u003eChrome Devtools\u003c/a\u003e. But not only that, having V8 as a backend also means supporting WebAssembly Exceptions and Garbage Collection under the hood. Stay tuned for more news on this front soon.\u003c/p\u003e\n\u003cp\u003eAs of today, Wasmer supports the following backends, so you can run WebAssembly using the Wasmer API in the following contexts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNatively\u003c/strong\u003e (via Wasmer native compilers)\n\u003cul\u003e\n\u003cli\u003eSinglepass (\u003ccode\u003esinglepass\u003c/code\u003e feature): ideal for blockchains\u003c/li\u003e\n\u003cli\u003eCranelift (\u003ccode\u003ecranelift\u003c/code\u003e feature): ideal for development\u003c/li\u003e\n\u003cli\u003eLLVM (\u003ccode\u003ellvm\u003c/code\u003e feature): ideal for production workloads\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBrowser\u003c/strong\u003e: the browser’s underlying Wasm engine (\u003ccode\u003eweb\u003c/code\u003e feature)\nSee \u003ca href=\"https://github.com/wasmerio/wasmer-js\"\u003ehttps://github.com/wasmerio/wasmer-js\u003c/a\u003e for more info.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJavascriptCore\u003c/strong\u003e: JavascriptCore engine from Apple. Ideal if you want to use a lightweight and incredibly performant runtime in macOS (\u003ccode\u003ejsc\u003c/code\u003e feature)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eV8\u003c/strong\u003e: Google’s JS V8 engine, ideal if you want to use Wasmer in iOS or Android (\u003ccode\u003ev8\u003c/code\u003e feature)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWasmi\u003c/strong\u003e: one of the most optimal Rust WebAssembly interpreters. Ideal if you want to use Wasm in \u003ccode\u003enostd\u003c/code\u003e environments or blockchains with a pure Rust codebase (\u003ccode\u003ewasmi\u003c/code\u003e feature)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWAMR\u003c/strong\u003e: (\u003ccode\u003ewamr\u003c/code\u003e feature) ideal for iOS\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo… how fast are each of the backends?\u003c/p\u003e\n\u003ch3\u003eBenchmarking the backends\u003c/h3\u003e\n\u003cp\u003eWe have run an extensive set of benchmarks based on \u003ca href=\"https://wasmi-labs.github.io/blog/posts/wasmi-v0.32/\"\u003eWasmi’s great benchmarking blogpost\u003c/a\u003e to see how each of these backends behave for diverse scenarios. Here are our findings!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-argon2.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Argon 2 benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-bulkops.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Bulk Operations benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-counter.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Counter benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-primes.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Primes benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-fibonacci-iterative.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Fibonacci (iterative) benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-fibonacci-recursive.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Fibonacci (recursive) benchmark\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-matmul.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Matmul benchmark\"/\u003e\u003c/p\u003e\n\u003ch2\u003eFull iOS Support via WAMR, Wasmi and V8 bindings\u003c/h2\u003e\n\u003cp\u003eFor the first time, Wasmer brings WebAssembly to \u003cstrong\u003eiOS\u003c/strong\u003e devices through a new interpreted mode.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-ios-new.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Running on iOS\"/\u003e\u003c/p\u003e\n\u003cp\u003eAbout a year ago we added support for \u003ca href=\"https://wasmer.io/posts/wasmer-3_3-and-javascriptcore\"\u003eJavacriptCore in Wasmer\u003c/a\u003e, with the hope that it would enable a fast runtime on iOS (since the JIT would be unrestricted). Unfortunately, iOS capped the ability of using WebAssembly via JavascriptCore (since iOS 14).\u003c/p\u003e\n\u003cp\u003eLeveraging the capabilities of \u003cstrong\u003eV8\u003c/strong\u003e, \u003cstrong\u003eWasmi\u003c/strong\u003e and \u003cstrong\u003eWebAssembly Micro Runtime (WAMR)\u003c/strong\u003e, developers can now run WebAssembly modules seamlessly on iOS thanks to Wasmer 5.0. No changes needed on their codebase. This opens up a world of possibilities for mobile development, enabling high-performance applications on Apple\u0026#39;s ecosystem.\u003c/p\u003e\n\u003cp\u003eWe want to thank \u003ca href=\"https://www.holochain.org/\"\u003eHolochain\u003c/a\u003e as this work wouldn’t be possible without our partnership.\u003c/p\u003e\n\u003ch2\u003eLeaner codebase\u003c/h2\u003e\n\u003cp\u003eFor the release of Wasmer 5.0 we have put an special emphasis on making Wasmer codebase as lean as possible, so we can develop new features even faster.\u003c/p\u003e\n\u003cp\u003eAs part of this effort, we realized that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEmscripten bindings have been mostly unused in the last two years, mainly influenced by these two factors:\n\u003cul\u003e\n\u003cli\u003eEmscripten emits code using WASI systemcalls under the hood when possible, removing the need for having special bindings for Emscripten\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://wasix.org/\"\u003eWASIX\u003c/a\u003e helps to bridge the gap of the WASI systemcalls that are not supported (\u003ccode\u003ethreads\u003c/code\u003e, \u003ccode\u003elongjmp/setjmp\u003c/code\u003e, \u003ccode\u003efork\u003c/code\u003e, …)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSome of the dependencies Wasmer used have been long unmaintained, or duplicated by newer and safer crates\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBecause of that, we decided to drop support for Emscripten and trimmed up the dependencies resulting in a net result of \u003cstrong\u003e20k lines of code deleted\u003c/strong\u003e in the Wasmer codebase.\u003c/p\u003e\n\u003ch2\u003eEnhanced Performance\u003c/h2\u003e\n\u003cp\u003eModule deserialization now is up to 50% faster (that is, when you call \u003ccode\u003eModule::deserialize\u003c/code\u003e or when you run a module via \u003ccode\u003ewasmer run\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003ePerformance is at the heart of Wasmer, and version 5.0 takes it to the next level. These improvements are leveraging essential updates on \u003cstrong\u003erkyv:\u003c/strong\u003e the zero-copy deserialization library that we use to deserialize our Modules.\u003c/p\u003e\n\u003cp\u003eHere’s a benchmark of all the backends using latest Wasmer vs the latest release.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-deserialize.original.png\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Time to deserialize a WebAssembly module\"/\u003e\u003c/p\u003e\n\u003ch2\u003eUpgraded Compilers: Cranelift  and LLVM 18\u003c/h2\u003e\n\u003cp\u003eThe latest Cranelift integration results in significant runtime speed improvements, making your WebAssembly modules execute faster than ever before.\u003c/p\u003e\n\u003cp\u003eWasmer 5.0 now includes the most recent version of \u003cstrong\u003eLLVM (18)\u003c/strong\u003e, ensuring that developers have access to the latest optimizations from the toolchain. The LLVM upgrade enhances compatibility and performance, providing a robust foundation for compiling and running complex WebAssembly modules.\u003c/p\u003e\n\u003cp\u003eOn top of that, Wasmer 5.0 also ships with experimental \u003cem\u003eLoongAarch64\u003c/em\u003e support.\u003c/p\u003e\n\u003cp\u003eWe have also benchmarked \u003ccode\u003ecoremark\u003c/code\u003e with the latest version of the compilers to see how they compare:\n\u003cimg src=\"https://wasmer.io/_next/image?url=https%3A%2F%2Fcdn.wasmer.io%2Fimages%2Fwasmer-5-time-coremark.original.jpg\u0026amp;w=1920\u0026amp;q=75\" alt=\"Wasmer 5 Coremark results\"/\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLLVM and Cranelift are about 8% faster in Wasmer v5.0 compared to v4.4.0\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eGetting Started with Wasmer 5.0\u003c/h2\u003e\n\u003cp\u003eReady to dive in? Here\u0026#39;s how you can start exploring the new features:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDownload Wasmer 5.0\u003c/strong\u003e: Get the latest version from our \u003ca href=\"https://wasmer.io/\"\u003eofficial website\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUpdate Your Projects\u003c/strong\u003e: Upgrade your existing Wasmer projects to leverage the new capabilities.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExplore the Documentation\u003c/strong\u003e: Visit our updated docs for detailed guides and tutorials.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJoin the Community\u003c/strong\u003e: Connect with other developers on our Discord server and share your experiences.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eLooking Ahead\u003c/h2\u003e\n\u003cp\u003eWasmer 5.0 is a significant step forward in our mission to empower developers thanks of the exciting possibilities that WebAssembly brings to the table. With iOS support, our pluggable backend architecture and the enhanced performance, the possibilities are now endless. We can\u0026#39;t wait to see what you\u0026#39;ll build next with Wasmer.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e\u003cstrong\u003eStay Updated\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eWebsite\u003c/strong\u003e: \u003ca href=\"https://wasmer.io/\"\u003ewasmer.io\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub\u003c/strong\u003e: \u003ca href=\"https://github.com/wasmerio/wasmer\"\u003egithub.com/wasmerio/wasmer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTwitter\u003c/strong\u003e: \u003ca href=\"https://twitter.com/wasmerio\"\u003e@wasmerio\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDiscord\u003c/strong\u003e: \u003ca href=\"https://discord.gg/rWkMNStrEW\"\u003eJoin our community\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThank you everyone for being part of the Wasmer journey!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2024-10-29T18:02:52.612834Z",
  "modifiedTime": null
}
