{
  "id": "00bdd0e9-c1ca-4778-95e0-d1aeebe8a4e4",
  "title": "“ZLinq”, a Zero-Allocation LINQ Library for .NET",
  "link": "https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749",
  "description": "Article URL: https://neuecc.medium.com/zlinq-a-zero-allocation-linq-library-for-net-1bb0a3e5c749 Comments URL: https://news.ycombinator.com/item?id=44046578 Points: 56 # Comments: 17",
  "author": "cempaka",
  "published": "Tue, 20 May 2025 22:29:12 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "Yoshifumi Kawai",
  "length": 25987,
  "excerpt": "I’ve released ZLinq v1 last month! By building on structs and generics, it achieves zero allocations. It includes extensions like LINQ to Span, LINQ to SIMD, LINQ to Tree (FileSystem, JSON…",
  "siteName": "Medium",
  "favicon": "https://miro.medium.com/v2/resize:fill:1000:1000/7*GAOKVe--MXbEJmV9230oOQ.png",
  "text": "I’ve released ZLinq v1 last month! By building on structs and generics, it achieves zero allocations. It includes extensions like LINQ to Span, LINQ to SIMD, LINQ to Tree (FileSystem, JSON, GameObject, etc.), a drop-in replacement Source Generator for arbitrary types, and support for multiple platforms including .NET Standard 2.0, Unity, and Godot. It has now exceeded 2000 GitHub stars.https://github.com/Cysharp/ZLinqStruct-based LINQ itself isn’t particularly rare, and many implementations have attempted this approach over the years. However, none have been truly practical until now. They’ve typically suffered from extreme assembly size bloat, insufficient operator coverage, or performance issues due to inadequate optimization, never evolving beyond experimental status. With ZLinq, we aimed to create something practical by implementing 100% coverage of all methods and overloads in .NET 10 (including new ones like Shuffle, RightJoin, LeftJoin), ensuring 99% behavior compatibility, and implementing optimizations beyond just allocation reduction, including SIMD support, to outperform in most scenarios.This was possible because of my extensive experience implementing LINQ. In April 2009, I released linq.js, a LINQ to Objects library for JavaScript (it’s wonderful to see that linq.js is still being maintained by someone who forked it!). I’ve also implemented the widely-used Reactive Extensions library UniRx for Unity, and recently released its evolution, R3. I’ve created variants like LINQ to GameObject, LINQ to BigQuery, and SimdLinq. By combining these experiences with knowledge from zero-allocation related libraries (ZString, ZLogger) and high-performance serializers (MessagePack-CSharp, MemoryPack), we achieved the ambitious goal of creating a superior alternative to the standard library.This simple benchmark shows that while normal LINQ allocations increase as you chain more methods (Where, Where.Take, Where.Take.Select), ZLinq remains at zero.Performance varies depending on the source, quantity, element type, and method chaining. To confirm that ZLinq performs better in most cases, we’ve prepared various benchmark scenarios that run on GitHub Actions: ZLinq/actions/Benchmark. While there are cases where ZLinq structurally can’t win, it outperforms in most practical scenarios.For extreme differences in benchmarks, consider repeatedly calling Select multiple times. Neither System.LINQ nor ZLinq apply special optimizations in this case, but ZLinq shows a significant performance advantage:(Memory measurement 1B is BenchmarkDotNet MemoryDiagnoser errors. The documentation clearly states that MemoryDiagnoser has an accuracy of 99.5%, which means slight measurement errors can occur.)In simple cases, operations that require intermediate buffers like Distinct or OrderBy show large differences because aggressive pooling significantly reduces allocations (ZLinq uses somewhat aggressive pooling since it’s primarily based on ref struct, which is expected to be short-lived):LINQ applies special optimizations based on method call patterns, so reducing allocations alone isn’t enough to always outperform it. For operator chain optimizations, such as those introduced in .NET 9 and described in Performance Improvements in .NET 9, ZLinq implements all these optimizations to achieve even higher performance:A great benefit of ZLinq is that these LINQ evolution optimizations become available to all .NET generations (including .NET Framework), not just the latest versions.Usage is simple — just add an AsValueEnumerable() call. Since all operators are 100% covered, replacing existing code works without issues:using ZLinq;var seq = source .AsValueEnumerable() // only add this line .Where(x =\u003e x % 2 == 0) .Select(x =\u003e x * 3);foreach (var item in seq) { }To ensure behavior compatibility, ZLinq ports System.Linq.Tests from dotnet/runtime and continuously runs them at ZLinq/System.Linq.Tests.9000 test cases guarantee behavior (Skip cases are due to ref struct limitations where identical test code can’t be run, etc.)Additionally, ZLinq provides a Source Generator for Drop-In Replacement that can optionally eliminate even the need for AsValueEnumerable():[assembly: ZLinq.ZLinqDropInAttribute(\"\", ZLinq.DropInGenerateTypes.Everything)]This mechanism allows you to freely control the scope of the Drop-In Replacement. ZLinq/System.Linq.Tests itself uses Drop-In Replacement to run existing test code with ZLinq without changing the tests.ValueEnumerable Architecture and OptimizationFor usage, please refer to the ReadMe. Here, I’ll delve deeper into optimization. The architectural distinction goes beyond simply implementing lazy sequence execution, containing many innovations compared to collection processing libraries in other languages.The definition of ValueEnumerable\u003cT\u003e, which forms the basis of chaining, looks like this:public readonly ref struct ValueEnumerable\u003cTEnumerator, T\u003e(TEnumerator enumerator) where TEnumerator : struct, IValueEnumerator\u003cT\u003e, allows ref struct // allows ref struct only in .NET 9 or later{ public readonly TEnumerator Enumerator = enumerator;}public interface IValueEnumerator\u003cT\u003e : IDisposable{ bool TryGetNext(out T current); // as MoveNext + Current // Optimization helper bool TryGetNonEnumeratedCount(out int count); bool TryGetSpan(out ReadOnlySpan\u003cT\u003e span); bool TryCopyTo(scoped Span\u003cT\u003e destination, Index offset);}Based on this, operators like Where chain as follows:public static ValueEnumerable\u003cWhere\u003cTEnumerator, TSource\u003e, TSource\u003e Where\u003cTEnumerator, TSource\u003e(this ValueEnumerable\u003cTEnumerator, TSource\u003e source, Func\u003cTSource, Boolean\u003e predicate) where TEnumerator : struct, IValueEnumerator\u003cTSource\u003e, allows ref structWe chose this approach rather than using IValueEnumerable\u003cT\u003e because with a definition like (this TEnumerable source) where TEnumerable : struct, IValueEnumerable\u003cTSource\u003e, type inference for TSource would fail. This is due to a C# language limitation where type inference doesn't work from type parameter constraints (dotnet/csharplang#6930). If implemented with that definition, it would require defining instance methods for a vast number of combinations. LinqAF took that approach, resulting in 100,000+ methods and massive assembly sizes, which wasn't ideal.In LINQ, all implementation is in IValueEnumerator\u003cT\u003e, and since all Enumerators are structs, I realized that instead of using GetEnumerator(), we could simply copy-pass the common Enumerator, allowing each Enumerator to process with its independent state. This led to the final structure of wrapping IValueEnumerator\u003cT\u003e with ValueEnumerable\u003cTEnumerator, T\u003e. This way, types appear in type declarations rather than constraints, avoiding type inference issues.TryGetNextLet’s examine MoveNext, the core of iteration, in more detail:// Traditional interfacepublic interface IEnumerator\u003cout T\u003e : IDisposable{ bool MoveNext(); T Current { get; }}// iterate examplewhile (e.MoveNext()){ var item = e.Current; // invoke get_Current()}// ZLinq interfacepublic interface IValueEnumerator\u003cT\u003e : IDisposable{ bool TryGetNext(out T current);}// iterate examplewhile (e.TryGetNext(out var item)){}C#’s foreach expands to MoveNext() + Current, which presents two issues. First, each iteration requires two method calls: MoveNext and get_Current. Second, Current requires holding a variable. Therefore, I combined them into bool TryGetNext(out T current). This reduces method calls to one per iteration, improving performance.This bool TryGetNext(out T current) approach is also used in Rust's iterator:pub trait Iterator { type Item; // Required method fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e;}To understand the variable holding issue, let’s look at the Select implementation:public sealed class LinqSelect\u003cTSource, TResult\u003e(IEnumerator\u003cTSource\u003e source, Func\u003cTSource, TResult\u003e selector) : IEnumerator\u003cTResult\u003e{ // Three fields IEnumerator\u003cTSource\u003e source = source; Func\u003cTSource, TResult\u003e selector = selector; TResult current = default!; public TResult Current =\u003e current; public bool MoveNext() { if (source.MoveNext()) { current = selector(source.Current); return true; } return false; }}public ref struct ZLinqSelect\u003cTEnumerator, TSource, TResult\u003e(TEnumerator source, Func\u003cTSource, TResult\u003e selector) : IValueEnumerator\u003cTResult\u003e where TEnumerator : struct, IValueEnumerator\u003cTSource\u003e, allows ref struct{ // Two fields TEnumerator source = source; Func\u003cTSource, TResult\u003e selector = selector; public bool TryGetNext(out TResult current) { if (source.TryGetNext(out var value)) { current = selector(value); return true; } current = default!; return false; }}IEnumerator\u003cT\u003e requires a current field because it advances with MoveNext() and returns with Current. However, ZLinq advances and returns values simultaneously, eliminating the need to store the field. This makes a significant difference in ZLinq's struct-based architecture. Since ZLinq embraces a structure where each method chain encompasses the previous struct entirely (TEnumerator being a struct), struct size grows with each method chain. While performance remains acceptable within reasonable method chain lengths, smaller structs mean lower copy costs and better performance. The adoption of TryGetNext was essential to minimize struct size.A drawback of TryGetNext is that it cannot support covariance and contravariance. However, I believe iterators and arrays should abandon covariance/contravariance support altogether. They’re incompatible with Span\u003cT\u003e, making them outdated concepts when weighing pros and cons. For example, array Span conversion can fail at runtime without compile-time detection:// Due to generic variance, Derived[] is accepted by Base[]Base[] array = new Derived[] { new Derived(), new Derived() };// In this case, casting to Span\u003cT\u003e or using AsSpan() causes a runtime error!// System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.Span\u003cBase\u003e foo = array;class Base;class Derived : Base;While this behavior exists because these features were added before Span\u003cT\u003e, it's problematic in modern .NET where Span is widely used, making features that can cause runtime errors practically unusable.TryGetNonEnumeratedCount / TryGetSpan / TryCopyToNaively enumerating everything doesn’t maximize performance. For example, when calling ToArray, if the size doesn’t change (e.g., array.Select().ToArray()), we can create a fixed-length array with new T[count]. System.LINQ internally uses an Iterator\u003cT\u003e type for such optimizations, but since the parameter is IEnumerable\u003cT\u003e, code like if (source is Iterator\u003cTSource\u003e iterator) is always needed.Since ZLinq is designed specifically for LINQ from the start, we’ve prepared for these optimizations. To avoid assembly size bloat, we’ve carefully selected the minimal set of definitions that provide maximum effect, resulting in these three methods.TryGetNonEnumeratedCount(out int count) succeeds when the original source has a finite count and no filtering methods (Where, Distinct, etc., though Take and Skip are calculable) intervene. This benefits ToArray and methods requiring intermediate buffers like OrderBy and Shuffle.TryGetSpan(out ReadOnlySpan\u003cT\u003e span) potentially delivers dramatic performance improvements when the source can be accessed as contiguous memory, enabling SIMD operations or Span-based loop processing for aggregation performance.TryCopyTo(scoped Span\u003cT\u003e destination, Index offset) enhances performance through internal iterators. To explain external vs. internal iterators, consider that List\u003cT\u003e offers both foreach and ForEach:// external iteratorforeach (var item in list) { Do(item); }// internal iteratorlist.ForEach(Do);They look similar but perform differently. Breaking down the implementations:// external iteratorList\u003cT\u003e.Enumerator e = list.GetEnumerator();while (e.MoveNext()){ var item = e.Current; Do(item);}// internal iteratorfor (int i = 0; i \u003c _size; i++){ action(_items[i]);}This becomes a competition between delegate call overhead (+ delegate creation allocation) vs. iterator MoveNext + Current calls. The iteration speed itself is faster with internal iterators. In some cases, delegate calls may be lighter, making internal iterators potentially advantageous in benchmarks.Of course, this varies case by case, and since lambda captures and normal control flow (like continue, break, await, etc…) aren’t available, I personally believe ForEach shouldn't be used, nor should custom extension methods be defined to mimic it. However, this structural difference exists.TryCopyTo(scoped Span\u003cT\u003e destination, Index offset) achieves limited internal iteration by accepting a Span rather than a delegate.Using Select as an example, for ToArray when Count is available, it passes a Span for internal iteration:public ref struct Select{ public bool TryCopyTo(Span\u003cTResult\u003e destination, Index offset) { if (source.TryGetSpan(out var span)) { if (EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice)) { // loop inlining for (var i = 0; i \u003c slice.Length; i++) { destination[i] = selector(slice[i]); } return true; } } return false; }}// ------------------// ToArrayif (enumerator.TryGetNonEnumeratedCount(out var count)){ var array = GC.AllocateUninitializedArray\u003cTSource\u003e(count); // try internal iterator if (enumerator.TryCopyTo(array.AsSpan(), 0)) { return array; } // otherwise, use external iterator var i = 0; while (enumerator.TryGetNext(out var item)) { array[i] = item; i++; } return array;}Thus, while Select can’t create a Span, if the original source can, processing as an internal iterator accelerates loop processing.TryCopyTo differs from regular CopyTo by including an Index offset and allowing destination to be smaller than the source (normal .NET CopyTo fails if destination is smaller). This enables ElementAt representation when destination size is 1 - index 0 becomes First, ^1 becomes Last. Adding First, Last, ElementAt directly to IValueEnumerator\u003cT\u003e would create redundancy in class definitions (affecting assembly size), but combining small destinations with Index allows one method to cover more optimization cases:public static TSource ElementAt\u003cTEnumerator, TSource\u003e(this ValueEnumerable\u003cTEnumerator, TSource\u003e source, Index index) where TEnumerator : struct, IValueEnumerator\u003cTSource\u003e, allows ref struct{ using var enumerator = source.Enumerator; var value = default(TSource)!; var span = new Span\u003cT\u003e(ref value); // create single span if (enumerator.TryCopyTo(span, index)) { return value; } // else...}LINQ to SpanIn .NET 9 and above, ZLinq allows chaining all LINQ operators on Span\u003cT\u003e and ReadOnlySpan\u003cT\u003e:using ZLinq;// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)Span\u003cint\u003e span = stackalloc int[5] { 1, 2, 3, 4, 5 };var seq1 = span.AsValueEnumerable().Select(x =\u003e x * x);// If enables Drop-in replacement, you can call LINQ operator directly.var seq2 = span.Select(x =\u003e x);While some libraries claim to support LINQ for Spans, they typically only define extension methods for Span\u003cT\u003e without a generic mechanism. They offer limited operators due to language constraints that previously prevented receiving Span\u003cT\u003e as a generic parameter. Generic processing became possible with the introduction of allows ref struct in .NET 9.In ZLinq, there’s no distinction between IEnumerable\u003cT\u003e and Span\u003cT\u003e - they're treated equally.However, since allows ref struct requires language/runtime support, while ZLinq supports all .NET versions from .NET Standard 2.0 up, Span support is limited to .NET 9 and above. This means in .NET 9+, all operators are ref struct, which differs from earlier versions.LINQ to SIMDSystem.Linq accelerates certain aggregation methods with SIMD. For example, calling Sum or Max directly on primitive type arrays provides faster processing than using a for loop. However, being based on IEnumerable\u003cT\u003e, applicable types are limited. ZLinq makes this more generic through IValueEnumerator.TryGetSpan, targeting collections where Span\u003cT\u003e can be obtained (including direct Span\u003cT\u003e application).Supported methods include:Range to ToArray/ToList/CopyTo/etc…Repeat for unmanaged struct and size is power of 2 to ToArray/ToList/CopyTo/etc...Sum for sbyte, short, int, long, byte, ushort, uint, ulong, doubleSumUnchecked for sbyte, short, int, long, byte, ushort, uint, ulong, doubleAverage for sbyte, short, int, long, byte, ushort, uint, ulong, doubleMax for byte, sbyte, short, ushort, int, uint, long, ulong, nint, nuint, Int128, UInt128Min for byte, sbyte, short, ushort, int, uint, long, ulong, nint, nuint, Int128, UInt128Contains for byte, sbyte, short, ushort, int, uint, long, ulong, bool, char, nint, nuintSequenceEqual for byte, sbyte, short, ushort, int, uint, long, ulong, bool, char, nint, nuintSum checks for overflow, which adds overhead. We've added a custom SumUnchecked method that's faster:Since these methods apply implicitly when conditions match, understanding the internal pipeline is necessary to target SIMD application. Therefore, for T[], Span\u003cT\u003e, or ReadOnlySpan\u003cT\u003e, we provide the .AsVectorizable() method to explicitly call SIMD-applicable operations like Sum, SumUnchecked, Average, Max, Min, Contains, and SequenceEqual (though these fall back to normal processing when Vector.IsHardwareAccelerated \u0026\u0026 Vector\u003cT\u003e.IsSupported is false).int[] or Span\u003cint\u003e gain the VectorizedFillRange method, which performs the same operation as ValueEunmerable.Range().CopyTo(), filling with sequential numbers using SIMD acceleration. This is much faster than filling with a for loop when needed:Vectorizable MethodsHandwriting SIMD loop processing requires practice and effort. We’ve provided helpers that take Func arguments for casual use. While these incur delegate overhead and perform worse than inline code, they’re convenient for casual SIMD processing. They accept Func\u003cVector\u003cT\u003e, Vector\u003cT\u003e\u003e vectorFunc and Func\u003cT, T\u003e func, processing with Vector\u003cT\u003e where possible and handling remainder with Func\u003cT\u003e.T[] and Span\u003cT\u003e offer the VectorizedUpdate method:using ZLinq.Simd; // needs usingint[] source = Enumerable.Range(0, 10000).ToArray();[Benchmark]public void For(){ for (int i = 0; i \u003c source.Length; i++) { source[i] = source[i] * 10; }}[Benchmark]public void VectorizedUpdate(){ // arg1: Vector\u003cint\u003e =\u003e Vector\u003cint\u003e // arg2: int =\u003e int source.VectorizedUpdate(static x =\u003e x * 10, static x =\u003e x * 10);}While faster than for loops, performance varies by machine environment and size, so verification is recommended for each use case.AsVectorizable() provides Aggregate, All, Any, Count, Select, and Zip:source.AsVectorizable().Aggregate((x, y) =\u003e Vector.Min(x, y), (x, y) =\u003e Math.Min(x, y))source.AsVectorizable().All(x =\u003e Vector.GreaterThanAll(x, new(5000)), x =\u003e x \u003e 5000);source.AsVectorizable().Any(x =\u003e Vector.LessThanAll(x, new(5000)), x =\u003e x \u003c 5000);source.AsVectorizable().Count(x =\u003e Vector.GreaterThan(x, new(5000)), x =\u003e x \u003e 5000);Performance depends on data, but Count can show significant differences:For Select and Zip, you follow with either ToArray or CopyTo:// Selectsource.AsVectorizable().Select(x =\u003e x * 3, x =\u003e x * 3).ToArray();source.AsVectorizable().Select(x =\u003e x * 3, x =\u003e x * 3).CopyTo(destination);// Zip2array1.AsVectorizable().Zip(array2, (x, y) =\u003e x + y, (x, y) =\u003e x + y).CopyTo(destination);array1.AsVectorizable().Zip(array2, (x, y) =\u003e x + y, (x, y) =\u003e x + y).ToArray();// Zip3array1.AsVectorizable().Zip(array2, array3, (x, y, z) =\u003e x + y + z, (x, y, z) =\u003e x + y + z).CopyTo(destination);array1.AsVectorizable().Zip(array2, array3, (x, y, z) =\u003e x + y + z, (x, y, z) =\u003e x + y + z).ToArray();Zip can be particularly interesting and fast for certain use cases (like merging two Vec3):LINQ to TreeHave you used LINQ to XML? In 2008 when LINQ appeared, XML was still dominant, and LINQ to XML’s usability was shocking. Now that JSON has taken over, LINQ to XML is rarely used.However, LINQ to XML’s value lies in being a reference design for LINQ-style operations on tree structures — a guideline for making tree structures LINQ-compatible. Tree traversal abstractions work excellently with LINQ to Objects. A prime example is working with Roslyn’s SyntaxTree, where methods like Descendants are commonly used in Analyzers and Source Generators.ZLinq extends this concept by defining an interface that generically enables Ancestors, Children, Descendants, BeforeSelf, and AfterSelf for tree structures:This diagram shows traversal of Unity’s GameObject, but we’ve included standard implementations for FileSystem (DirectoryTree) and JSON (enabling LINQ to XML-style operations on System.Text.Json’s JsonNode). Of course, you can implement the interface for custom types:public interface ITraverser\u003cTTraverser, T\u003e : IDisposable where TTraverser : struct, ITraverser\u003cTTraverser, T\u003e // self{ T Origin { get; } TTraverser ConvertToTraverser(T next); // for Descendants bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants bool TryGetChildCount(out int count); // optional: optimize use for Children bool TryGetParent(out T parent); // for Ancestors bool TryGetNextChild(out T child); // for Children | Descendants bool TryGetNextSibling(out T next); // for AfterSelf bool TryGetPreviousSibling(out T previous); // BeforeSelf}For JSON, you can write:var json = JsonNode.Parse(\"\"\"// snip...\"\"\");// JsonNodevar origin = json![\"nesting\"]![\"level1\"]![\"level2\"]!;// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.foreach (var item in origin.Descendants().Select(x =\u003e x.Node).OfType\u003cJsonArray\u003e()){ // [true, false, true], [\"fast\", \"accurate\", \"balanced\"], [1, 1, 2, 3, 5, 8, 13] Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));}We’ve included standard LINQ to Tree implementations for Unity’s GameObject and Transform and Godot's Node. Since allocation and traversal performance are carefully optimized, they might even be faster than manual loops.OSS and MeThere have been several incidents in .NET-related OSS in recent months, including the commercialization of well-known OSS projects. With over 40 OSS projects under github/Cysharp and more under my personal and other organizations like MessagePack, totaling over 50,000 stars, I believe I’m one of the largest OSS providers in the .NET ecosystem.Regarding commercialization, I have no plans for it, but maintenance has become challenging due to growing scale. A major factor in OSS projects attempting commercialization despite criticism is the mental burden on maintainers (compensation doesn’t match time investment). I experience this too!Setting aside financial aspects, my request is for users to accept occasional maintenance delays! When developing large libraries like ZLinq, I need focused time, which means Issues and PRs for other libraries might go without response for months. I intentionally avoid looking at them, not even reading titles (avoiding dashboards and notification emails). This seemingly neglectful approach is necessary to create innovative libraries — a necessary sacrifice!Even without that, the sheer number of libraries means rotation delays of months are inevitable. This is unavoidable due to absolute manpower shortage, so please accept these delays and don’t claim “this library is dead” just because responses are slow. That’s painful to hear! I try my best, but creating new libraries consumes tremendous time, causing cascading delays that drain my mental energy.Also, irritations related to Microsoft can reduce motivation — a common experience for C# OSS maintainers. Despite this, I hope to continue long-term.ConclusionZLinq’s structure changed significantly after feedback from the initial preview release. @Akeit0 provided many proposals for core performance-critical elements like the ValueEnumerable\u003cTEnumerator, T\u003e definition and adding Index to TryCopyTo. @filzrev contributed extensive test and benchmark infrastructure. Ensuring compatibility and performance improvements wouldn't have been possible without their contributions, for which I'm deeply grateful.While zero-allocation LINQ libraries aren’t novel, ZLinq’s thoroughness sets it apart. With experience and knowledge, driven by sheer determination, we implemented all methods, ran all test cases for complete compatibility, and implemented all optimizations including SIMD. This was truly challenging!The timing was perfect as .NET 9/C# 13 provided all the language features needed for a full implementation. Simultaneously, maintaining support for Unity and .NET Standard 2.0 was also important.Beyond being just a zero-allocation LINQ, LINQ to Tree is a favorite feature that I hope people will try!One LINQ performance bottleneck is delegates, and some libraries adopt a ValueDelegate approach using structs to mimic Func. We deliberately avoided this because such definitions are impractical due to their complexity. It’s better to write inline code than use LINQ with ValueDelegate structures. Complicating internal structure and bloating assembly size for benchmark hacks is wasteful, so we accept only System.Linq-compatible.R3 was an ambitious library intended to replace .NET’s standard System.Reactive, but replacing System.Linq would be a much larger or perhaps excessive undertaking, so I think there might be some resistance to adoption. However, I believe we’ve demonstrated sufficient benefits to justify the replacement, so I’d be very happy if you could try it out!",
  "image": "https://miro.medium.com/v2/resize:fit:281/1*_pyu2LwhltriPXPlbNvg4w.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\u003cdiv aria-hidden=\"false\"\u003e\u003ca rel=\"noopener follow\" href=\"https://neuecc.medium.com/?source=post_page---byline--1bb0a3e5c749---------------------------------------\"\u003e\u003cdiv\u003e\u003cp\u003e\u003cimg alt=\"Yoshifumi Kawai\" src=\"https://miro.medium.com/v2/resize:fill:64:64/0*5p7GOVtYN8PbMKTw.jpg\" width=\"32\" height=\"32\" loading=\"lazy\" data-testid=\"authorPhoto\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/a\u003e\u003c/div\u003e\u003cp id=\"c7b2\"\u003eI’ve released \u003ca href=\"https://github.com/Cysharp/ZLinq\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZLinq\u003c/a\u003e v1 last month! By building on structs and generics, it achieves zero allocations. It includes extensions like LINQ to Span, LINQ to SIMD, LINQ to Tree (FileSystem, JSON, GameObject, etc.), a drop-in replacement Source Generator for arbitrary types, and support for multiple platforms including .NET Standard 2.0, Unity, and Godot. It has now exceeded 2000 GitHub stars.\u003c/p\u003e\u003cul\u003e\u003cli id=\"a967\"\u003e\u003ca href=\"https://github.com/Cysharp/ZLinq\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ehttps://github.com/Cysharp/ZLinq\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2795\"\u003eStruct-based LINQ itself isn’t particularly rare, and many implementations have attempted this approach over the years. However, none have been truly practical until now. They’ve typically suffered from extreme assembly size bloat, insufficient operator coverage, or performance issues due to inadequate optimization, never evolving beyond experimental status. With ZLinq, we aimed to create something practical by implementing 100% coverage of all methods and overloads in .NET 10 (including new ones like Shuffle, RightJoin, LeftJoin), ensuring 99% behavior compatibility, and implementing optimizations beyond just allocation reduction, including SIMD support, to outperform in most scenarios.\u003c/p\u003e\u003cp id=\"9f6d\"\u003eThis was possible because of my extensive experience implementing LINQ. In April 2009, I released \u003ca href=\"https://github.com/neuecc/linq.js/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003elinq.js\u003c/a\u003e, a LINQ to Objects library for JavaScript (it’s wonderful to see that linq.js is still being maintained by someone who forked it!). I’ve also implemented the widely-used Reactive Extensions library \u003ca href=\"https://github.com/neuecc/UniRx\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eUniRx\u003c/a\u003e for Unity, and recently released its evolution, \u003ca href=\"https://github.com/Cysharp/R3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eR3\u003c/a\u003e. I’ve created variants like \u003ca href=\"https://assetstore.unity.com/packages/tools/integration/linq-to-gameobject-24256\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLINQ to GameObject\u003c/a\u003e, \u003ca href=\"https://github.com/neuecc/LINQ-to-BigQuery\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLINQ to BigQuery\u003c/a\u003e, and \u003ca href=\"https://github.com/Cysharp/SimdLinq/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eSimdLinq\u003c/a\u003e. By combining these experiences with knowledge from zero-allocation related libraries (\u003ca href=\"https://github.com/Cysharp/ZString\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZString\u003c/a\u003e, \u003ca href=\"https://github.com/Cysharp/ZLogger\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZLogger\u003c/a\u003e) and high-performance serializers (\u003ca href=\"https://github.com/MessagePack-CSharp/MessagePack-CSharp/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMessagePack-CSharp\u003c/a\u003e, \u003ca href=\"https://github.com/Cysharp/MemoryPack\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMemoryPack\u003c/a\u003e), we achieved the ambitious goal of creating a superior alternative to the standard library.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"1cba\"\u003eThis simple benchmark shows that while normal LINQ allocations increase as you chain more methods (Where, Where.Take, Where.Take.Select), ZLinq remains at zero.\u003c/p\u003e\u003cp id=\"83f9\"\u003ePerformance varies depending on the source, quantity, element type, and method chaining. To confirm that ZLinq performs better in most cases, we’ve prepared various benchmark scenarios that run on GitHub Actions: \u003ca href=\"https://github.com/Cysharp/ZLinq/actions/workflows/benchmark.yaml\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZLinq/actions/Benchmark\u003c/a\u003e. While there are cases where ZLinq structurally can’t win, it outperforms in most practical scenarios.\u003c/p\u003e\u003cp id=\"63b6\"\u003eFor extreme differences in benchmarks, consider repeatedly calling Select multiple times. Neither System.LINQ nor ZLinq apply special optimizations in this case, but ZLinq shows a significant performance advantage:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"3709\"\u003e(Memory measurement 1B is BenchmarkDotNet MemoryDiagnoser errors. The documentation clearly states that \u003ca href=\"https://benchmarkdotnet.org/articles/configs/diagnosers.html#restrictions\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eMemoryDiagnoser has an accuracy of 99.5%\u003c/a\u003e, which means slight measurement errors can occur.)\u003c/p\u003e\u003cp id=\"a10c\"\u003eIn simple cases, operations that require intermediate buffers like Distinct or OrderBy show large differences because aggressive pooling significantly reduces allocations (ZLinq uses somewhat aggressive pooling since it’s primarily based on \u003ccode\u003eref struct\u003c/code\u003e, which is expected to be short-lived):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"5b6f\"\u003eLINQ applies special optimizations based on method call patterns, so reducing allocations alone isn’t enough to always outperform it. For operator chain optimizations, such as those introduced in .NET 9 and described in \u003ca href=\"https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-9/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003ePerformance Improvements in .NET 9\u003c/a\u003e, ZLinq implements all these optimizations to achieve even higher performance:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9400\"\u003eA great benefit of ZLinq is that these LINQ evolution optimizations become available to all .NET generations (including .NET Framework), not just the latest versions.\u003c/p\u003e\u003cp id=\"6d2a\"\u003eUsage is simple — just add an \u003ccode\u003eAsValueEnumerable()\u003c/code\u003e call. Since all operators are 100% covered, replacing existing code works without issues:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"5410\"\u003eusing ZLinq;\u003cp\u003evar seq = source\u003cbr/\u003e    .AsValueEnumerable() // only add this line\u003cbr/\u003e    .Where(x =\u0026gt; x % 2 == 0)\u003cbr/\u003e    .Select(x =\u0026gt; x * 3);\u003cbr/\u003eforeach (var item in seq) { }\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"8b5d\"\u003eTo ensure behavior compatibility, ZLinq ports System.Linq.Tests from dotnet/runtime and continuously runs them at \u003ca href=\"https://github.com/Cysharp/ZLinq/tree/main/tests/System.Linq.Tests\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eZLinq/System.Linq.Tests\u003c/a\u003e.\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"9dd3\"\u003e9000 test cases guarantee behavior (Skip cases are due to ref struct limitations where identical test code can’t be run, etc.)\u003c/p\u003e\u003cp id=\"e832\"\u003eAdditionally, ZLinq provides a Source Generator for Drop-In Replacement that can optionally eliminate even the need for \u003ccode\u003eAsValueEnumerable()\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"b922\"\u003e[assembly: ZLinq.ZLinqDropInAttribute(\u0026#34;\u0026#34;, ZLinq.DropInGenerateTypes.Everything)]\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"c85c\"\u003eThis mechanism allows you to freely control the scope of the Drop-In Replacement. \u003ccode\u003eZLinq/System.Linq.Tests\u003c/code\u003e itself uses Drop-In Replacement to run existing test code with ZLinq without changing the tests.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"a507\"\u003eValueEnumerable Architecture and Optimization\u003c/h2\u003e\u003cp id=\"33e3\"\u003eFor usage, please refer to the ReadMe. Here, I’ll delve deeper into optimization. The architectural distinction goes beyond simply implementing lazy sequence execution, containing many innovations compared to collection processing libraries in other languages.\u003c/p\u003e\u003cp id=\"1bcd\"\u003eThe definition of \u003ccode\u003eValueEnumerable\u0026lt;T\u0026gt;\u003c/code\u003e, which forms the basis of chaining, looks like this:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"1fad\"\u003epublic readonly ref struct ValueEnumerable\u0026lt;TEnumerator, T\u0026gt;(TEnumerator enumerator)\u003cbr/\u003e    where TEnumerator : struct, IValueEnumerator\u0026lt;T\u0026gt;, allows ref struct // allows ref struct only in .NET 9 or later\u003cbr/\u003e{\u003cbr/\u003e    public readonly TEnumerator Enumerator = enumerator;\u003cbr/\u003e}\u003cp\u003epublic interface IValueEnumerator\u0026lt;T\u0026gt; : IDisposable\u003cbr/\u003e{\u003cbr/\u003e    bool TryGetNext(out T current); // as MoveNext + Current\u003cbr/\u003e    // Optimization helper\u003cbr/\u003e    bool TryGetNonEnumeratedCount(out int count);\u003cbr/\u003e    bool TryGetSpan(out ReadOnlySpan\u0026lt;T\u0026gt; span);\u003cbr/\u003e    bool TryCopyTo(scoped Span\u0026lt;T\u0026gt; destination, Index offset);\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"30b8\"\u003eBased on this, operators like Where chain as follows:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e782\"\u003epublic static ValueEnumerable\u0026lt;Where\u0026lt;TEnumerator, TSource\u0026gt;, TSource\u0026gt; Where\u0026lt;TEnumerator, TSource\u0026gt;(this ValueEnumerable\u0026lt;TEnumerator, TSource\u0026gt; source, Func\u0026lt;TSource, Boolean\u0026gt; predicate)\u003cbr/\u003e    where TEnumerator : struct, IValueEnumerator\u0026lt;TSource\u0026gt;, allows ref struct\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3acd\"\u003eWe chose this approach rather than using \u003ccode\u003eIValueEnumerable\u0026lt;T\u0026gt;\u003c/code\u003e because with a definition like \u003ccode\u003e(this TEnumerable source) where TEnumerable : struct, IValueEnumerable\u0026lt;TSource\u0026gt;\u003c/code\u003e, type inference for \u003ccode\u003eTSource\u003c/code\u003e would fail. This is due to a C# language limitation where type inference doesn\u0026#39;t work from type parameter constraints (\u003ca href=\"https://github.com/dotnet/csharplang/discussions/6930\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003edotnet/csharplang#6930\u003c/a\u003e). If implemented with that definition, it would require defining instance methods for a vast number of combinations. \u003ca href=\"https://github.com/kevin-montrose/LinqAF\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eLinqAF\u003c/a\u003e took that approach, resulting in \u003ca href=\"https://kevinmontrose.com/2018/01/17/linqaf-replacing-linq-and-not-allocating/\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e100,000+ methods and massive assembly sizes\u003c/a\u003e, which wasn\u0026#39;t ideal.\u003c/p\u003e\u003cp id=\"8e66\"\u003eIn LINQ, all implementation is in \u003ccode\u003eIValueEnumerator\u0026lt;T\u0026gt;\u003c/code\u003e, and since all Enumerators are structs, I realized that instead of using \u003ccode\u003eGetEnumerator()\u003c/code\u003e, we could simply copy-pass the common \u003ccode\u003eEnumerator\u003c/code\u003e, allowing each Enumerator to process with its independent state. This led to the final structure of wrapping \u003ccode\u003eIValueEnumerator\u0026lt;T\u0026gt;\u003c/code\u003e with \u003ccode\u003eValueEnumerable\u0026lt;TEnumerator, T\u0026gt;\u003c/code\u003e. This way, types appear in type declarations rather than constraints, avoiding type inference issues.\u003c/p\u003e\u003ch2 id=\"3c16\"\u003eTryGetNext\u003c/h2\u003e\u003cp id=\"0eab\"\u003eLet’s examine MoveNext, the core of iteration, in more detail:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"dbd5\"\u003e// Traditional interface\u003cbr/\u003epublic interface IEnumerator\u0026lt;out T\u0026gt; : IDisposable\u003cbr/\u003e{\u003cbr/\u003e    bool MoveNext();\u003cbr/\u003e    T Current { get; }\u003cbr/\u003e}\u003cp\u003e// iterate example\u003cbr/\u003ewhile (e.MoveNext())\u003cbr/\u003e{\u003cbr/\u003e    var item = e.Current; // invoke get_Current()\u003cbr/\u003e}\u003cbr/\u003e// ZLinq interface\u003cbr/\u003epublic interface IValueEnumerator\u0026lt;T\u0026gt; : IDisposable\u003cbr/\u003e{\u003cbr/\u003e    bool TryGetNext(out T current);\u003cbr/\u003e}\u003cbr/\u003e// iterate example\u003cbr/\u003ewhile (e.TryGetNext(out var item))\u003cbr/\u003e{\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"66df\"\u003eC#’s \u003ccode\u003eforeach\u003c/code\u003e expands to \u003ccode\u003eMoveNext() + Current\u003c/code\u003e, which presents two issues. First, each iteration requires two method calls: MoveNext and get_Current. Second, Current requires holding a variable. Therefore, I combined them into \u003ccode\u003ebool TryGetNext(out T current)\u003c/code\u003e. This reduces method calls to one per iteration, improving performance.\u003c/p\u003e\u003cp id=\"07f5\"\u003eThis \u003ccode\u003ebool TryGetNext(out T current)\u003c/code\u003e approach is also used in \u003ca href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eRust\u0026#39;s iterator\u003c/a\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"e5b0\"\u003epub trait Iterator {\u003cbr/\u003e    type Item;\u003cbr/\u003e    // Required method\u003cbr/\u003e    fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt;;\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"c150\"\u003eTo understand the variable holding issue, let’s look at the Select implementation:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"6608\"\u003epublic sealed class LinqSelect\u0026lt;TSource, TResult\u0026gt;(IEnumerator\u0026lt;TSource\u0026gt; source, Func\u0026lt;TSource, TResult\u0026gt; selector) : IEnumerator\u0026lt;TResult\u0026gt;\u003cbr/\u003e{\u003cbr/\u003e    // Three fields\u003cbr/\u003e    IEnumerator\u0026lt;TSource\u0026gt; source = source;\u003cbr/\u003e    Func\u0026lt;TSource, TResult\u0026gt; selector = selector;\u003cbr/\u003e    TResult current = default!;\u003cp\u003e    public TResult Current =\u0026gt; current;\u003c/p\u003e\u003cp\u003e    public bool MoveNext()\u003cbr/\u003e    {\u003cbr/\u003e        if (source.MoveNext())\u003cbr/\u003e        {\u003cbr/\u003e            current = selector(source.Current);\u003cbr/\u003e            return true;\u003cbr/\u003e        }\u003cbr/\u003e        return false;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003cp\u003epublic ref struct ZLinqSelect\u0026lt;TEnumerator, TSource, TResult\u0026gt;(TEnumerator source, Func\u0026lt;TSource, TResult\u0026gt; selector) : IValueEnumerator\u0026lt;TResult\u0026gt;\u003cbr/\u003e    where TEnumerator : struct, IValueEnumerator\u0026lt;TSource\u0026gt;, allows ref struct\u003cbr/\u003e{\u003cbr/\u003e    // Two fields\u003cbr/\u003e    TEnumerator source = source;\u003cbr/\u003e    Func\u0026lt;TSource, TResult\u0026gt; selector = selector;\u003cbr/\u003e    public bool TryGetNext(out TResult current)\u003cbr/\u003e    {\u003cbr/\u003e        if (source.TryGetNext(out var value))\u003cbr/\u003e        {\u003cbr/\u003e            current = selector(value);\u003cbr/\u003e            return true;\u003cbr/\u003e        }\u003cbr/\u003e        current = default!;\u003cbr/\u003e        return false;\u003cbr/\u003e    }\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"6f54\"\u003e\u003ccode\u003eIEnumerator\u0026lt;T\u0026gt;\u003c/code\u003e requires a \u003ccode\u003ecurrent\u003c/code\u003e field because it advances with \u003ccode\u003eMoveNext()\u003c/code\u003e and returns with \u003ccode\u003eCurrent\u003c/code\u003e. However, ZLinq advances and returns values simultaneously, eliminating the need to store the field. This makes a significant difference in ZLinq\u0026#39;s struct-based architecture. Since ZLinq embraces a structure where each method chain encompasses the previous struct entirely (\u003ccode\u003eTEnumerator\u003c/code\u003e being a struct), struct size grows with each method chain. While performance remains acceptable within reasonable method chain lengths, smaller structs mean lower copy costs and better performance. The adoption of \u003ccode\u003eTryGetNext\u003c/code\u003e was essential to minimize struct size.\u003c/p\u003e\u003cp id=\"ffb4\"\u003eA drawback of TryGetNext is that it cannot support covariance and contravariance. However, I believe iterators and arrays should abandon covariance/contravariance support altogether. They’re incompatible with \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e, making them outdated concepts when weighing pros and cons. For example, array Span conversion can fail at runtime without compile-time detection:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"d502\"\u003e// Due to generic variance, Derived[] is accepted by Base[]\u003cbr/\u003eBase[] array = new Derived[] { new Derived(), new Derived() };\u003cp\u003e// In this case, casting to Span\u0026lt;T\u0026gt; or using AsSpan() causes a runtime error!\u003cbr/\u003e// System.ArrayTypeMismatchException: Attempted to access an element as a type incompatible with the array.\u003cbr/\u003eSpan\u0026lt;Base\u0026gt; foo = array;\u003cbr/\u003eclass Base;\u003cbr/\u003eclass Derived : Base;\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"12ec\"\u003eWhile this behavior exists because these features were added before \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e, it\u0026#39;s problematic in modern .NET where Span is widely used, making features that can cause runtime errors practically unusable.\u003c/p\u003e\u003ch2 id=\"7013\"\u003eTryGetNonEnumeratedCount / TryGetSpan / TryCopyTo\u003c/h2\u003e\u003cp id=\"efba\"\u003eNaively enumerating everything doesn’t maximize performance. For example, when calling ToArray, if the size doesn’t change (e.g., \u003ccode\u003earray.Select().ToArray()\u003c/code\u003e), we can create a fixed-length array with \u003ccode\u003enew T[count]\u003c/code\u003e. System.LINQ internally uses an \u003ccode\u003eIterator\u0026lt;T\u0026gt;\u003c/code\u003e type for such optimizations, but since the parameter is \u003ccode\u003eIEnumerable\u0026lt;T\u0026gt;\u003c/code\u003e, code like \u003ccode\u003eif (source is Iterator\u0026lt;TSource\u0026gt; iterator)\u003c/code\u003e is always needed.\u003c/p\u003e\u003cp id=\"266e\"\u003eSince ZLinq is designed specifically for LINQ from the start, we’ve prepared for these optimizations. To avoid assembly size bloat, we’ve carefully selected the minimal set of definitions that provide maximum effect, resulting in these three methods.\u003c/p\u003e\u003cp id=\"a0ea\"\u003e\u003ccode\u003eTryGetNonEnumeratedCount(out int count)\u003c/code\u003e succeeds when the original source has a finite count and no filtering methods (Where, Distinct, etc., though Take and Skip are calculable) intervene. This benefits ToArray and methods requiring intermediate buffers like OrderBy and Shuffle.\u003c/p\u003e\u003cp id=\"e752\"\u003e\u003ccode\u003eTryGetSpan(out ReadOnlySpan\u0026lt;T\u0026gt; span)\u003c/code\u003e potentially delivers dramatic performance improvements when the source can be accessed as contiguous memory, enabling SIMD operations or Span-based loop processing for aggregation performance.\u003c/p\u003e\u003cp id=\"f19f\"\u003e\u003ccode\u003eTryCopyTo(scoped Span\u0026lt;T\u0026gt; destination, Index offset)\u003c/code\u003e enhances performance through internal iterators. To explain external vs. internal iterators, consider that \u003ccode\u003eList\u0026lt;T\u0026gt;\u003c/code\u003e offers both \u003ccode\u003eforeach\u003c/code\u003e and \u003ccode\u003eForEach\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"824c\"\u003e// external iterator\u003cbr/\u003eforeach (var item in list) { Do(item); }\u003cp\u003e// internal iterator\u003cbr/\u003elist.ForEach(Do);\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"f058\"\u003eThey look similar but perform differently. Breaking down the implementations:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"a447\"\u003e// external iterator\u003cbr/\u003eList\u0026lt;T\u0026gt;.Enumerator e = list.GetEnumerator();\u003cbr/\u003ewhile (e.MoveNext())\u003cbr/\u003e{\u003cbr/\u003e    var item = e.Current;\u003cbr/\u003e    Do(item);\u003cbr/\u003e}\u003cp\u003e// internal iterator\u003cbr/\u003efor (int i = 0; i \u0026lt; _size; i++)\u003cbr/\u003e{\u003cbr/\u003e    action(_items[i]);\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"3d4c\"\u003eThis becomes a competition between delegate call overhead (+ delegate creation allocation) vs. iterator MoveNext + Current calls. The iteration speed itself is faster with internal iterators. In some cases, delegate calls may be lighter, making internal iterators potentially advantageous in benchmarks.\u003c/p\u003e\u003cp id=\"ddd3\"\u003eOf course, this varies case by case, and since lambda captures and normal control flow (like continue, break, await, etc…) aren’t available, I personally believe \u003ccode\u003eForEach\u003c/code\u003e shouldn\u0026#39;t be used, nor should custom extension methods be defined to mimic it. However, this structural difference exists.\u003c/p\u003e\u003cp id=\"e159\"\u003e\u003ccode\u003eTryCopyTo(scoped Span\u0026lt;T\u0026gt; destination, Index offset)\u003c/code\u003e achieves limited internal iteration by accepting a \u003ccode\u003eSpan\u003c/code\u003e rather than a delegate.\u003c/p\u003e\u003cp id=\"c461\"\u003eUsing Select as an example, for ToArray when Count is available, it passes a Span for internal iteration:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"cd72\"\u003epublic ref struct Select\u003cbr/\u003e{\u003cbr/\u003e    public bool TryCopyTo(Span\u0026lt;TResult\u0026gt; destination, Index offset)\u003cbr/\u003e    {\u003cbr/\u003e        if (source.TryGetSpan(out var span))\u003cbr/\u003e        {\u003cbr/\u003e            if (EnumeratorHelper.TryGetSlice(span, offset, destination.Length, out var slice))\u003cbr/\u003e            {\u003cbr/\u003e                // loop inlining\u003cbr/\u003e                for (var i = 0; i \u0026lt; slice.Length; i++)\u003cbr/\u003e                {\u003cbr/\u003e                    destination[i] = selector(slice[i]);\u003cbr/\u003e                }\u003cbr/\u003e                return true;\u003cbr/\u003e            }\u003cbr/\u003e        }\u003cbr/\u003e        return false;\u003cbr/\u003e    }\u003cbr/\u003e}\u003cp\u003e// ------------------\u003c/p\u003e\u003cp\u003e// ToArray\u003cbr/\u003eif (enumerator.TryGetNonEnumeratedCount(out var count))\u003cbr/\u003e{\u003cbr/\u003e    var array = GC.AllocateUninitializedArray\u0026lt;TSource\u0026gt;(count);\u003cbr/\u003e    // try internal iterator\u003cbr/\u003e    if (enumerator.TryCopyTo(array.AsSpan(), 0))\u003cbr/\u003e    {\u003cbr/\u003e        return array;\u003cbr/\u003e    }\u003cbr/\u003e    // otherwise, use external iterator\u003cbr/\u003e    var i = 0;\u003cbr/\u003e    while (enumerator.TryGetNext(out var item))\u003cbr/\u003e    {\u003cbr/\u003e        array[i] = item;\u003cbr/\u003e        i++;\u003cbr/\u003e    }\u003cbr/\u003e    return array;\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"2c18\"\u003eThus, while Select can’t create a Span, if the original source can, processing as an internal iterator accelerates loop processing.\u003c/p\u003e\u003cp id=\"4170\"\u003e\u003ccode\u003eTryCopyTo\u003c/code\u003e differs from regular \u003ccode\u003eCopyTo\u003c/code\u003e by including an \u003ccode\u003eIndex offset\u003c/code\u003e and allowing destination to be smaller than the source (normal .NET CopyTo fails if destination is smaller). This enables ElementAt representation when destination size is 1 - index 0 becomes First, ^1 becomes Last. Adding \u003ccode\u003eFirst\u003c/code\u003e, \u003ccode\u003eLast\u003c/code\u003e, \u003ccode\u003eElementAt\u003c/code\u003e directly to \u003ccode\u003eIValueEnumerator\u0026lt;T\u0026gt;\u003c/code\u003e would create redundancy in class definitions (affecting assembly size), but combining small destinations with Index allows one method to cover more optimization cases:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2700\"\u003epublic static TSource ElementAt\u0026lt;TEnumerator, TSource\u0026gt;(this ValueEnumerable\u0026lt;TEnumerator, TSource\u0026gt; source, Index index)\u003cbr/\u003e    where TEnumerator : struct, IValueEnumerator\u0026lt;TSource\u0026gt;, allows ref struct\u003cbr/\u003e{\u003cbr/\u003e    using var enumerator = source.Enumerator;\u003cbr/\u003e    var value = default(TSource)!;\u003cbr/\u003e    var span = new Span\u0026lt;T\u0026gt;(ref value); // create single span\u003cbr/\u003e    if (enumerator.TryCopyTo(span, index))\u003cbr/\u003e    {\u003cbr/\u003e        return value;\u003cbr/\u003e    }\u003cbr/\u003e    // else...\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003ch2 id=\"58ce\"\u003eLINQ to Span\u003c/h2\u003e\u003cp id=\"0b41\"\u003eIn .NET 9 and above, ZLinq allows chaining all LINQ operators on \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e and \u003ccode\u003eReadOnlySpan\u0026lt;T\u0026gt;\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2499\"\u003eusing ZLinq;\u003cp\u003e// Can also be applied to Span (only in .NET 9/C# 13 environments that support allows ref struct)\u003cbr/\u003eSpan\u0026lt;int\u0026gt; span = stackalloc int[5] { 1, 2, 3, 4, 5 };\u003cbr/\u003evar seq1 = span.AsValueEnumerable().Select(x =\u0026gt; x * x);\u003cbr/\u003e// If enables Drop-in replacement, you can call LINQ operator directly.\u003cbr/\u003evar seq2 = span.Select(x =\u0026gt; x);\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7c75\"\u003eWhile some libraries claim to support LINQ for Spans, they typically only define extension methods for \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e without a generic mechanism. They offer limited operators due to language constraints that previously prevented receiving \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e as a generic parameter. Generic processing became possible with the introduction of \u003ccode\u003eallows ref struct\u003c/code\u003e in .NET 9.\u003c/p\u003e\u003cp id=\"c0ff\"\u003eIn ZLinq, there’s no distinction between \u003ccode\u003eIEnumerable\u0026lt;T\u0026gt;\u003c/code\u003e and \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e - they\u0026#39;re treated equally.\u003c/p\u003e\u003cp id=\"7176\"\u003eHowever, since \u003ccode\u003eallows ref struct\u003c/code\u003e requires language/runtime support, while ZLinq supports all .NET versions from .NET Standard 2.0 up, Span support is limited to .NET 9 and above. This means in .NET 9+, all operators are \u003ccode\u003eref struct\u003c/code\u003e, which differs from earlier versions.\u003c/p\u003e\u003ch2 id=\"c6f5\"\u003eLINQ to SIMD\u003c/h2\u003e\u003cp id=\"3951\"\u003eSystem.Linq accelerates certain aggregation methods with SIMD. For example, calling Sum or Max directly on primitive type arrays provides faster processing than using a for loop. However, being based on \u003ccode\u003eIEnumerable\u0026lt;T\u0026gt;\u003c/code\u003e, applicable types are limited. ZLinq makes this more generic through \u003ccode\u003eIValueEnumerator.TryGetSpan\u003c/code\u003e, targeting collections where \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e can be obtained (including direct \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e application).\u003c/p\u003e\u003cp id=\"c9cf\"\u003eSupported methods include:\u003c/p\u003e\u003cul\u003e\u003cli id=\"b1a3\"\u003e\u003cstrong\u003eRange\u003c/strong\u003e to ToArray/ToList/CopyTo/etc…\u003c/li\u003e\u003cli id=\"acc5\"\u003e\u003cstrong\u003eRepeat\u003c/strong\u003e for \u003ccode\u003eunmanaged struct\u003c/code\u003e and \u003ccode\u003esize is power of 2\u003c/code\u003e to ToArray/ToList/CopyTo/etc...\u003c/li\u003e\u003cli id=\"17a1\"\u003e\u003cstrong\u003eSum\u003c/strong\u003e for \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e\u003c/li\u003e\u003cli id=\"3037\"\u003e\u003cstrong\u003eSumUnchecked\u003c/strong\u003e for \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e\u003c/li\u003e\u003cli id=\"7681\"\u003e\u003cstrong\u003eAverage\u003c/strong\u003e for \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e\u003c/li\u003e\u003cli id=\"8bdc\"\u003e\u003cstrong\u003eMax\u003c/strong\u003e for \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003enint\u003c/code\u003e, \u003ccode\u003enuint\u003c/code\u003e, \u003ccode\u003eInt128\u003c/code\u003e, \u003ccode\u003eUInt128\u003c/code\u003e\u003c/li\u003e\u003cli id=\"688b\"\u003e\u003cstrong\u003eMin\u003c/strong\u003e for \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003enint\u003c/code\u003e, \u003ccode\u003enuint\u003c/code\u003e, \u003ccode\u003eInt128\u003c/code\u003e, \u003ccode\u003eUInt128\u003c/code\u003e\u003c/li\u003e\u003cli id=\"fa1f\"\u003e\u003cstrong\u003eContains\u003c/strong\u003e for \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003ebool\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003enint\u003c/code\u003e, \u003ccode\u003enuint\u003c/code\u003e\u003c/li\u003e\u003cli id=\"a43f\"\u003e\u003cstrong\u003eSequenceEqual\u003c/strong\u003e for \u003ccode\u003ebyte\u003c/code\u003e, \u003ccode\u003esbyte\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eushort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003eulong\u003c/code\u003e, \u003ccode\u003ebool\u003c/code\u003e, \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003enint\u003c/code\u003e, \u003ccode\u003enuint\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8e43\"\u003e\u003ccode\u003eSum\u003c/code\u003e checks for overflow, which adds overhead. We\u0026#39;ve added a custom \u003ccode\u003eSumUnchecked\u003c/code\u003e method that\u0026#39;s faster:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"217c\"\u003eSince these methods apply implicitly when conditions match, understanding the internal pipeline is necessary to target SIMD application. Therefore, for \u003ccode\u003eT[]\u003c/code\u003e, \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e, or \u003ccode\u003eReadOnlySpan\u0026lt;T\u0026gt;\u003c/code\u003e, we provide the \u003ccode\u003e.AsVectorizable()\u003c/code\u003e method to explicitly call SIMD-applicable operations like \u003ccode\u003eSum\u003c/code\u003e, \u003ccode\u003eSumUnchecked\u003c/code\u003e, \u003ccode\u003eAverage\u003c/code\u003e, \u003ccode\u003eMax\u003c/code\u003e, \u003ccode\u003eMin\u003c/code\u003e, \u003ccode\u003eContains\u003c/code\u003e, and \u003ccode\u003eSequenceEqual\u003c/code\u003e (though these fall back to normal processing when \u003ccode\u003eVector.IsHardwareAccelerated \u0026amp;\u0026amp; Vector\u0026lt;T\u0026gt;.IsSupported\u003c/code\u003e is false).\u003c/p\u003e\u003cp id=\"1e64\"\u003e\u003ccode\u003eint[]\u003c/code\u003e or \u003ccode\u003eSpan\u0026lt;int\u0026gt;\u003c/code\u003e gain the \u003ccode\u003eVectorizedFillRange\u003c/code\u003e method, which performs the same operation as \u003ccode\u003eValueEunmerable.Range().CopyTo()\u003c/code\u003e, filling with sequential numbers using SIMD acceleration. This is much faster than filling with a for loop when needed:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"09df\"\u003eVectorizable Methods\u003c/h2\u003e\u003cp id=\"8130\"\u003eHandwriting SIMD loop processing requires practice and effort. We’ve provided helpers that take Func arguments for casual use. While these incur delegate overhead and perform worse than inline code, they’re convenient for casual SIMD processing. They accept \u003ccode\u003eFunc\u0026lt;Vector\u0026lt;T\u0026gt;, Vector\u0026lt;T\u0026gt;\u0026gt; vectorFunc\u003c/code\u003e and \u003ccode\u003eFunc\u0026lt;T, T\u0026gt; func\u003c/code\u003e, processing with \u003ccode\u003eVector\u0026lt;T\u0026gt;\u003c/code\u003e where possible and handling remainder with \u003ccode\u003eFunc\u0026lt;T\u0026gt;\u003c/code\u003e.\u003c/p\u003e\u003cp id=\"f75d\"\u003e\u003ccode\u003eT[]\u003c/code\u003e and \u003ccode\u003eSpan\u0026lt;T\u0026gt;\u003c/code\u003e offer the \u003ccode\u003eVectorizedUpdate\u003c/code\u003e method:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"199f\"\u003eusing ZLinq.Simd; // needs using\u003cp\u003eint[] source = Enumerable.Range(0, 10000).ToArray();\u003cbr/\u003e[Benchmark]\u003cbr/\u003epublic void For()\u003cbr/\u003e{\u003cbr/\u003e    for (int i = 0; i \u0026lt; source.Length; i++)\u003cbr/\u003e    {\u003cbr/\u003e        source[i] = source[i] * 10;\u003cbr/\u003e    }\u003cbr/\u003e}\u003cbr/\u003e[Benchmark]\u003cbr/\u003epublic void VectorizedUpdate()\u003cbr/\u003e{\u003cbr/\u003e    // arg1: Vector\u0026lt;int\u0026gt; =\u0026gt; Vector\u0026lt;int\u0026gt;\u003cbr/\u003e    // arg2: int =\u0026gt; int\u003cbr/\u003e    source.VectorizedUpdate(static x =\u0026gt; x * 10, static x =\u0026gt; x * 10);\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"6304\"\u003eWhile faster than for loops, performance varies by machine environment and size, so verification is recommended for each use case.\u003c/p\u003e\u003cp id=\"690c\"\u003e\u003ccode\u003eAsVectorizable()\u003c/code\u003e provides \u003ccode\u003eAggregate\u003c/code\u003e, \u003ccode\u003eAll\u003c/code\u003e, \u003ccode\u003eAny\u003c/code\u003e, \u003ccode\u003eCount\u003c/code\u003e, \u003ccode\u003eSelect\u003c/code\u003e, and \u003ccode\u003eZip\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"82e6\"\u003esource.AsVectorizable().Aggregate((x, y) =\u0026gt; Vector.Min(x, y), (x, y) =\u0026gt; Math.Min(x, y))\u003cbr/\u003esource.AsVectorizable().All(x =\u0026gt; Vector.GreaterThanAll(x, new(5000)), x =\u0026gt; x \u0026gt; 5000);\u003cbr/\u003esource.AsVectorizable().Any(x =\u0026gt; Vector.LessThanAll(x, new(5000)), x =\u0026gt; x \u0026lt; 5000);\u003cbr/\u003esource.AsVectorizable().Count(x =\u0026gt; Vector.GreaterThan(x, new(5000)), x =\u0026gt; x \u0026gt; 5000);\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7e8c\"\u003ePerformance depends on data, but Count can show significant differences:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"bb6f\"\u003eFor \u003ccode\u003eSelect\u003c/code\u003e and \u003ccode\u003eZip\u003c/code\u003e, you follow with either \u003ccode\u003eToArray\u003c/code\u003e or \u003ccode\u003eCopyTo\u003c/code\u003e:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"bf05\"\u003e// Select\u003cbr/\u003esource.AsVectorizable().Select(x =\u0026gt; x * 3, x =\u0026gt; x * 3).ToArray();\u003cbr/\u003esource.AsVectorizable().Select(x =\u0026gt; x * 3, x =\u0026gt; x * 3).CopyTo(destination);\u003cp\u003e// Zip2\u003cbr/\u003earray1.AsVectorizable().Zip(array2, (x, y) =\u0026gt; x + y, (x, y) =\u0026gt; x + y).CopyTo(destination);\u003cbr/\u003earray1.AsVectorizable().Zip(array2, (x, y) =\u0026gt; x + y, (x, y) =\u0026gt; x + y).ToArray();\u003cbr/\u003e// Zip3\u003cbr/\u003earray1.AsVectorizable().Zip(array2, array3, (x, y, z) =\u0026gt; x + y + z, (x, y, z) =\u0026gt; x + y + z).CopyTo(destination);\u003cbr/\u003earray1.AsVectorizable().Zip(array2, array3, (x, y, z) =\u0026gt; x + y + z, (x, y, z) =\u0026gt; x + y + z).ToArray();\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"7ec4\"\u003eZip can be particularly interesting and fast for certain use cases (like merging two Vec3):\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003ch2 id=\"ecab\"\u003eLINQ to Tree\u003c/h2\u003e\u003cp id=\"9980\"\u003eHave you used LINQ to XML? In 2008 when LINQ appeared, XML was still dominant, and LINQ to XML’s usability was shocking. Now that JSON has taken over, LINQ to XML is rarely used.\u003c/p\u003e\u003cp id=\"b272\"\u003eHowever, LINQ to XML’s value lies in being a reference design for LINQ-style operations on tree structures — a guideline for making tree structures LINQ-compatible. Tree traversal abstractions work excellently with LINQ to Objects. A prime example is working with Roslyn’s SyntaxTree, where methods like Descendants are commonly used in Analyzers and Source Generators.\u003c/p\u003e\u003cp id=\"8b96\"\u003eZLinq extends this concept by defining an interface that generically enables \u003ccode\u003eAncestors\u003c/code\u003e, \u003ccode\u003eChildren\u003c/code\u003e, \u003ccode\u003eDescendants\u003c/code\u003e, \u003ccode\u003eBeforeSelf\u003c/code\u003e, and \u003ccode\u003eAfterSelf\u003c/code\u003e for tree structures:\u003c/p\u003e\u003cfigure\u003e\u003c/figure\u003e\u003cp id=\"a77d\"\u003eThis diagram shows traversal of Unity’s GameObject, but we’ve included standard implementations for FileSystem (DirectoryTree) and JSON (enabling LINQ to XML-style operations on System.Text.Json’s JsonNode). Of course, you can implement the interface for custom types:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"ccaa\"\u003epublic interface ITraverser\u0026lt;TTraverser, T\u0026gt; : IDisposable\u003cbr/\u003e    where TTraverser : struct, ITraverser\u0026lt;TTraverser, T\u0026gt; // self\u003cbr/\u003e{\u003cbr/\u003e    T Origin { get; }\u003cbr/\u003e    TTraverser ConvertToTraverser(T next); // for Descendants\u003cbr/\u003e    bool TryGetHasChild(out bool hasChild); // optional: optimize use for Descendants\u003cbr/\u003e    bool TryGetChildCount(out int count);   // optional: optimize use for Children\u003cbr/\u003e    bool TryGetParent(out T parent); // for Ancestors\u003cbr/\u003e    bool TryGetNextChild(out T child); // for Children | Descendants\u003cbr/\u003e    bool TryGetNextSibling(out T next); // for AfterSelf\u003cbr/\u003e    bool TryGetPreviousSibling(out T previous); // BeforeSelf\u003cbr/\u003e}\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"e9e3\"\u003eFor JSON, you can write:\u003c/p\u003e\u003cpre\u003e\u003cspan id=\"2871\"\u003evar json = JsonNode.Parse(\u0026#34;\u0026#34;\u0026#34;\u003cbr/\u003e// snip...\u003cbr/\u003e\u0026#34;\u0026#34;\u0026#34;);\u003cp\u003e// JsonNode\u003cbr/\u003evar origin = json![\u0026#34;nesting\u0026#34;]![\u0026#34;level1\u0026#34;]![\u0026#34;level2\u0026#34;]!;\u003cbr/\u003e// JsonNode axis, Children, Descendants, Anestors, BeforeSelf, AfterSelf and ***Self.\u003cbr/\u003eforeach (var item in origin.Descendants().Select(x =\u0026gt; x.Node).OfType\u0026lt;JsonArray\u0026gt;())\u003cbr/\u003e{\u003cbr/\u003e    // [true, false, true], [\u0026#34;fast\u0026#34;, \u0026#34;accurate\u0026#34;, \u0026#34;balanced\u0026#34;], [1, 1, 2, 3, 5, 8, 13]\u003cbr/\u003e    Console.WriteLine(item.ToJsonString(JsonSerializerOptions.Web));\u003cbr/\u003e}\u003c/p\u003e\u003c/span\u003e\u003c/pre\u003e\u003cp id=\"1d5d\"\u003eWe’ve included standard LINQ to Tree implementations for Unity’s \u003ccode\u003eGameObject\u003c/code\u003e and \u003ccode\u003eTransform\u003c/code\u003e and Godot\u0026#39;s \u003ccode\u003eNode\u003c/code\u003e. Since allocation and traversal performance are carefully optimized, they might even be faster than manual loops.\u003c/p\u003e\u003c/div\u003e\u003cdiv\u003e\u003ch2 id=\"c4a8\"\u003eOSS and Me\u003c/h2\u003e\u003cp id=\"81ba\"\u003eThere have been several incidents in .NET-related OSS in recent months, including the commercialization of well-known OSS projects. With over 40 OSS projects under \u003ca href=\"https://github.com/Cysharp\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003egithub/Cysharp\u003c/a\u003e and more under my personal and other organizations like MessagePack, totaling over 50,000 stars, I believe I’m one of the largest OSS providers in the .NET ecosystem.\u003c/p\u003e\u003cp id=\"f04a\"\u003eRegarding commercialization, I have no plans for it, but maintenance has become challenging due to growing scale. A major factor in OSS projects attempting commercialization despite criticism is the mental burden on maintainers (compensation doesn’t match time investment). I experience this too!\u003c/p\u003e\u003cp id=\"15bc\"\u003eSetting aside financial aspects, my request is for users to accept occasional maintenance delays! When developing large libraries like ZLinq, I need focused time, which means Issues and PRs for other libraries might go without response for months. I intentionally avoid looking at them, not even reading titles (avoiding dashboards and notification emails). This seemingly neglectful approach is necessary to create innovative libraries — a necessary sacrifice!\u003c/p\u003e\u003cp id=\"4aa6\"\u003eEven without that, the sheer number of libraries means rotation delays of months are inevitable. This is unavoidable due to absolute manpower shortage, so please accept these delays and don’t claim “this library is dead” just because responses are slow. That’s painful to hear! I try my best, but creating new libraries consumes tremendous time, causing cascading delays that drain my mental energy.\u003c/p\u003e\u003cp id=\"5c23\"\u003eAlso, irritations related to Microsoft can reduce motivation — a common experience for C# OSS maintainers. Despite this, I hope to continue long-term.\u003c/p\u003e\u003ch2 id=\"8da8\"\u003eConclusion\u003c/h2\u003e\u003cp id=\"dd7b\"\u003eZLinq’s structure changed significantly after feedback from the initial preview release. \u003ca href=\"https://github.com/Akeit0\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@Akeit0\u003c/a\u003e provided many proposals for core performance-critical elements like the \u003ccode\u003eValueEnumerable\u0026lt;TEnumerator, T\u0026gt;\u003c/code\u003e definition and adding \u003ccode\u003eIndex\u003c/code\u003e to \u003ccode\u003eTryCopyTo\u003c/code\u003e. \u003ca href=\"https://github.com/filzrev\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003e@filzrev\u003c/a\u003e contributed extensive test and benchmark infrastructure. Ensuring compatibility and performance improvements wouldn\u0026#39;t have been possible without their contributions, for which I\u0026#39;m deeply grateful.\u003c/p\u003e\u003cp id=\"3e2d\"\u003eWhile zero-allocation LINQ libraries aren’t novel, ZLinq’s thoroughness sets it apart. With experience and knowledge, driven by sheer determination, we implemented all methods, ran all test cases for complete compatibility, and implemented all optimizations including SIMD. This was truly challenging!\u003c/p\u003e\u003cp id=\"cf5a\"\u003eThe timing was perfect as .NET 9/C# 13 provided all the language features needed for a full implementation. Simultaneously, maintaining support for Unity and .NET Standard 2.0 was also important.\u003c/p\u003e\u003cp id=\"72be\"\u003eBeyond being just a zero-allocation LINQ, LINQ to Tree is a favorite feature that I hope people will try!\u003c/p\u003e\u003cp id=\"8175\"\u003eOne LINQ performance bottleneck is delegates, and some libraries adopt a ValueDelegate approach using structs to mimic Func. We deliberately avoided this because such definitions are impractical due to their complexity. It’s better to write inline code than use LINQ with ValueDelegate structures. Complicating internal structure and bloating assembly size for benchmark hacks is wasteful, so we accept only System.Linq-compatible.\u003c/p\u003e\u003cp id=\"7cf6\"\u003e\u003ca href=\"https://github.com/Cysharp/R3\" rel=\"noopener ugc nofollow\" target=\"_blank\"\u003eR3\u003c/a\u003e was an ambitious library intended to replace .NET’s standard System.Reactive, but replacing System.Linq would be a much larger or perhaps excessive undertaking, so I think there might be some resistance to adoption. However, I believe we’ve demonstrated sufficient benefits to justify the replacement, so I’d be very happy if you could try it out!\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "27 min read",
  "publishedTime": "2025-05-15T09:44:43.2Z",
  "modifiedTime": null
}
