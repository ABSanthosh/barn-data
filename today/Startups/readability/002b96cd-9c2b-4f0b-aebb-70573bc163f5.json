{
  "id": "002b96cd-9c2b-4f0b-aebb-70573bc163f5",
  "title": "Better Shell History Search",
  "link": "https://tratt.net/laurie/blog/2025/better_shell_history_search.html",
  "description": "Article URL: https://tratt.net/laurie/blog/2025/better_shell_history_search.html Comments URL: https://news.ycombinator.com/item?id=43476793 Points: 8 # Comments: 3",
  "author": "ltratt",
  "published": "Tue, 25 Mar 2025 22:35:17 +0000",
  "source": "https://hnrss.org/frontpage",
  "categories": null,
  "byline": "",
  "length": 14432,
  "excerpt": "I spend an awful lot of my day in Unix terminals running shell commands. For some reason, the variance in efficiency between different people when using the shell is huge: I know people who can run rings around me, and I’ve come across more than one paid professional who doesn’t use the “up” key to retrieve the previous command.",
  "siteName": "",
  "favicon": "",
  "text": "I spend an awful lot of my day in Unix terminals running shell commands. For some reason, the variance in efficiency between different people when using the shell is huge: I know people who can run rings around me, and I’ve come across more than one paid professional who doesn’t use the “up” key to retrieve the previous command. I chose that last example very deliberately: most of the commands most of us run in the shell are highly repetitive. I typically run around 50-100 unique (i.e. syntactically distinct) shell commands per working day [1] — but I’ll often run a tiny subset of those commands (e.g. cargo test) hundreds of time in a single day. Since many command-line tools have hard-to-remember options, we can save huge chunks of time – not to mention make fewer errors – if we can search our shell history to find a previous incantation of a command we want to run. In this post I’m going to show how, with little effort, searching shell history can look like this: [Video] Searching shell history Larger Unix shells such as Bash have long allowed users to search through their shell history by pressing Ctrl-r and entering a substring. If I (in order) executed the commands cat /etc/motd then cat /etc/rc.conf, then Ctrl-r followed by “cat” will first match cat /etc/rc.conf; pressing Ctrl-r again will cycle backwards for the next match which is cat /etc/motd. I almost never used this feature, because substring matching is too crude. For example, I may know the command I want is cat, the leaf name I’m looking for is motd but I don’t remember the directory: substring matching can’t help me find what I’m looking for. Instead, I regularly used grep (with wildcards) to search through my shell’s history file instead. For me, the game changer was pairing Ctrl-r with fzf, which brought two changes. First, matching is “fuzzy”, so I can type “c mo” and cat /etc/motd will be matched. Second, multiple matches are shown at once. Typing “cat” will show me several cat commands, allowing me to quickly select the right incantation (which may not have been the most recent). It’s difficult for me to overstate how powerful a feature this is. Few things in life make me as happy as pressing ctrl-R then typing “l1” and having a 100 character command-line execution that runs a complicated debugging tool, with multiple environment variables set, whose output gets put in /tmp/l1 appear in my terminal. Using Ctrl-r and fzf roughly doubled my efficiency in the shell overnight. Interestingly, it had an even greater long term effect: I became a more ambitious user of shell commands because I knew I could outsource my memory to fzf. For example, since it’s now very easy to recall past commands, I no longer set global environment variables, which had previously caused me grief when I forgot about them [2]. Now I set environment variables on a per-command basis, knowing that I can recall them with Ctrl-r and fzf. For many years my favoured shell was zsh. When I later moved from zsh to fish, Ctrl-r and fzf was the first thing I configured; and when I moved back to zsh [3], and redid my configuration from scratch, Ctrl-r and fzf was again the first thing I got working (shortly followed by autosuggestions). If you take nothing else from this post than “Ctrl-r and fzf are a significant productivity boon for Unix users”, then I will have done something useful. No tool, of course, is perfect. A couple of months back I somehow stumbled across skim, an fzf-alike that out-of-the-box happens to suit me just a little bit better than fzf. The differences are mostly minor, and you won’t go far wrong with either tool. That said, I find that skim’s matching more often finds the commands I want quickly, I prefer skim’s UI, and I find it easier to install skim on random boxes — small advantages, perhaps, but enough for switching to be worth it for me. Doing even better Finding Skim encouraged me to quickly look around to see what else in this sphere might improve my productivity. I quickly came across Atuin, which is a much more sophisticated shell history recording mechanism: the video on its front page showed a much nicer matching UI than I had previously considered possible. However, I quickly realised Atuin wasn’t for me or, at least, wasn’t easily for me. These days I regularly ssh into many different servers: over time I’ve streamlined my shell configuration to a single .zshrc file that I can scp over to a new machine and which instantly makes me productive. Atuin – and this isn’t a criticism, because it’s a more powerful tool – is more difficult to install [4] and setup [5] (I’m also not sure the ‘fuzzy’ aspects of Atuin quite match the heights of fzf/skim). That said, some readers may find it a useful tool to investigate. However, what I immediately realised from the Atuin video is that I would like my fuzzy matcher to show me more useful information about the commands it’s matching. In particular, fzf and skim both default to showing me a (to me!) meaningless integer before my matched command: this had always slightly bothered me, but I’d never thought to work out what it meant. For example, if I use zsh + fzf + Ctrl-r I see: What does 5408 mean and why is it taking up valuable screen space? Skim tries to be a bit nicer: it will show 5408 today'21:26 [6], but that takes up even more screen space! Adapting zsh and fzf/skim Fortunately, it turns out that improving the Ctrl-r and the fzf/skim UI is easy. Instead of wasting space on a meaningless-to-me integer, what I now see is the following (where 11d means “11 days in the past” and so on): I’m going to show how I adapted zsh and skim to do this. My guess is that it will take very little ingenuity to adapt this to other shells (and adapting this to fzf mostly involves swapping the sk command for fzf). The first thing I needed to do is make zsh record when commands were executed. I added this to my ~/.zshrc: setopt EXTENDED_HISTORY setopt inc_append_history_time The EXTENDED_HISTORY changes the format of .zsh_history to record when (in seconds from the Unix epoch) a command was executed and (with inc_append_history_time) how long it ran for. The good news is that these options migrate “traditionally formatted” history files naturally: any non-extended-history commands will be given the current date so that all of .zsh_history is in the same format. I then needed to understand how zsh’s history ended up being interrogated and displayed when I pressed Ctrl-r. fzf and skim share almost exactly the same code here: I’ll use skim’s zsh key bindings as my example. In essence, both tools define a function history-widget which they then bind to Ctrl-r: history-widget() { ... } zle -N history-widget bindkey '^R' history-widget One can override the version fzf and skim provide by putting the code above into your ~/.zshrc after the point you import their normal key bindings. Let’s look at skim’s history-widget: skim-history-widget() { local selected num setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases 2\u003e /dev/null local awk_filter='{ cmd=$0; sub(/^\\s*[0-9]+\\**\\s+/, \"\", cmd); if (!seen[cmd]++) print $0 }' # filter out duplicates local n=2 fc_opts='' if [[ -o extended_history ]]; then local today=$(date +%Y-%m-%d) # For today's commands, replace date ($2) with \"today\", otherwise remove time ($3). # And filter out duplicates. awk_filter='{ if ($2 == \"'$today'\") sub($2 \" \", \"today'\\''\") else sub($3, \"\") line=$0; $1=\"\"; $2=\"\"; $3=\"\" if (!seen[$0]++) print line }' fc_opts='-i' n=3 fi selected=( $(fc -rl $fc_opts 1 | awk \"$awk_filter\" | SKIM_DEFAULT_OPTIONS=\"--height ${SKIM_TMUX_HEIGHT:-40%} $SKIM_DEFAULT_OPTIONS -n$n..,.. --bind=ctrl-r:toggle-sort $SKIM_CTRL_R_OPTS --query=${(qqq)LBUFFER} --no-multi\" $(__skimcmd)) ) ... The first thing to note is that – thanks to EXTENDED_HISTORY – in my context the -o extended_history check always returns true, so the body of the if is always executed. We can then skip ahead: fc -rli 1 gets zsh to output its history in a more easily digestible form than going through .zsh_history directly: $ fc -rli 1 4 2025-02-07 15:05 pizauth status 3 2025-02-07 15:03 cargo run --release server 2 2025-02-07 15:03 email quick 1 2025-02-07 14:59 rsync_cmd bencher16 ./build.sh cargo test nested_tracing We can also now see what the magical integers from earlier are: they’re the row numbers from fc, where 1 is the oldest command in my ~/.zsh_history! These are, in some situations, used as identifiers because one can ask zsh to “return me command 5408”. The awk code streams over this output, replacing today’s date with the literal string today, removes the hours/minutes output from previous days, and removes duplicates. Although it’s easily missed, in the final line of the code snippet is -n$n..,.. which tells skim which whitespace-separated columns to fuzzy match and print out. At this point we now need to decide how to adapt things to our purposes. The first thing we need to do with fc’s output is convert the time to seconds since the Unix epoch. We can get fc to do that for us with -t '%s'. Instead of outputting 2025-03-21 22:10 we now get 1742595052. Notice that two fields have now become one! Because fc adds leading space to the row numbers, we’ll strip that off by piping fc’s output through sed -E \"s/^ *//\" [7]. I then needed to decide how to format “how far in the past was the command run”. After a few tries, I decided that a good approach is to give absolute hour:minute times for commands in the last 20 hours, and 1d, 2d (etc.) for commands 1 or more days in the past. Why 20 hours? Well, it turns out that if I start work at 08:00, press Ctrl-r and see an entry at 08:01 I won’t realise that was yesterday’s 08:01 (today’s 08:01 is only 60 seconds in the future!). 20 hours solves this ambiguity: it means that, at 08:00, yesterday afternoon’s commands show as 16:33 but yesterday morning’s commands as 1d. We now need to switch to awk. I will admit that I initially balked at the use of awk, a language I have never used before. I quickly explored alternatives before realising why the code uses awk: every Unix machine has awk installed. For those unfamiliar with awk, the program that we’re writing iterates over each line in the input, splits that line up by whitespace, and puts the split fields into the variables $1, $2 (etc.). We’ll keep the duplicate detection from the awk code above, but change most of the rest. The first thing we need to do in awk is to convert the Unix epoch time for a command (in field/variable $2) to an integer, and calculate how many seconds it is in the past using systime (which returns the current time relative to the Unix epoch): ts = int($2) delta = systime() - ts We can then convert delta seconds to days by dividing by 86,400 (24h * 60m * 60s == 86,400s). It’s then a simple series of if/else to format this nicely bearing in mind that: 20h == 72,000s string concatenation and int-to-string conversion in awk is implicit The conversion code looks as follows: delta_days = int(delta / 86400) if (delta_days \u003c 1 \u0026\u0026 delta \u003c 72000) { $2=strftime(\"%H:%M\", ts) } else if (delta_days == 0) { $2=\"1d\" } else { $2=delta_days \"d\" } One could choose to divvy things up further, perhaps showing commands older than a week with “1w” and so on: I haven’t found that worth worrying about yet. There is, however, one minor fly in the ointment: clock skew. This could cause commands to appear to be executing in the future. I’ve not seen seen this happen in practice yet, but bitter experience with computers and clocks tells me it will at some point. I’ve defensively catered for the inevitable confusion that will cause me by using a + prefix for such cases: delta_days = int(delta / 86400) if (delta \u003c 0) { $2=\"+\" (-delta_days) \"d\" } else ... Notice that I had to put (-delta_days) in brackets as otherwise – for reasons I’m too lazy to investigate – awk doesn’t concatenate the integer and string in the way I want. Since we have one fewer field than before we can slightly simplify our output: line=$0; $1=\"\"; $2=\"\" if (!seen[$0]++) print line That’s the awk code done. We then need to make one change to the selected=... line changing -n$n..,.. to --with-nth $n... This tells fzf and skim to suppress the output of the row number and not to make it part of the fuzzy matching either. Putting all that together, the updated chunk of the history-widget now looks as follows (you can find the whole code chunk here): local n=1 fc_opts='' if [[ -o extended_history ]]; then awk_filter=' { ts = int($2) delta = systime() - ts delta_days = int(delta / 86400) if (delta \u003c 0) { $2=\"+\" (-delta_days) \"d\" } else if (delta_days \u003c 1 \u0026\u0026 delta \u003c 72000) { $2=strftime(\"%H:%M\", ts) } else if (delta_days == 0) { $2=\"1d\" } else { $2=delta_days \"d\" } line=$0; $1=\"\"; $2=\"\" if (!seen[$0]++) print line }' fc_opts='-i' n=2 fi selected=( $(fc -rl $fc_opts -t '%s' 1 | sed -E \"s/^ *//\" | awk \"$awk_filter\" | SKIM_DEFAULT_OPTIONS=\"--height ${SKIM_TMUX_HEIGHT:-40%} $SKIM_DEFAULT_OPTIONS --with-nth $n.. --bind=ctrl-r:toggle-sort $SKIM_CTRL_R_OPTS --query=${(qqq)LBUFFER} --no-multi\" $(__skimcmd)) ) That simple change is enough to give me this output when I press Ctrl-r and start typing: [Video] Summary I’ve been using the changes above for about 6 weeks, and I’ve found it a meaningful productivity enhancement. It turns out that I often remember enough about a command I want to recall that seeing if a match is “1d” or “7d” in the past is enough to immediately rule it in or out without scanning rightwards. Occasionally I even search on the time delta itself: if I start a match with “2d” fzf or skim will naturally search commands from 2 days ago. But, perhaps, there is a larger point to take from this post. If, like me, you spend a lot of your life in a Unix terminal, it can be easy to fall into patterns of usage that would be recognisable to shell users from the 1970s. Not only can we do better, it’s easy to do so, and the productivity gains can be substantial! Acknowledgements: thanks to Edd Barrett for comments. 2025-03-25 11:50 Older If you’d like updates on new blog posts: follow me on Mastodon or Twitter; or subscribe to the RSS feed; or subscribe to email updates: Footnotes Comments",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"article-body\"\u003e\n\n\n\n\n\n\u003cp\u003eI spend an awful lot of my day in Unix terminals running shell commands. For\nsome reason, the variance in efficiency between different people when using the shell\nis huge: I know people who can run rings around me, and I’ve come across\nmore than one paid professional who doesn’t use the “up” key to retrieve the\nprevious command.\u003c/p\u003e\n\u003cp\u003eI chose that last example very deliberately: most of the commands most of us\nrun in the shell are highly repetitive. I typically run around 50-100 unique\n(i.e. syntactically distinct) shell commands per working day \u003cspan\u003e[1]\u003c/span\u003e — but\nI’ll often run a tiny subset of those commands (e.g. \u003ccode\u003ecargo test\u003c/code\u003e) hundreds of\ntime in a single day.\u003c/p\u003e\n\u003cp\u003eSince many command-line tools have hard-to-remember options, we can save huge\nchunks of time – not to mention make fewer errors – if we can search our\nshell history to find a previous incantation of a command we want to run. In\nthis post I’m going to show how, with little effort, searching shell\nhistory can look like this:\u003c/p\u003e\n\u003cp\u003e\u003cvideo controls=\"\"\u003e\u003csource src=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4\" type=\"video/mp4\"/\u003e\u003ca href=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4\"\u003e[Video]\u003c/a\u003e\u003c/video\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca name=\"searching_shell_history\"\u003eSearching shell history\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLarger Unix shells such as Bash have long allowed users to search through their\nshell history by pressing \u003ccode\u003eCtrl-r\u003c/code\u003e and entering a substring. If I (in order)\nexecuted the commands \u003ccode\u003ecat /etc/motd\u003c/code\u003e then \u003ccode\u003ecat /etc/rc.conf\u003c/code\u003e, then \u003ccode\u003eCtrl-r\u003c/code\u003e\nfollowed by “cat” will first match \u003ccode\u003ecat /etc/rc.conf\u003c/code\u003e; pressing \u003ccode\u003eCtrl-r\u003c/code\u003e again\nwill cycle backwards for the next match which is \u003ccode\u003ecat /etc/motd\u003c/code\u003e. I almost\nnever used this feature, because substring matching is too crude.\nFor example, I may know the command I want is \u003ccode\u003ecat\u003c/code\u003e, the leaf\nname I’m looking for is \u003ccode\u003emotd\u003c/code\u003e but I don’t remember the directory: substring\nmatching can’t help me find what I’m looking for. Instead, I regularly used\n\u003ccode\u003egrep\u003c/code\u003e (with wildcards) to search through my shell’s history file instead.\u003c/p\u003e\n\u003cp\u003eFor me, the game changer was pairing \u003ccode\u003eCtrl-r\u003c/code\u003e with\n\u003ca href=\"https://github.com/junegunn/fzf\"\u003efzf\u003c/a\u003e, which brought two changes. First,\nmatching is “fuzzy”, so I can type “c mo” and \u003ccode\u003ecat /etc/motd\u003c/code\u003e will be\nmatched. Second, multiple matches are shown at once. Typing “cat” will show\nme several \u003ccode\u003ecat\u003c/code\u003e commands, allowing me to quickly select the right\nincantation (which may not have been the most recent).\u003c/p\u003e\n\u003cp\u003eIt’s difficult for me to overstate how powerful a feature this is. Few things\nin life make me as happy as pressing \u003ccode\u003ectrl-R\u003c/code\u003e then typing “\u003ccode\u003el1\u003c/code\u003e” and having a 100\ncharacter command-line execution that runs a complicated debugging tool, with\nmultiple environment variables set, whose output gets put in \u003ccode\u003e/tmp/l1\u003c/code\u003e appear\nin my terminal.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003eCtrl-r\u003c/code\u003e and fzf roughly doubled my efficiency in the shell\novernight. Interestingly, it had an even greater long term effect: I became a\nmore ambitious user of shell commands because I knew I could outsource my\nmemory to fzf. For example, since it’s now very easy to recall past commands, I\nno longer set global environment variables, which had previously caused me\ngrief when I forgot about them \u003cspan\u003e[2]\u003c/span\u003e. Now I set environment variables on a\nper-command basis, knowing that I can recall them with \u003ccode\u003eCtrl-r\u003c/code\u003e and fzf.\u003c/p\u003e\n\u003cp\u003eFor many years my favoured shell was zsh. When I later moved from zsh to fish,\n\u003ccode\u003eCtrl-r\u003c/code\u003e and fzf was the first thing I configured; and when I moved back to zsh\n\u003cspan\u003e[3]\u003c/span\u003e, and redid my configuration from scratch, \u003ccode\u003eCtrl-r\u003c/code\u003e and fzf was again the first\nthing I got working (shortly followed by\n\u003ca href=\"https://github.com/zsh-users/zsh-autosuggestions\"\u003eautosuggestions\u003c/a\u003e). If you\ntake nothing else from this\npost than “\u003ccode\u003eCtrl-r\u003c/code\u003e and fzf are a significant productivity boon for Unix\nusers”, then I will have done something useful.\u003c/p\u003e\n\u003cp\u003eNo tool, of course, is perfect. A\ncouple of months back I somehow stumbled across\n\u003ca href=\"https://github.com/skim-rs/skim\"\u003eskim\u003c/a\u003e, an fzf-alike that out-of-the-box\nhappens to suit me just a little bit better than fzf. The differences\nare mostly minor, and you won’t go far wrong with either tool. That said,\nI find that skim’s matching more often finds the commands I want quickly,\nI prefer skim’s UI, and I find it easier to install skim on\nrandom boxes — small advantages, perhaps, but enough for switching to be\nworth it for me.\u003c/p\u003e\n\u003ch2\u003e\u003ca name=\"doing_even_better\"\u003eDoing even better\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFinding Skim encouraged me to quickly look around to see what else in this sphere might\nimprove my productivity. I quickly came across \u003ca href=\"https://atuin.sh/\"\u003eAtuin\u003c/a\u003e, which is a much\nmore sophisticated shell history recording mechanism: the video on its front\npage showed a much nicer matching UI than I had previously considered possible.\u003c/p\u003e\n\u003cp\u003eHowever, I quickly realised Atuin wasn’t for me or, at least, wasn’t easily for\nme. These days I regularly \u003ccode\u003essh\u003c/code\u003e into many different servers: over time I’ve\nstreamlined my shell configuration to a single \u003ccode\u003e.zshrc\u003c/code\u003e file that I can \u003ccode\u003escp\u003c/code\u003e\nover to a new machine and which instantly makes me productive. Atuin – and\nthis isn’t a criticism, because it’s a more powerful tool – is more difficult\nto install \u003cspan\u003e[4]\u003c/span\u003e and setup \u003cspan\u003e[5]\u003c/span\u003e (I’m also not sure the ‘fuzzy’\naspects of Atuin quite match the heights of fzf/skim). That said, some readers may find\nit a useful tool to investigate.\u003c/p\u003e\n\u003cp\u003eHowever, what I immediately realised from the Atuin video is that I would like\nmy fuzzy matcher to show me more useful information about the commands it’s\nmatching.\u003c/p\u003e\n\u003cp\u003eIn particular, fzf and skim both default to showing me a (to me!) meaningless\ninteger before my matched command: this had always slightly bothered me, but\nI’d never thought to work out what it meant. For example, if I use\nzsh + fzf + \u003ccode\u003eCtrl-r\u003c/code\u003e I see:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/fzf.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eWhat does 5408 mean and why is it taking up valuable screen space? Skim\ntries to be a bit nicer: it will show \u003ccode\u003e5408 today\u0026#39;21:26\u003c/code\u003e \u003cspan\u003e[6]\u003c/span\u003e, but that\ntakes up even more screen space!\u003c/p\u003e\n\u003ch2\u003e\u003ca name=\"adapting_zsh_and_fzfskim\"\u003eAdapting zsh and fzf/skim\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFortunately, it turns out that improving the \u003ccode\u003eCtrl-r\u003c/code\u003e and the fzf/skim UI is\neasy. Instead of wasting space on a meaningless-to-me integer, what I\nnow see is the following (where \u003ccode\u003e11d\u003c/code\u003e means “11 days in the past” and so on):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eI’m going to show how I adapted zsh and skim to do this. My guess is that it\nwill take very little ingenuity to adapt this to other shells (and adapting\nthis to fzf mostly involves swapping the \u003ccode\u003esk\u003c/code\u003e command for \u003ccode\u003efzf\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThe first thing I needed to do is make zsh record \u003cem\u003ewhen\u003c/em\u003e commands\nwere executed. I added this to my \u003ccode\u003e~/.zshrc\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003esetopt\u003c/span\u003e\u003cspan\u003e EXTENDED_HISTORY\n\u003c/span\u003e\u003cspan\u003esetopt\u003c/span\u003e\u003cspan\u003e inc_append_history_time\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eEXTENDED_HISTORY\u003c/code\u003e changes the format of \u003ccode\u003e.zsh_history\u003c/code\u003e to record when (in\nseconds from the Unix epoch) a command was executed and (with\n\u003ccode\u003einc_append_history_time\u003c/code\u003e) how long it ran for. The good news is that these\noptions migrate “traditionally formatted” history files naturally: any\nnon-extended-history commands will be given the current date so that\nall of \u003ccode\u003e.zsh_history\u003c/code\u003e is in the same format.\u003c/p\u003e\n\u003cp\u003eI then needed to understand how zsh’s history ended up being interrogated and\ndisplayed when I pressed \u003ccode\u003eCtrl-r\u003c/code\u003e. fzf and skim share almost exactly the same\ncode here: I’ll use skim’s \u003ca href=\"https://github.com/skim-rs/skim/blob/master/shell/key-bindings.zsh\"\u003ezsh key\nbindings\u003c/a\u003e\nas my example. In essence, both tools define a function \u003ccode\u003ehistory-widget\u003c/code\u003e\nwhich they then bind to \u003ccode\u003eCtrl-r\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003ehistory-widget\u003c/span\u003e\u003cspan\u003e() { \u003c/span\u003e\u003cspan\u003e... \u003c/span\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003cspan\u003ezle\u003c/span\u003e\u003cspan\u003e     -N\u003c/span\u003e\u003cspan\u003e   history-widget\n\u003c/span\u003e\u003cspan\u003ebindkey \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e^R\u003c/span\u003e\u003cspan\u003e\u0026#39; history-widget\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eOne can override the version fzf and skim provide by putting the code above\ninto your \u003ccode\u003e~/.zshrc\u003c/code\u003e after the point you import their normal key bindings.\u003c/p\u003e\n\u003cp\u003eLet’s look at skim’s \u003ccode\u003ehistory-widget\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003eskim-history-widget\u003c/span\u003e\u003cspan\u003e() {\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003elocal \u003c/span\u003e\u003cspan\u003eselected num\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003esetopt\u003c/span\u003e\u003cspan\u003e localoptions noglobsubst noposixbuiltins pipefail no_aliases \u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e\u0026gt; /dev/null\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003elocal \u003c/span\u003e\u003cspan\u003eawk_filter\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u003c/span\u003e\u003cspan\u003e{ cmd=$0; sub(/^\\s*[0-9]+\\**\\s+/, \u0026#34;\u0026#34;, cmd); if (!seen[cmd]++) print $0 }\u003c/span\u003e\u003cspan\u003e\u0026#39;  \u003c/span\u003e\u003cspan\u003e# filter out duplicates\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003elocal \u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e2 \u003c/span\u003e\u003cspan\u003efc_opts\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u0026#39;\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003e[[ \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e extended_history \u003c/span\u003e\u003cspan\u003e]]\u003c/span\u003e\u003cspan\u003e; \u003c/span\u003e\u003cspan\u003ethen\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elocal \u003c/span\u003e\u003cspan\u003etoday\u003c/span\u003e\u003cspan\u003e=$\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edate\u003c/span\u003e\u003cspan\u003e +\u003c/span\u003e\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003eY\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003em\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003e%\u003c/span\u003e\u003cspan\u003ed\u003c/span\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# For today\u0026#39;s commands, replace date ($2) with \u0026#34;today\u0026#34;, otherwise remove time ($3).\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003e# And filter out duplicates.\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eawk_filter\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e      if ($2 == \u0026#34;\u003c/span\u003e\u003cspan\u003e\u0026#39;$\u003c/span\u003e\u003cspan\u003etoday\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e\u0026#34;) sub($2 \u0026#34; \u0026#34;, \u0026#34;today\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e\\\u0026#39;\u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e\u0026#34;)\n\u003c/span\u003e\u003cspan\u003e      else sub($3, \u0026#34;\u0026#34;)\n\u003c/span\u003e\u003cspan\u003e      line=$0; $1=\u0026#34;\u0026#34;; $2=\u0026#34;\u0026#34;; $3=\u0026#34;\u0026#34;\n\u003c/span\u003e\u003cspan\u003e      if (!seen[$0]++) print line\n\u003c/span\u003e\u003cspan\u003e    }\u003c/span\u003e\u003cspan\u003e\u0026#39;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efc_opts\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u003c/span\u003e\u003cspan\u003e-i\u003c/span\u003e\u003cspan\u003e\u0026#39;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e3\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003efi\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003eselected\u003c/span\u003e\u003cspan\u003e=( $(\u003c/span\u003e\u003cspan\u003efc\u003c/span\u003e\u003cspan\u003e -rl \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003efc_opts\u003c/span\u003e\u003cspan\u003e 1 | \u003c/span\u003e\u003cspan\u003eawk \u003c/span\u003e\u003cspan\u003e\u0026#34;$\u003c/span\u003e\u003cspan\u003eawk_filter\u003c/span\u003e\u003cspan\u003e\u0026#34; |\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eSKIM_DEFAULT_OPTIONS\u003c/span\u003e\u003cspan\u003e=\u0026#34;\u003c/span\u003e\u003cspan\u003e--height \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eSKIM_TMUX_HEIGHT\u003c/span\u003e\u003cspan\u003e:-\u003c/span\u003e\u003cspan\u003e40%} \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eSKIM_DEFAULT_OPTIONS\u003c/span\u003e\u003cspan\u003e -n\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e..,.. --bind=ctrl-r:toggle-sort \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eSKIM_CTRL_R_OPTS\u003c/span\u003e\u003cspan\u003e --query=\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e(qqq)LBUFFER\u003c/span\u003e\u003cspan\u003e} --no-multi\u003c/span\u003e\u003cspan\u003e\u0026#34; $(\u003c/span\u003e\u003cspan\u003e__skimcmd\u003c/span\u003e\u003cspan\u003e)) )\n\u003c/span\u003e\u003cspan\u003e  \u003c/span\u003e\u003cspan\u003e...\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eThe first thing to note is that – thanks to \u003ccode\u003eEXTENDED_HISTORY\u003c/code\u003e – in\nmy context the \u003ccode\u003e-o extended_history\u003c/code\u003e check always returns \u003ccode\u003etrue\u003c/code\u003e, so the body of the \u003ccode\u003eif\u003c/code\u003e is\nalways executed.\u003c/p\u003e\n\u003cp\u003eWe can then skip ahead: \u003ccode\u003efc -rli 1\u003c/code\u003e gets zsh to output its history in a more\neasily digestible form than going through \u003ccode\u003e.zsh_history\u003c/code\u003e directly:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003e$ fc -rli 1\n\u003c/span\u003e\u003cspan\u003e    4  2025-02-07 15:05  pizauth status\n\u003c/span\u003e\u003cspan\u003e    3  2025-02-07 15:03  cargo run --release server\n\u003c/span\u003e\u003cspan\u003e    2  2025-02-07 15:03  email quick\n\u003c/span\u003e\u003cspan\u003e    1  2025-02-07 14:59  rsync_cmd bencher16 ./build.sh cargo test nested_tracing\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eWe can also now see what the magical integers from earlier are: they’re the row\nnumbers from \u003ccode\u003efc\u003c/code\u003e, where \u003ccode\u003e1\u003c/code\u003e is the oldest command in my \u003ccode\u003e~/.zsh_history\u003c/code\u003e! These\nare, in some situations, used as identifiers because one can ask zsh to “return\nme command 5408”.\u003c/p\u003e\n\u003cp\u003eThe awk code streams over this output, replacing today’s date with the literal\nstring \u003ccode\u003etoday\u003c/code\u003e, removes the hours/minutes output from previous days, and\nremoves duplicates.\u003c/p\u003e\n\u003cp\u003eAlthough it’s easily missed, in the final line of the code snippet is\n\u003ccode\u003e-n$n..,..\u003c/code\u003e which tells skim which whitespace-separated columns to fuzzy\nmatch and print out.\u003c/p\u003e\n\u003cp\u003eAt this point we now need to decide how to adapt things to our purposes.\nThe first thing we need to do with \u003ccode\u003efc\u003c/code\u003e’s output is convert the time to seconds\nsince the Unix epoch. We can get \u003ccode\u003efc\u003c/code\u003e to do that for us with \u003ccode\u003e-t \u0026#39;%s\u0026#39;\u003c/code\u003e. Instead\nof outputting \u003ccode\u003e2025-03-21 22:10\u003c/code\u003e we now get \u003ccode\u003e1742595052\u003c/code\u003e. Notice that two\nfields have now become one! Because \u003ccode\u003efc\u003c/code\u003e adds leading space to the row\nnumbers, we’ll strip that off by piping \u003ccode\u003efc\u003c/code\u003e’s output through \u003ccode\u003esed -E \u0026#34;s/^ *//\u0026#34;\u003c/code\u003e \u003cspan\u003e[7]\u003c/span\u003e.\u003c/p\u003e\n\u003cp\u003eI then needed to decide how to format “how far in the past was the command\nrun”. After a few tries, I decided that a good approach is to give absolute\n\u003ccode\u003ehour:minute\u003c/code\u003e times for commands in the last 20 hours, and \u003ccode\u003e1d\u003c/code\u003e, \u003ccode\u003e2d\u003c/code\u003e (etc.)\nfor commands 1 or more days in the past. Why 20 hours? Well, it turns out that\nif I start work at 08:00, press \u003ccode\u003eCtrl-r\u003c/code\u003e and see an entry at \u003ccode\u003e08:01\u003c/code\u003e I won’t\nrealise that was \u003cem\u003eyesterday’s\u003c/em\u003e 08:01 (today’s 08:01 is only 60 seconds in the\nfuture!). 20 hours solves this ambiguity: it means that, at 08:00,\nyesterday afternoon’s commands show as \u003ccode\u003e16:33\u003c/code\u003e but yesterday\nmorning’s commands as \u003ccode\u003e1d\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe now need to switch to awk. I will admit that I initially balked at the use\nof awk, a language I have never used before. I quickly explored alternatives\nbefore realising why the code uses awk: every Unix machine has awk installed.\nFor those unfamiliar with awk, the program that we’re writing iterates over\neach line in the input, splits that line up by whitespace, and puts the split\nfields into the variables \u003ccode\u003e$1\u003c/code\u003e, \u003ccode\u003e$2\u003c/code\u003e (etc.). We’ll keep the duplicate detection\nfrom the awk code above, but change most of the rest.\u003c/p\u003e\n\u003cp\u003eThe first thing we need to do in awk is to convert the Unix epoch time for a\ncommand (in field/variable \u003ccode\u003e$2\u003c/code\u003e) to an integer, and calculate how many seconds\nit is in the past using \u003ccode\u003esystime\u003c/code\u003e (which returns the current time relative to\nthe Unix epoch):\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003ets = int($2)\n\u003c/span\u003e\u003cspan\u003edelta = systime() - ts\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eWe can then convert \u003ccode\u003edelta\u003c/code\u003e seconds to days by dividing by 86,400 (24h * 60m *\n60s == 86,400s). It’s then a simple series of \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e to format this nicely\nbearing in mind that:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e20h == 72,000s\u003c/li\u003e\n\u003cli\u003estring concatenation and int-to-string conversion in awk is implicit\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe conversion code looks as follows:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003edelta_days = int(delta / 86400)\n\u003c/span\u003e\u003cspan\u003eif (delta_days \u0026lt; 1 \u0026amp;\u0026amp; delta \u0026lt; 72000) { $2=strftime(\u0026#34;%H:%M\u0026#34;, ts) }\n\u003c/span\u003e\u003cspan\u003eelse if (delta_days == 0) { $2=\u0026#34;1d\u0026#34; }\n\u003c/span\u003e\u003cspan\u003eelse { $2=delta_days \u0026#34;d\u0026#34; }\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eOne could choose to divvy things up further, perhaps showing commands older\nthan a week with “1w” and so on: I haven’t found that worth worrying about yet.\u003c/p\u003e\n\u003cp\u003eThere is, however, one minor fly in the ointment: clock skew. This could cause\ncommands to appear to be executing in the future. I’ve not seen seen this\nhappen in practice yet, but bitter experience with computers and clocks tells\nme it will at some point. I’ve defensively catered for the inevitable confusion\nthat will cause me by using a \u003ccode\u003e+\u003c/code\u003e prefix for such cases:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003edelta_days = int(delta / 86400)\n\u003c/span\u003e\u003cspan\u003eif (delta \u0026lt; 0) { $2=\u0026#34;+\u0026#34; (-delta_days) \u0026#34;d\u0026#34; }\n\u003c/span\u003e\u003cspan\u003eelse ...\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that I had to put \u003ccode\u003e(-delta_days)\u003c/code\u003e in brackets as otherwise – for reasons I’m\ntoo lazy to investigate – awk doesn’t concatenate the integer and\nstring in the way I want.\u003c/p\u003e\n\u003cp\u003eSince we have one fewer field than before we can slightly simplify our output:\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003eline=$0; $1=\u0026#34;\u0026#34;; $2=\u0026#34;\u0026#34;\n\u003c/span\u003e\u003cspan\u003eif (!seen[$0]++) print line\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s the awk code done. We then need to make one change to the \u003ccode\u003eselected=...\u003c/code\u003e\nline changing \u003ccode\u003e-n$n..,..\u003c/code\u003e to \u003ccode\u003e--with-nth $n..\u003c/code\u003e. This tells fzf and skim to\nsuppress the output of the row number and not to make it part\nof the fuzzy matching either.\u003c/p\u003e\n\u003cp\u003ePutting all that together, the updated chunk of the \u003ccode\u003ehistory-widget\u003c/code\u003e now\nlooks as follows (you can find the \u003ca href=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/zsh_history_widget.sh\"\u003ewhole code chunk\nhere\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003elocal \u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e1 \u003c/span\u003e\u003cspan\u003efc_opts\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u0026#39;\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eif \u003c/span\u003e\u003cspan\u003e[[ \u003c/span\u003e\u003cspan\u003e-o\u003c/span\u003e\u003cspan\u003e extended_history \u003c/span\u003e\u003cspan\u003e]]\u003c/span\u003e\u003cspan\u003e; \u003c/span\u003e\u003cspan\u003ethen\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003eawk_filter\u003c/span\u003e\u003cspan\u003e=\u0026#39;\n\u003c/span\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003cspan\u003e  ts = int($2)\n\u003c/span\u003e\u003cspan\u003e  delta = systime() - ts\n\u003c/span\u003e\u003cspan\u003e  delta_days = int(delta / 86400)\n\u003c/span\u003e\u003cspan\u003e  if (delta \u0026lt; 0) { $2=\u0026#34;+\u0026#34; (-delta_days) \u0026#34;d\u0026#34; }\n\u003c/span\u003e\u003cspan\u003e  else if (delta_days \u0026lt; 1 \u0026amp;\u0026amp; delta \u0026lt; 72000) { $2=strftime(\u0026#34;%H:%M\u0026#34;, ts) }\n\u003c/span\u003e\u003cspan\u003e  else if (delta_days == 0) { $2=\u0026#34;1d\u0026#34; }\n\u003c/span\u003e\u003cspan\u003e  else { $2=delta_days \u0026#34;d\u0026#34; }\n\u003c/span\u003e\u003cspan\u003e  line=$0; $1=\u0026#34;\u0026#34;; $2=\u0026#34;\u0026#34;\n\u003c/span\u003e\u003cspan\u003e  if (!seen[$0]++) print line\n\u003c/span\u003e\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e\u0026#39;\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003efc_opts\u003c/span\u003e\u003cspan\u003e=\u0026#39;\u003c/span\u003e\u003cspan\u003e-i\u003c/span\u003e\u003cspan\u003e\u0026#39;\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e=\u003c/span\u003e\u003cspan\u003e2\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003efi\n\u003c/span\u003e\u003cspan\u003e    \u003c/span\u003e\u003cspan\u003eselected\u003c/span\u003e\u003cspan\u003e=( $(\u003c/span\u003e\u003cspan\u003efc\u003c/span\u003e\u003cspan\u003e -rl \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003efc_opts -t \u003c/span\u003e\u003cspan\u003e\u0026#39;\u003c/span\u003e\u003cspan\u003e%s\u003c/span\u003e\u003cspan\u003e\u0026#39; 1 | \u003c/span\u003e\u003cspan\u003esed\u003c/span\u003e\u003cspan\u003e -E \u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e\u003cspan\u003es/^ *//\u003c/span\u003e\u003cspan\u003e\u0026#34; | \u003c/span\u003e\u003cspan\u003eawk \u003c/span\u003e\u003cspan\u003e\u0026#34;$\u003c/span\u003e\u003cspan\u003eawk_filter\u003c/span\u003e\u003cspan\u003e\u0026#34; |\n\u003c/span\u003e\u003cspan\u003e      \u003c/span\u003e\u003cspan\u003eSKIM_DEFAULT_OPTIONS\u003c/span\u003e\u003cspan\u003e=\u0026#34;\u003c/span\u003e\u003cspan\u003e--height \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003eSKIM_TMUX_HEIGHT\u003c/span\u003e\u003cspan\u003e:-\u003c/span\u003e\u003cspan\u003e40%} \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eSKIM_DEFAULT_OPTIONS\u003c/span\u003e\u003cspan\u003e --with-nth \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003en\u003c/span\u003e\u003cspan\u003e.. --bind=ctrl-r:toggle-sort \u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003eSKIM_CTRL_R_OPTS\u003c/span\u003e\u003cspan\u003e --query=\u003c/span\u003e\u003cspan\u003e$\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\u003cspan\u003e(qqq)LBUFFER\u003c/span\u003e\u003cspan\u003e} --no-multi\u003c/span\u003e\u003cspan\u003e\u0026#34; $(\u003c/span\u003e\u003cspan\u003e__skimcmd\u003c/span\u003e\u003cspan\u003e)) )\n\u003c/span\u003e\u003c/pre\u003e\n\u003cp\u003eThat simple change is enough to give me this output when I press \u003ccode\u003eCtrl-r\u003c/code\u003e and\nstart typing:\u003c/p\u003e\n\u003cp\u003e\u003cvideo controls=\"\"\u003e\u003csource src=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4\" type=\"video/mp4\"/\u003e\u003ca href=\"https://tratt.net/laurie/blog/extra/2025/better_shell_history_search/skim.mp4\"\u003e[Video]\u003c/a\u003e\u003c/video\u003e\u003c/p\u003e\n\u003ch2\u003e\u003ca name=\"summary\"\u003eSummary\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI’ve been using the changes above for about 6 weeks, and I’ve found it a\nmeaningful productivity enhancement. It turns out that I often remember enough\nabout a command I want to recall that seeing if a match is “1d” or “7d” in the\npast is enough to immediately rule it in or out without scanning rightwards.\nOccasionally I even search on the time delta itself: if I start a match with\n“2d” fzf or skim will naturally search commands from 2 days ago.\u003c/p\u003e\n\u003cp\u003eBut, perhaps, there is a larger point to take from this post. If, like me, you\nspend a lot of your life in a Unix terminal, it can be easy to fall into\npatterns of usage that would be recognisable to shell users from the 1970s.\nNot only can we do better, it’s easy to do so, and the productivity\ngains can be substantial!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAcknowledgements\u003c/strong\u003e: thanks to \u003ca href=\"http://www.eddbarrett.co.uk/\"\u003eEdd Barrett\u003c/a\u003e for comments.\u003c/p\u003e\n\n\n\u003cp\u003e\n\n2025-03-25 11:50\n\n\u003ca href=\"https://tratt.net/laurie/blog/2024/can_we_retain_the_benefits_of_transitive_dependencies_without_undermining_security.html\"\u003eOlder\u003c/a\u003e\n\n\u003c/p\u003e\n\n\u003cdiv id=\"article-updates\"\u003e\u003cp\u003e\nIf you’d like updates on new blog posts: follow me on\n\u003ca href=\"https://mastodon.social/@ltratt\"\u003eMastodon\u003c/a\u003e\nor \u003ca href=\"https://twitter.com/laurencetratt\"\u003eTwitter\u003c/a\u003e;\nor \u003ca href=\"https://tratt.net/laurie/blog/blog.rss\"\u003esubscribe to the RSS feed\u003c/a\u003e;\nor \u003ca href=\"https://tratt.net/laurie/newsletter/\"\u003esubscribe to email updates\u003c/a\u003e:\n\n\u003c/p\u003e\n\n\u003c/div\u003e\n\n\n\u003ch3\u003eFootnotes\u003c/h3\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ch3\u003eComments\u003c/h3\u003e\n\n\n\n\n\n\n\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "16 min read",
  "publishedTime": null,
  "modifiedTime": null
}
