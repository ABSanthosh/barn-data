{
  "id": "808957a5-ee72-4df6-a2ab-1cb12876bc37",
  "title": "Tips and tweaks to integrate Github Action to your iOS project",
  "link": "https://benoitpasquier.com/tips-tweaks-github-action-ios/",
  "description": "I’ve been exploring more and more tooling around iOS ecosystem. One tool I really enjoy using those days is Github Action as a continuous integration for my projects. Today we’ll dive into tips and tweaks to make the most of it.",
  "author": "",
  "published": "Fri, 28 Jan 2022 08:00:00 +0000",
  "source": "https://benoitpasquier.com/index.xml",
  "categories": null,
  "byline": "Benoit Pasquier",
  "length": 8682,
  "excerpt": "I’ve been exploring more and more tooling around iOS ecosystem. One tool I really enjoy using those days is Github Action as a continuous integration for my projects. Today we’ll dive into tips and tweaks to make the most of it.",
  "siteName": "Benoit Pasquier",
  "favicon": "https://benoitpasquier.com/favicon.png",
  "text": "January 28, 2022 in Mobile I’ve been exploring more and more tooling around iOS ecosystem. One tool I really enjoy using those days is Github Action as a continuous integration for my projects. Today we’ll dive into tips and tweaks to make the most of it. Github Action is a docker environment that allows you to execute different steps around your project. Like any cloud-based continuous integration system, it can help you analyse your code, run your test and verify your build, but also deploy it, and so on. Github Action relies on a workflow based on a YAML file that is part of the repository, under a .github folder at the root of your repo. You can have as many workflow as you want. From there, you can integrate steps and actions in your workflow. Most of them are open-sourced (I’m not sure if it can be private), free to use, and available through Github Marketplace. The setup is really straight forward, so we’ll focus directly into the workflow and steps. Let’s imagine I have a Swift Package I want to build and test over time. I would like to run the build and test on a macOS environment for any new pull request, to make sure I don’t break anything. Here what the .yml file would look like: name: Swift on: pull_request: branches: [ main ] jobs: build: runs-on: macos-latest steps: # Checking out our code base - uses: actions/checkout@v2 - name: Build run: swift build -v - name: Run tests run: swift test -v Pretty simple, right? I chose macOS for this workflow but I can also use Linux operating system, they are much more common, we wouldn’t have to wait for an available machine. Of course, we know that iOS project can be a bit more complex than just a standalone package. It often includes dependencies about tooling, like bundler, fastlane or slather for instance. It can also include code dependencies through CocoaPods or Carthage that we need to resolve before testing. name: iOS project on: pull_request: branches: [ main ] jobs: build: runs-on: macos-latest steps: - uses: actions/checkout@v2 - name: Bundle dependencies run: bundle install - name: CocoaPods dependencies run: bundle exec pod install - name: Run tests run: bundle exec fastlane scan If you’re familiar with other continuous integration system, you’ll notice I don’t enforce CocoaPods to get the latest --repo-update. Here, I assume that since Github Action runs on docker image, there is no cache to rely on, so it should stay up-to-date. But I’ll come back to this one. So far so good, now let’s look into tweaks to improve our workflow Cancelling previous build First thing I can think of is to avoid having multiple build for the same pull request. After all, the service is free until a certain limit. concurrency: group: build-ios-${{ github.ref }} cancel-in-progress: true jobs: #... From cancelling in-progress build, any new commit will stop the previous one. It saves build time, so it saves money. Environment variables and secrets For a stable build across developers, it can important for all your tests to run on the same environment. For same version of Xcode. jobs: build: runs-on: macOS-11 env: XCODE_VERSION: 12.5.1 steps: - uses: actions/checkout@v2 - name: Select Xcode 12 run: sudo xcode-select --switch /Applications/Xcode_${{ env.XCODE_VERSION }}.app We can also define a matrix to define multiple variation for the job. For instance, we can define multiple Xcode versions, or iOS devices. strategy: matrix: xcode_version: [10.3, 12.5.1] jobs: build: # ... steps: - uses: actions/checkout@v2 - name: Select Xcode run: sudo xcode-select --switch /Applications/Xcode_${{ matrix.xcode_version }}.app The same way, we can set other environment variables, something that your tooling can pick. For instance, we can override fastlane variables. jobs: build: runs-on: macOS-11 env: # Override fastlane tooling variables FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT: 180 FASTLANE_XCODEBUILD_SETTINGS_RETRIES: 10 We can also access secret environment defined at the repository level, or the organization level. ${{ secrets.MY_VARIABLE }} Runs steps on conditions Some part of the workflow might only make sense if the rest succeeded before. For instance, we could limit code coverage only when tests successfully passed. At the same time, we might want another step to capture the tests report regardless. - name: Run coverage if: success() run: capture-coverage.sh - name: Publish test report if: always() run: publish-report.sh We can also use if: failure() for failing conditions. Draft pull request workflow One state of Github pull request is to be as draft when it’s still in progress. By default, only opened, synchronize or reopened pull request are triggering Github Action. To enable it for draft conversion (and back), we need to extend the workflow. You can read more about the pull requests on the official documentation. on: pull_request: types: [opened, synchronize, reopened, ready_for_review, converted_to_draft] From there we can also detect when the job runs for a draft pull request. if: github.event.pull_request.draft == true Speeding up iOS workflow One issue that is constant for cloud-based continuous integration is the build time of the workflow. A big part of it is to get the dependencies ready. If you have already think about it ahead, using remote caching system for your dependencies, you might be in a great place of optimization. If you haven’t, Carthage supports remote caching, CocoaPods have few solutions as well. Bazel or Buck builds do also caching and incremental builds that could speed up your workflow. That being said, Github Action also proposes a caching action that we can leverage for your next build. From cache, we can setup what to keep for the next build. It has to be set on a key. - uses: actions/cache@v2 with: path: Pods key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }} restore-keys: | ${{ runner.os }}-pods- Running workflows sequently By default, workflows run in parallel but steps run one at a time. To make simpler workflow and more reusable, while keeping dependencies between them (i.e. test only if build passed, etc.), we can use needs keyword to chain them. We can still add conditions to it when required. jobs: job1: job2: needs: job1 job3: if: ${{ always() }} needs: [job1, job2] In this case, job3 would still run regardless of job1 and job2 results. Pull Private Dependencies For security reason, some organisations required to access Github only from whitelist IP, from the company VPN for instance. The great part of Github Action, it doesn’t require this VPN access and can directly access the code. That being said, some dependencies can be other private repositories and harder to access. At the moment, I found only two ways to work around: Using a Github token to pull that separate repository. Using a SSH action, like webfactory-ssh-agent to access those repositories. # ... - uses: webfactory/ssh-agent@v0.5.4 with: ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }} # ... In any case, be considerate to the security access you granted, the second one handles a private key in the workflow, it’s not something to handle lightly. If Github Action is quite recent in the Continuous Integration system, it already have a lot of options to make it a performant environment to consider. It’s super simple to integrate and maintain, and decently priced for indie developers or small organizations (2000 free minutes per month). That being said, as the team and iOS project grow over time, I have few concern how to keep the cost under control. For instance, macOS machine run time is multiplied 10x what Linux is. So improving the running time becomes key. The other part I haven’t finalized yet is the caching system. Ideally we want an environment to run fast and often, and waiting ~15mins just for CocoaPods dependencies at every build sounds like a waste. There are few actions to improve this, but it’s a never ending quest of optimization. The final great point of Github Action is probably the actions are open-sourced, so we can see what the action does before integrating it. Like any dependencies, you should still have a look at its content. For instance, just for security concern, it is an external dependency, maybe one could upload your code somewhere else? We’re never too careful. Thanks for reading!",
  "image": "https://benoitpasquier.com/images/2022/01/github-action-ios.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n  \n    \n  \n  \n  \u003cp\u003e\u003ctime itemprop=\"datePublished\" datetime=\"2022-01-28T08:00:00Z\"\u003e\n        \n  January 28, 2022\n\n      \u003c/time\u003e\n    \n    \n  \n  \n    \u003cspan\u003ein\u003c/span\u003e\n    \n      \u003ca href=\"https://benoitpasquier.com/categories/mobile\"\u003eMobile\u003c/a\u003e\n    \n  \n\n  \u003c/p\u003e\n\n\u003c/div\u003e\u003cdiv itemprop=\"articleBody\"\u003e\n              \u003cp\u003eI’ve been exploring more and more tooling around iOS ecosystem. One tool I really enjoy using those days is Github Action as a continuous integration for my projects. Today we’ll dive into tips and tweaks to make the most of it.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/features/actions\"\u003eGithub Action\u003c/a\u003e is a docker environment that allows you to execute different steps around your project. Like any cloud-based continuous integration system, it can help you analyse your code, run your test and verify your build, but also deploy it, and so on.\u003c/p\u003e\n\u003cp\u003eGithub Action relies on a workflow based on a YAML file that is part of the repository, under a \u003ccode\u003e.github\u003c/code\u003e folder at the root of your repo. You can have as many workflow as you want.\u003c/p\u003e\n\u003cp\u003eFrom there, you can integrate steps and actions in your workflow. Most of them are open-sourced (I’m not sure if it can be private), free to use, and available through Github Marketplace.\u003c/p\u003e\n\u003cp\u003eThe setup is really straight forward, so we’ll focus directly into the workflow and steps.\u003c/p\u003e\n\u003cp\u003eLet’s imagine I have a Swift Package I want to build and test over time. I would like to run the build and test on a macOS environment for any new pull request, to make sure I don’t break anything.\u003c/p\u003e\n\u003cp\u003eHere what the \u003ccode\u003e.yml\u003c/code\u003e file would look like:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eSwift\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eon\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003epull_request\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ebranches\u003c/span\u003e: [ \u003cspan\u003emain ]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebuild\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eruns-on\u003c/span\u003e: \u003cspan\u003emacos-latest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e# Checking out our code base\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003eactions/checkout@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eBuild\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003eswift build -v\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eRun tests\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003eswift test -v\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cem\u003ePretty simple, right?\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eI chose macOS for this workflow but I can also use Linux operating system, they are much more common, we wouldn’t have to wait for an available machine.\u003c/p\u003e\n\u003cp\u003eOf course, we know that iOS project can be a bit more complex than just a standalone package. It often includes dependencies about tooling, like bundler, fastlane or slather for instance. It can also include code dependencies through CocoaPods or Carthage that we need to resolve before testing.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eiOS project\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eon\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003epull_request\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ebranches\u003c/span\u003e: [ \u003cspan\u003emain ]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebuild\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eruns-on\u003c/span\u003e: \u003cspan\u003emacos-latest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003eactions/checkout@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eBundle dependencies\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003ebundle install\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eCocoaPods dependencies\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003ebundle exec pod install\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eRun tests\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003ebundle exec fastlane scan\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIf you’re familiar with other continuous integration system, you’ll notice I don’t enforce CocoaPods to get the latest \u003ccode\u003e--repo-update\u003c/code\u003e. Here, I assume that since Github Action runs on docker image, there is no cache to rely on, so it should stay up-to-date. But I’ll come back to this one.\u003c/p\u003e\n\u003cp\u003eSo far so good, now let’s look into tweaks to improve our workflow\u003c/p\u003e\n\u003ch2 id=\"cancelling-previous-build\"\u003eCancelling previous build\u003c/h2\u003e\n\u003cp\u003eFirst thing I can think of is to avoid having multiple build for the same pull request. After all, the service is free until a certain limit.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003econcurrency\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003egroup\u003c/span\u003e: \u003cspan\u003ebuild-ios-${{ github.ref }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ecancel-in-progress\u003c/span\u003e: \u003cspan\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e#...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFrom cancelling in-progress build, any new commit will stop the previous one. It saves build time, so it saves money.\u003c/p\u003e\n\u003ch2 id=\"environment-variables-and-secrets\"\u003eEnvironment variables and secrets\u003c/h2\u003e\n\u003cp\u003eFor a stable build across developers, it can important for all your tests to run on the same environment. For  same version of Xcode.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebuild\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eruns-on\u003c/span\u003e: \u003cspan\u003emacOS-11\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eenv\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eXCODE_VERSION\u003c/span\u003e: \u003cspan\u003e12.5.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      - \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003eactions/checkout@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eSelect Xcode 12\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003esudo xcode-select --switch /Applications/Xcode_${{ env.XCODE_VERSION }}.app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can also define a matrix to define multiple variation for the job. For instance, we can define multiple Xcode versions, or iOS devices.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003estrategy\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ematrix\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003excode_version\u003c/span\u003e: [\u003cspan\u003e10.3\u003c/span\u003e, \u003cspan\u003e12.5.1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebuild\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e# ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003esteps\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      - \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003eactions/checkout@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      - \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eSelect Xcode\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003esudo xcode-select --switch /Applications/Xcode_${{ matrix.xcode_version }}.app\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe same way, we can set other environment variables, something that your tooling can pick. For instance, we can override fastlane variables.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ebuild\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eruns-on\u003c/span\u003e: \u003cspan\u003emacOS-11\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eenv\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e# Override fastlane tooling variables\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eFASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\u003c/span\u003e: \u003cspan\u003e180\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003eFASTLANE_XCODEBUILD_SETTINGS_RETRIES\u003c/span\u003e: \u003cspan\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can also access secret environment defined at the repository level, or the organization level.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e${{ secrets.MY_VARIABLE }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"runs-steps-on-conditions\"\u003eRuns steps on conditions\u003c/h2\u003e\n\u003cp\u003eSome part of the workflow might only make sense \u003cem\u003eif\u003c/em\u003e the rest succeeded before.\u003c/p\u003e\n\u003cp\u003eFor instance, we could limit code coverage only when tests successfully passed.\u003c/p\u003e\n\u003cp\u003eAt the same time, we might want another step to capture the tests report regardless.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e- \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003eRun coverage\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e: \u003cspan\u003esuccess()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003ecapture-coverage.sh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e- \u003cspan\u003ename\u003c/span\u003e: \u003cspan\u003ePublish test report\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e: \u003cspan\u003ealways()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003erun\u003c/span\u003e: \u003cspan\u003epublish-report.sh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eWe can also use \u003ccode\u003eif: failure()\u003c/code\u003e for failing conditions.\u003c/p\u003e\n\u003ch2 id=\"draft-pull-request-workflow\"\u003eDraft pull request workflow\u003c/h2\u003e\n\u003cp\u003eOne state of Github pull request is to be as \u003cem\u003edraft\u003c/em\u003e when it’s still in progress.\u003c/p\u003e\n\u003cp\u003eBy default, only \u003ccode\u003eopened\u003c/code\u003e, \u003ccode\u003esynchronize\u003c/code\u003e or \u003ccode\u003ereopened\u003c/code\u003e pull request are triggering Github Action.\u003c/p\u003e\n\u003cp\u003eTo enable it for draft conversion (and back), we need to extend the workflow. You can read more about the pull requests on the official \u003ca href=\"https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request\"\u003edocumentation\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eon\u003c/span\u003e:  \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003epull_request\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003etypes\u003c/span\u003e: [\u003cspan\u003eopened, synchronize, reopened, ready_for_review, converted_to_draft]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eFrom there we can also detect when the job runs for a draft pull request.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eif\u003c/span\u003e: \u003cspan\u003egithub.event.pull_request.draft == true\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"speeding-up-ios-workflow\"\u003eSpeeding up iOS workflow\u003c/h2\u003e\n\u003cp\u003eOne issue that is constant for cloud-based continuous integration is the build time of the workflow.\u003c/p\u003e\n\u003cp\u003eA big part of it is to get the dependencies ready. If you have already think about it ahead, using remote caching system for your dependencies, you might be in a great place of optimization.\u003c/p\u003e\n\u003cp\u003eIf you haven’t, Carthage supports remote caching, CocoaPods have few solutions as well. Bazel or Buck builds do also caching and incremental builds that could speed up your workflow.\u003c/p\u003e\n\u003cp\u003eThat being said, Github Action also proposes a caching action that we can leverage for your next build.\u003c/p\u003e\n\u003cp\u003eFrom \u003ca href=\"https://github.com/actions/cache\"\u003ecache\u003c/a\u003e, we can setup what to keep for the next build. It has to be set on a key.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e- \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003eactions/cache@v2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003epath\u003c/span\u003e: \u003cspan\u003ePods\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ekey\u003c/span\u003e: \u003cspan\u003e${{ runner.os }}-pods-${{ hashFiles(\u0026#39;**/Podfile.lock\u0026#39;) }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003erestore-keys\u003c/span\u003e: |\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e      ${{ runner.os }}-pods-\u003c/span\u003e      \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"running-workflows-sequently\"\u003eRunning workflows sequently\u003c/h2\u003e\n\u003cp\u003eBy default, workflows run in parallel but steps run one at a time.\u003c/p\u003e\n\u003cp\u003eTo make simpler workflow and more reusable, while keeping dependencies between them (i.e. test only if build passed, etc.), we can use \u003ccode\u003eneeds\u003c/code\u003e keyword to chain them.\u003c/p\u003e\n\u003cp\u003eWe can still add conditions to it when required.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003ejobs\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ejob1\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ejob2\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eneeds\u003c/span\u003e: \u003cspan\u003ejob1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ejob3\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e: \u003cspan\u003e${{ always() }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eneeds\u003c/span\u003e: [\u003cspan\u003ejob1, job2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn this case, \u003ccode\u003ejob3\u003c/code\u003e would still run regardless of \u003ccode\u003ejob1\u003c/code\u003e and \u003ccode\u003ejob2\u003c/code\u003e results.\u003c/p\u003e\n\u003ch2 id=\"pull-private-dependencies\"\u003ePull Private Dependencies\u003c/h2\u003e\n\u003cp\u003eFor security reason, some organisations required to access Github only from whitelist IP, from the company VPN for instance. The great part of Github Action, it doesn’t require this VPN access and can directly access the code.\u003c/p\u003e\n\u003cp\u003eThat being said, some dependencies can be other private repositories and harder to access. At the moment, I found only two ways to work around:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUsing a \u003ca href=\"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\"\u003eGithub token\u003c/a\u003e to pull that separate repository.\u003c/li\u003e\n\u003cli\u003eUsing a SSH action, like \u003ca href=\"https://github.com/marketplace/actions/webfactory-ssh-agent\"\u003ewebfactory-ssh-agent\u003c/a\u003e to access those repositories.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"yml\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e# ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e- \u003cspan\u003euses\u003c/span\u003e: \u003cspan\u003ewebfactory/ssh-agent@v0.5.4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003ewith\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003essh-private-key\u003c/span\u003e: \u003cspan\u003e${{ secrets.SSH_PRIVATE_KEY }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e# ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIn any case, be considerate to the security access you granted, the second one handles a private key in the workflow, \u003cstrong\u003eit’s not something to handle lightly\u003c/strong\u003e.\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003eIf Github Action is quite recent in the Continuous Integration system, it already have a lot of options to make it a performant environment to consider. It’s super simple to integrate and maintain, and decently priced for indie developers or small organizations (2000 free minutes per month).\u003c/p\u003e\n\u003cp\u003eThat being said, as the team and iOS project grow over time, I have few concern how to keep the cost under control. For instance, macOS machine run time is multiplied 10x what Linux is. So improving the running time becomes key.\u003c/p\u003e\n\u003cp\u003eThe other part I haven’t finalized yet is the caching system. Ideally we want an environment to run fast and often, and waiting ~15mins just for CocoaPods dependencies at every build sounds like a waste. There are few actions to improve this, but it’s a never ending quest of optimization.\u003c/p\u003e\n\u003cp\u003eThe final great point of Github Action is probably the actions are open-sourced, so we can see what the action does before integrating it. Like any dependencies, you should still have a look at its content. For instance, just for security concern, it is an external dependency, maybe one could upload your code somewhere else? We’re never too careful.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThanks for reading!\u003c/em\u003e\u003c/p\u003e\n              \n            \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "9 min read",
  "publishedTime": "2022-01-28T08:00:00Z",
  "modifiedTime": "2022-01-28T08:00:00Z"
}
