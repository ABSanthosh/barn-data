{
  "id": "0136fcbf-74ef-4a19-82af-d12b66f538c8",
  "title": "When .animation animates more (or less) than it’s supposed to",
  "link": "https://oleb.net/2022/animation-modifier-position/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-11-10T21:48:45Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 9507,
  "excerpt": "SwiftUI views and view modifiers can be divided into “rendering“ and “non-rendering” groups. The position of the `animation` modifier with respect to non-rendering modifiers is irrelevant for the question if a change gets animated or not.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "The documentation for SwiftUI’s animation modifier says: Applies the given animation to this view when the specified value changes. This sounds unambiguous to me: it sets the animation for “this view”, i.e. the part of the view tree that .animation is being applied to. This should give us complete control over which modifiers we want to animate, right? Unfortunately, it’s not that simple: it’s easy to run into situations where a view change inside an animated subtree doesn’t get animated, or vice versa. Unsurprising examples Let me give you some examples, starting with those that do work as documented. I tested all examples on iOS 16.1 and macOS 13.0. 1. Sibling views can have different animations Independent subtrees of the view tree can be animated independently. In this example we have three sibling views, two of which are animated with different durations, and one that isn’t animated at all: struct Example1: View { var flag: Bool var body: some View { HStack(spacing: 40) { Rectangle() .frame(width: 80, height: 80) .foregroundColor(.green) .scaleEffect(flag ? 1 : 1.5) .animation(.easeOut(duration: 0.5), value: flag) Rectangle() .frame(width: 80, height: 80) .foregroundColor(flag ? .yellow : .red) .rotationEffect(flag ? .zero : .degrees(45)) .animation(.easeOut(duration: 2.0), value: flag) Rectangle() .frame(width: 80, height: 80) .foregroundColor(flag ? .pink : .mint) } } } The two animation modifiers each apply to their own subtree. They don’t interfere with each other and have no effect on the rest of the view hierarchy: Download video 2. Nested animation modifiers When two animation modifiers are nested in a single view tree such that one is an indirect parent of the other, the inner modifier can override the outer animation for its subviews. The outer animation applies to view modifiers that are placed between the two animation modifiers. In this example we have one rectangle view with animated scale and rotation effects. The outer animation applies to the entire subtree, including both effects. The inner animation modifier overrides the outer animation only for what’s nested below it in the view tree, i.e. the scale effect: struct Example2: View { var flag: Bool var body: some View { Rectangle() .frame(width: 80, height: 80) .foregroundColor(.green) .scaleEffect(flag ? 1 : 1.5) .animation(.default, value: flag) // inner .rotationEffect(flag ? .zero : .degrees(45)) .animation(.default.speed(0.3), value: flag) // outer } } As a result, the scale and rotation changes animate at different speeds: Download video Note that we could also pass .animation(nil, value: flag) to selectively disable animations for a subtree, overriding a non-nil animation further up the view tree. 3. animation only animates its children (with exceptions) As a general rule, the animation modifier only applies to its subviews. In other words, views and modifiers that are direct or indirect parents of an animation modifier should not be animated. As we’ll see below, it doesn’t always work like that, but here’s an example where it does. This is a slight variation of the previous code snippet where I removed the outer animation modifier (and changed the color for good measure): struct Example3: View { var flag: Bool var body: some View { Rectangle() .frame(width: 80, height: 80) .foregroundColor(.orange) .scaleEffect(flag ? 1 : 1.5) .animation(.default, value: flag) // Don't animate the rotation .rotationEffect(flag ? .zero : .degrees(45)) } } Recall that the order in which view modifiers are written in code is inverted with respect to the actual view tree hierarchy. Each view modifier is a new view that wraps the view it’s being applied to. So in our example, the scale effect is the child of the animation modifier, whereas the rotation effect is its parent. Accordingly, only the scale change gets animated: Download video Surprising examples Now it’s time for the “fun” part. It turns out not all view modifiers behave as intuitively as scaleEffect and rotationEffect when combined with the animation modifier. 4. Some modifiers don’t respect the rules In this example we’re changing the color, size, and alignment of the rectangle. Only the size change should be animated, which is why we’ve placed the alignment and color mutations outside the animation modifier: struct Example4: View { var flag: Bool var body: some View { let size: CGFloat = flag ? 80 : 120 Rectangle() .frame(width: size, height: size) .animation(.default, value: flag) .frame(maxWidth: .infinity, alignment: flag ? .leading : .trailing) .foregroundColor(flag ? .pink : .indigo) } } Unfortunately, this doesn’t work as intended, as all three changes are animated: Download video It behaves as if the animation modifier were the outermost element of this view subtree. 5. padding and border This one’s sort of the inverse of the previous example because a change we want to animate doesn’t get animated. The padding is a child of the animation modifier, so I’d expect changes to it to be animated, i.e. the border should grow and shrink smoothly: struct Example5: View { var flag: Bool var body: some View { Rectangle() .frame(width: 80, height: 80) .padding(flag ? 20 : 40) .animation(.default, value: flag) .border(.primary) .foregroundColor(.cyan) } } But that’s not what happens: Download video 6. Font modifiers Font modifiers also behave seemingly erratic with respect to the animation modifier. In this example, we want to animate the font width, but not the size or weight (smooth text animation is a new feature in iOS 16): struct Example6: View { var flag: Bool var body: some View { Text(\"Hello!\") .fontWidth(flag ? .condensed : .expanded) .animation(.default, value: flag) .font(.system( size: flag ? 40 : 60, weight: flag ? .regular : .heavy) ) } } You guessed it, this doesn’t work as intended. Instead, all text properties animate smoothly: Download video Why does it work like this? In summary, the placement of the animation modifier in the view tree allows some control over which changes get animated, but it isn’t perfect. Some modifiers, such as scaleEffect and rotationEffect, behave as expected, whereas others (frame, padding, foregroundColor, font) are less controllable. I don’t fully understand the rules, but the important factor seems to be if a view modifier actually “renders” something or not. For instance, foregroundColor just writes a color into the environment; the modifier itself doesn’t draw anything. I suppose this is why its position with respect to animation is irrelevant: RoundedRectangle(cornerRadius: flag ? 0 : 40) .animation(.default, value: flag) // Color change still animates, even though we’re outside .animation .foregroundColor(flag ? .pink : .indigo) The rendering presumably takes place on the level of the RoundedRectangle, which reads the color from the environment. At this point the animation modifier is active, so SwiftUI will animate all changes that affect how the rectangle is rendered, regardless of where in the view tree they’re coming from. The same explanation makes intuitive sense for the font modifiers in example 6. The actual rendering, and therefore the animation, occurs on the level of the Text view. The various font modifiers affect how the text is drawn, but they don’t render anything themselves. Similarly, padding and frame (including the frame’s alignment) are “non-rendering” modifiers too. They don’t use the environment, but they influence the layout algorithm, which ultimately affects the size and position of one or more “rendering” views, such as the rectangle in example 4. That rectangle sees a combined change in its geometry, but it can’t tell where the change came from, so it’ll animate the full geometry change. In example 5, the “rendering” view that’s affected by the padding change is the border (which is implemented as a stroked rectangle in an overlay). Since the border is a parent of the animation modifier, its geometry change is not animated. In contrast to frame and padding, scaleEffect and rotationEffect are “rendering” modifiers. They apparently perform the animations themselves. Conclusion SwiftUI views and view modifiers can be divided into “rendering“ and “non-rendering” groups (I wish I had better terms for these). In iOS 16/macOS 13, the placement of the animation modifier with respect to non-rendering modifiers is irrelevant for deciding if a change gets animated or not. Non-rendering modifiers include (non-exhaustive list): Layout modifiers (frame, padding, position, offset) Font modifiers (font, bold, italic, fontWeight, fontWidth) Other modifiers that write data into the environment, e.g. foregroundColor, foregroundStyle, symbolRenderingMode, symbolVariant Rendering modifiers include (non-exhaustive list): clipShape, cornerRadius Geometry effects, e.g. scaleEffect, rotationEffect, projectionEffect Graphical effects, e.g. blur, brightness, hueRotation, opacity, saturation, shadow",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003eThe documentation for SwiftUI’s \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/animation(_:value:)\"\u003e\u003ccode\u003eanimation\u003c/code\u003e modifier\u003c/a\u003e says:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eApplies the given animation to this view when the specified value changes.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThis sounds unambiguous to me: it sets the animation for “this view”, i.e. the part of the view tree that \u003ccode\u003e.animation\u003c/code\u003e is being applied to. This should give us complete control over which modifiers we want to animate, right? Unfortunately, it’s not that simple: it’s easy to run into situations where a view change inside an animated subtree doesn’t get animated, or vice versa.\u003c/p\u003e\n\n\u003ch2 id=\"unsurprising-examples\"\u003eUnsurprising examples\u003c/h2\u003e\n\n\u003cp\u003eLet me give you some examples, starting with those that do work as documented. I tested all examples on iOS 16.1 and macOS 13.0.\u003c/p\u003e\n\n\u003ch2 id=\"sibling-views-can-have-different-animations\"\u003e1. Sibling views can have different animations\u003c/h2\u003e\n\n\u003cp\u003eIndependent subtrees of the view tree can be animated independently. In this example we have three sibling views, two of which are animated with different durations, and one that isn’t animated at all:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample1\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eHStack\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003espacing\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaleEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eeaseOut\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eduration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.5\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\n      \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eyellow\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ered\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erotationEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edegrees\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e45\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eeaseOut\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eduration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2.0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n\n      \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epink\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe two \u003ccode\u003eanimation\u003c/code\u003e modifiers each apply to their own subtree. They don’t interfere with each other and have no effect on the rest of the view hierarchy:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-1.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-1.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 id=\"nested-animation-modifiers\"\u003e2. Nested \u003ccode\u003eanimation\u003c/code\u003e modifiers\u003c/h2\u003e\n\n\u003cp\u003eWhen two \u003ccode\u003eanimation\u003c/code\u003e modifiers are nested in a single view tree such that one is an indirect parent of the other, the inner modifier can override the outer animation for its subviews. The outer animation applies to view modifiers that are placed between the two \u003ccode\u003eanimation\u003c/code\u003e modifiers.\u003c/p\u003e\n\n\u003cp\u003eIn this example we have one rectangle view with animated \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-pmi7\"\u003escale\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/rotationeffect(_:anchor:)\"\u003erotation\u003c/a\u003e effects. The outer animation applies to the entire subtree, including both effects. The inner \u003ccode\u003eanimation\u003c/code\u003e modifier overrides the outer animation only for what’s nested below it in the view tree, i.e. the scale effect:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample2\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n  \n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaleEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// inner\u003c/span\u003e\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erotationEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edegrees\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e45\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003espeed\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0.3\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e// outer\u003c/span\u003e\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAs a result, the scale and rotation changes animate at different speeds:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-2.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-2.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003cp\u003eNote that we could also pass \u003ccode\u003e.animation(nil, value: flag)\u003c/code\u003e to selectively disable animations for a subtree, overriding a non-\u003ccode\u003enil\u003c/code\u003e animation further up the view tree.\u003c/p\u003e\n\n\u003ch2 id=\"animation-only-animates-its-children-with-exceptions\"\u003e3. \u003ccode\u003eanimation\u003c/code\u003e only animates its children (with exceptions)\u003c/h2\u003e\n\n\u003cp\u003eAs a general rule, the \u003ccode\u003eanimation\u003c/code\u003e modifier only applies to its subviews. In other words, views and modifiers that are direct or indirect \u003cem\u003eparents\u003c/em\u003e of an \u003ccode\u003eanimation\u003c/code\u003e modifier should not be animated. As we’ll see below, it doesn’t always work like that, but here’s an example where it does. This is a slight variation of the previous code snippet where I removed the outer \u003ccode\u003eanimation\u003c/code\u003e modifier (and changed the color for good measure):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample3\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003escaleEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1.5\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n      \u003cspan\u003e// Don\u0026#39;t animate the rotation\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erotationEffect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ezero\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edegrees\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e45\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eRecall that the order in which view modifiers are written in code is inverted with respect to the actual view tree hierarchy. Each view modifier is a new view that wraps the view it’s being applied to. So in our example, the scale effect is the child of the \u003ccode\u003eanimation\u003c/code\u003e modifier, whereas the rotation effect is its parent. Accordingly, only the scale change gets animated:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-3.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-3.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 id=\"surprising-examples\"\u003eSurprising examples\u003c/h2\u003e\n\n\u003cp\u003eNow it’s time for the “fun” part. It turns out not all view modifiers behave as intuitively as \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-pmi7\"\u003e\u003ccode\u003escaleEffect\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/rotationeffect(_:anchor:)\"\u003e\u003ccode\u003erotationEffect\u003c/code\u003e\u003c/a\u003e when combined with the \u003ccode\u003eanimation\u003c/code\u003e modifier.\u003c/p\u003e\n\n\u003ch2 id=\"some-modifiers-dont-respect-the-rules\"\u003e4. Some modifiers don’t respect the rules\u003c/h2\u003e\n\n\u003cp\u003eIn this example we’re changing the color, size, and alignment of the rectangle. Only the size change should be animated, which is why we’ve placed the alignment and color mutations outside the \u003ccode\u003eanimation\u003c/code\u003e modifier:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample4\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e120\u003c/span\u003e\n    \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003emaxWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einfinity\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ealignment\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eleading\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etrailing\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epink\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eindigo\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eUnfortunately, this doesn’t work as intended, as all three changes are animated:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-4.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-4.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003cp\u003eIt behaves as if the \u003ccode\u003eanimation\u003c/code\u003e modifier were the outermost element of this view subtree.\u003c/p\u003e\n\n\u003ch2 id=\"padding-and-border\"\u003e5. \u003ccode\u003epadding\u003c/code\u003e and \u003ccode\u003eborder\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eThis one’s sort of the inverse of the previous example because a change we want to animate doesn’t get animated. The \u003ccode\u003epadding\u003c/code\u003e is a child of the \u003ccode\u003eanimation\u003c/code\u003e modifier, so I’d expect changes to it to be animated, i.e. the border should grow and shrink smoothly:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample5\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eRectangle\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eframe\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e80\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epadding\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e20\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eborder\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eprimary\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecyan\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eBut that’s not what happens:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-5.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-5.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 id=\"font-modifiers\"\u003e6. Font modifiers\u003c/h2\u003e\n\n\u003cp\u003eFont modifiers also behave seemingly erratic with respect to the \u003ccode\u003eanimation\u003c/code\u003e modifier. In this example, we want to animate the font width, but not the size or weight (smooth text animation is a new feature in iOS 16):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eExample6\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n\n  \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eText\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e\u0026#34;Hello!\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efontWidth\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econdensed\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eexpanded\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003c/span\u003e\n      \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efont\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esystem\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\n        \u003cspan\u003esize\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e40\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e60\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\n        \u003cspan\u003eweight\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eregular\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheavy\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n      \u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYou guessed it, this doesn’t work as intended. Instead, all text properties animate smoothly:\u003c/p\u003e\n\n\u003cp\u003e\n\u003cfigure\u003e\n  \u003cvideo controls=\"\" width=\"932\"\u003e\n    \u003csource src=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-6.mp4\" type=\"video/mp4\"/\u003e\n  \u003c/video\u003e\n  \u003cfigcaption\u003e\n    \u003ca href=\"https://oleb.net/media/2022-11-10-SwiftUI-animation-example-6.mp4\"\u003eDownload video\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/p\u003e\n\n\u003ch2 id=\"why-does-it-work-like-this\"\u003eWhy does it work like this?\u003c/h2\u003e\n\n\u003cp\u003eIn summary, the placement of the \u003ccode\u003eanimation\u003c/code\u003e modifier in the view tree allows \u003cem\u003esome\u003c/em\u003e control over which changes get animated, but it isn’t perfect. Some modifiers, such as \u003ccode\u003escaleEffect\u003c/code\u003e and \u003ccode\u003erotationEffect\u003c/code\u003e, behave as expected, whereas others (\u003ccode\u003eframe\u003c/code\u003e, \u003ccode\u003epadding\u003c/code\u003e, \u003ccode\u003eforegroundColor\u003c/code\u003e, \u003ccode\u003efont\u003c/code\u003e) are less controllable.\u003c/p\u003e\n\n\u003cp\u003eI don’t fully understand the rules, but the important factor seems to be if a view modifier actually “renders” something or not. For instance, \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/foregroundcolor(_:)\"\u003e\u003ccode\u003eforegroundColor\u003c/code\u003e\u003c/a\u003e just writes a color into the environment; the modifier itself doesn’t draw anything. I suppose this is why its position with respect to \u003ccode\u003eanimation\u003c/code\u003e is irrelevant:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eRoundedRectangle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e40\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eanimation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003edefault\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eflag\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e// Color change still animates, even though we’re outside .animation\u003c/span\u003e\n  \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eforegroundColor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eflag\u003c/span\u003e \u003cspan\u003e?\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epink\u003c/span\u003e \u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eindigo\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe rendering presumably takes place on the level of the \u003ccode\u003eRoundedRectangle\u003c/code\u003e, which reads the color from the environment. At this point the \u003ccode\u003eanimation\u003c/code\u003e modifier is active, so SwiftUI will animate all changes that affect how the rectangle is rendered, regardless of where in the view tree they’re coming from.\u003c/p\u003e\n\n\u003cp\u003eThe same explanation makes intuitive sense for the font modifiers in \u003ca href=\"#font-modifiers\"\u003eexample 6\u003c/a\u003e. The actual rendering, and therefore the animation, occurs on the level of the \u003ccode\u003eText\u003c/code\u003e view. The various font modifiers affect how the text is drawn, but they don’t render anything themselves.\u003c/p\u003e\n\n\u003cp\u003eSimilarly, \u003ccode\u003epadding\u003c/code\u003e and \u003ccode\u003eframe\u003c/code\u003e (including the frame’s alignment) are “non-rendering” modifiers too. They don’t use the environment, but they influence the layout algorithm, which ultimately affects the size and position of one or more “rendering” views, such as the rectangle in \u003ca href=\"#some-modifiers-dont-respect-the-rules\"\u003eexample 4\u003c/a\u003e. That rectangle sees a combined change in its geometry, but it can’t tell where the change came from, so it’ll animate the full geometry change.\u003c/p\u003e\n\n\u003cp\u003eIn \u003ca href=\"#padding-and-border\"\u003eexample 5\u003c/a\u003e, the “rendering” view that’s affected by the padding change is the \u003ccode\u003eborder\u003c/code\u003e (which is implemented as \u003ca href=\"https://twitter.com/olebegemann/status/1579878430505852928\"\u003ea stroked rectangle in an overlay\u003c/a\u003e). Since the border is a parent of the \u003ccode\u003eanimation\u003c/code\u003e modifier, its geometry change is not animated.\u003c/p\u003e\n\n\u003cp\u003eIn contrast to \u003ccode\u003eframe\u003c/code\u003e and \u003ccode\u003epadding\u003c/code\u003e, \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/scaleeffect(_:anchor:)-pmi7\"\u003e\u003ccode\u003escaleEffect\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/swiftui/view/rotationeffect(_:anchor:)\"\u003e\u003ccode\u003erotationEffect\u003c/code\u003e\u003c/a\u003e are “rendering” modifiers. They apparently perform the animations themselves.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eSwiftUI views and view modifiers can be divided into “rendering“ and “non-rendering” groups (I wish I had better terms for these). In iOS 16/macOS 13, the placement of the \u003ccode\u003eanimation\u003c/code\u003e modifier with respect to non-rendering modifiers is irrelevant for deciding if a change gets animated or not.\u003c/p\u003e\n\n\u003cp\u003eNon-rendering modifiers include (non-exhaustive list):\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eLayout modifiers (\u003ccode\u003eframe\u003c/code\u003e, \u003ccode\u003epadding\u003c/code\u003e, \u003ccode\u003eposition\u003c/code\u003e, \u003ccode\u003eoffset\u003c/code\u003e)\u003c/li\u003e\n  \u003cli\u003eFont modifiers (\u003ccode\u003efont\u003c/code\u003e, \u003ccode\u003ebold\u003c/code\u003e, \u003ccode\u003eitalic\u003c/code\u003e, \u003ccode\u003efontWeight\u003c/code\u003e, \u003ccode\u003efontWidth\u003c/code\u003e)\u003c/li\u003e\n  \u003cli\u003eOther modifiers that write data into the environment, e.g. \u003ccode\u003eforegroundColor\u003c/code\u003e, \u003ccode\u003eforegroundStyle\u003c/code\u003e, \u003ccode\u003esymbolRenderingMode\u003c/code\u003e, \u003ccode\u003esymbolVariant\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eRendering modifiers include (non-exhaustive list):\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003eclipShape\u003c/code\u003e, \u003ccode\u003ecornerRadius\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eGeometry effects, e.g. \u003ccode\u003escaleEffect\u003c/code\u003e, \u003ccode\u003erotationEffect\u003c/code\u003e, \u003ccode\u003eprojectionEffect\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eGraphical effects, e.g. \u003ccode\u003eblur\u003c/code\u003e, \u003ccode\u003ebrightness\u003c/code\u003e, \u003ccode\u003ehueRotation\u003c/code\u003e, \u003ccode\u003eopacity\u003c/code\u003e, \u003ccode\u003esaturation\u003c/code\u003e, \u003ccode\u003eshadow\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "10 min read",
  "publishedTime": "2022-11-10T21:48:45Z",
  "modifiedTime": "2022-11-16T12:14:24Z"
}
