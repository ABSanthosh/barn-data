{
  "id": "71b9466c-85a2-4c99-8def-061275238558",
  "title": "Better logging with Emoji",
  "link": "https://atomicbird.com/blog/emoji-logging/",
  "description": "Apple’s developer tools provide a rich variety of debugging aids. Sometimes though, it’s useful to do things the old fashioned way. With debugging, this often means just printing out data while your code runs, and then looking through the results to see what’s going on. Some scenarios where printing debug data helps include: When you need to check on something that happens a lot. When the mental context switching between using your app and using the debugger gets to be too much.",
  "author": "",
  "published": "Fri, 17 Jan 2020 00:00:00 +0000",
  "source": "https://atomicbird.com/index.xml",
  "categories": null,
  "byline": "",
  "length": 10117,
  "excerpt": "Apple’s developer tools provide a rich variety of debugging aids. Sometimes though, it’s useful to do things the old fashioned way. With debugging, this often means just printing out data while your code runs, and then looking through the results to see what’s going on. Some scenarios where printing debug data helps include: When you need to check on something that happens a lot. When the mental context switching between using your app and using the debugger gets to be too much.",
  "siteName": "Title",
  "favicon": "https://atomicbird.com/apple-touch-icon-144-precomposed.png",
  "text": "Apple’s developer tools provide a rich variety of debugging aids. Sometimes though, it’s useful to do things the old fashioned way. With debugging, this often means just printing out data while your code runs, and then looking through the results to see what’s going on. Some scenarios where printing debug data helps include: When you need to check on something that happens a lot. When the mental context switching between using your app and using the debugger gets to be too much. When short timeouts for actions mean that a round-trip to the debugger interferes when what you want to test. If something happens automatically after a few seconds, can you get to Xcode and back in time? Xcode breakpoint actions If you’re not using a lot of debug printing, Xcode’s breakpoint actions are a good choice. Add a breakpoint and give it a “log message” action that prints something useful. Then make sure the breakpoint automatically continues, so that the code prints the message but doesn’t actually stop on the line. This is really nice because you can add these anywhere without putting debug-only print statements in your code. There’s zero chance of these ending up in production code, since they only exist in Xcode. There are a couple of drawbacks. One is that you need to use the Xcode UI to add them, which gets tedious if you need more than a few. You can’t copy and paste them– you need to go through a bunch of mouse actions for each one. Another is that Xcode still has the annoying habit that, if you delete a line of code, a breakpoint on that line or on an adjacent line will sometimes disappear. There goes your print statement! Improving on “print” for debugging The obvious alternative in Swift is to use print wherever you need to know what’s happening. That’s easy and common, so if it works for you, go right ahead. I have a wrapper I’ve used that makes it a little more useful when debugging. Often when I want to print, all I really want to know is “hey, you reached this line of code”. The log message needs to tell me where it is, but nothing else is necessary. I could do something like this but it gets to be almost as tedious as using breakpoint actions, since each one needs to be customized: print(\"Made it to DetailViewController's viewDidLoad\") Simple, yes, but every one is different, so I’d have to type out each one. My first pass at this makes use of Swift’s #file, #function, and #line to fill in the details of where the message occurs. There’s an optional extra message to add relevant information: func logMilestone(_ message: String? = nil, file: String = #file, function: String = #function, line: Int = #line) -\u003e Void { if let message = message { print(\"Milestone: \\((file as NSString).lastPathComponent):\\(line) \\(function): \\(message)\") } else { print(\"Milestone: \\((file as NSString).lastPathComponent):\\(line) \\(function)\") } } These hashtag-like values provide default values for function arguments. Since all arguments are either optional or have default values, I can call this message with no arguments. Dropping this in various places in code: Produces something like this: Milestone: AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:) Milestone: SceneDelegate.swift:20 scene(_:willConnectTo:options:) Milestone: SplitViewController.swift:14 viewDidLoad() Milestone: SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:) Milestone: BaseCollectionViewController.swift:40 viewDidLoad() Milestone: BaseCollectionViewController.swift:15 collectionView Milestone: BaseCollectionViewController.swift:26 layout Milestone: SymbolsCollectionViewController.swift:63 viewDidLoad() Milestone: SymbolsCollectionViewController.swift:13 searchController Milestone: SymbolsCollectionViewController.swift:37 symbols For each message I get the filename, line number, and function where logMilestone was called. It even works for computed properties, showing the property name instead of the function. I include the word Milestone because it makes it easy to use Xcode’s console filtering so that I see only these messages and nothing else. Using Emoji to improve readability So that’s nice, but it can still be awkward if you have a lot of log messages. It would be handy if there were some visual cue about what file a message came from. You might see a message from one file and want to find the next one from that file, even if there are a bunch of other messages in between. What if each filename had a unique Emoji? I do this by getting an integer hash of the filename, and then using that integer to select an Emoji from an array. That ends up looking like this. func logMilestone(_ message: String? = nil, file: String = #file, function: String = #function, line: Int = #line) -\u003e Void { let logEmojis = [\"😀\",\"😎\",\"😱\",\"😈\",\"👺\",\"👽\",\"👾\",\"🤖\",\"🎃\",\"👍\",\"👁\",\"🧠\",\"🎒\",\"🧤\",\"🐶\",\"🐱\",\"🐭\",\"🐹\",\"🦊\",\"🐻\",\"🐨\",\"🐵\",\"🦄\",\"🦋\",\"🌈\",\"🔥\",\"💥\",\"⭐️\",\"🍉\",\"🥝\",\"🌽\",\"🍔\",\"🍿\",\"🎹\",\"🎁\",\"❤️\",\"🧡\",\"💛\",\"💚\",\"💙\",\"💜\",\"🔔\"] let logEmoji = logEmojis[abs(file.hashValue % logEmojis.count)] if let message = message { print(\"Milestone: \\(logEmoji) \\((file as NSString).lastPathComponent):\\(line) \\(function): \\(message)\") } else { print(\"Milestone: \\(logEmoji) \\((file as NSString).lastPathComponent):\\(line) \\(function)\") } } The filename’s hash value selects an entry from logEmojis, and this Emoji becomes part of the log message. The log messages from earlier end up looking like this: Milestone: 👺 AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:) Milestone: 💚 SceneDelegate.swift:20 scene(_:willConnectTo:options:) Milestone: 👾 SplitViewController.swift:14 viewDidLoad() Milestone: 💚 SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:) Milestone: 🤖 BaseCollectionViewController.swift:40 viewDidLoad() Milestone: 🤖 BaseCollectionViewController.swift:15 collectionView Milestone: 🤖 BaseCollectionViewController.swift:26 layout Milestone: 🐵 SymbolsCollectionViewController.swift:63 viewDidLoad() Milestone: 🐵 SymbolsCollectionViewController.swift:13 searchController Milestone: 🐵 SymbolsCollectionViewController.swift:37 symbols If I want to know what’s going on in BaseCollectionViewController.swift, I can visually scan (or have Xcode filter) for the 🤖 Emoji. The logEmojis array is somewhat arbitrary. I wanted a few dozen entries to reduce the chance of collisions where more than one file would use the same Emoji. I chose them mostly with the goal of making them visually distinct, avoiding Emoji with similar color and shape to others in the list. One minor annoyance is that since hashValue is randomized, each file uses a different Emoji every time you run the app. It might be possible to fix that with a custom non-random hash function but I haven’t taken it that far. If you have an idea for that, I’d love to hear it. Fine tuning There are a few other adjustments that can be useful. Time stamps and thread info If you replace print in the function body with NSLog, you’ll get both a time stamp and a thread ID. If timing is important or if you’re working on more than one thread, this can be really handy. If not though, it’s just noise. 2020-01-13 16:59:16.349681-0700 SF Viewer[71421:13996033] Milestone: 🎹 AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:) 2020-01-13 16:59:16.452943-0700 SF Viewer[71421:13996033] Milestone: 😱 SceneDelegate.swift:20 scene(_:willConnectTo:options:) 2020-01-13 16:59:16.466323-0700 SF Viewer[71421:13996033] Milestone: 🔥 SplitViewController.swift:14 viewDidLoad() 2020-01-13 16:59:16.485690-0700 SF Viewer[71421:13996033] Milestone: 😱 SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:) 2020-01-13 16:59:16.534898-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:40 viewDidLoad() 2020-01-13 16:59:16.535238-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:15 collectionView 2020-01-13 16:59:16.535423-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:26 layout 2020-01-13 16:59:16.540553-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:63 viewDidLoad() 2020-01-13 16:59:16.541802-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:13 searchController 2020-01-13 16:59:16.623701-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:37 symbols 2020-01-13 16:59:16.624456-0700 SF Viewer[71421:13996033] Milestone: 😱 Symbols.swift:102 readCSV(_:) 2020-01-13 16:59:16.627482-0700 SF Viewer[71421:13996033] Milestone: 😱 Symbols.swift:81 getFont(for:): Getting font for weight UIImageSymbolWeight That’s a lot of extra text on every log message. Sometimes though, you really need that information. Logging errors I like to include a second version of the function that wraps the one above, as a convenience when I want to log a Swift Error: func logMilestone(_ error: Error, file: String = #file, function: String = #function, line: Int = #line) -\u003e Void { logMilestone(error.localizedDescription, file: file, function: function, line: line) } It’s simple but it means I can just logMilestone(error) and have it work. Keeping logs out of production code Of course I don’t want any of this leaking through to production code. Fortunately, Xcode adds a DEBUG compiler flag to new projects (and it’s easy to add one if you don’t have it) which can easily turn logMilestone into a no-op in production builds. Just add a check inside the function, like this: func logMilestone(_ message: String? = nil, file: String = #file, function: String = #function, line: Int = #line) -\u003e Void { #if DEBUG // Function body goes here #endif } Final notes A public gist with logMilestone can be found at https://gist.github.com/atomicbird/d3e6f40663ab481f3d3c73428a2a9046. Comments, questions, and forks are welcome. The files mentioned in the sample log messages are all from Aaron Pearce’s excellent SF Viewer app, which I used here for demonstration purposes. Update: This post was featured in iOS Dev Weekly #441. Thanks again, Dave!",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n    \u003cp\u003eApple’s developer tools provide a rich variety of debugging aids. Sometimes though, it’s useful to do things the old fashioned way. With debugging, this often means just printing out data while your code runs, and then looking through the results to see what’s going on.\u003c/p\u003e\n\u003cp\u003eSome scenarios where printing debug data helps include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen you need to check on something that happens a lot.\u003c/li\u003e\n\u003cli\u003eWhen the mental context switching between using your app and using the debugger gets to be too much.\u003c/li\u003e\n\u003cli\u003eWhen short timeouts for actions mean that a round-trip to the debugger interferes when what you want to test. If something happens automatically after a few seconds, can you get to Xcode and back in time?\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"xcode-breakpoint-actions\"\u003eXcode breakpoint actions\u003c/h3\u003e\n\u003cp\u003eIf you’re not using a lot of debug printing, Xcode’s breakpoint actions are a good choice. Add a breakpoint and give it a “log message” action that prints something useful. Then make sure the breakpoint automatically continues, so that the code prints the message but doesn’t actually stop on the line.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/emoji-logging/xcode-breakpoint-action.png\" alt=\"Xcode breakpoint action\"/\u003e\u003c/p\u003e\n\u003cp\u003eThis is really nice because you can add these anywhere without putting debug-only print statements in your code. There’s zero chance of these ending up in production code, since they only exist in Xcode.\u003c/p\u003e\n\u003cp\u003eThere are a couple of drawbacks. One is that you need to use the Xcode UI to add them, which gets tedious if you need more than a few. You can’t copy and paste them– you need to go through a bunch of mouse actions for each one. Another is that Xcode \u003cem\u003estill\u003c/em\u003e has the annoying habit that, if you delete a line of code, a breakpoint on that line \u003cem\u003eor on an adjacent line\u003c/em\u003e will sometimes disappear. There goes your print statement!\u003c/p\u003e\n\u003ch3 id=\"improving-on-print-for-debugging\"\u003eImproving on “print” for debugging\u003c/h3\u003e\n\u003cp\u003eThe obvious alternative in Swift is to use \u003ccode\u003eprint\u003c/code\u003e wherever you need to know what’s happening. That’s easy and common, so if it works for you, go right ahead.\u003c/p\u003e\n\u003cp\u003eI have a wrapper I’ve used that makes it a little more useful when debugging. Often when I want to \u003ccode\u003eprint\u003c/code\u003e, all I really want to know is “hey, you reached this line of code”. The log message needs to tell me where it is, but nothing else is necessary.\u003c/p\u003e\n\u003cp\u003eI could do something like this but it gets to be almost as tedious as using breakpoint actions, since each one needs to be customized:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003eprint(\u003cspan\u003e\u0026#34;Made it to DetailViewController\u0026#39;s viewDidLoad\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eSimple, yes, but every one is different, so I’d have to type out each one.\u003c/p\u003e\n\u003cp\u003eMy first pass at this makes use of Swift’s \u003ccode\u003e#file\u003c/code\u003e, \u003ccode\u003e#function\u003c/code\u003e, and \u003ccode\u003e#line\u003c/code\u003e to fill in the details of where the message occurs. There’s an optional extra \u003ccode\u003emessage\u003c/code\u003e to add relevant information:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003elogMilestone\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e message: String? = \u003cspan\u003enil\u003c/span\u003e, file: String = \u003cspan\u003e#file\u003c/span\u003e, function: String = \u003cspan\u003e#function\u003c/span\u003e, line: Int = \u003cspan\u003e#line\u003c/span\u003e) -\u0026gt; Void {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e message = message {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        print(\u003cspan\u003e\u0026#34;Milestone: \u003c/span\u003e\u003cspan\u003e\\((\u003c/span\u003efile \u003cspan\u003eas\u003c/span\u003e NSString\u003cspan\u003e)\u003c/span\u003e.lastPathComponent\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eline\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003efunction\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003emessage\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    } \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        print(\u003cspan\u003e\u0026#34;Milestone: \u003c/span\u003e\u003cspan\u003e\\((\u003c/span\u003efile \u003cspan\u003eas\u003c/span\u003e NSString\u003cspan\u003e)\u003c/span\u003e.lastPathComponent\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eline\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003efunction\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThese hashtag-like values provide default values for function arguments. Since all arguments are either optional or have default values, I can call this message with no arguments. Dropping this in various places in code:\u003c/p\u003e\n\u003cp\u003eProduces something like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eMilestone: AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:)\nMilestone: SceneDelegate.swift:20 scene(_:willConnectTo:options:)\nMilestone: SplitViewController.swift:14 viewDidLoad()\nMilestone: SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:)\nMilestone: BaseCollectionViewController.swift:40 viewDidLoad()\nMilestone: BaseCollectionViewController.swift:15 collectionView\nMilestone: BaseCollectionViewController.swift:26 layout\nMilestone: SymbolsCollectionViewController.swift:63 viewDidLoad()\nMilestone: SymbolsCollectionViewController.swift:13 searchController\nMilestone: SymbolsCollectionViewController.swift:37 symbols\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eFor each message I get the filename, line number, and function where \u003ccode\u003elogMilestone\u003c/code\u003e was called. It even works for computed properties, showing the property name instead of the function.\u003c/p\u003e\n\u003cp\u003eI include the word \u003ccode\u003eMilestone\u003c/code\u003e because it makes it easy to use Xcode’s console filtering so that I see \u003cem\u003eonly\u003c/em\u003e these messages and nothing else.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://atomicbird.com/blog/emoji-logging/xcode-console-filter.png#center50\" alt=\"Xcode console filter\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"using-emoji-to-improve-readability\"\u003eUsing Emoji to improve readability\u003c/h3\u003e\n\u003cp\u003eSo that’s nice, but it can still be awkward if you have a lot of log messages. It would be handy if there were some visual cue about what file a message came from. You might see a message from one file and want to find the next one from that file, even if there are a bunch of other messages in between. What if each filename had a unique Emoji?\u003c/p\u003e\n\u003cp\u003eI do this by getting an integer hash of the filename, and then using that integer to select an Emoji from an array. That ends up looking like this.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003elogMilestone\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e message: String? = \u003cspan\u003enil\u003c/span\u003e, file: String = \u003cspan\u003e#file\u003c/span\u003e, function: String = \u003cspan\u003e#function\u003c/span\u003e, line: Int = \u003cspan\u003e#line\u003c/span\u003e) -\u0026gt; Void {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e logEmojis = [\u003cspan\u003e\u0026#34;😀\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;😎\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;😱\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;😈\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;👺\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;👽\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;👾\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🤖\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🎃\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;👍\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;👁\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🧠\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🎒\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🧤\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐶\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐱\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐭\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐹\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🦊\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐻\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐨\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🐵\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🦄\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🦋\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🌈\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🔥\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;💥\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;⭐️\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🍉\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🥝\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🌽\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🍔\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🍿\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🎹\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🎁\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;❤️\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🧡\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;💛\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;💚\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;💙\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;💜\u0026#34;\u003c/span\u003e,\u003cspan\u003e\u0026#34;🔔\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e logEmoji = logEmojis[abs(file.hashValue \u003cspan\u003e%\u003c/span\u003e logEmojis.count)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e message = message {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        print(\u003cspan\u003e\u0026#34;Milestone: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003elogEmoji\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\((\u003c/span\u003efile \u003cspan\u003eas\u003c/span\u003e NSString\u003cspan\u003e)\u003c/span\u003e.lastPathComponent\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eline\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003efunction\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003emessage\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    } \u003cspan\u003eelse\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        print(\u003cspan\u003e\u0026#34;Milestone: \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003elogEmoji\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\((\u003c/span\u003efile \u003cspan\u003eas\u003c/span\u003e NSString\u003cspan\u003e)\u003c/span\u003e.lastPathComponent\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003eline\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\\(\u003c/span\u003efunction\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe filename’s hash value selects an entry from \u003ccode\u003elogEmojis\u003c/code\u003e, and this Emoji becomes part of the log message. The log messages from earlier end up looking like this:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eMilestone: 👺 AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:)\nMilestone: 💚 SceneDelegate.swift:20 scene(_:willConnectTo:options:)\nMilestone: 👾 SplitViewController.swift:14 viewDidLoad()\nMilestone: 💚 SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:)\nMilestone: 🤖 BaseCollectionViewController.swift:40 viewDidLoad()\nMilestone: 🤖 BaseCollectionViewController.swift:15 collectionView\nMilestone: 🤖 BaseCollectionViewController.swift:26 layout\nMilestone: 🐵 SymbolsCollectionViewController.swift:63 viewDidLoad()\nMilestone: 🐵 SymbolsCollectionViewController.swift:13 searchController\nMilestone: 🐵 SymbolsCollectionViewController.swift:37 symbols\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf I want to know what’s going on in \u003ccode\u003eBaseCollectionViewController.swift\u003c/code\u003e, I can visually scan (or have Xcode filter) for the \u003ccode\u003e🤖\u003c/code\u003e Emoji.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003elogEmojis\u003c/code\u003e array is somewhat arbitrary. I wanted a few dozen entries to reduce the chance of collisions where more than one file would use the same Emoji. I chose them mostly with the goal of making them visually distinct, avoiding Emoji with similar color and shape to others in the list.\u003c/p\u003e\n\u003cp\u003eOne minor annoyance is that since \u003ccode\u003ehashValue\u003c/code\u003e is randomized, each file uses a different Emoji every time you run the app. It might be possible to fix that with a custom non-random hash function but I haven’t taken it that far. If you have an idea for that, I’d love to hear it.\u003c/p\u003e\n\u003ch3 id=\"fine-tuning\"\u003eFine tuning\u003c/h3\u003e\n\u003cp\u003eThere are a few other adjustments that can be useful.\u003c/p\u003e\n\u003ch4 id=\"time-stamps-and-thread-info\"\u003eTime stamps and thread info\u003c/h4\u003e\n\u003cp\u003eIf you replace \u003ccode\u003eprint\u003c/code\u003e in the function body with \u003ccode\u003eNSLog\u003c/code\u003e, you’ll get both a time stamp and a thread ID. If timing is important or if you’re working on more than one thread, this can be really handy. If not though, it’s just noise.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2020-01-13 16:59:16.349681-0700 SF Viewer[71421:13996033] Milestone: 🎹 AppDelegate.swift:19 application(_:didFinishLaunchingWithOptions:)\n2020-01-13 16:59:16.452943-0700 SF Viewer[71421:13996033] Milestone: 😱 SceneDelegate.swift:20 scene(_:willConnectTo:options:)\n2020-01-13 16:59:16.466323-0700 SF Viewer[71421:13996033] Milestone: 🔥 SplitViewController.swift:14 viewDidLoad()\n2020-01-13 16:59:16.485690-0700 SF Viewer[71421:13996033] Milestone: 😱 SceneDelegate.swift:61 splitViewController(_:collapseSecondary:onto:)\n2020-01-13 16:59:16.534898-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:40 viewDidLoad()\n2020-01-13 16:59:16.535238-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:15 collectionView\n2020-01-13 16:59:16.535423-0700 SF Viewer[71421:13996033] Milestone: 🦊 BaseCollectionViewController.swift:26 layout\n2020-01-13 16:59:16.540553-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:63 viewDidLoad()\n2020-01-13 16:59:16.541802-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:13 searchController\n2020-01-13 16:59:16.623701-0700 SF Viewer[71421:13996033] Milestone: 🤖 SymbolsCollectionViewController.swift:37 symbols\n2020-01-13 16:59:16.624456-0700 SF Viewer[71421:13996033] Milestone: 😱 Symbols.swift:102 readCSV(_:)\n2020-01-13 16:59:16.627482-0700 SF Viewer[71421:13996033] Milestone: 😱 Symbols.swift:81 getFont(for:): Getting font for weight UIImageSymbolWeight\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat’s a lot of extra text on every log message. Sometimes though, you really need that information.\u003c/p\u003e\n\u003ch4 id=\"logging-errors\"\u003eLogging errors\u003c/h4\u003e\n\u003cp\u003eI like to include a second version of the function that wraps the one above, as a convenience when I want to log a Swift \u003ccode\u003eError\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003elogMilestone\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e error: Error, file: String = \u003cspan\u003e#file\u003c/span\u003e, function: String = \u003cspan\u003e#function\u003c/span\u003e, line: Int = \u003cspan\u003e#line\u003c/span\u003e) -\u0026gt; Void {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    logMilestone(error.localizedDescription, file: file, function: function, line: line)\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eIt’s simple but it means I can just \u003ccode\u003elogMilestone(error)\u003c/code\u003e and have it work.\u003c/p\u003e\n\u003ch4 id=\"keeping-logs-out-of-production-code\"\u003eKeeping logs out of production code\u003c/h4\u003e\n\u003cp\u003eOf course I don’t want any of this leaking through to production code. Fortunately, Xcode adds a \u003ccode\u003eDEBUG\u003c/code\u003e compiler flag to new projects (and it’s easy to add one if you don’t have it) which can easily turn \u003ccode\u003elogMilestone\u003c/code\u003e into a no-op in production builds. Just add a check inside the function, like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003elogMilestone\u003c/span\u003e(\u003cspan\u003e_\u003c/span\u003e message: String? = \u003cspan\u003enil\u003c/span\u003e, file: String = \u003cspan\u003e#file\u003c/span\u003e, function: String = \u003cspan\u003e#function\u003c/span\u003e, line: Int = \u003cspan\u003e#line\u003c/span\u003e) -\u0026gt; Void {\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#if\u003c/span\u003e \u003cspan\u003eDEBUG\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e// Function body goes here\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e#endif\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"final-notes\"\u003eFinal notes\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eA public gist with \u003ccode\u003elogMilestone\u003c/code\u003e can be found at \u003ca href=\"https://gist.github.com/atomicbird/d3e6f40663ab481f3d3c73428a2a9046\"\u003ehttps://gist.github.com/atomicbird/d3e6f40663ab481f3d3c73428a2a9046\u003c/a\u003e. Comments, questions, and forks are welcome.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe files mentioned in the sample log messages are all from Aaron Pearce’s excellent \u003ca href=\"https://github.com/aaronpearce/SF-Viewer\"\u003eSF Viewer\u003c/a\u003e app, which I used here for demonstration purposes.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eUpdate\u003c/strong\u003e: This post was featured in \u003ca href=\"https://iosdevweekly.com/issues/441?#start\"\u003eiOS Dev Weekly #441\u003c/a\u003e. Thanks again, Dave!\u003c/p\u003e\n\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "11 min read",
  "publishedTime": "2020-01-17T00:00:00Z",
  "modifiedTime": "2020-01-17T00:00:00Z"
}
