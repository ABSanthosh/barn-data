{
  "id": "3b182ec6-3d7c-40b5-be9d-a31c4345091d",
  "title": "Swift Testing Completion Handlers",
  "link": "https://useyourloaf.com/blog/swift-testing-completion-handlers/",
  "description": "How do you migrate an XCTest using completion handlers to Swift Testing? I’ve been slowly migrating XCTest cases to Swift Testing. One situation that slowed me down was figuring out the best way to test code that relies on completion handlers. XCTest Expectations I use a custom subclass of NSPersistentContainer when working with Core Data. My subclass performs some extra configuration when loading the store but otherwise works the same way. The loadPersistentStores method calls a completion handler for each store it loads: container.loadPersistentStores { description, error if let error { // handle error }} } I configure my container to load the store, and call the completion handler, asynchronously. I tested the operation with an XCTest like this: import XCTest class StoreTests: XCTestCase { private var container: CoreDataContainer! override func setupWithError() { container = CoreDataContainer(...) } @MainActor func testLoadStore() { let expect = expectation(description: \"Store loaded\") container.loadPersistentStores { description, error in XCTAssertNil(error) expect.fulfill() } waitForExpectations(timeout: 2, handler: nil) XCTAssertTrue(container.isStoreLoaded) } } The XCTest framework provides an expectation mechanism for testing asynchronous completion blocks like this. You first create an expectation: let expect = expectation(description: \"Store loaded\") Then in the completion handler we mark the expectation as fulfilled: expect.fulfill() Then we can wait for the expectation to fulfill. If we don’t fulfill the expectation within the timeout the test fails: waitForExpectations(timeout: 2, handler: nil) Swift Continuations The Swift Testing framework doesn’t use expectations. It does have something similar called confirmations, but they don’t help when testing completion handler code. Donny Wals has a helpful explanation. In brief, the confirmation doesn’t block the caller so we have no way to wait until we have fulfilled the confirmation (expectation). Apple’s guide to migrating a test from XCTest gives more specific guidance on testing completion handlers: For a function that takes a completion handler but which doesn’t use await, a Swift continuation can be used to convert the call into an async-compatible one. So we want to convert our test to be async using a Swift continuation. This doesn’t need any Swift Testing features. We can even rewrite our XCTest method to be asynchronous using a continuation and remove the expectation: @MainActor func testLoadStore() async { await withCheckedContinuation{ continuation in container.loadPersistentStores { description, error in XCTAssertNil(error) continuation.resume() } } XCTAssertTrue(container.isStoreLoaded) } This approach does have a couple of downsides: Failure to call the continuation method hangs the test so you may want to configure a shorter test execution time allowance in a test plan. You must call the continuation once, and only once. That would be a problem if my container was loading multiple stores. Swift Testing Migrating this new XCTestCase to Swift Testing now follows a familiar path, replacing the XCTest assertions with #expect: import Testing @MainActor struct StoreTests { private let container: CoreDataContainer init() { container = ... } @Test func loadStore() async { await withCheckedContinuation { continuation in container.loadPersistentStores { description, error in #expect(error == nil) continuation.resume() } } #expect(container.isStoreLoaded) } } Swift Testing Completion Handlers was originally posted 10 Mar 2025 on useyourloaf.com. Want this direct to your inbox? Sign up and get my free WWDC viewing guide PDF.",
  "author": "",
  "published": "Mon, 10 Mar 2025 15:43:28 +0000",
  "source": "https://useyourloaf.com/blog/rss.xml",
  "categories": null,
  "byline": "",
  "length": 3625,
  "excerpt": "How do you test completion handlers with Swift Testing.",
  "siteName": "Use Your Loaf - iOS Development News \u0026 Tips",
  "favicon": "https://useyourloaf.com/apple-touch-icon.png",
  "text": "How do you migrate an XCTest using completion handlers to Swift Testing? I’ve been slowly migrating XCTest cases to Swift Testing. One situation that slowed me down was figuring out the best way to test code that relies on completion handlers. XCTest Expectations I use a custom subclass of NSPersistentContainer when working with Core Data. My subclass performs some extra configuration when loading the store but otherwise works the same way. The loadPersistentStores method calls a completion handler for each store it loads: container.loadPersistentStores { description, error if let error { // handle error }} } I configure my container to load the store, and call the completion handler, asynchronously. I tested the operation with an XCTest like this: import XCTest class StoreTests: XCTestCase { private var container: CoreDataContainer! override func setupWithError() { container = CoreDataContainer(...) } @MainActor func testLoadStore() { let expect = expectation(description: \"Store loaded\") container.loadPersistentStores { description, error in XCTAssertNil(error) expect.fulfill() } waitForExpectations(timeout: 2, handler: nil) XCTAssertTrue(container.isStoreLoaded) } } The XCTest framework provides an expectation mechanism for testing asynchronous completion blocks like this. You first create an expectation: let expect = expectation(description: \"Store loaded\") Then in the completion handler we mark the expectation as fulfilled: Then we can wait for the expectation to fulfill. If we don’t fulfill the expectation within the timeout the test fails: waitForExpectations(timeout: 2, handler: nil) Swift Continuations The Swift Testing framework doesn’t use expectations. It does have something similar called confirmations, but they don’t help when testing completion handler code. Donny Wals has a helpful explanation. In brief, the confirmation doesn’t block the caller so we have no way to wait until we have fulfilled the confirmation (expectation). Apple’s guide to migrating a test from XCTest gives more specific guidance on testing completion handlers: For a function that takes a completion handler but which doesn’t use await, a Swift continuation can be used to convert the call into an async-compatible one. So we want to convert our test to be async using a Swift continuation. This doesn’t need any Swift Testing features. We can even rewrite our XCTest method to be asynchronous using a continuation and remove the expectation: @MainActor func testLoadStore() async { await withCheckedContinuation{ continuation in container.loadPersistentStores { description, error in XCTAssertNil(error) continuation.resume() } } XCTAssertTrue(container.isStoreLoaded) } This approach does have a couple of downsides: Failure to call the continuation method hangs the test so you may want to configure a shorter test execution time allowance in a test plan. You must call the continuation once, and only once. That would be a problem if my container was loading multiple stores. Swift Testing Migrating this new XCTestCase to Swift Testing now follows a familiar path, replacing the XCTest assertions with #expect: import Testing @MainActor struct StoreTests { private let container: CoreDataContainer init() { container = ... } @Test func loadStore() async { await withCheckedContinuation { continuation in container.loadPersistentStores { description, error in #expect(error == nil) continuation.resume() } } #expect(container.isStoreLoaded) } }",
  "image": "https://useyourloaf.com/blog/swift-testing-completion-handlers/cover.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n\u003cp\u003eHow do you migrate an XCTest using completion handlers to Swift Testing?\u003c/p\u003e\n\u003cp\u003eI’ve been slowly \u003ca href=\"https://useyourloaf.com/blog/migrating-xctest-to-swift-testing/\"\u003emigrating XCTest cases to Swift Testing\u003c/a\u003e. One situation that slowed me down was figuring out the best way to test code that relies on completion handlers.\u003c/p\u003e\n\u003ch3 id=\"xctest-expectations\"\u003eXCTest Expectations\u003c/h3\u003e\n\u003cp\u003eI use a custom subclass of \u003ccode\u003eNSPersistentContainer\u003c/code\u003e when working with Core Data.  My subclass performs some extra configuration when loading the store but otherwise works the same way. The \u003ccode\u003eloadPersistentStores\u003c/code\u003e method calls a completion handler for each store it loads:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eloadPersistentStores\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eerror\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e// handle error }}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI configure my container to load the store, and call the completion handler, asynchronously. I tested the operation with an XCTest like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eXCTest\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eStoreTests\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eXCTestCase\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCoreDataContainer\u003c/span\u003e\u003cspan\u003e!\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eoverride\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003esetupWithError\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainer\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCoreDataContainer\u003c/span\u003e\u003cspan\u003e(...)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etestLoadStore\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eexpect\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eexpectation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;Store loaded\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eloadPersistentStores\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eXCTAssertNil\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efulfill\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewaitForExpectations\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ehandler\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eXCTAssertTrue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisStoreLoaded\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThe XCTest framework provides an expectation mechanism for testing asynchronous completion blocks like this. You first create an expectation:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eexpect\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eexpectation\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\u0026#34;Store loaded\u0026#34;\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThen in the completion handler we mark the expectation as fulfilled:\u003c/p\u003e\n\u003cp\u003eThen we can wait for the expectation to fulfill. If we don’t fulfill the expectation within the timeout the test fails:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003ewaitForExpectations\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etimeout\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ehandler\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"swift-continuations\"\u003eSwift Continuations\u003c/h3\u003e\n\u003cp\u003eThe Swift Testing framework doesn’t use expectations. It does have something similar called \u003cstrong\u003econfirmations\u003c/strong\u003e, but they don’t help when testing completion handler code. Donny Wals has a \u003ca href=\"https://www.donnywals.com/testing-completion-handler-based-code-in-swift-testing/\"\u003ehelpful explanation\u003c/a\u003e. In brief, the confirmation doesn’t block the caller so we have no way to wait until we have fulfilled the confirmation (expectation).\u003c/p\u003e\n\u003cp\u003eApple’s guide to \u003ca href=\"https://developer.apple.com/documentation/testing/migratingfromxctest\"\u003emigrating a test from XCTest\u003c/a\u003e gives more specific guidance on testing completion handlers:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor a function that takes a completion handler but which doesn’t use await, a Swift continuation can be used to convert the call into an async-compatible one.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eSo we want to convert our test to be async using a Swift continuation. This doesn’t need any Swift Testing features. We can even rewrite our XCTest method to be asynchronous using a continuation and remove the expectation:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003etestLoadStore\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003ewithCheckedContinuation\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtinuation\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eloadPersistentStores\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003eXCTAssertNil\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003econtinuation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresume\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eXCTAssertTrue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisStoreLoaded\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis approach does have a couple of downsides:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFailure to call the continuation method hangs the test so you may want to configure a shorter test execution time allowance in a test plan.\u003c/li\u003e\n\u003cli\u003eYou must call the continuation once, and only once. That would be a problem if my container was loading multiple stores.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"swift-testing\"\u003eSwift Testing\u003c/h3\u003e\n\u003cp\u003eMigrating this new XCTestCase to Swift Testing now follows a familiar path, replacing the XCTest assertions with #expect:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eTesting\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eMainActor\u003c/span\u003e \u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eStoreTests\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCoreDataContainer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003econtainer\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e@\u003c/span\u003e\u003cspan\u003eTest\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eloadStore\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003ewithCheckedContinuation\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003econtinuation\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eloadPersistentStores\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003edescription\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerror\u003c/span\u003e \u003cspan\u003e==\u003c/span\u003e \u003cspan\u003enil\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e        \u003cspan\u003econtinuation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eresume\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e      \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e    \u003cspan\u003e#\u003c/span\u003e\u003cspan\u003eexpect\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtainer\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eisStoreLoaded\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e  \u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e\u003cspan\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "5 min read",
  "publishedTime": "2025-03-10T15:43:28Z",
  "modifiedTime": "2025-03-16T14:41:59Z"
}
