{
  "id": "8582a727-ea31-4fb6-9481-7261d30f1ea4",
  "title": "Animating complex shapes in SwiftUI",
  "link": "https://nerdyak.tech/development/2020/01/12/animating-complex-shapes-in-swiftui.html",
  "description": "Hello and welcome to another blog post about SwiftUI. This time, we will talk about the animation of complex shapes in SwiftUI. You will understand animatableData property and will be able to implement animatable custom Shape struct that depends on multiple parameters.",
  "author": "Pavel Zak",
  "published": "2020-01-12T00:00:00+00:00",
  "source": "https://nerdyak.tech/atom.xml",
  "categories": [
    "development",
    "swiftUI",
    "shape",
    "animation",
    "animatableData",
    "animatablePair",
    "animatableVector",
    "path",
    "charts"
  ],
  "byline": "Pavel Zak",
  "length": 11842,
  "excerpt": "Hello and welcome to another blog post about SwiftUI. This time, we will talk about the animation of complex shapes in SwiftUI. You will understand animatableData property and will be able to implement animatable custom Shape struct that depends on multiple parameters.",
  "siteName": "Pavel Zak",
  "favicon": "",
  "text": "Hello and welcome to another blog post about SwiftUI. This time, we will talk about the animation of complex shapes in SwiftUI. You will understand animatableData property and will be able to implement animatable custom Shape struct that depends on multiple parameters. AnimatableData Animating simple shapes is easy thanks to animatableData property. We have seen an example of such animation in my previous post about custom controls. The magic behind animatableData is actually quite simple math. During the animation, the property value is being interpolated (or extrapolated in case of spring animation) from starting to the ending value according to the animation timing curve. To demonstrate it once again, let’s start with a simple rectangle with cout-out rounded corners. struct CoutOutRectangle: Shape { var cornerRadius: CGFloat var animatableData: CGFloat { get { cornerRadius } set { cornerRadius = newValue } } func path(in rect: CGRect) -\u003e Path { return Path { path in let width = rect.width let height = rect.height path.move(to: CGPoint(x: cornerRadius, y: 0)) path.addLine(to: CGPoint(x: width-cornerRadius, y: 0)) path.addQuadCurve(to: CGPoint(x: width, y: cornerRadius), control: CGPoint(x: width-cornerRadius, y: cornerRadius)) // path.addLine(to: CGPoint(x: width, y: height-cornerRadius)) path.addQuadCurve(to: CGPoint(x: width-cornerRadius, y: height), control: CGPoint(x: width-cornerRadius, y: height-cornerRadius)) // path.addLine(to: CGPoint(x: cornerRadius, y: height)) path.addQuadCurve(to: CGPoint(x: 0, y: height-cornerRadius), control: CGPoint(x: cornerRadius, y: height-cornerRadius)) // path.addLine(to: CGPoint(x: 0, y: cornerRadius)) path.addQuadCurve(to: CGPoint(x: cornerRadius, y: 0), control: CGPoint(x: cornerRadius, y: cornerRadius)) } } } Notice that I have created a single property called cornerRadius that is being set or read from animatableData setter and getter. That is enough for SwiftUI to perform the animation whenever we change the corner radius. Let’s test it within a simple demo view that periodically animates corners from value 0 to 20 and back. You can try to change the animation type or its parameters to see how the animation changes. struct AnimationDemoView: View { @State var cornerRadius: CGFloat = 0.0 var body: some View { CoutOutRectangle(cornerRadius: self.cornerRadius) .fill(Color.green) .onAppear{ withAnimation (Animation.easeOut(duration: 0.4).repeatForever(autoreverses: true)){ self.cornerRadius = 20.0 } } } } It works! AnimatablePair Now, in the case things are more complicated and we need to animate the shape according to two values, we can utilize AnimatablePair\u003cT\u003e type. Here the only obstacle is to define the right getter and setter to pass data between our control properties and values stored in AnimatablePair. As an example, we will build a wedge shape that can be used to compose pie charts. The wedge has two main properties - angleOffset and wedgeWidth that we both want to be animatable. The best explanation of both properties gives the following illustration: And the resulting code is here. Note how AnimatablePair`s first and second values are being mapped to our properties. struct WedgeShape: Shape { var angleOffset: Double // in radians var wedgeWidth: Double // in radians public var animatableData: AnimatablePair\u003cDouble, Double\u003e { get { AnimatablePair(Double(angleOffset), Double(wedgeWidth)) } set { self.angleOffset = newValue.first self.wedgeWidth = newValue.second } } func path(in rect: CGRect) -\u003e Path { return Path { path in let width = Double(rect.width) let height = Double(rect.height) let middlePoint = CGPoint(x: width/2, y: height/2) let startingPoint = CGPoint(x: width/2 + cos(self.angleOffset)*width/2, y: height/2 + sin(self.angleOffset)*height/2) path.move(to: middlePoint) path.addLine(to: startingPoint) path.addArc(center: middlePoint, radius: rect.width/2, startAngle: Angle(radians: self.angleOffset), endAngle: Angle(radians: self.angleOffset+self.wedgeWidth), clockwise: false, transform: CGAffineTransform.init(scaleX: 1, y: rect.height/rect.width).translatedBy(x: 0, y: (rect.width-rect.height)/2)) path.addLine(to: middlePoint) } } } Having wedge shape ready, it is now possible to compose a ZStack of these views to create an animatable pie chart, like this: AnimatableVector The obvious question appears. What if our view depends on multiple values and we wish to animate according to all of them? There are two solutions. First, it is possible to cascade multiple AnimatablePairs to pass more (like 3 or 4) values. Something like this: AnimatablePair\u003cCGFloat, AnimatablePair\u003cCGFloat, AnimatablePair\u003cCGFloat, CGFloat\u003e\u003e\u003e This is actually used within the implementation of EdgeInsets type, but as you can guess, it is not very flexible and usable for more than five or six values. Luckily, there is a better approach. As animatableData can be set any type that implements to VectorArithmetic protocol. As we have seen, it is implemented by basic scalar types like Double or CGFloat and of course by AnimatablePair. Knowing that, let us implement a brand new type called AnimatableVector that will be able to hold up to N values. The VectorArithmetic requires definition of magnitudeSquared property and scale method plus implementation of addition and subtraction operations from AdditiveArithmetic. Our type is implemented as a standard Euclidean vector: addition, subtraction, and scale of these vectors are being done per-value and the magnitude of the vector is computed as a sum of all squared values. In case you need to refresh this part of high-school math, check this wikipedia article. The whole implementation of AnimatableVector: struct AnimatableVector: VectorArithmetic { var values: [Double] // vector values init(count: Int = 1) { self.values = [Double](repeating: 0.0, count: count) self.magnitudeSquared = 0.0 } init(with values: [Double]) { self.values = values self.magnitudeSquared = 0 self.recomputeMagnitude() } func computeMagnitude()-\u003eDouble { // compute square magnitued of the vector // = sum of all squared values var sum: Double = 0.0 for index in 0..\u003cself.values.count { sum += self.values[index]*self.values[index] } return Double(sum) } mutating func recomputeMagnitude(){ self.magnitudeSquared = self.computeMagnitude() } // MARK: VectorArithmetic var magnitudeSquared: Double // squared magnitude of the vector mutating func scale(by rhs: Double) { // scale vector with a scalar // = each value is multiplied by rhs for index in 0..\u003cvalues.count { values[index] *= rhs } self.magnitudeSquared = self.computeMagnitude() } // MARK: AdditiveArithmetic // zero is identity element for aditions // = all values are zero static var zero: AnimatableVector = AnimatableVector() static func + (lhs: AnimatableVector, rhs: AnimatableVector) -\u003e AnimatableVector { var retValues = [Double]() for index in 0..\u003cmin(lhs.values.count, rhs.values.count) { retValues.append(lhs.values[index] + rhs.values[index]) } return AnimatableVector(with: retValues) } static func += (lhs: inout AnimatableVector, rhs: AnimatableVector) { for index in 0..\u003cmin(lhs.values.count,rhs.values.count) { lhs.values[index] += rhs.values[index] } lhs.recomputeMagnitude() } static func - (lhs: AnimatableVector, rhs: AnimatableVector) -\u003e AnimatableVector { var retValues = [Double]() for index in 0..\u003cmin(lhs.values.count, rhs.values.count) { retValues.append(lhs.values[index] - rhs.values[index]) } return AnimatableVector(with: retValues) } static func -= (lhs: inout AnimatableVector, rhs: AnimatableVector) { for index in 0..\u003cmin(lhs.values.count,rhs.values.count) { lhs.values[index] -= rhs.values[index] } lhs.recomputeMagnitude() } } With AnimatableVector you have now complete freedom in building animated shapes and views. One of the handiest use cases is probably the creation of various animated charts, so let me demonstrate it here as well. I present to you my implementation of AnimatableGraph that plots the values either as a chart line or whole area below it. As you can see, the chart values (here named as controlPoints) are stored and passed as AnimatableVector. struct AnimatableGraph: Shape { var controlPoints: AnimatableVector var closedArea: Bool var animatableData: AnimatableVector { set { self.controlPoints = newValue } get { return self.controlPoints } } func point(index: Int, rect: CGRect) -\u003e CGPoint { let value = self.controlPoints.values[index] let x = Double(index)/Double(self.controlPoints.values.count)*Double(rect.width) let y = Double(rect.height)*value return CGPoint(x: x, y: y) } func path(in rect: CGRect) -\u003e Path { return Path { path in let startPoint = self.point(index: 0, rect: rect) path.move(to: startPoint) var i = 1; while i \u003c self.controlPoints.values.count { path.addLine(to: self.point(index: i, rect: rect)) i += 1; } if (self.closedArea) { // closed area below the chart line path.addLine(to: CGPoint(x: rect.width, y: rect.height)) path.addLine(to: CGPoint(x: 0, y: rect.height)) path.addLine(to: startPoint) } } } } Now, you can style this shape by setting fill and stroke properties and present eye-catching charts that can animate whenever its values are altered: let areaGradient = LinearGradient(gradient: Gradient(colors: [Color.red.opacity(0.1), Color.blue.opacity(0.4)]), startPoint: UnitPoint(x: 0, y: 0), endPoint: UnitPoint(x: 0, y: 1)) let lineGradient = LinearGradient(gradient: Gradient(colors: [Color.white, Color.orange]), startPoint: UnitPoint(x: 0, y: 0), endPoint: UnitPoint(x: 1, y: 0)) struct DemoChart: View { var vector: AnimatableVector var body: some View { let overlayLine = AnimatableGraph(controlPoints: self.vector, closedArea: false) .stroke(lineGradient, lineWidth: 3) return AnimatableGraph(controlPoints: self.vector, closedArea: true) .fill(areaGradient) .overlay(overlayLine) } } The challenge Now try to play with the AnimationVector by yourself and as a challenge implement morphable shapes like this one below: Do not hesitate to share your solution or ask for help, I will gladly assist you. I am looking forward to see your output! Did you enjoy this article? Do you have anything to add? Feel free to comment or criticize so the next one is even better. Or share it with other SwiftUI adopters ;)",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv id=\"main\" aria-label=\"Content\"\u003e\n    \u003carticle\u003e\n      \u003cdiv\u003e\n        \u003cp\u003eHello and welcome to another blog post about SwiftUI. This time, we will talk about the animation of complex shapes in SwiftUI. You will understand animatableData property and will be able to implement animatable custom Shape struct that depends on multiple parameters.\u003c/p\u003e\n\n\u003ch2 id=\"animatabledata\"\u003eAnimatableData\u003c/h2\u003e\n\n\u003cp\u003eAnimating simple shapes is easy thanks to \u003ccode\u003eanimatableData\u003c/code\u003e property. We have seen an example of such animation in my previous post about \u003ca href=\"https://nerdyak.tech/development/2019/11/28/creating-custom-views-in-swiftui.html\"\u003ecustom controls\u003c/a\u003e. The magic behind \u003ccode\u003eanimatableData\u003c/code\u003e is actually quite simple math. During the animation, the property value is being interpolated (or extrapolated in case of spring animation) from starting to the ending value according to the animation timing curve.\u003c/p\u003e\n\n\u003cp\u003eTo demonstrate it once again, let’s start with a simple rectangle with cout-out rounded corners.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eCoutOutRectangle\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eShape\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eanimatableData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddQuadCurve\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003econtrol\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003e//\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddQuadCurve\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003econtrol\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003e//\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddQuadCurve\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003econtrol\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003e//\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddQuadCurve\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003econtrol\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNotice that I have created a single property called \u003ccode\u003ecornerRadius\u003c/code\u003e that is being set or read from \u003ccode\u003eanimatableData\u003c/code\u003e setter and getter. That is enough for SwiftUI to perform the animation whenever we change the corner radius.\u003c/p\u003e\n\n\u003cp\u003eLet’s test it within a simple demo view that periodically animates corners from value 0 to 20 and back.\u003c/p\u003e\n\n\u003cp\u003eYou can try to change the animation type or its parameters to see how the animation changes.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAnimationDemoView\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003e@State\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.0\u003c/span\u003e\n\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eCoutOutRectangle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003egreen\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eonAppear\u003c/span\u003e\u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003ewithAnimation\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eAnimation\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eeaseOut\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eduration\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.4\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erepeatForever\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eautoreverses\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)){\u003c/span\u003e\n                    \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecornerRadius\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e20.0\u003c/span\u003e\n                \u003cspan\u003e}\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eIt works!\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_cutoutrectangle.gif\" alt=\"rectangle\" title=\"Animated rectangle with cut out corners\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"animatablepair\"\u003eAnimatablePair\u003c/h2\u003e\n\n\u003cp\u003eNow, in the case things are more complicated and we need to animate the shape according to two values, we can utilize \u003ccode\u003eAnimatablePair\u0026lt;T\u0026gt;\u003c/code\u003e type. Here the only obstacle is to define the right getter and setter to pass data between our control properties and values stored in AnimatablePair.\u003c/p\u003e\n\n\u003cp\u003eAs an example, we will build a wedge shape that can be used to compose pie charts. The wedge has two main properties - \u003ccode\u003eangleOffset\u003c/code\u003e and \u003ccode\u003ewedgeWidth\u003c/code\u003e that we both want to be animatable. The best explanation of both properties gives the following illustration:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_wedge.jpg\" alt=\"wedgeExplanation\" title=\"Explanation of wedge parameters\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAnd the resulting code is here. Note how AnimatablePair`s first and second values are being mapped to our properties.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eWedgeShape\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eShape\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e// in radians\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ewedgeWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e// in radians\u003c/span\u003e\n    \n    \u003cspan\u003epublic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eanimatableData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatablePair\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e\u0026gt;\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n           \u003cspan\u003eAnimatablePair\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewedgeWidth\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n\n        \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efirst\u003c/span\u003e\n            \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewedgeWidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003esecond\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emiddlePoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartingPoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003ecos\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003esin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emiddlePoint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartingPoint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddArc\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecenter\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emiddlePoint\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eradius\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003estartAngle\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAngle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eradians\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eendAngle\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAngle\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eradians\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eangleOffset\u003c/span\u003e\u003cspan\u003e+\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewedgeWidth\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eclockwise\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003etransform\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGAffineTransform\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003escaleX\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003etranslatedBy\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e-\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n            \n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003emiddlePoint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eHaving wedge shape ready, it is now possible to compose a \u003ccode\u003eZStack\u003c/code\u003e of these views to create an animatable pie chart, like this:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_piechart.gif\" alt=\"pieChart\" title=\"Animated pie chart composed from several wedges\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"animatablevector\"\u003eAnimatableVector\u003c/h2\u003e\n\n\u003cp\u003eThe obvious question appears. What if our view depends on multiple values and we wish to animate according to all of them? There are two solutions.\u003c/p\u003e\n\n\u003cp\u003eFirst, it is possible to cascade multiple \u003ccode\u003eAnimatablePairs\u003c/code\u003e to pass more (like 3 or 4) values. Something like this:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003eAnimatablePair\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eAnimatablePair\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eAnimatablePair\u003c/span\u003e\u003cspan\u003e\u0026lt;\u003c/span\u003e\u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eCGFloat\u003c/span\u003e\u003cspan\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis is actually used within the implementation of \u003ccode\u003eEdgeInsets\u003c/code\u003e type, but as you can guess, it is not very flexible and usable for more than five or six values.\u003c/p\u003e\n\n\u003cp\u003eLuckily, there is a better approach. As \u003ccode\u003eanimatableData\u003c/code\u003e can be set any type that implements to \u003ccode\u003eVectorArithmetic\u003c/code\u003e protocol. As we have seen, it is implemented by basic scalar types like \u003ccode\u003eDouble\u003c/code\u003e or \u003ccode\u003eCGFloat\u003c/code\u003e and of course by \u003ccode\u003eAnimatablePair\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eKnowing that, let us implement a brand new type called \u003ccode\u003eAnimatableVector\u003c/code\u003e that will be able to hold up to \u003ccode\u003eN\u003c/code\u003e values. The \u003ccode\u003eVectorArithmetic\u003c/code\u003e requires definition of \u003ccode\u003emagnitudeSquared\u003c/code\u003e property and \u003ccode\u003escale\u003c/code\u003e method plus implementation of addition and subtraction operations from \u003ccode\u003eAdditiveArithmetic\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eOur type is implemented as a standard Euclidean vector: addition, subtraction, and scale of these vectors are being done per-value and the magnitude of the vector is computed as a sum of all squared values. In case you need to refresh this part of high-school math, check this \u003ca href=\"https://en.wikipedia.org/wiki/Euclidean_vector\"\u003ewikipedia article\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe whole implementation of \u003ccode\u003eAnimatableVector\u003c/code\u003e:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eVectorArithmetic\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e// vector values\u003c/span\u003e\n    \n    \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e](\u003c/span\u003e\u003cspan\u003erepeating\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0.0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emagnitudeSquared\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.0\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e \u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003evalues\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emagnitudeSquared\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003ecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\u003cspan\u003e-\u0026gt;\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// compute square magnitued of the vector\u003c/span\u003e\n        \u003cspan\u003e// = sum of all squared values\u003c/span\u003e\n        \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003esum\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0.0\u003c/span\u003e\n        \n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003esum\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003esum\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003emutating\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003erecomputeMagnitude\u003c/span\u003e\u003cspan\u003e(){\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emagnitudeSquared\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003e// MARK: VectorArithmetic\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003emagnitudeSquared\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e \u003cspan\u003e// squared magnitude of the vector\u003c/span\u003e\n    \n    \u003cspan\u003emutating\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003escale\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eby\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003e// scale vector with a scalar\u003c/span\u003e\n        \u003cspan\u003e// = each value is multiplied by rhs\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e*=\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emagnitudeSquared\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003e// MARK: AdditiveArithmetic\u003c/span\u003e\n    \n    \u003cspan\u003e// zero is identity element for aditions\u003c/span\u003e\n    \u003cspan\u003e// = all values are zero\u003c/span\u003e\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ezero\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eretValues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e]()\u003c/span\u003e\n        \n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eretValues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eretValues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eretValues\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e]()\u003c/span\u003e\n        \n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003eretValues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eappend\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e-\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e])\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ewith\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eretValues\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003e-=\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003einout\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003efor\u003c/span\u003e \u003cspan\u003eindex\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e..\u0026lt;\u003c/span\u003e\u003cspan\u003emin\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e\u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e  \u003cspan\u003e{\u003c/span\u003e\n            \u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e \u003cspan\u003e-=\u003c/span\u003e \u003cspan\u003erhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003elhs\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003erecomputeMagnitude\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eWith \u003ccode\u003eAnimatableVector\u003c/code\u003e you have now complete freedom in building animated shapes and views. One of the handiest use cases is probably the creation of various animated charts, so let me demonstrate it here as well.\u003c/p\u003e\n\n\u003cp\u003eI present to you my implementation of \u003ccode\u003eAnimatableGraph\u003c/code\u003e that plots the values either as a chart line or whole area below it. As you can see, the chart values (here named as \u003ccode\u003econtrolPoints\u003c/code\u003e) are stored and passed as \u003ccode\u003eAnimatableVector\u003c/code\u003e.\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eAnimatableGraph\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eShape\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eclosedArea\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eBool\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eanimatableData\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003eset\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enewValue\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003eget\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eInt\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003evalue\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e/\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eDouble\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e*\u003c/span\u003e\u003cspan\u003evalue\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n    \n    \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ein\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGRect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e \u003cspan\u003ePath\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003epath\u003c/span\u003e \u003cspan\u003ein\u003c/span\u003e\n            \n            \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003estartPoint\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emove\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartPoint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \n            \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003ewhile\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e\u0026lt;\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evalues\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecount\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n                \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e  \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eindex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                \u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e+=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n            \n            \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eclosedArea\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003e// closed area below the chart line\u003c/span\u003e\n                \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewidth\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eCGPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003erect\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eheight\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n                \u003cspan\u003epath\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eaddLine\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eto\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003estartPoint\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e}\u003c/span\u003e\n        \u003cspan\u003e}\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003eNow, you can style this shape by setting \u003ccode\u003efill\u003c/code\u003e and \u003ccode\u003estroke\u003c/code\u003e properties and present eye-catching charts that can animate whenever its values are altered:\u003c/p\u003e\n\n\u003cfigure\u003e\u003cpre\u003e\u003ccode data-lang=\"swift\"\u003e\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eareaGradient\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLinearGradient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003egradient\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eGradient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecolors\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ered\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0.1\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eblue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eopacity\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e0.4\u003c/span\u003e\u003cspan\u003e)]),\u003c/span\u003e \u003cspan\u003estartPoint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnitPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eendPoint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnitPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e \u003cspan\u003elineGradient\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eLinearGradient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003egradient\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eGradient\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ecolors\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ewhite\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eColor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eorange\u003c/span\u003e\u003cspan\u003e]),\u003c/span\u003e \u003cspan\u003estartPoint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnitPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e),\u003c/span\u003e \u003cspan\u003eendPoint\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnitPoint\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ex\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003ey\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e))\u003c/span\u003e\n\n\n\u003cspan\u003estruct\u003c/span\u003e \u003cspan\u003eDemoChart\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eAnimatableVector\u003c/span\u003e\n    \n    \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ebody\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003esome\u003c/span\u003e \u003cspan\u003eView\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n        \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003eoverlayLine\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eAnimatableGraph\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eclosedArea\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003efalse\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n            \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003estroke\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003elineGradient\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003elineWidth\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \u003cspan\u003ereturn\u003c/span\u003e  \u003cspan\u003eAnimatableGraph\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003econtrolPoints\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003evector\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003eclosedArea\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003efill\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eareaGradient\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n                    \u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eoverlay\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eoverlayLine\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n        \n    \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_chart.gif\" alt=\"animatedChart\" title=\"Animated chart\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"the-challenge\"\u003eThe challenge\u003c/h2\u003e\n\n\u003cp\u003eNow try to play with the \u003ccode\u003eAnimationVector\u003c/code\u003e by yourself and as a challenge implement morphable shapes like this one below:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://nerdyak.tech/assets/posts/07_shapes.gif\" alt=\"animatedShapes\" title=\"Challenge with morphing shapes\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eDo not hesitate to share your solution or ask for help, I will gladly assist you.\u003c/p\u003e\n\n\u003cp\u003eI am looking forward to see your output!\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eDid you enjoy this article? Do you have anything to add?\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eFeel free to comment or criticize so the next one is even better. Or share it with other SwiftUI adopters ;)\u003c/em\u003e\u003c/p\u003e\n\n\n      \u003c/div\u003e\n      \n    \u003c/article\u003e\n  \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "13 min read",
  "publishedTime": "2020-01-12T00:00:00Z",
  "modifiedTime": null
}
