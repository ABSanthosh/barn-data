{
  "id": "315ffb3b-5381-49f0-b23a-8a1db229cc5d",
  "title": "The algorithm powering iHarmony",
  "link": "https://albertodebortoli.com/2020/05/24/the-algorithm-powering-iharmony/",
  "description": "ProblemI wrote the first version of iHarmony in 2008. It was the very first iOS app I gave birth to, combining my passion for music and programming. I remember buying an iPhone and my first Mac with the precise purpose of jumping on the apps train at a time",
  "author": "Alberto De Bortoli",
  "published": "Sun, 24 May 2020 17:44:21 GMT",
  "source": "https://albertodebortoli.com/rss/",
  "categories": [
    "music",
    "chords",
    "scales",
    "iOS",
    "swift",
    "App Store"
  ],
  "byline": "Alberto De Bortoli",
  "length": 17159,
  "excerpt": "Problem I wrote the first version of iHarmony [https://apps.apple.com/gb/app/iharmony/id292413210] in 2008. It was the very first iOS app I gave birth to, combining my passion for music and programming. I remember buying an iPhone and my first Mac with the precise purpose of jumping on the apps train at a time when it wasn't clear if the apps were there to stay or were just a temporary hype. But I did it, dropped my beloved Ubuntu to join a whole new galaxy. iHarmony was also one of the first 20",
  "siteName": "Alberto De Bortoli",
  "favicon": "",
  "text": "ProblemI wrote the first version of iHarmony in 2008. It was the very first iOS app I gave birth to, combining my passion for music and programming. I remember buying an iPhone and my first Mac with the precise purpose of jumping on the apps train at a time when it wasn't clear if the apps were there to stay or were just a temporary hype. But I did it, dropped my beloved Ubuntu to join a whole new galaxy. iHarmony was also one of the first 2000 apps on the App Store.Up until the recent rewrite, iHarmony was powered by a manually crafted database containing scales, chords, and harmonization I inputted.What-a-shame!I guess it made sense, I wanted to learn iOS and not to focus on implementing some core logic independent from the platform. Clearly a much better and less error-prone way to go would be to implement an algorithm to generate all the entries based on some DSL/spec. It took me almost 12 years to decide to tackle the problem and I've recently realized that writing the algorithm I wanted was harder than I thought. Also thought was a good idea give SwiftUI a try since the UI of iHarmony is extremely simple but... nope.Since someone on the Internet expressed interest ðŸ˜‰, I wrote this article to explain how I solved the problem of modeling music theory concepts in a way that allows the generation of any sort of scales, chords, and harmonization. I only show the code needed to get a grasp of the overall structure.I know there are other solutions ready to be used on GitHub but, while I don't particularly like any of them, the point of rewriting iHarmony from scratch was to challenge myself, not to reuse code someone else wrote. Surprisingly to me, getting to the solution described here took me 3 rewrites and 2 weeks.SolutionThe first fundamental building blocks to model are surely the musical notes, which are made up of a natural note and an accidental.enum NaturalNote: String { case C, D, E, F, G, A, B } enum Accidental: String { case flatFlatFlat = \"bbb\" case flatFlat = \"bb\" case flat = \"b\" case natural = \"\" case sharp = \"#\" case sharpSharp = \"##\" case sharpSharpSharp = \"###\" func applyAccidental(_ accidental: Accidental) throws -\u003e Accidental {...} } struct Note: Hashable, Equatable { let naturalNote: NaturalNote let accidental: Accidental ... static let Dff = Note(naturalNote: .D, accidental: .flatFlat) static let Df = Note(naturalNote: .D, accidental: .flat) static let D = Note(naturalNote: .D, accidental: .natural) static let Ds = Note(naturalNote: .D, accidental: .sharp) static let Dss = Note(naturalNote: .D, accidental: .sharpSharp) ... func noteByApplyingAccidental(_ accidental: Accidental) throws -\u003e Note {...} }Combinations of notes make up scales and chords and they are... many. What's fixed instead in music theory, and therefore can be hard-coded, are the keys (both major and minor) such as:C major: C, D, E, F, G, A, BA minor: A, B, C, D, E, F, GD major: D, E, F#, G, A, B, C#We'll get back to the keys later, but we can surely implement the note sequence for each musical key.typealias NoteSequence = [Note] extension NoteSequence { static let C = [Note.C, Note.D, Note.E, Note.F, Note.G, Note.A, Note.B] static let A_min = [Note.A, Note.B, Note.C, Note.D, Note.E, Note.F, Note.G] static let G = [Note.G, Note.A, Note.B, Note.C, Note.D, Note.E, Note.Fs] static let E_min = [Note.E, Note.Fs, Note.G, Note.A, Note.B, Note.C, Note.D] ... }Next stop: intervals. They are a bit more interesting as not every degree has the same types. Let's split into 2 sets:2nd, 3rd, 6th and 7th degrees can be minor, major, diminished and augmented1st (and 8th), 4th and 5th degrees can be perfect, diminished and augmented.We need to use different kinds of \"diminished\" and \"augmented\" for the 2 sets as later on we'll have to calculate the accidentals needed to turn an interval into another.Some examples:to get from 2nd augmented to 2nd diminished, we need a triple flat accidental (e.g. in C major scale, from Dâ™¯ to Dâ™­â™­ there are 3 semitones)to get from 5th augmented to 5th diminished, we need a double flat accidental (e.g. in C major scale, from Gâ™¯ to Gâ™­there are 2 semitones)We proceed to hard-code the allowed intervals in music, leaving out the invalid ones (e.g. Interval(degree: ._2, type: .augmented))enum Degree: Int, CaseIterable { case _1, _2, _3, _4, _5, _6, _7, _8 } enum IntervalType: Int, RawRepresentable { case perfect case minor case major case diminished case augmented case minorMajorDiminished case minorMajorAugmented } struct Interval: Hashable, Equatable { let degree: Degree let type: IntervalType static let _1dim = Interval(degree: ._1, type: .diminished) static let _1 = Interval(degree: ._1, type: .perfect) static let _1aug = Interval(degree: ._1, type: .augmented) static let _2dim = Interval(degree: ._2, type: .minorMajorDiminished) static let _2min = Interval(degree: ._2, type: .minor) static let _2maj = Interval(degree: ._2, type: .major) static let _2aug = Interval(degree: ._2, type: .minorMajorAugmented) ... static let _4dim = Interval(degree: ._4, type: .diminished) static let _4 = Interval(degree: ._4, type: .perfect) static let _4aug = Interval(degree: ._4, type: .augmented) ... static let _7dim = Interval(degree: ._7, type: .minorMajorDiminished) static let _7min = Interval(degree: ._7, type: .minor) static let _7maj = Interval(degree: ._7, type: .major) static let _7aug = Interval(degree: ._7, type: .minorMajorAugmented) }Now it's time to model the keys (we touched on them above already). What's important is to define the intervals for all of them (major and minor ones).enum Key { // natural case C, A_min // sharp case G, E_min case D, B_min case A, Fs_min case E, Cs_min case B, Gs_min case Fs, Ds_min case Cs, As_min // flat case F, D_min case Bf, G_min case Ef, C_min case Af, F_min case Df, Bf_min case Gf, Ef_min case Cf, Af_min ... enum KeyType { case naturalMajor case naturalMinor case flatMajor case flatMinor case sharpMajor case sharpMinor } var type: KeyType { switch self { case .C: return .naturalMajor case .A_min: return .naturalMinor case .G, .D, .A, .E, .B, .Fs, .Cs: return .sharpMajor case .E_min, .B_min, .Fs_min, .Cs_min, .Gs_min, .Ds_min, .As_min: return .sharpMinor case .F, .Bf, .Ef, .Af, .Df, .Gf, .Cf: return .flatMajor case .D_min, .G_min, .C_min, .F_min, .Bf_min, .Ef_min, .Af_min: return .flatMinor } } var intervals: [Interval] { switch type { case .naturalMajor, .flatMajor, .sharpMajor: return [ ._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj ] case .naturalMinor, .flatMinor, .sharpMinor: return [ ._1, ._2maj, ._3min, ._4, ._5, ._6min, ._7min ] } } var notes: NoteSequence { switch self { case .C: return .C case .A_min: return .A_min ... } }At this point we have all the fundamental building blocks and we can proceed with the implementation of the algorithm.The idea is to have a function that givena keya root intervala list of intervalsit works out the list of notes. In terms of inputs, it seems the above is all we need to correctly work out scales, chords, and - by extension - also harmonizations. Mind that the root interval doesn't have to be part of the list of intervals, that is simply the interval to start from based on the given key.Giving a note as a starting point is not good enough since some scales simply don't exist for some notes (e.g. Gâ™¯ major scale doesn't exist in the major key, and Gâ™­minor scale doesn't exist in any minor key).Before progressing to the implementation, please consider the following unit tests that should make sense to you:func test_noteSequence_C_1() { let key: Key = .C let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey, intervals: [._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj]) let expectedValue: NoteSequence = [.C, .D, .E, .F, .G, .A, .B] XCTAssertEqual(noteSequence, expectedValue) } func test_noteSequence_withRoot_C_3maj_majorScaleIntervals() { let key = Key.C let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey, rootInterval: ._3maj, intervals: [._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj]) let expectedValue: NoteSequence = [.E, .Fs, .Gs, .A, .B, .Cs, .Ds] XCTAssertEqual(noteSequence, expectedValue) } func test_noteSequence_withRoot_Gsmin_3maj_alteredScaleIntervals() { let key = Key.Gs_min let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey, rootInterval: ._3maj, intervals: [._1aug, ._2maj, ._3dim, ._4dim, ._5aug, ._6dim, ._7dim]) let expectedValue: NoteSequence = [.Bs, .Cs, .Df, .Ef, .Fss, .Gf, .Af] XCTAssertEqual(noteSequence, expectedValue) }and here is the implementation. Let's consider a simple case, so it's easier to follow:key = C majorroot interval = 3majinterval = major scale interval (1, 2maj, 3min, 4, 5, 6maj, 7min)if you music theory allowed you to understand the above unit tests, you would expect the output to be: E, Fâ™¯, G, A, B, Câ™¯, D (which is a Dorian scale).Steps:we start by shifting the notes of the C key to position the 3rd degree (based on the 3maj) as the first element of the array, getting the note sequence E, F, G, A, B, C, D;here's the first interesting bit: we then get the list of intervals by calculating the number of semitones from the root to any other note in the sequence and working out the corresponding Interval:1_perfect, 2_minor, 3_minor, 4_perfect, 5_perfect, 6_minor, 7_minor;we now have all we need to create a CustomKey which is pretty much a Key (with notes and intervals) but instead of being an enum with pre-defined values, is a struct;here's the second tricky part: return the notes by mapping the input intervals. Applying to each note in the custom key the accidental needed to match the desired interval. In our case, the only 2 intervals to 'adjust' are the 2nd and the 6th intervals, both minor in the custom key but major in the list of intervals. So we have to apply a sharp accidental to 'correct' them.ðŸ‘€ I've used force unwraps in these examples for simplicity, the code might already look complex by itself.class CoreEngine { func noteSequence(customKey: CustomKey, rootInterval: Interval = ._1, intervals: [Interval]) throws -\u003e NoteSequence { // 1. let noteSequence = customKey.shiftedNotes(by: rootInterval.degree) let firstNoteInShiftedSequence = noteSequence.first! // 2. let adjustedIntervals = try noteSequence.enumerated().map { try interval(from: firstNoteInShiftedSequence, to: $1, targetDegree: Degree(rawValue: $0)!) } // 3. let customKey = CustomKey(notes: noteSequence, intervals: adjustedIntervals) // 4. return try intervals.map { let referenceInterval = customKey.firstIntervalWithDegree($0.degree)! let note = customKey.notes[$0.degree.rawValue] let accidental = try referenceInterval.type.accidental(to: $0.type) return try note.noteByApplyingAccidental(accidental) } } }It's worth showing the implementation of the methods used above:private func numberOfSemitones(from sourceNote: Note, to targetNote: Note) -\u003e Int { let notesGroupedBySameTone: [[Note]] = [ [.C, .Bs, .Dff], [.Cs, .Df, .Bss], [.D, .Eff, .Css], [.Ds, .Ef, .Fff], [.E, .Dss, .Ff], [.F, .Es, .Gff], [.Fs, .Ess, .Gf], [.G, .Fss, .Aff], [.Gs, .Af], [.A, .Gss, .Bff], [.As, .Bf, .Cff], [.B, .Cf, .Ass] ] let startIndex = notesGroupedBySameTone.firstIndex { $0.contains(sourceNote)}! let endIndex = notesGroupedBySameTone.firstIndex { $0.contains(targetNote)}! return endIndex \u003e= startIndex ? endIndex - startIndex : (notesGroupedBySameTone.count - startIndex) + endIndex } private func interval(from sourceNote: Note, to targetNote: Note, targetDegree: Degree) throws -\u003e Interval { let semitones = numberOfSemitones(from: sourceNote, to: targetNote) let targetType: IntervalType = try { switch targetDegree { case ._1, ._8: return .perfect ... case ._4: switch semitones { case 4: return .diminished case 5: return .perfect case 6: return .augmented default: throw CustomError.invalidConfiguration ... case ._7: switch semitones { case 9: return .minorMajorDiminished case 10: return .minor case 11: return .major case 0: return .minorMajorAugmented default: throw CustomError.invalidConfiguration } } }() return Interval(degree: targetDegree, type: targetType) }the Note's noteByApplyingAccidental method:func noteByApplyingAccidental(_ accidental: Accidental) throws -\u003e Note { let newAccidental = try self.accidental.apply(accidental) return Note(naturalNote: naturalNote, accidental: newAccidental) }and the Accidental's apply method:func apply(_ accidental: Accidental) throws -\u003e Accidental { switch (self, accidental) { ... case (.flat, .flatFlatFlat): throw CustomError.invalidApplicationOfAccidental case (.flat, .flatFlat): return .flatFlatFlat case (.flat, .flat): return .flatFlat case (.flat, .natural): return .flat case (.flat, .sharp): return .natural case (.flat, .sharpSharp): return .sharp case (.flat, .sharpSharpSharp): return .sharpSharp case (.natural, .flatFlatFlat): return .flatFlatFlat case (.natural, .flatFlat): return .flatFlat case (.natural, .flat): return .flat case (.natural, .natural): return .natural case (.natural, .sharp): return .sharp case (.natural, .sharpSharp): return .sharpSharp case (.natural, .sharpSharpSharp): return .sharpSharpSharp ... }With the above engine ready (and ðŸ’¯ï¹ª unit tested!), we can now proceed to use it to work out what we ultimately need (scales, chords, and harmonizations).extension CoreEngine { func scale(note: Note, scaleIdentifier: Identifier) throws -\u003e NoteSequence {...} func chord(note: Note, chordIdentifier: Identifier) throws -\u003e NoteSequence {...} func harmonization(key: Key, harmonizationIdentifier: Identifier) throws -\u003e NoteSequence {...} func chordSignatures(note: Note, scaleHarmonizationIdentifier: Identifier) throws -\u003e [ChordSignature] {...} func harmonizations(note: Note, scaleHarmonizationIdentifier: Identifier) throws -\u003e [NoteSequence] {...} }ConclusionsThere's more to it but with this post I only wanted to outline the overall idea. The default database is available on GitHub at albertodebortoli/iHarmonyDB. The format used is JSON and the community can now easily suggest additions.Here is how the definition of a scale looks:\"scale_dorian\": { \"group\": \"group_scales_majorModes\", \"isMode\": true, \"degreeRelativeToMain\": 2, \"inclination\": \"minor\", \"intervals\": [ \"1\", \"2maj\", \"3min\", \"4\", \"5\", \"6maj\", \"7min\" ] }and a chord:\"chord_diminished\": { \"group\": \"group_chords_diminished\", \"abbreviation\": \"dim\", \"intervals\": [ \"1\", \"3min\", \"5dim\" ] }and a harmonization:\"scaleHarmonization_harmonicMajorScale4Tones\": { \"group\": \"group_harmonization_harmonic_major\", \"inclination\": \"major\", \"harmonizations\": [ \"harmonization_1_major7plus\", \"harmonization_2maj_minor7dim5\", \"harmonization_3maj_minor7\", \"harmonization_4_minor7plus\", \"harmonization_5_major7\", \"harmonization_6min_major7plus5sharp\", \"harmonization_7maj_diminished7\" ] }Have to say, I'm pretty satisfied with how extensible this turned out to be. Thanks for reading ðŸŽ¶",
  "image": "https://albertodebortoli.com/content/images/size/w1200/2020/05/Screenshot-2020-05-24-at-18.09.46-1.png",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv role=\"main\"\u003e\n\t\u003carticle\u003e\n\t\t\u003csection\u003e\n\t\t\t\t\u003ch2 id=\"problem\"\u003eProblem\u003c/h2\u003e\u003cp\u003eI wrote the first version of \u003ca href=\"https://apps.apple.com/gb/app/iharmony/id292413210?ref=albertodebortoli.com\"\u003eiHarmony\u003c/a\u003e in 2008. It was the very first iOS app I gave birth to, combining my passion for music and programming. I remember buying an iPhone and my first Mac with the precise purpose of jumping on the apps train at a time when it wasn\u0026#39;t clear if the apps were there to stay or were just a temporary hype. But I did it, dropped my beloved Ubuntu to join a whole new galaxy. iHarmony was also one of the first 2000 apps on the App Store.\u003c/p\u003e\u003cp\u003eUp until the recent rewrite, iHarmony was powered by a manually crafted database containing scales, chords, and harmonization I inputted.\u003c/p\u003e\u003cp\u003eWhat-a-shame!\u003c/p\u003e\u003cfigure\u003e\u003cimg src=\"https://albertodebortoli.com/content/images/2020/05/shame.png\" alt=\"\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003cp\u003eI guess it made sense, I wanted to learn iOS and not to focus on implementing some core logic independent from the platform. Clearly a much better and less error-prone way to go would be to implement an algorithm to generate all the entries based on some DSL/spec. It took me almost 12 years to decide to tackle the problem and I\u0026#39;ve recently realized that writing the algorithm I wanted was \u003ca href=\"https://twitter.com/albertodebo/status/1258123943573180425?s=20\u0026amp;ref=albertodebortoli.com\"\u003eharder than I thought\u003c/a\u003e. Also thought was a good idea give SwiftUI a try since the UI of iHarmony is extremely simple but... \u003ca href=\"https://twitter.com/albertodebo/status/1254096544468553728?s=20\u0026amp;ref=albertodebortoli.com\"\u003enope\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eSince \u003ca href=\"https://twitter.com/SteveBarnegren/status/1258391221397053441?ref=albertodebortoli.com\"\u003esomeone\u003c/a\u003e on the Internet expressed interest ðŸ˜‰, I wrote this article to explain how I solved the problem of modeling music theory concepts in a way that allows the generation of any sort of scales, chords, and harmonization. I only show the code needed to get a grasp of the overall structure.\u003c/p\u003e\u003cp\u003eI know there are other solutions ready to be used on GitHub but, while I don\u0026#39;t particularly like any of them, the point of rewriting iHarmony from scratch was to challenge myself, not to reuse code someone else wrote. Surprisingly to me, getting to the solution described here took me 3 rewrites and 2 weeks.\u003c/p\u003e\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\u003cp\u003eThe first fundamental building blocks to model are surely the musical notes, which are made up of a natural note and an accidental.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eenum NaturalNote: String {\n    case C, D, E, F, G, A, B\n}\n\nenum Accidental: String {\n    case flatFlatFlat = \u0026#34;bbb\u0026#34;\n    case flatFlat = \u0026#34;bb\u0026#34;\n    case flat = \u0026#34;b\u0026#34;\n    case natural = \u0026#34;\u0026#34;\n    case sharp = \u0026#34;#\u0026#34;\n    case sharpSharp = \u0026#34;##\u0026#34;\n    case sharpSharpSharp = \u0026#34;###\u0026#34;\n    \n    func applyAccidental(_ accidental: Accidental) throws -\u0026gt; Accidental {...}\n}\n\nstruct Note: Hashable, Equatable {\n    \n    let naturalNote: NaturalNote\n    let accidental: Accidental\n    \n    ...\n    \n    static let Dff = Note(naturalNote: .D, accidental: .flatFlat)\n    static let Df = Note(naturalNote: .D, accidental: .flat)\n    static let D = Note(naturalNote: .D, accidental: .natural)\n    static let Ds = Note(naturalNote: .D, accidental: .sharp)\n    static let Dss = Note(naturalNote: .D, accidental: .sharpSharp)\n    \n    ...\n    \n    func noteByApplyingAccidental(_ accidental: Accidental) throws -\u0026gt; Note {...}\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCombinations of notes make up scales and chords and they are... many. What\u0026#39;s fixed instead in music theory, and therefore can be hard-coded, are the keys (both major and minor) such as:\u003c/p\u003e\u003cul\u003e\u003cli\u003eC major: C, D, E, F, G, A, B\u003c/li\u003e\u003cli\u003eA minor: A, B, C, D, E, F, G\u003c/li\u003e\u003cli\u003eD major: D, E, F#, G, A, B, C#\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe\u0026#39;ll get back to the keys later, but we can surely implement the note sequence for each musical key.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etypealias NoteSequence = [Note]\n\nextension NoteSequence {\n    static let C = [Note.C, Note.D, Note.E, Note.F, Note.G, Note.A, Note.B]\n    static let A_min = [Note.A, Note.B, Note.C, Note.D, Note.E, Note.F, Note.G]\n    \n    static let G = [Note.G, Note.A, Note.B, Note.C, Note.D, Note.E, Note.Fs]\n    static let E_min = [Note.E, Note.Fs, Note.G, Note.A, Note.B, Note.C, Note.D]\n    \n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNext stop: intervals. They are a bit more interesting as not every degree has the same types. Let\u0026#39;s split into 2 sets:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cem\u003e2nd\u003c/em\u003e, \u003cem\u003e3rd\u003c/em\u003e, \u003cem\u003e6th\u003c/em\u003e and \u003cem\u003e7th\u003c/em\u003e degrees can be \u003cem\u003eminor\u003c/em\u003e, \u003cem\u003emajor\u003c/em\u003e, \u003cem\u003ediminished\u003c/em\u003e and \u003cem\u003eaugmented\u003c/em\u003e\u003c/li\u003e\u003cli\u003e\u003cem\u003e1st\u003c/em\u003e (and \u003cem\u003e8th\u003c/em\u003e), \u003cem\u003e4th\u003c/em\u003e and \u003cem\u003e5th\u003c/em\u003e degrees can be \u003cem\u003eperfect\u003c/em\u003e, \u003cem\u003ediminished\u003c/em\u003e and \u003cem\u003eaugmented\u003c/em\u003e.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eWe need to use different kinds of \u0026#34;diminished\u0026#34; and \u0026#34;augmented\u0026#34; for the 2 sets as later on we\u0026#39;ll have to calculate the accidentals needed to turn an interval into another.\u003c/p\u003e\u003cp\u003eSome examples:\u003c/p\u003e\u003cul\u003e\u003cli\u003eto get from \u003cem\u003e2nd augmented\u003c/em\u003e to \u003cem\u003e2nd diminished\u003c/em\u003e, we need a \u003cem\u003etriple flat\u003c/em\u003e accidental (e.g. in C major scale, from Dâ™¯ to Dâ™­â™­ there are 3 semitones)\u003c/li\u003e\u003cli\u003eto get from \u003cem\u003e5th augmented\u003c/em\u003e to \u003cem\u003e5th diminished\u003c/em\u003e, we need a \u003cem\u003edouble flat\u003c/em\u003e accidental (e.g. in C major scale, from Gâ™¯ to Gâ™­there are 2 semitones)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWe proceed to hard-code the allowed intervals in music, leaving out the invalid ones (e.g. \u003ccode\u003eInterval(degree: ._2, type: .augmented)\u003c/code\u003e)\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eenum Degree: Int, CaseIterable {\n    case _1, _2, _3, _4, _5, _6, _7, _8\n}\n\nenum IntervalType: Int, RawRepresentable {\n    case perfect\n    case minor\n    case major\n    case diminished\n    case augmented\n    case minorMajorDiminished\n    case minorMajorAugmented\n}\n\nstruct Interval: Hashable, Equatable {\n    let degree: Degree\n    let type: IntervalType\n    \n    static let _1dim = Interval(degree: ._1, type: .diminished)\n    static let _1    = Interval(degree: ._1, type: .perfect)\n    static let _1aug = Interval(degree: ._1, type: .augmented)\n    \n    static let _2dim = Interval(degree: ._2, type: .minorMajorDiminished)\n    static let _2min = Interval(degree: ._2, type: .minor)\n    static let _2maj = Interval(degree: ._2, type: .major)\n    static let _2aug = Interval(degree: ._2, type: .minorMajorAugmented)\n    \n    ...\n    \n    static let _4dim = Interval(degree: ._4, type: .diminished)\n    static let _4    = Interval(degree: ._4, type: .perfect)\n    static let _4aug = Interval(degree: ._4, type: .augmented)\n    \n    ...\n    \n    static let _7dim = Interval(degree: ._7, type: .minorMajorDiminished)\n    static let _7min = Interval(degree: ._7, type: .minor)\n    static let _7maj = Interval(degree: ._7, type: .major)\n    static let _7aug = Interval(degree: ._7, type: .minorMajorAugmented)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow it\u0026#39;s time to model the keys (we touched on them above already). What\u0026#39;s important is to define the intervals for all of them (major and minor ones).\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eenum Key {\n    // natural\n    case C, A_min\n    \n    // sharp\n    case G, E_min\n    case D, B_min\n    case A, Fs_min\n    case E, Cs_min\n    case B, Gs_min\n    case Fs, Ds_min\n    case Cs, As_min\n    \n    // flat\n    case F, D_min\n    case Bf, G_min\n    case Ef, C_min\n    case Af, F_min\n    case Df, Bf_min\n    case Gf, Ef_min\n    case Cf, Af_min\n    \n    ...\n    \n    enum KeyType {\n        case naturalMajor\n        case naturalMinor\n        case flatMajor\n        case flatMinor\n        case sharpMajor\n        case sharpMinor\n    }\n    \n    var type: KeyType {\n        switch self {\n        case .C: return .naturalMajor\n        case .A_min: return .naturalMinor\n        case .G, .D, .A, .E, .B, .Fs, .Cs: return .sharpMajor\n        case .E_min, .B_min, .Fs_min, .Cs_min, .Gs_min, .Ds_min, .As_min: return .sharpMinor\n        case .F, .Bf, .Ef, .Af, .Df, .Gf, .Cf: return .flatMajor\n        case .D_min, .G_min, .C_min, .F_min, .Bf_min, .Ef_min, .Af_min: return .flatMinor\n        }\n    }\n    \n    var intervals: [Interval] {\n        switch type {\n        case .naturalMajor, .flatMajor, .sharpMajor:\n            return [\n                ._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj\n            ]\n        case .naturalMinor, .flatMinor, .sharpMinor:\n            return [\n                ._1, ._2maj, ._3min, ._4, ._5, ._6min, ._7min\n            ]\n        }\n    }\n    \n    var notes: NoteSequence {\n        switch self {\n        case .C: return .C\n        case .A_min: return .A_min\n    \t...\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAt this point we have all the fundamental building blocks and we can proceed with the implementation of the algorithm.\u003c/p\u003e\u003cp\u003eThe idea is to have a function that given\u003c/p\u003e\u003cul\u003e\u003cli\u003ea key\u003c/li\u003e\u003cli\u003ea root interval\u003c/li\u003e\u003cli\u003ea list of intervals\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eit works out the list of notes. In terms of inputs, it seems the above is all we need to correctly work out scales, chords, and - by extension - also harmonizations. Mind that the root interval doesn\u0026#39;t have to be part of the list of intervals, that is simply the interval to start from based on the given key.\u003c/p\u003e\u003cp\u003eGiving a note as a starting point is not good enough since some scales simply don\u0026#39;t exist for some notes (e.g. Gâ™¯ major scale doesn\u0026#39;t exist in the major key, and Gâ™­minor scale doesn\u0026#39;t exist in any minor key).\u003c/p\u003e\u003cp\u003eBefore progressing to the implementation, please consider the following unit tests that should make sense to you:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc test_noteSequence_C_1() {\n    let key: Key = .C\n    let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey,\n                                                intervals: [._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj])\n    let expectedValue: NoteSequence = [.C, .D, .E, .F, .G, .A, .B]\n    XCTAssertEqual(noteSequence, expectedValue)\n}\n    \nfunc test_noteSequence_withRoot_C_3maj_majorScaleIntervals() {\n    let key = Key.C\n    let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey,\n                                                rootInterval: ._3maj,\n                                                intervals: [._1, ._2maj, ._3maj, ._4, ._5, ._6maj, ._7maj])\n    let expectedValue: NoteSequence = [.E, .Fs, .Gs, .A, .B, .Cs, .Ds]\n    XCTAssertEqual(noteSequence, expectedValue)\n}\n    \nfunc test_noteSequence_withRoot_Gsmin_3maj_alteredScaleIntervals() {\n    let key = Key.Gs_min\n    let noteSequence = try! engine.noteSequence(customKey: key.associatedCustomKey,\n                                                rootInterval: ._3maj,\n                                                intervals: [._1aug, ._2maj, ._3dim, ._4dim, ._5aug, ._6dim, ._7dim])\n    let expectedValue: NoteSequence = [.Bs, .Cs, .Df, .Ef, .Fss, .Gf, .Af]\n    XCTAssertEqual(noteSequence, expectedValue)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand here is the implementation. Let\u0026#39;s consider a simple case, so it\u0026#39;s easier to follow:\u003c/p\u003e\u003cul\u003e\u003cli\u003ekey = C major\u003c/li\u003e\u003cli\u003eroot interval = 3maj\u003c/li\u003e\u003cli\u003einterval = major scale interval (1, 2maj, 3min, 4, 5, 6maj, 7min)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eif you music theory allowed you to understand the above unit tests, you would expect the output to be: E, Fâ™¯, G, A, B, Câ™¯, D (which is a Dorian scale).\u003c/p\u003e\u003cp\u003eSteps:\u003c/p\u003e\u003col\u003e\u003cli\u003ewe start by shifting the notes of the C key to position the 3rd degree (based on the 3maj) as the first element of the array, getting the note sequence E, F, G, A, B, C, D;\u003c/li\u003e\u003cli\u003ehere\u0026#39;s the first interesting bit: we then get the list of intervals by calculating the number of semitones from the root to any other note in the sequence and working out the corresponding \u003ccode\u003eInterval\u003c/code\u003e:\u003cbr/\u003e\u003cem\u003e1_perfect, 2_minor, 3_minor, 4_perfect, 5_perfect, 6_minor, 7_minor;\u003c/em\u003e\u003c/li\u003e\u003cli\u003ewe now have all we need to create a \u003ccode\u003eCustomKey\u003c/code\u003e which is pretty much a \u003ccode\u003eKey\u003c/code\u003e (with notes and intervals) but instead of being an enum with pre-defined values, is a struct;\u003c/li\u003e\u003cli\u003ehere\u0026#39;s the second tricky part: return the notes by mapping the input intervals. Applying to each note in the custom key the accidental needed to match the desired interval. In our case, the only 2 intervals to \u0026#39;adjust\u0026#39; are the 2nd and the 6th intervals, both minor in the custom key but major in the list of intervals. So we have to apply a sharp accidental to \u0026#39;correct\u0026#39; them.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eðŸ‘€ I\u0026#39;ve used force unwraps in these examples for simplicity, the code might already look complex by itself.\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass CoreEngine {\n\n    func noteSequence(customKey: CustomKey,\n                      rootInterval: Interval = ._1,\n                      intervals: [Interval]) throws -\u0026gt; NoteSequence {\n        // 1.\n        let noteSequence = customKey.shiftedNotes(by: rootInterval.degree)\n        let firstNoteInShiftedSequence = noteSequence.first!\n        \n        // 2.\n        let adjustedIntervals = try noteSequence.enumerated().map {\n            try interval(from: firstNoteInShiftedSequence,\n                         to: $1,\n                         targetDegree: Degree(rawValue: $0)!)\n        }\n        \n        // 3.\n        let customKey = CustomKey(notes: noteSequence,\n                                  intervals: adjustedIntervals)\n        \n        // 4.\n        return try intervals.map {\n            let referenceInterval = customKey.firstIntervalWithDegree($0.degree)!\n            let note = customKey.notes[$0.degree.rawValue]\n            let accidental = try referenceInterval.type.accidental(to: $0.type)\n            return try note.noteByApplyingAccidental(accidental)\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt\u0026#39;s worth showing the implementation of the methods used above:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate func numberOfSemitones(from sourceNote: Note,\n                               to targetNote: Note) -\u0026gt; Int {\n    let notesGroupedBySameTone: [[Note]] = [\n        [.C, .Bs, .Dff],\n        [.Cs, .Df, .Bss],\n        [.D, .Eff, .Css],\n        [.Ds, .Ef, .Fff],\n        [.E, .Dss, .Ff],\n        [.F, .Es, .Gff],\n        [.Fs, .Ess, .Gf],\n        [.G, .Fss, .Aff],\n        [.Gs, .Af],\n        [.A, .Gss, .Bff],\n        [.As, .Bf, .Cff],\n        [.B, .Cf, .Ass]\n    ]\n        \n    let startIndex = notesGroupedBySameTone.firstIndex { $0.contains(sourceNote)}!\n    let endIndex = notesGroupedBySameTone.firstIndex { $0.contains(targetNote)}!\n        \n    return endIndex \u0026gt;= startIndex ? endIndex - startIndex : (notesGroupedBySameTone.count - startIndex) + endIndex\n}\n    \nprivate func interval(from sourceNote: Note,\n                      to targetNote: Note,\n                      targetDegree: Degree) throws -\u0026gt; Interval {\n    let semitones = numberOfSemitones(from: sourceNote, to: targetNote)\n        \n    let targetType: IntervalType = try {\n        switch targetDegree {\n        case ._1, ._8:\n            return .perfect\n        ...\n        case ._4:\n            switch semitones {\n            case 4:\n                return .diminished\n            case 5:\n                return .perfect\n            case 6:\n                return .augmented\n            default:\n                throw CustomError.invalidConfiguration\n        ...\n        case ._7:\n            switch semitones {\n            case 9:\n                return .minorMajorDiminished\n            case 10:\n                return .minor\n            case 11:\n                return .major\n            case 0:\n                return .minorMajorAugmented\n            default:\n                throw CustomError.invalidConfiguration\n            }\n        }\n    }()\n    return Interval(degree: targetDegree, type: targetType)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003ethe \u003ccode\u003eNote\u003c/code\u003e\u0026#39;s \u003ccode\u003enoteByApplyingAccidental\u003c/code\u003e method:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc noteByApplyingAccidental(_ accidental: Accidental) throws -\u0026gt; Note {\n    let newAccidental = try self.accidental.apply(accidental)\n    return Note(naturalNote: naturalNote, accidental: newAccidental)\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand the \u003ccode\u003eAccidental\u003c/code\u003e\u0026#39;s \u003ccode\u003eapply\u003c/code\u003e method:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc apply(_ accidental: Accidental) throws -\u0026gt; Accidental {\n    switch (self, accidental) {\n    ...\n    case (.flat, .flatFlatFlat):\n        throw CustomError.invalidApplicationOfAccidental\n    case (.flat, .flatFlat):\n        return .flatFlatFlat\n    case (.flat, .flat):\n        return .flatFlat\n    case (.flat, .natural):\n        return .flat\n    case (.flat, .sharp):\n        return .natural\n    case (.flat, .sharpSharp):\n        return .sharp\n    case (.flat, .sharpSharpSharp):\n        return .sharpSharp\n            \n    case (.natural, .flatFlatFlat):\n        return .flatFlatFlat\n    case (.natural, .flatFlat):\n        return .flatFlat\n    case (.natural, .flat):\n        return .flat\n    case (.natural, .natural):\n        return .natural\n    case (.natural, .sharp):\n        return .sharp\n    case (.natural, .sharpSharp):\n        return .sharpSharp\n    case (.natural, .sharpSharpSharp):\n        return .sharpSharpSharp   \n    ...\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWith the above engine ready (and ðŸ’¯ï¹ª unit tested!), we can now proceed to use it to work out what we ultimately need (scales, chords, and harmonizations).\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eextension CoreEngine {\n    func scale(note: Note, scaleIdentifier: Identifier) throws -\u0026gt; NoteSequence {...}\n    func chord(note: Note, chordIdentifier: Identifier) throws -\u0026gt; NoteSequence {...}\n    func harmonization(key: Key, harmonizationIdentifier: Identifier) throws -\u0026gt; NoteSequence {...}\n    func chordSignatures(note: Note, scaleHarmonizationIdentifier: Identifier) throws -\u0026gt; [ChordSignature] {...}\n    func harmonizations(note: Note, scaleHarmonizationIdentifier: Identifier) throws -\u0026gt; [NoteSequence] {...}\n}\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\u003cp\u003eThere\u0026#39;s more to it but with this post I only wanted to outline the overall idea. \u003c/p\u003e\u003cp\u003eThe default database is available on GitHub at \u003ca href=\"https://github.com/albertodebortoli/iHarmonyDB?ref=albertodebortoli.com\"\u003ealbertodebortoli/iHarmonyDB\u003c/a\u003e. The format used is JSON and the community can now easily suggest additions.\u003c/p\u003e\u003cp\u003eHere is how the definition of a scale looks:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;scale_dorian\u0026#34;: {\n    \u0026#34;group\u0026#34;: \u0026#34;group_scales_majorModes\u0026#34;,\n    \u0026#34;isMode\u0026#34;: true,\n    \u0026#34;degreeRelativeToMain\u0026#34;: 2,\n    \u0026#34;inclination\u0026#34;: \u0026#34;minor\u0026#34;,\n    \u0026#34;intervals\u0026#34;: [\n        \u0026#34;1\u0026#34;,\n        \u0026#34;2maj\u0026#34;,\n        \u0026#34;3min\u0026#34;,\n        \u0026#34;4\u0026#34;,\n        \u0026#34;5\u0026#34;,\n        \u0026#34;6maj\u0026#34;,\n        \u0026#34;7min\u0026#34;\n    ]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand a chord:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;chord_diminished\u0026#34;: {\n    \u0026#34;group\u0026#34;: \u0026#34;group_chords_diminished\u0026#34;,\n    \u0026#34;abbreviation\u0026#34;: \u0026#34;dim\u0026#34;,\n    \u0026#34;intervals\u0026#34;: [\n        \u0026#34;1\u0026#34;,\n        \u0026#34;3min\u0026#34;,\n        \u0026#34;5dim\u0026#34;\n    ]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eand a harmonization:\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026#34;scaleHarmonization_harmonicMajorScale4Tones\u0026#34;: {\n    \u0026#34;group\u0026#34;: \u0026#34;group_harmonization_harmonic_major\u0026#34;,\n    \u0026#34;inclination\u0026#34;: \u0026#34;major\u0026#34;,\n    \u0026#34;harmonizations\u0026#34;: [\n        \u0026#34;harmonization_1_major7plus\u0026#34;,\n        \u0026#34;harmonization_2maj_minor7dim5\u0026#34;,\n        \u0026#34;harmonization_3maj_minor7\u0026#34;,\n        \u0026#34;harmonization_4_minor7plus\u0026#34;,\n        \u0026#34;harmonization_5_major7\u0026#34;,\n        \u0026#34;harmonization_6min_major7plus5sharp\u0026#34;,\n        \u0026#34;harmonization_7maj_diminished7\u0026#34;\n    ]\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHave to say, I\u0026#39;m pretty satisfied with how extensible this turned out to be. \u003c/p\u003e\u003cp\u003eThanks for reading ðŸŽ¶\u003c/p\u003e\n\t\t\t\u003c/section\u003e\n\t\u003c/article\u003e\n\u003c/div\u003e\u003c/div\u003e",
  "readingTime": "18 min read",
  "publishedTime": "2020-05-24T17:44:21Z",
  "modifiedTime": "2020-08-07T18:12:15Z"
}
