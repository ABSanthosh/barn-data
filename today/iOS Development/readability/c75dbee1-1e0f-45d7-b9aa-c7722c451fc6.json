{
  "id": "c75dbee1-1e0f-45d7-b9aa-c7722c451fc6",
  "title": "How @MainActor works",
  "link": "https://oleb.net/2022/how-mainactor-works/",
  "description": "",
  "author": "Ole Begemann",
  "published": "2022-05-05T13:52:42Z",
  "source": "https://oleb.net/blog/atom.xml",
  "categories": null,
  "byline": "By Ole Begemann …",
  "length": 5529,
  "excerpt": "The main actor is a global actor that uses a custom executor that runs jobs on the main dispatch queue.",
  "siteName": "Ole Begemann",
  "favicon": "",
  "text": "@MainActor is a Swift annotation to coerce a function to always run on the main thread and to enable the compiler to verify this. How does this work? In this article, I’m going to reimplement @MainActor in a slightly simplified form for illustration purposes, mainly to show how little “magic” there is to it. The code of the real implementation in the Swift standard library is available in the Swift repository. @MainActor relies on two Swift features, one of them unofficial: global actors and custom executors. Global actors MainActor is a global actor. That is, it provides a single actor instance that is shared between all places in the code that are annotated with @MainActor. All global actors must implement the shared property that’s defined in the GlobalActor protocol (every global actor implicitly conforms to this protocol): @globalActor final actor MyMainActor { // Requirements from the implicit GlobalActor conformance typealias ActorType = MyMainActor static var shared: ActorType = MyMainActor() // Don’t allow others to create instances private init() {} } At this point, we have a global actor that has the same semantics as any other actor. That is, functions annotated with @MyMainActor will run on a thread in the cooperative thread pool managed by the Swift runtime. To move the work to the main thread, we need another concept, custom executors. Executors A bit of terminology: The compiler splits async code into jobs. A job roughly corresponds to the code from one await (= potential suspension point) to the next. The runtime submits each job to an executor. The executor is the object that decides in which order and in which context (i.e. which thread or dispatch queue) to run the jobs. Swift ships with two built-in executors: the default concurrent executor, used for “normal”, non-actor-isolated async functions, and a default serial executor. Every actor instance has its own instance of this default serial executor and runs its code on it. Since the serial executor, like a serial dispatch queue, only runs a single job at a time, this prevents concurrent accesses to the actor’s state. Custom executors As of Swift 5.6, executors are an implementation detail of Swift’s concurrency system, but it’s almost certain that they will become an official feature fairly soon. Why? Because it can sometimes be useful to have more control over the execution context of async code. Some examples are listed in a draft proposal for allowing developers to implement custom executors that was first pitched in February 2021 but then didn’t make the cut for Swift 5.5. @MainActor already uses the unofficial ability for an actor to provide a custom executor, and we’re going to do the same for our reimplementation. A serial executor that runs its job on the main dispatch queue is implemented as follows. The interesting bit is the enqueue method, where we tell the job to run on the main dispatch queue: final class MainExecutor: SerialExecutor { func asUnownedSerialExecutor() -\u003e UnownedSerialExecutor { UnownedSerialExecutor(ordinary: self) } func enqueue(_ job: UnownedJob) { DispatchQueue.main.async { job._runSynchronously(on: self.asUnownedSerialExecutor()) } } } We’re responsible for keeping an instance of the executor alive, so let’s store it in a global: private let mainExecutor = MainExecutor() Finally, we need to tell our global actor to use the new executor: import Dispatch @globalActor final actor MyMainActor { // ... // Requirement from the implicit GlobalActor conformance static var sharedUnownedExecutor: UnownedSerialExecutor { mainExecutor.asUnownedSerialExecutor() } // Requirement from the implicit Actor conformance nonisolated var unownedExecutor: UnownedSerialExecutor { mainExecutor.asUnownedSerialExecutor() } } That’s all there is to reimplement the basics of @MainActor. Conclusion The full code is on GitHub, including a usage example to demonstrate that the @MyMainActor annotations work. John McCall’s draft proposal for custom executors is worth reading, particularly the philosophy section. It’s an easy-to-read summary of some of the design principles behind Swift’s concurrency system: Swift’s concurrency design sees system threads as expensive and rather precious resources. … It is therefore best if the system allocates a small number of threads — just enough to saturate the available cores — and for those threads [to] only block for extended periods when there is no pending work in the program. Individual functions cannot effectively make this decision about blocking, because they lack a holistic understanding of the state of the program. Instead, the decision must be made by a centralized system which manages most of the execution resources in the program. This basic philosophy of how best to use system threads drives some of the most basic aspects of Swift’s concurrency design. In particular, the main reason to add async functions is to make it far easier to write functions that, unlike standard functions, will reliably abandon a thread when they need to wait for something to complete. And: The default concurrent executor is used to run jobs that don’t need to run somewhere more specific. It is based on a fixed-width thread pool that scales to the number of available cores. Programmers therefore do not need to worry that creating too many jobs at once will cause a thread explosion that will starve the program of resources.",
  "image": "",
  "html": "\u003cdiv id=\"readability-page-1\" class=\"page\"\u003e\u003cdiv\u003e\n          \u003cp\u003e\u003ca href=\"https://developer.apple.com/documentation/swift/mainactor#\"\u003e\u003ccode\u003e@MainActor\u003c/code\u003e\u003c/a\u003e is a Swift annotation to coerce a function to always run on the main thread \u003cem\u003eand\u003c/em\u003e to enable the compiler to verify this. How does this work? In this article, I’m going to reimplement \u003ccode\u003e@MainActor\u003c/code\u003e in a slightly simplified form for illustration purposes, mainly to show how little “magic” there is to it. \u003ca href=\"https://github.com/apple/swift/blob/main/stdlib/public/Concurrency/MainActor.swift\"\u003eThe code of the real implementation\u003c/a\u003e in the Swift standard library is available in the Swift repository.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e@MainActor\u003c/code\u003e relies on two Swift features, one of them unofficial: global actors and custom executors.\u003c/p\u003e\n\n\u003ch2 id=\"global-actors\"\u003eGlobal actors\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eMainActor\u003c/code\u003e is a \u003ca href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md\"\u003eglobal actor\u003c/a\u003e. That is, it provides a single actor instance that is shared between all places in the code that are annotated with \u003ccode\u003e@MainActor\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAll global actors must implement the \u003ccode\u003eshared\u003c/code\u003e property that’s defined in the \u003ca href=\"https://developer.apple.com/documentation/swift/globalactor\"\u003e\u003ccode\u003eGlobalActor\u003c/code\u003e protocol\u003c/a\u003e (every global actor implicitly conforms to this protocol):\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e@globalActor\u003c/span\u003e\n\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eactor\u003c/span\u003e \u003cspan\u003eMyMainActor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// Requirements from the implicit GlobalActor conformance\u003c/span\u003e\n  \u003cspan\u003etypealias\u003c/span\u003e \u003cspan\u003eActorType\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eMyMainActor\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eshared\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eActorType\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eMyMainActor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\n  \u003cspan\u003e// Don’t allow others to create instances\u003c/span\u003e\n  \u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003einit\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e{}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAt this point, we have a global actor that has the same semantics as any other actor. That is, functions annotated with \u003ccode\u003e@MyMainActor\u003c/code\u003e will run on a thread in the cooperative thread pool managed by the Swift runtime. To move the work to the main thread, we need another concept, custom executors.\u003c/p\u003e\n\n\u003ch2 id=\"executors\"\u003eExecutors\u003c/h2\u003e\n\n\u003cp\u003eA bit of terminology:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThe compiler splits async code into \u003cstrong\u003ejobs\u003c/strong\u003e. A job roughly corresponds to the code from one \u003ccode\u003eawait\u003c/code\u003e (= potential suspension point) to the next.\u003c/li\u003e\n  \u003cli\u003eThe runtime submits each job to an \u003cstrong\u003eexecutor\u003c/strong\u003e. The executor is the object that decides in which order and in which context (i.e. which thread or dispatch queue) to run the jobs.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSwift ships with two built-in executors: the default concurrent executor, used for “normal”, non-actor-isolated async functions, and a default serial executor. Every actor instance has its own instance of this default serial executor and runs its code on it. Since the serial executor, like a serial dispatch queue, only runs a single job at a time, this prevents concurrent accesses to the actor’s state.\u003c/p\u003e\n\n\u003ch3 id=\"custom-executors\"\u003eCustom executors\u003c/h3\u003e\n\n\u003cp\u003eAs of Swift 5.6, executors are an implementation detail of Swift’s concurrency system, but it’s almost certain that they will become an official feature fairly soon. Why? Because it can sometimes be useful to have more control over the execution context of async code. Some examples are listed in \u003ca href=\"https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md\"\u003ea draft proposal for allowing developers to implement custom executors\u003c/a\u003e that was first pitched in February 2021 but then didn’t make the cut for Swift 5.5.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e@MainActor\u003c/code\u003e already uses the unofficial ability for an actor to provide a custom executor, and we’re going to do the same for our reimplementation. A serial executor that runs its job on the main dispatch queue is implemented as follows. The interesting bit is the \u003ccode\u003eenqueue\u003c/code\u003e method, where we tell the job to run on the main dispatch queue:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eclass\u003c/span\u003e \u003cspan\u003eMainExecutor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eSerialExecutor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003easUnownedSerialExecutor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e \u003cspan\u003e-\u0026gt;\u003c/span\u003e \u003cspan\u003eUnownedSerialExecutor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eUnownedSerialExecutor\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eordinary\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003efunc\u003c/span\u003e \u003cspan\u003eenqueue\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e_\u003c/span\u003e \u003cspan\u003ejob\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnownedJob\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003eDispatchQueue\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emain\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easync\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003ejob\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e_runSynchronously\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eon\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eself\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easUnownedSerialExecutor\u003c/span\u003e\u003cspan\u003e())\u003c/span\u003e\n    \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWe’re responsible for keeping an instance of the executor alive, so let’s store it in a global:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eprivate\u003c/span\u003e \u003cspan\u003elet\u003c/span\u003e \u003cspan\u003emainExecutor\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eMainExecutor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eFinally, we need to tell our global actor to use the new executor:\u003c/p\u003e\n\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003eimport\u003c/span\u003e \u003cspan\u003eDispatch\u003c/span\u003e\n\n\u003cspan\u003e@globalActor\u003c/span\u003e\n\u003cspan\u003efinal\u003c/span\u003e \u003cspan\u003eactor\u003c/span\u003e \u003cspan\u003eMyMainActor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003e// ...\u003c/span\u003e\n  \n  \u003cspan\u003e// Requirement from the implicit GlobalActor conformance\u003c/span\u003e\n  \u003cspan\u003estatic\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003esharedUnownedExecutor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnownedSerialExecutor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003emainExecutor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easUnownedSerialExecutor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\n  \u003cspan\u003e// Requirement from the implicit Actor conformance\u003c/span\u003e\n  \u003cspan\u003enonisolated\u003c/span\u003e \u003cspan\u003evar\u003c/span\u003e \u003cspan\u003eunownedExecutor\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003eUnownedSerialExecutor\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003emainExecutor\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003easUnownedSerialExecutor\u003c/span\u003e\u003cspan\u003e()\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThat’s all there is to reimplement the basics of \u003ccode\u003e@MainActor\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://gist.github.com/ole/10a832ab2388163099841d683cfed102\"\u003eThe full code is on GitHub\u003c/a\u003e, including a usage example to demonstrate that the \u003ccode\u003e@MyMainActor\u003c/code\u003e annotations work.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md\"\u003eJohn McCall’s draft proposal for custom executors\u003c/a\u003e is worth reading, particularly \u003ca href=\"https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md#philosophy-of-thread-usage\"\u003ethe philosophy section\u003c/a\u003e. It’s an easy-to-read summary of some of the design principles behind Swift’s concurrency system:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eSwift’s concurrency design sees system threads as expensive and rather precious resources. …\u003c/p\u003e\n\n  \u003cp\u003eIt is therefore best if the system allocates a small number of threads — just enough to saturate the available cores — and for those threads [to] only block for extended periods when there is no pending work in the program. Individual functions cannot effectively make this decision about blocking, because they lack a holistic understanding of the state of the program. Instead, the decision must be made by a centralized system which manages most of the execution resources in the program.\u003c/p\u003e\n\n  \u003cp\u003eThis basic philosophy of how best to use system threads drives some of the most basic aspects of Swift’s concurrency design. In particular, the main reason to add async functions is to make it far easier to write functions that, unlike standard functions, will reliably abandon a thread when they need to wait for something to complete.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/rjmccall/swift-evolution/blob/custom-executors/proposals/0000-custom-executors.md#the-default-global-concurrent-executor\"\u003eAnd\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThe default concurrent executor is used to run jobs that don’t need to run somewhere more specific. It is based on a fixed-width thread pool that scales to the number of available cores. Programmers therefore do not need to worry that creating too many jobs at once will cause a thread explosion that will starve the program of resources.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n        \u003c/div\u003e\u003c/div\u003e",
  "readingTime": "7 min read",
  "publishedTime": "2022-05-05T13:52:42Z",
  "modifiedTime": "2022-05-06T17:47:57Z"
}
